<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>neo-thinsdk-cs 之 thinWallet 接入私链 - JoiT</title>
<link>http://www.cnblogs.com/JoiT/p/thinwallet-to-private-neo-chain.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JoiT/p/thinwallet-to-private-neo-chain.html</guid>
<description>&lt;blockquote readability=&quot;6.9861751152074&quot;&gt;
&lt;p&gt;2017年底刚开始接触区块链，目前在被 &lt;a href=&quot;https://neo.org/&quot;&gt;NEO&lt;/a&gt; 折磨。&lt;br/&gt;一开始被&lt;a href=&quot;http://docs.neo.org/en-us/index.html&quot;&gt;官方文档&lt;/a&gt;和 &lt;a href=&quot;https://neo.org/download&quot;&gt;NEO-GUI&lt;/a&gt; 搞得体无完肤（尤其是传说中的 F12），也找了各种调试工具用来搞 &lt;a href=&quot;http://docs.neo.org/en-us/sc/introduction.html&quot;&gt;NeoContract&lt;/a&gt;，然并卵。&lt;br/&gt;直到有一天发现了 &lt;a href=&quot;https://github.com/NewEconoLab&quot;&gt;NewEconoLab&lt;/a&gt; ，在它的 &lt;a href=&quot;https://github.com/NewEconoLab&quot;&gt;github&lt;/a&gt; 上有一个项目 &lt;a href=&quot;https://github.com/NewEconoLab/neo-thinsdk-cs&quot;&gt;neo-thinsdk-cs&lt;/a&gt; ，用 C# 实现了一个轻钱包 —— &lt;a href=&quot;https://github.com/NewEconoLab/neo-thinsdk-cs&quot;&gt;thinWallet&lt;/a&gt; 。&lt;br/&gt;这个轻钱包只做了一件事情，就是做交易，它把整个交易的流程都体现出来了，给开发者展示了明确的可视化交易拼接流程（包括Attribute、Inputs、Outputs、Script、Witness等，我曾经用 VS F11 一行一行的调试跟踪过它的源代码，所有的这些交易必须的数据都组装好，放到一个数据结构里，非常清晰）。&lt;br/&gt;最重要的是分解了 UTXO 和 使得 Witness 变得可处理，以达成 &lt;a href=&quot;https://neo.org/download&quot;&gt;NEO-GUI&lt;/a&gt; 达不到的操作。&lt;br/&gt;此外，目前的 &lt;a href=&quot;https://github.com/NewEconoLab/neo-thinsdk-cs&quot;&gt;thinWallet&lt;/a&gt; ，默认接入到 Testnet，还不支持直接接入 Mainnet ，也不支持接入到 &lt;a href=&quot;http://docs.neo.org/en-us/node/private-chain.html&quot;&gt;NEO 私有链&lt;/a&gt; ，我们都知道 Testnet 上的 Gas 十分珍贵，&lt;a href=&quot;https://neo.org/Testnet/Create&quot;&gt;需要去申请才能有&lt;/a&gt;，而我们部署合约，动不动就消耗 990 Gas 。而在&lt;a href=&quot;http://docs.neo.org/en-us/node/private-chain.html&quot;&gt;自己的私有链&lt;/a&gt;上 Gas 就是大白菜了，随便乱玩都可以。&lt;br/&gt;所以为了方便部署合约调试，今天的任务是将 &lt;a href=&quot;https://github.com/NewEconoLab/neo-thinsdk-cs&quot;&gt;thinWallet&lt;/a&gt; 接入到&lt;a href=&quot;http://docs.neo.org/en-us/node/private-chain.html&quot;&gt;私有链&lt;/a&gt;中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;1、环境准备&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基础要求&lt;/strong&gt;：四台 Debian 9（其他发行版随你喜欢，&lt;a href=&quot;http://docs.neo.org/en-us/node/setup.html&quot;&gt;单击此处查看支持的机器&lt;/a&gt;，建议创建一台虚拟机配好环境然后直接克隆，别忘了强制刷新 MAC 地址，要不然 IP 冲突） ，一台 Windows 10 ，.net core sdk，visual studio 2017 community，.net framework 4.7 SDK，NEO-CLI，搭私链跑共识，建钱包，拿到一亿的 NEO 币和至少 1000 个 Gas （相当于你的区块高度超过 125，这至少需要耗费31分钟），这些东西&lt;a href=&quot;http://docs.neo.org/en-us/node/private-chain.html&quot;&gt;文档&lt;/a&gt;里都有，此处不再赘述。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;克隆项目&lt;/strong&gt;：&lt;a href=&quot;https://github.com/NewEconoLab/NeoBlock-Mongo-Storage&quot;&gt;NeoBlock-Mongo-Storage&lt;/a&gt;，&lt;a href=&quot;https://github.com/NewEconoLab/NEO_Block_API&quot;&gt;NEO_Block_API&lt;/a&gt;，&lt;a href=&quot;https://github.com/NewEconoLab/neo-thinsdk-cs&quot;&gt;neo-thinsdk-cs&lt;/a&gt;，三个项目都是直接用 master 分支就可以了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里解释一下克隆下来的三个项目是什么样的关系，三个都是 .net 项目&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;neo-thinsdk-cs 是一整个解决方案，用 vs 2017 打开，里面有一个 WPF 项目是 thinWallet ，把它设置为启动项目，直接 CTRL+F5 就可以运行了，当然默认是接入 Testnet 。项目里面有一个《NEO智能合约开发（一）不可能完成的任务.docx》，好好看看。运行结果如下：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/thinWallet-index.png&quot; alt=&quot;thinWallet-index&quot;/&gt;&lt;br/&gt;&lt;strong&gt;这里我们按第二个按钮 ThinWallet Test 就好了，进去是这样的界面：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/thinWallet-test.png&quot; alt=&quot;thinWallet-test&quot;/&gt;&lt;/li&gt;
&lt;li&gt;我们可以看到右上角在调用一个 API for UTXO，这是一个 webapi ，由 NEO_Block_API 提供，大家可以看到这地方默认就是 Testnet ，区块高度也是 Testnet 的高度，切换网络那个按钮还没写功能。总共五个大面板都很好理解，第一个登录方式，第二个 api 信息，第三个账户信息（你的 utxo 将会出现在这里），第四个交易三要素，第五个决定是什么类型的交易。&lt;/li&gt;
&lt;li&gt;NEO_Block_API 里面用到了 mongodb ，所以我们的第三个项目 NeoBlock-Mongo-Storage 作为一个调度任务跑着，用来实时收集链上的交易信息存入 mongodb 中，供 NEO_Block_API 使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;顺便说明一下， vs 2017 很人性化，你直接 CTRL+F5 或者生成解决方案 ，会帮你还原依赖库的，看见黄色感叹号不要慌。如果你无法打开项目或者无法还原或者出现任何异常，相信我，一定是你的打开方式不对，或者你改了里面的东西改错了，或者环境有问题，三个项目是绝对没有错误的，我验证了好几遍了，请回头好好检查自己的环境等基础设施吧。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;配置-neo_block_api&quot;&gt;配置 NEO_Block_API&lt;/h2&gt;
&lt;p&gt;到这里，基础环境全部搭建完毕，thinWallet 也可以在 Testnet 上正常使用了，那么接下来就需要开始接入私链了。首先我们要把 NEO_Block_API 的源代码增改一下，让它支持接入私链。&lt;br/&gt;我们先看一下源代码长什么样，还是 vs 2017 打开：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/neo-block-api-code-structure.png&quot; alt=&quot;neo-block-api-code-structure&quot;/&gt;&lt;br/&gt;我已经生成过解决方案了，所以依赖库都没问题了，结构非常简单。Controllers 是控制器，就是一些 web 接口在这里实现，lib 就是要用到的工具，RPC 定义了一些数据结构，再加一个 Startup.cs 和 Program.cs 文件，典型的 .net core web 项目。&lt;br/&gt;我们可以看到里边有一个 mongodbsettings.json 文件带了个黄色警告标志，说明这个文件丢失了，因为在 .gitignore 里边把它写进去了，所以 git 就把它忽略了，问题不大，我们删掉它重新建立一个一样名字的文件就好了，我们可以找一下在哪里用到了这个文件，你可以 CTRL+SHIFT+F 全局查找，最终发现在 &lt;strong&gt;mongoHelper.cs&lt;/strong&gt; 里面有这么一段：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public mongoHelper() {
    var config = new ConfigurationBuilder()
        .AddInMemoryCollection()    //将配置文件的数据加载到内存中
        .SetBasePath(System.IO.Directory.GetCurrentDirectory())   //指定配置文件所在的目录
        .AddJsonFile(&quot;mongodbsettings.json&quot;, optional: true, reloadOnChange: true)  //指定加载的配置文件
        .Build();    //编译成对象  
    mongodbConnStr_testnet = config[&quot;mongodbConnStr_testnet&quot;];
    mongodbDatabase_testnet = config[&quot;mongodbDatabase_testnet&quot;];
    neoCliJsonRPCUrl_testnet = config[&quot;neoCliJsonRPCUrl_testnet&quot;];

    mongodbConnStr_mainnet = config[&quot;mongodbConnStr_mainnet&quot;];
    mongodbDatabase_mainnet = config[&quot;mongodbDatabase_mainnet&quot;];
    neoCliJsonRPCUrl_mainnet = config[&quot;neoCliJsonRPCUrl_mainnet&quot;];

    mongodbConnStr_NeonOnline = config[&quot;mongodbConnStr_NeonOnline&quot;];
    mongodbDatabase_NeonOnline = config[&quot;mongodbDatabase_NeonOnline&quot;];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么事情就简单了，我们看到这里面一共有 8 个字段要用到，给它就是了，我们在新建的 mongodbsettings.json 文件写上这些内容：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbConnStr_testnet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;mongodb://127.0.0.1:27017&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbDatabase_testnet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;testnet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;neoCliJsonRPCUrl_testnet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;http://47.96.168.8:20332&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;

  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbConnStr_mainnet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;mongodb://127.0.0.1:27017&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbDatabase_mainnet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;mainnet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;neoCliJsonRPCUrl_mainnet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;

  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbConnStr_privatenet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;mongodb://127.0.0.1:27017&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbDatabase_privatenet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;privatenet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;neoCliJsonRPCUrl_privatenet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;http://192.168.1.135:20332&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;

  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbConnStr_NeonOnline&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;mongodb://127.0.0.1:27017&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbDatabase_NeonOnline&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;neononline&quot;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mainnet 一时半会儿肯定用不着，我懒得写了，testnet 还是保留原样，加一个 privatenet 。注意 neoCliJsonRPCUrl_privatenet 这个字段的值是 &lt;a href=&quot;http://192.168.1.135:20332/&quot; class=&quot;uri&quot;&gt;http://192.168.1.135:20332&lt;/a&gt; ，192.168.1.135 这台机器是四台共识机中的一台，开了 RPC ，就是：&lt;code&gt;dotnet neo-cli.dll /rpc&lt;/code&gt; 。我们可以用 postman 来测试一下，随便找个接口，路由是： &lt;code&gt;http://192.168.1.135:20332&lt;/code&gt; 就用 &lt;a href=&quot;http://docs.neo.org/en-us/node/api/getbestblockhash.html&quot;&gt;getbestblockhash&lt;/a&gt; 吧：&lt;br/&gt;先看一下我跑的四个共识节点，我的共识跑了挺久了，现在高度接近 7000 ：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/consensus.png&quot; alt=&quot;consensus&quot;/&gt;&lt;br/&gt;接下来我们看一下 rpc 接口调用结果：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/rpc-test.png&quot; alt=&quot;rpc-test&quot;/&gt;&lt;br/&gt;如果你无法得到类似的结果，那还是得去多看看文档，跑跑共识。现在我们得到了正确结果，说明私链的 RPC 完全没有问题。此刻我们得到了第一个需要的接口就是刚才打开的 thinWallet 右上角 RPC Node 所需要的接口地址：&lt;code&gt;http://192.168.1.151:59908/api/privatenet&lt;/code&gt; 。&lt;br/&gt;mongodb 你得装一下（随你 linux 还是 windows，推荐 linux），为了演示方便，我装在了 windows 里面。装完之后就是 C:\Program Files\MongoDB\Server\3.6\bin 里面有一堆东西。其中 mongod.exe 这个是服务端，因为国际惯例有个 d 。别急着双击它，你得先建立两个文件夹：C:\data\db，不然双击就闪退了，其实你可以用 cmd 来打开，可以看到异常信息。现在你可以双击它了，结果就是一个控制台，打印了一堆日志，你可以用 mongodb 自带的可视化客户端连接一下。这边注意，我们不需要事先创建数据库。&lt;br/&gt;下面开始创建 webapi 接口，也就是新建一个控制器，在项目的 Controllers 文件夹下，新建一个类，取名：&lt;strong&gt;PrivatenetController.cs&lt;/strong&gt; ，然后把随便 &lt;strong&gt;TestnetController.cs&lt;/strong&gt; 或者 ** MainnetController.cs** 里面的内容全部复制粘贴到我们的 &lt;strong&gt;PrivatenetController.cs&lt;/strong&gt; 中，改一下两个地方，变成 privatenet ：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
public class PrivatenetController : Controller
{
    Api api = new Api(&quot;privatenet&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着 mongoHelper.cs 里面改一下，把私链的东西加进去：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public string mongodbConnStr_testnet = string.Empty;
public string mongodbDatabase_testnet = string.Empty;
public string neoCliJsonRPCUrl_testnet = string.Empty;

public string mongodbConnStr_mainnet = string.Empty;
public string mongodbDatabase_mainnet = string.Empty;
public string neoCliJsonRPCUrl_mainnet = string.Empty;

public string mongodbConnStr_privatenet = string.Empty;
public string mongodbDatabase_privatenet = string.Empty;
public string neoCliJsonRPCUrl_privatenet = string.Empty;

public string mongodbConnStr_NeonOnline = string.Empty;
public string mongodbDatabase_NeonOnline = string.Empty;

public mongoHelper() {
    var config = new ConfigurationBuilder()
        .AddInMemoryCollection()    //将配置文件的数据加载到内存中
        .SetBasePath(System.IO.Directory.GetCurrentDirectory())   //指定配置文件所在的目录
        .AddJsonFile(&quot;mongodbsettings.json&quot;, optional: true, reloadOnChange: true)  //指定加载的配置文件
        .Build();    //编译成对象  
    mongodbConnStr_testnet = config[&quot;mongodbConnStr_testnet&quot;];
    mongodbDatabase_testnet = config[&quot;mongodbDatabase_testnet&quot;];
    neoCliJsonRPCUrl_testnet = config[&quot;neoCliJsonRPCUrl_testnet&quot;];

    mongodbConnStr_mainnet = config[&quot;mongodbConnStr_mainnet&quot;];
    mongodbDatabase_mainnet = config[&quot;mongodbDatabase_mainnet&quot;];
    neoCliJsonRPCUrl_mainnet = config[&quot;neoCliJsonRPCUrl_mainnet&quot;];

    mongodbConnStr_privatenet = config[&quot;mongodbConnStr_privatenet&quot;];
    mongodbDatabase_privatenet = config[&quot;mongodbDatabase_privatenet&quot;];
    neoCliJsonRPCUrl_privatenet = config[&quot;neoCliJsonRPCUrl_privatenet&quot;];

    mongodbConnStr_NeonOnline = config[&quot;mongodbConnStr_NeonOnline&quot;];
    mongodbDatabase_NeonOnline = config[&quot;mongodbDatabase_NeonOnline&quot;];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，Api.cs 里面加私链的东西：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public Api(string node) {
    netnode = node;
    switch (netnode) {
        case &quot;testnet&quot;:
            mongodbConnStr = mh.mongodbConnStr_testnet;
            mongodbDatabase = mh.mongodbDatabase_testnet;
            neoCliJsonRPCUrl = mh.neoCliJsonRPCUrl_testnet;
            break;
        case &quot;mainnet&quot;:
            mongodbConnStr = mh.mongodbConnStr_mainnet;
            mongodbDatabase = mh.mongodbDatabase_mainnet;
            neoCliJsonRPCUrl = mh.neoCliJsonRPCUrl_mainnet;
            break;
        case &quot;privatenet&quot;:
            mongodbConnStr = mh.mongodbConnStr_privatenet;
            mongodbDatabase = mh.mongodbDatabase_privatenet;
            neoCliJsonRPCUrl = mh.neoCliJsonRPCUrl_privatenet;
            break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打完收工我们来试一下，CTRL+F5，我们可以看到内置的 IIS Express 被启动了，可以访问这个地址：&lt;br/&gt;&lt;code&gt;http://localhost:59908/api/privatenet&lt;/code&gt;&lt;br/&gt;显示的结果是：&lt;br/&gt;&lt;code&gt;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:0,&quot;error&quot;:{&quot;code&quot;:-100,&quot;message&quot;:&quot;Parameter Error&quot;,&quot;data&quot;:&quot;Value cannot be null.\r\nParameter name: s&quot;}}&lt;/code&gt;&lt;br/&gt;那说明 webapi 本身已经没问题了，我们看到用的是 localhost ，如果想局域网都能用的话我们可以改一下 .vs\config\applicationhost.config 里面的配置再运行，或者我们用典型的 .net core 方法（我采用这种），就是在 Program.cs 里面加一点料：&lt;code&gt;.UseUrls(&quot;http://*:59908&quot;)&lt;/code&gt;，详细如下，这是允许局域网 ip 访问的第一步:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static IWebHost BuildWebHost(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)
                .UseStartup&amp;lt;Startup&amp;gt;()
                .UseUrls(&quot;http://*:59908&quot;)
                .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步我们改一下启动方式，先重新生成解决方案，然后把 &lt;code&gt;appsettings.json&lt;/code&gt; 和 &lt;code&gt;mongodbsettings.json&lt;/code&gt; 两个文件复制到 &lt;code&gt;bin\Debug\netcoreapp2.0&lt;/code&gt; 里面去，关掉刚才启动的 IIS Express，然后我们以管理员身份打开 cmd ，cd 到你的 &lt;code&gt;bin\Debug\netcoreapp2.0&lt;/code&gt; 文件夹里面，然后 &lt;code&gt;dotnet NEO_Block_API.dll&lt;/code&gt; 就好了，结果如下：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/dotnet-neo-block-api.png&quot; alt=&quot;dotnet-neo-block-api&quot;/&gt;&lt;br/&gt;你可以去局域网的其他机器上用 postman 访问一下，没啥问题，用 &lt;code&gt;getblockcount&lt;/code&gt; 接口吧，路由是这个： &lt;code&gt;http://192.168.1.151:59908/api/privatenet&lt;/code&gt; ，文档在这：&lt;a href=&quot;http://www.xiaoyaoji.cn/share/1H0gjTDtfk/1GzzPWtpFG&quot;&gt;单击此处&lt;/a&gt; 。&lt;br/&gt;我在这台 windows 10 上操作的，IP 是 &lt;code&gt;192.168.1.151&lt;/code&gt; ，所以我们得到了第二个想要的接口地址，就是 API for UTXO 的 api 地址：&lt;code&gt;http://192.168.1.151:59908/api/privatenet&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;thinwallet-接入私链&quot;&gt;thinWallet 接入私链&lt;/h3&gt;
&lt;p&gt;现在我们来观察一下 thinWallet 的代码结构：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/thinWallet-code-structure.png&quot; alt=&quot;thinWallet-code-structure&quot;/&gt;&lt;br/&gt;很显然，上面三个项目都是通用库，第三个是用户端，而且我们只需要改一个地方就可以了，双击打开 &lt;strong&gt;Window_thinwallet.xaml&lt;/strong&gt; ，WPF 的界面文件，打开是这样的：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/wpf-full.png&quot; alt=&quot;wpf-full&quot;/&gt;&lt;br/&gt;简直不能忍，不仅丑爆了，还影响阅读和写代码，我们做一下调整，下面图里面中间，左右两个红圈圈出来的按钮，先按左边那个，上下窗口对调，然后按右边那个，把下窗口缩进去，这样就是纯代码界面了，又好看又能高效阅读。&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/wpf-adjust.png&quot; alt=&quot;wpf-adjust&quot;/&gt;&lt;br/&gt;接下来我们要把它接入私链，其实就该两个接口地址，就在这个界面代码里面，thinWallet 对这两个地址目前是写死在界面上的，我们在界面代码里面查找一下 CTRL+F ，输入 &lt;code&gt;47.96&lt;/code&gt; 就能找到了，一共两个地方，分别对应的填进去：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/private-api.png&quot; alt=&quot;private-api&quot;/&gt;&lt;br/&gt;打完收工我们来访问一下，CTRL+F5：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/thinWallet-error-height.png&quot; alt=&quot;thinWallet-error-height&quot;/&gt;&lt;br/&gt;我们发现一个很诡异的数字，下面那个直接访问 neo rpc 的已经完全正常了，但是上面那个访问 webapi 的居然是这么个诡异的数字，那么碰到问题，我们首先得想到的事情只有一件，就是 &lt;strong&gt;F5&lt;/strong&gt;，首先我们先打开 Window_thinwallet.xaml 这个文件的后台文件，就是 &lt;code&gt;Window_thinwallet.xaml.cs&lt;/code&gt; ，我们观察一下里面的代码，发现有一个异步更新界面的地方：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/update-ui-height.png&quot; alt=&quot;update-ui-height&quot;/&gt;&lt;br/&gt;再来看一下这个 &lt;code&gt;api_getHeight&lt;/code&gt; 是怎么实现的，F12 过去：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/update-ui-request.png&quot; alt=&quot;update-ui-request&quot;/&gt;&lt;br/&gt;真相在这里，请求了 webapi 的一个 &lt;code&gt;getblockcount&lt;/code&gt; 的接口，那么现在来看一下 NEO_Block_API 项目对 &lt;code&gt;getblockcount&lt;/code&gt; 是怎么实现的：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/impl-getblockcount.png&quot; alt=&quot;impl-getblockcount&quot;/&gt;&lt;br/&gt;这时候就发现了，这里居然在调用 mongodb 的数据，我们回想一下，似乎没有任何操作 mongodb 的地方，也就是说没有任何数据，那么我们可以猜到，&lt;code&gt;getblockcount&lt;/code&gt; 接口返回了一个 0 ，而且在我们的 &lt;code&gt;Window_thinwallet.xaml.cs&lt;/code&gt; 文件异步更新界面的地方，最后 &lt;code&gt;var height = ulong.Parse(json[0].AsDict()[&quot;blockcount&quot;].ToString()) - 1;&lt;/code&gt; 来了这么一句，很明确了，无符号长整型，减了个 1 ，导致变成了那个数字，现在来 F5 证明一下，断点打在 &lt;code&gt;api_getHeight&lt;/code&gt; 这个方法的最后一句 return 的代码上：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/debug.png&quot; alt=&quot;debug&quot;/&gt;&lt;br/&gt;其中 result 是请求结果，就是 0 ，已经说明了一切。那还差什么呢，想想我们好像漏了一个项目，没错还有最后一个调度任务项目没配置好。&lt;/p&gt;
&lt;h2 id=&quot;neoblock-mongo-storage-开启对私链的任务调度&quot;&gt;NeoBlock-Mongo-Storage 开启对私链的任务调度&lt;/h2&gt;
&lt;p&gt;老样子观察代码：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/storage-structure.png&quot; alt=&quot;storage-structure&quot;/&gt;&lt;br/&gt;很简单，一个入口，两个数据接口，一个工具，没了。&lt;br/&gt;我们可以发现在 &lt;code&gt;Program.cs&lt;/code&gt; 里面有这么一段：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var config = new ConfigurationBuilder()
    .AddInMemoryCollection()    //将配置文件的数据加载到内存中
    .SetBasePath(System.IO.Directory.GetCurrentDirectory())   //指定配置文件所在的目录
    .AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)  //指定加载的配置文件
    .Build();    //编译成对象  
mongodbConnStr = config[&quot;mongodbConnStr&quot;];
mongodbDatabase = config[&quot;mongodbDatabase&quot;];
NeoCliJsonRPCUrl = config[&quot;NeoCliJsonRPCUrl&quot;];
sleepTime = int.Parse(config[&quot;sleepTime&quot;]);
if (int.Parse(config[&quot;utxoIsSleep&quot;]) == 1) {
    utxoIsSleep = true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很简单了，加个文件，&lt;code&gt;appsettings.json&lt;/code&gt; :&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbConnStr&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;mongodb://127.0.0.1:27017&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbDatabase&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;privatenet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;NeoCliJsonRPCUrl&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;http://192.168.1.135:20332&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;sleepTime&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;utxoIsSleep&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样道理，重新生成解决方案，把这个 json 文件复制到 bin\Debug\netcoreapp2.0 里面去，然后管理员身份打开 cmd ，然后 cd 进去，然后 &lt;code&gt;dotnet NeoBlockMongoStorage.dll&lt;/code&gt; ，看下结果：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/GIF.gif&quot; alt=&quot;GIF&quot;/&gt;&lt;br/&gt;这个狂暴的气息，然后我们开一下 thinWallet，看下结果：&lt;br/&gt;&lt;img src=&quot;http://www.myjoit.com/thinWallet/update-height.gif&quot; alt=&quot;update-height&quot;/&gt;&lt;br/&gt;这个高度正在快速地向最高高度同步过去，同步完成之后，我们就完成了 thinWallet 接入私链的所有步骤，你的 thinWallet 就可以在私链中随便玩了。&lt;br/&gt;同步完成之后，我们最好把 NeoBlock-Mongo-Storage 项目的 appsettings.json 改一下，把 &lt;code&gt;sleepTime&lt;/code&gt; 从 0 改为 2000，&lt;code&gt;utxoIsSleep&lt;/code&gt; 从 0 改为 1，因为调度是个无限循环，如果不让它睡一会，就会一直浪费你的 cpu ，同步完成了，没那么多数据要写了，让它休息休息，这样造成的效果是，上面那个高度永远比下面那个高度更新慢半拍。单位是毫秒。自己随便调节。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbConnStr&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;mongodb://127.0.0.1:27017&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;mongodbDatabase&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;privatenet&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;NeoCliJsonRPCUrl&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;http://192.168.1.135:20332&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;sleepTime&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;2000&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;utxoIsSleep&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后对着这两篇质量文档去玩吧。&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s/7ifwcY-UVj7qquDRpq1zUA&quot;&gt;不可能任务一&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s/qe7lV71__FygKxO9E4_Oew&quot;&gt;不可能任务二&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 22:30:00 +0000</pubDate>
<dc:creator>JoiT</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JoiT/p/thinwallet-to-private-neo-chain.html</dc:identifier>
</item>
<item>
<title>揽货最短路径解决方案算法 - C# 蚁群优化算法实现 - McKay</title>
<link>http://www.cnblogs.com/aarond/p/ant_wuliu.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aarond/p/ant_wuliu.html</guid>
<description>&lt;p&gt;需求为（自己编的，非实际项目）：&lt;/p&gt;
&lt;p&gt;某配送中心进行揽货，目标客户数为50个客户，配送中心目前的运力资源如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;现有车辆5台&lt;/li&gt;
&lt;li&gt;单台运力最大行驶距离200千米&lt;/li&gt;
&lt;li&gt;单台运力最大载重公斤1吨&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;问：运力怎样走法才能以最低的成本完成针对这50个客户的揽货行为&lt;/p&gt;
&lt;p&gt;是个最优化问题（运筹学），我们只考虑简化后的模型，不考虑路面交通、时间窗口这些复杂计算，用蚁群优化算法来实现接近最优解的计算。&lt;/p&gt;
&lt;p&gt;关于蚁群优化算法的理论请看这篇文章：&lt;a href=&quot;https://www.cnblogs.com/asxinyu/p/Path_Optimization_Tsp_Problem_Ant_System_CSharp.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/asxinyu/p/Path_Optimization_Tsp_Problem_Ant_System_CSharp.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面的基本算法已经写明了，也有demo，本文是针对如何适应到具体业务的介绍（本文用的蚁群核心代码也是上文中改来的）&lt;/p&gt;
&lt;p&gt;蚁群主要步骤为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化（如信息素）&lt;/li&gt;
&lt;li&gt;开始迭代
&lt;ol&gt;&lt;li&gt;构造各个蚂蚁，以及蚂蚁走的路径（核心是针对后续节点的SELECT）&lt;/li&gt;
&lt;li&gt;计算适应度&lt;/li&gt;
&lt;li&gt;加入优秀蚂蚁到跟踪列表&lt;/li&gt;
&lt;li&gt;更新信息素（根据适应度）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;结束迭代&lt;/li&gt;
&lt;li&gt;给出报告&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;原文章里用的是TSP做DEMO，比较难看清楚如何应用到实际业务逻辑中&lt;/p&gt;
&lt;p&gt;同样的，最困惑的核心中的核心，类似遗传算法，也是适应度值的计算，有的地方是一步一步增加vlaue，比如单纯距离的增加，但是复杂点的都没法这么操作，而是要看整体路径的指标（包括惩罚等）&lt;/p&gt;
&lt;p&gt;由于蚁群优化算法和本文代码都能下载，所以只介绍适应度value的计算&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/aarond/%E7%89%A9%E6%B5%81%E9%85%8D%E9%80%81%E8%B7%AF%E5%BE%84%EF%BC%88ANT%EF%BC%89.rar&quot; target=&quot;_blank&quot;&gt;下载&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; FitnessValueCalculator
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; 拥有运力车辆数 = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; 单台运力最大行驶距离 = &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; 单台运力最大载重公斤 = &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; 惩罚权重 = &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; Calculator(ShortestDeliverAnt ant)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; paths = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; distances = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; weights = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; 当前行驶距离 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; 当前运力载重 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; 当前行驶路径 = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; 当前所需运力数 = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算枢纽到第一个客户配送距离&lt;/span&gt;
            当前行驶路径 += &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HUB--&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ant.PathNodes.First();
            当前行驶距离 &lt;/span&gt;+=&lt;span&gt; ant.DistanceHelper.hub.DistanceTo(ant.DistanceHelper.customers[ant.PathNodes.First()]);
            当前运力载重 &lt;/span&gt;+=&lt;span&gt; ant.DistanceHelper.customers[ant.PathNodes.First()].需求量_公斤;

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; path &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ant.Edges)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fromNodeId =&lt;span&gt; path.Key;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toNodeId =&lt;span&gt; path.Value;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fromNode =&lt;span&gt; ant.DistanceHelper.customers[fromNodeId];
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toNode =&lt;span&gt; ant.DistanceHelper.customers[toNodeId];

                &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; newAddedDistance2Customer = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; newAddedDistance2Hub = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; newAddedWeight = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

                newAddedDistance2Customer &lt;/span&gt;=&lt;span&gt; fromNode.DistanceTo(toNode);
                newAddedDistance2Hub &lt;/span&gt;=&lt;span&gt; toNode.DistanceTo(ant.DistanceHelper.hub);

                newAddedWeight &lt;/span&gt;=&lt;span&gt; toNode.需求量_公斤;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (当前行驶距离 + newAddedDistance2Customer + newAddedDistance2Hub &amp;lt;=&lt;span&gt; 单台运力最大行驶距离
                    &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
                    当前运力载重 &lt;/span&gt;&amp;lt;=&lt;span&gt; 单台运力最大载重公斤)
                {
                    当前行驶距离 &lt;/span&gt;+=&lt;span&gt; newAddedDistance2Customer;
                    当前运力载重 &lt;/span&gt;+=&lt;span&gt; newAddedWeight;
                    当前行驶路径 &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; toNodeId;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加当前客户距离、以及回到HUB的距离&lt;/span&gt;
                    当前行驶距离 +=&lt;span&gt; fromNode.DistanceTo(ant.DistanceHelper.hub);
                    distances.Add(当前行驶距离);

                    weights.Add(当前运力载重);

                    当前行驶路径 &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--&amp;gt;HUB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    paths.Add(当前行驶路径);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RESET&lt;/span&gt;
                    当前行驶距离 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    当前行驶距离 &lt;/span&gt;+=&lt;span&gt; ant.DistanceHelper.hub.DistanceTo(toNode);

                    当前运力载重 &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    当前运力载重 &lt;/span&gt;+=&lt;span&gt; toNode.需求量_公斤;

                    当前行驶路径 &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
                    当前行驶路径 &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HUB--&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; toNodeId;

                    当前所需运力数&lt;/span&gt;++&lt;span&gt;;
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回到枢纽&lt;/span&gt;
            当前行驶距离 +=&lt;span&gt; ant.DistanceHelper.customers[ant.PathNodes.Last()].DistanceTo(ant.DistanceHelper.hub);
            distances.Add(当前行驶距离);

            当前行驶路径 &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--&amp;gt;HUB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            paths.Add(当前行驶路径);



            &lt;/span&gt;&lt;span&gt;int 惩罚系数 = 0;
            if (当前所需运力数 &amp;gt; 拥有运力车辆数)
                惩罚系数 = 当前所需运力数 -&lt;/span&gt;&lt;span&gt;&lt;span&gt; 拥有运力车辆数;&lt;/span&gt;


            ant.运输距离顺序 &lt;/span&gt;=&lt;span&gt; distances;
            ant.运输路径 &lt;/span&gt;=&lt;span&gt; paths;

            ant.Total行驶距离 &lt;/span&gt;=&lt;span&gt; distances.Sum();
            ant.Total运力数 &lt;/span&gt;=&lt;span&gt; 当前所需运力数;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ant.Total行驶距离&lt;span&gt; + 惩罚系数 *&lt;/span&gt;&lt;span&gt;&lt;span&gt; 惩罚权重&lt;/span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt;ant.DistanceHelper.hub: 是配送中心的info，有地址信息&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ant.DistanceHelper.customers: 是50个客户的info，也有地址信息&lt;br/&gt;目前为了简化，是以街道距离来计算距离的&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span readability=&quot;4&quot;&gt;目前代码只是单目标优化算法，非多目标优化，后续研究研究再发文。&lt;br/&gt;上述代码其实就是第一辆车从配送中心开出到第一个客户位置，然后加上客户需求（揽的货物重量）&lt;br/&gt;接着判断能否开到下一个客户那里揽货，如果里程、重量都在限制条件只能，就开过去，不满足条件就开回枢纽；然后继续判断第二辆车，也是这么个逻辑&lt;br/&gt;最终车辆的数量就是完成这50个客户揽货所需的运力数&lt;br/&gt;万一碰到所需运力超出了限制（代码中为5辆车），这时就需要惩罚，由于最终函数返回是double，而且是越小代表越优越，因此碰到了需要惩罚的情况，实际就是大幅度的增加返回值（适应度值）&lt;br/&gt;红色部分就是惩罚变量部分。&lt;p&gt;各种优化算法的核心写完框架后基本就不怎么变化了，最易变的其实是适应度函数的计算，如果适应度计算中用到了预测技术，还得在上面那函数里调机器学习的代码，感觉强化学习中动作施加后给出的反馈值也是这么个值&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/aarond/%E7%89%A9%E6%B5%81%E9%85%8D%E9%80%81%E8%B7%AF%E5%BE%84%EF%BC%88ANT%EF%BC%89.rar&quot; target=&quot;_blank&quot;&gt;代码下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/68230/201802/68230-20180225032136955-1016057116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 24 Feb 2018 19:27:00 +0000</pubDate>
<dc:creator>McKay</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aarond/p/ant_wuliu.html</dc:identifier>
</item>
<item>
<title>Windows Server 2016-重置目录还原模式密码 - Wenzhongxiang</title>
<link>http://www.cnblogs.com/wenzhongxiang/p/8468243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenzhongxiang/p/8468243.html</guid>
<description>&lt;p&gt;目录还原模式：Directory Services Restore Mode，简称DSRM，又称目录服务恢复模式。是Windows域控制器的服务器安全模式启动选项。DSRM允许管理员用来修复或还原修复或重建活动目录数据库。&lt;/p&gt;
&lt;p&gt;在提升域控制器向导过程中提示管理员输入目录还原模式即DSRM密码。管理员妥善保管该密码可以防护数据库后门，避免后期很多问题。注DSRM密码并不能提供访问域或任何服务的权限。如DSRM密码遗忘，可通过命令行工具Ntdsutil进行更改。具体操作步骤如下：&lt;/p&gt;
&lt;p&gt;1、用域管理员账户登录域控制器：&lt;/p&gt;
&lt;p&gt;2、进入DOS命令提示符或Powershell界面(本例为后者)，输入：Ntdsutil&lt;/p&gt;
&lt;p&gt;3、在&quot;ntdsutil：&quot;提示符下输入set dsrm password 回车：&lt;/p&gt;
&lt;pre class=&quot;brush:vb;toolbar:false&quot;&gt;
ntdsutil.exe: set dsrm password&lt;br/&gt;重置 DSRM 管理员密码: ?&lt;br/&gt;? - 显示这个帮助信息&lt;br/&gt;Help - 显示这个帮助信息&lt;br/&gt;Quit - 返回到上一个菜单&lt;br/&gt;Reset Password on server %s - 在指定 AD DC/LDS 实例上重置目录服务还原模式管理员帐户密码。本地计算机使用 NULL。&lt;br/&gt;Sync from domain account %s - 执行从此 Active Directory 域的指定用户名 %s 到本地计算机上目录服务还原模式管理员帐户的一次性密码同步。&lt;br/&gt;注意: 如果目标 AD DC/LDS 实例当前处于目录服务还原模式，则无法使用 ntdsutil 重置或同步此密码。
&lt;/pre&gt;
&lt;p&gt;​4、在&quot;重置DSRM管理员密码：&quot;下输入reset password on server Major.azureyun.local：&lt;/p&gt;
&lt;p&gt;5、两次输入新密码并确认，如下图该密码与当前域环境密码策略一致，密码必须满足密码策略要求(密码最小长度、密码复杂性和密码历史要求等)；&lt;/p&gt;
&lt;p&gt;6、输入复杂性密码并确定，提示密码设置成功；&lt;/p&gt;
&lt;p&gt;7、输入两次quit命令退出ntdsutil；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022418_1620_WindowsServ1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们记得目录还原模式密码，可开机进入目录还原模式通过ctrl+alt+del调出重置密码界面进行更改，本章分享完成，感谢支持。&lt;/p&gt;

</description>
<pubDate>Sat, 24 Feb 2018 16:31:00 +0000</pubDate>
<dc:creator>Wenzhongxiang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenzhongxiang/p/8468243.html</dc:identifier>
</item>
<item>
<title>R语言-来自Prosper的贷款数据探索 - 月上贺兰</title>
<link>http://www.cnblogs.com/luhuajun/p/8468091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luhuajun/p/8468091.html</guid>
<description>&lt;p&gt;案例分析:Prosper是美国的一家P2P在线借贷平台，网站撮合了一些有闲钱的人和一些急用钱的人。用户若有贷款需求，可在网站上列出期望数额和可承受的最大利率。潜在贷方则为数额和利率展开竞价。&lt;/p&gt;&lt;p&gt;　　　　本项目拟通过该数据集的探索，结合自己的理解进行分析，最终目的的是初步预测哪些人贷款后会还款、哪些人会赖账。&lt;/p&gt;
&lt;p&gt;　　1.探索数据集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; loandata = read.csv(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prosperLoanData.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; str(loandata)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结论:一共有81个变量,113937个对象&lt;/p&gt;
&lt;p&gt;　　2.选择分析的变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;由于有81个变量，为简化分析，仅选取其中有代表性的13个变量。变量选取如下：

&lt;/span&gt;1. **ListingCreation**&lt;span&gt;: 列表创建时间。

&lt;/span&gt;2. **Term**&lt;span&gt;: 贷款期限，期限越长的，利率应当越高

&lt;/span&gt;3. **LoanStatus**&lt;span&gt;: 贷款状态（Completed、Current、Defaulted、Chargedoff等）

&lt;/span&gt;4. **BorrowerBorrowerRate**&lt;span&gt;: 借款利率。

&lt;/span&gt;5. **DelinquenciesLast7Years**&lt;span&gt;: 信用资料提交时借款人过去7年违约次数。

&lt;/span&gt;6. **StatedMonthlyIncome**&lt;span&gt;: 客户自己声称的月收入。

&lt;/span&gt;7. **IsBorrowerHomeowner**&lt;span&gt;: 借款人是否拥有住房。

&lt;/span&gt;8. **InquiriesLast6Months**&lt;span&gt;: 最近6个月的征信记录查询次数。一般来说，征信查询次数越多，该主体的贷款申请就越多。

&lt;/span&gt;9. **DebtToIncomeRatio**&lt;span&gt;: 借款人的债务收入比，债务收入比越高说明筹资者财务状况越差，还款能力越低。

&lt;/span&gt;10. **Occupation**&lt;span&gt;: 贷款人职业

&lt;/span&gt;11. **CreditGrade/ProsperRating(Alpha)**&lt;span&gt;: 信用等级，前者反映的是2009年7月1日前客户的信用等级，后者反映的是2009年7月1日后的信用等级。信用等级越高，其偿债能力越强。

&lt;/span&gt;12. **CreditScore**&lt;span&gt;: 由消费信用公司提供的消费信用评分，同信用评级作用。

&lt;/span&gt;13. **BankCardUse**: 信用资料提交时借款人信用卡使用额度和信用卡总透支额度的百分比，本文将这个数据分成四组（mild use; medium use; heavy use; super use）
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3.数据预处理&lt;/p&gt;
&lt;p&gt;　　　　3.1贷款状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 查看贷款状态&lt;br/&gt;1&lt;/span&gt; table(loandata$LoanStatus)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224095301422-1317468808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; # 2.整合数据&lt;br/&gt;# 针对LoanStatus进行重构&lt;br/&gt;# 1.将所有含有&quot;Past Due&quot;字段的值统一为&quot;PastDue&quot;&lt;br/&gt;# 2.将&quot;Cancelled&quot;归类到&quot;Current&quot;中&lt;br/&gt;# 3.将&quot;defaulted&quot;归类到&quot;Chargedoff&quot;中&lt;br/&gt;# 4.将&quot;FinalPaymentInProgress&quot;归类到&quot;Completed&quot;中&lt;br/&gt;1&lt;/span&gt; PastDue &amp;lt;- c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Past Due (&amp;gt;120 days)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;              &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Past Due (1-15 days)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;              &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Past Due (16-30 days)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;              &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Past Due (31-60 days)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;              &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Past Due (61-90 days)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;              &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Past Due (91-120 days)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; loandata$LoanStatus &amp;lt;-&lt;span&gt; as.character(loandata$LoanStatus)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; loandata$LoanStatus[loandata$LoanStatus %&lt;span&gt;in&lt;/span&gt;% PastDue] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PastDue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; loandata$LoanStatus[loandata$LoanStatus == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cancelled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Current&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; loandata$LoanStatus[loandata$LoanStatus == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Defaulted&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chargedoff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; loandata$LoanStatus[loandata$LoanStatus == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FinalPaymentInProgress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Completed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224095816544-961869321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.再次整合数据&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.然后将&quot;PastDue&quot;与&quot;Chargedoff&quot;合并，表示未按时还款&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.将&quot;Current&quot;和&quot;Completed&quot;合并，表示按时还款未出现不良记录的&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; loandata$LoanStatus[loandata$LoanStatus == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PastDue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chargedoff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; loandata$LoanStatus[loandata$LoanStatus == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Current&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Completed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; table(loandata$LoanStatus)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224100124922-955598172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　3.2消费信用评分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对借款人的消费信用评级，数据中有高低范围，将这两个数值取平均值做计算&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; loandata$CreditScore &amp;lt;- (loandata$CreditScoreRangeLower + loandata$CreditScoreRangeUpper) / 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　3.3信用评级&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因2009年7月1日，Prosper的信用评级模型发生了改变，所以需要进行分段处理&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先处理2009年7月1日前的数据&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; loandata$CreditGrade &amp;lt;-&lt;span&gt; ordered(loandata$CreditGrade,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                                 levels = c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 再处理2009年7月1日后的数据&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; loandata$ProsperRating..Alpha. &amp;lt;-&lt;span&gt; ordered(loandata$ProsperRating..Alpha.,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                                           levels = c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因为2009年7月1日是一个数据节点，因此将数据分成两段处理&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; loandata$LoanOriginationDate &amp;lt;-&lt;span&gt; as.Date(loandata$LoanOriginationDate)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; loandata$Phase[loandata$LoanOriginationDate &amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;After 2009&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; loandata$Phase[loandata$LoanOriginationDate &amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Before 2009&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; table(loandata$Phase)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224100643633-579831403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　3.4信用卡使用程度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义&quot;Mild Use&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;loandata$BankCardUse[
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     loandata$BankcardUtilization &amp;lt;&lt;span&gt; quantile(loandata$BankcardUtilization, 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                                             probs = 0.25, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&lt;span&gt; TRUE)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; ] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mild Use&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义“Medium Use”&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;loandata$BankCardUse[
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     loandata$BankcardUtilization &amp;gt;=&lt;span&gt; quantile(loandata$BankcardUtilization,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                                              probs = 0.25, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&lt;span&gt; TRUE) 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &amp;amp;
&lt;span&gt;12&lt;/span&gt;         loandata$BankcardUtilization &amp;lt;&lt;span&gt; quantile(loandata$BankcardUtilization,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                                                     probs = 0.5, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;=&lt;span&gt; TRUE)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; ] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Medium Use&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义“Heavy Use”&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;loandata$BankCardUse[
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     loandata$BankcardUtilization &amp;gt;=&lt;span&gt; quantile(loandata$BankcardUtilization,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                                              probs = 0.5, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&lt;span&gt; TRUE)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &amp;amp;
&lt;span&gt;21&lt;/span&gt;         loandata$BankcardUtilization &amp;lt;&lt;span&gt; quantile(loandata$BankcardUtilization,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                                                 probs = 0.75, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&lt;span&gt; TRUE)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; ] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Heavy Use&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义“Super Use”&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; loandata$BankCardUse[loandata$BankcardUtilization &amp;gt;= 0.75] &amp;lt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Super Use&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; loandata$BankCardUse &amp;lt;-&lt;span&gt; factor(loandata$BankCardUse,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                                levels = c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mild Use&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                                           &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Medium Use&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                                           &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Heavy Use&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                                           &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Super Use&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; table(loandata$BankCardUse)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224100857643-2108532529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4.探索数据集&lt;/p&gt;
&lt;p&gt;　　　　4.1单变量探索&lt;/p&gt;
&lt;p&gt;　　　　　　4.1.1贷款期限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = as.factor(Term)), data = loandata) +
&lt;span&gt;2&lt;/span&gt;     geom_histogram(stat = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +
&lt;span&gt;3&lt;/span&gt;     xlab(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; table(loandata$Term, dnn = (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224101122512-1970721501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224101138035-371260504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:一年期（12个月）的有1614笔，三年期（36个月）的有87778笔，五年期（60个月）的有24545笔。由此，平台上的贷款以中长期为主，且三年期占绝大多数。经查阅资料发现，Prosper平台是　　　　　　　　　　2009年以后才开始提供一年期和五年期贷款品种。&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.1.2贷款利率&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
ggplot(aes(x = BorrowerRate), data = loandata) +&lt;span&gt;
    geom_histogram(binwidth &lt;/span&gt;= 0.01) +&lt;span&gt;
    scale_x_continuous(breaks &lt;/span&gt;= seq(0, 0.5, 0.05)) +&lt;span&gt;
    facet_wrap(&lt;/span&gt;~ Term, ncol = 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224101445722-188950700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:平台上的借款利率多集中在0.08至0.2这个区间，另外，利率0.32附近也拥有大量的观测值。并且贷款利率似乎与贷款期限关系并不明显，未如经验判断的“期限越长、利率越高”。&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.1.3过去7年的违约次数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = DelinquenciesLast7Years), data = loandata) +
&lt;span&gt;2&lt;/span&gt;     geom_density(aes(fill = I(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))) +
&lt;span&gt;3&lt;/span&gt;     coord_cartesian(xlim =&lt;span&gt; c(0, quantile(loandata$DelinquenciesLast7Years,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                                                probs = 0.95, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = TRUE)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224103720793-2070303248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:大部分借款人在过去7年内的违约次数均为0，这说明整个平台借款人的信用状况较好&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.1.4月收入,月收入很大情况下能够反映借贷人的还款能力&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x =&lt;span&gt; StatedMonthlyIncome), 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        data = subset(loandata, loandata$StatedMonthlyIncome &amp;lt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;                         quantile(loandata$StatedMonthlyIncome, 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                                   probs = 0.95, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = TRUE))) +
&lt;span&gt;5&lt;/span&gt;     geom_histogram(binwidth = 500) +
&lt;span&gt;6&lt;/span&gt;     scale_x_continuous(breaks = seq(0, 21000, 500)) +
&lt;span&gt;7&lt;/span&gt;     geom_vline(xintercept = 2500, color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +
&lt;span&gt;8&lt;/span&gt;     geom_vline(xintercept = 6000, color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224103945474-1202803430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:大部分借贷人的月薪在2500~6000美金之间&lt;/p&gt;
&lt;p&gt; 　　　　　　　  4.1.5是否拥有房屋(有房子的要比没有房屋的人偿还能力强)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = IsBorrowerHomeowner), data = loandata) +
&lt;span&gt;2&lt;/span&gt;     geom_bar()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224104239765-809084194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:有房屋的借贷人略微大于没房屋的借贷人&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.1.6借款人征信查询的次数,征信查询的次数越多表示借款人近期的申请的贷款越多,资金越紧张&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
ggplot(aes(x = InquiriesLast6Months, fill = I(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)), data = loandata) +&lt;span&gt;
    geom_density(binwidth &lt;/span&gt;= 1) +&lt;span&gt;
    geom_vline(xintercept &lt;/span&gt;=&lt;span&gt; quantile(loandata$InquiriesLast6Months, 
                                     probs &lt;/span&gt;= 0.95, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&lt;span&gt; TRUE), 
               linetype &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dashed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
    coord_cartesian(xlim &lt;/span&gt;=&lt;span&gt; c(0, quantile(loandata$InquiriesLast6Months,
                                         probs &lt;/span&gt;= 0.95, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = TRUE)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224104529240-1749360144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:95%的借款人征信查询次数在5次及以下&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.1.7负债收益比(反映了借款人的杠杆率,如果大于1表示很难偿还贷款,极易引发坏账)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = DebtToIncomeRatio), data = loandata) +
&lt;span&gt;2&lt;/span&gt;     geom_histogram(binwidth = 0.05) +
&lt;span&gt;3&lt;/span&gt;     scale_x_continuous(breaks = seq(0, 10, 0.5)) +
&lt;span&gt;4&lt;/span&gt;     geom_vline(xintercept =&lt;span&gt; quantile(loandata$DebtToIncomeRatio, 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                                      probs = 0.95, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&lt;span&gt; TRUE),
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                linetype = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dashed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224105114610-733754002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:95%的借款人负债收入比小于0.5，另外注意到，极少数人的负债收入比达到甚至超过10,总体来说平台的负债收益比较低,资质较好&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.1.8借款人职业&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
data_count &amp;lt;- loandata %&amp;gt;%&lt;span&gt; 
    group_by(Occupation) &lt;/span&gt;%&amp;gt;%&lt;span&gt; 
    summarise(n &lt;/span&gt;=&lt;span&gt; n())

ggplot(aes(x &lt;/span&gt;= reorder(Occupation, -n), y =&lt;span&gt; n),
       data &lt;/span&gt;= data_count) +&lt;span&gt;
    geom_bar(stat &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
    theme(axis.text.x &lt;/span&gt;= element_text(angle = 90&lt;span&gt;,
                                     vjust &lt;/span&gt;= 0.5&lt;span&gt;,
                                     hjust &lt;/span&gt;= 1))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224105406176-2016489045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:职业中，选择“other”的人数最多，说明很多人在申请贷款时出于隐私或者其他原因不选择职业，该数据的真实性存疑&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.1.9贷款状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ggplot(aes(x = LoanStatus), data = loandata) +&lt;span&gt;
    geom_bar()
table(loandata$LoanStatus)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224105544303-1291268802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224105600110-1141698143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:Prosper平台整体贷款的违约率约为16.74%&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.1.10贷款日期&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; loandata$ListingCreationDate &amp;lt;-&lt;span&gt; as.Date(loandata$ListingCreationDate)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; ggplot(aes(x = ListingCreationDate), data = loandata) +
&lt;span&gt;4&lt;/span&gt;     geom_histogram()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224105931080-984650234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:09年前后，平台贷款成交量几乎为0，通过查阅相关资料发现，Prosper平台因涉诉被迫于2008年11月24日暂停运营，并于2009年7月1日重新开始营运。&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.1.11客户信用评价&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; p1 &amp;lt;- ggplot(aes(x = CreditScore), data = loandata) +
&lt;span&gt; 2&lt;/span&gt;     geom_histogram()+
&lt;span&gt; 3&lt;/span&gt;     coord_cartesian(xlim = c(400, 900)) +
&lt;span&gt; 4&lt;/span&gt;     scale_x_continuous(breaks = seq(400, 900, 50)) +
&lt;span&gt; 5&lt;/span&gt;     ggtitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Histogram of Borrowers' CreditScore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; p2 &amp;lt;- ggplot(aes(x =&lt;span&gt; CreditGrade),
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;              data = subset(loandata, LoanOriginationDate &amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) +
&lt;span&gt; 9&lt;/span&gt;     geom_bar() +
&lt;span&gt;10&lt;/span&gt;     scale_x_discrete(limits = c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) +
&lt;span&gt;11&lt;/span&gt;     ggtitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CreditGrade Before 2009&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt; p3 &amp;lt;- ggplot(aes(x =&lt;span&gt; ProsperRating..Alpha.),
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;              data = subset(loandata, LoanOriginationDate &amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) +
&lt;span&gt;15&lt;/span&gt;     geom_bar() +
&lt;span&gt;16&lt;/span&gt;     scale_x_discrete(limits = c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) +
&lt;span&gt;17&lt;/span&gt;     ggtitle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CreditGrade After 2009&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; grid.arrange(p1, p2, p3, ncol = 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224110059593-330396291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:大部分借款人的消费信用评分都高于600分，集中于700分左右，而2009年前后的信用评级也显示出较为优秀的信用资质B级。&lt;br/&gt;　　　　　　　　4.1.12信用卡使用情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;ggplot(aes(BankCardUse), 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        data = subset(loandata, !&lt;span&gt;is&lt;/span&gt;.na(BankcardUtilization))) +
&lt;span&gt;3&lt;/span&gt;     geom_bar()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224110253783-1827392635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:大部分人都处于Super Use状态，借款人的还款能力会因此而打折扣&lt;/p&gt;
&lt;p&gt;　　　　　单变量分析总结论:　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
数据集中共含有113937笔贷款记录，每笔记录均有12个特征描述，分别是：贷款日期（ListingCreationDate）、贷款期限（Term）、贷款状态（LoanStatus）、贷款利率（BorrowerRate）、借款人过去7年违约次数（DelinquenciesLast7Years）、借款人月收入（StatedMonthlyIncome）、借款人是否拥有房屋（IsBorrowerHomeowner）、借款人最近6个月的征信查询次数（InquiriesLast6Months）、借款人负债收入比（DebtToIncomeRatio）、借款人职业（Occupation）、借款人信用评价（CreditScore / CreditGrade /&lt;span&gt; ProsperRating(Alpha)）及借款人的信用卡使用情况（BankCardUse）。

这12个特征中，有4个特征用于描述贷款的特点，包括贷款日期、贷款期限、贷款状态和贷款利率。

有8个特征用于描述借款人主体的特点，包括过去7年违约次数、月收入、是否拥有房屋、最近6个月的征信查询次数、负债收入比、职业、信用评价及信用卡使用情况。

通过上一部分的初步探索，发现以下特点：

&lt;/span&gt;1&lt;span&gt;. 大部分贷款的期限为三年期。

&lt;/span&gt;2. 整个平台贷款的违约率为16.74%&lt;span&gt;。

&lt;/span&gt;3&lt;span&gt;. 大部分贷款利率集中在0.08至0.2这个区间，0.32附近也有较大的成交量。

&lt;/span&gt;4&lt;span&gt;. 平台上的借款人整体信用资质较好。

&lt;/span&gt;5&lt;span&gt;. 从信用卡使用角度来看，借款人的还款压力较大。

&lt;/span&gt;6&lt;span&gt;. 大部分借款人的月收入集中在2500至6000美元之间。

&lt;/span&gt;7&lt;span&gt;. 拥有房屋的借款人与未拥有房屋的借款人数量大致相当。

&lt;/span&gt;8. 出于隐私或者其他原因，借款人申请贷款时职业一项选择“other”的极多。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　4.2双变量探索&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.2.1贷款利率随着时间变化的趋势&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ggplot(aes(x = ListingCreationDate, y = BorrowerRate), data = loandata) +&lt;span&gt;
    geom_point(alpha &lt;/span&gt;= 0.05) +&lt;span&gt;
    facet_wrap(&lt;/span&gt;~Term)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224111014048-1892216781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:一年期与五年期贷款是在2011年前后才上线的产品。三年期是整个平台最主要的贷款,&lt;/p&gt;
&lt;p&gt;　　　　　　　　　   2008年以前，贷款利率主要分布在0.08至0.2这个区间，随着美国次贷危机的持续发酵2010年利率逐渐分化，优质借款人依旧可以拿到0.1甚至更低的利率，而更多的借款人则需要以0.2以上甚至　　　　　　　　　　   0.35的利率方可筹到资金。为了救市美联储实行了量化宽松政策，持续向市场中注入大量流动性，利率承压下行。至2014年，可以看到各个利率层面均有大量的成交记录信贷市场逐渐恢复元气。&lt;/p&gt;
&lt;p&gt; 　　　　　　　　4.2.2贷款利率与贷款状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = LoanStatus, y = BorrowerRate), data = loandata) +
&lt;span&gt;2&lt;/span&gt;     geom_boxplot()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224111428954-766189721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:违约贷款组的利率明显高于正常还款组。一方面，贷款定价高是由于借款人自身资质差；另一方面，高利率又使得借款人更加难以承受进而违约&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.2.3贷款利率与过去7年违约次数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = DelinquenciesLast7Years, y =&lt;span&gt; BorrowerRate), 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        data =&lt;span&gt; subset(loandata, 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                      loandata$DelinquenciesLast7Years &amp;lt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                         quantile(loandata$DelinquenciesLast7Years,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                                   probs = 0.95, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = TRUE))) +
&lt;span&gt;6&lt;/span&gt;     geom_point(alpha = 0.05, position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jitter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +
&lt;span&gt;7&lt;/span&gt;     geom_smooth()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224231115960-302586814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:95%的借款人过去7年违约次数低于23次，违约次数低于3次时，违约次数与贷款利率呈现出弱正相关性；而3次以后两者关系就趋于平稳。&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.2.4贷款利率和借款人月收入的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = StatedMonthlyIncome, y =&lt;span&gt; BorrowerRate), 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        data = subset(loandata, !&lt;span&gt;is&lt;/span&gt;.na(loandata$StatedMonthlyIncome))) +
&lt;span&gt;3&lt;/span&gt;     stat_density2d(aes(alpha = ..density..), geom = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, contour = FALSE) +
&lt;span&gt;4&lt;/span&gt;     scale_x_continuous(limits = c(0, 30000))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224231334383-612747306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:平台的借贷人月收入在10000美金以下,未发现贷款利率和月收入存在关系&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.2.5贷款利率与借款人是否拥有房屋之间的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = BorrowerRate), data = loandata) +
&lt;span&gt;2&lt;/span&gt;     geom_histogram() +
&lt;span&gt;3&lt;/span&gt;     geom_hline(yintercept = 3000, linetype = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dashed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +
&lt;span&gt;4&lt;/span&gt;     facet_wrap(~IsBorrowerHomeowner, ncol = 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224231554243-470657405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:拥有房屋的人比没有房屋的人贷款的利息更低&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.2.6贷款利率与过去6个月征信查询次数的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = as.factor(InquiriesLast6Months), y =&lt;span&gt; BorrowerRate), 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        data = subset(loandata, loandata$InquiriesLast6Months &amp;lt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;                         quantile(loandata$InquiriesLast6Months, 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                                   probs = 0.95, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = TRUE))) +
&lt;span&gt;5&lt;/span&gt;     geom_boxplot() +
&lt;span&gt;6&lt;/span&gt;     xlab(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InquiriesLast6Months&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224231839098-1165709729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:征信查询的次数越多,贷款的利率越高&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.2.7贷款利率和负债收益比的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = DebtToIncomeRatio, y =&lt;span&gt; BorrowerRate), 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        data = subset(loandata, loandata$DebtToIncomeRatio &amp;lt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;                         quantile(loandata$DebtToIncomeRatio, 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                                   probs = 0.95, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;na.rm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = TRUE))) +
&lt;span&gt;5&lt;/span&gt;     geom_point(alpha = 0.05, position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jitter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +
&lt;span&gt;6&lt;/span&gt;     stat_smooth(color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224232113344-709022753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:借款人的收入负债比越高，贷款利率也越高&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.2.8贷款利率和信用评分的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = CreditScore, y = BorrowerRate), data = loandata) +
&lt;span&gt;2&lt;/span&gt;     geom_point(alpha = 0.05) +
&lt;span&gt;3&lt;/span&gt;     facet_wrap(~Phase, ncol = 1) +
&lt;span&gt;4&lt;/span&gt;     coord_cartesian(xlim = c(400, 900), ylim = c(0, 0.4)) +
&lt;span&gt;5&lt;/span&gt;     geom_line(stat = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, fun.y = mean) +
&lt;span&gt;6&lt;/span&gt;     geom_line(stat = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, fun.y = median, linetype = 2, color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +
&lt;span&gt;7&lt;/span&gt;     geom_vline(xintercept = 600, color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224232512609-186746871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:在2009年之前,Prosper还会为消费信用评级低于600分的借款人提供服务,在2009年重新上线之后,不再为评分低于600分的客户服务&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.2.9贷款利率和信用等级的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2009年7月1日以前&lt;/span&gt;
ggplot(aes(x = CreditGrade, y =&lt;span&gt; BorrowerRate), 
       data &lt;/span&gt;= subset(loandata, LoanOriginationDate &amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) +&lt;span&gt;
    scale_x_discrete(limits &lt;/span&gt;= c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) +&lt;span&gt;
    geom_boxplot() &lt;/span&gt;+&lt;span&gt;
    stat_summary(fun.y &lt;/span&gt;= mean, geom = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;point&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, shape = 4) +&lt;span&gt;
    stat_summary(fun.y &lt;/span&gt;= mean, geom = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smooth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, aes(group = 1&lt;span&gt;))


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2009年7月1日以后&lt;/span&gt;
ggplot(aes(x = ProsperRating..Alpha., y =&lt;span&gt; BorrowerRate),
       data &lt;/span&gt;= subset(loandata, LoanOriginationDate &amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) +&lt;span&gt;
    geom_boxplot() &lt;/span&gt;+&lt;span&gt;
    scale_x_discrete(limits &lt;/span&gt;= c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) +&lt;span&gt;
    stat_summary(fun.y &lt;/span&gt;= mean, geom = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;point&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, shape = 4) +&lt;span&gt;
    stat_summary(fun.y &lt;/span&gt;= mean, geom = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smooth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, aes(group = 1))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224232736745-670102419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224232800652-415397301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　　　结论:通过比较2009年7月1日前后贷款利率与借款人信用评级之间的关系发现，2009年7月1日后图形的均值连线明显斜率更大，说明Prosper在涉诉恢复运营后更为重视借款人的信用评级，评级对贷款　　　　　　　　　　  利率的影响权重更大了。&lt;/p&gt;
&lt;p&gt;　　　　　　总结论:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;通过探索贷款利率与其他变量之间的关系，大致得出以下结论：

&lt;/span&gt;1&lt;span&gt;. 贷款利率与过去7年的违约次数、过去6个月征信查询次数及负债收入比呈现出正相关关系。

&lt;/span&gt;2&lt;span&gt;. 贷款利率似乎与借款人的月收入水平关系不明确。

&lt;/span&gt;3&lt;span&gt;. 拥有房屋的借款人相比未拥有房屋的借款人更能够以较低利率筹得资金。

&lt;/span&gt;4. Prosper平台在2009年7月1日后似乎增加了信用评级对贷款利率的影响权重，并且不再对消费信用评分低于600分的借款人提供服务。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　4.3多变量分析&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.3.1贷款日期和贷款利率和贷款状态之间的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = ListingCreationDate, y = BorrowerRate, color = LoanStatus), data = loandata) +
&lt;span&gt;2&lt;/span&gt;     geom_point(alpha = 0.05) +
&lt;span&gt;3&lt;/span&gt;     guides(colour = guide_legend(override.aes = list(alpha = 1, size = 5)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224233236989-499097889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:2009年之前的违约数远大于2009年之后,且利息越高违约率就越大&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.3.2贷款利率与消费信用评分及贷款状态的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ggplot(aes(x = CreditScore, y = BorrowerRate, color =&lt;span&gt; LoanStatus),
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        data = loandata) +
&lt;span&gt;3&lt;/span&gt;     geom_point(alpha = 0.05, position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jitter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +
&lt;span&gt;4&lt;/span&gt;     coord_cartesian(xlim = c(400, 900), ylim = c(0, 0.4)) +
&lt;span&gt;5&lt;/span&gt;     facet_wrap(~Phase, ncol = 1) +
&lt;span&gt;6&lt;/span&gt;     guides(color = guide_legend(override.aes = list(alpha = 1, size = 5)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224233652109-741808690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:在2009年之前的债务违约明显很多,并且是以信用评分较低的且贷款利率较高客户为主,2009年之后平台不再为信用评分低于600的客户提供贷款,贷款的质量有了明显提升&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　也可以看出信用评分越高的客户,贷款的利率越低&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.3.3贷款利率与贷款总额及信用评级的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2009年7月1日之前&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; ggplot(aes(x = LoanOriginalAmount, y = BorrowerRate, color =&lt;span&gt; CreditGrade),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;        data = subset(loandata, LoanOriginationDate &amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp; CreditGrade != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) +
&lt;span&gt; 4&lt;/span&gt;     geom_point(alpha = 0.5, position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jitter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +
&lt;span&gt; 5&lt;/span&gt;     scale_color_brewer(type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seq&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                        guide = guide_legend(title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CreditGrade&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, reverse =&lt;span&gt; F,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                                             override.aes = list(alpha = 1, size = 5))) +
&lt;span&gt; 8&lt;/span&gt;     facet_wrap(~LoanStatus, ncol = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2009年7月1日之后&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; ggplot(aes(x = LoanOriginalAmount, y = BorrowerRate, color =&lt;span&gt; ProsperRating..Alpha.), 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;        data = subset(loandata, LoanOriginationDate &amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;
&lt;span&gt;13&lt;/span&gt;                          !&lt;span&gt;is&lt;/span&gt;.na(ProsperRating..Alpha.))) +
&lt;span&gt;14&lt;/span&gt;     geom_point(alpha = 0.5) +
&lt;span&gt;15&lt;/span&gt;     scale_color_brewer(type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seq&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                        guide = guide_legend(title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProsPerRating&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, reverse =&lt;span&gt; F,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                                             override.aes = list(alpha = 1, size = 5))) +
&lt;span&gt;18&lt;/span&gt;     facet_wrap(~LoanStatus, ncol = 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224234535835-366494312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224234554924-777615773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:在2009年7月1日之后,Prosper将最大的贷款金额有25000提升到了35000,并且只针对信用评级为B以上的客户,随着贷款的金额越高利率在逐渐降低,此外平台的违约贷款都是由HR和E等级的客户导　　　　　　　　　　 致的&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.3.4贷款利率与贷款总额与信用卡使用频率的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2009年7月1日之前&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; ggplot(aes(x = LoanOriginalAmount, y = BorrowerRate, color =&lt;span&gt; BankCardUse),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;        data = subset(loandata, LoanOriginationDate &amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp; 
&lt;span&gt; 4&lt;/span&gt;                          !&lt;span&gt;is&lt;/span&gt;.na(BankCardUse))) +
&lt;span&gt; 5&lt;/span&gt;     geom_point(alpha = 0.5) +
&lt;span&gt; 6&lt;/span&gt;     scale_color_brewer(type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qual&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                        guide = guide_legend(title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BankCardUse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, reverse =&lt;span&gt; T,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                                             override.aes = list(alpha = 1, size = 5))) +
&lt;span&gt; 9&lt;/span&gt;     facet_wrap(~LoanStatus, ncol = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2009年7月1日之后&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; ggplot(aes(x = LoanOriginalAmount, y = BorrowerRate, color =&lt;span&gt; BankCardUse),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;        data = subset(loandata, LoanOriginationDate &amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;
&lt;span&gt;14&lt;/span&gt;                          !&lt;span&gt;is&lt;/span&gt;.na(BankCardUse))) +
&lt;span&gt;15&lt;/span&gt;     geom_point(alpha = 0.5) +
&lt;span&gt;16&lt;/span&gt;     scale_color_brewer(type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                        guide = guide_legend(title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BankCardUse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, reverse =&lt;span&gt; T,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                                             override.aes = list(alpha = 1, size = 5))) +
&lt;span&gt;19&lt;/span&gt;     facet_wrap(~LoanStatus, ncol = 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224235148049-526483412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224235205651-1436523178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　结论:从信用卡的使用情况来看，时间节点前后并无明显变化。但是，违约贷款中，信用卡使用情况为Mild Use的借款人占比极低；相对的，信用卡使用情况为Super Use的客户占比却极高，这也印证了　　　　　　　　　　 前文的判断，信用卡的超额透支会对借款人的还款能力产生较大的负面影响。&lt;/p&gt;
&lt;p&gt;　　　　　　总结论:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;本部分通过分时间节点、分贷款状态更为深入的探索了多重变量之间的关系，发现如下特点：

&lt;/span&gt;1&lt;span&gt;. 2009年以前贷款违约数量明显高于2009年以后的数量，且利率越高，违约率越高！

&lt;/span&gt;2&lt;span&gt;. 消费信用评分越高的借款人，其贷款利率也相对越低。

&lt;/span&gt;3&lt;span&gt;. 2009年以前，Prosper限制了最大借款金额为25000美元，而在2009年以后放宽限制至35000美元，且似乎只针对信用评级B级以上的客户开放申请。并且随着贷款金额的增加，贷款利率在逐渐降低。

&lt;/span&gt;4&lt;span&gt;. 信用评级为“HR”和“E”的借款人在违约组中的比例明显较高。

&lt;/span&gt;5. 信用卡使用情况为Super Use的借款人在违约组中的比例明显较高，使用情况为Mild Use的借款人在违约组中的占比极低。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.拟合因子,验证相关性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2009年7月1日之前&lt;/span&gt;
m1 &amp;lt;- lm(I(BorrowerRate)~&lt;span&gt;I(CreditScore),
         data&lt;/span&gt;=&lt;span&gt;subset(loan_data,
                     loan_data$LoanOriginationDate &lt;/span&gt;&amp;lt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
                      &amp;amp; !&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.na(CreditScore) 
                      &lt;/span&gt;&amp;amp; !&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.na(CreditGrade) 
                      &lt;/span&gt;&amp;amp; !&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.na(LoanOriginalAmount) 
                      &lt;/span&gt;&amp;amp; !&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.na(BankCardUse)))
m2 &lt;/span&gt;&amp;lt;- update(m1,~ . +&lt;span&gt; CreditGrade)
m3 &lt;/span&gt;&amp;lt;- update(m2,~ . +&lt;span&gt; LoanOriginalAmount)
m4 &lt;/span&gt;&amp;lt;- update(m3,~ . +&lt;span&gt; BankCardUse)
mtable(m1,m2,m3,m4)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2009年7月1日之后&lt;/span&gt;
m5 &amp;lt;- lm(I(BorrowerRate)~&lt;span&gt;I(CreditScore),
         data&lt;/span&gt;=&lt;span&gt;subset(loan_data,
                     loan_data$LoanOriginationDate &lt;/span&gt;&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2009-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
                      &amp;amp; !&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.na(CreditScore) 
                      &lt;/span&gt;&amp;amp; !&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.na(ProsperRating..Alpha.) 
                      &lt;/span&gt;&amp;amp; !&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.na(LoanOriginalAmount) 
                      &lt;/span&gt;&amp;amp; !&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.na(BankCardUse)))
m6 &lt;/span&gt;&amp;lt;- update(m5,~ . +&lt;span&gt; ProsperRating..Alpha.)
m7 &lt;/span&gt;&amp;lt;- update(m6,~ . +&lt;span&gt; LoanOriginalAmount)
m8 &lt;/span&gt;&amp;lt;- update(m7,~ . +&lt;span&gt; BankCardUse)
mtable(m5,m6,m7,m8)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180225000628066-1421241447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180225000649971-326397128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:从表上看出2者的P值都是0说明拟合的较好,在2009年7月1日之前的R²是0.5左右,2009年7月1日之后的R²是0.9左右,说明平台降低了对信用评分的权重,加强信用等级的权重&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 16:07:00 +0000</pubDate>
<dc:creator>月上贺兰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luhuajun/p/8468091.html</dc:identifier>
</item>
<item>
<title>Lua内存分析工具 - 李嘉的博客</title>
<link>http://www.cnblogs.com/lijiajia/p/8468054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiajia/p/8468054.html</guid>
<description>&lt;p&gt;最近给公司写了一个lua内存分析工具，可以方便的分析出Lua内存泄露问题（虽然还没正式使用，但我是这样想的，哈哈哈），有图形化界面操作，方便手机端上传快照等功能&lt;/p&gt;
&lt;p&gt;内存分析我是在c语言端写的，也有人写过lua端的分析工具，也蛮好用的，不过lua分析工具本身也会影响到lua的内存占用（尽管用的是弱表缓存的），也会有些不准确。&lt;br/&gt;Lua方案：&lt;a href=&quot;https://github.com/yaukeywang/LuaMemorySnapshotDump&quot; class=&quot;uri&quot;&gt;https://github.com/yaukeywang/LuaMemorySnapshotDump&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后找到了云风大神写的C语言解决方案&lt;br/&gt;&lt;a href=&quot;https://blog.codingnow.com/2012/12/lua_snapshot.html&quot; class=&quot;uri&quot;&gt;https://blog.codingnow.com/2012/12/lua_snapshot.html&lt;/a&gt;&lt;br/&gt;这个库功能颇为简单，简单到连对象引用链都没有，只打印出key名和内存地址&lt;/p&gt;
&lt;p&gt;所以我还是决定自己造轮子改进一下云风大神的方案，也是更进一步的去学习一下lua的c api&lt;/p&gt;
&lt;p&gt;C实现起来比Lua复杂一些&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;因为要操作Lua栈，稍微写错一个栈没对称弹出，就会导致溢出，调试起来非常麻烦&lt;/li&gt;
&lt;li&gt;因为c语言就像一块空地，什么都要自己造，连一些最基本的数据结构，都没有...&lt;/li&gt;
&lt;li&gt;你需要编译成各个平台的库，这个后面会讲到如何跟tolua c编译到一起&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;工具分为2个部分&quot;&gt;工具分为2个部分&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;c库生成快照&lt;/li&gt;
&lt;li&gt;web端接收上传快照，快照分析&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1208599-d7d614881e2c094e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot; alt=&quot;web端图&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;lua中哪些数据类型是需要gc的&quot;&gt;Lua中哪些数据类型是需要GC的？&lt;/h4&gt;
&lt;p&gt;lua源码中定义了这些数据类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
** basic types
*/
#define LUA_TNONE       (-1)

#define LUA_TNIL        0
#define LUA_TBOOLEAN        1
#define LUA_TLIGHTUSERDATA  2
#define LUA_TNUMBER     3
#define LUA_TSTRING     4
#define LUA_TTABLE      5
#define LUA_TFUNCTION       6
#define LUA_TUSERDATA       7
#define LUA_TTHREAD     8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用GCObject的联合体将所有需要进行垃圾回收的数据囊括了进来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
** Union of all collectable objects
*/
union GCObject {
  GCheader gch;
  union TString ts;
  union Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct UpVal uv;
  struct lua_State th;  /* thread */
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是还有一些不需要GC的数据类型，所以又定义了一个Value的联合体&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
** Union of all Lua values
*/
typedef union {
  GCObject *gc;
  void *p;
  lua_Number n;
  int b;
} Value;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以将Lua中所有的数据类型表示出来了，Lua还使用了一个宏来判断哪些数据类型是需要GC的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define iscollectable(o)    (ttype(o) &amp;gt;= LUA_TSTRING)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个我们可以知道，定义在LUA_TSTRING后的数据类型，都需要GC。一共有：LUA_TSTRING、LUA_TTABLE、LUA_TFUNCTION、LUA_TUSERDATA、LUA_TTHREAD&lt;/p&gt;
&lt;p&gt;通过这样的遍历方式，从根节点开始递归整颗GC树&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1208599-593c1511dcaf874e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;遍历方式&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;如何遍历table&quot;&gt;如何遍历table？&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;void mark_object(lua_State *L, const char *desc, struct lua_gc_node *parent)
{
    luaL_checkstack(L, LUA_MINSTACK, NULL);
    int t = lua_type(L, -1);
    switch (t) {
    case LUA_TTABLE:
        mark_table(L, desc, parent);
        break;
    case LUA_TUSERDATA:
        mark_userdata(L, desc, parent);
        break;
    case LUA_TFUNCTION:
        mark_function(L, desc, parent);
        break;
    case LUA_TTHREAD:
        mark_thread(L, desc, parent);
        break;
    default:
        lua_pop(L,1);
        break;
    }
}

void mark_table(lua_State *L, const char *desc, struct lua_gc_node *parent)
{
    const void *p = lua_topointer(L, -1);
    if(p == NULL)
    {
        return;
    }
    if(isMark(p))
    {
        lua_pop(L, 1);
        return;
    }

    struct lua_gc_node *currNode = gen_node(L, p, desc, parent);

    bool weakk = false;
    bool weakv = false;

    if(lua_getmetatable(L, -1))
    {
        lua_pushliteral(L, &quot;__mode&quot;);
        lua_rawget(L, -2);
        if (lua_isstring(L,-1)) 
        {
            const char *mode = lua_tostring(L, -1);
            if (strchr(mode, 'k')) 
            {
                weakk = true;
            }
            if (strchr(mode, 'v')) 
            {
                weakv = true;
            }
        }
        lua_pop(L,1);

        luaL_checkstack(L, LUA_MINSTACK, NULL);
        mark_table(L, &quot;.[metatable]&quot;, currNode);
    }
 
    lua_pushnil(L);
    while (lua_next(L, -2) != 0) 
    {
        if(weakv)
        {
            lua_pop(L, 1);
        }
        else
        {
            char temp[128];
            const char * _key = keystring(L, -2, temp);
            mark_object(L, _key, currNode);
        }
        if(!weakk)
        {
            lua_pushvalue(L,-1);
            mark_object(L, &quot;.[key]&quot;, currNode);
        }
    }
    lua_pop(L, 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;const void *p = lua_topointer(L, -1);&lt;br/&gt;取出栈顶的指针，下面用到指针做key存入一个哈希表里，来标记是否被遍历过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;从metatable中取出__mode，来判断key,value是否为弱引用。如果是弱引用就不需要继续递归了，否则就继续调用mark_object递归&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过lua_next方法可以取出table中的key,value压入栈中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里一定要严谨使用lua_pop(L, 1)管理虚拟栈的平衡，否则栈很快就溢出了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其他的函数可以多查找Lua手册，里面说的很详细，我就不一一列举啦。&lt;/p&gt;
&lt;p&gt;另外在c语言中自己创建的内存，需要手动释放，否则也会有内存溢出问题&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;s = malloc(sizeof(struct lua_gc_node)); 通过malloc开辟内存&lt;br/&gt;free(current_node); 对应使用free释放&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;递归完毕后，输出成Json格式的快照文件，方便Web端操作。&lt;/p&gt;
&lt;h4 id=&quot;web端功能&quot;&gt;Web端功能&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;手机上文件传到PC上不太方便，所以弄了个web端直接接收上传的快照文件&lt;/li&gt;
&lt;li&gt;取补集（可以取出2个快照之间，新创建了哪些东西没释放掉），比如战斗前快照，跟战斗后快照进行取补集，就可以知道战斗内有哪些是没释放的，立马就能查出泄露&lt;/li&gt;
&lt;li&gt;取交集（可以查询常住内存）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上传文件的php代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
  if ($_FILES[&quot;file&quot;][&quot;error&quot;] &amp;gt; 0)
  {
      echo &quot;错误：&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&amp;lt;br&amp;gt;&quot;;
  }
  else
  {
      if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))
      {
          echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; 文件已经存在。 &quot;;
      }
      else
      {
          // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下
          move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]);
          echo &quot;文件存储在: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];
      }
  }
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;如何把我们的代码编译到toluac中&quot;&gt;如何把我们的代码编译到toluac中？&lt;/h4&gt;
&lt;p&gt;在网上搜这方面的资料，找到了之前同事（外号姐夫）写的博客，哈哈&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/5a35602adef8&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/5a35602adef8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;他讲的很清楚，我这里就不写了，可以看这篇文章把环境搭好。&lt;/p&gt;
&lt;p&gt;另外还需要在tolua#中的LuaDLL.cs类里加上一个方法引入我们的库函数&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1208599-d4c191b4c9308d81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在LuaManager.cs中把函数注册进去给lua使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lua.OpenLibs (LuaDLL.luaopen_snapshot37);
lua.LuaSetField(-2, &quot;snapshot37&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在lua代码里，我们就可以通过&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;local snapLib = require &quot;snapshot37&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来引入我们的函数了&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;Lua内存分析工具的一些解决方案&lt;/li&gt;
&lt;li&gt;Lua中各种数据类型是怎么表示的&lt;/li&gt;
&lt;li&gt;遍历GCObject的步骤&lt;/li&gt;
&lt;li&gt;具体的一些LUA C API有不明白的可以多查看Lua官方文档&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文主要介绍了以上内容，欢迎找我一起交流讨论&lt;/p&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.codingnow.com/2012/12/lua_snapshot.html&quot; class=&quot;uri&quot;&gt;https://blog.codingnow.com/2012/12/lua_snapshot.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/yaukey/p/unity_lua_memory_leak_trace.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/yaukey/p/unity_lua_memory_leak_trace.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/5a35602adef8&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/5a35602adef8&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://troydhanson.github.io/uthash&quot; class=&quot;uri&quot;&gt;https://troydhanson.github.io/uthash&lt;/a&gt;&lt;br/&gt;《Lua设计与实现》—— codedump (作者)&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 16:03:00 +0000</pubDate>
<dc:creator>李嘉的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijiajia/p/8468054.html</dc:identifier>
</item>
<item>
<title>当inline元素包裹block元素时会发生什么 - 長风</title>
<link>http://www.cnblogs.com/Kuro-P/p/8468042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kuro-P/p/8468042.html</guid>
<description>&lt;p&gt;经常有图片链接写法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;www.baidu.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;baidu.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击图片自动跳转，不用增加新的点击事件，光标滑过时变成小手等等，这都是a标签的功劳。&lt;/p&gt;
&lt;p&gt;但是inline元素包裹block元素后，inline元素本身是否会变成blcok元素，还有待求证，于是做了如下对比：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这里是块元素&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用于测试（没有包裹 a 标签之前）&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200842/201802/1200842-20180224232010065-473045729.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;猜想一下，被 a 标签包裹之后 ,span 标签是否会和 div 标签处于同一行呢？（div即使设置了宽高也不会触发BFC）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;www.cnblogs.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这里是块元素&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用于测试（已经包裹 a 标签）&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200842/201802/1200842-20180224235045072-1153208851.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显，a 标签包裹block元素后变成了block元素。&lt;/p&gt;

</description>
<pubDate>Sat, 24 Feb 2018 15:54:00 +0000</pubDate>
<dc:creator>長风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Kuro-P/p/8468042.html</dc:identifier>
</item>
<item>
<title>xBIM WeXplorer xViewer 浏览器检查 - 在 水 一 方</title>
<link>http://www.cnblogs.com/w2011/p/8467945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w2011/p/8467945.html</guid>
<description>&lt;h3&gt;目录&lt;/h3&gt;
&lt;h4&gt;    基础&lt;/h4&gt;
&lt;h4&gt;     高级应用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;xBIM 综合使用案例与 ASP.NET MVC 集成（一）&lt;/li&gt;
&lt;li&gt;xBIM 综合使用案例与 ASP.NET MVC 集成（二）&lt;/li&gt;
&lt;li&gt;xBIM 综合使用案例与 ASP.NET MVC 集成（三）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    在之前的博客&lt;a href=&quot;http://www.cnblogs.com/w2011/p/8457805.html&quot; target=&quot;_blank&quot;&gt;xBIM WeXplorer xViewer 基本应用&lt;/a&gt; 我们已经提到，WeXplore不能在所有的浏览器上运行。为了方便简单操作，我们觉得使用最新技术。浏览器应该满足几个先决条件才能运行查看器。请不要放弃检查浏览器，它可以在几年前的电脑上运行Chrome 或者 Mozilla的PC 上运行。并且可以在平板电脑和移动设备上运行。主要的限制是关于在IE11之前不支持WebGLass的IE。为了在开发的过程中方便。查看器具有静态功能来检查其要求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; check &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xViewer.check();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (check.noErrors)
    {
        ...
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实很简单的，只要运行这个静态函数，他会向你报告任何错误和警告。（当然现在一般也不会遇到错误)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello building!&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;css/layout.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/xbim-viewer.debug.bundle.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;canvas &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;viewer&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;500&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; check &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xViewer.check();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (check.noErrors)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; viewer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; xViewer(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;viewer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                viewer.load(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/SampleHouse.wexbim&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                viewer.start();
            }
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果检查浏览器不兼容、可以向用户提供错误报告，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; check &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xViewer.check();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (check.noErrors)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;start animation, listen to events and do all the funny stuff&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; msg &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        msg.innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; check.errors)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; error &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; check.errors[i];
            msg.innerHTML &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div style='color: red;'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; error &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 24 Feb 2018 15:16:00 +0000</pubDate>
<dc:creator>在 水 一 方</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w2011/p/8467945.html</dc:identifier>
</item>
<item>
<title>TensorFlow实战之实现自编码器过程 - 蓝色之旅</title>
<link>http://www.cnblogs.com/georgeli/p/8467831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/georgeli/p/8467831.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt; &lt;span&gt; &lt;span&gt;      &lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;关于本文说明，已同步本人另外一个博客地址位于http://blog.csdn.net/qq_37608890，详见http://blog.csdn.net/qq_37608890/article/details/79352212。&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;      本文根据最近学习TensorFlow书籍网络文章的情况,特将一些学习心得做了总结,详情如下.如有不当之处,请各位大拿多多指点,在此谢过。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;一、相关概念&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;strong&gt;1、稀疏性（Sparsity）及稀疏编码（Sparse Coding）&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;         Sparsity 是当今机器学习领域中的一个重要话题。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;          Sparsity 的最重要的“客户”大概要属 high dimensional data 了吧。现在的机器学习问题中，具有非常高维度的数据随处可见。例如，在文档或图片分类中常用的 bag of words 模型里，如果词典的大小是一百万，那么每个文档将由一百万维的向量来表示。高维度带来的的一个问题就是计算量：在一百万维的空间中，即使计算向量的内积这样的基本操作也会是非常费力的。不过，如果向量是稀疏的的话（事实上在 bag of words 模型中文档向量通常都是非常稀疏的），例如两个向量分别只有L1 和 L2 个非零元素，那么计算内积可以只使用min(L1,L2) 次乘法完成。因此稀疏性对于解决高维度数据的计算量问题是非常有效的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;          稀疏编码(Sparse Coding)算法是一种无监督学习方法，它用来寻找一组“超完备”基向量来更高效地表示样本数据。稀疏编码算法的目的就是找到一组基向量 &lt;img src=&quot;http://img.blog.csdn.net/20180223130625593&quot; alt=&quot;&quot;/&gt;，使得我们能将输入向量&lt;img src=&quot;http://img.blog.csdn.net/20180223130636249&quot; alt=&quot;&quot;/&gt; 表示为这些基向量的线性组合：&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180223130647735&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;       虽然形如主成分分析技术（PCA）能使我们方便地找到一组“完备”基向量，但是这里我们想要做的是找到一组“超完备”基向量来表示输入向量&lt;img src=&quot;http://img.blog.csdn.net/20180223130845723&quot; alt=&quot;&quot;/&gt;（也就是说，k &amp;gt; n）。超完备基的好处是它们能更有效地找出隐含在输入数据内部的结构与模式。然而，对于超完备基来说，系数 ai 不再由输入向量&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180223130636249&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 唯一确定。因此，在稀疏编码算法中，我们另加了一个评判标准“稀疏性”来解决因超完备而导致的退化（degeneracy）问题。要求系数 ai 是稀疏的意思就是说：对于一组输入向量，我们只想有尽可能少的几个系数远大于零。选择使用具有稀疏性的分量来表示我们的输入数据是有原因的，因为绝大多数的感官数据，比如自然图像，可以被表示成少量基本元素的叠加，在图像中这些基本元素可以是面或者线。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         在早期，学者们研究稀疏编码（Sparse Coding）时，搜集了大量黑白风景照片，且从中提取了16像素*16像素的图片碎片。结果发现：几乎所有的图像碎片都可以用64种正交的边组合得到，且组合出一张图像碎片需要的边的数量是很少的，即稀疏的。学者们同时也发现，声音其实也存在这种情况，他们从大量的未标注的音频中发现了20种基本结构，绝大多数声音可以由这些基本结构线性组合得到。显然，这就是特征的稀疏表达，使用少量的基本特征组合拼装得到更高层抽象的特征。一般情况想，我们也需要多层的神经网络，对每一层神经网络而言，前一层的输出都是未加工的像素，而这一层则是对像素进行加工组织成更高阶的特征。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、自编码（AutoEncoder）&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;         顾名思义，即可以使用自身的高阶特征编码自己。自编码器其实也是一种神经网络，它的输入和输出是一致的，它借助稀疏编码的思想，目标是使用稀疏的一些高阶特征重新组合来重构自己，即 ：对所有的自编码器来讲，目标都是样本重构。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;         在机器学习中，自编码器的使用十分广泛。自编码器首先通过编码层，将高维空间的向量，压缩成低维的向量（潜在变量），然后通过解码层将低维向量解压重构出原始样本&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、隐含层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        指输入层和输出层以外，中间的那些层。输入层和输出层是可见的，且层的结构是相对固定的，而隐含层结构不固定，相当于不可见。只要隐含的节点足够多，即是只有一个隐含层的神经网络也可以拟合任意函数。隐含层层数越多，越容易拟合复杂的函数。拟合复杂函数需要的隐含节点数目随着层数的增多而呈指数下降。即层数越深，概念越抽象，这就是深度学习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、过拟合&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      指模型预测准确率在训练集上升高，但在测试集上反而下降。这是模型的泛化性不好，只记住了当前数据的特征。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、Dropout&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       Dropout:防止过拟合的一种方法。将神经网络某一层的输出节点数据随机丢弃一部分。可以理解为是对特征的采样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、优化函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        优化调试网络中的参数。一般情况下，在调参时，学习率的设置会导致最后结果差异很大。神经网络通常不是凸优化，充满局部最优，但是神经网络可能有很多个局部最优都能达到良好效果，反而全局最优容易出现过拟合。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       对于SGD，通常一开始学习率大一些，可以快速收敛，但是训练的后期，希望学习率可以小一些，可以比较稳定地落到一个局部最优解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        除SGD之外，还有自适应调节学习率的Adagrad、Adam、Adadelta等优化函数&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7、激活函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Sigmoid函数的输出在（0,1），最符合概率输出的定义，但局限性较大。&lt;br/&gt;ReLU,当x&amp;lt;=0时，y=0；当x&amp;gt;0时，y=x。这非常类似于人类的阈值响应机制。ReLU的3个显著特点：单侧抑制；相对宽阔的兴奋边界；稀疏激活性。它是目前最符合实际神经元的模型。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;二、自解码器算法原理     &lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、BacsicAuto-Encoder&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;         Auto-Encoder(AE)是20世纪80年代晚期提出的，简单讲，AE可以被视为一个三层神经网络结构：一个输入层、一个隐藏层和一个输出层，从数据规模上讲，输入层与输出层具有相同的规模。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-cn&quot;&gt;             &lt;img src=&quot;http://img.blog.csdn.net/20180224204452857&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;                             图1  Auto-Encoder网络结构示意图&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;     其中，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;n&lt;span lang=&quot;zh-cn&quot;&gt;表示输入层（同时也是作为输出层）的规模；m&lt;span lang=&quot;zh-cn&quot;&gt;表示隐藏层的规模；&lt;img src=&quot;http://img.blog.csdn.net/20180224205033962&quot; alt=&quot;&quot;/&gt;，&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;分别表示输出层、隐藏层和输出层上的向量，也是各层上对应的数据个数，这里隐藏层h&lt;span lang=&quot;zh-cn&quot;&gt;的数据低于输入层和输出层的数据，即x&amp;gt;h&amp;lt;y&lt;span lang=&quot;zh-cn&quot;&gt;且x=y&lt;span lang=&quot;zh-cn&quot;&gt;。根据输入层x&lt;span lang=&quot;zh-cn&quot;&gt;到隐藏层h&lt;span lang=&quot;zh-cn&quot;&gt;的映射矩阵求出h&lt;span lang=&quot;zh-cn&quot;&gt;，再根据隐藏层h&lt;span lang=&quot;zh-cn&quot;&gt;到输出层的映射矩阵求出y。&lt;img src=&quot;http://img.blog.csdn.net/20180224205122114&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;分别表示隐藏层和输出层上的偏置&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;向量。&lt;img src=&quot;http://img.blog.csdn.net/20180224205203602&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;表示输入层与隐藏层之间的权值矩阵，即x&lt;span lang=&quot;zh-cn&quot;&gt;到h&lt;span lang=&quot;zh-cn&quot;&gt;的映射矩阵，是n&lt;span lang=&quot;zh-cn&quot;&gt;乘m&lt;span lang=&quot;zh-cn&quot;&gt;阶矩阵；&lt;img src=&quot;http://img.blog.csdn.net/2018022420524792&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;表示隐藏层与输出层之间的权值矩阵，即h&lt;span lang=&quot;zh-cn&quot;&gt;到y&lt;span lang=&quot;zh-cn&quot;&gt;的映射矩阵，是m&lt;span lang=&quot;zh-cn&quot;&gt;乘n&lt;span lang=&quot;zh-cn&quot;&gt;阶矩阵，也是W&lt;span lang=&quot;zh-cn&quot;&gt;的逆&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;矩阵。&lt;span lang=&quot;zh-cn&quot;&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;   针对AE而言，重要的是解决好矩阵W问题，一个好的矩阵W可以保证x完全等于y，可实际上很难，尤其当输入层x的数据量大成千上百个时，x和y的差别就可以说明矩阵W的优良程度。总之，我们的工作就是要求出矩阵W，并使得x和y之间的差异尽可能小。下面给出下图，进一步做出解释&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-cn&quot;&gt;     &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;                  &lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224205351622&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;                        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                         &lt;span&gt;图2 Auto-Encoder抽象结构 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;如图2所示，AE由编码器（Enconder）和解码器（Decoder）两部分构成。显然，从输入层到隐藏层属于编码过程，从隐藏层到输出层属于解码过程。我们设定f和g分别表示编码和解码函数，结合上面的内容，我们可以给出f和g的方程，如下(1.1)和(1.2)式所示&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;                  &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224205555754&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       其中 &lt;img src=&quot;http://img.blog.csdn.net/2018022420563142&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;为编码器的激活函数，通常情况下取Sigmoid&lt;span lang=&quot;zh-cn&quot;&gt;函数，即 &lt;img src=&quot;http://img.blog.csdn.net/20180224205655758&quot; alt=&quot;&quot;/&gt;；&lt;img src=&quot;http://img.blog.csdn.net/2018022420572379&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;为解码器的激活函数，一般取Sigmoid&lt;span lang=&quot;zh-cn&quot;&gt;函数或恒等函数，即&lt;img src=&quot;http://img.blog.csdn.net/2018022420574696&quot; alt=&quot;&quot;/&gt;。权值矩阵&lt;img src=&quot;http://img.blog.csdn.net/20180224205817657&quot; alt=&quot;&quot;/&gt;一般取&lt;img src=&quot;http://img.blog.csdn.net/20180224205829436&quot; alt=&quot;&quot;/&gt;，&lt;span lang=&quot;zh-cn&quot;&gt;一些文献资料中提及称，这种情况下的AE&lt;span lang=&quot;zh-cn&quot;&gt;具有tiedweights&lt;span lang=&quot;zh-cn&quot;&gt;。本文指讨论二者相等的情况。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       所以，&lt;span lang=&quot;zh-cn&quot;&gt;截止目前，我们可知，AE&lt;span lang=&quot;zh-cn&quot;&gt;的参数为 &lt;img src=&quot;http://img.blog.csdn.net/20180224210005655&quot; alt=&quot;&quot;/&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;         假设目前我们有一个训练集&lt;/span&gt;&lt;/span&gt;&lt;span&gt;S=&lt;img src=&quot;http://img.blog.csdn.net/20180224210040279&quot; alt=&quot;&quot;/&gt;，&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;那么我们要考虑的问题是如何利用S&lt;span lang=&quot;zh-cn&quot;&gt;取&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;训练&lt;img src=&quot;http://img.blog.csdn.net/20180224210112771&quot; alt=&quot;&quot;/&gt;，首先是建立一个训练目标。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;       结合前面的梳理，我们可知，AE可以被看成一个普通的三层神经网络，y也可以看成由x做的一个预测（prediction），且保证x和y尽可能接近，这种接近程度可以通过重构误差（reconstruction error）函数L（x，y）来进行表达。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;    根据解码器激活函数&lt;img src=&quot;http://img.blog.csdn.net/20180224210456815&quot; alt=&quot;&quot;/&gt;的不同，这里L（x,y)一般有两种取值方法：&lt;br/&gt;             第一种，当&lt;img src=&quot;http://img.blog.csdn.net/20180224210518463&quot; alt=&quot;&quot;/&gt;为恒等函数时，取平方误差（sequared error）函数&lt;img src=&quot;http://img.blog.csdn.net/20180224210603953&quot; alt=&quot;&quot;/&gt;。&lt;br/&gt;     第二种，当 &lt;img src=&quot;http://img.blog.csdn.net/20180224210518463&quot; alt=&quot;&quot;/&gt;为sigmoid函数（此种情况输入&lt;img src=&quot;http://img.blog.csdn.net/20180224210654305&quot; alt=&quot;&quot;/&gt;）时，取交叉熵（cross-entropy）函数&lt;img src=&quot;http://img.blog.csdn.net/20180224210816895&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;    取得重构函数后，我们就可以对数据集S进行针对性的训练，去得到一个整体的损失函数（loss function）（1.5）&lt;br/&gt;                                 &lt;img src=&quot;http://img.blog.csdn.net/20180224210921163&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        将上面这个函数（1.5）进行极小化处理，我们就可以得到所需的参数&lt;img src=&quot;http://img.blog.csdn.net/20180224211016808&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        注意，一般文献中损失函数多数使用的是平均重构误差（average reconstruction error)，即下面函数（1.6）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;                         &lt;img src=&quot;http://img.blog.csdn.net/20180224211049914&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;         对于一个给定的训练集S而言，系数1/N并不对于上面这个损失函数最小化产生多大的影响，所以，为了简便，这里忽略这个系数。&lt;/p&gt;&lt;p&gt;    最开始，AE只是作为一种降维技巧来使用的，视隐藏层h为x的一种降维表示，也要求m&amp;lt;n（h&amp;lt;x）。但是，目前来看，AE在m&amp;gt;=n的情况（有些文献中称为 over-complete setting）下应用更多,以便获取更高维数更有意义的表达方式。当然，在次情况下，也会有一个问题不可忽略：若直接对损失函数（1.5）进行极小化的而没有加入任何其他限制条件的话，AE在这里学到的很可能是一个恒等函数（where the auto-encoder could perfectly reconstruction the input without needing to extract any useful feature），这种结果是不符合预期的。需要解决，例如  ， 在损失函数中加入稀疏性限制（Sparse Auto-Encoder），或在网络中引入随机性（如RBN，Denoising Auto-Encoder）等。&lt;br/&gt;    下面先介绍 Regularized Auto-Encoer 和Sparse Auto-Encoder，其余的AE变种算法，后续有机会继续梳理。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt; &lt;span&gt;&lt;strong&gt;2、 Regularized Auto-Encoder&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;         我们在损失函数（1.5）中加入正则项，便可以得到所谓的Regularized Auto-Encoder。 常见的正则化有L1 正则和 L2正则。以L2正则为例进行介绍，损失  函数则变为如下（2.7）：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;                        &lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211213129&quot; alt=&quot;&quot;/&gt;        &lt;br/&gt;      其中 &lt;img src=&quot;http://img.blog.csdn.net/20180224211305257&quot; alt=&quot;&quot;/&gt;     为权值矩阵W的元素。&lt;br/&gt;公式（2.7）中的&lt;img src=&quot;http://img.blog.csdn.net/20180224211335477&quot; alt=&quot;&quot;/&gt;即为L2正则项，也叫做权重衰减（weight-decay）项（&lt;img src=&quot;http://img.blog.csdn.net/20180224211402618&quot; alt=&quot;&quot;/&gt;下标中的&lt;img src=&quot;http://img.blog.csdn.net/20180224211416110&quot; alt=&quot;&quot;/&gt; 就是weight-decay的意思），lambda为权重衰减参数，用来控制公式中两项的相对重要性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、Sparse Auto-Encoder&lt;/strong&gt;&lt;br/&gt;         由公式（2.7）可以看出，权重衰减项实际上是对权重提出一些要求，也就是要求它们不能过大，否则会被惩罚。这里所讲的Sparse Auto-Encoder 是对隐藏层上神经元的激活度提出要求，使其满足一定的稀疏性。&lt;br/&gt;        关于隐藏层上神经元激活度如何刻画的问题，下面展开来看：&lt;br/&gt;            假设&lt;img src=&quot;http://img.blog.csdn.net/20180224211446567&quot; alt=&quot;&quot;/&gt;表示输入为x时，隐藏层上第j个神经元的激活度（&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211446567&quot; alt=&quot;&quot;/&gt;  是（1.1）中向量h的第j个分量），则（3.8）&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211524286&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;         表示隐藏层上第j个神经元在训练集 &lt;img src=&quot;http://img.blog.csdn.net/20180224211554424&quot; alt=&quot;&quot;/&gt;上的平均激活度。为了保证隐藏层上的神经元大部分时间被抑制为零或者接近于零（即稀疏性限制），这里要求（3.9）&lt;img src=&quot;http://img.blog.csdn.net/2018022421161515&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;其中，&lt;img src=&quot;http://img.blog.csdn.net/20180224211643482&quot; alt=&quot;&quot;/&gt;为稀疏性参数，一般情况下取一个很小的数（如   &lt;img src=&quot;http://img.blog.csdn.net/20180224211720594&quot; alt=&quot;&quot;/&gt;）。对于那些与&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211643482&quot; alt=&quot;&quot;/&gt;有显著不同的&lt;img src=&quot;http://img.blog.csdn.net/2018022421174477&quot; alt=&quot;&quot;/&gt;，会进行惩罚。这个限制方法的实现有多种，这里以一种基于KL divergence的方法，即引入（3.10） &lt;img src=&quot;http://img.blog.csdn.net/20180224211808841&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;其中，（3.11）&lt;img src=&quot;http://img.blog.csdn.net/20180224211918498&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;函数 &lt;img src=&quot;http://img.blog.csdn.net/20180224211941978&quot; alt=&quot;&quot;/&gt;具有如下性质：&lt;br/&gt;      随着&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/2018022421174477&quot; alt=&quot;&quot;/&gt;和   &lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211643482&quot; alt=&quot;&quot;/&gt;之间的差异增大而单调递增，尤其当 &lt;img src=&quot;http://img.blog.csdn.net/20180224212107723&quot; alt=&quot;&quot;/&gt;时，存在&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224212042114&quot; alt=&quot;&quot;/&gt;达到最小值。所以，如果将（3.10）加入到损失函数里，则最小化损失函数即可达到使得&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/2018022421174477&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;尽可能靠近 &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224211643482&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的效果。这样来看，Sparse Auto-Encoder的损失函数就可以表达为（3.12）&lt;br/&gt;                           &lt;span lang=&quot;zh-cn&quot;&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180224212203293&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;         这里beta为控制稀疏性惩罚项的权重系数。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;        我们也可以将L2正则和稀疏性限制结合起来使用，这时的损失函数也就变为（3.13）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                     &lt;img src=&quot;http://img.blog.csdn.net/2018022421230530&quot; alt=&quot;&quot;/&gt;&lt;span lang=&quot;zh-cn&quot;&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;三、实现去噪自编码器过程&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;1、代码实现过程如下&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;91&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 这里以最具代表性的去噪自编码器为例。

#导入MNIST数据集

import numpy as np

import sklearn.preprocessing as prep

import tensorflow as tf

from tensorflow.examples.tutorials.mnist import input_data


#这里使用一种参数初始化方法xavier initialization，需要对此做好定义工作。

#Xaiver初始化器的作用就是让权重大小正好合适。

#这里实现的是标准均匀分布的Xaiver初始化器。

def xavier_init(fan_in, fan_out, constant = 1):

&quot;&quot;&quot;

目的是合理初始化权重。

参数：

fan_in --行数；

fan_out -- 列数；

constant --常数权重，条件初始化范围的倍数。

return 初始化后的权重tensor.

&quot;&quot;&quot;

low = -constant * np.sqrt(6.0 / (fan_in + fan_out))

high = constant * np.sqrt(6.0 / (fan_in + fan_out))

return tf.random_uniform((fan_in, fan_out),

minval = low, maxval = high,

dtype = tf.float32)


#定义一个去噪的自编码类

class AdditiveGaussianNoiseAutoencoder(object):

&quot;&quot;&quot;

__init__() :构建函数；

n_input : 输入变量数；

n_hidden : 隐含层节点数；

transfer_function: 隐含层激活函数，默认是softplus；

optimizer : 优化器，默认是Adam;

scale : 高斯噪声系数，默认是0.1；

&quot;&quot;&quot;

def __init__(self, n_input, n_hidden, transfer_function =tf.nn.softplus, optimizer = tf.train.AdamOptimizer(),

scale = 0.1):

self.n_input = n_input

self.n_hidden = n_hidden

self.transfer = transfer_function

self.scale = tf.placeholder(tf.float32)

self.training_scale = scale

network_weights = self._initialize_weights()

self.weights = network_weights


# 定义网络结构，为输入x创建一个维度为n_input的placeholder，然后

#建立一个能提取特征的隐含层。

self.x = tf.placeholder(tf.float32, [None, self.n_input])

self.hidden = self.transfer(tf.add(tf.matmul(self.x +scale * tf.random_normal((n_input,)),

self.weights['w1']),

self.weights['b1']))

self.reconstruction = tf.add(tf.matmul(self.hidden,self.weights['w2']), self.weights['b2'])


#首先，定义自编码器的损失函数，在此直接使用平方误差(SquaredError)作为cost。

#然后，定义训练操作作为优化器self.optimizer对损失self.cost进行优化。

#最后，创建Session，并初始化自编码器全部模型参数。

self.cost = 0.5 *tf.reduce_sum(tf.pow(tf.subtract(self.reconstruction, self.x), 2.0))

self.optimizer = optimizer.minimize(self.cost)


init = tf.global_variables_initializer()

self.sess = tf.Session()

self.sess.run(init)


def _initialize_weights(self):

all_weights = dict()

all_weights['w1'] = tf.Variable(xavier_init(self.n_input,self.n_hidden))

all_weights['b1'] = tf.Variable(tf.zeros([self.n_hidden],dtype = tf.float32))

all_weights['w2'] = tf.Variable(tf.zeros([self.n_hidden,self.n_input], dtype = tf.float32))

all_weights['b2'] = tf.Variable(tf.zeros([self.n_input],dtype = tf.float32))

return all_weights


def partial_fit(self, X):

cost, opt = self.sess.run((self.cost, self.optimizer),feed_dict = {self.x: X,

self.scale: self.training_scale})

return cost


def calc_total_cost(self, X):

return self.sess.run(self.cost, feed_dict = {self.x: X,

self.scale:self.training_scale})

#定义一个transform函数，以便返回自编码器隐含层的输出结果，目的是提供一个接口来获取抽象后的特征。

def transform(self, X):

return self.sess.run(self.hidden, feed_dict = {self.x: X,

self.scale:self.training_scale})


def generate(self, hidden = None):

if hidden is None:

hidden = np.random.normal(size = self.weights[&quot;b1&quot;])

return self.sess.run(self.reconstruction, feed_dict ={self.hidden: hidden})

def reconstruct(self, X):

return self.sess.run(self.reconstruction, feed_dict ={self.x: X,

self.scale: self.training_scale})


def getWeights(self): #获取隐含层的权重w1.

return self.sess.run(self.weights['w1'])


def getBiases(self): #获取隐含层的偏执系数b1.

return self.sess.run(self.weights['b1'])

#利用TensorFlow提供的读取示例数据的函数载入MNIST数据集。

mnist = input_data.read_data_sets('MNIST_data', one_hot = True)

#定义一个对训练、测试数据进行标准化处理的函数。

def standard_scale(X_train, X_test):

preprocessor = prep.StandardScaler().fit(X_train)

X_train = preprocessor.transform(X_train)

X_test = preprocessor.transform(X_test)

return X_train, X_test


def get_random_block_from_data(data, batch_size):

start_index = np.random.randint(0, len(data) - batch_size)

return data[start_index:(start_index + batch_size)]


X_train, X_test = standard_scale(mnist.train.images,mnist.test.images)


n_samples = int(mnist.train.num_examples)

training_epochs = 20

batch_size = 128

display_step = 1

autoencoder = AdditiveGaussianNoiseAutoencoder(n_input = 784,

n_hidden = 200,

transfer_function =tf.nn.softplus,

optimizer =tf.train.AdamOptimizer(learning_rate = 0.001),

scale = 0.01)

for epoch in range(training_epochs):

avg_cost = 0.

total_batch = int(n_samples / batch_size)

# Loop over all batches

for i in range(total_batch):

batch_xs = get_random_block_from_data(X_train, batch_size)


# Fit training using batch data

cost = autoencoder.partial_fit(batch_xs)

# Compute average loss

avg_cost += cost / n_samples * batch_size

# Display logs per epoch step

if epoch % display_step == 0:

print(&quot;Epoch:&quot;, '%04d' % (epoch + 1), &quot;cost=&quot;,&quot;{:.9f}&quot;.format(avg_cost))

#最后对训练完的模型进行性能测试。

print(&quot;Total cost: &quot; +str(autoencoder.calc_total_cost(X_test)))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、执行结果如下&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
Extracting MNIST_data/train-images-idx3-ubyte.gz
Extracting MNIST_data/train-labels-idx1-ubyte.gz
Extracting MNIST_data/t10k-images-idx3-ubyte.gz
Extracting MNIST_data/t10k-labels-idx1-ubyte.gz
Epoch: 0001 cost= 18871.253996591
Epoch: 0002 cost= 12308.673515909
Epoch: 0003 cost= 10227.495348864
Epoch: 0004 cost= 11243.596613636
Epoch: 0005 cost= 10782.029647727
Epoch: 0006 cost= 9165.328120455
Epoch: 0007 cost= 8487.490198295
Epoch: 0008 cost= 9195.667004545
Epoch: 0009 cost= 9026.087407955
Epoch: 0010 cost= 8301.502948295
Epoch: 0011 cost= 9921.268600568
Epoch: 0012 cost= 8789.966229545
Epoch: 0013 cost= 9115.636243182
Epoch: 0014 cost= 8993.681156818
Epoch: 0015 cost= 7670.030270455
Epoch: 0016 cost= 8108.834190341
Epoch: 0017 cost= 7897.135417045
Epoch: 0018 cost= 8332.914957955
Epoch: 0019 cost= 8091.132888068
Epoch: 0020 cost= 7822.976949432
Total cost: 725054.5
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、小结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    &lt;br/&gt;           至此，我们可以发现，从实现的角度而言，自编码器其实和一个单隐含层的神经网络差不多，只是自编码器在数据输入时做了标准化处理，且加上了一个高斯噪声，同时我们的输出结果不是数字分类结果，而是复原的数据，因此不需要用标注过的数据进行监督训练。自编码器作为一种无监督学习方法，它与其他无监督学习的区别主要在于：它不是对数据进行聚类，而是把数据中最有用、最频繁的高阶特征提取出来，然后根据这些高阶特征进行重构数据。在深度学习发展早期非常流行的DBN，也是依靠这种思想，先对数据进行无监督学习，提取到一些有用的特征，将神经网络权重初始化到一个较好的分布，然后再使用有标注的数据进行监督训练，即对权重进行fine-tune。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         现实生活中，大部分数据是没有标准信息的，但人脑比较擅长处理这些数据，会提取出其中的高阶抽象特征，并使用在别的地方。自编码器作为深度学习在无监督领域的应用的确非常成功，同时无监督学习也将成为深度学习一个重要发展方向。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考资料   &lt;strong&gt;主要参考资料《TensorFlow实战》（黄文坚  唐源 著）（电子工业出版社）&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;



</description>
<pubDate>Sat, 24 Feb 2018 14:07:00 +0000</pubDate>
<dc:creator>蓝色之旅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/georgeli/p/8467831.html</dc:identifier>
</item>
<item>
<title>【深度学习】常用的模型评估指标 - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8467613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8467613.html</guid>
<description>&lt;p&gt;“没有测量，就没有科学。”这是科学家门捷列夫的名言。在计算机科学中，特别是在机器学习的领域，对模型的测量和评估同样至关重要。只有选择与问题相匹配的评估方法，我们才能够快速的发现在模型选择和训练过程中可能出现的问题，迭代地对模型进行优化。本文将总结机器学习最常见的模型评估指标，其中包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;precision&lt;/li&gt;
&lt;li&gt;recall&lt;/li&gt;
&lt;li&gt;F1-score&lt;/li&gt;
&lt;li&gt;PRC&lt;/li&gt;
&lt;li&gt;ROC和AUC&lt;/li&gt;
&lt;li&gt;IOU&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;从混淆矩阵谈起&quot;&gt;从混淆矩阵谈起&lt;/h2&gt;
&lt;p&gt;看一看下面这个例子：假定瓜农拉来一车西瓜，我们用训练好的模型对这些西瓜进行判别，显然我们可以使用错误率来衡量有多少比例的瓜被判别错误。但如果我们关心的是“挑出的西瓜中有多少比例是好瓜”，或者“所有好瓜中有多少比例被挑出来了”，那么错误率显然就不够用了，这时我们需要引入新的评估指标，比如“查准率”和查全率更适合此类需求的性能度量。&lt;/p&gt;
&lt;p&gt;在引入查全率和查准率之前我们必须先理解到什么是混淆矩阵（Confusion matrix）。这个名字起得是真的好，初学者很容易被这个矩阵搞得晕头转向。下图a就是有名的混淆矩阵，而下图b则是由混淆矩阵推出的一些有名的评估指标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204329655-1160264310.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们首先好好解读一下混淆矩阵里的一些名词和其意思。根据混淆矩阵我们可以得到TP,FN,FP,TN四个值，显然TP+FP+TN+FN=样本总数。这四个值中都带两个字母，单纯记忆这四种情况很难记得牢，我们可以这样理解：第一个字母表示本次预测的正确性，T就是正确，F就是错误；第二个字母则表示由分类器预测的类别，P代表预测为正例，N代表预测为反例。比如TP我们就可以理解为分类器预测为正例（P），而且这次预测是对的（T），FN可以理解为分类器的预测是反例（N），而且这次预测是错误的（F），正确结果是正例，即一个正样本被错误预测为负样本。我们使用以上的理解方式来记住TP、FP、TN、FN的意思应该就不再困难了。，下面对混淆矩阵的四个值进行总结性讲解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;True Positive （真正，TP）被模型预测为正的正样本&lt;/li&gt;
&lt;li&gt;True Negative（真负 , TN）被模型预测为负的负样本&lt;/li&gt;
&lt;li&gt;False Positive （假正, FP）被模型预测为正的负样本&lt;/li&gt;
&lt;li&gt;False Negative（假负 , FN）被模型预测为负的正样本&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;precisionrecallprcf1-score&quot;&gt;Precision、Recall、PRC、F1-score&lt;/h2&gt;
&lt;p&gt;Precision指标在中文里可以称为查准率或者是精确率，Recall指标在中卫里常被称为查全率或者是召回率，查准率 P和查全率 R分别定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224205202185-367942820.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查准率P和查全率R的具体含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查准率(Precision）是指在所有系统判定的“真”的样本中，确实是真的的占比&lt;/li&gt;
&lt;li&gt;查全率（Recall）是指在所有确实为真的样本中，被判为的“真”的占比&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里想强调一点，precision和accuracy（正确率）不一样的，accuracy针对所有样本，precision针对部分样本，即正确的预测/总的正反例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224205007882-641098274.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查准率和查全率是一对矛盾的度量，一般而言，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。我们从直观理解确实如此：我们如果希望好瓜尽可能多地选出来，则可以通过增加选瓜的数量来实现，如果将所有瓜都选上了，那么所有好瓜也必然被选上，但是这样查准率就会越低；若希望选出的瓜中好瓜的比例尽可能高，则只选最有把握的瓜，但这样难免会漏掉不少好瓜，导致查全率较低。通常只有在一些简单任务中，才可能使查全率和查准率都很高。&lt;/p&gt;
&lt;p&gt;再说PRC， 其全称就是Precision Recall Curve，它以查准率为Y轴，、查全率为X轴做的图。它是综合评价整体结果的评估指标。所以，哪总类型（正或者负）样本多，权重就大。也就是通常说的『对样本不均衡敏感』，『容易被多的样品带走』。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204341976-647484907.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图就是一幅P-R图，它能直观地显示出学习器在样本总体上的查全率和查准率，显然它是一条总体趋势是递减的曲线。在进行比较时，若一个学习器的PR曲线被另一个学习器的曲线完全包住，则可断言后者的性能优于前者，比如上图中A优于C。但是B和A谁更好呢？因为AB两条曲线交叉了，所以很难比较，这时比较合理的判据就是比较PR曲线下的面积，该指标在一定程度上表征了学习器在查准率和查全率上取得相对“双高”的比例。因为这个值不容易估算，所以人们引入“平衡点”(BEP)来度量，他表示“查准率=查全率”时的取值，值越大表明分类器性能越好，以此比较我们一下子就能判断A较B好。&lt;/p&gt;
&lt;p&gt;BEP还是有点简化了，更常用的是F1度量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224205027586-434414606.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;F1-score 就是一个综合考虑precision和recall的指标，比BEP更为常用。&lt;/p&gt;
&lt;h2 id=&quot;roc-auc&quot;&gt;ROC &amp;amp; AUC&lt;/h2&gt;
&lt;p&gt;ROC全称是“受试者工作特征”（Receiver Operating Characteristic）曲线，ROC曲线以“真正例率”（TPR）为Y轴，以“假正例率”（FPR）为X轴，对角线对应于“随机猜测”模型，而（0,1）则对应“理想模型”。ROC形式如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204355006-1724131879.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TPR和FPR的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224205043320-355960721.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从形式上看TPR就是我们上面提到的查全率Recall，而FPR的含义就是：所有确实为“假”的样本中，被误判真的样本。&lt;/p&gt;
&lt;p&gt;进行学习器比较时，与PR图相似，若一个学习器的ROC曲线被另一个学习器的曲线包住，那么我们可以断言后者性能优于前者；若两个学习器的ROC曲线发生交叉，则难以一般性断言两者孰优孰劣。此时若要进行比较，那么可以比较ROC曲线下的面积，即AUC，面积大的曲线对应的分类器性能更好。&lt;/p&gt;
&lt;p&gt;AUC（Area Under Curve）的值为ROC曲线下面的面积，若分类器的性能极好，则AUC为1。但现实生活中尤其是工业界不会有如此完美的模型，一般AUC均在0.5到1之间，AUC越高，模型的区分能力越好，上图AUC为0.81。若AUC=0.5，即与上图中红线重合，表示模型的区分能力与随机猜测没有差别。若AUC真的小于0.5，请检查一下是不是好坏标签标反了，或者是模型真的很差。&lt;/p&gt;
&lt;h2 id=&quot;怎么选择评估指标&quot;&gt;怎么选择评估指标？&lt;/h2&gt;
&lt;p&gt;这种问题的答案当然是具体问题具体分析啦，单纯地回答谁好谁坏是没有意义的，我们需要结合实际场景给出合适的回答。&lt;/p&gt;
&lt;p&gt;考虑下面是两个场景，由此看出不同场景下我们关注的点是不一样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;地震的预测对于地震的预测，我们希望的是Recall非常高，也就是说每次地震我们都希望预测出来。这个时候我们可以牺牲Precision。情愿发出1000次警报，把10次地震都预测正确了；也不要预测100次对了8次漏了两次。所以我们可以设定在合理的precision下，最高的recall作为最优点，找到这个对应的threshold点。&lt;/li&gt;
&lt;li&gt;嫌疑人定罪基于不错怪一个好人的原则，对于嫌疑人的定罪我们希望是非常准确的。及时有时候放过了一些罪犯（Recall低），但也是值得的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ROC和PRC在模型性能评估上效果都差不多，但需要注意的是，在正负样本分布得极不均匀(highly skewed datasets)的情况下，PRC比ROC能更有效地反应分类器的好坏。在数据极度不平衡的情况下，譬如说1万封邮件中只有1封垃圾邮件，那么如果我挑出10封，50封，100...封垃圾邮件（假设我们每次挑出的N封邮件中都包含真正的那封垃圾邮件），Recall都是100%，但是FPR分别是9/9999, 49/9999, 99/9999（数据都比较好看：FPR越低越好），而Precision却只有1/10，1/50， 1/100 （数据很差：Precision越高越好）。所以在数据非常不均衡的情况下，看ROC的AUC可能是看不出太多好坏的，而PR curve就要敏感的多。&lt;/p&gt;
&lt;h2 id=&quot;iou&quot;&gt;IOU&lt;/h2&gt;
&lt;p&gt;上面讨论的是分类任务中的评价指标，这里想简单讲讲目标检测任务中常用的评价指标：IOU（Intersection over Union），中文翻译为交并比。&lt;/p&gt;
&lt;p&gt;这里是一个实际例子：下图绿色框是真实感兴趣区域，红色框是预测区域，这种情况下交集确实是最大的，但是红色框并不能准确预测物体位置。因为预测区域总是试图覆盖目标物体而不是正好预测物体位置。这时如果我们能除以一个并集的大小，就可以规避这种问题。这就是IOU要解决的问题了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204408601-1945220368.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图表示了IOU的具体意义，即：预测框与标注框的交集与并集之比，数值越大表示该检测器的性能越好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204418589-582088419.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用IOU评价指标后，上面提到的问题一下子解决了：我们控制并集不要让并集太大，对准确预测是有益的，这就有效抑制了“一味地追求交集最大”的情况的发生。下图的2,3小图就是目标检测效果比较好的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180224204428523-871794088.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 12:45:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8467613.html</dc:identifier>
</item>
<item>
<title>Redis Sentinel安装与部署，实现redis的高可用 - youzhibing2904</title>
<link>http://www.cnblogs.com/youzhibing/p/8466491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youzhibing/p/8466491.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　对于生产环境，高可用是避免不了要面对的问题，无论什么环境、服务，只要用于生产，就需要满足高可用；此文针对的是redis的高可用。&lt;/p&gt;
&lt;p&gt;　　接下来会有系列文章，该系列是对&lt;a href=&quot;http://www.cnblogs.com/youzhibing/p/7348337.html&quot; target=&quot;_blank&quot;&gt;spring-session实现分布式集群session的共享&lt;/a&gt;的完整阐述，同时也引伸出缓存的实现；而此篇是该系列的第一篇。&lt;/p&gt;
&lt;p&gt;　　github地址：&lt;a href=&quot;https://github.com/youzhibing/redis&quot; target=&quot;_blank&quot;&gt;https://github.com/youzhibing/redis&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;环境准备&lt;/h2&gt;
&lt;p&gt;　　redis版本：redis-3.0.0&lt;/p&gt;
&lt;p&gt;　　linux：centos6.7&lt;/p&gt;
&lt;p&gt;　　ip：192.168.11.202， 一台服务器上搭建搭建全部redis实例，包括数据节点实例以及哨兵(sentinel)实例&lt;/p&gt;
&lt;p&gt;　　客户端jedis，基于spring-boot&lt;/p&gt;
&lt;h2&gt;redis主从复制&lt;/h2&gt;
&lt;p&gt;　　搭建一主二从的主从环境&lt;/p&gt;
&lt;h3&gt;　　1、redis安装&lt;/h3&gt;
&lt;p&gt;　　　　安装很简单，网上资料很多，redis官网也有说明；主要就是3步：解压，make，make install&lt;/p&gt;
&lt;h3&gt;　　2、数据节点配置文件&lt;/h3&gt;
&lt;p&gt;　　　　redis解压后，redis home目录下有redis配置的样例文件，我们不直接在此文件上就行修改，在redis home目录下新建文件夹master_slave，将配置文件都放于此目录下&lt;/p&gt;
&lt;p&gt;　　　　master配置文件：redis-6379.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
port 6379&lt;span&gt;
bind &lt;/span&gt;192.168.11.202&lt;span&gt;
requirepass &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;6379.log&quot;&lt;span&gt;
dbfilename &lt;/span&gt;&quot;dump-6379.rdb&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;

#如若master设置了认证密码，那么所有redis数据节点都配置上masterauth属性
masterauth &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　slave-1配置文件：redis-6380.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
port 6380&lt;span&gt;
bind &lt;/span&gt;192.168.11.202&lt;span&gt;
requirepass &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;6380.log&quot;&lt;span&gt;
dbfilename &lt;/span&gt;&quot;dump-6380.rdb&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;

#如若master设置了认证密码，那么所有redis数据节点都配置上masterauth属性
masterauth &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;
slaveof &lt;/span&gt;192.168.11.202 6379
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　slave-2配置文件：redis-6381.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
port 6381&lt;span&gt;
bind &lt;/span&gt;192.168.11.202&lt;span&gt;
requirepass &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;6381.log&quot;&lt;span&gt;
dbfilename &lt;/span&gt;&quot;dump-6381.rdb&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;

#如若master设置了认证密码，那么所有redis数据节点都配置上masterauth属性
masterauth &lt;/span&gt;&quot;myredis&quot;&lt;span&gt;
slaveof &lt;/span&gt;192.168.11.202 6379
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、节点启动&lt;/h3&gt;
&lt;p&gt;　　　　如下相关路径需要根据自己的情况进行改动，可能和我的不一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# cd /opt/redis-3.0.0/master_slave/&lt;span&gt;
[root@slave1 master_slave]# .&lt;/span&gt;/../src/redis-server redis-6379&lt;span&gt;.conf 
[root@slave1 master_slave]# .&lt;/span&gt;/../src/redis-server redis-6380&lt;span&gt;.conf 
[root@slave1 master_slave]# .&lt;/span&gt;/../src/redis-server redis-6381.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　确认主从关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# ./../src/redis-cli -h 192.168.11.202 -p 6379 -&lt;span&gt;a myredis info replication
# Replication
role:master
connected_slaves:&lt;/span&gt;2&lt;span&gt;
slave0:ip&lt;/span&gt;=192.168.11.202,port=6380,state=online,offset=393,lag=0&lt;span&gt;
slave1:ip&lt;/span&gt;=192.168.11.202,port=6381,state=online,offset=393,lag=0&lt;span&gt;
master_repl_offset:&lt;/span&gt;393&lt;span&gt;
repl_backlog_active:&lt;/span&gt;1&lt;span&gt;
repl_backlog_size:&lt;/span&gt;1048576&lt;span&gt;
repl_backlog_first_byte_offset:&lt;/span&gt;2&lt;span&gt;
repl_backlog_histlen:&lt;/span&gt;392
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　还可以从从节点视角来看：[root@slave1 master_slave]# ./../src/redis-cli -h 192.168.11.202 -p 6380 -a myredis info replication&lt;/p&gt;
&lt;p&gt;　　如若进行顺利，按如上配置，一主二从环境搭建完毕&lt;/p&gt;
&lt;h3&gt;　　4、从节点作用&lt;/h3&gt;
&lt;p&gt;　　　　主要两个作用：1、作为主节点的一个备份，一旦主节点出现故障，从节点可以作为后备&quot;顶&quot;上来，并且保证数据尽量不丢失（主从复制是最终一致性）；2、从节点可以拓展主节点的能力，一旦主节点不能支撑大并发的读操作，从节点可以在一定程度上帮助主节点分担读压力&lt;/p&gt;
&lt;h3&gt;　　5、主从复制问题&lt;/h3&gt;
&lt;p&gt;　　　　1、一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程需要人工干预&lt;/p&gt;
&lt;p&gt;　　　　2、主节点的写能力受到单机的限制&lt;/p&gt;
&lt;p&gt;　　　　3、主节点的存储能力受到单机的限制&lt;/p&gt;
&lt;h2&gt;redis sentinel部署&lt;/h2&gt;
&lt;p&gt;　　此片主要讲通过sentinel解决上述问题1，问题2、3则在下篇博客进行说明&lt;/p&gt;
&lt;h3&gt;　　1、3个sentinel节点的配置文件基本一致，区别的只是端口&lt;/h3&gt;
&lt;p&gt;　　　　sentinel-26379.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
port 26379&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;26379.log&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;
sentinel monitor mymaster &lt;/span&gt;192.168.11.202 6380 2&lt;span&gt;
#redis数据master节点设置了认证，则需要如下配置
sentinel auth&lt;/span&gt;-&lt;span&gt;pass mymaster myredis
sentinel down&lt;/span&gt;-after-milliseconds mymaster 30000&lt;span&gt;
sentinel parallel&lt;/span&gt;-syncs mymaster 1&lt;span&gt;
sentinel failover&lt;/span&gt;-timeout mymaster 180000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　sentinel-26380.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
port 26380&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;26379.log&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;
sentinel monitor mymaster &lt;/span&gt;192.168.11.202 6380 2&lt;span&gt;
#redis数据master节点设置了认证，则需要如下配置
sentinel auth&lt;/span&gt;-&lt;span&gt;pass mymaster myredis
sentinel down&lt;/span&gt;-after-milliseconds mymaster 30000&lt;span&gt;
sentinel parallel&lt;/span&gt;-syncs mymaster 1&lt;span&gt;
sentinel failover&lt;/span&gt;-timeout mymaster 180000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　sentinel-26381.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
port 26381&lt;span&gt;
daemonize yes
logfile &lt;/span&gt;&quot;26379.log&quot;&lt;span&gt;
dir &lt;/span&gt;&quot;/opt/soft/redis/data&quot;&lt;span&gt;
sentinel monitor mymaster &lt;/span&gt;192.168.11.202 6380 2&lt;span&gt;
#redis数据master节点设置了认证，则需要如下配置
sentinel auth&lt;/span&gt;-&lt;span&gt;pass mymaster myredis
sentinel down&lt;/span&gt;-after-milliseconds mymaster 30000&lt;span&gt;
sentinel parallel&lt;/span&gt;-syncs mymaster 1&lt;span&gt;
sentinel failover&lt;/span&gt;-timeout mymaster 180000
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2、启动sentinel&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# ./../src/redis-sentinel sentinel-26379&lt;span&gt;.conf 
[root@slave1 master_slave]# .&lt;/span&gt;/../src/redis-sentinel sentinel-26380&lt;span&gt;.conf 
[root@slave1 master_slave]# .&lt;/span&gt;/../src/redis-sentinel sentinel-26381.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、sentinel确认&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# ./../src/redis-cli -h 192.168.11.202 -p 26379&lt;span&gt; info Sentinel
# Sentinel
sentinel_masters:&lt;/span&gt;1&lt;span&gt;
sentinel_tilt:&lt;/span&gt;0&lt;span&gt;
sentinel_running_scripts:&lt;/span&gt;0&lt;span&gt;
sentinel_scripts_queue_length:&lt;/span&gt;0&lt;span&gt;
master0:name&lt;/span&gt;=mymaster,status=ok,address=192.168.11.202:6379,slaves=2,sentinels=3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Redis  Sentinel 最终拓扑结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/747662/201802/747662-20180224202458889-1076709938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　4、高可用测试&lt;/h3&gt;
&lt;p&gt;　　　　手动停掉6379实例或者kill掉6379实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# ./../src/redis-cli -h 192.168.11.202 -p 6379 -&lt;span&gt;a myredis
&lt;/span&gt;192.168.11.202:6379&amp;gt; shutdown
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　查看26379.log&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/747662/201802/747662-20180224185113303-44074682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　master节点已经自动切换到192.168.11.202:6380了，重启6379，6379则是6378的从节点了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
[root@slave1 master_slave]# ./../src/redis-cli -h 192.168.11.202 -p 6380 -&lt;span&gt;a myredis
&lt;/span&gt;192.168.11.202:6380&amp;gt;&lt;span&gt; info replication
# Replication
role:master
connected_slaves:&lt;/span&gt;2&lt;span&gt;
slave0:ip&lt;/span&gt;=192.168.11.202,port=6381,state=online,offset=80802,lag=1&lt;span&gt;
slave1:ip&lt;/span&gt;=192.168.11.202,port=6379,state=online,offset=80802,lag=1&lt;span&gt;
master_repl_offset:&lt;/span&gt;80945&lt;span&gt;
repl_backlog_active:&lt;/span&gt;1&lt;span&gt;
repl_backlog_size:&lt;/span&gt;1048576&lt;span&gt;
repl_backlog_first_byte_offset:&lt;/span&gt;2&lt;span&gt;
repl_backlog_histlen:&lt;/span&gt;80944　
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;客户端（Jedis）连接&lt;/h2&gt;
&lt;p&gt;　　基于spring-boot开发，spring-boot-test测试， 这两者本文不做说明，网上资料很多，不熟悉的自行去补充； 工程结构如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/747662/201802/747662-20180224190204996-1522466455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　pom.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3f45f652-f5ff-4250-976b-02c6297ebdde&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3f45f652-f5ff-4250-976b-02c6297ebdde&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3f45f652-f5ff-4250-976b-02c6297ebdde&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.lee&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;redis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;name&amp;gt;redis&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.apache.org&amp;lt;/url&amp;gt;&lt;/span&gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.5.9.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;!-- 日志过滤器 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.codehaus.janino&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;janino&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　redis-sentinel.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_b8989f92-9eb9-4962-af0f-59dfbf51a9fe&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b8989f92-9eb9-4962-af0f-59dfbf51a9fe&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b8989f92-9eb9-4962-af0f-59dfbf51a9fe&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
redis.masterName=&lt;span&gt;mymaster
redis.sentinels&lt;/span&gt;=192.168.11.202:26379,192.168.11.202:26380,192.168.11.202:26381&lt;span&gt;
redis.timeout&lt;/span&gt;=10000&lt;span&gt;
#连接master需要用到的密码，如果redis数据节点开启了连接认证
redis.password&lt;/span&gt;=&lt;span&gt;myredis

# 连接池
# 连接池最大连接数（使用负值表示没有限制）
redis.pool.maxActive&lt;/span&gt;=150&lt;span&gt;
# 连接池中的最大空闲连接
redis.pool.maxIdle&lt;/span&gt;=10&lt;span&gt;
# 连接池中的最小空闲连接
redis.pool.minIdle&lt;/span&gt;=1&lt;span&gt;
# 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认&lt;/span&gt;-1&lt;span&gt;
redis.pool.maxWaitMillis&lt;/span&gt;=3000&lt;span&gt;
# 每次释放连接的最大数目
redis.pool.numTestsPerEvictionRun&lt;/span&gt;=50&lt;span&gt;
# 释放连接的扫描间隔（毫秒）
redis.pool.timeBetweenEvictionRunsMillis&lt;/span&gt;=3000&lt;span&gt;
# 连接最小空闲时间（毫秒）
redis.pool.minEvictableIdleTimeMillis&lt;/span&gt;=1800000&lt;span&gt;
# 连接空闲多久后释放, 当空闲时间&lt;/span&gt;&amp;gt;该值 且 空闲连接&amp;gt;&lt;span&gt;最大空闲连接数 时直接释放（毫秒）
redis.pool.softMinEvictableIdleTimeMillis&lt;/span&gt;=10000&lt;span&gt;
# 在获取连接的时候检查有效性, 默认false
redis.pool.testOnBorrow&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
# 在空闲时检查有效性, 默认false
redis.pool.testWhileIdle&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
# 在归还给pool时，是否提前进行validate操作
redis.pool.testOnReturn&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
# 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true
redis.pool.blockWhenExhausted&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　RedisConfig.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_49540c68-8672-4578-8549-54ced71e0bca&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_49540c68-8672-4578-8549-54ced71e0bca&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_49540c68-8672-4578-8549-54ced71e0bca&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lee.redis.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.PropertySource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis.clients.jedis.JedisPoolConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis.clients.jedis.JedisSentinelPool;

@Configuration
@PropertySource(&lt;/span&gt;&quot;redis/redis-sentinel.properties&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisConfig {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(RedisConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    @Value(&lt;/span&gt;&quot;${redis.masterName}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String masterName;
    @Value(&lt;/span&gt;&quot;${redis.sentinels}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sentinels;
    @Value(&lt;/span&gt;&quot;${redis.timeout}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; timeout;
    @Value(&lt;/span&gt;&quot;${redis.password}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    
    @Value(&lt;/span&gt;&quot;${redis.pool.maxActive}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxTotal;

    @Value(&lt;/span&gt;&quot;${redis.pool.maxIdle}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxIdle;

    @Value(&lt;/span&gt;&quot;${redis.pool.minIdle}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; minIdle;

    @Value(&lt;/span&gt;&quot;${redis.pool.maxWaitMillis}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; maxWaitMillis;

    @Value(&lt;/span&gt;&quot;${redis.pool.numTestsPerEvictionRun}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numTestsPerEvictionRun;

    @Value(&lt;/span&gt;&quot;${redis.pool.timeBetweenEvictionRunsMillis}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeBetweenEvictionRunsMillis;

    @Value(&lt;/span&gt;&quot;${redis.pool.minEvictableIdleTimeMillis}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; minEvictableIdleTimeMillis;

    @Value(&lt;/span&gt;&quot;${redis.pool.softMinEvictableIdleTimeMillis}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; softMinEvictableIdleTimeMillis;

    @Value(&lt;/span&gt;&quot;${redis.pool.testOnBorrow}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; testOnBorrow;

    @Value(&lt;/span&gt;&quot;${redis.pool.testWhileIdle}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; testWhileIdle;

    @Value(&lt;/span&gt;&quot;${redis.pool.testOnReturn}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; testOnReturn;

    @Value(&lt;/span&gt;&quot;${redis.pool.blockWhenExhausted}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; blockWhenExhausted;
    
    @SuppressWarnings({ &lt;/span&gt;&quot;unchecked&quot;, &quot;rawtypes&quot;&lt;span&gt; })
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JedisSentinelPool jedisSentinelPool(JedisPoolConfig poolConfig) {
        LOGGER.info(&lt;/span&gt;&quot;sentinel set : {}&quot;&lt;span&gt;, sentinels);
        Set sentinelSet &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashSet(Arrays.asList(sentinels.split(&quot;,&quot;&lt;span&gt;)));
        JedisSentinelPool jedisPool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JedisSentinelPool(masterName, sentinelSet, poolConfig, timeout, password);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jedisPool;
    }
    
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JedisPoolConfig jedisPoolConfig() {
        JedisPoolConfig jedisPoolConfig &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(maxTotal);
        jedisPoolConfig.setMaxIdle(maxIdle);
        jedisPoolConfig.setMinIdle(minIdle);
        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);
        jedisPoolConfig.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
        jedisPoolConfig
                .setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
        jedisPoolConfig
                .setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        jedisPoolConfig
                .setSoftMinEvictableIdleTimeMillis(softMinEvictableIdleTimeMillis);
        jedisPoolConfig.setTestOnBorrow(testOnBorrow);
        jedisPoolConfig.setTestWhileIdle(testWhileIdle);
        jedisPoolConfig.setTestOnReturn(testOnReturn);
        jedisPoolConfig.setBlockWhenExhausted(blockWhenExhausted);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jedisPoolConfig;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　Application.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ca24ef0a-e6da-46c7-9020-9bf5965385b1&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ca24ef0a-e6da-46c7-9020-9bf5965385b1&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ca24ef0a-e6da-46c7-9020-9bf5965385b1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lee.redis;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.Banner;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.EnableAutoConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ComponentScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;

@Configuration
@EnableAutoConfiguration
@ComponentScan
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        SpringApplication app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SpringApplication(Application.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        app.setBannerMode(Banner.Mode.OFF);            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否打印banner
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; app.setApplicationContextClass();        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定spring应用上下文启动类&lt;/span&gt;
        app.setWebEnvironment(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        app.run(args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　RedisTest.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_cf455dd6-3923-431b-81c6-2d3e4837fbcf&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cf455dd6-3923-431b-81c6-2d3e4837fbcf&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cf455dd6-3923-431b-81c6-2d3e4837fbcf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lee.redis;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.test.context.SpringBootTest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringRunner;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis.clients.jedis.Jedis;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis.clients.jedis.JedisSentinelPool;

@RunWith(SpringRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest(classes &lt;/span&gt;= Application.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisTest {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(RedisTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JedisSentinelPool sentinelPool;
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getNameTest() {
        Jedis jedis &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            jedis &lt;/span&gt;=&lt;span&gt; sentinelPool.getResource();
            String name &lt;/span&gt;= jedis.get(&quot;name&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;name is &quot; +&lt;span&gt; name);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e) {
            LOGGER.error(e.getMessage(), e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (jedis != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                jedis.close();
            }
        }
        
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　更多详情请上我的github&lt;/p&gt;
&lt;p&gt;　　运行RedisTest.java的getNameTest方法（name属性已经在redis中设置，没设置的需要提前设置），得到结果：&lt;img src=&quot;https://images2018.cnblogs.com/blog/747662/201802/747662-20180224190848962-1545756249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;注意点&lt;/h2&gt;
&lt;p&gt;　　1、有人可能会有这样的疑问：为什么通过sentinel来获取redis的连接，而不是直接连接master来获取redis连接呢？&lt;/p&gt;
&lt;p&gt;　　　　试想一下，客户端直接通过master节点获取redis连接，如果master节点挂掉了，虽然Redis Sentinel可以完成故障转移，但是客户端无法获取这个变化，那么客户端就无法获取redis连接了；&lt;/p&gt;
&lt;p&gt;　　　　最了解master节点信息的就是Sentinel节点集合，所以通过sentinel来获取redis连接就能满足高可用的要求了。&lt;/p&gt;
&lt;p&gt;　　2、redis master的故障转移不影响客户端连接代码， 但是转移期间内，通过sentinel是获取不到主节点的连接的， 因为转移期间内master节点还没被选举出来；&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;　　《Redis开发与运维》&lt;/p&gt;
&lt;p&gt;　　http://www.redis.cn/topics/sentinel.html&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 12:40:00 +0000</pubDate>
<dc:creator>youzhibing2904</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youzhibing/p/8466491.html</dc:identifier>
</item>
</channel>
</rss>