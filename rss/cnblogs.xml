<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>eclipse的maven项目中找不到Maven Dependencies - Visitors</title>
<link>http://www.cnblogs.com/dmeck/p/8456034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dmeck/p/8456034.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　今天记录一个初级错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　比如我们在eclipse创建maven项目来运行我们的web项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220232558221-444071489.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220232638333-2061703535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220233102404-567774525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　搭建完工程后发现javax-servlet包全部报错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220233344619-1791450561.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　到这里我还不知道什么原因，想看原因的伙伴请移步最后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找了半天都说是改eclipse配置文件，但是还是没用，只能翻看我之前看的项目视频，看看它是怎么搭建的&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220233653208-69720744.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先它是一个pom工程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220233737958-362939039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后继承这个pom的jar&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220234145247-1081648039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我操没问题啊，然后我又创建了下面这个项目一遍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220233102404-567774525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为毛还是没有&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220234416763-2054746630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; --------------------------------------------------------------耿直的分割线-----------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220235907120-1939506093.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;好了，细心的朋友已经知道原因了&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220234623712-735798958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到它了吗？翻阅maven官方手册才知道，&lt;strong&gt;这是一个pom工程才会有的，它使里面的jar包不会加载，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;意思就是，这是创建pom工程才会有的标签！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以后还是老老实实的看看手册才靠谱，不然以后就要看《从删库到跑路》这本名言了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 所以说这篇博客文不应该叫&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/doStudying/p/6478281.html&quot;&gt;解决项目中找不到Maven Dependencies&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而是叫 &amp;lt;dependencyManagement&amp;gt;标签的作用，但是相信很多老哥都是这样找bug出现的问题，但不知到问题所在，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总是去搜bug出现的问题，而不知道真正的问题，所以我觉得这个标题比较靠谱&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 20 Feb 2018 15:56:00 +0000</pubDate>
<dc:creator>Visitors</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dmeck/p/8456034.html</dc:identifier>
</item>
<item>
<title>云计算之路-阿里云上：重启 manager 节点引发 docker swarm 集群宕机 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8455956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8455956.html</guid>
<description>&lt;p&gt;为了迎接春节假期后的访问高峰，我们今天对 docker swarm 集群进行了变更操作，购买了1台阿里云4核8G的服务器作为 worker 节点，由原来的  3 manager nodes + 2 worker nodes 变为  3 manager nodes + 3 worker nodes 。&lt;/p&gt;
&lt;p&gt;晚上，我们对已经持续运行一段时间的5个节点逐一进行重启操作，重启方式如下：&lt;/p&gt;
&lt;p&gt;1）docker node update --availability drain 让节点下线&lt;br/&gt;2）阿里云控制台重启服务器&lt;br/&gt;3）docker node update --availability active 让节点上线&lt;/p&gt;
&lt;p&gt;以前多次进行过这样的操作，未曾遇到问题，而今天在将其中1台manager节点下线后竟然意外地引发了整个集群宕机 。。。21:39 - 22:02 左右，这个突发的故障给您带来很大的麻烦，请您谅解。受这次故障影响的站点有 &lt;a href=&quot;https://ing.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;闪存&lt;/a&gt;，&lt;a href=&quot;https://q.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;博问&lt;/a&gt;，&lt;a href=&quot;https://edu.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;班级&lt;/a&gt;，&lt;a href=&quot;https://home.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;园子&lt;/a&gt;，&lt;a href=&quot;https://msg.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;短信息&lt;/a&gt;，&lt;a href=&quot;https://job.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;招聘&lt;/a&gt;，&lt;a href=&quot;https://group.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;小组&lt;/a&gt;，&lt;a href=&quot;https://wz.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;网摘&lt;/a&gt;，&lt;a href=&quot;https://news.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;新闻&lt;/a&gt;，openapi 。&lt;/p&gt;
&lt;p&gt;经过分析，我们得到的教训是尽可能避免只有2个manager节点的情况（manager节点采用的是投票机制，少数服从多数，2个节点的投票永远是1:1，这也是一种不稳定情况）。针对这个教训，我们调整了节点的部署，改为了 5 manager nodes + 1 worker nodes ，这样即使2个manger节点下线或出问题，也不会群龙无首。&lt;/p&gt;
&lt;p&gt;docker swarm 集群的不稳定让我们如履薄冰，今年我们会想尽一切办法彻底解决这个问题。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 15:33:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/8455956.html</dc:identifier>
</item>
<item>
<title>5.C++里的4种新型类型转换 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8456000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8456000.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1首先来&lt;span&gt;回顾&lt;/span&gt;&lt;span&gt;C的&lt;span&gt;强制转换&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;大家都知道&lt;/span&gt;,&lt;span&gt;在编译&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;语言中的强制转换时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;编译器&lt;span&gt;不会检查&lt;/span&gt;转换是否成功&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;都会编译正确&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;比如&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdio.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Position
{
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y;
};

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
 &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; Position *&lt;span&gt;p;

 i&lt;/span&gt;=&lt;span&gt;0x123456&lt;/span&gt;&lt;span&gt;;

 p&lt;/span&gt;=(&lt;span&gt;struct&lt;/span&gt; Position *&lt;span&gt;)i;

 printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;px=%d,py=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p-&amp;gt;x,p-&amp;gt;&lt;span&gt;y);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;输出结果如下图所示&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201802/1182576-20180220231349143-1675499389.png&quot; alt=&quot;&quot; width=&quot;318&quot; height=&quot;89&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从上图可以看到&lt;/span&gt;,&lt;span&gt;只有当运行代码时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;才会出现段错误问题&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当&lt;/span&gt;C&lt;span&gt;代码&lt;strong&gt;&lt;span&gt;上千行&lt;/span&gt;&lt;/strong&gt;时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;若出现这种问题&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;是非常难找的&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2.C++的新型类型转换&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以在&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;便引入了&lt;/span&gt;&lt;strong&gt;&lt;span&gt;4&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;种&lt;/span&gt;&lt;/strong&gt;强制类型转换&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1 &lt;span&gt;static_cast&lt;/span&gt;(&lt;span&gt;静态类型转换&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;基本数据&lt;/span&gt;&lt;/strong&gt;类型之间的转换&lt;/span&gt;&lt;span&gt;(char,int,const int&lt;span&gt;等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;不能用于&lt;/strong&gt;&lt;/span&gt;基本数据类型指针之间的转换&lt;/span&gt;&lt;span&gt;(char *,int *&lt;span&gt;等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;有继承关系类对象&lt;/span&gt;&lt;/strong&gt;之间的转换&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;类指针&lt;/span&gt;&lt;/strong&gt;之间的转换&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;例如&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    int&lt;/span&gt; i = &lt;span&gt;0x45&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

    c &lt;/span&gt;= static_cast&amp;lt;&lt;span&gt;char&lt;/span&gt;&amp;gt;&lt;span&gt;(i);    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;char* pc = static_cast&amp;lt;char*&amp;gt;(&amp;amp;i);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此行错误,不能用于基本指针之间转换&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 &lt;span&gt;const_cast&lt;/span&gt;(&lt;span&gt;去常类型转换&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;去除&lt;/span&gt;&lt;/strong&gt;变量的&lt;strong&gt;&lt;span&gt;只读属性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;且强制转换的类型必须是&lt;strong&gt;&lt;span&gt;指针&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;*&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;或&lt;strong&gt;&lt;span&gt;引用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;例如&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x =&lt;span&gt;1&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;const：定义一个常量x&lt;/span&gt; 

&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&amp;amp; j =&lt;span&gt;2&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;const引用:定义一个只读变量j&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt;&amp;amp; p1= const_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;amp;&amp;gt;(x);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制转换int &amp;amp;&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; *p2 = const_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;*&amp;gt;(&amp;amp;j);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制转换int*

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int p3 = const_cast&amp;lt;int&amp;gt;(j);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此行错误,不能转换普通数据型&lt;/span&gt;
&lt;span&gt;
p1&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;*p2=&lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=%d,   j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,x,j);
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1=%d  *p2=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p1,*p2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
x=&lt;span&gt;1&lt;/span&gt;   j=&lt;span&gt;4&lt;/span&gt;&lt;span&gt;

p1&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;  *p2=&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从输出结果&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;可以看出修改&lt;/span&gt;&lt;span&gt;p1,p2,&lt;/span&gt;&lt;span&gt;只有&lt;/span&gt;&lt;span&gt;j&lt;/span&gt;&lt;span&gt;内容变换了&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;是因为变量&lt;/span&gt;&lt;span&gt;j&lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;引用定义的&lt;/span&gt;&lt;span&gt;,所以&lt;/span&gt;&lt;span&gt;是个只读变量&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 dynamic_cast(&lt;span&gt;动态类型转换&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;有继承关系的类指针&lt;/span&gt;&lt;/strong&gt;间的转换&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;有交叉关系的类指针&lt;/span&gt;&lt;/strong&gt;间的转换&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;具有&lt;span&gt;&lt;strong&gt;类型检查&lt;/strong&gt;&lt;/span&gt;的功能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;需要&lt;strong&gt;&lt;span&gt;虚函数&lt;/span&gt;&lt;/strong&gt;的支持&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;不能用于&lt;/strong&gt;&lt;/span&gt;基本数据类型指针之间的转换&lt;/span&gt;&lt;span&gt;(char *,int *&lt;span&gt;等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.4 reinterpret_ cast(&lt;span&gt;解读类型转换&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;用于&lt;span&gt;&lt;strong&gt;所有指针&lt;/strong&gt;&lt;/span&gt;的强制转换&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;(&lt;span&gt;解读是指&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;对要转换的数据进行重新的解读&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; j=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;   *p1=reinterpret_cast&amp;lt;&lt;span&gt;int&lt;/span&gt; *&amp;gt;(&amp;amp;&lt;span&gt;i);

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;  *p2=reinterpret_cast&amp;lt;&lt;span&gt;char&lt;/span&gt; *&amp;gt;(&amp;amp;&lt;span&gt;j);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int  p3=reinterpret_cast&amp;lt;int &amp;gt;i;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此行错误,不能转换普通数据型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 15:24:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8456000.html</dc:identifier>
</item>
<item>
<title>Redis安装和基础介绍 - appleYang</title>
<link>http://www.cnblogs.com/zhikou/p/8455992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhikou/p/8455992.html</guid>
<description>&lt;p&gt;&lt;br/&gt;一：初识Redis&lt;/p&gt;
&lt;p&gt;　　Redis是一个远程内存数据库，它不仅性能强劲，而且还具有复制特性以及为解决问题而生的独一无二的数据模型。Redis提供了5种不同类型的数据结构，各式各样的问题都可以很自然地映射到这些数据结构上：Redis有着数据库没有的适应用户使用需求，此外，通过复制、持久化和客服端分片等特性，用户可以很方便的将Redis扩展成一个能够包含数百GB数据、每秒处理上百万次请求的系统。&lt;/p&gt;
&lt;p&gt;　　上面对Redis数据库只说出了一部分真相。Redis是一个速度非常快的非关系数据库，它可以存储键（key）与5种不同类型的值（value）之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片（是一种将数据划分为多个部分的方法，对数据的划分可以基于键包含的id，基于键的散列值，或者基于以上两者的某种组合。通过对数据进行分片，用户可以将数据存储到多台服务器上，也可以从多台服务器上获取到数据，这种方法在解决某些问题时可以获得线性级别的性能提升）来扩展写的性能，接下来具体操作。&lt;/p&gt;
&lt;p&gt;二：安装Redis服务&lt;/p&gt;
&lt;p&gt;　　官方的Redis并没有Window安装包，但可以上github上有开源的代码，点击：&lt;a href=&quot;https://github.com/ServiceStack/redis-windows&quot; target=&quot;_blank&quot;&gt;https://github.com/ServiceStack/redis-windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201802/1137026-20180220225652148-2027098308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开cmd开启redis-server&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201802/1137026-20180220230313814-827363576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;redis-cli.exe文件是客户端，cmd运行它之后就可以执行redis命令了。&lt;/p&gt;

&lt;div start=&quot;1&quot;&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span&gt;redis-server --service-install redis.windows.conf --loglevel verbose &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201802/1137026-20180220230701019-961611406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后查看服务是否存在&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201802/1137026-20180220230914776-75768410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Redis的命令还是需要打开它的客户端redis-cli.exe的。&lt;/p&gt;
&lt;p&gt;更多的redis命令，可以看官方网站或中文站，戳这里：&lt;a href=&quot;http://www.redis.cn/commands.html&quot; target=&quot;_blank&quot;&gt;http://www.redis.cn/commands.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;顺便介绍一个Redis可视化工具，&lt;a href=&quot;https://github.com/uglide/RedisDesktopManager&quot; target=&quot;_blank&quot;&gt;RedisDesktopManager&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它开源的，托管在github上：&lt;a href=&quot;https://github.com/uglide/RedisDesktopManager&quot; target=&quot;_blank&quot;&gt;https://github.com/uglide/RedisDesktopManager&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最终，为了什么呢？不安装会出错的，大哥&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201802/1137026-20180220231629137-1064669965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后开启服务之后就可以成功运行了&lt;/p&gt;

</description>
<pubDate>Tue, 20 Feb 2018 15:18:00 +0000</pubDate>
<dc:creator>appleYang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhikou/p/8455992.html</dc:identifier>
</item>
<item>
<title>【SSH框架】之Hibernate系列一 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8455986.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8455986.html</guid>
<description>
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;微信公众号：compassblog&lt;/p&gt;
&lt;p&gt;欢迎关注、转发，互相学习，共同进步！&lt;/p&gt;
&lt;p&gt;有任何问题，请后台留言联系！&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h3 id=&quot;h1hibernate&quot;&gt;1、Hibernate框架概述&lt;/h3&gt;
&lt;p&gt;（1）、什么是Hibernate&lt;br/&gt;Hibernate是一个开放源代码的 ORM 框架，是主流的Java持久层框架之一，它对 JDBC进行了轻量级的对象封装，使得Java开发人员可以使用面向对象的编程思想来操作数据库。&lt;br/&gt;（2）、Hibernate在三层架构中的位置&lt;br/&gt;上篇文章所讲的Struts2框架取代的是三层框架中的web层，而Hibernate框架取代的则是dao层，具体描述如下图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b33a5e0e10c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（3）、什么是ORM&lt;br/&gt;ORM（Object Relational Mapping），即对象关系映射，就是利用描述对象和数据库表之间映射的元数据，自动把Java应用程序中的对象，持久化到关系型数据库的表中。通过操作Java对象，就可以完成对数据库表的操作。可以把 ORM 理解为关系型数据和对象的一个纽带，开发人员只需要关注纽带一端映射的对象即可。ORM 实现原理如下图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b359b2c1b9c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（4）、Hibernate框架的优势与功能&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Hlbernate对JDBC访问数据库的代码做了轻量级封装，大大简化了数据访问层繁琐的重复性代码，并且减少了内存消耗，加快了运行效率。&lt;/li&gt;
&lt;li&gt;Hlbernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，它很大程度的简化了DAO (DataAccess Object，数据访问对象）层编码工作。操作数据库的时候，可以以面向对象的方式来完成，不再需要书写SQL语句。&lt;/li&gt;
&lt;li&gt;Hlbernate的性能非常好，映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系。&lt;/li&gt;
&lt;li&gt;可扩展性强，由于源代码的开源以及API的开放，当本身功能不够用时，可以自行编码进行扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h2hibernate&quot;&gt;2、搭建Hibernate框架，完成第一个应用实例&lt;/h3&gt;
&lt;p&gt;（1）、创建一个web项目，导入所需要的jar包，包括数据库驱动包，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b37b63c6d3f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（2）、创建数据库demo_project和表user，建表语句如下：&lt;/p&gt;

&lt;p&gt;创建数据库demo_project语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create &lt;span class=&quot;hljs-keyword&quot;&gt;database demo_project;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常见表user语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE &lt;span class=&quot;hljs-string&quot;&gt;`user` (
  &lt;span class=&quot;hljs-string&quot;&gt;`id` &lt;span class=&quot;hljs-built_in&quot;&gt;int(&lt;span class=&quot;hljs-number&quot;&gt;10) &lt;span class=&quot;hljs-keyword&quot;&gt;NOT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`name` &lt;span class=&quot;hljs-built_in&quot;&gt;varchar(&lt;span class=&quot;hljs-number&quot;&gt;50) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`age` &lt;span class=&quot;hljs-built_in&quot;&gt;int(&lt;span class=&quot;hljs-number&quot;&gt;3) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`height` &lt;span class=&quot;hljs-built_in&quot;&gt;int(&lt;span class=&quot;hljs-number&quot;&gt;11) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`weight` &lt;span class=&quot;hljs-keyword&quot;&gt;double(&lt;span class=&quot;hljs-number&quot;&gt;10,&lt;span class=&quot;hljs-number&quot;&gt;0) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  PRIMARY &lt;span class=&quot;hljs-keyword&quot;&gt;KEY (&lt;span class=&quot;hljs-string&quot;&gt;`id`)
) &lt;span class=&quot;hljs-keyword&quot;&gt;ENGINE=&lt;span class=&quot;hljs-keyword&quot;&gt;InnoDB &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-keyword&quot;&gt;CHARSET=utf8;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）、创建实体User.java，具体代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;User.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.hibernate.demo;

&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;User {
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）、导入约束，在与实体同一个包下新建ORM配置文件User.hbm.xml，书写ORM元数据，具体配置代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;User.hbm.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE hibernate-mapping PUBLIC 
    &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&amp;gt;
   &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）、在src下新建hibernate.cfg.xml主配置文件，具体配置代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hibernate.cfg.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE hibernate-configuration PUBLIC
    &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;hibernate-configuration&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;session-factory&amp;gt;

         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）、新建测试类TestDemo.java，书写测试代码，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TestDemo.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.hibernate.test;

&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.Session;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.SessionFactory;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.Transaction;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.cfg.Configuration;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.junit.Test;

&lt;span class=&quot;hljs-keyword&quot;&gt;import com.hibernate.domain.User;

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（7）、使用JUnit测试运行，信息插入成功，具体结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b3c5e45d471?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b414a6abb2b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;本项目运行环境：jdk1.7、Tomcat7.0&lt;/p&gt;

&lt;h3 id=&quot;h3hibernate&quot;&gt;3、Hibernate配置文件详解&lt;/h3&gt;
&lt;p&gt;（1）、orm元数据配置详解：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;package&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;property&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;（2）、Hibernate主配置文件详解：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;必选配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;可选配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;引入orm元数据配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;span&gt;关注微信公众号compassblog，后台回复 “&lt;strong&gt;Hibernate系列一&lt;/strong&gt;&lt;span&gt;” 获取本项目源码&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247483975&amp;amp;idx=1&amp;amp;sn=24f28cdc3399c0d295a5ceb209383e10&amp;amp;chksm=fe322189c945a89f0c2723de0c7c1ef48cbd218e14ed2c8ea0a9c7c4da241737011bc7cf66d7#rd&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247483975&amp;amp;idx=1&amp;amp;sn=24f28cdc3399c0d295a5ceb209383e10&amp;amp;chksm=fe322189c945a89f0c2723de0c7c1ef48cbd218e14ed2c8ea0a9c7c4da241737011bc7cf66d7#rd&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本系列后期仍会持续更新，欢迎关注！&lt;/p&gt;

&lt;p&gt;如果你认为这篇文章有用，欢迎转发分享给你的好友！&lt;/p&gt;

&lt;p&gt;本号文章可以任意转载，转载请注明出处！&lt;/p&gt;
&lt;h2&gt;扫码关注微信公众号，了解更多&lt;/h2&gt;
&lt;div&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180220230815636&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 20 Feb 2018 15:14:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8455986.html</dc:identifier>
</item>
<item>
<title>使用 RxJS 实现一个简易的仿 Elm 架构应用 - 不如隐茶去</title>
<link>http://www.cnblogs.com/JacZhu/p/8455974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JacZhu/p/8455974.html</guid>
<description>&lt;p&gt;标签（空格分隔）： 前端&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;什么是-elm-架构&quot;&gt;什么是 Elm 架构&lt;/h2&gt;
&lt;p&gt;Elm 架构是一种使用 Elm 语言编写 Web 前端应用的简单架构，在代码模块化、代码重用以及测试方面都有较好的优势。使用 Elm 架构，可以非常轻松的构建复杂的 Web 应用，无论是面对重构还是添加新功能，它都能使项目保持良好的健康状态。&lt;/p&gt;
&lt;p&gt;Elm 架构的应用通常由三部分组成——&lt;strong&gt;模型&lt;/strong&gt;、&lt;strong&gt;更新&lt;/strong&gt;、&lt;strong&gt;视图&lt;/strong&gt;。这三者之间使用 &lt;strong&gt;Message&lt;/strong&gt; 来相互通信。&lt;/p&gt;
&lt;h3 id=&quot;模型&quot;&gt;模型&lt;/h3&gt;
&lt;p&gt;模型通常是一个简单的 POJO 对象，包含了需要展示的数据或者是界面显示逻辑的状态信息，在 Elm 语言中，通常是自定义的“记录类型”，模型对象及其字段都是不可变的（immutable）。使用 TypeScript 的话，可以简单的用接口来描述模型：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export interface IHabbitPresetsState {
    presets: IHabbitPreset[];
    isLoading: boolean;
    isOperating: boolean;
    isOperationSuccess: boolean;
    isEditing: boolean;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候，我们就需要在心中谨记，&lt;strong&gt;永远不要去修改模型的字段！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;message&quot;&gt;Message&lt;/h3&gt;
&lt;p&gt;Message 用来定义应用程序在运行过程中可能会触发的事件，例如，在一个秒表应用中，我们会定义“开始计时”、“暂停计时”、“重置”这三种事件。在 Elm 中，可以使用 Union Type 来定义 Message，如果使用 TypeScript 的话，可以定义多个消息类，然后再创建一个联合类型定义：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export type HabbitPresetsMsg =
    Get | Receive
    | Add | AddResp
    | Delete | DeleteResp
    | Update | UpdateResp
    | BeginEdit | StopEdit;

export class Get {
}

export class Receive {
    constructor(public payload: IHabbitPreset[]) { }
}

export class Add {
    constructor(public payload: IHabbitPreset) { }
}

export class AddResp {
    constructor(public payload: IHabbitPreset) {
    }
}

export class Delete {
    constructor(public payload: number) {
    }
}

export class DeleteResp {
    constructor(public payload: number) { }
}

export class Update {

    constructor(public payload: IHabbitPreset) {
    }
}

export class UpdateResp {
    constructor(public payload: IHabbitPreset) {
    }
}

export class BeginEdit {
    constructor(public payload: number) { }
}

export class StopEdit {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的应用程序一般从视图层来触发 Message，比如，在页面加载完毕后，就立即触发“加载数据”这个 Message，被触发的 Message 由更新模块来处理。&lt;/p&gt;
&lt;h3 id=&quot;更新&quot;&gt;更新&lt;/h3&gt;
&lt;p&gt;更新，即模型的更新方式，通常是一个函数，用 TypeScript 来描述这个函数就是：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;update(state: IHabbitPresetsState, msg: HabbitPresetsMsg): IHabbitPresetsState&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每当一个新的 Message 被触发的时候，Elm 架构便会将应用程序当前的模型跟接受到 Message 传入 update 函数，再把执行结果作为应用程序新的模型——这就是模型的更新。&lt;br/&gt;在 Elm 程序中，视图的渲染仅依赖模型中的数据，所以，模型的更新往往会导致视图的更新。&lt;/p&gt;
&lt;h3 id=&quot;视图&quot;&gt;视图&lt;/h3&gt;
&lt;p&gt;Elm 语言自带了一个前端的视图库，其特点是视图的更新仅依赖模型的更新，几乎所有的 Message 也都是由视图来触发。但在这篇文章里面，我将使用 Angular5 来演示效果，当然了，也可以使用 React 或者 jQuery 来实现视图，这取决于个人爱好。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;至此，我们大致的了解了一下 Elm 架构的几个要点：模型、更新、视图以及 Message。一个 Elm 架构的程序，通常是视图因为用户的动作触发特定 Message，然后由这个触发的 Message 跟当前应用的模型计算得出新的模型，新的模型的产生使得视图产生变化。&lt;/p&gt;
&lt;h2 id=&quot;开始实现&quot;&gt;开始实现&lt;/h2&gt;
&lt;p&gt;首先让我们写出一个空的框架：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export class ElmArch&amp;lt;TState, TMsgType&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TState 表示应用程序的模型类型，TMsgType 表示应用程序的消息联合类型。&lt;/p&gt;
&lt;p&gt;由上一节可以知道，Message 是应用程序能够运行的关键，Message 在运行时要能够手动产生，并且，Message 的触发还要能被监听，所以，可以使用 RxJS/Subject 来构建一个 Message 流。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export class ElmArch&amp;lt;TState, TMsgType&amp;gt; {
    private readonly $msg = new Subject&amp;lt;TMsgType&amp;gt;();
    send(msg: TMsgType) {
        this.$msg.next(msg);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里之所以定义一个 send 函数是为了更好的将代码封装起来，消息流对外只暴露一个触发消息的接口。&lt;/p&gt;
&lt;p&gt;接下来，我们可以考虑一下模型流的实现。他跟消息流很类似，首先要能被监听，其次，还接收到消息后还要能手动产生，所以也可以使用 Subject 来实现。但是这里我用的是 BehaviorSubject ，因为 Behavior Subject 能够保留最后产生的对象，这样我们就可以随时访问模型里面的数据，而不需要使用 Subscribe。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$res = new BehaviorSubject&amp;lt;TState&amp;gt;(initState);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，1/3 的工作已经完成了，现在来按照我们的要求，使用 rxjs 让消息流能正确的触发模型流的更新。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;this.$msg.scan(this.update, initState)
            .subscribe((s: TState) =&amp;gt; {
                    $res.next(s);
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;scan 是 rxjs 的一个操作符，类似于 JS 中的 reduce，LINQ 中的 Aggregate。因为设置了一个初始模型（initState），所以在消息流每次产生新的消息的时候，update 函数就可以接收到上一次计算出来的模型，以及最新接收到的消息，然后返回新的模型。也就是说，scan 将消息流转化为了新的模型流。接着订阅这个模型流，并用之前定义的 BehaviorSubject 来广播新的模型。&lt;/p&gt;
&lt;p&gt;这里就接近完成 1/2 的工作了，模型跟消息这两个的东西已经实现好了，接下来就继续实现更新。&lt;/p&gt;
&lt;p&gt;Elm 是一门函数式语言，模式匹配的能力比 js 不知道高到哪里去了，既然要模仿 Elm 架构，那么这个地方也要仿出来。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;type Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt; =
    [new (...args: any[]) =&amp;gt; TMsg, (acc: TState, msg: TMsg, $msg: Subject&amp;lt;TMsgType&amp;gt;) =&amp;gt; TState];

    /**
     * Pattern matching syntax
     * @template TMsg
     * @param {new (...args: any[]) =&amp;gt; TMsg} type constructor of Msg
     * @param {(acc: TState, msg: TMsg, $msg: Subject&amp;lt;TMsgType&amp;gt;) =&amp;gt; TState} reducer method to compute new state
     * @returns {Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt;}
     * @memberof ElmArch
     */
    caseOf&amp;lt;TMsg&amp;gt;(
        type: new (...args: any[]) =&amp;gt; TMsg,
        reducer: (acc: TState, msg: TMsg, $msg: Subject&amp;lt;TMsgType&amp;gt;) =&amp;gt; TState)
        : Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt; {
        return [type, reducer];
    }

    matchWith&amp;lt;TMsg&amp;gt;($msg: Subject&amp;lt;TMsgType&amp;gt;, patterns: Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt;[]) {
        return (acc: TState, msg: TMsg) =&amp;gt; {
            const state = acc;
            for (const it of patterns) {
                if (msg instanceof it[0]) {
                    return it[1](state, msg, $msg);
                }
            }
            throw new Error('Invalid Message Type');
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们定义了一个元组类型 &lt;code&gt;Pattern&lt;/code&gt; 用来表示模式匹配的语法，在这里面，主要需要实现的是基于类型的匹配，所以元组的第一个元素是消息类，第二个参数是当匹配成功时要执行的回调函数，用来计算新的模型，使用 &lt;code&gt;caseOf&lt;/code&gt; 函数可以创建这种元组。&lt;code&gt;matchWith&lt;/code&gt; 函数的返回值是一个函数，与 &lt;code&gt;scan&lt;/code&gt; 的第一个参数的签名相符合，第一个参数是最后被创建出来的模型，第二个参数是接收到的消息。在这个函数中，我们找到与接收到的消息相匹配的 pattern 元组，然后用这个元组的第二个元素计算出新的模型。&lt;/p&gt;
&lt;p&gt;用上面的东西就可以比较好的模拟模式匹配的功能了，写出来的样子像这样：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;const newStateAcc = matchWith(msg, [
            caseOf(GetMonth, (s, m, $m) =&amp;gt; {
                // blablabla
            }),
            caseOf(GetMonthRecv, (s, m) =&amp;gt; {
                // blablabla
            }),
            caseOf(ChangeDate, (s, m) =&amp;gt; {
                // blablabla
            }),
            caseOf(SaveRecord, (s, m, $m) =&amp;gt; {
                // blablabla
            }),
            caseOf(SaveRecordRecv, (s, m) =&amp;gt; {
                // blablabla
            })
        ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，之前用来构建模型流的地方就需要做一些改动：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;this.$msg.scan(this.matchWith(this.$msg, patterns), initState)
            .subscribe((s: TState) =&amp;gt; {
                    $res.next(s);
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在构建模型流需要依赖一个初始状态跟一个模式数组，那么就可以用一个函数封装起来，将这两个依赖项作为参数传入：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;begin(initState: TState, patterns: Pattern&amp;lt;any, TState, TMsgType&amp;gt;[]) {
        const $res = new BehaviorSubject&amp;lt;TState&amp;gt;(initState);
        this.$msg.scan(this.matchWith(this.$msg, patterns), initState)
            .subscribe((s: TState) =&amp;gt; {
                    $res.next(s);
            });
        return $res;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到目前为止，2/3 的工作就已经完成了，我们设计出了消息流、模型流以及处理消息的更新方法，做一个简单的计数器是完全没有问题的。&lt;a href=&quot;https://stackblitz.com/edit/angular-6uk7be?embed=1&amp;amp;file=app/hello.component.ts&quot;&gt;点击查看样例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是实际上，我们需要面对的问题远不止一个计数器这么简单，更多的情况是处理请求，有时候还需要处理消息的时候触发新的消息。对于异步的请求，需要在请求的响应中触发新的消息，可以直接调用 &lt;code&gt;$msg.next()&lt;/code&gt; ，对于需要在更新的操作中触发新的消息，也可以主动调用 &lt;code&gt;$msg.next()&lt;/code&gt; 这个函数就好了。&lt;/p&gt;
&lt;p&gt;不过，事情往往没有这么简单，因为模型流并不是从消息流直接通过 rxjs 的操作符转换出来的，而更新函数中模式匹配部分执行时间长短不一，这可能导致消息与模型更新顺序不一致的问题。我想出的解决方法是：对于同步的操作需要触发新的消息，就必须要保证当前消息处理完成后，模型的更新被广播出去后才能触发新的消息。基于这一准则，我就又添加了一些代码：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;type UpdateResult&amp;lt;TState, TMsgType&amp;gt; = TState | [TState, TMsgType[]];

/**
* Generate a result of a new state with a sets of msgs, these msgs will be published after new state is published
* @param {TState} newState
* @param {...TMsgType[]} msgs
* @returns {UpdateResult&amp;lt;TState, TMsgType&amp;gt;}
* @memberof ElmArch
*/
nextWithCmds(newState: TState, ...msgs: TMsgType[]): UpdateResult&amp;lt;TState, TMsgType&amp;gt; {
    if (arguments.length === 1) {
        return newState;
    } else {
        return [newState, msgs];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我添加了新的类型—— &lt;code&gt;UpdateResult&amp;lt;TState, TMsgType&amp;gt;&lt;/code&gt;，这个类型表示模型类型或模型类型与消息数组类型的元组类型。这么说起来确实有些绕口，这个类型存在的意义就是：Update 函数除了返回新的模型之外，还可以选择性的返回接下来要触发的消息。这样，单纯的模型流就变成了模型消息流，接着在 &lt;code&gt;subscribe&lt;/code&gt; 的地方，在原先的模型流产生新的模型的地方后面再去触发新的消息流，如果返回结果中有需要触发的消息的话。&lt;/p&gt;
&lt;p&gt;完整代码在此：&lt;a href=&quot;https://gist.github.com/ZeekoZhu/c10b30815b711db909926c172789dfd2&quot; class=&quot;uri&quot;&gt;https://gist.github.com/ZeekoZhu/c10b30815b711db909926c172789dfd2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用样例&quot;&gt;使用样例&lt;/h2&gt;
&lt;p&gt;在上面的 gits 中提到了一个样例，但是不是很完整，之后会放出完整例子。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;看到这里，你可能已经发现了，本文实现的这个小工具看起来跟 redux 挺像的，确实，redux 也是 js 程序员对 Elm 架构的致敬。通过把 Web 应用的逻辑拆解成一个个状态间改变的逻辑，可以帮助我们更好的理解所编写的东西，同时，也让 MV* 的思想得到进一步的展现，因为在编写 update 相关的代码的时候，可以在实现业务逻辑的同时而毫不碰触 UI 层面的东西，所以，正如本文开头提到的，视图可以是任何东西：React、Angular、jQuery，这都没关系，只要能够对模型的 Observable 流的改变做出响应， DOM API 也是可以的，可能，这就是所谓的响应式编程吧。&lt;/p&gt;
&lt;h3 id=&quot;对于普通的-angular-应用来说意味这什么&quot;&gt;对于普通的 Angular 应用来说意味这什么？&lt;/h3&gt;
&lt;p&gt;在我自己将这个小工具结合 Angular 的使用体验来看，最大的改变就是&lt;strong&gt;代码变得更加有规律&lt;/strong&gt;了，特别是处理异步并改变 UI 的场景，变得更容易套路化，更容易套路化就意味着更方便生成代码了。再一个，在 Angualr 中，如果组件依赖的所有输入都是 Observable 对象，那么可以将默认的变更检查策略改为：OnPush。这样，&lt;strong&gt;Angular 就不用对这个组件进行“脏检查”了&lt;/strong&gt;，只有在 Observable 发生更新的时候，才会去重新改变组件，这个好处，不言而喻。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 15:06:00 +0000</pubDate>
<dc:creator>不如隐茶去</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JacZhu/p/8455974.html</dc:identifier>
</item>
<item>
<title>ES6 学习笔记之一 块作用域与let和const - 刘兴伟</title>
<link>http://www.cnblogs.com/matchless/p/8455218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/matchless/p/8455218.html</guid>
<description>&lt;p&gt;---恢复内容开始---&lt;/p&gt;
&lt;p&gt;在学习ES6的块作用域和 let、const 之前，我们先来看看ES5以前的 var 关键字。&lt;/p&gt;
&lt;p&gt;var 关键字用于定义一个变量，通常我们会将其与变量的赋值合并为一条语句，就像下面这样（例1）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 30;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但实际情况是有些微妙的。&lt;/p&gt;
&lt;p&gt;在JavaScript中，变量的定义与否，虽然不像强类型语言那样重要，但也还是有所不同的。&lt;/p&gt;
&lt;p&gt;变量未定义，是一种未捕获类型的错误，输出的结果是变量未定义，同时终止后续脚本的执行，示例如下（例2）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
console.log(age);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
age is not defined.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;已经定义但未赋值的变量，输出的结果是undefined（这个undefined不是未定义，是指变量的值为undefined，这是JavaSript中的一个特殊的值）。示例如下（例3）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; age;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;var 定义变量语句，在JavaScript中会被编译器提前到整个作用域的最前端，无论它写在脚本的哪个位置。示例如下（例4）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;

&lt;p&gt;这个待遇只有 var 定义语句都有，赋值语句是不会被提前的。当我们在代码中写下一条定义的同时赋值的 var 语句时，编译器会将其拆分为定义语句和赋值语句，并将定义语句提前，而赋值语句仍然留在原处。&lt;/p&gt;
&lt;p&gt;请看下面的例子（例5）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30;&lt;br/&gt;console.log(age);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它与如下例子的输出是一致的（例6）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; age;
console.log(age);
age &lt;/span&gt;= 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;undefined
&lt;/span&gt;30
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还知道，JavaScript中变量可以不定义就使用，比如（例7）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
age = 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;这种直接赋值的语句，与定义的同时赋值，还是有所不同。参见下面的例子（例8）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
age &lt;/span&gt;= 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ReferenceError: age is not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之所以一例5有这么大的区别，在于这里只有变量赋值，没有 var 定义部分。编译器不会自动补充一个 var 定义并提前至作用域最前（或者说编译器补充了一个隐含的 var 定义，但是这个隐含的 var 定义不会被提前），因此第一个console.log语句会直接报出变量未定义的错误，之后的变量赋值和输出语句不被执行。&lt;/p&gt;
&lt;p&gt;为避免误用未定义的变量，在使用变量前，要养成在使用变量前用 var 进行定义的好习惯:)。除非在函数作用域内要使用父作用域的变量，这也是闭包存在的根源。&lt;/p&gt;
&lt;p&gt;如果可能，可以使用严格模式，即在脚本作用域的第一行，写下 &quot;use strict&quot;（注意要带着又引号哦）。这样做的一个好处是，WebStorm 这样的 IDE 会在为未定义的变量赋值时，直接给出警告。&lt;/p&gt;
&lt;h3&gt;块作用域&lt;/h3&gt;
&lt;p&gt;块作用域是指用一对花括号括住的语句块使用域。在ES5以前，是没有块作用域的，它只有函数作用域，因此 var 在非函数作用域的括号内，与在括号外，没有区别。为了保持向下兼容，在ES6中，var 在块作用域中仍然保持其原有性状。如下例（例9）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30&lt;span&gt;;
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未定义就赋值的变量，也与原来的表现一致（例10）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    age &lt;/span&gt;= 30&lt;span&gt;;
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要使块作用域别有不一样的意义，就需要 let 和 const，这两个关键字了。&lt;/p&gt;

&lt;p&gt;---恢复内容结束---&lt;/p&gt;
&lt;p&gt;在学习ES6的块作用域和 let、const 之前，我们先来看看ES5以前的 var 关键字。&lt;/p&gt;
&lt;p&gt;var 关键字用于定义一个变量，通常我们会将其与变量的赋值合并为一条语句，就像下面这样（例1）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 30;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但实际情况是有些微妙的。&lt;/p&gt;
&lt;p&gt;在JavaScript中，变量的定义与否，虽然不像强类型语言那样重要，但也还是有所不同的。&lt;/p&gt;
&lt;p&gt;变量未定义，是一种未捕获类型的错误，输出的结果是变量未定义，同时终止后续脚本的执行，示例如下（例2）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
console.log(age);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
age is not defined.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;已经定义但未赋值的变量，输出的结果是undefined（这个undefined不是未定义，是指变量的值为undefined，这是JavaSript中的一个特殊的值）。示例如下（例3）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; age;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;var 定义变量语句，在JavaScript中会被编译器提前到整个作用域的最前端，无论它写在脚本的哪个位置。示例如下（例4）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;

&lt;p&gt;这个待遇只有 var 定义语句都有，赋值语句是不会被提前的。当我们在代码中写下一条定义的同时赋值的 var 语句时，编译器会将其拆分为定义语句和赋值语句，并将定义语句提前，而赋值语句仍然留在原处。&lt;/p&gt;
&lt;p&gt;请看下面的例子（例5）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30;&lt;br/&gt;console.log(age);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它与如下例子的输出是一致的（例6）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; age;
console.log(age);
age &lt;/span&gt;= 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;undefined
&lt;/span&gt;30
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还知道，JavaScript中变量可以不定义就使用，比如（例7）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
age = 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;这种直接赋值的语句，与定义的同时赋值，还是有所不同。参见下面的例子（例8）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
age &lt;/span&gt;= 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ReferenceError: age is not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之所以一例5有这么大的区别，在于这里只有变量赋值，没有 var 定义部分。编译器不会自动补充一个 var 定义并提前至作用域最前（或者说编译器补充了一个隐含的 var 定义，但是这个隐含的 var 定义不会被提前），因此第一个console.log语句会直接报出变量未定义的错误，之后的变量赋值和输出语句不被执行。&lt;/p&gt;
&lt;p&gt;为避免误用未定义的变量，在使用变量前，要养成在使用变量前用 var 进行定义的好习惯:)。除非在函数作用域内要使用父作用域的变量，这也是闭包存在的根源。&lt;/p&gt;
&lt;p&gt;如果可能，可以使用严格模式，即在脚本作用域的第一行，写下 &quot;use strict&quot;（注意要带着又引号哦）。这样做的一个好处是，WebStorm 这样的 IDE 会在为未定义的变量赋值时，直接给出警告。&lt;/p&gt;
&lt;h3&gt;块作用域&lt;/h3&gt;
&lt;p&gt;块作用域是指用一对花括号括住的语句块使用域。在ES5以前，是没有块作用域的，它只有函数作用域，因此 var 在非函数作用域的括号内，与在括号外，没有区别。为了保持向下兼容，在ES6中，var 在块作用域中仍然保持其原有性状。如下例（例9）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30&lt;span&gt;;
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;undefined
&lt;/span&gt;30
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未定义就赋值的变量，也与原来的表现一致（例10）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    age &lt;/span&gt;= 30&lt;span&gt;;
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;p&gt;要使块作用域别有不一样的意义，就需要 let 和 const，这两个关键字了。&lt;/p&gt;
&lt;p&gt;let 关键字与 var 的作用类似，都是定义变量，也都可以在定义变量的同时，为变量赋值。不同之处有以下两点：&lt;/p&gt;
&lt;p&gt;第一，let 可以定义（仅在）块作用域内（有效）的变量。如下例所示（例11）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    let age &lt;/span&gt;= 30&lt;span&gt;;
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ReferenceError: age is not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对照例9，可以看出区别所在。&lt;/p&gt;
&lt;p&gt;第二，let 定义变量语句，不会被提前至作用域最前。见下例（例12）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
let age &lt;/span&gt;= 30;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ReferenceError: age is not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对照例4，可以看出区别所在。&lt;/p&gt;
&lt;p&gt;还有一个细节，let 和 var 都有在子作用域内定义与父作用域同名变量时，屏蔽父作用域同名变量的作用。&lt;/p&gt;
&lt;p&gt;见如下两例：&lt;/p&gt;
&lt;p&gt;（例13）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30&lt;span&gt;;
    console.log(age);
})();
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（例14）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
{
    let age &lt;/span&gt;= 30&lt;span&gt;;
    console.log(age);
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果均为：&lt;/p&gt;

&lt;p&gt;区别在于，如果在子作用域中，定义同名变量之前就使用该变量，对于 var 而言，由于其会被提前至本作用域的开头，因此得到的是undefined。对于let，不会被提前，却也不会使用父作用域的变量，而是报出引用错误。示例如下：&lt;/p&gt;
&lt;p&gt;（例15）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(age);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30&lt;span&gt;;
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;（例16）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
{
    console.log(age);
    let age &lt;/span&gt;= 30&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ReferenceError: age is not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 还要说明一点，在ES6中，所有具有语句块含义花括号括住的部分都构成块作用域，包括单纯的语句块、if语句块、while语句块、for语句块、break语句块和函数语句块。&lt;/p&gt;
&lt;p&gt;而出现在if语句块的条件部分，for语句块的循环变量赋值部分的let定义，相当于在语句块内部执行的let定义。&lt;/p&gt;
&lt;p&gt;尤其在for的循环变量定义，会在每次迭代中执行一遍，就相当于每次迭代定义一个变量，迭代结束销毁，循环多少次，生成多少个不同的循环变量。 这个特点的实际意义，可以用下面的两个示例说明。&lt;/p&gt;
&lt;p&gt;（例17）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
    fn[i] &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(i);
    }
}
fn[&lt;/span&gt;0&lt;span&gt;]();
fn[&lt;/span&gt;1&lt;span&gt;]();
fn[&lt;/span&gt;2]();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可能会预期其输出结果为：&lt;/p&gt;

&lt;p&gt;实际输出结果为：&lt;/p&gt;

&lt;p&gt;（例18）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; fn =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
    fn[i] &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(i);
    }
}
fn[&lt;/span&gt;0&lt;span&gt;]();
fn[&lt;/span&gt;1&lt;span&gt;]();
fn[&lt;/span&gt;2]();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;p&gt;在没有块作用域和let关键字之前，要实现同样效果，需要利用闭包（例19）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn  =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
    fn[i] &lt;/span&gt;= (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (i) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            console.log(i);
        }
    })(i);
}
fn[&lt;/span&gt;0&lt;span&gt;]();
fn[&lt;/span&gt;1&lt;span&gt;]();
fn[&lt;/span&gt;2]();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于 let 相较于 var 优势明显，又没有明显的缺点，在ES6兼容环境下，可以完全抛弃 var，而用 let 代替。&lt;/p&gt;
&lt;p&gt;《你不知道的JavaScript》中，提倡C语言风格的 let 使用方法，即在作用域的起始处使用 let 定义作用域内的所有变量，这样可以避免变量未定义就使用的情况发生。&lt;/p&gt;
&lt;p&gt;个人觉得还是按现代编程语言就近声明的惯例更合适，可以避免无意识的误用，而且在阅读时也不需要在代码间跳跃以寻找变量定义和赋值。不过如果能保持代码块的简短，又能坚持同一变量在同一作用域内不作两用的原则，其实放在哪儿都无关紧要。&lt;/p&gt;
&lt;p&gt;对于 const，其实没有太多需要说明的，常量定义而已。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 14:19:00 +0000</pubDate>
<dc:creator>刘兴伟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/matchless/p/8455218.html</dc:identifier>
</item>
<item>
<title>什么是递归?先了解什么是递归. - Pushy</title>
<link>http://www.cnblogs.com/Pushy/p/8455862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Pushy/p/8455862.html</guid>
<description>&lt;blockquote readability=&quot;5.1153846153846&quot;&gt;
&lt;p&gt;你好！欢迎阅读我的博文，你可以跳转到&lt;a href=&quot;http://blog.pushy.site/&quot;&gt;我的个人博客网站&lt;/a&gt;，会有更好的排版效果和功能。&lt;br/&gt;此外，本篇博文为本人Pushy原创，如需转载请注明出处：&lt;a href=&quot;http://blog.pushy.site/posts/1519134018&quot; class=&quot;uri&quot;&gt;http://blog.pushy.site/posts/1519134018&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一说起递归,我想每个人都不陌生.举个从小就听过的例子:从前有座山,山里有座庙,庙里有个和尚,和尚在讲故事,从前有座山,山里有座庙,庙里有个和尚,和尚在讲故事,从前有座山...,还有你从两面相对的镜子中看到的画面,其实都是抽象出来的递归现象,但是严格来说并不是递归,因为会一直重复下去,没有终止条件,那就称为死循环了.有关递归和死循环的异同我们之后会说到,那么现在先来了解一下什么是递归?&lt;/p&gt;
&lt;p&gt;那么什么是递归呢? &lt;strong&gt;要理解递归,就得先了解什么是递归&lt;/strong&gt;,实际上这句话就是一个递归.这么说可能不好理解,接下来我举个简单的例子来解释这段话的意义.&lt;/p&gt;
&lt;p&gt;假设我们现在都不知道什么是递归,我们自然想到打开浏览器,输入到谷歌的网页,我们点击搜索递归,然后我们在为维基百科中了解到了递归的基本定义,在了解到了递归实际上是和栈有关的时候,你又蒙圈了,什么是栈呢?数据结构没学清楚,此时的你只能又打开谷歌,搜索什么是栈.接下来你依次了解了内存/操作系统.在你基本了解好知识之后,你通过操作系统了解了内存,通过内存了解了栈,通过栈了解了什么是递归这下你恍然大悟!原来这就是递归啊!&lt;/p&gt;
&lt;p&gt;这下应该有点明白了吧,这个过程其实就是递归的过程,如果不了解递归,那就先了解什么是递归,可能你会说这是个循环并不是递归,我们前面说到,递归是需要终止条件的,那么&lt;strong&gt;你明白递归是什么&lt;/strong&gt;其实就是终止条件.整个过程,搜索引擎充当递归函数(只是形象的假设);在你去依次查找递归/栈/内存/操作系统的过程为前行阶段,在你都了解完之后,反回去了解含义的过程为退回阶段.如果还是不太清楚,可以接着看下面的例子&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;2. 示例:&lt;/h2&gt;
&lt;p&gt;也许之前你在网络上看到过这张图片:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.pushy.site/pic/xiaoliyu.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上这张图就很形象地表达出了递归,这句&lt;strong&gt;吓得我抱起了抱着抱着抱着我的小鲤鱼的我的我的我&lt;/strong&gt;如果从字面意义上看可能看不出是什么意思,那么我们可以通过代码来实现同样的效果:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Recursion&lt;/span&gt;(depth) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'抱着'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;depth) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'我的小鲤鱼'&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;Recursion&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;depth)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;// 递归调用&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'的我'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'吓得我抱起了'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;Recursion&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在终端的打印结果为如下,可以看到和上面的那段话是一样的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.pushy.site/pic/xiaoliyuconsole.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码其实十分简单,但是需要理解的是:&lt;code&gt;if&lt;/code&gt;代码块的条件(&lt;code&gt;!depth&lt;/code&gt;)为递归调用的终止条件,在&lt;code&gt;else&lt;/code&gt;代码块内递归调用函数.我们前面有说到递归的过程是存在前行和退回阶段的,那么在前行阶段我们在每次调用函数后,打印出了&quot;抱着&quot;,并且当&lt;code&gt;depth≠0&lt;/code&gt;时重新调用该函数;在退回阶段,将会去执行代码&lt;code&gt;console.log('的我');&lt;/code&gt;再打印出&quot;的我&quot;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/people/chuyue/activities&quot;&gt;褚跃跃&lt;/a&gt;的图也能比较清楚地反映出这个过程:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.pushy.site/pic/enterReturn.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了!这下你应该明白什么是递归了吧?如果你还没有明白什么是递归的话,你可以看&lt;a href=&quot;http://www.cnblogs.com/Pushy/p/8455862.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用&quot;&gt;3. 应用:&lt;/h2&gt;
&lt;h3 id=&quot;斐波拉契数列&quot;&gt;3.1 斐波拉契数列:&lt;/h3&gt;
&lt;p&gt;有关递归应用的应用有很多,例如注明的&lt;a href=&quot;https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin&amp;amp;fromid=10078434&amp;amp;fromtitle=%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97&quot;&gt;斐波拉契数列&lt;/a&gt;就可以通过递归来实现:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; fib(x):
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 当x &amp;gt; 2时,开始递归调用fib()函数:&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; fib(x &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; fib(x &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)

&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(fib(&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;))  &lt;span class=&quot;co&quot;&gt;# 打印结果为:8&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要对&lt;code&gt;i&amp;lt;2&lt;/code&gt;时的特殊情况做出判断,当&lt;code&gt;x==0&lt;/code&gt;时,直接返回&lt;code&gt;0&lt;/code&gt;,当&lt;code&gt;x==1&lt;/code&gt;时,直接返回&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;遍历文件&quot;&gt;3.2 遍历文件:&lt;/h3&gt;
&lt;p&gt;首先我们需要了解遍历的算法:定义的&lt;code&gt;file_display&lt;/code&gt;函数以某个目录(&lt;code&gt;/home/pushy&lt;/code&gt;)作为遍历的起点.遇到一个子目录时,就先接着遍历子目录(递归调用函数);遇到一个文件时,就直接对改文件进行操作(这里只打印出文件的文件名):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; os

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; file_display(filepath):
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; each &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; os.listdir(filepath):
        &lt;span class=&quot;co&quot;&gt;# 得到文件的绝对路径:&lt;/span&gt;
        absolute_path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; os.path.join(filepath, each)
        &lt;span class=&quot;co&quot;&gt;# 得到是否为文件还是目录的布尔值:&lt;/span&gt;
        is_file &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; os.path.isfile(absolute_path)
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; is_file:
            &lt;span class=&quot;co&quot;&gt;# 当前的绝对路径为文件:&lt;/span&gt;
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(each)
        &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
            &lt;span class=&quot;co&quot;&gt;# 当前的绝对路径为目录:&lt;/span&gt;
            file_display(absolute_path)

file_display(&lt;span class=&quot;st&quot;&gt;'/home/pushy'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以遍历到&lt;code&gt;/home/pushy&lt;/code&gt;路径下的所有文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/Pushy/p/pic/readFile.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外我们还可以使用递归来创建目录:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; os

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; createFile(dirname):
    exits &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; os.path.exists(dirname)
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; exits:
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        &lt;span class=&quot;co&quot;&gt;# 开始递归调用函数,并接受其返回值:&lt;/span&gt;
        rec_result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; createFile(os.path.dirname(dirname))
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; rec_result:
            &lt;span class=&quot;co&quot;&gt;# 如果不存在该目录,则创建dirname的目录,并返回已经创建(存在)的值True:&lt;/span&gt;
            os.mkdir(dirname)
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;

createFile(&lt;span class=&quot;st&quot;&gt;'./aa/bb/cc'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;循环与递归&quot;&gt;4. 循环与递归:&lt;/h2&gt;
&lt;p&gt;好了,递归的知识差不多介绍完了.如果看完上边大概已经了解了循环和递归的区别了.对了!简单来说,循环是有去无回,而递归则是有去有回(因为存在终止条件).&lt;/p&gt;
&lt;p&gt;举个栗子,你用你手中的钥匙打开一扇门,结果去发现前方还有一扇门,紧接着你又用钥匙打开了这扇门,然后你又看到一扇们...但是当你开到某扇门时,发现前方是一堵墙无路可走了,你选择原路返回.这就是递归&lt;/p&gt;
&lt;p&gt;但是如果你打开一扇门后,同样发现前方也有一扇们,紧接着你又打开下一扇门...但是却一直没有碰到尽头,这就是循环.&lt;/p&gt;

&lt;blockquote readability=&quot;1.0714285714286&quot;&gt;
&lt;p&gt;参考资料:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/20507130&quot;&gt;[知乎]什么是递归&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://nqdeng.github.io/7-days-nodejs/#3.3.1&quot;&gt;七天学会NodeJs--递归算法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 20 Feb 2018 13:38:00 +0000</pubDate>
<dc:creator>Pushy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Pushy/p/8455862.html</dc:identifier>
</item>
<item>
<title>Web Storage - 超然haha</title>
<link>http://www.cnblogs.com/chaoran/p/8455825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaoran/p/8455825.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;1. 引言&lt;/h2&gt;
&lt;p&gt;本地存储：避免取回数据前页面空白，减少请求服务器次数&lt;br/&gt;chrome浏览器，查看resources&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801580/201802/801580-20180220211516154-1129637835.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;常用存储方案&quot;&gt;2. 常用存储方案&lt;/h2&gt;
&lt;h4 id=&quot;indexdb&quot;&gt;2.1. indexDB&lt;/h4&gt;
&lt;p&gt;类似SQL数据库的结构化数据存储机制，能够在客户端存储大量的结构化数据&lt;br/&gt;缺点： 兼容性不好，浏览器支持度低&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801580/201802/801580-20180220211541606-203310780.png&quot; alt=&quot;cookie_limit!(/img/in-post/post-js-storage/cookie_limit.png)[][](https://images2018.cnblogs.com/blog/801580/201802/801580-20180220211630867-626139653.png)&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;cookie&quot;&gt;2.2. cookie&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;HTTP cookie 「浏览器」提供的一种机制，通过document.cookie访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;既可以服务器端设置，也可以客户端设置，会跟随任意HTTP请求发送&lt;/li&gt;
&lt;li&gt;cookie是存于用户硬盘的一个文件，这个文件通常对应于一个域名，也就是说，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;用途&quot;&gt;2.2.1. 用途&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;保存用户信息&lt;/li&gt;
&lt;li&gt;购物车&lt;/li&gt;
&lt;li&gt;跟踪用户行为&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;查找过程&quot;&gt;2.2.2. 查找过程&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;用户访问站点&lt;/li&gt;
&lt;li&gt;web应用读取cookie包含的信息&lt;/li&gt;
&lt;li&gt;再次访问时，浏览器在本地硬盘上查找相关cookie&lt;/li&gt;
&lt;li&gt;若存在该cookie，添加到request header cookie字段中，与该HTTP请求一起发送&lt;br/&gt;&lt;em&gt;存储在cookie的数据每次都会自动添加到请求中，滥用则降低性能&lt;/em&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801580/201802/801580-20180220211800805-1373661219.png&quot; alt=&quot;cookie&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;cookie相关属性&quot;&gt;2.2.3. cookie相关属性&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801580/201802/801580-20180220211820434-1302825503.png&quot; alt=&quot;resources_cookie&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;domain 和 path 共同决定了cookie的共享页面&lt;/p&gt;
&lt;em&gt;例如cookie设置为&quot;domain=.google.com.hk; path=/webhp&quot;，那么只有&quot;.google.com.hk/webhp&quot;及&quot;/webhp&quot;下的任一子目录如&quot;/webhp/aaa&quot;或&quot;/webhp/bbb&quot;会发送cookie信息，而&quot;.google.com.hk&quot;就不会发送，即使它们来自同一个域。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;expries 和 max-age 是用来决定cookie的生命周期&lt;/li&gt;
&lt;li&gt;secure cookie的安全标志&lt;br/&gt;cookie中唯一一个非名值对儿的部分，默认为空，不论是 http 请求还是 https 请求，均会发送cookie。&lt;br/&gt;指定后，cookie只有在使用SSL连接（如HTTPS请求）时才会发送到服务器&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;httponly&lt;br/&gt;服务端设置&lt;br/&gt;限制客户端脚本对cookie的访问，将 cookie 设置成 httponly 可以减轻xss攻击的危害&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;cookie设置&quot;&gt;2.2.4. cookie设置&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;服务器端&lt;br/&gt;通过发送一个名为 Set-Cookie 的HTTP头来创建一个cookie，作为 Response Headers 的一部分，每个Set-Cookie 表示一个 cookie（如果有多个cookie,需写多个Set-Cookie），每个属性也是以名/值对的形式（除了secure），属性间以分号加空格隔开。格式如下：&lt;br/&gt;&lt;code&gt;Set-Cookie: name=value[; expires=GMTDate][; domain=domain][; path=path][; secure]&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801580/201802/801580-20180220212306641-1668427464.png&quot; alt=&quot;cookie_server&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;只有name，value发送到服务器，其他是给浏览器的指示&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;客户端&lt;br/&gt;&lt;code&gt;document.cookie = &quot;name=value[; expires=GMTDate][; domain=domain][; path=path][; secure]&quot;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var cookie = {
    /**设置cookie 
     ** name 标识
     ** value 值
     ** options {
     **   'path': '访问路径',
     **   'domain' : '域名',
     **   'expire' : 过期时间
     }
     **/
    setCookie : function(name,value,options){
      var options = options ? options : {},
          path = options.path ? options.path : '/',
          domain = options.domain ? options.domain : document.domain,
          time = options.expire ? (new Date().getTime() + options.expire * 1000) : '',
          expire = new Date(time).toUTCString();
      document.cookie = encodeURIComponent(name) + &quot;=&quot;+ encodeURIComponent(value) + &quot;;expires=&quot; + expire + 
                        &quot;;domain=&quot; + domain + &quot;;path=&quot; + path;
    },
    //获取cookie
    getCookie: function(name){
      var arr,
          reg=new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;);
      if(arr=document.cookie.match(reg)){
         console.log(arr);
         return unescape(arr[2]);
      }
      return null;

    },
    //移除cookie
    removeCookie: function(name){
      var val = this.getCookie(name);
      if(val != null){
        this.setCookie(name,val, {
          expire : - 1
        })
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;优缺点&quot;&gt;2.2.5. 优缺点&lt;/h5&gt;
&lt;p&gt;优点： 兼容性好&lt;br/&gt;缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;增加了网络流量&lt;/li&gt;
&lt;li&gt;数据容量有限（最多4kb，浏览器间有区别）&lt;/li&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;sessionstorage和localstorage&quot;&gt;2.3. sessionStorage和localStorage&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;key value形式存储&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801580/201802/801580-20180220211945230-1069099729.png&quot; alt=&quot;storage_support&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;localStorage - 没有时间限制的数据存储&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;sessionStorage - 针对一个 session 的数据存储&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(typeof(Storage)!==&quot;undefined&quot;)
{
// 是的! 支持 localStorage  sessionStorage 对象!
// 一些代码.....
} else {
// 抱歉! 不支持 web 存储。
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用&quot;&gt;2.3.1. 使用&lt;/h5&gt;
&lt;code&gt;localStorage.sitename = &quot;菜鸟教程&quot;;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;localStorage.removeItem(&quot;lastname&quot;);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;保存数据：&lt;br/&gt;&lt;code&gt;localStorage.setItem(key,value);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;读取数据：&lt;br/&gt;&lt;code&gt;localStorage.getItem(key);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除单个数据：&lt;br/&gt;&lt;code&gt;localStorage.removeItem(key);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除所有数据：&lt;br/&gt;&lt;code&gt;localStorage.clear();&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;得到某个索引的key：localStorage.key(index);&lt;/p&gt;
&lt;h5 id=&quot;适用范围&quot;&gt;2.3.2. 适用范围&lt;/h5&gt;
&lt;/li&gt;
&lt;li&gt;不需要和服务器进行交互的一些数据&lt;br/&gt;比如导航栏当前的状态，一些普通的数据进行缓存。甚至我们可以存储html片段，js或者css文件段&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;很多应用通过版本控制来存储一些不经常改动的js/css文件。减少用户请求带宽的同时优化整个页面的加载速度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;注意&quot;&gt;2.3.3. 注意&lt;/h5&gt;
&lt;p&gt;localstorage存储的值只能是字符串的形式&lt;br/&gt;当我们存储数据为引用对象的时候，会默认调用对象的toString方法，转化为字符串存储&lt;br/&gt;&lt;em&gt;所以我们在存储数组时，存储的数据会将数据项以,隔开，解析的时候需要我们分解成为数组再操作。而对于对象，我们需要用JSON.stringify转化存储，获取数据后再用JSON.parse转化为对象&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;web-storage-与-cookie&quot;&gt;2.4. web storage 与 cookie&lt;/h4&gt;
&lt;p&gt;web storage优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;web storage 为了更大容量存储，一般限制为同一域名5M，，并且不同域名的数据不能相互访问&lt;/li&gt;
&lt;li&gt;localStorage是存储在用户本地的浏览器上，不像cookie一样携带在http请求头部的字段里面，这有效的节约了带宽&lt;/li&gt;
&lt;li&gt;cookie需要指定作用域，不可跨域调用&lt;/li&gt;
&lt;li&gt;拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;cookie优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;cookie作用是与服务器交互，作为HTTP规范的一部分，web storage仅仅为&lt;strong&gt;本地存储&lt;/strong&gt;而生&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考：&lt;a href=&quot;https://segmentfault.com/a/1190000004743454&quot;&gt;常用的本地存储——cookie篇&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 13:22:00 +0000</pubDate>
<dc:creator>超然haha</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaoran/p/8455825.html</dc:identifier>
</item>
<item>
<title>ES6中let和闭包 - 逸丶风</title>
<link>http://www.cnblogs.com/yifeng555/p/8455414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yifeng555/p/8455414.html</guid>
<description>&lt;p&gt;　　在开始本文之前我们先来看一段代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;){
    arr[i]&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
    }
}
console.log(arr[&lt;/span&gt;3]());//10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然这段代码输出10，并没有向我们期望的返回3，原因也很简单（js的变量提升）函数在调用时候访问的是一个全局作用域的i，此时for循环已经执行完毕，全局变量i=10；&lt;/p&gt;
&lt;p&gt;在ES5标准中，我们要想返回期望的3，通常的做法也很简单,就是让数组中的每个函数有单独的作用域，那么我们只要构造一个立即执行函数即可（js中没有块级作用域，只区分函数作用域和全局作用域）就像下面这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; array=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;){
    array[i]&lt;/span&gt;=(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }
    })(i);
}
console.log(array[&lt;/span&gt;3]());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一来数组的每个函数就处于一个立即执行函数的函数作用域中，该立即执行函数传入i,其实for循环执行了如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    array[0]=(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }
    })(&lt;/span&gt;0&lt;span&gt;);
    array[&lt;/span&gt;1]=(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }
    })(&lt;/span&gt;1&lt;span&gt;);
    array[&lt;/span&gt;2]=(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }
    })(&lt;/span&gt;2&lt;span&gt;);
……&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样一来，数字组中每个函数对应一个单独的函数作用域（立即执行函数的）这里共创建了10个函数作用域，这些函数作用域里的i值就是执行时候传入的0……9，当执行&lt;/p&gt;
&lt;p&gt;array[3]();时候函数访问的i值是其对应的立即执行函数作用域里的 i，而不是全局的i值，这样我们就得到了预期的效果。&lt;/p&gt;
&lt;p&gt;说得到这里我们简单来说一下闭包，闭包可以理解为一个闭包就是一个没有释放资源的栈区，栈区内的变量处于激活状态。上面的例子中for循环在执行时系统分配内存，js执行线程创建执行栈区，执行时候检测到立即执行函数里的变量i被内部函数引用，所以该栈区在内存中没有被释放，函数（数组元素）被调用时候根据作用链首先访问到的是上一级作用域（立即执行函数）的变量。&lt;/p&gt;
&lt;p&gt;　　这里不再详细介绍闭包，如果想详细了解闭包请阅读《javascript高级程序设计》第7章&lt;/p&gt;
&lt;p&gt;　　前面提到js中并没有块级作用域，只区分全局作用域和函数作用域，在ES6中let实际是为js新增了块级作用域，例如下面代码不用创造函数作用域就可以让每个数组里的函数访问各自作用域里的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let arr=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i=0;i&amp;lt;10;i++&lt;span&gt;){
    arr[i]&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
    }
}
console.log(arr[&lt;/span&gt;3]());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到我们并没有像之前那样构造一个函数作用域就能实现我们期望的效果，引入块级作用域之后更方便我们书写和理解代码，上述代码中for循环之后的{}是块级作用域，每次循环时候每个返回的函数引用的是其对应块作用域的变量，稍微改一下代码看着形象些：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let arr=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i=0;i&amp;lt;10;i++&lt;span&gt;){
    let k&lt;/span&gt;=&lt;span&gt;i;
    arr[k]&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; k;
    }
}
console.log(arr[&lt;/span&gt;3]());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见ES6引入块作用域之后我们构造闭包函数更方便了。&lt;/p&gt;
&lt;p&gt;这里不多叙述let和const的相关内容，如果之前没接触ES6的小伙伴建议阅读阮一峰老师的《ES6标准入门》。&lt;/p&gt;
&lt;p&gt;在这里再提一点，很多人看完概念之后，第一印象都是：“const 是表示不可变的值，而 let 则是用来替换原来的 var 的。”很多时候把let当做是var的替代品，凡是声明变量就用let，你很可能写出下面代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义常量&lt;/span&gt;
const REG_GET_INPUT = /^\d{1,3}$/&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义配置项&lt;/span&gt;
let config =&lt;span&gt; {
  isDev : &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
  pubDir: &lt;/span&gt;'./admin/'&lt;span&gt;
}

let path &lt;/span&gt;= require('path'&lt;span&gt;);
let HtmlWebpackPlugin &lt;/span&gt;= require('html-webpack-plugin'&lt;span&gt;);
let CleanWebpackPlugin &lt;/span&gt;= require('clean-webpack-plugin');
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　const 的定义是不可重新赋值的值，与不可变的值(immutable value)不同；const 定义的 Object，在定义之后仍可以修改其属性。&lt;/p&gt;
&lt;p&gt;所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以cosnt做定义。反之就 let 而言，他的使用场景应该是相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他。&lt;/p&gt;
&lt;p&gt;猜想：就执行效率而言，const 由于不可以重新赋值的特性，所以可以做更多语法静态分析方面的优化，从而有更高的执行效率。&lt;/p&gt;
&lt;p&gt;所以上面代码中，所有使用 let 的部分，其实都应该是用 const 的。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 09:13:00 +0000</pubDate>
<dc:creator>逸丶风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yifeng555/p/8455414.html</dc:identifier>
</item>
</channel>
</rss>