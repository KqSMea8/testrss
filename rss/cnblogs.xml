<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Adobe Html5 Extension开发初体验 - 24K纯开源</title>
<link>http://www.cnblogs.com/csuftzzk/p/adobe_html_extension_development.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csuftzzk/p/adobe_html_extension_development.html</guid>
<description>&lt;p&gt;      Adobe公司出品的多媒体处理软件产品线较多，涵盖了音视频编辑、图像处理、平面设计、影视后期等领域。为了扩展软件的功能，Adobe公司为开发者提供了两种方式来增加软件的功能：分别是插件（&lt;strong&gt;Plugin&lt;/strong&gt;）和扩展（&lt;strong&gt;Extension&lt;/strong&gt;）。去年利用官方提供的SDK开发过两款Premiere插件，分别用于导入自定义格式的多媒体文件和视频流预览。近来体验了一下Adobe Extension的开发。&lt;/p&gt;
&lt;p&gt;      Adobe Plugin一般用于提供更靠近底层的功能。官方出于效率的考虑，提供的插件SDK是基于C++语言的。而Adobe Extension则偏向与提供上层应用的扩展，在Adobe CS时代是采用的&lt;strong&gt;Flash&lt;/strong&gt;形式实现的。在Adobe CC时代则提供了HTML5实现，这使得开发者们可以接口&lt;strong&gt;HTML5&lt;/strong&gt;, &lt;strong&gt;CSS3&lt;/strong&gt;, &lt;strong&gt;Javascript&lt;/strong&gt;甚至是&lt;strong&gt;NodeJS&lt;/strong&gt;来开发。因为Adobe在PremierePro里面嵌入了&lt;strong&gt;CEF&lt;/strong&gt;，可以高效的解析渲染HTML5、运行Nodejs程序。而Nodejs则能实现系统功能的调用，简直不要太叼！在这篇文章中，我大概总结了一下使用HTML5来开发一款Adobe扩展的心路历程。&lt;/p&gt;
&lt;p&gt;      我们要做的一款扩展非常简单，如下图所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114141355031-1061645010.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;      这是国外一家知名的视频素材交易网站&lt;strong&gt;Pond5&lt;/strong&gt;开发的一款PremierePro扩展，它可以让用户在Pr中登陆网站、下载预览素材、购买高清素材、自动导入视频或自动替换视频。使得用户无需额外打开浏览器登陆网站操作，极大的提高了用户的使用体验。类似的还有&lt;strong&gt;shutterstock&lt;/strong&gt;开发的插件：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114141508827-534944786.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;      Adobe官方基于eclipse推出了一个用于开发Adobe Html5 Extension的IDE。因此，我们按如下流程先来配置下开发环境：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;下载 Eclipse，最好是3.6或更高版本，以及Extension Builder&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114141809937-1014813664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装Adobe Premiere Pro CC 2014/2015.&lt;/li&gt;
&lt;li&gt;配置elicpse的“target application”和&quot;Service Manager&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114141947499-1391002633.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114141958343-60990382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开调试模式：在注册表中添加 'PlayerDebugMode'字段&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114142036827-1655865232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      配置结束，到这里可以利用eclipse生成extension的模板工程了。生成的模板工程非常简单，面板里面只有一个默认的按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114142337609-463676697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; manifest.xml文件&lt;/h2&gt;
&lt;p&gt;      Adobe Html5 Extension的开发，最重要的一个文件就是manifest.xml。这个文件描述了这个extension的基本信息，以便Adobe宿主程序能够正常识别加载。其大体内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&amp;gt;
&amp;lt;ExtensionManifest ExtensionBundleId=&quot;com.example.helloworld&quot; ExtensionBundleName=&quot;Hello world&quot; ExtensionBundleVersion=&quot;1.0&quot; Version=&quot;4.0&quot;&amp;gt;
  &amp;lt;ExtensionList&amp;gt;
    &amp;lt;Extension Id=&quot;com.example.helloworld.extension&quot; Version=&quot;1.0&quot;/&amp;gt;
  &amp;lt;/ExtensionList&amp;gt;
  &amp;lt;ExecutionEnvironment&amp;gt;
    &amp;lt;HostList&amp;gt;
      &amp;lt;Host Name=&quot;PHXS&quot; Version=&quot;[14.0,14.9]&quot;/&amp;gt;
    &amp;lt;/HostList&amp;gt;
    &amp;lt;LocaleList&amp;gt;
      &amp;lt;Locale Code=&quot;All&quot;/&amp;gt;
    &amp;lt;/LocaleList&amp;gt;
    &amp;lt;RequiredRuntimeList&amp;gt;
      &amp;lt;RequiredRuntime Name=&quot;CSXS&quot; Version=&quot;4.0&quot;/&amp;gt;
    &amp;lt;/RequiredRuntimeList&amp;gt;
  &amp;lt;/ExecutionEnvironment&amp;gt;
  &amp;lt;DispatchInfoList&amp;gt;
    &amp;lt;Extension Id=&quot;com.example.helloworld.extension&quot;&amp;gt;
      &amp;lt;DispatchInfo&amp;gt;
        &amp;lt;Resources&amp;gt;
          &amp;lt;MainPath&amp;gt;./index.html&amp;lt;/MainPath&amp;gt;
        &amp;lt;/Resources&amp;gt;
        &amp;lt;UI&amp;gt;
          &amp;lt;Type&amp;gt;Panel&amp;lt;/Type&amp;gt;
          &amp;lt;Menu&amp;gt;Hello world&amp;lt;/Menu&amp;gt;
          &amp;lt;Geometry&amp;gt;
            &amp;lt;Size&amp;gt;
              &amp;lt;Height&amp;gt;400&amp;lt;/Height&amp;gt;
              &amp;lt;Width&amp;gt;400&amp;lt;/Width&amp;gt;
            &amp;lt;/Size&amp;gt;
          &amp;lt;/Geometry&amp;gt;
        &amp;lt;/UI&amp;gt;
      &amp;lt;/DispatchInfo&amp;gt;
    &amp;lt;/Extension&amp;gt;
  &amp;lt;/DispatchInfoList&amp;gt;
&amp;lt;/ExtensionManifest&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中，&lt;strong&gt;BundleName&lt;/strong&gt;, &lt;strong&gt;BundleId&lt;/strong&gt;, &lt;strong&gt;BundleVersion&lt;/strong&gt;由开发者来定，一般就是按照正常的版本迭代来确定。最重要的是&lt;strong&gt;HostList&lt;/strong&gt;和&lt;strong&gt;RequiredRuntimeList&lt;/strong&gt;这两个标签的内容。&lt;strong&gt;HostList&lt;/strong&gt;里面确定了这个extension支持哪些宿主程序（如PremierePro, After Effects等等）。下面的代码指明了多个宿主程序都可以加载：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;HostList&amp;gt;
        &amp;lt;Host Name=&quot;PPRO&quot; Version=&quot;[7.0, 10.0]&quot; /&amp;gt;
        &amp;lt;Host Name=&quot;PHSP&quot; Version=&quot;[14.0, 16.0]&quot; /&amp;gt;
        &amp;lt;Host Name=&quot;PHXS&quot; Version=&quot;[14.0, 14.9]&quot; /&amp;gt; 
&amp;lt;/HostList&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里只支持&lt;strong&gt;Photoshop Extended&lt;/strong&gt;，其Host ID对应为&lt;strong&gt;PHXS&lt;/strong&gt;，其他宿主程序的Host ID及版本如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114142723437-727372111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      注意到Version使用了一个方括号的形式&lt;strong&gt;[14.0, 14.9]&lt;/strong&gt;，这表明这个extension支持版本14.0-14.9的Photoshop Extended ，高于这个版本或者低于这个版本的Photoshop Extended是不会加载这个extension的。但是，如果要指定某版本以上的所有版本都支持该如何指定？比如要支持2014以上的PremierePro CC，如何指定这个Version呢？只写上最低版本号即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;HostList&amp;gt;
        &amp;lt;Host Name=&quot;PPRO&quot; Version=&quot;7.0&quot; /&amp;gt;
        &amp;lt;Host Name=&quot;PHSP&quot; Version=&quot;14.0&quot; /&amp;gt;
        &amp;lt;Host Name=&quot;PHXS&quot; Version=&quot;14.0&quot; /&amp;gt;
        &amp;lt;Host Name=&quot;IDSN&quot; Version=&quot;9.0&quot;/&amp;gt;
        &amp;lt;Host Name=&quot;ILST&quot; Version=&quot;17.0&quot; /&amp;gt;
&amp;lt;/HostList&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另外，就是&lt;strong&gt;RequiredRuntimeList&lt;/strong&gt;这个标签了。这个标签指定了运行时的&lt;strong&gt;CEP&lt;/strong&gt;版本。所谓的CEP是&lt;strong&gt;Common Extensibility Platform&lt;/strong&gt;的简称，它提供了一个核心服务集，便于开发者执行&lt;strong&gt;Extendscript&lt;/strong&gt;代码、探查宿主程序的环境变量、处理extension与host之间发送的事件。在之前这个服务集叫做&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt; Creative Suite Extensible Services&lt;/strong&gt;，简称&lt;strong&gt;CSXS&lt;/strong&gt;。因此，在一些配置文件中仍然可以看到CSXS这个缩写。CEP最初版本为4.x，发展至今已经有5个大版本了，最新的版本为8.x，支持最新的Adobe CC 2018宿主程序。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114142913874-242413090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      如上图，如果我们要支持初代CC版本的宿主程序的话，RequiredRuntime的Version就要设置为4.0。否则是无法正常加载extension的。此外，如果想在扩展中访问文件系统的话，还得指定额外一些参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;CEFCommandLine&amp;gt;
        &amp;lt;Parameter&amp;gt;--allow-file-access&amp;lt;/Parameter&amp;gt;
        &amp;lt;Parameter&amp;gt;--allow-file-access-from-files&amp;lt;/Parameter&amp;gt;
        &amp;lt;Parameter&amp;gt;--enable-nodejs&amp;lt;/Parameter&amp;gt;
&amp;lt;/CEFCommandLine&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;禁用签名验证&lt;/h2&gt;
&lt;p&gt;      我们在开发的时候，需要随时调整extension的代码。而Adobe宿主程序对于那些没有签名的extension，是置之不理不会加载的。因此，我们需要把调试模式打开，这样开发的时候就不必对扩展进行签名了：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;在mac上，打开&lt;strong&gt;~/Library/Preferences/com.adobe.CSXS.6.plist这个文件并增加一行，&lt;/strong&gt;键名为&lt;strong&gt;PlayerDebugMode&lt;/strong&gt;，类型为 &quot;String&quot;,值设置为&quot;1&quot;.&lt;/li&gt;
&lt;li&gt;在Windows上， 打开注册表项：&lt;strong&gt;HKEY_CURRENT_USER/Software/Adobe/CSXS.6&lt;/strong&gt;，增加一项名为&lt;strong&gt;PlayerDebugMode&lt;/strong&gt;, 类型为 &quot;String&quot;, 值为 &quot;1&quot;的键值对.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;      注意：&lt;span&gt;如果宿主程序的版本不同，对应的文件可能也不同。比如CC2017,就要把上面对应部分改成 &quot;CSXS.7&quot;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;chrome调试&lt;/h2&gt;
&lt;p&gt;      chrome调试工具有助于观察extension的输出、探查extension的DOM结构，对于调试起着非常大的帮助。启用chrome调试工具也很简单，在extension文件夹的根目录创建一个名为.debug的文件，写入下述内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;ExtensionList&amp;gt;
    &amp;lt;Extension Id=&quot;com.pond5.marketplace&quot;&amp;gt;
        &amp;lt;HostList&amp;gt;
            &amp;lt;Host Name=&quot;PHXS&quot; Port=&quot;8000&quot;/&amp;gt;
            &amp;lt;Host Name=&quot;IDSN&quot; Port=&quot;8001&quot;/&amp;gt;
            &amp;lt;Host Name=&quot;AICY&quot; Port=&quot;8002&quot;/&amp;gt;
            &amp;lt;Host Name=&quot;ILST&quot; Port=&quot;8003&quot;/&amp;gt;
            &amp;lt;Host Name=&quot;PPRO&quot; Port=&quot;8004&quot;/&amp;gt;
            &amp;lt;Host Name=&quot;PRLD&quot; Port=&quot;8005&quot;/&amp;gt;
            &amp;lt;Host Name=&quot;FLPR&quot; Port=&quot;8006&quot;/&amp;gt;
            &amp;lt;Host Name=&quot;AUDT&quot; Port=&quot;8007&quot;/&amp;gt;
        &amp;lt;/HostList&amp;gt;
    &amp;lt;/Extension&amp;gt;
&amp;lt;/ExtensionList&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个列表说明了调试不同的宿主程序时用的端口不一样。以Pond5为例，其.debug文件内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; 
&amp;lt;ExtensionList&amp;gt;
    &amp;lt;Extension Id=&quot;com.pond5.ppro&quot;&amp;gt;
        &amp;lt;HostList&amp;gt;
            &amp;lt;!-- Premiere --&amp;gt;
            &amp;lt;Host Name=&quot;PPRO&quot; Port=&quot;8089&quot; /&amp;gt;
        &amp;lt;/HostList&amp;gt;
    &amp;lt;/Extension&amp;gt;
&amp;lt;/ExtensionList&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　指定调试Premiere的extension时，端口为8089。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114143450077-1267704071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;CEP缓存清理&lt;/h2&gt;
&lt;p&gt;      开发的时候，有可能需要禁止CEF对web内容缓存，可以直接手动删除掉如下位置中extension对应的文件夹：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;Windows: C:\Users\USERNAME\AppData\Local\Temp\cep_cache\&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;Mac: /Users/USERNAME/Library/Logs/CSXS/cep_cache&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;      当然，也有Adobe的开发者说指定CEF参数&lt;strong&gt;&amp;lt;Parameter&amp;gt;--disable-application-cache&amp;lt;/Parameter&amp;gt;&lt;/strong&gt;来禁用CEF缓存，不过我尝试过好像不起作用。&lt;/p&gt;
&lt;h2&gt;Extension文件夹&lt;/h2&gt;
&lt;p&gt;      Extension存放的位置有分两种，系统范围的和用户个人的。系统范围安装Extension的话，Extension文件会存放在如下位置：&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;ul&gt;&lt;li&gt;On Mac,:&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;/Library/Application Support/Adobe/CEP/extensions&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;On Windows:&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;C:\Program Files (x86)\Common Files\Adobe\CEP\extensions&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      这样，当前系统的所有用户都可以加载这个Extension了。也可以仅仅安装给当前用户使用，其位置如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;On Mac: ~/Library/Application Support/Adobe/CEP/extensions&lt;/li&gt;
&lt;li&gt;On Windows: C:\\AppData\Roaming\Adobe\CEP\extensions  &lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2&gt;签名打包&lt;/h2&gt;
&lt;p&gt;      发布Extension的时候，需要对整个包进行签名。这里需要用到&lt;strong&gt;ZXPSignCmd&lt;/strong&gt;这个工具，在官方网站上可以下载。首先，要进行签名我们需要一个数字证书。这个证书我们可以从第三方证书签发机构购买，这需要一定的经费。也可以做一个自签名的证书，对extension进行签名。我们就按照后面一种方式来走个流程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
./ZXPSignCmd -selfSignedCert &amp;lt;countryCode&amp;gt; &amp;lt;stateOrProvince&amp;gt; &amp;lt;organization&amp;gt; &amp;lt;commonName&amp;gt; &amp;lt;password&amp;gt; &amp;lt;outputPath.p12&amp;gt;
./ZXPSignCmd -selfSignedCert US Washington myOrganization &quot;John Smith&quot; myPassword myCertificate.p12
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样会在当前目录下生成一个自签名证书，然后我们可以用这个证书签名打包了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
./ZXPSignCmd -sign &amp;lt;inputDirectory&amp;gt; &amp;lt;outputZxp&amp;gt; &amp;lt;p12&amp;gt; &amp;lt;p12Password&amp;gt;
./ZXPSignCmd -sign HelloWorld/ HelloWorld.zxp myCertificate.p12 myPassword
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;ZXPSignCmd&lt;/strong&gt;工具签名时会在extension目录下生成一个&lt;strong&gt;META-INF&lt;/strong&gt;文件，里面存放这次签名的信息。然后，工具会将整个目录打包压缩成一个&lt;strong&gt;*.zxp&lt;/strong&gt;文件。这就是我们最终需要发布的扩展文件了。^_^&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114151933296-1146385741.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Pond5和Shutterstock的套路分析&lt;/h2&gt;
&lt;p&gt;通过仔细分析Pond5和shutterstock的实现，我们可以总结下这种类型的扩展的一般执行逻辑：&lt;/p&gt;
&lt;p&gt;（1）在宿主程序中打开extension面板，通过”窗口-扩展“可以找到已加载的扩展&lt;/p&gt;
&lt;p&gt;（2）Extension的脚本会分析用户是否是第一次使用。如果是第一次，让用户选择视频素材要保存的位置，这个一般通过弹出对话框实现。用户选择的位置信息，一般通过xml文件持久化存在用户家目录中。用户如果不是第一次使用扩展的话，就直接加载家目录中的xml文件解析了。&lt;/p&gt;
&lt;p&gt;（3）用户点击了某个视频素材，开启下载。这个过程一般可通过nodejs实现。不过，要设置好下载回调函数。&lt;/p&gt;
&lt;div readability=&quot;7.7433155080214&quot;&gt;（4）下载成功后执行回调函数，把下载好的视频文件导入到宿主程序中。这个步骤则是调用extendscript脚本实现。具体脚本编写可以参考&lt;a href=&quot;https://github.com/Adobe-CEP/Samples&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/div&gt;

&lt;p&gt;参考这个套路，实现了类似&lt;strong&gt;Pond5&lt;/strong&gt;和&lt;strong&gt;Shutterstock&lt;/strong&gt;的Adobe Extension：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/214648/201711/214648-20171114153400202-1860573413.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 14 Nov 2017 07:35:00 +0000</pubDate>
<dc:creator>24K纯开源</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/csuftzzk/p/adobe_html_extension_development.html</dc:identifier>
</item>
<item>
<title>MUI框架开发HTML5手机APP(一)--搭建第一个手机APP - 杰瑞教育</title>
<link>http://www.cnblogs.com/jerehedu/p/7832808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerehedu/p/7832808.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  前  言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;JRedu&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　随着HTML5的不断发展，移动开发成为主流趋势！越来越多的公司开始选择使用HTML5开发手机APP，而随着手机硬件设备配置的不断提升，各种开发框架的不断优化，也使着H5开发的混合APP的体验越来越趋于原生！那么在本系列博客中，我们就来一探H5开发APP的神秘面纱吧~~&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、 移动APP项目搭建&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;由于我们的H5编写的都是一个个网页，需要使用浏览器打开才能使用，这显然不是APP的使用方式。 那么我们才能将一个手机网站，封装成一个APP呢？ 时下热门的Cordova、PhoneGap、appMobi、WeX5等…都是主流的构建APP工具！但是这些工具有一个共同的特点——使用麻烦！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我们介绍一种最简便的构建的方式，使用HBuilder一键打包！HBuilder是数字天堂旗下的一款前端开发IDE，其功能强大远超你想象，我们使用的MUI框架，HTML5+框架，都是数字天堂旗下产品，Hbuilder+MUI这对好基友，简直就是绝配！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HBuilder下载地址：&lt;/span&gt;&lt;a href=&quot;http://www.dcloud.io/&quot;&gt;&lt;span&gt;http://www.dcloud.io/&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;span&gt;，下载完成后傻瓜式安装即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;使用HBuilder新建移动APP项目&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;HBuilder安装成功以后，就可以新建一个移动APP项目啦！点击“文件—&amp;gt;新建—&amp;gt;移动APP”,输入你的项目名称，就可以搭建完成一个移动APP项目啦！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;项目的目录结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/708076/201711/708076-20171114131441171-1436747229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;manifest.json文件介绍&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;项目目录中的css/img/js/html等文件就不一一赘述了，建好项目后我们需要新增页面只需要新建HTML文件即可，与开发手机网站的操作一模一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而这里面最重要的应该就是manifest.json这个文件了，这个文件几乎包含了我们APP的所有设置，双击打开，可以看到这个界面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/708076/201711/708076-20171114131836952-2118276526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;底部的选项卡可以看到，这里面包含了我们APP的名称、版本号、首页文件、应用的图标、应用的启动图片以及我们需要的各种SDK。大家可以根据自己的需求自行设置，此处不再一一赘述。&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、APP程序的打包与调试&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的操作中，我们搭建了一款属于自己的移动APP项目，那么这个项目怎么运行调试，又是怎么打包成Android以及IOS能够安装的APP呢？&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;将项目打包成APP&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;首先，我们来看一下如何和将项目打包成一个能够安装的应用程序，这是Hbuilder最便捷的一步，也是杰小瑞老师选择Hbuilder这款IDE的主要原因之一。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选中项目，点击Hbuilder顶部导航栏的“发行—&amp;gt;发行为原生安装包”，可以看到如下页面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/708076/201711/708076-20171114132337484-189015756.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击打包，就可以在不需要Xcode和 Android SDK的情况下，直接在云端打包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/708076/201711/708076-20171114132353109-457336070.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打包完成后，就可以得到安卓的apk文件和苹果的ipa文件。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;直接运行调试&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;上面介绍的是将项目打包成应用程序，但是开发过程中，我们每个页面都要进行大量的调试测试，HBuilder也是支持的。常用的方式有多种，直接通过浏览器调试，通过手机运行调试，通过模拟器调试，都是可以。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击运行，就可以选择调试模式啦~~此处不再赘述，如果需要可以评论留言哦！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/708076/201711/708076-20171114132457593-1701826302.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、MUI框架与HTML5+框架介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上面提到&lt;span&gt;，&lt;/span&gt;HBuilder编辑器、MUI框架、HTML5+框架都是数字天堂公司的知名产品。&lt;span&gt;那么&lt;/span&gt;MUI框架和HTML5+框架都是干什么的呢？&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;MUI框架&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;MUI框架号称是“最接近原生APP体验的高性能前端框架”，当然这是官方的口号，杰小瑞老师不负责吹牛~ 官方文档地址：&lt;a href=&quot;http://dev.dcloud.net.cn/mui/&quot;&gt;&lt;span&gt;http://dev.dcloud.net.cn/mui/&lt;/span&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;经过我们的亲身体验，MUI框架确实对得起他的口号，当然也有很大的进步空间需要提升&lt;span&gt;。&lt;/span&gt; &lt;span&gt;但是配合&lt;/span&gt;HBuilder的使用，如此般顺滑的操作体验会让你不敢相信自己在敲代码。 MUI给我们提供了大量的组件，只需要在HBuilder中输入一个”m”开头，就可以同列表中选择形形色色各种组件！&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/708076/201711/708076-20171114133044890-1709740912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选中你需要的任意一个组件，回车，一大段代码直接生成！比如我们选择第一个maccordion回车，就会直接生成一大段代码，如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/708076/201711/708076-20171114133055952-1728781955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行之后，就可以看到一个折叠面板：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/708076/201711/708076-20171114133111952-260844225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这相比于其他框架需要自己手写Class的方式，这种操作是不是顺滑到不能想象呀！麻麻再也不用担心你记不住这么多class名字了~~ 所以，MUI提供了这么多的组件，使用如此简单，我们也就不再一一讲解了。感兴趣的同学，可以进入帮助文档&lt;a href=&quot;http://dev.dcloud.net.cn/mui/ui/&quot;&gt;&lt;span&gt;http://dev.dcloud.net.cn/mui/ui/&lt;/span&gt;&lt;/a&gt; 查看所有组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们后面的内容，将主要针对MUI中的页面跳转、选项卡切换、Ajax、下拉刷新&amp;amp;上拉加载、调取底层摄像头的功能展开讲解。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;HTML5+框架介绍&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;上面我们介绍了MUI框架的基本使用。也了解到了MUI的主要功能是搭建APP的页面布局所使用的框架。那么HTML5+则是增强版的手机浏览器引擎，让HTML5达到原生水平！二维码、语音输入、摇一摇、摄像头、文件系统、微信分享……等几乎你能想到的原生底层功能，HTML5+都能帮你实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官方给出了一句话： 40万原生API能力随意调用。功能可谓强大，可以点击进入详细了解：&lt;a href=&quot;http://www.dcloud.io/runtime.html&quot;&gt;&lt;span&gt;http://www.dcloud.io/runtime.html&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后续的文章中，我们也会使用到HTML5+调用原生摄像头、写入原生文件等能力进行演示。&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、搭建第一个APP应用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;介绍完了APP搭建的基本内容，我们就开始制作我们第一个移动APP吧。首先，我们为我们的APP制作一个首页。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;创建第一个首页&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;首先，我们应该新建一个index.html文件，注意新建的时候选择“含MUI的html文件”，这样可以帮助我们自动导入所需要的各种默认配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/708076/201711/708076-20171114135446546-430538157.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;创建完成后的第一个文件，代码以及详细解释如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;设置页面的视口宽度&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;导入页面所需要的MUI的CSS文件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;css/mui.min.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;导入页面所需要的MUI的JS文件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/mui.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MUI页面初始化函数&lt;/span&gt;
&lt;span&gt;            mui.init()
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;搭建首页HTML布局&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;首先，&lt;span&gt;我们先在&lt;/span&gt;body中输入“m”选择mHead，生成头部导航栏。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;头部APP顶部导航栏区域&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;header &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-bar mui-bar-nav&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;导航栏左上角返回按钮，首页不需要返回按钮，删除即可&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;a class=&quot;mui-action-back mui-icon mui-icon-left-nav mui-pull-left&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;导航栏标题&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;杰瑞教育APPDemo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在导航栏下面，输入mbody，生成页面的主体部分，其实就是一个div。 页面中除了Header和Footer以外的全部内容，必须包裹在body中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;紧接着，我们在body中，输入一个mList，生成一个列表。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            1、页面加载子页&amp;amp;列表跳转详情页并传参
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            2、 底部选项卡切换(Div模式)
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            3、底部选项卡切换(WebView模式)
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            4、底部选项卡切换(自定义)
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            5、图片轮播组件
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            6、HTML5+摄像头使用
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            7、下拉刷新&amp;amp;上拉加载更多&lt;/span&gt;&lt;span&gt;&amp;amp;Ajax&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;这里面的7个功能，也就是我们将逐一讲解的7个重要功能~！是不是剧透了呢~~生成的页面效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/708076/201711/708076-20171114144829671-111358570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;3&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;为每个列表添加点击事件跳转页面&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;添加点击事件肯定就要用到JS啦~~先介绍几个非常常用的MUI方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 mui.init&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;strong&gt;{}&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mui.init方法时MUI的初始化函数，接受一个对象参数，用于进行页面的各种配置，比如子页面的加载、页面预加载等。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面的代码是利用mui.init在页面初始化时进行页面手势操作的开关：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化页面中的MUI控件&lt;/span&gt;
&lt;span&gt;      mui.init({
          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置各种手势操作的开关&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          gestureConfig:{
           tap: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认为true&lt;/span&gt;
           doubletap: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认为false&lt;/span&gt;
           longtap: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认为false&lt;/span&gt;
           swipe: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认为true&lt;/span&gt;
           drag: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认为true&lt;/span&gt;
           hold:&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认为false，不监听&lt;/span&gt;
           release:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认为false，不监听&lt;/span&gt;
&lt;span&gt;        }
      });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.2 mui.ready()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mui.ready()是MUI框架中的文档就绪函数，&lt;span&gt;表示&lt;/span&gt;mui框架已经加载完毕，接受一个回调函数&lt;span&gt;，功能上有些类似于&lt;/span&gt;JQuery的文档就绪函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当MUI的页面DOM加载完成后，执行的函数。 但是，基本都使用mui.plusReady&lt;/span&gt;
      mui.ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(&quot;我在plusReady之前调用！&quot;);&lt;/span&gt;
      })
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.3 mui.plusReady ()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mui.plusReady()方法使用与mui.ready()类似，但是这个方法在执行时间上，&lt;span&gt;略晚于&lt;/span&gt;mui.ready()&lt;span&gt;。因为这个方法除了要求&lt;/span&gt;MUI框架加载完毕的基础上，还要求HTML5+运行时必须准备完毕！&lt;/p&gt;
&lt;p&gt;所以我们一般用这个函数，&lt;span&gt;来代替&lt;/span&gt;JS中的window.onload函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面中HTML5+相关的内容加载完毕后，执行的函数。  类似于window.onload = function(){}&lt;/span&gt;
      mui.plusReady(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(&quot;我在mui.ready之后调用！&quot;);&lt;/span&gt;
      })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.4 页面跳转功能的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;页面跳转功能的实现思路是，我们新建了一个数组，数组中存放着与列表一一对应的链接地址&lt;span&gt;。&lt;/span&gt; &lt;span&gt;然后使用循环给每一个列表&lt;/span&gt;list添加点击事件，并打开数组中对应的页面地址，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; page = [&quot;01-jiazaiziyemian.html&quot;,&quot;02-tabbarDiv.html&quot;,&quot;03-tabbarWebView.html&quot;,&quot;04-tabbarMy.html&quot;,&quot;05-imglunbo.html&quot;,&quot;06-Camera.html&quot;,&quot;07-fullPush.html&quot;&lt;span&gt;];
          
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = document.getElementsByTagName(&quot;a&quot;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;arr.length; i++&lt;span&gt;){
              &lt;/span&gt;!&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i){
                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在手机APP中，事件绑定推荐使用DOM2模型。 用tap事件取代click事件。&lt;/span&gt;
                  arr[i].addEventListener(&quot;tap&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                      mui.openWindow({
                          url:page[i],
                          id:page[i],
                      })
                  })
              }(i);
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.5 跳转代码解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述代码中，对于很多初学者来说可能会存在一些问题，下面我们来一一解释一下这部分代码：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 移动端开发中使用tap替代click&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在移动端开发中，&lt;span&gt;由于使用&lt;/span&gt;click事件会存在一定的延迟，严重影响用户体验，&lt;span&gt;所以我们一律用&lt;/span&gt;tap事件取代所有的点击事件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 为什么for循环中嵌套一个自执行函数？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个问题我们在&lt;/span&gt;JS面向对象环节探讨过，&lt;span&gt;由于&lt;/span&gt;for循环会在页面加载时直接循环结束，&lt;span&gt;所以当我们点击&lt;/span&gt;list时，&lt;span&gt;其中的&lt;/span&gt;i已经变成了数组的长度&lt;span&gt;。&lt;/span&gt; &lt;span&gt;至于为什么这么解决，大家可以参考之前的博客：&lt;/span&gt;&lt;a href=&quot;http://www.cnblogs.com/jerehedu/p/7592124.html&quot;&gt;&lt;span&gt;http://www.cnblogs.com/jerehedu/p/7592124.html&lt;/span&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;③mui.openWindow ()是个什么东西？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;mui.openWindow是MUI官方给我们提供的专门用于打开一个新窗口的函数，详细的使用教程可以参考：&lt;a href=&quot;http://www.cnblogs.com/jerehedu/p/7832808.html#openwindow&quot;&gt;&lt;span&gt;http://dev.dcloud.net.cn/mui/window/#openwindow&lt;/span&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;而这个函数的完整配置项如下，&lt;span&gt;当然我们上述的操作只需要一个&lt;/span&gt;URL和一个页面ID即可，&lt;span&gt;而且我们以后的页面&lt;/span&gt;ID基本都使用URL同名的方式哦~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mui.openWindow({
    url:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;-page-&lt;span&gt;url,
    id:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;-page-&lt;span&gt;id,
    styles:{
      top:newpage&lt;/span&gt;-top-position,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新页面顶部位置&lt;/span&gt;
      bottom:newage-bottom-position,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新页面底部位置&lt;/span&gt;
      width:newpage-width,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新页面宽度，默认为100%&lt;/span&gt;
      height:newpage-height,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新页面高度，默认为100%&lt;/span&gt;
&lt;span&gt;      ......
    },
    extras:{
      .....&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义扩展参数，可以用来处理页面间传值&lt;/span&gt;
&lt;span&gt;    },
    createNew:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否重复创建同样id的webview，默认为false:不重复创建，直接显示&lt;/span&gt;
&lt;span&gt;    show:{
      autoShow:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面loaded事件发生后自动显示，默认为true&lt;/span&gt;
      aniShow:animationType,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面显示动画，默认为”slide-in-right“；&lt;/span&gt;
      duration:animationTime&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面动画持续时间，Android平台默认100毫秒，iOS平台默认200毫秒；&lt;/span&gt;
&lt;span&gt;    },
    waiting:{
      autoShow:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动显示等待框，默认为true&lt;/span&gt;
      title:'正在加载...',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待对话框上显示的提示内容&lt;/span&gt;
&lt;span&gt;      options:{
        width:waiting&lt;/span&gt;-dialog-widht,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待框背景区域宽度，默认根据内容自动计算合适宽度&lt;/span&gt;
        height:waiting-dialog-height,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待框背景区域高度，默认根据内容自动计算合适高度&lt;/span&gt;
&lt;span&gt;        ......
      }
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，截止到这，我们的首页就全部搭建完成啦！最终效果如下！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.6 首页最终效果预览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/708076/201711/708076-20171114145831827-721327691.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然这里面还有很多功能我们暂时没有实现，后面的博客我们继续再见吧！&lt;/p&gt;
&lt;p&gt;如若想要源码可戳&lt;a href=&quot;http://www.jredu100.com/index.php?m=content&amp;amp;c=index&amp;amp;a=show&amp;amp;catid=65&amp;amp;id=38&quot; target=&quot;_blank&quot;&gt;http://www.jredu100.com/index.php?m=content&amp;amp;c=index&amp;amp;a=show&amp;amp;catid=65&amp;amp;id=38&lt;/a&gt;自行下载。&lt;/p&gt;

&lt;div&gt;作者：杰瑞教育&lt;br/&gt;出处：&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/jerehedu/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/jerehedu/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;版权声明：本文版权归&lt;span&gt;烟&lt;/span&gt;&lt;/span&gt;&lt;span&gt;台&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://www.jredu100.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;杰瑞教育&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;科&lt;/span&gt;&lt;span&gt;&lt;span&gt;技有限公司&lt;/span&gt;和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;br/&gt;技术咨询：&lt;a href=&quot;http://shang.qq.com/wpa/qunwpa?idkey=69fd2f84c1212ecb10062430746aa802c93431c006c1d8cd8c34c5dd4f14772d&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;JRedu技术交流&quot; src=&quot;http://pub.idqqimg.com/wpa/images/group.png&quot; alt=&quot;JRedu技术交流&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 14 Nov 2017 07:31:00 +0000</pubDate>
<dc:creator>杰瑞教育</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jerehedu/p/7832808.html</dc:identifier>
</item>
<item>
<title>触碰密码世界的大门 - 大转转FE</title>
<link>http://www.cnblogs.com/zhuanzhuanfe/p/7827488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuanzhuanfe/p/7827488.html</guid>
<description>&lt;h3&gt;背景&lt;/h3&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;前段时间有个文科朋友问我，能不能帮他拿到之前在他手机上登录过的别人的密码。我想了一下，用户登录的账号密码，如果保存在本地，不是应该加密过吗？如果保存的是用户第一次登录服务器返回的有时效性的token，这种情况肯定就拿不到明文密码了。那么本地保存的经过加密后的呢？或者，假定现在他是第一次登录的请求呢？&lt;/p&gt;
&lt;p&gt;鉴于现大多数登录都是通过https，密码也是经过SSL安全传输层加密处理后发送到服务端的。如果登录使用的是http，登录也应该是经过一些hash处理并且搭配图形化的验证码或者验证短信作为验证，再配合后台的加密来保证一定程度的安全性的（介于窃听者不需要原始密码，通过hash结果等就可以伪造登录，所以前端加密只能用来保护用户的隐私，以防止被窃听的原文密码被用来社会学攻击上，比如用户多站点共享密码，攻击者窃听到http网站下的原文密码用在https的网站下）。接着我又想，那么保存在本地的加密后的密码呢，或者攻击者直接处理加密后的密文呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;   以上只是我初步臆想，所以就有了进一步的学习，本来应该是了解关于网络安全的东西，但是偏偏就看了一下关于密码学的东西（密码学和网络安全是两个方向），然后发现密码学是一门深不可测但是很有意思的科学。下面给大家分享一下我收获的一些简单的知识。&lt;/p&gt;
&lt;h3&gt;一些密码学基础&lt;/h3&gt;
&lt;p&gt;先介绍一些密码学的基础知识&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送者和接收者： 发送者想要发送消息给接收者，并且这个消息是安全的（让偷听者不能阅读这个消息）&lt;/li&gt;
&lt;li&gt;消息和加密：消息被称作&lt;code&gt;明文&lt;/code&gt;。通过某种方法伪装消息以隐藏它的内容的过程称作&lt;code&gt;加密&lt;/code&gt;。被加密的消息被称作&lt;code&gt;密文&lt;/code&gt;。相应的，把密文转变成明文的过程叫作&lt;code&gt;解密&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://gitlab.58corp.com/zz-fe/zzarticles/raw/zhangyiwen/zhangyiwen/images/enigma_1.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;算法和密钥：密码算法也叫&lt;code&gt;密码&lt;/code&gt;，是用于加密和解密的数学函数。如果算法的保密性是针对于保持算法的秘密，这种算法称为受限制算法。按现在的标准，这种受限制算法保密性已经远远不够。现代密码学使用&lt;code&gt;秘钥&lt;/code&gt;来解决了这个问题。有些算法使用两个不同的密钥，即加密密钥和解密密钥不同。这些算法的安全性就是基于密钥的安全性，而不是算法细节的安全性，这就意味着算法可以公开，即使偷听者知道算法，但是不知道具体使用的密钥，就不可能阅读消息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://gitlab.58corp.com/zz-fe/zzarticles/raw/zhangyiwen/zhangyiwen/images/enigma_2.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;密码系统：由所有可能的明文、密文、密钥、以及算法组成。&lt;/li&gt;
&lt;li&gt;对称算法：又叫传统密码算法，加密秘钥能从解密密钥中推算出来，反过来也成立。通常加密和解密使用同一个密钥，称作&lt;code&gt;单密钥算法&lt;/code&gt;或者是&lt;code&gt;秘密密钥算法&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;公开密钥算法（非对称算法）：用作加密的秘钥不同于用作解密的解密秘钥，而且解密秘钥不能通过加密秘钥计算出来（至少在合理假定的长时间内）。之所以叫作公开密钥算法，因为加密秘钥能够公开，但是偷听者只能使用加密秘钥加密信息，只有用相应的解密秘钥才能解密信息。这里，加密密钥又被称作&lt;code&gt;公开密钥&lt;/code&gt;（简称公钥），解密秘钥称作&lt;code&gt;私人密钥&lt;/code&gt;（简称私钥）。&lt;/li&gt;
&lt;li&gt;混合密码系统：将对称密码和公钥密码结合起来的密码方式称为混合密码系统。&lt;/li&gt;
&lt;li&gt;密码分析：密码分析是在不知道密钥的情况下，恢复出明文的科学。成功的密码分析能恢复明文或者密钥。也可以发现密码体制的弱点而得到明文和密钥。（密钥通过非密码分析的方式的丢失叫&lt;code&gt;泄露&lt;/code&gt; ）&lt;/li&gt;
&lt;li&gt;算法的安全性：那么什么样的算法才是安全的呢？如果破译算法的代价大于加密数据的价值；如果破译算法所需要的时间比加密数据保密的时间更长；如果用单密钥加密的数据量比破译算法需要的数据量少得多。那么你可能是安全的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;历史加密技术&lt;/h3&gt;
&lt;h4&gt;单表加密&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;   著名的恺撒密码是一种简单的替换密码，它的每一个明文字符都是由其右边第三个字符替换。它实际上是一种单表映射，数学上称为单射&lt;/p&gt;
&lt;p&gt;以英文字母26个为例&lt;/p&gt;
&lt;p&gt;明码表：ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/p&gt;
&lt;p&gt;密码表：DEFGHIJKLMNOPQRSTUVWXYZABC&lt;/p&gt;
&lt;p&gt;如果我们输入HELLO WORLD，就会输出KHOOR ZRUOG&lt;/p&gt;
&lt;p&gt;这种密码很好破解，密钥最多也就26个，暴力破解法（穷举法）手动都能找到&lt;/p&gt;
&lt;p&gt;经过改版后的恺撒密码使用随机的密码表来使密钥数大量增加，就不是使用移位了，有A26(26) = 26!种可能密钥(手动暴力破解不是要试到猴年马月)。但是有一种高端的学科叫概率论，&lt;code&gt;频率分析法&lt;/code&gt;就是这种单表映射的克星。拿到密文后，可以统计字母出现频率，再对照英文字母频率表来对照明文和密文的对应方式，这种方式需要较大的密文量，不然频率分析就不准确了。&lt;/p&gt;
&lt;h4&gt;多表加密&lt;/h4&gt;
&lt;p&gt;   代表为维吉尼亚密码，是人们在单一恺撒密码的基础上扩展出的多表密码。多表加密，顾名思义，就是多张换字表（单表）进行加密，这样就可以消除字母出现的高频率，频率分析法也就失效了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://gitlab.58corp.com/zz-fe/zzarticles/raw/zhangyiwen/zhangyiwen/images/enigma_3.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张表叫做维热纳尔方阵，是为了方便加密者进行多字母替换而设计的。&lt;/p&gt;
&lt;p&gt;   例如，第一张表中“A”对应“B”，那我加密时第一次遇到“A”就要将其加密为“B”；第二张换字表中“A”对应“C”，那么第二次遇见“A”，就加密为“C”，所以，如果我想加密“AA...”，那么密文就会是“BC...”。当换字表用尽时进行下一轮循环。&lt;/p&gt;
&lt;p&gt;   维吉尼亚密码用到了循环，所以实际上，维吉尼亚密码就是有&lt;code&gt;周期&lt;/code&gt;的多组单表替代。既然存在周期，那么就有被破译的可能，如果观察足够多的密文，就会发现间隔多少位，会有规律地出现特定的字母组，比如of、the，找到了这些重复出现的字母组，那么密钥长度，可能就是他们的间距。具体破解的方法叫&lt;code&gt;卡西斯基试验&lt;/code&gt;，感兴趣的小伙伴可以去看看。&lt;/p&gt;
&lt;h4&gt;Enigma&lt;/h4&gt;
&lt;p&gt;   既然单表不安全，多表也会被破解，那么单表加多表的组合呢？&lt;/p&gt;
&lt;p&gt;   1918年，德国发明家亚瑟·谢尔比乌斯的发明了一个机器并给它起名叫做Enigma（迷）。按下机器键盘上的一个键，上方显示器的一个母就会亮起来，同时在机器顶部的三个转轮最右边的那一个会相应转动一个位置。再按下相同的键，另一个字母又会亮起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://gitlab.58corp.com/zz-fe/zzarticles/raw/zhangyiwen/zhangyiwen/images/enigma_4.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   起初这台机器被用来加密商业机密，但是德国军方看上了它，于是在整个二次世界大战进程中，德军使用Enigma作为加密通讯信息的工具。&lt;/p&gt;
&lt;p&gt;   这台机器看起来是一个装满了复杂而精致的元件的盒子，虽然Enigma看上去挺复杂，但是拆分下来，它是由&lt;code&gt;键盘（输入字符）&lt;/code&gt;，&lt;code&gt;接线板&lt;/code&gt;，&lt;code&gt;转轮&lt;/code&gt;，&lt;code&gt;反射器&lt;/code&gt;，和&lt;code&gt;显示器&lt;/code&gt;组成&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;键盘：加密字符的录入&lt;/li&gt;
&lt;li&gt;接线板：盒子最前面看到的那些插孔，操作员一般选6对字母插上交换线来改变字母对应关系，其他的字母不变，这相当于就是单表加密的作用，这里就有&lt;code&gt;100391791500&lt;/code&gt;种可能的替换表。&lt;/li&gt;
&lt;li&gt;转轮：转轮是enigma的核心，一个enigma机一般装了至少3个转轮，操作员输入一个字母，电流经过接线板进入第一个转轮，经过转子被置换成另一个字母（单个转子对输入内容所做的本质上是一次单字母替换加密），再相同地经过第二第三个转轮到达反射器，经反射器再反向经过刚才经过的转子到达显示器。不同的是，每输入一个字符，第一个转轮就会转动一格，当第一个转轮转到进位点时带动第二个转轮转动，同理，当第二个转轮转动到进位点时带动第三个转轮转动。转轮在生产出来替换规则就定死了，也就是说，一个转子提供26种不会改变的替换密码表，所以3个转子就是263 = &lt;code&gt;17576&lt;/code&gt;个不同密码表，再加上德军一般是从5个转轮中选择3个并可以随便排列位置，这又有C3(5) * A3(3) = &lt;code&gt;60&lt;/code&gt;种可能。（多表替换的表述决定密钥长度，“卡西斯基试验”在Enigma面前就没有什么用处了，17576的密钥长度意味着密文至少要在17576位之后才会出现循环加密，一般哪里有这么长的密文）&lt;/li&gt;
&lt;li&gt;反射器：反射器和转子一样，区别在于&lt;code&gt;不会转动&lt;/code&gt;，而且替换规则是&lt;code&gt;一对字母的替换&lt;/code&gt;，比如输入A，反射器替换成B，输入B，反射器替换成A。这么设计的作用是为了让Enigma机能自我实现加密解密，可以类比光路可逆，电流流向也可逆，原理如下图。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://gitlab.58corp.com/zz-fe/zzarticles/raw/zhangyiwen/zhangyiwen/images/enigma_5.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如输入A，电流流经3个转轮被反射器反射回到三个转轮输出B，那么我输入B，就可以反向输出A。&lt;/p&gt;
&lt;p&gt;Enigma的操作员每个月都会收到一个密码本，指定每天使用的密钥，Enigma的密钥如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;三个转子的排列顺序（例如转子从左至右编号分别为3-1-2）&lt;/li&gt;
&lt;li&gt;三个转子的转动位置，这里称作指标组（例如转子当前转动到Z-Y-W）&lt;/li&gt;
&lt;li&gt;接线板的设置（哪些字母两两交换）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;   以上就是Enigma机的原理，关于Enigma的破译，最早破译Enigma的是波兰人，然后就是我们的计算机之父&lt;code&gt;图灵&lt;/code&gt;最终破译了Enigma，这段历史感兴趣的小伙伴可以自己搜搜。&lt;/p&gt;
&lt;p&gt;这里有一个在线Enigma的网站，可以去玩玩:&lt;a href=&quot;http://enigmaco.de/enigma/enigma.html&quot; rel=&quot;nofollow&quot;&gt;http://enigmaco.de/enigma/enigma.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在看到这里时，因为一直都在学习，两天没敲代码就手痒-0-，就想着自己用代码实现一下Enigma机。&lt;/p&gt;
&lt;h4&gt;Enigma机的js实现&lt;/h4&gt;
&lt;p&gt;   网上有很多实现enigma的代码，但是大多数都太算法化了，而且没有注释，比较难看懂，读别人代码尤其是没有注释的代码是很痛苦的一件事。我按我的理解用代码来还原enigma的整个系统，抽象出enigma机的各个部件，不对的地方还望指正。&lt;/p&gt;
&lt;p&gt;   我用数组来作为enigma内部字母表的替换，比如初始状态为['A', 'B', 'C']，我的映射表为['B', 'C', 'A']，用两数组相同index的项作为替换规则，那么替换表结果就为 A =&amp;gt; B、B =&amp;gt; C。&lt;/p&gt;
&lt;p&gt;   首先是反射板，因为反射板字母的替换规则必须是两两交换，所以写了一个shuffle函数来生成一个随机的两两交换的反射板&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 反射板
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
class Reflector {
  constructor () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反射板字母反射关系&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.mapping = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S'&lt;span&gt;
      , &lt;/span&gt;'T', 'U', 'V', 'W', 'X', 'Y', 'Z'&lt;span&gt;]
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机设置反射板映射关系  (两两交换)&lt;/span&gt;
&lt;span&gt;  shuffle (arr) {
    let copyArr &lt;/span&gt;=&lt;span&gt; arr.slice()
    let map &lt;/span&gt;=&lt;span&gt; {}
    let resultList &lt;/span&gt;=&lt;span&gt; []
    let count &lt;/span&gt;= 0
    &lt;span&gt;while&lt;/span&gt; (copyArr.length &amp;gt; 0&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (map[arr[count]]) {
        count&lt;/span&gt;++
        &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录处理过的字母&lt;/span&gt;
      map[arr[count]] = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      copyArr.splice(copyArr.indexOf(arr[count]), &lt;/span&gt;1&lt;span&gt;)       
      let randSeq &lt;/span&gt;= Math.round(Math.random() * (copyArr.length - 1&lt;span&gt;))
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;map[copyArr[randSeq]]) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机一个字母的位置&lt;/span&gt;
        let index =&lt;span&gt; arr.indexOf(copyArr[randSeq])
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换位置后放在对应位置上&lt;/span&gt;
        resultList[count] =&lt;span&gt; copyArr[randSeq]
        resultList[index] &lt;/span&gt;=&lt;span&gt; arr[count]
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已换的位置作标记&lt;/span&gt;
        map[copyArr[randSeq]] = &lt;span&gt;true&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除已经交换的字母&lt;/span&gt;
        copyArr.splice(randSeq, 1&lt;span&gt;)
        count&lt;/span&gt;++&lt;span&gt;
      }
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapping =&lt;span&gt; resultList
  }
  init () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打乱字母 生成随机的映射关系&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.shuffle(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mapping)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   然后是转子，我以数组第一位作为&lt;code&gt;指标组&lt;/code&gt;的位置，也是就当前转子转到哪里了，然后生成一个随机的&lt;code&gt;进位点&lt;/code&gt;，转子的替换表规则不用两两交换，所以用了一个完全随机的函数打乱数组元素，然后包括转子的顺时针和逆时针转动。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 转子  转子指标组默认为数组第一个位置
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
class Roter extends Reflector {
  constructor () {
    super()
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于表示该转子转动到哪儿了&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.index = 0
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进位 该转子进位点&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.carry = 0&lt;span&gt;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 顺时针旋&lt;/span&gt;
&lt;span&gt;  cwRote (distance) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapping = &lt;span&gt;this&lt;/span&gt;.mapping.concat(&lt;span&gt;this&lt;/span&gt;.mapping.splice(0&lt;span&gt;, distance))
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.index +=&lt;span&gt; distance
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.index &amp;gt; 25&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.index -= 26&lt;span&gt;
    }
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 逆时针旋转&lt;/span&gt;
&lt;span&gt;  acwRote (distance) {
    let len &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mapping.length
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapping = &lt;span&gt;this&lt;/span&gt;.mapping.splice(len - distance, distance).concat(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mapping)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.index -=&lt;span&gt; distance
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.index &amp;lt; 0&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.index = 26 + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index
    }
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字母乱序 完全随机&lt;/span&gt;
&lt;span&gt;  shuffle (arr) {
    let len &lt;/span&gt;=&lt;span&gt; arr.length;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; len - 1; i++&lt;span&gt;) {
      let idx &lt;/span&gt;= Math.floor(Math.random() * (len -&lt;span&gt; i))
      let temp &lt;/span&gt;=&lt;span&gt; arr[idx]
      arr[idx] &lt;/span&gt;= arr[len - i - 1&lt;span&gt;]
      arr[len &lt;/span&gt;- i - 1] =&lt;span&gt; temp
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr
  }
  init () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打乱字母 生成随机的映射关系&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.shuffle(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mapping)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成 随机进位点&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.carry = Math.round(Math.random() * 25&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   接下来是接线板，接线板因为是需要接线员手动选择替换情况的，所以传入一个替换规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 接线板
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
class Plug {
  constructor() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapping = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S'&lt;span&gt;
      , &lt;/span&gt;'T', 'U', 'V', 'W', 'X', 'Y', 'Z'&lt;span&gt;]
  }
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 设置接线板 字母交换情况：A和B交换  C和D交换
   * 交换的数组 [['A', 'B'], ['C', 'D']]
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  init (changeArr) {
    changeArr.map(item &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item[0] === item[1&lt;span&gt;]) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      }
      let frontIdx &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.mapping.indexOf(item[0&lt;span&gt;])
      let nextIdx &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.mapping.indexOf(item[1&lt;span&gt;])
      let middle &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mapping[nextIdx]
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapping[nextIdx] = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mapping[frontIdx]
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapping[frontIdx] =&lt;span&gt; middle
    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   好，现在零件都齐了，就剩最后组合出Enigma机了。首先是sortRoter函数，用来设置转子的排列顺序，接着是setRoterIndex函数，用来设置转子的转动情况。关键在于inputChar 字符录入函数，为了便于理解，用了current变量也就是数组当前索引来模拟电流流向，input作为一个零件的输入，多写了一个output变量作为一个零件的输出（一个零件的输出是另一个零件的输入），有点冗余，但是能清晰模拟电流方向。这样，电流经: 输入 ==&amp;gt; 接线板 ==&amp;gt; 第一个转子 ==&amp;gt; 第二个转子 ==&amp;gt; 第三个转子 ==&amp;gt; 反射器 ==&amp;gt; 第三个转子 ==&amp;gt; 第二个转子 ==&amp;gt; 第一个转子 ==&amp;gt; 输出。这样就很容易理解了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 英格玛机抽象类
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
class Enigma {
  constructor () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.reflector = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Reflector()
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.plug = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Plug()
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roterArr = [&lt;span&gt;new&lt;/span&gt; Roter(), &lt;span&gt;new&lt;/span&gt; Roter(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Roter()]
  }
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   *设置接线板 字母交换情况
   * @changeArr  [['A', 'C']]  接线板转换情况
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  init (changeArr) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Object.prototype.toString.call(changeArr) !== '[object Array]'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.reflector.init()
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.plug.init(changeArr)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roterArr.map(item =&amp;gt;&lt;span&gt; {
      item.init()
    })
  }
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 设置转子排列顺序
   * [0, 1, 2]   [2, 0, 1] 转子排列
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  sortRoter (sort) {
    let first &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.roterArr[sort[0&lt;span&gt;]]
    let second &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.roterArr[sort[1&lt;span&gt;]]
    let third &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.roterArr[sort[2&lt;span&gt;]]
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roterArr =&lt;span&gt; [first, second, third]
  }
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * 设置转子 指标 转子指标组当前转到哪个位置
   * @arr ['A', 'B', 'C']
   * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 
  setRoterIndex (arr) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Object.prototype.toString.call(arr) !== '[object Array]'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转动转子到指标所在位置&lt;/span&gt;
    let first = Math.abs(&lt;span&gt;this&lt;/span&gt;.roterArr[0].mapping.indexOf(arr[0&lt;span&gt;]))
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roterArr[0&lt;span&gt;].cwRote(first)

    let second &lt;/span&gt;= Math.abs(&lt;span&gt;this&lt;/span&gt;.roterArr[1].mapping.indexOf(arr[1&lt;span&gt;]))
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roterArr[1&lt;span&gt;].cwRote(second)

    let third &lt;/span&gt;= Math.abs(&lt;span&gt;this&lt;/span&gt;.roterArr[2].mapping.indexOf(arr[2&lt;span&gt;]))
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roterArr[2&lt;span&gt;].cwRote(third)
  }
  inputChar (&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理映射关系的数组&lt;/span&gt;
    let startArr = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S'&lt;span&gt;
    , &lt;/span&gt;'T', 'U', 'V', 'W', 'X', 'Y', 'Z'&lt;span&gt;]
    let input &lt;/span&gt;= &lt;span&gt;char&lt;/span&gt;&lt;span&gt;
    let output
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前电流位置&lt;/span&gt;
    let current =&lt;span&gt; startArr.indexOf(input)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过接线板&lt;/span&gt;
    output =  &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.plug.mapping[current]
    input &lt;/span&gt;=&lt;span&gt; output
    current &lt;/span&gt;=&lt;span&gt; startArr.indexOf(input)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过第一个转轮&lt;/span&gt;
    output = &lt;span&gt;this&lt;/span&gt;.roterArr[0&lt;span&gt;].mapping[current]
    input &lt;/span&gt;=&lt;span&gt; output
    current &lt;/span&gt;=&lt;span&gt; startArr.indexOf(input)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过第二个转轮&lt;/span&gt;
    output = &lt;span&gt;this&lt;/span&gt;.roterArr[1&lt;span&gt;].mapping[current]
    input &lt;/span&gt;=&lt;span&gt; output
    current &lt;/span&gt;=&lt;span&gt; startArr.indexOf(input)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过第三个转轮&lt;/span&gt;
    output = &lt;span&gt;this&lt;/span&gt;.roterArr[2&lt;span&gt;].mapping[current]


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时倒推回去    &lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过反射器&lt;/span&gt;
    input =&lt;span&gt; output
    current &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.reflector.mapping.indexOf(input)
    output &lt;/span&gt;=&lt;span&gt; startArr[current]

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过第三个转轮&lt;/span&gt;
    input =&lt;span&gt; output
    current &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.roterArr[2&lt;span&gt;].mapping.indexOf(input)
    output &lt;/span&gt;=&lt;span&gt; startArr[current]

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过第二个转轮&lt;/span&gt;
    input =&lt;span&gt; output
    current &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.roterArr[1&lt;span&gt;].mapping.indexOf(input)
    output &lt;/span&gt;=&lt;span&gt; startArr[current]

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过第一个转轮&lt;/span&gt;
    input =&lt;span&gt; output
    current &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.roterArr[0&lt;span&gt;].mapping.indexOf(input)
    output &lt;/span&gt;=&lt;span&gt; startArr[current]

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过接线板&lt;/span&gt;
    input =&lt;span&gt; output
    current &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.plug.mapping.indexOf(input)
    output &lt;/span&gt;=&lt;span&gt; startArr[current]

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个转子顺时针转动1格&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.roterArr[0].cwRote(1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个转子转到进位点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.roterArr[0].index == &lt;span&gt;this&lt;/span&gt;.roterArr[0&lt;span&gt;].carry) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个转子逆时针转动1格&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.roterArr[1].acwRote(1&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个转子转到进位点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.roterArr[1].index == &lt;span&gt;this&lt;/span&gt;.roterArr[1&lt;span&gt;].carry) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三个转子顺时针转动1格&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.roterArr[2].cwRote(1&lt;span&gt;)
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; output 
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   以上是我实现的Enigma加密器，首先初始化enigma机，然后初始化接线板接线规则，调整转子排列顺序，调整转子位置，然后就可以单字符输入，经过一系替换后输出加密后的字符了。在相同的转子排列和转子位置下，输入加密后的字符，就可以输出刚才的明文字符。&lt;/p&gt;
&lt;h3&gt;现代加密技术&lt;/h3&gt;
&lt;p&gt;   在计算机出现以前，密码学由基于字符的密码组成。不同的密码算法是字符之间互相替换或者互相换位，好的密码是结合这两种方法进行多次运算。而现代的变化是算法对比特而不是对字母进行变换，实际上只是字母表的改变，从26个字符变成2个字符，好的算法仍然是代替和换位的组合。&lt;/p&gt;
&lt;p&gt;Kerckhoff加密原则：一个安全保护系统的安全性不是建立在它的算法对于对手来说是保密的，而是应该建立在它所选择的密钥对于对手来说是保密的，这一原则现也被普遍承认为传统密码与现代密码的分界线。&lt;/p&gt;
&lt;h4&gt;对称算法&lt;/h4&gt;
&lt;p&gt;最开始提到的，算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DES(Data Encryption Standard)：DES是现代密码的第一个标志，它在1977年被美国政府正式采纳为数据加密的标准，然而随着计算机进步，DES已经能被暴力破解了，强度大不如从前。&lt;/li&gt;
&lt;li&gt;3DES（Triple DES）：DES的升级版，为了增强DES的强度，将DES重复3次得到的一种密码算法。&lt;/li&gt;
&lt;li&gt;AES(Advanced Encryption Standard)：是取代前任（DES）而成为新标准的一种对称算法，它的原型是一种名为Rijndael的对称密码算法，于2000年全世界若干候选对称算法中脱颖而出被选为新一代的标准密码算法---AES。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;公开密钥算法（非对称算法）&lt;/h4&gt;
&lt;p&gt;   在对称密码中，因为加密和解密使用的相同的密钥，所以必须向接收者配送密钥。公钥密码技术就是解决密钥的配送问题而产生的----两把钥匙，用&lt;code&gt;公钥加密&lt;/code&gt;，用&lt;code&gt;私钥解密&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;   我们来认识两个密码学上的知名人士Alice和Bob，现在他们是一对地下情侣，以及一个自作多情的第三者Eve。&lt;/p&gt;
&lt;p&gt;   Alice和Bob想互相写情书，但是他们不想让Eve偷看到他们互递情书内容，于是他们准备给情书加密。Alice加密后，把情书给Bob看，但是情书已经加密了，Bob看不懂，Alice意识到她还得把解密的密钥给一起发送给Bob。&lt;/p&gt;
&lt;p&gt;   但是如果Alice直接把密文和密钥一起发送给Bob行不行呢？如果一起发送，Eve两个都会拿到就可以像Bob一样看情书的内容了，也就是说，同时发送密钥，Eve也能完成解密。Alice一筹莫展，密钥必须发送给Bob，但又不能发送，哎呀她要纠结死了。&lt;/p&gt;
&lt;p&gt;后来，Alice想到，既然必须给钥匙，那么我可以准备两把钥匙啊，于是她和Bob商量这么做：&lt;/p&gt;
&lt;p&gt;1）两人准备两把配对钥匙，一把用来加密（公钥），一把用来解密（私钥）。&lt;/p&gt;
&lt;p&gt;2）Bob把他的公钥发送给Alice，这时被Eve截获，Eve很兴奋，“嗨呀，拿到你们的钥匙了”&lt;/p&gt;
&lt;p&gt;3）然后Alice收到Bob的公钥后，用Bob的公钥加密，然后把密文发送给Bob。这时又被Eve截获，“嗨呀，看我破解你的密码，咦？怎么打不开呢？”&lt;/p&gt;
&lt;p&gt;4）Bob拿到Alice给他的密文后，用自己的私钥对密文解密。（从此以后，Alice和Bob的地下恋情就不怕被Eve曝光了，我们只是在谈论学习，你是不会懂的。Eve还是一脸懵逼）&lt;/p&gt;
&lt;p&gt;以上就是公钥密码在传输过程中的原理。&lt;/p&gt;
&lt;p&gt;常见非对称算法有:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DSA（Digital Signature Algorithm)：数字签名算法，是一种标准的 DSS（数字签名标准）&lt;/li&gt;
&lt;li&gt;ECC（Elliptic Curves Cryptography）：椭圆曲线密码，它是通过将椭圆曲线上的特定点进行特殊的乘法运算实现的，它利用了这种乘法运算的逆运算非常困难的特征。&lt;/li&gt;
&lt;li&gt;RSA（以三个开发者命名：Rivet、Shamir、Adelman)：现在使用最广泛的公钥密码算法，SSL的密码系统中就用到了它。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;证书&lt;/h4&gt;
&lt;p&gt;   Alice和Bob的生活过得美滋滋，但是Eve很生气，Eve破解不了他们的加密的密码，“哼，没关系”。&lt;/p&gt;
&lt;p&gt;1）Alice又在问Bob要公钥了，Bob收到命令后，把自己的公钥发送给Alice，这时又被Eve拿到了，Eve这次不给Alice了，它把Bob的公钥藏了起来，并且把自己的公钥发给Alice。&lt;/p&gt;
&lt;p&gt;2）Alice拿到了钥匙，但是它以为这就是Bob的钥匙，于是写上“我爱你”，然后用这个公钥加密后发给Bob。&lt;/p&gt;
&lt;p&gt;3）又被Eve拦截了，因为Alice使用的是它的公钥，所以Eve用自己的私钥打开，看到了“我爱你”，“哇，原来你们在我背后搞这些事情，我要拆散你们！”于是Eve写上，“你这个丑鬼，我再也不想见到你了”然后用刚才藏起来的Bob的公钥加密，发给Bob。&lt;/p&gt;
&lt;p&gt;4) Bob心都碎了，重复上述，Eve也可以随意篡改Bob发给Alice的消息了。于是，两人分手了，嘿嘿嘿~&lt;/p&gt;
&lt;p&gt;   以上是公钥密码算法潜在的问题，&lt;code&gt;中间人攻击&lt;/code&gt;，但是这种攻击并不针对算法本身。公钥密码并没有被破译，密码算法正常工作并保证了机密性，但是机密性只是在Alice和Eve，Eve和Bob之间的。所以，仅仅靠公钥密码本身，无法防御中间人攻击。&lt;/p&gt;
&lt;p&gt;   所以问题的起因就是不能判断公钥的由来，于是就有了&lt;code&gt;公钥证书&lt;/code&gt;。公钥证书简称&lt;code&gt;证书&lt;/code&gt;，和身份证相似，里面有各种个人所属信息，以及属于个人的公钥，并有&lt;code&gt;认证机构&lt;/code&gt;（CA）施加&lt;code&gt;数字签名&lt;/code&gt;。认证机构中有国际性组织和政府设立的组织，也有通过认证服务盈利的企业。这样相当于公钥就有了身份证，身份证该可以证明来源真实性了吧。&lt;/p&gt;
&lt;h4&gt;数字签名&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;   数字签名就是现实社会中签名或者盖章这样的行为数字世界的实现，数字签名的处理过程耗时，一般不会对整个消息做数字签名，而是先通过&lt;code&gt;单项散列函数&lt;/code&gt;计算出消息的散列值，再对这个散列值做数字签名。&lt;/p&gt;
&lt;p&gt;   其中单项散列函数一般用于验证消息的&lt;code&gt;完整性&lt;/code&gt;，我们经常做的登录验证实际上就是单项散列函数的一种应用，它能根据任意长度的消息计算出固定长度的散列值，通过对比散列值就可以判断两条消息是否一致。但是，单项散列函数能辨别出&lt;code&gt;“篡改”&lt;/code&gt;，但无法辨别&lt;code&gt;“伪装”&lt;/code&gt;。还需要上述的&lt;code&gt;认证&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;常见的单项散列函数有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MD4：Rivest于1990年设计的单项散列函数，不过随着Dobbertin提出寻找散列碰撞的方法，因此它现在已经不安全了。&lt;/li&gt;
&lt;li&gt;MD5：我们常见的MD5，是由Rivest于1991年设计的，它的强抗碰撞性也已经被攻破，因此也不安全了。&lt;/li&gt;
&lt;li&gt;SHA-1、SHA-256、SHA-384、SHA-512：由NIST（美国国家标准技术研究所）设计的单项散列函数，其中，SHA-1的强抗碰撞性已于2005年被攻破。SHA-256、SHA-384、SHA-512统称为SHA-2。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;混合密码算法&lt;/h4&gt;
&lt;p&gt;   使用对称密码，可以保证机密性，但是需要解决密钥配送问题；使用公钥密码，处理速度远远低于对称密码外，还难以防御中间人攻击。所以就有了混合密码系统---将对称密码和公钥密码相结合的方法。&lt;/p&gt;
&lt;p&gt;   用快速的对称密码对消息加密，消息转换成了密文，保证了消息的&lt;code&gt;机密性&lt;/code&gt;。然后用公钥密码对对称密码的密钥进行加密，由于对称密码的密钥一般比信息短，所以公钥密码的速度慢的问题就可以被忽略了，这样就保证了密钥配送的&lt;code&gt;安全性&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;   混合密码系统还用了&lt;code&gt;伪随机数生成器&lt;/code&gt;生成对称密码加密中使用的会话密钥，结合这三种技术创造出了兼具两者优点的密码方式。著名密码软件&lt;code&gt;PGP&lt;/code&gt;，以及我们众所周知的&lt;code&gt;SSL/TLS&lt;/code&gt;都运用的是混合密码系统。&lt;/p&gt;
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;   本来想再仔细研究现代加密算法的具体实现，但是发现自己大脑已经发烧，这次就先到这里，虽然自己还在密码世界的大门之外，但是也略有所获，我先去买瓶六个核桃。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 如果你喜欢我们的文章，关注我们的公众号和我们互动吧。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201709/1203274-20170929105350169-1798795184.jpg&quot; alt=&quot;&quot; width=&quot;344&quot; height=&quot;344&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 Nov 2017 06:18:00 +0000</pubDate>
<dc:creator>大转转FE</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuanzhuanfe/p/7827488.html</dc:identifier>
</item>
<item>
<title>数学模型与计算机科学的认知 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/7832125.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/7832125.html</guid>
<description>[unable to retrieve full-text content]长时间地呆在解决数学问题的世界里，反而会让你看不清楚数学的本质，或者数学的根本性的东西。这个观点，陈省身（Shiing-Shen Chern）和陶哲轩（Terence Tao）都表达过。陈省身在谈论纳什（John Nash, 电影《美丽心灵》的主角，诺贝尔经济学奖得主）的时候就反复提到：John N</description>
<pubDate>Tue, 14 Nov 2017 05:40:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<dc:identifier>http://www.cnblogs.com/kid551/p/7832125.html</dc:identifier>
</item>
<item>
<title>如何优雅的设计React组件 - nicolaszhao</title>
<link>http://www.cnblogs.com/nicolaszhao/p/7832012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nicolaszhao/p/7832012.html</guid>
<description>&lt;p&gt;如今的 web 前端已被 React、Vue 和 Angular 三分天下，一统江山十几年的 jQuery 显然已经很难满足现在的开发模式。那么，为什么大家会觉得 jQuery “过时了”呢？一来，文章《&lt;a href=&quot;https://www.sitepoint.com/dom-manipulation-vanilla-javascript-no-jquery/&quot;&gt;No JQuery! 原生 JavaScript 操作 DOM&lt;/a&gt;》就直截了当的告诉你，现在用原生 JavaScript 可以非常方便的操作 DOM 了。其次，jQuery 的便利性是建立在有一个基础 DOM 结构的前提下的，看上去是符合了样式、行为和结构分离，但其实 DOM 结构和 JavaScript 的代码逻辑是耦合的，你的开发思路会不断的在 DOM 结构和 JavaScript 之间来回切换。&lt;/p&gt;
&lt;p&gt;尽管现在的 jQuery 已不再那么流行，但 jQuery 的设计思想还是非常值得致敬和学习的，特别是 jQuery 的插件化。如果大家开发过 jQuery 插件的话，想必都会知道，一个插件要足够灵活，需要有细颗粒度的参数化设计。一个灵活好用的 React 组件跟 jQuery 插件一样，都离不开合理的属性化（&lt;code&gt;props&lt;/code&gt;）设计，但 React 组件的拆分和组合比起 jQuery 插件来说还是简单的令人发指。&lt;/p&gt;
&lt;p&gt;So! 接下来我们就以万能的 TODO LIST 为例，一起来设计一款 React 的 &lt;code&gt;TodoList&lt;/code&gt; 组件吧！&lt;/p&gt;
&lt;h2 id=&quot;实现基本功能&quot;&gt;实现基本功能&lt;/h2&gt;
&lt;p&gt;TODO LIST 的功能想必我们应该都比较了解，也就是 TODO 的添加、删除、修改等等。本身的功能也比较简单，为了避免示例的复杂度，显示不同状态 TODO LIST 的导航（全部、已完成、未完成）的功能我们就不展开了。&lt;/p&gt;
&lt;h3 id=&quot;约定目录结构&quot;&gt;约定目录结构&lt;/h3&gt;
&lt;p&gt;先假设我们已经拥有一个可以运行 React 项目的脚手架（ha~ 因为我不是来教你如何搭建脚手架的），然后项目的源码目录 &lt;code&gt;src/&lt;/code&gt; 下可能是这样的：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;.
├── components
├── containers
│   └── App
│       ├── app.scss
│       └── index.js
├── index.html
└── index.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先来简单解释下这个目录设定。我们看到根目录下的 &lt;code&gt;index.js&lt;/code&gt; 文件是整个项目的入口模块，入口模块将会处理 DOM 的渲染和 React 组件的热更新（&lt;a href=&quot;https://github.com/gaearon/react-hot-loader&quot;&gt;react-hot-loader&lt;/a&gt;）等设置。然后，&lt;code&gt;index.html&lt;/code&gt; 是页面的 HTML 模版文件，这 2 个部分不是我们这次关心的重点，我们不再展开讨论。&lt;/p&gt;
&lt;p&gt;入口模块 &lt;code&gt;index.js&lt;/code&gt; 的代码大概是这样子的：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;// import reset css, base css...

import React from 'react';
import ReactDom from 'react-dom';
import { AppContainer } from 'react-hot-loader';
import App from 'containers/App';

const render = (Component) =&amp;gt; {
  ReactDom.render(
    &amp;lt;AppContainer&amp;gt;
      &amp;lt;Component /&amp;gt;
    &amp;lt;/AppContainer&amp;gt;,
    document.getElementById('app')
  );
};

render(App);

if (module.hot) {
  module.hot.accept('containers/App', () =&amp;gt; {
    let nextApp = require('containers/App').default;
    
    render(nextApp);
  });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看 &lt;code&gt;containers/&lt;/code&gt; 目录，它将放置我们的页面容器组件，业务逻辑、数据处理等会在这一层做处理，&lt;code&gt;containers/App&lt;/code&gt; 将作为我们的页面主容器组件。作为通用组件，我们将它们放置于 &lt;code&gt;components/&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;p&gt;基本的目录结构看起来已经完成，接下来我们实现下主容器组件 &lt;code&gt;containers/App&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;实现主容器&quot;&gt;实现主容器&lt;/h3&gt;
&lt;p&gt;我们先来看下主容器组件 &lt;code&gt;containers/App/index.js&lt;/code&gt; 最初的代码实现：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;import React, { Component } from 'react';
import styles from './app.scss';

class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      todos: []
    };
  }

  render() {
    return (
      &amp;lt;div className={styles.container}&amp;gt;
        &amp;lt;h2 className={styles.header}&amp;gt;Todo List Demo&amp;lt;/h2&amp;gt;
        &amp;lt;div className={styles.content}&amp;gt;
          &amp;lt;header className={styles['todo-list-header']}&amp;gt;
            &amp;lt;input 
              type=&quot;text&quot;
              className={styles.input}
              ref={(input) =&amp;gt; this.input = input} 
            /&amp;gt;
            &amp;lt;button 
              className={styles.button} 
              onClick={() =&amp;gt; this.handleAdd()}
            &amp;gt;
              Add Todo
            &amp;lt;/button&amp;gt;
          &amp;lt;/header&amp;gt;
          &amp;lt;section className={styles['todo-list-content']}&amp;gt;
            &amp;lt;ul className={styles['todo-list-items']}&amp;gt;
              {this.state.todos.map((todo, i) =&amp;gt; (
                &amp;lt;li key={`${todo.text}-${i}`}&amp;gt;
                  &amp;lt;em 
                    className={todo.completed ? styles.completed : ''} 
                    onClick={() =&amp;gt; this.handleStateChange(i)}
                  &amp;gt;
                    {todo.text}
                  &amp;lt;/em&amp;gt;
                  &amp;lt;button 
                    className={styles.button} 
                    onClick={() =&amp;gt; this.handleRemove(i)}
                  &amp;gt;
                    Remove
                  &amp;lt;/button&amp;gt;
                &amp;lt;/li&amp;gt;
              ))}
            &amp;lt;/ul&amp;gt;
          &amp;lt;/section&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }

  handleAdd() {
    ...
  }

  handleRemove(index) {
    ...
  }

  handleStateChange(index) {
    ...
  }
}

export default App;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以像上面这样把所有的业务逻辑一股脑的塞进主容器中，但我们要考虑到主容器随时会组装其他的组件进来，将各种逻辑堆放在一起，到时候这个组件就会变得无比庞大，直到“无法收拾”。所以，我们得分离出一个独立的 &lt;code&gt;TodoList&lt;/code&gt; 组件。&lt;/p&gt;
&lt;h2 id=&quot;分离组件&quot;&gt;分离组件&lt;/h2&gt;
&lt;h3 id=&quot;todolist-组件&quot;&gt;TodoList 组件&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;components/&lt;/code&gt; 目录下，我们新建一个 &lt;code&gt;TodoList&lt;/code&gt; 文件夹以及相关文件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode diff&quot;&gt;
&lt;code class=&quot;sourceCode diff&quot;&gt;.
├── components
&lt;span class=&quot;ot&quot;&gt;+│   └── TodoList&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│       ├── index.js&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│       └── todo-list.scss&lt;/span&gt;
├── containers
│   └── App
│       ├── app.scss
│       └── index.js
...&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们将 &lt;code&gt;containers/App/index.js&lt;/code&gt; 下跟 &lt;code&gt;TodoList&lt;/code&gt; 组件相关的功能抽离到 &lt;code&gt;components/TodoList/index.js&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode diff&quot;&gt;
&lt;code class=&quot;sourceCode diff&quot;&gt;...
import styles from './todo-list.scss';

export default class TodoList extends Component {
  ...
  
  render() {
    return (
      &amp;lt;div className={styles.container}&amp;gt;
&lt;span class=&quot;st&quot;&gt;-       &amp;lt;header className={styles['todo-list-header']}&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+       &amp;lt;header className={styles.header}&amp;gt;&lt;/span&gt;
          &amp;lt;input 
            type=&quot;text&quot;
            className={styles.input}
            ref={(input) =&amp;gt; this.input = input} 
          /&amp;gt;
          &amp;lt;button 
            className={styles.button} 
            onClick={() =&amp;gt; this.handleAdd()}
          &amp;gt;
            Add Todo
          &amp;lt;/button&amp;gt;
        &amp;lt;/header&amp;gt;
&lt;span class=&quot;st&quot;&gt;-       &amp;lt;section className={styles['todo-list-content']}&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+       &amp;lt;section className={styles.content}&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;-         &amp;lt;ul className={styles['todo-list-items']}&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+         &amp;lt;ul className={styles.items}&amp;gt;&lt;/span&gt;
            {this.state.todos.map((todo, i) =&amp;gt; (
              &amp;lt;li key={`${todo}-${i}`}&amp;gt;
                &amp;lt;em 
                  className={todo.completed ? styles.completed : ''} 
                  onClick={() =&amp;gt; this.handleStateChange(i)}
                &amp;gt;
                  {todo.text}
                &amp;lt;/em&amp;gt;
                &amp;lt;button 
                  className={styles.button} 
                  onClick={() =&amp;gt; this.handleRemove(i)}
                &amp;gt;
                  Remove
                &amp;lt;/button&amp;gt;
              &amp;lt;/li&amp;gt;
            ))}
          &amp;lt;/ul&amp;gt;
        &amp;lt;/section&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }

  ...
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有没有注意到上面 &lt;code&gt;render&lt;/code&gt; 方法中的 &lt;code&gt;className&lt;/code&gt;，我们省去了 &lt;code&gt;todo-list*&lt;/code&gt; 前缀，由于我们用的是 &lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;CSS MODULES&lt;/a&gt;，所以当我们分离组件后，原先在主容器中定义的 &lt;code&gt;todo-list*&lt;/code&gt; 前缀的 &lt;code&gt;className&lt;/code&gt; ，可以很容易通过 webpack 的配置来实现：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;...
&lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  ...
  &lt;span class=&quot;dt&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [
      &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\.&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;css/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [
          &lt;span class=&quot;st&quot;&gt;'style-loader'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'css-loader'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;dt&quot;&gt;modules&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;dt&quot;&gt;localIdentName&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'[name]--[local]-[hash:base64:5]'&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
          ...
        ]
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    ]  
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  ...
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再来看下该组件的代码输出后的结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; data-reactroot=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;app--container-YwMsF&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  ...
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;todo-list--container-2PARV&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;header&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;todo-list--header-3KDD3&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        ...
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;/header&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;section&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;todo-list--content-3xwvR&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;ul&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;todo-list--items-1SBi6&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
          ...
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;/section&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面 webpack 的配置和输出的 HTML 中可以看到，&lt;code&gt;className&lt;/code&gt; 的命名空间问题可以通过语义化 &lt;code&gt;*.scss&lt;/code&gt; 文件名的方式来实现，比如 &lt;code&gt;TodoList&lt;/code&gt; 的样式文件 &lt;code&gt;todo-list.scss&lt;/code&gt;。这样一来，省去了我们定义组件 &lt;code&gt;className&lt;/code&gt; 的命名空间带来的烦恼，从而只需要从组件内部的结构下手。&lt;/p&gt;
&lt;p&gt;回到正题，我们再来看下分离 &lt;code&gt;TodoList&lt;/code&gt; 组件后的 &lt;code&gt;containers/App/index.js&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;import TodoList from 'components/TodoList';
...

class App extends Component {
  render() {
    return (
      &amp;lt;div className={styles.container}&amp;gt;
        &amp;lt;h2 className={styles.header}&amp;gt;Todo List Demo&amp;lt;/h2&amp;gt;
        &amp;lt;div className={styles.content}&amp;gt;
          &amp;lt;TodoList /&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default App;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;抽离通用组件&quot;&gt;抽离通用组件&lt;/h3&gt;
&lt;p&gt;作为一个项目，当前的 &lt;code&gt;TodoList&lt;/code&gt; 组件包含了太多的子元素，如：input、button 等。为了让组件“&lt;strong&gt;一次编写，随处使用&lt;/strong&gt;”的原则，我们可以进一步拆分 &lt;code&gt;TodoList&lt;/code&gt; 组件以满足其他组件的使用。&lt;/p&gt;
&lt;p&gt;但是，如何拆分组件才是最合理的呢？我觉得这个问题没有最好的答案，但我们可以从几个方面进行思考：可封装性、可重用性和灵活性。比如拿 &lt;code&gt;h1&lt;/code&gt; 元素来讲，你可以封装成一个 &lt;code&gt;Title&lt;/code&gt; 组件，然后这样 &lt;code&gt;&amp;lt;Title text={title} /&amp;gt;&lt;/code&gt; 使用，又或者可以这样 &lt;code&gt;&amp;lt;Title&amp;gt;{title}&amp;lt;/Title&amp;gt;&lt;/code&gt; 来使用。但你有没有发现，这样实现的 &lt;code&gt;Title&lt;/code&gt; 组件并没有起到简化和封装的作用，反而增加了使用的复杂度，对于 HTML 来讲，&lt;code&gt;h1&lt;/code&gt; 本身也是一个组件，所以我们拆分组件也是需要掌握一个度的。&lt;/p&gt;
&lt;p&gt;好，我们先拿 input 和 button 下手，在 &lt;code&gt;components/&lt;/code&gt; 目录下新建 2 个 &lt;code&gt;Button&lt;/code&gt; 和 &lt;code&gt;Input&lt;/code&gt; 组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode diff&quot;&gt;
&lt;code class=&quot;sourceCode diff&quot;&gt;.
├── components
&lt;span class=&quot;ot&quot;&gt;+│   ├── Button&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│   │   ├── button.scss&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│   │   └── index.js&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│   ├── Input&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│   │   ├── index.js&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│   │   └── input.scss&lt;/span&gt;
│   └── TodoList
│       ├── index.js
│       └── todo-list.scss
...&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Button/index.js&lt;/code&gt; 的代码：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;...
export default class Button extends Component {
  render() {
    const { className, children, onClick } = this.props;

    return (
      &amp;lt;button 
        type=&quot;button&quot; 
        className={cn(styles.normal, className)} 
        onClick={onClick}
      &amp;gt;
        {children}
      &amp;lt;/button&amp;gt;
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Input/index.js&lt;/code&gt; 的代码：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;...
export default class Input extends Component {
  render() {
    const { className, value, inputRef } = this.props;

    return (
      &amp;lt;input 
        type=&quot;text&quot;
        className={cn(styles.normal, className)}
        defaultValue={value}
        ref={inputRef} 
      /&amp;gt;
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于这 2 个组件自身不涉及任何业务逻辑，应该属于纯渲染组件（木偶组件），我们可以使用 React 轻量的无状态组件的方式来声明：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;...
const Button = ({ className, children, onClick }) =&amp;gt; (
  &amp;lt;button 
    type=&quot;button&quot; 
    className={cn(styles.normal, className)} 
    onClick={onClick}
  &amp;gt;
    {children}
  &amp;lt;/button&amp;gt;
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是觉得酷炫很多！&lt;/p&gt;
&lt;p&gt;另外，从 &lt;code&gt;Input&lt;/code&gt; 组件的示例代码中看到，我们使用了&lt;a href=&quot;https://reactjs.org/docs/uncontrolled-components.html&quot;&gt;非受控组件&lt;/a&gt;，这里是为了降低示例代码的复杂度而特意为之，大家可以根据自己的实际情况来决定是否需要设计成&lt;a href=&quot;https://reactjs.org/docs/forms.html#controlled-components&quot;&gt;受控组件&lt;/a&gt;。一般情况下，如果不需要获取实时输入值的话，我觉得使用非受控组件应该够用了。&lt;/p&gt;
&lt;p&gt;我们再回到上面的 &lt;code&gt;TodoList&lt;/code&gt; 组件，将之前分离的子组件 &lt;code&gt;Button&lt;/code&gt;，&lt;code&gt;Input&lt;/code&gt; 组装进来。&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;...
import Button from 'components/Button';
import Input from 'components/Input';
...

export default class TodoList extends Component {
  render() {
    return (
      &amp;lt;div className={styles.container}&amp;gt;
        &amp;lt;header className={styles.header}&amp;gt;
          &amp;lt;Input 
            className={styles.input} 
            inputRef={(input) =&amp;gt; this.input = input} 
          /&amp;gt;
          &amp;lt;Button onClick={() =&amp;gt; this.handleAdd()}&amp;gt;
            Add Todo
          &amp;lt;/Button&amp;gt;
        &amp;lt;/header&amp;gt;
        ...
      &amp;lt;/div&amp;gt;
    );
  }
}

...&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拆分子组件&quot;&gt;拆分子组件&lt;/h3&gt;
&lt;p&gt;然后继续接着看 &lt;code&gt;TodoList&lt;/code&gt; 的 items 部分，我们注意到这部分包含了较多的渲染逻辑在 &lt;code&gt;render&lt;/code&gt; 中，导致我们需要浪费对这段代码与上下文之间会有过多的思考，所以，我们何不把它抽离出去：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;...

export default class TodoList extends Component {
  render() {
    return (
      &amp;lt;div className={styles.container}&amp;gt;
        ...
        &amp;lt;section className={styles.content}&amp;gt;
          {this.renderItems()}
        &amp;lt;/section&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }

  renderItems() {
    return (
      &amp;lt;ul className={styles.items}&amp;gt;
        {this.state.todos.map((todo, i) =&amp;gt; (
          &amp;lt;li key={`${todo}-${i}`}&amp;gt;
            ...
          &amp;lt;/li&amp;gt;
        ))}
      &amp;lt;/ul&amp;gt;
    );
  }
  
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码看似降低了 &lt;code&gt;render&lt;/code&gt; 的复杂度，但仍然没有让 &lt;code&gt;TodoList&lt;/code&gt; 减少负担。既然我们要把这部分逻辑分离出去，我们何不创建一个 &lt;code&gt;Todos&lt;/code&gt; 组件，把这部分逻辑拆分出去呢？so，我们以“&lt;strong&gt;就近声明&lt;/strong&gt;”的原则在 &lt;code&gt;components/TodoList/&lt;/code&gt; 目录下创建一个子目录 &lt;code&gt;components/TodoList/components/&lt;/code&gt; 来存放 &lt;code&gt;TodoList&lt;/code&gt; 的子组件 。why？因为我觉得 组件 &lt;code&gt;Todos&lt;/code&gt; 跟 &lt;code&gt;TodoList&lt;/code&gt; 有紧密的父子关系，且跟其他组件间也不太会有任何交互，也可以认为它是 &lt;code&gt;TodoList&lt;/code&gt; 私有的。&lt;/p&gt;
&lt;p&gt;然后我们预览下现在的目录结构：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode diff&quot;&gt;
&lt;code class=&quot;sourceCode diff&quot;&gt;.
├── components
│   ...
│   └── TodoList
&lt;span class=&quot;ot&quot;&gt;+│       ├── components&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│       │   └── Todos&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│       │       ├── index.js&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│       │       └── todos.scss&lt;/span&gt;
│       ├── index.js
│       └── todo-list.scss&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Todos/index.js&lt;/code&gt; 的代码：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;...
const Todos = ({ data: todos, onStateChange, onRemove }) =&amp;gt; (
  &amp;lt;ul className={styles.items}&amp;gt;
    {todos.map((todo, i) =&amp;gt; (
      &amp;lt;li key={`${todo}-${i}`}&amp;gt;
        &amp;lt;em 
          className={todo.completed ? styles.completed : ''} 
          onClick={() =&amp;gt; onStateChange(i)}
        &amp;gt;
          {todo.text}
        &amp;lt;/em&amp;gt;
        &amp;lt;Button onClick={() =&amp;gt; onRemove(i)}&amp;gt;
          Remove
        &amp;lt;/Button&amp;gt;
      &amp;lt;/li&amp;gt;
    ))}
  &amp;lt;/ul&amp;gt;
);
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看拆分后的 &lt;code&gt;TodoList/index.js&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;render() {
  return (
    &amp;lt;div className={styles.container}&amp;gt;
      ...
      &amp;lt;section className={styles.content}&amp;gt;
        &amp;lt;Todos 
          data={this.state.todos}
          onStateChange={(index) =&amp;gt; this.handleStateChange(index)}
          onRemove={(index) =&amp;gt; this.handleRemove(index)}
        /&amp;gt;
      &amp;lt;/section&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;增强子组件&quot;&gt;增强子组件&lt;/h3&gt;
&lt;p&gt;到目前为止，大体上的功能已经搞定，子组件看上去拆分的也算合理，这样就可以很容易的增强某个子组件的功能了。就拿 &lt;code&gt;Todos&lt;/code&gt; 来说，在新增了一个 TODO 后，假如我们并没有完成这个 TODO，而我们又希望可以修改它的内容了。ha～不要着急，要不我们再拆分下这个 &lt;code&gt;Todos&lt;/code&gt;，比如增加一个 &lt;code&gt;Todo&lt;/code&gt; 组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode diff&quot;&gt;
&lt;code class=&quot;sourceCode diff&quot;&gt;.
├── components
│   ...
│   └── TodoList
│       ├── components
&lt;span class=&quot;ot&quot;&gt;+│       │   ├── Todo&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│       │   │   ├── index.js&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+│       │   │   └── todo.scss&lt;/span&gt;
│       │   └── Todos
│       │       ├── index.js
│       │       └── todos.scss
│       ├── index.js
│       └── todo-list.scss&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看下 &lt;code&gt;Todos&lt;/code&gt; 组件在抽离了 &lt;code&gt;Todo&lt;/code&gt; 后的样子：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;...
import Todo from '../Todo';
...

const Todos = ({ data: todos, onStateChange, onRemove }) =&amp;gt; (
  &amp;lt;ul className={styles.items}&amp;gt;
    {todos.map((todo, i) =&amp;gt; (
      &amp;lt;li key={`${todo}-${i}`}&amp;gt;
        &amp;lt;Todo
          {...todo}
          onClick={() =&amp;gt; onStateChange(i)}
        /&amp;gt;
        &amp;lt;Button onClick={() =&amp;gt; onRemove(i)}&amp;gt;
          Remove
        &amp;lt;/Button&amp;gt;
      &amp;lt;/li&amp;gt;
    ))}
  &amp;lt;/ul&amp;gt;
);

export default Todos;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先不关心 &lt;code&gt;Todo&lt;/code&gt; 内是何如实现的，就如我们上面说到的那样，我们需要对这个 &lt;code&gt;Todo&lt;/code&gt; 增加一个可编辑的功能，从单纯的属性配置入手，我们只需要给它增加一个 &lt;code&gt;editable&lt;/code&gt; 的属性：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode diff&quot;&gt;
&lt;code class=&quot;sourceCode diff&quot;&gt;&lt;span class=&quot;st&quot;&gt;&amp;lt;Todo&lt;/span&gt;
  {...todo}
&lt;span class=&quot;ot&quot;&gt;+ editable={editable}&lt;/span&gt;
  onClick={() =&amp;gt; onStateChange(i)}
/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，我们再思考下，在 &lt;code&gt;Todo&lt;/code&gt; 组件的内部，我们需要重新组织一些功能逻辑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据传入的 &lt;code&gt;editable&lt;/code&gt; 属性来判断是否需要显示编辑按钮&lt;/li&gt;
&lt;li&gt;根据组件内部的编辑状态，是显示文本输入框还是文本内容&lt;/li&gt;
&lt;li&gt;点击“更新”按钮后，需要通知父组件更新数据列表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们先来实现下 &lt;code&gt;Todo&lt;/code&gt; 的第一个功能点：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;render() {
  const { completed, text, editable, onClick } = this.props;

  return (
    &amp;lt;span className={styles.wrapper}&amp;gt;
      &amp;lt;em
        className={completed ? styles.completed : ''} 
        onClick={onClick}
        &amp;gt;
        {text}
      &amp;lt;/em&amp;gt;
      {editable &amp;amp;&amp;amp; 
        &amp;lt;Button&amp;gt;
          Edit
        &amp;lt;/Button&amp;gt;
      }
    &amp;lt;/span&amp;gt;
  );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然实现这一步似乎没什么 luan 用，我们还需要点击 Edit 按钮后能显示 &lt;code&gt;Input&lt;/code&gt; 组件，使内容可修改。所以，简单的传递属性似乎无法满足该组件的功能，我们还需要一个内部状态来管理组件是否处于编辑中：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;render() {
  const { completed, text, editable, onStateChange } = this.props,
    { editing } = this.state;

  return (
    &amp;lt;span className={styles.wrapper}&amp;gt;
      {editing ? 
        &amp;lt;Input 
          value={text}
          className={styles.input}
          inputRef={input =&amp;gt; this.input = input}
        /&amp;gt; :
        &amp;lt;em
          className={completed ? styles.completed : ''} 
          onClick={onStateChange}
        &amp;gt;
          {text}
        &amp;lt;/em&amp;gt;
      }
      {editable &amp;amp;&amp;amp; 
        &amp;lt;Button onClick={() =&amp;gt; this.handleEdit()}&amp;gt;
          {editing ? 'Update' : 'Edit'}
        &amp;lt;/Button&amp;gt;
      }
    &amp;lt;/span&amp;gt;
  );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，&lt;code&gt;Todo&lt;/code&gt; 组件在点击 Update 按钮后需要通知父组件更新数据：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;handleEdit&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; text&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; onUpdate &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; editing &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  editing &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;editing&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; editing &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;editing &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;input&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; text) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;onUpdate&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;input&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，我们传递的是更新后的内容，在数据没有任何变化的情况下通知父组件是毫无意义的。&lt;/p&gt;
&lt;p&gt;我们再回过头来修改下 &lt;code&gt;Todos&lt;/code&gt; 组件对 &lt;code&gt;Todo&lt;/code&gt; 的调用。先增加一个由 &lt;code&gt;TodoList&lt;/code&gt; 组件传递下来的回调属性 &lt;code&gt;onUpdate&lt;/code&gt;，同时修改 &lt;code&gt;onClick&lt;/code&gt; 为 &lt;code&gt;onStateChange&lt;/code&gt;，因为这时的 &lt;code&gt;Todo&lt;/code&gt; 已不仅仅只有单个点击事件了，需要定义不同状态变更时的事件回调：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode diff&quot;&gt;
&lt;code class=&quot;sourceCode diff&quot;&gt;&lt;span class=&quot;st&quot;&gt;&amp;lt;Todo&lt;/span&gt;
  {...todo}
  editable={editable}
&lt;span class=&quot;st&quot;&gt;- onClick={() =&amp;gt; onStateChange(i)}&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+ onStateChange={() =&amp;gt; onStateChange(i)}&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;+ onUpdate={(value) =&amp;gt; onUpdate(i, value)}&lt;/span&gt;
/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而最终我们又在 &lt;code&gt;TodoList&lt;/code&gt; 组件中，增加 &lt;code&gt;Todo&lt;/code&gt; 在数据更新后的业务逻辑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TodoList&lt;/code&gt; 组件的 &lt;code&gt;render&lt;/code&gt; 方法内的部分示例代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode diff&quot;&gt;
&lt;code class=&quot;sourceCode diff&quot;&gt;&lt;span class=&quot;st&quot;&gt;&amp;lt;Todos &lt;/span&gt;
  editable
  data={this.state.todos}
&lt;span class=&quot;ot&quot;&gt;+ onUpdate={(index, value) =&amp;gt; this.handleUpdate(index, value)}&lt;/span&gt;
  onStateChange={(index) =&amp;gt; this.handleStateChange(index)}
  onRemove={(index) =&amp;gt; this.handleRemove(index)}
/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;TodoList&lt;/code&gt; 组件的 &lt;code&gt;handleUpdate&lt;/code&gt; 方法的示例代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;handleUpdate&lt;/span&gt;(index&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; todos &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [...&lt;span class=&quot;va&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;todos&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; target &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; todos[index]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  todos &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [
    ...&lt;span class=&quot;va&quot;&gt;todos&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; index)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; value&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;completed&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;completed&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    ...&lt;span class=&quot;va&quot;&gt;todos&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;(index &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
  ]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; todos &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;组件数据管理&quot;&gt;组件数据管理&lt;/h2&gt;
&lt;p&gt;既然 &lt;code&gt;TodoList&lt;/code&gt; 是一个组件，初始状态 &lt;code&gt;this.state.todos&lt;/code&gt; 就有可能从外部传入。对于组件内部，我们不应该过多的关心这些数据从何而来（可能通过父容器直接 Ajax 调用后返回的数据，或者 Redux、MobX 等状态管理器获取的数据），我觉得组件的数据属性的设计可以从以下 3 个方面来考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在没有初始数据传入时应该提供一个默认值&lt;/li&gt;
&lt;li&gt;一旦数据在组件内部被更新后应该及时的通知父组件&lt;/li&gt;
&lt;li&gt;当有新的数据（从后端 API 请求的）传入组件后，应该重新更新组件内部状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据这几点，我们可以对 &lt;code&gt;TodoList&lt;/code&gt; 再做一番改造。&lt;/p&gt;
&lt;p&gt;首先，对 &lt;code&gt;TodoList&lt;/code&gt; 增加一个 &lt;code&gt;todos&lt;/code&gt; 的默认数据属性，使父组件在没有传入有效属性值时也不会影响该组件的使用：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TodoList &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;(props) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(props)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;todos&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;todos&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  ...
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;TodoList&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;defaultProps&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;todos&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; []
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，再新增一个内部方法 &lt;code&gt;this.update&lt;/code&gt; 和一个组件的更新事件回调属性 &lt;code&gt;onUpdate&lt;/code&gt;，当数据状态更新时可以及时的通知父组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TodoList &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  ...
  &lt;span class=&quot;at&quot;&gt;handleAdd&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    ...
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;update&lt;/span&gt;(todos)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;handleUpdate&lt;/span&gt;(index&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    ...
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;update&lt;/span&gt;(todos)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;handleRemove&lt;/span&gt;(index) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    ...
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;update&lt;/span&gt;(todos)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;handleStateChange&lt;/span&gt;(index) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    ...
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;update&lt;/span&gt;(todos)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;at&quot;&gt;update&lt;/span&gt;(todos) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; onUpdate &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; todos &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    onUpdate &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;onUpdate&lt;/span&gt;(todos)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就完事儿了？No! No! No! 因为 &lt;code&gt;this.state.todos&lt;/code&gt; 的初始状态是由外部 &lt;code&gt;this.props&lt;/code&gt; 传入的，假如父组件重新更新了数据，会导致子组件的数据和父组件不同步。那么，如何解决？&lt;/p&gt;
&lt;p&gt;我们回顾下 &lt;a href=&quot;https://reactjs.org/docs/react-component.html#the-component-lifecycle&quot;&gt;React 的生命周期&lt;/a&gt;，父组件传递到子组件的 props 的更新数据可以在 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 中获取。所以我们有必要在这里重新更新下 &lt;code&gt;TodoList&lt;/code&gt; 的数据，哦！千万别忘了判断传入的 todos 和当前的数据是否一致，因为，当任何传入的 props 更新时都会导致 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 的触发。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;componentWillReceiveProps&lt;/span&gt;(nextProps) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; nextTodos &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;nextProps&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;todos&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isArray&lt;/span&gt;(nextTodos) &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isEqual&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;todos&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; nextTodos)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;todos&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; nextTodos &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意代码中的 &lt;code&gt;_.isEqual&lt;/code&gt;，该方法是 &lt;a href=&quot;https://lodash.com/&quot;&gt;Lodash&lt;/a&gt; 中非常实用的一个函数，我经常拿来在这种场景下使用。&lt;/p&gt;
&lt;h2 id=&quot;结尾&quot;&gt;结尾&lt;/h2&gt;
&lt;p&gt;由于本人对 React 的了解有限，以上示例中的方案可能不一定最合适，但你也看到了 &lt;code&gt;TodoList&lt;/code&gt; 组件，既可以是包含多个不同功能逻辑的大组件，也可以拆分为独立、灵巧的小组件，我觉得我们只需要掌握一个度。当然，如何设计取决于你自己的项目，正所谓：&lt;strong&gt;没有最好的，只有更合适的&lt;/strong&gt;。还是希望本篇文章能给你带来些许的小收获。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Nov 2017 05:03:00 +0000</pubDate>
<dc:creator>nicolaszhao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nicolaszhao/p/7832012.html</dc:identifier>
</item>
<item>
<title>机器学习能在游戏开发中做什么 - 腾讯云技术社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/7831329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/7831329.html</guid>
<description>&lt;h2 id=&quot;-&quot;&gt;机器学习适合做什么&lt;/h2&gt;
&lt;p&gt;机器学习当前在很多领域，都取得了相当巨大的进步。从应用领域来看，机器学习在“信息识别”、“数据预测”、“复杂控制”几个方面，展现出很大的能力。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;比如“信息识别”领域，依赖于大数据的训练，现在的图形识别已经非常完善了，手写数字的识别仅仅是类似Hello World一类的简单应用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;“数据预测”领域百度对于世界杯的预测达到令人吃惊的100%准确率，将来这种技术在各种据别历史数据的预测应用上，将有长足的发展，比如广告的推荐系统、财经数据的决策系统等等；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;“复杂控制”方面，自动驾驶的技术经历了十几年的研究，剩下的似乎只有识别硬件的成本问题了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然而，以上这些技术，相当一部分来源于“大数据”，或者叫“监督学习”的训练，也就是说，实际上这些机器的智能是来源于人类积累在数据中的“智慧”。机器仅仅是在“模拟”人类的某种思考判断，而这种模拟采用的更多是类似“查询搜索”的方法。——不过说回来，人类的经验几千年来，都是记录在书本上，需要用另外一个大脑来学习，然后才加以运用；而机器学习跳过了人脑这个阶段，从经验直接到应用，确实是一个伟大的进度。可以增加一点想象的是，以后所有“需要经验”的事情，已经是可以用电脑来代替了，比如医生看病。不过那些需要“创造”或者“发现”的事情，比如艺术创作，理解和发现客观规律，还是需要人脑。所幸是机器学习在“无监督学习”领域，能协助人类更好的去理解和发现世界的特征，这个方面也是非常有用的，但现在似乎应用领域并不非常活跃（也许是我的了解还不够广泛）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1510556947703_4873_1510557016017.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[机器学习预测房价的例子]&lt;/p&gt;
&lt;p&gt;AlphaGo在围棋领域战胜人类，给了我们很大的想想空间，我们会想：机器是否也能像人类一样理解游戏规则，从而玩游戏呢？我个人的理解，实际上现在还是不行的。如“监督学习”的模型下，机器只能通过大量的人类的“经验数据”，来模拟人类的游戏行为，但无法独立做出判断和思考；如果使用“深度学习”，确实会有一种“超越人类”的错觉，但是无法忽视的是，“深度学习”需要一种高度抽象，模拟游戏胜负规则的公式，来指导机器的自我对弈。在围棋、象棋这类已经发展了数千年的游戏领域，“子力计算”等游戏模式经验，已经能相当准确的描述这个游戏了。而对于其他的一些比较复杂的游戏，要高度抽象的用数学模型来概括一个游戏，还是需要人类大量的思考。这也是为什么深度学习在一些规则简单的游戏中，还能表现的比较好，而另外一些比较复杂的游戏上，就需要大量的人工干预才能稍微像样的原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1510556963782_5648_1510557032136.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[AlphaGo是用了人类的游戏经验的]&lt;/p&gt;
&lt;p&gt;所以我认为，机器学习在现阶段，最成熟的应用，是利用“监督学习”的方法，对于大量人类的“经验”大数据进行模拟思考的方面。这个方向处理用于“理解”客观世界，也可以“模拟”人类对于复杂环境的行为，这两者是几乎一样的。&lt;/p&gt;
&lt;h2 id=&quot;-ai-&quot;&gt;游戏角色AI在开发上的困境&lt;/h2&gt;
&lt;p&gt;机器学习很容易让人联想到在游戏中的角色AI。一直以来游戏中NPC或怪物的AI问题都是一个游戏比较难解决的问题。比如游戏的角色行为过于单一，让玩家乏味；或者游戏角色容易因为BUG陷入一些卡死的境地。为什么游戏角色AI会有这些问题？大体不外乎几个原因：其一是描述一个完整的AI非常的繁琐，环境越复杂，AI逻辑流程越容易出现漏洞；其二是为了游戏角色AI的目标非常多样化，很多游戏角色并不是越“聪明厉害”越好，而应该是作为一个“演出系统”，来让玩家体验游戏世界的工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1510556992723_8357_1510557061056.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[一套简单的游戏行为，就需要一个复杂的行为树]&lt;/p&gt;
&lt;p&gt;现在比较流行的游戏角色AI开发方法，无外乎“状态机”和“行为树”两种，而这两种在数据结构上，是可以无损转换的，也就是说本质上是一样。这两个技术，都是为了帮游戏开发者，更准确、更完整的表述AI逻辑判断的数据结构。但是游戏本身的逻辑复杂度，还是要由程序员一段段的去理解，然后才能编写成程序。在另外一些游戏中，会用到一种叫“面向目标的路径规划”的技术，实际上是“状态机”的一种升级技术：利用A*等寻路算法，来自动生成“状态”之间的逻辑路径，而无需一开始就以人工输入的方式全部输入进去。这种技术因为是在运行时产生状态机图，所以表现出来的行为会更加丰富和准确，较少会陷入一些“没有事先预测到的状况”从而陷入逻辑卡住的情况。&lt;/p&gt;
&lt;p&gt;但是不管状态机和行为树如何努力，从开发者角度来说，都必须通过人脑来抽象和理解游戏世界的规则，和各种可能的情况。加上游戏AI很多时候是需要一种“表演”效果，要用代码和逻辑去“模拟”出一场表演，是相当繁琐的工作量。（如果以深度学习技术来说，实际上也无法做出这种表演效果，因为这种表演的逻辑行为，往往不是“最优”的选择，甚至是相当“差劲”的）&lt;/p&gt;
&lt;p&gt;所以，归根结底，游戏中的AI的困境，是由于工作量的原因造成的。由于我们没有很好的生成“游戏行为”的工具，导致我们的游戏行为往往不够好。&lt;/p&gt;
&lt;h2 id=&quot;-ai-&quot;&gt;机器学习如何应用在游戏角色AI的开发上&lt;/h2&gt;
&lt;p&gt;在机器学习领域，学习人类的行为，并且应用于合适的场景，是“监督学习”下最常见、最成熟的技术之一，经典的应用就是“自动驾驶”。相对于自动驾驶需要昂贵的雷达设备，才能“感受”现实世界，在游戏中所有的数据都唾手可得，这种监督学习的应用更是没有任何障碍。&lt;/p&gt;
&lt;p&gt;假设我们的游戏，已经把基本的游戏规则开发好，游戏场景也已经布置好，剩下的就是如何置入游戏角色。就好像一部电影，场景、道具都已经到位，摄像机和剧本都已经准备好，那么剩下的就是演员的表演了。按照以前的做法，我们需要用复杂的状态机系统，去操控那些游戏角色演出，而现在，我们可以让策划（或者其他开发人员）直接去操控游戏中的角色，去真实的以游戏的操作行为，去让游戏角色做出演出行为，而机器学习的程序，就好像录像机一样，可以通过记录我们操控的角色的行为，去学习如何模仿我们的操控。当我们表演的足够丰富后，机器学习就可以完全取代人工的操控，做出一些和预设相同的行为特征。&lt;/p&gt;
&lt;p&gt;如果我们的游戏能像上面的方法去开发角色AI，我们将会在游戏AI行为工具上，得到一次巨大的进步。我们不再需要通过人脑去抽象和转化游戏的“表演”，而是可以直接去“扮演”，这样除了可以节省大量的“程序员”的开发工作外，对于调试AI行为，表达更丰富的角色行为特征（性格），也是有相当大的好处。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1510557012593_3291_1510557080944.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[游戏开发在很多方面已经越来越接近电影制作]&lt;/p&gt;
&lt;p&gt;显然，如果完全用“游戏”的形式来取代AI开发，即便在机器学习的支持下，可能还会有很多不足之处，比如“人工表演”可能无法覆盖所有的游戏场景环境。但是只要能节省下工作量，我们还是可以利用旧的状态机技术，来定义比较“完整”的逻辑环境，弥补那些可能存在的漏洞。不过我相信，随着对游戏测试的深入，机器学习会能更快更好的应对这些逻辑漏洞，毕竟“玩”几把游戏，比用写代码然后调试，要快的多。&lt;/p&gt;
&lt;h2 id=&quot;-ai-&quot;&gt;游戏角色AI的业务价值&lt;/h2&gt;
&lt;p&gt;现在的成名游戏中，确实有那么一大批是似乎对游戏角色AI“没有必要性需求”的，比如我们常见的MOBA类游戏。在棋牌类游戏中，我们也不太希望用一个厉害的AI让我持续的输钱。但如果设想一下，如果我们的策划能比较低成本的生产“AI”，那么我们的游戏就会脱离“玩具”的层面，变成一种可以“表演”的产品。我们常常说IP对游戏的重要性，而真正能体现出IP的，往往是故事体验，这就需要一套很好的“表演”系统。&lt;/p&gt;
&lt;p&gt;从另外一个角度说，如果我们的游戏除了精彩的PVP内容，还有很多优秀的PVE内容（所谓的单机体验内容），那么玩家也许会慢慢倾向对我们所生产的PVE内容来付费。从电影市场这么多年的发展来看，优秀的“表演”还是会有很大的市场的。从知识产权保护的角度来看，游戏玩法很容易被抄袭（PVP主要是玩法），但PVE内容却很容易得到保护。除了利用海量用户去激活PVP的收入，在PVE方面的开发，也许是一个新的市场空间。（从《阴阳师》这类产品能明显感受到这股市场的潜力）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1510557028255_7939_1510557096671.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[巫师3不仅仅是一部互动电影，也是一个玩法优秀的游戏，更是一个超级IP]&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;如果我们能利用机器学习技术，开发出更通用的游戏角色AI工具，那么可能让游戏拓展出新的PVE游戏市场，对于游戏IP的输出也有非常明显的作用。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文来自 韩大 微信公众号&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 14 Nov 2017 02:49:00 +0000</pubDate>
<dc:creator>腾讯云技术社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/7831329.html</dc:identifier>
</item>
<item>
<title>Spring IOC容器分析(3) -- DefaultListableBeanFactory - YGingko</title>
<link>http://www.cnblogs.com/hthuang/p/7831305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hthuang/p/7831305.html</guid>
<description>&lt;p&gt;上一节介绍了封装bean对象的&lt;a href=&quot;http://blog.ygingko.top/2017/08/16/spring-IOC-source-3/&quot;&gt;BeanDefinition接口&lt;/a&gt;。从前面小结对&lt;a href=&quot;http://blog.ygingko.top/2017/08/11/spring-IOC-source-2/&quot;&gt;BeanFactory的介绍&lt;/a&gt;中，我们知道bean对象是存储在map中，通过调用getBean方法可以得到bean对象。在接口BeanFactory中定义了多个相同签名的getBean方法，如下所示：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    Object &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(String name) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException;

    &amp;lt;T&amp;gt; T &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(String name, Class&amp;lt;T&amp;gt; requiredType) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException;

    &amp;lt;T&amp;gt; T &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(Class&amp;lt;T&amp;gt; requiredType) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException;

    Object &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(String name, Object&lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException;

    &amp;lt;T&amp;gt; T &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(Class&amp;lt;T&amp;gt; requiredType, Object&lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;DefaultListableBeanFactory是Bean工厂的一个默认实现，我们可以对它进行拓展以便实现自定义的Bean工厂。作为默认的Bean工厂实现，肯定也实现了接口中定义的getBean方法。截取DefaultListableBeanFactory中与getBean方法相关的源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DefaultListableBeanFactory &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; AbstractAutowireCapableBeanFactory
        &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {
    
    ......
    
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(Class&amp;lt;T&amp;gt; requiredType) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(requiredType, (Object[]) &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(Class&amp;lt;T&amp;gt; requiredType, Object&lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException {
        NamedBeanHolder&amp;lt;T&amp;gt; namedBean = &lt;span class=&quot;fu&quot;&gt;resolveNamedBean&lt;/span&gt;(requiredType, args);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (namedBean != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; namedBean.&lt;span class=&quot;fu&quot;&gt;getBeanInstance&lt;/span&gt;();
        }
        BeanFactory parent = &lt;span class=&quot;fu&quot;&gt;getParentBeanFactory&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (parent != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; parent.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(requiredType, args);
        }
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;NoSuchBeanDefinitionException&lt;/span&gt;(requiredType);
    }
    
    ......
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现DefaultListableBeanFactory中只实现了两个getBean接口，BeanFactory中总共有五个接口，那另外三个接口呢？在哪里实现的？尤其是最重要的&lt;code&gt;getBean(String name)&lt;/code&gt;接口。&lt;/p&gt;
&lt;p&gt;查看DefaultListableBeanFactory类UML类图关系发现有一个AbstractBeanFactory抽象类，DefaultListableBeanFactory继承了AbstractBeanFactory，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oucea6kvo.bkt.clouddn.com/spring-ioc-source-defaultListableBeanFactory-UML%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB.jpg&quot; alt=&quot;DefaultListableBeanFactoryUML类图关系&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过查找AbstractBeanFactory源码，终于找到BeanFactory接口中另外三个getBean方法的实现。源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;64&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package org.springframework.beans.factory.support;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.beans.PropertyEditor;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.security.AccessControlContext;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.security.AccessController;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.security.PrivilegedAction;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.security.PrivilegedActionException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.security.PrivilegedExceptionAction;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Arrays;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Collections;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.HashMap;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.HashSet;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Iterator;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.LinkedHashMap;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.LinkedHashSet;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.LinkedList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Map;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Set;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ConcurrentHashMap;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.BeanUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.BeanWrapper;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.BeansException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.PropertyEditorRegistrar;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.PropertyEditorRegistry;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.PropertyEditorRegistrySupport;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.SimpleTypeConverter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.TypeConverter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.TypeMismatchException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.BeanCreationException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.BeanCurrentlyInCreationException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.BeanDefinitionStoreException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.BeanFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.BeanFactoryUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.BeanIsAbstractException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.BeanIsNotAFactoryException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.BeanNotOfRequiredTypeException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.CannotLoadBeanClassException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.FactoryBean;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.NoSuchBeanDefinitionException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.ObjectFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.SmartFactoryBean;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.config.BeanDefinition;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.config.BeanDefinitionHolder;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.config.BeanExpressionContext;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.config.BeanExpressionResolver;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.config.BeanPostProcessor;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.config.ConfigurableBeanFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.config.Scope;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.core.DecoratingClassLoader;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.core.NamedThreadLocal;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.core.ResolvableType;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.core.convert.ConversionService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.util.Assert;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.util.ClassUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.util.ObjectUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.util.StringUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.util.StringValueResolver;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; AbstractBeanFactory &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; FactoryBeanRegistrySupport &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; ConfigurableBeanFactory {
    
    ......
      
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(String name) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doGetBean&lt;/span&gt;(name, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(String name, Class&amp;lt;T&amp;gt; requiredType) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doGetBean&lt;/span&gt;(name, requiredType, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(String name, Object&lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doGetBean&lt;/span&gt;(name, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, args, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(String name, Class&amp;lt;T&amp;gt; requiredType, Object&lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doGetBean&lt;/span&gt;(name, requiredType, args, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; T &lt;span class=&quot;fu&quot;&gt;doGetBean&lt;/span&gt;(
            &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String name, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; requiredType, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Object[] args, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; typeCheckOnly)
            &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException {

        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String beanName = &lt;span class=&quot;fu&quot;&gt;transformedBeanName&lt;/span&gt;(name);
        Object bean;

        &lt;span class=&quot;co&quot;&gt;// Eagerly check singleton cache for manually registered singletons.&lt;/span&gt;
        Object sharedInstance = &lt;span class=&quot;fu&quot;&gt;getSingleton&lt;/span&gt;(beanName);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (sharedInstance != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; args == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (logger.&lt;span class=&quot;fu&quot;&gt;isDebugEnabled&lt;/span&gt;()) {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isSingletonCurrentlyInCreation&lt;/span&gt;(beanName)) {
                    logger.&lt;span class=&quot;fu&quot;&gt;debug&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Returning eagerly cached instance of singleton bean '&quot;&lt;/span&gt; + beanName +
                            &lt;span class=&quot;st&quot;&gt;&quot;' that is not fully initialized yet - a consequence of a circular reference&quot;&lt;/span&gt;);
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                    logger.&lt;span class=&quot;fu&quot;&gt;debug&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Returning cached instance of singleton bean '&quot;&lt;/span&gt; + beanName + &lt;span class=&quot;st&quot;&gt;&quot;'&quot;&lt;/span&gt;);
                }
            }
            bean = &lt;span class=&quot;fu&quot;&gt;getObjectForBeanInstance&lt;/span&gt;(sharedInstance, name, beanName, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
        }

        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// Fail if we're already creating this bean instance:&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// We're assumably within a circular reference.&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isPrototypeCurrentlyInCreation&lt;/span&gt;(beanName)) {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanCurrentlyInCreationException&lt;/span&gt;(beanName);
            }

            &lt;span class=&quot;co&quot;&gt;// Check if bean definition exists in this factory.&lt;/span&gt;
            BeanFactory parentBeanFactory = &lt;span class=&quot;fu&quot;&gt;getParentBeanFactory&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (parentBeanFactory != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span class=&quot;fu&quot;&gt;containsBeanDefinition&lt;/span&gt;(beanName)) {
                &lt;span class=&quot;co&quot;&gt;// Not found -&amp;gt; check parent.&lt;/span&gt;
                String nameToLookup = &lt;span class=&quot;fu&quot;&gt;originalBeanName&lt;/span&gt;(name);
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (args != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                    &lt;span class=&quot;co&quot;&gt;// Delegation to parent with explicit args.&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (T) parentBeanFactory.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(nameToLookup, args);
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                    &lt;span class=&quot;co&quot;&gt;// No args -&amp;gt; delegate to standard getBean method.&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; parentBeanFactory.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(nameToLookup, requiredType);
                }
            }

            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!typeCheckOnly) {
                &lt;span class=&quot;fu&quot;&gt;markBeanAsCreated&lt;/span&gt;(beanName);
            }

            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; RootBeanDefinition mbd = &lt;span class=&quot;fu&quot;&gt;getMergedLocalBeanDefinition&lt;/span&gt;(beanName);
                &lt;span class=&quot;fu&quot;&gt;checkMergedBeanDefinition&lt;/span&gt;(mbd, beanName, args);

                &lt;span class=&quot;co&quot;&gt;// Guarantee initialization of beans that the current bean depends on.&lt;/span&gt;
                String[] dependsOn = mbd.&lt;span class=&quot;fu&quot;&gt;getDependsOn&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (dependsOn != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (String dep : dependsOn) {
                        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isDependent&lt;/span&gt;(beanName, dep)) {
                            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanCreationException&lt;/span&gt;(mbd.&lt;span class=&quot;fu&quot;&gt;getResourceDescription&lt;/span&gt;(), beanName,
                                    &lt;span class=&quot;st&quot;&gt;&quot;Circular depends-on relationship between '&quot;&lt;/span&gt; + beanName + &lt;span class=&quot;st&quot;&gt;&quot;' and '&quot;&lt;/span&gt; + dep + &lt;span class=&quot;st&quot;&gt;&quot;'&quot;&lt;/span&gt;);
                        }
                        &lt;span class=&quot;fu&quot;&gt;registerDependentBean&lt;/span&gt;(dep, beanName);
                        &lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(dep);
                    }
                }

                &lt;span class=&quot;co&quot;&gt;// Create bean instance.&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (mbd.&lt;span class=&quot;fu&quot;&gt;isSingleton&lt;/span&gt;()) {
                    sharedInstance = &lt;span class=&quot;fu&quot;&gt;getSingleton&lt;/span&gt;(beanName, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectFactory&amp;lt;Object&amp;gt;() {
                        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;getObject&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException {
                            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;createBean&lt;/span&gt;(beanName, mbd, args);
                            }
                            &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (BeansException ex) {
                                &lt;span class=&quot;co&quot;&gt;// Explicitly remove instance from singleton cache: It might have been put there&lt;/span&gt;
                                &lt;span class=&quot;co&quot;&gt;// eagerly by the creation process, to allow for circular reference resolution.&lt;/span&gt;
                                &lt;span class=&quot;co&quot;&gt;// Also remove any beans that received a temporary reference to the bean.&lt;/span&gt;
                                &lt;span class=&quot;fu&quot;&gt;destroySingleton&lt;/span&gt;(beanName);
                                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; ex;
                            }
                        }
                    });
                    bean = &lt;span class=&quot;fu&quot;&gt;getObjectForBeanInstance&lt;/span&gt;(sharedInstance, name, beanName, mbd);
                }

                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (mbd.&lt;span class=&quot;fu&quot;&gt;isPrototype&lt;/span&gt;()) {
                    &lt;span class=&quot;co&quot;&gt;// It's a prototype -&amp;gt; create a new instance.&lt;/span&gt;
                    Object prototypeInstance = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                        &lt;span class=&quot;fu&quot;&gt;beforePrototypeCreation&lt;/span&gt;(beanName);
                        prototypeInstance = &lt;span class=&quot;fu&quot;&gt;createBean&lt;/span&gt;(beanName, mbd, args);
                    }
                    &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
                        &lt;span class=&quot;fu&quot;&gt;afterPrototypeCreation&lt;/span&gt;(beanName);
                    }
                    bean = &lt;span class=&quot;fu&quot;&gt;getObjectForBeanInstance&lt;/span&gt;(prototypeInstance, name, beanName, mbd);
                }

                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                    String scopeName = mbd.&lt;span class=&quot;fu&quot;&gt;getScope&lt;/span&gt;();
                    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Scope scope = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scopes&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(scopeName);
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (scope == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;st&quot;&gt;&quot;No Scope registered for scope name '&quot;&lt;/span&gt; + scopeName + &lt;span class=&quot;st&quot;&gt;&quot;'&quot;&lt;/span&gt;);
                    }
                    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                        Object scopedInstance = scope.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(beanName, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ObjectFactory&amp;lt;Object&amp;gt;() {
                            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;getObject&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; BeansException {
                                &lt;span class=&quot;fu&quot;&gt;beforePrototypeCreation&lt;/span&gt;(beanName);
                                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;createBean&lt;/span&gt;(beanName, mbd, args);
                                }
                                &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
                                    &lt;span class=&quot;fu&quot;&gt;afterPrototypeCreation&lt;/span&gt;(beanName);
                                }
                            }
                        });
                        bean = &lt;span class=&quot;fu&quot;&gt;getObjectForBeanInstance&lt;/span&gt;(scopedInstance, name, beanName, mbd);
                    }
                    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IllegalStateException ex) {
                        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanCreationException&lt;/span&gt;(beanName,
                                &lt;span class=&quot;st&quot;&gt;&quot;Scope '&quot;&lt;/span&gt; + scopeName + &lt;span class=&quot;st&quot;&gt;&quot;' is not active for the current thread; consider &quot;&lt;/span&gt; +
                                &lt;span class=&quot;st&quot;&gt;&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;&lt;/span&gt;,
                                ex);
                    }
                }
            }
            &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (BeansException ex) {
                &lt;span class=&quot;fu&quot;&gt;cleanupAfterBeanCreationFailure&lt;/span&gt;(beanName);
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; ex;
            }
        }

        &lt;span class=&quot;co&quot;&gt;// Check if required type matches the type of the actual bean instance.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (requiredType != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; bean != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !requiredType.&lt;span class=&quot;fu&quot;&gt;isAssignableFrom&lt;/span&gt;(bean.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;())) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getTypeConverter&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;convertIfNecessary&lt;/span&gt;(bean, requiredType);
            }
            &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (TypeMismatchException ex) {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (logger.&lt;span class=&quot;fu&quot;&gt;isDebugEnabled&lt;/span&gt;()) {
                    logger.&lt;span class=&quot;fu&quot;&gt;debug&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Failed to convert bean '&quot;&lt;/span&gt; + name + &lt;span class=&quot;st&quot;&gt;&quot;' to required type '&quot;&lt;/span&gt; +
                            ClassUtils.&lt;span class=&quot;fu&quot;&gt;getQualifiedName&lt;/span&gt;(requiredType) + &lt;span class=&quot;st&quot;&gt;&quot;'&quot;&lt;/span&gt;, ex);
                }
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanNotOfRequiredTypeException&lt;/span&gt;(name, requiredType, bean.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;());
            }
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (T) bean;
    }
  
    ......
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在三个相同签名getBean方法中，均调用doGetBean方法。doGetBean方法负责从Bean工厂中获取bean对象的具体实现，下面来看看该方法的具体实现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查手动注册的单例集合缓存中是否含有该bean对象，若有，则取出返回，否则继续执行；&lt;/li&gt;
&lt;li&gt;检查该bean是否已经创建，从而判断是否属于循环引用，若是，抛出异常返回，否则继续执行；&lt;/li&gt;
&lt;li&gt;判断bean工厂中是否存在该bean definition，若存在，则取出返回，否则继续执行；&lt;/li&gt;
&lt;li&gt;初始化该bean所依赖的bean对象；&lt;/li&gt;
&lt;li&gt;判断该bean是否是单例模式（singleton），若是，创建单例对象，否则继续执行；&lt;/li&gt;
&lt;li&gt;判断该bean是否是原型模式（prototype），若是，创建原型对象，否则继续执行；&lt;/li&gt;
&lt;li&gt;创建自定义类型（scope）bean对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上面对doGetBean方法分析，可看出创建并获取bean对象是一个非常复杂的过程，并不是简简单单的放入Map中再从其中取出。&lt;/p&gt;

&lt;p&gt;本文对IOC容器的核心getBean()方法作了简单的分析，初步了解了IOC容器中getBean()方法的执行流程原理，这对于帮助我们理解IOC容器是十分有帮助的。目前对IOC机制的各个模块都有了一定的了解，下面可以综合各个模块，串联起来研究IOC依赖注入的完整流程。&lt;/p&gt;
&lt;p&gt;下文将以ClassPathXmlApplicationContext作为xml文件加载器，实现Spring IOC的类加载，通过断点跟踪来&lt;a href=&quot;http://blog.ygingko.top/2017/08/22/spring-IOC-source-5&quot;&gt;了解IOC对象注入完整流程&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Nov 2017 02:45:00 +0000</pubDate>
<dc:creator>YGingko</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hthuang/p/7831305.html</dc:identifier>
</item>
<item>
<title>基础技能树-22 基于数组实现数据结构 - 李永京</title>
<link>http://www.cnblogs.com/lyj/p/foundation_22_data_structure.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyj/p/foundation_22_data_structure.html</guid>
<description>&lt;p&gt;本节内容&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开篇&lt;/li&gt;
&lt;li&gt;栈(Stack)&lt;/li&gt;
&lt;li&gt;队列(Queue)&lt;/li&gt;
&lt;li&gt;缓冲区(Pool)[付费阅读]&lt;/li&gt;
&lt;li&gt;链表(Linked List)[付费阅读]&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;开篇&quot;&gt;开篇&lt;/h2&gt;
&lt;p&gt;很显然数组带来很大的好处，直接的好处有几点，第一它是一块完整的连续的内存而且只需要一次性分配，第二数组本身访问效率很高，第三我们可以对数组进行复制，因为数组只有一块内存，我只要把这一块的内存完整复制就可以了，而其他的很多复合结构可能有多块内存组成的，我们想复制的时候并不容易。比如切片还好点只有两块内存，比如像链表可能有很多块内存，我们想复制一个链表的时候我们得遍历一块一块的复制，所以数组先天性的具备了性能上的优势，我们承认数组在操作上的确有很多麻烦，但数组的性能不能忽略。接下来我们做的是能不能用数组实现常用的数据结构。第一我们使用数组带来的性能优势，第二把数组转换为另外的访问方式带来操作上的便利性。把这两者结合起来，因为直接操作数组的很多时候比较麻烦，比如我们插入、删除这些操作不特别方便。所以我们接下来把数组和其他数组结构访问上的便利性结合起来。&lt;/p&gt;
&lt;h2 id=&quot;栈stack&quot;&gt;栈(Stack)&lt;/h2&gt;
&lt;p&gt;栈是很典型的先进后出(FILO)数据结构。其实我们在前面接触很多的栈，调用堆栈本身就是一个栈结构，它是一个内存空间，地址从高位到低位分配，首先高位记录一个位置，比如使用BP寄存器保存，另外一个位置用SP寄存器来处理当前栈顶的位置。加一个数据即Push操作SP往上减，弹出一个数据即Pop操作SP往下增。很显然用一个数组加两个字段来模拟SP、BP就可以了。我们怎么样去做呢，用一个最简单的做法就是第一种方式使用一个结构体，指针属性指向一个数组，数组天生就包含了起始位置BP和容量cap，或者这个数组直接内联，然后SP属性记录栈顶的位置就可以实现简单栈的管理。还有个简单的方式使用一个数组，把位置一当作BP寄存器使用，假如我们需要分配四个元素项的栈，那么实际分配就是4+1，把索引0当作BP来用，以后就是操作数组后面的空间。这样的方式与结构体类似，因为结构体本身内存也是连续的，一块是数组，一块是BP，结构体也是这样的数据结构本质上是一回事。当然也可以用数组方式做，只需要有个地方记录一下BP的值就可以了，所以整个的栈结构实现起来非常的简单。&lt;/p&gt;
&lt;p&gt;s是一个动态的内存，所以我们用切片的方式去创建，切片看上去和数组是一样的，我们的目的是获得一个动态数组，我们把容量+1，用0来当作BP寄存器来用。首先初始化的时候0指向栈底的位置，然后往里加数据的时候BP往上移，所以BP初始化的时候指向最后一个位置。接下来往里面加数据的时候，读取BP寄存器的值，如果这时候SP指向0的位置的时候栈已经满了，先判断栈是否已经满了，满了的话返回一个错误，如果不满的话直接把数据写进去，同时往里压数据的时候，每压一个数据，BP寄存器往上移一次，表示下次可以往新的地方写。弹出数据的时候，BP寄存器记录的是最后一次可写的位置，可写和可读的数据中间应该差一个，首先加上1调整BP寄存器位置，如果这个位置指向最低的时候表示没有数据了，表示为空，如果有数据就返回，同时调整BP寄存器，因为我们知道弹出数据的时候，SP往下做加法，压数据的时候，SP往上做减法。整个操作很简单也就是4-5行核心代码。&lt;/p&gt;
&lt;p&gt;如果不用数组用链表实现队列和栈最简单的，但是链表在内存管理上有很大的缺陷。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;errors&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; Stack []&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; (
    ErrStackFull  = errors.New(&lt;span class=&quot;st&quot;&gt;&quot;stack full&quot;&lt;/span&gt;)
    ErrStackEmpty = errors.New(&lt;span class=&quot;st&quot;&gt;&quot;stack empty&quot;&lt;/span&gt;)
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; NewStack(&lt;span class=&quot;fu&quot;&gt;cap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) Stack {
    s := &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;cap&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;)
    s[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;fu&quot;&gt;cap&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; s
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; (s Stack) Push(v &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;error&lt;/span&gt; {
    i := s[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; i == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ErrStackFull
    }

    s[i] = v
    s[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] = i - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; (s Stack) Pop() (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;error&lt;/span&gt;) {
    i := s[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; i == &lt;span class=&quot;fu&quot;&gt;cap&lt;/span&gt;(s) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, ErrStackEmpty
    }

    v := s[i]
    s[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] = i

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; v, &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;队列queue&quot;&gt;队列(Queue)&lt;/h2&gt;
&lt;p&gt;队列是很典型的先进先出(FIFO)数据结构。队列如果是一个数组结构，我们从左往右加数据，实际上有两个属性需要注意的，第一个是写W的位置，第二个是读R的位置。比如我们可以连续写3个格子，写的位置就到位置4，读的位置还是停留在位置1，所以读和写的位置是不一样的。这地方就有个问题，我们怎么维护读和写的位置。比如说写满了以后就不能写了，我们通常会实现一个&lt;code&gt;环状队列&lt;/code&gt;，比如写满了，接下来读操作，读到位置3，那么1-2空间就重新可用了，写的位置就会调整到位置1，这就有个麻烦，W可能大于R，W也可能小于R，我们怎么处理这个呢？&lt;/p&gt;
&lt;p&gt;记录当前元素数量记录W和R的位置，因为W和R默认都为0，当往里面写的时候数量会递增，当数量等于容量的时候表示满了，假如数据数量是2，在位置2和位置3，W写的时候写在位置4，写满了，这时候数据数据不等于容量，怎么知道W需要回头呢。所以W和R除了要和数据数量比较还需要和容量即最后一个索引号比较。如果等于最大的索引号，W就需要回头。&lt;/p&gt;
&lt;p&gt;第一个背景，假设有这样的一个容器，4个格子，我们有个指针一直做加法，那么到一定程度就超出了容器的限制，不管这个指针超出多大，我们对于指针与容量取模操作结果值肯定是在容量范围之内。任何一个数字除以一个固定容量那么余数肯定会在这个范围之类。&lt;/p&gt;
&lt;p&gt;第二个背景，队列R和W最大的麻烦是队列有长度限制，因为有长度限制，所以R和W有回头操作，假如长度没有限制无限长，那么W永远大于等于R，W减去R肯定是当前数据长度，这样的话，队列长度无限的，判断逻辑就非常简单。&lt;/p&gt;
&lt;p&gt;我们把第一个背景和第二个背景组合到一起，如果变成一个环，假如这个队列是个环状的，假如这个环是无限大小的，那么R到W区域就是有数据的。问题是真实情况我们的队列肯定是有限制的，我们用抽象大小的环来处理R和W的值，第一个用抽象的处理R和W，避免R和W回头操作，第二个在数据读写的时候，去做取模操作，因为取模操作就可以映射到真实的容量具体的位置上面，那么接下来需要判断事就很简单，要么写满了，要么是空的没数据。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
    &lt;span class=&quot;st&quot;&gt;&quot;errors&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; RingQueue &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; {
    data []&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
    head &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
    tail &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; (
    ErrQueueFull  = errors.New(&lt;span class=&quot;st&quot;&gt;&quot;queue full&quot;&lt;/span&gt;)
    ErrQueueEmpty = errors.New(&lt;span class=&quot;st&quot;&gt;&quot;queue empty&quot;&lt;/span&gt;)
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; NewRingQueue(&lt;span class=&quot;fu&quot;&gt;cap&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) *RingQueue {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &amp;amp;RingQueue{
        data: &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;cap&lt;/span&gt;),
    }
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; (q *RingQueue) Push(x &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;error&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;cap&lt;/span&gt;(q.data) - (q.tail - q.head)) == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ErrQueueFull
    }

    n := q.tail % &lt;span class=&quot;fu&quot;&gt;cap&lt;/span&gt;(q.data)
    q.data[n] = x

    q.tail++
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; (q *RingQueue) Pop() (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;error&lt;/span&gt;) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; q.tail == q.head {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, ErrQueueEmpty
    }

    n := q.head % &lt;span class=&quot;fu&quot;&gt;cap&lt;/span&gt;(q.data)
    x := q.data[n]

    q.head++
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; x, &lt;span class=&quot;ot&quot;&gt;nil&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是很简单的数据结构，一个数组，一个读一个写，写的位置作为头head，读的位置作为尾tail。头和尾之间的区域就是有数据的区域。往里面写Push的时候，先判断下当前是否有真实的地方有空位，假如无限大小的，tail减去head是有数据的区域，总长度减去有数据的长度就是空位长度，所以&lt;code&gt;cap(data) - (tail - head)&lt;/code&gt;就是是否有空位，那么tail和head一直累加和总长度没有关系的，这样的话首先判断是否有空位，如果空位等于零就表示已经满了，直接返回一个错误。如果没有满，把尾部的信息取模操作就是把抽象的环映射到真实的数据结构上面。接下来在真实位置写，然后把抽象环上的tail值累加。读操作其实也是一样的，所以说这地方只有两个概念构成，抽象大小的环处理tail和head的位置，这两个位置只是要判断有数据的长度或者是空位的长度，有数据的长度大于零代表有数据，空位的长度大于零代表有写的位置。对应映射固定长度的队列，有数据队列上肯定有数据的，有空位队列上肯定有空位的。&lt;/p&gt;
&lt;p&gt;这样一来我们就不需要处理tail和head前后的问题了，把这个逻辑变得很简单了，有些时候我们需要用抽象的概念去处理复杂的逻辑，就是把复杂的逻辑抽象化。我们借助抽象的概念来处理简单的索引位置。这是一个很典型的环状设计。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
    s := NewRingQueue(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)

    fmt.Println(s.Push(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), s)
    fmt.Println(s.Push(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), s)
    fmt.Println(s.Push(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;), s)
    fmt.Println(s.Push(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;), s)

    fmt.Println(s.Pop())
    fmt.Println(s.Pop())
    fmt.Println(s.Pop())
    fmt.Println(s.Pop())

    fmt.Println(s.Push(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;), s)
    fmt.Println(s.Push(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), s)
    fmt.Println(s.Pop())
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 14 Nov 2017 01:14:00 +0000</pubDate>
<dc:creator>李永京</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyj/p/foundation_22_data_structure.html</dc:identifier>
</item>
<item>
<title>riot.js教程【三】访问DOM元素、使用jquery、mount输入参数、riotjs标签的生命周期 - liulun</title>
<link>http://www.cnblogs.com/liulun/p/7827072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liulun/p/7827072.html</guid>
<description>&lt;blockquote readability=&quot;0.54961832061069&quot;&gt;
&lt;p&gt;前文回顾&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/liulun/p/7681073.html&quot;&gt;riot.js教程【二】组件撰写准则、预处理器、标签样式和装配方法；&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/liulun/p/7672876.html&quot;&gt;riot.js教程【一】简介；&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;访问dom元素&quot;&gt;访问DOM元素&lt;/h2&gt;
&lt;p&gt;你可以通过this.refs对象访问dom元素&lt;/p&gt;
&lt;p&gt;而且还有大量的属性简写方式可以使用&lt;/p&gt;
&lt;p&gt;比如：if=&quot;{...}&quot;，（有时候你需要对这些东西做一些特殊的处理才能用）&lt;/p&gt;
&lt;h2 id=&quot;使用jquery&quot;&gt;使用Jquery&lt;/h2&gt;
&lt;p&gt;如果你想在riot标签内部访问dom元素&lt;/p&gt;
&lt;p&gt;你可能需要了解一下riot标签生命周期相关的知识&lt;/p&gt;
&lt;p&gt;你会注意到，mount方法还没执行的时候，dom元素是不会被创建的&lt;/p&gt;
&lt;p&gt;这就意味着，mount方法之前访问DOM元素，是不会成功的&lt;/p&gt;
&lt;p&gt;请看如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;example-tag&amp;gt;
  &amp;lt;p id=&quot;findMe&quot;&amp;gt;Do I even Exist?&amp;lt;/p&amp;gt;
  &amp;lt;script&amp;gt;
  var test1 = document.getElementById('findMe')
  console.log('test1', test1)  // Fails
  this.on('update', function(){
    var test2 = document.getElementById('findMe')
    console.log('test2', test2) // Succeeds, fires on every update
  })
  this.on('mount', function(){
    var test3 = document.getElementById('findMe')
    console.log('test3', test3) // Succeeds, fires once (per mount)
  })
  &amp;lt;/script&amp;gt;
&amp;lt;/example-tag&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，你只要在正确的函数中使用jquery是一点问题都没有的；&lt;/p&gt;
&lt;p&gt;再看下面的代码（两种检索方式都是支持的，第一种就是jquery检索DOM）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;example-tag&amp;gt;
  &amp;lt;p id=&quot;findMe&quot;&amp;gt;Do I even Exist?&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;Is this real life?&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;Or just fantasy?&amp;lt;/p&amp;gt;
  &amp;lt;script&amp;gt;
  this.on('mount', function(){
    // Contexted jQuery
    $('p', this.root)

    // Contexted Query Selector
    this.root.querySelectorAll('p')
  })
  &amp;lt;/script&amp;gt;
&amp;lt;/example-tag&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mount输入参数&quot;&gt;mount输入参数&lt;/h2&gt;
&lt;p&gt;你可以在初始化的时候为riotjs标签传入更多参数，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
riot.mount('todo', { title: 'My TODO app', items: [ ... ] })
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以传递任何类型的数据；&lt;/p&gt;
&lt;p&gt;可以是一个简单的object；&lt;/p&gt;
&lt;p&gt;也可以是动态变化的数据存储（flux store）&lt;/p&gt;
&lt;p&gt;在标签内部，你可以使用如下方法访问这些输入参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;my-tag&amp;gt;
  &amp;lt;!-- Options in HTML --&amp;gt;
  &amp;lt;h3&amp;gt;{ opts.title }&amp;lt;/h3&amp;gt;
  // Options in JavaScript
  var title = opts.title
&amp;lt;/my-tag&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;riotjs标签的生命周期&quot;&gt;riotjs标签的生命周期&lt;/h2&gt;
&lt;p&gt;riotjs标签按照如下步骤构造及渲染&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Tag构造&lt;/li&gt;
&lt;li&gt;Tag内部的js执行&lt;/li&gt;
&lt;li&gt;Tag内部的HTML中的表达式被执行&lt;/li&gt;
&lt;li&gt;Tag在浏览器上渲染，mount事件触发&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一个riotjs标签在浏览器上渲染，mount事件触发后，何时会被更新呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当一个Tag内的事件被触发的时候（除非你设置了禁止更新变量e.preventUpdate为true）&lt;/li&gt;
&lt;li&gt;当在Tag实例内部调用this.update()的时候&lt;/li&gt;
&lt;li&gt;当在一个父组件实例内部调用this.update()的时候（该父组件下的所有子组件都会更新）&lt;/li&gt;
&lt;li&gt;当调用riot.update()的时候（会触发全局更新）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当一个组件执行更新后，会触发update事件&lt;/p&gt;
&lt;h2 id=&quot;监听生命周期事件&quot;&gt;监听生命周期事件&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;todo&amp;gt;

  this.on('before-mount', function() {
    // before the tag is mounted
  })

  this.on('mount', function() {
    // right after the tag is mounted on the page
  })

  this.on('update', function() {
    // allows recalculation of context data before the update
  })

  this.on('updated', function() {
    // right after the tag template is updated after an update call
  })

  this.on('before-unmount', function() {
    // before the tag is removed
  })

  this.on('unmount', function() {
    // when the tag is removed from the page
  })

  // curious about all events ?
  this.on('*', function(eventName) {
    console.info(eventName)
  })

&amp;lt;/todo&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以为一个事件设置多个监听&lt;/p&gt;
</description>
<pubDate>Tue, 14 Nov 2017 01:13:00 +0000</pubDate>
<dc:creator>liulun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liulun/p/7827072.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core集成现有系统认证 - 腾飞（Jesse)</title>
<link>http://www.cnblogs.com/jesse2013/p/integrate-with-lagacy-auth.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jesse2013/p/integrate-with-lagacy-auth.html</guid>
<description>&lt;p&gt;我们现在大多数转向ASP.NET Core来使用开发的团队，应该都不是从0开始搭建系统，而是老的业务系统已经在运行，ASP.NET Core用来开发新模块。那么解决用户认证的问题，成为我们的第一个拦路虎。本文将给大家简单阐述一下认证与授权的基本概念，以及基于ASP.NET Core 中间件实现的认证和改造JwtBearer 认证中间件来实现的认证达到与老系统（主要是token-based认证）的集成。&lt;/p&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;认证与授权
&lt;ul&gt;&lt;li&gt;什么是认证&lt;/li&gt;
&lt;li&gt;何谓授权&lt;/li&gt;
&lt;li&gt;用Middleware拦截&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;定制JWT Bearer 认证
&lt;ul&gt;&lt;li&gt;更改token来源&lt;/li&gt;
&lt;li&gt;更改token验证方式&lt;/li&gt;
&lt;li&gt;开始授权 &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;magicdomid4&quot; class=&quot;gutter-author-150938 locate lineguid-3tKkfX70Q6eFbKWn&quot; data-author-name=&quot;Jesse&quot;&gt;&lt;span class=&quot;author-150938 b&quot;&gt;什么是认证？ &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-150938&quot;&gt;首先认证并不是登录。认证是一个知道用户是谁的一个过程。我们最早使用的基于Session的认证，拿到用户输入的用户名和密码到数据库里面校验一，看看是否正确，如果是正确的我们就放到session里面。这是一个完成认证的过程，系统现在知道你是我的某一个用户了。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;magicdomid8&quot; class=&quot;gutter-author-150938 locate lineguid-n3DeP2pguAKyF8Pw&quot; data-author-name=&quot;Jesse&quot;&gt;&lt;span class=&quot;author-150938 b&quot;&gt;那么何谓授权？ &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-150938&quot;&gt;现在用户登录之后我们跳转到了另一个页面，这个页面可能会写一段这样的代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;gutter-author-150938 locate lineguid-I4Ys9cS9gPIkTCVx&quot; data-author-name=&quot;Jesse&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(Session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
{
  Response.redirect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/login.aspx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;20.5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;author-150938&quot;&gt;如果用户登录的Session不存在则再跳回到登录页面让用户登录。 检查当前用户有没有某个权限的这个过程叫授权。如果没有怎么办？我们就会跳转用户到一个没有权限的提示页面，或者返回  Forbidden 403 的HTTP 状态码，这是最简单的授权。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;author-150938&quot;&gt;复杂的授权方式包括对角色，对具体资源访问以及操作的授权，这块我们后面再讲。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;author-150938&quot;&gt;当我们的ASP.NET Core项目需要与老的项目兼容的时候，就需要兼容老项目的认证方式，比如某种自定义的token（这是之前比较常见的做法）。我们需要在ASP.NET Core中根据当前用户header里面的token来判断是否为一个合法的用户。&lt;/span&gt;&lt;/p&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;12&quot;&gt;
&lt;h3 id=&quot;magicdomid20&quot; class=&quot;gutter-author-150938 heading-2 locate lineguid-6xPlNDJbqTTMHAt6&quot; data-author-name=&quot;Jesse&quot;&gt;用Middleware拦截&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;author-150938&quot;&gt;第一种简单粗暴的方法即用Middleware来拦截。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在ASP.NET Core下，MVC以一个Middleware加入到整个HTTP管道。在此之前还会添加一个Routing的Middleware，注意这里的意思也就是说 Routing不再和ASP.NET MVC一样属于它的一部分。正好相反，在ASP.NET Core里面是有一个MVCRouteHandler被 Routing Middleware 加载出来处理请求。关于路由这块我们后面再说。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;如果我们要在MVC Middleware执行之请拦截请求只要加一个Middleware在 MVC Middleware或者Routing之前即可。&lt;/p&gt;

&lt;div data-author-name=&quot;Jesse&quot;&gt;&lt;img class=&quot;size-full wp-image-120 aligncenter&quot; src=&quot;http://www.jessetalk.cn/wp-content/uploads/2017/11/middleware_sequence.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;601&quot;/&gt;&lt;/div&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app)
{
    app.Use(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; (context, next) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.Request.Headers.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token =&lt;span&gt; 
        context.Request.Headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].FirstOrDefault();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (token == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jessetalk.cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {
          &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next();
        }
    }  
    context.Response.StatusCode &lt;/span&gt;= &lt;span&gt;401&lt;/span&gt;&lt;span&gt;;
  });
  
  
  app.UseMvc();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;13.5&quot;&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;18.5&quot;&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;上面是我们有简易的方法实现的一个Middleware，被加到了MVC之前。当Request的Headers中没有一个值为“jessetalk.cn” 以及 name为” token”的项的时候，我们就返回401状态，并且不执行后面的处理。（不调用 next方法)&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;author-150938&quot;&gt;但是这种办法相当于一刀切，我们添加的这个Middleware发生在 MVC Middleware之前把所有没有认证信息的请求全部拦截掉了。好处是有节省服务器资源（如果确定是要拦截的就没有必须再经过MVC的一些处理了），坏处是无法实现单个Controller或者Action的灵活配置。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;ASP.NET Core为我们实现了JWTBearer Authentication，关于 JWTBearer Authentication的实现可以参考另外一篇文章《在ASP.NET Core中使用JWTBearer Authentication》。我们今天要做的就是通过定制JWTBearer Authentication来达到让它读取我们自定义的Token并且用我们自己的方式来校验这个Token。有点时代倒退的感觉是不是？&lt;/p&gt;
&lt;p&gt;如果在时间和人员都足够的情况下，我们是可能直接整体替换成标准的JWT方案，甚至做到SSO。但是架构是没有止境的，在一定的时间框架下，要做到高效且安全的切换，这不失为一种好办法。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;首先我们需要看一下在JWTBearer中默认获取的token是在Authorization的头里，Bearer空格加上token。而如果有不规范的做法，可能是直接在headers里面加了一个token，里面有一个用我们自己的算法生成的token。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone wp-image-123 size-full&quot; src=&quot;http://www.jessetalk.cn/wp-content/uploads/2017/11/20171103103203.png&quot; alt=&quot;&quot; width=&quot;860&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;更改token的来源&lt;/h3&gt;
&lt;p&gt;JWTBearer authentication handler提供的Events中有一个OnMessageReceived委托可以让我们从另外的地方读取token。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
services.AddAuthentication(options =&amp;gt;&lt;span&gt;
{
    options.DefaultAuthenticateScheme &lt;/span&gt;=&lt;span&gt; JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme &lt;/span&gt;=&lt;span&gt; JwtBearerDefaults.AuthenticationScheme;
}).AddJwtBearer(o &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    o.Events &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtBearerEvents()
    {
        OnMessageReceived &lt;/span&gt;= context =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = context.Request.Headers[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            context.Token &lt;/span&gt;=&lt;span&gt; token.FirstOrDefault();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        },
    };
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;28&quot;&gt;
&lt;h3&gt;定制token的验证方式&lt;/h3&gt;
&lt;p&gt;从headers里面拿到token之后，下一步就是要把它的验证算法改成我们自己的。这一步可以通过自定义 ISecurityTokenValidator来实现 。我们在这个Validator里面，校验token生成一个ClaimsPrincipal，这个principal就会被赋值到 HttpContext.User上。&lt;/p&gt;
&lt;p&gt;同时我们还根据当前的token添加了一个Role Claim，它的值有user和admin。这个可能用来做基于角色的授权 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyTokenValidator : ISecurityTokenValidator
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ClaimsPrincipal ValidateToken(&lt;span&gt;string&lt;/span&gt; securityToken, TokenValidationParameters validationParameters, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; SecurityToken validatedToken)
    {
        validatedToken &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; identity = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClaimsIdentity(JwtBearerDefaults.AuthenticationScheme);
        identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jesse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        identity.AddClaim(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(ClaimsIdentity.DefaultRoleClaimType, securityToken == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jessetalk.cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; principal = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClaimsPrincipal(identity);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; principal;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意ClaimsIdentity的AuthenticationScheme一定要与我们在UseAuthentication时设置的名称一样。否则Identity.IsAuthenticated无法正确设置为true，我们的授权就没有办法完成。&lt;br/&gt;有了我们自定义的Validator之后，我们要对JwtBearer进行改造，去掉它默认的Validator，加上我们自己定义的这个。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
services.AddAuthentication(options =&amp;gt;&lt;span&gt;
{
    options.DefaultAuthenticateScheme &lt;/span&gt;=&lt;span&gt; JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme &lt;/span&gt;=&lt;span&gt; JwtBearerDefaults.AuthenticationScheme;
}).AddJwtBearer(o &lt;/span&gt;=&amp;gt;&lt;span&gt;
{

    o.SecurityTokenValidators.Clear();
    o.SecurityTokenValidators.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyTokenValidator());
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;开始进行授权&lt;/h2&gt;
&lt;p&gt;为了给大家演示上面的功能，我们新建两个Controller，一个是Admin，另一个是Home。两者都需要用户有token才能正常访问，但是对于Admin我们需要用户具有admin的role才可以，否则会被拒绝返回403。&lt;/p&gt;
&lt;p&gt;HomeController.cs&lt;/p&gt;
&lt;/div&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;12&quot;&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Authorize]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当Headers里面没有token 值的时候，API请求返回 401。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-126&quot; src=&quot;http://www.jessetalk.cn/wp-content/uploads/2017/11/home_no_token.png&quot; alt=&quot;&quot; width=&quot;912&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当Headers里面有token值时，API可以被正常访问。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-127&quot; src=&quot;http://www.jessetalk.cn/wp-content/uploads/2017/11/home_token_valid.png&quot; alt=&quot;&quot; width=&quot;902&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们又加了一个AdminController，不一样的是这次我们给Authorize加上了Role=”admin”，也就是只有拥有admin的Role才可以访问这个API。&lt;/p&gt;
&lt;/div&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[Authorize(Roles =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AdminController : Controller
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们用user的token访问时，我们会得到403。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-124&quot; src=&quot;http://www.jessetalk.cn/wp-content/uploads/2017/11/admin_token_invalid.png&quot; alt=&quot;&quot; width=&quot;902&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;8.971807628524&quot;&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;8&quot;&gt;
&lt;div data-author-name=&quot;Jesse&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;只有用admin的token，才能正常访问。&lt;/p&gt;
&lt;div data-author-name=&quot;Jesse&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-125&quot; src=&quot;http://www.jessetalk.cn/wp-content/uploads/2017/11/admin_token_valid.png&quot; alt=&quot;&quot; width=&quot;902&quot; height=&quot;225&quot;/&gt;&lt;/div&gt;

&lt;p&gt;以是就是基于JWT Authentication来定制的我们自己的认证方案的一个基本思路，主要是实现OnMessageReceived来改造token的来源，以及定义自己的 &lt;code&gt;ISecurityTokenValidator&lt;/code&gt; 来实现对token的验证。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div data-author-name=&quot;Jesse&quot;&gt;&lt;img class=&quot;alignnone size-medium wp-image-6&quot; src=&quot;http://www.jessetalk.cn/wp-content/uploads/2017/09/qrcode_for_gh_e59d348bb37b_430-1-300x300.jpg&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;300&quot;/&gt;&lt;/div&gt;
&lt;p&gt;本文首发于公众号jessetalk。 如需转载，请保留公众号二维码，谢谢。&lt;/p&gt;

&lt;h2 data-author-name=&quot;Jesse&quot;&gt;更多精彩文章：&lt;/h2&gt;





&lt;/div&gt;
</description>
<pubDate>Tue, 14 Nov 2017 00:55:00 +0000</pubDate>
<dc:creator>腾飞（Jesse)</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jesse2013/p/integrate-with-lagacy-auth.html</dc:identifier>
</item>
</channel>
</rss>