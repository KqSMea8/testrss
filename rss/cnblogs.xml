<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>网络爬虫之html2md - caryForJava</title>
<link>http://www.cnblogs.com/ccylovehs/p/9607702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ccylovehs/p/9607702.html</guid>
<description>&lt;p&gt;上周利用java爬取的网络文章，一直未能利用java实现html转化md，整整一周时间才得以解决。&lt;/p&gt;
&lt;p&gt;虽然本人的博客文章数量不多，但是绝不齿于手动转换，毕竟手动转换浪费时间，把那些时间用来做些别的也是好的。&lt;/p&gt;

&lt;h2&gt;Java实现&lt;/h2&gt;
&lt;p&gt;一开始的思路是想着用java来解析html，想着各种标签解析、符号解析、正则替换等等，决定在&lt;a title=&quot;github&quot; href=&quot;https://github.com&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;上搜索一波，果然是有前辈实现过，顿时欣喜若狂；&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;代码地址&quot; href=&quot;https://github.com/pnikosis/jHTML2Md&quot; target=&quot;_blank&quot;&gt;代码地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载后如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/996357/201809/996357-20180908001920536-747407913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可利用htmlToHexoMd方法测试运行&lt;/p&gt;
&lt;p&gt;可能作者是在linux服务器上定义的路径，我测试的时候一直提示路径问题，结果被迫更改转化的路径代码，&lt;/p&gt;
&lt;p&gt;调试运行后生成的md文件，本地启动hexo服务，上传刚刚生成md文件，网页浏览，不满，弃之。&lt;/p&gt;
&lt;h2&gt;NodeJS实现&lt;/h2&gt;
&lt;p&gt;为何突然会选择NodeJS来实现，刚好最近在看node书籍，里面有提到node爬虫，解析爬取的内容，书中提到利用&lt;a title=&quot;cheerio&quot; href=&quot;https://cnodejs.org/topic/5203a71844e76d216a727d2e&quot; target=&quot;_blank&quot;&gt;cheerio&lt;/a&gt;模块，遂果断浏览其api文档，cheerio其实就是jquery的翻版，这下可方便了，心中大喜。&lt;/p&gt;

&lt;p&gt;实现单个转化&lt;/p&gt;
&lt;p&gt;自定义解析&lt;/p&gt;
&lt;p&gt;实现批量转化&lt;/p&gt;

&lt;p&gt;自定义解析是比较头疼的事情，必须要分析需要转化的html的格式，需要读取的内容，本人对h1,h2,h3,div,img,a标签做了处理，可自行扩展&lt;/p&gt;
&lt;p&gt;html解析代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　if&lt;/span&gt;('p' ===&lt;span&gt; name){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e_children.type === 'text'&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e.children.length &amp;gt; 1&lt;span&gt;){
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0,c_len=e.children.length;j&amp;lt;c_len;j++&lt;span&gt;){
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e.children[j]['name'] === 'a') writeData = writeData + '('+e.children[j].attribs.href + ')\r\n'&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(e.children[j]['type'] === 'text') writeData = writeData + e.children[j].data + '\r\n'&lt;span&gt;;
                        }
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; writeData = writeData + e.children[0].data + '\r\n'&lt;span&gt;;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(e_children.name === 'img') writeData = writeData + '![Image]('+e.children[0].attribs.src + ')\r\n'&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;('div' ===&lt;span&gt; name){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; codes = $('#cnblogs_post_body .cnblogs_code pre').eq(code_idx++&lt;span&gt;).text();
                codes &lt;/span&gt;= codes.replace(/^(\s*)\d+/gm, ' '&lt;span&gt;);
                writeData &lt;/span&gt;= writeData + '```bash\r\n' + codes + '\r\n```\r\n'&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;('h1' === name) writeData = writeData + '# ' + e_children.data + '\r\n'&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;('h2' === name) writeData = writeData + '## ' + e_children.data + '\r\n'&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;('h3' === name) writeData = writeData + '### ' + e_children.data + '\r\n';
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整代码请移步至本人的&lt;a title=&quot;cheerio实现html2md&quot; href=&quot;https://github.com/chenchangyuan/html2md&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;，如果此文章对您有用请不吝star&lt;/p&gt;

</description>
<pubDate>Fri, 07 Sep 2018 16:50:00 +0000</pubDate>
<dc:creator>caryForJava</dc:creator>
<og:description>前言 上周利用java爬取的网络文章，一直未能利用java实现html转化md，整整一周时间才得以解决。 虽然本人的博客文章数量不多，但是绝不齿于手动转换，毕竟手动转换浪费时间，把那些时间用来做些别的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ccylovehs/p/9607702.html</dc:identifier>
</item>
<item>
<title>凸优化基础 - xinet</title>
<link>http://www.cnblogs.com/q735613050/p/9495428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/q735613050/p/9495428.html</guid>
<description>&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;
&lt;p&gt;无论做任何事情, 人们总是希望以最小的代价获取最大的利益, 力求最好! 为此, 人们发明各式各样的数学工具: 导数,积分等. 现代优化理论大都来源于处理多元问题时导致的复杂性, 它有三个重要的基础:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;矩阵理论: 矩阵是描述多元问题的最基本的工具, 为多元问题分析和求解提供了基本的数据结构.&lt;/li&gt;
&lt;li&gt;数值分析: 导数和微分为多元问题分析和求解提供了基本的数学方法.&lt;/li&gt;
&lt;li&gt;计算机: 为多元问题分析和求解提供了基本的实践工具.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由此, 一个最优化问题需要我们同时具备三种基本的能力: &lt;strong&gt;数学建模、公式推导、算法设计&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;最优化的数学描述&quot;&gt;最优化的数学描述&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \min_{x\in \mathbb{R}^n}\; &amp;amp; f(x) &amp;amp;&amp;amp; (\text{等价于 } \max_{x\in \mathbb{R}^n} -f(x))\\ \text{s.t. } &amp;amp; \begin{cases} h_i(x) = 0\\ g_j(x) \leq 0 \end{cases} \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 被称为&lt;strong&gt;决策变量&lt;/strong&gt;或问题的解&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{s.t.}\)&lt;/span&gt; 为英文 subject to 的缩写, 表示受制于&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 称为目标函数或代价函数 (Cost Function)&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt; 为等式约束, &lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt; 为不等式约束&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外, 最优化问题中的无约束问题可以描述为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \operatorname*{\arg \max}_x\, f(x), (\Leftrightarrow \operatorname*{\arg \max}_x\, -f(x)) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\arg\max\)&lt;/span&gt; 符号是指求解当函数 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 达到最大值 (或最小值) 时 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的取值.&lt;/p&gt;
&lt;p&gt;根据目标函数与约束函数的不同形式，可以把最优化问题分为不同的类型:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt; 均为线性函数，就称为&lt;strong&gt;线性规划&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;若任意其中一个是非线性函数, 则就称为&lt;strong&gt;非线性规划&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(g(x)\)&lt;/span&gt; 均为凸函数，就称为&lt;strong&gt;凸优化&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;若目标函数为二次函数 (如二次型), 约束全为线性函数, 就称为&lt;strong&gt;二次规划&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;若目标函数为向量函数, 则称为&lt;strong&gt;多目标规划&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;其他。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;凸集与分离定理&quot;&gt;凸集与分离定理&lt;/h2&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 是线性空间 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 中的子集, &lt;span class=&quot;math inline&quot;&gt;\(x, y \in X\)&lt;/span&gt;, 集合 &lt;span class=&quot;math inline&quot;&gt;\(\{\lambda x + (1- \lambda y: 0 \leq \lambda \leq 1\}\)&lt;/span&gt; 称为联结 &lt;span class=&quot;math inline&quot;&gt;\(x,y\)&lt;/span&gt; 两点的&lt;strong&gt;线段&lt;/strong&gt;, 记作 &lt;span class=&quot;math inline&quot;&gt;\([x,y]\)&lt;/span&gt;. 若对 &lt;span class=&quot;math inline&quot;&gt;\(\forall x,y \in A, [x,y] \in A\)&lt;/span&gt;, 则称 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 中的&lt;strong&gt;凸集&lt;/strong&gt;, 而集 &lt;span class=&quot;math inline&quot;&gt;\(\{x = \displaystyle\sum_{k=1}^n \lambda_kx_k: \lambda_k \geq 0, \displaystyle\sum_{k=1}^n \lambda_k = 1\}\)&lt;/span&gt; 称为 &lt;span class=&quot;math inline&quot;&gt;\(x_1,x_2,\cdots, x_n\)&lt;/span&gt; 的&lt;strong&gt;凸组合&lt;/strong&gt;. (易推知, &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 的线性子空间是凸集.)&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(A_{\alpha} (\alpha \in I)\)&lt;/span&gt; 为凸集, 则 &lt;span class=&quot;math inline&quot;&gt;\(\underset{\alpha \in I}\cap A_{\alpha}\)&lt;/span&gt; 仍为凸集, 设 &lt;span class=&quot;math inline&quot;&gt;\(A_{\alpha}\)&lt;/span&gt; 是包含 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 的所有凸集, 则 &lt;span class=&quot;math inline&quot;&gt;\(\underset{\alpha \in I}\cap A_{\alpha}\)&lt;/span&gt; 称为由 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 生成的凸集, 或集 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 的&lt;strong&gt;凸包&lt;/strong&gt;, 记作 &lt;span class=&quot;math inline&quot;&gt;\(\text{co} (A)\)&lt;/span&gt;, 它是包含 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 的最小凸集.&lt;/p&gt;
&lt;p&gt;集 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 的&lt;strong&gt;核&lt;/strong&gt;定义为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ A^{\circ} = \{x: \forall y \in X, \exists \delta = \delta(y)&amp;gt;0, \,\text{s.t. } |t| &amp;gt; δ, x+ty \in A \} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 是凸集, 且 &lt;span class=&quot;math inline&quot;&gt;\(A^{\circ} \neq ∅ ,\)&lt;/span&gt; 则称 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 为&lt;strong&gt;凸体&lt;/strong&gt;. 在赋范线性空间 &lt;span class=&quot;math inline&quot;&gt;\((X, ||\cdot ||)\)&lt;/span&gt; 中, 凸体 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 可定义为&lt;br/&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(∀ x,y \in A, x \neq y, ||x|| = ||y||,\)&lt;/span&gt; 则 &lt;span class=&quot;math inline&quot;&gt;\(||x+y|| &amp;lt; ||x|| + ||y||.\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;凸集的几何意义&quot;&gt;凸集的几何意义&lt;/h3&gt;
&lt;p&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(x,y \in S(0, r)(\text{球面})(||x||=||y||=r),\)&lt;/span&gt; 则联结 &lt;span class=&quot;math inline&quot;&gt;\(x,y\)&lt;/span&gt; 线段的中点 &lt;span class=&quot;math inline&quot;&gt;\((x+y)/2 \in B(0,r)\)&lt;/span&gt;(球体). 即若 &lt;span class=&quot;math inline&quot;&gt;\(x,y\)&lt;/span&gt; 在同一球面上, 则线段 &lt;span class=&quot;math inline&quot;&gt;\([x,y]\)&lt;/span&gt; 的中点就位于该球体的内部.&lt;/p&gt;
&lt;h3 id=&quot;超平面&quot;&gt;超平面&lt;/h3&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 为实数域 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb{R}\)&lt;/span&gt; 上的线性空间, &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 上的实值泛函, 则&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L_f (\alpha) = \{x\in X: f(x) = \alpha, \alpha \in \mathbb{R} \} \]&lt;/span&gt;&lt;br/&gt;称为 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 中的&lt;strong&gt;超平面&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&quot;支撑超平面&quot;&gt;支撑超平面&lt;/h3&gt;
&lt;p&gt;参考: &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Supporting_hyperplane&quot;&gt;支撑超平面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 是&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E6%8B%93%E6%92%B2%E5%90%91%E9%87%8F%E7%A9%BA%E9%96%93&quot;&gt;拓扑向量空间&lt;/a&gt; &lt;span class=&quot;math inline&quot;&gt;\(X=ℝ^n\)&lt;/span&gt; 上的一个凸集, 且 &lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 的边界上的一个点, 则存在一个包含点 &lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt; 的&lt;strong&gt;支撑超平面&lt;/strong&gt;. 若 &lt;span class=&quot;math inline&quot;&gt;\(x^* \in X^* \backslash \{0\}\)&lt;/span&gt; 其中 &lt;span class=&quot;math inline&quot;&gt;\(X^*\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 的对偶空间(dual space), &lt;span class=&quot;math inline&quot;&gt;\(x^*\)&lt;/span&gt; 是非零线性泛函, 这样, 对于所有的 &lt;span class=&quot;math inline&quot;&gt;\(x\in S\)&lt;/span&gt;, 有 &lt;span class=&quot;math inline&quot;&gt;\(x^*\left(x_0\right) \geq x^*(x)\)&lt;/span&gt;, 则&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ H = \{x \in X: x^*(x) = x^*\left(x_0\right)\} \]&lt;/span&gt;&lt;br/&gt;被定义为支撑超平面 (Supporting hyperplane).&lt;/p&gt;
&lt;h3 id=&quot;凸集分离定理&quot;&gt;凸集分离定理&lt;/h3&gt;
&lt;p&gt;参考: &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyperplane_separation_theorem&quot;&gt;Hyperplane separation theorem&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hyperplane separation theorem: 有 &lt;span class=&quot;math inline&quot;&gt;\(ℝ^n\)&lt;/span&gt; 中两个非空的 凸集 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;. 存在非零向量 &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; 和实数 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;, 使得&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\langle x, v \rangle \ge c \, \text{ 和 } \langle y, v \rangle \le c\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(∀ x \in A, y \in B\)&lt;/span&gt;, 则称超平面 &lt;span class=&quot;math inline&quot;&gt;\(\langle x, \cdot \rangle = c\)&lt;/span&gt; 分离(disjoint) &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;凸集分离定理的意义在于, 它为分类提供了理论上的开端. 在机器学习的分类问题中, 我们可以把带有类别标签的训练集看作不同的凸集, 而分隔它们的超平面就是&lt;strong&gt;分类器&lt;/strong&gt;. 我们的目标是根据这些训练集的特性, 找到一个分类算法, 通过学习或训练计算出这些凸集的超平面, 这样就达到了分类的目的.&lt;/p&gt;
&lt;p&gt;大多数传统的最优化理论和算法都只能保证找到满意解 (局部最优解, 见 &lt;a href=&quot;https://yq.aliyun.com/articles/626152?spm=a2c4e.11155435.0.0.107b3312kdgA1y&quot;&gt;凸函数相关&lt;/a&gt;), 为此, 人们尽可能的使用凸函数作为优化问题的目标函数. 对于那些无法转换为凸函数的优化问题, 只有通过穷举法来计算函数的所有值 (如果可能) 来找到全局最优解. 当然针对一些特定的问题可以通过, 诸如模拟退火法、隐马尔科夫链算法等随机优化方法来寻找最优解.&lt;/p&gt;
&lt;h2 id=&quot;计算复杂性与-np-问题&quot;&gt;计算复杂性与 NP 问题&lt;/h2&gt;
&lt;p&gt;衡量算法的两个重要指标: 时间复杂度与空间复杂度.&lt;/p&gt;
&lt;p&gt;一般地, 如果不考虑算法的优劣 (最优化算法), 一个算法执行过程所占用的资源越多, 则说明该算法要解决的问题的复杂性越高.&lt;/p&gt;
&lt;p&gt;在各类算法理论中, 通常将在多项式时间内即可解决的问题看作易解问题, 需要指数时间才可解决的问题看作是难解问题. 因而, 当前算法研究的一个重要任务是如何将指数时间算法变换为多项式算法？&lt;/p&gt;
&lt;p&gt;除了问题规模和运算时间的比较之外, 衡量一个算法还需要考虑&lt;strong&gt;确定性&lt;/strong&gt;和&lt;strong&gt;非确定性&lt;/strong&gt;的概念. 下面先引入&lt;strong&gt;自动机模型&lt;/strong&gt;, 或简称为&lt;strong&gt;自动机&lt;/strong&gt; (Automata Machine) 或机 (Machine), 实际上常指一种基于状态变化进行迭代的算法 (如玻耳兹曼机 (Boltzman) 和支持向量机). 在算法领域常把这类算法看作是一个机器.&lt;/p&gt;
&lt;p&gt;所谓确定性是指针对各种自动机模型, 根据当时的状态和输入, 若自动机的状态转移是唯一确定的, 则称&lt;strong&gt;确定性&lt;/strong&gt;; 在每一时刻, 若自动机有多个状态可供选择, 并尝试执行每个可选择的状态时, 则称为&lt;strong&gt;非确定性&lt;/strong&gt;. 通俗地说, 确定性就是程序在每个运行时 (自动机状态转移时) 产生下一步的结果是唯一的, 因此返回的结果也是唯一的. 而非确定性就是在每个运行时执行路径是并行的 (随机的): 所有路径都有可能返回结果, 也可能只有部分返回结果, 也可能不返回结果, 但只要有一个路径能够返回结果, 那么算法就会结束.&lt;/p&gt;
&lt;p&gt;在求解优化问题时, 非确定性算法可能会陷入局部最优, 因为所有并行的路径中某个执行路径运行达到最优, 算法就会结束, 但此时返回的不一定是全局最优解.&lt;/p&gt;
&lt;p&gt;下面我们便可以定义问题的计算复杂度了.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 类问题&lt;/strong&gt;就是指能够以多项式时间的确定性算法来对问题进行判定或求解, 实现它的算法在每个运行时的状态都是唯一的, 最终一定能够确定唯一的结果——最优解的.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(NP\)&lt;/span&gt; 类问题&lt;/strong&gt;就是指可以用多项式时间的非确定性算法来对问题进行判定或求解.
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(NP\)&lt;/span&gt; 完全问题&lt;/strong&gt;是 NP 类问题中最难的问题, 其中任何一个问题至今都没有找到多项式时间的算法.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多参考: &lt;a href=&quot;https://en.wikipedia.org/wiki/P_versus_NP_problem&quot;&gt;P versus NP problem&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细内容见: &lt;a href=&quot;https://www.imooc.com/article/75121&quot;&gt;图片: 凸优化基础&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/dbfbdc9fb668&quot;&gt;凸优化关键点&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 16:22:00 +0000</pubDate>
<dc:creator>xinet</dc:creator>
<og:description>概要 无论做任何事情, 人们总是希望以最小的代价获取最大的利益, 力求最好! 为此, 人们发明各式各样的数学工具: 导数,积分等. 现代优化理论大都来源于处理多元问题时导致的复杂性, 它有三个重要的基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/q735613050/p/9495428.html</dc:identifier>
</item>
<item>
<title>Nancy in .NET Core学习笔记 - 路由 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9607652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9607652.html</guid>
<description>&lt;blockquote readability=&quot;5.0057142857143&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/9593600.html&quot;&gt;前文中&lt;/a&gt;，我介绍了Nancy的来源和优点，并创建了一个&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/9593600.html&quot;&gt;简单的Nancy应用&lt;/a&gt;，在网页中输出了一个&quot;Hello World&quot;，本篇我来总结一下Nancy中的路由&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nancy中的路由是定义在每个Module的构造函数中的。&lt;br/&gt;为了创建一个路由，你需要定义如下4个部分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Http请求的方法(Method)&lt;/li&gt;
&lt;li&gt;路由模板(Pattern)&lt;/li&gt;
&lt;li&gt;处理对应路由模板请求的响应方法(Action)&lt;/li&gt;
&lt;li&gt;条件约束(Condition)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/9593600.html&quot;&gt;前篇&lt;/a&gt;的代码为例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class HelloModule : NancyModule
    {
        public HelloModule()
        {
            Get(&quot;/&quot;, p =&amp;gt; &quot;Hello World&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前构造中定义了的一个路由&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它的Http请求方法是GET&lt;/li&gt;
&lt;li&gt;它的路由模板是&quot;/&quot;, 即网站根目录&lt;/li&gt;
&lt;li&gt;它的响应结果是输出一个&quot;Hello World&quot;&lt;/li&gt;
&lt;li&gt;这里它没有指定任何的条件约束&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;nancy中支持的http请求方法http-method&quot;&gt;Nancy中支持的Http请求方法(Http Method)&lt;/h2&gt;
&lt;p&gt;Nancy中支持&lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;OPTIONS&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;和&lt;code&gt;PATCH&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;nancy中的路由模板pattern&quot;&gt;Nancy中的路由模板(Pattern)&lt;/h2&gt;
&lt;p&gt;下面我们介绍一下Nancy中默认提供的几种路由片段和约束条件。&lt;/p&gt;
&lt;h3 id=&quot;nancy中的几种路由片段&quot;&gt;Nancy中的几种路由片段&lt;/h3&gt;
&lt;p&gt;Nancy中默认支持一下几种路由片段。&lt;/p&gt;
&lt;h4 id=&quot;纯文字片段literal-segment&quot;&gt;纯文字片段(Literal Segment)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;例: /products/cocacola&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class ProductModule : NancyModule
    {
        public ProductModule()
        {
            Get(&quot;/products/cocacola&quot;, p =&amp;gt; &quot;Coca Cola&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908000729662-711102461.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;含变量的片段capture-segment&quot;&gt;含变量的片段(Capture Segment)&lt;/h4&gt;
&lt;p&gt;Nancy中Get方法的第二个参数是一个Func委托, &lt;code&gt;Func&amp;lt;dynamic, object&amp;gt;&lt;/code&gt;, 该委托的指向方法的第一个参数是&lt;code&gt;dynamic&lt;/code&gt;类型的变量, 我们可以从该变量上获取Url中的可变参数的值。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;例: /products/{productName}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class ProductModule : NancyModule
    {
        public ProductModule()
        {
            Get(&quot;/products/{productName}&quot;, p =&amp;gt; p.productName);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908000744254-761214726.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;含可空变量的片段capture-segment---optional&quot;&gt;含可空变量的片段(Capture Segment - Optional)&lt;/h4&gt;
&lt;p&gt;Nancy中的Url参数也支持可空类型, 只需要在参数后面加一个问号。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;例：/products/{productName?}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class ProductModule : NancyModule
    {
        public ProductModule()
        {
            Get(&quot;/products/{productName?}&quot;, p =&amp;gt; p.productName == null ? &quot;Missing the name&quot; : p.productName);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908000829190-2096982664.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Nancy中对于可空类型的参数也可以设置默认值, 默认值可以放在问号的后面。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;例：/products/{productName?defaultName}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class ProductModule : NancyModule
    {
        public ProductModule()
        {
            Get(&quot;/products/{productName?defaultName}&quot;, p =&amp;gt; p.productName);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908000839818-920331928.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;正则片段regex-segment&quot;&gt;正则片段(RegEx Segment)&lt;/h4&gt;
&lt;p&gt;Nancy的路由模板中也可以使用正则表达式。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;例：/products/(?[\d]{2,})&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class ProductModule : NancyModule
    {
        public ProductModule()
        {
            Get(@&quot;/products/(?&amp;lt;productId&amp;gt;[\d]{2,})&quot;, p =&amp;gt; &quot;Your product id is &quot; + p.productId);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个正则的意思是只允许2位数以上的整数。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908000851705-1424937805.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;贪婪片段greedy-segment&quot;&gt;贪婪片段(Greedy Segment)&lt;/h4&gt;
&lt;p&gt;Nancy中可以在变量尾部追加一个星号，表示匹配从当前位置到Url结尾的所有字符串。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;例：/products/{productName*}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class ProductModule : NancyModule
    {
        public ProductModule()
        {
            Get(&quot;/products/{productName*}&quot;, p =&amp;gt; p.productName);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908000901562-1453397170.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们把星号去掉看一下区别。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;例：/products/{productName}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908000910362-320060814.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不能匹配到任何路由模板。&lt;/p&gt;
&lt;h4 id=&quot;优先级别&quot;&gt;优先级别&lt;/h4&gt;
&lt;p&gt;在ASP.NET MVC中我们会使用MapRoute方法定义的路由模板，当有请求进入的时候，MVC Handler会根据我们定义的路由模板顺序来依次匹配, 如果匹配成功就会进入对应的Action方法处理请求。&lt;/p&gt;
&lt;p&gt;那么在Nancy这种无配置的框架中如何确定模板的匹配顺序呢?&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在Nancy中，对于默认提供的几种路由片段类型，Nancy都提供了一个模板分数(Pattern Scoring)，模板分数越高的越优先匹配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nancy中几种基本模板类型的分数&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;纯文字片段(Literal Segment)&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;含变量的片段(Capture Segment)&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;含可空变量的片段(Capture Segment - Optional)&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;正则片段(RegEx Segment)&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;贪婪正则片段(Greedy RegEx Segment)&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;多变量片段(Multiple Captures Segment)&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;贪婪片段(Greedy Segment)&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;例：当前有2个路由模板&quot;/products/{productName}&quot;和&quot;/products/coffee&quot;，我们请求Url为/products/coffee时，结果如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class ProductModule : NancyModule
    {
        public ProductModule()
        {
            Get(&quot;/products/{productName}&quot;, p =&amp;gt; p.productName);
            Get(&quot;/products/coffee&quot;, p =&amp;gt; &quot;Hello Coffee.&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908000923914-772810032.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里是因为纯文字片段的优先级别比含变量的片段高，所以优先处理了当前请求。&lt;/p&gt;
&lt;h3 id=&quot;路由片段参数类型约束&quot;&gt;路由片段参数类型约束&lt;/h3&gt;
&lt;p&gt;Nancy还可以在路由模板中对参数类型进行约束。约束的格式是&quot;{变量名: 约束类型}&quot;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;例： &quot;/products/{productId:int}&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class ProductModule : NancyModule
    {
        public ProductModule()
        {
            Get(&quot;/products/{productId:int}&quot;, p =&amp;gt; &quot;Product id is &quot; + p.productId);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当约束条件匹配时，请求成功。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908000932774-1227045618.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当约束条件不匹配时，请求失败。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908000941770-1990966985.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;常规约束&quot;&gt;常规约束&lt;/h4&gt;
&lt;p&gt;Nancy中提供如下的常规约束类型。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;只允许Int32的数字&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;只允许Int64的数字&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;decimal&lt;/td&gt;
&lt;td&gt;只允许小数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;guid&lt;/td&gt;
&lt;td&gt;只允许Guid&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;只允许true/false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;alpha&lt;/td&gt;
&lt;td&gt;只允许字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;只允许时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;datetime(format)&lt;/td&gt;
&lt;td&gt;只允许特定格式时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;min(mininum)&lt;/td&gt;
&lt;td&gt;允许的最小整数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;max(maxinum)&lt;/td&gt;
&lt;td&gt;允许的最大整数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;range(mininum, maxinum)&lt;/td&gt;
&lt;td&gt;允许的整数值范围&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;minlength(length)&lt;/td&gt;
&lt;td&gt;允许的字符串最小长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;maxlength(length)&lt;/td&gt;
&lt;td&gt;允许的字符串最大长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;length(length)&lt;/td&gt;
&lt;td&gt;允许的字符串长度范围&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;version&lt;/td&gt;
&lt;td&gt;只允许版本号，例1.0.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;自定义约束&quot;&gt;自定义约束&lt;/h4&gt;
&lt;p&gt;Nancy中可以通过继承&lt;code&gt;RouteSegmentConstraintBase&lt;/code&gt; 和&lt;code&gt;ParameterizedRouteSegmentConstraintBase&lt;/code&gt;来自定义约束条件。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;RouteSegmentConstraintBase - 不带参数约束条件的积累&lt;br/&gt;ParameterizedRouteSegmentConstraintBase - 带参数约束条件的基类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们自己创建一个email约束。&lt;br/&gt;首先我们创建一个&lt;code&gt;EmailRouteSegmentConstraint&lt;/code&gt;类，并继承&lt;code&gt;RouteSegmentConstraintBase&lt;/code&gt;类,其代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class EmailRouteSegmentConstraint : RouteSegmentConstraintBase&amp;lt;string&amp;gt;
    {
        public override string Name
        {
            get { return &quot;email&quot;; }
        }

        protected override bool TryMatch(string constraint, string segment, out string matchedValue)
        {
            if (segment.Contains(&quot;@&quot;))
            {
                matchedValue = segment;
                return true;
            }

            matchedValue = null;
            return false;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中TryMatch方法表示尝试判断参数是否匹配，如果返回true就是匹配成功，false就是匹配失败。Name属性表示了当前约束的名称。&lt;/p&gt;
&lt;p&gt;我们创建一个新的&lt;code&gt;StaffModule&lt;/code&gt;类，其代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class StaffModule : NancyModule
    {
        public StaffModule()
        {
            Get(&quot;/staff/{email:email}&quot;, p =&amp;gt; &quot;Your email is &quot; + p.email);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们启动项目，在浏览器中输入/staff/lamondlu@qq.com，请求被正确处理。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908000957442-938339308.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时如果我们在浏览器中输入/staff/lamondlu, 系统会返回404。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908001007250-1784294209.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;nancy中的条件约束condition&quot;&gt;Nancy中的条件约束(Condition)&lt;/h2&gt;
&lt;p&gt;Nancy中还可以实现针对请求的一些条件约束。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;例如：当提交的Form中包含email字段，且email字段的值为lamondlu@qq.com时才处理当前请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class StaffModule : NancyModule
    {
        public StaffModule()
        {
            Post(&quot;/staff&quot;, p =&amp;gt; &quot;Submited&quot;, p =&amp;gt; p.Request.Form.email == &quot;lamondlu@qq.com&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我加入了第三个参数condition, condition是一个&lt;code&gt;Func&amp;lt;NancyContext, bool&amp;gt;&lt;/code&gt;类型的委托, 从NancyContext中我们可以获得请求的所有信息。这里我从请求的Form中读取的email字段，如果email字段的值是lamondlu@qq.com, Nancy将返回一个Submited文本。&lt;/p&gt;
&lt;p&gt;下面我们使用Postman来测试一下。&lt;br/&gt;首先我们在Form中不加入任何字段，请求结果如下。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908001017714-577655396.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们在Form中加入email字段，且值为lamondlu@qq.com, 请求结果如下。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65831/201809/65831-20180908001025946-65525358.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求被正确处理了。&lt;/p&gt;
&lt;p&gt;以上就是Nancy路由部分的全部内容，有兴趣的同学可以加我的QQ：309728709一起研究, 下一次我将分享Nancy中的视图引擎。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/lwqlun/Route.zip&quot;&gt;附源代码&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/&quot; rel=&quot;license&quot;&gt;&lt;img src=&quot;https://i.creativecommons.org/l/by/4.0/88x31.png&quot; alt=&quot;知识共享许可协议&quot;/&gt;&lt;/a&gt;&lt;br/&gt;作者：Lamond Lu&lt;br/&gt;出处：https://www.cnblogs.com/lwqlun/p/9607652.html&lt;br/&gt;本站使用「&lt;a href=&quot;https://creativecommons.org/licenses/by/4.0&quot; target=&quot;_blank&quot;&gt;署名 4.0 国际&lt;/a&gt;」创作共享协议，转载请在文章明显位置注明作者及出处。</description>
<pubDate>Fri, 07 Sep 2018 16:19:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9607652.html</dc:identifier>
</item>
<item>
<title>Scala的控制结构和函数 - codegeekgao</title>
<link>http://www.cnblogs.com/codegeekgao/p/9607608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codegeekgao/p/9607608.html</guid>
<description>&lt;h2 id=&quot;控制结构和函数&quot;&gt;控制结构和函数&lt;/h2&gt;
&lt;p&gt;先看以下简单的一个条件表达式的demo&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;object TestConditional {

  def main(args: Array[String]): Unit = {
    // scala的if判断表达式
    var x = 1
    if (x &amp;gt; 0) x = 10 else x = 20
    println(x)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Scala的if/else语法结构与java一样，如以上代码一样，需要注意的是当else部分缺失了比如：if(x&amp;gt;0) 1,这个if语句没有输出值，但是在Scala中，每个表达式都应该有值，这个问题可以引入一个Unit类，写做（）。不带else的这个if语句等同于 if (x&amp;gt;0) 1 else () Scala中没有switch语句，只需if即可解决所有。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;语句终止&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;在java和C++中，每一个语句都以分号结束，而在Scala中和JavaScript类似--行尾的位置不需要分号，因为Scala编译器能够从上下文明确判断出是语句的终止，但是若要在单行中写下多个语句，需要用分号隔开,例如下面的表达式需要分号隔开
if (n &amp;gt; 0) {r = r * n; n-=1}
若是在写较长的语句，需要两行来写，需要告诉编译器不是语句结尾，例子如下：
x = y + (v - m) * d + // +告诉编译器不是结尾
0.5 * （c - v） * t&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;块表达式和赋值&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;在java中，块语句是一个包含与{}中的语句序列，在Scala中{}包含一系列表达式，在Scala中，赋值动作本身没有值，它们是Unit类型，相当于java中的void，而这个类型只有一个值，写做()
{r = r * n; n-=1}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;输入和输出&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;打印一个值可以使用print或者println函数，
例如: println(&quot;x=&quot;+&quot;10&quot;),另外还有一个带有C风格格式化的字符串printf函数例如：
printf(&quot;hello, %S! welcome to Scala world.\n&quot;,&quot;michael&quot;)
也可以使用readLine函数从控制台读取一行输入，读取数字，Boolean或者是字符，可以永readInt，readDouble，readByte，readShort，readLong，readFloat，readBoolean或者readChar。
// 使用readLine
val name=readLine(&quot;your name:&quot;)
print(&quot;your age&quot;)
val age = readInt()
printf(&quot;hello,%s! you have %d year work experience&quot;,name,age)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Scala中没有与for（初始化变量值；变量布尔表达式；变量更新），Scala中有两个选择：一个是使用while循环，而是使用以下for语句&lt;br/&gt;for (i&amp;lt;- 表达式)让变量i遍历&amp;lt;-右边的表达式的所有值，对于Scala集合比如Range而言，会取到集合中的每个值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Scala中没有提供break或者continue语句退出循环，一般可以有以下三种方法跳出循环：
1. 使用Boolean型的控制变量
2. 使用嵌套函数---使用return
3. 使用breaks对象中的break方法
import scala.util.control.Breaks._
breakable {
    for(...) {
    // 退出循环
        if(...) break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;for循环推导式&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Scala中的for循环比java要丰富的多，下面介绍其高级特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;    // 多个生成器
    for (i &amp;lt;- 1 to 3; j &amp;lt;- 1 to 3) print((10 * i + j) + &quot; &quot;)
    println()
    // 守卫生成器，if前没有分号
    for (i &amp;lt;- 1 to 3; j &amp;lt;- 1 to 3 if i != j) print((10 * i + j) + &quot; &quot;)
    // 可以定义变量，在循环中引入
    println()
    for (i &amp;lt;- 1 to 3; from = 4 - i; j &amp;lt;- from to 3) print((10 * i + j) + &quot; &quot;)
    
 for循环中的 yield 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合。Scala中for循环是有返回值的。如果被循环的是Map，返回的就是Map，被循环的是List，返回的就是List，以此类推。

scala&amp;gt; for (i &amp;lt;- 1 to 5) yield i
res10: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3, 4, 5) &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Scala中定义函数需要定义函数的名称、参数和函数体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt; def abs (x: Double) = if (x &amp;gt;= 0) x else -x
 
 必须给出所有参数的类型，只要不是递归就不需指定返回类型。Scala会自动通过=符号右侧的表达式的类型推断出返回类型
 
// 递归函数，必须指定返回类型
def fac(n : Int) ：Int = if (n&amp;lt;=0) 1 else n* fac(n -1) &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;默认参数和带名参数&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;/**
 * 我们在调用某些函数无需显示给出所有的参数值，可以初始化给出默认值
 */
 def haha(str:String,left:String=&quot;[&quot;,right:String=&quot;]&quot;) = left + str +right&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可变参数&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// 传入的参数是单个参数
def sum(args : Int*)：Int = {
    var result = 0
    for (arg &amp;lt;- args) result += arg
    // 返回result
    result
}

// 计算1+2的值
val s1 = sum(1, 2)
// 用法是错误的，因为1 to 3 是一个整数区间不是单个整数
val s3 = sum (1 to 3)
// 计算1+2+3的值（解决区间问题）
val s2 = sum(1 to 3: _*)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;异常处理&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;Scala异常的工作机制和java或C++一样，当你抛出异常时：
throw new IllegalArgumentException(&quot;description for exception&quot;)
和java一样，抛出的对象必须是java.lang.Throwable的子类，不过没有编译时候的检查异常
try {
    process(new URL(&quot;http:wwww.baidu.com&quot;))
} catch {
    // 自定义异常描述
    case _:URLException =&amp;gt; println(&quot;bad url&quot;)
    // 使用默认异常信息
    case ex: IOException =&amp;gt; ex.printStackTrace()
}

使用try finally语句：
var in = new URL(&quot;http:www.baidu.com&quot;).openStream()
try {
    process(in)
} finally {
    in.close()
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 07 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>codegeekgao</dc:creator>
<og:description>控制结构和函数 先看以下简单的一个条件表达式的demo Scala的if/else语法结构与java一样，如以上代码一样，需要注意的是当else部分缺失了比如：if(x 0) 1,这个if语句没有输出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codegeekgao/p/9607608.html</dc:identifier>
</item>
<item>
<title>Spring Boot系列——如何集成Log4j2 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/spring-boot-log4j2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/spring-boot-log4j2.html</guid>
<description>&lt;p&gt;上篇《Spring Boot系列——日志配置》介绍了Spring Boot如何进行日志配置，日志系统用的是Spring Boot默认的LogBack。&lt;/p&gt;
&lt;p&gt;事实上，除了使用默认的LogBack，Spring Boot还可以使用Log4j、Log42等作为自己的日志系统。今天就那Log4j2来举例，说明Spring Boot是如何集成其他日志系统的。&lt;/p&gt;
&lt;h3 id=&quot;添加jar包依赖&quot;&gt;添加jar包依赖&lt;/h3&gt;
&lt;p&gt;上篇提到过，Spring Boot默认使用LogBack，但是我们没有看到显示依赖的jar包，其实是因为所在的jar包&lt;code&gt;spring-boot-starter-logging&lt;/code&gt;都是作为&lt;code&gt;spring-boot-starter-web&lt;/code&gt;或者&lt;code&gt;spring-boot-starter&lt;/code&gt;依赖的一部分。&lt;/p&gt;
&lt;p&gt;如果这里要使用Log4j2，需要从&lt;code&gt;spring-boot-starter-web&lt;/code&gt;中去掉&lt;code&gt;spring-boot-starter-logging&lt;/code&gt;依赖，同时显示声明使用Log4j2的依赖jar包，具体如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;exclusions&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-logging&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-log4j2&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里顺便插一句，上面的依赖中，我们看到并没有声明版本，这是因为我在项目的父级pom文件中引入了dependencyManagement。&lt;/p&gt;
&lt;p&gt;大致说下，我们常见的dependency标签是用来引入需要依赖的jar用的。而dependencyManagement并不能起到同样的作用，它的作用可以用来声明版本规范。当在父级pom声明某个版本的依赖时，如果子pom所在项目并没有用到的话，是不会依赖这个声明的jar包的，需要在子pom主动添加依赖才生效，这个父级pom中的dependencyManagement是用来做统一版本的。&lt;/p&gt;
&lt;p&gt;具体看rome项目中的父级pom文件配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.jackie&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;rome&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;rome&amp;lt;/name&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;

    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;springboot&amp;lt;/module&amp;gt;
        &amp;lt;module&amp;gt;wowjava&amp;lt;/module&amp;gt;
    &amp;lt;/modules&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;lombok.version&amp;gt;1.16.18&amp;lt;/lombok.version&amp;gt;
        &amp;lt;spring.boot.version&amp;gt;2.0.4.RELEASE&amp;lt;/spring.boot.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${lombok.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring.boot.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-log4j2&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring.boot.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;

            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
                &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
                &amp;lt;version&amp;gt;${spring.boot.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;

    &amp;lt;/dependencyManagement&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里放在denpendencyManagement中的denpendency都声明了版本，这样当子pom在继承这个父pom的时候，比如这里的&lt;code&gt;spring-boot-starter-log4j2&lt;/code&gt;就可以继承父pom中声明的&lt;code&gt;2.0.4.RELEASE&lt;/code&gt;，不需要再写version标签。这样做是方便项目的版本统一。&lt;/p&gt;
&lt;h3 id=&quot;添加配置文件log4j2.xml&quot;&gt;添加配置文件log4j2.xml&lt;/h3&gt;
&lt;p&gt;在resources目录下新建一个log4j2.xml文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;configuration&amp;gt;
    &amp;lt;Appenders&amp;gt;
        &amp;lt;Console name=&quot;CONSOLE&quot; target=&quot;SYSTEM_OUT&quot;&amp;gt;
            &amp;lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;[%-5p] %d %c - %m%n&quot; /&amp;gt;
        &amp;lt;/Console&amp;gt;

        &amp;lt;File name=&quot;File&quot; fileName=&quot;/Users/jackie/workspace/rome/springboot.log&quot;&amp;gt;
            &amp;lt;PatternLayout pattern=&quot;%m%n&quot; /&amp;gt;
        &amp;lt;/File&amp;gt;
    &amp;lt;/Appenders&amp;gt;

    &amp;lt;Loggers&amp;gt;
        &amp;lt;root level=&quot;info&quot;&amp;gt;
            &amp;lt;AppenderRef ref=&quot;CONSOLE&quot; /&amp;gt;
            &amp;lt;AppenderRef ref=&quot;File&quot; /&amp;gt;
        &amp;lt;/root&amp;gt;
    &amp;lt;/Loggers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：这里的xml标签和上篇介绍的差不多，都是定义了日志输出源以及日志格式的定义等，不在赘述。&lt;/p&gt;
&lt;p&gt;但是这样还不够，Spring Boot并不知道log4j2.xml是干嘛的，需要通过在application.properties文件中显示声明才行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
logging.config= classpath:log4j2.xml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行SpringBootDemoApplication&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180907232924693-1582485512.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如果我们注释掉application.properties中的&lt;code&gt;logging.config= classpath:log4j2.xml&lt;/code&gt;，运行SpringBootDemoApplication&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180907232939863-1929913745.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出没有建立关联，所以log4j2.xml的配置也没有生效，此时Spring Boot的启动日志没有打印到控制台上。&lt;/p&gt;
&lt;p&gt;注意，这里有个“潜规则”。如果想在application.properties中注释掉和配置文件的关系前提下仍然能读取到配置文件的信息，可以这样做&lt;/p&gt;
&lt;p&gt;将log4j2.xml重命名为log4j2-spring.xml，这样运行SpringBootDemoApplication也是可以正常按照配置打印日志信息的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201809/619240-20180907232950896-1258933773.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自定义日志配置&quot;&gt;自定义日志配置&lt;/h3&gt;
&lt;p&gt;根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Logback： logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Log4j： log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Log4j2： log4j2-spring.xml, log4j2.xml&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JDK (Java Util Logging)： logging.properties&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OK，Spring Boot有关日志配置的介绍就到此为止了，有问题下方留言一起讨论。&lt;/p&gt;
&lt;h3 id=&quot;项目代码地址&quot;&gt;项目代码地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DMinerJackie/rome&quot; class=&quot;uri&quot;&gt;https://github.com/DMinerJackie/rome&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请记住这个地址，后面可能很多文章的项目代码都会集中到这个项目。&lt;/p&gt;
&lt;p&gt;取名rome（罗马），源于谚语&lt;strong&gt;Rome was not built in one day&lt;/strong&gt;。翻译成中文就是我个人很喜欢的“不积跬步无以至千里，不积小流无以成江海”。&lt;/p&gt;
&lt;p&gt;没有哪一次commit能一步到位建成罗马，但是都是让现实越来越靠近梦想！&lt;/p&gt;
&lt;p&gt;项目的目录划分采用《没做过大项目，但我会建大项目》介绍的“大项目”结构，在每个module中都会有README.md，其主要记录了网上一些较好的参考资料以及在项目module主题遇到的问题，方便后续翻阅。&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 15:32:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>除了上篇的Spring Boot内置的LogBack日志系统，Spring Boot又是如何集成其他日志系统的，比如Log4j2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/spring-boot-log4j2.html</dc:identifier>
</item>
<item>
<title>springboot源码学习笔记之进入之前发生了啥 - 千里授渔</title>
<link>http://www.cnblogs.com/qlsy/p/9607550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qlsy/p/9607550.html</guid>
<description>&lt;table&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;人称:&lt;/td&gt;
&lt;td&gt;露哥&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;QQ:&lt;/td&gt;
&lt;td&gt;408365330&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td colspan=&quot;2&quot;&gt;N01.编程就是验证学习的最好方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td colspan=&quot;2&quot;&gt;N02.为了挣钱所以编程，为了挣大钱所以写好代码，为了写好代码所以学习&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td colspan=&quot;2&quot;&gt;N03.好好学习天天编程&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;
&lt;p&gt;虽然用springboot也有一段时间,但是之前也没怎么关注过springboot项目打包过程中发生了什么，启动过程细节是什么！&lt;br/&gt;直到最近在搞公司的私有化大平台时需要了解更多的本质上的东西才细细品味了一下springboot的源码，从起源开始……&lt;/p&gt;
&lt;h2 id=&quot;springboot-程序长啥样身材和脸蛋&quot;&gt;springboot 程序长啥样（身材和脸蛋）？&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableAutoConfiguration
public class EgojitApplication {
    public static void main(String[] args) {
        SpringApplication.run(EgojitApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我第一眼看到特别亲切，这就是一个main程序啊；然后再看一眼，好像比普通的main上面多了两个注解,总以为两眼就了解她，和普通的main也没什么不同么啊，其实只是了解了身材和脸蛋；需要三回眸免得错过什么精彩内容；然后我使用 &lt;strong&gt;spring-boot-maven-plugin&lt;/strong&gt; 进行打包；生成一个jar包；既然要深入了解她的“品质”啊，那就得由内而外；unzip 这个美丽的jar吧；&lt;/p&gt;
&lt;h2 id=&quot;springboot的jar包内在品质&quot;&gt;springboot的jar包内在（品质）&lt;/h2&gt;
&lt;h3 id=&quot;名词说明&quot;&gt;名词说明&lt;/h3&gt;
&lt;p&gt;我们这里把由 &lt;strong&gt;spring-boot-maven-plugin&lt;/strong&gt; maven插件打包的jar包称为“胖jar”或者“聚合jar”（不仅仅只有这一种打包胖jar的方式，我们约定胖jar就是spring-boot-maven-plugin插件打包的jar包，我喜欢约定）,把maven-jar-plugin 默认打包出来的jar包称为“瘦jar”或者“散jar”&lt;/p&gt;
&lt;h3 id=&quot;n01-有内涵&quot;&gt;N01 有内涵&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1309126/201809/1309126-20180907231906317-889177525.png&quot; alt=&quot;springboot的jar包 BOOT-INF&quot;/&gt;&lt;br/&gt;unzip后发现这个和普通的main程序jar包完全不同啊，包含BOOT-INF，META-INF,org三个目录；然后可以看见BOOT-INF/classes才是真正的classpath,而传统的jar包直接解压后就是classpath&lt;/p&gt;
&lt;h3 id=&quot;n02-有特色&quot;&gt;N02 有特色&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1309126/201809/1309126-20180907231952979-865934314.png&quot; alt=&quot;springboot的jar包 MAINFEST.MF&quot;/&gt;&lt;br/&gt;META-INF目录中我重点关注MANIFEST.INF文件，我看到了我不敢相信的一幕，她和普通main区别大大的，她可不是表面上看到的那样，入口main在JarLauncher中（记住它后面我们分析spring-boot-loader源码从它入手）；所以我推翻我之前的认知springboot的xxxApplicaion中的main不是普通的main。它只是一个被xxxApplicion调用的普通方法而已；和普通的MANIFEST.INF不同它还有一个Start-Class，不要怀疑这个就是我们写的xxxApplicaion; Spring-Boot-Classes指出了springboot的特殊class目录；Spring-Boot-Lib配置第三方依赖包目录&lt;/p&gt;
&lt;h3 id=&quot;n03-超仙&quot;&gt;N03 超仙&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1309126/201809/1309126-20180907232018946-1867373201.png&quot; alt=&quot;springboot的jar包&quot;/&gt;&lt;/p&gt;
&lt;p&gt;org目录有点神奇，出现了超自然现象啊，我的项目绝对没有org.springframework.boot包啊。它从哪里来的？我怀疑人生的打开项目依赖找了一遍，我确定它是超自然现象，好仙，不是我等凡人容易理解的；我想到既然我没干什么，那就绝对是打包干的，谁打包？？？？？&lt;br/&gt;&lt;strong&gt;spring-boot-maven-plugin&lt;/strong&gt; 对！就是它，被我逮到了；它把项目打包成我们看到的目录结构，同时把spring-boot-loader jar包中的class拷贝到项目中了；&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-loader-分析&quot;&gt;spring-boot-loader 分析&lt;/h2&gt;
&lt;p&gt;以下是JarLauncher执行流程分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1309126/201809/1309126-20180907232040887-629525085.png&quot; alt=&quot;JarLauncher执行流程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过源码分析流程可以知道spring-boot-load模块通过自定义jar包结构自定义类加载器优雅的实现了嵌套jar资源的加载，通过打包时候重新设置启动类和组织jar结构，通过运行时设置自定义加载器来实现嵌套jar资源加载；&lt;br/&gt;知道这些我们可以实现自己的JarLauncher实现Archive动态指定实现插件化；既然spring-boot-loader能指定lib以及class目录，那么我们也可以实现自己的JarLauncher合并更多的lib目录，实现外部扩展lib，再结合spring boot中的spring.factries的原理扫描注入代码；公司的私有化平台中的应用托管就是我在研究spring-boot-loader这种原理结合spring boot中的spring.factries的机制基础上实现的；改造了原来基于java的jagent方式。这种方案解决了很多问题；其中第三方springboot应用日志采集，性能监控，健康检查等等都可以基于这个机制去实现（了解这个原理多么重要）；更多的就涉密了……。哈哈……&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 15:25:00 +0000</pubDate>
<dc:creator>千里授渔</dc:creator>
<og:description>spring-boot-loader原理解析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qlsy/p/9607550.html</dc:identifier>
</item>
<item>
<title>Spring系列(二) Bean装配 - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/9607524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/9607524.html</guid>
<description>&lt;p&gt;创建应用对象之间协作关系的行为称为装配(wiring), 这也是DI的本质.&lt;/p&gt;
&lt;h2 id=&quot;spring中装配bean的方式&quot;&gt;Spring中装配Bean的方式&lt;/h2&gt;
&lt;p&gt;Spring提供了三种装配Bean的方式.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;隐式的Bean发现机制和自动装配&lt;/li&gt;
&lt;li&gt;Java Config&lt;/li&gt;
&lt;li&gt;Xml Config&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spring可以任意选择三种方式其中的一种或多种组合. 但建议尽量使用自动装配方式以避免产生繁杂的xml配置文件及java代码, 其次是使用类型安全的Java Config, 如果都满足不了需求则最后再考虑xml config.&lt;/p&gt;
&lt;h2 id=&quot;自动配置&quot;&gt;自动配置&lt;/h2&gt;
&lt;p&gt;借助于下面两个方面Spring可以实现自动化Bean配置.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;组件扫描(component scanning): 自动发现上下文种创建的bean&lt;/li&gt;
&lt;li&gt;自动专配(autowiring) 自动创建对象间依赖&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一. 组件扫描:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Component&lt;/code&gt; 注解标记的java类会作为组件类. 带参的&lt;code&gt;@Component(&quot;beanid&quot;)&lt;/code&gt;, 参数为bean的名称, 默认为首字母小写的类名. &lt;code&gt;@Component&lt;/code&gt; 等同 &lt;code&gt;@Named&lt;/code&gt; 注解;&lt;br/&gt;对应xml配置节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ComponentScan&lt;/code&gt; 用来启动组件扫描, 默认的扫描范围是该注解标记的类所在的包. 带参的 &lt;code&gt;@ComponentScan(basePackages={&quot;basePackage1&quot;,&quot;basePackage2&quot;})&lt;/code&gt; 可以指定扫描的包范围 ; 带参的 &lt;code&gt;@ComponentScan(basePackageClasses={ClassNameA.class,InterfaceB.class})&lt;/code&gt;这些类或接口所在的包将作为扫描的基础包范围, 相比指定字符串的基础包, 这种方式提供了类型安全性(重构友好的);&lt;br/&gt;对应的xml配置节点是&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二. 自动装配&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@AutoWired&lt;/code&gt; 提供了自动装配能力. 构造器注入和setter注入均可以使用该注解, 事实上它可以在任何方法上发挥作用.&lt;code&gt;@AutoWired(required=false)&lt;/code&gt; 设置为false在没有匹配到bean时不会抛出异常. &lt;code&gt;@AutoWired&lt;/code&gt;等同于&lt;code&gt;@Inject&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java-config&quot;&gt;Java Config&lt;/h2&gt;
&lt;p&gt;对于无法使用&lt;code&gt;@Conmponent&lt;/code&gt;和&lt;code&gt;@Autowired&lt;/code&gt;注解的, 比如第三方类库的组件, 可以使用java config的方式装配. 同时, javaconfig也是java代码, 他们不应该包含任何业务代码, 实际上两者应该完全分开,所以一般会将java config代码放在单独的包中.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Configuration&lt;/code&gt; 注解标识类是一个配置类.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Bean&lt;/code&gt; 注解的方法声明为返回bean. &lt;code&gt;@Bean(name='methodname')&lt;/code&gt; 参数标识bean的id名称, 默认为方法名称.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public A getA(){
    return new A();
}

@Bean
public B getB(){
    return new B(getA());
}

@Bean
public C getC(){
    return new C(getA());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面代码中构建组件B,C使用的构造器注入了A的bean&lt;code&gt;getA()&lt;/code&gt;, 在一般的java程序中B,C的Bean会分别持有A的不同实例, 但Spring中不是这样, 所有&lt;code&gt;getA()&lt;/code&gt;会被拦截, 并返回同一个bean. 默认情况下Spring的bean都是单例的.&lt;/p&gt;
&lt;p&gt;可以使用更为简单的方式创建B,C的bean, 代码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public B getB(){
    return new B(A a); // 也可以使用setter方式, 或者任何其他方式创建bean
}

@Bean
public C getC(){
    return new C(A a);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Import({ClassnameA.class,ClassnameB.class})&lt;/code&gt; 对于不同位置的bean, javaconfig可以使用此注解导入其他配置类.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;xml-config&quot;&gt;XML Config&lt;/h2&gt;
&lt;p&gt;XML是Spring最原始的装配方式, 熟悉Xml config对了解历史项目, 以及渐进重构到java config或自动配置都是有帮助的.&lt;/p&gt;
&lt;p&gt;xml配置构造器(setter)注入的方式有两种, 两种方式各有利弊:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;c-命名控制 或 p-命名空间 特点是简洁, 但不能注入集合; 使用时需要引入XSD.&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;配置文件的顶部需要声明多个XSD.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;bean class=&quot;com.xlx.c02.MyClass&quot;&amp;gt;&lt;/code&gt; 声明了一个bean, 默认id为com.xlx.c02.MyClass#0, 可以使用属性id为bean指定名称&lt;code&gt;&amp;lt;bean id=&quot;myclass&quot; class=&quot;com.xlx.c02.MyClass&quot;&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt; 用来配置构造器注入的参数, 引用其他bean时使用&lt;code&gt;&amp;lt;constructor-arg ref=&quot;otherBeanId&quot;&amp;gt;&lt;/code&gt;, 等同c-命名空间的属性&lt;code&gt;c:otherBean-ref='otherBeanId'&lt;/code&gt;, 或者参数数字索引&lt;code&gt;c:_0-ref='otherBeanId'&lt;/code&gt;(单参数可以省略数字); 也可以注入字面量值&lt;code&gt;&amp;lt;constructor-arg value=&quot;this is value&quot;&amp;gt;&lt;/code&gt; 等同c-命名空间的属性&lt;code&gt;c:_name='jery'&lt;/code&gt;,或 &lt;code&gt;c:_0='jery'&lt;/code&gt;(单参数可省略数字)&lt;/li&gt;
&lt;li&gt;装配集合&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;constuctor-arg&amp;gt;
    &amp;lt;list&amp;gt;
        &amp;lt;value&amp;gt;first&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;second&amp;lt;/value&amp;gt;
    &amp;lt;/list&amp;gt;
&amp;lt;/constuctor-arg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;设置属性: &lt;code&gt;&amp;lt;property name=&quot;propertyName&quot; ref=&quot;beanId&quot;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;p:propertyName-ref=&quot;beanId&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;util 命名空间的功能可以简化一些字面量属性设置, 同样,需要首先声明XSD.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--定义集合--&amp;gt;
&amp;lt;util:list id=&quot;trackList&quot;&amp;gt;
    &amp;lt;value&amp;gt;first&amp;lt;/value&amp;gt;
    &amp;lt;value&amp;gt;second&amp;lt;/value&amp;gt;
&amp;lt;/util:list&amp;gt;

&amp;lt;!--p-命名的方式引用集合--&amp;gt;
p:tracks-ref=&quot;trackList&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;混合配置&quot;&gt;混合配置&lt;/h2&gt;
&lt;p&gt;一. Java Config引用其他&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Import&lt;/code&gt; 可以导入java配置类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ImportResource&lt;/code&gt; 可以导入xml配置, 如&lt;code&gt;@ImportResource(&quot;classpath:my-config.xml&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二. XML Config 引用其他&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;import resource='my-config.xml'&amp;gt;&lt;/code&gt; 引用其他xml配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 引用java config&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不管如何引用, 创建一个根配置会使配置更具层次, 更易于阅读管理.&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 15:13:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>创建应用对象之间协作关系的行为称为装配(wiring), 这也是DI的本质. Spring中装配Bean的方式 Spring提供了三种装配Bean的方式. 1. 隐式的Bean发现机制和自动装配 2.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/9607524.html</dc:identifier>
</item>
<item>
<title>关于 MongoDB 与 SQL Server 通过本身自带工具实现数据快速迁移 及 注意事项 的探究 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9607515.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9607515.html</guid>
<description>&lt;h2&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;随着业务的发展、需求的变化，促使我们追求使用不同类型的数据库，充分发挥其各自特性。如果决定采用新类型的数据库，就需要将既有的数据迁移到新的数据库中。在这类需求中，将SQL Server中的数据导入到MongoDB 中显得尤为突出。&lt;/p&gt;
&lt;p&gt;面对这种需求，大家优先想到的就是百度查找第三方工具，可惜截止目前，还没有一款公认比较满意的数据迁移工具。百度不到，大家可能就要回头自己开发了。如此，更是花费不少人力物力和宝贵的精力。甚至，由于没有理想的迁移工具，导致项目优化一再延迟。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实，你原本不必如此！因为，还有一个工具，并且性能还傲视群雄。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那就是充分挖掘数据库自身的导出导入功能。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;原理&lt;/h2&gt;

&lt;p align=&quot;left&quot;&gt;MongoDB数据库 可以通过mongoexport/mongoimport命令进行数据的导出导入，并且支持文件CSV格式；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server 数据库 一样可以进行导出导入【“任务”—&amp;gt;导出数据/导入数据】，其数据一样可以保存到CSV文件中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;那么，我们是不是可以借助 CSV文件，在这两种数据库间进行数据迁移呢？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;答案是肯定的！答案是肯定的！答案是肯定的！&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此外，数据直接导出导入，性要比其它工具快一个数量级。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;即：&lt;span&gt;&lt;strong&gt;&lt;span&gt;通过SQL Server 和 MongoDB 本身自带的 导入导出功能 ，可以实现数据的快速迁移&lt;/span&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2&gt; 将SQL Server中的数据导入到MongoDB中&lt;/h2&gt;

&lt;p&gt;step 1 选择指定数据库，进行【导出数据】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222401689-1812385615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 2  选择导出的数据源信息&lt;/p&gt;
&lt;p&gt;因在SQL Server 服务器上执行，服务器名称可选择本地（. 即可），身份认证可以使用Window身份验证（如SQL Server 禁用了此window登入方式，那么就要使用SQL Server 身份验证），然后，选择数据库。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222604064-1387060112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 3 选择导出目标（此为&lt;strong&gt;关键步骤&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;目标一定要选择 &lt;strong&gt;&lt;span&gt;【平面文件目标】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222717864-1798420642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为 导出文件命名 选择 【浏览】，在打开的 界面上 选择导出文件类型&lt;strong&gt;&lt;span&gt;【CSV 文件（*.csv）】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222811714-1456177146.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，文件命名为SQLToMongoDB01&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222837927-875625145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 【下一步】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222908380-1786291049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 4  指定表复制 或 查询&lt;/p&gt;
&lt;p&gt;可以指定从数据源复制一个或多个表和视图，还是通过 T_SQL 语句从数据源中复制查询结（可以指定选择列 或对列二次加工后的数据）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907222952794-1124494023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 5  配置平面文件目标&lt;/p&gt;
&lt;p&gt;在这一步选择要导出的表或视图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223025832-2037098857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想对 field 字段 进行修改，可以选择 &lt;span&gt;&lt;strong&gt;【编辑映射】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对想要修改的列命进行重命名，例如 将SQL Server 中的 AreaCode 命名 而在MongoDB中命名为 AreaCodeMongoDB&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223129574-2059987106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后 点击 【下一步】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223720517-691737529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 6 保存并运行包&lt;/p&gt;
&lt;p&gt;直接点击 【下一步】&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223820486-55251772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 7 完成该向导&lt;/p&gt;
&lt;p&gt;直接点击 【完成】&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223831006-779156624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据导出成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907223857617-308251871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;导出数据&lt;strong&gt;&lt;span&gt;773838&lt;/span&gt;&lt;/strong&gt; 笔数据。&lt;/p&gt;

&lt;p&gt;Step 8 将产生的文件Copy至 MongoDB 服务器上&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;Step 9 在mongoDB 服务器上 执行 mongoimport 命令， 将从 SQL Server 导出的csv 数据导入到MongoDB中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;执行命令 为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;/data/mongodb/mongobin344/bin/mongoimport --file /data/mongodb_back/SQLToMongoDB01.csv  -h 172.X.X.XXX --port 端口  --type csv --headerline -u 用户名 -p '密码' -d testdba0906 --authenticationDatabase 认证数据库 -c SQLToMongoDB01&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224028349-32781890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;执行成功，导入数据 &lt;strong&gt;&lt;span&gt;773838&lt;/span&gt;&lt;/strong&gt; 个文档。并且可以看到很快，不到15S。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;span&gt;此部分 测试验证OK！&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;将 MongoDB中的数据导入的SQL Server 中&lt;/h2&gt;

&lt;p align=&quot;left&quot;&gt;Step 1 使用 mongoexport 将MongoDB数据库中的数据导出&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;执行命令&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;/data/mongodb/mongobin344/bin/mongoexport   -h 172.X.X.X --port 端口  --type csv  -u 用户名 -p '密码' -d testdba0906 --authenticationDatabase 认证数据库  -c SQLToMongoDB01  -f 字段1,字段2,字段3,字段4,字段5 -o  /data/mongodb_back/MongoDBToSQL.csv &lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;Step 2  将从MongoDB中导出的CSV 文件上传到 SQL Server 服务器上。&lt;/p&gt;

&lt;p&gt;Step 3 将CSV 文件导入到SQL Server中&lt;/p&gt;
&lt;p&gt;（此过程，不是本文章的重点，所以不再详细说明，只指出关键步骤。）&lt;/p&gt;
&lt;p&gt;选择数据源，请选择&lt;span&gt;&lt;strong&gt;【平面文件源】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224356790-1223906565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择源表和源视图 【可以通过编辑映射，修改列名，修改字段类型，修改字段长度】&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224423186-1400844074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224439610-1705770013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 4  数据导出成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224524368-247168520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;检查数据量和源表数据一致。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此部分 测试验证OK！&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;注意事项&lt;/h2&gt;

&lt;p align=&quot;left&quot;&gt;&lt;em&gt;&lt;strong&gt;注意1&lt;/strong&gt;&lt;/em&gt;： 因为 mongoimport 导入的文件默认是json 格式，所以csv 文件，一定要在命令中指明 --type csv&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;否则，就无法识别文件中的数据。报错信息：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Failed: error processing document #1: invalid character 'X' looking for beginning of value&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907224741579-1170801006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（X代表文件中的第一个字符）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意 2&lt;/strong&gt;&lt;/em&gt; ：  mongoimport 导入的csv文件，一定要执行 –headerline 参数，指明不导入第一行。csv格式的文件第一行为列名。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;否则 ，提示一定要指明字段属性，报错信息：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;error validating settings: must specify --fields, --fieldFile or --headerline to import this file type&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;em&gt;注意 3&lt;/em&gt;&lt;/strong&gt; ：CSV 文件的列数据中不可以包含“” （中文双引号）。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;否则，当导入此行数据时，提示错误信息&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Failed: read error on entry #XXXX: line XXXX, column 110: bare &quot; in non-quoted-field&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180907225134045-1506637258.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意 4&lt;/strong&gt;&lt;/em&gt;： 如果数据中含有中文，需检查导入后是否变成了乱码。&lt;/p&gt;
&lt;p&gt;为防止乱码，需要将csv文档改成utf-8的编码方式即可。例如使用edit with notepad ++ 编辑器打开文件，另存为utf-8就可以了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意 5&lt;/strong&gt;&lt;/em&gt;：MongoDB导出CSV格式一定要通过 –f 参数 指明字段名，负责报错：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Failed: CSV mode requires a field list。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意 6&lt;/strong&gt;&lt;/em&gt;：MongoDB DB 数据模式自由，并且文档可以内嵌，所以将MongoDB中的数据导入到SQL Server 比较困难，特别是含有中文语句时。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意 7&lt;/strong&gt;&lt;/em&gt; : SQL Server 导出数据时，字段数据中不可以包含nchar(9)、nchar(32)、nchar(160) 等特殊字符，否则，在导出数据生成csv文件时报错。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 07 Sep 2018 15:11:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>背景介绍 随着业务的发展、需求的变化，促使我们追求使用不同类型的数据库，充分发挥其各自特性。如果决定采用新类型的数据库，就需要将既有的数据迁移到新的数据库中。在这类需求中，将SQL Server中的数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9607515.html</dc:identifier>
</item>
<item>
<title>面向对象 - cherry小樱桃</title>
<link>http://www.cnblogs.com/surewing/p/9607455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surewing/p/9607455.html</guid>
<description>&lt;p&gt;标签（空格分隔）： 面向对象&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;面向对象：&lt;/p&gt;
&lt;h2 id=&quot;类&quot;&gt;类：&lt;/h2&gt;
&lt;p&gt;任何事物归为一类，就是一系列相似特征与技能的结合体；&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;强调：站在不同的角度得到的分类是不一样的；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;对象和类&quot;&gt;对象和类：&lt;/h3&gt;
&lt;p&gt;在现实世界中：先有对象，后有总结出来的类&lt;br/&gt;在程序中：先有类，然后调用类来产生对象；&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;类就相当于模版，然后才造对象；&lt;br/&gt;例如：&lt;br/&gt;王二丫：&lt;br/&gt;特征:&lt;br/&gt;--------学校：&lt;br/&gt;--------名字：&lt;br/&gt;--------性别：&lt;br/&gt;--------年龄：&lt;br/&gt;技能：&lt;br/&gt;--------吃饭：&lt;br/&gt;--------学习：&lt;br/&gt;--------睡觉：&lt;br/&gt;李三：&lt;br/&gt;特征：&lt;br/&gt;--------学校：&lt;br/&gt;--------名字：&lt;br/&gt;--------性别：&lt;br/&gt;--------年龄：&lt;br/&gt;技能：&lt;br/&gt;--------吃饭：&lt;br/&gt;--------学习：&lt;br/&gt;--------睡觉：&lt;br/&gt;相似的特征：&lt;br/&gt;学习，吃饭，睡觉&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;so:先定义类：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#先定义类
class Student:
    schoole='home'
    #功能---用方法表示
    def learn(self):
        print('learn')
    def sleep(self):
        print('sleep')
    def eat(self):
        print('eat')
#产生对象，最终程序的运行就是对象调用的；
stu1=Student()#实例化对象
stu2=Student()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何使用类&quot;&gt;如何使用类：&lt;/h2&gt;
&lt;p&gt;类和函数的区别，类在定义的时候，就会就会被执行，但是函数只有在调用的时候，才会被执行；&lt;/p&gt;
&lt;p&gt;在内存里面，执行类的时候，会有一个名称空间来存放类的名称空间；&lt;br/&gt;查看类的名称空间:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(Student.__dict__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类是一系列对象相似的特证与技能的集合：特征在程序中用：变量表示，技能用函数表示：类的内部无非就是变量的定义与函数的定义，但是python不限制，写其他的代码在类里面；&lt;/p&gt;
&lt;p&gt;类的用法：无非就是一些名字，技能，针对这些东西，进行增删改查，就是通过类的名称空间来进行这些操作：如下代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student:
    schoole='home'
    #功能---用方法表示
    def learn(self):
        print('learn')
    def sleep(self):
        print('sleep')
    def eat(self):
        print('eat')
print(Student.__dict__['school'])
print(Student.__dict__['eat'])&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何使用对象&quot;&gt;如何使用对象：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/wangcherry123/bxw3j21i0tmn8t1u3tz3u0zu/image.png&quot; alt=&quot;image.png-57.6kB&quot;/&gt;&lt;br/&gt;如上图的代码：&lt;br/&gt;stu1,就是一个实例化的对象，这个对象有个两个功能，学习，吃饭，属相是同一个学校；&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;但是特殊的对象怎么办？就是有些对象有个性化的设置：&lt;br/&gt;__init__用来为对象定义对象独有的特征；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class luffStudent:
    school='luffcity'
    def __init__(self,name,age,sex):
        self.Name=name
        self.Age=age
        self.Sex=sex
    def learn(self):
        print('is learning')
    def eat(self):
        print('is sleeping')
stu1=LuffyStudent()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照上述代码执行：&lt;br/&gt;结果会报错:&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/wangcherry123/ljq4ddwv3x4k76u3e9xvxcez/image.png&quot; alt=&quot;image.png-22.8kB&quot;/&gt;&lt;br/&gt;这里用户会很懵逼：明明我们只是创建了一个类而已，并没有调用__init__方法，以上错误说明，是python自己调用，就是在你实例化的时候，就会调用这个方法，&lt;/p&gt;
&lt;p&gt;针对上述的代码：我们进行修改为：&lt;br/&gt;stu1=LuffyStudent('wang','nv','45')&lt;/p&gt;
&lt;p&gt;在次执行上述代码，不会报错了；&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;现在有__init__方法的时候，在实例化的时候：&lt;br/&gt;1.先产生一个对象，&lt;br/&gt;2.触发__init__会返回类的函数属性，里面有几个参数传几个参数，其实self就是LuffyStudent()空对象而已；然后self就是这个空对象，他会当做第一个参数传给__init__,&lt;br/&gt;3.然后传：'wang','nv','45'&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;访问属性：&lt;br/&gt;print(stu1.Name)&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;同样我们可以对属性进行增删改查：&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/wangcherry123/n6ysiks8q9zxpphvqjhtu24k/image.png&quot; alt=&quot;image.png-49.5kB&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 14:46:00 +0000</pubDate>
<dc:creator>cherry小樱桃</dc:creator>
<og:description>面向对象 标签（空格分隔）： 面向对象 面向对象： 类： 任何事物归为一类，就是一系列相似特征与技能的结合体； 强调：站在不同的角度得到的分类是不一样的； 对象和类： 在现实世界中：先有对象，后有总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surewing/p/9607455.html</dc:identifier>
</item>
<item>
<title>OpenCV 使用 findContours 函数 Note1: 利用各个轮廓的相互阶层（hierarchy）关系 - MsPark</title>
<link>http://www.cnblogs.com/SarahPaulson/p/9607410.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SarahPaulson/p/9607410.html</guid>
<description>&lt;p&gt;&lt;span data-cke-copybin-start=&quot;1&quot;&gt;&lt;span data-cke-copybin-start=&quot;1&quot;&gt;​&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907212510288-410097084.png&quot; alt=&quot;&quot; width=&quot;196&quot; height=&quot;194&quot;/&gt;输入图像&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Detect_Object(Mat img)
{
    Mat gray, binaryIMG;
    Mat correct_IMG;

    cvtColor(img, gray, CV_BGR2GRAY);
    Canny(gray, binaryIMG, &lt;/span&gt;&lt;span&gt;90&lt;/span&gt;, &lt;span&gt;180&lt;/span&gt;&lt;span&gt;);
    blur(binaryIMG, binaryIMG, Size(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Find contours&lt;/span&gt;
    vector&amp;lt;vector&amp;lt;Point&amp;gt; &amp;gt;&lt;span&gt; contours;
    vector&lt;/span&gt;&amp;lt;Vec4i&amp;gt;&lt;span&gt; hierarchy;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; TargetArea = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    findContours(binaryIMG, contours, hierarchy, RETR_TREE, CV_CHAIN_APPROX_NONE, Point(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contours.size(); i++&lt;span&gt;)
    {
        drawContours(img, contours, i, Scalar(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, hierarchy, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, Point());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先上代码， 上述函数是寻找一个图像内的所有轮廓。&lt;/p&gt;
&lt;p&gt;执行后，利用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
drawContours(img, contours, i, Scalar(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, hierarchy, &lt;span&gt;0&lt;/span&gt;, Point());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个函数，会画出所有图像内的轮廓。&lt;/p&gt;
&lt;p&gt;执行上述代码后，我的代码上显示 contour.size() ,即轮廓个数是34个。 这个轮廓个数不是绝对的， 结果由你对canny()选取的阈值， blur() mask的大小选取都有影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907212752710-1274643595.png&quot; alt=&quot;&quot; width=&quot;277&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Canny 和 Blurring 算法结果图像。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907212923569-1595166025.png&quot; alt=&quot;&quot; width=&quot;302&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红色显示的是 FindContours函数所检测到的轮廓。&lt;/p&gt;

&lt;p&gt;你或许会觉得，最终显示的结果像一幅捕捉边缘的图像，即Edge Map。也会不解，有了Canny，何须多此一举在寻找轮廓。&lt;/p&gt;
&lt;p&gt;接下来我就要介绍本章的主角轮廓 Hierarchy的阶层关系。&lt;/p&gt;
&lt;p&gt;先看一段修改后的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contours.size(); i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hierarchy[i][&lt;span&gt;3&lt;/span&gt;] == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                drawContours(img, contours, i, Scalar(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, hierarchy, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, Point());
            }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码中，多了一段条件语句，语句里写了 &lt;/p&gt;
&lt;pre&gt;
hierarchy[i][3] == -1
&lt;/pre&gt;
&lt;p&gt;首先，我们确认一下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907213906487-1446149151.png&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;317&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次的结果里，只检测出了最外围轮廓。很明显&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
hierarchy[i][3] == -1 起了决定性的作用。 &lt;p&gt;我们先看看OpenCV官方文件是怎么写的。
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;OpenCV represents it as an array of four values : &lt;strong&gt;[Next, Previous, First_Child, Parent].   (&lt;a href=&quot;https://docs.opencv.org/3.4.0/d9/d8b/tutorial_py_contours_hierarchy.html&quot; target=&quot;_blank&quot;&gt;Link&lt;/a&gt; me: https://docs.opencv.org/3.4.0/d9/d8b/tutorial_py_contours_hierarchy.html)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;pre readability=&quot;14&quot;&gt;
hierarchy[i][3] == -1， 这里的hierarchy[i]指的是第i个轮廓的阶层关系。而hierarchy[i][0],hierarchy[i][1],hierarchy[i][2],hierarchy[i][3]分别指的是Next, Previous, First_child, Parent。&lt;p&gt;我们设定的hierarchy[i][3]== -1 的意思就是 “轮廓没有父母”， 即“这个轮廓没有上层阶级的轮廓”。&lt;/p&gt;&lt;p&gt;同理， hierarchy[i][2]== -1 的意思就是 “此轮廓没有第一个孩子”，即“此轮廓没有下层阶级的轮廓”。&lt;/p&gt;&lt;p&gt;至于，hierarchy[][0],hierarchy[][1] 指的是此轮廓的后一个轮廓，和前一个轮廓。他们都是同一个阶级的轮廓。这个前后顺序可能是很随意的，至今还没找到规律。所以还没有到怎么利用他们。&lt;/p&gt;&lt;p&gt;所以，
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
hierarchy[i][3]== -1 条件下的结果， 是选中了没有父母的轮廓，即他的外围没有包围他的轮廓。&lt;p&gt;再看看
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
hierarchy[i][2]== -1 条件下的结果：
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907220205470-570318093.png&quot; alt=&quot;&quot; width=&quot;417&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;

&lt;pre readability=&quot;24&quot;&gt;
和预想的一样，它只标出了没有“孩子”的轮廓，即此轮廓内没有更小的轮廓。&lt;p&gt;对了，我要强调一下，这个例子里我在使用FindContours函数的时候，我用了&lt;strong&gt;RETR_TREE&lt;/strong&gt; 模式。这个模式是“万能的”，把图像内各轮廓的亲属关系都联系上了。简而言之，你能知道一个轮廓的”爷爷奶奶“，”孙子孙女“。甚至更深的祖辈关系。 &lt;/p&gt;&lt;p&gt;opencv 提供了各种模式，RETR_LIST, RETR_EXTERNAL等。 上面的官方文件有详细说明。&lt;br/&gt;RETR_LIST 就是这个图像的轮廓只可能是两个阶层的其中之一，要么你就是爹， 要么你就是儿子。本章只讲RETR_TREE。&lt;/p&gt;&lt;p&gt;这时候你可能还没领会到Hierarchy的魅力。 他不会马上帮你挑出你最想要的信息，但是他确实个帮你排除“杂质”帮手。&lt;/p&gt;&lt;p&gt;例如， 我们这次测试的Heliport图像， 很明显这个图像里的“H”是叫无人机去识别， 并且在其中心降落的。 那我们怎么去识别他呢？ 如果不用Deep Learning。&lt;/p&gt;&lt;p&gt;我们可以在这个图像里找没有孩子的轮廓，但没有孩子的轮廓候补也很多。怎么办？ &lt;br/&gt;很简单， 选取轮廓面积最大的，或者大于一定面积以上的，其实方法真的很多。只要你多加一个条件语句。&lt;/p&gt;&lt;p&gt;简单的看下代码：
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; contours.size(); i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hierarchy[i][&lt;span&gt;2&lt;/span&gt;] == -&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; contourArea(contours[i]) &amp;gt; &lt;span&gt;9800&lt;/span&gt;&lt;span&gt;)
            {
                drawContours(img, contours, i, Scalar(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;), &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, hierarchy, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, Point());

            }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;我加了一段 面积大于 9800 像素的条件。结果就找到了 “H”。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367920/201809/1367920-20180907222304853-814899664.png&quot; alt=&quot;&quot; width=&quot;297&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;你问我怎么算的9800？ 估算的， 但是我想说的不是面积这部分，利用面积也只是方法之一。 想要更精确确定的方法有很多。比如是高和宽的比例。&lt;/p&gt;
&lt;p&gt;今天主要是为了介绍hierarchy的魅力，其实利用好真的能排除很多没用的信息。hierarchy 只是OpenCV Contours 这部分的魅力之一， 仔细翻阅官方文件你会发现，opencv 这部分还真的准备了很多宝贝。&lt;/p&gt;





&lt;p&gt;&lt;span data-cke-copybin-start=&quot;1&quot;&gt;&lt;span data-cke-copybin-end=&quot;1&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 07 Sep 2018 14:29:00 +0000</pubDate>
<dc:creator>MsPark</dc:creator>
<og:description>​输入图像 先上代码， 上述函数是寻找一个图像内的所有轮廓。 执行后，利用 这个函数，会画出所有图像内的轮廓。 执行上述代码后，我的代码上显示 contour.size() ,即轮廓个数是34个。 这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SarahPaulson/p/9607410.html</dc:identifier>
</item>
</channel>
</rss>