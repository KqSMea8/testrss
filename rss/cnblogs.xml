<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>chrome调试工具高级不完整使用指南（实战二） - 谢灿勇</title>
<link>http://www.cnblogs.com/st-leslie/p/8271347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/st-leslie/p/8271347.html</guid>
<description>&lt;h2&gt;3.3 给页面添加测试脚本&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在现实的工作中，我们往往会遇到一些问题在线上就会触发然后本地就触发不了的问题。或者是，要给某个元素写一个测试脚本。这个时候如果是浏览器有提供一个添加脚本的功能的话，那么我们的整个操作就方便多了。具体操作如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180113154410097-1761856932.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 我们先来给自己定一个需求，我们要在博客园的tab面板上面添加一个弹窗，弹窗的内容为1&lt;/p&gt;
&lt;p&gt;这个时候的操作如下：首先先把面板切换到Sources，然后再右侧中选中Snippets，接着点击New snippet来，添加的脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
$(&quot;.post_nav_block&quot;).on(&quot;click&quot;,&quot;li&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    alert(&lt;/span&gt;1&lt;span&gt;);
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;[观察netWork中的加载，我们发现博客园使用了jquery，所以我们可以使用jquery的绑定事件，对于不存在jquery引入的网站，我们不能这样使用]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;编写之后保存我们发现点击之后没有反应，其实这个脚本编写之后是需要运行才能够使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180113155547457-1979380160.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;右击选择run,只要不触发页面刷新，新加入的脚本是不会停止的，如果触发刷新就会停止脚本的运行，但是脚本还是存在。即使你关闭了浏览器，下一次打开还是存在这个脚本，除非你删除了这个脚本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180113160135238-1327847656.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3.4  经典的断点调试&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;相信很多前端人员都应该挺熟悉断点调试的吧，不熟悉也没有关系，我们来整理一下。首先我们自己编写如下的一段测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;
    &amp;lt;script&amp;gt;
        &lt;span&gt;var&lt;/span&gt; a=1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b=2&lt;span&gt;;
        console.log(b);
        console.log(a);
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;断点如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180113210302347-1674004547.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们要在断点3调到断点5，不经过断点4的话，我们可以使用左侧的按钮&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180113210440285-1327863027.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果要分别一次进行下去，只需要按下F10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果有函数的话，要运行到函数内部，可以使用F11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其中&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180113211319504-1378107046.gif&quot; alt=&quot;&quot;/&gt;是用来开启和关闭断点，当关闭断点后，所有的断点都会失效&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;选中变量，右击菜单选择Add selected text to watches把变量添加到右侧的watch面板，这样可以监控一个变量的当前情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;重新编写一段测试代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;script&amp;gt;&lt;span&gt;
        test1();
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test1(){
            test2();
        }
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test2(){
            test3(&lt;/span&gt;&quot;this is test&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test3(params) {
            console.log(params);
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a=1&lt;span&gt;;
        alert(a);
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;然后在test3下面的console.log语句中打断点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看下右侧的栈调用面板如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180113222309832-433792169.gif&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;从而我们可以快速的定位到函数的栈调用情况&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.5 查看chrome插件的代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;chrome中的source提供了一种可以查看插件代码的功能，选中右侧中的Content scripts就可以看到了，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/728493/201801/728493-20180113232132910-769112595.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;具体的代码就可以将文件夹直接展开就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;source模块的用法大致上也就是这些了。下一节将讲一讲chrome对性能分析上面的利用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/st-leslie/p/8196493.html%20&quot; target=&quot;_blank&quot;&gt; chrome调试工具高级不完整使用指南（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/st-leslie/p/8244559.html&quot; target=&quot;_blank&quot;&gt; chrome调试工具高级不完整使用指南（优化篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/st-leslie/p/8261319.html&quot; target=&quot;_blank&quot;&gt; chrome调试工具高级不完整使用指南（实战一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/st-leslie/p/8271347.html&quot; target=&quot;_blank&quot;&gt; chrome调试工具高级不完整使用指南（实战二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; chrome调试工具高级不完整使用指南（实战三）&lt;/p&gt;

</description>
<pubDate>Sat, 13 Jan 2018 15:24:00 +0000</pubDate>
<dc:creator>谢灿勇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/st-leslie/p/8271347.html</dc:identifier>
</item>
<item>
<title>CSS选择器：伪类（图文详解） - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8280814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8280814.html</guid>
<description>&lt;blockquote readability=&quot;5.375&quot;&gt;
&lt;p&gt;本文最初发表于&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8280814.html&quot;&gt;博客园&lt;/a&gt;，并在&lt;a href=&quot;https://github.com/smyhvae/Web&quot;&gt;GitHub&lt;/a&gt;上持续更新&lt;strong&gt;前端的系列文章&lt;/strong&gt;。欢迎在GitHub上关注我，一起入门和进阶前端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;伪类伪类选择器&quot;&gt;伪类（伪类选择器）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;伪类&lt;/strong&gt;：同一个标签，根据其&lt;strong&gt;不同的种状态，有不同的样式&lt;/strong&gt;。这就叫做“伪类”。伪类用冒号来表示。&lt;/p&gt;
&lt;p&gt;比如div是属于box类，这一点很明确，就是属于box类。但是a属于什么类？不明确。因为需要看用户点击前是什么状态，点击后是什么状态。所以，就叫做“伪类”。&lt;/p&gt;
&lt;h3 id=&quot;静态伪类和动态伪类&quot;&gt;静态伪类和动态伪类&lt;/h3&gt;
&lt;p&gt;伪类选择器分为两种。&lt;/p&gt;
&lt;p&gt;（1）&lt;strong&gt;静态伪类&lt;/strong&gt;：只能用于&lt;strong&gt;超链接&lt;/strong&gt;的样式。如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;:link&lt;/code&gt; 超链接点击之前&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:visited&lt;/code&gt; 链接被访问过之后&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：以上两种样式，只能用于超链接。&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;动态伪类&lt;/strong&gt;：针对&lt;strong&gt;所有标签&lt;/strong&gt;都适用的样式。如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;:hover&lt;/code&gt; “悬停”：鼠标放到标签上的时候&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:active&lt;/code&gt; “激活”： 鼠标点击标签，但是不松手时。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:focus&lt;/code&gt; 是某个标签获得焦点时的样式（比如某个输入框获得焦点）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：以上三种样式，只能用于超链接。&lt;/p&gt;
&lt;h2 id=&quot;超链接a标签&quot;&gt;超链接a标签&lt;/h2&gt;
&lt;h3 id=&quot;超链接的四种状态&quot;&gt;超链接的四种状态&lt;/h3&gt;
&lt;p&gt;a标签有4种伪类（即对应四种状态），要求背诵。如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;:link&lt;/code&gt; “链接”：超链接点击之前&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:visited&lt;/code&gt; “访问过的”：链接被访问过之后&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:hover&lt;/code&gt; “悬停”：鼠标放到标签上的时候&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:active&lt;/code&gt; “激活”： 鼠标点击标签，但是不松手时。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应的代码如下：（不带注释）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;        a&lt;span class=&quot;dv&quot;&gt;:link&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        a&lt;span class=&quot;dv&quot;&gt;:visited&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;orange&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        a&lt;span class=&quot;dv&quot;&gt;:hover&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        a&lt;span class=&quot;dv&quot;&gt;:active&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应的代码如下：（带注释）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;       /*让超链接点击之前是红色*/
        a:link{
            color:red;
        }

        /*让超链接点击之后是绿色*/
        a:visited{
            color:orange;
        }
        /*鼠标悬停，放到标签上的时候*/
        a:hover{
            color:green;
        }
        /*鼠标点击链接，但是不松手的时候*/
        a:active{
            color:black;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;记住，在css中，这四种状态&lt;strong&gt;必须按照固定的顺序写&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;a:&lt;strong&gt;l&lt;/strong&gt;ink 、a:visited 、a:hover 、a:active&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果不按照顺序，那么将失效。“爱恨准则”：love hate。必须先爱，后恨。&lt;/p&gt;
&lt;p&gt;看一下这四种状态的动图效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180113_2239.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;超链接的美化&quot;&gt;超链接的美化&lt;/h3&gt;
&lt;p&gt;问：既然&lt;code&gt;a{}&lt;/code&gt;定义了超链的属性，和&lt;code&gt;a:link{}&lt;/code&gt;定义了超链点击之前的属性，那这两个有啥区别呢？&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;a{}&lt;/code&gt;和&lt;code&gt;a:link{}&lt;/code&gt;的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;a{}&lt;/code&gt;定义的样式针对所有的超链接(包括锚点)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a:link{}&lt;/code&gt;定义的样式针对所有写了href属性的超链接(不包括锚点)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;超链接a标签在使用的时候，比较难。因为不仅仅要控制a这个盒子，也要控制它的伪类。&lt;/p&gt;
&lt;p&gt;我们一定要将a标签写在前面，将&lt;code&gt;:link、:visited、:hover、:active&lt;/code&gt;这些伪类写在后面。&lt;/p&gt;
&lt;p&gt;举个例子。如果效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170810_2235.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了实现上面这个效果，完整版代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xml:lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; http-equiv=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Document&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/css&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        *&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;padding:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;960px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;/*去掉小圆点*/&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;list-style:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul li&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;float:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;/*让内容水平居中*/&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;text-align:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;/*让行高等于nav的高度，就可以保证内容垂直居中*/&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;line-height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul li a&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;/*两个伪类的属性，可以用逗号隔开*/&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul li a&lt;span class=&quot;dv&quot;&gt;:link&lt;/span&gt; , &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul li a&lt;span class=&quot;dv&quot;&gt;:visited&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;text-decoration:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;purple&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul li a&lt;span class=&quot;dv&quot;&gt;:hover&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; orange&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;nav&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网站栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网站栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网站栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网站栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网站栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网站栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网站栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;网站栏目&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上方代码中，我们发现，当我们在定义&lt;code&gt;a:link&lt;/code&gt;和 &lt;code&gt;a:visited&lt;/code&gt;这两个伪类的时候，如果它们的属性相同，我们其实可以写在一起，用逗号隔开就好，摘抄如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul li a&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;/*两个伪类的属性，可以用逗号隔开*/&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul li a&lt;span class=&quot;dv&quot;&gt;:link&lt;/span&gt; , &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul li a&lt;span class=&quot;dv&quot;&gt;:visited&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;text-decoration:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;purple&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul li a&lt;span class=&quot;dv&quot;&gt;:hover&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; orange&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上方代码所示，最标准的写法，就是把link、visited、hover这三个伪类都要写。但是前端开发工程师在大量的实践中，发现不写link、visited也挺兼容。写法是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;a:link、a:visited都是可以省略的，简写在a标签里面。也就是说，a标签涵盖了link、visited的状态（前提是都具有了相同的属性）。写法如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul li a&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;text-decoration:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;purple&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.nav&lt;/span&gt; ul li a&lt;span class=&quot;dv&quot;&gt;:hover&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; orange&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然了，在写&lt;code&gt;a:link&lt;/code&gt;、&lt;code&gt;a:visited&lt;/code&gt;这两个伪类的时候，要么同时写，要么同时不写。如果只写&lt;code&gt;a&lt;/code&gt;属性和&lt;code&gt;a:link&lt;/code&gt;属性，不规范。&lt;/p&gt;
&lt;h2 id=&quot;动态伪类举例&quot;&gt;动态伪类举例&lt;/h2&gt;
&lt;p&gt;我们在第一段中描述过，下面这三种动态伪类，针对所有标签都适用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;:hover&lt;/code&gt; “悬停”：鼠标放到标签上的时候&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:active&lt;/code&gt; “激活”： 鼠标点击标签，但是不松手时。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:focus&lt;/code&gt; 是某个标签获得焦点时的样式（比如某个输入框获得焦点）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们不妨来举下例子。&lt;/p&gt;
&lt;p&gt;举例1：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/css&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    伪类选择器：动态伪类&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;  */&lt;/span&gt;

   &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    让文本框获取焦点时：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    边框：#FF6F3D这种橙色&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    文字：绿色&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    背景色：#6a6a6a这种灰色&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   */&lt;/span&gt;
    input&lt;span class=&quot;dv&quot;&gt;:focus&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;3px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#FF6F3D&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;#6a6a6a&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    鼠标放在标签上时显示蓝色&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    */&lt;/span&gt;
    label&lt;span class=&quot;dv&quot;&gt;:hover&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    点击标签鼠标没有松开时显示红色&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    */&lt;/span&gt;
    label&lt;span class=&quot;dv&quot;&gt;:active&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-02.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;利用这个&lt;code&gt;hover&lt;/code&gt;属性，我们同样对表格做一个样式的设置：&lt;br/&gt;表格举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;er&quot;&gt;&amp;lt;&lt;/span&gt;!doctype html&amp;gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Generator&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;EditPlus®&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Author&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Keywords&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Description&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Document&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/css&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/*整个表格的样式*/&lt;/span&gt;
    table&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;300px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;/*border-collapse属性：对表格的线进行折叠*/&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;border-collapse:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;collapse&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/*鼠标悬停时，让当前行显示#868686这种灰色*/&lt;/span&gt;
    table tr&lt;span class=&quot;dv&quot;&gt;:hover&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#868686&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;/*每个单元格的样式*/&lt;/span&gt;
    table td&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;&amp;lt;table&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;

 &lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-04.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;我的公众号&quot;&gt;我的公众号&lt;/h2&gt;
&lt;p&gt;想学习&lt;span&gt;&lt;strong&gt;代码之外的软技能&lt;/strong&gt;&lt;/span&gt;？不妨关注我的微信公众号：&lt;strong&gt;生命团队&lt;/strong&gt;（id：&lt;code&gt;vitateam&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jan 2018 14:58:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8280814.html</dc:identifier>
</item>
<item>
<title>redux入门指南 - Grewer</title>
<link>http://www.cnblogs.com/Grewer/p/8280639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Grewer/p/8280639.html</guid>
<description>&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;前言:大概一个月没有写博客了,这两天正好是周末,就写点东西来梳理下之前几个月的所写与所得;&lt;br/&gt;两个月前,学习了一下 redux ,还是一点难度的,花了我一天的时间来搞明白他,&lt;br/&gt;但是都没怎么记录,今天这篇博客就是用一个demo来介绍 redux , react-redux , react-thunk 的简单用法;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先就是下载,使用命令:&lt;br/&gt;&lt;code&gt;npm install --save redux react-redux react-thunk&lt;/code&gt;&lt;br/&gt;下好后 &lt;code&gt;npm start&lt;/code&gt; 启动;&lt;/p&gt;
&lt;p&gt;文件夹列表如下:&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1182844/201801/1182844-20180113224532472-2045955414.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;redux 的最关键的函数就是 dispatch !&lt;br/&gt;而 dispatch 的本质是什么呢?&lt;br/&gt;dispatch 接受的是一个对象,这个对象至少有一个是键值是用来判断类型的,其余的可以是任意的;&lt;br/&gt;而他(其实也就是 reducer 函数)他本身有一个 state ,用来存储初始值,根据接受到的对象中的类型键值来判断对于当前值的不同操作,&lt;br/&gt;而且他必须返回修改后的 state;&lt;/p&gt;
&lt;p&gt;现在我们创建好文件后修改 src/index.js::&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; createStore&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;applyMiddleware&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'redux'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; thunk &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'redux-thunk'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; Provider &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react-redux'&lt;/span&gt; 
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; calcul &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./redux/reducer'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; store &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;createStore&lt;/span&gt;(calcul&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;applyMiddleware&lt;/span&gt;(thunk))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ReactDOM&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Provider store&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;store&lt;span class=&quot;op&quot;&gt;}&amp;gt;&amp;lt;&lt;/span&gt;App /&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/Provider&amp;gt;, document.getElementById&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'root'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上部的代码中除了 reactDOM.render 是修改的,其他都是新添加的;&lt;br/&gt;这里我们是引用了 redux, redux-thunk, react-redux模块和一个 reducer 文件;&lt;br/&gt;讲一下 createStore 的作用,他在官方文档中的释义是这样的:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;创建一个 Redux store 来以存放应用中所有的 state。&lt;br/&gt;应用中应有且仅有一个 store。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实这只是一个声明赋值,而如果你不用中间件(thunk)可以这样写:&lt;br/&gt;&lt;code&gt;let store = createStore(calcul);&lt;/code&gt;&lt;br/&gt;一下子简单了很多;&lt;br/&gt;而 Provider 这个html的标签就是将 redux 的值和函数,传递给整个项目;&lt;/p&gt;
&lt;p&gt;上面说到了 create那我们先创建 reducer/index.js:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; combineReducers &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'redux'&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; countReducer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (state &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; action) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;switch&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'INCREMENT'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; state &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'DECREMENT'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; state &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;action&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; state&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; calcul &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;combineReducers&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    countReducer
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; calcul&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;combineReducers 是一个语法糖:他的作用就是将多个reducer函数合并成一个对象;&lt;br/&gt;上面的 countReducer 就是一个reducer函数了,就像我上面所说的,action就是接受的那个对象,&lt;br/&gt;而state就是他自带的初始值,通过switch操作,根据 action.type 的值来进行不同的操作,&lt;br/&gt;但是也是最重要的就是必须有返回值;&lt;/p&gt;
&lt;p&gt;接下来是修改src/App.js:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;connect&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react-redux'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Calculation &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./components/calculation'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; App &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;dispatch&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;countNum&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;div className&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;App&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;Calculation getValue&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;countNum&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; dispatch&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;dispatch&lt;span class=&quot;op&quot;&gt;}&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/Calculation&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;      &amp;lt;/div&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
    )&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;showData&lt;/span&gt;(state) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;countNum&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;countReducer&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;connect&lt;/span&gt;(showData)(App)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;connect 函数是来自 react-redux 的,他是一个非常重要的函数,&lt;br/&gt;在最下面一行代码中:&lt;code&gt;connect(showData)(App);&lt;/code&gt;&lt;br/&gt;第一个接受的是一个对象,在 showData 中, state 就是所有 reducer 的初始值;&lt;br/&gt;通过这个函数将当前的组件与 redux 中的数值挂钩,他返回的是当期组件所需要的 reducer 的值(你也可以对值进行filter),&lt;br/&gt;而第二个接受对象呢,就是当前组件了;&lt;br/&gt;可以看到,我们还引用了一个名为 Calculation 的组件,他接收了来自 redux 的 dispatch , countNum 这两个参数(函数);&lt;/p&gt;
&lt;p&gt;在下一个文件是 src/components/calculation.js:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;DECREMENT&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;middleINCRENT&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'../redux/action'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Count &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;(props) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(props)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;changeVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    input &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (e)&lt;span class=&quot;op&quot;&gt;=&amp;gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;changeVal&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Number&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;dispatch&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;getValue&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt; is calculation
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;op&quot;&gt;&amp;gt;{&lt;/span&gt;getValue&lt;span class=&quot;op&quot;&gt;}&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            &amp;lt;input type=&quot;text&quot; onChange={this.input} value={this.state.changeVal} /&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;middleINCRENT&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;changeVal&lt;/span&gt;)))&lt;span class=&quot;op&quot;&gt;}&amp;gt;+&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            &amp;lt;button onClick={&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; =&amp;gt; &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;DECREMENT&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;this.state.changeVal&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)))&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;}&amp;gt;-&amp;lt;/button&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    }&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个文件引用了文件:src/redux/action/index.js里的 DECREMENT , middleINCRENT 两个函数;&lt;br/&gt;其中 middleINCRENT 便是添加了中间件的 action 函数;&lt;br/&gt;这个组件的作用是什么呢:就是根据 input 里的值,来改变 redux 里的 countReducer 的初始值,靠着点击按钮来触发;&lt;br/&gt;dispatch 我先不说,先说下 DECREMENT , middleINCRENT ,而这就不得不提到下面这个文件:&lt;/p&gt;
&lt;p&gt;src/redux/action/index.js:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;INCREMENT&lt;/span&gt;(data)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'INCREMENT'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        data
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;middleINCRENT&lt;/span&gt;(data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (dispatch&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; getState) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; currentValue &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;getState&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;currentValue&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;countReducer&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;dispatch&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;INCREMENT&lt;/span&gt;(data))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;DECREMENT&lt;/span&gt;(data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'DECREMENT'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        data
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在你们知道中间件的作用了么?他就是在提交值的时候,对值进行统一的判断和修改,&lt;br/&gt;我们看这个文件里的 INCREMENT 和 DECREMENT 函数,这两个 函数返回的值就是我最开始所说的, dispatch 所接收的值,&lt;br/&gt;可以看到 type 即是判断的类型了,而 data 呢,就是组件 caculation.js 里的 input 的值;&lt;/p&gt;
&lt;p&gt;现在看中间件 middleINCRENT 这个函数,他是返回一个函数,而这个函数可以接受到两个参数,一个呢是 dispatch 函数,而另外一个呢是当前的 reducer 函数的值;&lt;/p&gt;
&lt;p&gt;通过学习这个组件, redux 的基本流程可以掌握了,当然实际项目中并不会这么简单,但是原理就是这样;&lt;/p&gt;
&lt;p&gt;最后我将这个 demo 放在了GitHub:&lt;a href=&quot;https://github.com/Grewer/reduxDemo&quot; class=&quot;uri&quot;&gt;https://github.com/Grewer/reduxDemo&lt;/a&gt;&lt;br/&gt;如果帮到了你,还请推荐或者 star;&lt;/p&gt;
&lt;p&gt;完;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jan 2018 14:47:00 +0000</pubDate>
<dc:creator>Grewer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Grewer/p/8280639.html</dc:identifier>
</item>
<item>
<title>【深度学习系列】关于PaddlePaddle的一些避“坑”技巧 - Charlotte77</title>
<link>http://www.cnblogs.com/charlotte77/p/8270710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlotte77/p/8270710.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;最近除了工作以外，业余在参加Paddle的AI比赛，在用Paddle训练的过程中遇到了一些问题，并找到了解决方法，跟大家分享一下：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PaddlePaddle的Anaconda的兼容问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　之前我是在服务器上安装的PaddlePaddle的gpu版本，我想把BROAD数据拷贝到服务器上面，结果发现我们服务器的22端口没开，不能用scp传上去，非常郁闷，只能在本地训练。本机mac的显卡是A卡，所以只能装cpu版本的，安装完以后，我发现运行一下程序的时候报错了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; paddle.v2 as paddle
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; paddle.init(use_gpu=False,trainer_count=1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;报错：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;Fatal Python error: PyThreadState_Get: no current thread
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Abort trap: 6
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;这让我非常郁闷，因为之前我直接在服务器上装没有问题，但是我的数据不能传上去，所以只能在本机装一个，直接pip install paddlepaddle，初始化报错。后来我发现我本机装了anaconda，用anaconda的python运行paddle会有一些小问题，不过可以使用otool 和 install_name_tool对_swig_paddle.so进行修改就可以：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.运行otool，可以看到pip安装之后的_swig_paddle.so依赖/usr/local/opt/python/Frameworks/Python.framework/Versions/2.7/Python，但实际系统中不存在该路径&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;otool -L /anaconda/lib/python2.7/site-packages/py_paddle/_swig_paddle.so
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; /anaconda/lib/python2.7/site-packages/py_paddle/&lt;span&gt;_swig_paddle.so:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1445.12&lt;span&gt;.0)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; /System/Library/Frameworks/Security.framework/Versions/A/Security (compatibility version 1.0.0, current version 58286.20.16&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;/usr/local/opt/python/Frameworks/Python.framework/Versions/2.7/Python (compatibility version 2.7.0, current version 2.7.0)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9&lt;span&gt;.0)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.0.0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;2.利用install_name_tool来替换依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; install_name_tool -change /usr/local/opt/python/Frameworks/Python.framework/Versions/2.7/Python &lt;span&gt;~/anaconda&lt;/span&gt;/lib/libpython2.7.dylib &lt;span&gt;~/anaconda&lt;/span&gt;/lib/python2.7/site-packages/py_paddle/_swig_paddle.so
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;3.替换成功后，可以看到第五条已经成功的换成anaconda下的路径了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;otool -L /anaconda/lib/python2.7/site-packages/py_paddle/_swig_paddle.so
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; /anaconda/lib/python2.7/site-packages/py_paddle/&lt;span&gt;_swig_paddle.so:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1445.12&lt;span&gt;.0)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; /System/Library/Frameworks/Security.framework/Versions/A/Security (compatibility version 1.0.0, current version 58286.20.16&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;/anaconda/lib/libpython2.7.dylib (compatibility version 2.7.0, current version 2.7.0)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9&lt;span&gt;.0)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.0.0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;现在再运行paddle.init就不会有问题了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  不过要注意一点的是：在第二步中，anaconda的路径要写绝对路径。不能直接进去到anacona的上层目录后直接写/anaconda/lib...，如果这样做，那么你换一个路径再执行paddle.init还是会有问题，因为找不到你的anaconda的路径。&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;PaddlePaddle数据类型与数据读取&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我在这篇文章“&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/charlotte77/p/7802226.html&quot;&gt;&lt;span&gt;【深度学习系列】PaddlePaddle之数据预处理&lt;/span&gt;&lt;/a&gt;”中写过PaddlePaddle的基本数据类型与如何用自己的数据集进行训练，但是还有很多同学给我发邮件问我这方面的问题，说在处理自己数据集的时候遇到了很多问题。下面我总结一下几个被问到的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;1.不明白什么时候用sequence数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们知道paddle有四种数据类型：dense_vector、sparse_binary_vector、sparse_float_vector和integer，但是还有三种序列格式，对于dense_vector的话，它的序列格式是dense_vector_sequence，但是什么时候用dense_vector_sequence呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你的数据是x = [1.0,2.0,3.0,4.0]这样的，那么就应该用dense_vector，维度即为输入数据的维度（这里我们假设是4），那么应该设置为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　x = paddle.layer.data(name='x', type=paddle.data_type.dense_vector(4))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你的数据是x = [ [1.0,2.0], [2.0,3.0], [3.0,4.0]]，那么我们可以看到这个数据有三个时间步长，每个时间步的向量维度是2，应该设置为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　x = paddle.layer.data(name='x', type=paddle.data_type.dense_vector_sequence(2))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　同理，interger_value和interger_value_sequence也是同样的处理方法，只不过向量里的元素由dense_vector中的float换成了int。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;span&gt;2.不知道如何创建reader&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在数据预处理那篇文章中举了两个例子来说明如何创建自己的数据集，包括三种方式：reader、reader_creator和reader_decorator，针对于这个比赛，我们将数据解析后，转换成data和label的形式，那么我们应该如何创建reader呢？其实有很多种方式，写一个最简单的方式。我们来创建一个reader creator：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; reader_creator(data,label):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; reader():
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xrange(len(data)):
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; data[i,:],int(label[i])
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; reader
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　在这里可以看到，使用了yield生成器来生成数据，分别生成同一个sample的data和label，返回的是一个reader函数，方便我们后面train的时候灌入数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然也有其他的方式可以创建，大家可以自行发挥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;3.不知道怎么用创建好的reader训练&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　大家可能会觉得很奇怪，为什么我们创建了reader creator后要返回一个reader函数呢，其实我们是为了方便在训练的时候调用，下面创建一个train_reader&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
train_reader =&lt;span&gt; paddle.batch(paddle.reader.shuffle(
                reader_creator(data,label),buf_size&lt;/span&gt;=200&lt;span&gt;),
                batch_size&lt;/span&gt;=16)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;我们上一步创建好的reader返回的数据放到paddle.reader.shuffle里进行数据混洗，就是把数据打散，buf_size表示我一次性把多少条数据放进来进行shuffle，可以自行设置，混洗好的数据放到paddle.batch里进行，以batch_size的量级批量灌倒模型里去训练，注意如果使用sgd的话，batch_size不能设置的太大，会崩溃，亲测 = =！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　同理，我们也可以创建val_reader，test_reader。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　创建完后，就可以放到trainer里训练了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
trainer.train(reader=train_reader,num_passes=20,event_handler=event_handler)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;还有一些关于模型训练的参数设置技巧大家可以多尝试，如果有很多相同的问题话，我会再总结了发出来。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 13 Jan 2018 13:21:00 +0000</pubDate>
<dc:creator>Charlotte77</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlotte77/p/8270710.html</dc:identifier>
</item>
<item>
<title>SQL Server-聚焦WHERE Column=@Param OR @Param IS NULL有问题？ - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/8280460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/8280460.html</guid>
<description>&lt;p&gt;上一篇我们讲完SQL动态查询，本节我们继续来讲解SQL动态查询中存在的问题。&lt;/p&gt;
&lt;h2 id=&quot;sql动态查询条件筛选过滤&quot;&gt;SQL动态查询条件筛选过滤&lt;/h2&gt;
&lt;p&gt;当我们创建存储过程调用存储过程时，若筛选条件有值则过滤，没有值则返回所行记录，类似如下查询：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt; (SomeColumn=@col &lt;span class=&quot;kw&quot;&gt;OR&lt;/span&gt; @col &lt;span class=&quot;kw&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样查询会存在什么问题呢？性能会不会有问题呢，这个是我们本节需要深入探讨的问题。&lt;/p&gt;
&lt;p&gt;接下来我们创建如下测试表并插入测试数据，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;TABLE&lt;/span&gt; Test
    (
      SomeCol1 &lt;span class=&quot;dt&quot;&gt;INT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; ,
      Somecol2 &lt;span class=&quot;dt&quot;&gt;INT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;
    )
 
&lt;span class=&quot;kw&quot;&gt;INSERT&lt;/span&gt;  Test
        &lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;number&lt;/span&gt; ,
                low
        &lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt;    master..spt_values
        &lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt;   &lt;span class=&quot;kw&quot;&gt;TYPE&lt;/span&gt; = &lt;span class=&quot;st&quot;&gt;'p'&lt;/span&gt;
 
 
&lt;span class=&quot;kw&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;INDEX&lt;/span&gt; ix_col2 &lt;span class=&quot;kw&quot;&gt;ON&lt;/span&gt; Test(Somecol2)
GO&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于动态SQL条件筛选过滤我们利用WHERE 1 = 1来拼接。接下来我们使用一般SQL语句和动态查询并比较其IO，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;STATISTICS&lt;/span&gt; IO &lt;span class=&quot;kw&quot;&gt;ON&lt;/span&gt;
GO
 
&lt;span class=&quot;kw&quot;&gt;DECLARE&lt;/span&gt; @col &lt;span class=&quot;dt&quot;&gt;INT&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; @col = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
 
&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; SomeCol2 
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; Test
&lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; =&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;AND&lt;/span&gt;  (SomeCol2=@col &lt;span class=&quot;kw&quot;&gt;OR&lt;/span&gt; @col &lt;span class=&quot;kw&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;)
 
GO
 
&lt;span class=&quot;kw&quot;&gt;DECLARE&lt;/span&gt; @col &lt;span class=&quot;dt&quot;&gt;INT&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; @col = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
 
&lt;span class=&quot;kw&quot;&gt;DECLARE&lt;/span&gt; @SQL &lt;span class=&quot;dt&quot;&gt;NVARCHAR&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4000&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;SET&lt;/span&gt; @SQL = &lt;span class=&quot;st&quot;&gt;'SELECT SomeCol2 &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;                FROM Test&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;                WHERE 1 =1'&lt;/span&gt;
 
&lt;span class=&quot;kw&quot;&gt;IF&lt;/span&gt; @col &lt;span class=&quot;kw&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; 
    &lt;span class=&quot;kw&quot;&gt;SET&lt;/span&gt; @SQL = @SQL + &lt;span class=&quot;st&quot;&gt;' AND SomeCol2=@InnerParamcol '&lt;/span&gt;
    
&lt;span class=&quot;kw&quot;&gt;EXEC&lt;/span&gt; sp_executesql @SQL,N&lt;span class=&quot;st&quot;&gt;'@InnerParamcol INT'&lt;/span&gt;,@col
 
&lt;span class=&quot;kw&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;STATISTICS&lt;/span&gt; IO &lt;span class=&quot;kw&quot;&gt;OFF&lt;/span&gt;
GO&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180113203545160-992054557.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180113203554863-1997298890.png&quot;/&gt;&lt;br/&gt;我们能够看到动态SQL查询逻辑读取只读取2次，而另外一般SQL语句查询逻辑读取7次，同时我们看到SQL动态查询计划执行的是索引查找，而一般SQL语句则是索引扫描。&lt;/p&gt;
&lt;p&gt;看来执行一般SQL语句不会走索引查找，将导致性能问题，在开头我们就讲过筛选条件有值则过滤，无值则查询所有数据，那么我们完全可以借助ISNULL来查询，下面我们用ISNULL来改变一般语句筛选条件，看看是否会走索引查找呢？&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;STATISTICS&lt;/span&gt; IO &lt;span class=&quot;kw&quot;&gt;ON&lt;/span&gt;
GO
 
&lt;span class=&quot;kw&quot;&gt;DECLARE&lt;/span&gt; @col &lt;span class=&quot;dt&quot;&gt;INT&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; @col = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
 
&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; SomeCol2
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; dbo.Test
&lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;AND&lt;/span&gt;  SomeCol2 = ISNULL(@col,SomeCol2)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180113211016535-1437151193.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180113211030129-1388767968.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到结果依然是走索引扫描，没有任何改变。是不是就没有解决之道了呢？我们来改变一般SQL语句查询方式，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;DECLARE&lt;/span&gt; @col &lt;span class=&quot;dt&quot;&gt;INT&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; @col = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;IF&lt;/span&gt; @Col &lt;span class=&quot;kw&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt;  SomeCol2
    &lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt;    Test
    &lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt;   &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;ELSE&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt;  SomeCol2
    &lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt;    dbo.Test
    &lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt;   &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;AND&lt;/span&gt; SomeCol2 = @col

GO&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上只能是勉勉强强解决了问题，因为只是针对一个参数，如果有多个参数要进行IF...ELSE..,那可就傻逼了。从本质上解决这个问题我们需要利用可选项重新编译。如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;STATISTICS&lt;/span&gt; IO &lt;span class=&quot;kw&quot;&gt;ON&lt;/span&gt;
GO
 
&lt;span class=&quot;kw&quot;&gt;DECLARE&lt;/span&gt; @col &lt;span class=&quot;dt&quot;&gt;INT&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; @col = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
 
&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; SomeCol2 
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; dbo.Test
&lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; =&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;AND&lt;/span&gt;  (SomeCol2 = @col &lt;span class=&quot;kw&quot;&gt;OR&lt;/span&gt; @col &lt;span class=&quot;kw&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;OPTION&lt;/span&gt;(RECOMPILE)
 
 
GO
 
&lt;span class=&quot;kw&quot;&gt;DECLARE&lt;/span&gt; @col &lt;span class=&quot;dt&quot;&gt;INT&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; @col = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
 
&lt;span class=&quot;kw&quot;&gt;DECLARE&lt;/span&gt; @SQL &lt;span class=&quot;dt&quot;&gt;NVARCHAR&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4000&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;SET&lt;/span&gt; @SQL = &lt;span class=&quot;st&quot;&gt;'SELECT SomeCol2 &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;                FROM dbo.Test&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;                WHERE 1 =1'&lt;/span&gt;
 
&lt;span class=&quot;kw&quot;&gt;IF&lt;/span&gt; @col &lt;span class=&quot;kw&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; 
    &lt;span class=&quot;kw&quot;&gt;SET&lt;/span&gt; @SQL = @SQL + &lt;span class=&quot;st&quot;&gt;' AND SomeCol2 = @InnerParamcol '&lt;/span&gt;
    
    
    
&lt;span class=&quot;kw&quot;&gt;EXEC&lt;/span&gt; sp_executesql @SQL,N&lt;span class=&quot;st&quot;&gt;'@InnerParamcol INT'&lt;/span&gt;,@col
 
&lt;span class=&quot;kw&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;STATISTICS&lt;/span&gt; IO &lt;span class=&quot;kw&quot;&gt;OFF&lt;/span&gt;
GO&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180113211049676-869522275.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180113211057144-879459216.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当利用条件筛选过滤数据时，如果条件有值则过滤，否则返回所有行记录。如果执行一般SQL语句和动态SQL，那么动态SQL会走索引查找，而一般SQL语句将导致索引扫描，此时需要加上OPTION(RECOMPILE)才走索引查找。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 13 Jan 2018 13:14:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/8280460.html</dc:identifier>
</item>
<item>
<title>4、ABPZero系列教程之拼多多卖家工具 集成短信发送模块 - 李子深</title>
<link>http://www.cnblogs.com/shensigzs/p/8280542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shensigzs/p/8280542.html</guid>
<description>&lt;p&gt;　　ABPZero并没有手机短信发送功能，现在我们来集成一个，为后面注册、登录作铺垫。&lt;/p&gt;

&lt;p&gt;首先需要在阿里云开通短信服务，&lt;a href=&quot;https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=39yy18gg&amp;amp;productCode=newdysmsbag&amp;amp;utm_source=39yy18gg&quot; target=&quot;_blank&quot;&gt;连接地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开通后，在签名管理中添加一个签名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/488385/201801/488385-20180113210840629-772156247.jpg&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在模板管理中添加一个模板，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/488385/201801/488385-20180113200128769-154901415.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后需要使用阿里云提供的.NET发送短信类库，下面可以直接下载我上传的类库，也可以去官方下载，然后提取我所说的2个类库（aliyun-net-sdk-core.dll、aliyun-net-sdk-dysmsapi.dll）&lt;/p&gt;
&lt;p&gt;直接下载文件：&lt;a href=&quot;https://files.cnblogs.com/files/shensigzs/aliyun-net-sdk.zip&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/shensigzs/aliyun-net-sdk.zip&lt;/a&gt; （&lt;span&gt;里面包含2个类库，把这2个类库引用到Core项目&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;.NET发送短信SDK:https://help.aliyun.com/document_detail/59836.html?spm=5176.doc55284.6.573.GaNxg6&lt;/p&gt;

&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;使用的模块是Abp.Net.Sms，源码地址：https://github.com/berkaroad/Abp.Net.Sms&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/488385/201801/488385-20180113203303394-187436478.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;添加AliDayuSmsSender类，实现2个方法（一个同步、一个异步）&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Core\Authorization\Users\AliDayuSmsSender.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Abp.Dependency;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Abp.Net.Sms;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Abp.UI;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Aliyun.Acs.Core;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Aliyun.Acs.Core.Exceptions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Aliyun.Acs.Core.Profile;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Aliyun.Acs.Dysmsapi.Model.V20170525;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Castle.Core.Logging;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; MyCompanyName.AbpZeroTemplate.Authorization.Users
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AliDayuSmsSender : SmsSenderBase, ITransientDependency
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IClientProfile profile = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ILogger Logger { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AliDayuSmsSender(ISmsSenderConfiguration configuration) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(configuration)
        {
            Logger &lt;/span&gt;=&lt;span&gt; NullLogger.Instance;
            profile &lt;/span&gt;= DefaultProfile.GetProfile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cn-hangzhou&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, configuration.GetAppKey(), configuration.GetAppSecret());
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SendSms(SmsMessage sms)
        {

            DefaultProfile.AddEndpoint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cn-hangzhou&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cn-hangzhou&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dysmsapi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dysmsapi.aliyuncs.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            IAcsClient acsClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultAcsClient(profile);
            SendSmsRequest request &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SendSmsRequest();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填:待发送手机号。支持以逗号分隔的形式进行批量调用，批量上限为1000个手机号码,批量调用相对于单条调用及时性稍有延迟,验证码类型的短信推荐使用单条调用的方式&lt;/span&gt;
                request.PhoneNumbers =&lt;span&gt; sms.To;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填:短信签名-可在短信控制台中找到&lt;/span&gt;
                request.SignName =&lt;span&gt; sms.FreeSignName;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填:短信模板-可在短信控制台中找到&lt;/span&gt;
                request.TemplateCode = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(sms.TemplateCode)
                    &lt;/span&gt;?&lt;span&gt; _configuration.GetDefaultSmsTemplateCode()
                    : sms.TemplateCode;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可选:模板中的变量替换JSON串,如模板内容为&quot;亲爱的${name},您的验证码为${code}&quot;时,此处的值为&lt;/span&gt;
                request.TemplateParam =&lt;span&gt; sms.TemplateParams;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;request.OutId = &quot;yourOutId&quot;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求失败这里会抛ClientException异常&lt;/span&gt;
                SendSmsResponse sendSmsResponse =&lt;span&gt; acsClient.GetAcsResponse(request);
                Logger.Info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发送返回：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; sendSmsResponse.Message);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ServerException e)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UserFriendlyException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;短信发送失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;to:{0},errCode:{1},errMsg:{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        sms.To,
                        e.ErrorCode,
                        e.Message)));
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClientException e)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UserFriendlyException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;短信发送失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;to:{0},errCode:{1},errMsg:{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        sms.To,
                        e.ErrorCode,
                        e.Message)));
            }

        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task SendSmsAsync(SmsMessage sms)
        {
            DefaultProfile.AddEndpoint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cn-hangzhou&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cn-hangzhou&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dysmsapi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dysmsapi.aliyuncs.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task = &lt;span&gt;new&lt;/span&gt; Task(() =&amp;gt;&lt;span&gt;
            {
                IAcsClient acsClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultAcsClient(profile);
                SendSmsRequest request &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SendSmsRequest();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填:待发送手机号。支持以逗号分隔的形式进行批量调用，批量上限为1000个手机号码,批量调用相对于单条调用及时性稍有延迟,验证码类型的短信推荐使用单条调用的方式&lt;/span&gt;
                    request.PhoneNumbers =&lt;span&gt; sms.To;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填:短信签名-可在短信控制台中找到&lt;/span&gt;
                    request.SignName =&lt;span&gt; sms.FreeSignName;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填:短信模板-可在短信控制台中找到&lt;/span&gt;
                    request.TemplateCode = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(sms.TemplateCode)
                        &lt;/span&gt;?&lt;span&gt; _configuration.GetDefaultSmsTemplateCode()
                        : sms.TemplateCode;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可选:模板中的变量替换JSON串,如模板内容为&quot;亲爱的${name},您的验证码为${code}&quot;时,此处的值为&lt;/span&gt;
                    request.TemplateParam =&lt;span&gt; sms.TemplateParams;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;request.OutId = &quot;yourOutId&quot;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求失败这里会抛ClientException异常&lt;/span&gt;
                    SendSmsResponse sendSmsResponse =&lt;span&gt; acsClient.GetAcsResponse(request);
                    Logger.Info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发送返回：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; sendSmsResponse.Message);
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ServerException e)
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UserFriendlyException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;短信发送失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;to:{0},errCode:{1},errMsg:{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            sms.To,
                            e.ErrorCode,
                            e.Message)));
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClientException e)
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UserFriendlyException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;短信发送失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;to:{0},errCode:{1},errMsg:{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            sms.To,
                            e.ErrorCode,
                            e.Message)));
                }
            });


            task.Start();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; task;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改AppSettingProvider.cs，在return new[]里面添加如下代码&lt;/p&gt;
&lt;p&gt;文件路径：D:\abpweb\PddSellerAssistant\PddSellerAssistant.Core\Configuration\AppSettingProvider.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
                   {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sms config&lt;/span&gt;
                        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SettingDefinition(SmsSettingNames.ServiceUrl,
                            ConfigurationManager.AppSettings[SmsSettingNames.ServiceUrl] &lt;/span&gt;?? &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;),
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SettingDefinition(SmsSettingNames.AppKey,
                            ConfigurationManager.AppSettings[SmsSettingNames.AppKey] &lt;/span&gt;?? &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;),
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SettingDefinition(SmsSettingNames.AppSecret,
                            ConfigurationManager.AppSettings[SmsSettingNames.AppSecret] &lt;/span&gt;?? &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;),
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SettingDefinition(SmsSettingNames.DefaultFreeSignName,
                            ConfigurationManager.AppSettings[SmsSettingNames.DefaultFreeSignName] &lt;/span&gt;?? &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;),
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SettingDefinition(SmsSettingNames.DefaultSmsTemplateCode,
                            ConfigurationManager.AppSettings[SmsSettingNames.DefaultSmsTemplateCode] &lt;/span&gt;?? &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;),
                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Host settings&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 修改web.config，添加如下配置节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 短信api配置开始&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;Abp.Net.Sms.AppKey&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;Abp.Net.Sms.AppSecret&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;Abp.Net.Sms.DefaultFreeSignName&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;填写签名名称&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;Abp.Net.Sms.DefaultSmsTemplateCode&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;填写模板ID&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;Abp.Net.Sms.ServiceUrl&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 短信api配置结束&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; AppKey、AppSecret都可以在阿里云后台获取&lt;/p&gt;

&lt;p&gt; 修改AbpZeroTemplateCoreModule，代码修改如下&lt;/p&gt;
&lt;p&gt; 文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Core\AbpZeroTemplateCoreModule.cs&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DebugHelper.IsDebug)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调试模式禁用邮件发送
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IocManager.Register&amp;lt;IEmailSender, NullEmailSender&amp;gt;(DependencyLifeStyle.Transient);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调试模式禁用手机短信发送
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IocManager.Register&amp;lt;ISmsSender, NullSmsSender&amp;gt;(DependencyLifeStyle.Transient);&lt;/span&gt;
            }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 可以看到我都备注掉，因为我就是要在调试模式下测试邮件、短信是否能够发送。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[DependsOn(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(AbpZeroCoreModule),
       &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(AbpZeroLdapModule),
       &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(AbpAutoMapperModule),
       &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(AbpNetSmsModule)
       )]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 此处是添加短信模块依赖&lt;/p&gt;

&lt;p&gt;添加文件ISmsMessageService.cs&lt;/p&gt;
&lt;p&gt; 文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Application\Authorization\Users\ISmsMessageService.cs&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ISmsMessageService : IApplicationService
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Send(&lt;span&gt;string&lt;/span&gt; to, &lt;span&gt;string&lt;/span&gt; templateCode, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; templateParams);
        Task SendAsync(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; to, &lt;span&gt;string&lt;/span&gt; templateCode, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; templateParams);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再添加实现文件SmsMessageService.cs&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Application\Authorization\Users\SmsMessageService.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SmsMessageService: ISmsMessageService
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ISmsSender _smsSender;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SmsMessageService(ISmsSender smsSender)
        {
            _smsSender &lt;/span&gt;=&lt;span&gt; smsSender;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Send(&lt;span&gt;string&lt;/span&gt; to, &lt;span&gt;string&lt;/span&gt; templateCode, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; templateParams)
        {
            _smsSender.Send(to, templateCode, templateParams);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task SendAsync(&lt;span&gt;string&lt;/span&gt; to, &lt;span&gt;string&lt;/span&gt; templateCode, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; templateParams)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _smsSender.SendAsync(to, templateCode, templateParams);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，生成项目&lt;/p&gt;
&lt;p&gt;浏览器打开：http://localhost:8088/swagger/ui/index（8088是IIS配置的端口）&lt;/p&gt;
&lt;p&gt;找到app_smsMessageService服务进行测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/488385/201801/488385-20180113210223722-349104105.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/488385/201801/488385-20180113210257254-1979563525.jpg&quot; alt=&quot;&quot; width=&quot;350&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同步、异常都测试通过，至此手机短信发送模块集成完成。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/shensigzs/p/8277860.html&quot; target=&quot;_blank&quot;&gt;返回总目录&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 13 Jan 2018 13:11:00 +0000</pubDate>
<dc:creator>李子深</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shensigzs/p/8280542.html</dc:identifier>
</item>
<item>
<title>编码与模式------《Designing Data-Intensive Applications》读书笔记5 - HappenLee</title>
<link>http://www.cnblogs.com/happenlee/p/8280374.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/happenlee/p/8280374.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;进入到第四章了，本篇主要聊的点是编码（也就是&lt;strong&gt;序列化&lt;/strong&gt;）与代码升级的一些场景，来梳理存储之中涉及到的编解码的流程。目前主流的编解码便是来自Apache的&lt;strong&gt;Avro&lt;/strong&gt;，来自Facebook的&lt;strong&gt;Thrift&lt;/strong&gt;与Google的&lt;strong&gt;Protocolbuf&lt;/strong&gt;，在本篇之中，我们也会一一梳理各种编码的优点与痛点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;非二进制的编码格式&quot;&gt;1.非二进制的编码格式&lt;/h4&gt;
&lt;p&gt;程序通常以至少两种不同的表示方式处理数据：&lt;/p&gt;
&lt;p&gt;1、在内存中，数据是保存在对象、结构、列表、数组、哈希表、树、等等。这些数据结构在内存之中被优化为CPU可以高效访问和操作的结构（&lt;strong&gt;通常这是操作系统的任务，并不需要程序员操心&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;2、而当你想把数据写入一个文件或者通过网络发送它时，你必须把它编码成某种形式的字节序列（&lt;strong&gt;例如，一个JSON文档&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;因此，我们需要两种形式之间的某种转换。（内存与其他位置）翻译从内存中表示的数据称之为编码（也称为序列化），反之称为解码（反序列化）。&lt;/p&gt;
&lt;p&gt;通常编码有如下几种格式：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;&lt;strong&gt;特定的语言格式&lt;/strong&gt;&lt;br/&gt;许多编程语言都对编码有内置的支持，用于将内存对象编码成字节序列。例如：Java的&lt;strong&gt;java.io.Serializable&lt;/strong&gt; , Ruby的&lt;strong&gt;Marshal&lt;/strong&gt;, Python的&lt;strong&gt;pickle&lt;/strong&gt;。但是这些编程语言内置的库存在一些深层次的问题。&lt;/li&gt;
&lt;li&gt;编码通常与特定的编程语言捆绑在一起，用另一种语言读取数据是非常困难的&lt;/li&gt;
&lt;li&gt;为了在同一对象类型中恢复数据，解码过程需要能够实例化任意类，如果攻击者可以让您的应用程序解码任意字节序列，则它们可以实例化任意类。这常常是安全问题的来源。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;效率（用于编码或解码的CPU时间，以及编码结构的大小），java内置编码库臭名昭著的就是其糟糕的表现和臃肿的编码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JSON、XML与CSV&lt;/strong&gt;&lt;br/&gt;上面这几种格式，也是我们在编码之中常见到的。&lt;/li&gt;
&lt;li&gt;XML的描述十分精准，但是因过于冗长。&lt;/li&gt;
&lt;li&gt;JSON的流行主要归功于它在Web浏览器中的内置支持（由于它是JavaScript的一个子集）和相对于XML的简单性。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CSV是另一种流行的与语言无关的格式，尽管功能不强。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JSON、XML和CSV都是文本格式，因此都具有一定的可读性。但他们也有如下一些微妙的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关于数字的编码有很多歧义。在XML和CSV中，不能区分恰好由数字组成的数字和字符串（除了引用外部模式）。JSON区分字符串和数字，但它不区分整数和浮点数，也不能确认精度。&lt;/li&gt;
&lt;li&gt;JSON与XML为Unicode字符串的支持，但他们不支持二进制字符串（字节序列没有字符编码）。&lt;/li&gt;
&lt;li&gt;对于XML和JSON，都有可选的模式支持。这些模式语言非常强大，因此学习和实现起来相当复杂。而CSV没有任何模式，因此需要应用程序定义每个行和列的含义。如果应用程序添加了新行或列，则必须手动处理该更新。CSV是一个相当模糊的格式（出于是分隔符的原因）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;二进制的编码格式&quot;&gt;2.二进制的编码格式&lt;/h4&gt;
&lt;p&gt;二进制的编码格式通常是最紧凑的编码格式，对于一个小的数据集，编码大小的收益是微不足道的，但一旦进入百万兆字节的数据集，数据格式的选择就会有很大的影响了。接下来我们来看一个通过JSON描述的数据结构：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-d62deda3a61020a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;使用JSON描述的数据结构&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MessagPack&lt;/strong&gt;&lt;br/&gt;我们来看看通过MessagePack进行二进制编码之后的JSON格式：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-3b5062e9ae394afc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;通过MessagePack进行编码后的二进制格式&quot;/&gt;&lt;br/&gt;二进制编码长度为66个字节，这仅比81字节的文本JSON编码小了一点。通过这样的空间减少便丧失了可读性的保障，我们来看看有木有更优秀的解决方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Thrift&lt;/strong&gt;&lt;br/&gt;在Thrift中的数据进行编码，需要预先在Thrift接口定义语言（IDL）中描述这样的模式：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-1aaa2401441adf74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;通过IDL描述Thrift的数据格式&quot;/&gt;&lt;br/&gt;在Thrift之中存在两种不同的二进制编码格式，一种是直接使用二进制编码的&lt;strong&gt;Binary&lt;/strong&gt;格式，另一种则是使用压缩之后的&lt;strong&gt;Compact&lt;/strong&gt;格式，我们来一一看两者的区别。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-2906f00215b576db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Binary格式&quot;/&gt;&lt;br/&gt;Binary格式编码之后为59个字节大小，并且每个字段都有一个类型注释（用于指示它是字符串、整数、列表等），并在需要时指定长度指示（字符串的长度、列表中项的数量）。但是和MessagePack相比就省去了字段名等信息，取而代之的是字段标记（1,2和3），这些是出现在模式定义中的数字。字段标记类似于字段别名，它们是一种简洁的方式来描述我们所谈论的字段，而不必拼写字段名称。从而减少了二进制编码的大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-9e070eb72957c497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Compact格式&quot;/&gt;&lt;br/&gt;Compact格式它包含相同的信息只有34个字节。它通过将字段类型和标记号打包成一个字节，并使用可变长度整数来实现这一点。它不是为1337号使用八个完整的字节，而是用两个字节编码，每个字节的最高位用来指示是否还有更多的字节要来。这意味着64到63之间的数字用一个字节编码，8192到8191之间的数字用两个字节编码，较大的数字使用更多字节。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;ProtocolBuf&lt;/strong&gt;&lt;br/&gt;Protocolbuf（只有一个二进制编码格式）相同的数据编码如下图所示。它位包装略有不同，但Thrift的Compact格式大同小异。Protobuf以33字节匹配相同的记录。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-b30898fb38088d37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ProtocolBuf的编码格式&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Avro&lt;/strong&gt;&lt;br/&gt;Avro是一个二进制编码格式，它是发源于开源项目Hadoop，来作为Thrift的替换方案存在的，我们来看看通过Avro编码之后的记录，又是怎么样的呢？&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-5cd981e6301893c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Avro的编码格式&quot;/&gt;&lt;br/&gt;在Avro模式之中没有标记号。将同样的数据进行编码，Avro二进制编码是32个字节长，是上述编码之中最紧凑的。检查上述的字节序列，并没有标识字段或数据类型。编码简单地由连接在一起的值组成。在解析二进制数据时，通过使用模式来确定每个字段的数据类型。这意味着如果读取数据的代码与写入数据的代码使用完全相同的模式，二进制数据才能被正确地解码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;模式升级与演化&quot;&gt;3.模式升级与演化&lt;/h4&gt;
&lt;p&gt;随着应用程序的开发，模式不可避免地需要随着时间而改变。而在这个过程之中，二进制编码同时保持向后和向前兼容性呢？&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li&gt;字段标记&lt;/li&gt;
&lt;li&gt;从示例中可以看到，编码的记录只是编码字段的串联。每个字段由标签号码和注释的数据类型识别（如字符串或整数）。如果没有设置字段值，则只需从已编码的记录中省略该字段值。因此字段标记对编码数据的含义至关重要。我们可以更改模式中字段的名称，因为编码的数据从不引用字段名称，但不能更改字段的标记，因为这将使所有现有编码数据无效。&lt;/li&gt;
&lt;li&gt;可以通过添加一个新的标记号的方式向模式添加新字段。如果旧代码（不知道您添加的新标记号）试图读取由新代码编写的数据，包括一个新字段，该字段的标记号不识别，它可以简单地忽略该字段。数据类型注释允许分析器来确定需要跳过多少字节。因为每个字段都有唯一的标记号，新代码可以无缝连接旧的数据，因为标记号仍然具有相同的含义。但是，如果是添加了一个新字段，则不能使它成为必需字段。如果要添加一个字段并使其成为必需的字段，那么如果新代码读取旧代码编写的数据，则该检查将失败，因为旧代码将不会写入您添加的新字段。因此，为了保持向后兼容性，在初始部署模式之后添加的每个字段必须是可选的或具有默认值。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;删除字段就像添加字段一样，这意味着只能删除一个可选的字段（必填字段不能被删除），而且您不能再次使用相同的标记号（因为您可能还有一个包含旧标记号的数据，该字段必须被新代码忽略）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;数据类型&lt;br/&gt;如何改变字段的数据类型？例如，将32位整数转换为64位整数。新代码可以很容易地读取旧代码编写的数据，因为解析器可以用零填充任何丢失的位。但是，如果旧代码读取由新代码编写的数据，旧代码仍然使用32位变量来保存值。如果解码的64位值不适合32位，会被截断。&lt;br/&gt;Protocolbuf并没有一个列表或数组的数据类型，而是有一个重复的标记字段。可以将可选的（单值）字段转换为重复的（多值）字段。读取旧数据的新代码看到一个具有零个或一个元素的列表（取决于字段是否存在）；读取新数据的旧代码只看到列表的最后一个元素。而Thrift有一个专门的列表数据类型，这是参数列表中的数据类型。这不允许像Protocolbuf那样从单值到多值的升级，但它具有支持嵌套列表的优点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;动态生成模式&lt;br/&gt;Avro最大的特点是支持了动态生成模式，它的核心思想是编码者与解码者的模式可以不同，事实上他们只需要兼容就可以了。相比于Protocolbuf和Thrift，它并不包含任何标签数字。每当数据库模式发生变化时，管理员必须手动更新从数据库列名到字段标记的映射。而Avro是每次运行时简单地进行模式转换。任何读取新数据文件的程序都会感知到记录的字段发生了变化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;小结&quot;&gt;4.小结&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;编码的细节不仅影响到工作效率，更重要的是会影响到应用程序和软件的架构。Prorotocol Buf，Thrift 与 Avro，都使用一个模式来描述一个二进制编码格式。它们的模式语言比XML模式或JSON模式要简单得多，它支持更详细的验证规则，并且能够更好的进行模式的演化升级，在性能上也有了更好的提升。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jan 2018 11:46:00 +0000</pubDate>
<dc:creator>HappenLee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/happenlee/p/8280374.html</dc:identifier>
</item>
<item>
<title>通过Chocolatey软件包管理器安装.NET Core - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/8280340.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/8280340.html</guid>
<description>&lt;p&gt;在Linux的世界里，有了yum/apt-get百分之九十的软件都可以通过它来安装管理。但是在Windows系统上，装个软件还是挺折腾的。比如我要装个Chrome浏览器，我先得打开IE浏览器吧，我还打不开Chrome的官网吧，得百度吧，。没经验的兄弟还要被那些坑二婶的广告链接忽悠一下吧。用某卫士或者某管家的美女，你们有福可以统一管理，统一安装。当然Windows上现在也有了专门负责软件包管理的&lt;strong&gt;Chocolatey。&lt;/strong&gt;今天我们就来演示下如何通过Chocolatey安装.NET Core的最新版本。&lt;/p&gt;
&lt;h4&gt;1. 安装&lt;/h4&gt;
&lt;p&gt;Chocolatey的安装过程简单至极，在&lt;a href=&quot;http://chocolatey.org/&quot;&gt;Chocolatey.org&lt;/a&gt;上最醒目的地方有一行命令，把它复制到命令行中运行，只要一分钟左右，安装就完成了。用管理员权限运行命令行，在命令下键入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))&quot; &amp;amp;&amp;amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
可以验证安装是否成功。
&lt;/pre&gt;
&lt;p&gt;C:\WINDOWS\system32&amp;gt;chocolatey -help&lt;br/&gt;This is a listing of all of the different things you can pass to choco.&lt;/p&gt;
&lt;p&gt;这里我们可以看到chocllatey的命令行就是choco：&lt;/p&gt;
&lt;h4&gt;2. 初体验&lt;/h4&gt;
&lt;p&gt;默认情况下，Chocolatey会把自己安装到C:\ProgramData\chocolatey 目录下。该目录下还有三个主要子目录，它们的作用分别是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bin - Chocolatey自身的命令，以及通过Chocolatey安装的某些软件会在bin下增加一个*.bat的快捷方法。&lt;/li&gt;
&lt;li&gt;logs- Chocolatey运行时的程序以及各种log。&lt;/li&gt;
&lt;li&gt;lib - 安装过程中下载的包。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/510/201801/510-20180113192338941-24429235.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/510/201801/510-20180113192339488-991941937.png&quot; alt=&quot;image&quot; width=&quot;338&quot; height=&quot;139&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完成后就可以在命令行使用choco命令安装软件，像apt-get或npm一样方便了，是时候尝试一下Chocolatey的威力了，在命令行上键入【&lt;a title=&quot;https://chocolatey.org/packages/dotnetcore/&quot; href=&quot;https://chocolatey.org/packages/dotnetcore/&quot;&gt;https://chocolatey.org/packages/dotnetcore/&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;choco upgrade dotnetcore&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/510/201801/510-20180113192339863-481640420.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/510/201801/510-20180113192340144-1464128315.png&quot; alt=&quot;image&quot; width=&quot;345&quot; height=&quot;305&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就可以自动安装dotnet core了。&lt;/p&gt;
&lt;p&gt;如不知道该如何安装需要的软件，可以先在&lt;a href=&quot;https://chocolatey.org/packages&quot;&gt;packages页面&lt;/a&gt;搜索，然后按提示在命令行进行安装。&lt;/p&gt;
&lt;h4&gt;3. 安装自己的包&lt;/h4&gt;
&lt;p&gt;Chocoletay包一个满足特定目录结构的NuGet包。&lt;a href=&quot;http://nuget.org/&quot;&gt;NuGet&lt;/a&gt;是另一个Windows上令人心动的工具，它是一种特定的包格式，类似于.deb .rpm，同时它也具有版本化的包管理功能。与Chocolatey的不同在于，NuGet关注在开发人员使用的包，而Chocoletay更关注最终用户可用的软件包。既然Chocolatey包就是NuGet包，如果你没有安装NuGet没有关系，Chocolatey包含了一个NuGet的二进制执行文件，可以使用命令choco pack， 具体请看&lt;a title=&quot;https://chocolatey.org/docs/create-packages&quot; href=&quot;https://chocolatey.org/docs/create-packages&quot;&gt;https://chocolatey.org/docs/create-packages&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jan 2018 11:24:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/8280340.html</dc:identifier>
</item>
<item>
<title>当初我为什么要去创业公司呢？ - 沧海粟</title>
<link>http://www.cnblogs.com/dylancao/p/8280191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dylancao/p/8280191.html</guid>
<description>&lt;p&gt;　　在最近反思的过程中，我一直在问自己这个问题。当初是什么原因驱使着我，一定要挤进小的创业公司呢？ 是深思熟虑？还是头脑发热？ 是向往金科铁马的战场？还是向往纸醉金迷的生活？&lt;br/&gt;还记得那个夏天，天很热很热，热的太阳就快掉下来了。在火热的夕阳的余晖下，我和前领导的对话历历在目：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　一定要走吗？在这里我待你咋样？ XX总，在这里，要不是跟着你，我不会有今天的待遇，也不会进步那么快，我对你十分敬重。可是，我已经做了慎重的决定，趁着年轻，想出去闯闯。&lt;br/&gt;作为老领导我劝你，最好不要轻易出去，经历告诉我，选一家好的公司，是在太难了，你出去很难碰到像目前这样好的平台了。&lt;br/&gt;　　这个我不好说，可是，只有闯闯才知道，闯过之后，后悔了我再回来，呵呵。&lt;br/&gt;哎，怎么说你呢，你还年轻，可能不知道，找一个赏识你的人是非常难的，尽管你很优秀？&lt;br/&gt;　　多谢XX总这样的教诲，以后我会记着你的教导的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　面对老领导的百般挽留和劝阻，我心意已决，做下的决定是无论如何都要去实践的。我要出去追寻自由，要出去历练自己。这家公司虽然无论从待遇还是从稳定来说，都是在行业中顶尖的。&lt;/p&gt;
&lt;p&gt;可是，在这种公司中，却永远没有自己二字。该走了，去外边闯闯，哪怕是风雨兼程，至少会有自由。&lt;/p&gt;
&lt;p&gt;　　若干年后，我深深的理解了前领导的这句话并反复揣摩，至理名言啊，找到一个赏识你的人的确很难，特别是你最需要别人赏识并给你机会的时候。&lt;/p&gt;
&lt;p&gt;　　凭着一腔热血，就迅速了的办理了离职，凭着以前在职时主动联系过的猎头，我没有把自己放到市场中去找机会。再者，当初给自己定的目标很明确，就要去小公司，越小越好，这样才有成长&lt;/p&gt;
&lt;p&gt;的机会和比较多的期权，能够实现心中的理想，也称之为很俗的目标。冲着这点，很多大一点的优秀的公司我连面试的机会都没给对方，现在想想，当初是多么的轻狂啊，多么的稚嫩啊。请君暂上&lt;/p&gt;
&lt;p&gt;凌烟阁,若个书生万户侯? 估计，当初我的心态就是这样的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　简单的人，目标总是那么的简单，只要给待遇差不太多的，只要能多给点期权，是做实事的公司，就去了。虽然，美其名曰做过调研---也就问问熟悉的同事不过，做过慎重考虑--也就是看待遇&lt;/p&gt;
&lt;p&gt;和期权（关键是没太重视这个期权）。中间还是向不少人打听了，也问了一些该公司的情况，得到的反馈还是很符合我的预期的，这种情况下，没有做过多的考虑，就匆匆赶来干活了。&lt;br/&gt;　　当在公司发展遇到困境时，我才静下心来深深反思，为什么要去创业公司呢？当初从上家公司离职有方向性的错误吗？&lt;br/&gt;　　从老东家出来我是没有后悔的，虽然，待遇会少一大截。但是，在那家公司的发展的确遇到了瓶颈，这个产品线研发基本结束，后面的迭代没什么技术含量的，再者就是做的东西根本没啥商用前景，&lt;/p&gt;
&lt;p&gt;从商业上，是失败的。技术上，更没有什么公司会搞这个东西，说白了就是屠龙之技。在老东家这种公司，假如选择一个注定失败的项目去做，下场只能用败寇来形容。针对这种情况，那个时间选择离开，&lt;/p&gt;
&lt;p&gt;选择离开本身是没啥错误的。&lt;br/&gt;　　出来之后，为什么我要坚持要去创业公司呢？特别是小的创业公司呢？&lt;br/&gt;　　首先，这和目前的中国创业环境分不开的，在全民创业，万众创新的号召下，很多人都变得非常不淡定。某某在什么公司，几年后实现了财务自由，某某又创办了XX公司，现在估值超过XXX亿美金了。&lt;/p&gt;
&lt;p&gt;在周围媒体天天狂轰乱炸下，很多人的选择也会变得脱离了自身的实际。这很多人当中，就有头脑发热的我。后来，和很多创业公司的员工聊起来这些事情时，很多人都坚持类似的观点，要来创业公司大&lt;/p&gt;
&lt;p&gt;赚一笔，要当上CTO，迎娶白富美。可见，绝大多数人还是很难摆脱环境的影响的。能够静下来针对自己的实际情况深思的人，绝对不会仓促的趟这趟浑水的。这个教训的确很深刻。是故智者之虑，必杂于&lt;/p&gt;
&lt;p&gt;利害。杂于利而务可信也；杂于害而患可解也。切记，切记，智者之虑。&lt;br/&gt;　　这也和我的经历有关系，毕业后就去了上家公司上班，一干就是很多年，在上家公司高强度工作和极端封闭的环境下，是很难真实的了解外边的情况的。得到的大多是在媒体看到的信息和周围同事的&lt;/p&gt;
&lt;p&gt;道听途说，在没有深入的调研分析思考的情况下，是很难作出有前瞻性的判断的，特别是要去什么样的公司，去什么样的创业公司？无论对创始人，还是对行业，都无法达到了如指掌的境界，这种情况下&lt;/p&gt;
&lt;p&gt;去做判断，不出错误才怪呢。仅仅靠运气去碰出一家好的创业公司，估计和中六合彩的概率差不多。这种运气，在从小到大，凭着仅中过一次公司抽奖的耳机的运气，我实在是不敢用它来赌未来，可是，实际情&lt;/p&gt;
&lt;p&gt;况，就是如此。造化弄人啊。没有调研就没有发言权，毛爷爷的教导在穿越历史，响彻云霄，一下子击中我这个小毛头。&lt;/p&gt;
&lt;p&gt;　　除了上面的情况，深层次的原因是还是目标和做事情的方法有问题。当初定的这个去小公司的目标都是有点荒诞，只考虑到了小公司万一发展好了，就会将来有可能大赚一笔，没考虑到在小公司的风险。&lt;/p&gt;
&lt;p&gt;风险是和收益成正比的，不对哦，是收益和风险是成正比的。我的实际情况是，风险很大，就是万一成功了收益却很一般。做事情的方法绝对有问题，没有做充分的调研，没有调研，就没有发言权，针对这种能&lt;/p&gt;
&lt;p&gt;影响到我命运的大事情，没有花费一个月以上的时间去调研的话，绝对是不充分的。当你决策所依靠的数据都不对的情况下，决策能会成功吗？能说出天误我也的人，一般都是在历史片中扮演悲剧角色的，真实&lt;/p&gt;
&lt;p&gt;的历史也是这样，不信你翻开资治通鉴看看。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;　　说白了，我的错误，错在调研不充分，目标不明确，考虑欠缺害。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　行业调研，公司调研，老板调研，利益诉求，成本产出，明确目标。&lt;/p&gt;

&lt;p&gt;　　后面，要针对这些做一些系统的分析和总结，给自己和像自己一样的年轻人在选择的时候提供点参考&lt;/p&gt;

</description>
<pubDate>Sat, 13 Jan 2018 10:30:00 +0000</pubDate>
<dc:creator>沧海粟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dylancao/p/8280191.html</dc:identifier>
</item>
<item>
<title>编写OC高质量的代码的有效方法 - 沉江小鱼</title>
<link>http://www.cnblogs.com/chenjiangxiaoyu/p/8275816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenjiangxiaoyu/p/8275816.html</guid>
<description>&lt;h3&gt;1. 写这个只是为了自己记忆，有相关pdf文件，如需要留下邮箱。。&lt;/h3&gt;
&lt;h3&gt;2. 在类的头文件中尽量少引入其他头文件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类（使用@class），并在实现文件中引入那些类的头文件，这样做可以尽量降低类之间的耦合。&lt;/li&gt;
&lt;li&gt;如果要声明某个类遵循某个协议，应该把这个协议放到分类中，或者把协议单独放在一个头文件中，然后将其引入。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3. 多用字面量语法，少用与之等价的方法&lt;/h3&gt;
&lt;p&gt;　　下面是两种方式的对比：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
// 使用字面量语法的例子
NSArray *array1 = @[@&quot;1&quot;,,@&quot;2&quot;];

NSNumber *number1 = @1;

NSDictionary *dictionary1 = @{@&quot;key&quot;:@&quot;value&quot;};

// 使用与之对应的方法
NSArray *array2 = [NSArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;,nil];

NSNumber *number2 = [NSNumber numberWithInt:2];

NSDictionary *dictionary2 = [NSDictionary dictionaryWithWithObjectsAndKeys:@&quot;value&quot;:@&quot;key&quot;];
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; 使用字面量语法来创建字符串、数值、数组、字典。与常规方法相比，更加简明扼要&lt;/li&gt;
&lt;li&gt;应该通过取下标操作来访问数组下标或字典中的键所对应的元素&lt;/li&gt;
&lt;li&gt;使用字面量语法创建数组或字典时，若值中有nil，则会抛出异常，因此，需确保值里面不含nil&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4. 多用类型常量，少用#define预处理指令&lt;/h3&gt;
&lt;p&gt;定义一个常量的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
// 第一种：预处理指令
#define ANIMATION_DURATION 0.3

// 第二种：定义静态常量
static const NSTimeInterval kAnimationDuration = 0.3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们一般推荐使用第二种，这个方式定义的常量包含类型信息，有助于代码阅读。&lt;/p&gt;
&lt;p&gt;注意：常量命名法是：若常量局限于“编译单元”（也就是实现文件,.m文件）之内，则在前面加字母k；若常量在类之外可见，则通常以类名为前缀。&lt;/p&gt;
&lt;p&gt;如我们需要对外公布某个常量，我们可以写成下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
// Test.h
#import &amp;lt;Foundation/Foundation.h&amp;gt;

extern NSString *const TestDidChangeNotification;

@interface Test : NSObject

@end

// Test.m

#import &quot;Test.h&quot;

NSString *const TestDidChangeNotification = @&quot;TestDidChangeNotification&quot;;

@implementation Test
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; 不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前根据此执行查找和替换。即使有人重新定义了常量值，编译器也不会有警告，这将导致应用程序中的常量值不一致&lt;/li&gt;
&lt;li&gt;在.m文件中使用 static const 来定义“编译单元内可见常量”，无需加类名前缀，加k&lt;/li&gt;
&lt;li&gt;在头文件中使用 extern 来声明全局常量，并在相关实现文件中定义其值，这种常量要加类名前缀。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;5. 用枚举来表示状态、选项、状态码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字&lt;/li&gt;
&lt;li&gt;用NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。&lt;/li&gt;
&lt;li&gt;在处理枚举类型的switch语句中不要事先default分支，这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;6. 理解“属性”这一概念&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用@property语法来定义对象中所封装的数据&lt;/li&gt;
&lt;li&gt;通过“特质”属性关键字来指定存储数据所需的正确语义&lt;/li&gt;
&lt;li&gt;在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;7. 在对象内部尽量直接访问实例变量&lt;/h3&gt;
&lt;p&gt;比如，Person类有个name属性，我们在这个类的内部想获取这个name属性的数据的时候，一种是通过 self.name，一种是 _name.&lt;/p&gt;
&lt;p&gt;这两种的区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接访问实例变量的速度比较快，编译器所生成的代码会直接访问保存对象实例变量的那块内存&lt;/li&gt;
&lt;li&gt;直接访问实例变量，不会调用其“设置方法”，这就绕过了为相关属性所定义的“内存管理语义”，比如，在ARC下直接访问一个声明为copy的属性，那么并不会拷贝该属性，只会保留新值，释放旧值&lt;/li&gt;
&lt;li&gt;如果直接访问实例变量，那么不会触发“KVO”，这样做是否会产生问题，取决于具体的对象行为。&lt;/li&gt;
&lt;li&gt;通过属性来访问有助于排查与之相关的错误，因为可以给“获取方法”或“设置方法”中新增“断点”，监控该属性的调用者及其访问时机。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应通过属性来写&lt;/li&gt;
&lt;li&gt;在初始化方法及dealloc方法中，总是应该直接通过实例变量来读写数据&lt;/li&gt;
&lt;li&gt;有时候会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;8. 理解“对象等同性”这一概念&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;若想检测对象的等同性，请提供“isEqual:”与hash方法&lt;/li&gt;
&lt;li&gt;相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同&lt;/li&gt;
&lt;li&gt;不要盲目的逐个检测每条属性，而是根据具体需求来指定方案&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;9. “以类族模式”隐藏实现细节&lt;/h3&gt;
&lt;p&gt;“类族”是一种很有种的模式，可以隐藏“抽象基类”背后的实现细节。OC的系统框架中普遍使用此模式，比如有一个处理雇员的类，每个雇员都有“名字”和“薪水”这两个属性，管理者可以命令其执行日常工作，但是各种雇员的工作内容却不同，经理在带领雇员做项目时，无需关系每个人如何完成其具体工作，仅需指示其开工就行。我们重构多个子类，把每个人完成具体工作的方法，在子类实现。&lt;/p&gt;
&lt;p&gt;首先定义一个抽象基类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
typedef NS_ENUM(NSUInteger, EOCEmployeeType){
    EOCEmployeeTypeDeveloper,
    EOCEmployeeTypeDesigner,
    EOCEmployeeTypeFinance     
}

@interface EOCEmployee : NSObject
@property (copy, nonatomic) NSString *name;
@property (assign, nonatomic) NSInteger salary;

// 创建一个雇员对象
+(EOCEmployee*)employeeWithType:(EOCEmployeeType)type;

// 让雇员工作
- (void)doADaysWork;

@implementation EOCEmployee

+ (EOCEmployee *)employeeWithType:(EOCEmployeeType)type{
    switch (type){
          case EOCEmployeeTypeDeveloper:
                  return [EOCEmployeeTypeDeveloper new];
                  break;
          case EOCEmployeeTypeDeveloper:
                  return [EOCEmployeeTypeDesigner new];
                  break;
           case EOCEmployeeTypeDeveloper:
                  return [EOCEmployeeTypeFinance new];
                  break;
    }  
}

- (void)doADayWork{
  // 子类去实现
}

@end
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后，每个“实体子类”都从基类继承而来，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
@interface EOCEmployeeDeveloper : EOCEmployee

@end

@implementation EOCEmployeeDeveloper

- (void)doADaysWork{
   [self wirteCode];
}

@end
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在本例中，基类实现了一个“类方法”，该方法根据待创建的雇员类别分配好对应的雇员类实例，这种“工厂模式”是创建类族的办法之一。&lt;/p&gt;
&lt;p&gt;如果对象所属的类位于某个类族中，你可能觉得自己创建了某个类的实例，然而实际上创建的却是其子类的实例。&lt;/p&gt;
&lt;p&gt;OC中的NSNumber、NSArray等都是类族。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类族模式可以把实现细节隐藏在一套简单的公共接口后面。&lt;/li&gt;
&lt;li&gt;系统框架中经常使用类族&lt;/li&gt;
&lt;li&gt;从类族的公共抽象基类中集成子类时要当心，若有开发文档，应先阅读。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;10. 在既有类中使用关联对象存放自定义数据&lt;/h3&gt;
&lt;p&gt;有时候需要在对象中存放相关信息，这时候我们通常都会从对象所属类中继承一个子类，然后改用这个子类对象，但是有时候类的实例可能是由某种机制所创建的，而开发者无法令这种机制创建出自己所写的子类实例。OC中有一项强大的特性可以解决，就是“关联对象”。&lt;/p&gt;
&lt;p&gt;基于runtime来实现，此处就不多说。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以通过“关联对象”机制来把两个对象连起来。&lt;/li&gt;
&lt;li&gt;定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非用有关系”&lt;/li&gt;
&lt;li&gt;只有在其他做法不可行时才应该选用关联对象，这种做法通常会引入难于查找的bug&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; 11. 理解objc_msgSend的作用&lt;/h3&gt;
&lt;p&gt;在对象上调用方法是OC中经常使用的功能。专业术语叫做：“传递消息”。消息有“名称”或“选择子”，可以接受参数，而且可能还有返回值。&lt;/p&gt;
&lt;p&gt;C语言使用“静态绑定”，在编译期就能决定运行时所应调用的函数。&lt;/p&gt;
&lt;p&gt;OC中使用“动态绑定”，对象接收到消息之后，究竟该调用哪个方法则完全于运行期决定，甚至可以在程序运行时改变。&lt;/p&gt;
&lt;p&gt;这里就不多解释objc_msgSend的使用，如有需要可以看runtime的使用。&lt;/p&gt;
&lt;p&gt;objc_msgSend 函数会根据接收者和选择子的类型来调用适当的方法，为了完成此操作，该方法需要在接收者所属的类中找到其“方法列表”，如果能找到与选择子名称相符的方法，就跳至其实现代码，如果找不到，那就沿着继承体系向上查找，如果最终没找到，则执行“消息转发”操作。每个类都会有一块缓存，用来缓存方法，若是稍后还向该类发送与选择子相同的消息，那么执行起来就会很快了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消息由接收者，选择子及参数构成。给某对象“发送消息”，也就相当于在该对象上“调用方法”&lt;/li&gt;
&lt;li&gt;发给某对象的全部消息都要由“动态消息派发系统”来处理，该系统会查出对应的方法，并执行其代码。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;12. 理解消息转发机制&lt;/h3&gt;
&lt;p&gt;当对象接收到无法解读的消息后，就会启动“消息转发”机制，程序员可经由此过程告诉对象应该如何处理未知消息。&lt;/p&gt;
&lt;p&gt;如果在控制台中看到 unrecognized selector sent to instance 0x87 就说明你曾向某个对象发送过一条其无法解读的消息，从而启动了消息转发机制，然后以程序崩溃而告终。&lt;/p&gt;
&lt;p&gt;消息转发分为两个阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个“未知的选择子（unknown selector）”，这叫做“动态方法解析”&lt;/li&gt;
&lt;li&gt;第二阶段，涉及“完整的消息转发机制”，如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。这又分为两小步：
&lt;ol&gt;&lt;li&gt;首先，看接收者看看有没有其他对象能否处理这条消息&lt;/li&gt;
&lt;li&gt;如果有，则运行期系统会把消息转给那个对象，于是转发郭恒结束，如果没有“备用的接收者”，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;动态方法解析：&lt;/p&gt;
&lt;p&gt;对象在收到无法解读的消息后，首先将调用其所属类的下列类方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// 如果该类调用了一个没有实现的实例方法，会调用此方法&lt;br/&gt;+ (BOOL)resolveInstanceMethod:(SEL)selector&lt;br/&gt;// 如果该类调用了一个没有实现的类方法，会调用此方法&lt;br/&gt;+ (BOOL)resolveClassMethod;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　该方法的参数就是那个未知的选择子，其返回值为Boolean类型，表示这个类是否能新增一个实例方法用以处理此选择子。在继续往下执行转发机制之前，我们可以使用runtime动态的增加这个方法。&lt;/p&gt;
&lt;p&gt;使用这种办法的前提是：相关方法的实现代码已经写好，只等着运行的时候动态插在类里面就可以了。&lt;/p&gt;
&lt;p&gt;备用接收者：&lt;/p&gt;
&lt;p&gt;当前接收者还有第二次机会能处理未知的选择子，在这一步中，运行期系统会问它：能不能把这条消息转给其他接收者来处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// 方法参数代表未知的选择子，若当前接收者能够找到备援对象，则将其返回，如果找不到就返回nil。
- (id)forwardingTargetForSelector:(SEL)selector;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　我们可以用“组合”来模拟出“多重继承”的某些特性，在一个对象内部，可能还有其它一系列对象，该对象可经由此方法将能够处理某选择子的相关内部对象返回，这样的话，在外界看来，好像是由该对象亲自处理的。&lt;/p&gt;
&lt;p&gt;完整的消息转发：&lt;/p&gt;
&lt;p&gt;如果转发已经来到这一步的话，那么唯一能做的就是启用完整的消息转发机制了，系统会创建NSInvocation 对象，把与尚未处理的那条消息有关的全部细节都封装于其中，此对象包含选择子、目标（target）及参数，在触发NSInvocation对象时，“消息派发系统”将亲自出马，把消息指派给目标对象。&lt;/p&gt;
&lt;p&gt;此步骤会调用下列方法来转发消息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// 该方法可以实现的很简单，只需要改变调用目标，是消息在新目标上得以调用即可，然而这样实现出来的方法与“备援接收者”方案所实现的方法等效，所以很少有人采用这么简单的实现方法，比较有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或是改换选择子等等。
- (void)forwardInvocation:(NSInvocation *)invocation;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　实现此方法时，若发现某调用操作不应由本类处理，则需要调用超类的同名方法。这样的话，继承体系中的每个类都有机会处理此调用请求，直到NSObject，如果最后调用了NSObject类的方法，那么该方法还会继续调用“doesNotRecognizeSelector”，以抛出异常，此异常表明选择子最终未能得到处理。&lt;/p&gt;
&lt;p&gt;消息转发全流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180112180849504-2139330177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180112180828894-783972757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接收者在每一步中均有机会处理消息，步骤越往后，处理消息的代价就越大，最好能在第一步处理完，这样的话，运行期系统就可以将此方法缓存起来了，如果这个类的实例稍后还收到同名选择子，那么根本无需启动消息转发流程。如果想在第三步里把消息转给备援的接收者，那还不如把转发操作提前到第二步。因为第三步只是修改了调用目标，这项改动放在第二部执行会更为简单，不然的话，还得创建并处理完整的NSInvocation。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若对象无法响应某个选择子，则进入消息转发流程。&lt;/li&gt;
&lt;li&gt;通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。&lt;/li&gt;
&lt;li&gt;对象可以把其无法解读的某些选择子转交给其它对象来处理&lt;/li&gt;
&lt;li&gt;经过上述两步之后，如果还是没有办法处理选择子，那就启动完整的消息转发机制。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;http://www.cocoachina.com/ios/20150604/12013.html 相关的例子&lt;/p&gt;
&lt;h3&gt;13. 用“方法调配技术”调试“黑盒方法”&lt;/h3&gt;
&lt;p&gt;主要就是runtime的方法交换，runtime具体可见OC类目中关于runtime的介绍。&lt;/p&gt;
&lt;p&gt;我们在这里简单的分析下：&lt;/p&gt;
&lt;p&gt;类的方法列表会把选择子的名称映射到相关的方法实现直上，使得“动态消息派发系统”能够据此找到应该调用的方法，这些方法均以函数指针的形式来表示，这种指针叫做IMP，其原型如下：&lt;/p&gt;
&lt;p&gt;id (*IMP)(id,SEL,...)&lt;/p&gt;
&lt;p&gt;比如，NSString 类可以相应lowercaseString、uppercaseString、capitalizedString等选择子。这张映射表中的每个选择子都映射到了不同的IMP之上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180112182550441-1757892459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OC运行期系统提供的几个方法都能够用来操作这张表，开发者可以向其中新增选择子，也可以改变某选择子所对应的方法实现，还可以交换两个选择子所映射到的指针，比如我们交换 lowercaseString 和 uppercaseString 的方法实现，类的方法表就会变成以下这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180112182808769-1767707084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在新的映射表中，我们可以看到交换了lowercaseString 和 uppercaseString 的方法实现，并且多了一个名为newSelector的选择子，上述修改均无需编写子类，只要修改了“方法表”的布局，就会反映到程序中所有的NSString实例之上。&lt;/p&gt;
&lt;p&gt;通过此方案，开发者可以为那些“完全不知道其具体实现”的黑盒方法增加日志记录功能，这有助于程序调试。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在运行期，可以向类中新增或替换选择子所对应的方法实现。&lt;/li&gt;
&lt;li&gt;使用另一份实现来替换原有的方法实现，这道工序叫做“方法调配”，也就是方法交换，开发者常用此技术向原有实现中添加新功能。&lt;/li&gt;
&lt;li&gt;一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;14. 理解“类对象”的用意&lt;/h3&gt;
&lt;p&gt;对象类型并非在编译期就绑定好了，而是要在运行期查找。而且，还有个特殊的类叫做id，它能指代任意的OC对象类型，一般情况下，应该指明消息接收者的具体类型，这样的话，如果向其发送了无法解读的消息，那么编译器就会产生警告信息，而类型为id的对象则不然，编译器嘉定它能够响应所有的消息。&lt;/p&gt;
&lt;p&gt;“在运行期检视对象类型”，这个操作也叫做“类型信息查询”（内省），这个强大而有用的特性内置于Foundation框架的NSObject协议里，凡是由公共根类(common root class)继承而来的对象都要遵从此协议。在程序中不要直接比较对象所属的类，明智的做法是调用“类型信息查询方法”。&lt;/p&gt;
&lt;p&gt;在此之前，我们看下OC对象的本质是什么？&lt;/p&gt;
&lt;p&gt;每个OC对象实例都是指向某块内存数据的指针，所以在声明变量时，类型后面要跟一个“*”字符,如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// pointerVariable可以理解成存放内存地址的变量，而NSString 自身的数据就存储于那个地址中，因此可以说，该变量”指向“NSString 实例。所有OC对象都是如此，
NSString *pointerVariable = @&quot;Some string&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　描述OC对象所用的数据结构定义在运行期程序库的头文件里，id类型本身也定义在这里：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
typedef struct objc_object{
    Class isa;
}*id;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　每个对象，结构体的首个成员是Class类的变量。该变量定义了对象所属的类，通常称为“is a”指针，例如，刚才的例子中所有的对象“是一个”(is a)NSString，所以其“is a”指针就指向NSString。Class对象也定义在运行期程序库的头文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
typedef stuct objc_class *Class;
struct objc_class{
    Class isa;
    Class super_class;
    const char *name;
    long version;
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;
    struct objc_method_list *methodList;
    struct objc_cache *cache;
    struct objc_protocol_list *protocols;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 此结构体存放类的“元数据”，例如类的实例实现了几个方法，具备多少个实例变量等信息。此结构体的首个变量也是isa指针，这说明Class本身亦为OC对象。结构体里还有个变量为super_class，它定义了本类的超类。类对象所属的类型(也就是isa指针所指向的类型)，是另外一个类，叫做“元类”，用来表述类对象本身所具备的元数据。“类方法”就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个“类对象”，而每个“类对象”仅有一个与之相关的“元类”。&lt;/p&gt;
&lt;p&gt;super_class 指针确立了继承关系，而isa指针描述了实例所属的类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系。&lt;/li&gt;
&lt;li&gt;如果对象类型无法再编译期确定，那么就应该使用类型信息查询方法来弹指&lt;/li&gt;
&lt;li&gt;尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;15. 用前缀避免命名空间冲突&lt;/h3&gt;
&lt;p&gt;应该为所有的名称都加上适当的前缀，比如，你所在的公司焦作Effective Widgets，那么就可以在公共部分代码中使用EWS做前缀，如果有些代码只用于Effective Browser的浏览器项目中，可以使用EWB作前缀。&lt;/p&gt;
&lt;p&gt;前缀最好是三个字母的，因为Apple宣称其保留使用所有“两字母前缀”。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;选择与你的公司，应用程序或二者皆有关联之名称作为类名的前缀，并在所有代码中使用这一前缀&lt;/li&gt;
&lt;li&gt;若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;16. 提供“全能初始化方法” &lt;/h3&gt;
&lt;p&gt;UITableViewCell，初始化该类对象时，需要指明其样式及标示符，标示符能够区分不同类型的单元格，由于这种对象的创建成本较高，所以绘制表格时可依照标示符来复用，以提升程序效率，我们把这种可为对象提供必要信息以便其能完成工作的初始化方法叫做“全能初始化方法”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
// 比如创建一个NSDate
- (id)init;
- (id)initWithString:(NSString *)string;
- (id)initWithTimeIntervalSinceNow:(NSTimeInterval)seconds;
- (id)initWIthTimeIntervalSinceRefrenceDate:(NSTimeInterval)seconds;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 第四个方法是全能初始化方法，也就是说其余的初始化方法都要调用它，当底层数据存储机制改变时，只需修改此方法的代码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在类中提供一个全能初始化方法，并在文档里指明。其它初始化方法均应调用此方法&lt;/li&gt;
&lt;li&gt;若全能初始化方法与超类不同，则需要复写超类中的对应方法。&lt;/li&gt;
&lt;li&gt;如果超类的初始化方法不适用子类，那么应该复写这个超类方法，并在其中抛出异常。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;17. 实现description方法&lt;/h3&gt;
&lt;p&gt;调试程序的时候，经常需要打印并查看对象信息，我们可以重写该对象的description方法，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180113160929441-1676529011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实现description方法返回一个有意义的字符串，用以描述该实例&lt;/li&gt;
&lt;li&gt;若想在调试时打印出更详尽的对象描述信息，则应实现debugDescription方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;18. 尽量使用不可变对象&lt;/h3&gt;
&lt;p&gt;设计类的时候，应充分运用属性来封装数据，尽量把对外公布出来的属性设为只读，而且只在确有必要时才将属性对外公布。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽量创建不可变的对象&lt;/li&gt;
&lt;li&gt;若某属性仅可于对象内部修改，则在.m文件中，则将其由readonly变成readwrite属性。&lt;/li&gt;
&lt;li&gt;不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的collection&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;19. 使用清晰而协调的命名方式&lt;/h3&gt;
&lt;p&gt;给方法命名时注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果方法的返回值是新创建的，那么方法名的某个词应该是返回值的类型，除非还有修饰语，如：localizedString。属性的存取方法不遵循这种命名方式。&lt;/li&gt;
&lt;li&gt;应该把表示参数类型的名词放在参数前面。&lt;/li&gt;
&lt;li&gt;如果方法要在当前对象上执行操作，那么应该包含动词。&lt;/li&gt;
&lt;li&gt;不要使用str这种简称，使用全程。&lt;/li&gt;
&lt;li&gt;Boolean属性应加is前缀。如果某方法返回非属性的Boolean值，那么应该根据其功能，选用has或is当前缀。&lt;/li&gt;
&lt;li&gt;将get这个前缀留给那些借由”输出参数“来保存返回值的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;起名时应遵从标准的OC命名规范，这样创建出来的接口更容易为开发者所理解。&lt;/li&gt;
&lt;li&gt;方法名要言简意赅&lt;/li&gt;
&lt;li&gt;方法名不要使用缩略后的类型名称&lt;/li&gt;
&lt;li&gt;给方法起名时的第一要务就是确保其风格与你自己的代码或所要继承的框架相符。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;20. 为私有方法名加前缀&lt;/h3&gt;
&lt;p&gt;一个类所做的事情通常都要比从外面看到的更多，编写类的实现代码时，经常要写一些在内部使用的方法。应该为这种方法的名称加上某些前缀，这有助于调试，因为据此很容易就能把公共方法和私有方法区别开。&lt;/p&gt;
&lt;p&gt;具体使用何种前缀，可根据个人喜好来定，其中最好包含下划线和字母p，比如p_method。不要使用 _method，因为Apple公司喜欢单用一个下划线做私有方法的前缀，可能会引起冲突。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给私有方法的名称加上前缀，这样可以很容易地将其同公共方法区分开&lt;/li&gt;
&lt;li&gt;不要单用一个下划线做私有方法的前缀，因为这种做法是留给苹果公司用的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;21. 理解OC错误模型&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;只有发生了可使整个应用程序崩溃的严重错误时，才使用异常。&lt;/li&gt;
&lt;li&gt;在错误不严重的情况下，使用NSError&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;22. 理解NSCopying协议&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;若想让自己所写的对象具有拷贝功能，则需要实现NSCopying协议&lt;/li&gt;
&lt;li&gt;如果自定义的对象分为可变和不可变，那么就要同时实现NSCopying和NSMutableCopying协议&lt;/li&gt;
&lt;li&gt;复制对象时需决定采用浅拷贝还是深拷贝，一般情况下执行浅拷贝&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;23. 通过委托与数据源协议进行对象间通信&lt;/h3&gt;
&lt;p&gt;委托模式：定义一套接口，某对象若想接受另一个对象的委托，则需要实现这个接口，以便成为其&quot;委托对象&quot;，而这”另一个对象“则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;委托模式为对象提供了一套接口，使其可由此将相关事件告知其它对象&lt;/li&gt;
&lt;li&gt;将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法&lt;/li&gt;
&lt;li&gt;当某对象需要从另外一个对象中获取数据时，可以使用委托模式，比如 tableView的dataSource&lt;/li&gt;
&lt;li&gt;如果有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存下来，比如，声明一个属性，记录是否实现了某个方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;24. 将类的实现代码分散到便于管理的数个分类之中&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用分类机制把类的实现代码划分成易于管理的小块&lt;/li&gt;
&lt;li&gt;将应该视为”私有“的方法归入名叫Private的分类中，隐藏实现细节。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;25. 总是为第三方类的分类名称加前缀&lt;/h3&gt;
&lt;p&gt;比如你想给系统类添加个方法，如果你没有添加前缀的话，可能会覆盖其方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;向第三方类中添加分类时，总应给其名称加上你专用的前缀。&lt;/li&gt;
&lt;li&gt;给其中的方法名加上你专用的前缀。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;26. 不要再分类中声明属性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;把封装数据所用的全部属性都定义在主接口里&lt;/li&gt;
&lt;li&gt;在分类中，可以定义存取方法，但尽量不要定义属性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;27. 使用 &quot;class-continuation分类&quot;隐藏实现细节&lt;/h3&gt;
&lt;p&gt;&quot;class-continuation分类&quot;和普通的分类不同，它必须定义在其所接续的那个累的实现文件里。其重要之处在于，这是唯一能够声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法都应该定义在类的主实现文件里。而且，和其它分类不同，它没有名字，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
@interface Person ()
// Methods here
@end
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; 通过“class-continuation分类”向类中新增实例变量&lt;/li&gt;
&lt;li&gt;如果某属性在主接口中声明为只读，而类的内部又要用设置方法修改此属性，那么就在“class-continuation分类”中将其扩展为“可读写”&lt;/li&gt;
&lt;li&gt;把私有方法的原型声明在“class-continuation分类”里面&lt;/li&gt;
&lt;li&gt;若想让类所遵循的协议不为人所知，则可于“class-continuation分类”中声明。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;28. 通过协议提供匿名对象&lt;/h3&gt;
&lt;p&gt;如下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
@property (nonatomic, weak) id &amp;lt;WCEDelegate&amp;gt; delegate;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于该属性的类型id&amp;lt;EOCDelegate&amp;gt;，所以实际上任何类的对象都能充当这一属性，对于具备此属性的类来说，delegate就是”匿名的“。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法&lt;/li&gt;
&lt;li&gt;使用匿名对象来隐藏类型名称&lt;/li&gt;
&lt;li&gt;如过具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;29. 理解引用计数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1.若保留计数为正，则对象继续存活，当保留计数将为0时，对象就销毁了&lt;/li&gt;
&lt;li&gt;在对象声明期中，其余对象通过引用来保留或释放此对象，保留和释放操作分别会递增及递减保留计数&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;30. ARC注意事项&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在ARC之后，程序员就无需担心内存管理问题了&lt;/li&gt;
&lt;li&gt;不要手动管理&lt;/li&gt;
&lt;li&gt;CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease.&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;31. 在dealloc方法中只释放引用并解除监听&lt;/h3&gt;
&lt;p&gt;对象在经历其生命周期后，最终会为系统所回收，这时就要执行dealloc方法，在每个对象的生命周期内，此方法仅执行一次，也就是当保留计数为0的时候，然而具体何时执行，则无法保证。&lt;/p&gt;
&lt;p&gt;在dealloc方法中，一般都是移除观测行为，注销通知。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在dealloc方法里，应该做的事情就是释放指向其它对象的引用，并取消原来订阅的”kvo“或通知中心的等通知，不要做其它事情&lt;/li&gt;
&lt;li&gt;如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。&lt;/li&gt;
&lt;li&gt;执行异步任务的方法不应再dealloc里，只能在正常状态执行的哪些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;32. 以弱引用避免循环引用&lt;/h3&gt;
&lt;p&gt;如果两个对象，相互引用，那么这两个对象都无法被释放，产生内存泄露。&lt;/p&gt;
&lt;p&gt;unsafe_unretained 和 weak的区别：&lt;/p&gt;
&lt;p&gt;当指向某个实例的引用移除后，unsafe_unretained属性仍指向那个已经回收的实例，而weak属性则指向nil。weak比unsafe_unretained应用可以令代码更安全。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当某些引用设为weak，可避免出现循环引用&lt;/li&gt;
&lt;li&gt;weak引用可以自动清空，也可以不自动清空。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;33. 自动释放池&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里&lt;/li&gt;
&lt;li&gt;合理运用自动释放池，可降低应用程序的内存峰值&lt;/li&gt;
&lt;li&gt;使用@autoreleasepool&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;34. 为常用的block类型创建typedef&lt;/h3&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
typedef void(^WCECompletionHander)(NSData *data);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; 用typedef重新定义块类型，可让块变量用起来更加简单&lt;/li&gt;
&lt;li&gt;定义新类型时，应遵循命名规则&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;35. 使用block降低代码分散程度&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在创建对象时，可以使用内联的handler代码块将相关业务逻辑声明&lt;/li&gt;
&lt;li&gt;比如网络请求一般使用代码块来回调数据&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sat, 13 Jan 2018 10:10:00 +0000</pubDate>
<dc:creator>沉江小鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenjiangxiaoyu/p/8275816.html</dc:identifier>
</item>
</channel>
</rss>