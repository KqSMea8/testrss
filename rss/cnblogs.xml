<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>VS重新生成项目失败，但是不报错 - ElleryO</title>
<link>http://www.cnblogs.com/elleryo/p/9449295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/elleryo/p/9449295.html</guid>
<description>&lt;p&gt;&lt;span&gt;相信很多同行可能都遇到这种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用SVN或者其他项目管理工具checkout一个项目后，重新生成项目后，&lt;span&gt;生成失败&lt;/span&gt;了，但是&lt;span&gt;没有显示任何错误&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/939629/201808/939629-20180809152450288-1802828023.png&quot; alt=&quot;&quot; width=&quot;775&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实，这个大多数是因为类库里面的&lt;span&gt;引用失效&lt;/span&gt;导致的，我们可以先在每一个类库检查，看是否能成功生成项目：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/939629/201808/939629-20180809152931683-1947621442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在不能成功生成的类库或者web项目里面打开其“引用”信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/939629/201808/939629-20180809153024794-2057714301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果你会发现有些引用出现了“黄色叹号”，意思是这个引用无效了，因为可能引用路径的dll在你的电脑不存在,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你需要重新引用你本地的&lt;/span&gt;&lt;span&gt;dll,然后重新生成项目，就OK了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/939629/201808/939629-20180809153237416-1567311004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 09 Aug 2018 07:35:00 +0000</pubDate>
<dc:creator>ElleryO</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/elleryo/p/9449295.html</dc:identifier>
</item>
<item>
<title>mpvue小程序项目框架搭建 - web-慰尘</title>
<link>http://www.cnblogs.com/weichen913/p/9439203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weichen913/p/9439203.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　mpvue框架对于从没有接触过小程序又要尝试小程序开发的人员来说，无疑是目前最好的选择。mpvue从底层支持 Vue.js 语法和构建工具体系，同时再结合相关UI组件库，便可以高效的实现小程序开发&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　本文讲述如何搭建完整的小程序项目框架，因为是第一次使用，有不完善的地方请大佬指正。&lt;/p&gt;
&lt;p&gt;　　搭建内容包括：&lt;/p&gt;
&lt;p&gt;　　1、使用scss语法：依赖插件sass-loader 、node-sass&lt;/p&gt;
&lt;p&gt;　　2、像vue一样使用路由：依赖插件 &lt;a href=&quot;https://github.com/F-loat/mpvue-entry&quot; target=&quot;_blank&quot;&gt;mpvue-entry&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/F-loat/mpvue-entry&quot; target=&quot;_blank&quot;&gt;mpvue-router-patch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　3、使用ZanUI:有赞团队的小程序版UI组件库（&lt;a href=&quot;https://github.com/youzan/zanui-weapp&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　4、使用vuex进行状态管理&lt;/p&gt;
&lt;p&gt;　　5、使用flyio进行数据交互：&lt;a href=&quot;https://github.com/wendux/fly&quot; target=&quot;_blank&quot;&gt;GitHub地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;项目结构：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;讲解：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;一、使用scss语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;1、安装依赖&lt;/p&gt;
&lt;p&gt;　　cnpm install node-sass sass-loader --save-dev&lt;/p&gt;
&lt;p&gt;　　因为一些不知名的原因导致node-sass经常安装失败，所以采用cnpm方式安装最好&lt;/p&gt;
&lt;p&gt;　　2、在.vue文件中的style节点加上lang=”scss”，这样就可以愉快地使用sass进行开发了，无需再webpack.base.config.js中配置loader，webpack会自动识别.scss文件以及.vue中的scss代码。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;二、像vue一样使用路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在使用mpvue提供的命令 vue init mpvue/mpvue-quickstart my-project 创建项目后，会发现每个页面都要配置main.js 文件，不仅繁琐而且显得多余，所以我们是否可以改造成像vue一样使用路由的方式呢，答案是可以的，需要用到mpvue-entry 和 mpvue-router-patch插件（集中式页面配置，自动生成各页面的入口文件，优化目录结构，支持新增页面热更新）和&lt;/p&gt;
&lt;p&gt;　　mpvue-entry: 集中式页面配置，自动生成各页面的入口文件，优化目录结构，支持新增页面热更新&lt;/p&gt;
&lt;p&gt;　　mpvue-router-patch: 在 mpvue 中使用 vue-router 兼容的路由写法&lt;/p&gt;
&lt;p&gt;　　1、安装依赖&lt;/p&gt;
&lt;p&gt;　　cnpm install mpvue-entry --save-dev&lt;/p&gt;
&lt;p&gt;　　cnpm install mpvue-router-patch --save&lt;/p&gt;
&lt;p&gt;　　2、项目src文件夹下创建router文件夹和router.js文件&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1417530/201808/1417530-20180807202047175-682208521.png&quot; alt=&quot;&quot; width=&quot;276&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3、项目引入src下的main.js文件　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;
import MpvueRouterPatch from &lt;/span&gt;'mpvue-router-patch'&lt;span&gt;

Vue.use(MpvueRouterPatch)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;注：main.js的 export default {} 不能为空，不然编译时不生成app.json文件&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　4、修改webpack.base.conf.js配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const MpvueEntry = require('mpvue-entry'&lt;span&gt;)

module.exports &lt;/span&gt;=&lt;span&gt; {
    entry:MpvueEntry.getEntry(&lt;/span&gt;'./src/router/router.js'&lt;span&gt;),
    .......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5、配置router.js 文件　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首个路由为首页&lt;/span&gt;
module.exports =&lt;span&gt; [{
    path: &lt;/span&gt;'pages/index'&lt;span&gt;,
    name: &lt;/span&gt;'Index'&lt;span&gt;,
    config: {
        navigationBarTitleText: &lt;/span&gt;'文章详情'&lt;span&gt;,&lt;br/&gt;　　　　//引入UI组件，后面会讲到
        usingComponents:{
            &lt;/span&gt;&quot;zan-button&quot;: &quot;../dist/btn/index&quot;&lt;span&gt;
        }
    }
}, {
    path: &lt;/span&gt;'pages/list/list'&lt;span&gt;,
    name: &lt;/span&gt;'List'&lt;span&gt;,
    config: {
        navigationBarTitleText: &lt;/span&gt;'list详情'&lt;span&gt;
    }
}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;三、使用小程序UI组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、将UI组件库克隆到本地&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1417530/201808/1417530-20180807203741274-344310447.png&quot; alt=&quot;&quot; width=&quot;541&quot; height=&quot;348&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、将上图中的dist目录拷贝到mpvue项目的输出目录中&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1417530/201808/1417530-20180807204107417-192586666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、在router.js文件中引入UI组件　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; [{
    path: &lt;/span&gt;'pages/index'&lt;span&gt;,
    name: &lt;/span&gt;'Index'&lt;span&gt;,
    config: {
        navigationBarTitleText: &lt;/span&gt;'文章详情'&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入UI组件&lt;/span&gt;
&lt;span&gt;        usingComponents:{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组件名和引用路径&lt;/span&gt;
            &quot;zan-button&quot;: &quot;../dist/btn/index&quot;&lt;span&gt;
        }
    }
}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4、页面中使用UI组件　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;index&quot;&amp;gt;
        &amp;lt;zan-button type=&quot;primary&quot; size=&quot;small&quot;&amp;gt;确认付款&amp;lt;/zan-button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5、&lt;/p&gt;
&lt;p&gt;　　小程序使用自定义组件：https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/&lt;/p&gt;
&lt;p&gt;　　ZanUI组件库使用讲解：https://github.com/youzan/zanui-weapp/blob/dev/README.md&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;四、使用vuex进行状态管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、安装&lt;/p&gt;
&lt;p&gt;　　　　cnpm install vuex --save&lt;/p&gt;
&lt;p&gt;　　2、引入（main.js文件）&lt;/p&gt;
&lt;p&gt;　　　　impotr store from './vuex/index'&lt;/p&gt;
&lt;p&gt;　　　　Vue.prototrype.$store = store//挂在到vue原型上 &lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;五、使用flyio进行数据交互&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、安装&lt;/p&gt;
&lt;p&gt;　　　　cnpm install flyio --save&lt;/p&gt;
&lt;p&gt;　　2、引入（main.js文件）&lt;/p&gt;
&lt;p&gt;　　　　const Fly = require(&quot;flyio/dist/npm/wx&quot;)//引入&lt;/p&gt;
&lt;p&gt;　　　　const fly = new Fly&lt;/p&gt;
&lt;p&gt;　　　　Vue.prototrype.$fly = fly//挂在到vue原型上&lt;/p&gt;
&lt;p&gt;　　3、使用&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    　　　　add(){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在add方法中执行接口请求&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.$fly.get('http://******/user?id=133'&lt;span&gt;)
                    .then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求成功&lt;/span&gt;
                           console.log('res'&lt;span&gt;,res);
                    })
                    .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求失败&lt;/span&gt;
                        console.log('err'&lt;span&gt;,err);
                    });
            }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;






</description>
<pubDate>Thu, 09 Aug 2018 07:26:00 +0000</pubDate>
<dc:creator>web-慰尘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weichen913/p/9439203.html</dc:identifier>
</item>
<item>
<title>反射？切面？怎样对公共参数及行为进行封装 - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/9449091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/9449091.html</guid>
<description>&lt;p&gt;　　现在都是微服务化访问，某系统访问另一系统时，总有一些公用参数需要处理，另外还需要对访问情况进行日志打印。&lt;br/&gt;　　调用的服务是dubbo服务，如何封装这一些公共参数而不是每次调用方法时都做反复的事呢？&lt;br/&gt;三个方法：&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　1. 写一个公共方法，在调用rpc方法前和方法后，都进行调用；&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　　　简单直接且易读，且想加就加更灵活。不好处就是每个地方都要重复写这两段公用代码，不简洁。&lt;br/&gt;　&lt;strong&gt;&lt;span&gt;　2. 使用反射方法，进行调用dubbo方法，在调用前调用后，都进行参数组装，并将日志打印好。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　　　好处是每次只需调用一个反射封装方法，就能完成所有工作，简单实用。坏处是方法被反射调用后，不直观，无法使用ide的语法检查快速发现潜在问题。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　3. 使用切面进行设值处理。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　　　好处是代码无侵入，简洁明了。坏处是新来的同学不易理解一些运行原理，不能很好利用切面辅助，另外，切面规则需要保持一致，否则无法实现处理。&lt;br/&gt;来几个实现的例子吧！&lt;br/&gt;&lt;span&gt;使用公共方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 公用封装参数方法，四处调用，当然这里是不完整的封装，可能还需要更复杂的代码侵入&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; wrapCommonField(Object param) {
        ThreadlocalVar session &lt;/span&gt;=&lt;span&gt; ThreadlocalVar.getVar();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != param &amp;amp;&amp;amp; (param &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BaseDTO)) {
            BaseDTO basePara &lt;/span&gt;=&lt;span&gt; (BaseDTO) param;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; session) {
                basePara.setIp(session.getIp());
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(session.getUserId() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    basePara.setUserId(session.getUserId());
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用，在调用service方法时，先鲁一段该调用代码&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        RpcServiceA serviceA &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RpcServiceA();
        Object param &lt;/span&gt;=&lt;span&gt; ...;
        wrapCommonField(param);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;使用反射：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 公用反射方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T callMethod(Object service, String mName, Object param) {
        ThreadlocalVar session &lt;/span&gt;=&lt;span&gt; ThreadlocalVar.getVar();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != param &amp;amp;&amp;amp; (param &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BaseDTO)) {
            BaseDTO basePara &lt;/span&gt;=&lt;span&gt; (BaseDTO) param;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; session) {
                basePara.setIp(session.getIp());
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(session.getUserId() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    basePara.setUserId(session.getUserId());
                }
            }
        }
        Class&lt;/span&gt;&amp;lt;?&amp;gt; rpcServiceClass =&lt;span&gt; service.getClass();
        logger.info(&lt;/span&gt;&quot;call method:{},param:{}&quot;&lt;span&gt;, mName, param);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Method method &lt;/span&gt;= rpcServiceClass.getMethod(mName, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Class[] { param.getClass() });
            ResponseResult&lt;/span&gt;&amp;lt;T&amp;gt; re = (ResponseResult&amp;lt;T&amp;gt;) method.invoke(rpcService, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[] { param });
            logger.info(&lt;/span&gt;&quot;result:{}&quot;&lt;span&gt;, re);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == re || !&quot;1111&quot;&lt;span&gt;.equals(re.getCode())) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(re.getCode(), re.getMsg());
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; re.getData();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (NoSuchMethodException |&lt;span&gt; InvocationTargetException e) {
            logger.error(&lt;/span&gt;&quot;exception:{}&quot;&lt;span&gt;, e);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (SecurityException | IllegalAccessException |&lt;span&gt; IllegalArgumentException e) {
            logger.error(&lt;/span&gt;&quot;exception:{}&quot;&lt;span&gt;, e);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        }
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        RpcServiceA serviceA &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RpcServiceA();
        Object param &lt;/span&gt;=&lt;span&gt; ...;
        callMethod(serviceA, &lt;/span&gt;&quot;giveMeFive&quot;&lt;span&gt;, param);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;使用切面：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 完整切面类，独立&lt;/span&gt;
@Order(1&lt;span&gt;)
@Component
@Aspect
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SignLoginAop {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger =&lt;span&gt; LoggerFactory.getLogger(getClass());
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CALLAPI_POINT = &quot;execution(* com.xx.api.web.d.*.*(..))&quot;&lt;span&gt;;
    
    @Around(CALLAPI_POINT)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object validSign(ProceedingJoinPoint pjp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException, SecurityException, KydException {
        Object retVal &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        Object[] args &lt;/span&gt;=&lt;span&gt; pjp.getArgs();
        Object param &lt;/span&gt;= (&lt;span&gt;null&lt;/span&gt; != args &amp;amp;&amp;amp; args.length &amp;gt; 0) ? args[0] : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != param &amp;amp;&amp;amp; (param &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BaseDTO)) {
            BaseDTO basePara &lt;/span&gt;=&lt;span&gt; (BaseDTO) param;
            ThreadlocalVar session &lt;/span&gt;=&lt;span&gt; ThreadlocalVar.getSession();
            BaseDTO basePara &lt;/span&gt;=&lt;span&gt; (BaseDTO) param;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; session) {
                basePara.setIp(session.getIp());
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(session.getUserId() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    basePara.setUserId(session.getUserId());
                }
            }
        }
        Signature signature &lt;/span&gt;=&lt;span&gt; pjp.getSignature();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            logger.info(&lt;/span&gt;&quot;call method {}, param:{}&quot;&lt;span&gt;, signature, args);
            retVal &lt;/span&gt;=&lt;span&gt; pjp.proceed(args);
            logger.info(&lt;/span&gt;&quot;end method {}, retVal:{}&quot;&lt;span&gt;, signature, retVal);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.error(&lt;/span&gt;&quot;发生了错误:&quot;&lt;span&gt;, e);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用，独立写业务&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;性能对比！额，就不去收集对比数据了。第一个自然最快。第二、三个不相伯仲！&lt;/p&gt;
&lt;p&gt;封装是为了代码更简洁！哟豁。&lt;/p&gt;

</description>
<pubDate>Thu, 09 Aug 2018 07:13:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yougewe/p/9449091.html</dc:identifier>
</item>
<item>
<title>redis的主从搭建与sentinel高可用服务的搭建 - 一直是小学生</title>
<link>http://www.cnblogs.com/jiang-jt/p/9449035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiang-jt/p/9449035.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　以下内容是记录在公司的测试服务器上安装redis 3.0.7并搭建主从和配置了sentinel服务的过程，验证了一遍当redis主实例宕机后是否会发生主库自动转移，并探究了在故障转移过程中redis实例和sentinel的配置文件的相关参数变化，体会sentinel监控主从、保证主库高可用的基本过程。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;主从搭建&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　在测试服务器P2P-test1(10.19.62.2)上已安装好redis-3.0.7，安装目录为/home/wwwad/software/redis-3.0.7/，test1服务器上只配置了一个redis实例，相关基本配置信息如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　端口号为6999(没有采用redis默认的6379端口号)；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　datadir为&quot;/data/redis/6999/&quot;；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　安装目录为&quot;/data/redis/6999/bin/&quot;；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　配置文件为&quot;/etc/redis/6999.conf&quot;；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　日志文件为&quot;/etc/redis/6999/redis_6999.log&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　在测试服务器test_3(10.19.110.150)上也安装了redis-3.0.7，安装目录为/home/wwwad/redis-3.0.7/目录，test_3服务器上只配置了一个redis实例，相关基本配置信息如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　端口号为6999(没有采用redis默认的6379端口号)；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　datadir为&quot;/data/redis/6999/&quot;；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　安装目录为&quot;/data/redis/6999/bin/&quot;；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　  配置文件为&quot;/etc/redis/6999.conf&quot;；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　  日志文件为&quot;/etc/redis/6999/redis_6999.log&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;开始搭建主从&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　我们让10.19.62.2:6999成为主库，10.19.110.150:6999成为从库。搭建主从很简单，最简单地就是进入test_3的redis上，执行&quot;slaveof 10.19.62.2 6999&quot;即建立了主从，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809143104256-2129083008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;span&gt;执行info replication命令可以看到role为slave，表示本实例为从库。同样地，可以到10.19.62.2上执行相应的命令查看一下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809143213750-451833155.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;span&gt;这种通过命令行搭建起来的主从架构是不稳定的。当主从断开或者主从重启后它们的复制关系就不存在了，无法保证持久复制，所以需要在配置文件里通过参数永久设置主从复制。方式是在从库的配置文件里添加下面参数：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　slaveof 10.19.62.2 6999 #复制参数，指定主库的IP和端口号&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　slave-read-only yes #设置从库为只读&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　masterauth redis123 #如果主库设置了requirepass，那么从库连上主库需要有主库的密码才行，如果不设置改参数，那么主从关系可能可以建立，但是主库有数据更新时从库上不会重现(可以试一下)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　添加后重启从库，进入从库后执行info replication命令，可以发现此时复制关系仍然存在，这是因为配置文件中的参数作用。如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809143335344-825288016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;搭建sentinel服务&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　sentinel中文即哨兵的意思，也就是一个“监视器”。它是通过给定的配置文件来发现主服务器，再通过向主服务器发送info信息来发现该主服务器的从服务器。Sentinel实际上就是一个运行在 Sentienl 模式下的 Redis 服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　·我们先在从服务器上搭建一个sentinel实例，来测试一下效果。首先建立sentinel实例目录：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　[wwwad@test_3 sentinel]$ sudo mkdir /data/redis/sentinel/&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　·将sentinel的配置文件拷贝到/etc/redis/下&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　[wwwad@test_3 redis-3.0.7]$ cp sentinel.conf /etc/redis/sentinel_16999.conf&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　·配置一下下面的关键性的参数，其余的参数默认值即可：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　port 16999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　#指定sentinel的端口号为16999(默认为26379，这里不采用默认的)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　dir &quot;/data/redis/sentinel&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　#指定sentinel的安装目录&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　logfile &quot;/data/redis/sentinel/sentinel_16999.log&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　#指定sentinel的日志文件存放位置&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　daemonize yes&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　#指定是否用守护线程的方式启动sentinel。yes代表启用守护线程，这时sentinel会在后台运行，不占用前端界面；no表不启用守护线程，这时会占用前端界面&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　sentinel monitor mymaster 10.19.62.2 6999 1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　#告诉sentinel主库的位置在10.19.62.2:6999，并将该主库命名为mymaster，1表示在sentinel集群中，有多少个sentinel认为master不可用了，才能真正认定master不可用。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　sentinel auth-pass mymaster redis123&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　#主库设置requirepass，这里需要指定主库的密码&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　·启动sentinel&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　通过命令redis-sentinel并指定配置文件的方式启动sentinel：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　[wwwad@test_3 redis-3.0.7]$ sudo redis-sentinel /etc/redis/sentinel_16999.conf&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809143622589-262918537.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　启动后，查看一下sentinel日志的输出信息，如上图中的倒数第二行表示sentinel找到了主库并加入了监控，倒数第一行表示找到slave并加入到slave列表。这时查看sentinel的配置文件，会发现多了这样的一行：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　sentinel known-slave mymaster 10.19.110.150 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　这表示sentinel将从库信息写到配置文件里保存了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　如果日志的输出信息中没有上面的倒数第一行的信息，表示sentinel没有找到主库所对应的从库，sentinel的启动是不成功的，当主库宕机后sentinel无法实现故障转移。这时候需要进行排错，首先看日志文件的输出信息，然后可能的原因如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　redis-sentinel命令用得对不对；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　sentinel的配置文件配置是否正确；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　主从库的配置文件以及主从关系是否真正建立。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;测试redis的主从故障转移&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1、kill掉10.19.62.2:6999主库后的情形&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　在主库上kill掉主库进程，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809143822085-1210856600.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　在从库上查看从库的状态：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809143909360-1045818668.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　查看sentinel的故障转移过程的输出信息，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:07.173 # +sdown master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:07.173 # +odown master mymaster 10.19.62.2 6999 #quorum 1/1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:07.173 # +new-epoch 25&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:07.173 # +try-failover master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:07.174 # +vote-for-leader aefc57c5a4d0a78bb985d6ab4252a9dfdcd5b099 25&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:07.174 # +elected-leader master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:07.174 # +failover-state-select-slave master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:07.251 # +selected-slave slave 10.19.110.150:6999 10.19.110.150 6999 @ mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:07.251 * +failover-state-send-slaveof-noone slave 10.19.110.150:6999 10.19.110.150 6999 @ mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:07.322 * +failover-state-wait-promotion slave 10.19.110.150:6999 10.19.110.150 6999 @ mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:08.214 # +promoted-slave slave 10.19.110.150:6999 10.19.110.150 6999 @ mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:08.214 # +failover-state-reconf-slaves master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:08.284 # +failover-end master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:08.284 # +switch-master mymaster 10.19.62.2 6999 10.19.110.150 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:08.284 * +slave slave 10.19.62.2:6999 10.19.62.2 6999 @ mymaster 10.19.110.150 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;13747:X 01 Aug 18:05:23.343 # +sdown slave 10.19.62.2:6999 10.19.62.2 6999 @ mymaster 10.19.110.150 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　在这个转移过程中，10.19.110.150:6999的配置文件和sentinel配置文件都有参数改变：10.19.110.150:6999配置文件的slaveof参数被删除；sentinel配置文件sentinel monitor参数指向了新的主库：sentinel monitor mymaster 10.19.110.150 6999 1；sentinel known-slave参数指向了刚才宕掉的10.19.62.2:6999库：sentinel known-slave mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2、重新启动10.19.62.2:6999实例后的情形&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　重新启动10.19.62.2:6999，重启后进入数据库中查看复制状态，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809144037508-541389291.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　这里10.19.62.2:6999启动后即成为10.19.110.150:6999的从库，要知道在启动10.19.62.2:6999时，其配置文件中是没有slaveof参数，但是这里还是建立复制关系。这是因为在之前的故障转移时，sentinel把10.19.62.2:6999作为10.19.110.150:6999的slave存到了配置文件中，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809144133875-1460673894.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　sentinel通过这条配置信息为二者建立了主从关系。再查看10.19.62.2:6999实例的配置文件，会发现多了&quot;slaveof 10.19.110.150 6999&quot;信息，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809144155244-1643598895.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　这时新的主从关系确立了：10.19.62.2:6999变成了从，10.19.110.150:6999变成了主。下面再模拟主库宕机，看sentinel还能不能再切过来。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3、kill掉10.19.110.150:6999后的情形&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　查看10.19.110.150:6999实例的进程id后并杀死，这时在10.19.62.2:6999上查看复制状态，可以看出和预想的一样，10.19.62.2:6999成为了主库。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809144329830-2090233291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　这时再查看下10.19.62.2:6999的配置文件信息，看看还有没有&quot;slaveof 10.19.110.150 6999&quot;信息，如下图：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809144423315-466418891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　很明显，10.19.62.2:6999配置文件中的这条参数配置已被删除。另外再查看sentinel的配置文件，相应地主从库配置也改变了：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809144435009-387311302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　同样地，当启动10.19.110.150:6999实例后，将自动与10.19.62.2:6999建立主从关系，并且10.19.110.150:6999的配置文件里添加了slaveof参数：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809144451827-1751867758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;4、测试sentinel的sentinel notification-script和sentinel client-reconfig-script参数&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　网上有文章说notification-script参数指定的脚本不会执行，而client-reconfig-script参数指定的脚本会执行，下面来验证一下。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;测试client-reconfig-script参数：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　先编辑一个简单的脚本，脚本位于/var/redis/目录下，并赋予脚本可执行权限：chmod 755 /var/redis/reconfig.sh，脚本内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809144709220-790793399.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　在sentinel的配置文件中添加如下一行参数：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　sentinel client-reconfig-script mymaster /var/redis/reconfig.sh&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　重新启动sentinel：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　[wwwad@test_3 sentinel]$ redis-cli -p 16999 shutdown&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　[wwwad@test_3 sentinel]$ sudo redis-sentinel /etc/redis/sentinel_16999.conf&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　此时在/home/wwwad/目录下是没有test_1文件的：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809144748875-101671329.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　现在kill掉redis主库，这时会进行主库切换，sentinel根据配置文件里的client-reconfig-script参数也会去执行reconfig.sh脚本，是否执行过该脚本可以看/home/wwwad/下有没有test_1文件：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809144815905-561781630.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　可以看出，该参数指定脚本是会执行的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;测试sentinel notification-script参数：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　在sentinel配置文件里注释掉sentinel client-reconfig-script参数，添加sentinel notification-script参数：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809144948538-2001458760.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　再重启sentinel，并将/home/wwwad/目录下的test_1文件删除：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809145005859-913589834.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　此时再模拟一次主库故障，即kill掉主库，过一会在/home/wwwad目录下发现test_1文件同样被创建：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809145030753-1521800869.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　可以看出sentinel notification-script参数指定的脚本同样会执行。&lt;/span&gt;&lt;span&gt;所以这两个参数基本上都是有效的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　上面的搭建中，只在10.19.110.150服务器上搭建了一个sentinel，但是一个sentinel容易出现单点问题，所以我们需要配置sentinel集群，在10.19.62.2和10.19.110.150两台服务器上各搭建两个sentinel实例，即redis架构由上图向下图转换：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809145324499-958202647.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809145333836-1992792296.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　先创建sentinel的dir目录，然后将redis安装目录下的sentinel.conf文件复制到/etc/redis/目录下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　[wwwad@P2P-test1 redis]$ sudo mkdir sentinel_15999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　[wwwad@P2P-test1 redis-3.0.7]$ cp sentinel.conf /etc/redis/sentinel_15999.conf&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　修改下sentinel的配置文件，进行如下的基本配置：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　port 15999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　dir &quot;/data/redis/sentinel_15999&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　logfile &quot;/data/redis/sentinel_15999/sentinel_1599.log&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　daemonize yes&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　sentinel monitor mymaster 10.19.62.2 6999 3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　sentinel down-after-milliseconds mymaster 15000&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　sentinel auth-pass mymaster redis123&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　sentinel config-epoch mymaster 38&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　sentinel leader-epoch mymaster 0&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　sentinel current-epoch 38&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　然后开始启动各个sentinel实例，启动后再看各个sentinel的配置文件，会增加如下几行配置信息(以10.19.62.2:15999为例)：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809145443071-847389887.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　上图表示每个sentinel实例都识别到了10.19.110.150:6999从实例以及另外三个sentinel实例的信息，此时构成了sentinel实例集群。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　此时redis主从、sentinel监控集群都部署完毕，再模拟故障转移场景。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;sentinel集群下的主库故障转移&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　在主库10.19.62.2:6999上kill掉主库实例并同时记录kill掉的时间：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226035/201808/1226035-20180809145514171-1125145129.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　查看10.19.62.2:16999 sentinel的日志文件，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.164 # +sdown master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#主观检测到主库不可用&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.222 # +odown master mymaster 10.19.62.2 6999 #quorum 4/3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#投票完成，客观认为主库是不可用的&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;#&lt;/strong&gt;&lt;strong&gt;这里quorum 4/3感觉有些问题，四个sentinel都将quorum配置为3，但是这里居然是4/3，应该是3/3才合理，但是故障转移过程也实现了。。。&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.222 # +new-epoch 43&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.222 # +try-failover master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#开始准备转移主库&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.224 # +vote-for-leader 9d853e5036cf96fbfea10c1a717296ee353f0de3 43&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.226 # 10.19.62.2:15999 voted for 9d853e5036cf96fbfea10c1a717296ee353f0de3 43&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.236 # 10.19.110.150:15999 voted for 9d853e5036cf96fbfea10c1a717296ee353f0de3 43&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.236 # 10.19.110.150:16999 voted for 9d853e5036cf96fbfea10c1a717296ee353f0de3 43&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#以上都是在选举sentinel leader&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.300 # +elected-leader master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.300 # +failover-state-select-slave master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#准备选择一个slave来充当新主&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.377 # +selected-slave slave 10.19.110.150:6999 10.19.110.150 6999 @ mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#选择10.19.110.150:6999为新主&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.377 * +failover-state-send-slaveof-noone slave 10.19.110.150:6999 10.19.110.150 6999 @ mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#改变10.19.110.150:6999的身份，即去除掉其配置文件里slaveof参数&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:42.439 * +failover-state-wait-promotion slave 10.19.110.150:6999 10.19.110.150 6999 @ mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:43.287 # +promoted-slave slave 10.19.110.150:6999 10.19.110.150 6999 @ mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#提升10.19.110.150:6999为主库&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:43.287 # +failover-state-reconf-slaves master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:43.368 # +failover-end master mymaster 10.19.62.2 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#表示故障转移成功&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:43.369 # +switch-master mymaster 10.19.62.2 6999 10.19.110.150 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#master的地址发生变化&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:43.369 * +slave slave 10.19.62.2:6999 10.19.62.2 6999 @ mymaster 10.19.110.150 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;15168:X 03 Aug 11:42:58.420 # +sdown slave 10.19.62.2:6999 10.19.62.2 6999 @ mymaster 10.19.110.150 6999&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#以上是添加其他slave到新主下，但10.19.62.2:6999处于不可用状态&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;查看日志，发现sentinel是在11:42:42秒开始进行故障转移，到11:42:58秒结束，而故障是发生在11:42:27秒。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 07:07:00 +0000</pubDate>
<dc:creator>一直是小学生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiang-jt/p/9449035.html</dc:identifier>
</item>
<item>
<title>js事件委托代码优化【感悟总结】 - 张少凯</title>
<link>http://www.cnblogs.com/shaokai7878/p/9448839.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shaokai7878/p/9448839.html</guid>
<description>&lt;p&gt;前两天接手了同事的一个项目，是一个网站首页，其中有段代码很累赘，要实现的功能就是，&lt;/p&gt;
&lt;p&gt;通过给父元素添加鼠标移入移出事件，来控制子元素显示隐藏。&lt;/p&gt;
&lt;p&gt;html代码，一共有四个父元素div，每个父元素嵌套一个子元素div，&lt;/p&gt;
&lt;p&gt;这是截取了其中一个div：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1448663/201808/1448663-20180809144629866-9696886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最简单粗暴的方法莫过于这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1448663/201808/1448663-20180809142930684-1649301314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接写八个方法，分别设置属性的样式block或者none。&lt;/p&gt;
&lt;p&gt;这样写虽然简单，但是出于代码优化，页面响应速度的关系，我们还是需要改动的。&lt;/p&gt;
&lt;p&gt;问了问同事，说看看有关事件委托的相关方法，能有效解决这个问题。&lt;/p&gt;
&lt;p&gt;经过一顿操作之后，楼主写出了如下代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1448663/201808/1448663-20180809143300738-467780010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这么写能实现效果了，可是在查看控制台的时候竟然一片飘红。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1448663/201808/1448663-20180809143347146-392223029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实在是头痛啊，看到这个。明明效果实现了，为什么还报错呢？&lt;/p&gt;
&lt;p&gt;今天中午午休的时候，趴着想了想，突然就来了灵感。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1448663/201808/1448663-20180809143512414-2108467072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是修改之后的代码。看完你就明白，这是因为target指代的是当前对象，&lt;/p&gt;
&lt;p&gt;当鼠标移到父元素div时，子元素div属性变为block，会显示出来。&lt;/p&gt;
&lt;p&gt;但是当你移动到子元素div上时，target就指向了子元素，而子元素没有firstElementChild，所以会报错。&lt;/p&gt;
&lt;p&gt;这时我们只需加个判断，如果子对象不存在，那么就修改当前对象的属性。&lt;/p&gt;
&lt;p&gt;否则，也就是子对象存在的情况，那就修改子对象属性。&lt;/p&gt;
&lt;p&gt;经过了两天的折腾，终于优化了这么一小段代码。&lt;/p&gt;
&lt;p&gt;本来是想到的for循环，但是这样循环下来，dom操作还是很多。&lt;/p&gt;
&lt;p&gt;感谢给我提醒事件委托的那位朋友，以上代码有不足之处欢迎指教。&lt;/p&gt;
&lt;p&gt;刚参加工作，还有很多学习的地方，欢迎大家提出批评建议。&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 06:42:00 +0000</pubDate>
<dc:creator>张少凯</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shaokai7878/p/9448839.html</dc:identifier>
</item>
<item>
<title>运用 node + express + http-proxy-middleware 实现前端代理跨域的  详细实例哦 - yulijian</title>
<link>http://www.cnblogs.com/oxiaojiano/p/9448628.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oxiaojiano/p/9448628.html</guid>
<description>&lt;h2 id=&quot;一你需要准备的知识储备&quot;&gt;一、你需要准备的知识储备&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;运用node的包管理工具npm 安装插件、中间件的基本知识；&lt;br/&gt;2.express框架的一些基础知识，知道如何建立一个小的服务器；晓得如何快速的搭建一个express框架小应用；&lt;br/&gt;3.还需要一些前端的基础小知识，html\css\js\jquery&lt;br/&gt;4。最重要的一点就是知道怎么产生的跨域，要是不知道怎么产生的跨域，如何知道需要去破解它呢？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二实例的代码分析&quot;&gt;二、实例的代码分析&lt;/h2&gt;
&lt;h3 id=&quot;场景分析我本地的域名为http.localhost8080我要请求的地址是http..com&quot;&gt;场景分析，我本地的域名为&amp;lt;http.localhost:8080&amp;gt;，我要请求的地址是&amp;lt;http.****.com&amp;gt;&lt;/h3&gt;
&lt;h4 id=&quot;html页面代码express生成的public文件夹下的index.html-----稍后会有图片展示目录关系&quot;&gt;html页面代码（express生成的public文件夹下的index.html)-----稍后会有图片展示目录关系。&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;form action=&quot;&quot; method='GET'&amp;gt;
        &amp;lt;input type=&quot;submit&quot;&amp;gt;
        &amp;lt;input type=&quot;hidden&quot; name='__method' value='search'&amp;gt;
    &amp;lt;/form&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    $.ajax({
        url: '/api/message/alllist/new',
        type: 'get',
        dataType: 'json',
        success: function(res) {
            console.log(res)
        }
    })
&amp;lt;/script&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;app.js页面代码express生成的app.js&quot;&gt;app.js页面代码(express生成的app.js）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;
var createError = require('http-errors');
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var indexRouter = require('./routes/index');
var usersRouter = require('./routes/users');

var app = express();
var proxyMiddleware = require('http-proxy-middleware');

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');



// app.use(function(req, res, next) {
//     console.log(req.query.__method, req.method);

//     req.old = req.method;
//     req.method = req.query.__method;
//     next();
// })
app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({
    extended: false
}));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));


app.middleware = [
    proxyMiddleware(['/api/message/alllist/*'], {
        target: 'http://***.com',//将要代理的地址
        changeOrigin: true
    })
];

app.use(app.middleware);
// catch 404 and forward to error handler
app.use(function(req, res, next) {
    next(createError(404));
});

// error handler
app.use(function(err, req, res, next) {
    // set locals, only providing error in development
    res.locals.message = err.message;
    res.locals.error = req.app.get('env') === 'development' ? err : {};

    // render the error page
    res.status(err.status || 500);
    res.render('error');
});

module.exports = app;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;目录图片&quot;&gt;目录图片&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1073936/201808/1073936-20180809135645766-1813571625.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;自己大白话解释&quot;&gt;自己大白话解释：&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;首先要安装http-proxy-middleware ，&lt;code&gt;npm install http-proxy-middleware --save-dev&lt;/code&gt;,然后再页面中引用。&lt;br/&gt;&lt;code&gt;app.middleware = [ proxyMiddleware(['/api/message/alllist/*'], { target: 'http://***.com', changeOrigin: true }) ];&lt;/code&gt;将服务器代理到这个地址，并将匹配路由/api/message/alllist/*&lt;br/&gt;启动服务器，可以用node的本身的命令 node app.js 或者可以用expess框架中的命令 npm start (package.json中)；这时候的终端显示为&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1073936/201808/1073936-20180809140635015-860619084.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最后在浏览器中输入地址 ：localhost:3100，&lt;strong&gt;注意&lt;/strong&gt;这里面的地址是你自己启动的服务器的地址以及端口；我的端口号是3100。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1073936/201808/1073936-20180809141021212-1301705343.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1073936/201808/1073936-20180809141046030-1769747494.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问过后查看终端变化，显示请求成功&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1073936/201808/1073936-20180809141211008-1195029184.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;至此你请求的数据就是你代理的服务器上的数据这就是我对用node-expresshttp-proxy-middleware进行跨域请求得见解如果有大神觉得有不对的地方欢迎指正以及欢迎志同道合的同志一起研究技术&quot;&gt;至此你请求的数据就是你代理的服务器上的数据，这就是我对用node +express+http-proxy-middleware进行跨域请求得见解，如果有大神觉得有不对的地方欢迎指正，以及欢迎志同道合的同志一起研究技术。&lt;/h3&gt;
</description>
<pubDate>Thu, 09 Aug 2018 06:17:00 +0000</pubDate>
<dc:creator>yulijian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/oxiaojiano/p/9448628.html</dc:identifier>
</item>
<item>
<title>从零开始学 Web 之 移动Web（三）Zepto - Daotin</title>
<link>http://www.cnblogs.com/lvonve/p/9448530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvonve/p/9448530.html</guid>
<description>&lt;blockquote readability=&quot;6.9491150442478&quot;&gt;
&lt;p&gt;大家好，这里是「 从零开始学 Web 系列教程 」，并在下列地址同步更新......&lt;/p&gt;
&lt;p&gt;在这里我会从 Web 前端零基础开始，一步步学习 Web 相关的知识点，期间也会分享一些好玩的项目。现在就让我们一起进入 Web 前端学习的探索之旅吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Daotin/pic/raw/master/fgx.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一zepto简介&quot;&gt;一、Zepto简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754332/201808/754332-20180809140217741-2119949132.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Zepto是一个轻量级的针对现代高级浏览器的 &lt;strong&gt;JavaScript库&lt;/strong&gt;， 它&lt;strong&gt;与jquery有着类似的api。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Zepto 主要使用在移动端浏览器上面，由于移动端的浏览器都是比较新的平台，而 jQuery 主要是在 PC 上为了浏览器的兼容性而使用的，所以&lt;strong&gt;在移动端一般不使用 jQuery，因为它的兼容性失去了意义。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zepto 就是移动端代替 jQuery 的 js 库，它封装了很多关于手势操作的方法。如果你会用jquery，那么你也会用zepto。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Zepto js 库文件的下载地址：&lt;a href=&quot;https://github.com/madrobby/zepto&quot; class=&quot;uri&quot;&gt;https://github.com/madrobby/zepto&lt;/a&gt; ，直接下载源码文件，相应的所有 js 文件就在 src 目录下。&lt;/p&gt;
&lt;h2 id=&quot;二手势事件封装&quot;&gt;二、手势事件封装&lt;/h2&gt;
&lt;p&gt;Zepto 将移动端的 &lt;code&gt;touchStart&lt;/code&gt;，&lt;code&gt;touchmove&lt;/code&gt; 和 &lt;code&gt;touchEnd&lt;/code&gt; 封装成了一系列事件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tap&lt;/code&gt; ：触摸屏幕时触发。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;singleTap&lt;/code&gt; ：单击屏幕时触发&lt;/p&gt;
&lt;p&gt;&lt;code&gt;doubleTap&lt;/code&gt;：双击屏幕时触发。(如果你不需要检测单击、双击，使用 tap 代替)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;longTap&lt;/code&gt; ：长按时触发。当一个元素被按住超过750ms触发。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swipe&lt;/code&gt;：滑动屏幕时触发。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swipeLeft, swipeRight, swipeUp, swipeDown&lt;/code&gt;：屏幕左滑，右滑，上滑，下滑时触发。&lt;/p&gt;
&lt;h2 id=&quot;三zepto-模块化&quot;&gt;三、Zepto 模块化&lt;/h2&gt;
&lt;p&gt;Zepto 有一点和 jQuery 是不同的，就是 Zepto 是分模块的。在使用的时候不是像 jQuery 只需要引入一个 js 文件就可以了。Zepto 是分模块的。&lt;/p&gt;
&lt;p&gt;默认的 &lt;strong&gt;Zepto.js&lt;/strong&gt; 文件只包含下面一些功能：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;event&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;通过&lt;code&gt;on()&lt;/code&gt;&amp;amp; &lt;code&gt;off()&lt;/code&gt;处理事件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ajax&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;XMLHttpRequest 和 JSONP 实用功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;form&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;序列化 &amp;amp; 提交web表单&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ie&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;增加支持桌面的Internet Explorer 10+和Windows Phone 8。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果要使用到其他的功能，就需要包含其他的 js 文件：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;14.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;fx.js&lt;/td&gt;
&lt;td&gt;The &lt;code&gt;animate()&lt;/code&gt;方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;fx_methods.js&lt;/td&gt;
&lt;td&gt;以动画形式的 &lt;code&gt;show&lt;/code&gt;, &lt;code&gt;hide&lt;/code&gt;, &lt;code&gt;toggle&lt;/code&gt;, 和 &lt;code&gt;fade*()&lt;/code&gt;方法.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;assets.js&lt;/td&gt;
&lt;td&gt;实验性支持从DOM中移除image元素后清理iOS的内存。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;data.js&lt;/td&gt;
&lt;td&gt;一个全面的 &lt;code&gt;data()&lt;/code&gt;方法, 能够在内存中存储任意对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;deferred.js&lt;/td&gt;
&lt;td&gt;提供 &lt;code&gt;$.Deferred&lt;/code&gt;promises API. 依赖&quot;callbacks&quot; 模块. 当包含这个模块时候, &lt;code&gt;$.ajax()&lt;/code&gt; 支持promise接口链式的回调。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;callbacks.js&lt;/td&gt;
&lt;td&gt;为&quot;deferred&quot;模块提供 &lt;code&gt;$.Callbacks&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;selector.js&lt;/td&gt;
&lt;td&gt;实验性的支持 jQuery CSS 表达式 实用功能，比如 &lt;code&gt;$('div:first')&lt;/code&gt;和&lt;code&gt;el.is(':visible')&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;touch.js&lt;/td&gt;
&lt;td&gt;在触摸设备上触发tap– 和 swipe– 相关事件。这适用于所有的&lt;code&gt;touch&lt;/code&gt;(iOS, Android)和&lt;code&gt;pointer&lt;/code&gt;事件(Windows Phone)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;gesture.js&lt;/td&gt;
&lt;td&gt;在触摸设备上触发 pinch 手势事件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;stack.js&lt;/td&gt;
&lt;td&gt;提供 &lt;code&gt;andSelf&lt;/code&gt;&amp;amp; &lt;code&gt;end()&lt;/code&gt;链式调用方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;ios3.js&lt;/td&gt;
&lt;td&gt;String.prototype.trim 和 Array.prototype.reduce 方法 (如果他们不存在) ，以兼容 iOS 3.x.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以，每次在使用到某一个功能的时候，就需要到 html 文件下添加相应的 js 库文件，这样就比较繁琐，更重要的是多个 js 文件会增加访问服务器的次数，那么我们可不可以像 jQuery 一样，只包含一个 js 库文件就包括所有的功能呢？&lt;/p&gt;
&lt;p&gt;答案是肯定的。&lt;/p&gt;
&lt;h2 id=&quot;四zepto-的定制&quot;&gt;四、Zepto 的定制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Zepto 允许将多个 js 文件打包成一个 js 文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、安装 Nodejs 环境&lt;/p&gt;
&lt;p&gt;2、下载 zepto.js 源码并解压好。&lt;/p&gt;
&lt;p&gt;4、cmd 命令行进入解压缩后的目录&lt;/p&gt;
&lt;p&gt;5、执行&lt;code&gt;npm install&lt;/code&gt; 命令（这一步需要联网下载）&lt;/p&gt;
&lt;p&gt;6、编辑 zepto.js 源码中的 make文件，添加自定义模块并保存，如下&lt;/p&gt;
&lt;p&gt;原来的：&lt;code&gt;modules = (env['MODULES'] || 'zepto event ajax form ie').split(' ')&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;增加自己需要的模块：&lt;code&gt;modules = (env['MODULES'] || 'zepto event ajax form ie fx selector touch').split(' ')&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;7、然后执行命令 &lt;code&gt;npm run-script dist&lt;/code&gt;（这一步会在当前目录生成一个dist文件夹）&lt;br/&gt;8、查看目录 dist ，里面就有我们打包好的 zepto.js 库文件。&lt;/p&gt;
&lt;h2 id=&quot;五使用-zepto-实现京东移动首页&quot;&gt;五、使用 zepto 实现京东移动首页&lt;/h2&gt;
&lt;p&gt;相关源码已放置 &lt;a href=&quot;https://github.com/Daotin/Web/tree/master/Code/src/11/jd.zip&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下为详细代码：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./css/base.css&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&amp;gt;
    &amp;lt;!-- &amp;lt;script src=&quot;./js/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
    &amp;lt;script src=&quot;./zepto-master/src/zepto.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./zepto-master/src/fx.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./zepto-master/src/selector.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./zepto-master/src/touch.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./js/index-zepto.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;jd&quot;&amp;gt;
        &amp;lt;!-- 搜索栏开始 --&amp;gt;
        &amp;lt;div class=&quot;search&quot;&amp;gt;
            &amp;lt;a href=&quot;javascript:;&quot; class=&quot;search-logo&quot;&amp;gt;&amp;lt;/a&amp;gt;
            &amp;lt;form action=&quot;&quot; class=&quot;search-text&quot;&amp;gt;
                &amp;lt;input type=&quot;text&quot; placeholder=&quot;请输入商品名称&quot;&amp;gt;
            &amp;lt;/form&amp;gt;
            &amp;lt;a href=&quot;javascript:;&quot; class=&quot;search-login&quot;&amp;gt;登录&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;!-- 搜索栏结束 --&amp;gt;

        &amp;lt;!-- 轮播图开始 --&amp;gt;
        &amp;lt;div class=&quot;slideshow&quot;&amp;gt;
            &amp;lt;ul class=&quot;slideshow-img clearfix&quot;&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/l1.jpg&quot; alt=&quot;&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/l2.jpg&quot; alt=&quot;&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/l3.jpg&quot; alt=&quot;&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/l4.jpg&quot; alt=&quot;&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/l5.jpg&quot; alt=&quot;&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/l6.jpg&quot; alt=&quot;&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/l7.jpg&quot; alt=&quot;&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/l8.jpg&quot; alt=&quot;&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
            &amp;lt;ul class=&quot;slideshow-dot&quot;&amp;gt;
                &amp;lt;li class=&quot;select&quot;&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;!-- 轮播图结束 --&amp;gt;

        &amp;lt;!-- 导航栏开始 --&amp;gt;
        &amp;lt;div class=&quot;nav&quot;&amp;gt;
            &amp;lt;ul class=&quot;nav-ul clearfix&quot;&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/nav0.png&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                    &amp;lt;p&amp;gt;商品分类&amp;lt;/p&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/nav1.png&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                    &amp;lt;p&amp;gt;商品分类&amp;lt;/p&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/nav2.png&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                    &amp;lt;p&amp;gt;商品分类&amp;lt;/p&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/nav3.png&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                    &amp;lt;p&amp;gt;商品分类&amp;lt;/p&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/nav4.png&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                    &amp;lt;p&amp;gt;商品分类&amp;lt;/p&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/nav5.png&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                    &amp;lt;p&amp;gt;商品分类&amp;lt;/p&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/nav6.png&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                    &amp;lt;p&amp;gt;商品分类&amp;lt;/p&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img src=&quot;./uploads/nav7.png&quot;&amp;gt;
                    &amp;lt;/a&amp;gt;
                    &amp;lt;p&amp;gt;商品分类&amp;lt;/p&amp;gt;
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;!-- 导航栏结束 --&amp;gt;

        &amp;lt;!-- 主体内容开始 --&amp;gt;
        &amp;lt;div class=&quot;content&quot;&amp;gt;
            &amp;lt;div class=&quot;content-box clearfix content-box-sk&quot;&amp;gt;
                &amp;lt;div class=&quot;content-title&quot;&amp;gt;
                    &amp;lt;span class=&quot;content-title-left-clock&quot;&amp;gt;&amp;lt;/span&amp;gt;
                    &amp;lt;span class=&quot;content-title-left-text fl&quot;&amp;gt;掌上秒杀&amp;lt;/span&amp;gt;
                    &amp;lt;div class=&quot;content-title-left-time fl&quot;&amp;gt;
                        &amp;lt;span&amp;gt;0&amp;lt;/span&amp;gt;
                        &amp;lt;span&amp;gt;0&amp;lt;/span&amp;gt;
                        &amp;lt;span&amp;gt;:&amp;lt;/span&amp;gt;
                        &amp;lt;span&amp;gt;0&amp;lt;/span&amp;gt;
                        &amp;lt;span&amp;gt;0&amp;lt;/span&amp;gt;
                        &amp;lt;span&amp;gt;:&amp;lt;/span&amp;gt;
                        &amp;lt;span&amp;gt;0&amp;lt;/span&amp;gt;
                        &amp;lt;span&amp;gt;0&amp;lt;/span&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;span class=&quot;content-title-right fr&quot;&amp;gt;更多秒杀...&amp;lt;/span&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;lu class=&quot;content-ul clearfix&quot;&amp;gt;
                    &amp;lt;li&amp;gt;
                        &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                            &amp;lt;img src=&quot;./uploads/detail01.jpg&quot; alt=&quot;&quot; class=&quot;br&quot;&amp;gt;
                        &amp;lt;/a&amp;gt;
                        &amp;lt;p&amp;gt;￥10.00&amp;lt;/p&amp;gt;
                        &amp;lt;p class=&quot;content-ul-delete&quot;&amp;gt;￥20.00&amp;lt;/p&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;
                        &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                            &amp;lt;img src=&quot;./uploads/detail01.jpg&quot; alt=&quot;&quot; class=&quot;br&quot;&amp;gt;
                        &amp;lt;/a&amp;gt;
                        &amp;lt;p&amp;gt;￥10.00&amp;lt;/p&amp;gt;
                        &amp;lt;p class=&quot;content-ul-delete&quot;&amp;gt;￥20.00&amp;lt;/p&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;
                        &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                            &amp;lt;img src=&quot;./uploads/detail01.jpg&quot; alt=&quot;&quot;&amp;gt;
                        &amp;lt;/a&amp;gt;
                        &amp;lt;p&amp;gt;￥10.00&amp;lt;/p&amp;gt;
                        &amp;lt;p class=&quot;content-ul-delete&quot;&amp;gt;￥20.00&amp;lt;/p&amp;gt;
                    &amp;lt;/li&amp;gt;
                &amp;lt;/lu&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;content-box clearfix&quot;&amp;gt;
                &amp;lt;div class=&quot;content-title&quot;&amp;gt;
                    &amp;lt;h3&amp;gt;京东超市&amp;lt;/h3&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;lu class=&quot;content-ul&quot;&amp;gt;
                    &amp;lt;li class=&quot;fl&quot;&amp;gt;
                        &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                            &amp;lt;img src=&quot;./uploads/cp1.jpg&quot; alt=&quot;&quot;&amp;gt;
                        &amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li class=&quot;fl bl bb&quot;&amp;gt;
                        &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                            &amp;lt;img src=&quot;./uploads/cp2.jpg&quot; alt=&quot;&quot;&amp;gt;
                        &amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li class=&quot;fl bl&quot;&amp;gt;
                        &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                            &amp;lt;img src=&quot;./uploads/cp3.jpg&quot; alt=&quot;&quot;&amp;gt;
                        &amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                &amp;lt;/lu&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;content-box clearfix&quot;&amp;gt;
                &amp;lt;div class=&quot;content-title&quot;&amp;gt;
                    &amp;lt;h3&amp;gt;京东超市&amp;lt;/h3&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;lu class=&quot;content-ul&quot;&amp;gt;
                    &amp;lt;li class=&quot;fr&quot;&amp;gt;
                        &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                            &amp;lt;img src=&quot;./uploads/cp4.jpg&quot; alt=&quot;&quot;&amp;gt;
                        &amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li class=&quot;fl bl bb&quot;&amp;gt;
                        &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                            &amp;lt;img src=&quot;./uploads/cp5.jpg&quot; alt=&quot;&quot;&amp;gt;
                        &amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                    &amp;lt;li class=&quot;fl bl&quot;&amp;gt;
                        &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                            &amp;lt;img src=&quot;./uploads/cp6.jpg&quot; alt=&quot;&quot;&amp;gt;
                        &amp;lt;/a&amp;gt;
                    &amp;lt;/li&amp;gt;
                &amp;lt;/lu&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;!-- 主体内容结束 --&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;js 文件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(function () {  
    // 1.在开始和最后位置添加图片
    // 2.重新设置图片盒子的宽度和图片的宽度
    // 3.添加定时器，自动轮播
    // 4.添加过渡结束事件
    // 5.设置小白点
    // 6.添加手动轮播

    // 获取元素
    var ulObj = $(&quot;.slideshow-img&quot;);
    var first = ulObj.find(&quot;li:first-of-type&quot;);
    var last = ulObj.find(&quot;li:last-of-type&quot;);

    var bannerWidth = $(&quot;.slideshow&quot;).width();

    // 在开始和最后位置添加图片
    ulObj.append(first.clone());
    last.clone().insertBefore(first);

    // 重新设置图片盒子的宽度和图片的宽度
    var liObjs = ulObj.find(&quot;li&quot;);

    ulObj.width(liObjs.length +&quot;00%&quot;);
    liObjs.each(function (index) {  
        // 数组是DOM操作，要转换成zepto元素
        $(liObjs[index]).width(bannerWidth);
    });    

    // 设置默认显示第一张图
    ulObj.css(&quot;transform&quot;, &quot;translateX(&quot;+ -bannerWidth +&quot;px)&quot;);

    var index = 1;

    // 盒子改变大小的时候重现设置图片盒子的宽度和图片的宽度
    $(window).on(&quot;resize&quot;, function () {  
        ulObj.width(liObjs.length +&quot;00%&quot;);
        liObjs.each(function (index) {  
            // 数组是DOM操作，要转换成zepto元素
            $(liObjs[index]).width($(&quot;.slideshow&quot;).width());            
        });
        ulObj.css(&quot;transform&quot;, &quot;translateX(&quot;+ -$(&quot;.slideshow&quot;).width()*index +&quot;px)&quot;);
    });

    // 轮播动画函数
    var setAnimate = function () {  
        ulObj.animate(
            {&quot;transform&quot;: &quot;translateX(&quot;+ -$(&quot;.slideshow&quot;).width()*index +&quot;px)&quot;},
            500,
            &quot;linear&quot;,
            function () {  // 过渡结束事件回调函数
                if(index == 0) {
                    index = liObjs.length -2;
                    ulObj.css(&quot;transform&quot;, &quot;translateX(&quot;+ -$(&quot;.slideshow&quot;).width()*index +&quot;px)&quot;);
                } else if(index == liObjs.length -1) {
                    index = 1;
                    ulObj.css(&quot;transform&quot;, &quot;translateX(&quot;+ -$(&quot;.slideshow&quot;).width()*index +&quot;px)&quot;);
                }
                // 设置小白点
                $(&quot;.slideshow-dot&quot;).children(&quot;li&quot;).removeClass(&quot;select&quot;).eq(index-1).addClass(&quot;select&quot;);          
    
            }
        );
    };

    var timerId;
    // 添加定时器，自动轮播
    var timerStart = function () {  
        timerId = setInterval(function () {  
            index++;
            setAnimate();
        }, 1500);
    };
    timerStart();

    // 手动轮播操作
    ulObj.on(&quot;swipeLeft&quot;, function () {
        clearInterval(timerId);
        index++;
        setAnimate();
        //手动轮播操作完成后再开启定时器
        timerStart();
    });
    ulObj.on(&quot;swipeRight&quot;, function () {
        clearInterval(timerId);
        index--;
        setAnimate();
        // 手动轮播操作完成后再开启定时器
        timerStart();
    });

    //------------------------------------------------

    // 搜索栏上下滚动时改变透明度
    var bannerEffect = function () {  
        var bannerObj = $(&quot;.search&quot;);
        var slideshowObj = $(&quot;.slideshow&quot;);
        var bannerHeight = bannerObj.height();
        var imgHeight = slideshowObj.height();
        // console.log(bannerHeight + '  ' + imgHeight);

        $(window).on(&quot;scroll&quot;, function (e) {  
            var scrollHeight = $(window).scrollTop();            
            if(scrollHeight &amp;lt; (imgHeight-bannerHeight)) {
                var setopacity = scrollHeight / (imgHeight-bannerHeight);
                bannerObj.css(&quot;backgroundColor&quot;, &quot;rgba(233, 35, 34,&quot;+setopacity+&quot;)&quot;);
            }
            
        });
        
    };
    bannerEffect();

    //-----------------------------------------------------

    // 设置倒计时
    var timerCount = function () {  
        var timers = $(&quot;.content-title-left-time&quot;).children(&quot;span&quot;);
        var titleCount = 2*60*60;

        var timerId = setInterval(function () {  
            titleCount--;
            var hour = Math.floor(titleCount / 3600);
            var minute = Math.floor((titleCount % 3600) / 60);
            var second = titleCount % 60;

            if(titleCount &amp;gt;= 0) {
                $(timers[0]).html(Math.floor(hour / 10));
                $(timers[1]).html(hour % 10);
                $(timers[3]).html(Math.floor(minute / 10));
                $(timers[4]).html(minute % 10);
                $(timers[6]).html(Math.floor(second / 10));
                $(timers[7]).html(second % 10);
            } else {
                titleCount = 0;
                clearInterval(timerId);
                return;
            }

        }, 1000);
    };
    timerCount();

});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754332/201808/754332-20180809135956776-1402224882.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Daotin/pic/raw/master/fgx.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 06:03:00 +0000</pubDate>
<dc:creator>Daotin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvonve/p/9448530.html</dc:identifier>
</item>
<item>
<title>execl导入工具 - 云枭zd</title>
<link>http://www.cnblogs.com/fixzd/p/9448344.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fixzd/p/9448344.html</guid>
<description>&lt;p&gt;execl导入工具&lt;/p&gt;
&lt;p&gt;整个项目的代码结构如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    \---execlExport # 导出工具包
        |   AsyncExportExecl.java #多线程导出
        |   ExeclImport.java # 导出工具类
        |
        +---data
        |       BaseParam.java # 基础导出参数类
        |
        +---dataConversion
        |       DataExportConversion.java # 属性导出转换接口
        |
        +---defaultDataHandle # 默认的数据处理
        |       AbstractDataHandler.java
        |       BooleanDataHandler.java
        |       DataHandlerFactory.java
        |       DateDataHandler.java
        |       StringDataHandler.java
        |
        \---style # 默认的样式
                AbstractCellStyle.java
                DefaultDataCellStyle.java
                DefaultTitleCellStyle.java

com
\---utils
    +---demo # 案例相关
    |   |   ExeclImportApplication.java # springboot启动类
    |   |
    |   +---bean
    |   |       DemoBean.java # 测试bean
    |   |
    |   +---controller
    |   |       ExeclImportController.java # 测试从web导入execl和从文件导入execl
    |   |
    |   \---importParam
    |       |   DemoImportParam.java # 导入参数
    |       |
    |       \---dataConversion
    |               HobbyConversion.java # 爱好属性导入转换类
    |
    \---execlImport # 导入工具包
        |   ExeclImport.java # 导入工具类
        |
        +---data
        |       CellParam.java # 导入列参数类
        |
        \---dataConversion
            |   DataImportConversion.java # 属性导入转换接口
            |
            \---impl
                    DateConversion.java # 日期属性导入转换接口
                    MapConversion.java  # 键值对属性导入转换接口              &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单的来说execl导入可以分为几步&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上传execl文件&lt;/li&gt;
&lt;li&gt;将execl转换为数据，有需要的数据进行转换&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;execlimport工具类&quot;&gt;2.1 ExeclImport工具类&lt;/h2&gt;
&lt;p&gt;首先实例化ExeclImport工具类，我这里提供了一个构造函数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ExeclImport(Class&amp;lt;T&amp;gt; clazz, List&amp;lt;CellParam&amp;gt; cellParams)&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;clazz&lt;/td&gt;
&lt;td&gt;Class对象（需要转换为Bean的Class对象）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cellParams&lt;/td&gt;
&lt;td&gt;CellParam的list列表（每一列对应的字段及数据转换类）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;实例化ExeclImport工具类之后，需要调用importExecl方法,方法定义如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public List&amp;lt;T&amp;gt; importExecl(InputStream is)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要传入InputStream即可。&lt;/p&gt;
&lt;h2 id=&quot;导入列参数类cellparam&quot;&gt;2.2 导入列参数类CellParam&lt;/h2&gt;
&lt;p&gt;CellParam类代码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CellParam {
    private String fieldName;
    private DataImportConversion conversion;
    
    //Set Get Constructor
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;属性&quot;&gt;2.2.1 属性&lt;/h3&gt;
&lt;p&gt;可以看到CellParam类有两个属性&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private String fieldName;
private DataImportConversion conversion;&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;fieldName&lt;/td&gt;
&lt;td&gt;列对应Bean的属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;conversion&lt;/td&gt;
&lt;td&gt;数据转换类&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;数据转换接口dataimportconversion&quot;&gt;2.3 数据转换接口DataImportConversion&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface DataImportConversion&amp;lt;T&amp;gt; {
    T transferData(Object data);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里默认提供了两种数据转换，一个是键值对，另一个是日期&lt;/p&gt;
&lt;h3 id=&quot;键值对数据转换&quot;&gt;2.3.1 键值对数据转换&lt;/h3&gt;
&lt;p&gt;键值对数据转换类是为了将一些通用数据转换而提供的。&lt;br/&gt;例如：男女、是否和一些不同名称对应的不同数字（正常--&amp;gt;0,异常--&amp;gt;1,其他--&amp;gt;2）&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用者可以通过传入的map的泛型决定返回值的类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MapConversion&amp;lt;K,V&amp;gt; implements DataImportConversion&amp;lt;V&amp;gt; {

    private Map&amp;lt;K,V&amp;gt; map ;

    private V defaultReturnValue;

    public MapConversion(Map&amp;lt;K, V&amp;gt; map) {
        this(map,null);
    }

    public MapConversion(Map&amp;lt;K, V&amp;gt; map,V defaultReturnValue) {
        this.map = map;
        this.defaultReturnValue = defaultReturnValue;
    }

    @Override
    public V transferData(Object data) {
        if (map == null) return null;

        //如果data为null且map的null对应的值不为null，则直接返回map中null对应的值
        if (data == null &amp;amp;&amp;amp; map.get(null) != null){
            return map.get(null);
        }

        //循环查找对应的key
        for (Map.Entry&amp;lt;K,V&amp;gt; entry:map.entrySet()){
            if (entry.getKey() != null &amp;amp;&amp;amp; entry.getKey().equals(data)){
                return entry.getValue();
            }
        }
        //如果map里面找不到对应的数据，则返回defaultReturnValue
        return defaultReturnValue;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;日期数据转换&quot;&gt;2.3.2 日期数据转换&lt;/h3&gt;
&lt;p&gt;提供日期转换功能，通过传入的日期转换格式进行转换。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DateConversion implements DataImportConversion&amp;lt;Date&amp;gt; {
    private SimpleDateFormat format;

    public DateConversion(String pattern) {
        this.format = new SimpleDateFormat(pattern);
    }

    @Override
    public Date transferData(Object data) {
        try {
            return format.parse(data.toString());
        } catch (Exception e){
            e.printStackTrace();
        }

        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;场景&quot;&gt;3.1 场景&lt;/h2&gt;
&lt;p&gt;原始数据如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;尘心&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;td&gt;2018-08-08 14:59:11&lt;/td&gt;
&lt;td&gt;舞刀,弄枪&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;千月&lt;/td&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;td&gt;2018-08-08 14:59:11&lt;/td&gt;
&lt;td&gt;唱歌,跳舞&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;需要转换为实体bean的列表，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DemoBean{name='尘心', sex=0, birthday=Wed Aug 08 14:13:45 CST 2018, hobbies=[舞刀, 弄枪]}
DemoBean{name='千月', sex=1, birthday=Wed Aug 08 14:13:45 CST 2018, hobbies=[唱歌, 跳舞]}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实体类如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DemoBean {

    //姓名
    private String name;

    //性别，0-&amp;gt;女,1-&amp;gt;男
    private Integer sex;

    //出生日期
    private Date birthday;

    //爱好
    private List&amp;lt;String&amp;gt; hobbies;

    //Set Get
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据转换&quot;&gt;3.2 数据转换&lt;/h2&gt;
&lt;p&gt;可以看到有三个属性需要转换，分别是性别、日期和爱好。性别和日期的数据转换可以使用默认的数据转换。爱好需要将字符串根据&lt;code&gt;，&lt;/code&gt;分割并转换为list列表数据，下面是爱好的数据转换，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HobbyConversion implements DataImportConversion&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; {
    @Override
    public List&amp;lt;String&amp;gt; transferData(Object data) {
        if (data == null) return null;

        //根据，分割字符串
        String hobbyStr = data.toString();
        String[] hobbyArray = hobbyStr.split(&quot;,&quot;);

        //转换成list
        List&amp;lt;String&amp;gt; hobbies = Arrays.asList(hobbyArray);
        return hobbies;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;导入参数类&quot;&gt;3.3 导入参数类&lt;/h2&gt;
&lt;p&gt;数据转换类写好了之后，开始编写导入参数类，代码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DemoImportParam {
    public static List&amp;lt;CellParam&amp;gt; getCellParams(){
        Map&amp;lt;String,Integer&amp;gt; sexMap = new HashMap&amp;lt;&amp;gt;();
        sexMap.put(&quot;女&quot;,0);
        sexMap.put(&quot;男&quot;,1);

        List&amp;lt;CellParam&amp;gt; cellParams = new ArrayList&amp;lt;&amp;gt;();
        cellParams.add(new CellParam(&quot;name&quot;));
        cellParams.add(new CellParam(&quot;sex&quot;, new MapConversion(sexMap)));
        cellParams.add(new CellParam(&quot;birthday&quot;, new DateConversion(&quot;yyyy-MM-dd HH:mm:ss&quot;)));
        cellParams.add(new CellParam(&quot;hobbies&quot;, new HobbyConversion()));
        return cellParams;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在DemoImportParam类中可以看到一个静态方法getCellParams，返回List&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一列标题名称为姓名，对应的属性名称为name&lt;/li&gt;
&lt;li&gt;第二列标题名称为性别，对应的属性名称为sex，数据转换对象MapConversion&lt;/li&gt;
&lt;li&gt;第三列标题名称为出生日期，对应的属性名称为birthday，日期转换&lt;/li&gt;
&lt;li&gt;第四列标题名称为爱好，对应的属性名称为hobbies，数据转换对象HobbyConversion&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;导出&quot;&gt;3.4 导出&lt;/h2&gt;
&lt;p&gt;接下来有两种数据导出方式，一种是url访问弹出下载execl文件，另外一种是导出execl到文件&lt;/p&gt;
&lt;h3 id=&quot;从web导入execl&quot;&gt;3.4.1 从web导入execl&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ResponseBody
@PostMapping(&quot;/import&quot;)
public List&amp;lt;DemoBean&amp;gt; importByWeb(MultipartFile file) throws Exception {
    ExeclImport execlImport = new ExeclImport(DemoBean.class, DemoImportParam.getCellParams());
    List&amp;lt;DemoBean&amp;gt; list = execlImport.importExecl(file.getInputStream());

    return list;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;从文件导入execl&quot;&gt;3.4.2 从文件导入execl&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void importByFile() throws Exception {
    File file = new File(&quot;F:\\导出demo.xlsx&quot;);
    FileInputStream inputStream = new FileInputStream(file);

    //导入转换
    ExeclImport execlImport = new ExeclImport(DemoBean.class, DemoImportParam.getCellParams());
    List&amp;lt;DemoBean&amp;gt; list = execlImport.importExecl(inputStream);

    //输出
    for (DemoBean bean:list){
        System.out.println(bean);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;项目位置：&lt;a href=&quot;https://github.com/rainbowda/utils/tree/master/execl_import&quot; class=&quot;uri&quot;&gt;https://github.com/rainbowda/utils/tree/master/execl_import&lt;/a&gt;，有需要的可以看看&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 05:28:00 +0000</pubDate>
<dc:creator>云枭zd</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fixzd/p/9448344.html</dc:identifier>
</item>
<item>
<title>Mysql Innodb 索引原理 - 网易云</title>
<link>http://www.cnblogs.com/163yun/p/9448205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/163yun/p/9448205.html</guid>
<description>&lt;p&gt;本文来自&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//sq.163yun.com/blog&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;网易云社区&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Innodb是Mysql最常用的存储引擎，了解Innodb存储引擎的索引对于日常工作有很大的益处，索引的存在便是为了加速数据库行记录的检索。以下是我对最近学习的知识的一些总结，以及对碰到的以及别人提到过的问题的一些分析，如有错误，请指正，我会及时更正。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Innodb表结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此小结与索引其实没有太多的关联，但是为了便于理解索引的内容，添加此小结作为铺垫知识。&lt;/p&gt;
&lt;h4&gt;1.1 Innodb逻辑存储结构&lt;/h4&gt;
&lt;p&gt;Mysql表中的所有数据被存储在一个空间内，称之为表空间，表空间内部又可以分为段(segment)、区(extent)、页(page)、行(row),逻辑结构如下图：&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093043eed4e6e4-8617-448d-9447-b72a78ef9a70.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;段(segment)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;表空间是由不同的段组成的，常见的段有：数据段，索引段，回滚段等等，在Mysql中，数据是按照B+树来存储，因此数据即索引，因此数据段即为B+树的叶子节点，索引段为B+树的非叶子节点,回滚段用于存储undo日志，用于事务失败后数据回滚以及在事务未提交之前通过undo日志获取之前版本的数据，在Innodb1.1版本之前一个Innodb,只支持一个回滚段，支持1023个并发修改事务同时进行，在Innodb1.2版本，将回滚段数量提高到了128个，也就是说可以同时进行128*1023个并发修改事务。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;区(extent)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;区是由连续页组成的空间，每个区的固定大小为1MB,为保证区中页的连续性，Innodb会一次从磁盘中申请4~5个区，在默认不压缩的情况下，一个区可以容纳64个连续的页。但是在开始新建表的时候，空表的默认大小为96KB,是由于为了高效的利用磁盘空间，在开始插入数据时表会先利用32个页大小的碎片页来存储数据，当这些碎片使用完后，表大小才会按照MB倍数来增加。&lt;/p&gt;
&lt;p&gt;页是Innodb存储引擎的最小管理单位，每页大小默认是16KB，从Innodb 1.2.x版本开始，可以利用&lt;code&gt;innodb_page_size&lt;/code&gt;来改变页size，但是改变只能在初始化Innodb实例前进行修改，之后便无法进行修改，除非mysqldump导出创建新库，常见的页类型有：数据页、undo页、系统页、事务数据页、插入缓冲位图页、插入缓冲空闲列表页、未压缩的二进制大对象页、压缩的二进制大对象页。&lt;/p&gt;
&lt;p&gt;行对应的是表中的行记录，每页存储最多的行记录也是有硬性规定的最多16KB/2-200,即7992行（16KB是页大小，我也不明白为什么要这么算,据说是内核定义）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 Innodb行记录格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Innodb提供了两种格式来存储行记录：Redundant格式、Compact格式、Dynamic格式、Compressed格式，Redudant格式是为了兼容保留的。&lt;/p&gt;
&lt;h5&gt;Redundant行格式（5.0版本之前的格式）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093122ed5e4122-4e4d-484a-827f-fc3cfadde834.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字段长度偏移列表：存储字段偏移量，与列字段顺序相反存放，若列长度小于255字节，用一个字节表示，若大于255字节，用两个字节表示&lt;/li&gt;
&lt;li&gt;记录头信息：固定用6字节表示，具体含义如下：&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808090931400cae0960-3d43-4a3d-b784-a9c4a742f81e.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;隐藏列：事务id和回滚列id,分别占用6、7字节，若此表没有主键，还会增加6字节的rowid列。&lt;/p&gt;
&lt;h5&gt;Compact行格式(5.6版本的默认行格式)&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093151b95de3a6-9205-45ba-b070-a5a8a132e323.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变长字段长度列表：此字段标识列字段的长度，与列字段顺序相反存放，若列长度小于255字节，用一个字节表示，若大于255字节，用两个字节表示，这也是Mysql的VARCHAR类型最大长度限制为65535&lt;/li&gt;
&lt;li&gt;NULL标志位：标识改列是否有空字段，有用1表示，否则为0，该标志位长度为ceil(N/8)（此处是Mysql技术内幕-Innodb存储引擎与官方文档有出入的地方）；&lt;/li&gt;
&lt;li&gt;记录头信息：固定用5字节表示，具体含义如下： &lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093202c500935b-6eb6-4959-987c-690127f29a16.jpg&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;列数据：此行存储着列字段数据，Null是不占存储空间的；&lt;/li&gt;
&lt;li&gt;隐藏列：事务id和回滚列id,分别占用6、7字节，若此表没有主键，还会增加6字节的rowid列。&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;Dynamic格式(5.7版本默认行格式)和Compressed格式&lt;/h5&gt;
&lt;p&gt;Dynamic格式和Compressed格式与Compact的不同之处在于对于行溢出只会在该列处存放20字节的指针，指向该字符串的实际存储位置，不会存储768字节前缀，而且Compressed格式在存储BLOB、TEXT、VARCHAR等类型会利用zlib算法进行压缩，能够以很高的存储效率来存储字符串。&lt;/p&gt;
&lt;h4&gt;1.3 Innodb数据页结构&lt;/h4&gt;
&lt;p&gt;《Mysql技术内幕-Innodb存储引擎》书中对此有描述，但是应该不是太准确，书中有如下描述，此处不做详细介绍，若有兴趣请看此神书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093215d3b3dee2-2308-4afd-89df-7a9dc5e2f01f.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. B树与B+树&lt;/h3&gt;
&lt;h4&gt;2.1 B树&lt;/h4&gt;
&lt;h5&gt;定义：&lt;/h5&gt;
&lt;p&gt;B树（B-TREE）满足如下条件，即可称之为m阶B树：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个节点之多拥有m棵子树；&lt;/li&gt;
&lt;li&gt;根结点至少拥有两颗子树（存在子树的情况下);&lt;/li&gt;
&lt;li&gt;除了根结点以外，其余每个分支结点至少拥有 m/2 棵子树；&lt;/li&gt;
&lt;li&gt;所有的叶结点都在同一层上；&lt;/li&gt;
&lt;li&gt;有 k 棵子树的分支结点则存在 k-1 个关键码，关键码按照递增次序进行排列；&lt;/li&gt;
&lt;li&gt;关键字数量需要满足ceil(m/2)-1 &amp;lt;= n &amp;lt;= m-1；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;B树插入&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093232884e2cc8-6208-4e83-8647-b35a33d77ccd.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h5&gt;B树删除&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018080909324030f5567e-3ab7-486e-bc36-99b631e6f2c2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;2.2 B+树&lt;/h4&gt;
&lt;h5&gt;定义：&lt;/h5&gt;
&lt;p&gt;B+树满足如下条件，即可称之为m阶B+树：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根结点只有一个，分支数量范围为[2，m]&lt;/li&gt;
&lt;li&gt;分支结点，每个结点包含分支数范围为[ceil(m/2), m]；&lt;/li&gt;
&lt;li&gt;分支结点的关键字数量等于其子分支的数量减一，关键字的数量范围为[ceil(m/2)-1, m-1]，关键字顺序递增；&lt;/li&gt;
&lt;li&gt;所有叶子结点都在同一层；&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;插入：&lt;/h5&gt;
&lt;p&gt;B+树的插入必须保证插入后叶节点中的记录依然排序，同时需要考虑插入B+树的三种情况，每种情况都可能会导致不同的插入算法，插入算法入下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808090933007fd48500-83c4-4643-9e73-f113b472354d.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插入举例(未加入双向链表)：&lt;/p&gt;
&lt;p&gt;1、 插入28这个键值，发现当前Leaf Page和Index Page都没有满，直接插入。&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093316074a582f-4103-4486-b9f9-a7818a09c022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、 插入70这个键值，Leaf Page已经满了，但是Index Page还没有满，根据中间的值60拆分叶节点。&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093323fffc091f-1bee-4897-bb55-c23ff4b7da66.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、 插入记录95，Leaf Page和Index Page都满了，这时需要做两次拆分&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018080909333017abd2db-a76c-4803-b9cf-596e02349e01.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、 B+树总是会保持平衡。但是为了保持平衡，对于新插入的键值可能需要做大量的拆分页（split）操作，而B+树主要用于磁盘，因此页的拆分意味着磁盘数据移动，应该在可能的情况下尽量减少页的拆分。因此，B+树提供了旋转（rotation）的功能。旋转发生在Leaf Page已经满了、但是其左右兄弟节点没有满的情况下。这时B+树并不会急于去做拆分页的操作，而是将记录移到所在页的兄弟节点上。通常情况下，左兄弟被首先检查用来做旋转操作，在第一张图情况下，插入键值70，其实B+树并不会急于去拆分叶节点，而是做旋转，50，55，55旋转。&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808090933443ba4ab30-7e04-42fb-b383-b8732dae80f8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;删除：&lt;/h5&gt;
&lt;p&gt;B+树使用填充因子（fill factor）来控制树的删除变化，50%是填充因子可设的最小值。B+树的删除操作同样必须保证删除后叶节点中的记录依然排序，同插入一样，B+树的删除操作同样需要考虑下图所示的三种情况，与插入不同的是，删除根据填充因子的变化来衡量。&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093356173d7873-e160-4cf2-ae4b-1692bd31d98c.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;删除示例(未加入双向链表)： 1、删除键值为70的这条记录，直接删除（在插入第三点基础上的图）。&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093414820cf2b9-b04b-435e-ba0d-4b3b1937059c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、接着我们删除键值为25的记录，该值还是Index Page中的值，因此在删除Leaf Page中25的值后，还应将25的右兄弟节点的28更新到Page Index中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808090934215419a0c7-2a68-4d54-8a7e-d6280f189a0a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;3、删除键值为60的情况，删除Leaf Page中键值为60的记录后，填充因子小于50%，这时需要做合并操作，同样，在删除Index Page中相关记录后需要做Index Page的合并操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093431c79a9e57-82a0-40d3-9075-78ce3dafb6aa.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h5&gt;B树与B+树区别：&lt;/h5&gt;
&lt;p&gt;以m阶树为例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关键字不同：B+树中分支结点有m个关键字，其叶子结点也有m个，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。&lt;/li&gt;
&lt;li&gt;存储位置不同：B+树非叶子节点的关键字只起到索引作用，实际的关键字存储在叶子节点，B树的非叶子节点也存储关键字。&lt;/li&gt;
&lt;li&gt;分支构造不同：B+树的分支结点仅仅存储着关键字信息和儿子的指针，也就是说内部结点仅仅包含着索引信息。&lt;/li&gt;
&lt;li&gt;查询不同（稳定）：B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;3. 聚簇索引和二级索引&lt;/h3&gt;
&lt;h4&gt;3.1 聚簇索引&lt;/h4&gt;
&lt;p&gt;每个Innodb的表都拥有一个索引，称之为聚簇索引，此索引中存储着行记录，一般来说，聚簇索引是根据主键生成的。为了能够获得高性能的查询、插入和其他数据库操作，理解Innodb聚簇索引是很有必要的。&lt;/p&gt;
&lt;p&gt;聚簇索引按照如下规则创建：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当定义了主键后，innodb会利用主键来生成其聚簇索引；&lt;/li&gt;
&lt;li&gt;如果没有主键，innodb会选择一个非空的唯一索引来创建聚簇索引；&lt;/li&gt;
&lt;li&gt;如果这也没有，Innodb会隐式的创建一个自增的列来作为聚簇索引。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Note: 对于选择唯一索引的顺序是按照定义唯一索引的顺序，而非表中列的顺序, 同时选中的唯一索引字段会充当为主键，或者Innodb隐式创建的自增列也可以看做主键。&lt;/p&gt;
&lt;p&gt;聚簇索引整体是一个b+树，非叶子节点存放的是键值，叶子节点存放的是行数据，称之为数据页，这就决定了表中的数据也是聚簇索引中的一部分，数据页之间是通过一个双向链表来链接的，上文说到B+树是一棵平衡查找树，也就是聚簇索引的数据存储是有序的，但是这个是逻辑上的有序，但是在实际在数据的物理存储上是，因为数据页之间是通过双向链表来连接，假如物理存储是顺序的话，那维护聚簇索引的成本非常的高。&lt;/p&gt;
&lt;h4&gt;3.2 辅助索引&lt;/h4&gt;
&lt;p&gt;除了聚簇索引之外的索引都可以称之为辅助索引，与聚簇索引的区别在于辅助索引的叶子节点中存放的是主键的键值。一张表可以存在多个辅助索引，但是只能有一个聚簇索引，通过辅助索引来查找对应的航记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚簇索引中查询到对应的行记录，也就是进行两次B+树搜索。相反通过辅助索引来查询主键的话，遍历一次辅助索引就可以确定主键了，也就是所谓的索引覆盖，不用回表（查询聚簇索引）。&lt;/p&gt;
&lt;p&gt;创建辅助索引，可以创建单列的索引，也就是用一个字段来创建索引，也可以用多个字段来创建副主索引称为联合索引，创建联合索引后，B+树的节点存储的键值数量不是1个，而是多个，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093453f4781ab7-9971-46c0-97b2-8d01a282c822.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;联合索引的B+树和单键辅助索引的B+树是一样的，键值都是排序的，通过叶子节点可以逻辑顺序的读出所有的数据，比如上图所存储的数据时，按照(a,b)这种形式(1,1),(1,2),(2,1),(2,4),(3,1),(3,2)进行存放，这样有个好处存放的数据时排了序的，当进行&lt;code&gt;order by&lt;/code&gt;对某个字段进行排序时，可以减少复杂度，加速进行查询；&lt;/li&gt;
&lt;li&gt;当用&lt;code&gt;select * from table where a=? and ?&lt;/code&gt;可以使用索引(a,b)来加速查询，但是在查询时有一个原则，sql的where条件的顺序必须和二级索引一致，而且还遵循索引最左原则，&lt;code&gt;select * from table where b=?&lt;/code&gt;则无法利用(a,b)索引来加速查询。&lt;/li&gt;
&lt;li&gt;辅助索引还有一个概念便是索引覆盖，索引覆盖的一个好处便是辅助索引不高含行记录，因此其大小远远小于聚簇索引，利用辅助索引进行查询可以减少大量的io操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;4. sql执行顺序&lt;/h3&gt;
&lt;p&gt;以下的每一步操作都会生成一个虚拟表，作为下一个处理的输入，在这个过程中，这些虚拟表对于用户都是透明的，只用最后一步执行完的虚拟表返回给用户，在处理过程中，没有的步骤会直接跳过。&lt;/p&gt;
&lt;p&gt;以下为逻辑上的执行顺序： &lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018080909352988d2831d-5ae8-41e8-97bc-12a8a15b240f.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1) &lt;code&gt;from&lt;/code&gt;：对左表&lt;code&gt;left-table&lt;/code&gt;和右表&lt;code&gt;right-table&lt;/code&gt;执行笛卡尔积(a*b)，形成虚拟表VT1;&lt;/li&gt;
&lt;li&gt;(2) &lt;code&gt;on&lt;/code&gt;: 对虚拟表VT1进行&lt;code&gt;on&lt;/code&gt;条件进行筛选，只有符合条件的记录才会插入到虚拟表VT2中;&lt;/li&gt;
&lt;li&gt;(3) &lt;code&gt;join&lt;/code&gt;: 指定&lt;code&gt;out join&lt;/code&gt;会将未匹配行添加到VT2产生VT3,若有多张表，则会重复(1)~(3);&lt;/li&gt;
&lt;li&gt;(4) &lt;code&gt;where&lt;/code&gt;: 对VT3进行条件过滤，形成VT4, &lt;code&gt;where&lt;/code&gt;条件是从左向右执行的;&lt;/li&gt;
&lt;li&gt;(5) &lt;code&gt;group by&lt;/code&gt;: 对VT4进行分组操作得到VT5;&lt;/li&gt;
&lt;li&gt;(6) &lt;code&gt;cube | rollup&lt;/code&gt;: 对VT5进行&lt;code&gt;cube | rollup&lt;/code&gt;操作得到VT6;&lt;/li&gt;
&lt;li&gt;(7) &lt;code&gt;having&lt;/code&gt;: 对VT6进行过滤得到VT7;&lt;/li&gt;
&lt;li&gt;(8) &lt;code&gt;select&lt;/code&gt;: 执行选择操作得到VT8，本人看来VT7和VT8应该是一样的;&lt;/li&gt;
&lt;li&gt;(9) &lt;code&gt;distinct&lt;/code&gt;: 对VT8进行去重，得到VT9;&lt;/li&gt;
&lt;li&gt;(10) &lt;code&gt;order by&lt;/code&gt;: 对VT9进行排序，得到VT10;&lt;/li&gt;
&lt;li&gt;(11) &lt;code&gt;limit&lt;/code&gt;: 对记录进行截取，得到VT11返回给用户。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Note: &lt;code&gt;on&lt;/code&gt;条件应用于连表过滤，&lt;code&gt;where&lt;/code&gt;应用于on过滤后的结果（有&lt;code&gt;on&lt;/code&gt;的话），&lt;code&gt;having&lt;/code&gt;应用于分组过滤&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. sql优化建议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引有如下有点：减少服务器扫描的数据量、避免排序和临时表、将随机I/O变为顺序I/O。&lt;/p&gt;
&lt;h4&gt;可使用B+树索引的查询方式&lt;/h4&gt;

&lt;ul&gt;&lt;li&gt;全值匹配：与索引中的所有列进行匹配，也就是条件字段与联合索引的字段个数与顺序相同；&lt;/li&gt;
&lt;li&gt;匹配最左前缀：只使用联合索引的前几个字段；&lt;/li&gt;
&lt;li&gt;匹配列前缀：比如&lt;code&gt;like 'xx%'&lt;/code&gt;可以走索引；&lt;/li&gt;
&lt;li&gt;匹配范围值：范围查询，比如&lt;code&gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;like&lt;/code&gt;等；&lt;/li&gt;
&lt;li&gt;匹配某一列并范围匹配另外一列：精确查找+范围查找；&lt;/li&gt;
&lt;li&gt;只访问索引查询：索引覆盖，&lt;code&gt;select&lt;/code&gt;的字段为主键；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;范围查询后的条件不会走索引，具体原因会在下一节进行介绍。&lt;/p&gt;
&lt;h4&gt;列的选择性（区分度）&lt;/h4&gt;
&lt;p&gt;选择性（区分度）是指不重复的列值个数/列值的总个数，一般意义上建索引的字段要区分度高，而且在建联合索引的时候区分度高的列字段要放在前边，这样可以在第一个条件就过滤掉大量的数据，有利用性能的提升，对于如何计算列的区分度，有如下两种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据定义，手动计算列的区分度，不重复的列值个数/列值的总个数&lt;/li&gt;
&lt;li&gt;通过mysql的carlinality,通过命令&lt;code&gt;show index from &amp;lt;table_name&amp;gt;&lt;/code&gt;来查看 解释一下此处的carlinality并不是准确值，而且mysql在B+树种选择了8个数据页来抽样统计的值，也就是说carlinality=每个数据页记录总和/8*所有的数据页，因此也说明这个值是不准确的，因为在插入/更新记录时，实时的去更新carlinality对于Mysql的负载是很高的，如果数据量很大的话，触发mysql重新统计该值得条件是当表中的1/16数据发生变化时。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是选择区分度高的列作为索引也不是百试百灵的，某些情况还是不合适的，下节会进行介绍。&lt;/p&gt;
&lt;p&gt;Mysql查询过程&lt;/p&gt;
&lt;p&gt;当希望Mysql能够高性能运行的时候，最好的办法就是明白Mysql是如何优化和执行的，一旦理解了这一点，很多查询优化工作实际上就是遵循了一些原则让优化器能够按照预想的合理的方式运行————《引用自高性能Mysql》&lt;/p&gt;
&lt;p&gt;当想Mysql实例发送一个请求时，Mysql按照如下图的方式进行查询：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808090935534ea3353c-ca4d-4cf8-81b4-20749ffe1338.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端先发送一条查询给服务器；&lt;/li&gt;
&lt;li&gt;服务器先检查查询缓存，如果命中了缓存，则立刻返回给存储在缓存中的结果，否则进入下一个阶段；&lt;/li&gt;
&lt;li&gt;服务器端进行sql解析、预处理，再由优化器生成对应的执行计划；&lt;/li&gt;
&lt;li&gt;Mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询&lt;/li&gt;
&lt;li&gt;将结果返回客户端&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;注意&amp;amp;建议&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;主键推荐使用整型，避免索引分裂；&lt;/li&gt;
&lt;li&gt;查询使用索引覆盖能够提升很大的性能，因为避免了回表查询；&lt;/li&gt;
&lt;li&gt;选择合适的顺序建立索引，有的场景并非区分度越高的列字段放在前边越好，联合索引使用居多；&lt;/li&gt;
&lt;li&gt;合理使用&lt;code&gt;in&lt;/code&gt;操作将范围查询转换成多个等值查询；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;in&lt;/code&gt;操作相当于多个等值操作，但是要注意的是对于&lt;code&gt;order by&lt;/code&gt;来说，这相当于范围查询，因此例如&lt;code&gt;select * from t1 where c1 in (x,x) order by c2&lt;/code&gt;的sql是不走索引的；&lt;/li&gt;
&lt;li&gt;将大批量数据查询任务分解为分批查询；&lt;/li&gt;
&lt;li&gt;将复杂查询转换为简单查询；&lt;/li&gt;
&lt;li&gt;合理使用&lt;code&gt;inner join&lt;/code&gt;,比如说分页时候&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 一些问题分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个部分是我在学习过程中产生的一些疑问，以及在工作中碰到的或者同事提起的一些问题，对此我做了些调研，总结了一下并添加了些自己的理解，如有错误还请指正。&lt;/p&gt;
&lt;h4&gt;索引分裂&lt;/h4&gt;
&lt;p&gt;此处提一下索引分裂，就我个人理解，在Mysql插入记录的同时会更新配置的相应索引文件，根据以上的了解，在插入索引时，可能会存在索引的页的分裂，因此会导致磁盘数据的移动。当插入的主键是随机字符串时，每次插入不会是在B+树的最后插入，每次插入位置都是随机的，每次都可能导致数据页的移动，而且字符串的存储空间占用也很大，这样重建索引不仅仅效率低而且Mysql的负载也会很高，同时还会导致大量的磁盘碎片，磁盘碎片多了也会对查询造成一定的性能开销，因为存储位置不连续导致更多的磁盘I/O,这就是为什么推荐定义主键为递增整型的一个原因，Mysql索引页默认大小是16KB，当有新纪录插入的时候，Mysql会留下每页空间的1/16用于未来索引记录增长，避免过多的磁盘数据移动。&lt;/p&gt;
&lt;h4&gt;自增主键的弊端&lt;/h4&gt;
&lt;p&gt;对于高并发的场景，在Innodb中按照主键的顺序插入可能会造成明显的争用，主键的上界会成为“热点”，因为所有的插入都发生在此处，索引并发的插入可能会造成间隙锁竞争，何为间隙锁竞争，下个会详细介绍；另外一个原因可能是Auto_increment的锁机制，在Mysql处理自增主键时，当&lt;code&gt;innodb_autoinc_lock_mode&lt;/code&gt;为0或1时，在不知道插入有多少行时，比如&lt;code&gt;insert t1 xx select xx from t2&lt;/code&gt;，对于这个statement的执行会进行锁表，只有这个statement执行完以后才会释放锁，然后别的插入才能够继续执行，,但是在&lt;code&gt;innodb_autoinc_lock_mode=2&lt;/code&gt;时，这种情况不会存在表锁，但是只能保证所有并发执行的statement插入的记录是唯一并且自增的，但是每个statement做的多行插入之间是不连接的。&lt;/p&gt;
&lt;h4&gt;优化器不使用索引选择全表扫描&lt;/h4&gt;
&lt;p&gt;比如一张order表中有联合索引(order_id, goods_id)，在此例子上来说明 这个问题是从两个方面来说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询字段在索引中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;select order_id from order where order_id &amp;gt; 1000&lt;/code&gt;,如果查看其执行计划的话，发现是用use index condition,走的是索引覆盖&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询字段不在索引中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;select * from order where order_id &amp;gt; 1000&lt;/code&gt;, 此条语句查询的是该表所有字段，有一部分字段并未在此联合索引中，因此走联合索引查询会走两步，首先通过联合索引确定符合条件的主键id,然后利用这些主键id再去聚簇索引中去查询，然后得到所有记录，利用主键id在聚簇索引中查询记录的过程是无序的，在磁盘上就变成了离散读取的操作，假如当读取的记录很多时（一般是整个表的20%左右），这个时候优化器会选择直接使用聚簇索引，也就是扫全表，因为顺序读取要快于离散读取，这也就是为何一般不用区分度不大的字段单独做索引，注意是单独因为利用此字段查出来的数据会很多，有很大概率走全表扫描。&lt;/p&gt;
&lt;h4&gt;范围查询之后的条件不走索引&lt;/h4&gt;
&lt;p&gt;根据Mysql的查询原理的话，当处理到&lt;code&gt;where&lt;/code&gt;的范围查询条件后，会将查询到的行全部返回到服务器端（查询执行引擎），接下来的条件操作在服务器端进行处理，这也就是为什么范围条件不走索引的原因了，因为之后的条件过滤已经不在存储引擎完成了。但是在Mysql 5.6以后假如了一个新的功能index condition pushdown(ICP),这个功能允许范围查询条件之后的条件继续走索引，但是需要有几个前提条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询条件的第一个条件需要时有边界的，比如&lt;code&gt;select * from xx where c1=x and c2&amp;gt;x and c3&amp;lt;x&lt;/code&gt;,这样c3是可以走到索引的；&lt;/li&gt;
&lt;li&gt;支持InnoDB和MyISAM存储引擎；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;where&lt;/code&gt;条件的字段需要在索引中；&lt;/li&gt;
&lt;li&gt;分表ICP功能5.7开始支持；&lt;/li&gt;
&lt;li&gt;使用索引覆盖时，ICP不起作用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;set @@optimizer_switch = &quot;index_condition_pushdown=on&quot;&lt;/span&gt; 开启ICP &lt;code&gt;set @@optimizer_switch = &quot;index_condition_pushdown=off&quot;&lt;/code&gt; 关闭ICP&lt;/p&gt;
&lt;h4&gt;范围查询统计函数不遵循Mysql索引最左原则&lt;/h4&gt;
&lt;p&gt;比如创建一个表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table `person`(
    `id` int not null auto_increment primary key,
    `uid` int not null,    
    `name` varchar(60) not null,
    `time` date not null,
    key `idx_uid_date` (uid, time) 
)engine=innodb default charset=utf8mb4;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当执行&lt;code&gt;select count(*) from person where time &amp;gt; '2018-03-11'&lt;/code&gt; and time &amp;lt; '2018-03-16'&lt;code&gt;时，time是可以用到&lt;/code&gt;idx_uid_date`的索引的,看如下的执行计划：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180809093621accd2b99-64d3-4ebc-b58b-b321784a8405.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中extra标识use index说明是走索引覆盖的，一般意义来说是Mysql是无法支持松散索引的，但是对于统计函数，是可以使用索引覆盖的，因此Mysql的优化器选择利用该索引。&lt;/p&gt;
&lt;h4&gt;分页offset值很大性能问题&lt;/h4&gt;
&lt;p&gt;在Mysql中，分页当offset值很大的时候，性能会非常的差，比如&lt;code&gt;limit 100000, 20&lt;/code&gt;，需要查询100020条数据，然后取20条，抛弃前100000条，在这个过程中产生了大量的随机I/O,这是性能很差的原因，为了解决这个问题，切入点便是减少无用数据的查询，减少随机I/O。 解决的方法是利用索引覆盖，也就是扫描索引得到id然后再从聚簇索引中查询行记录，我知道有两种方式：&lt;/p&gt;
&lt;p&gt;比如从表t1中分页查询&lt;code&gt;limit 1000000,5&lt;/code&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用&lt;code&gt;inner join&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;select * from t1 inner join (select id from t1 where xxx order by xx limit 1000000,5) as t2 using(id)&lt;/code&gt;,子查询先走索引覆盖查得id,然后根据得到的id直接取5条得数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用范围查询条件来限制取出的数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;select * from t1 where id &amp;gt; 1000000 order by id limit 0, 5&lt;/code&gt;，即利用条件&lt;code&gt;id &amp;gt; 1000000&lt;/code&gt;在扫描索引是跳过1000000条记录，然后取5条即可,这种处理方式的offset值便成为0了，但此种方式通常分页不能用，但是可以用来分批取数据。&lt;/p&gt;
&lt;h4&gt;索引合并&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;
SELECT * FROM tbl_name WHERE (key1 = 10 OR key2 = 20) AND non_key=30;
SELECT * FROM t1, t2 WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE 'value%') AND t2.key1=t1.some_col;
SELECT * FROM t1, t2 WHERE t1.key1=1 AND (t2.key1=t1.some_col OR t2.key2=t1.some_col2);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于如上的sql在mysql 5.0版本之前，假如没有建立相应的联合索引，是要走全表扫描的，但是在Mysql 5.1后引入了一种优化策略为索引合并，可以在一定程度上利用表上的多个单列索引来定位指定行，其原理是将对每个索引的扫描结果做运算，总共有：交集、并集以及他们的组合，但是索引合并并非是一种合适的选择，因为在做索引合并时可能会消耗大量的cpu和内存资源，一般用到索引合并的情况也从侧面反映了该表的索引需要优化。&lt;/p&gt;

&lt;h3&gt;7. 参考资料&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;《Mysql技术内幕-Innodb存储引擎》：此书对于Innodb的讲解是比较全面而且细致的，但是稍微有一点点老并且还有一点点错误地方，此书是基于Mysql 5.6版本的，里边会混杂一些5.7的知识。&lt;/li&gt;
&lt;li&gt;《MySQL技术内幕：SQL编程》：值得一看。&lt;/li&gt;
&lt;li&gt;《高性能Mysql 第三版》：此书是一本Mysql神书，里边有很多的Mysql优化建议以及一些案例&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/&quot;&gt;&lt;span&gt;&lt;span&gt;官方文档&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;：这个是比较权威而且是最新的文档，缺点是篇幅很长，内容很多，而且还是纯英文，在理解和阅读速度上相对而言没有中文来得快。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;网易云新用户大礼包：&lt;a href=&quot;https://www.163yun.com/gift?tag=M_sq_&quot;&gt;&lt;span&gt;&lt;span&gt;https://www.163yun.com/gift&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文来自网易云社区，经作者范鹏程授权发布。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 04:32:00 +0000</pubDate>
<dc:creator>网易云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/163yun/p/9448205.html</dc:identifier>
</item>
<item>
<title>推荐系统中物品相似度计算 - Byron_Wu</title>
<link>http://www.cnblogs.com/bjwu/p/9448043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bjwu/p/9448043.html</guid>
<description>&lt;p&gt;最近天气有点热，三伏天得了空调病，最后发现是颈椎引起的问题，期间还拔了颗顽固的智齿，也算是一波三折了。&lt;/p&gt;
&lt;p&gt;这次介绍&lt;strong&gt;Item(User)相似度&lt;/strong&gt;的计算方法，其广泛运用于基于邻域的协同过滤算法的推荐系统。简而言之，基于邻域，就是基于相邻的元素进行推荐，而相邻元素的得到过程就是相似度的计算过程。&lt;/p&gt;
&lt;p&gt;对于空间上的点来说：传统机器学习模型中KNN的距离度量方法（如欧式距离等），距离越近的点我们把他们归为一类，也可以说他们更相似。&lt;/p&gt;
&lt;p&gt;对于空间上的向量来说：方向更相同，向量越相似，这就是cosine度量方法的原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题来了，我们得到不同物品/用户的相似度有什么用呢❓&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🙋回答：从ItemCF的角度来说，在得到物品之间的相似度&lt;span class=&quot;math inline&quot;&gt;\(w_{ij}\)&lt;/span&gt;（物品 i 和 j ）之后，通过如下公式可以计算用户u对一个物品 j 的兴趣：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(p_{uj}=\sum\limits_{i \in N(u)\cap S(j,k)}w_{ji}r_{ui}\tag{0}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里N(u)是用户喜欢的物品的集合，S(j, k)是物品j最相似的K个物品的集合，&lt;span class=&quot;math inline&quot;&gt;\(r_{ui}\)&lt;/span&gt;是用户u对物品i的兴趣程度。&lt;/p&gt;
&lt;h3 id=&quot;jaccard公式&quot;&gt;Jaccard公式&lt;/h3&gt;
&lt;p&gt;这是一个在《推荐系统实践》中看到的公式，这里我们研究两个用户users的兴趣相似度：给定用户u和用户v，令N(u)，N(v)分别表示用户u，v曾经有过正反馈的物品集合。那么用户u和v的相似度为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\omega_{uv}=\frac{|N(u)\cap N(v)|}{|N(u)\cup N(v)|} \tag{1}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上述公式简单表述就是：&lt;span class=&quot;math inline&quot;&gt;\(\frac{两个用户都感兴趣物品数目}{两个用户中只要有一个用户感兴趣的物品数目}\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;cosine公式&quot;&gt;cosine公式&lt;/h3&gt;
&lt;p&gt;与上述公式相同，只是在分母中加了个根号，这里我们研究物品items的相似度：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\omega_{ij}=\frac{|N(i)\cap N(j)|}{\sqrt{|N(i)\cup N(j)|}}\tag{2}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里N(i)和N(j)分别表示喜欢物品i 和物品j 的人数。&lt;/p&gt;
&lt;p&gt;到这里为止，我们研究的对象只有喜欢不喜欢两种度量，如果对象换做是评分，如电影评分（分数ratings有：1，2，3，4，5🌟），那么相应的cosine公式变换为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{cosine_sim}(i, j) = \frac{\sum\limits_{u \in U_{ij}} r_{ui} \cdot r_{uj}}{\sqrt{\sum\limits_{u \in U_{ij}} r_{ui}^2} \cdot\sqrt{\sum\limits_{u \in U_{ij}} r_{uj}^2}}\tag{3}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(r_{ui}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(r_{uj}\)&lt;/span&gt;分别表示用户 u 对物品 i 和 j 的评分，&lt;span class=&quot;math inline&quot;&gt;\(U_{ij}\)&lt;/span&gt;代表同时喜欢物品 i 和 j 的用户集合。&lt;/p&gt;
&lt;p&gt;以下为&lt;a href=&quot;https://github.com/NicolasHug/Surprise/blob/711fb80748140c44e0ed870e573c735307e6c3cc/surprise/similarities.pyx&quot;&gt;surprise&lt;/a&gt;库的cosine函数源码和分析：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def cosine(n_x, yr, min_support):
    
    ### 此处省略了一些东西
    
    for y, y_ratings in iteritems(yr):
        ### xi和xj分别表示物品i和j
        ### 以下为生成(3)式中的分母和分子
        for xi, ri in y_ratings:
            for xj, rj in y_ratings:
                freq[xi, xj] += 1
                prods[xi, xj] += ri * rj
                sqi[xi, xj] += ri**2
                sqj[xi, xj] += rj**2
                
    ### 以下为使用（3）式进行计算            
    for xi in range(n_x):
        sim[xi, xi] = 1
        for xj in range(xi + 1, n_x):
            if freq[xi, xj] &amp;lt; min_sprt:
                sim[xi, xj] = 0
            else:
                denum = np.sqrt(sqi[xi, xj] * sqj[xi, xj])
                sim[xi, xj] = prods[xi, xj] / denum

            sim[xj, xi] = sim[xi, xj]

    return sim  
    ### 返回的结果sim是一个对称矩阵，行列的index表示对应每个物品item，矩阵元素表示行列对应物品的相似度&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;pearson-correlationpc&quot;&gt;Pearson Correlation(PC)&lt;/h3&gt;
&lt;p&gt;如果在(3)式的基础上进行去均值的话，那么就得到了(4)式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{pearson_sim}(i, j) = \frac{ \sum\limits_{u \in U_{ij}}(r_{ui} - \mu_i) \dot (r_{uj} - \mu_{j})} {\sqrt{\sum\limits_{u\in U_{ij}} (r_{ui} - \mu_i)^2} \cdot \sqrt{\sum\limits_{u \in U_{ij}} (r_{uj} - \mu_{j})^2} }\tag{4}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意一点，这里的均值计算只考虑到同时喜欢物品i和j的用户集合&lt;span class=&quot;math inline&quot;&gt;\(U_{ij}\)&lt;/span&gt;，对于其他不涉及物品i和j的用户，不要加到均值计算的过程中。&lt;/p&gt;
&lt;p&gt;通常来说，不同用户👨评分标准的差别要比不同物品评分标准差别要高很多（The differences in the rating scales of individual users are often more pronounced than the differences in ratings given to individual items），因为不同人的评分标准不一样，对于某人来说，他评分的所有物品分数都偏低。但是对于一个物品来说，不同物品之间所依据的评分标准都是大众评价的结果，这是一个被不同标准泛化了的标准。&lt;/p&gt;
&lt;p&gt;所以，当我们计算物品相似度&lt;span class=&quot;math inline&quot;&gt;\(\text{pearson_sim}(i, j)\)&lt;/span&gt;时，减去的均值应该针对于用户，而不是物品。所以，PC可以优化为AC(Adjusted):&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{ adjusted_sim}(i, j) = \frac{ \sum\limits_{u \in U_{ij}}(r_{ui} - \mu_u) \dot (r_{uj} - \mu_{u})} {\sqrt{\sum\limits_{u\in U_{ij}} (r_{ui} - \mu_u)^2} \cdot \sqrt{\sum\limits_{u \in U_{ij}} (r_{uj} - \mu_{u})^2} }\tag{5}\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;均方差msd&quot;&gt;均方差（MSD）&lt;/h3&gt;
&lt;p&gt;仍然考虑物品i和j的相似度，MSD考虑的角度为同时喜欢物品i和j的用户对于这两个物品的评分差距程度：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{msd}(i, j) = \frac{1}{|U_{ij}|} \cdot \sum\limits_{u \in U_{ij}} (r_{ui} - r_{uj})^2\tag{6}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(6)式表示均方差，值越小，物品i和j相似度越大。为了与之前的相似度表示一致（值越大，物品相似度越大），定义相似度为：&lt;/p&gt;
&lt;p&gt;$ \text{msd_sim}(i,j) = \frac{1}{\text{msd}(i,j) + 1}\tag{7}$&lt;/p&gt;
&lt;h2 id=&quot;一些考虑&quot;&gt;一些考虑🤔&lt;/h2&gt;
&lt;h3 id=&quot;accounting-for-significance&quot;&gt;Accounting for significance&lt;/h3&gt;
&lt;p&gt;对于推荐系统来说，考虑到用户的数量，评分数据是相当稀疏的。上述方法得到的所有相似度权重通常只使用了很小一部分的评分。举个例子，假设两部很小众的电影正好同时只被两个人喜欢，运用上面的方法，我们得到这两部影片相似度很高。然而实际情况可能并不是这样，这可能我们取的样本太少的缘故。所以，有这样一个思想很重要，即：&lt;strong&gt;当计算只用到很小范围的评分时，减小这个计算的相似度的权重&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Reduce the magnitude of a similarity weight when this weight is computed using only a few ratings&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以给计算出来的相似度一个惩罚(penalized)，所用的评分集合&lt;span class=&quot;math inline&quot;&gt;\(U_{ij}\)&lt;/span&gt;越小，惩罚越大：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(w_{ij}=\frac{min\{|U_{ij}|, \gamma\}}{\gamma} \times w_{ij}\tag{8}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当评分的用户集合大到一定程度时，惩罚消失。&lt;/p&gt;
&lt;h3 id=&quot;accounting-for-variance&quot;&gt;Accounting for variance&lt;/h3&gt;
&lt;p&gt;活跃度跟高的用户通常会评分很多物品，覆盖范围也更广，也就是方差(var)越大，他们的评分多，但是贡献度却要少。&lt;/p&gt;
&lt;p&gt;为什么呢？假如一个人非常爱购物，在淘宝上疯狂买各种各样的东西，那么他的一个购买跟物品种类的相关性就很低。同样的，对于物品来说，如电影《教父》，被很多人喜欢，那么根据它也很难找到与他相似的电影。简单来说：&lt;strong&gt;活跃用户对物品相似度的贡献应该小于不活跃用户&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么，我们引入一个参数：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{u} = log\frac{|I|}{|I_{u}|}\tag{9}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个参数&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{u}\)&lt;/span&gt;定义为用户u的活跃程度的倒数，&lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt;为所有物品，&lt;span class=&quot;math inline&quot;&gt;\(I_{u}\)&lt;/span&gt;为用户u有操作的物品，两者之商越大，代表活跃程度越低，即权重越高。&lt;/p&gt;
&lt;p&gt;将该参数运用到Pearson中，即：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\text{pearson_sim}(i, j) = \frac{ \sum\limits_{u \in U_{ij}}\lambda_{u} (r_{ui} - \mu_i) \dot (r_{uj} - \mu_{j})} {\sqrt{\sum\limits_{u\in U_{ij}} \lambda_{u} (r_{ui} - \mu_i)^2} \cdot \sqrt{\sum\limits_{u \in U_{ij}} \lambda_{u} (r_{uj} - \mu_{j})^2} }\tag{10}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一般化，我们可以把Pearson-baseline correlation定义如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\begin{align}\begin{aligned}\text{pearson_baseline_shrunk_sim}(u, v) = \frac{|I_{uv}| - 1} {|I_{uv}| - 1 + \text{shrinkage}} \cdot \omega_{uv}\\\text{pearson_baseline_shrunk_sim}(i, j)= \frac{|U_{ij}| - 1} {|U_{ij}| - 1 + \text{shrinkage}} \cdot \omega_{ij}\end{aligned}\end{align}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这也是surprise中&lt;code&gt;pearson_baseline()&lt;/code&gt;的计算方法。👌&lt;/p&gt;
&lt;h2 id=&quot;性能比较&quot;&gt;性能比较&lt;/h2&gt;
&lt;p&gt;下面使用surprise库对上面介绍的几种相似度度量进行比较：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pandas as pd
import numpy as np

from surprise.prediction_algorithms.knns import KNNBasic
from surprise import Dataset, Reader
from surprise.model_selection import train_test_split&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1、读取数据，预处理&lt;/p&gt;
&lt;p&gt;为了方便，这里只使用ml-latest_small的movielens数据集进行操作&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;reader = Reader(rating_scale=(1, 5), line_format='user item rating timestamp')
df_data = pd.read_csv('./data/ml-latest-small/ratings.csv', usecols=['userId','movieId','rating'])
data = Dataset.load_from_df(df_data, reader)

trainset, testset = train_test_split(data, test_size=0.2)  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、建立模型&lt;/p&gt;
&lt;p&gt;建立KNN基于邻域的模型，其预测函数为(0)式的一个优化，即：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\hat{r}_{ui} = \frac{\sum\limits_{j \in N^k_u(i)} \text{sim}(i, j) \cdot r_{uj}}{\sum\limits_{j \in N^k_u(j)} \text{sim}(i, j)}\tag{11}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们分别使用cosine, msd, pearson以及pearson-baseline作为相似度度量进行比较，分别得到其precision和recall（这里使用Top5作为metric）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;/strong&gt;precision_recall_at_k()函数见&lt;a href=&quot;https://github.com/NicolasHug/Surprise/blob/711fb80748140c44e0ed870e573c735307e6c3cc/examples/precision_recall_at_k.py&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sim = ['cosine', 'msd', 'pearson','pearson_baseline']

for s in sim:
    params = {'name': s, 'user_based': False}
    knn = KNNBasic(k=40, min_k=1, sim_options=params)
    knn.fit(trainset)
    predictions = knn.test(testset)
    precisions, recalls = precision_recall_at_k(predictions, k=5, threshold=3.5)
    print('Precision:', sum(prec for prec in precisions.values()) / len(precisions))
    print('Recall:', sum(rec for rec in recalls.values()) / len(recalls))
    print('')&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;cosine&lt;/td&gt;
&lt;td&gt;0.765&lt;/td&gt;
&lt;td&gt;0.343&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;msd&lt;/td&gt;
&lt;td&gt;0.807&lt;/td&gt;
&lt;td&gt;0.367&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;pearson&lt;/td&gt;
&lt;td&gt;0.729&lt;/td&gt;
&lt;td&gt;0.346&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;pearson-base&lt;/td&gt;
&lt;td&gt;0.776&lt;/td&gt;
&lt;td&gt;0.391&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由于数据量很小，上述的评测指数仅作参考&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《推荐系统实践》. 项亮&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://surprise.readthedocs.io/en/stable/similarities.html&quot; class=&quot;uri&quot;&gt;http://surprise.readthedocs.io/en/stable/similarities.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Recommender Systems Handbook》.Francesco Ricci · Lior Rokach · Bracha Shapira · Paul B. Kantor&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 09 Aug 2018 03:54:00 +0000</pubDate>
<dc:creator>Byron_Wu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bjwu/p/9448043.html</dc:identifier>
</item>
</channel>
</rss>