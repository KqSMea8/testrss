<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>你不知道的腾讯社招面试经验（已offer） - p2227</title>
<link>http://www.cnblogs.com/p2227/p/tencent-interview.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/p2227/p/tencent-interview.html</guid>
<description>&lt;pre class=&quot;markdown-doc&quot;&gt;
# 你不知道的腾讯社招面试经验（已offer）

## 背景
最近一段时间换工作，成功获得了腾讯的offer。在这里有点经验跟大家分享，我觉得，比起具体的面试题，有些东西更加重要，你知道这些东西，再去准备面试，说不定能获得offer；但是有些东西不注意，可能你有这个能力，但是最终还是没有offer。

我写这篇文章的目的，是让有能力有意向去腾讯的人如愿以偿，假如你能力达到，腾讯其实是挺需要人的。其他互联网大厂也可以参考，会有通用的地方。我的岗位是前端开发。

## 不要裸辞
要社招进腾讯，千万记得，**不要裸辞！不要裸辞！不要裸辞！**因为腾讯的社招流程是很长的，至少要有四轮面试，如果你级别高，甚至六到八轮，不同部门可能有差别。理想情况下都要一个月（投简历到offer），我自己是用了两个月。如果你裸辞，一般人会受不住的。而且后面还有背调什么的，即使是裸辞，offer之后可能也要8-10天才能上班。在职的话，可以跟面试官约晚上的时间，或者是要求电话面试，或者自己想办法请假。反正我异地，所以全程没去过腾讯。

腾讯的流程长，据说是为了等更好的面试者，有些时候是因为面试官出差了，反正大厂流程就是这样。

## 耐心但是要主动
面试完当时不要急着问结果，但是如果有一周没通知，这时候就要主动去问。不要自己去臆想结果，有时候，没有结果，是因为面试管没空。我试过两个面试之间相隔一周，也试过相隔两个小时，都有可能。

## 运气是十分重要的
不同面试官风格不一样，有的就问一些网上能搜到的典型题，有的会问一些课本题，但是我最喜欢的是针对我的简历深挖的风格，我offer的部门就是这样。你没办法同时很好的应对各种风格的面试官的，建议坚持自己的风格，直到遇到跟你一样风格的面试官。

前面也说过，有时候面试不过，是因为有更加好的面试者，比如职位就招一个人，但是有5个候选者，这时候面试官当然挑好的那个。有时候问题不是出在你身上，这时候只能靠运气。

## 基础与深度
腾讯面试最喜欢问的，应该是基础与深度。基础包括哪些？自己脑补吧，建议做最好的准备。深度是什么？就是你平时工作中遇到问题，不要仅仅停留在把问题解决的层面。而是要搞清楚背后的原理，怎么预防有没有更好的解决方法业界怎么处理解决方案的适用程度等等等等，这些是要有扎实基础，再加上实践，才能得到的东西。面试前要准备，但是有些深度不是一两个月能够得到的。我的第一家公司是一家不到20人的传统公司，一直走到现在，自我感觉不容易呢。

## 多交流，问走在你前面的人
业界有很多技术交流会，建议你多参加。而且不仅仅只是听讲师的内容，还要面基。多跟BAT，TMD或者其他你想要去的公司的人交流，最终离你目标就会越近。哪怕不是出于这个目的，会后的深♂入♂交♂流♂，会得到更加切身的体会。 =_=*


## 最后的话
以上只是我个人的一点小经验，未必适用每个人，建议自己去思考。最后github求follow求star

[https://github.com/p2227/p2227.github.io](https://github.com/p2227/p2227.github.io)
&lt;/pre&gt;</description>
<pubDate>Mon, 02 Jul 2018 07:51:00 +0000</pubDate>
<dc:creator>p2227</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/p2227/p/tencent-interview.html</dc:identifier>
</item>
<item>
<title>iFIERO - (一) 宇宙大战 SPACE BATTLE — 场景SCENE、SpriteKit精灵、PARTICLE粒子及背景音乐 - 布袋</title>
<link>http://www.cnblogs.com/apiapia/p/9253909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apiapia/p/9253909.html</guid>
<description>&lt;p&gt;开始游戏教程前，首先介绍一下&lt;a href=&quot;https://developer.apple.com/spritekit/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;SpriteKit&lt;/a&gt;是什么?&lt;br/&gt;SpriteKit提供了一个图形渲染和动画的基础结构，你可以使用它让任意类型的纹理图片或者精灵动起来。SpriteKit使用渲染循环，利用图形硬件渲染动画的每一帧。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;686&quot; data-height=&quot;429&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-80f60fc2f6e2c603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/686&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-80f60fc2f6e2c603.png&quot; data-original-width=&quot;686&quot; data-original-height=&quot;429&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;54989&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;SpriteKit框架渲染每一帧的周期流程原理图&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;在iOS传统的view的系统中，view的内容被渲染一次后就将一直等待，直到需要渲染的内容发生改变（比如用户发生交互，view的迁移等）的时候，才进行下一次渲染。这主要是因为传统的view大多工作在静态环境下，并没有需要频繁改变的需求。而对于SpriteKit来说，其本身就是用来制作大多数时候是动态的游戏的，为了保证动画的流畅和场景的持续更新，在SpriteKit中view将会循环不断地重绘。&lt;/p&gt;
&lt;p&gt;动画和渲染的进程是和SKScene对象绑定的，只有当场景被呈现时，这些渲染以及其中的action才会被执行。SKScene实例中，一个循环按执行顺序包括：&lt;/p&gt;
&lt;p&gt;每一帧开始时，SKScene的-update:方法将被调用，参数是从开始时到调用时所经过的时间。在该方法中，我们应该实现一些游戏逻辑，包括AI，精灵行为等等，另外也可以在该方法中更新node的属性或者让node执行action&lt;br/&gt;在update执行完毕后，SKScene将会开始执行所有的action。因为action是可以由开发者设定的（还记得runBlock:么），因此在这一个阶段我们也是可以执行自己的代码的。&lt;/p&gt;
&lt;p&gt;在当前帧的action结束之后，SKScene的-didEvaluateActions将被调用，我们可以在这个方法里对结点做最后的调整或者限制，之后将进入物理引擎的计算阶段。&lt;/p&gt;
&lt;p&gt;然后SKScene将会开始物理计算，如果在结点上添加了SKPhysicsBody的话，那么这个结点将会具有物理特性，并参与到这个阶段的计算。根据物理计算的结果，SpriteKit将会决定结点新的状态。&lt;/p&gt;
&lt;p&gt;然后-didSimulatePhysics会被调用，这类似之前的-didEvaluateActions。这里是我们开发者能参与的最后的地方，是我们改变结点的最后机会。&lt;br/&gt;一帧的最后是渲染流程，根据之前设定和计算的结果对整个呈现的场景进行绘制。完成之后，SpriteKit将开始新的一帧。&lt;/p&gt;
&lt;p&gt;在了解了一些SpriteKit的基础概念后，就跟着iFIERO来创建一个简单的游戏作为开启游戏入门之旅吧。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此《宇宙大战 Space Battle》教程共分为三个章节系列，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;(一)宇宙大战 Space Battle — 新建场景Scene、导入各个SpriteNode精灵、Particle粒子节点及建立背景音乐(你正在此处进行学习)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;(二)宇宙大战 Space Battle — 创建无限循环的背景Endless、监测精灵之间的物体碰撞及物理引擎Accleroation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;(三)宇宙大战 Space Battle — 各个场景SCENE之间的切换、利用UserDefaults统计分数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你将在此教程中的三个系列当中学到如下的技能：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SpaceBattle 宇宙大战 在此游戏中您将获得如下技能：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1、LaunchScreen 学习如何设置游戏启动画面;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2、Scenes 学习如何切换不同的场景 主菜单+游戏场景+游戏结束场景;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3、Accleroation 利用重力加速度 让飞船左右移动;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;4、Endless Background 无限循环背景;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;5、Scene Edit 直接使用可见即所得操作;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;6、UserDefaults 保存游戏分数、最高分;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;7、Random 利用可复用的随机函数生成Enemy;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;8、Background Music 如何添加背景音乐;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;9、Particle 粒子爆炸特效;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;应用以上各项SpriteKit与Swift技能，你开发出来的最终手机游戏的效果为如下所示：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;720&quot; data-height=&quot;450&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-7becf3b55e8fb039.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-7becf3b55e8fb039.gif&quot; data-original-width=&quot;720&quot; data-original-height=&quot;450&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;1268704&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;一、教程开始 Getting Started&lt;/p&gt;
&lt;p&gt;游戏开始前，请下载本教程的初始项目(&lt;a href=&quot;http://www.ifiero.com/uploads/SpaceBattle-01Starter.zip&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://www.ifiero.com/uploads/SpaceBattle-01Starter.zip&lt;/a&gt;)。本游戏是由SpriteKit框架、Swift语言，XCODE开发工具进行开发的。&lt;/p&gt;
&lt;p&gt;1、打开XCODE(请用正式版,非Beta版),选择Create a new Xcode project,选择iOS-&amp;gt;Game,输入Product Name(这里命名为SpaceBattle),开发语言Language选择Swfit,点击Next,工程即新建完毕&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1598&quot; data-height=&quot;934&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-428aa4a6a6b8060e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-428aa4a6a6b8060e.png&quot; data-original-width=&quot;1598&quot; data-original-height=&quot;934&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;299330&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;xcode.png&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1448&quot; data-height=&quot;1044&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-996efac6e121435f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-996efac6e121435f.png&quot; data-original-width=&quot;1448&quot; data-original-height=&quot;1044&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;154439&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;iosGame.png&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1458&quot; data-height=&quot;1052&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-f1a1bb7ad6fc36ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-f1a1bb7ad6fc36ae.png&quot; data-original-width=&quot;1458&quot; data-original-height=&quot;1052&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;152571&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;03.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;2、选择Genrnal面板,因为此Space Battle游戏为竖屏游戏,所以去除勾选Deployment Info -&amp;gt; Device Orientation中的Landscape Left 与Landscape Right,我们不需要横屏效果&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2182&quot; data-height=&quot;1590&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-9885c064af1d175d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-9885c064af1d175d.png&quot; data-original-width=&quot;2182&quot; data-original-height=&quot;1590&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;370099&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;04.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;3、删除XCode左侧目录中的 Action.sks(暂时没有用到)，修改GameScene.swift及GameViewController.swift的相关代码&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1014&quot; data-height=&quot;762&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-2aa8b53faaadf38e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-2aa8b53faaadf38e.png&quot; data-original-width=&quot;1014&quot; data-original-height=&quot;762&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;126039&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;删除Action.sks&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1878&quot; data-height=&quot;1174&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-b32f6f280e22a0d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-b32f6f280e22a0d5.png&quot; data-original-width=&quot;1878&quot; data-original-height=&quot;1174&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;382543&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;修改GameScene.swift的代码&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1988&quot; data-height=&quot;1228&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-6097ad29441606e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-6097ad29441606e2.png&quot; data-original-width=&quot;1988&quot; data-original-height=&quot;1228&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;452609&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;设置Scene的尺寸为CGSize(x:1536,y:2048)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;二、可视化编辑场景 Introducing the Sprite Kit Visual Editor&lt;/p&gt;
&lt;p&gt;1.首先需要编辑场景.sks文件，打开GameScene.sks文件，设置场景的尺寸为iPAD4:3的比例(W:1536,H:2048)，并删除场景中的文字。&lt;/p&gt;

&lt;div class=&quot;image-package&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2708&quot; data-height=&quot;1416&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-50e7ff029b3ac4a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-50e7ff029b3ac4a9.png&quot; data-original-width=&quot;2708&quot; data-original-height=&quot;1416&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;548628&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;点击Color面板,可修改Scene的场景背景颜色&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;2.拖动音乐文件到导航栏navigator-&amp;gt;SpaceBattle文件夹，勾选Copy items if needed,Added folders选择Create groups,Add to targets勾选SpaceBattle&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2362&quot; data-height=&quot;1362&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-c029c52fb73fc4f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-c029c52fb73fc4f3.png&quot; data-original-width=&quot;2362&quot; data-original-height=&quot;1362&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;474989&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;拖动音乐文件&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;3.拖动游戏工程所需要的图片到Assets.xcassets文件夹&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2720&quot; data-height=&quot;1526&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-665053702cd9e7d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-665053702cd9e7d3.png&quot; data-original-width=&quot;2720&quot; data-original-height=&quot;1526&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;770568&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Assets.xcassets&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;4.资源导入后，左侧的导航栏navigator如下图所示&lt;/p&gt;

&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1952&quot; data-height=&quot;1006&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-ff4110fa8882dda9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-ff4110fa8882dda9.png&quot; data-original-width=&quot;1952&quot; data-original-height=&quot;1006&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;378789&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;左侧的导航栏navigator样式&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;5.Assets图库中的图片尺寸分为1x,2x,3x，你只需设置1x的图片尺寸大小即可，SpriteKit会自动根据你运行的device设备尺寸(iPhoneX,iPhone,iPhone Plus,iPad)进行相应比例的调整。&lt;/p&gt;

&lt;div class=&quot;image-package&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2204&quot; data-height=&quot;904&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-5617feaba9c9f967.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-5617feaba9c9f967.png&quot; data-original-width=&quot;2204&quot; data-original-height=&quot;904&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;308547&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Assets图库中的图片尺寸分为1x,2x,3x,只需设置1x图片即可&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;非常的棒，你已经学会如何导入Mac电脑中的资源文件(图片、音乐、粒子)到SpaceBattle游戏工程内中了。&lt;br/&gt;那么，现在我们就来学习如何新建SpriteKit精灵节点吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;6.选择左侧导航栏Navigator的GameScene.sks，直接拖动一个Color Sprite到场景中，选中精灵，设置Position(0,0)，修改texture为BG_SpaceBattle_planet(AssetsAssets.xcassets文件夹的名称),并命名精灵节点的名称 Name为bg。&lt;/p&gt;

&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2700&quot; data-height=&quot;1678&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-c2f5f203c5c09c96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-c2f5f203c5c09c96.png&quot; data-original-width=&quot;2700&quot; data-original-height=&quot;1678&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;513149&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;拖动一个Color Sprite到场景中&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2166&quot; data-height=&quot;1566&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-87b082d369acd4a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-87b082d369acd4a2.png&quot; data-original-width=&quot;2166&quot; data-original-height=&quot;1566&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;408788&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;命名精灵节点的名称 Name为bg&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;7.现在你可以运行模拟器(XCode -&amp;gt; Product -&amp;gt; Run)，看看你的游戏是否正确显示你刚刚建立的精灵节点。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1046&quot; data-height=&quot;702&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-0f17c2865201acf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-0f17c2865201acf7.png&quot; data-original-width=&quot;1046&quot; data-original-height=&quot;702&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;222870&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;选择device设备&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1530&quot; data-height=&quot;758&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-13ea0ff6b5c4d648.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-13ea0ff6b5c4d648.png&quot; data-original-width=&quot;1530&quot; data-original-height=&quot;758&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;324217&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Run运行&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1986&quot; data-height=&quot;1802&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-d646db5933d0fb37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-d646db5933d0fb37.png&quot; data-original-width=&quot;1986&quot; data-original-height=&quot;1802&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;482324&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Simulator模拟器&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;棒棒哒! 你已学会了如何在场景中建立精灵节点及如何运行模拟器进行调试！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三、SpriteKit Physics 物理引擎&lt;/p&gt;
&lt;p&gt;1.Spritekit提供了一个默认的物理模拟系统，用来模拟真实物理世界，可以使得编程者将注意力从力学碰撞和重力模拟的计算中解放出来，通过简单地代码来实现物理碰撞的模拟，而将注意力集中在更需要花费精力的地方。现在，让我们来学习这个系统的使用吧。&lt;/p&gt;
&lt;p&gt;首先需要认识两个类，一个是场景scene的属性类SKPhysicsWorld，这个类基于场景，只能被修改但是不能被创建，这个类负责提供重力和检查碰撞（碰撞需要实现SKPhysicsContactDelegate代理协议），另一个就是SKPhysicsBody类，你可以对你的SKNode节点添加物理体属性，来让他们可以参与物理模拟的相关计算。&lt;/p&gt;
&lt;p&gt;SpriteKit SKPhysicsBody类物理体的属性图表&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属 性&lt;/th&gt;
&lt;th&gt;功 能&lt;/th&gt;
&lt;th&gt;图示&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;40.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;mass&lt;/td&gt;
&lt;td&gt;它决定力是如何影响主体,以及当主体参与碰撞时它有多大的动量,以千克为单位&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;800&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-1f05a336f8c43997?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-1f05a336f8c43997&quot; data-original-width=&quot;800&quot; data-original-height=&quot;800&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;45436&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;mass&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;friction&lt;/td&gt;
&lt;td&gt;它决定了物体的光滑程度.取值范围为从0.0(表面光滑,物体滑动很顺畅,就像小冰块似的)到1.0(在表面滑动是,物体会很快停止)&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;linearDamping&lt;/td&gt;
&lt;td&gt;物体的线性阻尼.取值范围为0.0(速度从不衰减)到1.0(速度立即衰减).默认值为0.1该属性被用于模拟水流或者空气的阻力.&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;800&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-c266aa158950a027?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-c266aa158950a027&quot; data-original-width=&quot;800&quot; data-original-height=&quot;800&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;27323&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;linearDamping&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;angularDamping&lt;/td&gt;
&lt;td&gt;物体的角速度阻尼.取值范围为0.0(速度从不衰减)到1.0(速度立即衰减).默认值为0.1该属性被用于模拟水流或者空气的阻力.&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;800&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-bfe002459c46a16c?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-bfe002459c46a16c&quot; data-original-width=&quot;800&quot; data-original-height=&quot;800&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;35959&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;angularDamping&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;restitution&lt;/td&gt;
&lt;td&gt;描述了当物理实体从另外一个物体上弹出时,还拥有多少能量.基本上我们称之为&quot;反弹力&quot;.它的取值介于0.0(完全不反弹)到1.0(和物体碰撞反弹是所受的力与刚开始碰撞时的力的大小相同)之间.默认值为0.2&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;800&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-a70074ff32153759?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-a70074ff32153759&quot; data-original-width=&quot;800&quot; data-original-height=&quot;800&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;35979&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;restitution&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;density&lt;/td&gt;
&lt;td&gt;物体的密度,以千克每立方米为单位.密度是根据单位体积的质量来定义的.密度越高,体积越大,物体也就会越重.密度的默认值为1.0&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;affectedByGravity&lt;/td&gt;
&lt;td&gt;设置物体是否受重力的影响.所有的物体默认的情况都是受重力影响,但是开发者可以简单的吧这个标记设置为NO,使其不受重力影响.&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;800&quot;&gt;&lt;img class=&quot;image-loading&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-2ff8ce3caced06e1&quot; data-original-width=&quot;800&quot; data-original-height=&quot;800&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;25994&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;affectedByGravity&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;allowsRotation&lt;/td&gt;
&lt;td&gt;设置物体是否受到一个旋转力的影响,默认为YES,如果该值设置为NO,物理体将忽略施加在它身上所有的力&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;resting&lt;/td&gt;
&lt;td&gt;设置物理体是否在休息.物理引擎对于一段时间内没有移动过的物体做了一个优化,把他们标记为&quot;正在休息(resting)&quot;,这样,物理引擎就不需要对它们进行计算了.如果你想要手动的唤醒一个正在休息的物体,简单的把resting设置为NO即可&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;categoryBitMask&lt;/td&gt;
&lt;td&gt;一个16进制数,定义了物体的类别.场景中每一个物理体都可以分配到超过32个不同的种类里面,每个对应位中的值&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;800&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-c7e5fd12e792b82b?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-c7e5fd12e792b82b&quot; data-original-width=&quot;800&quot; data-original-height=&quot;800&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;24608&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;categoryBitMask&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;collisionBitMask&lt;/td&gt;
&lt;td&gt;一个16进制数,定义哪种类别的物理体可以与之发生碰撞.当两个物体相关联的时候,就可能发生一个碰撞.这个物体的位相对于其他物体的类别做一个逻辑上的加法操作.如果结果是一个非零的值,则该物体收到碰撞的影响&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;contactTestBitMask&lt;/td&gt;
&lt;td&gt;一个16进制数,两个物体碰撞后发出通知 didBegin可接收到通知&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td&gt;usesPreciseCollisionDetection&lt;/td&gt;
&lt;td&gt;设置物体是否使用更精准的碰撞算法.默认情况下,除非确实有必要,Sprite Kit并不会启动精确的冲突检测,因为这样运行效率更高.但是不启动精确的冲突检测会有一个副作用,如果一个物体移动的非常快(比如一个子弹),它可能会直接穿过其他物体.如果这种情况确实发生了,你就应该尝试启动更精准的冲突检测了&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;velocity&lt;/td&gt;
&lt;td&gt;物理体的速度矢量&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;800&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-01855e71029a2d89?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-01855e71029a2d89&quot; data-original-width=&quot;800&quot; data-original-height=&quot;800&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;32925&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;velocity&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;angularVelocity&lt;/td&gt;
&lt;td&gt;物理体的角速度.角速度是一个围绕着一个轴矢量(0.0,0.0,1.0)的速度,单位是弧度每秒&lt;/td&gt;
&lt;td&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;800&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-058f3ebadd80bd31?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-058f3ebadd80bd31&quot; data-original-width=&quot;800&quot; data-original-height=&quot;800&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;38979&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;angularVelocity&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;以上图表感谢简书作者的收集整理：https://www.jianshu.com/p/4046bab3a63d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.对SpriteKit PhysicsBody类的基础的概念了解后，我们现在就来新建player玩家飞船节点playerNode还有alien外星飞船精灵节点，并设置他们的物理属性。&lt;/p&gt;

&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1500&quot; data-height=&quot;1208&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-68e65a6a8c8c9c27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-68e65a6a8c8c9c27.png&quot; data-original-width=&quot;1500&quot; data-original-height=&quot;1208&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;398768&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;新建player玩家飞船节点 属性面板中Sprite Name命名为playerNode&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class GameScene: &lt;span class=&quot;hljs-built_in&quot;&gt;SKScene,&lt;span class=&quot;hljs-built_in&quot;&gt;SKPhysicsContactDelegate {
    
    private var playerNode:&lt;span class=&quot;hljs-built_in&quot;&gt;SKSpriteNode!  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随机生成alien精灵节点&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;&gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CGFloat.random 拓展函数 返回二个数之间的随机数&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;&gt;import CoreGraphics
import SpriteKit

public extension &lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat {
    
    &lt;span class=&quot;hljs-meta&quot;&gt;#if !(arch(x86_64) || arch(arm64))
    func sqrt(a: &lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat) -&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat(sqrtf(Float(a)))
    }
    &lt;span class=&quot;hljs-meta&quot;&gt;#endif
    
    public &lt;span class=&quot;hljs-keyword&quot;&gt;static func random() -&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat(Float(arc4random()) / &lt;span class=&quot;hljs-number&quot;&gt;0xFFFFFFFF)
    }
    
    public &lt;span class=&quot;hljs-keyword&quot;&gt;static func random(min: &lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat, max: &lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat) -&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat {
        assert(min &amp;lt; max)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat.random() * (max - min) + min
    }
    
}

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在override func didMove(to view: SKView) {}内应用Timer.scheduledTimer间隔0.5秒生成Alien&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;现在Command+R 运行工程下(或选择XCODE -&amp;gt; Product-&amp;gt; Run),你在模拟器中应可以看到源源不断的alien外星飞船正向下俯冲&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;720&quot; data-height=&quot;450&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-e27cc162e3e259e9.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-e27cc162e3e259e9.gif&quot; data-original-width=&quot;720&quot; data-original-height=&quot;450&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;187736&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;alien外星飞船正向下俯冲&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;3.生成子弹及粒子效果&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们将在第二章节学习飞船子弹的发射以及粒子效果的知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;四、到此，此章节就接近尾声了&lt;/p&gt;
&lt;p&gt;我们已经学会了很多技能，包括如何新建工程，如何建立Sprite精灵节点，还有如何应用SpriteKit Physics物理引擎。你可以在此下载此章节的工程完整代码。(&lt;a href=&quot;http://www.ifiero.com/uploads/SpaceBattle-01final.zip&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://www.iFIERO.com/uploads/SpaceBattle-01final.zip&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;五、更多内容&lt;/p&gt;
&lt;p&gt;在下一章节当中，(二)宇宙大战 Space Battle — 创建无限循环的背景Endless、监测精灵之间的物体碰撞及物理引擎Accleroation，我们将学习如何监测SpriteKit Physics物理之间碰撞，如何销毁对象，如何监测屏幕Scene的点击事件以及物理引擎Accleroation的相关知识。&lt;/p&gt;
&lt;p&gt;请注意，此《宇宙大战 Space Battle》教程共分为三个章节系列：&lt;/p&gt;
&lt;p&gt;(一)宇宙大战 Space Battle — 新建场景Scene、导入各个SpriteNode精灵、Particle粒子节点及建立背景音乐(你正在此处进行学习)&lt;/p&gt;
&lt;p&gt;(二)宇宙大战 Space Battle — 创建无限循环的背景Endless、监测精灵之间的物体碰撞及物理引擎Accleroation&lt;/p&gt;
&lt;p&gt;(三)宇宙大战 Space Battle — 各个场景SCENE之间的切换、利用UserDefaults统计分数&lt;/p&gt;
&lt;p&gt;更多游戏教学：iFIERO.COM -- 开源手机游戏教程网,让手机游戏开发变得简单!&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1000&quot; data-height=&quot;33&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-51047d8dc0b2467d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3896436-51047d8dc0b2467d.png&quot; data-original-width=&quot;1000&quot; data-original-height=&quot;33&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;5382&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;iFiero.com&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 02 Jul 2018 07:10:00 +0000</pubDate>
<dc:creator>布袋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apiapia/p/9253909.html</dc:identifier>
</item>
<item>
<title>深入出不来nodejs源码-内置模块引入再探 - 书生小龙</title>
<link>http://www.cnblogs.com/QH-Jimmy/p/9243859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QH-Jimmy/p/9243859.html</guid>
<description>&lt;p&gt;　　我发现每次细看源码都能发现我之前写的一些东西是错误的，去改掉吧，又很不协调，不改吧，看着又脑阔疼……&lt;/p&gt;
&lt;p&gt;　　所以，这一节再探，是对之前一些说法的纠正，另外再缝缝补补一些新的内容。&lt;/p&gt;
&lt;p&gt;　　错误在哪呢？在之前的初探中，有这么一块代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The bootstrapper scripts are lib/internal/bootstrap/loaders.js and
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; lib/internal/bootstrap/node.js, each included as a static C string
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; defined in node_javascript.h, generated in node_javascript.cc by
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; node_js2c.&lt;/span&gt;
  Local&amp;lt;String&amp;gt; loaders_name =&lt;span&gt;
      FIXED_ONE_BYTE_STRING(env&lt;/span&gt;-&amp;gt;isolate(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;internal/bootstrap/loaders.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  Local&lt;/span&gt;&amp;lt;Function&amp;gt; loaders_bootstrapper =&lt;span&gt;
      GetBootstrapper(env, LoadersBootstrapperSource(env), loaders_name);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当时，我的理解是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt; 辅助函数则是加载了internal/bootstrap中的两个JS文件，加载的时候参数传入了C++代码生成的特殊对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　但是在我调试这块代码的时候，发现根本没有任何readFile的痕迹，才发现事情并没有那么简单，也就是说这个地方压根就没有加载对应的JS文件。&lt;/p&gt;
&lt;p&gt;　　那么问题来了，既然没有加载这个JS文件，那这个文件有什么意义？何处加载的？&lt;/p&gt;
&lt;p&gt;　　第一个问题，我猜大概是开发者想让我们直观的了解到加载了什么东西，所以以文件的形式保留在文件夹中方便查看。&lt;/p&gt;
&lt;p&gt;　　第二个问题，根据注释，可以很快的知道答案，但是当时哪里注意那么多哟。&lt;/p&gt;
&lt;p&gt;　　简单讲，这个文件的内容以静态的字符串的形式定义在node_javascript.h中，内容则在node_javascript.cc中，并使用node_js2c进行JS代码到C++代码的转换。&lt;/p&gt;

&lt;p&gt;　　问题的答案很简单，探索过程对我来说还是挺心酸的，这里一共有两行代码，首先看第一行。&lt;/p&gt;
&lt;p&gt;　　FIXED_ONE_BYTE_STRING是一个宏，这里暂不讨论内部实现，根据参数和返回类型可以简单判断这是一个转换函数，可以将const char*类型转换成Local&amp;lt;String&amp;gt;类型，至于Local是什么，可以参考我上一节内容，或者查阅其他的资料。&lt;/p&gt;
&lt;p&gt;　　对于第二行代码，需要关注的是LoaderBootstrapperSource这个方法，进去之后会发现又是一个调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
v8::Local&amp;lt;v8::String&amp;gt; LoadersBootstrapperSource(Environment*&lt;span&gt; env) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; internal_bootstrap_loaders_value.ToStringChecked(env-&amp;gt;&lt;span&gt;isolate());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个internal_bootstrap_loaders_value是一个结构体，形式比较简单(C++代码结构都很简单)，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; v8::String::ExternalOneByteStringResource {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写父类函数
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强制进行const unsigned char[] =&amp;gt; const char*的类型转换&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* data() &lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; reinterpret_cast&amp;lt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&amp;gt;&lt;span&gt;(raw_internal_bootstrap_loaders_value);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数组长度&lt;/span&gt;
    size_t length() &lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; arraysize(raw_internal_bootstrap_loaders_value); }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认delete函数&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; Dispose() &lt;span&gt;override&lt;/span&gt; { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Default calls `delete this`. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; const char* =&amp;gt; Local&amp;lt;String&amp;gt;的类型转换&lt;/span&gt;
    v8::Local&amp;lt;v8::String&amp;gt; ToStringChecked(v8::Isolate*&lt;span&gt; isolate) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; v8::String::NewExternalOneByte(isolate, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;).ToLocalChecked();
    }
} internal_bootstrap_loaders_value;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　几个内部的属性作用非常明朗，注释都有写。&lt;/p&gt;
&lt;p&gt;　　暂时不去深入了解ToStringChecked方法的内部实现，从返回类型来看，最终也是生成一个Local&amp;lt;String&amp;gt;类型的方法，而这个String的源头，就是上面另外一个变量raw_internal_bootstrap_loaders_value。&lt;/p&gt;
&lt;p&gt;　　这个东西是这么定义的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; uint8_t raw_internal_bootstrap_loaders_value[] = { &lt;span&gt;47&lt;/span&gt;,&lt;span&gt;47&lt;/span&gt;,&lt;span&gt;32&lt;/span&gt;,&lt;span&gt;84&lt;/span&gt;,&lt;span&gt;104&lt;/span&gt;,&lt;span&gt;105&lt;/span&gt;,&lt;span&gt;115&lt;/span&gt;,&lt;span&gt;32&lt;/span&gt;,&lt;span&gt;102&lt;/span&gt;,&lt;span&gt;105&lt;/span&gt;,&lt;span&gt;108&lt;/span&gt;,&lt;span&gt;101&lt;/span&gt;,&lt;span&gt;32&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;114&lt;/span&gt;,&lt;span&gt;101&lt;/span&gt;,&lt;span&gt;97&lt;/span&gt;,&lt;span&gt;116&lt;/span&gt;,&lt;span&gt;101&lt;/span&gt;,&lt;span&gt;115&lt;/span&gt;,... }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　很长很长的一个数组，uint8_t是unsigned char的别名，也就是说，这是一个超长的char数组。&lt;/p&gt;
&lt;p&gt;　　根据C++的基础知识，数组的名字本质上是一个指针，指向数组的第一个值，而数组的值又恰好是char类型的，所以说，对该值进行reinterpret_cast&amp;lt;const char*&amp;gt;的转换是不会有问题的。&lt;/p&gt;
&lt;p&gt;　　那么另外一个问题是，const char*更为熟知的类型是string字符串，这里一个数字数组是怎么变成字符串的？&lt;/p&gt;
&lt;p&gt;　　干想果然是浪费时间的，我把这个大数组弄到本地自己打印了一下，发现输出的内容竟然是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201806/858904-20180629170937029-987449440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　怎么感觉这么熟悉，翻开JS文件，果然……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201806/858904-20180629171026888-1645255804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　简单思考后，原来这里是因为ASCII表转换，把对应的一个个字符转换成了数字保存在字符数组中，真的是恶心啊。&lt;/p&gt;
&lt;p&gt;　　那么问题就解决了，&lt;strong&gt;加载的辅助JS文件内容其实是以字符数组保存在C++中的，获取完整内容后通过对JS到C++的转换，然后执行对应的代码&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　既然完成了JS文件内容、文件名的内容获取，下一步就是构建对应的函数体，方法就是GetBootstrapper，源码简化后如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态公共方法 专门负责生成初始化辅助函数体
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; env =&amp;gt; 上下文环境
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; source =&amp;gt; JS格式的函数字符串
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; script_name =&amp;gt; 资源名&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; Local&amp;lt;Function&amp;gt; GetBootstrapper(Environment* env, Local&amp;lt;String&amp;gt;&lt;span&gt; source,
    Local&lt;/span&gt;&amp;lt;String&amp;gt;&lt;span&gt; script_name) {
    EscapableHandleScope scope(env&lt;/span&gt;-&amp;gt;&lt;span&gt;isolate());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析JS字符串并转换成Local&amp;lt;Value&amp;gt;类型&lt;/span&gt;
    Local&amp;lt;Value&amp;gt; bootstrapper_v =&lt;span&gt; ExecuteString(env, source, script_name);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检测返回的数据类型是否是函数并进行强制类型转换&lt;/span&gt;
    CHECK(bootstrapper_v-&amp;gt;&lt;span&gt;IsFunction());
    Local&lt;/span&gt;&amp;lt;Function&amp;gt; bootstrapper = Local&amp;lt;Function&amp;gt;&lt;span&gt;::Cast(bootstrapper_v);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; scope.Escape(bootstrapper);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里省略了一些无关的错误处理，比较关键的几步可以看注释描述，有几点需要特殊说明一下：&lt;/p&gt;
&lt;p&gt;1、关于EscapableHandleScope，正常情况下都是使用的HandleScope来管理作用域的Local，但是如果函数需要返回临时创建的Local，在返回前Local已经被V8的GC进行了处理，这里必须使用EscapableHandleScope类创建一个特殊的scope，并在最后调用Escape方法将指定的Local返回。&lt;/p&gt;
&lt;p&gt;2、返回类型的Local&amp;lt;Value&amp;gt;，如果有看过上一节对于V8引擎一些基本概念的讲解，应该会发现Value是所有数据类型的根类，在对类型进行CHECK后再强制转换可以保证类型安全。&lt;/p&gt;

&lt;p&gt;　　最后看一眼ExecuteString方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; Local&amp;lt;Value&amp;gt; ExecuteString(Environment*&lt;span&gt; env,
    Local&lt;/span&gt;&amp;lt;String&amp;gt;&lt;span&gt; source,
    Local&lt;/span&gt;&amp;lt;String&amp;gt;&lt;span&gt; filename) {
    EscapableHandleScope scope(env&lt;/span&gt;-&amp;gt;&lt;span&gt;isolate());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译解析一条龙&lt;/span&gt;
&lt;span&gt;    ScriptOrigin origin(filename);
    MaybeLocal&lt;/span&gt;&amp;lt;v8::Script&amp;gt; script =&lt;span&gt;
        v8::Script::Compile(env&lt;/span&gt;-&amp;gt;context(), source, &amp;amp;&lt;span&gt;origin);
    MaybeLocal&lt;/span&gt;&amp;lt;Value&amp;gt; result = script.ToLocalChecked()-&amp;gt;Run(env-&amp;gt;&lt;span&gt;context());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回Local&amp;lt;Value&amp;gt;类型的C++代码&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; scope.Escape(result.ToLocalChecked());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里同样省略一些无关代码，可以发现，处理过程非常直白，直接利用Script类对字符串进行编译解析，然后返回执行完后生成的函数体。&lt;/p&gt;
&lt;p&gt;　　对于&quot;internal/bootstrap/node.js&quot;的加载过程也类似，就不再重复了。&lt;/p&gt;
&lt;p&gt;　　目前得到了函数体，但是并没有执行，后面再分析这块内容。&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 06:52:00 +0000</pubDate>
<dc:creator>书生小龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QH-Jimmy/p/9243859.html</dc:identifier>
</item>
<item>
<title>React Native基础&amp;入门教程：初步使用Flexbox布局 - 葡萄城控件技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/react-native-tutorials2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/react-native-tutorials2.html</guid>
<description>&lt;p&gt;在上篇中，笔者分享了部分安装并调试React Native应用过程里的一点经验，如果还没有看过的同学请点击&lt;strong&gt;《&lt;/strong&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/powertoolsteam/p/react-native-tutorials1.html&quot;&gt;React Native基础&amp;amp;入门教程：调试React Native应用的一小步&lt;/a&gt;&lt;strong&gt;》。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本篇里，让我们一起来了解一下，什么是Flexbox布局，以及如何使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、长度的单位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在开始任何布局之前，让我们来首先需要知道，在写React Native组件样式时，长度的不带单位的，它表示“与设备像素密度无关的逻辑像素点”。&lt;/p&gt;
&lt;p&gt;这个怎么理解呢？&lt;/p&gt;
&lt;p&gt;我们知道，屏幕上一个发光的最小点，对应着一个pixel（像素）点。&lt;/p&gt;
&lt;p&gt;假设下面三个矩形，代表三个屏幕大小一样的设备，但是，它们拥有的分辨率（resolution）不同：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135741324-487884672.png&quot;&gt;&lt;img title=&quot;clip_image001&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135741649-842976119.png&quot; alt=&quot;clip_image001&quot; width=&quot;577&quot; height=&quot;295&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图1.相同尺寸的设备 不同的分辨率&lt;/p&gt;
&lt;p&gt;图上的每一个小格子，其实就代表了一个像素（pixel）。可以看到，一个像素点的大小，在这个三个物理尺寸一样但拥有不同分辨率的设备上，是不一样的。&lt;/p&gt;
&lt;p&gt;如果我们以像素为单位来设置一个界面元素的大小，比如说2px的高度，那么这2px的长度上面的设备中就会是下面这个样子：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135741919-2135551401.png&quot;&gt;&lt;img title=&quot;clip_image002&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135742200-256125548.png&quot; alt=&quot;clip_image002&quot; width=&quot;582&quot; height=&quot;291&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图2.不同分辨率下的2px实际高度&lt;/p&gt;
&lt;p&gt;它们真实显示出的长度是不一样的。&lt;/p&gt;
&lt;p&gt;我们想要一种长度单位，在同样物理尺寸大小的屏幕上（不论分辨率谁高谁低，只要物理尺寸大小一样即可），1个单位的长度所代表的物理尺寸是一样的。这种单位就应该是独立于分辨率的，把它起一个名字叫做 density-independent pixels，简称dp。这其实就是Android系统中所使用的长度单位。&lt;/p&gt;
&lt;p&gt;举例来说，2dp宽，2dp高的内容，在不同分辨率但屏幕尺寸一样的设备上所显示出的物理大小是一样的。（一个题外话：有些Android开发者建议所有可点击的按钮，宽高都不应该少于48dp。）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135742494-416271747.png&quot;&gt;&lt;img title=&quot;clip_image003&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135742761-1031048644.png&quot; alt=&quot;clip_image003&quot; width=&quot;591&quot; height=&quot;334&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图3. 2dp * 2dp大小的内容 在同样尺寸的屏幕中所占据的物理大小一致&lt;/p&gt;
&lt;p&gt;Android中字体大小使用另外一个单位，叫做scale independent pixels，简称sp。这个单位和dp很类似，不过它通常是用在对字体大小的设置中。通过它设置的字体，可以根据系统字体大小的变化而变化。&lt;/p&gt;
&lt;p&gt;pixel与dp存在一个公式：px = dp * (dpi/160)。&lt;/p&gt;
&lt;p&gt;dpi表示dot per inch，是每英寸上的像素点，它也有个自己的计算公式，具体这里就不展开了。只需要知道我们之所以要使用一个独立于设备分辨率的单位，主要是为了让应用在不同分辨率的设备中，看起来一致。&lt;/p&gt;
&lt;p&gt;在RN中，同样也拥有一个类似于dp的长度单位。如果我们想知道自己的屏幕以这种长度的计量下是多少单位，可以通过引入react-native包中的Dimensions拿到，同时还可以查看本机的像素比例是多少。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import {
　　Text,
　　View,
　　Dimensions,
　　PixelRatio
} from &lt;/span&gt;'react-native'&lt;span&gt;;
const { height, width } &lt;/span&gt;= Dimensions.get('window'&lt;span&gt;);
const pxRatio &lt;/span&gt;=&lt;span&gt; PixelRatio.get();&lt;br/&gt;&lt;/span&gt;&amp;lt;View style={styles.container}&amp;gt;
　　&amp;lt;Text style={styles.welcome}&amp;gt;&lt;span&gt;
　　　　{`width: ${width}, height: ${height}`}
　　&lt;/span&gt;&amp;lt;/Text&amp;gt;
　　&amp;lt;Text style={styles.welcome}&amp;gt;&lt;span&gt;
　　　　{`pixel radio: ${pxRatio}`}
　　&lt;/span&gt;&amp;lt;/Text&amp;gt;
&amp;lt;/View&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135743183-1513045350.png&quot;&gt;&lt;img title=&quot;clip_image004&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135743651-1551548619.png&quot; alt=&quot;clip_image004&quot; width=&quot;371&quot; height=&quot;657&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图4. 当前手机的屏幕信息&lt;/p&gt;
&lt;p&gt;它反映出，当前手机屏幕的宽度占据360个单位，高度占据640个单位。像素比例是3，实际上这就是一个 1080 * 1920 像素的手机。其中1080 = width * pixelRadio, 1920 = height * pixelRatio&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、&lt;/strong&gt;&lt;strong&gt;Flexbox&lt;/strong&gt;&lt;strong&gt;布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flexbox布局，也就是弹性盒模型布局。也许有Android开发经验的朋友还对LinearLayout，RelativeLayout，FrameLayout等布局方法记忆犹新，但是对于更了解CSS的Web开发者而言，使用flexbox布局肯定会让他感受到更加顺手的开发体验。&lt;/p&gt;
&lt;p&gt;RN中的flexbox布局，其实源于CSS中的flexbox（弹性盒子）布局规范。其实它在CSS中还处于Last Call Working Draft（最终征求意见稿）阶段，但是主流浏览器对它都有了良好的支持。在RN中，几乎完全借鉴了其中的布局语义，同时更没有浏览器兼容的烦恼，用起来是很方便的。RN中只是把CSS的属性用camelCase写法代替连字符写法。后面还还会看到，默认的flex方向也不同。&lt;/p&gt;
&lt;p&gt;理解弹性盒模型布局，首先要知道四个最基本的概念：Flex Container（容器），Flex Item（项），Flex Direction（方向）和Axis（轴）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Flex Container&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就是包裹内容的容器，需要把它的display设置为‘flex’（或者'inline-flex'）。&lt;/p&gt;
&lt;p&gt;以下6个属性设置在容器上。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;alignItems 指定item在侧轴上的对齐方式&lt;/li&gt;
&lt;li&gt;alignContent 指定item在多条轴上的对齐方式&lt;/li&gt;
&lt;li&gt;flexDirection 指定主轴方向&lt;/li&gt;
&lt;li&gt;flexWrap 指定item在主轴方向如何换行&lt;/li&gt;
&lt;li&gt;flexFlow flexDirection属性和flexWrap属性的简写形式&lt;/li&gt;
&lt;li&gt;justifyContent 指定item在主轴上的分布方式&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;2.Flex Item&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器做直接包裹的元素。所谓弹性盒布局，通常想要布局的东西就是它们。&lt;/p&gt;
&lt;p&gt;以下6个属性设置在项目上。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;alignSelf 每个item可以单独设置对齐方式 覆盖Flex Container给设置的alignItems&lt;/li&gt;
&lt;li&gt;order 指定item排列顺序 数字越小越靠前&lt;/li&gt;
&lt;li&gt;flexGrow 指定item的拉伸比例&lt;/li&gt;
&lt;li&gt;flexShrink 指定item的压缩比例&lt;/li&gt;
&lt;li&gt;flexBasis 指定item在分配多余空间之前，占主轴的大小&lt;/li&gt;
&lt;li&gt;flex 其实是 flexGrow flexShrink flexBasis的简写&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;3.Flex Direction and Axis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在弹性盒子中，项目默认沿着main axis（主轴）排列，和主轴垂直的轴叫做cross axis，叫做侧轴，或者交叉轴。&lt;/p&gt;
&lt;p&gt;在盒子中，排列项目又四个方向：水平的正反两个，垂直的正反两个。&lt;/p&gt;
&lt;p&gt;结构代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;View&amp;gt;
    &amp;lt;View style={styles.row}&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;1&amp;lt;/Text&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;2&amp;lt;/Text&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;3&amp;lt;/Text&amp;gt;
    &amp;lt;/View&amp;gt;
    &amp;lt;View style={styles.rowReverse}&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;1&amp;lt;/Text&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;2&amp;lt;/Text&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;3&amp;lt;/Text&amp;gt;
    &amp;lt;/View&amp;gt;
    &amp;lt;View style={styles.column}&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;1&amp;lt;/Text&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;2&amp;lt;/Text&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;3&amp;lt;/Text&amp;gt;
    &amp;lt;/View&amp;gt;
    &amp;lt;View style={styles.columnReverse}&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;1&amp;lt;/Text&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;2&amp;lt;/Text&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;3&amp;lt;/Text&amp;gt;
    &amp;lt;/View&amp;gt;
&amp;lt;/View&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;样式代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;row: &lt;/span&gt;{&lt;span&gt;
backgroundColor&lt;/span&gt;:&lt;span&gt; '#ffe289',
flexDirection: 'row'
&lt;/span&gt;}&lt;span&gt;,
rowReverse: &lt;/span&gt;{&lt;span&gt;
flexDirection&lt;/span&gt;:&lt;span&gt; 'row-reverse'
&lt;/span&gt;}&lt;span&gt;,
column: &lt;/span&gt;{&lt;span&gt;
backgroundColor&lt;/span&gt;:&lt;span&gt; '#ffe289',
flexDirection: 'column'
&lt;/span&gt;}&lt;span&gt;,
columnReverse: &lt;/span&gt;{&lt;span&gt;
flexDirection&lt;/span&gt;:&lt;span&gt; 'column-reverse'
&lt;/span&gt;}&lt;span&gt;,&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135743994-1354538437.png&quot;&gt;&lt;img title=&quot;clip_image005&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135744334-533120049.png&quot; alt=&quot;clip_image005&quot; width=&quot;370&quot; height=&quot;654&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图5. flexDirection&lt;/p&gt;
&lt;p&gt;由于网上关于flex布局讲解的资源挺丰富的，读者可以参考最后给出的连接，或者自行上网搜索，CSS中的和RN是相通的。&lt;/p&gt;
&lt;p&gt;这里主要分享个人在学习过程中，觉得容易引起混淆的两个小点。&lt;/p&gt;
&lt;p&gt;首先，justify-content和align-content这两个属性，可能比较容易搞错它们作用的方向。&lt;/p&gt;
&lt;p&gt;其中，justify-content是设置items沿着主轴上是如何分布的。align-content是设置items沿着侧轴如何对齐的。&lt;/p&gt;
&lt;p&gt;还是拿之前的例子，默认情况下，flex的方向是column（这个与移动端与web页面不同，在web页面用CSS设置flex布局，默认的fiex-direction是row，即水平从左往右）。&lt;/p&gt;
&lt;p&gt;在移动端，主轴默认是垂直方向，从上往下。让我们把它的高度设置高一点，放3个item在里面：&lt;/p&gt;
&lt;p&gt;结构代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;View&amp;gt;
    &amp;lt;View style={styles.defaultFlex}&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;1&amp;lt;/Text&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;2&amp;lt;/Text&amp;gt;
        &amp;lt;Text style={styles.item}&amp;gt;3&amp;lt;/Text&amp;gt;
    &amp;lt;/View&amp;gt;
&amp;lt;/View&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;样式代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;defaultFlex: &lt;/span&gt;{&lt;span&gt;
height&lt;/span&gt;:&lt;span&gt; 300,
backgroundColor: '#ffe289',
display: 'flex'
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135744656-1282320572.png&quot;&gt;&lt;img title=&quot;clip_image006&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135744985-1988800356.png&quot; alt=&quot;clip_image006&quot; width=&quot;379&quot; height=&quot;671&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图6. 默认的flex&lt;/p&gt;
&lt;p&gt;justify-content设置items在主轴方向的如何分布，比如，如果我们加上justifyContent: 'space-between'&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;defaultFlex: &lt;/span&gt;{&lt;span&gt;
height&lt;/span&gt;:&lt;span&gt; 300,
backgroundColor: '#ffe289',
display: 'flex',
justifyContent: 'space-between'
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;items就&lt;strong&gt;沿主轴&lt;/strong&gt;分开了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135745322-1875065342.png&quot;&gt;&lt;img title=&quot;clip_image007&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135745628-2015626682.png&quot; alt=&quot;clip_image007&quot; width=&quot;384&quot; height=&quot;679&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图7. justifyContent: 'space-between'&lt;/p&gt;
&lt;p&gt;如果我们设置alignItems: 'center',项目就沿侧轴（这里就是水平轴）居中了。注意这两个属性是可以同时起作用的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135745951-911007953.png&quot;&gt;&lt;img title=&quot;clip_image008&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135746332-2075954732.png&quot; alt=&quot;clip_image008&quot; width=&quot;375&quot; height=&quot;663&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图8. justifyContent: 'space-between' 以及 alignItems: 'center'&lt;/p&gt;
&lt;p&gt;然后，值得指出的是，flex这个属性，其实是flexGrow, flexShrink, flexBasis（对应的CSS属性flex-grow, flex-shrink和flex-basis)三个属性的结合。&lt;/p&gt;
&lt;p&gt;我们通常在移动端看到的flex:1这个设置，其实是对flex-grow的设置。后者的默认值为0。使用把flex-grow设置为正整数的方法，可以让item按比例分布，或者在其他item为固定大小时撑满剩余的盒子空间，就仿佛具有弹性一样。&lt;/p&gt;
&lt;p&gt;结构代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;View style={styles.container}&amp;gt;
    &amp;lt;View style={styles.flex1}&amp;gt;&amp;lt;/View&amp;gt;
    &amp;lt;View style={styles.flex2}&amp;gt;&amp;lt;/View&amp;gt;
    &amp;lt;View style={styles.flex3}&amp;gt;&amp;lt;/View&amp;gt;
&amp;lt;/View&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;样式代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;container: &lt;/span&gt;{&lt;span&gt;
flex&lt;/span&gt;:&lt;span&gt; 1
&lt;/span&gt;}&lt;span&gt;,
flex1: &lt;/span&gt;{&lt;span&gt;
// height&lt;/span&gt;:&lt;span&gt; 99,
flexGrow: 1,
backgroundColor: 'orange',
&lt;/span&gt;}&lt;span&gt;,
flex2: &lt;/span&gt;{&lt;span&gt;
flexGrow&lt;/span&gt;:&lt;span&gt; 2,
backgroundColor: 'lightblue',
&lt;/span&gt;}&lt;span&gt;,
flex3: &lt;/span&gt;{&lt;span&gt;
flexGrow&lt;/span&gt;:&lt;span&gt; 3,
backgroundColor: 'green',
&lt;/span&gt;}&lt;span&gt;,&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135746718-253807996.png&quot;&gt;&lt;img title=&quot;clip_image009&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135747050-1950589006.png&quot; alt=&quot;clip_image009&quot; width=&quot;376&quot; height=&quot;666&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图9. 按比例分布&lt;/p&gt;
&lt;p&gt;需要注意的是，如果父容器的尺寸为零（即没有设置宽高，或者没有设定flex），即使子组件如果使用了flex，也是无法显示的。&lt;/p&gt;
&lt;p&gt;所以这里最外层的使用了flex布局的，flex:1，表示让它占据了垂直的整个空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、小小实战演练&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们来简单使用flex布局，对之前的例子稍加调整，实现一个头部，底部固定高度，中间内容占满剩下的屏幕的布局：&lt;/p&gt;
&lt;p&gt;第一步，调整结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;View style={styles.container}&amp;gt;
    &amp;lt;View style={styles.header}&amp;gt;&amp;lt;/View&amp;gt;
    &amp;lt;View style={styles.body}&amp;gt;&amp;lt;/View&amp;gt;
    &amp;lt;View style={styles.footer}&amp;gt;&amp;lt;/View&amp;gt;
&amp;lt;/View&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调整样式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;container: &lt;/span&gt;{&lt;span&gt;
flex&lt;/span&gt;:&lt;span&gt; 1
&lt;/span&gt;}&lt;span&gt;,
header: &lt;/span&gt;{&lt;span&gt;
height&lt;/span&gt;:&lt;span&gt; 60,
backgroundColor: 'orange',
&lt;/span&gt;}&lt;span&gt;,
body: &lt;/span&gt;{&lt;span&gt;
flexGrow&lt;/span&gt;:&lt;span&gt; 1,
backgroundColor: 'lightblue',
&lt;/span&gt;}&lt;span&gt;,
footer: &lt;/span&gt;{&lt;span&gt;
height&lt;/span&gt;:&lt;span&gt; 60,
backgroundColor: 'green',
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135747396-1578422041.png&quot;&gt;&lt;img title=&quot;clip_image010&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135747711-1081935288.png&quot; alt=&quot;clip_image010&quot; width=&quot;375&quot; height=&quot;664&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图10. 有头尾的布局&lt;/p&gt;
&lt;p&gt;第二部，给header添加标题。&lt;/p&gt;
&lt;p&gt;我们让头部的分成3部分，左边模拟一个返回按钮，中间显示标题文字，右边模拟一把小叉：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;View style={styles.header}&amp;gt;
    &amp;lt;Text style={styles.back}&amp;gt;返回&amp;lt;/Text&amp;gt;
    &amp;lt;Text style={styles.title}&amp;gt;这是一个标题&amp;lt;/Text&amp;gt;
    &amp;lt;Text style={styles.exit}&amp;gt;×&amp;lt;/Text&amp;gt;
&amp;lt;/View&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要把header的flexDirection设置为水平方向：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;header: &lt;/span&gt;{&lt;span&gt;
height&lt;/span&gt;:&lt;span&gt; 60,
backgroundColor: 'orange',
flexDirection: 'row',
alignItems: 'center'
&lt;/span&gt;}&lt;span&gt;,
back: &lt;/span&gt;{&lt;span&gt;
color&lt;/span&gt;:&lt;span&gt; 'white',
marginLeft: 15
&lt;/span&gt;}&lt;span&gt;,
title: &lt;/span&gt;{&lt;span&gt;
flexGrow&lt;/span&gt;:&lt;span&gt; 1,
fontSize: 20,
color: 'white',
textAlign: 'center'
&lt;/span&gt;}&lt;span&gt;,
exit: &lt;/span&gt;{&lt;span&gt;
marginRight&lt;/span&gt;:&lt;span&gt; 20,
fontSize: 20,
color: 'white'
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135748026-2147288311.png&quot;&gt;&lt;img title=&quot;clip_image011&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135748350-1851378325.png&quot; alt=&quot;clip_image011&quot; width=&quot;357&quot; height=&quot;632&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图11. header有了标题&lt;/p&gt;
&lt;p&gt;第三步，我们可以把footer三等分，模拟成菜单的样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;View style={styles.footer}&amp;gt;
    &amp;lt;Text style={styles.firstMenu}&amp;gt;添加&amp;lt;/Text&amp;gt;
    &amp;lt;Text style={styles.menu}&amp;gt;删除&amp;lt;/Text&amp;gt;
    &amp;lt;Text style={styles.menu}&amp;gt;修改&amp;lt;/Text&amp;gt;
&amp;lt;/View&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加样式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;footer: &lt;/span&gt;{&lt;span&gt;
height&lt;/span&gt;:&lt;span&gt; 60,
backgroundColor: 'green',
flexDirection: 'row',
alignItems: 'center'
&lt;/span&gt;}&lt;span&gt;,
menu: &lt;/span&gt;{&lt;span&gt;
flexGrow&lt;/span&gt;:&lt;span&gt; 1,
textAlign: 'center',
borderColor: 'white',
borderLeftWidth: 1,
color: 'white'
&lt;/span&gt;}&lt;span&gt;,
firstMenu: &lt;/span&gt;{&lt;span&gt;
flexGrow&lt;/span&gt;:&lt;span&gt; 1,
textAlign: 'center',
color: 'white'
&lt;/span&gt;}&lt;span&gt;,&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135748671-2147081782.png&quot;&gt;&lt;img title=&quot;clip_image012&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135749016-1183839573.png&quot; alt=&quot;clip_image012&quot; width=&quot;376&quot; height=&quot;665&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图12. footer三等分 模拟菜单&lt;/p&gt;
&lt;p&gt;最后，让我们在body里也填入几个带按钮的输入框。&lt;/p&gt;
&lt;p&gt;引入TextInput和Button组件，然后把它们分三组放入body中，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;View style={styles.body}&amp;gt;
    &amp;lt;View style={styles.inputRow}&amp;gt;
        &amp;lt;TextInput style={styles.textInput}&amp;gt;&amp;lt;/TextInput&amp;gt;
        &amp;lt;Button style={styles.btn} onPress={() =&amp;gt; {}} title=&quot;确定&quot;&amp;gt;&amp;lt;/Button&amp;gt;
    &amp;lt;/View&amp;gt;
    &amp;lt;View style={styles.inputRow}&amp;gt;
        &amp;lt;TextInput style={styles.textInput}&amp;gt;&amp;lt;/TextInput&amp;gt;
        &amp;lt;Button style={styles.btn} onPress={() =&amp;gt; {}} title=&quot;非常确定&quot;&amp;gt;&amp;lt;/Button&amp;gt;
    &amp;lt;/View&amp;gt;
    &amp;lt;View style={styles.inputRow}&amp;gt;
        &amp;lt;TextInput style={styles.textInput}&amp;gt;&amp;lt;/TextInput&amp;gt;
        &amp;lt;Button style={styles.btn} onPress={() =&amp;gt; {}} title=&quot;确定一定以及肯定&quot;&amp;gt;&amp;lt;/Button&amp;gt;
    &amp;lt;/View&amp;gt;
&amp;lt;/View&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加样式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;body: &lt;/span&gt;{&lt;span&gt;
flexGrow&lt;/span&gt;:&lt;span&gt; 1,
backgroundColor: 'lightblue',
&lt;/span&gt;}&lt;span&gt;,
inputRow: &lt;/span&gt;{&lt;span&gt;
flexDirection&lt;/span&gt;:&lt;span&gt; 'row',
alignItems: 'center',
marginLeft: 10,
marginRight: 10
&lt;/span&gt;}&lt;span&gt;,
textInput: &lt;/span&gt;{&lt;span&gt;
flex&lt;/span&gt;:&lt;span&gt; 1
&lt;/span&gt;}&lt;span&gt;,
btn: &lt;/span&gt;{&lt;span&gt;
minWidth&lt;/span&gt;:&lt;span&gt; 60
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135749365-49429998.png&quot;&gt;&lt;img title=&quot;clip_image013&quot; src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180702135749709-76450858.png&quot; alt=&quot;clip_image013&quot; width=&quot;379&quot; height=&quot;671&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;flex布局的一个常用实践是，部分内容固定宽高，让剩下的内容自适应。&lt;/p&gt;
&lt;p&gt;像上面这样，我们给Button有一个最小宽度，且TextInput的flexGrow为1，这样的做法可以实现，TextInput总是占满剩下的宽度，且可伸缩。&lt;/p&gt;
&lt;p&gt;看了上面的例子，是否觉得在React Native中使用Flexbox布局也挺简单呢？&lt;/p&gt;
&lt;p&gt;希望这是个不错的开始。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;移动端应用开发利器：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.grapecity.com.cn/developer/spreadjs&quot;&gt;&lt;strong&gt;SpreadJS&lt;/strong&gt;&lt;strong&gt;纯前端表格控件&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;a href=&quot;http://www.grapecity.com.cn/developer/wijmojs&quot;&gt;&lt;strong&gt;WijmoJS&lt;/strong&gt;&lt;strong&gt;纯前端控件集&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;为您的移动应用带来更加灵活的操作体验和更佳美观的外观风格，欢迎下载。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gcdn.grapecity.com.cn/forum.php?mod=viewthread&amp;amp;tid=47507&amp;amp;extra=page%3D1&quot;&gt;&lt;strong&gt;纯干货分享：&lt;/strong&gt;&lt;strong&gt;如何在 React &lt;/strong&gt;&lt;strong&gt;框架中使用SpreadJS&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 06:23:00 +0000</pubDate>
<dc:creator>葡萄城控件技术团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/powertoolsteam/p/react-native-tutorials2.html</dc:identifier>
</item>
<item>
<title>Swagger如何访问需要权限验证的Web API - 桂素伟</title>
<link>http://www.cnblogs.com/axzxs2001/p/9253495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/axzxs2001/p/9253495.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;先亮源代码：https://github.com/axzxs2001/Asp.NetCoreExperiment/tree/master/Asp.NetCoreExperiment/SwaggerDemo&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这篇博文不是对asp.net core中使用Swagger作介绍，因为社区博客作了详细说明。&lt;/p&gt;
&lt;p&gt;今天主要说一下Swagger在Ocelot网关权限验证模式下的访问，以及Swagger请求应答的数据格式。&lt;/p&gt;
&lt;p&gt;首先创建四个项目：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SwaggerOcelot：asp.net core web api类型，api网关项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SwaggerAuthorize：asp.net core web api类型，用户验证项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SwaggerAPI01：asp.net core web api类型，api 1项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SWaggerAPI02：asp.net core web api类型，api 2项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先在四个项目中添加基于Jwt的Toekn认证，参见&lt;a href=&quot;https://www.cnblogs.com/axzxs2001/p/9250588.html&quot;&gt;https://www.cnblogs.com/axzxs2001/p/9250588.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再在四个项目Nuget中引入Swashbuckle.AspNetCore，我的Demo中用的是2.5.0，再分别配置Swagger&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;SwaggerAuthorize  Starup.cs&lt;/strong&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    services.AddTokenJwtAuthorize();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    services.AddMvc()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            .SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     services.AddSwaggerGen(options =&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         options.SwaggerDoc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SwaggerAuthorize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Info { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Version = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Contact = &lt;span&gt;new&lt;/span&gt; Contact { Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;285130205@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://0.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }, Description = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorize项目&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; basePath =&lt;span&gt; PlatformServices.Default.Application.ApplicationBasePath;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; xmlPath = Path.Combine(basePath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SwaggerAuthorize.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        options.IncludeXmlComments(xmlPath);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        app.UseDeveloperExceptionPage();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    app.UseMvc()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         .UseSwagger(options =&amp;gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             options.RouteTemplate = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{documentName}/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         .UseSwaggerUI(options =&amp;gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             options.SwaggerEndpoint(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/SwaggerAuthorize/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;SwaggerAPI01，SwaggerAPI02类似，Starup.cs配置，其中让Swagger支付Token验证，就是要在这部分添加Swagger配置&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     services.AddApiJwtAuthorize((context) =&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  
&lt;span&gt; 8&lt;/span&gt;     services.AddSwaggerGen(options =&amp;gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         options.SwaggerDoc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SwaggerAPI01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Info { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;API01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Version = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Contact = &lt;span&gt;new&lt;/span&gt; Contact { Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;285130205@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;API01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://0.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }, Description = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;API01项目&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; basePath =&lt;span&gt; PlatformServices.Default.Application.ApplicationBasePath;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; xmlPath = Path.Combine(basePath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SwaggerAPI01.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        options.IncludeXmlComments(xmlPath);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是给Swagger添加验证的部分&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         options.AddSecurityDefinition(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ApiKeyScheme { In = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Description = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入带有Bearer的Token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apiKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         options.AddSecurityRequirement(&lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 Enumerable.Empty&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    services
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        .AddMvc()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        .SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;  
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    app.UseMvc()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         .UseSwagger(options =&amp;gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             options.RouteTemplate = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{documentName}/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         .UseSwaggerUI(options =&amp;gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             options.SwaggerEndpoint(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/SwaggerAPI01/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;API01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;SwaggerOcelot，Starup.cs配置&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    services.AddOcelotJwtAuthorize();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入Ocelot&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    services.AddOcelot(Configuration);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  
&lt;span&gt; 8&lt;/span&gt;     services.AddSwaggerGen(options =&amp;gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         options.SwaggerDoc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApiGateway&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Info { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;网关服务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Version = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Contact = &lt;span&gt;new&lt;/span&gt; Contact { Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;285130205@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SwaggerOcelot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://10.10.10.10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }, Description = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;网关平台&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        app.UseDeveloperExceptionPage();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; apis = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;[] {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             KeyValuePair.Create(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SwaggerAuthorize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             KeyValuePair.Create(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SwaggerAPI01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;API01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             KeyValuePair.Create(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SwaggerAPI02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;API02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;  
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    app.UseMvc()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;       .UseSwagger()
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;        .UseSwaggerUI(options =&amp;gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;       {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;            apis.Keys.ToList().ForEach(key =&amp;gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;           {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                options.SwaggerEndpoint($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/{key}/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{apis[key]} -【{key}】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;           });
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;            options.DocumentTitle = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger测试平台&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;       });
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;await&lt;/span&gt;&lt;span&gt; app.UseOcelot();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，为Swagger访问Web API项目，添加请求返回格式，默认状况下，Swagger是支持Json的，下来添加支持XML格式&lt;/p&gt;
&lt;p&gt;第一步，添加支持XML格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;services.AddMvc()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                   .AddXmlSerializerFormatters() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置支持XML格式输入输出&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;                   .AddJsonOptions(op =&amp;gt; op.SerializerSettings.ContractResolver = &lt;span&gt;new&lt;/span&gt; DefaultContractResolver())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大小写不转换&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;                   .SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步，在对应的Action添加ProducesResponseType特性，为转换作支持&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; [ProducesResponseType(&lt;span&gt;typeof&lt;/span&gt;(API01Model), &lt;span&gt;200&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;API01Model&amp;gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; API01Model { ID = &lt;span&gt;1&lt;/span&gt;, IsSure = &lt;span&gt;true&lt;/span&gt;, Price = &lt;span&gt;2.3m&lt;/span&gt;, Describe = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;先看登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/14888/201807/14888-20180702135231695-2147175612.gif&quot; alt=&quot;&quot; width=&quot;1500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再看api访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/14888/201807/14888-20180702135432085-1084703503.gif&quot; alt=&quot;&quot; width=&quot;1500&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 05:57:00 +0000</pubDate>
<dc:creator>桂素伟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/axzxs2001/p/9253495.html</dc:identifier>
</item>
<item>
<title>java多线程系列：ThreadPoolExecutor源码分析 - 云枭zd</title>
<link>http://www.cnblogs.com/fixzd/p/9253203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fixzd/p/9253203.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;这篇主要讲述ThreadPoolExecutor的源码分析，贯穿类的创建、任务的添加到线程池的关闭整个流程，让你知其然所以然。希望你可以通过本篇博文知道ThreadPoolExecutor是怎么添加任务、执行任务的，以及延伸的知识点。那么先来看看ThreadPoolExecutor的继承关系吧。&lt;/p&gt;
&lt;h2 id=&quot;继承关系&quot;&gt;继承关系&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/rainbowda/learnWay/blob/master/learnConcurrency/img/ThreadPoolExecutor%E7%B1%BB%E5%9B%BE.png?raw=true&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;executor接口&quot;&gt;Executor接口&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Executor {
    void execute(Runnable command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Executor接口只有一个方法execute,传入线程任务参数&lt;/p&gt;
&lt;h3 id=&quot;executorservice接口&quot;&gt;ExecutorService接口&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ExecutorService extends Executor {

    void shutdown();

    List&amp;lt;Runnable&amp;gt; shutdownNow();

    boolean isShutdown();

    boolean isTerminated();

    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;

    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);

    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result);

    Future&amp;lt;?&amp;gt; submit(Runnable task);

    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException;

    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    
    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException, ExecutionException;

   
    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ExecutorService接口继承Executor接口，并增加了submit、shutdown、invokeAll等等一系列方法。&lt;/p&gt;
&lt;h3 id=&quot;abstractexecutorservice抽象类&quot;&gt;AbstractExecutorService抽象类&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractExecutorService implements ExecutorService {

    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&amp;lt;T&amp;gt;(runnable, value);
    }

    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Callable&amp;lt;T&amp;gt; callable) {
        return new FutureTask&amp;lt;T&amp;gt;(callable);
    }

    public Future&amp;lt;?&amp;gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }

    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }

    private &amp;lt;T&amp;gt; T doInvokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                              boolean timed, long nanos)
        throws InterruptedException, ExecutionException, TimeoutException {...}

    public &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException, ExecutionException {... }

    public &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                           long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {...}

    public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException {...}

    public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                                         long timeout, TimeUnit unit)
        throws InterruptedException {...}

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AbstractExecutorService抽象类实现ExecutorService接口，并且提供了一些方法的默认实现，例如submit方法、invokeAny方法、invokeAll方法。&lt;/p&gt;
&lt;p&gt;像execute方法、线程池的关闭方法（shutdown、shutdownNow等等）就没有提供默认的实现。&lt;/p&gt;
&lt;h2 id=&quot;threadpoolexecutor&quot;&gt;ThreadPoolExecutor&lt;/h2&gt;
&lt;p&gt;先介绍下ThreadPoolExecutor线程池的状态吧&lt;/p&gt;
&lt;h3 id=&quot;线程池状态&quot;&gt;线程池状态&lt;/h3&gt;
&lt;p&gt;int 是4个字节，也就是32位（&lt;code&gt;注：一个字节等于8位&lt;/code&gt;）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//记录线程池状态和线程数量（总共32位，前三位表示线程池状态，后29位表示线程数量）
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
//线程数量统计位数29  Integer.SIZE=32 
private static final int COUNT_BITS = Integer.SIZE - 3;
//容量 000 11111111111111111111111111111
private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;

//运行中 111 00000000000000000000000000000
private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
//关闭 000 00000000000000000000000000000
private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
//停止 001 00000000000000000000000000000
private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
//整理 010 00000000000000000000000000000
private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
//终止 011 00000000000000000000000000000
private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;

//获取运行状态（获取前3位）
private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }
//获取线程个数（获取后29位）
private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;RUNNING：接受新任务并且处理阻塞队列里的任务&lt;/li&gt;
&lt;li&gt;SHUTDOWN：拒绝新任务但是处理阻塞队列里的任务&lt;/li&gt;
&lt;li&gt;STOP：拒绝新任务并且抛弃阻塞队列里的任务同时会中断正在处理的任务&lt;/li&gt;
&lt;li&gt;TIDYING：所有任务都执行完（包含阻塞队列里面任务）当前线程池活动线程为0，将要调用terminated方法&lt;/li&gt;
&lt;li&gt;TERMINATED：终止状态。terminated方法调用完成以后的状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;线程池状态转换&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;RUNNING -&amp;gt; SHUTDOWN
   显式调用shutdown()方法, 或者隐式调用了finalize()方法
(RUNNING or SHUTDOWN) -&amp;gt; STOP
   显式调用shutdownNow()方法
SHUTDOWN -&amp;gt; TIDYING
   当线程池和任务队列都为空的时候
STOP -&amp;gt; TIDYING
   当线程池为空的时候
TIDYING -&amp;gt; TERMINATED
   当 terminated() hook 方法执行完成时候&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;构造函数&lt;/h3&gt;
&lt;p&gt;有四个构造函数，其他三个都是调用下面代码中的这个构造函数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数介绍&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;corePoolSize&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;核心线程数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;maximumPoolSize&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;最大线程数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;keepAliveTime&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;存活时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;unit&lt;/td&gt;
&lt;td&gt;TimeUnit&lt;/td&gt;
&lt;td&gt;时间单位&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;workQueue&lt;/td&gt;
&lt;td&gt;BlockingQueue&lt;/td&gt;
&lt;td&gt;存放线程的队列&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;threadFactory&lt;/td&gt;
&lt;td&gt;ThreadFactory&lt;/td&gt;
&lt;td&gt;创建线程的工厂&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;handler&lt;/td&gt;
&lt;td&gt;RejectedExecutionHandler&lt;/td&gt;
&lt;td&gt;多余的的线程处理器（拒绝策略）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;提交任务&quot;&gt;提交任务&lt;/h3&gt;
&lt;h4 id=&quot;submit&quot;&gt;submit&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Future&amp;lt;?&amp;gt; submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, null);
    execute(ftask);
    return ftask;
}

public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result) {
    if (task == null) throw new NullPointerException();
    RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);
    execute(ftask);
    return ftask;
}

public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);
    execute(ftask);
    return ftask;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;流程步骤如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用submit方法，传入Runnable或者Callable对象&lt;/li&gt;
&lt;li&gt;判断传入的对象是否为null，为null则抛出异常，不为null继续流程&lt;/li&gt;
&lt;li&gt;将传入的对象转换为RunnableFuture对象&lt;/li&gt;
&lt;li&gt;执行execute方法，传入RunnableFuture对象&lt;/li&gt;
&lt;li&gt;返回RunnableFuture对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;流程图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/rainbowda/learnWay/blob/master/learnConcurrency/img/sibmit%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;execute&quot;&gt;execute&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void execute(Runnable command) {
   //传进来的线程为null，则抛出空指针异常
   if (command == null)
       throw new NullPointerException();
  
   //获取当前线程池的状态+线程个数变量
   int c = ctl.get();
   /**
    * 3个步骤
    */
   //1.判断当前线程池线程个数是否小于corePoolSize,小于则调用addWorker方法创建新线程运行,且传进来的Runnable当做第一个任务执行。
   //如果调用addWorker方法返回false，则直接返回
   if (workerCountOf(c) &amp;lt; corePoolSize) {
       if (addWorker(command, true))
           return;
       c = ctl.get();
   }

   //2.如果线程池处于RUNNING状态，则添加任务到阻塞队列
   if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {

       //二次检查
       int recheck = ctl.get();
       //如果当前线程池状态不是RUNNING则从队列删除任务，并执行拒绝策略
       if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
           reject(command);

       //否者如果当前线程池线程空，则添加一个线程
       else if (workerCountOf(recheck) == 0)
           addWorker(null, false);
   }
   //3.新增线程，新增失败则执行拒绝策略
   else if (!addWorker(command, false))
       reject(command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实从上面代码注释中可以看出就三个判断，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;核心线程数是否已满&lt;/li&gt;
&lt;li&gt;队列是否已满&lt;/li&gt;
&lt;li&gt;线程池是否已满&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后根据这三个条件进行不同的操作，下图是Java并发编程的艺术书中的线程池的主要处理流程，或许会比较容易理解些&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/rainbowda/learnWay/blob/master/learnConcurrency/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png?raw=true&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是整个流程的详细步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用execute方法，传入Runable对象&lt;/li&gt;
&lt;li&gt;判断传入的对象是否为null，为null则抛出异常，不为null继续流程&lt;/li&gt;
&lt;li&gt;获取当前线程池的状态和线程个数变量&lt;/li&gt;
&lt;li&gt;判断当前线程数是否小于核心线程数，是走流程5，否则走流程6&lt;/li&gt;
&lt;li&gt;添加线程数，添加成功则结束，失败则重新获取当前线程池的状态和线程个数变量,&lt;/li&gt;
&lt;li&gt;判断线程池是否处于RUNNING状态，是则添加任务到阻塞队列，否则走流程10，添加任务成功则继续流程7&lt;/li&gt;
&lt;li&gt;重新获取当前线程池的状态和线程个数变量&lt;/li&gt;
&lt;li&gt;重新检查线程池状态，不是运行状态则移除之前添加的任务，有一个false走流程9，都为true则走流程11&lt;/li&gt;
&lt;li&gt;检查线程池线程数量是否为0，否则结束流程，是调用addWorker(null, false)，然后结束&lt;/li&gt;
&lt;li&gt;调用!addWorker(command, false)，为true走流程11，false则结束&lt;/li&gt;
&lt;li&gt;调用拒绝策略reject(command)，结束&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可能看上面会有点绕，不清楚的可以看下面的流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/rainbowda/learnWay/blob/master/learnConcurrency/img/execute%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;addworker&quot;&gt;　addWorker&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 检查当前线程池状态是否是SHUTDOWN、STOP、TIDYING或者TERMINATED
        // 且！（当前状态为SHUTDOWN、且传入的任务为null，且队列不为null）
        // 条件都成立则返回false
        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
            ! (rs == SHUTDOWN &amp;amp;&amp;amp;
               firstTask == null &amp;amp;&amp;amp;
               ! workQueue.isEmpty()))
            return false;
        //循环
        for (;;) {
            int wc = workerCountOf(c);
            //如果当前的线程数量超过最大容量或者大于（根据传入的core决定是核心线程数还是最大线程数）核心线程数 || 最大线程数，则返回false
            if (wc &amp;gt;= CAPACITY ||
                wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
                return false;
            //CAS增加c，成功则跳出retry
            if (compareAndIncrementWorkerCount(c))
                break retry;
            //CAS失败执行下面方法，查看当前线程数是否变化，变化则继续retry循环，没变化则继续内部循环
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
        }
    }
    //CAS成功
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        //新建一个线程
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            //加锁
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                
                //重新检查线程池状态
                //避免ThreadFactory退出故障或者在锁获取前线程池被关闭
                int rs = runStateOf(ctl.get());

                if (rs &amp;lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                    if (t.isAlive()) // 先检查线程是否是可启动的
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s &amp;gt; largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            //判断worker是否添加成功，成功则启动线程，然后将workerStarted设置为true
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        //判断线程有没有启动成功，没有则调用addWorkerFailed方法
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以将addWorker分为两部分，第一部分增加线程池个数，第二部分是将任务添加到workder里面并执行。&lt;/p&gt;
&lt;p&gt;第一部分主要是两个循环，外层循环主要是判断线程池状态，下面描述来自&lt;a href=&quot;http://ifeve.com/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0threadpoolexecutor%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/&quot;&gt;Java中线程池ThreadPoolExecutor原理探究&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;pre&gt;
&lt;code&gt;rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
              ! (rs == SHUTDOWN &amp;amp;&amp;amp;
                  firstTask == null &amp;amp;&amp;amp;
                  ! workQueue.isEmpty())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;展开！运算后等价于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
               (rs != SHUTDOWN ||
             firstTask != null ||
             workQueue.isEmpty())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说下面几种情况下会返回false：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前线程池状态为STOP，TIDYING，TERMINATED&lt;/li&gt;
&lt;li&gt;当前线程池状态为SHUTDOWN并且已经有了第一个任务&lt;/li&gt;
&lt;li&gt;当前线程池状态为SHUTDOWN并且任务队列为空&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;内层循环作用是使用cas增加线程个数，如果线程个数超限则返回false，否者进行cas，cas成功则退出双循环，否者cas失败了，要看当前线程池的状态是否变化了，如果变了，则重新进入外层循环重新获取线程池状态，否者进入内层循环继续进行cas尝试。&lt;/p&gt;
&lt;p&gt;到了第二部分说明CAS成功了，也就是说线程个数加一了，但是现在任务还没开始执行，这里使用全局的独占锁来控制workers里面添加任务，其实也可以使用并发安全的set，但是性能没有独占锁好（这个从注释中知道的）。这里需要注意的是要在获取锁后重新检查线程池的状态，这是因为其他线程可可能在本方法获取锁前改变了线程池的状态，比如调用了shutdown方法。添加成功则启动任务执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以这里也将流程图分为两部分来描述&lt;/p&gt;
&lt;p&gt;第一部分流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/rainbowda/learnWay/blob/master/learnConcurrency/img/addWorkers%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.png?raw=true&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二部分流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/rainbowda/learnWay/blob/master/learnConcurrency/img/addWorkers%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.png?raw=true&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;worker对象&quot;&gt;Worker对象&lt;/h4&gt;
&lt;p&gt;Worker是定义在ThreadPoolExecutor中的finnal类，其中继承了AbstractQueuedSynchronizer类和实现Runnable接口，其中的run方法如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void run() {
    runWorker(this);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程启动时调用了runWorker方法，关于类的其他方面这里就不在叙述。&lt;/p&gt;
&lt;h4 id=&quot;runworker&quot;&gt;runWorker&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock();
    boolean completedAbruptly = true;
    try {
        //循环获取任务
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // 当线程池是处于STOP状态或者TIDYING、TERMINATED状态时，设置当前线程处于中断状态
            // 如果不是，当前线程就处于RUNNING或者SHUTDOWN状态，确保当前线程不处于中断状态
            // 重新检查当前线程池的状态是否大于等于STOP状态
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;amp;&amp;amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                //提供给继承类使用做一些统计之类的事情，在线程运行前调用
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    //提供给继承类使用做一些统计之类的事情，在线程运行之后调用
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                //统计当前worker完成了多少个任务
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        //整个线程结束时调用，线程退出操作。统计整个线程池完成的任务个数之类的工作
        processWorkerExit(w, completedAbruptly);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;gettask&quot;&gt;getTask&lt;/h4&gt;
&lt;p&gt;getTask方法的主要作用其实从方法名就可以看出来了，就是获取任务&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?
    //循环
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        //线程线程池状态和队列是否为空
        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }
        //线程数量
        int wc = workerCountOf(c);

        
        boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;

        //（当前线程数是否大于最大线程数或者）
        //且（线程数大于1或者任务队列为空）
        //这里有个问题(timed &amp;amp;&amp;amp; timedOut)timedOut = false，好像(timed &amp;amp;&amp;amp; timedOut)一直都是false吧
        if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))
            &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            //获取任务
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关闭线程池&quot;&gt;关闭线程池&lt;/h3&gt;
&lt;h4 id=&quot;shutdown&quot;&gt;shutdown&lt;/h4&gt;
&lt;p&gt;当调用shutdown方法时，线程池将不会再接收新的任务，然后将先前放在队列中的任务执行完成。&lt;/p&gt;
&lt;p&gt;下面是shutdown方法的源码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(SHUTDOWN);
        interruptIdleWorkers();
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;shutdownnow&quot;&gt;shutdownNow&lt;/h4&gt;
&lt;p&gt;立即停止所有的执行任务，并将队列中的任务返回&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;Runnable&amp;gt; shutdownNow() {
    List&amp;lt;Runnable&amp;gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(STOP);
        interruptWorkers();
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;shutdown和shutdownnow区别&quot;&gt;shutdown和shutdownNow区别&lt;/h4&gt;
&lt;p&gt;shutdown和shutdownNow这两个方法的作用都是关闭线程池，流程大致相同，只有几个步骤不同，如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;加锁&lt;/li&gt;
&lt;li&gt;检查关闭权限&lt;/li&gt;
&lt;li&gt;CAS改变线程池状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置中断标志(线程池不在接收任务，队列任务会完成)/中断当前执行的线程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用onShutdown方法（给子类提供的方法）/获取队列中的任务&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;解锁&lt;/li&gt;
&lt;li&gt;尝试将线程池状态变成终止状态TERMINATED&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结束/返回队列中的任务&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;线程池可以给我们多线程编码上提供极大便利，就好像数据库连接池一样，减少了线程的开销，提供了线程的复用。而且ThreadPoolExecutor也提供了一些未实现的方法，供我们来使用，像beforeExecute、afterExecute等方法，我们可以通过这些方法来对线程进行进一步的管理和统计。&lt;/p&gt;
&lt;p&gt;在使用线程池上好需要注意，提交的线程任务可以分为&lt;code&gt;CPU 密集型任务&lt;/code&gt;和&lt;code&gt;IO 密集型任务&lt;/code&gt;，然后根据任务的不同进行分配不同的线程数量。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU密集型任务：
&lt;ul&gt;&lt;li&gt;应当分配较少的线程，比如 &lt;code&gt;CPU&lt;/code&gt;个数相当的大小&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;IO 密集型任务：
&lt;ul&gt;&lt;li&gt;由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;混合型任务：
&lt;ul&gt;&lt;li&gt;可以将其拆分为 &lt;code&gt;CPU&lt;/code&gt; 密集型任务以及 &lt;code&gt;IO&lt;/code&gt; 密集型任务，这样来分别配置。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了，这篇博文到这里就结束了，文中可能会有些纰漏，欢迎留言指正。&lt;/p&gt;
&lt;p&gt;如果本文对你有所帮助，给个star呗，谢谢。本文GitHub地址：&lt;a href=&quot;https://github.com/rainbowda/learnWay/blob/master/learnConcurrency/src/main/java/com/learnConcurrency/executor/customThreadPool/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md&quot;&gt;点这里点这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://ifeve.com/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0threadpoolexecutor%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/&quot;&gt;并发编程网-Java中线程池ThreadPoolExecutor原理探究&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java并发编程的艺术&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 02 Jul 2018 05:16:00 +0000</pubDate>
<dc:creator>云枭zd</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fixzd/p/9253203.html</dc:identifier>
</item>
<item>
<title>PHP7.1中使用openssl替换mcrypt - 给个理由先</title>
<link>http://www.cnblogs.com/z1298703836/p/9252612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/z1298703836/p/9252612.html</guid>
<description>&lt;p&gt;在php开发中，使用mcrypt相关函数可以很方便地进行AES加、解密操作，但是PHP7.1中&lt;a href=&quot;http://www.php.net/manual/zh/book.mcrypt.php&quot;&gt;废弃了mcrypt扩展&lt;/a&gt;，所以必需寻找另一种实现。在&lt;a href=&quot;http://php.net/manual/en/migration71.deprecated.php&quot;&gt;迁移手册&lt;/a&gt;中已经指出了用openssl代替mcrypt，但未给出具体示例。网上有很多示例，可以替换大部分场景，但对于其中细节却并未说明。同样，简单地使用网上示例在某种代码场景下有可能导致代码替换前后的兼容问题，以下则来谈谈具体代码及原因。&lt;/p&gt;
&lt;p&gt;首先我们直接给出替换的代码，再从代码中分析问题。&lt;em&gt;（本文中分析的算法是AES-128-CBC）&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;替换示例&quot;&gt;替换示例&lt;/h2&gt;
&lt;p&gt;示例会展示两种mcrypt的使用方式，主要在于&lt;strong&gt;填充&lt;/strong&gt;不同（在下文会解释&lt;strong&gt;填充&lt;/strong&gt;）。在整个加、解密过程中，完整程度高一点代码则会自主实现填充、移除填充，简单一点代码会直接忽略填充，但两种方式均可正常运行；在实际开发中（7.1之前版本），建议加上填充。请看如下具体示例：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;mcrypt未使用填充
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;mcrypt加密:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  $key = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'; 
  $iv = 'aaaaaaaaaaaaaaaa';
  $data = 'dataString';

  $cipher = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');
  mcrypt_generic_init($cipher, $key, $iv);
  $cipherText256 = mcrypt_generic($cipher, $data);
  mcrypt_generic_deinit($cipher);

  return bin2hex($cipherText256);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;相同功能的openssl加密代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  $key = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'; 
  $iv = 'aaaaaaaaaaaaaaaa';
  $data = 'dataString';

  $data = $data . str_repeat(&quot;\x00&quot;, 16 - (strlen($data) % 16)); // 双引号可以解析asc-ii码\x00

  return bin2hex(openssl_encrypt($data, &quot;AES-256-CBC&quot;, $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING, $iv));&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mcrypt使用填充&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;mcrypt加密:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  $key = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'; 
  $iv = 'aaaaaaaaaaaaaaaa';
  $data = 'dataString';

  // 填充（移除填充反着移除即可）
  $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);

  $pad = $block - (strlen($data) % $block);
  if ($pad &amp;lt;= $block) {
      $char = chr($pad);
      $data .= str_repeat($char, $pad);
  }

  $cipher = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');
  mcrypt_generic_init($cipher, $key, $iv);
  $cipherText256 = mcrypt_generic($cipher, $data);
  mcrypt_generic_deinit($cipher);

  return bin2hex($cipherText256);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;相同功能的openssl加密代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  $key = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'; 
  $iv = 'aaaaaaaaaaaaaaaa';
  $data = 'dataString';

  return bin2hex(openssl_encrypt($data, 'AES-256-CBC', $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING, $iv));&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上示例均可成功运行，其中第一个示例（未使用填充，但在openssl中进行了填充）和第二个示例（使用填充，在openssl中未使用填充）在替换前后输出相同，并无兼容问题。大家可以根据代码不同的填充方式来选择不同的替换方案，但其中有三个细节需要说明&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为什么要有填充？&lt;/li&gt;
&lt;li&gt;用openssl替换后算法的名称为何不同？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来会则会具体分析 &lt;strong&gt;填充&lt;/strong&gt; 、&lt;strong&gt;算法&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;填充&quot;&gt;填充&lt;/h2&gt;
&lt;p&gt;为什么有填充则要从加密的算法说起。因为在&lt;a href=&quot;https://blog.csdn.net/qq_28205153/article/details/55798628&quot;&gt;AES-128-CBC&lt;/a&gt;算法中，会把要加密的字符串以每16个byte的长度进行分段，逐步计算，由此导致不足16byte的段则会进行填充。所以给出的示例中会有两种：一种是使用默认的填充，另一种是自主填充。在与openssl的替换中，如何选择填充方案，则需要对mcrypt与openssl针对默认与自主填充有所了解。&lt;/p&gt;
&lt;ul readability=&quot;17.344502036283&quot;&gt;&lt;li readability=&quot;11.913875598086&quot;&gt;
&lt;p&gt;mcrypt默认填充&lt;/p&gt;
&lt;p&gt;在php的源码中，可以看出默认会以&lt;code&gt;\x00&lt;/code&gt;进行填充，事实上，并非是以&lt;code&gt;\x00&lt;/code&gt;进行填充，从&lt;a href=&quot;https://github.com/php/php-src/blob/php-7.0.30/ext/mcrypt/mcrypt.c&quot;&gt;源码&lt;/a&gt;中可以发现，首先申请了一个16位的空字符串，所以初始化时每位字节均为&lt;code&gt;\x00&lt;/code&gt;, 实际上可以说其中并没有填充，只是它本来就是&lt;code&gt;\x00&lt;/code&gt; ，使用默认填充得到的加密字符串会是如下形式：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726033/201807/726033-20180702113006925-1005323751.png&quot; alt=&quot;mcrypt默认填充&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以解密时则要移除多余的&lt;code&gt;\x00&lt;/code&gt;。当然也可以懒一点，不移除&lt;code&gt;\x00&lt;/code&gt;。 因为在php中字符串&quot;string\x00&quot;与字符串&quot;string&quot;除了长度不一样外，其他表现均一致，所以看起来并无区别，如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   // 尾部包含若干个`\x00` 均可功输出true
   if (&quot;string\x00&quot; == &quot;string&quot;) { // 用双引号可解析\x00
       echo true;
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;\x00&lt;/code&gt;填充后的示例：(请注意字符串的长度，由此可见用&lt;code&gt;\x00&lt;/code&gt;填充会影响长度)&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726033/201807/726033-20180702113448385-1703661251.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;mcrypt自主填充&lt;/p&gt;
&lt;p&gt;填充算法需以如下算法进行：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;加入填充&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  /**
   * 填充算法
   * @param string $source
   * @return string
   */
  function addPKCS7Padding($source)
  {
      $source = trim($source);
      $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);

      $pad = $block - (strlen($source) % $block);
      if ($pad &amp;lt;= $block) {
          $char = chr($pad);
          $source .= str_repeat($char, $pad);
      }
      return $source;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加入填充后字符串实际上如下形式：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726033/201807/726033-20180702113036556-838868545.png&quot; alt=&quot;标准填充&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;移除填充&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  /**
   * 移去填充算法
   * @param string $source
   * @return string
   */
  function stripPKSC7Padding($source)
  {
      $source = trim($source);
      $char = substr($source, -1);
      $num = ord($char);
      if ($num == 62) return $source;
      $source = substr($source, 0, -$num);
      return $source;
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;openssl默认填充&lt;/p&gt;
&lt;p&gt;其默认方式与标准的mcrypt的自主填充方式一致，所以在第二个示例中，对于使用了如上的填充算法后， 可直接使用openssl_encrypt替换，不会产生兼容问题。填充后的加密字符串如下形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726033/201807/726033-20180702113036556-838868545.png&quot; alt=&quot;标准填充&quot;/&gt;&lt;/p&gt;
&lt;em&gt;需注意的是在&lt;code&gt;openssl_encrypt&lt;/code&gt;与&lt;code&gt;openssl_decrypt&lt;/code&gt;中内置了填充与移除填充，所以直接使用即可，除非需自主实现填充，否则不需要考虑填充&lt;/em&gt;&lt;/li&gt;
&lt;li readability=&quot;16.557163531114&quot;&gt;
&lt;p&gt;openssl自主填充&lt;/p&gt;
&lt;p&gt;openssl_encrypt提供了option参数以支持自主填充，但在查阅php源码中openssl的&lt;a href=&quot;https://github.com/php/php-src/blob/master/ext/openssl/tests/openssl_decrypt_basic.phpt#L22&quot;&gt;测试用例代码&lt;/a&gt;才找到正确用法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   // if we want to manage our own padding
  $padded_data = $data . str_repeat(' ', 16 - (strlen($data) % 16));
  $encrypted = openssl_encrypt($padded_data, $method,     $password, OPENSSL_RAW_DATA|OPENSSL_ZERO_PADDING, $iv);
  $output = openssl_decrypt($encrypted, $method, $password, OPENSSL_RAW_DATA|OPENSSL_ZERO_PADDING, $iv);
  var_dump(rtrim($output));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（备注：如上，&lt;code&gt;OPENSSL_ZERO_PADDING&lt;/code&gt; 并非是为0填充的意思）&lt;br/&gt;由此，我们就可以解释，在第一个示例中openssl_encrypt之前加入了自主点充&lt;code&gt;\x00&lt;/code&gt;的代码原因了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从以上的加、解密针对填充逻辑不同，针对上文中的示例可以很好地解释：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;示例1：&lt;br/&gt;mcrypt加密时未使用填充，故以&lt;code&gt;\x00&lt;/code&gt;进行了填充，所以在替换成openssl，需要自主实现&lt;code&gt;\x00&lt;/code&gt;填充。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;示例2：&lt;br/&gt;mcrypt加密时使用了标准的填充，同时openssl的填充方式也为标准填充，故直接使用即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分析到这，可以发现，无论是何种填充策略都需注意&lt;strong&gt;在加密时加入填充，在解密时则必须要移除填充&lt;/strong&gt;。至此，上文中示例中的填充相关则分析完成了，接下来我们再看看如何选择替换后的算法。&lt;/p&gt;
&lt;h2 id=&quot;选择算法&quot;&gt;选择算法&lt;/h2&gt;
&lt;p&gt;在以上的示例中，有一个问题在于，mcrypt中的AES-128-CBC算法，在openssl中怎么替换成了AES_256?&lt;br/&gt;关于这一点， 我也未找到合理的解释，查看源码一时半会也没找到原因（能力有限~），但通过以下资料，还是完成了功能&lt;/p&gt;
&lt;p&gt;若是有同学找到原因，欢迎给我留言，谢谢。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;对于使用mcrypt AES 进行加密密的部分，若是在替换过程中问题， 可以从算法替换或填充这两方面着手考虑下。同时还是一必须满足的条件是根据不同的填充方式选择, 替换最重要的就要考虑兼容问题，保证&lt;strong&gt;替换后不发生任何改变&lt;/strong&gt;。 虽然只是只是有细微的差别----尾部几个字符串的不同，但若是在多平台中同时进行修改也是一件麻烦事，但变动越少风险越小。&lt;/p&gt;
&lt;p&gt;本文只是针对AES算法进行了简单说明，对于其他算法是否适用还有待研究。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;PHP 7.1.x 中废弃的特性: &lt;a href=&quot;http://www.php.net/manual/zh/migration71.deprecated.php&quot; class=&quot;uri&quot;&gt;http://www.php.net/manual/zh/migration71.deprecated.php&lt;/a&gt;&lt;br/&gt;mcrypt扩展废弃:&lt;a href=&quot;http://www.php.net/manual/zh/book.mcrypt.php&quot; class=&quot;uri&quot;&gt;http://www.php.net/manual/zh/book.mcrypt.php&lt;/a&gt;&lt;br/&gt;AES算法:&lt;a href=&quot;https://blog.csdn.net/qq_28205153/article/details/55798628&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qq_28205153/article/details/55798628&lt;/a&gt;&lt;br/&gt;mcrypt源码：&lt;a href=&quot;https://github.com/php/php-src/blob/php-7.0.30/ext/mcrypt/mcrypt.c&quot; class=&quot;uri&quot;&gt;https://github.com/php/php-src/blob/php-7.0.30/ext/mcrypt/mcrypt.c&lt;/a&gt;&lt;br/&gt;openssl扩展原码:&lt;a href=&quot;https://github.com/php/php-src/blob/master/ext/openssl/openssl.c&quot; class=&quot;uri&quot;&gt;https://github.com/php/php-src/blob/master/ext/openssl/openssl.c&lt;/a&gt;&lt;br/&gt;openssl 解密 mcrypt AES 数据不兼容问题：&lt;a href=&quot;https://www.v2ex.com/t/370493&quot; class=&quot;uri&quot;&gt;https://www.v2ex.com/t/370493&lt;/a&gt;&lt;br/&gt;Convert mcrypt_generic to openssl_encrypt Ask Question:&lt;a href=&quot;https://stackoverflow.com/questions/48800725/convert-mcrypt-generic-to-openssl-encrypt&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/48800725/convert-mcrypt-generic-to-openssl-encrypt&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作者: 给个理由先&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;本文地址: https://www.cnblogs.com/z1298703836/p/9252612.html&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 02 Jul 2018 03:46:00 +0000</pubDate>
<dc:creator>给个理由先</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/z1298703836/p/9252612.html</dc:identifier>
</item>
<item>
<title>[Abp 源码分析]五、系统设置 - myzony</title>
<link>http://www.cnblogs.com/myzony/p/9253122.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myzony/p/9253122.html</guid>
<description>&lt;h2 id=&quot;简要介绍&quot;&gt;0.简要介绍&lt;/h2&gt;
&lt;p&gt;Abp 本身有两种设置，一种就是 &lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/myzony/p/9230565.html&quot;&gt;上一篇文章&lt;/a&gt;&lt;/strong&gt; 所介绍的模块配置 Configuration，该配置主要用于一些复杂的数据类型设置，不仅仅是字符串，也有可能是一些 C# 运行时的一些变量。另外一种则是本篇文章所讲的 Setting，Setting 主要用于配置一些简单的参数，比如 SMTP 地址，数据库连接字符串等一些基本的配置类型可以使用 Setting 来进行处理。&lt;/p&gt;
&lt;h2 id=&quot;代码分析&quot;&gt;1.代码分析&lt;/h2&gt;
&lt;h3 id=&quot;启动流程&quot;&gt;1.1 启动流程&lt;/h3&gt;
&lt;p&gt;我们先来看一下设置是怎样被加入到 Abp 框架当中，并且是如何来使用它的。&lt;/p&gt;
&lt;p&gt;在 Abp 框架内部开发人员可以通过 &lt;code&gt;ISettingsConfiguration&lt;/code&gt; 的 Providers 属性来添加自己实现的 &lt;code&gt;SettingProvider&lt;/code&gt; ，而 &lt;code&gt;ISettingsConfiguration&lt;/code&gt; 的初始化是在上一篇文章所写的 &lt;code&gt;AbpBootstrapper.Initialize()&lt;/code&gt; 里面进行初始化的。&lt;/p&gt;
&lt;p&gt;开发人员通过继承 &lt;code&gt;SettingProvider&lt;/code&gt; 来提供这些设置信息，并且在模块的 &lt;code&gt;PreInitialize()&lt;/code&gt; 方法当中通过 &lt;code&gt;Configuration&lt;/code&gt; 来添加书写好的配置提供者。&lt;/p&gt;
&lt;p&gt;在模块进行初始化之后(也就是在 &lt;code&gt;PostInitiailze()&lt;/code&gt; 方法内部)，所有开发人员定义的 &lt;code&gt;SettingProvider&lt;/code&gt; 通过 &lt;code&gt;ISettingDefinitionManager&lt;/code&gt; 的 &lt;code&gt;Initialize()&lt;/code&gt; 方法存储到一个 &lt;code&gt;Dictionary&lt;/code&gt; 里面。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public sealed class AbpKernelModule : AbpModule
{
    // 其他代码
    public override void PostInitialize()
    {
        // 其他代码
        IocManager.Resolve&amp;lt;SettingDefinitionManager&amp;gt;().Initialize();
        // 其他代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Initialize()&lt;/code&gt; 方法内部：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private readonly IDictionary&amp;lt;string, SettingDefinition&amp;gt; _settings;

public void Initialize()
{
    var context = new SettingDefinitionProviderContext(this);

    foreach (var providerType in _settingsConfiguration.Providers)
    {
        using (var provider = CreateProvider(providerType))
        {
            foreach (var settings in provider.Object.GetSettingDefinitions(context))
            {
                _settings[settings.Name] = settings;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对外则是通过 &lt;code&gt;ISettingManager&lt;/code&gt; 来进行管理的。&lt;/p&gt;
&lt;p&gt;所有的设置项是通过 &lt;code&gt;ServiceProvider&lt;/code&gt; 来提供的。&lt;/p&gt;
&lt;p&gt;设置的持久化配置则是通过 &lt;code&gt;ISettingStore&lt;/code&gt; 来实现的，开发者可以通过替换 &lt;code&gt;ISettingStore&lt;/code&gt; 的实现达到持久化到数据库或者是其他位置。&lt;/p&gt;
&lt;h3 id=&quot;典型用法&quot;&gt;1.2 典型用法&lt;/h3&gt;
&lt;h4 id=&quot;设置提供者定义&quot;&gt;1.2.1 设置提供者定义&lt;/h4&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;internal class EmailSettingProvider : SettingProvider
{
    public override IEnumerable&amp;lt;SettingDefinition&amp;gt; GetSettingDefinitions(SettingDefinitionProviderContext context)
    {
        return new[]
               {
                   new SettingDefinition(EmailSettingNames.Smtp.Host, &quot;127.0.0.1&quot;, L(&quot;SmtpHost&quot;), scopes: SettingScopes.Application | SettingScopes.Tenant),
                   new SettingDefinition(EmailSettingNames.Smtp.Port, &quot;25&quot;, L(&quot;SmtpPort&quot;), scopes: SettingScopes.Application | SettingScopes.Tenant),
                   new SettingDefinition(EmailSettingNames.Smtp.UserName, &quot;&quot;, L(&quot;Username&quot;), scopes: SettingScopes.Application | SettingScopes.Tenant),
                   new SettingDefinition(EmailSettingNames.Smtp.Password, &quot;&quot;, L(&quot;Password&quot;), scopes: SettingScopes.Application | SettingScopes.Tenant),
                   new SettingDefinition(EmailSettingNames.Smtp.Domain, &quot;&quot;, L(&quot;DomainName&quot;), scopes: SettingScopes.Application | SettingScopes.Tenant),
                   new SettingDefinition(EmailSettingNames.Smtp.EnableSsl, &quot;false&quot;, L(&quot;UseSSL&quot;), scopes: SettingScopes.Application | SettingScopes.Tenant),
                   new SettingDefinition(EmailSettingNames.Smtp.UseDefaultCredentials, &quot;true&quot;, L(&quot;UseDefaultCredentials&quot;), scopes: SettingScopes.Application | SettingScopes.Tenant),
                   new SettingDefinition(EmailSettingNames.DefaultFromAddress, &quot;&quot;, L(&quot;DefaultFromSenderEmailAddress&quot;), scopes: SettingScopes.Application | SettingScopes.Tenant),
                   new SettingDefinition(EmailSettingNames.DefaultFromDisplayName, &quot;&quot;, L(&quot;DefaultFromSenderDisplayName&quot;), scopes: SettingScopes.Application | SettingScopes.Tenant)
               };
    }

    private static LocalizableString L(string name)
    {
        return new LocalizableString(name, AbpConsts.LocalizationSourceName);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;注入设置提供者&quot;&gt;1.2.2 注入设置提供者&lt;/h4&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public sealed class AbpKernelModule : AbpModule
{
    public override void PreInitialize()
    {
        // 其他代码
        Configuration.Settings.Providers.Add&amp;lt;EmailSettingProvider&amp;gt;();
        // 其他代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注入之后，那么相应的模块如何得到已经注入的配置项呢？&lt;/p&gt;
&lt;p&gt;我们拿一个最直观的例子来展示一下，这里我们来到 Abp 项目的 Email 模块，来看看它是如何使用的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class DefaultMailKitSmtpBuilder : IMailKitSmtpBuilder, ITransientDependency
{
    private readonly ISmtpEmailSenderConfiguration _smtpEmailSenderConfiguration;

    public DefaultMailKitSmtpBuilder(ISmtpEmailSenderConfiguration smtpEmailSenderConfiguration)
    {
        _smtpEmailSenderConfiguration = smtpEmailSenderConfiguration;
    }

    public virtual SmtpClient Build()
    {
        var client = new SmtpClient();

        try
        {
            ConfigureClient(client);
            return client;
        }
        catch
        {
            client.Dispose();
            throw;
        }
    }

    protected virtual void ConfigureClient(SmtpClient client)
    {
        client.Connect(
            _smtpEmailSenderConfiguration.Host,
            _smtpEmailSenderConfiguration.Port,
            _smtpEmailSenderConfiguration.EnableSsl
        );

        if (_smtpEmailSenderConfiguration.UseDefaultCredentials)
        {
            return;
        }

        client.Authenticate(
            _smtpEmailSenderConfiguration.UserName,
            _smtpEmailSenderConfiguration.Password
        );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到以上代码通过 &lt;code&gt;ISmtpEmailSenderConfiguration&lt;/code&gt; 来拿到 SMTP 对应的主机名与端口号，那这与我们的 &lt;code&gt;ISettingManager&lt;/code&gt; 又有何关系呢？&lt;/p&gt;
&lt;p&gt;其实我们转到 &lt;code&gt;ISmtpEmailSenderConfiguration&lt;/code&gt; 的实现 &lt;code&gt;SmtpEmailSenderConfiguration&lt;/code&gt; 就清楚了。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class SmtpEmailSenderConfiguration : EmailSenderConfiguration, ISmtpEmailSenderConfiguration, ITransientDependency
{
    /// &amp;lt;summary&amp;gt;
    /// SMTP Host name/IP.
    /// &amp;lt;/summary&amp;gt;
    public virtual string Host
    {
        get { return GetNotEmptySettingValue(EmailSettingNames.Smtp.Host); }
    }

    /// &amp;lt;summary&amp;gt;
    /// SMTP Port.
    /// &amp;lt;/summary&amp;gt;
    public virtual int Port
    {
        get { return SettingManager.GetSettingValue&amp;lt;int&amp;gt;(EmailSettingNames.Smtp.Port); }
    }

    /// &amp;lt;summary&amp;gt;
    /// User name to login to SMTP server.
    /// &amp;lt;/summary&amp;gt;
    public virtual string UserName
    {
        get { return GetNotEmptySettingValue(EmailSettingNames.Smtp.UserName); }
    }

    /// &amp;lt;summary&amp;gt;
    /// Password to login to SMTP server.
    /// &amp;lt;/summary&amp;gt;
    public virtual string Password
    {
        get { return GetNotEmptySettingValue(EmailSettingNames.Smtp.Password); }
    }

    /// &amp;lt;summary&amp;gt;
    /// Domain name to login to SMTP server.
    /// &amp;lt;/summary&amp;gt;
    public virtual string Domain
    {
        get { return SettingManager.GetSettingValue(EmailSettingNames.Smtp.Domain); }
    }

    /// &amp;lt;summary&amp;gt;
    /// Is SSL enabled?
    /// &amp;lt;/summary&amp;gt;
    public virtual bool EnableSsl
    {
        get { return SettingManager.GetSettingValue&amp;lt;bool&amp;gt;(EmailSettingNames.Smtp.EnableSsl); }
    }

    /// &amp;lt;summary&amp;gt;
    /// Use default credentials?
    /// &amp;lt;/summary&amp;gt;
    public virtual bool UseDefaultCredentials
    {
        get { return SettingManager.GetSettingValue&amp;lt;bool&amp;gt;(EmailSettingNames.Smtp.UseDefaultCredentials); }
    }

    /// &amp;lt;summary&amp;gt;
    /// Creates a new &amp;lt;see cref=&quot;SmtpEmailSenderConfiguration&quot;/&amp;gt;.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;settingManager&quot;&amp;gt;Setting manager&amp;lt;/param&amp;gt;
    public SmtpEmailSenderConfiguration(ISettingManager settingManager)
        : base(settingManager)
    {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里我们可以看到这些配置项其实是通过一个名字叫做 &lt;code&gt;GetNotEmptySettingValue()&lt;/code&gt; 的方法来得到的，该方法定义在 &lt;code&gt;SmtpEmailSenderConfiguration&lt;/code&gt; 的基类 &lt;code&gt;EmailSenderConfiguration&lt;/code&gt; 当中。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public abstract class EmailSenderConfiguration : IEmailSenderConfiguration
{
    // 其他代码，已经省略

    /// &amp;lt;summary&amp;gt;
    /// Creates a new &amp;lt;see cref=&quot;EmailSenderConfiguration&quot;/&amp;gt;.
    /// &amp;lt;/summary&amp;gt;
    protected EmailSenderConfiguration(ISettingManager settingManager)
    {
        SettingManager = settingManager;
    }

    /// &amp;lt;summary&amp;gt;
    /// Gets a setting value by checking. Throws &amp;lt;see cref=&quot;AbpException&quot;/&amp;gt; if it's null or empty.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;name&quot;&amp;gt;Name of the setting&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;Value of the setting&amp;lt;/returns&amp;gt;
    protected string GetNotEmptySettingValue(string name)
    {
        var value = SettingManager.GetSettingValue(name);

        if (value.IsNullOrEmpty())
        {
            throw new AbpException($&quot;Setting value for '{name}' is null or empty!&quot;);
        }

        return value;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总而言之，如果你想要获取已经添加好的设置项，直接注入 &lt;code&gt;ISettingManager&lt;/code&gt; 通过其 &lt;code&gt;GetSettingValue()&lt;/code&gt; 就可以拿到这些设置项。&lt;/p&gt;
&lt;h3 id=&quot;具体代码分析&quot;&gt;1.3 具体代码分析&lt;/h3&gt;
&lt;p&gt;Abp 系统设置相关的最核心的部分就是 &lt;code&gt;ISettingManager&lt;/code&gt;、&lt;code&gt;ISettingDefinitionManager&lt;/code&gt;、&lt;code&gt;ISettingStore&lt;/code&gt;，&lt;code&gt;SettingProvider&lt;/code&gt;、&lt;code&gt;SettingDefinition&lt;/code&gt; 下面就这几个类进行一些细致的解析。&lt;/p&gt;
&lt;h4 id=&quot;settingdefinition&quot;&gt;1.3.1 SettingDefinition&lt;/h4&gt;
&lt;p&gt;在 Abp 当中，一个设置项就是一个 &lt;code&gt;SettingDefinition&lt;/code&gt;，每个 &lt;code&gt;SettingDefinition&lt;/code&gt; 的 Name 与 Value 是必填的，其中 Scopes 字段对应一个 &lt;code&gt;SettingScopes&lt;/code&gt; 枚举，该属性用于确定这个设置项的使用应用范围。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class SettingDefinition
{
    /// &amp;lt;summary&amp;gt;
    /// Unique name of the setting.
    /// &amp;lt;/summary&amp;gt;
    public string Name { get; private set; }

    /// &amp;lt;summary&amp;gt;
    /// Display name of the setting.
    /// This can be used to show setting to the user.
    /// &amp;lt;/summary&amp;gt;
    public ILocalizableString DisplayName { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// A brief description for this setting.
    /// &amp;lt;/summary&amp;gt;
    public ILocalizableString Description { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// Scopes of this setting.
    /// Default value: &amp;lt;see cref=&quot;SettingScopes.Application&quot;/&amp;gt;.
    /// &amp;lt;/summary&amp;gt;
    public SettingScopes Scopes { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// Is this setting inherited from parent scopes.
    /// Default: True.
    /// &amp;lt;/summary&amp;gt;
    public bool IsInherited { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// Gets/sets group for this setting.
    /// &amp;lt;/summary&amp;gt;
    public SettingDefinitionGroup Group { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// Default value of the setting.
    /// &amp;lt;/summary&amp;gt;
    public string DefaultValue { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// Can clients see this setting and it's value.
    /// It maybe dangerous for some settings to be visible to clients (such as email server password).
    /// Default: false.
    /// &amp;lt;/summary&amp;gt;
    [Obsolete(&quot;Use ClientVisibilityProvider instead.&quot;)]
    public bool IsVisibleToClients { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// Client visibility definition for the setting.
    /// &amp;lt;/summary&amp;gt;
    public ISettingClientVisibilityProvider ClientVisibilityProvider { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// Can be used to store a custom object related to this setting.
    /// &amp;lt;/summary&amp;gt;
    public object CustomData { get; set; }
    
    public SettingDefinition(
            string name,
            string defaultValue,
            ILocalizableString displayName = null,
            SettingDefinitionGroup group = null,
            ILocalizableString description = null,
            SettingScopes scopes = SettingScopes.Application,
            bool isVisibleToClients = false,
            bool isInherited = true,
            object customData = null,
            ISettingClientVisibilityProvider clientVisibilityProvider = null)
    {
        if (string.IsNullOrEmpty(name))
        {
            throw new ArgumentNullException(nameof(name));
        }

        Name = name;
        DefaultValue = defaultValue;
        DisplayName = displayName;
        Group = @group;
        Description = description;
        Scopes = scopes;
        IsVisibleToClients = isVisibleToClients;
        IsInherited = isInherited;
        CustomData = customData;

        ClientVisibilityProvider = new HiddenSettingClientVisibilityProvider();

        if (isVisibleToClients)
        {
            ClientVisibilityProvider = new VisibleSettingClientVisibilityProvider();
        }
        else if (clientVisibilityProvider != null)
        {
            ClientVisibilityProvider = clientVisibilityProvider;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;isettingmanager&quot;&gt;1.3.2 ISettingManager&lt;/h4&gt;
&lt;p&gt;首先我们看一下 &lt;code&gt;ISettingManager&lt;/code&gt; 的默认实现 &lt;code&gt;SettingManager&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class SettingManager : ISettingManager, ISingletonDependency
{
    public const string ApplicationSettingsCacheKey = &quot;ApplicationSettings&quot;;

    /// &amp;lt;summary&amp;gt;
    /// Reference to the current Session.
    /// &amp;lt;/summary&amp;gt;
    public IAbpSession AbpSession { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// Reference to the setting store.
    /// &amp;lt;/summary&amp;gt;
    public ISettingStore SettingStore { get; set; }

    private readonly ISettingDefinitionManager _settingDefinitionManager;
    private readonly ITypedCache&amp;lt;string, Dictionary&amp;lt;string, SettingInfo&amp;gt;&amp;gt; _applicationSettingCache;
    private readonly ITypedCache&amp;lt;int, Dictionary&amp;lt;string, SettingInfo&amp;gt;&amp;gt; _tenantSettingCache;
    private readonly ITypedCache&amp;lt;string, Dictionary&amp;lt;string, SettingInfo&amp;gt;&amp;gt; _userSettingCache;

    /// &amp;lt;inheritdoc/&amp;gt;
    public SettingManager(ISettingDefinitionManager settingDefinitionManager, ICacheManager cacheManager)
    {
        _settingDefinitionManager = settingDefinitionManager;

        AbpSession = NullAbpSession.Instance;
        SettingStore = DefaultConfigSettingStore.Instance;

        _applicationSettingCache = cacheManager.GetApplicationSettingsCache();
        _tenantSettingCache = cacheManager.GetTenantSettingsCache();
        _userSettingCache = cacheManager.GetUserSettingsCache();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在这里面，他注入了 &lt;code&gt;ISetingStore&lt;/code&gt; 与 &lt;code&gt;ISettingDefinitionManager&lt;/code&gt; ，并且使用了三个 &lt;code&gt;ITypedCache&lt;/code&gt; 来为这些设置进行一个缓存。&lt;/p&gt;
&lt;p&gt;下面这个 &lt;code&gt;GetSettingValueAsync()&lt;/code&gt; 方法则是获取一个指定名称的设置值。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public Task&amp;lt;string&amp;gt; GetSettingValueAsync(string name)
{
    return GetSettingValueInternalAsync(name, AbpSession.TenantId, AbpSession.UserId);
}

private async Task&amp;lt;string&amp;gt; GetSettingValueInternalAsync(string name, int? tenantId = null, long? userId = null, bool fallbackToDefault = true)
{
    // 获取指定 Name 的 SettingDefine
    var settingDefinition = _settingDefinitionManager.GetSettingDefinition(name);

    // 判断该设置项的使用范围是否为 User
    if (settingDefinition.Scopes.HasFlag(SettingScopes.User) &amp;amp;&amp;amp; userId.HasValue)
    {
        var settingValue = await GetSettingValueForUserOrNullAsync(new UserIdentifier(tenantId, userId.Value), name);
        if (settingValue != null)
        {
            return settingValue.Value;
        }

        if (!fallbackToDefault)
        {
            return null;
        }

        if (!settingDefinition.IsInherited)
        {
            return settingDefinition.DefaultValue;
        }
    }

    // 判断该设置项的使用范围是否为 Tenant
    if (settingDefinition.Scopes.HasFlag(SettingScopes.Tenant) &amp;amp;&amp;amp; tenantId.HasValue)
    {
        var settingValue = await GetSettingValueForTenantOrNullAsync(tenantId.Value, name);
        if (settingValue != null)
        {
            return settingValue.Value;
        }

        if (!fallbackToDefault)
        {
            return null;
        }

        if (!settingDefinition.IsInherited)
        {
            return settingDefinition.DefaultValue;
        }
    }

    // 判断该设置项的使用范围是否为 Application
    if (settingDefinition.Scopes.HasFlag(SettingScopes.Application))
    {
        var settingValue = await GetSettingValueForApplicationOrNullAsync(name);
        if (settingValue != null)
        {
            return settingValue.Value;
        }

        if (!fallbackToDefault)
        {
            return null;
        }
    }

    // 如果都没有定义，则返回默认的设置值
    return settingDefinition.DefaultValue;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里又为每个判断内部封装了一个方法，这里以 &lt;code&gt;GetSettingValueForApplicationOrNullAsync()&lt;/code&gt; 为例，转到其定义：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private async Task&amp;lt;SettingInfo&amp;gt; GetSettingValueForApplicationOrNullAsync(string name)
{
    return (await GetApplicationSettingsAsync()).GetOrDefault(name);
}

private async Task&amp;lt;Dictionary&amp;lt;string, SettingInfo&amp;gt;&amp;gt; GetApplicationSettingsAsync()
{
    // 从缓存当中获取设置信息，如果不存在，则执行其工厂方法
    return await _applicationSettingCache.GetAsync(ApplicationSettingsCacheKey, async () =&amp;gt;
    {
        var dictionary = new Dictionary&amp;lt;string, SettingInfo&amp;gt;();
        
        // 从 ISettingStore 当中获取对应的 Value 值
        var settingValues = await SettingStore.GetAllListAsync(null, null);
        foreach (var settingValue in settingValues)
        {
            dictionary[settingValue.Name] = settingValue;
        }

        return dictionary;
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;isettingdefinitionmanager&quot;&gt;1.3.3 ISettingDefinitionManager&lt;/h4&gt;
&lt;p&gt;这个管理器作用最开始已经说明了，就是单纯的获取到用户注册到 Providers 里面的 &lt;code&gt;SettingDefinition&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;settingprovider&quot;&gt;1.3.4 SettingProvider&lt;/h4&gt;
&lt;p&gt;SettingProvider 用于开发人员配置自己的配置项，所有的设置提供者只需要继承自本类，实现其 &lt;code&gt;GetSettingDefinitions&lt;/code&gt; 方法即可。&lt;/p&gt;
&lt;h4 id=&quot;isettingstore&quot;&gt;1.3.5 ISettingStore&lt;/h4&gt;
&lt;p&gt;本类用于设置项值的存储，其本身并不做设置项的新增，仅仅是相同的名称的设置项，优先从 &lt;code&gt;ISettingStore&lt;/code&gt; 当中进行获取，如果不存在的话，才会使用开发人员在 &lt;code&gt;SettingProvider&lt;/code&gt; 定义的值。&lt;/p&gt;
&lt;p&gt;Abp 项目默认的 &lt;code&gt;DefaultConfigSettingStore&lt;/code&gt; 实现并不会进行任何实质性的操作，只有 Zero.Common 项目当中重新实现的 &lt;code&gt;SettingStore&lt;/code&gt; 类才是针对这些设置的值进行了持久化操作。&lt;/p&gt;
&lt;h2 id=&quot;扩展abp.mailkit-模块配置&quot;&gt;2.扩展：Abp.MailKit 模块配置&lt;/h2&gt;
&lt;p&gt;如果要在 .NetCore 环境下面使用邮件发送的话，首先推荐的就是 MailKit 这个库，而 Abp 针对 MailKit 库封装了一个新的模块，叫做 Abp.MailKit ，只需要进行简单的设置就可以发送邮件了。&lt;/p&gt;
&lt;p&gt;在需要使用的模块上面添加：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[DependsOn(typeof(AbpMailKitModule))]
public class TestModule : AbpModule
{
    // 其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后需要自己定义一个 &lt;code&gt;SettingProvider&lt;/code&gt; 并且在里面做好 SMTP 发件服务器配置：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class DevEmailSettings : SettingProvider
{
    public override IEnumerable&amp;lt;SettingDefinition&amp;gt; GetSettingDefinitions(SettingDefinitionProviderContext context)
    {
            return new[]
            {
                // smtp 服务器地址
                new SettingDefiniion(EmailSettingNames.Smtp.Host, &quot;smtpserver&quot;),
                // smtp 用户名称
                new SettingDefinition(EmailSettingNames.Smtp.UserName, &quot;yourusername&quot;),
                // smtp 服务端口
                new SettingDefinition(EmailSettingNames.Smtp.Port, &quot;25&quot;),
                // smtp 用户密码
                new SettingDefinition(EmailSettingNames.Smtp.Password, &quot;yourpassword&quot;),
                // 发件人邮箱地址
                new SettingDefinition(EmailSettingNames.DefaultFromAddress, &quot;youremailaddress&quot;),
                // 是否启用默认验证
                new SettingDefinition(EmailSettingNames.Smtp.UseDefaultCredentials,&quot;false&quot;)
        };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在之前的模块预加载当中添加这个 Provider 到全局设置当中：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[DependsOn(typeof(AbpMailKitModule))]
public class TestModule : AbpModule
{
    public override void PreInitialize()
    {
        Configuration.Settings.Providers.Add&amp;lt;DevEmailSettings&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送邮件十分简单，直接在需要使用的地方注入 &lt;code&gt;IEmailSender&lt;/code&gt; 调用其 &lt;code&gt;Send&lt;/code&gt; 或者 &lt;code&gt;SendAsync&lt;/code&gt; 方法即可，下面是一个例子：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class TestApplicationService : ApplicationService
{
    private readonly IEmailSender _emailSender;
    
    public TestApplicationService(IEmailSender emailSender)
    {
        _emailSender = emailSender;
    }
    
    public Task TestMethod()
    {
        _emailSender.Send(&quot;xxxxxx@qq.com&quot;,&quot;无主题&quot;,&quot;测试正文&quot;,false);
        return Task.FromResult(0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203160/201807/1203160-20180702114408204-1558769123.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 03:45:00 +0000</pubDate>
<dc:creator>myzony</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myzony/p/9253122.html</dc:identifier>
</item>
<item>
<title>windows下使用jenkins持续集成.net项目 - SeeThrough</title>
<link>http://www.cnblogs.com/seethrough/p/9252804.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seethrough/p/9252804.html</guid>
<description>&lt;blockquote readability=&quot;4.2553191489362&quot;&gt;
&lt;p&gt;windows下使用 &lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/seethrough/p/9252804.html#jump_10&quot;&gt;jenkins&lt;/a&gt;&lt;/strong&gt; 持续集成.net项目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;随着微服务的兴起，原先一个庞大的项目，被切分一个个功能独立的微服务，虽然使得业务系统的扩展性和维护性得到提升，但是也加大了维护人员的工作量。有的系统由成百上千个微服务组成，如果每次有修改，都要手工去发布的话，那将是一件可怕的事。&lt;br/&gt;而 &lt;strong&gt;jenkins&lt;/strong&gt; 的到来，让运维人员看到了福音。&lt;/p&gt;
&lt;h3 id=&quot;什么是jenkins&quot;&gt;什么是Jenkins？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702105739317-1269147890.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通俗的讲，&lt;strong&gt;jenkins&lt;/strong&gt;就是用来简化，代码托管服务器到部署服务器的过程。举个例子，如果我有一个页面视图，显示 ASP.NET，现在接到需求要改成 Hello Word，你会怎么做？&lt;/p&gt;
&lt;h4 id=&quot;步骤&quot;&gt;步骤&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702113449058-1673073517.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上的步骤还是比较理想化的，中途可能会遇到这几种情况&lt;/p&gt;
&lt;p&gt;1.获取代码编译不通过，需要通知程序员&lt;br/&gt;2.运维人员任务繁忙，没有测试项目是否正常运行&lt;/p&gt;
&lt;p&gt;而这一些有了&lt;strong&gt;Jenkins&lt;/strong&gt;之后，就十分方便了，运维人员只要第一次配置好，后面需要发布时，只需发送一个指令，或者手动构建，就可以完成代码的迁出编译部署的过程，并且可以方便看到编译日志，最终如果失败掉还可以发送邮件通知相关人员。&lt;/p&gt;
&lt;p&gt;接下来我简单的介绍下windows下如何部署Jenkins！&lt;/p&gt;
&lt;h3 id=&quot;安装jenkins&quot;&gt;安装Jenkins&lt;/h3&gt;
&lt;p&gt;前往 &lt;a href=&quot;https://jenkins.io/download/&quot;&gt;Jenkins官网&lt;/a&gt; 下载，这里选择的是windows版本，下载完成后，跟着向导模式一步步安装，这里就不阐述细节了。如果没有修改配置，默认的端口为8080，也就说，你打开浏览器输入 &lt;a href=&quot;http://localhost:8080/&quot; class=&quot;uri&quot;&gt;http://localhost:8080/&lt;/a&gt; 就可以进入后台&lt;/p&gt;
&lt;h3 id=&quot;安装jenkins插件&quot;&gt;安装Jenkins插件&lt;/h3&gt;
&lt;p&gt;打开Jenkins后台，点击 系统管理&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702105910831-58947515.png&quot;/&gt;&lt;br/&gt;找到插件管理&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702110013511-919523680.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为我们是部署.net项目，所以这里选择 &lt;strong&gt;MSBuild Plugin&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702110158239-330612221.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置msbuild-plugin&quot;&gt;配置MSBuild Plugin&lt;/h3&gt;
&lt;p&gt;点击 &lt;strong&gt;系统管理-全局工具设置&lt;/strong&gt; 找到&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702110416127-523361053.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，这里根据你项目的版本去选择 &lt;strong&gt;MSBuild&lt;/strong&gt;，如果你的项目是&lt;strong&gt;.net framwork 4.5&lt;/strong&gt;，那么就选择跟我一样的路径。&lt;/p&gt;
&lt;h3 id=&quot;创建任务&quot;&gt;创建任务&lt;/h3&gt;
&lt;p&gt;1.点击系统左边的菜单，新建一个任务&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702110823996-354761948.png&quot;/&gt;&lt;br/&gt;2.输入项目名称后，选择自由风格的软件项目&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702110918457-215739123.png&quot;/&gt;&lt;br/&gt;3.输入项目的地址，因为我用的是github，所以直接在这里写入项目URL&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702111108879-1197498844.png&quot;/&gt;&lt;br/&gt;4.展开 高级 的源码管理中&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702111217795-1250564622.png&quot;/&gt;&lt;br/&gt;在这里面输入github相关用户信息，注意这里可以根据你代码托管软件来设置，这边也支持SVN&lt;br/&gt;5.接下来，构建触发器，所谓的触发器就是指，你用什么方式触发编译部署。可以选择定时，也可以选择 发送指令，这里我选择发送指令 9527&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702111427462-917788345.png&quot;/&gt;&lt;br/&gt;6.构建前的操作，有时候，你需要在编译前，删除旧的代码，看具体需求而定&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702111500256-1434051101.png&quot;/&gt;&lt;br/&gt;7.构建设置&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702111550266-1433967899.png&quot;/&gt;&lt;br/&gt;这里设置相关的编译参数，我这边主要是指定了 MSBuild版本，和需要编译的 sln，你也可以指定项目编译，还有指定了 编译发布路径&lt;br/&gt;8.增加构建步骤&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702112106748-342283318.png&quot;/&gt;&lt;br/&gt;因为我这边是做测试，所以都在同一台机子，我增加的步骤是直接用命令行拷贝到IIS项目所在文件夹，如果是远程机子，你可以使用&lt;strong&gt;FTP&lt;/strong&gt;插件来上传&lt;br/&gt;9.增加构建后步骤&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702112239173-459878892.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如你想要构建后，删除代码，等等。&lt;/p&gt;
&lt;p&gt;10.保存&lt;/p&gt;
&lt;h3 id=&quot;触发编译&quot;&gt;触发编译&lt;/h3&gt;
&lt;p&gt;因为我使用 发送指令来触发编译&lt;br/&gt;所以我在浏览器中 输入 &lt;a href=&quot;http://localhost:8080/me/my-views/view/all/job/JekinsTest/token=9527&quot; class=&quot;uri&quot;&gt;http://localhost:8080/me/my-views/view/all/job/JekinsTest/token=9527&lt;/a&gt; 就可以触发编译&lt;/p&gt;
&lt;h3 id=&quot;查看编译日志&quot;&gt;查看编译日志&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702112855508-275744225.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/583382/201807/583382-20180702112543816-1305910551.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;整体上，我这里只完成了最简单的Jenkins部署，但是万变不离其宗，只要熟悉了它工作的原理，就可以根据具体的项目，做个性化的设置，理论上，它支持各种复杂的项目部署，所以你不用担心它能不能满足你的需求。&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 03:27:00 +0000</pubDate>
<dc:creator>SeeThrough</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/seethrough/p/9252804.html</dc:identifier>
</item>
<item>
<title>.Net Core 自动化部署：使用jenkins部署到linux docker容器运行 - Arthur·Wang</title>
<link>http://www.cnblogs.com/YahuiWang/p/jenkins-dotnet-core-publish2linux-docker.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YahuiWang/p/jenkins-dotnet-core-publish2linux-docker.html</guid>
<description>&lt;blockquote readability=&quot;5.3577981651376&quot;&gt;
&lt;p&gt;上次我们说到&lt;a href=&quot;https://www.cnblogs.com/YahuiWang/p/jenkins-docker-dotnet-core-publish.html&quot;&gt;.Net Core 自动化部署：使用docker版jenkins部署dotnetcore应用&lt;/a&gt;,这次我们使用jenkins发布我们的.NET Core站点到docker容器中运行，为后面的的docker集群化部署做准备&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为linux下ssh连接使用更方便快捷，所以这里建议使用ssh发布插件来完成发布操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在插件中心搜索&lt;code&gt;Publish Over SSH&lt;/code&gt;关键字可以找到这个插件，安装它然后重启jenkins&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;进入 系统管理-&amp;gt;系统设置-&amp;gt;&lt;code&gt;Publish over SSH&lt;/code&gt; 根据您的发布目标服务器的情况配置ip地址 key 和&lt;code&gt;Remote Directory&lt;/code&gt;&lt;br/&gt;注意：&lt;code&gt;Remote Directory&lt;/code&gt;既是您发布任务指定目录的根目录&lt;code&gt;/&lt;/code&gt;,发布任务的远程目录是以&lt;code&gt;Remote Directory&lt;/code&gt;为基础的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我已经做了个自动启动和重新构建的docker-compose项目&lt;br/&gt;项目地址是：&lt;a href=&quot;https://github.com/YahuiWong/docker-netcore&quot; class=&quot;uri&quot;&gt;https://github.com/YahuiWong/docker-netcore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;git clone https://github.com/YahuiWong/docker-netcore
cd docker-netcore&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;release publish your project to ./publish dir&lt;/li&gt;
&lt;li&gt;run &lt;code&gt;docker-compose down&lt;/code&gt; remove earlier image &amp;amp; container&lt;/li&gt;
&lt;li&gt;run &lt;code&gt;docker-compose build --no-cache&lt;/code&gt; build with no-cache&lt;/li&gt;
&lt;li&gt;docker-compose up -d&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote readability=&quot;4.7699115044248&quot;&gt;
&lt;p&gt;代码发布的代码获取和生成部分我们这次就不详细说明了，可以到&lt;a href=&quot;https://www.cnblogs.com/YahuiWang/p/jenkins-docker-dotnet-core-publish.html&quot;&gt;.Net Core 自动化部署：使用docker版jenkins部署dotnetcore应用&lt;/a&gt;查看，这里着重讲解&lt;code&gt;Publish over SSH&lt;/code&gt;在发布任务的配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;在&lt;code&gt;添加构建后操作&lt;/code&gt;新增选项 &lt;code&gt;Send build artifacts over SSH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SSH Server Name&lt;/code&gt;选择自己配置好的ssh服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Source files&lt;/code&gt;和&lt;code&gt;Remove prefix&lt;/code&gt;和之前的配置一样，这里不细说&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Remote directory&lt;/code&gt;选择ssh服务器 &lt;code&gt;/docker-netcore/publish&lt;/code&gt; 路径&lt;/li&gt;
&lt;li&gt;Exec command 填写&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;cd /data/tests/docker-netcore # 进入您的docker-compose.yml位置
docker-compose down
docker-compose build --no-cache
docker-compose up -d&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 02 Jul 2018 03:26:00 +0000</pubDate>
<dc:creator>Arthur&amp;#183;Wang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YahuiWang/p/jenkins-dotnet-core-publish2linux-docker.html</dc:identifier>
</item>
</channel>
</rss>