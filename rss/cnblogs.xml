<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>从运维的角度分析使用阿里云数据库RDS的必要性--你不应该在阿里云上使用自建的MySQL/SQL Server/Oracle/PostgreSQL数据库 - chinaglwo</title>
<link>http://www.cnblogs.com/chinaglwo/p/7844711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chinaglwo/p/7844711.html</guid>
<description>&lt;h3&gt;开宗明义，你不应该在阿里云上使用自建的MySQL or SQL Server数据库，对了，还有Oracle or PostgreSQL数据库。&lt;/h3&gt;
&lt;p&gt;云数据库 RDS（Relational Database Service）是一种稳定可靠、可弹性伸缩的在线数据库服务。基于飞天分布式系统和全SSD盘高性能存储，支持MySQL、SQL Server、PostgreSQL和PPAS（高度兼容Oracle）引擎，默认部署主备架构且提供了容灾、备份、恢复、监控、迁移等方面的全套解决方案。&lt;/p&gt;
&lt;p&gt;当然，并不是指所有用户，这还是有条件的，包括但不限于以下两点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;你的网站或项目发展到一定阶段，需要将数据库独立出来，不再和网站程序或应用程序放在一台ECS上；&lt;/li&gt;
&lt;li&gt;即便你有一个对数据库很了解的开发人员或运维人员，也不应该自建数据库，因为让开发专注做程序开发，让运维专注做运维自动化，这才是能让生产最大化的决策。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;还有个别情况是：你也许有一个小型的数据库技术团队，比如2、3个人，也不应该自建数据库，因为这通常需要维护整个基础架构，比如说网络负载均衡（管理交换机）、数据可靠性（磁盘raid）、中间件（读写分离）、故障自动转移（主备切换）、主从架构（数据同步）等等。这些技能不见得DBA都会，比如网络设备，是不是又要增加一个网络工程师的岗位呢，对于成本的增加，你有没有考虑进去？&lt;/p&gt;
&lt;p&gt;然而，对于阿里云数据库RDS来说，以上这些需求本身已经具备了，所以数据库DBA更应该着重于跟业务相关的优化上面。因为这才是iaas（基础架构即服务）的精髓。&lt;/p&gt;
&lt;p&gt;但是，我们还是要分析清楚，为什么要使用RDS，它好在哪些具体的地方？&lt;/p&gt;
&lt;h3&gt;先插播个小福利：&lt;a href=&quot;https://www.lastupdate.net/go/lastupdate&quot;&gt;&lt;span&gt;一键领取阿里云幸运券，领券后再下单购买阿里云产品，享受官网全部优惠，还可参加幸运大抽奖~&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;阿里云数据库RDS包括了4种：MySQL/SQL Server/Oracle/PostgreSQL，我们先说其中之一的RDS for MySQL吧。&lt;/p&gt;
&lt;p&gt;RDS for MySQL目前包括了三个版本：5.7、5.6、5.5：&lt;/p&gt;
&lt;blockquote readability=&quot;7.9420793512887&quot;&gt;
&lt;ol&gt;&lt;li&gt;首先推荐的是5.6，因为5.6与5.5相比，性能优化了很多，阿里的数据库团队，向mysql官方提供了很多的patch，是国内最大的技术贡献者。而且5.6推出一段时间了，非常成熟稳定，5.6和5.5的兼容性也非常好，笔者曾经将多个不同使用场景的5.5的数据库迁移到5.6，都没发生任何兼容性问题。如果不是有啥特殊原因一定要5.5，就建议选择5.6啦。另外，5.6在主从同步方面也是采用半同步方式，而不是5.5的异步，这就更加保证的数据可靠性。&lt;br/&gt;&lt;img src=&quot;https://imgs.lastupdate.net/wp-content/uploads/2017/11/1-3.jpg?imageslim|imageView2/2/w/900/interlace/1&quot; alt=&quot;《从运维的角度分析使用阿里云数据库RDS的必要性--你不应该在阿里云上使用自建的MySQL/SQL Server/Oracle/PostgreSQL数据库》&quot;/&gt;&lt;/li&gt;
&lt;li&gt;5.6还有一个非常重要的功能，就是独写分离，目前只有5.6支持，笔者所在的项目已经使用这个功能几个月了，非常的好用，非常的让人省心，我想这个可能是互联网电商项目梦寐以求的功能吧。要知道，你自建读写分离，一般是使用开源的中间件作为代理层，这就要求你非常熟悉这个中间件的用法，包括设置权重、阈值、健康检查等等，这就大大增加了学习成本，不然的话你不担心出了故障无法解决吗？另外，使用开源中间件，在数据到达数据库之前需要经历多个组件的语句解析和转发，对响应延迟有较大的影响。而 RDS 读写分离在已有的高安全链路中直接内置，没有任何额外的组件来消耗时间，能够有效降低延迟，提升处理速度。&lt;br/&gt;&lt;img src=&quot;https://imgs.lastupdate.net/wp-content/uploads/2017/11/2-3.png?imageslim|imageView2/2/w/900/interlace/1&quot; alt=&quot;《从运维的角度分析使用阿里云数据库RDS的必要性--你不应该在阿里云上使用自建的MySQL/SQL Server/Oracle/PostgreSQL数据库》&quot;/&gt;&lt;/li&gt;
&lt;li&gt;不管5.6还是5.5，都提供高可用版本，笔者强烈推荐互联网电商、游戏等项目使用它，这个版本是采用一主一备的高可用架构，同时提供本地ssd存储，有故障会自动切换主备实例。就光这一点，自建数据库就达不到，可以说绝大多数公司的主数据库都是单个mysql实例，遇到机器故障就只能停机，做不到自动切换。这并不是说这些公司不想使用高可用架构，而是真的有门槛，你以为照着网上的教程搭建好两个master，用心跳软件做好监控就行了吗？错了，后期的维护往往要比最初的环境搭建要难多了，这不仅仅是mysql本身的高可用，还必须结合自身业务情况才行。笔者以前所在的大型电商公司，就拥有数据库团队，曾经想做这样的高可用架构，但一直不敢正式上线运行，原因就是现实中会遇到各种各样的问题，始终没有完美的办法解决。&lt;/li&gt;
&lt;li&gt;5.6同时还提供金融版：采用一主两备的架构，通过日志“多副本同步复制”，确保数据的强一致性，所以特别适合金融、证券、保险行业的核心数据库。而且，高可用版和金融版之间，是可以切换的哦，赞不赞？&lt;/li&gt;
&lt;li&gt;有人说RDS的费用比自建MySQL所用的ECS服务器，相同配置贵了不少。没错，确实是贵一些，要知道上面刚说了，是一主一备两个实例，你自建如果用两台ECS实现，费用更贵，而且还不考虑是否好用的因素，明白了吗？&lt;/li&gt;
&lt;li&gt;提供全面的监控诊断：线程内存、SQL资源消耗等监控，帮助用户快速进行问题诊断。这个也是重点呀，自建的数据库可以说基本没有这些监控，只能记录慢查询，再采用第三方工具分析日志，再进一步，使用一些开源工具平台，比如zabbix，自带了一些mysql基础监控，如果要粒度更进一步，可能需要安装其他插件，比如有一个比较有名的zabbix for mysql插件叫做fpmmm的，笔者也一直在使用。然而即便如此，笔者仍然认为比不上RDS提供的监控项，要知道，现实中分析一个故障，是需要多种手段结合起来一起辅助分析的，并不是提供的监控图越多，就一定能找出来。&lt;br/&gt;&lt;img src=&quot;https://imgs.lastupdate.net/wp-content/uploads/2017/11/3-1.jpg?imageslim|imageView2/2/w/900/interlace/1&quot; alt=&quot;《从运维的角度分析使用阿里云数据库RDS的必要性--你不应该在阿里云上使用自建的MySQL/SQL Server/Oracle/PostgreSQL数据库》&quot;/&gt;&lt;/li&gt;
&lt;li&gt;备份：包括数据备份和日志备份，RDS都提供了，而且对于备份而言，更重要的是恢复和检查数据完整性。笔者想问问各位，有多少人是没做备份的，又有多少人是做了备份，但是没有定时去恢复的，也就是说，你做的备份正确吗，你验证过吗，你会定期去验证吗？恐怕由于人力物力的问题，这些都不会去做的。RDS提供了很重要的恢复方法，有三种：叫只读实例、克隆实例、灾备实例。从字面上应该可以理解它们的作用了，详细使用方法还是去看RDS文档吧。&lt;/li&gt;
&lt;li&gt;CloudDBA是监控和管理RDS实例性能及运行状况的服务，在RDS控制台的实例管理页面，目前只适用于MySQL类型的实例。针对SQL语句的性能、CPU使用率、IOPS使用率、内存使用率、磁盘空间使用率、连接数、锁信息、热点表等，CloudDBA提供了智能的诊断及优化功能，能最大限度发现数据库存在的或潜在的健康问题。CloudDBA的诊断基于单个实例，该诊断会提供问题详情及相应的解决方案，可为您管理实例运行状况带来极大的便利。目前只支持5.6和5.5。&lt;/li&gt;
&lt;li&gt;现在说5.7，是最近推出不久的，它的关键在于是单机版。与标准的主备双机高可用版相比，单机基础版只提供一个数据库节点，通过底层数据存储层来保证数据多副本可靠性。数据库节点的减少，大幅降低了CPU和内存资源的开销，从而降低整体投入成本。因为对于个人、中小企业来说，能够接受短暂的故障停机（当然如果维护得好 ，这基本也是不存在的）。它的价格，与自建数据库相当了，但是仍然提供了前面几点的各种功能，所以强烈推荐中小企业使用的。&lt;/li&gt;
&lt;li&gt;安全性，也是很多人关注的。云数据库RDS提供了多样化的安全加固功能来保障用户数据的安全，其中包括但不限于：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;* 网络：IP 白名单、VPC 网络、SSL（安全套接层协议）、SQL 防火墙&lt;br/&gt;* 存储：TDE（透明数据加密）、自动备份&lt;br/&gt;* 容灾：同城容灾（多可用区实例）、异地容灾（两地多中心）&lt;br/&gt;&lt;img src=&quot;https://imgs.lastupdate.net/wp-content/uploads/2017/11/2-1.jpg?imageslim|imageView2/2/w/900/interlace/1&quot; alt=&quot;《从运维的角度分析使用阿里云数据库RDS的必要性--你不应该在阿里云上使用自建的MySQL/SQL Server/Oracle/PostgreSQL数据库》&quot;/&gt;&lt;br/&gt;11. 数据库管理：笔者用过命令行、navicat、phpMyAdmin等工具进行日常的数据库维护，我猜想大部分人也是如此。RDS使用“数据管理DMS”：提供关系型数据库和NoSQL的统一管理。它源自阿里数据库服务平台iDB，为数万研发人员提供数据库研发支撑，已在线上运行8年。您可以使用数据管理DMS轻松构建企业独有的数据库DevOps，促进数据库研发自助化，提升研发效率，同时保证员工数据库访问安全及数据库高性能。默认是免费版的，已经可以满足大多数人的使用需求了，如果还觉得不够，可以购买高级版，提供更强大的功能，具体可以查阅产品文档。笔者想说的是：你只需要有一个浏览器，就可以管理自己的数据库。&lt;br/&gt;12. 有人说，说了这么多，到底性能如何呀，我建议你还是自己体验吧，附上一张图：&lt;br/&gt;&lt;img src=&quot;https://imgs.lastupdate.net/wp-content/uploads/2017/11/4.jpg?imageslim|imageView2/2/w/900/interlace/1&quot; alt=&quot;《从运维的角度分析使用阿里云数据库RDS的必要性--你不应该在阿里云上使用自建的MySQL/SQL Server/Oracle/PostgreSQL数据库》&quot;/&gt;&lt;br/&gt;13. 如何从自建库迁移到RDS，请看文档吧：&lt;a href=&quot;https://help.aliyun.com/document_detail/26210.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://help.aliyun.com/document_detail/26210.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;现在，你同意我的观点吗：RDS是不是比自建数据库要好呢？&lt;/h3&gt;
&lt;h3&gt;购买地址：&lt;a href=&quot;https://s.click.taobao.com/uWHB4Yw&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;阿里云数据库RDS for MySQL&lt;/a&gt;，记得领前面提到的幸运券哦，购买时长就和你的ECS服务器一致就行了，年付8.5折，两年付7折，三年付5折。&lt;/h3&gt;
&lt;p&gt;更新：有的朋友让推荐一下购买配置，这个其实还是跟自身的项目有关。笔者曾经短时间跟过一个电商项目，每天都有几场到十几场秒杀，规模上来之后，ECS服务器的配置是8核16G的，当时把数据库从本机拆出来，购买了RDS，选的配置5.6高可用版，硬件是4核16G，存储是100G，使用起来网站还是很流畅的，这也得益于前端防刷做得比较好吧。当然，除了ECS和RDS，也还使用了诸如OSS、CDN、WAF等产品，结合nginx过滤和程序防刷机制等等。&lt;br/&gt;&lt;img src=&quot;https://imgs.lastupdate.net/wp-content/uploads/2017/11/1-4.png?imageslim|imageView2/2/w/900/interlace/1&quot; alt=&quot;《从运维的角度分析使用阿里云数据库RDS的必要性--你不应该在阿里云上使用自建的MySQL/SQL Server/Oracle/PostgreSQL数据库》&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 07:48:00 +0000</pubDate>
<dc:creator>chinaglwo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chinaglwo/p/7844711.html</dc:identifier>
</item>
<item>
<title>最近实现的一个分离文章内容功能，挺有意思，分享一下 - 指尖下的幽灵</title>
<link>http://www.cnblogs.com/linguanh/p/7844628.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linguanh/p/7844628.html</guid>
<description>&lt;p&gt;这个功能的描述是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;把一本符合&lt;code&gt;markdown语法写的书&lt;/code&gt;里面的所有大章节里面内容的&lt;code&gt;每个大标题和该标题对应下的内容做分离，&lt;/code&gt;一 一对应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般会出现这种问题的场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;笔试算法题&lt;/li&gt;
&lt;li&gt;产品需求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子，有一段内容是如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode markdown&quot;&gt;
&lt;code class=&quot;sourceCode markdown&quot;&gt;&lt;span class=&quot;fu&quot;&gt;### 糖尿病的症状 （这是 markdown 的第三级标题）&lt;/span&gt;
初期的症状体现在.....&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分离后要求达到:&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;title   ===&amp;gt; 糖尿病的症状
content ===&amp;gt; 初期的症状体现在...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对我而言，这个功能的目的是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们把一本书分割成上述的样子，数据存入数据库。供搜索使用。搜索方式，以 title 或 content 做模糊匹配，命中即返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;相信看到这里的读者都能清楚知道上面谈的是什么，但愿我的文字能通俗易懂，文字多了，我也记不住，累赘。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;实现思路：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;正则匹配 ------------- ①&lt;/li&gt;
&lt;li&gt;逐行处理 ------------- ②&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先谈谈&lt;code&gt;正则匹配&lt;/code&gt;下的处理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点
&lt;ul&gt;&lt;li&gt;写好匹配式，其它交给 API，方便&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;&lt;li&gt;难度大，上述问题的内容掺杂情况有很多种&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后是&lt;code&gt;逐行处理&lt;/code&gt;处理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点
&lt;ul&gt;&lt;li&gt;逻辑可控，可丰富自定义处理，例如过滤和二重分割，属于完整的字符串操作&lt;/li&gt;
&lt;li&gt;代码清晰，速度快一些&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;&lt;li&gt;消耗内存多一些&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两种方法的对比:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;效率，平分&lt;/li&gt;
&lt;li&gt;可读性，② &amp;gt; ①&lt;/li&gt;
&lt;li&gt;整体内存占比，② &amp;gt; ①&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子对比：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode markdown&quot;&gt;
&lt;code class=&quot;sourceCode markdown&quot;&gt;标题有下面的 markdown 代码形式:
&lt;span class=&quot;fu&quot;&gt;###   第一种标题&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;####  第二种&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;##### 第三种[点我](http://www.xxx.com)&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;### ``第四种``&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;### &amp;lt;strong&amp;gt;第五种，嵌套html标签&amp;lt;/strong&amp;gt;&lt;/span&gt;
...&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;采用正则表达式处理的时候&quot;&gt;采用正则表达式处理的时候&lt;/h5&gt;
&lt;p&gt;对于上面的情况，第一次的正则拿出标题内容很简单，例如这个： &lt;code&gt;###?&lt;/code&gt; 从三个#号开始贪婪匹配。这样我们可以拿出标题，但是标题里面还&lt;code&gt;掺杂着一些其他标签&lt;/code&gt;。你会想，有没有可能在正则匹配就把&lt;code&gt;掺杂&lt;/code&gt;的标签去掉。那这个是肯定可以的，代价就是高超的正则匹配式子，且现在还没考虑内容的情况。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为什么非要去掉标签呢？&lt;/code&gt; 因为这是标题，标题将会被用作搜索的 key，且返回给前端的时候，你不能把这个解析符号也给前端对吧？去掉了有以下好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;减少搜索的 o(n)&lt;/li&gt;
&lt;li&gt;方便显示&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;采用逐行处理的时候&quot;&gt;采用逐行处理的时候&lt;/h5&gt;
&lt;p&gt;我们从文件中读出第一行 &lt;code&gt;### 第一种标题&lt;/code&gt;，replace 函数处理掉 &lt;code&gt;###&lt;/code&gt; 等符号，这里循环处理即可去掉指定的任何符号。&lt;br/&gt;读出第三行的时候 &lt;code&gt;##### 第三种[点我](http://www.xxx.com)&lt;/code&gt;，处理掉，&lt;code&gt;#####&lt;/code&gt; &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; 等，剩下就是完美：&lt;code&gt;第三种点我&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;看到这你是否觉得事情变简单了&quot;&gt;看到这，你是否觉得事情变简单了？&lt;/h5&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们知道 &lt;code&gt;markdown 的非标题内容部分，符号和标签更是多种多样&lt;/code&gt;，如果我们用正则解决，假设标题能完美处理，那么内容怎么办呢？ &amp;gt; 如果去掉内容的其他无用标签，或者要求特定保存一些，等情况，多批次的正则过滤将会是花销巨大的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解决流程&quot;&gt;解决流程：&lt;/h3&gt;
&lt;p&gt;无论是&lt;code&gt;正则匹配方案&lt;/code&gt; 还是 &lt;code&gt;逐行处理方案&lt;/code&gt;，这两种我都写了对应的&lt;code&gt;引擎函数&lt;/code&gt;，通过且以后者运行谓之&lt;code&gt;0 bug&lt;/code&gt;。实现的时间加起来不足 3.5 小时。后者尤其快，下面我&lt;code&gt;仅主要介绍后者的解决流程&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;先明确几个细节点&quot;&gt;先明确几个细节点&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;只有标题没对应内容，自动补充为空字符串&lt;/li&gt;
&lt;li&gt;只有内容没对应标题，不录入&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;例如&quot;&gt;例如&lt;/h5&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode markdown&quot;&gt;
&lt;code class=&quot;sourceCode markdown&quot;&gt;内容66655
&lt;span class=&quot;fu&quot;&gt;####  标题一&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;####  标题二&lt;/span&gt;
456789....&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;title[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] ===&amp;gt; &lt;span class=&quot;st&quot;&gt;&quot;标题一&quot;&lt;/span&gt; , content[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] ===&amp;gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;
title[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] ===&amp;gt; &lt;span class=&quot;st&quot;&gt;&quot;标题二&quot;&lt;/span&gt; , content[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] ===&amp;gt; &lt;span class=&quot;st&quot;&gt;&quot;456789....&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;流程图&quot;&gt;流程图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690927/201711/690927-20171116154320015-159781774.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，已经很简答，例如 Java 语言的 &lt;code&gt;String API startWith&lt;/code&gt; 就能用在&lt;code&gt;判断是否是title&lt;/code&gt;，&lt;code&gt;if(startWith&quot;####&quot;)&lt;/code&gt;&lt;br/&gt;过滤方面，replace 之类的函数，等都可以。公司代码，不便公开。&lt;/p&gt;

</description>
<pubDate>Thu, 16 Nov 2017 07:38:00 +0000</pubDate>
<dc:creator>指尖下的幽灵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linguanh/p/7844628.html</dc:identifier>
</item>
<item>
<title>（二）springboot整合thymeleaf模板 - nfcm</title>
<link>http://www.cnblogs.com/nfcm/p/7843935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nfcm/p/7843935.html</guid>
<description>&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;在我们平时的开发中，用了很久的jsp作view显示层，但是标签库和JSP缺乏良好格式的一个副作用就是它很少能够与其产生的HTML类似。所以，在Web浏览器或HTML编辑器中查看未经渲染的JSP模板是非常令人困惑的，而且得到的结果看上去也非常丑陋（也就是不放到服务器，直接本地打开）。&lt;/p&gt;
&lt;p&gt;但是Thymeleaf模板是原生的，不依赖于标签库。它能在接受原始HTML的地方进行编辑和渲染（也就是说我们通过thymeleaf写一个页面，如果不放到服务器进行渲染，也是可以看到效果的，跟后端打开基本相同）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-thymeleaf&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;配置springbean视图&lt;/h2&gt;
&lt;p&gt;首先我们需要让springboot（springmvc通用）知道我们的页面是通过什么来渲染的（jsp,freemarker,thymeleaf等等，以及模板的位置等信息）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 设置视图解析器
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; templateEngine
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
 &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ViewResolver viewResolver(SpringTemplateEngine templateEngine){
    ThymeleafViewResolver resolver &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThymeleafViewResolver();
    resolver.setTemplateEngine(templateEngine);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolver;
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 设置模板引擎
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; templateResolver
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
 &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SpringTemplateEngine templateEngine(TemplateResolver templateResolver){
    SpringTemplateEngine engine &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringTemplateEngine();
    engine.setTemplateResolver(templateResolver);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; engine;
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 模板解析引擎
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
 &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TemplateResolver templateResolver(){
    TemplateResolver resolver &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringResourceTemplateResolver();
    resolver.setPrefix(&lt;/span&gt;&quot;/WEB-INF/template/&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置地址前缀&lt;/span&gt;
    resolver.setSuffix(&quot;.html&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置后缀&lt;/span&gt;
    resolver.setCacheable(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置不缓存&lt;/span&gt;
    resolver.setTemplateMode(&quot;HTML5&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolver;
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ThymeleafViewResolver&lt;/span&gt;是Spring MVC中ViewResolver的一个实现类。像其他的视图解析器一样，它会接受一个逻辑视图名称，并将其解析为视图&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TemplateResolver&lt;/span&gt;会最终定位和查找模板。与之前配置InternalResourceViewResolver类似，它使用了prefix和suffix属性。前缀和后缀将会与逻辑视图名组合使用，进而定位Thymeleaf引擎。它的templateMode属性被设置成了HTML 5，这表明我们预期要解析的模板会渲染成HTML 5输出&lt;/p&gt;
&lt;p&gt;到这里我们就基本配置完了 。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;接下来我们在WEB-INF/template下建立home.html,头部加入thymeleaf的命令空间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns:th&lt;/span&gt;&lt;span&gt;=&quot;http://www.thymeleaf.org&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立一个controller，写我们的第一个controller，打开访问localhost:8080/home就会转发到/WEB-INF/template/home.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;/home&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String hello(Map&amp;lt;String,Object&amp;gt;&lt;span&gt; map){
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;1&quot;, &quot;fei&quot;, 22, &quot;爱好：篮球&quot;,&quot;admin&quot;&lt;span&gt;);
        map.put(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
        
        List&lt;/span&gt;&amp;lt;User&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i =0;i&amp;lt;5;i++&lt;span&gt;){
            User u &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;&quot;+(i+2), &quot;fei&quot;+(i+2), 22+(i+2), &quot;爱好：篮球&quot;+(i+2),&quot;user&quot;+&lt;span&gt;i);
            list.add(u);
        }
        map.put(&lt;/span&gt;&quot;userList&quot;&lt;span&gt;,list);
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;home&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;thymeleaf语法&lt;/h2&gt;
&lt;h3&gt;文本显示&lt;/h3&gt;
&lt;p&gt;${}的使用和jsp的el表达式很类似，我们在后台绑定了一个user对象那么我们可以通过${user.name}获取用户名，相当于user.getName();但是注意这个只能放到th表达式里面&lt;/p&gt;
&lt;p&gt;th:text就相当于把里面的渲染主来的值放到aaa的位置上，&lt;span&gt;如果th:text里面的值只有${user.name},并且为null，那么就会显示aaa&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;'用户名：' +${user.name}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aaa&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
#或者下面的这种方式，|…|中只能包含变量表达式${…}，不能包含其他常量、条件表达式等
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;|用户名：${user.name}|&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 运算符&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在表达式中可以使用各类算术运算符，例如+, -, *, /, %&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;'年龄*2='+ ${user.age}*2 &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;逻辑运算符&quot; data-source-line=&quot;64&quot;&gt;逻辑运算符&lt;/h4&gt;
&lt;p&gt;在表达式中可以使用逻辑运算符，但是除了==其他的要使用转义字符&lt;/p&gt;
&lt;p&gt;&amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;= != 对应(gt, lt, ge, le, ne)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;(${user.age} eq 22)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aaa&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;  //输出true
#可以使用二元表达式
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;(${user.age} ge 23?'超过年纪':'ok')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;条件判断&lt;/h3&gt;
&lt;p&gt;th:if条件成立才会显示&lt;br/&gt;th:unless条件不成立才会显示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;th:if&lt;/span&gt;&lt;span&gt;=&quot;(${user.age} gt 21)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年龄超过21才会显示&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;th:href&lt;/span&gt;&lt;span&gt;=&quot;@{/login}&quot;&lt;/span&gt;&lt;span&gt; th:unless&lt;/span&gt;&lt;span&gt;=${session.user &lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;= null}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Login&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Switch&lt;/h3&gt;
&lt;p&gt;* 代表default，其他都没匹配到会显示带*的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;th:switch&lt;/span&gt;&lt;span&gt;=&quot;${user.role}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;th:case&lt;/span&gt;&lt;span&gt;=&quot;'admin'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户是管理员&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;th:case&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户是普通人员&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;循环&lt;/h3&gt;
&lt;p&gt;第二个参数称作状态变量，属性有&lt;br/&gt;- index:当前迭代对象的index（从0开始计算）&lt;br/&gt;- count: 当前迭代对象的index(从1开始计算)&lt;br/&gt;- size:被迭代对象的大小&lt;br/&gt;- current:当前迭代变量&lt;br/&gt;- even/odd:布尔值，当前循环是否是偶数/奇数（从0开始计算）&lt;br/&gt;- first:布尔值，当前循环是否是第一个&lt;br/&gt;- last:布尔值，当前循环是否是最后一个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;name&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;age&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;th:each&lt;/span&gt;&lt;span&gt;=&quot;user,iterStat: ${userList}&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;${iterStat.index}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;${user.id}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;${user.name}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;王五&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;${user.age}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;55&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;* 号和$符号共用&lt;/h3&gt;
&lt;p&gt;*{}里面的值就是上层th:object对象里面对应的属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;th:object&lt;/span&gt;&lt;span&gt;=&quot;${user}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Name: &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;*{name}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;wangwu&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;AGE: &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;*{age}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;22&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Utilities&lt;/h3&gt;
&lt;p&gt;Utilities为了模板更加易用，Thymeleaf还提供了一系列Utility对象（内置于Context中），可以通过#直接访问&lt;/p&gt;
&lt;p&gt;- dates ： java.util.Date的功能方法类。&lt;br/&gt;- calendars : 类似#dates，面向java.util.Calendar&lt;br/&gt;- numbers : 格式化数字的功能方法类&lt;br/&gt;- strings : 字符串对象的功能类，contains,startWiths,prepending/appending等等。&lt;br/&gt;- objects: 对objects的功能类操作。&lt;br/&gt;- bools: 对布尔值求值的功能方法。&lt;br/&gt;- arrays：对数组的功能类方法。&lt;br/&gt;- lists: 对lists功能类方法&lt;br/&gt;- sets&lt;br/&gt;- maps&lt;/p&gt;
&lt;p&gt;表达式基本对象&lt;br/&gt;- #ctx: 上下文对象.&lt;br/&gt;- #vars: context中的变量们.&lt;br/&gt;- #locale: context中的locale.&lt;br/&gt;- #httpServletRequest: (只在web context中) HttpServletRequest对象.&lt;br/&gt;- #httpSession: (只在web context中) HttpSession对象.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;将date渲染成后面的格式
${#dates.format(date, 'dd/MMM/yyyy HH:mm')}
得到当前时间
${#dates.createNow()}
得到当前时间并显示
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot; ${#dates.format(new java.util.Date().getTime(), 'yyyy-MM-dd hh:mm:ss')} &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#strings/&quot; target=&quot;_blank&quot;&gt;utilities其他使用链接，很详细&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;内联&lt;/h3&gt;
&lt;h4&gt;Text inlining&lt;/h4&gt;
&lt;p&gt;后面[[]]里面的值是从域中获取的text文本，跟使用th:text效果类似&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;th:inline&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;[[${user.name}]]&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;JavaScript inlining&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;th:inline&lt;/span&gt;&lt;span&gt;=&quot;javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [[${user.name}]];
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面这个意思是如果没有跑在服务器，name就会是我们的lisi，如果在服务器上，会取出user.name的值，忽略lisi&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
var name = /*[[${user.name}]]*/&quot;lisi&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;CSS inlining&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;style th:inline=&quot;css&quot;&amp;gt;
    .[[$&lt;/span&gt;{&lt;span&gt;classname&lt;/span&gt;}&lt;span&gt;]] &lt;/span&gt;{&lt;span&gt;
      text-align&lt;/span&gt;:&lt;span&gt; [[${align&lt;/span&gt;}&lt;span&gt;]];
    }
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;none inlining&lt;/h4&gt;
&lt;p&gt;但是如果我么就要显示[[${user.name}]]不需要他转换呢，就会用到none inlining&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;span th:inline=&quot;none&quot;&amp;gt;[[$&lt;/span&gt;{&lt;span&gt;user.name&lt;/span&gt;}&lt;span&gt;]]&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;嵌套&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在当前home.html路径下有个footer.html,内容如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt; xmlns:th&lt;/span&gt;&lt;span&gt;=&quot;http://www.thymeleaf.org&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;footer &lt;/span&gt;&lt;span&gt;th:fragment&lt;/span&gt;&lt;span&gt;=&quot;copy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;amp;copy;&lt;/span&gt;&lt;span&gt; 2011 The Good Thymes Virtual Grocery
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;footer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在home.html引用这个footer，footer代表html的名称，copy代表fragmen的值&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;th:replace&lt;/span&gt;&lt;span&gt;=&quot;footer:: copy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;th:include&lt;/span&gt;&lt;span&gt;=&quot;footer:: copy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;展现的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;footer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;amp;copy;&lt;/span&gt;&lt;span&gt; 2011 The Good Thymes Virtual Grocery
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;footer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;amp;copy;&lt;/span&gt;&lt;span&gt; 2011 The Good Thymes Virtual Grocery
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得出结论：&lt;br/&gt; - th:replace会将当前div整个替换成foot的元素&lt;br/&gt; - th:include只是将footer里面的内容拷贝进来&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;链接&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;链接一般用th:href=&quot;@{地址}&quot;，“@{}”表达式，用来计算相对于URL的路径,在html ==&amp;lt;a  href=&quot;/register&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;th:href&lt;/span&gt;&lt;span&gt;=&quot;@{/register}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;register&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;常用标签&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100855/201711/1100855-20171116154946202-546329580.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;springboot简化配置&lt;/h2&gt;
&lt;p&gt;当然在springboot中，上面的视图解析器等注册都不需要我们做了，因为springboot都默认帮我们做了，（只要我们将Thymeleaf maven依赖添加到项目的pom文件下，就启用了Spring Boot的自动配置。当应用运行时，Spring Boot将会探测到类路径中的Thymeleaf，然后会自动配置视图解析器、模板解析器以及模板引擎）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果什么都不配置，springboot会默认查找类跟目录下的templates文件夹下的模板，home.html放到src/main/ resources/templates目录下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100855/201711/1100855-20171116145437406-1513102195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们要在home的html中引入一些静态资源怎么办呢，这点springboot也帮我们考虑到了&lt;/p&gt;
&lt;p&gt;springboot它会将“/**”映射到几个资源路径中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;META-INF/resources/&lt;/li&gt;
&lt;li&gt;resources&lt;/li&gt;
&lt;li&gt;static&lt;/li&gt;
&lt;li&gt;public&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说我们在有一个static/css/home.css&lt;/p&gt;
&lt;p&gt;那么我们这样引入就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; th:href=&quot;@&lt;/span&gt;{&lt;span&gt;/css/home.css&lt;/span&gt;}&lt;span&gt;&quot;&amp;gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然，我们还是可以配置前缀后缀，以及是否缓存等，只需要一个简单的配置即可&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#配置前缀
#spring.thymeleaf.prefix&lt;/span&gt;=classpath:/templates/&lt;span&gt;  
#配置后缀
#spring.thymeleaf.suffix&lt;/span&gt;=&lt;span&gt;.html
#spring.thymeleaf.mode&lt;/span&gt;=&lt;span&gt;HTML5 
#spring.thymeleaf.encoding&lt;/span&gt;=UTF-8&lt;span&gt; 
#spring.thymeleaf.content&lt;/span&gt;-type=text/&lt;span&gt;html 
#是否开启缓存
spring.thymeleaf.cache&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Thu, 16 Nov 2017 07:09:00 +0000</pubDate>
<dc:creator>nfcm</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nfcm/p/7843935.html</dc:identifier>
</item>
<item>
<title>Owin中间件动手做 - RocketRobin</title>
<link>http://www.cnblogs.com/rocketRobin/p/7844423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rocketRobin/p/7844423.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;摘要：本文目的是了解Owin基本原理。讲述如何从控制台创建一个自宿主的OwinHost，然后再编写一两个中间件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;首先通过VisualStudio创建一个控制台应用&lt;/p&gt;
&lt;p&gt;然后添加Owin的Nuget包引用&lt;/p&gt;
&lt;p&gt;需要的包如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Owin
Microsoft.Owin
Microsoft.Owin.Hosting
Microsoft.Owin.Host.HttpListener&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;准备工作到此结束&lt;/p&gt;
&lt;h2 id=&quot;编写owinstartup类&quot;&gt;编写OwinStartup类&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class Startup
{
    public void Configuration(IAppBuilder app)
    {
        app.Run(HandleRequest);
    }
    static Task HandleRequest(IOwinContext context)
    {
        context.Response.ContentType = &quot;text/plain&quot;;
        return context.Response.WriteAsync(&quot;Hello world from myOwin&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当OwinHost运行时，会首先加载Startup类，&lt;code&gt;Configuration&lt;/code&gt;方法是必须有的，在&lt;code&gt;Configuration&lt;/code&gt;方法中向Owin管道插入中间件，所有的请求都是中间件处理。&lt;/p&gt;
&lt;p&gt;在这个&lt;code&gt;Configuration&lt;/code&gt;中&lt;code&gt;app.Run(HandleRequest);&lt;/code&gt;方法的作用是向管道中添加一个没有后续中间件的中间件，一般来讲一个Owin管道中有许多中间件，不同的中间件处理不同的事情，在处理结束后&lt;strong&gt;选择性&lt;/strong&gt;的调用后面的中间件，例如某个身份验证中间件可以在验证失败时结束请求。而&lt;code&gt;app.Run&lt;/code&gt;方法就是插如一个没有后续事项的中间件。稍后我们会编写常规的中间件。&lt;/p&gt;
&lt;p&gt;这个中间件做的事很简单，就是向响应写入一个字符串，无论请求是什么结果都是一样的。&lt;/p&gt;
&lt;h2 id=&quot;在main方法中启动host&quot;&gt;在Main方法中启动Host&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;static void Main(string[] args)
{
    var url = &quot;http://localhost:8080/&quot;;
    var opt = new StartOptions(url);

    using (WebApp.Start&amp;lt;Startup&amp;gt;(opt))
    {
        Console.WriteLine(&quot;Server run at &quot; + url + &quot; , press Enter to exit.&quot;);
        Console.ReadLine();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;StartOptions&lt;/code&gt;类用来指定一些启动参数，最少应该指定一个url,这里一并指定了使用8080端口&lt;/p&gt;
&lt;p&gt;启动程序控制台输出如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Server run at http://localhost:8080/ , press Enter to exit.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用浏览器打开 &lt;a href=&quot;http://localhost:8080/&quot; class=&quot;uri&quot;&gt;http://localhost:8080/&lt;/a&gt;&lt;br/&gt;效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`Hello world from myOwin`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尝试更改路径你得到的始终是一个结果&lt;br/&gt;你可以尝试将&lt;code&gt;Configuration&lt;/code&gt;中的代码注释掉，在运行程序，这是访问将得到空页面，Http代码也将是404，因为Owin管道中没有中间件处理请求。&lt;/p&gt;
&lt;h2 id=&quot;编写中间件&quot;&gt;编写中间件&lt;/h2&gt;
&lt;p&gt;我们编写一个名为Ding的中间件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DingMiddleware : OwinMiddleware
{
    public DingMiddleware(OwinMiddleware next) : base(next)
    {
    }

    public override Task Invoke(IOwinContext context)
    {
        if (context.Request.Path.Value.Equals(&quot;/home/index&quot;))
        {
            context.Response.Write(&quot;hello world from home/index&quot;);
        }
        if (Next != null)
        {
            return Next.Invoke(context);
        }
        return Task.CompletedTask;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个中间件在检测到访问路径是&lt;code&gt;/home/index&lt;/code&gt;时向Response中写入一句话，然后检测是否有下一个中间件，如果有就调用。&lt;/p&gt;
&lt;h2 id=&quot;添加中间件到configuration&quot;&gt;添加中间件到&lt;code&gt;Configuration&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;可以直接在&lt;code&gt;Configuration&lt;/code&gt;中加入&lt;code&gt;app.Use&amp;lt;DingMiddleware&amp;gt;()&lt;/code&gt;来插入中间件，但是我们一般使用扩展方法来做这件事。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class MyMidlewareExtention
{
    public static IAppBuilder UseDing(this IAppBuilder app)
    {
        return app.Use&amp;lt;DingMiddleware&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;Configuration&lt;/code&gt;中的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configuration(IAppBuilder app)
{
    app.UseDing();
    app.Run(HandleRequest);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在管道中有两个中间件了，现在运行程序，在地址栏中输入&lt;code&gt;http://localhost:8080/home/index&lt;/code&gt;将得到如下结果&lt;br/&gt;&lt;code&gt;hello world from home/indexHello world from myOwin&lt;/code&gt;&lt;br/&gt;因为Ding中间件在处理之后继续调用了接下来的中间件&lt;br/&gt;输入其他路径将得到&lt;code&gt;Hello world from myOwin&lt;/code&gt;这个结果&lt;/p&gt;
&lt;p&gt;如果将&lt;code&gt;Configuration&lt;/code&gt;中的两个中间件位置调换，的到的结果只有一个&lt;code&gt;Hello world from myOwin&lt;/code&gt;，因为&lt;code&gt;app.Run(HandleRequest);&lt;/code&gt;不执行后续的中间件。&lt;/p&gt;
&lt;h2 id=&quot;第二个中间件&quot;&gt;第二个中间件&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class DiDiDiMiddleware : OwinMiddleware
{
    public DiDiDiMiddleware(OwinMiddleware next) : base(next)
    {
    }

    public override Task Invoke(IOwinContext context)
    {
        if (context.Request.QueryString.Value == &quot;boom&quot;)
        {
            context.Response.Write(&quot;Boom! Boom! Boom!&quot;);
            return Task.CompletedTask;
        }
        if (Next != null)
        {
            return Next.Invoke(context);
        }
        return Task.CompletedTask;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个中间件在地址栏QueryString（?后边的部分）等于boom时结束请求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MyMidlewareExtention&lt;/code&gt;代码修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class MyMidlewareExtention
{
    public static IAppBuilder UseDing(this IAppBuilder app)
    {
        return app.Use&amp;lt;DingMiddleware&amp;gt;();
    }
    public static IAppBuilder UseDiDiDi(this IAppBuilder app)
    {
        return app.Use&amp;lt;DiDiDiMiddleware&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Startup&lt;/code&gt;类修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Startup
{
    public void Configuration(IAppBuilder app)
    {

        app.UseDiDiDi();
        app.UseDing();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里去掉了&lt;code&gt;app.Run&lt;/code&gt;此时，对于非&lt;code&gt;/home/index&lt;/code&gt;的请求会得到404，所以我们暂时改动下代码将&lt;code&gt;HandleRequest&lt;/code&gt;方法封装成一个默认的中间件&lt;/p&gt;
&lt;p&gt;代码改动如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DefaultMiddleware : OwinMiddleware
{
    public DefaultMiddleware(OwinMiddleware next) : base(next)
    {
    }

    public override Task Invoke(IOwinContext context)
    {
        var path = context.Request.Path.Value;
        context.Response.Write($&quot;hey you come from {path}!&quot;);
        return Task.CompletedTask;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;public class Startup
{
    public void Configuration(IAppBuilder app)
    {
        app.UseDiDiDi();
        app.UseDing();
        app.UseDefault();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序观察结果是否符合预期。&lt;br/&gt;当地址中含有?boom时会的到一个Boom！Boom！Boom！&lt;/p&gt;
&lt;p&gt;总结：Owin的管道概念其实简单易懂，在程序启动之前，向里面插入中间件，中间件决定请求是否继续向下走。在管道中的中间件可以拿到请求的所有信息以对请求进行处理，管道里的中间件执行结束之后，这个请求就被处理完成了，然后发回浏览器。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 07:02:00 +0000</pubDate>
<dc:creator>RocketRobin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rocketRobin/p/7844423.html</dc:identifier>
</item>
<item>
<title>一起写框架-MVC框架-基础功能-Date类型数据绑定(七) - 继续前向</title>
<link>http://www.cnblogs.com/zhuyuejiu/p/7821608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuyuejiu/p/7821608.html</guid>
<description>&lt;h2&gt;&lt;span&gt;实现功能&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;表单请求传递的数据，格式为以下格式的日期时间数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）&lt;span&gt;：&lt;/span&gt;yyyy-MM-dd hh:mm:ss&lt;/p&gt;
&lt;p&gt;（2）&lt;span&gt;：&lt;/span&gt;yyyy-MM-dd&lt;/p&gt;
&lt;p&gt;执行方法可以使用Date类型接收。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;实现思路&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.获得表单字符串。判断是否符合Date的格式。使用DataFormat转成成Date。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;实现代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.原来数据绑定的代码都堆在&lt;/span&gt;ControllerRelolver，这样导致ControllerRelolver臃肿了。所以&lt;span&gt;创建一个&lt;/span&gt;DataBind数据绑定&lt;span&gt;类，将数据绑定的代码移进里面。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; ioc.webmvc.impl;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Parameter;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.ParseException;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletContext;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletRequest;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletResponse;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpSession;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ioc.webmvc.annotation.Param;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataBind {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;     * 绑定作用域对象
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; typeClass
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; response
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; session
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; application
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object bindScope(Class&amp;lt;?&amp;gt;&lt;span&gt; typeClass, HttpServletRequest request, HttpServletResponse response,
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;            HttpSession session, ServletContext application) {
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ServletRequest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; request;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ServletResponse.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; response;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (HttpSession.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; session;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ServletContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; application;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;     * 绑定基础数据类型
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; typeClass
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parameter
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object bindBasicData(Class&amp;lt;?&amp;gt;&lt;span&gt; typeClass, Parameter parameter, HttpServletRequest request) {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         Param param = parameter.getAnnotation(Param.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (param == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;自定义参数没有使用@Param注解绑定&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;        System.out.println(param.value());
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得参数值&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;         String parameterValue =&lt;span&gt; request.getParameter(param.value());
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.判断基础数据类型的String类型&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; request.getParameter(param.value());
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Long.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.判断基础数据类型的Long类型&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Long.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Integer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6.判断基础数据类型的Integer类型&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Integer.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Double.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 7.判断基础数据类型的Double类型&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Double.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Float.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 8.判断基础数据类型的Float类型&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Float.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Boolean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 9.判断基础数据类型的Boolean类型&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Boolean.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Character.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10.判断基础数据类型的Character类型&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 String s = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(parameterValue);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; s.toCharArray()[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Short.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 11.判断基础数据类型的Short类型&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Short.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Byte.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 12.判断基础数据类型的Byte类型&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Byte.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;long&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.判断基础数据类型的long类型&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Long.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6.判断基础数据类型的int类型&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Integer.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 7.判断基础数据类型的double类型&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Double.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; 0.0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;float&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 8.判断基础数据类型的float类型&lt;/span&gt;
&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Float.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; 0.0f&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;boolean&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 9.判断基础数据类型的boolean类型&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Boolean.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; 
&lt;span&gt;151&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10.判断基础数据类型的char类型&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;                 String s = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(parameterValue);
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; s.toCharArray()[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; ' '&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; 
&lt;span&gt;159&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;short&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 11.判断基础数据类型的short类型&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Short.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;byte&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; 
&lt;span&gt;169&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 12.判断基础数据类型的byte类型&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Byte.valueOf(parameterValue);
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; 
&lt;span&gt;176&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; 
&lt;span&gt;179&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;182&lt;/span&gt; &lt;span&gt;     * 绑定日期类型,默认支持的格式为： 1.yyyy-mm-dd hh:mm:ss 2.yyyy-mm-dd
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; typeClass
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parameter
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;188&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;189&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object bindDate(Class&amp;lt;?&amp;gt;&lt;span&gt; typeClass, Parameter parameter, HttpServletRequest request) {
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (Date.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(typeClass)) {
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; 
&lt;span&gt;192&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10.判断基础数据类型的char类型&lt;/span&gt;
&lt;span&gt;193&lt;/span&gt;             Param param = parameter.getAnnotation(Param.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;             System.out.println(&quot;--绑定字段名 :&quot; +&lt;span&gt; param.value());
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;             String parameterValue =&lt;span&gt; request.getParameter(param.value());
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;             String pattern = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; 
&lt;span&gt;198&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (parameterValue != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(parameterValue)) {
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (parameterValue.lastIndexOf(&quot;:&quot;) &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;                     pattern = &quot;yyyy-MM-dd hh:mm:ss&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;                     pattern = &quot;yyyy-MM-dd&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;                 SimpleDateFormat format = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormat(pattern);
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; 
&lt;span&gt;206&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; format.parse(parameterValue);
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParseException e) {
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; 
&lt;span&gt;213&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; 
&lt;span&gt;217&lt;/span&gt; 
&lt;span&gt;218&lt;/span&gt; 
&lt;span&gt;219&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2.修改ControllerRelolver类的绑定参数的方法getparameterObjects&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object[] getparameterObjects(Parameter[] parameters) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.创建设置一个参数对象的数组，参数的格式和参数类型的个一致&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         Object[] parameterObjects = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[parameters.length];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.根据参数的类型，将对于的对象填在对象数组中&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;parameters.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             
&lt;span&gt; 7&lt;/span&gt;             Class&amp;lt;?&amp;gt; typeClass =&lt;span&gt; parameters[i].getType();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.根据判断方法参数的类型和我们制定的4个作用是否是父子类关系。如果是就赋值
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---绑定域对象request,reponse,session,application&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             Object scopeData =&lt;span&gt; DataBind.bindScope(typeClass, request, response, session, application);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---绑定基础数据类型------------------------------&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(scopeData!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 parameterObjects[i]=&lt;span&gt;scopeData;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             Object basicData =&lt;span&gt; DataBind.bindBasicData(typeClass, parameters[i], request);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt;(basicData!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     parameterObjects[i]=&lt;span&gt;basicData;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;             }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---绑定日期格式-------&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             Object dateData =&lt;span&gt;DataBind.bindDate(typeClass, parameters[i], request);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt;(dateData!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     parameterObjects[i]=&lt;span&gt;dateData;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---绑定数组数据&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             Object arrayData =&lt;span&gt; DataBind.bindArray(typeClass, parameters[i], request);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(arrayData!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 parameterObjects[i]=&lt;span&gt;arrayData;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; parameterObjects;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;测试代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.测试目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/866702/201711/866702-20171116153429906-1813480605.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1.测试页面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Insert title here&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    用户注册
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;${pageContext.request.contextPath }/register.do&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;        用户名：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;        密码：  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;        年龄：    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;      出生日期：   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;date&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;date&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;注册&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.测试的Controller代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 注册页面
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; username
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; password
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     @RequestMapping(value = &quot;/register&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String register(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password ,@Param(&quot;age&quot;) &lt;span&gt;long&lt;/span&gt; age,HttpServletRequest request,@Param(&quot;date&quot;&lt;span&gt;) Date date){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;用户名:&quot;+username+&quot;,密码:&quot;+password+&quot;，年龄&quot;+&lt;span&gt;age);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        System.out.println(request.getRequestURI());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        System.out.println(date);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;redirect:/register.jsp&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.测试结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/866702/201711/866702-20171116153706562-4015166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 16 Nov 2017 06:44:00 +0000</pubDate>
<dc:creator>继续前向</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuyuejiu/p/7821608.html</dc:identifier>
</item>
<item>
<title>jQuery学习笔记之Ajax用法详解 - 左逸枫</title>
<link>http://www.cnblogs.com/zuoyifeng/p/7844211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuoyifeng/p/7844211.html</guid>
<description>&lt;p&gt;这篇文章主要介绍了jQuery学习笔记之Ajax用法,结合实例形式较为详细的分析总结了jQuery中ajax的相关使用技巧,包括ajax请求、载入、处理、传递等,需要的朋友可以参考下&lt;/p&gt;
&lt;p&gt;本文实例讲述了jQuery学习笔记之Ajax用法。分享给大家供大家参考，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原文链接：&lt;a href=&quot;https://yq.aliyun.com/ziliao/153370&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://yq.aliyun.com/ziliao/153370&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、Ajax请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1、jQuery.ajax(options)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;通过 HTTP 请求加载远程数据。jQuery 底层 AJAX 实现。简单易用的高层实现见 .get,.post 等。&lt;/p&gt;
&lt;p&gt;　　　　.ajax()返回其创建的XMLHttpRequest对象。大多数情况下你无需直接操作该对象，但特殊情况下可用于手动终止请求。.ajax() 只有一个参数：参数 key/value 对象，包含各配置及回调函数信息。详细参数选项见下。&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;注意：  如果你指定了 dataType 选项，请确保服务器返回正确的 MIME 信息，(如 xml 返回 &quot;text/xml&quot;)。错误的 MIME 类型可能导致不可预知的错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　注意：如果dataType设置为&quot;script&quot;，那么在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;jQuery 1.2 中，您可以跨域加载 JSON 数据，使用时需将数据类型设置为 JSONP。使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。数据类型设置为 &quot;jsonp&quot; 时，jQuery 将自动调用回调函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　返回值： XMLHttpRequest&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;参数：&lt;/p&gt;
&lt;p&gt;　　　　options (可选) : AJAX 请求设置。所有选项都是可选的。&lt;/p&gt;
&lt;p&gt;　　　　选项&lt;/p&gt;
&lt;p&gt;　　　 （1）、 &lt;span class=&quot;cnblogs_code&quot;&gt;async (Boolean)&lt;/span&gt;  : (默认: true) &lt;/p&gt;
&lt;p&gt;　　　　　　默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。&lt;/p&gt;
&lt;p&gt;　　　 （2）、 &lt;span class=&quot;cnblogs_code&quot;&gt;beforeSend (Function)&lt;/span&gt;  : 发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。&lt;/p&gt;
&lt;p&gt;　　　　　　XMLHttpRequest 对象是唯一的参数。这是一个 Ajax 事件。如果返回false可以取消本次ajax请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　function&lt;/span&gt;&lt;span&gt; (XMLHttpRequest) {
 　　　　　　 &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用本次AJAX请求时传递的options参数&lt;/span&gt;
　　　　　}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　 （3）、 &lt;span class=&quot;cnblogs_code&quot;&gt;cache (Boolean)&lt;/span&gt;  : (默认: true,dataType为script时默认为false) 。jQuery 1.2 新功能，设置为 false 将不会从浏览器缓存中加载请求信息。&lt;/p&gt;
&lt;p&gt;　　　 （4）、 &lt;span class=&quot;cnblogs_code&quot;&gt;complete (Function)&lt;/span&gt;  : 请求完成后回调函数 (请求成功或失败时均调用)。&lt;/p&gt;
&lt;p&gt;　　　　　　参数： XMLHttpRequest 对象和一个描述成功请求类型的字符串。 这是一个 Ajax 事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　function&lt;/span&gt;&lt;span&gt; (XMLHttpRequest, textStatus) {
  　　　　　　&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用本次AJAX请求时传递的options参数&lt;/span&gt;
　　　　} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　 （5）、 &lt;span class=&quot;cnblogs_code&quot;&gt;contentType (String)&lt;/span&gt;  : (默认: &quot; &lt;span class=&quot;cnblogs_code&quot;&gt;application/x-www-form-urlencoded&lt;/span&gt; &quot;) 发送信息至服务器时内容编码类型。默认值适合大多数应用场合。&lt;/p&gt;
&lt;p&gt;　　　 （6）、 &lt;span class=&quot;cnblogs_code&quot;&gt;data (Object,String)&lt;/span&gt;  : 发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在URL 后。查看processData选项说明以禁止此自动转换。&lt;/p&gt;
&lt;p&gt;　　　　　　必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如  &lt;span class=&quot;cnblogs_code&quot;&gt;{foo:[&quot;bar1&quot;, &quot;bar2&quot;]}&lt;/span&gt;  转换为 '&amp;amp;foo=bar1&amp;amp;foo=bar2'。&lt;/p&gt;
&lt;p&gt;　　　 （7）、 &lt;span class=&quot;cnblogs_code&quot;&gt;dataFilter (Function)&lt;/span&gt;  :给Ajax返回的原始数据的进行预处理的函数。提供data和type两个参数：data是Ajax返回的原始数据，type是调用jQuery.ajax时&lt;/p&gt;
&lt;p&gt;　　　　　　提供的dataType参数。函数返回的值将由jQuery进一步处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　function&lt;/span&gt;&lt;span&gt; (data, type) {
  　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对Ajax返回的原始数据进行预处理&lt;/span&gt;
  　　　　　　&lt;span&gt;return&lt;/span&gt; data &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回处理后的数据&lt;/span&gt;
　　　　　　} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　 （8）、 &lt;span class=&quot;cnblogs_code&quot;&gt;dataType (String)&lt;/span&gt;  : (默认值：智能判断xml或者html)&lt;/p&gt;
&lt;p&gt;　　　　　　　　预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息返回responseXML 或 responseText，并作为回调函数参数传递，可用值：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理。&lt;br/&gt;　　　　　　　　&quot;html&quot;: 返回纯文本 HTML 信息；包含的script标签会在插入dom时执行。&lt;br/&gt;　　　　　　　　&quot;script&quot;: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了&quot;cache&quot;参数。注意：在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载)&lt;br/&gt;　　　　　　　　&quot;json&quot;: 返回 JSON 数据 。&lt;br/&gt;　　　　　　　　&quot;jsonp&quot;: JSONP 格式。使用 JSONP 形式调用函数时，如 &quot; &lt;span class=&quot;cnblogs_code&quot;&gt;myurl?callback=?&lt;/span&gt; &quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。&lt;br/&gt;　　　　　　　　&quot;text&quot;: 返回纯文本字符串&lt;/p&gt;
&lt;p&gt;　　　 （9）、 &lt;span class=&quot;cnblogs_code&quot;&gt;error (Function)&lt;/span&gt;  : (默认: 自动判断 (xml 或 html)) 请求失败时调用时间。参数有以下三个：XMLHttpRequest 对象、错误信息、（可选）捕获的错误对象。&lt;/p&gt;
&lt;p&gt;　　　　　　如果发生了错误，错误信息（第二个参数）除了得到null之外，还可能是&quot;timeout&quot;, &quot;error&quot;, &quot;notmodified&quot; 和 &quot;parsererror&quot;。Ajax 事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　function&lt;/span&gt;&lt;span&gt; (XMLHttpRequest, textStatus, errorThrown) {
　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通常 textStatus 和 errorThrown 之中&lt;/span&gt;
　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有一个会包含信息&lt;/span&gt;
　　　　　　　　&lt;span&gt;this&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用本次AJAX请求时传递的options参数&lt;/span&gt;
　　　　　　}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　 （10）、 &lt;span class=&quot;cnblogs_code&quot;&gt;global (Boolean)&lt;/span&gt;  : (默认: true) 是否触发全局 AJAX 事件。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的 Ajax 事件。&lt;/p&gt;
&lt;p&gt;　　　 （11）、 &lt;span class=&quot;cnblogs_code&quot;&gt;ifModified (Boolean)&lt;/span&gt;  : (默认: false) 仅在服务器数据改变时获取新数据。使用 HTTP 包 Last-Modified 头信息判断。　　&lt;/p&gt;
&lt;p&gt;　　　 （12）、 &lt;span class=&quot;cnblogs_code&quot;&gt;jsonp (String)&lt;/span&gt;  : 在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的&quot;callback&quot;部分，&lt;/p&gt;
&lt;p&gt;　　　　　　　　比如 &lt;span class=&quot;cnblogs_code&quot;&gt;{jsonp:'onJsonPLoad'}&lt;/span&gt; 会导致将&quot;onJsonPLoad=?&quot;传给服务器。&lt;/p&gt;
&lt;p&gt;　　　 （13）、 &lt;span class=&quot;cnblogs_code&quot;&gt;password (String)&lt;/span&gt;  : 用于响应HTTP访问认证请求的密码&lt;/p&gt;
&lt;p&gt;　　　 （14）、 &lt;span class=&quot;cnblogs_code&quot;&gt;processData (Boolean)&lt;/span&gt;  : (默认: true) 默认情况下，发送的数据将被转换为对象(技术上讲并非字符串) 以配合默认内容类型&lt;/p&gt;
&lt;p&gt;　　　　　　　　&quot; &lt;span class=&quot;cnblogs_code&quot;&gt;application/x-www-form-urlencoded&lt;/span&gt; &quot;。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。&lt;/p&gt;
&lt;p&gt;　　　 （15）、 &lt;span class=&quot;cnblogs_code&quot;&gt;scriptCharset (String)&lt;/span&gt;  : 只有当请求时dataType为&quot;jsonp&quot;或&quot;script&quot;，并且type是&quot;GET&quot;才会用于强制修改charset。通常在本地和远程的内容编码不同时使用。&lt;/p&gt;
&lt;p&gt;　　　 （16）、 &lt;span class=&quot;cnblogs_code&quot;&gt;success (Function)&lt;/span&gt;  : 请求成功后的回调函数。参数：由服务器返回，并根据dataType参数进行处理后的数据；描述状态的字符串。 Ajax 事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　function&lt;/span&gt;&lt;span&gt; (data, textStatus) {
  　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; data 可能是 xmlDoc, jsonObj, html, text, 等等&lt;/span&gt;
  　　　　　　&lt;span&gt;this&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用本次AJAX请求时传递的options参数&lt;/span&gt;
　　　　　　}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　 （17）、 &lt;span class=&quot;cnblogs_code&quot;&gt;timeout (Number)&lt;/span&gt; : 设置请求超时时间（毫秒）。此设置将覆盖全局设置。&lt;/p&gt;
&lt;p&gt;　　　 （18）、 &lt;span class=&quot;cnblogs_code&quot;&gt;type (String)&lt;/span&gt;  : (默认: &quot;GET&quot;) 请求方式 (&quot;POST&quot; 或 &quot;GET&quot;)， 默认为 &quot;GET&quot;。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器&lt;/p&gt;
&lt;p&gt;　　　　　　　　支持。&lt;/p&gt;
&lt;p&gt;　　　 （19）、 &lt;span class=&quot;cnblogs_code&quot;&gt;url (String)&lt;/span&gt;  : (默认: 当前页地址) 发送请求的地址。&lt;/p&gt;
&lt;p&gt;　　　 （20）、 &lt;span class=&quot;cnblogs_code&quot;&gt;username (String)&lt;/span&gt;  : 用于响应HTTP访问认证请求的用户名&lt;/p&gt;
&lt;p&gt;　　　 （21）、 &lt;span class=&quot;cnblogs_code&quot;&gt;xhr (Function)&lt;/span&gt;  : 需要返回一个XMLHttpRequest 对象。默认在IE下是ActiveXObject 而其他情况下是XMLHttpRequest 。用于重写或者提供一个增强的&lt;/p&gt;
&lt;p&gt;　　　　　　　　XMLHttpRequest 对象。这个参数在jQuery 1.3以前不可用。&lt;/p&gt;
&lt;p&gt;　　　  ps:上述的部分是 &lt;span class=&quot;cnblogs_code&quot;&gt;url&lt;/span&gt;  &lt;span class=&quot;cnblogs_code&quot;&gt;type&lt;/span&gt;  &lt;span class=&quot;cnblogs_code&quot;&gt;dataType&lt;/span&gt;  &lt;span class=&quot;cnblogs_code&quot;&gt;data&lt;/span&gt;  &lt;span class=&quot;cnblogs_code&quot;&gt;success&lt;/span&gt; 调用常用的参数设置，利用这几个参数就可以成功实现ajax调用了.&lt;/p&gt;
&lt;p&gt;　　　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;jQTest.js&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; jqRequestUrl = &quot;AjaxHandler.ashx&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、 加载并执行一个 JS 文件&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  $.ajax({
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     type: &quot;GET&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     url: &quot;js/jqLoadJs.js&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     dataType: &quot;script&quot;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  });
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、装载一个 HTML 网页最新版本 &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  $.ajax({
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     url: &quot;test.htm&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     cache: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有缓存的说&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(html) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;alert(html);&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;       $(&quot;#spanGetHtml&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       $(&quot;#spanGetHtml&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       $(&quot;#spanGetHtml&quot;&lt;span&gt;).append(html);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  });
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、获取并解析一个xml文件(从服务端获取xml)&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;  $.ajax({
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     type: 'GET'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     dataType: 'xml', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里可以不写，但千万别写text或者html&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     url: jqRequestUrl + &quot;?action=jquerGetXmlRequest&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(xml) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确解析服务端的xml文件&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;       $(xml).find(&quot;profile&quot;).each(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; name = $(&lt;span&gt;this&lt;/span&gt;).children(&quot;userName&quot;).text(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取对象文本&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; location = $(&lt;span&gt;this&lt;/span&gt;).children(&quot;location&quot;&lt;span&gt;).text();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         alert(&quot;Xml at SERVER is gotten by CLIENT:&quot; + name + &quot; is living in &quot; +&lt;span&gt; location);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;      });
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     error: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(xml) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;       alert('An error happend while loading XML document '&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;  });
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、发送 XML 数据至服务器(客户端发送xml到服务端)&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; xmlDocument = &quot;&amp;lt;profile&amp;gt;&quot; +
&lt;span&gt;40&lt;/span&gt;   &quot; &amp;lt;userName&amp;gt;jeff wong&amp;lt;/userName&amp;gt;&quot; +
&lt;span&gt;41&lt;/span&gt;   &quot; &amp;lt;location&amp;gt;beijing&amp;lt;/location&amp;gt;&quot; +
&lt;span&gt;42&lt;/span&gt;   &quot;&amp;lt;/profile&amp;gt;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;  $.ajax({
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     url: jqRequestUrl + &quot;?action=jqueryXmlRequest&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     processData: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 processData 选项为 false，防止自动转换数据格式。&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;type: &quot;xml&quot;,&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     cache: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     type: &quot;xml&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    data: xmlDocument,
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(html) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;       alert(html); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹出提示&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;       $(&quot;#spanResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;       $(&quot;#spanResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;       $(&quot;#spanResult&quot;).html(html); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给当前dom的一个span元素赋值&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     error: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(oXmlHttpReq, textStatus, errorThrown) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;       alert(&quot;jquery ajax xml request failed&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;       $(&quot;#spanResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;       $(&quot;#spanResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;       $(&quot;#spanResult&quot;).html(&quot;jquery ajax xml request failed&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提示出错&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;  });
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、同步加载数据。发送请求时锁住浏览器。需要锁定用户交互操作时使用同步方式。&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; html =&lt;span&gt; $.ajax({
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有type 默认为GET方式&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     url: jqRequestUrl + &quot;?action=syncRequest&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     async: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt; &lt;span&gt;  }).responseText;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;  alert(html);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、显式get测试&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;  $.ajax({
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;     type: &quot;GET&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     url: jqRequestUrl + &quot;?action=jquery&amp;amp;userName=&quot; + $(&quot;#txtUserName&quot;&lt;span&gt;).val(),
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     cache: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(html) {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; alert(html); //弹出提示&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt;       $(&quot;#spanResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;       $(&quot;#spanResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;       $(&quot;#spanResult&quot;).html(html); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给当前dom的一个span元素赋值&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;     error: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(oXmlHttpReq, textStatus, errorThrown) {
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;       alert(&quot;jquery ajax request failed&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;       $(&quot;#spanResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;       $(&quot;#spanResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;       $(&quot;#spanResult&quot;).html(&quot;jquery ajax request failed&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提示出错&lt;/span&gt;
&lt;span&gt;86&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;  });
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7、显式POST测试 &lt;/span&gt;
&lt;span&gt;89&lt;/span&gt; &lt;span&gt;  $.ajax({
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;     type: &quot;POST&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; &lt;span&gt;    url: jqRequestUrl,
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt;     data: &quot;action=jquerySaveData&amp;amp;userName=jeffwong&amp;amp;location=beijing&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt;     success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(html) {
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt; &lt;span&gt;      alert(html);
&lt;/span&gt;&lt;span&gt;95&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;96&lt;/span&gt; &lt;span&gt;  });
&lt;/span&gt;&lt;span&gt;97&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、load(url,[data],[callback])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　载入远程 HTML 文件代码并插入至 DOM 中。&lt;/p&gt;
&lt;p&gt;　　默认使用 GET 方式 - 传递附加参数时自动转换为 POST 方式。jQuery 1.2 中，可以指定选择符，来筛选载入的 HTML 文档，DOM 中将仅插入筛选出的 HTML 代码。语法形如 &quot;url #some &amp;gt; selector&quot;。&lt;/p&gt;
&lt;p&gt;　　返回值 jQuery&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;url (String)&lt;/span&gt;  : 待装入 HTML 网页网址。&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;data (Map,String)&lt;/span&gt;  : (可选) 发送至服务器的 key/value 数据。在jQuery 1.3中也可以接受一个字符串了。&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;callback (Callback)&lt;/span&gt;  : (可选) 载入成功时回调函数。&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   $(&quot;#spanResult&quot;).load(&quot;test.htm&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   $(&quot;#spanResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   $(&quot;#spanResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、jQuery.get(url,[data],[callback],[type])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过远程 HTTP GET 请求载入信息。&lt;/p&gt;
&lt;p&gt;　　这是一个简单的 GET 请求功能以取代复杂 .ajax。请求成功时可调用回调函数。如果需要在出错时执行函数，请使用.ajax。&lt;/p&gt;
&lt;p&gt;　　返回值  XMLHttpRequest&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;url (String)&lt;/span&gt;  : 待载入页面的URL地址&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;data (Map)&lt;/span&gt;  : (可选) 待发送 Key/value 参数。&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;callback (Function)&lt;/span&gt;  : (可选) 载入成功时回调函数。&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;type (String)&lt;/span&gt;  : (可选) 返回内容格式，xml, html, script, json, text, _default。&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; jqRequestUrl = &quot;AjaxHandler.ashx&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   $.get(jqRequestUrl + &quot;?action=jquery&quot;, { userName: &quot;jeff wong&quot;, location: &quot;beijing&quot; }, jqGetNormalCallBack, 'text'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回数据类型&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqGetNormalCallBack(oData) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;   $(&quot;#spanResult&quot;).html(oData);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里直接json数据绑定了，下一个jquery方法会有处理&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;   $(&quot;#spanResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;   $(&quot;#spanResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ps：本例中，我们返回的是一段json类型的数据，在客户端没有对json类型数据进行处理，在下一个方法（jQuery.getJSON）中会改进处理的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、jQuery.getJSON(url,[data],[callback])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过 HTTP GET 请求载入 JSON 数据。&lt;/p&gt;
&lt;p&gt;　　在 jQuery 1.2 中，您可以通过使用JSONP 形式的回调函数来加载其他网域的JSON数据，如 &quot;myurl?callback=?&quot;。jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 &lt;br/&gt;　　&lt;span&gt;注意：此行以后的代码将在这个回调函数执行前执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　返回值  XMLHttpRequest&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;url (String)&lt;/span&gt;  : 发送请求地址。&lt;br/&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;data (Map)&lt;/span&gt;  : (可选) 待发送 Key/value 参数。&lt;br/&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;callback (Function)&lt;/span&gt;  : (可选) 载入成功时回调函数。&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; jqRequestUrl = &quot;AjaxHandler.ashx&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;getJSON方法调用&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;   $.getJSON(jqRequestUrl + &quot;?action=jquery&quot;, { userName: &quot;jeff wong&quot;, location: &quot;beijing&quot; }, jqGetJsonCallBack); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回json数据类型&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对json数据进行处理 (oData是json类型的数据)&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqGetJsonCallBack(oData) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; oJsonStr = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取json中的数据,并呈现&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;   oJsonStr += &quot;userName:&quot; + oData.userName + &quot;  location:&quot; + oData.location + &quot;&amp;lt;br/&amp;gt;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div中显示所有数据&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   $(&quot;#divResult&quot;&lt;span&gt;).html(oJsonStr);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5、jQuery.getScript(url,[callback])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过 HTTP GET 请求载入并执行一个 JavaScript 文件。&lt;/p&gt;
&lt;p&gt;　　jQuery 1.2 版本之前，getScript 只能调用同域 JS 文件。 1.2中，您可以跨域调用 JavaScript 文件。注意：Safari 2 或更早的版本不能在全局作用域中同步执行脚本。如果通过 getScript 加入脚本，请加入延时函数。&lt;/p&gt;
&lt;p&gt;　　返回值  XMLHttpRequest&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;url (String)&lt;/span&gt;  : 待载入 JS 文件地址。&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;callback (Function)&lt;/span&gt;  : (可选) 成功载入后回调函数。&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; jsUrl = &quot;js/jqLoadJs.js&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;getScript方法调用&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  $.getScript(jsUrl, jqGetJsCallBack);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;oData返回的是整个js路径下js文件内容&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqGetJsCallBack(oData) {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;  alert(oData);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6、jQuery.post(url,[data],[callback],[type])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过远程 HTTP POST 请求载入信息。&lt;/p&gt;
&lt;p&gt;　　这是一个简单的 POST 请求功能以取代复杂 .ajax。请求成功时可调用回调函数。如果需要在出错时执行函数，请使用.ajax。&lt;/p&gt;
&lt;p&gt;　　返回值  XMLHttpRequest&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;url (String)&lt;/span&gt;  : 发送请求地址。&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;data (Map)&lt;/span&gt;  : (可选) 待发送 Key/value 参数。&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;callback (Function)&lt;/span&gt;  : (可选) 发送成功时回调函数。&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;type (String)&lt;/span&gt;  : (可选) 返回内容格式，xml, html, script, json, text, _default。&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; jqRequestUrl = &quot;AjaxHandler.ashx&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   $.post(jqRequestUrl + &quot;?action=jquery&quot;, { userName: &quot;jeff wong&quot;, location: &quot;beijing&quot; }, jqPostCallBack, &quot;text&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回text数据类型&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqPostCallBack(oData) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div中显示所有数据&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;   $(&quot;#divResult&quot;&lt;span&gt;).html(oData);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;二、Ajax事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1、ajaxComplete(callback)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　AJAX 请求完成时执行函数。Ajax 事件。&lt;/p&gt;
&lt;p&gt;　　　　XMLHttpRequest 对象和设置作为参数传递给回调函数。&lt;/p&gt;
&lt;p&gt;　　　　返回值  jQuery&lt;/p&gt;
&lt;p&gt;　　　　参数&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;callback (Function)&lt;/span&gt;  : 待执行函数&lt;/p&gt;
&lt;p&gt;　　　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; jqRequestUrl = &quot;AjaxHandler.ashx&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   $.post(jqRequestUrl + &quot;?action=jquery&quot;, { userName: &quot;jeff wong&quot;, location: &quot;beijing&quot; }, jqPostCallBack, &quot;text&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回text数据类型&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AJAX 请求完成时执行函数&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   $(&quot;#divResult&quot;).ajaxComplete(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event, request, settings) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     $(&lt;span&gt;this&lt;/span&gt;).append(&quot;&amp;lt;br/&amp;gt;请求完成.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  });
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqPostCallBack(oData) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div中显示所有数据&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   $(&quot;#divResult&quot;&lt;span&gt;).html(oData);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;2、ajaxError(callback)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　AJAX 请求发生错误时执行函数。Ajax 事件。&lt;/p&gt;
&lt;p&gt;　　　　XMLHttpRequest 对象和设置作为参数传递给回调函数。捕捉到的错误可作为最后一个参数传递。&lt;/p&gt;
&lt;p&gt;　　　　返回值  jQuery&lt;/p&gt;
&lt;p&gt;　　　　参数&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span class=&quot;cnblogs_code&quot;&gt;callback (Function)&lt;/span&gt;  : 待执行函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event, XMLHttpRequest, ajaxOptions, thrownError) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; thrownError 只有当异常发生时才会被传递&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听的 dom 元素&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; jqRequestUrl = &quot;AjaxHandlers.ashx&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确的文件名 AjaxHandler.ashx 这里故意写错 引发ajaxError事件&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;   $.post(jqRequestUrl + &quot;?action=jquery&quot;, { userName: &quot;jeff wong&quot;, location: &quot;beijing&quot; }, jqPostCallBack, &quot;text&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AJAX 请求发生错误时执行函数 (这一段放在jqAjaxTest函数内也可以)&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; $(&quot;#divResult&quot;).ajaxError(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event, request, settings) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   $(&lt;span&gt;this&lt;/span&gt;).append(&quot;&amp;lt;br/&amp;gt;出错页面:&quot; +&lt;span&gt; settings.url);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqPostCallBack(oData) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div中显示所有数据&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   $(&quot;#divResult&quot;&lt;span&gt;).html(oData);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;3、ajaxSend(callback)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　AJAX 请求发送前执行函数。Ajax 事件。&lt;/p&gt;
&lt;p&gt;　　XMLHttpRequest 对象和设置作为参数传递给回调函数。&lt;/p&gt;
&lt;p&gt;　　返回值  jQuery&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　callback (Function) : 待执行函数&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; jqRequestUrl = &quot;AjaxHandler.ashx&quot;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   $.post(jqRequestUrl + &quot;?action=jquery&quot;, { userName: &quot;jeff wong&quot;, location: &quot;beijing&quot; }, jqPostCallBack, &quot;text&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AJAX 请求发送前执行函数&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; $(&quot;#divResult&quot;).ajaxSend(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(evt, request, settings) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   $(&lt;span&gt;this&lt;/span&gt;).append(&quot;&amp;lt;br/&amp;gt;开始请求: &quot; + settings.url + &quot;&amp;lt;br/&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqPostCallBack(oData) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div中显示所有数据&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   $(&quot;#divResult&quot;&lt;span&gt;).append(oData);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;4、ajaxStart(callback)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　AJAX 请求开始时执行函数。Ajax 事件。&lt;/p&gt;
&lt;p&gt;　　返回值  jQuery&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　callback (Function) : 待执行函数&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; jqRequestUrl = &quot;AjaxHandler.ashx&quot;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   $.post(jqRequestUrl + &quot;?action=jquery&quot;, { userName: &quot;jeff wong&quot;, location: &quot;beijing&quot; }, jqPostCallBack, &quot;text&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AJAX 请求开始时执行函数&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; $(&quot;#divResult&quot;).ajaxStart(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   $(&lt;span&gt;this&lt;/span&gt;).append(&quot;&amp;lt;br/&amp;gt;请求开始了&amp;lt;br/&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqPostCallBack(oData) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div中显示所有数据&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   $(&quot;#divResult&quot;&lt;span&gt;).append(oData);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;5、ajaxStop(callback)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　AJAX 请求结束时执行函数。Ajax 事件。&lt;/p&gt;
&lt;p&gt;　　返回值  jQuery&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　callback (Function) : 待执行函数&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; jqRequestUrl = &quot;AjaxHandler.ashx&quot;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   $.post(jqRequestUrl + &quot;?action=jquery&quot;, { userName: &quot;jeff wong&quot;, location: &quot;beijing&quot; }, jqPostCallBack, &quot;text&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AJAX 请求开始时执行函数&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; $(&quot;#divResult&quot;).ajaxStop(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   $(&lt;span&gt;this&lt;/span&gt;).append(&quot;&amp;lt;br/&amp;gt;请求已经结束了&amp;lt;br/&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqPostCallBack(oData) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div中显示所有数据&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   $(&quot;#divResult&quot;&lt;span&gt;).append(oData);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;6、ajaxSuccess(callback)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　AJAX 请求成功时执行函数。Ajax 事件。&lt;/p&gt;
&lt;p&gt;　　XMLHttpRequest 对象和设置作为参数传递给回调函数。&lt;/p&gt;
&lt;p&gt;　　返回值  jQuery&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　callback (Function) : 待执行函数&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqAjaxTest() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; jqRequestUrl = &quot;AjaxHandler.ashx&quot;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   $.post(jqRequestUrl + &quot;?action=jquery&quot;, { userName: &quot;jeff wong&quot;, location: &quot;beijing&quot; }, jqPostCallBack, &quot;text&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AJAX 请求成功时执行函数&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; $(&quot;#divResult&quot;).ajaxSuccess(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(evt, request, settings) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   $(&lt;span&gt;this&lt;/span&gt;).append(&quot;&amp;lt;br/&amp;gt;请求成功&amp;lt;br/&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   $(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).append(settings.url);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; jqPostCallBack(oData) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在div中显示所有数据&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   $(&quot;#divResult&quot;&lt;span&gt;).append(oData);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;display&quot;, &quot;block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   $(&quot;#divResult&quot;).css(&quot;color&quot;, &quot;red&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三、其他&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1、jQuery.ajaxSetup(options)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;设置全局 AJAX 默认选项。&lt;/p&gt;
&lt;p&gt;　　参数见 '$.ajax' 说明。&lt;/p&gt;
&lt;p&gt;　　返回值  jQuery&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;options (可选) : 选项设置。所有设置项均为可选设置。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 AJAX 请求默认地址为 &quot;AjaxHandler.ashx&quot;，禁止触发全局 AJAX 事件，用 POST 代替默认 GET 方法。其后的 AJAX 请求不再设置任何选项参数。 &lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;$.ajaxSetup({
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   url: &quot;AjaxHandler.ashx&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   global: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   type: &quot;POST&quot;
&lt;span&gt;6&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;2、serialize()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　序列化表单内容为字符串。&lt;/p&gt;
&lt;p&gt;　　返回值  jQuery&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　序列化表单内容为字符串，用于 Ajax 请求。&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; $(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; oSerializedStr = $(&quot;form&quot;).serialize(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;序列化表单内容为字符串&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   $(&quot;#results&quot;).append(&quot;&amp;lt;tt&amp;gt;&quot; + oSerializedStr + &quot;&amp;lt;/tt&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　文档片段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt; 2&lt;/span&gt;   &amp;lt;p id=&quot;results&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;b&amp;gt;Results: &amp;lt;/b&amp;gt;
&lt;span&gt; 4&lt;/span&gt;   &amp;lt;/p&amp;gt;
&lt;span&gt; 5&lt;/span&gt;   &amp;lt;form&amp;gt;
&lt;span&gt; 6&lt;/span&gt;   &amp;lt;select name=&quot;single&quot;&amp;gt;
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;option&amp;gt;Single&amp;lt;/option&amp;gt;
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;option&amp;gt;Single2&amp;lt;/option&amp;gt;
&lt;span&gt; 9&lt;/span&gt;   &amp;lt;/select&amp;gt;
&lt;span&gt;10&lt;/span&gt;   &amp;lt;select name=&quot;multiple&quot; multiple=&quot;multiple&quot;&amp;gt;
&lt;span&gt;11&lt;/span&gt;     &amp;lt;option selected=&quot;selected&quot;&amp;gt;Multiple&amp;lt;/option&amp;gt;
&lt;span&gt;12&lt;/span&gt;     &amp;lt;option&amp;gt;Multiple2&amp;lt;/option&amp;gt;
&lt;span&gt;13&lt;/span&gt;     &amp;lt;option selected=&quot;selected&quot;&amp;gt;Multiple3&amp;lt;/option&amp;gt;
&lt;span&gt;14&lt;/span&gt;   &amp;lt;/select&amp;gt;&amp;lt;br /&amp;gt;
&lt;span&gt;15&lt;/span&gt;   &amp;lt;input type=&quot;checkbox&quot; name=&quot;check&quot; value=&quot;check1&quot; /&amp;gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  check1
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   &amp;lt;input type=&quot;checkbox&quot; name=&quot;check&quot; value=&quot;check2&quot; checked=&quot;checked&quot; /&amp;gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  check2
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   &amp;lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;radio1&quot; checked=&quot;checked&quot; /&amp;gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  radio1
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   &amp;lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;radio2&quot; /&amp;gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;  radio2
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;   &amp;lt;/form&amp;gt;
&lt;span&gt;24&lt;/span&gt;   &amp;lt;script src=&quot;js/jQTest.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt;25&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;3、serializeArray()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　序列化表单内容，返回 JSON 数据结构数据。&lt;/p&gt;
&lt;p&gt;　　返回值  jQuery&lt;/p&gt;
&lt;p&gt;　　参数&lt;/p&gt;
&lt;p&gt;　　序列化表单内容为JSON ，用于 Ajax 请求。&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; $(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; fields = $(&quot;select, :radio&quot;).serializeArray(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;序列化表单select和raido为json&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   jQuery.each(fields, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i, field) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     $(&quot;#results&quot;).append(field.value + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;  }); 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jQuery封装好的ajax函数用起来确实方便，有了这样的“神兵利器”，以后写ajax的应用程序肯定会更加得心应手。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 06:31:00 +0000</pubDate>
<dc:creator>左逸枫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuoyifeng/p/7844211.html</dc:identifier>
</item>
<item>
<title>深入探讨List中的一个姿势。 - YamatAmain</title>
<link>http://www.cnblogs.com/YamatAmain/p/7844141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YamatAmain/p/7844141.html</guid>
<description>&lt;h2 id=&quot;距离上一篇博文差不多两年了终于憋出来了一篇手动滑稽&quot;&gt;距离上一篇博文，差不多两年了。终于憋出来了一篇。[手动滑稽]&lt;/h2&gt;
&lt;p&gt;List&amp;lt;&amp;gt;是c#中很常见的一种集合形式，近期在阅读c#源码时，发现了一个很有意思的定义：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    [DebuggerTypeProxy(typeof(Mscorlib_CollectionDebugView&amp;lt;&amp;gt;))]
    [DebuggerDisplay(&quot;Count = {Count}&quot;)]
    [Serializable]
    public class List&amp;lt;T&amp;gt; : IList&amp;lt;T&amp;gt;, System.Collections.IList, IReadOnlyList&amp;lt;T&amp;gt;
    {
        private const int _defaultCapacity = 4;
 
        private T[] _items;
        [ContractPublicPropertyName(&quot;Count&quot;)]
        private int _size;
        private int _version;
        [NonSerialized]
        private Object _syncRoot;
        
        static readonly T[]  _emptyArray = new T[0];        
            
        // Constructs a List. The list is initially empty and has a capacity
        // of zero. Upon adding the first element to the list the capacity is
        // increased to 16, and then increased in multiples of two as required.
        public List() {
            _items = _emptyArray;
        }
    }
    ...
    ...
    ...
    private void EnsureCapacity(int min) {
        if (_items.Length &amp;lt; min) {
            int newCapacity = _items.Length == 0? _defaultCapacity : _items.Length * 2;
            if ((uint)newCapacity &amp;gt; Array.MaxArrayLength) newCapacity = Array.MaxArrayLength;
            if (newCapacity &amp;lt; min) newCapacity = min;
            Capacity = newCapacity;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;咦，_defaultCapacity = 4， _items.Length * 2。抱着怀疑的态度，有了以下这一篇文章。&lt;/p&gt;
&lt;h3 id=&quot;defaultcapacity4&quot;&gt;defaultCapacity=4？&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;带着怀疑的态度，我们新建一个Console程序，Debug一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var list = new List&amp;lt;int&amp;gt;();
Console.WriteLine(list.Capacity);&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;运行结果：&lt;br/&gt;图片：&lt;img src=&quot;http://images2017.cnblogs.com/blog/325947/201711/325947-20171116141841624-2134579348.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;...怎么是0呢？一定是我打开的姿势不对，再看一下源码。发现：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static readonly T[]  _emptyArray = new T[0];
...
...
public List() {
     _items = _emptyArray;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哦，这就对了，初始化时候当然是0。那这个_defaultCapacity有何用？继续看源码。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; if (_items.Length &amp;lt; min) {
    int newCapacity = _items.Length == 0? _defaultCapacity : _items.Length * 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现这个三元表达式，为什么要这样做呢？翻了一下google，发现了这样一段文字：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;List实例化一个List对象时，Framework只是在内存中申请了一块内存存放List对象本身，系统此时并不知道List会有多少个item元素及元素本身大小。当List添加了第一个item时，List会申请能存储4个item元素的存储空间，此时Capacity是4，当我们添加第五个item时，此时的Capacity就会变成8。也就是当List发现元素的总数大于Capacity数量时，会主动申请且重新分配内存，每次申请的内存数量是之前item数量的两倍。然后将之前所有的item元素复制到新内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的测试，Capacity=0已经证明了上述这段话的&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;List实例化一个List对象时，Framework只是在内存中申请了一块内存存放List对象本身，系统此时并不知道List会有多少个item元素及元素本身大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们证明&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当List添加了第一个item时，List会申请能存储4个item元素的存储空间，此时Capacity是4&lt;br/&gt;图片：&lt;img src=&quot;http://images2017.cnblogs.com/blog/325947/201711/325947-20171116141859546-1303504693.jpg&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RT，接下来，我们证明&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们添加第五个item时，此时的Capacity就会变成8。&lt;br/&gt;图片：&lt;img src=&quot;http://images2017.cnblogs.com/blog/325947/201711/325947-20171116141910281-665860264.jpg&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RT，的确是这样。&lt;br/&gt;那是否我们得出一个结论，因为不定长的List在Add的时候，频繁的重新申请、分配内存、复制到新内存，效率是否还可以再提升一下呢？&lt;br/&gt;我们先试一下&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;for (int i = 0; i &amp;lt; count; i++)
{
    var listA = new List&amp;lt;int&amp;gt;(10);
    listA.Add(i);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;144&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;23&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;49&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;45&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;73&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;9&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;21&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;10&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;22&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;运行结果：注定长为0表示未设置List长度&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;10000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3741&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;10000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3934&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;10000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;4258&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;10000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;4013&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;10000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;4830&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;10000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;9&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;4159&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;10000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;10&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2370&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;好吃鲸...为啥9和10差距这么多。。。&lt;br/&gt;我们加大循环次数。结果：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1000000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;317590&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1000000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;263378&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1000000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;150444&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1000000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;157317&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1000000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;139041&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1000000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;9&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;124714&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1000000&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;10&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;120547&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;随着循环次数、定长的增加，可以看出，&lt;strong&gt;频繁的重新申请、分配内存、复制到新内存，是很耗费时间和性能的。&lt;/strong&gt;&lt;br/&gt;在以后的工作中，如果有频繁的List.Add,特别是循环Add，不妨考虑一下给List设置一个定长。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 06:20:00 +0000</pubDate>
<dc:creator>YamatAmain</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YamatAmain/p/7844141.html</dc:identifier>
</item>
<item>
<title>Visual Studio的调试技巧 - asml</title>
<link>http://www.cnblogs.com/DragonStart/p/7843977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DragonStart/p/7843977.html</guid>
<description>&lt;p&gt;调试技巧是衡量程序员水平的一个重要指标.掌握好的调试技巧与工具的使用方法,也是非常重要的.&lt;br/&gt;***&lt;/p&gt;

&lt;p&gt;VS2017&lt;br/&gt;C#&lt;br/&gt;***&lt;/p&gt;

&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Program
{
    private static int data
    {
        get;
        set;
    } = 0;
        
    public static void Main(string[] argv)
    {
        data = 10;
        new Thread(new ThreadStart(T1)) { IsBackground = true }.Start();
        new Thread(new ThreadStart(T2)) { IsBackground = true }.Start();
        Console.ReadKey(true);
    }
    private static int DataA
    {
        get;
        set;
    } = 0;
    private static int DataB = 0;
    private static void T1()
    {
        while (true)
        {
            DataA += 1;
            Thread.Sleep(1000);
        }
    }
    private static void T2()
    {
        while (true)
        {
            DataB += 1;
            Thread.Sleep(1000);
        }
    }
}//End Class&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;这是最基本的操作了,想必大伙都会了...&lt;br/&gt;我们可以点击编辑器的这个地方:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201711/481370-20171116104544562-1658859397.png&quot;/&gt;&lt;br/&gt;给代码添加一个断点,这样当代码执行到这里的时候就会挂起进程,此时代码会暂停执行,并等待用户操作.&lt;/p&gt;
&lt;h2 id=&quot;如何继续&quot;&gt;如何继续?&lt;/h2&gt;
&lt;p&gt;可按以下快捷键其中一个来实现继续:&lt;br/&gt;F5(继续执行,直到再次遇到断点,或者按Ctrl+Alt+Break键强行中断)&lt;br/&gt;F10(步过,继续执行,但是到下一行又会挂起,不管下一行有没有断点)&lt;br/&gt;F11(步入,和步过同效,但如果当前挂起位置是一个函数的话,下一步会进到函数里)&lt;br/&gt;Shift+F11(步出,执行到当前函数返回)&lt;/p&gt;
&lt;h2 id=&quot;挂起的生效范围&quot;&gt;挂起的生效范围&lt;/h2&gt;
&lt;p&gt;这个挂起,是对整个进程生效的,也就是说所有线程都会暂停.&lt;br/&gt;挂起状态:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201711/481370-20171116112248531-1804153780.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在挂起的时候能做的事&quot;&gt;在挂起的时候能做的事&lt;/h2&gt;
&lt;h3 id=&quot;查看或修改变量的值&quot;&gt;查看或修改变量的值&lt;/h3&gt;
&lt;p&gt;如同图中那样,当鼠标指针指向变量名的时候,可以查看或修改该变量的值,修改完要按回车确认.&lt;br/&gt;该操作仅限当前位置作用域内的变量.&lt;/p&gt;
&lt;h3 id=&quot;控制线程下一步要执行的代码位置&quot;&gt;控制线程下一步要执行的代码位置&lt;/h3&gt;
&lt;p&gt;看图中左边的小箭头,其实是能拖动的!可以把他往上或往下拖,从而改变线程下一步要执行的代码位置,但是有两点要注意:&lt;br/&gt;1:位置改变了,但是操作过的变量值不会改变,所以别指望能用来倒退已经执行过的操作.&lt;br/&gt;2:改变是有范围的,不能跳到别的函数,就算是局部函数,也不能跳到外面.&lt;/p&gt;

&lt;p&gt;有时候代码执行到某地方,某个变量就会被莫名其妙的改了.这时候我们需要找出来是哪里改了这个变量.&lt;br/&gt;VS有提供一个叫做[数据断点]的东西,但那个只支持native类的语言,C#是不行的.&lt;br/&gt;但有个不是很完美的方法:&lt;br/&gt;我们可以给目标变量加上get;set;访问器,然后在上面加断点,看开头的代码:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static int data
{
    get;
    set;
} = 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201711/481370-20171116114248156-377880373.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候按住Ctrl键不放,接着连续按D T键,就能呼出调用堆栈窗口,看是哪里在尝试修改这个变量,也可以按Shift+F11,执行到返回,这样就能直接跳到修改这个变量的代码:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201711/481370-20171116114525827-331955296.png&quot;/&gt;&lt;br/&gt;说这个方法不完美是因为它对没有代码的其它dll里的全局变量无法使用.&lt;/p&gt;
&lt;h2 id=&quot;给断点加条件&quot;&gt;给断点加条件&lt;/h2&gt;
&lt;p&gt;当我们在循环里打断点的时候,断点会被循环触发,这样调试起来就很麻烦了,我们可以给断点加条件,让断点满足条件才触发.&lt;br/&gt;按住Ctrl键不放,接着连续按D B键,能看到所有断点的列表.&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201711/481370-20171116115728093-868631051.png&quot;/&gt;&lt;br/&gt;在目标断点按下鼠标右键,在菜单里选择设置.可进入断点设置界面:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201711/481370-20171116115906015-1562629491.png&quot;/&gt;&lt;br/&gt;给条件打上勾.可看到有三种条件模板,三个模板可相与(居然不能相或...)&lt;/p&gt;
&lt;h2 id=&quot;条件表达式&quot;&gt;条件表达式:&lt;/h2&gt;
&lt;p&gt;可以输入一条表达式,以表达式的结果决定是否触发,表达式参数可以是当前断点作用域内的变量或常量,判断方式有两种:&lt;br/&gt;表达式结果返回true时触发&lt;br/&gt;表达式结果变化时触发(只支持bool类型结果)&lt;br/&gt;提醒:如果想要在返回false的情况下触发,可以把表达式改为: !(表达式)&lt;/p&gt;
&lt;h2 id=&quot;命中次数&quot;&gt;命中次数:&lt;/h2&gt;
&lt;p&gt;代码执行过断点次数达到一定次数才触发,这个模版分为三种类型:&lt;br/&gt;等于:执行过第x次触发断点&lt;br/&gt;大于等于:执行过第x次以及之后都触发&lt;br/&gt;倍数于:代码执行过x的倍数次时触发断点&lt;/p&gt;
&lt;h2 id=&quot;筛选器&quot;&gt;筛选器:&lt;/h2&gt;
&lt;p&gt;可根据线程ID,线程名,进程ID,进程名,机器名,等条件决定是否断下线程.各条件之间可进行逻辑操作&lt;br/&gt;******&lt;/p&gt;

&lt;p&gt;按住Ctrl键不放,接着连续按D T键,能显示[线程]窗口,可从中看到当前调试进程的所有线程.&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201711/481370-20171116112919077-1863788604.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;查看所有线程当前位置&quot;&gt;查看所有线程当前位置&lt;/h2&gt;
&lt;p&gt;点菜单栏的这个地方,能显示所有线程挂起时的位置:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201711/481370-20171116113000140-1867086615.png&quot;/&gt;&lt;br/&gt;效果如下:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201711/481370-20171116113143859-577003267.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;冻结一个线程&quot;&gt;冻结一个线程&lt;/h2&gt;
&lt;p&gt;这时候我们可以单独冻结一个线程,让这个线程被单独挂起,其它线程继续调试,选择线程,然后点这里:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201711/481370-20171116113456452-683103278.png&quot;/&gt;&lt;br/&gt;如你所见,解冻按钮就在旁边...&lt;br/&gt;线程被冻结后,就会被单独挂起,直到解冻才继续执行.&lt;/p&gt;
&lt;h2 id=&quot;切换线程&quot;&gt;切换线程&lt;/h2&gt;
&lt;p&gt;如果当前挂起的线程不是自己要调试的线程,可以在这里切换到别的线程:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/481370/201711/481370-20171116114848187-603257772.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 05:52:00 +0000</pubDate>
<dc:creator>asml</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DragonStart/p/7843977.html</dc:identifier>
</item>
<item>
<title>[认证授权] 5.OIDC（OpenId Connect）身份认证授权（扩展部分） - Blackheart</title>
<link>http://www.cnblogs.com/linianhui/p/openid-connect-extension.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linianhui/p/openid-connect-extension.html</guid>
<description>&lt;p&gt;在上一篇&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-core.html&quot; target=&quot;_blank&quot;&gt;[认证授权] 4.OIDC（OpenId Connect）身份认证授权（核心部分）&lt;/a&gt;中解释了OIDC的核心部分的功能，即OIDC如何提供id token来用于认证。由于OIDC是一个协议族，如果只是简单的只关注其核心部分其实是不足以搭建一个完整的OIDC服务的。本篇则解释下OIDC中比较常用的几个相关扩展协议，可以说是搭建OIDC服务必备的几个扩展协议（在上一篇中有提到这几个协议规范）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://openid.net/specs/openid-connect-discovery-1_0.html&quot; target=&quot;_blank&quot;&gt;Discovery&lt;/a&gt;：可选。发现服务，使客户端可以动态的获取OIDC服务相关的元数据描述信息（比如支持那些规范，接口地址是什么等等）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html&quot; target=&quot;_blank&quot;&gt;OAuth 2.0 Multiple Response Types&lt;/a&gt; ：可选。针对OAuth2的扩展，提供几个新的response_type。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html&quot; target=&quot;_blank&quot;&gt;OAuth 2.0 Form Post Response Mode&lt;/a&gt;：可选。针对OAuth2的扩展，OAuth2回传信息给客户端是通过URL的querystring和fragment这两种方式，这个扩展标准提供了一基于form表单的形式把数据post给客户端的机制。&lt;/li&gt;
&lt;li&gt;会话管理：&lt;a href=&quot;http://openid.net/specs/openid-connect-session-1_0.html&quot; target=&quot;_blank&quot;&gt;Session Management&lt;/a&gt; &lt;span class=&quot;Apple-converted-space&quot;&gt;：可选。Session管理，用于规范OIDC服务如何管理Session信息；&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;a href=&quot;http://openid.net/specs/openid-connect-frontchannel-1_0.html&quot; target=&quot;_blank&quot;&gt;Front-Channel Logout&lt;/a&gt;：可选。基于前端的注销机制。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;顾名思义，Discovery定义了一个服务发现的规范，它定义了一个api（ &lt;span class=&quot;cnblogs_code&quot;&gt;/.well-known/openid-configuration&lt;/span&gt; ），这个api返回一个json数据结构，其中包含了一些OIDC中提供的服务以及其支持情况的描述信息，这样可以使得oidc服务的RP可以不再硬编码OIDC服务接口信息。这个api返回的&lt;strong&gt;示例信息&lt;/strong&gt;如下（这里面只是一部分，更完整的信息在官方的规范中有详细的描述和解释说明：&lt;a href=&quot;http://openid.net/specs/openid-connect-discovery-1_0.html&quot; target=&quot;_blank&quot;&gt;http://openid.net/specs/openid-connect-discovery-1_0.html&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201711/168328-20171116110603468-231295331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相信大家都看得懂的，它包含有授权的url，获取token的url，注销token的url，以及其对OIDC的扩展功能支持的情况等等信息，这里就不再详细解释每一项了。&lt;/p&gt;

&lt;p&gt;在本系列的第一篇博客&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/oauth2-authorization.html&quot; target=&quot;_blank&quot;&gt;[认证授权] 1.OAuth2授权&lt;/a&gt;中解释OAuth2的授权请求的时候，其请求参数中有一个 &lt;span class=&quot;cnblogs_code&quot;&gt;response_type&lt;/span&gt; 的参数，其允许的值有 &lt;span class=&quot;cnblogs_code&quot;&gt;code&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;token&lt;/span&gt; 两个，在这两个的基础上，OIDC增加了一个新值 &lt;span class=&quot;cnblogs_code&quot;&gt;id_token&lt;/span&gt; （详细信息定义在&lt;a href=&quot;http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html&quot; target=&quot;_blank&quot;&gt;http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html&lt;/a&gt;）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;code：oauth2定义的。用于获取authorization_code。&lt;/li&gt;
&lt;li&gt;token：oauth2定义的。用户获取access_token。&lt;/li&gt;
&lt;li&gt;id_token：OIDC定义的。用户获取id_token。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此OIDC是支持三种类型的response_type的，不但如此，OIDC还允许了可以组合这三种类型，即在一个response_type中包含多个值（空格分隔）。比如当参数是这样的时候 &lt;span class=&quot;cnblogs_code&quot;&gt;response_type=id_token token&lt;/span&gt; ，OIDC服务就会把access_token和id_token一并给到调用方。OIDC对这些类型的支持情况体现在上面提到的Discovery服务中返回的&lt;strong&gt;response_types_supported字段&lt;/strong&gt;中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201711/168328-20171116113412843-931273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在oauth2的授权码流程中，当response_type设置为code的时候，oauth2的授权服务会把authorization_code通过url的query部分传递给调用方，比如这样“https://client.lnh.dev/oauth2-callback&lt;strong&gt;?&lt;/strong&gt;code=SplxlOBeZQQYbYS6WxSbIA&amp;amp;state=xyz”。&lt;/p&gt;
&lt;p&gt;在oauth2的隐式授权流程中，当response_type设置为token的时候，oauth2的授权服务会直接把access_token通过url的fragment部分传递给调用方，比如这样“http://client.lnh.dev/oauth2-callback&lt;strong&gt;#&lt;/strong&gt;access_token=2YotnFZFEjr1zCsicMWpAA&amp;amp;state=xyz&amp;amp;expires_in=3600”；&lt;/p&gt;
&lt;p&gt;在oauth2中，上面的两种情况是其默认行为，并没有通过参数来显示的控制。OIDC在保持oauth2的默认行为的基础上，增加了一个名为&lt;strong&gt;response_mode&lt;/strong&gt;的参数，并且增加了一种通过form表单传递信息的方式，即form_post（详细信息定义在&lt;a href=&quot;http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html&quot; target=&quot;_blank&quot;&gt;http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html&lt;/a&gt;）。OIDC服务对这个扩展的支持情况体现在上面提到的Discovery服务中返回的&lt;strong&gt;response_modes_supported字段&lt;/strong&gt;中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201711/168328-20171116115439265-1599392306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当reponse_mode设置为form_post的时候，OIDC则会返回如下的信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Submit This Form&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;onload&lt;/span&gt;&lt;span&gt;=&quot;javascript:document.forms[0].submit()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt; action&lt;/span&gt;&lt;span&gt;=&quot;https://client.lnh.dev/oidc-callback&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;state&quot;&lt;/span&gt;&lt;span&gt;
       value&lt;/span&gt;&lt;span&gt;=&quot;DcP7csa3hMlvybERqcieLHrRzKBra&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;id_token&quot;&lt;/span&gt;&lt;span&gt;
       value&lt;/span&gt;&lt;span&gt;=&quot;eyJhbGciOiJSUzI1NiIsImtpZCI6IjEifQ.eyJzdWIiOiJqb2huIiw
         iYXVkIjoiZmZzMiIsImp0aSI6ImhwQUI3RDBNbEo0c2YzVFR2cllxUkIiLC
         Jpc3MiOiJodHRwczpcL1wvbG9jYWxob3N0OjkwMzEiLCJpYXQiOjEzNjM5M
         DMxMTMsImV4cCI6MTM2MzkwMzcxMywibm9uY2UiOiIyVDFBZ2FlUlRHVE1B
         SnllRE1OOUlKYmdpVUciLCJhY3IiOiJ1cm46b2FzaXM6bmFtZXM6dGM6U0F
         NTDoyLjA6YWM6Y2xhc3NlczpQYXNzd29yZCIsImF1dGhfdGltZSI6MTM2Mz
         kwMDg5NH0.c9emvFayy-YJnO0kxUNQqeAoYu7sjlyulRSNrru1ySZs2qwqq
         wwq-Qk7LFd3iGYeUWrfjZkmyXeKKs_OtZ2tI2QQqJpcfrpAuiNuEHII-_fk
         IufbGNT_rfHUcY3tGGKxcvZO9uvgKgX9Vs1v04UaCOUfxRjSVlumE6fWGcq
         XVEKhtPadj1elk3r4zkoNt9vjUQt9NGdm1OvaZ2ONprCErBbXf1eJb4NW_h
         nrQ5IKXuNsQ1g9ccT5DMtZSwgDFwsHMDWMPFGax5Lw6ogjwJ4AQDrhzNCFc
         0uVAwBBb772-86HpAkGWAKOK-wTC6ErRTcESRdNRe0iKb47XRXaoz5acA&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个会在html加载完毕后，通过一个自动提交的form表单，把id_token，access_token，authorization_code或者其他的相关数据POST到调用方指定的回调地址上。&lt;/p&gt;

&lt;p&gt;综合上篇提到的idtoken和前面的discovery服务以及针对oauth2的扩展，则可以让OIDC服务的RP完成用户认证的过程。那么如何主动的撤销这个认证呢（也就是我们常说的退出登录）？总结来说就是其认证的会话管理，OIDC单独定义了3个独立的规范来完成这件事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://openid.net/specs/openid-connect-session-1_0.html&quot; target=&quot;_blank&quot;&gt;Session Management&lt;/a&gt; &lt;span class=&quot;Apple-converted-space&quot;&gt;：可选。Session管理，用于规范OIDC服务如何管理Session信息。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;a href=&quot;http://openid.net/specs/openid-connect-frontchannel-1_0.html&quot; target=&quot;_blank&quot;&gt;Front-Channel Logout&lt;/a&gt;：可选。基于前端的注销机制。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;a href=&quot;http://openid.net/specs/openid-connect-backchannel-1_0.html&quot; target=&quot;_blank&quot;&gt;Back-Channel Logout&lt;/a&gt;：可选。基于后端的注销机制。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;其中Session Management是OIDC服务自身管理会话的机制；Back-Channel Logout则是定义在纯后端服务之间的一种注销机制，应用场景不多，这里也不详细解释了。这里重点关注一下Front-Channel Logout这个规范（&lt;a href=&quot;http://openid.net/specs/openid-connect-frontchannel-1_0.html&quot; target=&quot;_blank&quot;&gt;http://openid.net/specs/openid-connect-frontchannel-1_0.html&lt;/a&gt;），它的使用最为广泛，其工作的具体的流程如下（&lt;span class=&quot;Apple-converted-space&quot;&gt;结合Session Management规范）&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201711/168328-20171116130533093-2130179831.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在上图中的2和3属于session management这个规范的一部。其中第2步中，odic的退出登录的地址是通过Discovery服务中返回的&lt;strong&gt;end_session_endpoint字段&lt;/strong&gt;提供的RP的。其中还有一个&lt;strong&gt;check_session_iframe字段&lt;/strong&gt;则是供纯前端的js应用来检查oidc的登录状态用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201711/168328-20171116131454890-1348809127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4567这四步则是属于front-channel logout规范的一部分，OIDC服务的支持情况在Discovery服务中也有对应的字段描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201711/168328-20171116134555890-742505552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4567这一部分中重点有两个信息：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RP退出登录的URL地址（这个在RP注册的时候会提供给OIDC服务）；&lt;/li&gt;
&lt;li&gt;URL中的sessionid这个参数，这个参数一般是会包含在idtoken中给到OIDC客户端，或者在认证完成的时候以一个独立的sessionid的参数给到OIDC客户端，通常来讲都是会直接把它包含在IDToken中以防止被篡改。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;本篇博客介绍了OIDC的发现服务，OAuth2的两个扩展规范，以及OIDC管理会话的机制。至此则可以构成一个完整的认证和退出的流程。其中有一点需要特别注意，这个流程中用到的token是OIDC定义的&lt;strong&gt;IDToken&lt;/strong&gt;，&lt;strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;IDToken&lt;/span&gt;&lt;/strong&gt;，&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;IDToken&lt;/strong&gt;（重要要的事情说三遍），而不是OAuth2中定义的Access Token，千万不要混淆这两者，它们是有着本质的区别的（这一点在&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/authentication-based-on-oauth2.html&quot; target=&quot;_blank&quot;&gt;[认证授权] 3.基于OAuth2的认证（译）&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-core.html&quot; target=&quot;_blank&quot;&gt;[认证授权] 4.OIDC（OpenId Connect）身份认证授权（核心部分）&lt;/a&gt;中都有解释）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;笔者基于IdentityServer3和IdentitySever4（两者都是基于OIDC的一个.NET版本的开源实现）写的一个集成SSO，API访问授权控制，QQ联合登陆（作为OP）的demo：&lt;a href=&quot;https://github.com/linianhui/oidc.example&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/oidc.example 。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;oidc ： &lt;a href=&quot;http://openid.net/connect/&quot; target=&quot;_blank&quot;&gt;http://openid.net/connect/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;oidc - discovery ：&lt;a href=&quot;http://openid.net/specs/openid-connect-discovery-1_0.html&quot; target=&quot;_blank&quot;&gt;http://openid.net/specs/openid-connect-discovery-1_0.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;oauth2 - multiple-response-types ：&lt;a href=&quot;http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html&quot; target=&quot;_blank&quot;&gt;http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;oauth2 - form-post-response-mode ：&lt;a href=&quot;http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html&quot; target=&quot;_blank&quot;&gt;http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;oidc - session-menagement ：&lt;a href=&quot;http://openid.net/specs/openid-connect-session-1_0.html&quot; target=&quot;_blank&quot;&gt;http://openid.net/specs/openid-connect-session-1_0.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;oidc - front-channel-logout ：&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;a href=&quot;http://openid.net/specs/openid-connect-frontchannel-1_0.html&quot; target=&quot;_blank&quot;&gt;http://openid.net/specs/openid-connect-frontchannel-1_0.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 16 Nov 2017 05:39:00 +0000</pubDate>
<dc:creator>Blackheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linianhui/p/openid-connect-extension.html</dc:identifier>
</item>
<item>
<title>【Kafka源码】KafkaConsumer - 端木轩</title>
<link>http://www.cnblogs.com/f-zhao/p/7843883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-zhao/p/7843883.html</guid>
<description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;KafkaConsumer是从kafka集群消费消息的客户端。这是kafka的高级消费者，而SimpleConsumer是kafka的低级消费者。何为高级？何为低级？&lt;/p&gt;
&lt;p&gt;我们所谓的高级，就是可以自动处理kafka集群的失败信息，也可以适应kafka集群中消息的分区迁移。这个客户端也可以与服务端进行交互，使用消费者分组负载平衡消费，下面我们具体会讲解。&lt;/p&gt;
&lt;p&gt;消费者与对应的broker保持TCP连接，来获取数据。使用完成后关闭消费者连接失败，会泄露连接。这个消费者不是线程安全的。&lt;/p&gt;

&lt;p&gt;Kafka在分区中为每条记录维护了一个数字形式的偏移量。这个偏移量是数据在分区中的唯一值，也可以表示为消费者在分区中的偏移量。例如，一个消费者的偏移量为5，表示偏移量为0到4的消息已经被消费过。关于消费者使用的偏移量，有两个比较重要的概念。&lt;/p&gt;
&lt;h2 id=&quot;topicpartition&quot;&gt;1.1 TopicPartition&lt;/h2&gt;
&lt;p&gt;消费者的偏移量表示消费者下一个需要消费的消息的偏移量。这个值会比当前消费者在那个分区刚刚消费的消息偏移量大一。这个值在下面情况下会自动增长：消费者调用了poll(long)并且获取到了消息。&lt;/p&gt;
&lt;h2 id=&quot;committed-position提交偏移量&quot;&gt;1.2 committed position提交偏移量&lt;/h2&gt;
&lt;p&gt;这个committed position表示最新的被安全保存的偏移量。如果当前过程中失败然后重启了，这个是重启后消费的偏移量起点。消费者有三种方式来提交偏移量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自动定时提交&lt;/li&gt;
&lt;li&gt;同步提交。手动提交偏移量，使用的方法是commitSync()，这个方法会一直被阻塞，直到偏移量被成功提交了，或者在提交过程中发生了严重的错误。&lt;/li&gt;
&lt;li&gt;异步提交。使用的方法是commitAsync(OffsetCommitCallback)，在成功或者发生严重错误后，会触发OffsetCommitCallback方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kafka使用消费分组的概念，允许一个处理池来将消费和处理过程分开。这些处理可以在同一台机器上运行，也可以分布在多台机器上，来提供扩展性和容错。&lt;/p&gt;
&lt;p&gt;每个Kafka消费者都可以配置自己所属的消费分组，并且可以通过接口subscribe(Collection, ConsumerRebalanceListener)动态设置订阅的主题。Kafka会把每条消息传递到分组中的某个运行过程。这是通过平衡消费分组中的每个消费者对应的分区来实现的，最终实现的是每个分组正好被分配到分组的某个消费者。所以如果一个主题有4个分区，一个消费分组有两个消费者process，每个process会消费两个分区。&lt;/p&gt;
&lt;p&gt;消费分组中的成员是动态的：如果某个process挂了，分配给他的分区会被分到组中其他的process。类似的，如果一个新的消费者加入了分组，分区会迁移到新的分组上。这被称为分组平衡。需要注意的是，当订阅的主题中新的分区出现的时候，相同的情况也会出现：分组不断地检测新的分区，平衡分组，最终每个分区都被分配到某个组成员上。&lt;/p&gt;
&lt;p&gt;概念上，你可以把消费分组想象成一个单独的逻辑上的消费者，恰巧有多个消费进程。作为一个多订阅的系统，kafka天然支持某个主题有多个消费分组，而数据不会重复。&lt;/p&gt;
&lt;p&gt;这些功能对于一个消息系统来说很普通。和传统的消息队列不同，你可以同时有很多的分组。在传统消息系统中，每个消费者都会有自己的消费分组，所以每个消费者会订阅主题下的所有记录，也就是会收到所有的消息。&lt;/p&gt;
&lt;p&gt;而且，当分组重新分配自动出现时，会通过ConsumerRebalanceListener通知消费者，然后消费者自身处理一些应用级的逻辑，比如状态清除，手动提交offset等等。&lt;/p&gt;
&lt;p&gt;对消费者来说，还可以手动分配分区，使用的方法是assign（类似于SimpleConsumer）。在这种情况下，动态分区调整和消费分组协调功能会被禁用。&lt;/p&gt;

&lt;p&gt;订阅一批主题之后，消费者在调用poll的时候，会自动加入分组。poll是用于确保消费者的存活。只要消费者不停地调用poll，那么他就会一直存在于分组中，并且不断地收到对应分区推送给他的消息。另外，poll方法也会定时发送心跳给服务端，当你停止调用poll时，心跳也会停止。如果server超过session.timeout时间没有收到心跳，消费者会被踢出分组，分区也会重新分配。这是为了防止消费者挂掉之后，还占用分区的情况发生（这种情况下分组中的其他消费者无法消费到消息）。为了继续存在于分组中，消费者必须调用poll方法证明还活着。&lt;/p&gt;
&lt;p&gt;这个设计的目的还在于，一个poll循环中的消息处理过程的时间必须是有界的，那样心跳才能在session.timeout之前发出去。消费者提供两个配置来控制这种行为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;session.timeout.ms：通过增加这个值，消费者可以有更多的时间来处理poll返回的一批消息。唯一的缺点就是服务端要耗费更多的时间来检测消费者是否存活，这可能会导致分组平衡的延迟。然后，这不会影响close方法的调用，因为一旦调用了这个方法，消费者会发送一个明确的消息给服务端，离开分组，分组平衡会被立即触发。&lt;/li&gt;
&lt;li&gt;max.poll.records：一个poll循环的处理时间应该和消息的数量成正比。所以应该设置一次最多处理多少条数据。默认情况下，这个值没有限制消息的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当前消费客户端提供了多种方法来消费，下面是几个例子。&lt;/p&gt;
&lt;h2 id=&quot;自动提交automatic-offset-committing&quot;&gt;3.1 自动提交Automatic Offset Committing&lt;/h2&gt;
&lt;p&gt;这个方法说明了kafka消费客户端的简单使用，依赖于自动提交offset。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Properties props = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Properties();
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;bootstrap.servers&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;localhost:9092&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;group.id&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;test&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;enable.auto.commit&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;auto.commit.interval.ms&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;1000&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;session.timeout.ms&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;30000&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;key.deserializer&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;value.deserializer&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;/span&gt;);
KafkaConsumer&amp;lt;String, String&amp;gt; consumer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; KafkaConsumer&amp;lt;&amp;gt;(props);
consumer.&lt;span class=&quot;fu&quot;&gt;subscribe&lt;/span&gt;(Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;bar&quot;&lt;/span&gt;));
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) {
    ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;String, String&amp;gt; record : records)
        System.&lt;span class=&quot;fu&quot;&gt;out.printf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;offset = &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;, key = &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;, value = &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, record.&lt;span class=&quot;fu&quot;&gt;offset&lt;/span&gt;(), record.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;(), record.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;());
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置enable.auto.commit表示是自动提交offset，并且提交的频率为auto.commit.interval.ms。服务器可以通过bootstrap.servers来配置，可以不用配置全部的服务器，因为会自动发现集群中所有的服务器。当然不建议只配置一个，因为如果这个挂掉了，就找不到其他的机器了。&lt;/p&gt;
&lt;p&gt;反序列化配置表示如何把二进制消息转换为消息对象。例如，使用string反序列化，表示消息的key和value都是字符串。&lt;/p&gt;
&lt;h2 id=&quot;手动提交偏移量manual-offset-control&quot;&gt;3.2 手动提交偏移量Manual Offset Control&lt;/h2&gt;
&lt;p&gt;与自动提交不同，我们可以通过配置来控制消息什么时候消费完成，并提交偏移量。在一条消息需要多个任务处理，所有任务完成后才能提交偏移量的场景下，需要手动提交。在下面的例子中，我们会一次消费一批数据，然后把他们放到内存中，当消息达到一定的数量时，我们会把他们插入数据库中。如果这种情况下，我们配置为自动提交，那么就会出现消息被消费，但是实际上并没有插入到数据库的情况。为了避免这种情况，我们必须在消息插入数据库之后，手动提交偏移量。这也会出现另一种情况，就是消息插入数据库成功，但是在提交偏移量的过程中失败。这种情况下，其他的消费者会继续读取偏移量，然后重新执行批量插入数据库的操作。这么使用的话，kafka提供的是“至少一次”的消息保证，也就是消息至少会被传递一次，但是消费失败的情况下会重复消费。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Properties props = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Properties();
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;bootstrap.servers&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;localhost:9092&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;group.id&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;test&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;enable.auto.commit&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;auto.commit.interval.ms&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;1000&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;session.timeout.ms&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;30000&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;key.deserializer&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;/span&gt;);
props.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;value.deserializer&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;/span&gt;);
KafkaConsumer&amp;lt;String, String&amp;gt; consumer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; KafkaConsumer&amp;lt;&amp;gt;(props);
consumer.&lt;span class=&quot;fu&quot;&gt;subscribe&lt;/span&gt;(Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;bar&quot;&lt;/span&gt;));
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minBatchSize = &lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;;
List&amp;lt;ConsumerRecord&amp;lt;String, String&amp;gt;&amp;gt; buffer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) {
    ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;String, String&amp;gt; record : records) {
        buffer.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(record);
    }
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (buffer.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() &amp;gt;= minBatchSize) {
        &lt;span class=&quot;fu&quot;&gt;insertIntoDb&lt;/span&gt;(buffer);
        consumer.&lt;span class=&quot;fu&quot;&gt;commitSync&lt;/span&gt;();
        buffer.&lt;span class=&quot;fu&quot;&gt;clear&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的例子使用的是同步提交commitSync()方法。在某些情况下，你可能需要对消息消费有更加精确的控制，下面的例子中，我们按照分区提交偏移量。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(running) {
        ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;(Long.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (TopicPartition partition : records.&lt;span class=&quot;fu&quot;&gt;partitions&lt;/span&gt;()) {
            List&amp;lt;ConsumerRecord&amp;lt;String, String&amp;gt;&amp;gt; partitionRecords = records.&lt;span class=&quot;fu&quot;&gt;records&lt;/span&gt;(partition);
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;String, String&amp;gt; record : partitionRecords) {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(record.&lt;span class=&quot;fu&quot;&gt;offset&lt;/span&gt;() + &amp;amp;quot;: &amp;amp;quot; + record.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;());
            }
            &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; lastOffset = partitionRecords.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(partitionRecords.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;offset&lt;/span&gt;();
            consumer.&lt;span class=&quot;fu&quot;&gt;commitSync&lt;/span&gt;(Collections.&lt;span class=&quot;fu&quot;&gt;singletonMap&lt;/span&gt;(partition, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;OffsetAndMetadata&lt;/span&gt;(lastOffset + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)));
        }
    }
} &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
  consumer.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：提交的偏移量应该是下一次消费的消息的偏移量，所以commitSync(offsets)这个方法中的内容，应该是当前消息偏移量加上一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;手动分配分区manual-partition-assignment&quot;&gt;3.3 手动分配分区Manual Partition Assignment&lt;/h2&gt;
&lt;p&gt;前面的例子中，消费者订阅主题，然后服务端动态分配了分区给消费者。在某些情况下，我们需要精确控制消费的分区，例如：&lt;/p&gt;
&lt;p&gt;消费者维护了与分区相关的本地状态（例如本地磁盘键值存储），那么他应该只读取特定分区的数据。如果消费者本身是高可用的，在挂掉之后会自动重启（可能正在使用集群管理框架，比如YARN，Mesos或者AWS，或者作为流式处理框架）。这种情况下，kafka没必要检测消费者的存活，重新分配分区，因为消费进程会在同样的机器上重启。&lt;/p&gt;
&lt;p&gt;为了使用这种模式，我们不能使用subscribe(Collection)，而是应该使用assign(Collection)方法，来指定一批分区。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;String topic = &lt;span class=&quot;st&quot;&gt;&quot;foo&quot;&lt;/span&gt;;                                    
TopicPartition partition0 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;TopicPartition&lt;/span&gt;(topic, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
TopicPartition partition1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;TopicPartition&lt;/span&gt;(topic, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
consumer.&lt;span class=&quot;fu&quot;&gt;assign&lt;/span&gt;(Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(partition0, partition1));  &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种情况下，不会使用到分组协调器，所以消费者挂掉的情况，也不会重新分配分区。所以每个消费者都是独立的，为了避免偏移量提交冲突，每个消费者的分组信息应该是唯一的。&lt;/p&gt;
&lt;h2 id=&quot;在kafka外存储偏移量storing-offsets-outside-kafka&quot;&gt;3.4 在kafka外存储偏移量Storing Offsets Outside Kafka&lt;/h2&gt;
&lt;p&gt;消费者应用可能不想把offset存到kafka中，所以kafka也提供了把offset存储到其他地方的接口。这种情况下，就能自己实现消息只消费一次的场景，比至少一次强很多。那么我们如何使用呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先需要配置enable.auto.commit=false&lt;/li&gt;
&lt;li&gt;使用ConsumerRecord提供的偏移量来存储你的offset&lt;/li&gt;
&lt;li&gt;重启时使用seek(TopicPartition, long)来发现重启前的offset&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种场景在手动分配分区的情况下很简单。如果分区分配是自动的，我们需要特殊处理分区分配改变的情况。这个可以通过提供ConsumerRebalanceListener实例，在调用subscribe(Collection, ConsumerRebalanceListener)和subscribe(Pattern, ConsumerRebalanceListener)时实现。&lt;/p&gt;
&lt;h2 id=&quot;控制消费者位点controlling-the-consumers-position&quot;&gt;3.5 控制消费者位点Controlling The Consumer's Position&lt;/h2&gt;
&lt;p&gt;大多数情况下，消费者会简单的从头到尾消费消息，定时提交位点（自动或手动）。然后，kafka允许消费者手动控制位点，可以设置位点的位置。这意味着消费者可以消费已经消费过的消息，也可以跳过最新的消息。&lt;/p&gt;
&lt;p&gt;kafka可以通过seek(TopicPartition, long)方法来指定消费起点，寻找早的或者新的位点，也可以通过seekToBeginning(Collection)和seekToEnd(Collection)来指定。&lt;/p&gt;
&lt;h2 id=&quot;消费流量控制&quot;&gt;3.6 消费流量控制&lt;/h2&gt;
&lt;p&gt;如果一个消费者被分配到了多个分区，他会尝试同时消费所有的分区，所有的分区的权重一样。然而，在某些情况下，消费者需要首先全速消费某些特定的分区，当这个分区没有消息后再消费其他的分区。&lt;/p&gt;
&lt;p&gt;例如，流式处理。消费者同时从两个主题消费，然后把消息合并。当某个主题落后于另一个主题很多时，消费者应该停止消费快的那个主题，等慢的那个赶上来。再比如，有个主题有很多历史数据需要被消费，这种情况下，消费者应该优先消费那些有最新消息的主题。&lt;/p&gt;
&lt;p&gt;kafka支持动态控制消费流量，通过pause(Collection)和resume(Collection)方法。&lt;/p&gt;

&lt;p&gt;kafka消费者不是线程安全的。所有的网络IO操作都在发起调用的一个线程中执行。他需要保证多线程时的线程安全。不同的操作会引起ConcurrentModificationException。&lt;/p&gt;
&lt;p&gt;我们在外部线程中可以调用wakeup()方法来停止当前的操作。这种情况下，可能会从阻塞操作的线程抛出org.apache.kafka.common.errors.WakeupException异常。这可以用于在另一个线程中停止当前的消费者。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; KafkaConsumerRunner &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; AtomicBoolean closed = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; AtomicBoolean(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; KafkaConsumer consumer;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            consumer.&lt;span class=&quot;fu&quot;&gt;subscribe&lt;/span&gt;(Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;topic&quot;&lt;/span&gt;));
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (!closed.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;()) {
                ConsumerRecords records = consumer.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;);
                &lt;span class=&quot;co&quot;&gt;// Handle new records&lt;/span&gt;
            }
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (WakeupException e) {
            &lt;span class=&quot;co&quot;&gt;// Ignore exception if closing&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!closed.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;()) &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; e;
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            consumer.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        }
    }

    &lt;span class=&quot;co&quot;&gt;// Shutdown hook which can be called from a separate thread&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;shutdown&lt;/span&gt;() {
        closed.&lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
        consumer.&lt;span class=&quot;fu&quot;&gt;wakeup&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在另一个线程中，可以通过closed标识来关闭或者启动消费者。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 05:30:00 +0000</pubDate>
<dc:creator>端木轩</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-zhao/p/7843883.html</dc:identifier>
</item>
</channel>
</rss>