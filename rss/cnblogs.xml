<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Unity3D游戏xlua轻量级热修复框架 - SChivas</title>
<link>http://www.cnblogs.com/SChivas/p/7893048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SChivas/p/7893048.html</guid>
<description>&lt;p&gt;　　前阵子刚刚集成xlua到项目，目的只有一个：对线上游戏C#逻辑有Bug的地方执行修复，通过考察了xlua和tolua，最终选择了xlua，原因如下：&lt;/p&gt;
&lt;p&gt;　　1）项目已经到了后期，线上版本迭代了好几次，所以引入Lua的目的不是为了开发新版本模块，而是修复旧版本Bug。&lt;/p&gt;
&lt;p&gt;　　2）修复Bug针对的是iOS平台，总所周知，安卓平台是可以通过更新DLL去修复的，而修复Bug直接改写C#代码肯定要比整个函数翻译为Lua来得简单，实际上最后由于xlua注入和我们项目的安卓代码加密流程冲突，我们对安卓保留了原先的热更流程，而对iOS平台才执行xlua热更。&lt;/p&gt;
&lt;p&gt;　　xlua在我们的这种情况下很是适用，如xlua作者所说，用C#开发，用lua热更，xlua这套框架为我们提供了诸多便利，至少我可以说，在面临同样的情况下，你用tolua去做同样的事情是很费心的。同样，在读的各位，如果你是想用xlua做整套客户端游戏逻辑的，这篇文对你可能就没什么借鉴意义了，这里提前打个招呼，毕竟大家时间都有限的，我也不想你读完后才发现我在坑你。其实关于纯lua写游戏逻辑的整套框架，我目前正在开发之中，如果到时候觉得有必要，有时间再适当做做分享。不过，这套正在做的框架我选择了tolua。其实纯lua写逻辑，使用xlua还是tolua并不是那么重要，因为与c#交互会少很多，而且一般都是耗性能的地方才放c#，你一次A*寻路的开销，相比一次lua到c#调用的开销是不知道大到哪里去的，所以即使网上有各种lua框架性能的评测，其实我感觉意义都不太大，如果真要频繁调用，那不管xlua还是tolua你都要考虑方案去优化的。这个话题以后有时间再去展开好了。&lt;/p&gt;
&lt;p&gt;　　当时在做完这个xlua热更框架，我还打算写篇博文分享一下，因为经常看到xlua群里面网友问各种问题，其实原因说起来只有一个，因为大家对xlua集成到项目没有实战经验，你只要尝试过，很多问题都没有想象中的那么困难。后来，由于工作一直比较忙，忙着另外一个游戏的网络同步优化，还有近期正在做的上面说的这套全新的lua框架，这个事情就被搁浅了下来；还有另一层面的原因是因为做完这个框架以后，发现其实大部分都是在熟悉xlua，而自己写的代码少得可伶，感觉也没什么太多要分享的地方。毕竟热修复，本质上来说就是一个轻量级的东西。&lt;/p&gt;
&lt;p&gt;　　最近，趁着周末闲来无事，我又去网上找了下xlua相关的博客、github分享，我不知道你们有做过xlua引入项目进行热修复的人，对这些分享是什么感受，总是，我个人是发现没有一个是我能够得到太多参考价值的，其实这也和xlua的框架特性有关。它的核心理念是C#写逻辑，xlua热修复，除非你是新开的项目，一开始就遵循xlua热更的各种规范。而如果你是后期引入的xlua，那么，xlua热修复代码的复杂度，很大程度上取决于你框架原先c#代码的写法，我这里举一个例子，你们大概就能清楚我到底在说什么：&lt;/p&gt;
&lt;p&gt;　　比如说委托的使用，在c#侧经常作为回调去使用，xlua的demo里对委托的热修复示例是这样的：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Action&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; TestDelegate = (param) =&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Debug.Log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestDelegate in c#:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; param);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TestFunction(Action&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; callback)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     callback(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestCall()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    TestFunction(TestDelegate);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这里相当于把委托定义为了成员变量，那么你在lua侧，如果要热修复TestCall函数，要将这个委托作为回调传递给TestFunction，只需要使用self.TestDelegate就能访问，很简单。而问题就在于，我们项目之前对委托的使用方式是这样的：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestDelegate(String param)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Debug.Log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestDelegate in c#:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; param);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TestFunction(Action&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; callback)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     callback(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestCall()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    TestFunction(TestDelegate);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　那么问题就来了，这个TestDelegate是一个函数，在调用的时候才自动创建了一个临时委托，那么Lua侧，你就没办法简单地去热更了，怎么办？清楚了吧，我说的就是类似这样的一些问题，因为一开始没有考虑过进行xlua热更，所以导致没有明确匹配xlua热更规则的相关代码规范，从而xlua热修复困难。&lt;/p&gt;
&lt;p&gt;　　这个例子可能举得不是太好，你可以暴力修改项目中所有这样写法的地方，可是我很不愿意这样去对旧代码进行大改，不仅工作量大而且还风险大，谁知道会不会为了修复Bug引入另外的Bug，你说是不是？另外，下面的这种写法其实有GC问题，很不推荐，这个问题是项目历史遗留下来的，因为早期开发这个游戏的人并没有注重GC问题，关于GC，后面有时间我再去展开讨论，这里也不再多说。&lt;/p&gt;
&lt;p&gt;　　总之，通过这么一个例子，我首先想要大家弄明白的一点的是这篇博客在讨论什么东西，所以，如果你如果初识xlua框架，也面临同样的境况，那接下来的内容就值得一读。&lt;/p&gt;

&lt;p&gt;　　上面说了，我本来是不打算浪费精力写这篇博客的，但是翻阅了giehub上start排前的几个项目，发现坑不是一般的多，实在是看不下去了，所以才打算提笔写写我遇到过的与解决过的坑。现行所谓xlua分享大多都不着要点，没有直接命中大部分人所面临的问题，初步缺陷有如下几点：&lt;/p&gt;
&lt;p&gt;　　1）体积太重：一些所谓xlua热更框架，集成了各种所谓资源热更新、场景管理、音乐管理、定时器管理等等模块。我要做游戏框架，我不会用你的这些模块；我要做xlua热更，我找不到我想要的东西。&lt;/p&gt;
&lt;p&gt;　　2）避重就轻：有些分享框架，把xlua集成过来，然后自己用NGUI或者UGUI写了个小场景，然后，你看下去发现全是Demo的c#代码，这是什么玩意？&lt;/p&gt;
&lt;p&gt;　　3）不着要点：有些甚至是c#框架+lua框架，我初步浏览也是没看明白xlua在里面到底扮演了什么角色。&lt;/p&gt;
&lt;p&gt;　　有关这些东西，我就不多吐槽了，总之一句话，商用借鉴价值，不大。&lt;/p&gt;

&lt;p&gt;　　与其说是框架，不如说这只是xlua进行热修复的一个演示demo，或者说xlua的一个扩展，对xlua很多没有提供的一些外围功能进行了相关扩展。xlua的设计还是挺不错的，包括整个架构，也保持了简洁性，不带太多多余的东西，包括第三方库这点就可以看出。一个框架的设计理念很重要，什么东西该放进来，什么东西不需要考虑，有取舍才能够简洁，而简洁的东西用起来才清爽。&lt;/p&gt;
&lt;h2&gt;框架工程结构&lt;/h2&gt;
&lt;p&gt;　　我假设你已经清楚了xlua做热修复的流程，包括xlua工作原理，怎么加载lua脚本，怎么去做lua脚本打包和热更，lua热工脚本是怎样的工作流程等内容，因为这些太过基础，我不会讲述太多，如果你不清楚，自己去补补功课。下面给先一张工程截图，让大家有个总体认识：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278213/201711/1278213-20171125013052562-920111818.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;xlua热修复框架工程结构&lt;/p&gt;

&lt;p&gt;　　1）Scripts/xlua/XLuaManager：xlua热修复环境，包括的luastate管理，自定义loader，就这么些东西。&lt;/p&gt;
&lt;p&gt;　　2）Resources/xlua/Main.lua：xlua热修复入口&lt;/p&gt;
&lt;p&gt;　　3）Resources/xlua/Common：提供给lua代码使用的一些工具方法，大部分所遇到的工程问题得到的统一解决方案，都写在这里，提供lua逻辑代码到C#调用的一层封装&lt;/p&gt;
&lt;p&gt;　　4）Scripts/xlua/Util：为xlua的lua脚本提供的C#侧代码支持，被Resources/xlua/Common所使用&lt;/p&gt;
&lt;p&gt;　　5）Scripts/test/HotfixTest：需要热修复的c#脚本，由于时间有限，我并没有去单独写示例，这些都是从项目中抽离出来的脚本，不可运行，只是为了让大家对比热修复的C#代码才放上来的&lt;/p&gt;
&lt;p&gt;　　6）Resources/xlua/HotFix：热修复脚本，同样，无法直接运行，但是大部分问题lua代码都在其中，对比被修复的C#代码，就能抓住要点。&lt;/p&gt;
&lt;p&gt;　　可以看到，很轻量的一个东西，全为xlua做热修复量身定制，没有任何多余的东西。另外，由于时间有限，我并没有把所有自己项目使用到的东西提供出来，刚刚也说了，xlua怎么做热修复，会遇到什么样的问题，和你本身的C#代码有很大关系，而各位自己的项目，肯定有很多东西和我们项目不一样，所以我觉得完全没有必要去弄全。而且，授人鱼不如授人以渔，这里侧重说几点重要的问题，和它们的解决思路，举一反三，大家应该就知道怎么去做好热更了。这里主要说的方向有这么几点：&lt;/p&gt;
&lt;p&gt;　　1）消息系统：打通cs和lua侧的消息系统，其中的关键问题是泛型委托&lt;/p&gt;
&lt;p&gt;　　2）对象创建：怎么样在lua侧创建cs对象，特别是泛型对象&lt;/p&gt;
&lt;p&gt;　　3）迭代器：cs侧列表、字典之类的数据类型，怎样在lua侧泛型迭代&lt;/p&gt;
&lt;p&gt;　　4）协程：cs侧协程怎么热更，怎么在lua侧创建协程&lt;/p&gt;
&lt;p&gt;　　5）委托作为回调：cs侧函数用作委托回调当作函数调用时的形参时，怎样在lua侧传递委托形参&lt;/p&gt;
&lt;p&gt;　　Scripts/xlua/Util与Resources/xlua/Common这两个目录下的脚本，基本上来说，已经很好的说明了怎么样针对自己项目的具体情况对xlua进行扩展，虽然这里的脚本不是面面俱到，但是这里组织的结构我想应该是可以适应大多数问题的解决方式的。下面就上面几点着重分析一下。&lt;/p&gt;
&lt;h2&gt;lua侧cs泛型对象创建&lt;/h2&gt;
&lt;p&gt;　　先从简单的说起，对象创建xlua给的例子很简单，直接new CS.XXX就好，但是如果你要创建一个泛型List对象，比如List&amp;lt;string&amp;gt;，要怎么弄？你可以为List&amp;lt;sting&amp;gt;在c#侧定义一个静态辅助类，提供类似叫CreateListString的函数去创建，但是你不可能为所有的类型都定义这样一层包装吧。所以，问题的核心是，我们怎么样在Lua侧只知道类型信息，就能让cs代劳给我们创建出对象，下面看代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;common.helper.lua&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; new泛型array&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; new_array(item_type, item_count)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; CS.XLuaHelper.CreateArrayInstance(item_type, item_count)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; new泛型list&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; new_list(item_type)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; CS.XLuaHelper.CreateListInstance(item_type)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; new泛型字典&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; new_dictionary(key_type, value_type)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; CS.XLuaHelper.CreateDictionaryInstance(key_type, value_type)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这是Resources/xlua/Common下的helper脚本其中的一部分，接下来的脚本我都会在开头写上模块名，不再做说明。之前说过，这个目录下的代码为lua逻辑代码提过对cs代码访问的桥接，这样做有两个好处：第一个是隐藏实现细节，第二个是容易更改实现。这里的三个接口都使用到了Scripts/xlua/Util下的XLuaHelper来做真实的事情。这两个目录下的脚本大概的职责都是这样的，Resources/xlua/Common封装lua调用，如果能用lua脚本实现，那就实现，不能实现，那在Resources/xlua/Common写cs脚本提供支持。下面看cs侧相关代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CS.XLuaHelper
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 说明：扩展CreateInstance方法&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Array CreateArrayInstance(Type itemType, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; itemCount)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Array.CreateInstance(itemType, itemCount);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IList CreateListInstance(Type itemType)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (IList)Activator.CreateInstance(MakeGenericListType(itemType));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IDictionary CreateDictionaryInstance(Type keyType, Type valueType)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (IDictionary)Activator.CreateInstance(MakeGenericDictionaryType(keyType, valueType));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这里并没有太多要说的东西，如果你对cs的API不熟悉，那msdn查就好，主要是提供一个代码结构和对类似问题的一个通用解决方式给大家参考。&lt;/p&gt;
&lt;h2&gt;lua侧cs迭代器访问&lt;/h2&gt;
&lt;p&gt;　　这个问题其实也很简单，xlua作者在demo中也给出了示例，只是我觉得麻烦，想要lua侧通用一点的语法，所以包装了一层语法糖，同样，lua代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; common.helper.lua&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; cs列表迭代器：含包括Array、ArrayList、泛型List在内的所有列表&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; list_iter(cs_ilist, index)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     index = index + &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; index &amp;lt; cs_ilist.Count &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; index, cs_ilist[index]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; list_ipairs(cs_ilist)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; list_iter, cs_ilist, -&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; cs字典迭代器&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; dictionary_iter(cs_enumerator)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; cs_enumerator:MoveNext() &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; current =&lt;span&gt; cs_enumerator.Current
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; current.Key, current.Value
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; dictionary_ipairs(cs_idictionary)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; cs_enumerator =&lt;span&gt; cs_idictionary:GetEnumerator()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dictionary_iter, cs_enumerator
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这部分代码不需要额外的cs脚本提供支持，这里只是实现了lua的泛型迭代，能够用在lua的for循环中，使用代码如下（只给出列表示例，对字典是类似的）：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; common.helper.lua&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; Lua创建和遍历泛型列表示例&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; helper = &lt;span&gt;require&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;common.helper&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; testList =&lt;span&gt; helper.new_list(typeof(CS.System.String))
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; testList:Add(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; testList:Add(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; testList:Add(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;333&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;testList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, testList, testList.Count, testList[testList.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 注意:循环区间为闭区间[0,testList.Count - 1]&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 适用于列表子集（子区间）遍历&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, testList.Count - &lt;span&gt;1&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;testList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, i, testList[i])
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 说明：工作方式与上述遍历一样，使用方式上雷同lua库的ipairs，类比于cs的foreach&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 适用于列表全集（整区间）遍历，推荐，很方便&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 注意：同cs的foreach，遍历函数体不能修改i,v，否则结果不可预料&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i, v &lt;span&gt;in&lt;/span&gt; helper.list_ipairs(testList) &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;testList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, i, v)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　要看懂这部分的代码，需要知道lua中的泛型for循环是怎么样工作的：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; var_1, ..., var_n &lt;span&gt;in&lt;/span&gt; explist &lt;span&gt;do&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    block 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　对于如上泛型for循环通用结构，其代码等价于：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; &lt;span&gt;_f&lt;/span&gt;, &lt;span&gt;_s&lt;/span&gt;, &lt;span&gt;_var&lt;/span&gt; =&lt;span&gt; explist
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; var_1, ... , var_n = &lt;span&gt;_f&lt;/span&gt;(&lt;span&gt;_s&lt;/span&gt;, &lt;span&gt;_var&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;_var&lt;/span&gt; =&lt;span&gt; var_1
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;_var&lt;/span&gt; == &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;then&lt;/span&gt; &lt;span&gt;break&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        block
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　泛型for循环的执行过程如下：&lt;br/&gt;　　首先，初始化，计算 in 后面表达式的值，表达式应该返回范性 for 需要的三个值：迭代函数_f，状态常量_s和控制变量_var；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。&lt;br/&gt;　　第二，将状态常量_s和控制变量_var作为参数调用迭代函数_f（注意：对于 for 结构来说，状态常量_s没有用处，仅仅在初始化时获取他的值并传递给迭代函数_f）。&lt;br/&gt;　　第三，将迭代函数_f返回的值赋给变量列表。&lt;br/&gt;　　第四，如果返回的第一个值为 nil 循环结束，否则执行循环体。&lt;br/&gt;　　第五，回到第二步再次调用迭代函数。&lt;/p&gt;
&lt;p&gt;　　如果控制变量的初始值是 a0，那么控制变量将循环：a1=_f(_s,a0)、a2=_f(_s,a1)、……，直到 ai=nil。对于如上列表类型的迭代，其中explist = list_ipairs(cs_ilist)，根据第一点，可以得到_f = list_iter，_s = cs_ilist, _var = -1，然后进入while死循环，此处每次循环拿_s = cs_ilist, _var = -1作为参数调用_f = list_iter，_f = list_iter内部对_var执行自增，所以这里的_var就是一个计数变量，也是list的index下标，返回值index、cs_ilist[index]赋值给for循环中的i、v，当遍历到列表末尾时，两个值都被赋值为nil，循环结束。这个机制和cs侧的foreach使用迭代器的工作机制是有点雷同的，如果你清楚这个机制，那么这里的原理就不难理解。&lt;/p&gt;
&lt;h2&gt;lua侧cs协程热更&lt;/h2&gt;
&lt;p&gt;　　这里先看cs侧协程的用法：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cs.UIRankMain&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Open(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; param, UIPathData pathData)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其它代码省略&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     StartCoroutine(TestCorotine(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; IEnumerator TestCorotine(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sec)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitForSeconds(sec);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     Logger.Log(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This message appears after {0} seconds in cs!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sec));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这是很普通的一种协程写法，下面对这个协程的调用函数Open，协程函数TestCorotine执行热修复：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; HotFix.UIRankMainTest.lua&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 模拟Lua侧的异步回调&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; lua_async_test(seconds, coroutine_break)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lua_async_test &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;..seconds..&lt;span&gt;'&lt;/span&gt;&lt;span&gt; seconds!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; TODO：这里还是用Unity的协程相关API模拟异步，有需要的话再考虑在Lua侧实现一个独立的协程系统&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    yield_return(CS.UnityEngine.WaitForSeconds(seconds))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     coroutine_break(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, seconds)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; lua侧新建协程：本质上是在Lua侧建立协程，然后用异步回调驱动，&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; corotineTest = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self, seconds)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;NewCoroutine: lua corotineTest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; s = &lt;span&gt;os.time&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;coroutine start1 : &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, s)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 使用Unity的协程相关API：实际上也是CS侧协程结束时调用回调，驱动Lua侧协程继续往下跑&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 注意：这里会在CS.CorotineRunner新建一个协程用来等待3秒，这个协程是和self没有任何关系的&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    yield_return(CS.UnityEngine.WaitForSeconds(seconds))
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;coroutine end1 : &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;os.time&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;This message1 appears after &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;..&lt;span&gt;os.time&lt;/span&gt;() - s..&lt;span&gt;'&lt;/span&gt;&lt;span&gt; seconds in lua!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; s = &lt;span&gt;os.time&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;coroutine start2 : &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, s)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 使用异步回调转同步调用模拟yield return&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 这里使用cs侧的函数也是可以的，规则一致：最后一个参数必须是一个回调，回调被调用时表示异步操作结束&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 注意：&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    1、如果使用cs侧函数，必须将最后一个参数的回调（cs侧定义为委托）导出到[CSharpCallLua]&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    2、用cs侧函数时，返回值也同样通过回调（cs侧定义为委托）参数传回&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; boolRetValue, secondsRetValue =&lt;span&gt; util.async_to_sync(lua_async_test)(seconds)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;coroutine end2 : &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;os.time&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;This message2 appears after &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;..&lt;span&gt;os.time&lt;/span&gt;() - s..&lt;span&gt;'&lt;/span&gt;&lt;span&gt; seconds in lua!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 返回值测试&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;boolRetValue:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, boolRetValue, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;secondsRetValue:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, secondsRetValue)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 协程热更示例&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; xlua.hotfix(CS.UIRankMain, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Open&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self, param, pathData)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HOTFIX:Open &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 省略其它代码&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 方式一：新建Lua协程，优点：可新增协程；缺点：使用起来麻烦&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;----------async call----------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     util.coroutine_call(corotineTest)(self, &lt;span&gt;4&lt;/span&gt;)&lt;span&gt;--&lt;/span&gt;&lt;span&gt;相当于CS的StartCorotine，启动一个协程并立即返回&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;----------async call end----------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 方式二：沿用CS协程，优点：使用方便，可直接热更协程代码逻辑，缺点：不可以新增协程&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     self:StartCoroutine(self:TestCorotine(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; cs侧协程热更&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; xlua.hotfix(CS.UIRankMain, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestCorotine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self, seconds)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HOTFIX:TestCorotine &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self, seconds)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt;注意：这里定义的匿名函数是无参的，全部参数以闭包方式传入&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; util.cs_generator(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; s = &lt;span&gt;os.time&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;coroutine start3 : &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, s)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt;注意：这里直接使用coroutine.yield，跑在self这个MonoBehaviour脚本中&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;coroutine.yield&lt;/span&gt;&lt;span&gt;(CS.UnityEngine.WaitForSeconds(seconds))
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;coroutine end3 : &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;os.time&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;This message3 appears after &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;..&lt;span&gt;os.time&lt;/span&gt;() - s..&lt;span&gt;'&lt;/span&gt;&lt;span&gt; seconds in lua!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这里代码看起来有点复杂，但是实际上要说的点几乎没有，因为xlua作者已经到协程做了比较好的支持。关于lua协程的工作原理，由于篇幅和时间的关系，这里不再具体做介绍了。&lt;/p&gt;
&lt;h2&gt;lua侧创建cs委托回调&lt;/h2&gt;
&lt;p&gt;　　这一点和接下来的消息系统，说起来都有点麻烦，我不会说得太细，如果听不懂，那说明你对xlua或者lua语言的熟悉程度还有待提高。这里回归的是篇头所阐述的问题，当cs侧某个函数的参数是一个委托，而调用方在cs侧直接给了个函数，在lua侧怎么去热更的问题，先给cs代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cs.UIArena&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; UpdateDailyAwardItem(List&amp;lt;BagItemData&amp;gt;&lt;span&gt; itemList)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (itemList == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; itemList.Count; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         UIGameObjectPool.instance.GetGameObject(ResourceMgr.RESTYPE.UI, TheGameIds.UI_BAG_ITEM_ICON, &lt;span&gt;new&lt;/span&gt; GameObjectPool.CallbackInfo(onBagItemLoad, itemList[i], Vector3.zero, Vector3.one * &lt;span&gt;0.65f&lt;/span&gt;&lt;span&gt;, m_awardGrid.gameObject));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    m_awardGrid.Reposition();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这是UI上面普通的一段异步加载背包Item的Icon资源问题，资源层异步加载完毕以后回调到当前脚本的onBagItemLoa函数对UI资源执行展示。现在就这段代码执行一下热修复：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; HotFix.UIArenaTese.lua&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 回调热更示例（消息系统的回调除外）&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    1、缓存委托&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    2、Lua绑定（实际上是创建LuaFunction再cast到delegate），需要在委托类型上打[CSharpCallLua]标签--推荐&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    3、使用反射再执行Lua绑定&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; xlua.hotfix(CS.UIArena, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;UpdateDailyAwardItem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self, itemList)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HOTFIX:UpdateDailyAwardItem &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self, itemList)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; itemList == &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;do&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i, item &lt;span&gt;in&lt;/span&gt; helper.list_ipairs(itemList) &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 方式一：使用CS侧缓存委托&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; callback1 =&lt;span&gt; self.onBagItemLoad
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 方式二：Lua绑定&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; callback2 = util.bind(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self, gameObject, object)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            self:OnBagItemLoad(gameObject, object)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;end&lt;/span&gt;&lt;span&gt;, self)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 方式三：&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    1、使用反射创建委托---这里没法直接使用，返回的是Callback&amp;lt;,&amp;gt;类型，没法隐式转换到CS.GameObjectPool.GetGameObjectDelegate类型&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    2、再执行Lua绑定--需要在委托类型上打[CSharpCallLua]标签&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 注意：&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    1、使用反射创建的委托可以直接在Lua中调用，但作为参数时，必须要求参数类型一致，或者参数类型为Delegate--参考Lua侧消息系统实现&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    2、正因为存在类型转换问题，而CS侧的委托类型在Lua中没法拿到，所以在Lua侧执行类型转换成为了不可能，上面才使用了Lua绑定&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    3、对于Lua侧没法执行类型转换的问题，可以在CS侧去做，这就是[CSharpCallLua]标签的作用，xlua底层已经为我们做好这一步&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    4、所以，这里相当于方式二多包装了一层委托，从这里可以知道，委托做好全部打[CSharpCallLua]标签，否则更新起来很受限&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt;    5、对于Callback和Action类型的委托（包括泛型）都在CS.XLuaHelper实现了反射类型创建，所以不需要依赖Lua绑定，可以任意使用&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 静态函数测试&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; delegate = helper.new_callback(typeof(CS.UIArena), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OnBagItemLoad2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, typeof(CS.UnityEngine.GameObject), typeof(CS.System.Object))
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         delegate(self.gameObject, &lt;span&gt;nil&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 成员函数测试&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; delegate = helper.new_callback(self, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OnBagItemLoad&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, typeof(CS.UnityEngine.GameObject), typeof(CS.System.Object))
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; callback3 = util.bind(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self, gameObject, object)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            delegate(gameObject, object)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;end&lt;/span&gt;&lt;span&gt;, self)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 其它测试：使用Lua绑定添加委托：必须[CSharpCallLua]导出委托类型，否则不可用&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         callback5 = callback1 + util.bind(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self, gameObject, object)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;callback4 in lua&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self, gameObject, object)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;end&lt;/span&gt;&lt;span&gt;, self)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; callbackInfo = CS.GameObjectPool.CallbackInfo(callback3, item, Vector3.zero, Vector3.one * &lt;span&gt;0.65&lt;/span&gt;&lt;span&gt;, self.m_awardGrid.gameObject)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        CS.UIGameObjectPool.instance:GetGameObject(CS.ResourceMgr.RESTYPE.UI, CS.TheGameIds.UI_BAG_ITEM_ICON, callbackInfo)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    self.m_awardGrid:Reposition()
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　有三种可行的热修复方式：&lt;/p&gt;
&lt;p&gt;　　1）缓存委托：就是在cs侧不要直接用函数名来作为委托参数传递，之前也说了，这里会临时创建一个委托，所以，最好在cs侧用函数初始化一个成员变量委托并缓存下来，使用的使用直接self.xxx传递委托到参数即可。&lt;/p&gt;
&lt;p&gt;　　2）Lua绑定：创建一个闭包，需要在cs侧的委托类型上打上[CSharpCallLua]标签，实际上xlua作者建议将工程中所有的委托类型打上这个标签，打上标签的委托xlua会生成一张映射表，当lua函数作为委托传递给cs函数用时，会自动去查表做映射。&lt;/p&gt;
&lt;p&gt;　　3）使用反射再执行lua绑定：这种方式使用起来很受限，这里不再做说明，要了解的朋友自己参考源代码中的注释或者自行测试体会。&lt;/p&gt;

&lt;h2&gt;打通lua和cs的消息系统&lt;/h2&gt;
&lt;p&gt;　　这部分是最难说清楚的一点，也算是很有价值的一个参考方案。cs侧的这个消息系统参考：&lt;a href=&quot;http://wiki.unity3d.com/index.php/Advanced_CSharp_Messenger&quot; target=&quot;_blank&quot;&gt;http://wiki.unity3d.com/index.php/Advanced_CSharp_Messenger&lt;/a&gt;。这里面使用了泛型编程的思想，xlua作者在demo中针对泛型接口的热修复给出的建议是实现扩展函数，但是扩展函数需要对一个类型去做一个接口，这里的消息系统类型完全是可以任意的，甚至是自定义类型，显然这种方案显得捉襟见肘。核心的问题只有一个，怎么根据参数类型信息去动态创建委托类型。&lt;/p&gt;
&lt;p&gt;　　委托类型其实是一个数据结构，它引用静态方法或引用类实例及该类的实例方法。在我们定义一个委托类型时，C#会创建一个类，有点类似C++函数对象的概念，但是它们还是相差很远。我这里不再做太多说明，总之这个数据结构在lua侧是无法用类似CS.XXX去访问到的，正因为如此，所以才为什么所有的委托类型都需要打上[CSharpCallLua]标签去做一个映射表。lua不能访问到cs委托类型，没关系，我们可以在cs侧创建出来就行了。而Delegate 类是委托类型的基类，所有的泛型委托类型都可通过它进行函数调用的参数传递，现在先看下怎么样在lua怎么去用这个消息系统，然后再从上层到下层做一次分析：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; HotFix.UIArenaTest.lua&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; Lua消息响应&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; TestLuaCallback = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self, param)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LuaDelegateTest: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, self, param, param &lt;span&gt;and&lt;/span&gt;&lt;span&gt; param.rank)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; TestLuaCallback2 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self, param)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LuaDelegateTest: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, self, param, param &lt;span&gt;and&lt;/span&gt;&lt;span&gt; param.Count)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 添加消息示例&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; xlua.hotfix(CS.UIArena, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;AddListener&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------------------------消息系统热更测试---------------------------------&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 用法一：使用cs侧函数作为回调，必须在XLuaMessenger导出，无法新增消息监听，不支持重载函数&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    messenger.add_listener(CS.MessageName.MN_ARENA_PERSONAL_PANEL, self, self.UpdatePanelInfo)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 用法二：使用lua函数作为回调，必须在XLuaMessenger导出，可以新增任意已导出的消息监听&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    messenger.add_listener(CS.MessageName.MN_ARENA_PERSONAL_PANEL, self, TestLuaCallback)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 用法三：使用CS侧成员委托，无须在XLuaMessenger导出，可以新增同类型的消息监听，CS侧必须缓存委托&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    messenger.add_listener(CS.MessageName.MN_ARENA_UPDATE, self.updateLeftTimes)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 用法四：使用反射创建委托，无须在XLuaMessenger导出，CS侧无须缓存委托，灵活度高，效率低，支持重载函数&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 注意：如果该消息在CS代码中没有使用过，则最好打[ReflectionUse]标签，防止IOS代码裁剪&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     messenger.add_listener(CS.MessageName.MN_ARENA_BOX, self, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SetBoxState&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, typeof(CS.System.Int32))
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 移除消息示例&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; xlua.hotfix(CS.UIArena, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;RemoveListener&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 用法一&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    messenger.remove_listener(CS.MessageName.MN_ARENA_PERSONAL_PANEL, self, self.UpdatePanelInfo)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 用法二&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    messenger.remove_listener(CS.MessageName.MN_ARENA_PERSONAL_PANEL, self, TestLuaCallback)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 用法三&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    messenger.remove_listener(CS.MessageName.MN_ARENA_UPDATE, self.updateLeftTimes)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 用法四&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     messenger.remove_listener(CS.MessageName.MN_ARENA_BOX, self, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SetBoxState&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, typeof(CS.System.Int32))
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 发送消息示例&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; util.hotfix_ex(CS.UIArena, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OnGUI&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(self)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; Button(Rect(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;, &lt;span&gt;150&lt;/span&gt;, &lt;span&gt;80&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lua BroadcastMsg1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; testData = CS.ArenaPanelData()&lt;span&gt;--&lt;/span&gt;&lt;span&gt;正确&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt;local testData = helper.new_object(typeof(CS.ArenaPanelData))--正确&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         testData.rank = &lt;span&gt;7777&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        messenger.broadcast(CS.MessageName.MN_ARENA_PERSONAL_PANEL, testData)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; Button(Rect(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;400&lt;/span&gt;, &lt;span&gt;150&lt;/span&gt;, &lt;span&gt;80&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lua BroadcastMsg3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; testData =&lt;span&gt; CS.ArenaPanelData()
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         testData.rank = &lt;span&gt;7777&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        messenger.broadcast(CS.MessageName.MN_ARENA_UPDATE, testData)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; Button(Rect(&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;, &lt;span&gt;150&lt;/span&gt;, &lt;span&gt;80&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lua BroadcastMsg4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;         messenger.broadcast(CS.MessageName.MN_ARENA_BOX, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    self:OnGUI()
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　从lua侧逻辑层来说，有4种使用方式：&lt;/p&gt;
&lt;p&gt;　　1）使用cs侧函数作为回调：直接使用cs侧的函数作为回调，传递self.xxx函数接口，必须在XLuaMessenger导出，无法新增消息监听，不支持重载函数，XLuaMessenger稍后再做说明&lt;/p&gt;
&lt;p&gt;　　2）使用lua函数作为回调：在lua侧定义函数作为消息回调，必须在XLuaMessenger导出，可以新增任意已导出的消息监听&lt;/p&gt;
&lt;p&gt;　　3）使用CS侧成员委托：无须在XLuaMessenger导出，可以新增同类型的消息监听，CS侧必须缓存委托，这个之前也说了，委托作为类成员变量缓存，很方便在lua中使用&lt;/p&gt;
&lt;p&gt;　　4）使用反射创建委托：就是根据参数类型动态生成委托类型，无须在XLuaMessenger导出，CS侧无须缓存委托，灵活度高，效率低，支持重载函数。需要注意的是该委托类型必须没有被裁剪&lt;/p&gt;
&lt;p&gt;　　从以上4种使用方式来看，lua层逻辑代码使用消息系统十分简单，切灵活性很大，总有一种方式是可以实现消息系统热修复的。lua侧的整套消息系统用common.messenger.lua辅助实现，看下代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; common.messenger.lua&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; added by wsh @ 2017-09-07 for Messenger-System-Proxy&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; lua侧消息系统，基于CS.XLuaMessenger导出类，可以看做是对CS.Messenger的扩展，使其支持Lua&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; &lt;span&gt;unpack&lt;/span&gt; = &lt;span&gt;unpack&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; table.&lt;span&gt;unpack&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; util = &lt;span&gt;require&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;common.util&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; helper = &lt;span&gt;require&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;common.helper&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; cache =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; GetKey = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(...)
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; params =&lt;span&gt; {...}
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; key = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; _,v &lt;span&gt;in&lt;/span&gt; &lt;span&gt;ipairs&lt;/span&gt;(params) &lt;span&gt;do&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;         key = key..&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;..&lt;span&gt;tostring&lt;/span&gt;&lt;span&gt;(v)
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; key
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; GetCache = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(key)
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache[key]
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; SetCache = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(key, value)
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;assert&lt;/span&gt;(GetCache(key) == &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;already contains key &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;..key)
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     cache[key] =&lt;span&gt; value
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; ClearCache = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(key)
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     cache[key] = &lt;span&gt;nil&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; add_listener_with_delegate = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(messengerName, cs_del_obj)
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;    CS.XLuaMessenger.AddListener(messengerName, cs_del_obj)
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; add_listener_with_func = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(messengerName, cs_obj, func)
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; key =&lt;span&gt; GetKey(cs_obj, func)
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; obj_bind_callback =&lt;span&gt; GetCache(key)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; obj_bind_callback == &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;         obj_bind_callback =&lt;span&gt; util.bind(func, cs_obj)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;        SetCache(key, obj_bind_callback)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; lua_callback =&lt;span&gt; CS.XLuaMessenger.CreateDelegate(messengerName, obj_bind_callback)
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;        CS.XLuaMessenger.AddListener(messengerName, lua_callback)
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; add_listener_with_reflection = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(messengerName, cs_obj, method_name, ...)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; cs_del_obj =&lt;span&gt; helper.new_callback(cs_obj, method_name, ...)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;    CS.XLuaMessenger.AddListener(messengerName, cs_del_obj)
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; add_listener = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(messengerName, ...)
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; params =&lt;span&gt; {...}
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;assert&lt;/span&gt;(#params &amp;gt;= &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error params count!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; #params == &lt;span&gt;1&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;         add_listener_with_delegate(messengerName, &lt;span&gt;unpack&lt;/span&gt;&lt;span&gt;(params))
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     &lt;span&gt;elseif&lt;/span&gt; #params == &lt;span&gt;2&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;(params[&lt;span&gt;2&lt;/span&gt;]) == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;         add_listener_with_func(messengerName, &lt;span&gt;unpack&lt;/span&gt;&lt;span&gt;(params))
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;         add_listener_with_reflection(messengerName, &lt;span&gt;unpack&lt;/span&gt;&lt;span&gt;(params))
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; broadcast = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(messengerName, ...)
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    CS.XLuaMessenger.Broadcast(messengerName, ...)
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; remove_listener_with_delegate = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(messengerName, cs_del_obj)
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;    CS.XLuaMessenger.RemoveListener(messengerName, cs_del_obj)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; remove_listener_with_func = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(messengerName, cs_obj, func)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; key =&lt;span&gt; GetKey(cs_obj, func)
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; obj_bind_callback =&lt;span&gt; GetCache(key)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; obj_bind_callback ~= &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;        ClearCache(key)
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         
&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;local&lt;/span&gt; lua_callback =&lt;span&gt; CS.XLuaMessenger.CreateDelegate(messengerName, obj_bind_callback)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        CS.XLuaMessenger.RemoveListener(messengerName, lua_callback)
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; remove_listener_with_reflection = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(messengerName, cs_obj, method_name, ...)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; cs_del_obj =&lt;span&gt; helper.new_callback(cs_obj, method_name, ...)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;    CS.XLuaMessenger.RemoveListener(messengerName, cs_del_obj)
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;local&lt;/span&gt; remove_listener = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(messengerName, ...)
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     &lt;span&gt;local&lt;/span&gt; params =&lt;span&gt; {...}
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;assert&lt;/span&gt;(#params &amp;gt;= &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error params count!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; #params == &lt;span&gt;1&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;         remove_listener_with_delegate(messengerName, &lt;span&gt;unpack&lt;/span&gt;&lt;span&gt;(params))
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;elseif&lt;/span&gt; #params == &lt;span&gt;2&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;(params[&lt;span&gt;2&lt;/span&gt;]) == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;         remove_listener_with_func(messengerName, &lt;span&gt;unpack&lt;/span&gt;&lt;span&gt;(params))
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;         remove_listener_with_reflection(messengerName, &lt;span&gt;unpack&lt;/span&gt;&lt;span&gt;(params))
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;end&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;     add_listener =&lt;span&gt; add_listener,
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     broadcast =&lt;span&gt; broadcast,
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     remove_listener =&lt;span&gt; remove_listener,
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　有以下几点需要说明：&lt;/p&gt;
&lt;p&gt;　　1）各个接口内部实现通过参数个数和参数类型实现重载，以下只对add_listener系列接口给出说明&lt;/p&gt;
&lt;p&gt;　　2）add_listener_with_delegate接受的参数直接是一个cs侧的委托对象，在lua侧不做任何特殊处理。对应上述的使用方式三&lt;/p&gt;
&lt;p&gt;　　3）add_listener_with_func接受参数是一个cs侧的对象，和一个函数，内部使用这两个信息创建闭包，传递给cs侧的是一个LuaFunction作为函数回调。对应上述的使用方式一和使用方式二&lt;/p&gt;
&lt;p&gt;　　4）add_listener_with_reflection接受的是一个cs侧的对象，外加一个cs侧的函数，或者是函数的名字和参数列表。对应的是使用方式四&lt;/p&gt;
&lt;p&gt;　　初步可以看出来，add_listener_with_delegate最简单，cs侧应该也不用做太多事情；add_listener_with_func不管是lua函数还是cs侧的函数，都是通过创建闭包，再将闭包函数映射到cs侧委托类型来创建的委托；add_listener_with_reflection看起来是通过反射动态创建的委托。所有接口的共通点就是想办法去创建委托，只是来源不一样。下面着重看下后两种方式是怎么实现的。&lt;/p&gt;
&lt;p&gt;　　对于反射创建委托，相对来说要简单一点，helper.new_callback最终会调用到XLuaHelper.cs中去，相关代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cs.XLuaHelper
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 说明：创建委托
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意：重载函数的定义顺序很重要：从更具体类型（Type）到不具体类型（object）,xlua生成导出代码和lua侧函数调用匹配时都是从上到下的，如果不具体类型（object）写在上面，则永远也匹配不到更具体类型（Type）的重载函数，很坑爹&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Delegate CreateActionDelegate(Type type, &lt;span&gt;string&lt;/span&gt; methodName, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] paramTypes)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; InnerCreateDelegate(MakeGenericActionType, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, type, methodName, paramTypes);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Delegate CreateActionDelegate(&lt;span&gt;object&lt;/span&gt; target, &lt;span&gt;string&lt;/span&gt; methodName, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] paramTypes)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; InnerCreateDelegate(MakeGenericActionType, target, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, methodName, paramTypes);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Delegate CreateCallbackDelegate(Type type, &lt;span&gt;string&lt;/span&gt; methodName, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] paramTypes)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; InnerCreateDelegate(MakeGenericCallbackType, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, type, methodName, paramTypes);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Delegate CreateCallbackDelegate(&lt;span&gt;object&lt;/span&gt; target, &lt;span&gt;string&lt;/span&gt; methodName, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] paramTypes)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; InnerCreateDelegate(MakeGenericCallbackType, target, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, methodName, paramTypes);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; Type MakeGenericDelegateType(&lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] paramTypes);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Delegate InnerCreateDelegate(MakeGenericDelegateType del, &lt;span&gt;object&lt;/span&gt; target, Type type, &lt;span&gt;string&lt;/span&gt; methodName, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Type[] paramTypes)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (target != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         type =&lt;span&gt; target.GetType();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance |&lt;span&gt; BindingFlags.Static;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     MethodInfo methodInfo = (paramTypes == &lt;span&gt;null&lt;/span&gt; || paramTypes.Length == &lt;span&gt;0&lt;/span&gt;) ? type.GetMethod(methodName, bindingFlags) : type.GetMethod(methodName, bindingFlags, &lt;span&gt;null&lt;/span&gt;, paramTypes, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     Type delegateType =&lt;span&gt; del(paramTypes);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Delegate.CreateDelegate(delegateType, target, methodInfo);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这部分代码没什么特别需要说明的，就是利用反射创建委托类型，这部分代码xlua作者在lua代码中也有实现。接下来的是怎么利用LuaFunction去创建委托，看下XLuaMesseneger.cs中创建委托的代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Type&amp;gt; MessageNameTypeMap = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Type&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; UIArena测试模块&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     { MessageName.MN_ARENA_PERSONAL_PANEL, &lt;span&gt;typeof&lt;/span&gt;(Callback&amp;lt;ArenaPanelData&amp;gt;) },&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出测试&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     { MessageName.MN_ARENA_UPDATE, &lt;span&gt;typeof&lt;/span&gt;(Callback&amp;lt;ArenaPanelData&amp;gt;) },&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存委托测试&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     { MessageName.MN_ARENA_BOX, &lt;span&gt;typeof&lt;/span&gt;(Callback&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;) },&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射测试&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;[LuaCallCSharp]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Type&amp;gt; LuaCallCSharp = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Type&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; XLuaMessenger&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(XLuaMessenger),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MessageName),
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;[CSharpCallLua]
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Type&amp;gt; CSharpCallLua1 = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Type&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由映射表自动导出&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;[CSharpCallLua]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Type&amp;gt; CSharpCallLua2 = Enumerable.Where(MessageNameTypeMap.Values, type =&amp;gt; &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Delegate).IsAssignableFrom(type)).ToList();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Delegate CreateDelegate(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; eventType, LuaFunction func)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;MessageNameTypeMap.ContainsKey(eventType))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Debug.LogError(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You should register eventType : {0} first!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, eventType));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; func.Cast(MessageNameTypeMap[eventType]);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　可以看到，这里用消息类型（String）和消息对应的委托类型做了一次表映射，lua侧传递LuaFunction过来时，通过消息类型就可以知道要Cast到什么类型的委托上面。由于时间关系（现在已经半夜4点半了），我这里也不再多说了，想要做更多了解的下载工程来看下源码就知道了，特别是这个Cast是干了什么，后面会贴身GitHub地址。这里多啰嗦一句，我这里是用消息类型对LuaFunction映射到委托进行了查表，而xlua中的原理是你所有导出的委托类型为一个列表，当LuaFunction要映射到委托类型时，会遍历这种表找一个参数类型匹配的委托执行映射。&lt;/p&gt;
&lt;p&gt;　　其它的应该都比较简单了，XLuaMessenger.cs是对Messenger.cs做了扩展，使其支持object类型参数，主要是提供对Lua侧发送消息的支持，截取其中一个函数来做下展示，这里也不再做过多说明：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Broadcast(&lt;span&gt;string&lt;/span&gt; eventType, &lt;span&gt;object&lt;/span&gt; arg1, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; arg2)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    Messenger.OnBroadcasting(eventType);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    Delegate d;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Messenger.eventTable.TryGetValue(eventType, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; d))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Type[] paramArr =&lt;span&gt; d.GetType().GetGenericArguments();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;object&lt;/span&gt; param1 =&lt;span&gt; arg1;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;object&lt;/span&gt; param2 =&lt;span&gt; arg2;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (paramArr.Length &amp;gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 param1 = CastType(paramArr[&lt;span&gt;0&lt;/span&gt;], arg1) ??&lt;span&gt; arg1;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 param2 = CastType(paramArr[&lt;span&gt;1&lt;/span&gt;], arg2) ??&lt;span&gt; arg2;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            d.DynamicInvoke(param1, param2);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (System.Exception ex)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             Debug.LogError(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ex.Message, &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arg1 = {0}, typeof(arg1) = {1}, arg2 = {2}, typeof(arg2) = {3}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, arg1, arg1.GetType(), arg2, arg2.GetType())));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; Messenger.CreateBroadcastSignatureException(eventType);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　有关这个所谓的xlua轻量级热修复框架中的重点就这些，消息系统可以很好的说明，当xlua对你项目中的某些模块支持得很乏力的时候，你应该怎样去扩展xlua的热修复框架，使它支持对你项目代码的热修复。我对模块间的封装和解耦一直比较重视，从这个框架结构也可以看出来，各个模块的职责很清晰，也不做多余的事情。对消息系统的扩充也没有在原来的Messenger.cs做修改，而是另启了一个XLuaMessenger.cs脚本来实现。说句废话，一个模块或者一个系统的封装性好不好，或者说和其它模块的耦合度低不低，你想一个事情就可以了：假如，我要把这个系统、或者模块迁移到其他项目，我要做多少事情，怎样设计，可以让迁移变得方便。在设计模块的时候，你就应该考虑这个事情，由于最近我经常在整合和迁移游戏框架，导致我对这方面的设计敏感度特别高，如果当初就项目的某个模块设计不合理，封装性不好，进行项目迁移的时候真叫一个想骂娘，我脾气已经很好了，可真是脾气好的人都会吐血，切记。&lt;/p&gt;
&lt;p&gt;　　说到这差不多该说的都已经说了，之前看xlua讨论群里还有人问怎么构建xlua动态库，或者说怎么集成第三方插件。其实这个东西要说的真不多，懂点套路就行，关于xlua构建，我这里也不专门做讲解了，有兴趣的参考我的另一篇博客：&lt;a href=&quot;http://www.cnblogs.com/SChivas/p/7854100.html&quot; target=&quot;_blank&quot;&gt;Unity3D跨平台动态库编译---记kcp基于CMake的各平台构建实践&lt;/a&gt;。这里有kcp的构建，其实这是我第一次尝试去编译Unity各平台的动态库经历，整个构建都是参考的xlua构建，你看懂并实践成功了kcp的构建，那么xlua的也会了，没毛病。&lt;/p&gt;


&lt;p&gt;　　github地址在：&lt;a href=&quot;https://github.com/smilehao/xlua-framework&quot; target=&quot;_blank&quot;&gt;https://github.com/smilehao/xlua-framework&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　不说了，很久没有码这么多字了，我一向是建议别人自己去读代码的，多读读优秀的代码才能切实进步。就像你不如坑，不知道水深一样；你不去读代码，只看别人理论分析还是有所欠缺的。&lt;/p&gt;

</description>
<pubDate>Fri, 24 Nov 2017 21:21:00 +0000</pubDate>
<dc:creator>SChivas</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SChivas/p/7893048.html</dc:identifier>
</item>
<item>
<title>key-value数据库-Redis - 姚红</title>
<link>http://www.cnblogs.com/yaohong/p/7893802.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaohong/p/7893802.html</guid>
<description>&lt;h2&gt;1.简介&lt;/h2&gt;
&lt;p&gt;Redis是完全开源的&lt;a href=&quot;https://baike.baidu.com/item/ANSI%20C/7657277?fr=aladdin&quot; target=&quot;_blank&quot;&gt;ANSI C&lt;/a&gt;语言编写、遵守&lt;a href=&quot;https://baike.baidu.com/item/BSD%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/2961212?fr=aladdin&quot; target=&quot;_blank&quot;&gt;BSD&lt;/a&gt;协议，高性能的key-value数据库。&lt;/p&gt;
&lt;h3&gt;1.1特点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
&lt;li&gt;Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1.2优势&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。&lt;/li&gt;
&lt;li&gt;丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。&lt;/li&gt;
&lt;li&gt;原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2.安装&lt;/h2&gt;
&lt;h3&gt; 2.1windows安装&lt;/h3&gt;
&lt;p&gt;   在&lt;a href=&quot;https://github.com/MicrosoftArchive/redis/releases&quot; target=&quot;_blank&quot;&gt;  https://github.com/MicrosoftArchive/redis/releases&lt;/a&gt;下下载Redis-x64-3.2.100.zip。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024482/201711/1024482-20171124110803312-541973802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将下载的包移动到c盘下，新建redis文件夹，将压缩包在redis文件夹下解压。&lt;/p&gt;
&lt;p&gt;打开一个 &lt;strong&gt;cmd&lt;/strong&gt; 窗口 使用cd命令切换目录到 &lt;strong&gt;C:\redis&lt;/strong&gt; 运行 &lt;strong&gt;redis-server.exe redis.windows.conf&lt;/strong&gt; 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
C:\redis&amp;gt; redis-&lt;span&gt;server.exe redis.windows.conf
                _._
           _.-``__ ''-&lt;span&gt;._
      _.-``    `.  `_.  ''-._           Redis 3.2.100 (00000000/0) 64&lt;span&gt; bit
  .-`` .-```.  ```\/    _.,_ ''-&lt;span&gt;._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 11604
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |&lt;span&gt;
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'&lt;span&gt;
          `-._        _.-'
              `-.__.-'
&lt;span&gt;
[11604] 24 Nov 11:04:00.253 # Server started, Redis version 3.2.100&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。&lt;/p&gt;
&lt;p&gt;切换到redis目录下运行 &lt;strong&gt;redis-cli.exe -h 127.0.0.1 -p 6379&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;设置键值对 &lt;strong&gt;set myKey abc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取出键值对 &lt;strong&gt;get myKey&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
C:\redis&amp;gt;redis-cli.exe -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; set&lt;span&gt; mykey yaohong
OK
127.0.0.1:6379&amp;gt; get&lt;span&gt; mykey
&quot;yaohong&quot;
127.0.0.1:6379&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.配置&lt;/h2&gt;
&lt;p&gt;3.1获取配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 #CONFIG GET *
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.2便捷配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#CONFIG SET loglevel &quot;notice&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.数据类型&lt;/h2&gt;
&lt;p&gt;Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。&lt;/p&gt;
&lt;h2&gt;5.命令&lt;/h2&gt;
&lt;h3&gt; 5.1基本命令&lt;/h3&gt;
&lt;p&gt;启动redis客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
C:\redis&amp;gt;redis-&lt;span&gt;cli
127.0.0.1:6379&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检测redis服务是否启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
127.0.0.1:6379&amp;gt;&lt;span&gt; PING
PONG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 连接远程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
C:\redis&amp;gt;redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;redis 127.0.0.1:6379&amp;gt;&lt;span&gt;
redis 127.0.0.1:6379&amp;gt; PING&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 5.2键（key）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 增：SET keyname redis  ---key后面跟key的名称和key的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;删：del keyname&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 改：EXPIRE yhkey 60  ---修改key的过期时间、EXPIRE以秒计算、  PEXPIRE 以毫秒计算   &lt;/p&gt;
&lt;p&gt;       ttl myname -----修改key永不过期&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       rename key yhkey9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查：keys * 查询所有key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      keys  yh* 过滤出包含yh的key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      exists keyname  判断key是否存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       pttl mekey查找key的剩余时间&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 5.3Redis-String&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#增&lt;br/&gt;127.0.0.1:6379&amp;gt; SET keyname2 &quot;hello myname is yaohong, what is your name?&quot;&lt;span readability=&quot;3&quot;&gt;
OK&lt;br/&gt;#查
127.0.0.1:6379&amp;gt;&lt;span readability=&quot;6&quot;&gt; GET keyname2
&quot;hello myname is yaohong, what is your name?&quot;&lt;p&gt;#截取字符串
127.0.0.1:6379&amp;gt; GETRANGE keyname2 2 14
&quot;llo myname is&quot;
127.0.0.1:6379&amp;gt; keys *
1) &quot;keyname2&quot;
2) &quot;yhkey1&quot;
3) &quot;yhkey9&quot;
4) &quot;yhkey3&quot;
5) &quot;keyname1&quot;
6) &quot;yhyhkey&quot;
7) &quot;mykey&quot;&lt;/p&gt;&lt;p&gt;#同时获取多个字符串
127.0.0.1:6379&amp;gt;&lt;span&gt; GET yhkey1 yhkey3
(error) ERR wrong number of arguments for 'get'&lt;span&gt; command
127.0.0.1:6379&amp;gt;&lt;span&gt; MGET yhkey1 yhkey3
1) &quot;redis&quot;
2) &quot;redis&quot;
127.0.0.1:6379&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 5.4Redis-Hash&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;增：hmset(同时将多个file-value设置到hash表中)、hget&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删：hdel&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查：hget、hgetall、&lt;em&gt;hkey获取hash表中所有域（file）、&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
  hmget myhash file1 file2 file3(返回哈希表中，一个或多个给定字段的值)
&lt;/pre&gt;
&lt;p&gt;      hvals获取哈希表中所有值&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 判：hexists 判断是否存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       hlen获取file个数&lt;/p&gt;
&lt;h3&gt;5.5Redis-List&lt;/h3&gt;
&lt;p&gt;Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）&lt;/p&gt;
&lt;p&gt;增：lpush(头部插入元素)、rpush(尾部插入元素)&lt;/p&gt;
&lt;p&gt;删：lpop(移除列表第一个元素)、rpop(移除列表最后一个元素)、lrem keyname count value(count大于0从头部开始删除value元素)&lt;/p&gt;
&lt;p&gt;查：llen(获取列表长度)、lreng key start stop(获取start到stop的元素)&lt;/p&gt;
&lt;p&gt;改：lset、rset&lt;/p&gt;
&lt;h3&gt;5.6Redis-Set&lt;/h3&gt;
&lt;p&gt;增：sadd、&lt;/p&gt;
&lt;p&gt;      sunionstore &lt;span class=&quot;pln&quot;&gt; myset myset1 myset2  命令将给定集合的并集存储在指定的集合 myset中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;删：spop移除集合中随机数&lt;/p&gt;
&lt;p&gt;      srem按值移除集合中元素&lt;/p&gt;
&lt;p&gt;查：smembers、scard(获取成员数)、&lt;/p&gt;
&lt;p&gt;      sdiff(列出第一个集合拥有，第二个集合没有的元素)、&lt;/p&gt;
&lt;p&gt;      sdiffstore(将第一个集合拥有，第二个集合没有的元素保存到第三个集合中)、&lt;/p&gt;
&lt;p&gt;      sinter(列出两个集合的交集)&lt;/p&gt;
&lt;p&gt;      smembers列出集合所有成员&lt;/p&gt;
&lt;p&gt;改：&lt;span class=&quot;pln&quot;&gt;smove  myset1 myset2 &lt;span class=&quot;str&quot;&gt;&quot;key1&quot;   将key1从myset1移到myset2&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;判：sismember 判断元素是否是key的成员&lt;/p&gt;
&lt;h3&gt;5.7Redis-ZSet&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;增：zadd keyname scoren value&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;删：zrem keyname nember 移除有序集合中的一个或多个成员&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;      zremrangebylex&lt;/em&gt;&lt;span class=&quot;pln&quot;&gt; key min max 移除有序集合中给定的字典区间的所有成员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pln&quot;&gt;      zremrangebyrank key start stop  移除有序集合中给定的排名区间的所有成员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;      zremrangebyscore key min max  &lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;移除有序集合中给定的分数区间的所有成员&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;查：zcard 获取集合的成员数&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;      zcount key min max 计算在有序集合中指定区间分数的成员数 &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;      zrange key start stop WITHSCORES &lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;通过索引区间返回有序集合成指定区间内的成员&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;em&gt;5.8事务&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Redis 事务可以一次执行多个命令&lt;/p&gt;
&lt;p&gt;开始事务：MULTI&lt;/p&gt;
&lt;p&gt;执行事务：EXEC&lt;/p&gt;
&lt;p&gt;取消事务：DISCARD    取消事务，放弃执行事务块内的所有命令&lt;/p&gt;
&lt;p&gt; 监视事务：WATCH      监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断&lt;/p&gt;
&lt;p&gt;取消监视：UNWATCH   取消 WATCH 命令对所有 key 的监视。&lt;/p&gt;
&lt;h3&gt;5.9脚本&lt;/h3&gt;
&lt;p&gt;Eval 命令使用 Lua 解释器执行脚本。&lt;/p&gt;
&lt;p&gt;5.10服务器&lt;/p&gt;
&lt;p&gt;Redis 服务器命令主要是用于管理 redis 服务。&lt;/p&gt;
&lt;p&gt;统计参数：INFO&lt;/p&gt;
&lt;p&gt;重置 INFO 命令中的某些统计数据：config resetstat&lt;/p&gt;
&lt;p&gt;键数：dbsize&lt;/p&gt;
&lt;p&gt; 删除所有key：flushall&lt;/p&gt;
&lt;p&gt;删除当前数据库key：flushdb&lt;/p&gt;
&lt;p&gt;异步保存数据到硬盘：save&lt;/p&gt;
&lt;h2&gt;6.Redis高级&lt;/h2&gt;
&lt;h3&gt;6.1Redis 数据备份与恢复&lt;/h3&gt;
&lt;p&gt;备份：save&lt;/p&gt;
&lt;p&gt;恢复：1：将生成的rdb文件移动到 redis 安装目录（执行config get dir）并启动服务即可&lt;/p&gt;
&lt;p&gt;创建 redis 备份文件也可以使用命令 &lt;strong&gt;BGSAVE&lt;/strong&gt;，该命令在后台执行。&lt;/p&gt;
&lt;h3&gt;6.2Redis 安全&lt;/h3&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;设置密码：config &lt;span class=&quot;kwd&quot;&gt;set&lt;span class=&quot;pln&quot;&gt; requirepass &lt;span class=&quot;str&quot;&gt;&quot;itnihao&quot;&lt;br/&gt;&lt;span class=&quot;pln&quot;&gt;auth itnihao
&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;获取密码：CONFIG &lt;span class=&quot;kwd&quot;&gt;get&lt;span class=&quot;pln&quot;&gt; requirepass&lt;span class=&quot;lit&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;em id=&quot;__mceDel&quot;&gt;6.3Redis 性能测试&lt;/em&gt;&lt;/h3&gt;
&lt;h3&gt;6.4Redis 客户端连接&lt;/h3&gt;
&lt;p&gt;查看最大连接数：&lt;em id=&quot;__mceDel&quot;&gt;&lt;span class=&quot;pln&quot;&gt;config &lt;span class=&quot;kwd&quot;&gt;get&lt;span class=&quot;pln&quot;&gt; maxclients&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;设置最大连接数：&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;maxclients &lt;span class=&quot;lit&quot;&gt;100000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;6.5Redis 管道技术&lt;/h3&gt;
&lt;p&gt;Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。&lt;/p&gt;
&lt;h3&gt;6.6Redis 分区&lt;/h3&gt;
&lt;p&gt;分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。&lt;/p&gt;
</description>
<pubDate>Fri, 24 Nov 2017 17:49:00 +0000</pubDate>
<dc:creator>姚红</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaohong/p/7893802.html</dc:identifier>
</item>
<item>
<title>[树莓派(raspberry pi)] 01、在linux环境下给树莓派安装系统及入门各种资料 - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/7893024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/7893024.html</guid>
<description>
&lt;h4&gt;1、预准备&lt;/h4&gt;
&lt;p&gt;进入帮助页面https://www.raspberrypi.org/help/，可以直接看到GET START WITH PASPBERRY PI，点击进入；&lt;/p&gt;
&lt;p&gt;接下来会引导你检查配件是否齐全：树莓派一个、显示器、HDMI线、鼠标、键盘、电源、8GB以上SD卡；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506370/201711/506370-20171125004025828-1233228847.png&quot; alt=&quot;&quot; width=&quot;435&quot; height=&quot;245&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在最下面的&lt;a href=&quot;https://www.raspberrypi.org/learning/hardware-guide/equipment.md&quot;&gt;Check you have the right equipment to start&lt;/a&gt; 对上述配件进行了更详细的描述，其中最值得注意的一个是SD卡！&lt;/p&gt;

&lt;h4&gt;2、制作SD卡启动盘&lt;/h4&gt;
&lt;p&gt;和用U盘在普通PC上安装新系统类似，树莓派需要用一个≥8GB的micro SD卡来制作启动盘！&lt;/p&gt;
&lt;blockquote readability=&quot;12.145124716553&quot;&gt;
&lt;p&gt;The latest version of Raspbian, the default operating system recommended for the Raspberry Pi, requires an 8GB (or larger) micro SD card. Not all SD cards are made equal, and some have higher failure rates than others. If you're unsure, you can always buy our official SD cards from &lt;a href=&quot;http://uk.rs-online.com/web/p/secure-digital-cards/9176317/&quot;&gt;RS&lt;/a&gt; or &lt;a href=&quot;https://cpc.farnell.com/sandisk/sdsdqu-008g-bmut/microsd-card-8gb-class-10-noobs/dp/SC13797?COM=main-search%20CMPNULL&quot;&gt;Farnell&lt;/a&gt;. Any 8GB SD card will work, although you'll need to follow the &lt;a href=&quot;https://www.raspberrypi.org/learning/software-guide&quot;&gt;software setup guide&lt;/a&gt; to learn how to load an operating system onto the card.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中 &lt;a href=&quot;https://www.raspberrypi.org/learning/software-guide/quickstart.md&quot;&gt;Downloading and installing the Raspberry Pi software&lt;/a&gt; 详细介绍如何在windows上制作 启动SD卡，主要是按照要求格式化SD卡、下载NOOBS文件并解压到格式化后的SD卡。但是楼主并没有windows电脑，而在linux上制作SD卡使我走了些弯路：&lt;/p&gt;
&lt;p&gt;a) 参考&lt;a href=&quot;https://www.raspberrypi.org/documentation/installation/noobs.md&quot; target=&quot;_blank&quot;&gt;https://www.raspberrypi.org/documentation/installation/noobs.md&lt;/a&gt;发现可以在linux系统上用命令行制作启动SD卡；&lt;/p&gt;
&lt;p&gt;b) 参考&lt;a href=&quot;http://qdosmsq.dunbar-it.co.uk/blog/2013/06/noobs-for-raspberry-pi/&quot; target=&quot;_blank&quot;&gt;http://qdosmsq.dunbar-it.co.uk/blog/2013/06/noobs-for-raspberry-pi&lt;/a&gt;/用命令行制作启动SD卡，下面是用到的命令：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1&amp;gt;&lt;/strong&gt;&lt;/span&gt; sudo fdisk -l    查看所有硬盘设备&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://images2018.cnblogs.com/blog/506370/201711/506370-20171125010748562-38982685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2&amp;gt; &lt;/strong&gt;&lt;/span&gt;sudo umount /dev/sdb || sudo umount /dev/sdb1 || sudo umount /dev/sdb2  全部卸载目标盘&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3&amp;gt;&lt;/strong&gt;&lt;/span&gt; sudo fdisk /dev/sdb 利用fdisk命令进行制作&lt;/p&gt;
&lt;p&gt;　　　 根据提示删除完所有的partition，我这里有两个，有些SD卡这一步会有警告，可以忽略&lt;/p&gt;
&lt;p&gt;　　  &lt;img src=&quot;https://images2018.cnblogs.com/blog/506370/201711/506370-20171125011420968-1964662091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　用n命令创建一个新的主分区，命名为1，使用默认的起始与结束扇区值，下面的操作在整个SD上只建立一个分区：&lt;/p&gt;
&lt;p&gt;　　  &lt;img src=&quot;https://images2018.cnblogs.com/blog/506370/201711/506370-20171125012048375-551650473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　  由于这里我们需要的不是Linux类型的分区，而是FAT32型的，因此我们可以用t命令修改它：&lt;/p&gt;
&lt;p&gt;　　  &lt;img src=&quot;https://images2018.cnblogs.com/blog/506370/201711/506370-20171125012631359-158986310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　  最后用write命令将新的分区表写入SD卡：（有的卡会有警告，可忽略）&lt;/p&gt;
&lt;p&gt;　　  &lt;img src=&quot;https://images2018.cnblogs.com/blog/506370/201711/506370-20171125013019562-1322245485.png&quot; alt=&quot;&quot;/&gt;　　 &lt;/p&gt;

&lt;h4&gt;3、安装系统&lt;/h4&gt;
&lt;p&gt;将上面制作好的SD卡插入树莓派、连接显示器、鼠标、键盘，给树莓派上电，按照安装引导安装：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506370/201711/506370-20171125013859828-331530960.gif&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;330&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;资料链接&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;:: 如果您觉得不错，请推荐给更多人，帮助他们更快地解决实际问题中的坑~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 24 Nov 2017 17:42:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/7893024.html</dc:identifier>
</item>
<item>
<title>&quot;虐待&quot;过我的老师们，你们如今还好吗 - 柒小栈主</title>
<link>http://www.cnblogs.com/qixiaoyizhan/p/7893364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qixiaoyizhan/p/7893364.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/998608/201711/998608-20171125010457046-2006351210.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当皇城脚下的民生问题都这么难做的时候，其他地方又该如何保障呢？&lt;/p&gt;
&lt;p&gt;京城“红黄蓝”出名了，京城发生锅炉大爆炸了，京城发生火灾了……&lt;/p&gt;
&lt;p&gt;聊天中，有一好友突然蹦出了一句话：“你看在皇城脚下都不安全了”。&lt;/p&gt;
&lt;p&gt;久久我没有回复，是啊，皇城脚下都不安全了，那在别处呢？&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;一&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;早上突然就在各大媒介爆出了“红黄蓝”事件，一时间各路人马纷纷热议，甚至揪出了前不久备受瞩目的虐童事件，然而令“观众”唏嘘不已的竟是“那些虐过童的幼儿园居然毫发无伤”！毫发无伤！！！&lt;/p&gt;
&lt;p&gt;相比掌掴、针扎、脱衣服、罚站、喷杀虫剂、抹芥末…性侵已经是最为恶劣的行径了，如果我不压着剩下的意思文明，那我会忍不住大喊出“禽兽、畜生”的字眼，可是现在已经不需要去压制文明了，不是吗？光守着所谓的文明还有用吗？突然有了周树人先生当年从医救国的无力之感…&lt;/p&gt;
&lt;p&gt;幼儿园的院长，带着幼儿园的老师狼狈为奸，对着祖国的花朵一次次“做着示范”，没错，就是伴随着花朵长大一直浇着这样的毒汁毒液！竟然丧尽天良培养一种“这就是课程”的思想，可想而知这样的“误人子弟”已经不能算是误人子弟了，简直是赤裸裸的欺骗，真真是变态的“传销”！&lt;/p&gt;
&lt;p&gt;你们好狠心，居然能对年幼的生命做出如此悖逆人伦的事情，请问你们有孩子吗？换位思考一下如果你们的孩子被街上的人强奸你们的心里究竟是怎样的？&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;二&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;看官向来是如此的，只要事情不是发生在自己身上，一时的愤懑之情，不多久便会烟消云散…&lt;/p&gt;
&lt;p&gt;逐渐平息“满腔怒火”的我突然就想起了当年被我的恩师“暴力教育”的场景，虽然当时不服气，认为老师做的过分，但是和现在发生在眼前的事情一比较，竟然觉得我的恩师的做法居然并没有那么狠毒，居然是那么的“温柔”。&lt;/p&gt;
&lt;p&gt;记忆中的实际意义上接受到的体罚应该是在初中时候了，那时候的数学老师为了减少大家的出错率，特意准备了一个长条形的木板，除了上课时比划板书之外，下课便是“体罚学生”的道具。当时的计算公式是一道错题一个木板，手虽然很疼，但是老师态度是非常和颜悦色的，以至于当时的我虽然忍受着肉体的疼痛，竟然把挨老师的板子当成一种有趣的事情。当事后了解到古代的体罚木板上要挖洞以便能吸住手上的肉造成更大的二次疼痛时，我竟有些庆幸老师没有用到这种地步…&lt;/p&gt;
&lt;p&gt;第二次的针对性的体罚便是“初四”那年因为上网被抓，当中在讲台上挨了班主任一个耳光，这件事记忆非常深刻，但是当初的自己玩性太大，不久便把这件事从自己的黑名单中勾去…&lt;/p&gt;
&lt;p&gt;最后一次记忆也是极为深刻的，那是在高中下体育课为了多打会球，竟然在大扫除“大家都在打扫”的时候开小差，晚回去了会。恰巧当天班主任在，把我喊出去问话，当时班主任问我啥时候回来的，我想我回来十分钟了，脱口而出“回来了会了”。然后一只脚就落在了我的左腿上，很痛快！&lt;/p&gt;
&lt;p&gt;印象中最直接的就是如上三件了，至于物理老师揪揪头发了什么的…我想，我们老师也是够温柔，够慈祥，所有的以上种种，都是为了我们自己的成长，相比惨不忍睹的事件，我着实是幸运良多。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;三&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;京城前几天着火了，这两天又发生了爆炸事件，这两件事情导致的直接后果就是迎来了统一理由下的拆迁指令。可是政府部门又哪里会去关心因为生活压力不得已住在这样残破的环境下的“北漂”的人们。&lt;/p&gt;
&lt;p&gt;看着别人视频里拎着大大小小行李在搬迁的人们，出租房里寄人篱下的我感受颇为强烈。&lt;/p&gt;
&lt;p&gt;这就是流离失所，这就是逃荒！这就是逃荒！！！&lt;/p&gt;
&lt;p&gt;北漂两周了，逐渐适应以后，顿然发现，这和在津又有什么区别？一样的背井离乡，一样的漂泊无依…&lt;/p&gt;
&lt;p&gt;只要非故乡，同是无根草！&lt;/p&gt;
&lt;p&gt;2017-11-25 01:01:18&lt;br/&gt;柒小于京&lt;/p&gt;
</description>
<pubDate>Fri, 24 Nov 2017 17:17:00 +0000</pubDate>
<dc:creator>柒小栈主</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qixiaoyizhan/p/7893364.html</dc:identifier>
</item>
<item>
<title>下一个计划 : .NET/.NET Core应用性能管理 - Lemon丶</title>
<link>http://www.cnblogs.com/liuhaoyang/p/next-plan-apm.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuhaoyang/p/next-plan-apm.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;最近几个月一直在研究开源的APM和监控方案，并对比使用了Zipkin,CAT,Sky-walking,PinPoint(仅对比,未实际部署),Elastic APM,TICK Stack,Prometheus等开源产品，其中不乏功能强大的监控和追踪系统，但它们都对.NET/.NET Core没有支持或支持不够完备。而在.NET/.NET Core平台也仅有Metrics.NET,AppMetrics,MiniProfiler等轻量级监控组件，它们也都和功能完备的APM系统差距甚远，也无法完全满足对当前流行的微服务系统进行全链路追踪和端对端监控的需求。为了满足实际的监控需求以及自身对APM系统的研究刨析，我决定从零开发.NET/.NET Core的APM，它应该包含&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Http请求监控&lt;/li&gt;
&lt;li&gt;应用健康检查&lt;/li&gt;
&lt;li&gt;方法执行监控&lt;/li&gt;
&lt;li&gt;应用内数据库访问监控&lt;/li&gt;
&lt;li&gt;应用内缓存访问监控（Redis）&lt;/li&gt;
&lt;li&gt;CLR/CoreCLR Runtime/GC/Threading监控&lt;/li&gt;
&lt;li&gt;请求链路监控&lt;/li&gt;
&lt;li&gt;分布式追踪&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了实现如上需求，我创建了AspectCoreAPM(基于AspectCore AOP的APM client agent)和Butterfly(独立的分布式追踪Server)两个开源项目，你可以在dotnet-lab[&lt;a href=&quot;https://github.com/dotnet-lab&quot; class=&quot;uri&quot;&gt;https://github.com/dotnet-lab&lt;/a&gt;]这个github organization下找到它们。下面将分别对两个项目进行简单介绍。&lt;/p&gt;
&lt;h3 id=&quot;butterfly--a-distributed-tracing-server&quot;&gt;Butterfly--A distributed tracing server&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet-lab/Butterfly&quot;&gt;Butterfly&lt;/a&gt;被设计为分布式追踪和APM的Server端，它将包含Collector，Storage，独立的Web UI，并使用&lt;a href=&quot;http://opentracing.io/&quot;&gt;Open Tracing&lt;/a&gt;规范来设计追踪数据。目前仅根据规范实现了Open Tracing API。&lt;/p&gt;
&lt;h3 id=&quot;aspectcoreapm&quot;&gt;AspectCoreAPM&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet-lab/AspectCore-APM&quot;&gt;AspectCoreAPM&lt;/a&gt;抽象了APM的应用探针设计，它将会使用自动探针（收集CLR/CoreCLR数据），AOP探针（收集方法执行数据）和手动探针（业务数据）三种方式来收集数据发送到不同Collector Server或Storage。鉴于Butterfly Server并未完全实现，现阶段使用InfluxDB作为数据存储，并使用Grafana进行监控展示（在Butterfly Server完成后在Web UI进行统一的监控数据展示）。AspectCoreAPM目前已经完成了Http请求监控,简单的GC/Threading监控和RedisClient监控。&lt;br/&gt;在使用AspectCoreAPM之前，我们需要先安装InfluxDB和Grafana。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在这里我使用ubuntu作为演示，如需在其他系统安装InfluxDB和Grafana，请各自参考它们的文档：  
InfluxDb：https://portal.influxdata.com/downloads  
Grafana：https://grafana.com/grafana/download&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装InfluxDB：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://dl.influxdata.com/influxdb/releases/influxdb_1.4.2_amd64.deb
sudo dpkg -i influxdb_1.4.2_amd64.deb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装之后，执行&lt;code&gt;influx&lt;/code&gt;进入influxdb的CLI，并创建一个名称为&lt;code&gt;aspectcore&lt;/code&gt;的database：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE DATABASE aspectcore&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后安装Grafana：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana_4.6.2_amd64.deb 
sudo dpkg -i grafana_4.6.2_amd64.deb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Grafana默认绑定的http地址为localhost，我们需要修改http_addr才可在外部访问Grafana，使用vi打开Grafana的配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo vi /etc/grafana/grafana.ini&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到&lt;code&gt;http_addr&lt;/code&gt;配置修改为&lt;code&gt;0.0.0.0:3000&lt;/code&gt;或你的外网IP。&lt;/p&gt;
&lt;p&gt;在浏览器打开Grafana，默认账号和密码均为admin，然后添加DataSource。Type选择influxdb，并且database填写我们上面创建的&lt;code&gt;aspectcore&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575322/201711/575322-20171125004333140-79330190.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载并导入AspectCoreAPM的Dashborad ： &lt;a href=&quot;https://grafana.com/dashboards/3837&quot; class=&quot;uri&quot;&gt;https://grafana.com/dashboards/3837&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575322/201711/575322-20171125004351625-556193769.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来创建一个Asp.Net Core项目，并从nuget添加AspectCoreAPM：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package AspectCore.APM.AspNetCore
Install-Package AspectCore.APM.LineProtocolCollector
Install-Package AspectCore.APM.ApplicationProfiler&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;Startup.cs&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Startup
{
    public Startup(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public IConfiguration Configuration { get; }

    // This method gets called by the runtime. Use this method to add services to the container.
    public IServiceProvider ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();

        services.AddAspectCoreAPM(component =&amp;gt;
        {
            component.AddApplicationProfiler(); //注册ApplicationProfiler收集GC和ThreadPool数据
            component.AddHttpProfiler();        //注册HttpProfiler收集Http请求数据
            component.AddLineProtocolCollector(options =&amp;gt; //注册LineProtocolCollector将数据发送到InfluxDb
            {
                options.Server = &quot;http://192.168.3.4:8086&quot;; //你自己的InfluxDB Http地址
                options.Database = &quot;aspectcore&quot;;    //你自己创建的Database
            });
        });

        return services.BuildAspectCoreServiceProvider(); //返回AspectCore AOP的ServiceProvider,这句代码一定要有
    }

    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        app.UseAspectCoreAPM();     //启动AspectCoreAPM，这句代码一定要有
        app.UseHttpProfiler();      //启动Http请求监控

        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseMvc();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动应用并访问页面。最后回到Grafana，在DataSource处选择&lt;code&gt;aspectcore&lt;/code&gt;，就能看到我们的监控数据啦。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575322/201711/575322-20171125004407609-2032842391.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;有问题反馈&quot;&gt;有问题反馈&lt;/h3&gt;
&lt;p&gt;希望有更多的.NET/.NET Core开发者能关注到这个项目并参与进来。&lt;br/&gt;如果您有任何问题，请提交 &lt;a href=&quot;https://github.com/dotnet-lab/AspectCore-APM/issues/new&quot;&gt;Issue&lt;/a&gt; 给我们。&lt;br/&gt;Github : &lt;a href=&quot;https://github.com/dotnet-lab/AspectCore-APM&quot; class=&quot;uri&quot;&gt;https://github.com/dotnet-lab/AspectCore-APM&lt;/a&gt;&lt;br/&gt;如果您觉得此项目对您有帮助，请点个Star~&lt;br/&gt;AspectCore QQ群: 306531723&lt;/p&gt;
</description>
<pubDate>Fri, 24 Nov 2017 16:45:00 +0000</pubDate>
<dc:creator>Lemon丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuhaoyang/p/next-plan-apm.html</dc:identifier>
</item>
<item>
<title>EditText 限制输入整数和小数 的位数 - 丁小雨™</title>
<link>http://www.cnblogs.com/dingzq/p/7892836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dingzq/p/7892836.html</guid>
<description>

&lt;p&gt;　　如题，本文主要说的就是  如何限制 EditText 中 可输入整数和小数 的位数 。&lt;/p&gt;
&lt;p&gt;　　近期，由于公司业务需求中有价格输入功能，给出的要求说是，必须整数能输入几位，小数能输入几位。。。好嘛，产品一句话，开发人员就得忙好久。平时工作过程中，一般用到的都是限制输入内容的长度而已，像这种限制 数值输入的整数位和小数位的需求还真不怎么多见。当时，做到这个的时候，我也有种懵逼的感觉，感觉真是太麻烦了，，后来想了想，只要分析清楚了，还是挺容易的。现整理出来，希望能帮助到有需要的人。&lt;/p&gt;

&lt;p&gt;　　用法如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        EditText etTest =&lt;span&gt; (EditText) findViewById(R.id.et_test);
        etTest.setInputType(InputType.TYPE_CLASS_NUMBER &lt;/span&gt;|&lt;span&gt; InputType.TYPE_NUMBER_FLAG_DECIMAL);
        etTest.addTextChangedListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DecimalInputTextWatcher(etTest,3,5));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 整数最多3位，小数最多5位&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实现的原理就是  实现 &lt;span&gt;implements TextWatcher，重写其中的方法 ：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterTextChanged(Editable editable){}
&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;
DecimalInputTextWatcher 源码：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.text.Editable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.text.InputFilter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.text.TextWatcher;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.EditText;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * EditText 限制输入整数和小数 的位数
 * 默认 整数位无限制，小数位 最多2位
 * &amp;lt;p&amp;gt;
 * Created by dingzuoqiang on 2017/11/24.
 * 530858106@qq.com
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DecimalInputTextWatcher &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; TextWatcher {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 需要设置该 DecimalInputTextWatcher 的 EditText
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; EditText editText = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认  小数的位数   2 位
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_DECIMAL_DIGITS = 2&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; decimalDigits;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小数的位数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; integerDigits;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 整数的位数&lt;/span&gt;


    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DecimalInputTextWatcher(EditText editText) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.editText =&lt;span&gt; editText;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.decimalDigits =&lt;span&gt; DEFAULT_DECIMAL_DIGITS;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; editText      editText
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; decimalDigits 小数的位数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; DecimalInputTextWatcher(EditText editText, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; decimalDigits) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.editText =&lt;span&gt; editText;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (decimalDigits &amp;lt;= 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;decimalDigits must &amp;gt; 0&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.decimalDigits =&lt;span&gt; decimalDigits;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; editText      editText
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; integerDigits 整数的位数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; decimalDigits 小数的位数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; DecimalInputTextWatcher(EditText editText, &lt;span&gt;int&lt;/span&gt; integerDigits, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; decimalDigits) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.editText =&lt;span&gt; editText;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (integerDigits &amp;lt;= 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;integerDigits must &amp;gt; 0&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (decimalDigits &amp;lt;= 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;decimalDigits must &amp;gt; 0&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.integerDigits =&lt;span&gt; integerDigits;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.decimalDigits =&lt;span&gt; decimalDigits;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; beforeTextChanged(CharSequence charSequence, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; i1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i2) {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onTextChanged(CharSequence charSequence, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; i1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i2) {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterTextChanged(Editable editable) {
        String s &lt;/span&gt;=&lt;span&gt; editable.toString();
        editText.removeTextChangedListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s.contains(&quot;.&quot;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (integerDigits &amp;gt; 0&lt;span&gt;) {
                editText.setFilters(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; InputFilter[]{&lt;span&gt;new&lt;/span&gt; InputFilter.LengthFilter(integerDigits + decimalDigits + 1&lt;span&gt;)});
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s.length() - 1 - s.indexOf(&quot;.&quot;) &amp;gt;&lt;span&gt; decimalDigits) {
                s &lt;/span&gt;= s.substring(0&lt;span&gt;,
                        s.indexOf(&lt;/span&gt;&quot;.&quot;) + decimalDigits + 1&lt;span&gt;);
                editable.replace(&lt;/span&gt;0&lt;span&gt;, editable.length(), s.trim());
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (integerDigits &amp;gt; 0&lt;span&gt;) {
                editText.setFilters(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; InputFilter[]{&lt;span&gt;new&lt;/span&gt; InputFilter.LengthFilter(integerDigits + 1&lt;span&gt;)});
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s.length() &amp;gt;&lt;span&gt; integerDigits) {
                    s &lt;/span&gt;= s.substring(0&lt;span&gt;, integerDigits);
                    editable.replace(&lt;/span&gt;0&lt;span&gt;, editable.length(), s.trim());
                }
            }

        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s.trim().equals(&quot;.&quot;&lt;span&gt;)) {
            s &lt;/span&gt;= &quot;0&quot; +&lt;span&gt; s;
            editable.replace(&lt;/span&gt;0&lt;span&gt;, editable.length(), s.trim());
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s.startsWith(&quot;0&quot;&lt;span&gt;)
                &lt;/span&gt;&amp;amp;&amp;amp; s.trim().length() &amp;gt; 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!s.substring(1, 2).equals(&quot;.&quot;&lt;span&gt;)) {
                editable.replace(&lt;/span&gt;0, editable.length(), &quot;0&quot;&lt;span&gt;);
            }
        }
        editText.addTextChangedListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);


    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;a href=&quot;https://github.com/dingzuoqiang/DecimalInputTextWatcher&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;源码下载&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 24 Nov 2017 16:06:00 +0000</pubDate>
<dc:creator>丁小雨™</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dingzq/p/7892836.html</dc:identifier>
</item>
<item>
<title>张高兴的 Xamarin.Forms 开发笔记：TapGestureRecognizer 的简单介绍与应用 - 张高兴</title>
<link>http://www.cnblogs.com/zhanggaoxing/p/7892791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggaoxing/p/7892791.html</guid>
<description>&lt;p&gt;　　最近很少写应用了，一直在忙关于 ASP.NET 的东西（哈欠...）。抽点时间对 TapGestureRecognizer 做点总结。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;一、简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　TapGestureRecognizer 就是对 Tap 手势进行识别。 Forms 里的大多数控件都继承自 View 类，而 View 类中有一个公共属性 GestureRecognizers，因此控件都可以添加各种手势识别。当然手势不止 Tap 这一种，更多的可以在 Xamarin 的指南中了解：&lt;a href=&quot;https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/gestures/&quot; target=&quot;_blank&quot;&gt;https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/gestures/&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; IList&amp;lt;IGestureRecognizer&amp;gt; GestureRecognizers { &lt;span&gt;get&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;二、用法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在说用法之前，首先要搞清楚我们需要关注 Tap 的哪些属性。最重要的还是 Tap 的次数。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1. Xaml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label.GestureRecognizers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TapGestureRecognizer &lt;/span&gt;&lt;span&gt;NumberOfTapsRequired&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Tapped&lt;/span&gt;&lt;span&gt;=&quot;TapGestureRecognizer_Tapped&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label.GestureRecognizers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　直接上代码，这里以 Label 举例，最最基本的用法都在这了，用 NumberOfTapsRequired 设置点击数， Tapped 绑定监听事件。对于 MVVM 涉及的绑定，可以去官方找找。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;2. C# 代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; tapGestureRecognizer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TapGestureRecognizer();

tapGestureRecognizer.NumberOfTapsRequired &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
tapGestureRecognizer.Tapped &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO&lt;/span&gt;
&lt;span&gt;};

YourControl.GestureRecognizers.Add(tapGestureRecognizer);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;三、应用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　写了一个小小的 Demo （GitHub：&lt;a href=&quot;https://github.com/ZhangGaoxing/xamarin-forms-demo/tree/master/GestureRecognizersDemo&quot; target=&quot;_blank&quot;&gt;https://github.com/ZhangGaoxing/xamarin-forms-demo/tree/master/GestureRecognizersDemo&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1. 超链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Forms 里是没有超链接的，有时候就很头疼。我顺便看了一下 &lt;a href=&quot;https://github.com/Microsoft/xaml-standard/blob/staging/docs/v1draft.md&quot; target=&quot;_blank&quot;&gt;Xaml Standard&lt;/a&gt; 的第一版草稿，里面还是没有超链接。可以用 TapGestureRecognizer 去仿制一个。这里就以 Label 跳转邮件链接和 Image 跳转网页链接举例。&lt;/p&gt;
&lt;p&gt;　　Xaml 代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;Hyperlinks&quot;&lt;/span&gt;&lt;span&gt; FontSize&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;Text : &quot;&lt;/span&gt;&lt;span&gt; VerticalTextAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Email&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;zhangyuexin121@live.cn&quot;&lt;/span&gt;&lt;span&gt; VerticalTextAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;DodgerBlue&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;Image : &quot;&lt;/span&gt;&lt;span&gt; VerticalTextAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Weibo&quot;&lt;/span&gt;&lt;span&gt; Source&lt;/span&gt;&lt;span&gt;=&quot;weibo.png&quot;&lt;/span&gt;&lt;span&gt; HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;35&quot;&lt;/span&gt;&lt;span&gt; WidthRequest&lt;/span&gt;&lt;span&gt;=&quot;35&quot;&lt;/span&gt;&lt;span&gt; VerticalOptions&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　C# 代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; tapGestureRecognizer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TapGestureRecognizer();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置触发点击数&lt;/span&gt;
tapGestureRecognizer.NumberOfTapsRequired = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
tapGestureRecognizer.Tapped &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Label)
    {
        Device.OpenUri(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mailto:zhangyuexin121@live.cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Image)
    {
        Device.OpenUri(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.weibo.com/279639933&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    }
};

Email.GestureRecognizers.Add(tapGestureRecognizer);
Weibo.GestureRecognizers.Add(tapGestureRecognizer);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;2. 为没有 Clicked 事件的控件添加假的 Clicked 事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　换句大白话来说，就是点击一个控件触发一个事件。这里以 Label 举例，点击 Label 以“0”和“1”变化。&lt;/p&gt;
&lt;p&gt;　　Xaml 代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;Fake Click Event&quot;&lt;/span&gt;&lt;span&gt; FontSize&lt;/span&gt;&lt;span&gt;=&quot;20&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; FontSize&lt;/span&gt;&lt;span&gt;=&quot;18&quot;&lt;/span&gt;&lt;span&gt; FontAttributes&lt;/span&gt;&lt;span&gt;=&quot;Bold&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label.GestureRecognizers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TapGestureRecognizer &lt;/span&gt;&lt;span&gt;NumberOfTapsRequired&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Tapped&lt;/span&gt;&lt;span&gt;=&quot;TapGestureRecognizer_Tapped&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label.GestureRecognizers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　C# 代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TapGestureRecognizer_Tapped(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
{
    Label label &lt;/span&gt;= sender &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Label;

    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; val =&lt;span&gt; label.Text;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (val)
    {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            label.Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            label.TextColor &lt;/span&gt;= Color.FromHex(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#2196F3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            label.Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            label.TextColor &lt;/span&gt;=&lt;span&gt; Color.Black;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;3. 效果图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1085877/201711/1085877-20171124234620562-1507154578.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Nov 2017 15:48:00 +0000</pubDate>
<dc:creator>张高兴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggaoxing/p/7892791.html</dc:identifier>
</item>
<item>
<title>Java提高十六：TreeMap深入分析 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/7892401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/7892401.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一篇容器元素比较Comparable&amp;amp;Comparator分析的时候，我们提到了TreeMap，但没有去细致分析它，只是说明其在添加元素的时候可以进行比较，从而使得集合有序，但是怎么做的呢?我们下面来进行分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、认识TreeMap&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前的文章讲解了HashMap，它保证了以O(1)的时间复杂度进行增、删、改、查，从存储角度考虑，这两种数据结构是非常优秀的。&lt;/p&gt;
&lt;p&gt;尽管如此，HashMap还是有自己的局限性----它们&lt;strong&gt;不具备统计性能，或者说它们的统计性能时间复杂度并不是很好才更准确，所有的统计必须遍历所有Entry，因此时间复杂度为O(N)&lt;/strong&gt;。比如Map的Key有1、2、3、4、5、6、7，我现在要统计：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所有Key比3大的键值对有哪些&lt;/li&gt;
&lt;li&gt;Key最小的和Key最大的是哪两个&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;就类似这些操作，HashMap做得比较差，此时我们可以使用TreeMap。TreeMap的Key按照自然顺序进行排序或者根据创建映射时提供的Comparator接口进行排序。&lt;strong&gt;TreeMap为增、删、改、查这些操作提供了log(N)的时间开销&lt;/strong&gt;，从存储角度而言，这比HashMap的O(1)时间复杂度要差些；但是在统计性能上，TreeMap同样可以保证log(N)的时间开销，这又比HashMap的O(N)时间复杂度好不少。&lt;/p&gt;
&lt;p&gt;因此总结而言：如果只需要存储功能，使用HashMap是一种更好的选择；如果还需要保证统计性能或者需要对Key按照一定规则进行排序，那么使用TreeMap是一种更好的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、红黑树介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我们知道一颗基本的二叉树他们都需要满足一个基本性质--即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉树的平衡，大牛们提出了各种实现的算法，如：AVL，SBT，伸展树，TREAP ，红黑树等等。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124211523265-768872994.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、每个节点都只能是红色或者黑色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、根节点是黑色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、每个叶节点（NIL节点，空节点）是黑色的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。所以红黑树它是复杂而高效的，其检索效率O(log &lt;em&gt;n&lt;/em&gt;)。下图为一颗典型的红黑二叉树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124211651984-1917137019.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://cmsblogs.qiniudn.com/wp-content/uploads/2014/05/2014051700004.gif&quot; alt=&quot;&quot; width=&quot;329&quot; height=&quot;241&quot;/&gt;左边旋转&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cmsblogs.qiniudn.com/wp-content/uploads/2014/05/2014051700005.gif&quot; alt=&quot;&quot; width=&quot;301&quot; height=&quot;258&quot;/&gt;右边旋转&lt;/p&gt;
&lt;p&gt;（图片来自：&lt;a title=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html&quot; href=&quot;http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html&quot;&gt;http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：由于本文主要是讲解Java中TreeMap，所以并没有对红黑树进行非常深入的了解和研究，如果想对其进行更加深入的研究提供几篇较好的博文：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1&lt;span&gt;、&lt;/span&gt;&lt;a href=&quot;http://blog.csdn.net/v_JULY_v/article/category/774945&quot;&gt;&lt;span&gt;红黑树系列集锦&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、&lt;/span&gt;&lt;a href=&quot;http://www.cnblogs.com/fanzhidongyzby/p/3187912.html&quot;&gt;&lt;span&gt;红黑树数据结构剖析&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;/span&gt;&lt;a href=&quot;http://blog.csdn.net/eric491179912/article/details/6179908&quot;&gt;&lt;span&gt;红黑树&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、TreeMap的数据结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TreeMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; NavigableMap&amp;lt;K,V&amp;gt;, Cloneable, java.io.Serializable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;TreeMap继承AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， NavigableMap（&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/NavigableMap.html&quot;&gt;更多&lt;/a&gt;）则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TreeMap中同时也包含了如下几个重要的属性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt; comparator;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TreeMap红-黑节点，为TreeMap的内部类&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器大小&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TreeMap修改次数&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; modCount = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;红黑树的节点颜色--红色&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; RED = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;红黑树的节点颜色--黑色&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; BLACK = &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于叶子节点Entry是TreeMap的内部类，它有几个重要的属性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;键&lt;/span&gt;
&lt;span&gt;        K key;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;
&lt;span&gt;        V value;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左孩子&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; left = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右孩子&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父亲&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt;&lt;span&gt; parent;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; color = BLACK;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、核心方法put 分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析put方法的过程，我们采用实例来进行分析，下面我们是我们写的一段代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pony1223;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.TreeMap;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MapDemo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) 
    {
        TreeMap&lt;/span&gt;&amp;lt;Integer, String&amp;gt; treeMap = &lt;span&gt;new&lt;/span&gt; TreeMap&amp;lt;Integer, String&amp;gt;&lt;span&gt;();
        treeMap.put(&lt;/span&gt;10, &quot;10&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;83, &quot;83&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;15, &quot;15&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;72, &quot;72&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;20, &quot;20&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;60, &quot;60&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;30, &quot;30&quot;&lt;span&gt;);
        treeMap.put(&lt;/span&gt;50, &quot;50&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;Integer, String&amp;gt;&lt;span&gt; entry : treeMap.entrySet()) {
            System.out.println(entry.getKey() &lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; entry.getValue());
        }
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们打印结果发现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124213205515-1339492964.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;事实再次证明TreeMap是有序的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来的内容会给出插入每条数据之后红黑树的数据结构是什么样子的。首先看一下treeMap的put方法的代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用t表示二叉树的当前节点&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; t =&lt;span&gt; root;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t为null表示一个空树，即TreeMap中没有任何元素，直接插入&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较key值，个人觉得这句代码没有任何意义，空树还需要比较、排序？&lt;/span&gt;
                compare(key, key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; type (and possibly null) check
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root&lt;/span&gt;
                root = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;(key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器的size = 1，表示TreeMap集合中存在一个元素&lt;/span&gt;
                size = 1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改次数 + 1&lt;/span&gt;
                modCount++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cmp;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cmp表示key排序的返回结果&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; parent;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; split comparator and comparable paths&lt;/span&gt;
            Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt; cpr = comparator;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定的排序算法
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (cpr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    parent &lt;/span&gt;= t;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;parent指向上次循环后的t
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较新增节点的key和当前节点key的大小&lt;/span&gt;
                    cmp =&lt;span&gt; cpr.compare(key, t.key);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
                        t &lt;/span&gt;=&lt;span&gt; t.left;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cmp返回值大于0，表示新增节点的key大于当前节点的key，则以当前节点的右子节点作为新的当前节点&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cmp &amp;gt; 0&lt;span&gt;)
                        t &lt;/span&gt;=&lt;span&gt; t.right;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t.setValue(value);
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果cpr为空，则采用默认的排序算法进行创建TreeMap集合&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key值为空抛出异常&lt;/span&gt;
                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 下面处理过程和上面一样 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                Comparable&lt;/span&gt;&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt; k = (Comparable&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt;) key;
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    parent &lt;/span&gt;=&lt;span&gt; t;
                    cmp &lt;/span&gt;=&lt;span&gt; k.compareTo(t.key);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
                        t &lt;/span&gt;=&lt;span&gt; t.left;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cmp &amp;gt; 0&lt;span&gt;)
                        t &lt;/span&gt;=&lt;span&gt; t.right;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t.setValue(value);
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新增节点当做parent的子节点&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; e = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;&lt;span&gt;(key, value, parent);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果新增节点的key小于parent的key，则当做左子节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
                parent.left &lt;/span&gt;=&lt;span&gt; e;
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果新增节点的key大于parent的key，则当做右子节点&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                parent.right &lt;/span&gt;=&lt;span&gt; e;
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             *  上面已经完成了排序二叉树的的构建，将新增节点插入该树中的合适位置
             *  下面fixAfterInsertion()方法就是对这棵树进行调整、平衡，具体过程参考上面的五种情况
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            fixAfterInsertion(e);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TreeMap元素数量 + 1&lt;/span&gt;
            size++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TreeMap容器修改次数 + 1&lt;/span&gt;
            modCount++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从这段代码，先总结一下TreeMap添加数据的几个步骤：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.获取根节点，根节点为空，产生一个根节点，将其着色为黑色，退出余下流程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.获取比较器，如果传入的Comparator接口不为空，使用传入的Comparator接口实现类进行比较；如果传入的Comparator接口为空，将Key强转为Comparable接口进行比较&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.从根节点开始逐一依照规定的排序算法进行比较，取比较值cmp，如果cmp=0，表示插入的Key已存在；如果cmp&amp;gt;0，取当前节点的右子节点；如果cmp&amp;lt;0，取当前节点的左子节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.排除插入的Key已存在的情况，第（3）步的比较一直比较到当前节点t的左子节点或右子节点为null，此时t就是我们寻找到的节点，cmp&amp;gt;0则准备往t的右子节点插入新节点，cmp&amp;lt;0则准备往t的左子节点插入新节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.new出一个新节点，默认为黑色，根据cmp的值向t的左边或者右边进行插入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6.插入之后进行修复，包括左旋、右旋、重新着色这些操作，让树保持平衡性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第1~第5步都没有什么问题，红黑树最核心的应当是第6步插入数据之后进行的修复工作，对应的Java代码是TreeMap中的fixAfterInsertion方法，下面看一下put每个数据之后TreeMap都做了什么操作，借此来理清TreeMap的实现原理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(10, &quot;10&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是put(10, &quot;10&quot;)，由于此时TreeMap中没有任何节点，因此10为根且根节点为黑色节点，put(10, &quot;10&quot;)之后的数据结构为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124214618750-62744801.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(83, &quot;83&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着是put(83, &quot;83&quot;)，这一步也不难，83比10大，因此在10的右节点上，即执行上面代码中do{}代码块，它是实现排序二叉树的核心算法，通过该算法我们可以确认新增节点在该树的正确位置。找到正确位置后将插入即可，但是由于83不是根节点，我知道TreeMap的底层实现是红黑树，红黑树是一棵平衡排序二叉树，普通的排序二叉树可能会出现失衡的情况，所以下一步就是要进行调整。fixAfterInsertion(e); 调整的过程务必会涉及到红黑树的左旋、右旋、着色三个基本操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 新增节点后的修复操作
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * x 表示新增节点
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fixAfterInsertion(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; x) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             x.color = RED;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增节点的颜色为红色
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环 直到 x不是根节点，且x的父节点不为红色&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; x != root &amp;amp;&amp;amp; x.parent.color ==&lt;span&gt; RED) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的父节点（P）是其父节点的父节点（G）的左节点&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (parentOf(x) ==&lt;span&gt; leftOf(parentOf(parentOf(x)))) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取X的叔节点(U)&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                     Entry&amp;lt;K,V&amp;gt; y =&lt;span&gt; rightOf(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的叔节点（U） 为红色（情况三）&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (colorOf(y) ==&lt;span&gt; RED) {     
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点（P）设置为黑色&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的叔节点（U）设置为黑色&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                        setColor(y, BLACK);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点的父节点（G）设置红色&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         x =&lt;span&gt; parentOf(parentOf(x));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {   
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; rightOf(parentOf(x))) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点作为X&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                             x =&lt;span&gt; parentOf(x);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右旋转&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                            rotateLeft(x);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（情况五）
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点（P）设置为黑色&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点的父节点（G）设置红色&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以X的父节点的父节点（G）为中心右旋转&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                        rotateRight(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的父节点（P）是其父节点的父节点（G）的右节点&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取X的叔节点（U）&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                     Entry&amp;lt;K,V&amp;gt; y =&lt;span&gt; leftOf(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的叔节点（U） 为红色（情况三）&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (colorOf(y) ==&lt;span&gt; RED) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点（P）设置为黑色&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的叔节点（U）设置为黑色&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                        setColor(y, BLACK);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点的父节点（G）设置红色&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                         x =&lt;span&gt; parentOf(parentOf(x));
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; leftOf(parentOf(x))) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点作为X&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;                             x =&lt;span&gt; parentOf(x);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右旋转&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                            rotateRight(x);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（情况五）
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点（P）设置为黑色&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将X的父节点的父节点（G）设置红色&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;                        setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以X的父节点的父节点（G）为中心右旋转&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;                        rotateLeft(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将根节点G强制设置为黑色&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;             root.color =&lt;span&gt; BLACK;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们看第6行的代码，它&lt;strong&gt;将默认的插入的那个节点着色成为&lt;/strong&gt;&lt;strong&gt;红色&lt;/strong&gt;，这很好理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据红黑树的性质（3），红黑树要求从根节点到叶子所有叶子节点上经过的黑色节点个数是相同的，因此如果插入的节点着色为黑色，那必然有可能导致某条路径上的黑色节点数量大于其他路径上的黑色节点数量，因此默认插入的节点必须是红色的，以此来维持红黑树的性质（3）.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然插入节点着色为红色节点后，有可能导致的问题是违反性质（2），即出现连续两个红色节点，这就需要通过旋转操作去改变树的结构，解决这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着看&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
while (x != null &amp;amp;&amp;amp; x != root &amp;amp;&amp;amp; x.parent.color ==&lt;span&gt; RED)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;的判断，前两个条件都满足，但是因为83这个节点的父节点是根节点的，根节点是黑色节点，因此这个条件不满足，while循环不进去，直接执行一次&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
root.color =&lt;span&gt; BLACK;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;行的代码给根节点着色为黑色（因为在旋转过程中有可能导致根节点为红色，而红黑树的根节点必须是黑色，因此最后不管根节点是不是黑色，都要重新着色确保根节点是黑色的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么put(83, &quot;83&quot;)之后，整个树的结构变为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124215733156-1716953325.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、为根节点&lt;/span&gt; &lt;/p&gt;
&lt;p&gt; 若新插入的节点N没有父节点，则直接当做根据节点插入即可，同时将颜色设置为黑色&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、父节点为黑色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种情况新节点N同样是直接插入，同时颜色为红色，由于根据规则四它会存在两个黑色的叶子节点，值为null。同时由于新增节点N为红色，所以通过它的子节点的路径依然会保存着相同的黑色节点数，同样满足规则5。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在看put(15, &quot;15&quot;)之前，必须要先过一下fixAfterInsertion方法。第11行～第41行的代码和第43行~第73行的代码是一样的，无非一个是操作左子树另一个是操作右子树而已，因此就看前一半：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; x != root &amp;amp;&amp;amp; x.parent.color ==&lt;span&gt; RED) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (parentOf(x) ==&lt;span&gt; leftOf(parentOf(parentOf(x)))) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt; y =&lt;span&gt; rightOf(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (colorOf(y) ==&lt;span&gt; RED) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            setColor(y, BLACK);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             x =&lt;span&gt; parentOf(parentOf(x));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; rightOf(parentOf(x))) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 x =&lt;span&gt; parentOf(x);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                rotateLeft(x);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            setColor(parentOf(x), BLACK);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            setColor(parentOf(parentOf(x)), RED);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            rotateRight(parentOf(parentOf(x)));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    ....
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第2行的判断注意一下，用语言描述出来就是：&lt;strong&gt;判断当前节点的父节点与当前节点的父节点的父节点的左子节点是否同一个节点&lt;/strong&gt;。翻译一下就是：&lt;strong&gt;当前节点是否左子节点插入.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在上面代码中说到的情况三、四、五的意思是；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、若父节点P和P的兄弟节点U都为红色&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于这种情况若直接插入肯定会出现不平衡现象（不能出现两个连着的红色）。怎么处理？P、U节点变黑、G节点变红。这时由于经过节点P、U的路径都必须经过G所以在这些路径上面的黑节点数目还是相同的。但是经过上面的处理，可能G节点的父节点也是红色，这个时候我们需要将G节点当做新增节点递归处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124221112015-1041895978.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;四、若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对于这种情况我们对新增节点N、P进行一次左旋转。这里所产生的结果其实并没有完成，还不是平衡的（违反了规则四），这是我们需要进行情况5的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124221527140-103726934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;五、父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这种情况有可能是由于情况四而产生的，也有可能不是。对于这种情况先已P节点为中心进行右旋转，在旋转后产生的树中，节点P是节点N、G的父节点。但是这棵树并不规范，它违反了规则4，所以我们将P、G节点的颜色进行交换，使之其满足规范。开始时所有的路径都需要经过G其他们的黑色节点数一样，但是现在所有的路径改为经过P，且P为整棵树的唯一黑色节点，所以调整后的树同样满足规范5。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124222148078-49067841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结：对于第四种情况和第五种情况而言这两种插入方式的处理是不同的，区别是第四种情况插入多一步左旋操作。能看出，&lt;strong&gt;红黑树的插入最多只需要进行两次旋转，不管这棵红黑树多么复杂，都可以根据这五种情况来进行生成。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124222927093-651673821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中左边的是左子树外侧插入，右边的是左子树内侧插入&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;put(15, &quot;15&quot;)&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看完fixAfterInsertion方法流程之后，继续添加数据，这次添加的是put(15, &quot;15&quot;)，15比10大且比83小，因此15最终应当是83的左子节点，默认插入的是红色节点，因此首先将15作为红色节点插入83的左子节点后的结构应当是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124222617156-1250942400.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是显然这里违反了红黑树的性质（2），即连续出现了两个红色节点，因此此时必须进行旋转。回看前面fixAfterInsertion的流程，上面演示的是左子树插入流程，右子树一样，可以看到这是右子树内侧插入，需要进行两次旋转操作：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;对新插入节点的父节点进行一次右旋操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;新插入节点的父节点着色为黑色，新插入节点的祖父节点着色为红色&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对新插入节点的祖父节点进行一次左旋操作&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;旋转是红黑树中最难理解也是最核心的操作，右旋和左旋是对称的操作，我个人的理解，以右旋为例，对某个节点x进行右旋，其实质是：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;降低左子树的高度，增加右子树的高度&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;将x变为当前位置的右子节点&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;左旋是同样的道理，在旋转的时候一定要记住这两句话，这将会帮助我们清楚地知道在不同的场景下旋转如何进行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看一下&quot;对新插入节点的父节点进行一次右旋操作&quot;，源代码为rotateRight方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rotateRight(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将L设置为P的左子树&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; l =&lt;span&gt; p.left;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将L的右子树设置为P的左子树&lt;/span&gt;
            p.left =&lt;span&gt; l.right;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若L的右子树不为空，则将P设置L的右子树的父节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (l.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
                l.right.parent &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将P的父节点设置为L的父节点&lt;/span&gt;
            l.parent =&lt;span&gt; p.parent;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果P的父节点为空，则将L设置根节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p.parent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                root &lt;/span&gt;=&lt;span&gt; l;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若P为其父节点的右子树，则将L设置为P的父节点的右子树&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p.parent.right ==&lt;span&gt; p)
                p.parent.right &lt;/span&gt;=&lt;span&gt; l;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则将L设置为P的父节点的左子树&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
                p.parent.left &lt;/span&gt;=&lt;span&gt; l;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将P设置为L的右子树&lt;/span&gt;
            l.right =&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将L设置为P的父节点&lt;/span&gt;
            p.parent =&lt;span&gt; l;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;左旋与右旋是一个对称的操作，大家可以试试看把右图的b节点进行左旋，就变成了左图了。这里多说一句，&lt;strong&gt;旋转一定要说明是对哪个节点进行旋转&lt;/strong&gt;，网上看很多文章讲左旋、右旋都是直接说旋转之后怎么样怎么样，我认为脱离具体的节点讲旋转是没有任何意义的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里可能会有的一个问题是：b有左右两个子节点分别为d和e，为什么右旋的时候要将右子节点e拿到a的左子节点而不是b的左子节点d？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个很简单的解释是：&lt;strong&gt;如果将b的左子节点d拿到a的左子节点，那么b右旋后右子节点指向a，b原来的右子节点e就成为了一个游离的节点，游离于整个数据结构之外&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回到实际的例子，对83这个节点进行右旋之后还有一次着色操作（2），分别是将x的父节点着色为黑色，将x的祖父节点着色为红色，然后对节点10进行一次左旋操作（3），左旋之后的结构为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124223244078-1457287722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(72, &quot;72&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;put(72, &quot;72&quot;)就很简单了，72是83的左子节点，由于72的父节点以及叔父节点都是红色节点，因此直接将72的父节点83、将72的叔父节点10着色为黑色即可，72这个节点着色为红色，即满足红黑树的特性，插入72之后的结构图为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124223601859-142900299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(20, &quot;20&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;put(20, &quot;20&quot;)，插入的位置应当是72的左子节点，默认插入红色，插入之后的结构图为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124223758109-938030745.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题很明显，出现了连续两个红色节点，20的插入位置是一种左子树外侧插入的场景，因此只需要进行着色+对节点83进行一次右旋即可，着色+右旋之后数据结构变为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124223846375-825960498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(60, &quot;60&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面进行put(60, &quot;60&quot;)操作，节点60插入的位置是节点20的右子节点，由于节点60的父节点与叔父节点都是红色节点，因此只需要将节点60的父节点与叔父节点着色为黑色，将节点60的组父节点着色为红色即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么put(60, &quot;60&quot;)之后的结构为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124223952281-1218713418.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(30, &quot;30&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;put(30, &quot;30&quot;)，节点30应当为节点60的左子节点，因此插入节点30之后应该是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124224221156-298976549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然这里违反了红黑树性质即连续出现了两个红色节点，因此这里要进行旋转。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;put(30, &quot;30&quot;)的操作和put(15, &quot;15&quot;)的操作类似，同样是右子树内侧插入的场景，那么需要进行两次旋转：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;对节点30的父节点节点60进行一次右旋&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;右旋之后对节点60的祖父节点20进行一次左旋&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;右旋+着色+左旋之后，put(30, &quot;30&quot;)的结果应当为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124224332625-2051209453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;put(50, &quot;50&quot;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124224542093-1165186117.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rotateLeft(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取P的右子节点，其实这里就相当于新增节点N（情况四而言）&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; r =&lt;span&gt; p.right;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将R的左子树设置为P的右子树&lt;/span&gt;
            p.right =&lt;span&gt; r.left;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若R的左子树不为空，则将P设置为R左子树的父亲&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (r.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                r.left.parent &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将P的父亲设置R的父亲&lt;/span&gt;
            r.parent =&lt;span&gt; p.parent;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果P的父亲为空，则将R设置为跟节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p.parent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                root &lt;/span&gt;=&lt;span&gt; r;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果P为其父节点（G）的左子树，则将R设置为P父节点(G)左子树&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p.parent.left ==&lt;span&gt; p)
                p.parent.left &lt;/span&gt;=&lt;span&gt; r;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则R设置为P的父节点（G）的右子树&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                p.parent.right &lt;/span&gt;=&lt;span&gt; r;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将P设置为R的左子树&lt;/span&gt;
            r.left =&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将R设置为P的父节点&lt;/span&gt;
            p.parent =&lt;span&gt; r;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 五、delete方法分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对于红黑树的增加节点而言，删除显得更加复杂，使原本就复杂的红黑树变得更加复杂。同时删除节点和增加节点一样，同样是找到删除的节点，删除之后调整红黑树。但是这里的删除节点并不是直接删除，而是通过走了“弯路”通过一种捷径来删除的：找到被删除的节点D的子节点C，用C来替代D，不是直接删除D，因为D被C替代了，直接删除C即可。所以这里就将删除父节点D的事情转变为了删除子节点C的事情，这样处理就将复杂的删除事件简单化了。子节点C的规则是：右分支最左边，或者 左分支最右边的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红-黑二叉树删除节点，最大的麻烦是要保持 各分支黑色节点数目相等。 因为是删除，所以不用担心存在颜色冲突问题——插入才会引起颜色冲突。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红黑树删除节点同样会分成几种情况，这里是按照待删除节点有几个儿子的情况来进行分类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面就论各种删除情况来进行图例讲解，但是在讲解之前请允许我再次啰嗦一句，请时刻牢记红黑树的5点规定：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、每个节点都只能是红色或者黑色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、根节点是黑色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、每个叶节点（NIL节点，空节点）是黑色的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;诚然，既然删除节点比较复杂，那么在这里我们就约定一下规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、下面要讲解的删除节点一定是实际要删除节点的后继节点（N），如前面提到的C。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、下面提到的删除节点的树都是如下结构，该结构所选取的节点是待删除节点的右树的最左边子节点。这里我们规定真实删除节点为N、父节点为P、兄弟节点为W兄弟节点的两个子节点为X1、X2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 删除元素的过程和普通二叉搜索树的搜索过程大体也比较类似，首先是根据待删除节点的情况进行分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 待删除节点没有子节点， 则直接删除该节点。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124230155109-1930464163.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 待删除节点有一个子节点，则用该子节点替换它的父节点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124230357265-752652354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3. 待删除节点有两个子节点，则取它的后继节点替换它，并删除这个后继节点原来的位置。它可能有种情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124230439140-453103889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;删除后的调整&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 删除元素之后的调整和前面的插入元素调整的过程比起来更复杂。它不是一个简单的在原来过程中取反。我们先从一个最基本的点开始入手。首先一个，我们要进行调整的这个点肯定是因为我们要删除的这个点破坏了红黑树的本质特性。而如果我们删除的这个点是红色的，则它肯定不会破坏里面的属性。因为从前面删除的过程来看，我们这个要删除的点是已经在濒临叶节点的附近了，它要么有一个子节点，要么就是一个叶节点。如果它是红色的，删除了，从上面的节点到叶节点所经历的黑色节点没有变化。所以，这里的一个前置条件就是待删除的节点是黑色的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在前面的那个前提下，我们要调整红黑树的目的就是要保证，这个原来是黑色的节点被删除后，我们要通过一定的变化，使得他们仍然是合法的红黑树。我们都知道，在一个黑色节点被删除后，从上面的节点到它所在的叶节点路径所经历的黑色节点就少了一个。我们需要做一些调整，使得它少的这个在后面某个地方能够补上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ok，有了这一部分的理解，我们再来看调整节点的几种情况。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 当前节点和它的父节点是黑色的，而它的兄弟节点是红色的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124230633937-319334034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这种情况下既然它的兄弟节点是红色的，从红黑树的属性来看，它的兄弟节点必然有两个黑色的子节点。这里就通过节点x的父节点左旋，然后父节点B颜色变成红色，而原来的兄弟节点D变成黑色。这样我们就将树转变成第二种情形中的某一种情况。在做后续变化前，这棵树这么的变化还是保持着原来的平衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2. 1） 当前节点的父节点为红色，而它的兄弟节点，包括兄弟节点的所有子节点都是黑色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124230741812-1836079901.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  在这种情况下，我们将它的兄弟节点设置为红色，然后x节点指向它的父节点。这里有个比较难以理解的地方，就是为什么我这么一变之后它就平衡了呢？因为我们假定A节点是要调整的节点一路调整过来的。因为原来那个要调整的节点为黑色，它一旦被删除就路径上的黑色节点少了1.所以这里A所在的路径都是黑色节点少1.这里将A的兄弟节点变成红色后，从它的父节点到下面的所有路径就都统一少了1.保证最后又都平衡了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    当然，大家还会有一个担忧，就是当前调整的毕竟只是一棵树中间的字数，这里头的节点B可能还有父节点，这么一直往上到根节点。你这么一棵字数少了一个黑色节点，要保证整理合格还是不够的。这里在代码里有了一个保证。假设这里B已经是红色的了。那么代码里那个循环块就跳出来了，最后的部分还是会对B节点，也就是x所指向的这个节点置成黑色。这样保证前面亏的那一个黑色节点就补回来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2） 当前节点的父节点为黑色，而它的兄弟节点，包括兄弟节点的所有子节点都是黑色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这种情况和前面比较类似。如果接着前面的讨论来，在做了那个将兄弟节点置成红色的操作之后，从父节点B开始的所有子节点都少了1.那么这里从代码中间看的话，由于x指向了父节点，仍然是黑色。则这个时候以父节点B作为基准的子树下面都少了黑节点1. 我们就接着以这么一种情况向上面推进。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.  当前节点的父节点为红色，而它的兄弟节点是黑色，同时兄弟节点有一个节点是红色。&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124231113218-303819138.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里所做的操作就是先将兄弟节点做一个右旋操作，转变成第4种情况。当然，前面的前提是B为红色，在B为黑色的情况下也可以同样的处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 在当前兄弟节点的右子节点是红色的情况下。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201711/401339-20171124231156437-937263510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里是一种比较理想的处理情况，我们将父节点做一个左旋操作，同时将父节点B变成黑色，而将原来的兄弟节点D变成红色，并将D的右子节点变成黑色。这样保证了新的子树中间根节点到各叶子节点的路径依然是平衡的。大家看到这里也许会觉得有点奇怪，为什么这一步调整结束后就直接x = T.root了呢？也就是说我们一走完这个就可以把x直接跳到根节点，其他的都不需要看了。这是因为我们前面的一个前提，A节点向上所在的路径都是黑色节点少了一个的，这里我们以调整之后相当于给它增加了一个黑色节点，同时对其他子树的节点没有任何变化。相当于我内部已经给它补偿上来了。所以后续就不需要再往上去调整。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面讨论的这4种情况是在当前节点是父节点的左子节点的条件下进行的。如果当前节点是父节点的右子节点，则可以对应的做对称的操作处理，过程也是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;其他&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;TreeMap的红黑树实现当然也包含其他部分的代码实现，如用于查找元素的getEntry方法，取第一个和最后一个元素的getFirstEntry, getLastEntry方法以及求前驱和后继的predecesor, successor方法。这些方法的实现和普通二叉搜索树的实现没什么明显差别。这里就忽略不讨论了。这里还有一个有意思的方法实现，就是buildFromSorted方法。它的实现过程并不复杂，不过经常被作为面试的问题来讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、小节&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这篇博文确实是有点儿长，在这里非常感谢各位看客能够静下心来读完，我想你通过读完这篇博文一定收获不小。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;同时这篇博文我写的过程中，看了、参考了大量的博文。同时不免会有些地方存在借鉴之处，在这里对其表示感谢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;另外，我想说的是，重点要掌握的是put方法即可，其它如果精力足够可以细细品读。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;1、红黑树数据结构剖析：&lt;a title=&quot;http://www.cnblogs.com/fanzhidongyzby/p/3187912.html&quot; href=&quot;http://www.cnblogs.com/fanzhidongyzby/p/3187912.html&quot;&gt;http://www.cnblogs.com/fanzhidongyzby/p/3187912.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、红黑二叉树详解及理论分析 ：&lt;a title=&quot;http://blog.csdn.net/kartorz/article/details/8865997&quot; href=&quot;http://blog.csdn.net/kartorz/article/details/8865997&quot;&gt;http://blog.csdn.net/kartorz/article/details/8865997&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;http://blog.csdn.net/v_july_v/article/details/6105630&quot;&gt;教你透彻了解红黑树 &lt;/a&gt;：&lt;a href=&quot;http://cmsblogs.com/blog.csdn.net/v_july_v/article/details/6105630&quot;&gt;blog.csdn.net/v_july_v/article/details/6105630&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、经典算法研究系列：五、红黑树算法的实现与剖析 ：&lt;a title=&quot;http://blog.csdn.net/v_JULY_v/article/details/6109153&quot; href=&quot;http://blog.csdn.net/v_JULY_v/article/details/6109153&quot;&gt;http://blog.csdn.net/v_JULY_v/article/details/6109153&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、示例，红黑树插入和删除过程：&lt;a title=&quot;http://saturnman.blog.163.com/blog/static/557611201097221570/&quot; href=&quot;http://saturnman.blog.163.com/blog/static/557611201097221570/&quot;&gt;http://saturnman.blog.163.com/blog/static/557611201097221570/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、红黑二叉树详解及理论分析 ：&lt;a title=&quot;http://blog.csdn.net/kartorz/article/details/8865997&quot; href=&quot;http://blog.csdn.net/kartorz/article/details/8865997&quot;&gt;http://blog.csdn.net/kartorz/article/details/8865997&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7、红黑树概念、红黑树的插入及旋转操作：&lt;a href=&quot;http://www.cnblogs.com/xrq730/p/6867924.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/xrq730/p/6867924.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、treemap:&lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/26668941&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/chenssy/article/details/26668941&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Nov 2017 15:26:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/7892401.html</dc:identifier>
</item>
<item>
<title>源码剖析Django REST framework的请求生命周期 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/7892719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/7892719.html</guid>
<description>&lt;p&gt;学习Django的时候知道,在Django请求的生命周期中,请求经过WSGI和中间件到达路由,不管是FBV还是CBV都会先执行View视图函数中的dispatch方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;REST framework&lt;/code&gt;是基于Django的API框架,REST framework采用的是CBV的请求模式.&lt;/p&gt;
&lt;p&gt;所以在一个项目中,使用了REST framework的时候,&lt;/p&gt;
&lt;p&gt;请求到达&lt;code&gt;REST framework&lt;/code&gt;后,也先执行&lt;code&gt;REST framework&lt;/code&gt;中的&lt;code&gt;dispatch&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;先来看看&lt;code&gt;dispatch&lt;/code&gt;方法的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def dispatch(self, request, *args, **kwargs):

    self.args = args            # 函数传递过来的参数
    self.kwargs = kwargs        # 函数传递过来的参数
    
    # 封装request
    request = self.initialize_request(request, *args, **kwargs)
    self.request = request
    self.headers = self.default_response_headers  # deprecate?

    try:
        self.initial(request, *args, **kwargs)

        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(),
                              self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed

        response = handler(request, *args, **kwargs)

    except Exception as exc:
        response = self.handle_exception(exc)

    self.response = self.finalize_response(request, response, *args, **kwargs)
    return self.response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看&lt;code&gt;initialize_request&lt;/code&gt;方法,可以知道这个方法接收客户端的request请求,再重新封装成新的request&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def initialize_request(self, request, *args, **kwargs):

    parser_context = self.get_parser_context(request)

    return Request(
        request,
        parsers=self.get_parsers(),
        authenticators=self.get_authenticators(),
        negotiator=self.get_content_negotiator(),
        parser_context=parser_context
    )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再查看Request方法的源码&lt;/p&gt;
&lt;p&gt;可以知道这个&lt;code&gt;Request&lt;/code&gt;类是&lt;code&gt;rest framework&lt;/code&gt;中定义的一个类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Request(object):

    def __init__(self, request, parsers=None, authenticators=None,
                 negotiator=None, parser_context=None):
        self._request = request
        self.parsers = parsers or ()
        self.authenticators = authenticators or ()
        self.negotiator = negotiator or self._default_negotiator()
        self.parser_context = parser_context
        self._data = Empty
        self._files = Empty
        self._full_data = Empty
        self._content_type = Empty
        self._stream = Empty

        if self.parser_context is None:
            self.parser_context = {}
        self.parser_context['request'] = self
        self.parser_context['encoding'] = request.encoding or settings.DEFAULT_CHARSET

        force_user = getattr(request, '_force_auth_user', None)
        force_token = getattr(request, '_force_auth_token', None)
        if force_user is not None or force_token is not None:
            forced_auth = ForcedAuthentication(force_user, force_token)
            self.authenticators = (forced_auth,)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先不看这个&lt;code&gt;Request&lt;/code&gt;到底执行了什么操作&lt;/p&gt;
&lt;p&gt;但是已经知道经过Request处理过的request已经不再是客户端发送过来的那个request了&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;initialize_request&lt;/code&gt;方法中,有一个方法处理过request,来看看&lt;code&gt;get_parser_context&lt;/code&gt;方法的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def get_parser_context(self, http_request):

    return {
        'view': self,
        'args': getattr(self, 'args', ()),
        'kwargs': getattr(self, 'kwargs', {})
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里,view的值是self,代指的是&lt;code&gt;UsersView&lt;/code&gt;这个对象,所以&lt;code&gt;get_parser_context&lt;/code&gt;方法把UsersView这个类封装进来然后返回&lt;/p&gt;
&lt;p&gt;所以&lt;code&gt;get_parser_context&lt;/code&gt;方法最后返回的当前对象以及当前对象所传的参数&lt;/p&gt;
&lt;p&gt;经过&lt;code&gt;initialize_request&lt;/code&gt;函数处理之后的request,现在就变成了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Request(
    request,
    parsers=self.get_parsers(),
    authenticators=self.get_authenticators(),
    negotiator=self.get_content_negotiator(),
    parser_context=parser_context
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在再来看看Request的其他参数代指的是什么&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;get_parsers                 根据字面意思,是解析get请求的意思
get_authenticators          认证相关
get_content_negotiator      选择相关
parser_context              封闭self和self的参数

def get_parsers(self):

    return [parser() for parser in self.parser_classes]

def get_authenticators(self):

    return [auth() for auth in self.authentication_classes]

def get_permissions(self):

    return [permission() for permission in self.permission_classes]

def get_throttles(self):

    return [throttle() for throttle in self.throttle_classes]

def get_content_negotiator(self):

    if not getattr(self, '_negotiator', None):
        self._negotiator = self.content_negotiation_class()
    return self._negotiator&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看看&lt;code&gt;UsersView&lt;/code&gt;这个类中的get方法和post方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def get(self,request,*args,**kwargs):
    pass

def post(self,request,*args,**kwargs):
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到get方法的参数中有一个request,通过前面可以知道这个request已经不是最开始时到达服务端的request了&lt;/p&gt;
&lt;p&gt;这个request方法中已经被&lt;code&gt;REST framework&lt;/code&gt;封装了解析,认证和选择等相关的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def dispatch(self, request, *args, **kwargs):

    self.args = args
    self.kwargs = kwargs
    request = self.initialize_request(request, *args, **kwargs)
    self.request = request
    self.headers = self.default_response_headers  # deprecate?

    try:
        self.initial(request, *args, **kwargs)

        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(),
                              self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed

        response = handler(request, *args, **kwargs)

    except Exception as exc:
        response = self.handle_exception(exc)

    self.response = self.finalize_response(request, response, *args, **kwargs)
    return self.response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;default_response_headers&lt;/code&gt;这个方法从它的注释可以看出已经被丢弃了.&lt;/p&gt;
&lt;p&gt;再来看&lt;code&gt;initial&lt;/code&gt;这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def initial(self, request, *args, **kwargs):
    &quot;&quot;&quot;
    Runs anything that needs to occur prior to calling the method handler.
    &quot;&quot;&quot;
    self.format_kwarg = self.get_format_suffix(**kwargs)

    # Perform content negotiation and store the accepted info on the request
    neg = self.perform_content_negotiation(request)
    request.accepted_renderer, request.accepted_media_type = neg

    # Determine the API version, if versioning is in use.
    version, scheme = self.determine_version(request, *args, **kwargs)
    request.version, request.versioning_scheme = version, scheme

    # Ensure that the incoming request is permitted
    self.perform_authentication(request)
    self.check_permissions(request)
    self.check_throttles(request)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先执行&lt;code&gt;get_format_suffix&lt;/code&gt;来获取客户端所发送的url的后缀&lt;/p&gt;
&lt;p&gt;然后执行&lt;code&gt;perform_content_negotiation&lt;/code&gt;方法,从它的注释可以知道这个方法的主要作用是执行内容选择,并把服务端接收到的信息保存在request中&lt;/p&gt;
&lt;p&gt;然后再执行&lt;code&gt;determine_version&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def determine_version(self, request, *args, **kwargs):
    &quot;&quot;&quot;
    If versioning is being used, then determine any API version for the
    incoming request. Returns a two-tuple of (version, versioning_scheme)
    &quot;&quot;&quot;
    if self.versioning_class is None:
        return (None, None)
    scheme = self.versioning_class()
    return (scheme.determine_version(request, *args, **kwargs), scheme)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;determine_version&lt;/code&gt;方法的官方注释中可以知道,&lt;code&gt;determine_version&lt;/code&gt;方法的主要作用是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如果url中有版本信息,就获取发送到服务端的版本,返回一个元组&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完上面的方法,再执行&lt;code&gt;perform_authentication&lt;/code&gt;方法来进行认证操作&lt;/p&gt;
&lt;p&gt;来看下&lt;code&gt;perform_authentication&lt;/code&gt;方法的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def perform_authentication(self, request):
    &quot;&quot;&quot;
    Perform authentication on the incoming request.

    Note that if you override this and simply 'pass', then authentication
    will instead be performed lazily, the first time either
    `request.user` or `request.auth` is accessed.
    &quot;&quot;&quot;
    request.user&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面有代码及注释中可以看出,&lt;code&gt;perform_authentication&lt;/code&gt;方法的作用就是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;执行认证功能,确认进行后续操作的用户是被允许的.
perform_authentication方法返回经过认证的用户对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完&lt;code&gt;perform_authentication&lt;/code&gt;方法,就会执行&lt;code&gt;check_permissions&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def check_permissions(self, request):
    &quot;&quot;&quot;
    Check if the request should be permitted.
    Raises an appropriate exception if the request is not permitted.
    &quot;&quot;&quot;
    for permission in self.get_permissions():
        if not permission.has_permission(request, self):
            self.permission_denied(
                request, message=getattr(permission, 'message', None)
            )
            &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;check_permissions&lt;/code&gt;方法的作用是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如果用户通过认证,检查用户是否有权限访问url中所传的路径.
如用用户访问的是没有没有权限的路径,则会抛出异常.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;check_permissions&lt;/code&gt;方法执行完成后,就会执行&lt;code&gt;check_throttles&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;check_throttles&lt;/code&gt;方法的作用是检查用户是否被限制了访问主机的次数&lt;br/&gt;如果用户访问服务器的次数超出设定值,则会抛出一个异常&lt;/p&gt;
&lt;p&gt;例如,如果想限制一个ip地址每秒钟只能访问几次,一个小时之内最多可以访问多少次,就可以在&lt;code&gt;settings.py&lt;/code&gt;文件中进行配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def check_throttles(self, request):
    &quot;&quot;&quot;
    Check if request should be throttled.
    Raises an appropriate exception if the request is throttled.
    &quot;&quot;&quot;
    for throttle in self.get_throttles():
        if not throttle.allow_request(request, self):
            self.throttled(request, throttle.wait())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;initial&lt;/code&gt;这个方法执行完成后,&lt;code&gt;request.method.lower&lt;/code&gt;把请求的方法转换成小写&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Get the appropriate handler method
if request.method.lower() in self.http_method_names:
    handler = getattr(self, request.method.lower(),
                      self.http_method_not_allowed)
else:
    handler = self.http_method_not_allowed

response = handler(request, *args, **kwargs)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再通过通过反射的方式来执行&lt;code&gt;UsersView&lt;/code&gt;类中的get或post等自定义方法&lt;/p&gt;
&lt;p&gt;需要注意的是,在执行&lt;code&gt;initial&lt;/code&gt;方法之前,使用了&lt;code&gt;try/except&lt;/code&gt;方法来进行异常处理&lt;/p&gt;
&lt;p&gt;如果执行&lt;code&gt;initial&lt;/code&gt;方法的时候出现错误,就调用&lt;code&gt;handle_exception&lt;/code&gt;来处理&lt;code&gt;initial&lt;/code&gt;方法抛出的异常,返回正确的响应信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def handle_exception(self, exc):
    &quot;&quot;&quot;
    Handle any exception that occurs, by returning an appropriate response,
    or re-raising the error.
    &quot;&quot;&quot;
    if isinstance(exc, (exceptions.NotAuthenticated,
                        exceptions.AuthenticationFailed)):
        # WWW-Authenticate header for 401 responses, else coerce to 403
        auth_header = self.get_authenticate_header(self.request)

        if auth_header:
            exc.auth_header = auth_header
        else:
            exc.status_code = status.HTTP_403_FORBIDDEN

    exception_handler = self.get_exception_handler()

    context = self.get_exception_handler_context()
    response = exception_handler(exc, context)

    if response is None:
        self.raise_uncaught_exception(exc)

    response.exception = True
    return response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在前面,如果&lt;code&gt;initial&lt;/code&gt;方法执行完成没有抛出异常,则根据反射执行自定义的请求方法,然后返回响应信息&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;initial&lt;/code&gt;方法抛出异常则执行&lt;code&gt;handle_exception&lt;/code&gt;方法处理抛出的异常,也返回响应信息&lt;/p&gt;
&lt;p&gt;等到上面的过程执行完成后,再执行&lt;code&gt;finalize_response&lt;/code&gt;方法把最终的响应信息返回给客户端的浏览器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def finalize_response(self, request, response, *args, **kwargs):
    &quot;&quot;&quot;
    Returns the final response object.
    &quot;&quot;&quot;
    # Make the error obvious if a proper response is not returned
    assert isinstance(response, HttpResponseBase), (
        'Expected a `Response`, `HttpResponse` or `HttpStreamingResponse` '
        'to be returned from the view, but received a `%s`'
        % type(response)
    )

    if isinstance(response, Response):
        if not getattr(request, 'accepted_renderer', None):
            neg = self.perform_content_negotiation(request, force=True)
            request.accepted_renderer, request.accepted_media_type = neg

        response.accepted_renderer = request.accepted_renderer
        response.accepted_media_type = request.accepted_media_type
        response.renderer_context = self.get_renderer_context()

    # Add new vary headers to the response instead of overwriting.
    vary_headers = self.headers.pop('Vary', None)
    if vary_headers is not None:
        patch_vary_headers(response, cc_delim_re.split(vary_headers))

    for key, value in self.headers.items():
        response[key] = value

    return response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以总结:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;REST framework&lt;/code&gt;请求的生命周期为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.请求到达服务端,经过WSGI和中间件到达路由系统
2.路由系统执行配置的CBV或者FBV中的dispatch方法
3.在dispatch方法中,request方法被封装添加了解析器,认证方法及选择器等方法
4.然后执行initial方法
5.再获取版本,进行认证操作,权限操作和节流操作
6.最后执行自定义的get,post,push,delete等自定义方法
7.在执行initial方法之前,通过try来捕获可能出现的异常
8.如果出现异常,就执行handle_exception方法来处理捕获到的异常
9.不管是否出现异常,最后的返回值都通过finalize_response方法来处理响应的内容&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 24 Nov 2017 15:22:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/7892719.html</dc:identifier>
</item>
<item>
<title>RocketMQ快速入门 - 匠心零度</title>
<link>http://www.cnblogs.com/lirenzuo/p/7892593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lirenzuo/p/7892593.html</guid>
<description>&lt;p&gt;前面几篇文章介绍了为什么选择RocketMQ，以及与kafka的一些对比： &lt;a href=&quot;https://mp.weixin.qq.com/s/KfBruI-tOz-eJuM2fgqyew&quot;&gt;阿里 RocketMQ 优势对比&lt;/a&gt;，方便大家对于RocketMQ有一个简单的整体了解，之后介绍了：&lt;a href=&quot;https://mp.weixin.qq.com/s/PhUJoD5y9Fu7CxFSBmf29w&quot;&gt;MQ 应用场景&lt;/a&gt;，让我们知道MQ在什么时候可以使用，可以解决什么问题，之后介绍了：&lt;a href=&quot;http://mp.weixin.qq.com/s/SeN8cKPzjcOR4CRBYfzYGQ&quot;&gt;RocketMQ集群部署配置&lt;/a&gt;；本篇文章接着上篇内容之后，来给大家介绍下RocketMQ快速入门。&lt;/p&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;h3 id=&quot;引入-rocketmq-client&quot;&gt;1、引入 rocketmq-client&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.&lt;span class=&quot;fu&quot;&gt;apache&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rocketmq&lt;/span&gt;&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;rocketmq-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;&lt;span class=&quot;fl&quot;&gt;4.1.0&lt;/span&gt;-incubating&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;编写producer&quot;&gt;2、编写Producer&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt; DefaultMQProducer producer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DefaultMQProducer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;producer_demo&quot;&lt;/span&gt;);
       &lt;span class=&quot;co&quot;&gt;//指定NameServer地址&lt;/span&gt;
        producer.&lt;span class=&quot;fu&quot;&gt;setNamesrvAddr&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;192.168.116.115:9876;192.168.116.116:9876&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//修改为自己的&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * Producer对象在使用之前必须要调用start初始化，初始化一次即可&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * 注意：切记不可以在每次发送消息时，都调用start方法&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt;
        producer.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();

        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;997892&lt;/span&gt;; i++) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;//构建消息&lt;/span&gt;
                Message msg = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Message&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;TopicTest&quot;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/* Topic */&lt;/span&gt;,
                    &lt;span class=&quot;st&quot;&gt;&quot;TagA&quot;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/* Tag */&lt;/span&gt;,
                    (&lt;span class=&quot;st&quot;&gt;&quot;测试RocketMQ&quot;&lt;/span&gt; + i).&lt;span class=&quot;fu&quot;&gt;getBytes&lt;/span&gt;(RemotingHelper.&lt;span class=&quot;fu&quot;&gt;DEFAULT_CHARSET&lt;/span&gt;)
                );

                &lt;span class=&quot;co&quot;&gt;//发送同步消息&lt;/span&gt;
                SendResult sendResult = producer.&lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(msg);

                System.&lt;span class=&quot;fu&quot;&gt;out.printf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s%n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, sendResult);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
                Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;);
            }
        }


producer.&lt;span class=&quot;fu&quot;&gt;shutdown&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;编写consumer&quot;&gt;3、编写Consumer&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Consumer Group,非常重要的概念，后续会慢慢补充&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
DefaultMQPushConsumer consumer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DefaultMQPushConsumer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;consumer_demo&quot;&lt;/span&gt;);
&lt;span class=&quot;co&quot;&gt;//指定NameServer地址，多个地址以 ; 隔开&lt;/span&gt;
consumer.&lt;span class=&quot;fu&quot;&gt;setNamesrvAddr&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;192.168.116.115:9876;192.168.116.116:9876&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//修改为自己的&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 如果非第一次启动，那么按照上次消费的位置继续消费&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
consumer.&lt;span class=&quot;fu&quot;&gt;setConsumeFromWhere&lt;/span&gt;(ConsumeFromWhere.&lt;span class=&quot;fu&quot;&gt;CONSUME_FROM_FIRST_OFFSET&lt;/span&gt;);

consumer.&lt;span class=&quot;fu&quot;&gt;subscribe&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;TopicTest&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;*&quot;&lt;/span&gt;);

consumer.&lt;span class=&quot;fu&quot;&gt;registerMessageListener&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MessageListenerConcurrently&lt;/span&gt;() {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ConsumeConcurrentlyStatus &lt;span class=&quot;fu&quot;&gt;consumeMessage&lt;/span&gt;(List&amp;lt;MessageExt&amp;gt; msgs,
    ConsumeConcurrentlyContext context) {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(MessageExt msg:msgs){
        String msgbody = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String(msg.&lt;span class=&quot;fu&quot;&gt;getBody&lt;/span&gt;(), &lt;span class=&quot;st&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;  MessageBody: &quot;&lt;/span&gt;+ msgbody);&lt;span class=&quot;co&quot;&gt;//输出消息内容&lt;/span&gt;
        }
    } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
        e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ConsumeConcurrentlyStatus.&lt;span class=&quot;fu&quot;&gt;RECONSUME_LATER&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;//稍后再试&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ConsumeConcurrentlyStatus.&lt;span class=&quot;fu&quot;&gt;CONSUME_SUCCESS&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;//消费成功&lt;/span&gt;
    }
});


consumer.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();

System.&lt;span class=&quot;fu&quot;&gt;out.printf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Consumer Started.&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;说明&quot;&gt;4、说明&lt;/h3&gt;
&lt;p&gt;各位根据自己的环境，修改NamesrvAddr的值，我的集群请参考：&lt;a href=&quot;http://mp.weixin.qq.com/s/SeN8cKPzjcOR4CRBYfzYGQ&quot;&gt;RocketMQ集群部署配置&lt;/a&gt;。稍后通过RocketMQ管控台就可以看到之前搭建的多Master多Slave模式，异步复制集群模式。&lt;/p&gt;
&lt;h3 id=&quot;通过rocketmq管控台&quot;&gt;5、通过RocketMQ管控台&lt;/h3&gt;
&lt;p&gt;rocketmq-console-ng获取方式为：&lt;a href=&quot;https://github.com/apache/rocketmq-externals/tree/master/rocketmq-console&quot;&gt;rocketmq-console-ng&lt;/a&gt;，之后通过mavne进行编译获取jar，命令如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;mvn clean &lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; -Dmaven.test.skip=true
java -jar target/rocketmq-console-ng&lt;span class=&quot;fl&quot;&gt;-1.0.0&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;jar&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到rocketmq-console-ng-1.0.0.jar之后，找到rocketmq-console-ng-1.0.0.jar\BOOT-INF\classes\application.properties文件，根据自己的NamesrvAddr进行修改rocketmq.config.namesrvAddr的值。&lt;/p&gt;
&lt;p&gt;直接启动：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;java -jar rocketmq-console-ng&lt;span class=&quot;fl&quot;&gt;-1.0.0&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;jar&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-9e31a4c828df89f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;管控台&quot;/&gt;&lt;br/&gt;管控台是基于springboot的，的确springboot非常方便和非常火了，所以有必要去学习下springboot了（其实还是spring系列，所以spring也必要深入学习下），稍后通过管控台进行观察运行。&lt;/p&gt;
&lt;h3 id=&quot;运行观察&quot;&gt;6、运行观察&lt;/h3&gt;
&lt;p&gt;一个好的习惯是先运行Consumer，之后在运行Producer，之后通过rocketmq-console-ng管控台观察&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-53732248cf8e4bd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;运行中截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行完成之后，的确broker-a的数据加上broker-b的数据量就等于我们发送的数据量，而且slave的数量也master的数量也是一致的，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-9507e06b57aaf0af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;运行完成&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看发送这些数据，2台机器的磁盘情况如下：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-6f5a9ee73f49ec9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;rocketmq1占用磁盘空间&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-3e99e4c95eacf2fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;rocketmq2占用磁盘空间&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到目前位置，关于RocketMQ快速入门就结束了，未完待续……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果读完觉得有收获的话，欢迎点赞加关注。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;个人公众号，欢迎关注，查阅更多精彩历史！！！&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-5f48f1430e958383.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;匠心零度公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 24 Nov 2017 14:22:00 +0000</pubDate>
<dc:creator>匠心零度</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lirenzuo/p/7892593.html</dc:identifier>
</item>
</channel>
</rss>