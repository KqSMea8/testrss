<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>centos7 redis伪集群安装 - Mr.chengJQ</title>
<link>http://www.cnblogs.com/qiyuan880794/p/9407469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiyuan880794/p/9407469.html</guid>
<description>&lt;p&gt;安装gcc： yum install gcc -y&lt;/p&gt;

&lt;p&gt;上传redis软件包到 /home下&lt;/p&gt;

&lt;p&gt;解压: tar xf redis-3.2.11.tar.gz&lt;/p&gt;

&lt;p&gt;进入 redis 目录 ： cd redis-3.2.11&lt;/p&gt;

&lt;p&gt;编译: make&lt;/p&gt;

&lt;p&gt;返回home下 : cd /home&lt;/p&gt;

&lt;p&gt;创建目录：&lt;/p&gt;
&lt;p&gt;mkdir redis-sentinel&lt;/p&gt;
&lt;p&gt;mkdir redis-sentinel/6379&lt;/p&gt;
&lt;p&gt;mkdir redis-sentinel/6380&lt;/p&gt;

&lt;p&gt;创建redis-cli 软链接：&lt;/p&gt;
&lt;p&gt;ln -s /home/redis-3.2.11/src/redis-cli /usr/bin/&lt;/p&gt;

&lt;p&gt;编写redis配置文件（注意所有ip地址改成自己虚拟机的ip！！！）&lt;/p&gt;
&lt;p&gt;vi /home/redis-sentinel/6379/redis.conf&lt;/p&gt;
&lt;p&gt;bind 0.0.0.0&lt;/p&gt;
&lt;p&gt;protected-mode yes&lt;/p&gt;
&lt;p&gt;port 6379&lt;/p&gt;
&lt;p&gt;tcp-backlog 511&lt;/p&gt;
&lt;p&gt;timeout 0&lt;/p&gt;
&lt;p&gt;tcp-keepalive 300&lt;/p&gt;
&lt;p&gt;daemonize yes&lt;/p&gt;
&lt;p&gt;supervised no&lt;/p&gt;
&lt;p&gt;pidfile &quot;/var/run/redis_6379.pid&quot;&lt;/p&gt;
&lt;p&gt;loglevel notice&lt;/p&gt;
&lt;p&gt;logfile &quot;&quot;&lt;/p&gt;
&lt;p&gt;databases 16&lt;/p&gt;
&lt;p&gt;save 900 1&lt;/p&gt;
&lt;p&gt;save 300 10&lt;/p&gt;
&lt;p&gt;save 60 10000&lt;/p&gt;
&lt;p&gt;stop-writes-on-bgsave-error yes&lt;/p&gt;
&lt;p&gt;rdbcompression yes&lt;/p&gt;
&lt;p&gt;rdbchecksum yes&lt;/p&gt;
&lt;p&gt;dbfilename &quot;dump.rdb&quot;&lt;/p&gt;
&lt;p&gt;dir &quot;/home/redis-sentinel/6379&quot;&lt;/p&gt;
&lt;p&gt;masterauth &quot;juziyanfa&quot;&lt;/p&gt;
&lt;p&gt;slave-serve-stale-data yes&lt;/p&gt;
&lt;p&gt;slave-read-only yes&lt;/p&gt;
&lt;p&gt;repl-diskless-sync no&lt;/p&gt;
&lt;p&gt;repl-diskless-sync-delay 5&lt;/p&gt;
&lt;p&gt;repl-disable-tcp-nodelay no&lt;/p&gt;
&lt;p&gt;slave-priority 100&lt;/p&gt;
&lt;p&gt;requirepass &quot;juziyanfa&quot;&lt;/p&gt;
&lt;p&gt;appendonly yes&lt;/p&gt;
&lt;p&gt;appendfilename &quot;appendonly.aof&quot;&lt;/p&gt;
&lt;p&gt;appendfsync everysec&lt;/p&gt;
&lt;p&gt;no-appendfsync-on-rewrite no&lt;/p&gt;
&lt;p&gt;auto-aof-rewrite-percentage 100&lt;/p&gt;
&lt;p&gt;auto-aof-rewrite-min-size 64mb&lt;/p&gt;
&lt;p&gt;aof-load-truncated yes&lt;/p&gt;
&lt;p&gt;lua-time-limit 5000&lt;/p&gt;
&lt;p&gt;slowlog-log-slower-than 10000&lt;/p&gt;
&lt;p&gt;slowlog-max-len 128&lt;/p&gt;
&lt;p&gt;latency-monitor-threshold 0&lt;/p&gt;
&lt;p&gt;notify-keyspace-events &quot;&quot;&lt;/p&gt;
&lt;p&gt;hash-max-ziplist-entries 512&lt;/p&gt;
&lt;p&gt;hash-max-ziplist-value 64&lt;/p&gt;
&lt;p&gt;list-max-ziplist-size -2&lt;/p&gt;
&lt;p&gt;list-compress-depth 0&lt;/p&gt;
&lt;p&gt;set-max-intset-entries 512&lt;/p&gt;
&lt;p&gt;zset-max-ziplist-entries 128&lt;/p&gt;
&lt;p&gt;zset-max-ziplist-value 64&lt;/p&gt;
&lt;p&gt;hll-sparse-max-bytes 3000&lt;/p&gt;
&lt;p&gt;activerehashing yes&lt;/p&gt;
&lt;p&gt;client-output-buffer-limit normal 0 0 0&lt;/p&gt;
&lt;p&gt;client-output-buffer-limit slave 256mb 64mb 60&lt;/p&gt;
&lt;p&gt;client-output-buffer-limit pubsub 32mb 8mb 60&lt;/p&gt;
&lt;p&gt;hz 10&lt;/p&gt;
&lt;p&gt;aof-rewrite-incremental-fsync yes&lt;/p&gt;
&lt;p&gt;slaveof 192.168.121.228 6380&lt;/p&gt;

&lt;p&gt;———————————————————————————————&lt;/p&gt;

&lt;p&gt;vi /home/redis-sentinel/6379/sentinel.conf&lt;/p&gt;
&lt;p&gt;bind 0.0.0.0&lt;/p&gt;
&lt;p&gt;protected-mode yes&lt;/p&gt;
&lt;p&gt;port 26379&lt;/p&gt;
&lt;p&gt;daemonize yes&lt;/p&gt;
&lt;p&gt;logfile &quot;./sentinel.log&quot;&lt;/p&gt;
&lt;p&gt;dir &quot;/tmp&quot;&lt;/p&gt;
&lt;p&gt;sentinel myid cce0dc9a6db63e09900b4a655e5b37e114b5b6d7&lt;/p&gt;
&lt;p&gt;sentinel monitor mymaster 192.168.121.228 6380 2&lt;/p&gt;
&lt;p&gt;sentinel down-after-milliseconds mymaster 5000&lt;/p&gt;
&lt;p&gt;sentinel failover-timeout mymaster 10000&lt;/p&gt;
&lt;p&gt;sentinel auth-pass mymaster juziyanfa&lt;/p&gt;
&lt;p&gt;sentinel config-epoch mymaster 919&lt;/p&gt;
&lt;p&gt;sentinel leader-epoch mymaster 3260&lt;/p&gt;
&lt;p&gt;sentinel known-slave mymaster 192.168.121.228 6379&lt;/p&gt;
&lt;p&gt;sentinel known-sentinel mymaster 192.168.121.228 26380 dce0dc9a6db63e09900b4a655e5b37e114b5b6d7&lt;/p&gt;
&lt;p&gt;sentinel current-epoch 3260&lt;/p&gt;

&lt;p&gt;——————————————————————————————————————————————&lt;/p&gt;

&lt;p&gt;vi /home/redis-sentinel/6380/redis.conf&lt;/p&gt;
&lt;p&gt;bind 0.0.0.0&lt;/p&gt;
&lt;p&gt;protected-mode yes&lt;/p&gt;
&lt;p&gt;port 6380&lt;/p&gt;
&lt;p&gt;tcp-backlog 511&lt;/p&gt;
&lt;p&gt;timeout 0&lt;/p&gt;
&lt;p&gt;tcp-keepalive 300&lt;/p&gt;
&lt;p&gt;daemonize yes&lt;/p&gt;
&lt;p&gt;supervised no&lt;/p&gt;
&lt;p&gt;pidfile &quot;/var/run/redis_6380.pid&quot;&lt;/p&gt;
&lt;p&gt;loglevel notice&lt;/p&gt;
&lt;p&gt;logfile &quot;&quot;&lt;/p&gt;
&lt;p&gt;databases 16&lt;/p&gt;
&lt;p&gt;save 900 1&lt;/p&gt;
&lt;p&gt;save 300 10&lt;/p&gt;
&lt;p&gt;save 60 10000&lt;/p&gt;
&lt;p&gt;stop-writes-on-bgsave-error yes&lt;/p&gt;
&lt;p&gt;rdbcompression yes&lt;/p&gt;
&lt;p&gt;rdbchecksum yes&lt;/p&gt;
&lt;p&gt;dbfilename &quot;dump.rdb&quot;&lt;/p&gt;
&lt;p&gt;dir &quot;/home/redis-sentinel/6380&quot;&lt;/p&gt;
&lt;p&gt;masterauth &quot;juziyanfa&quot;&lt;/p&gt;
&lt;p&gt;slave-serve-stale-data yes&lt;/p&gt;
&lt;p&gt;slave-read-only yes&lt;/p&gt;
&lt;p&gt;repl-diskless-sync no&lt;/p&gt;
&lt;p&gt;repl-diskless-sync-delay 5&lt;/p&gt;
&lt;p&gt;repl-disable-tcp-nodelay no&lt;/p&gt;
&lt;p&gt;slave-priority 100&lt;/p&gt;
&lt;p&gt;requirepass &quot;juziyanfa&quot;&lt;/p&gt;
&lt;p&gt;appendonly yes&lt;/p&gt;
&lt;p&gt;appendfilename &quot;appendonly.aof&quot;&lt;/p&gt;
&lt;p&gt;appendfsync everysec&lt;/p&gt;
&lt;p&gt;no-appendfsync-on-rewrite no&lt;/p&gt;
&lt;p&gt;auto-aof-rewrite-percentage 100&lt;/p&gt;
&lt;p&gt;auto-aof-rewrite-min-size 64mb&lt;/p&gt;
&lt;p&gt;aof-load-truncated yes&lt;/p&gt;
&lt;p&gt;lua-time-limit 5000&lt;/p&gt;
&lt;p&gt;slowlog-log-slower-than 10000&lt;/p&gt;
&lt;p&gt;slowlog-max-len 128&lt;/p&gt;
&lt;p&gt;latency-monitor-threshold 0&lt;/p&gt;
&lt;p&gt;notify-keyspace-events &quot;&quot;&lt;/p&gt;
&lt;p&gt;hash-max-ziplist-entries 512&lt;/p&gt;
&lt;p&gt;hash-max-ziplist-value 64&lt;/p&gt;
&lt;p&gt;list-max-ziplist-size -2&lt;/p&gt;
&lt;p&gt;list-compress-depth 0&lt;/p&gt;
&lt;p&gt;set-max-intset-entries 512&lt;/p&gt;
&lt;p&gt;zset-max-ziplist-entries 128&lt;/p&gt;
&lt;p&gt;zset-max-ziplist-value 64&lt;/p&gt;
&lt;p&gt;hll-sparse-max-bytes 3000&lt;/p&gt;
&lt;p&gt;activerehashing yes&lt;/p&gt;
&lt;p&gt;client-output-buffer-limit normal 0 0 0&lt;/p&gt;
&lt;p&gt;client-output-buffer-limit slave 256mb 64mb 60&lt;/p&gt;
&lt;p&gt;client-output-buffer-limit pubsub 32mb 8mb 60&lt;/p&gt;
&lt;p&gt;hz 10&lt;/p&gt;
&lt;p&gt;aof-rewrite-incremental-fsync yes&lt;/p&gt;

&lt;p&gt;————————————————————————————————————&lt;/p&gt;

&lt;p&gt;vi /home/redis-sentinel/6380/sentinel.conf&lt;/p&gt;
&lt;p&gt;bind 0.0.0.0&lt;/p&gt;
&lt;p&gt;protected-mode yes&lt;/p&gt;
&lt;p&gt;port 26380&lt;/p&gt;
&lt;p&gt;daemonize yes&lt;/p&gt;
&lt;p&gt;logfile &quot;./sentinel.log&quot;&lt;/p&gt;
&lt;p&gt;dir &quot;/tmp&quot;&lt;/p&gt;
&lt;p&gt;sentinel myid dce0dc9a6db63e09900b4a655e5b37e114b5b6d7&lt;/p&gt;
&lt;p&gt;sentinel monitor mymaster 192.168.121.228 6380 2&lt;/p&gt;
&lt;p&gt;sentinel down-after-milliseconds mymaster 5000&lt;/p&gt;
&lt;p&gt;sentinel failover-timeout mymaster 10000&lt;/p&gt;
&lt;p&gt;sentinel auth-pass mymaster juziyanfa&lt;/p&gt;
&lt;p&gt;sentinel config-epoch mymaster 919&lt;/p&gt;
&lt;p&gt;sentinel leader-epoch mymaster 3260&lt;/p&gt;
&lt;p&gt;sentinel known-slave mymaster 192.168.121.228 6379&lt;/p&gt;
&lt;p&gt;sentinel known-slave mymaster 192.168.0.121 6379&lt;/p&gt;
&lt;p&gt;sentinel known-sentinel mymaster 192.168.121.228 26379 cce0dc9a6db63e09900b4a655e5b37e114b5b6d7&lt;/p&gt;
&lt;p&gt;sentinel current-epoch 3260&lt;/p&gt;

&lt;p&gt;——————————————————————————————————————&lt;/p&gt;

&lt;p&gt;启动redis：&lt;/p&gt;
&lt;p&gt;cd /home/redis-3.2.11/src/&lt;/p&gt;

&lt;p&gt;./redis-server /home/redis-sentinel/6379/redis.conf&lt;/p&gt;
&lt;p&gt;./redis-sentinel /home/redis-sentinel/6379/sentinel.conf&lt;/p&gt;
&lt;p&gt;./redis-server /home/redis-sentinel/6380/redis.conf&lt;/p&gt;
&lt;p&gt;./redis-sentinel /home/redis-sentinel/6380/sentinel.conf&lt;/p&gt;
&lt;p&gt;ps -ef |grep redis&lt;/p&gt;

&lt;p&gt;关闭防火墙&lt;/p&gt;
&lt;p&gt;ss -ln 找到6379 和 6380端口就可以&lt;/p&gt;

&lt;p&gt;redis:192.168.121.38 6379 auth：juziyanfa&lt;/p&gt;
&lt;p&gt;26379 和 26380 中的protected-mode：no&lt;/p&gt;

</description>
<pubDate>Thu, 02 Aug 2018 07:33:00 +0000</pubDate>
<dc:creator>Mr.chengJQ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiyuan880794/p/9407469.html</dc:identifier>
</item>
<item>
<title>redis系列--主从复制以及redis复制演进 - W-D</title>
<link>http://www.cnblogs.com/wdliu/p/9407179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wdliu/p/9407179.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;　　在之前的文章已经详细介绍了redis入门基础已经持久化相关内容包括redis4.0所提供的混合持久化。&lt;/p&gt;
&lt;p&gt;　　通过持久化功能，Redis保证了即使在服务器宕机情况下数据的丢失非常少。但是如果这台服务器出现了硬盘故障、系统崩溃等等，不仅仅是数据丢失，很可能对业务造成灾难性打击。为了避免单点故障通常的做法是将数据复制多个副本保存在不同的服务器上，这样即使有其中一台服务器出现故障，其他服务器依然可以继续提供服务。当然Redis提供了多种高可用方案包括：主从复制、哨兵模式的主从复制、以及集群。&lt;/p&gt;
&lt;p&gt;　　本文将详细介绍Redis从2.6以到4.0提供复制方案的演进，也包括：主从复制、复制原理以及相关实践。&lt;/p&gt;
&lt;h2&gt;二、主从复制&lt;/h2&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;　　在主从复制中，数据库分为两类，一类是主库(master)，另一类是同步主库数据的从库(slave)。主库可以进行读写操作，当写操作导致数据变化时会自动同步到从库。而从库一般是只读的(特定情况也可以写,通过参数slave-read-only指定)，并接受来自主库的数据，一个主库可拥有多个从库，而一个从库只能有一个主库。这样就使得redis的主从架构有了两种模式：一类是一主多从如下图1，二类是“链式主从复制”--主-&amp;gt;从-&amp;gt;主-从如下图2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180730155111136-745183766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180730155309716-991924999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于一主多从的复制架构不必多说，这里解释下链式主从复制：如上图2，主库A的数据会同步到从库B和从库C，而B又是从库D和从库E的主库，所以B的数据会同步到从库D和从库E。如果向B中写数据，数据只能同步到D和E中，所以对于这种架构数据的一致性将不能保持，也不推荐这种架构。&lt;/p&gt;

&lt;h3&gt;搭建配置主从&lt;/h3&gt;
&lt;p&gt;　　由于没有过多的机器，这里将使用一台机器上启动多个redis实例实现主从复制。&lt;/p&gt;
&lt;p&gt;　　对于redis来说搭建主从非常容易，引用官网一句话来说：there is a very simple to use and configure leader follower (master-slave) replication。&lt;/p&gt;
&lt;p&gt;　　本次实践分别以 &lt;strong&gt;10.1.210.68:6379&lt;/strong&gt; 作为主，两个从服务器分别是 &lt;strong&gt;10.1.210.69:6380&lt;/strong&gt; 和 &lt;strong&gt;10.1.210.69:6381&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;搭建步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将redis.conf文件拷贝三份，名称最好有显示的区别，我这里采用名字为 6379.conf、 6380.conf、 6381.conf；&lt;/li&gt;
&lt;li&gt;分别修改三个文件的ip(默认127.0.0.1可以不用修改)、端口(尽量和配置文件一致)、pid文件，日志文件，持久化数据目录(dir)、后台运行(daemonize yes);&lt;/li&gt;
&lt;li&gt;使用启动命令脚本启动每个redis服务；&lt;/li&gt;
&lt;li&gt;设置主从关系、验证主从同步；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;步骤一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;建立三个redis目录&lt;/span&gt;
mkdir -p /opt/db/&lt;span&gt;{redis6379,redis6380,redis6381} 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从源码中拷贝配置文件&lt;/span&gt;
cp redis-stable/redis.conf /opt/db/redis6379/6379&lt;span&gt;.conf
cp redis&lt;/span&gt;-stable/redis.conf /opt/db/redis6380/6380&lt;span&gt;.conf 
cp redis&lt;/span&gt;-stable/redis.conf /opt/db/redis6381/6381.conf 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤二：&lt;/p&gt;
&lt;p&gt;修改配置项如下：找到对应的参数修改即可,下面是每个配置文件修改部分、本机器IP地址是10.1.210.69；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9031bafd-b918-4ee5-a7c9-c69a4738a188')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_9031bafd-b918-4ee5-a7c9-c69a4738a188&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9031bafd-b918-4ee5-a7c9-c69a4738a188&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9031bafd-b918-4ee5-a7c9-c69a4738a188',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9031bafd-b918-4ee5-a7c9-c69a4738a188&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
daemonize yes   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改redis为后台运行模式&lt;/span&gt;
&lt;span&gt;
pidfile &lt;/span&gt;/var/run/redis_6379.pid  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改运行的redis实例的pid，不能重复&lt;/span&gt;
&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/db/redis6379/6379.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;指明日志文件&lt;/span&gt;
&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/db/redis6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;工作目录，存放持久化数据的目录&lt;/span&gt;
&lt;span&gt;
bind &lt;/span&gt;10.1.210.69   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;监听地址，如果是单机多个示例可以不用修改&lt;/span&gt;
&lt;span&gt;
port &lt;/span&gt;6379         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;监听端口，保持和配置文件名称端口一致&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;6379.conf&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7b5f6ea7-f942-4880-b57b-a6d3c2016c09')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7b5f6ea7-f942-4880-b57b-a6d3c2016c09&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7b5f6ea7-f942-4880-b57b-a6d3c2016c09&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7b5f6ea7-f942-4880-b57b-a6d3c2016c09',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7b5f6ea7-f942-4880-b57b-a6d3c2016c09&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
daemonize yes   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改redis为后台运行模式&lt;/span&gt;
&lt;span&gt;
pidfile &lt;/span&gt;/var/run/redis_6380.pid  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改运行的redis实例的pid，不能重复&lt;/span&gt;
&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/db/redis6380/6380.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;指明日志文件&lt;/span&gt;
&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/db/redis6380&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;工作目录，存放持久化数据的目录&lt;/span&gt;
&lt;span&gt;
bind &lt;/span&gt;10.1.210.69   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;监听地址，如果是单机多个示例可以不用修改&lt;/span&gt;
&lt;span&gt;
port &lt;/span&gt;6380         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;监听端口，保持和配置文件名称端口一致&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;6380.conf&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fe529587-e05d-42a6-9108-405500cfcc9c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_fe529587-e05d-42a6-9108-405500cfcc9c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fe529587-e05d-42a6-9108-405500cfcc9c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fe529587-e05d-42a6-9108-405500cfcc9c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fe529587-e05d-42a6-9108-405500cfcc9c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
daemonize yes   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改redis为后台运行模式&lt;/span&gt;
&lt;span&gt;
pidfile &lt;/span&gt;/var/run/redis_6381.pid  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改运行的redis实例的pid，不能重复&lt;/span&gt;
&lt;span&gt;
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/db/redis6379/6381.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;指明日志文件&lt;/span&gt;
&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/db/redis6381&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;工作目录，存放持久化数据的目录&lt;/span&gt;
&lt;span&gt;
bind &lt;/span&gt;10.1.210.69   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;监听地址，如果是单机多个实例可以不用修改使用127.0.0.1&lt;/span&gt;
&lt;span&gt;
port &lt;/span&gt;6381         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;监听端口，保持和配置文件名称端口一致&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;6381.conf&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;步骤三：&lt;/p&gt;
&lt;p&gt;启动每个redis实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
redis-server /opt/db/redis6379/6379&lt;span&gt;.conf
redis&lt;/span&gt;-server /opt/db/redis6380/6380&lt;span&gt;.conf
redis&lt;/span&gt;-server /opt/db/redis6381/6381.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤四：&lt;/p&gt;
&lt;p&gt;设置主从关系，当然你可以直接指明从库配置文件直接使用slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;指定，这里我在用客户端修改，分别使用客户端redis-cli命令连入端口为6380、6381的redis。&lt;/p&gt;
&lt;p&gt;连入6380数据库，使用redis-cli -h 10.1.210.69 -p 6380,其中-h代表ip地址，-p代表端口，并执行slaveof 10.1.210.69 6379，并写入配置文件config rewrite，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180730173050083-989231580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样我们在从库6381执行相同操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180730173207029-1055620923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们在使用info Replication 查看相关主从信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180730173642102-1640307242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同时，还可以测试主从功能，在6379上创建key，在从库查看：&lt;/p&gt;
&lt;p&gt;主库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180730173801008-2132033550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180730173841113-1788529495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;三、复制原理 &lt;/h2&gt;
&lt;p&gt;　　了解redis复制原理对日后运维有很大帮助，包括如何规划节点，如何处理节点故障，redis复制过程可分为三个阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;复制初始化阶段&lt;/li&gt;
&lt;li&gt;数据同步阶段&lt;/li&gt;
&lt;li&gt;命令传播阶段&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;复制初始化阶段&lt;/h3&gt;
&lt;p&gt;　　当执行完slaveof  masterip  port 命令时候，从库根据指明的master节点ip和port向主库发起socket连接，主库收到socket连接之后将连接信息保存，此时连接建立；&lt;/p&gt;
&lt;p&gt;　　当socket连接建立完成以后，从库向主库发送ping命令，以确认主库是否可用，此时的结果返回如果是PONG则代表主库可以用，否则可能出现超时或者主库此时在处理其他任务阻塞那么此时从库将断开socket连接，然后进行重试；&lt;/p&gt;
&lt;p&gt;　　如果主库连接设置了密码，则从库需要设置masterauth参数，此时从库会发送auth命令，命令格式为“auth + 密码”进行密码验证，其中密码为masterauth参数配置的密码，需要注意的是如果主库设置了密码验证，从库未配置masterauth参数则报错，socket连接断开。&lt;/p&gt;
&lt;p&gt;　　当身份验证完成以后，从节点发送自己的监听端口，主库保存其端口信息，此时进入下一个阶段：数据同步阶段。&lt;/p&gt;
&lt;h3&gt;数据同步阶段&lt;/h3&gt;
&lt;p&gt;　　主库和从库都确认对方信息以后，便可开始数据同步，此时从库向主库发送psync命令(需要注意的是redis4.0版本对2.8版本的psync做了优化，后续会进行说明)，主库收到该命令后判断是进行增量复制还是全量复制，然后根据策略进行数据的同步，当主库有新的写操作时候，此时进入复制第三阶段：命令传播阶段。&lt;/p&gt;
&lt;h3&gt;命令传播阶段&lt;/h3&gt;
&lt;p&gt;　　当数据同步完成以后，在此后的时间里主从维护着心跳检查来确认对方是否在线，每隔一段时间（默认10秒，通过repl-ping-slave-period参数指定）主节点向从节点发送PING命令判断从节点是否在线，而从节点每秒1次向主节点发送REPLCONF ACK命令&lt;strong&gt;，&lt;/strong&gt;命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量，作用一是汇报自己复制偏移量，主节点会对比复制偏移量向从节点发送未同步的命令，作用二在于判断主节点是否在线，从库接送命令并执行，最终实现与主库数据相同。&lt;/p&gt;
&lt;h3&gt;乐观复制&lt;/h3&gt;
&lt;p&gt;　　redis采用量乐观复制策略，容忍在一定时间内主从数据内容是不同的，但是两者的数据最终会同步。&lt;/p&gt;

&lt;h2&gt;四、redis复制演进&lt;/h2&gt;
&lt;h3&gt;sync&amp;amp;psync1&amp;amp;psync2&lt;/h3&gt;
&lt;p&gt;　　从redis2.6到4.0开发人员对其复制流程进行逐步的优化，以下是演进过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;redis版本&amp;lt;=2.6&amp;lt;2.8,复制采用sync命令，无论是第一次主从复制还是断线重连进行复制都采用全量复制；&lt;/li&gt;
&lt;li&gt;2.8&amp;lt;=redis版本&amp;lt;4.0,复制采用psync，从redis2.8开始，redis复制从sync过渡到psync，这一特性主要添加了redis在断线重新时候可使用部分复制；&lt;/li&gt;
&lt;li&gt;redis版本&amp;gt;=4.0，也采用psync，相比与2.8版本的psync优化了增量复制，这里我们称为psync2，2.8版本的psync称为psync1。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　以下将分别说明各个版本的复制演进。&lt;/p&gt;
&lt;h3&gt;sync&lt;/h3&gt;
&lt;p&gt;　　在redis2.6以及以前的版本，复制采用sync命令，当一个从库启动后，会向主库发送sync命令，主库收到sync命令后执行bgsave后台保存RDB快照（该过程在上一篇已经详细介绍），同时将保存快照的将快照保存期间接受的写命令保存到缓冲队列。当快照完成以后，主库将快照文件已经缓存的所有命令发送给从库，从库接受到快照文件并载入，再将执行主库发送的命令，也就是上面我们介绍的复制初始化阶段和数据同步阶段，其后就是命令增量同步，最终主库与从库保持数据一直。&lt;/p&gt;
&lt;p&gt;　　当从库在某些情况断线重连（如从库重启、由于网络原因主从连接超时），重复上述过程，进行数据同步。由此可见，redis2.6版本以及2.6以前复制过程全部采用全量复制。&lt;/p&gt;
&lt;p&gt;　　sync虽然解决了数据同步问题，但是在数据量比较大情况下，从库断线从来依然采用全量复制机制，无论是从数据恢复、宽带占用来说，sync所带来的问题还是很多的。于是redis从2.8开始，引入新的命令psync。&lt;/p&gt;
&lt;h3&gt;psync1&lt;/h3&gt;
&lt;p&gt;　　在redis2.8版本，redis引入psync命令来进行主从的数据同步，这里我们称该命令为psync1。psync1实现依赖以下三个关键点：&lt;/p&gt;
&lt;p&gt;　　1.&lt;strong&gt;offset（复制偏移量）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　主库和从库分别各自维护一个复制偏移量（可以使用info replication查看），用于标识自己复制的情况，在主库中代表主节点向从节点传递的字节数，在从库中代表从库同步的字节数。每当主库向从节点发送N个字节数据时，主节点的offset增加N，从库每收到主节点传来的N个字节数据时，从库的offset增加N。因此offset总是不断增大，这也是判断主从数据是否同步的标志，若主从的offset相同则表示数据同步量，不通则表示数据不同步。以下图示分别代表某个时刻两个主从的同步情况（以下是4.0版本截图）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180801135444197-751445165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180801135522241-1234065587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;　　2.replication backlog buffer（复制积压缓冲区）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;复制积压缓冲区是一个固定长度的FIFO队列，大小由配置参数repl-backlog-size指定，默认大小1MB。需要注意的是该缓冲区由master维护并且有且只有一个，所有slave共享此缓冲区，其作用在于备份最近主库发送给从库的数据。&lt;/p&gt;
&lt;p&gt;　　在主从命令传播阶段，主节点除了将写命令发送给从节点外，还会发送一份到复制积压缓冲区，作为写命令的备份。除了存储最近的写命令，复制积压缓冲区中还存储了每个字节相应的复制偏移量（如下图），由于复制积压缓冲区固定大小先进先出的队列，所以它总是保存的是最近redis执行的命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180801160728206-427681814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3.run_id(服务器运行的唯一ID) &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　每个redis实例在启动时候，都会随机生成一个长度为40的唯一字符串来标识当前运行的redis节点，查看此id可通过命令info server查看。&lt;/p&gt;
&lt;p&gt;　　当主从复制在初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来,当断线重连时，从节点会将这个runid发送给主节点。主节点根据runid判断能否进行部分复制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会更具offset偏移量之后的数据判断是否执行部分复制，如果offset偏移量之后的数据仍然都在复制积压缓冲区里，则执行部分复制，否则执行全量复制；&lt;/li&gt;
&lt;li&gt;如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的redis节点并不是当前的主节点，只能进行全量复制;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　介绍完三个概念以后，接下来就可以介绍redis2.8提供的psync命令实现过程，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180801182353640-84564117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　图文说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器进行完整重同步（因为这时不可能执行部分重同步）；&lt;/li&gt;
&lt;li&gt;相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC &amp;lt;runid&amp;gt; &amp;lt;offset&amp;gt;命令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作，如何判断已经在介绍runid时进行详细说明。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据情况，接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果主服务器返回+FULLRESYNC &amp;lt;runid&amp;gt; &amp;lt;offset&amp;gt;回复，那么表示主服务器将与从服务器执行完整重同步操作：其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量；&lt;/li&gt;
&lt;li&gt;如果主服务器返回+CONTINUE回复，那么表示主服务器将与从服务器执行部分同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了；&lt;/li&gt;
&lt;li&gt;如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　由此可见psync也有不足之处，当从库重启以后runid发生变化，也就意味者从库还是会进行全量复制，而在实际的生产中进行从库的维护很多时候会进行重启，而正是有由于全量同步需要主库执行快照，以及数据传输会带不小的影响。因此在4.0版本，psync命令做了改进，以下说明。&lt;/p&gt;
&lt;h3&gt;psync2&lt;/h3&gt;
&lt;p&gt;　　redis4.0新版本除了增加混合持久化，还优化了psync（以下称psync2）并实现即使redis实例重启的情况下也能实现部分同步，下面主要介绍psync2实现过程。psync2在psync1基础上新增两个复制id（可使用info replication 查看如下图）：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;master_replid: 复制id1(后文简称：replid1)，一个长度为41个字节(40个随机串+’0’)的字符串，每个redis实例都有，和runid没有直接关联，但和runid生成规则相同。当实例变为从实例后，自己的replid1会被主实例的replid1覆盖。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;master_replid2：复制id2(后文简称:replid2),默认初始化为全0，用于存储上次主实例的replid1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180801192922018-1514588913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在4.0之前的版本，redis复制信息完全丢失，所以每个实例重启后只能进行全量复制，到了4.0版本，任然可以使用部分同步，其实现过程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：存储复制信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;redis在关闭时，通过shutdown save,都会调用rdbSaveInfoAuxFields函数，把当前实例的repl-id和repl-offset保存到RDB文件中,当前的RDB存储的数据内容和复制信息是一致性的可通过redis-check-rdb命令查看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：重启后加载RDB文件中的复制信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　redis加载RDB文件，会专门处理文件中辅助字段(AUX fields）信息，把其中repl_id和repl_offset加载到实例中，分别赋给master_replid和master_repl_offset两个变量值，特别注意当从库开启了AOF持久化，redis加载顺序发生变化优先加载AOF文件，但是由于aof文件中没有复制信息，所以导致重启后从实例依旧使用全量复制！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：向主库上报复制信息，判断是否进行部分同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　从实例向主库上报master_replid和master_repl_offset+1；从实例同时满足以下两条件，就可以部分重新同步，否则执行全量同步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从实例上报master_replid串，与主实例的master_replid1或replid2有一个相等，用于判断主从未发生改变；&lt;/li&gt;
&lt;li&gt;从实例上报的master_repl_offset+1字节，还存在于主实例的复制积压缓冲区中，用于判断从库丢失部分是否在复制缓冲区中；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;psync2除了解决redis重启使用部分同步外，还为解决在主库故障时候从库切换为主库时候使用部分同步机制。redis从库默认开启复制积压缓冲区功能，以便从库故障切换变化master后，其他落后该从库可以从缓冲区中获取缺少的命令。该过程的实现通过两组replid、offset替换原来的master runid和offset变量实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一组：master_replid和master_repl_offset：如果redis是主实例，则表示为自己的replid和复制偏移量； 如果redis是从实例，则表示为自己主实例的replid1和同步主实例的复制偏移量。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;第二组：master_replid2和second_repl_offset：无论主从，都表示自己上次主实例repid1和复制偏移量；用于兄弟实例或级联复制，主库故障切换psync。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;判断是否使用部分复制条件：如果从库提供的master_replid与master的replid不同，且与master的replid2不同，或同步速度快于master； 就必须进行全量复制，否则执行部分复制。&lt;/p&gt;
&lt;p&gt;以下常见的主从切换都可以使用部分复制：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一主一从发生切换，A-&amp;gt;B 切换变成 B-&amp;gt;A ;&lt;/li&gt;
&lt;li&gt;一主多从发生切换，兄弟节点变成父子节点时；&lt;/li&gt;
&lt;li&gt;级别复制发生切换， A-&amp;gt;B-&amp;gt;C 切换变成 B-&amp;gt;C-&amp;gt;A；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;用一句redis开发者话来说psync2，尽管它不是非常完美，但是已经非常适用。&lt;/p&gt;

&lt;h2&gt;五、马上实践&lt;/h2&gt;
&lt;p&gt;　　为了演示4.0的psync2功能，这里做实践演示。主从实例采用上述搭建的主从架构，主库：10.1.210.69:6379 、从库：10.1.210.69:6380和10.1.210.69:6381。首先关闭一台从节点10.1.210.69:6380：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180802113700324-25622018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看日志从库执行了RDB快照： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180802113741228-1335790172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看RDB文件，里面记录了相关复制信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180802122133431-232307850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们在启动从库，查看对应日志，此时启用部分复制来恢复数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180802122301440-618859517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前提到过，当从库开启来AOF持久化时候，重启时加载文件从AOF文件中加载，但是AOF文件中没有对应的复制信息，所以从实例依旧采用全量复制。以下是从库开启AOF持久化后，重启日志，可以看到是全量同步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1075473/201808/1075473-20180802123535888-1553147287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;六、总结 &lt;/h2&gt;
&lt;h3&gt;复制演进中解决的问题&lt;/h3&gt;
&lt;p&gt;　　早起版本才用的sync同步方法，虽然实现了简单的主从同步，但是在从库断线或重启时无法实现部分同步，由此在2.8版本推出psync1，redis2.8的部分同步机制，有效解决了网络环境不稳定、redis执行高时间复杂度的命令引起的复制中断，从而导致全量同步。但在应对从库重启和主库故障切换的场景时，psync1还是需进行全量同步。于是在4.0新的psync得到了加强，redis4.0通过在关闭时候执行RDB快照，将复制信息保存在RDB中等到重新启动时加载RDB文件载入复制信息，通过对比复制信息启用部分复制，有效的解决了psync1情形下从库重启复制信息丢失而导致全量同步的问题。同时引入两组replid、offset，主从切换时交换两组值来实现主从故障切换时候依旧采用部分复制。&lt;/p&gt;
&lt;p&gt;　　再次强调，在上述的过程的实现是从库不开启AOF持久化情况下,如果从库开启的AOF持久化，重启时候依然使用全量复制。&lt;/p&gt;

&lt;h3&gt;故障切换　&lt;/h3&gt;
&lt;p&gt;　　在实际生产环境中，在没有哨兵的主从架构里如果要重启从库，比较好的方式是先动态调配主库中的复制积压缓冲队列，调整大小应大于某个N值，N值计算公式：backlog_size = 重启从实例时长 * 主实例offset每秒写入量，这样好处在于，即使从库重启断线一段时间后再启动任然保持部分复制。调整方式通过config set repl-backlog-size &amp;lt;字节数&amp;gt;，当我们重启完成后又可以将&lt;/p&gt;
&lt;p&gt;repl-backlog-size重新调回原有值。当然在数据量小或者重启时间短情况下，也可以直接重启从节点。　&lt;/p&gt;
&lt;p&gt;　　当主库宕机时候，在没有哨兵情况下，需要现将从节点中的某一台提升为主库，我们需要在所有从节点中找到当前的offset最大值的从库（这样代表该库相对其他从库数据较全），然后执行slaveof no one将该从库提升为主库，最后将所有其他重库依次执行slaveof ip port（ip和port是新主库的IP地址和端口），最后完成故障切换。此外，redis4.0中这种切换任然采用部分复制进行数据同步。&lt;/p&gt;

&lt;h3&gt;主从配置参数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#######从库##############&lt;/span&gt;
&lt;span&gt;
slaveof &lt;/span&gt;&amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt; 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置该数据库为其他数据库的从数据库&lt;/span&gt;
&lt;span&gt;
masterauth &lt;/span&gt;&amp;lt;master-password&amp;gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;主从复制中，设置连接master服务器的密码（前提master启用了认证）&lt;/span&gt;
&lt;span&gt;
slave&lt;/span&gt;-serve-stale-&lt;span&gt;data yes
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当从库同主库失去连接或者复制正在进行，从库有两种运行方式：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续相应客户端的请求&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2) 如果slave-serve-stale-data是指为no，除了INFO和SLAVOF命令之外的任何请求都会返回一个错误&quot;SYNC with master in progress&quot;&lt;/span&gt;
&lt;span&gt;
slave&lt;/span&gt;-priority 100
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;当主库发生宕机时候，哨兵会选择优先级最高的一个称为主库，从库优先级配置默认100，数值越小优先级越高&lt;/span&gt;
&lt;span&gt;
slave&lt;/span&gt;-read-&lt;span&gt;only yes
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从节点是否只读；默认yes只读，为了保持数据一致性，应保持默认&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###主库##############&lt;/span&gt;
&lt;span&gt;
repl&lt;/span&gt;-disable-tcp-&lt;span&gt;nodelay no
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在slave和master同步后（发送psync/sync），后续的同步是否设置成TCP_NODELAY假如设置成yes，则redis会合并小的TCP包从而节省带宽，但会增加同步延迟（40ms），造成master与slave数据不一致假如设置成no，则redis master会立即发送同步数据，没有延迟&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;前者关注性能，后者关注一致性&lt;/span&gt;
&lt;span&gt;
repl&lt;/span&gt;-ping-slave-period 10
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从库会按照一个时间间隔向主库发送PING命令来判断主服务器是否在线，默认是10秒&lt;/span&gt;
&lt;span&gt;
repl&lt;/span&gt;-backlog-&lt;span&gt;size 1mb
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;复制积压缓冲区大小设置&lt;/span&gt;
&lt;span&gt;
repl&lt;/span&gt;-backlog-ttl 3600
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。&lt;/span&gt;
&lt;span&gt;
min&lt;/span&gt;-slaves-to-write 3&lt;span&gt;
min&lt;/span&gt;-slaves-max-lag 10
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置某个时间断内，如果从库数量小于该某个值则不允许主机进行写操作，以上参数表示10秒内如果主库的从节点小于3个，则主库不接受写请求，min-slaves-to-write 0代表关闭此功能。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 02 Aug 2018 07:01:00 +0000</pubDate>
<dc:creator>W-D</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wdliu/p/9407179.html</dc:identifier>
</item>
<item>
<title>IOS NSNotification 通知 - 冬季的暖风</title>
<link>http://www.cnblogs.com/zhouDongdong/p/9406166.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouDongdong/p/9406166.html</guid>
<description>&lt;p&gt;&lt;span&gt;1. NSNotification 通知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;@interface NSNotification : NSObject &amp;lt;NSCopying, NSCoding&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接口通知，&lt;span&gt;继承NSObject&lt;/span&gt;，实现NSCopying，NSCoding协议&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　A container for information broadcast through a notification center to all registered observers.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过通知中心向所有注册观察员进行信息广播的&lt;span&gt;容器&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　You don’t usually create your own notifications directly, but instead call the NSNotificationCenter methods.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你&lt;span&gt;不能使用init去创建&lt;/span&gt;，而是调用NSNotificationCenter下的方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2. NSNotificationCenter 通知中心&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;A notification dispatch mechanism that enables the broadcast of information to registered observers.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一种&lt;span&gt;通知调度机制&lt;/span&gt;，该机制允许向注册观察员广播信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　Each running app has a defaultCenter notification center, and you can create new notification centers to organize communications in particular contexts.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;每个运行的应用程序都有一个默认中心通知中心&lt;/span&gt;，您可以创建新的通知中心来组织特定上下文中的通信&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　A notification center can deliver notifications only within a single program; if you want to post a notification to other processes or receive notifications from other processes, use NSDistributedNotificationCenter instead.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通知中心只能在单个程序中传递通知；如果要将通知发布到其他进程或接收来自其他进程的通知，则使用NSdultDeNeTimeCenter代替&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3. addObserver(_:selector:name:object:) 添加观察者方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;topic-container section-content row&quot;&gt;
&lt;div class=&quot;topic-description column large-9 medium-9 small-12&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;topic-abstract abstract formatted-content&quot; readability=&quot;35&quot;&gt;
&lt;p&gt;　&lt;span&gt;　Adds an entry to the notification center's dispatch table with an observer, a selector, and an optional notification name and sender.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　使用&lt;span&gt;观察者、选择器和可选通知名称和发送器&lt;/span&gt;向通知中心的调度表添加条目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Declaration 声明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/772820/201808/772820-20180802121118224-1948568015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;*observer&lt;/span&gt; &lt;span&gt;观察者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　作为观察者注册的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;*aSelector&lt;/span&gt; &lt;span&gt;选择器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当发出通知时，通知中心将向通知观察者发送通知的选择器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;*aName &lt;/span&gt;&lt;span&gt;注册观察员的通知的名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当NIL时，通知中心不使用通知的名称来决定是否将其传递给观察者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;*anObject &lt;/span&gt;观察者希望接收的通知对象 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当NIL时，通知中心不使用通知的发送方来决定是否将其传递给观察者&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4. postNotificationName(_:object:userInfo:) 发送通知消息的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;Creates a notification with a given name, sender, and information and posts it to the notification center.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　创建一个带有&lt;span&gt;给定名称、发送者和信息的通知&lt;/span&gt;，并将其发布到通知中心&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)postNotificationName:(NSNotificationName)aName
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;                           &lt;span&gt;object&lt;/span&gt;:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)anObject
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;                          userInfo:(NSDictionary *)aUserInfo;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; * &lt;code class=&quot;parameter-name&quot;&gt;aName&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;parameter-discussion formatted-content&quot;&gt;
&lt;p&gt;&lt;span&gt;　　通知的名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;* anObject&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;parameter-discussion formatted-content&quot; readability=&quot;32&quot;&gt;
&lt;p&gt;&lt;span&gt;　　发布通知的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;* aUserInfo&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;parameter-discussion formatted-content&quot; readability=&quot;81.889845500649&quot;&gt;
&lt;p&gt;&lt;span&gt;　　关于通知的可选信息&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5. removeObserver:name:object: 移除观察者的方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;trans-right&quot;&gt;
&lt;div class=&quot;output-wrap small-font&quot;&gt;
&lt;div class=&quot;output-mod ordinary-wrap&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;output-bd&quot; dir=&quot;ltr&quot; readability=&quot;10&quot;&gt;
&lt;p class=&quot;ordinary-output target-output clearfix&quot;&gt;&lt;span&gt;　　&lt;span&gt;从通知中心的调度表中移除指定观察者的所有指定条目。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ordinary-output target-output clearfix&quot;&gt;&lt;span&gt;　　如果你的应用程序瞄准了iOS 9和后来的Mac OS 10.11和以后，你就不需要在它的 dealloc 方法中注销观察者&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre class=&quot;declaration&quot;&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;- (&lt;span&gt;void&lt;/span&gt;)removeObserver:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)observer;
&lt;br/&gt;&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)removeObserver:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)observer 
   　　　　　　　　　name:(NSString &lt;/span&gt;*&lt;span&gt;)aName 
   　　　　　　　　&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;:(&lt;span&gt;id&lt;/span&gt;)anObject;  &lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 二. 通知使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;declaration&quot;&gt;
&lt;span&gt;&lt;span&gt;示例背景： 用到两个ViewController,分别是 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;NotificationVC，TestVCViewController，当前代码写在NotificationVC中&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;1. 注册通知&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化通知中心&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     NSNotificationCenter * center =&lt;span&gt; [NSNotificationCenter defaultCenter];&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册通知&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     [center addObserver:self selector:@selector(methodTest:) name:nil       &lt;span&gt;object&lt;/span&gt;:nil];
&lt;span&gt; 5&lt;/span&gt;     [center addObserver:self selector:@selector(sadNotif:)   name:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;sad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;    &lt;span&gt;object&lt;/span&gt;:nil];
&lt;span&gt; 6&lt;/span&gt;     [center addObserver:self selector:@selector(smileNotif:) name:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;smile&lt;/span&gt;&lt;span&gt;&quot; &lt;/span&gt; &lt;span&gt;object&lt;/span&gt;:nil];
&lt;span&gt; 7&lt;/span&gt;     [center addObserver:self selector:@selector(sad2Notif:)  name:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;sad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;    &lt;span&gt;object&lt;/span&gt;:self];
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     [center addObserver:test selector:@selector(testNotif:)  name:nil       &lt;span&gt;object&lt;/span&gt;:nil];
&lt;span&gt;10&lt;/span&gt;     [center addObserver:test selector:@selector(sadNotif:)   name:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;sad&lt;/span&gt;&lt;span&gt;&quot;   &lt;/span&gt; &lt;span&gt;object&lt;/span&gt;:nil];
&lt;span&gt;11&lt;/span&gt;     [center addObserver:test selector:@selector(smileNotif:) name:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;smile&lt;/span&gt;&lt;span&gt;&quot; &lt;/span&gt; &lt;span&gt;object&lt;/span&gt;:nil];
&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用法说明
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;上面使用了两个监听器self,test，并且就参数三name，参数四object不同情况分别作出示例&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     [center &lt;span&gt;addObserver&lt;/span&gt;:&amp;lt;#(nonnull id)#&amp;gt; &lt;br/&gt;　　　　　　　　　    &lt;span&gt;selector&lt;/span&gt;:&amp;lt;#(nonnull SEL)#&amp;gt; &lt;br/&gt;&lt;span&gt;　　　　　　　　　        name&lt;/span&gt;:&amp;lt;#(nullable NSNotificationName)#&amp;gt; &lt;br/&gt;&lt;span&gt;　　　　　　　　　      object&lt;/span&gt;:&amp;lt;#(nullable id)#&amp;gt;]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * 参数一 ：监听器，即谁要接受这个通知
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * 参数二 ：回调方法，即接受通知时候，回调这个方法，作出响应
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     并把通知对象当作 参数 传入
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * 参数三 ： 通知的名称，标签
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     如果为nil，可以监听所有此类通知（具体还需要结合参数四）
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     如果有值，只监听这个名称的所有通知
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     * 参数四 ：通知发布者
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     如果为nil，不关心是谁发布的通知，可根据参数三获取通知
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     如果有值，会获取这个值发布的通知，具体还需要看参数三是否一致
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;      
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     四个参数的作用：
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     参数一： 用于决定回调方法的位置，写在哪个类里面
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     参数二： 具体的回调方法，参数是通知对象
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     参数三： 是否需要监听指定的通知名称的通知
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     参数四： 是否需要监听指定的发布通告者的通知
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;      
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     注意： 如果通知名（参数三），发布通知者（参数四）都为nil
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;     那么这个监听器的方法（参数二）可以回调所有此类通知
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;     *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;declaration&quot;&gt;
&lt;strong&gt;&lt;span&gt;2.发布通知：&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发出通知&lt;/span&gt;
&lt;span&gt;
    [center postNotificationName:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;sad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;:nil  userInfo:@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;伤心&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}];
    [center postNotificationName:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;sad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;:self userInfo:@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;伤心&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}];
    [center postNotificationName:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;sad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;:test userInfo:@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;伤心&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}];

    [center postNotificationName:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;smile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;:nil  userInfo:@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;开心&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}];
    [center postNotificationName:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;smile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;:test userInfo:@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;开心&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}];
    [center postNotificationName:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;smile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;:self userInfo:@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;开心&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}];

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发布通知
        [center &lt;span&gt;postNotificationName&lt;/span&gt;:&amp;lt;#(nonnull NSNotificationName)#&amp;gt; &lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　object&lt;/span&gt;:&amp;lt;#(nullable id)#&amp;gt; &lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　　　　　  userInfo&lt;/span&gt;:&amp;lt;#(nullable NSDictionary *)#&amp;gt;]
     * 第一个参数，通知的方法名字，不能为nil
     * 第二个参数，通知的发布者，可以为nil
     * 第三个参数，通知所传递的信息，为字典格式
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;declaration&quot;&gt;
&lt;strong&gt;&lt;span&gt;3. 回调方法：&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; self 中（NotificationVC）&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)smileNotif:(NSNotification *&lt;span&gt;)notif{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;------1----%@/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,notif.userInfo);
}
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)sadNotif:(NSNotification *&lt;span&gt;)notif{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;------2----%@/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,notif.userInfo);
}
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)methodTest:(NSNotification *&lt;span&gt;)notif{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;------3----%@/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,notif.userInfo);
}
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)sad2Notif:(NSNotification *&lt;span&gt;)notif{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;------4----%@/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,notif.userInfo);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TestVCViewController中&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)testNotif:(NSNotification *&lt;span&gt;)notif{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;-----5-----%@/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,notif.userInfo);
}
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)smileNotif:(NSNotification *&lt;span&gt;)notif{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;-----6-----%@/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,notif.userInfo);
}
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)sadNotif:(NSNotification *&lt;span&gt;)notif{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;-----7-----%@/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,notif.userInfo);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于打印的太多，这里不提供打印结果了，有兴趣的可以copy，断点打印，查看 参数不同 的 注册通知 之间的区别&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  4. 移除通知：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)dealloc {
    [[NSNotificationCenter defaultCenter] removeObserver:test];
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移除方法&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)removeObserver:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)observer;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)removeObserver:(&lt;span&gt;id&lt;/span&gt;)observer name:(NSString *)aName &lt;span&gt;object&lt;/span&gt;:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)anObject;

 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
removeObserver:是删除通知中心保存的调度表指定某个观察者的所有入口        removeObserver:name:object:是删除通知中心保存的调度表中某个观察者的指定某个入口
注意参数notificationObserver为要删除的观察者，不能为nil
*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通常这样写 在viewWillAppear 中 addObserver，在viewWillDisappear 中 removeObserver&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear:animated];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(xxxx) name:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;xxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;:nil];
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewWillDisappear:(BOOL)animated
{
    [super viewWillDisappear:animated];
    [[NSNotificationCenter defaultCenter] removeObserver:self name:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;xxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;:nil];
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;declaration&quot;&gt;
&lt;strong&gt;&lt;span&gt;三. 扩展&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;1.block 通知&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 官方语法：&lt;/span&gt;
     - (&lt;span&gt;id&lt;/span&gt; &amp;lt;NSObject&amp;gt;&lt;span&gt;)addObserverForName:(nullable NSNotificationName)name 
　　　　　　　　　　　　　　　　　　　 　&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;:(nullable &lt;span&gt;id&lt;/span&gt;&lt;span&gt;)obj 
　　　　　　　　　　　　　　　　　　　　　queue:(nullable NSOperationQueue &lt;/span&gt;*&lt;span&gt;)queue 
　　　　　　　　　　　　　　　　　　usingBlock:(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; (^)(NSNotification *note))block API_AVAILABLE(macos(&lt;span&gt;10.6&lt;/span&gt;&lt;span&gt;),
 ios(&lt;/span&gt;&lt;span&gt;4.0&lt;/span&gt;), watchos(&lt;span&gt;2.0&lt;/span&gt;), tvos(&lt;span&gt;9.0&lt;/span&gt;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     // The return value is retained by the system, and should be held onto by the caller in
     // order to remove the observer with removeObserver: later, to stop observation.
     返回值由系统保留，并由调用方保存。
     顺序删除观测者，稍后，停止观察。
     *  参数一 : 通知名称
     *  参数二 : 监听者，即谁监听发出的通知
     *  参数三 : 队列，决定block在哪个线程中区执行
     如果传入nil，在发布通知的线程中去执行，即发布通知在哪个线程，block就在哪个线程中区执行
     如果是耗时操作，放在子线程
     *  参数四 : 监听到通知后的block回调
     
    注意 : block函数返回值（示例：上文声明的 id object），由当前调用方保存，最后要移除
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;object&lt;/span&gt; = [[NSNotificationCenter defaultCenter]&lt;span&gt;addObserverForName&lt;/span&gt;:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;good&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;object&lt;/span&gt;&lt;/span&gt;:self &lt;br/&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;queue&lt;/span&gt;:nil &lt;br/&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;usingBlock&lt;/span&gt;:^(NSNotification *&lt;span&gt; _Nonnull note) &lt;br/&gt;　　{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听到通知会调用，不用单独写方法&lt;/span&gt;
        NSLog(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;-----8-----%@/n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,note.userInfo);
    }]; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; object 为声明的 id object&lt;/span&gt;
&lt;span&gt;    
    [center postNotificationName:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;good&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;:self userInfo:@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;good&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;好极了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}];
    [center postNotificationName:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;sad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;object&lt;/span&gt;:self userInfo:@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;sad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;坏死了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.异步调用通知&lt;/span&gt;  &lt;/p&gt;
&lt;p&gt;&lt;span&gt;即 通知放在异步方法中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;* NSNotificationCenter&lt;/code&gt;消息的接受线程是基于发送消息的线程的，即 同步的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;*  有时，你发送的消息可能不在主线程，但是操作UI必须在主线程，不然会出现不响应的情况。所以，在收到消息通知的时候，注意选择你要执行的线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;*  一般用于通知中执行耗时操作，异步执行，保证UI主线程的流程，不会“假死，卡死”&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通知通常用于监听需求属性，当属性发生变化，发出通知，通过回调方法作出改变，响应通知&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考博客：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/qq_31810357/article/details/50760917&quot; target=&quot;_blank&quot;&gt;iOS中 本地通知／本地通知详解 韩俊强的博客&lt;/a&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;ps： 本地通知讲解的很详细，有兴趣可以下载他的demo）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jx66/p/5442351.html&quot;&gt;iOS中通知中心(NSNotificationCenter)的使用总结&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.jianshu.com/p/b9deed86aad1&quot; target=&quot;_blank&quot;&gt;IOS中通知中心(NSNotificationCenter)的使用总结&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/199700eb140d&quot; target=&quot;_blank&quot;&gt;IOS 通知详解+异步发送和接收通知&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Thu, 02 Aug 2018 06:55:00 +0000</pubDate>
<dc:creator>冬季的暖风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouDongdong/p/9406166.html</dc:identifier>
</item>
<item>
<title>HDFS 入门介绍 - 水木山川</title>
<link>http://www.cnblogs.com/zengming/p/9407070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zengming/p/9407070.html</guid>
<description>&lt;h4&gt;HDFS简介&lt;/h4&gt;
&lt;h4&gt;　　HDFS（Hadoop Distributed File System，Hadoop分布式文件系统），它是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，适合那些有着超大数据集（large data set）的应用程序。&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;HDFS&lt;/strong&gt;&lt;strong&gt;基本概念篇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         设计思想：分而治之：将大文件、大批量文件，分布式存放在大量服务器上，以便于采取分而治之的方式对海量数据进行运算分析；&lt;/p&gt;
&lt;p&gt;         在大数据系统中作用：为各类分布式运算框架（如：mapreduce，spark，tez等）提供数据存储服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HDFS&lt;/strong&gt;&lt;strong&gt;的概念和特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         一个分布式文件系统，用于存储文件，通过统一的命名空间——目录树来定位文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hadoop 3个核心组件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         分布式文件系统：&lt;span&gt;Hdfs&lt;/span&gt;——实现将文件分布式存储在很多的服务器上（hdfs是一个基于Linux本地文件系统上的文件系统）&lt;/p&gt;
&lt;p&gt;　　  分布式运算编程框架：&lt;span&gt;MapReduce&lt;/span&gt;——实现在很多机器上分布式并行运算&lt;/p&gt;
&lt;p&gt;　　  分布式资源调度平台：&lt;span&gt;Yarn&lt;/span&gt;——帮用户调度大量的mapreduce程序，并合理分配运算资源&lt;/p&gt;
&lt;p&gt;　　  MapReduce：通俗说MapReduce是一套从海量源数据提取分析元素最后返回结果集的编程模型，将文件分布式存储到硬盘是第一步，而从海量数据中提取分析我们需要的内容就是MapReduce做的事了。&lt;br/&gt;　　  MapReduce的基本原理就是：将大的数据分析分成小块逐个分析，最后再将提取出来的数据汇总分析，最终获得我们想要的内容。当然怎么分块分析，怎么做Reduce操作非常复杂，Hadoop已经提供了数据分析的实现，我们只需要编写简单的需求命令即可达成我们想要的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HDFS&lt;/strong&gt;&lt;strong&gt;的设计特点是&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;         1、大数据文件，非常适合上T级别的大文件或者一堆大数据文件的存储，如果文件只有几个G甚至更小就没啥意思了。&lt;/p&gt;
&lt;p&gt;         2、文件分块存储，HDFS会将一个完整的大文件平均分块存储到不同计算器上，它的意义在于读取文件时可以同时从多个主机取不同区块的文件，多主机读取比单主机读取效率要高得多得多。&lt;/p&gt;
&lt;p&gt;         3、流式数据访问，一次写入多次读写，这种模式跟传统文件不同，它不支持动态改变文件内容，而是要求让文件一次写入就不做变化，要变化也只能在文件末添加内容。&lt;/p&gt;
&lt;p&gt;         4、廉价硬件，HDFS可以应用在普通PC机上，这种机制能够让给一些公司用几十台廉价的计算机就可以撑起一个大数据集群。&lt;/p&gt;
&lt;p&gt;         5、硬件故障，HDFS认为所有计算机都可能会出问题，为了防止某个主机失效读取不到该主机的块文件，它将同一个文件块副本分配到其它某几个主机上，如果其中一台主机失效，可以迅速找另一块副本取文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要特性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         1.HDFS中的文件在物理上是分块存储（block），块的大小可以通过配置参数( dfs.blocksize)来规定，默认大小在hadoop2.x版本中是128M，老版本中是64M&lt;/p&gt;
&lt;p&gt;         2.HDFS文件系统会给客户端提供一个统一的抽象目录树，客户端通过路径来访问文件&lt;/p&gt;
&lt;p&gt;         3.目录结构及文件分块信息(元数据)的管理由namenode节点承担——namenode是HDFS集群主节点，负责维护整个hdfs文件系统的目录树，以及每一个路径（文件）所对应的block块信息（block的id，及所在的datanode服务器）&lt;/p&gt;
&lt;p&gt;         4.文件的各个block的存储管理由datanode节点承担----datanode是HDFS集群从节点，每一个block都可以在多个datanode上存储多个副本（副本数量也可以通过参数设置dfs.replication）&lt;/p&gt;
&lt;p&gt;         5.HDFS是设计成适应一次写入，多次读出的场景，且不支持文件的修改&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HDFS&lt;/strong&gt;&lt;strong&gt;的关键元素：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         1、Block：将一个文件进行分块，通过配置参数( dfs.blocksize)来设置，hadoop2.x版本中是128M，老版本中是64M。&lt;/p&gt;
&lt;p&gt;         2、NameNode：保存整个文件系统的目录信息、文件信息及分块信息，这是由唯一一台主机专门保存，当然这台主机如果出错，NameNode就失效了。在 Hadoop2.* 开始支持 activity-standy 模式----如果主 NameNode 失效，启动备用主机运行NameNode。&lt;/p&gt;
&lt;p&gt;         3、DataNode：分布在廉价的计算机上，用于存储Block块文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、HDFS&lt;/strong&gt;&lt;strong&gt;运行原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、NameNode和DataNode节点初始化完成后，采用RPC进行信息交换，采用的机制是心跳机制，即DataNode节点定时向NameNode反馈状态信息，反馈信息如:是否正常、磁盘空间大小、资源消耗情况等信息，以确保NameNode知道DataNode的情况；&lt;/p&gt;
&lt;p&gt;2、NameNode会将子节点的相关元数据信息缓存在内存中，对于文件与Block块的信息会通过fsImage和edits文件方式持久化在磁盘上，以确保NameNode知道文件各个块的相关信息；&lt;/p&gt;
&lt;p&gt;3、NameNode负责存储fsImage和edits元数据信息，但fsImage和edits元数据文件需要定期进行合并，这时则由SecondNameNode进程对fsImage和edits文件进行定期合并，合并好的文件再交给NameNode存储。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1035949/201808/1035949-20180802144304995-585982367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、HDFS&lt;/strong&gt;&lt;strong&gt;数据合并原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、NameNode初始化时会产生一个edits文件和一个fsimage文件，edits文件用于记录操作日志，比如文件的删除或添加等操作信息，fsImage用于存储文件与目录对应的信息以及edits合并进来的信息，即相当于fsimage文件在这里是一个总的元数据文件，记录着所有的信息；&lt;/p&gt;
&lt;p&gt;2、随着edits文件不断增大，当达到设定的一个阀值的时候，这时SecondaryNameNode会将edits文件和fsImage文件通过采用http的方式进行复制到SecondaryNameNode下（在这里考虑到网络传输，所以一般将NameNode和SecondaryNameNode放在相同的节点上，这样就无需走网络带宽了，以提高运行效率），同时NameNode会产生一个新的edits文件替换掉旧的edits文件，这样以保证数据不会出现冗余；&lt;/p&gt;
&lt;p&gt;3、SecondaryNameNode拿到这两个文件后，会在内存中进行合并成一个fsImage.ckpt的文件，合并完成后，再通过http的方式将合并后的文件fsImage.ckpt复制到NameNode下，NameNode文件拿到fsImage.ckpt文件后，会将旧的fsimage文件替换掉，并且改名成fsimage文件。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1035949/201808/1035949-20180802144239051-330720373.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、HDFS&lt;/strong&gt;&lt;strong&gt;写原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、HDFS客户端提交写操作到NameNode上，NameNode收到客户端提交的请求后，会先判断此客户端在此目录下是否有写权限，如果有，然后进行查看，看哪几个DataNode适合存放，再给客户端返回存放数据块的节点信息，即告诉客户端可以把文件存放到相关的DataNode节点下；&lt;/p&gt;
&lt;p&gt;2、客户端拿到数据存放节点位置信息后，会和对应的DataNode节点进行直接交互，进行数据写入，由于数据块具有副本replication，在数据写入时采用的方式是先写第一个副本，写完后再从第一个副本的节点将数据拷贝到其它节点，依次类推，直到所有副本都写完了，才算数据成功写入到HDFS上，副本写入采用的是串行，每个副本写的过程中都会逐级向上反馈写进度，以保证实时知道副本的写入情况；&lt;/p&gt;
&lt;p&gt;3、随着所有副本写完后，客户端会收到数据节点反馈回来的一个成功状态，成功结束后，关闭与数据节点交互的通道，并反馈状态给NameNode,告诉NameNode文件已成功写入到对应的DataNode。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1035949/201808/1035949-20180802144211838-1381098606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、HDFS&lt;/strong&gt;&lt;strong&gt;读原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、HDFS客户端提交读操作到NameNode上，NameNode收到客户端提交的请求后，会先判断此客户端在此目录下是否有读权限，如果有，则给客户端返回存放数据块的节点信息，即告诉客户端可以到相关的DataNode节点下去读取数据块；&lt;/p&gt;
&lt;p&gt;2、客户端拿到块位置信息后，会去和相关的DataNode直接构建读取通道，读取数据块，当所有数据块都读取完成后关闭通道，并给NameNode返回状态信息，告诉NameNode已经读取完毕。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1035949/201808/1035949-20180802144048792-776991952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;备注：&lt;br/&gt;作者：Shengming Zeng&lt;br/&gt;博客：http://www.cnblogs.com/zengming/ &lt;/p&gt;
&lt;p&gt;本文是原创，欢迎大家转载；但转载时必须注明文章来源，且在文章开头明显处给明链接。&lt;br/&gt;&amp;lt;欢迎有不同想法或见解的同学一起探讨，共同进步&amp;gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Aug 2018 06:48:00 +0000</pubDate>
<dc:creator>水木山川</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zengming/p/9407070.html</dc:identifier>
</item>
<item>
<title>微信小程序 - 入门指引 - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/9406922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/9406922.html</guid>
<description>&lt;p&gt; 稍微整了整微信小程序，还是有不少问题的，做个小总结吧&lt;/p&gt;
&lt;p&gt;本文采用此 &lt;a href=&quot;https://github.com/imwtr/miniprogram-sign&quot; target=&quot;_blank&quot;&gt;小程序Demo &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;一、微信公众平台 - 小程序后台&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.申请小程序账号&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://mp.weixin.qq.com/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;官网注册&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注册时所用的邮箱有限制（未注册过公众平台、开放平台、企业号、未绑定个人号的邮箱）&lt;/p&gt;
&lt;p&gt;选择主体为个人或企业，按照流程注册&lt;/p&gt;
&lt;p&gt;小程序的信息填写有次数限制，需要注意不要乱填（服务类目，名称，头像，介绍 等）&lt;/p&gt;
&lt;p&gt;登录&lt;/p&gt;

&lt;h3 id=&quot;id-[前端]微信小程序入门指引-2.设置&quot;&gt;&lt;span&gt;2.设置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;记住这两项 AppID 和 AppSecret，在开发时需要用到&lt;/p&gt;
&lt;p&gt;大部分操作都需要管理员扫码验证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125044900-35626047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置好开发者，体验用户的相关权限&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125106801-936810687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置 -&amp;gt; 基本设置 中配置好 基础库最低版本的设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125126657-1634464134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置 -&amp;gt; 开发者设置 -&amp;gt; 服务器域名中   配置好服务器域名，小程序才能正确地发起异步请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125146656-551888355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;id-[前端]微信小程序入门指引-二、小程序社区&quot;&gt;&lt;span&gt;3.小程序社区&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;常见的问题可以 在 &lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;小程序社区&lt;/a&gt; 及 &lt;a class=&quot;external-link&quot; href=&quot;http://www.wxapp-union.com/forum.php&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;小程序论坛&lt;/a&gt; 及 &lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/miniprogram/dev/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;小程序文档&lt;/a&gt; 查找答案 &lt;/p&gt;

&lt;h2 id=&quot;id-[前端]微信小程序入门指引-三、小程序开发者工具&quot;&gt;&lt;span&gt;二、小程序开发者工具&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;使用文档&lt;/a&gt;  &lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;工具下载&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;id-[前端]微信小程序入门指引-1.安装&quot;&gt;&lt;span&gt;1.安装&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注意，小程序开发者工具与公众号开发者工具不能同时运行，不能安装在同一个目录中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了能够兼容两者的使用，需要一些额外的操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如需要同时使用三个工具，先修改文件夹命名&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125232394-864941093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内部的exe可执行程序修改成对应的名称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125258778-193236518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125311409-1791989389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在开始菜单中才能正确找到三个程序的快捷入口&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125347144-1478969951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般来说，开发者工具仅作为编译及调试使用，代码编辑建议使用自己的编辑器或IDE&lt;/p&gt;
&lt;p&gt;开发者工具bug多多，如果发现失效的奇怪的问题，请重启开发者工具&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用快捷键：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ctrl+B 编译 &lt;/p&gt;
&lt;p&gt;Ctrl+R 刷新 &lt;/p&gt;
&lt;p&gt;Ctrl+Shift+P 远程预览（项目需要提供AppID） &lt;/p&gt;

&lt;h3 id=&quot;id-[前端]微信小程序入门指引-2.其他说明&quot;&gt;&lt;span&gt;2.其他说明&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1. 打开开发者工具，选择项目文件夹，自动识别为已有项目还是新建的项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;填写AppID 才能使用真机预览&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125412582-2132395801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2. 小程序布局以iPhone6为基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以在移动设备模拟中 选用 iPhone6作为基准，再兼容其他设备&lt;/p&gt;
&lt;p&gt;设备模拟与真机预览某些时候差异很大，别忘了在手机上调试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125433321-1403372769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 建议的设置项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125452961-66002887.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125513732-1793588362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认开发者工具中发起的异步请求仅在开发者工具中看到，如需使用Fiddler进行调试，需要手动设置代理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125533716-589193413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.4 项目配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目的设置，会自动同步到 project.config.json文件中&lt;/p&gt;
&lt;p&gt;点开右侧详情，选中比较高的调试基础库版本&lt;/p&gt;
&lt;p&gt;选用自带的ES6转ES5,代码补全压缩&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发时记得勾选不校验域名&lt;/strong&gt;（防止访问失败），&lt;strong&gt;上线阶段记得取消勾选&lt;/strong&gt;（校验域名可更安全）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125605185-1525497199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可点击切换编辑器的显示隐藏，快速调整右下开发者调试的窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125653964-525779298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.5 代码上传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.5.1 先进行编译并远程预览&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125712528-2130556428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.5.2 再进行上传，管理员登录微信公众平台选择启用为体验版本，相关人员进行体验&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125729299-833914684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.5.3 管理员选用体验版本上传作为审核&lt;/p&gt;
&lt;p&gt;不可随意上传审核，多次审核不通过有惩罚机制&lt;/p&gt;
&lt;p&gt;2.5.4 管理员选择审核通过的版本，发布为线上版本&lt;/p&gt;

&lt;h2 id=&quot;id-[前端]微信小程序入门指引-四、小程序开发框架、代码结构&quot;&gt;&lt;span&gt;三、小程序开发框架、代码结构&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;id-[前端]微信小程序入门指引-1.基础结构&quot;&gt;&lt;span&gt;1.基础结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/structure.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125758010-1636237798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/config.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;文件的配置项&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;tabbar中的路径以及页面中的跳转路径，都必须在app.json的pages中配置好，其中分包的pages也要配置好&lt;/p&gt;
&lt;h3 id=&quot;id-[前端]微信小程序入门指引-2.项目结构&quot;&gt;&lt;span&gt;2.项目结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;小程序支持大部分ES6语法，但为了支持完整的ES6+语法，以及对原生的回调做优化，引入 &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/youngjuning/wxPromise&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;wxPromise&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基本支持小程序的所有API转换成 then catch  finally 的便捷语法，加上 wx.pro.即可  如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 演示 wxPromise 的能力&lt;/span&gt;
&lt;span&gt;wx.request({
  url: &lt;/span&gt;'test.php', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;仅为示例，并非真实的接口地址&lt;/span&gt;
&lt;span&gt;  data: {
     x: &lt;/span&gt;''&lt;span&gt; ,
     y: &lt;/span&gt;''&lt;span&gt;
  },
  header: {
    &lt;/span&gt;'content-type': 'application/json' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认值&lt;/span&gt;
&lt;span&gt;  },
  success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res) {
    console.log(res.data)
  },
  fail: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    console.log(e)
  },
  complete: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    console.log(e)
  }
})
wx.pro.request({
  url: &lt;/span&gt;'test.php'&lt;span&gt;,
  data: {},
  method: &lt;/span&gt;'GET'&lt;span&gt;,
  header: {&lt;/span&gt;'content-type': 'application/json'&lt;span&gt;}
}).then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(res)
}).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
  console.log(err)
}).&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;(() =&amp;gt;&lt;span&gt; {
  wx.hideLoading()
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;小程序不支持SCSS预编译的CSS，为了支持SCSS，所有需要引入构建工具进行编译&lt;/p&gt;
&lt;p&gt;小程序自带了代码压缩，不过基本上只是对JS做了压缩，还需要压缩其他资源文件（WXSS、WXML等）&lt;/p&gt;
&lt;p&gt;引入&lt;a class=&quot;external-link&quot; href=&quot;https://www.gulpjs.com.cn/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Gulp构建工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目参考 &lt;a href=&quot;https://github.com/imwtr/miniprogram-sign&quot; target=&quot;_blank&quot;&gt;此Demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802125948074-1600701943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;src目录为源代码，gulpfile为 Gulp的任务配置，经过处理猴，将生成dist目录，在小程序开发者工具中打开此 dist目录即可&lt;/p&gt;
&lt;p&gt;在sign目录下，执行 npm i 安装依赖包，然后运行 npm start 即可执行并监听，更新dist目录的内容，然后在 开发者工具中重新编译 Ctrl+B 即可看到效果（有时开发者工具出现奇怪问题的，就重启工具）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130014476-584009307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;src目录中主要为项目根文件，pages页面目录，assets资源目录&lt;/p&gt;
&lt;p&gt;pages目录中的 嵌入的subPages目录用作分包目录，页面之外的其他资源文件或其他模块在assets目录中&lt;/p&gt;
&lt;p&gt;app.json配置示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('33097d25-5542-48b0-8f4a-58ca486febb9')&quot; readability=&quot;44&quot;&gt;&lt;img id=&quot;code_img_closed_33097d25-5542-48b0-8f4a-58ca486febb9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_33097d25-5542-48b0-8f4a-58ca486febb9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('33097d25-5542-48b0-8f4a-58ca486febb9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_33097d25-5542-48b0-8f4a-58ca486febb9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;pages&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;pages/index/index&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;pages/user/user&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;pages/wait/wait&quot;&lt;span&gt;
    ],
    &lt;/span&gt;&quot;window&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;backgroundTextStyle&quot;: &quot;light&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;navigationBarBackgroundColor&quot;: &quot;#1296db&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;navigationBarTitleText&quot;: &quot;我来也&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;navigationBarTextStyle&quot;: &quot;white&quot;&lt;span&gt;
    },
    &lt;/span&gt;&quot;subPackages&quot;&lt;span&gt;: [{
        &lt;/span&gt;&quot;root&quot;: &quot;pages/subPages&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;pages&quot;&lt;span&gt;: [
            &lt;/span&gt;&quot;signed/signed&quot;&lt;span&gt;
        ]
    }],
    &lt;/span&gt;&quot;tabBar&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;selectedColor&quot;: &quot;#1296db&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;borderStyle&quot;: &quot;white&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;list&quot;&lt;span&gt;: [
            {
                &lt;/span&gt;&quot;pagePath&quot;: &quot;pages/index/index&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;text&quot;: &quot;我要签到&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;iconPath&quot;: &quot;./assets/imgs/sign.png&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;selectedIconPath&quot;: &quot;./assets/imgs/sign_active.png&quot;&lt;span&gt;
            },
            {
                &lt;/span&gt;&quot;pagePath&quot;: &quot;pages/wait/wait&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;text&quot;: &quot;等候大厅&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;iconPath&quot;: &quot;./assets/imgs/wait.png&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;selectedIconPath&quot;: &quot;./assets/imgs/wait_active.png&quot;&lt;span&gt;
            },
            {
                &lt;/span&gt;&quot;pagePath&quot;: &quot;pages/user/user&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;text&quot;: &quot;个人中心&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;iconPath&quot;: &quot;./assets/imgs/user.png&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;selectedIconPath&quot;: &quot;./assets/imgs/user_active.png&quot;&lt;span&gt;
            }
        ]
    },
    &lt;/span&gt;&quot;debug&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;页面配置user.json配置示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fd747a57-ea2c-41f0-b1da-acc7ac4a71fe')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_fd747a57-ea2c-41f0-b1da-acc7ac4a71fe&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fd747a57-ea2c-41f0-b1da-acc7ac4a71fe&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fd747a57-ea2c-41f0-b1da-acc7ac4a71fe',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fd747a57-ea2c-41f0-b1da-acc7ac4a71fe&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;navigationBarTitleText&quot;: &quot;个人中心&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;Gulp编译示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130123814-1997675484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130157398-655671319.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3 id=&quot;id-[前端]微信小程序入门指引-3.项目框架&quot;&gt;&lt;span&gt;3. 项目框架&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;小程序开发，一般有三种方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 纯原生开发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2 基本使用原生开发，并使用构建工具进行一些简单构建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3 使用小程序开发框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较常用的框架为，&lt;a class=&quot;external-link&quot; href=&quot;https://tencent.github.io/wepy/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;wepy&lt;/a&gt; 和 &lt;a class=&quot;external-link&quot; href=&quot;http://mpvue.com/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;mpvue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130310990-121309471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两者都需要vue语法基础，无vue基础则有些障碍，相对来说 mpvue能更纯粹地使用以往开发Web的经验，wepy在小程序之上又有自己的一套规则&lt;/p&gt;
&lt;p&gt;使用框架，并不是不再需要使用小程序原生的语法API&lt;/p&gt;
&lt;p&gt;鉴于此，为了弥补原生不支持SCSS的不足，&lt;strong&gt;使用 3.2 做简单构建方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不采用webpack的原因是webpack基于JS模块，通过配置入口模块做依赖打包，在小程序项目中Gulp工作流的方案更为合适&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2 id=&quot;id-[前端]微信小程序入门指引-五、小程序基础语法、常见问题&quot;&gt;&lt;span&gt;四、小程序基础语法、常见问题&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;id-[前端]微信小程序入门指引-1.基础用法&quot;&gt;&lt;span&gt;1.基础用法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;小程序的学习主要分为 &lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;框架&lt;/a&gt;  &lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/miniprogram/dev/component/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;组件&lt;/a&gt; &lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;API &lt;/a&gt;三个部分&lt;/p&gt;
&lt;p&gt;框架为基础的语法结构&lt;/p&gt;
&lt;p&gt;组件类似web中的HTML标签，web中的component &lt;/p&gt;
&lt;p&gt;API为小程序中的可用JS方法&lt;/p&gt;
&lt;p&gt;部分组件与API有版本兼容问题，需要注意&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;id-[前端]微信小程序入门指引-2.常见问题&quot;&gt;&lt;span&gt;2. 常见问题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1 input组件中上方的图标按钮在真机中点击失效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;input组件为原生组件，层级最高。focus 聚焦状态下点击上方的按钮时，会先触发失焦，再次点击按钮才生效&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130326012-1592027502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决办法，按钮置于input后面，背景做一些处理，与input区域的背景协调一致&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130345783-2094173674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外要注意，需要将按钮可点区域扩大，可以获得更好的使用体验&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130404789-1980596505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2 image组件的大小适应问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小程序中image默认为完全拉伸至填满image容器的scaleToFill 属性，有时会导致图片扭曲变形&lt;/p&gt;
&lt;p&gt;常用的 &lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/miniprogram/dev/component/image.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;mode&lt;/a&gt; 模式为 widthFix 宽度不变，高度自动变化，保持原图宽高比不变。需要先设置好宽度&lt;/p&gt;
&lt;p&gt;另外，在引入小图标时，也要注意小图标受到image组件默认宽高320px*240px 的影响，会被拉伸。可手动设置宽高解决&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 部分小图标可使用自带的 icon组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130451196-520955988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.4 如需要提供可选择可复制的文本 ，需使用 text组件 ，而不是 view 组件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.5 Flex布局的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小程序中会大量使用到 &lt;a class=&quot;external-link&quot; href=&quot;https://segmentfault.com/a/1190000008823763&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Flex布局&lt;/a&gt;，要掌握好。优先使用此布局方案&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.6 rpx自适应单位的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小程序中引入了新的CSS单位 &lt;a class=&quot;external-link&quot; href=&quot;http://huang-jerryc.com/2017/05/21/talk-about-pixel-and-rpx/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;rpx&lt;/a&gt;（responsive pixel）, 相对于px，它提供了自适应的能力，优先使用这个单位&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130512875-840403672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;规定了以iPhone6屏幕（375px*667px）为基准，其设备像素比DPR为2，所以定义其屏幕宽度为 375px * 2 = 750rpx，相当于 1px == 2rpx  、1rpx == 0.5px&lt;/p&gt;
&lt;p&gt;在以往web开发中，我们需要根据不同机型的屏幕宽度与DPR，手动计算不同的rpx值&lt;/p&gt;
&lt;p&gt;但在小程序中，我们只需要以iPhone6为基准开发即可（设计稿也需要设计成iPhone6的750px宽度），设置好750px下某个元素应该是多少rpx，其他的转换工作无需考虑&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.7 文本垂直居中的处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在小程序中文本和图片之前的垂直居中可能需要特殊处理， 以往web页面中可用 vertical-align: middle; 实现居中效果&lt;/p&gt;
&lt;p&gt;但在小程序中的 image组件 和 text 组件的表现不太一样，看着不居中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130536631-1324498915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用Flex布局居中的方式，父元素设置  display: flex;  align-items: center; 即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130554929-285959030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.8 底部 tabbar图标与文本大小的自适应&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小程序自带的 底部tabbar可自定义的程度不是很高，不同机型下可能会出现图标太大或文字太小的不同现象&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;使用自带tabbar，图标选用 81px * 81px ,注意图标不要撑满大小，需要留白，否则会偏大&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130622281-867233601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自定义tabbar，需要模拟原生tabbar的一些跳转时的固定效果，尽量保持和自定义的体验一致&lt;/p&gt;
&lt;p&gt;可参考 &lt;a class=&quot;external-link&quot; href=&quot;http://www.wxapp-union.com/forum.php?mod=viewthread&amp;amp;tid=3655&amp;amp;highlight=%E8%B7%B3%E5%9D%91%2Btabbar&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;一些Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.9  页面跳转使用绝对路径，且需要在 pages 中配置好&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如 跳转到某个页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wx.navigateTo({
    url: &lt;/span&gt;'/pages/subPages/signed/signed'&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.10 tabbar中配置的页面，需要使用 switchTab 才能跳转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样的 switchTab 也只能跳转到 tabbar设置的页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
wx.switchTab({url:'/pages/user/user'&lt;span&gt;});
 
&lt;/span&gt;&amp;lt;navigator class='goto-sign' open-type=&quot;switchTab&quot; url='/pages/index/index'&amp;gt;
    &amp;lt;image src=&quot;../../assets/imgs/sign_active.png&quot;  /&amp;gt;
    &amp;lt;text&amp;gt;前往签到&amp;lt;/text&amp;gt;
&amp;lt;/navigator&amp;gt;
&lt;span&gt; 
wx.redirectTo({url:&lt;/span&gt;'/pages/subPages/signed/signed'});
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.11 在WXSS中的背景图片不能设置为本地路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仅支持作为 base64引入图片，或者使用网络地址的图片，或者使用 image组件引入图片&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.12 请求时的url参数需要设置为带 scheme（如 http）的绝对地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;且需要在微信工作平台设置好服务器域名&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.13 小程序的代码包限制为 2M &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可使用分包策略，单个包限制为2M，所有包限制为8M&lt;/p&gt;
&lt;p&gt;能使用网络资源的就使用网络资源（比如图片、音频等），能压缩的就压缩，精简优化代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分包方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设对不需要初次就加载的页面 signed.wxml进行打包加载，对其进行分包&lt;/p&gt;
&lt;p&gt;在 app.json中配置 subPackages&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&quot;subPackages&quot;&lt;span&gt;: [{
    &lt;/span&gt;&quot;root&quot;: &quot;pages/subPages&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;pages&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;signed/signed&quot;&lt;span&gt;
    ]
}],
&lt;/span&gt;&quot;tabBar&quot;&lt;span&gt;: {
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将该页面包放在 pages主页面目录下的 subPages 子页面目录即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130758362-1568561497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跳转时记得把 这里的 subPages 路径也加上  /pages/subPages/signed/signed&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.14 过多地进行 setData 操作可能会导致性能下降&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.15 登录授权的兼容方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下仅涉及获取用户基本信息的部分，如要获取openID 手机号等 还需要发起请求让后端来解密处理 &lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html#wxloginobject&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;更多步骤&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;旧版本中一般直接使用JS进行调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wx.getUserInfo({
    success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res) {
        console.log(res.userInfo)
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130837372-449150659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新版本中已逐渐不支持，直接调用会失效，应该改用 button组件引导用户启用授权&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130907051-903115989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击按钮后再获取信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802130933951-1831213746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='user__info'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;wx:if&lt;/span&gt;&lt;span&gt;=&quot;{{!hasUserInfo}}&quot;&lt;/span&gt;&lt;span&gt; open-type&lt;/span&gt;&lt;span&gt;='getUserInfo' &lt;/span&gt;&lt;span&gt;bindgetuserinfo&lt;/span&gt;&lt;span&gt;='getUserInfo'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='user__wx' &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../../assets/imgs/wx.png&quot;&lt;/span&gt;&lt;span&gt; mode&lt;/span&gt;&lt;span&gt;='widthFix' &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;微信授权登录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;block &lt;/span&gt;&lt;span&gt;wx:else&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;user__avatar&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;{{avatar}}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{nickName}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有信息的就直接显示信息，否则提示用户点击按钮授权&lt;/p&gt;
&lt;p&gt;点击后将触发 getUserInfo回调，e.detail中携带了 与 wx.getUserInfo 相同的返回信息&lt;/p&gt;
&lt;p&gt;将用户信息保存到本地缓存&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;data: {
    hasUserInfo: app.globalData.userInfo.hasUserInfo,
    avatar: app.globalData.userInfo.avatar,
    nickName: app.globalData.userInfo.nickName
},
...
getUserInfo(e) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;e.detail.userInfo) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    app.globalData.userInfo &lt;/span&gt;=&lt;span&gt; {
        hasUserInfo: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        avatar: e.detail.userInfo.avatarUrl,
        nickName: e.detail.userInfo.nickName
    }
    wx.setStorage({
        key: &lt;/span&gt;'userInfo'&lt;span&gt;,
        data: app.globalData.userInfo
    });
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
        hasUserInfo: app.globalData.userInfo.hasUserInfo,
        avatar: app.globalData.userInfo.avatar,
        nickName: app.globalData.userInfo.nickName
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.16 上传文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前仅支持上传图片及小视频&lt;/p&gt;
&lt;p&gt;仅支持一次上传一个文件，多个文件需循环上传&lt;/p&gt;
&lt;p&gt;需考虑全部上传成功才继续操作，可使用 &lt;a class=&quot;external-link&quot; href=&quot;http://es6.ruanyifeng.com/#docs/promise#Promise-all&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;promise.all &lt;/a&gt;结合&lt;a class=&quot;external-link&quot; href=&quot;http://es6.ruanyifeng.com/#docs/async&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt; await/async&lt;/a&gt; 异步处理&lt;/p&gt;
&lt;p&gt;如 上传图片成功后才提交数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;async uploadFaces() {
     let p &lt;/span&gt;=&lt;span&gt; [];
     (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data.face || []).forEach(item =&amp;gt;&lt;span&gt; {
         p.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
             wx.pro.uploadFile({
                 url: &lt;/span&gt;'http://local.recruit.com/?r=resumeV2/uploadPhoto'&lt;span&gt;,
                 filePath: item,
                 name: &lt;/span&gt;'cover'&lt;span&gt;,
                 formData: {
                     _csrf: &lt;/span&gt;'RktCQ3daWDJ3Sk1aSE9ucikRJRYcLhoFODo1Yx4AACgLBDsTBSwAYS59fGsxJ1of'&lt;span&gt;
                 },
                 header: {
                     &lt;/span&gt;'Cookie': 'PHPSESSID=95nno109b17gbfb852tpf4mke4'&lt;span&gt;,
                     &lt;/span&gt;'content-type': 'multipart/form-data'&lt;span&gt;
                 }
             }).then(rs &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                 let data &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt; rs.data === 'string' ?&lt;span&gt; JSON.parse(rs.data) : rs.data;
                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;data.status) {
                     reject(rs);
                 } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                     resolve(rs);
                 }
                 console.log(rs);
             }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(e =&amp;gt;&lt;span&gt; {
                 reject(e);
                 console.log(e);
             });
         }));
     });
     await Promise.all(p);
 },
 submitData(data) {
     let that &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
     console.log(data);
 ...
 }
 
 
 ...
  
 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rs.confirm) {
    let uploadFaceloading &lt;/span&gt;=&lt;span&gt; wx.showLoading({
       title: &lt;/span&gt;'上传中'&lt;span&gt;
    });
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先上传图片&lt;/span&gt;
&lt;span&gt;    that.uploadFaces()
        .then((rs) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'uploadSuccess'&lt;span&gt;, rs);
              
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再提交数据&lt;/span&gt;
&lt;span&gt;            that.submitData(e.detail.value);
       }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(e =&amp;gt;&lt;span&gt; {
           wx.showToast({
              title: &lt;/span&gt;'上传失败'&lt;span&gt;,
             icon: &lt;/span&gt;'none'&lt;span&gt;
           });
           console.log(&lt;/span&gt;'uploadFail'&lt;span&gt;, e);
       }).&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;(rs =&amp;gt;&lt;span&gt; {
           wx.hideLoading(uploadFaceloading);
       });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.17  获取本地图片 wx.chooseImage 等相关的API，会触发页面的 onHide/onShow&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开始选择，直到选择完毕，相关的触发流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802131113947-668944737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以在onShow或onHide中需要处理一些数据时，要关注这个问题&lt;/p&gt;
&lt;p&gt;在app.globalData中设置一个标志位，由其他页面跳转进来onShow时获取到正确的标志位（即其他页面卸载/隐藏时 将该标志为置位），chooseImage 选择后不置位&lt;/p&gt;
&lt;p&gt;使用一些获取页面栈的API，来判断当前页面的信息（如 getCurrentPages() ，只是能够判断出来的几率不是很大）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.18 获取用户坐标位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 wx.getLocation 能够获取用户坐标的经纬度，我们还需要将其转换为可识别的城市信息，需要使用第三方API（比如腾讯地图，百度地图等）来解析坐标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802131135962-1017666688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;a class=&quot;external-link&quot; href=&quot;https://lbs.qq.com/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;腾讯位置服务&lt;/a&gt;，先注册登录，生成属于自己的 KEY值用于传值，需要启用 WebServiceAPI&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802131227546-1511379083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看&lt;a class=&quot;external-link&quot; href=&quot;https://lbs.qq.com/qqmap_wx_jssdk/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;相关文档&lt;/a&gt;，&lt;a class=&quot;external-link&quot; href=&quot;http://3gimg.qq.com/lightmap/xcx/jssdk/qqmap-wx-jssdk1.0.zip&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;下载 JDK&lt;/a&gt;，然后引入&lt;/p&gt;
&lt;p&gt;在获取到经纬度之后，调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; app.js&lt;/span&gt;
let QQMapWX = require('./assets/js/qqmap-wx-jssdk.min.js'&lt;span&gt;);
 
App({
    onLaunch: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        let userInfo &lt;/span&gt;= wx.getStorageSync('userInfo'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.globalData.qqmapsdk = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QQMapWX({
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入对应的key&lt;/span&gt;
            key: '...'&lt;span&gt;
        });
    },
 
    globalData: {
        qqmapsdk: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    }
});
 
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; index.js&lt;/span&gt;
let app =&lt;span&gt; getApp();
 
Page({
    onReady() {
        wx.pro.getLocation({
            type: &lt;/span&gt;'wgs84'&lt;span&gt;
        }).then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(res);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前位置&lt;/span&gt;
&lt;span&gt;            app.globalData.qqmapsdk.reverseGeocoder({
                location: {
                    latitude: res.latitude,
                    longitude: res.longitude
                },
                success: (addressRes) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                    let city &lt;/span&gt;=&lt;span&gt; addressRes.result.address_component.city;
                    console.log(addressRes.result.address_component, city);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配当前坐标，设置城市&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (city) {
                        let groupSelected &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.data.group.find(item =&amp;gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; city.includes(item);
                        });
                        groupSelected &lt;/span&gt;&amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
                            groupSelected: groupSelected
                        });
                    }
                },
                fail: (e) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                    console.log(e);
                }
            });
        }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(e =&amp;gt;&lt;span&gt; {
            console.log(e);
        });
    }
 
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以手动设置经纬度进行测试，在开发者工具中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802131309829-763777372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以使用百度地图&lt;a class=&quot;external-link&quot; href=&quot;http://api.map.baidu.com/lbsapi/getpoint/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;拾取坐标系统&lt;/a&gt; 查询某地的坐标，用作测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802131333963-1833487910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首次调用时会询问用户授权，如果用户允许了，接下去就不再询问。如果拒绝，则将一直拒绝。&lt;/p&gt;
&lt;p&gt;大部分授权的询问机制是差不多的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.19 关于授权&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信小程序涉及很多&lt;a class=&quot;external-link&quot; href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;授权&lt;/a&gt;相关的东西，基础的信息可以直接使用API获取，敏感数据需要通过后端发起API来解析&lt;/p&gt;
&lt;p&gt;在微信开发者工具中，可以在这里清除授权信息（远程调试的手机上也会被清除），用以反复测试授权的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802131359822-1340078169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802131414512-854249281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在手机上，可以点击小程序右上角的.. ，查看关于小程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802131441103-1112467884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802131456096-1745840329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180802131515021-1983630294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;即可在这个页面的授权列表中开启或关闭&lt;/p&gt;
&lt;p&gt;如果用户之前已经拒绝授权，调用相关API时将直接失败，不会再弹出授权窗口&lt;/p&gt;
&lt;p&gt;这时，可以考虑使用 wx.openSetting ,将会跳转到这个授权列表页，让用户先手动设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开授权设置窗口，进行手动授权&lt;/span&gt;
&lt;span&gt;        wx.pro.openSetting({})
            .then(rs &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(rs);
            }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(e =&amp;gt;&lt;span&gt; {
                console.log(e);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以使用 wx.authorize 来指定哪种授权，不过如果之前用户拒绝过，将在一段时间之内一直返回失败的信息，所以还是很鸡肋的..&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取用户的授权状态列表&lt;/span&gt;
&lt;span&gt;wx.pro.getSetting({})
    .then(rs &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.log(rs);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询位置信息是否已允许授权&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!rs.authSetting['scope.userLocation'&lt;span&gt;]) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求授权获取用户位置&lt;/span&gt;
&lt;span&gt;            wx.pro.authorize({
                scope: &lt;/span&gt;'scope.userLocation'&lt;span&gt;
            })
            .then(rs &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(rs);
            }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(e =&amp;gt;&lt;span&gt; {
                console.log(e);
            });
        }
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(e =&amp;gt;&lt;span&gt; {
        console.log(e);
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他相关的API&lt;/p&gt;
&lt;p&gt;获取用户的登录状态，在调用某些API时，需要先调用此API，目前还不得而知&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取用户的登录状态&lt;/span&gt;
&lt;span&gt;wx.pro.login({})
    .then(rs &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.log(rs);
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(e =&amp;gt;&lt;span&gt; {
        console.log(e);
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 02 Aug 2018 06:23:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/9406922.html</dc:identifier>
</item>
<item>
<title>雪花算法(Snowflake)C#版本 压测Id重复严重 - 123!</title>
<link>http://www.cnblogs.com/yushuo/p/9406906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yushuo/p/9406906.html</guid>
<description>&lt;h2&gt; 不建议在生产环境中使用，压测重复id严重&lt;/h2&gt;
&lt;h2&gt; 不建议在生产环境中使用，压测重复id严重&lt;/h2&gt;
&lt;h2&gt; 不建议在生产环境中使用，压测重复id严重&lt;/h2&gt;
&lt;p&gt;压测工具 Jmeter&lt;/p&gt;
&lt;p&gt;大名鼎鼎的 雪花算法 &lt;a href=&quot;https://github.com/twitter/snowflake&quot;&gt;Twitter's Snowflake&lt;/a&gt;我就不多介绍了，直接上代码吧&lt;/p&gt;
&lt;p&gt;目前能搜索(百度，github，Google)到的C#版的代码基本上都一致 和java版本并无区别&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SnowflakeNet
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基准时间&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; StartStmp = &lt;span&gt;1288834974657L&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private const long START_STMP = 1480166465631L;&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;每一部分占用的位数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;机器标识位数&lt;/span&gt;
        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MachineIdBits = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据标志位数&lt;/span&gt;
        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DatacenterIdBits = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序列号识位数&lt;/span&gt;
        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SequenceBits = &lt;span&gt;12&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 每一部分的最大值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;机器ID最大值&lt;/span&gt;
        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; MaxMachineNum = -&lt;span&gt;1L&lt;/span&gt; ^ (-&lt;span&gt;1L&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; MachineIdBits);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据标志ID最大值&lt;/span&gt;
        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; MaxDatacenterNum = -&lt;span&gt;1L&lt;/span&gt; ^ (-&lt;span&gt;1L&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; DatacenterIdBits);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序列号ID最大值&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; MaxSequenceNum = -&lt;span&gt;1L&lt;/span&gt; ^ (-&lt;span&gt;1L&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; SequenceBits);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;每一部分向左的位移&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;机器ID偏左移12位&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MachineShift =&lt;span&gt; SequenceBits;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据ID偏左移17位&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DatacenterIdShift = SequenceBits +&lt;span&gt; MachineIdBits;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;时间毫秒左移22位&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TimestampLeftShift = SequenceBits + MachineIdBits +&lt;span&gt; DatacenterIdBits;


        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; _sequence = &lt;span&gt;0L&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序列号&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; _lastTimestamp = -&lt;span&gt;1L&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上一次时间戳&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; MachineId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;; }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;机器标识&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; DatacenterId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;; }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据中心
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public long Sequence = 0L;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序列号
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    get { return _sequence; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    internal set { _sequence = value; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; DateTime Jan1st1970 = &lt;span&gt;new&lt;/span&gt; DateTime(&lt;span&gt;1970&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, DateTimeKind.Utc);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; _lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SnowflakeNet(&lt;span&gt;long&lt;/span&gt; machineId, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; datacenterId)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果超出范围就抛出异常&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (machineId &amp;gt; MaxMachineNum || machineId &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;machineId 必须大于0，MaxMachineNum： {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, MaxMachineNum));
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (datacenterId &amp;gt; MaxDatacenterNum || datacenterId &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datacenterId必须大于0，且不能大于MaxDatacenterNum： {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, MaxDatacenterNum));
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先检验再赋值&lt;/span&gt;
            MachineId =&lt;span&gt; machineId;
            DatacenterId &lt;/span&gt;=&lt;span&gt; datacenterId;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_sequence = sequence;&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public static Init(long machineId, long datacenterId)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; NextId()
        {
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timestamp =&lt;span&gt; TimeGen();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timestamp &amp;lt;&lt;span&gt; _lastTimestamp)
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;时间戳必须大于上一次生成ID的时间戳.  拒绝为{0}毫秒生成id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, _lastTimestamp -&lt;span&gt; timestamp));
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果上次生成时间和当前时间相同,在同一毫秒内&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (_lastTimestamp ==&lt;span&gt; timestamp)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sequence自增，和sequenceMask相与一下，去掉高位&lt;/span&gt;
                    _sequence = (_sequence + &lt;span&gt;1&lt;/span&gt;) &amp;amp;&lt;span&gt; MaxSequenceNum;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否溢出,也就是每毫秒内超过1024，当为1024时，与sequenceMask相与，sequence就等于0&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (_sequence == &lt;span&gt;0L&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待到下一毫秒&lt;/span&gt;
                        timestamp =&lt;span&gt; TilNextMillis(_lastTimestamp);
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果和上次生成时间不同,重置sequence，就是下一毫秒开始，sequence计数重新从0开始累加,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了保证尾数随机性更大一些,最后一位可以设置一个随机数&lt;/span&gt;
                    _sequence = &lt;span&gt;0L&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new Random().Next(10);&lt;/span&gt;
&lt;span&gt;                }

                _lastTimestamp &lt;/span&gt;=&lt;span&gt; timestamp;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((timestamp - StartStmp) &amp;lt;&amp;lt; TimestampLeftShift) | (DatacenterId &amp;lt;&amp;lt; DatacenterIdShift) | (MachineId &amp;lt;&amp;lt; MachineShift) |&lt;span&gt; _sequence;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防止产生的时间比之前的时间还要小（由于NTP回拨等问题）,保持增量的趋势.&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; TilNextMillis(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; lastTimestamp)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timestamp =&lt;span&gt; TimeGen();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (timestamp &amp;lt;=&lt;span&gt; lastTimestamp)
            {
                timestamp &lt;/span&gt;=&lt;span&gt; TimeGen();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; timestamp;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前的时间戳&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; TimeGen()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return TimeExtensions.CurrentTimeMillis();&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;long&lt;/span&gt;)(DateTime.UtcNow -&lt;span&gt; Jan1st1970).TotalMilliseconds;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 下面是封装为静态类调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IdWorkerHelper{
             &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SnowflakeNet_idWorker= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IdWorkerHelper()
        {

        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; IdWorkerHelper()
        {
            _idWorker&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; SnowflakeNet(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }
          &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; GenId64()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _idWorker.nextId();

        }
  }


调用 IdWorkerHelper.GenId64();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　然后就是压测了 压测很简单 就是一个接口 直接往测试表里写数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; IdTest()
        {
            IdTest model &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdTest();
            model .DataId &lt;/span&gt;=&lt;span&gt; IdWorkerHelper.GenId64();
            model .InsertTime&lt;/span&gt;=&lt;span&gt;DateTime.Now;
            Sqldb.Insertable(img).ExecuteCommand();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;IdTest 表的主键Id用来自增&lt;br/&gt;控制器代码&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult IdTest()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ResultJson();
            _platApp.IdTest();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Content(result.ToJson());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;然后通过Jmeter压测&lt;/p&gt;
&lt;p&gt;线程组分别设置100，,200，500,1000,2000&lt;/p&gt;
&lt;p&gt;实际结果重复DataId十分严重&lt;/p&gt;
&lt;p&gt;一下结果是线程组1000的情况下的重复情况 &lt;/p&gt;
&lt;p&gt;sql语句：select DataId from IdTest GROUP BY DataId HAVING COUNT(DataId)&amp;gt;1;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/342125/201808/342125-20180802141755466-26123888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到重复情况多严重 了&lt;/p&gt;
&lt;p&gt;后来我想C#版本和JAVA版本并无区别，然后就用测试了一下Java版本 &lt;/p&gt;
&lt;p&gt;但是java版本在Jmeter的压测下并没有出现重复情况，很奇怪，java版本代码我就不贴了 百度大把 &lt;/p&gt;
</description>
<pubDate>Thu, 02 Aug 2018 06:21:00 +0000</pubDate>
<dc:creator>123!</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yushuo/p/9406906.html</dc:identifier>
</item>
<item>
<title>神奇的选择器 :focus-within - ChokCoco</title>
<link>http://www.cnblogs.com/coco1s/p/9406413.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coco1s/p/9406413.html</guid>
<description>&lt;p&gt;&lt;span&gt;CSS 的伪类选择器和伪元素选择器，让 CSS 有了更为强大的功能。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;伪类大家听的多了，伪元素可能听到的不是那么频繁，其实 CSS 对这两个是有区分的。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;有个错误有必要每次讲到伪类都提一下，有时你会发现伪类元素使用了两个冒号 (::) 而不是一个冒号 (:)，这是 CSS3 规范中的一部分要求，目的是为了区分伪类和伪元素，大多数浏览器都支持下面这两种表示方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常而言，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
#id:after{
 ...
}

#id::after{
...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;符合标准而言，单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，也有例外，对于 CSS2 中已经有的伪元素，例如 :before，单冒号和双冒号的写法 ::before 作用是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，如果你的网站只需要兼容 webkit、firefox、opera 等浏览器或者是移动端页面，建议对于伪元素采用双冒号的写法，如果不得不兼容低版本 IE 浏览器，还是用 CSS2 的单冒号写法比较安全。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;伪类选择器 &lt;code&gt;:focus-within&lt;/code&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;言归正传，今天要说的就是&lt;code&gt;:focus-within&lt;/code&gt; 伪类选择器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它表示一个元素获得焦点，或，该元素的后代元素获得焦点。划重点，它或它的后代获得焦点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这也就意味着，它或它的后代获得焦点，都可以触发 &lt;code&gt;:focus-within&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;code&gt;:focus-within&lt;/code&gt; 的冒泡性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这个属性有点类似 Javascript 的事件冒泡，从可获焦元素开始一直冒泡到根元素 &lt;code&gt;html&lt;/code&gt;，都可以接收触发 &lt;code&gt;:focus-within&lt;/code&gt; 事件，类似下面这个简单的例子这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;div class=&quot;g-father&quot;&amp;gt;
    &amp;lt;div class=&quot;g-children&quot;&amp;gt;
        &amp;lt;input type=&quot;button&quot; value=&quot;Button&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
html,
body,
.g-father,
.g-children {
    padding: 30px;
    border:1px solid #999;
}

input {
    ...
    &amp;amp;:focus {
        background: #00bcd4;
    }
}

html:focus-within {
    background: #e91e63;
}
body:focus-within {
    background: #ff5722;
}
.g-father:focus-within {
    background: #ffeb3b;
}
.g-children:focus-within {
    background: #4caf50;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;就是这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/43559244-e4f738da-963f-11e8-8c0c-10d9d44bdce4.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/43559244-e4f738da-963f-11e8-8c0c-10d9d44bdce4.gif&quot; alt=&quot;focuswithinmaopao&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://codepen.io/Chokcoco/pen/gjeoPg&quot; rel=&quot;nofollow&quot;&gt;CodePen Demo -- :focus-within 冒泡触发&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个选择器的存在，让 CSS 有了进一步的让元素持久停留在一种新状态的的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面几个例子，看看 &lt;code&gt;:focus-within&lt;/code&gt; 可以提供什么能力，做些什么事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;感应用户聚焦区域&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;它或它的后代获得焦点，这一点使得让感知获焦区域变得更大，所以，最常规的用法就是使用 &lt;code&gt;:focus-within&lt;/code&gt; 感应用户操作聚焦区域，高亮提醒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面的效果没有任何 JS 代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/43518041-4ea2d312-95bd-11e8-9a62-9b21f5e0f528.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/43518041-4ea2d312-95bd-11e8-9a62-9b21f5e0f528.gif&quot; alt=&quot;cssfocuswithinpesudo&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里是什么意思呢？&lt;code&gt;:focus-within&lt;/code&gt; 做了什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;我们无须去给获焦的元素设置 &lt;code&gt;:focus&lt;/code&gt; 伪类，而是可以给需要的父元素设置，这样当元素获焦时，我可以一并控制它的父元素的样式&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;核心思想用 CSS 代码表达出来大概是这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;div class=&quot;g-container&quot;&amp;gt;
    &amp;lt;div class=&quot;g-username&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; placeholder=&quot;user name&quot; class=&quot;g_input&quot; &amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;g-username&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; placeholder=&quot;code&quot; class=&quot;g_input&quot; &amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.g-container:focus-within {
    ...

    input {
        ....
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://codepen.io/Chokcoco/pen/rrJeLj&quot; rel=&quot;nofollow&quot;&gt;DEMO -- CSS focus-within INPUT&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运用上面思想，我们可以把效果做的更炫一点点，在某些场景制作一些增强用户体验的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/43517551-b6bfed24-95bb-11e8-8cdd-4db11e7b4e6a.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/43517551-b6bfed24-95bb-11e8-8cdd-4db11e7b4e6a.gif&quot; alt=&quot;purecssfocus&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://codepen.io/Chokcoco/pen/EpEjQX?editors=1100&quot; rel=&quot;nofollow&quot;&gt;DEMO -- PURE CSS FOCUS By :focus-within&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;TAB导航切换&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在之前的一篇文章里，介绍了两种纯 CSS 实现的 TAB 导航栏切换方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/coco1s/p/5955631.html&quot; rel=&quot;nofollow&quot;&gt;纯CSS的导航栏Tab切换方案&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在又多了一种方式，利用了 &lt;code&gt;:focus-within&lt;/code&gt; 可以在父节点获取元素获得焦点的特性，实现的TAB导航切换：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/43519376-c5dcb9e4-95c1-11e8-84ea-f1bfbb69e04e.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/43519376-c5dcb9e4-95c1-11e8-84ea-f1bfbb69e04e.gif&quot; alt=&quot;focuswithintab&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://codepen.io/Chokcoco/pen/RJEpaP&quot; rel=&quot;nofollow&quot;&gt;DEMO -- focus-within switch tab&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要的思路就是通过获焦态来控制其他选择器，以及最重要的是利用了父级的 &lt;code&gt;:not(:focus-within)&lt;/code&gt; 来设置默认样式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.nav-box:not(:focus-within) {
    // 默认样式
}

.nav-A:focus-within ~ .content-box .content-A {
    display: block;
}

.nav-B:focus-within ~ .content-box .content-B {
    display: block;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;配合 &lt;code&gt;:placeholder-shown&lt;/code&gt; 伪类实现表单效果&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;:focus-within&lt;/code&gt; 一个人能力有限，通常也会配合其他伪类实现一些不错的效果。这里要再简单介绍的是另外一个有意思的伪类 &lt;code&gt;:placeholder-shown&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;:placeholder-shown&lt;/code&gt;：The :placeholder-shown CSS pseudo-class represents any or &amp;lt;textarea&amp;gt; element that is currently displaying placeholder text.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;另外，划重点，这个伪类是仍处于实验室的方案。也就是未纳入标准，当然我们的目的是探寻有意思的 CSS 。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;意思大概就是，当 &lt;code&gt;input&lt;/code&gt; 类型标签使用了 placeholder 属性有了默认占位的文字，会触发此伪类样式。配合&lt;code&gt;:not()&lt;/code&gt;伪类，可以再改变当默认文字消失后的样式，再配合本文的主角，我们可以实现表单的一系列效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CSS 代码大概呈现成这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.g-container {
    width: 500px;
    height: 60px;

    input {
        height: 100%;
        width: 100%;

        &amp;amp;:not(:placeholder-shown) {
            ...
        }

        &amp;amp;:placeholder-shown {
            ...
        }
    }

    &amp;amp;:focus-within {
        ...
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;实际效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/43517148-48c40d10-95ba-11e8-9c42-61567daae18d.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/43517148-48c40d10-95ba-11e8-9c42-61567daae18d.gif&quot; alt=&quot;placeholder&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，上面的效果没有用到任何 JS，可以实现：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;整个 input（包括父元素所在区域）获焦与非获焦样式控制&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;placeholder 属性设置的文字出现与消失后样式控制&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://codepen.io/Chokcoco/pen/xJWwyB&quot; rel=&quot;nofollow&quot;&gt;CodePen Demo -- :placeholder-shown &amp;amp;&amp;amp; :focus-within&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;实现离屏导航&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这个是其他很多文章都有提到过的一个功能，利用 &lt;code&gt;focus-within&lt;/code&gt; 便捷的实现离屏导航，可以说将这个属性的功能发挥的淋漓尽致，这里我直接贴一个 codepen 上 &lt;a href=&quot;https://codepen.io/dannievinther/&quot; rel=&quot;nofollow&quot;&gt;Dannie Vinther&lt;/a&gt; 对这个效果的实现方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/43521890-23749ff6-95ca-11e8-907e-67a6d5528330.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/43521890-23749ff6-95ca-11e8-907e-67a6d5528330.gif&quot; alt=&quot;offscreennav&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://codepen.io/dannievinther/pen/NvZjvz&quot; rel=&quot;nofollow&quot;&gt;CodePen Demo -- Off-screen nav with :focus-within [PURE CSS]&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;实现掘金登录动效切换&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://juejin.im/&quot; rel=&quot;nofollow&quot;&gt;juejin.im&lt;/a&gt;是我很喜欢的一个博客网站，它的登录有一个小彩蛋，最上面的熊猫在你输入帐号密码的时候会有不同的状态，效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/43560815-dc8f7fca-9646-11e8-8c36-7cd61f85fd03.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/43560815-dc8f7fca-9646-11e8-8c36-7cd61f85fd03.gif&quot; alt=&quot;juejin&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用本文所讲的 &lt;code&gt;focus-within&lt;/code&gt; ，可以不借助任何 Javascript，实现这个动效：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/43560900-2ef72358-9647-11e8-8123-ecfc45828c3d.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/43560900-2ef72358-9647-11e8-8123-ecfc45828c3d.gif&quot; alt=&quot;juejinfocuswithin&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感兴趣的可以戳这里看看完整的Demo代码：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://codepen.io/Chokcoco/pen/yqKrPR?editors=1100&quot; rel=&quot;nofollow&quot;&gt;CodePen Demo -- 掘金登录效果纯CSS实现&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;兼容性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;好了，例子举例的也差不多了，下面到了杀人诛心的兼容性时刻，按照惯例，这种属性大概率是一片红色，看看 CANIUSE，截图日期（2018/08/02），其实也还不算特别惨淡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/43561041-c9a1a1c6-9647-11e8-9fa1-3a701eba95d0.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/43561041-c9a1a1c6-9647-11e8-9fa1-3a701eba95d0.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;感谢耐心读完。本文只是抛砖引玉，期待发掘 &lt;code&gt;focus-within&lt;/code&gt; 更多有意义的用法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多精彩 CSS 技术文章汇总在我的 &lt;a href=&quot;https://github.com/chokcoco/iCSS&quot;&gt;Github -- iCSS&lt;/a&gt; ，持续更新，欢迎点个 star 订阅收藏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，本文到此结束，希望对你有帮助 :)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 02 Aug 2018 04:26:00 +0000</pubDate>
<dc:creator>ChokCoco</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coco1s/p/9406413.html</dc:identifier>
</item>
<item>
<title>句子相似度--余弦相似度算法的实现 - J.mg</title>
<link>http://www.cnblogs.com/Jm-15/p/9406425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jm-15/p/9406425.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;strong&gt;1、余弦相似度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;余弦距离，也称为余弦相似度，是用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小的度量。余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，这就叫&quot;余弦相似性&quot;。&lt;/p&gt;
&lt;p&gt;                             &lt;img src=&quot;https://images2018.cnblogs.com/blog/1019336/201808/1019336-20180802112723220-1557022617.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图两个向量a,b的夹角很小可以说a向量和b向量有很高的的相似性，极端情况下，a和b向量完全重合。如下图：&lt;/p&gt;
&lt;p&gt;                               &lt;img src=&quot;https://images2018.cnblogs.com/blog/1019336/201808/1019336-20180802112747812-1136443340.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图可以认为a和b向量是相等的，也即a，b向量代表的文本是完全相似的，或者说是相等的。如果a和b向量夹角较大，或者反方向，可以说a向量和b向量有很低的的相似性，或者说a和b向量代表的文本基本不相似。&lt;/p&gt;
&lt;p&gt;向量a和向量b的夹角 的余弦计算如下：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1019336/201808/1019336-20180802114858368-793879871.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扩展，如果向量a和b不是二维而是n维，上述余弦的计算法仍然正确。假定a和b是两个n维向量，a是  ，b是  ，则a与b的夹角 的余弦等于：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1019336/201808/1019336-20180802115241253-1690650938.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;2、如下举例说明利用余弦计算句子相似度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;句子A&lt;/strong&gt;：这只皮靴号码大了。那只号码合适&lt;br/&gt;&lt;strong&gt;句子B&lt;/strong&gt;：这只皮靴号码不小，那只更合适&lt;/p&gt;
&lt;p&gt;怎样计算上面两句话的相似程度？&lt;br/&gt;基本思路是：如果这两句话的用词越相似，它们的内容就应该越相似。因此，可以从词频入手，计算它们的相似程度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步，分词。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;句子A：这只/皮靴/号码/大了。那只/号码/合适。&lt;/p&gt;
&lt;p&gt;句子B：这只/皮靴/号码/不/小，那只/更/合适。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步，列出所有的词。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这只，皮靴，号码，大了。那只，合适，不，小，更&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步，计算词频。（下面程序用的jieba分词工具所以结果不一样但不影响计算）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;句子A：这只1，皮靴1，号码2，大了1。那只1，合适1，不0，小0，更0&lt;/p&gt;
&lt;p&gt;句子B：这只1，皮靴1，号码1，大了0。那只1，合适1，不1，小1，更1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步，写出词频向量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;句子A：(1，1，2，1，1，1，0，0，0)&lt;/p&gt;
&lt;p&gt;句子B：(1，1，1，0，1，1，1，1，1)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五步，利用上述公式计算&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;3、python代码实现&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;Created on Mon Jul 30 09:35:54 2018
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@author: Administrator
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; jieba
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_word_vector():
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    w = np.ones((3,4))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    q = np.ones((3,4&quot;))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    print(w)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    print(np.sum(w * q))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;    &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;    
&lt;span&gt;19&lt;/span&gt;     s1 = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;句子1：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     s2 = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;句子2：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt;     cut1 =&lt;span&gt; jieba.cut(s1)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     cut2 =&lt;span&gt; jieba.cut(s2)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     
&lt;span&gt;25&lt;/span&gt;     list_word1 = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.join(cut1)).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     list_word2 = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.join(cut2)).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list_word1)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list_word2)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt;     key_word = list(set(list_word1 + list_word2))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;取并集&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(key_word)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt;     word_vector1 = np.zeros(len(key_word))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;给定形状和类型的用0填充的矩阵存储向量&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     word_vector2 =&lt;span&gt; np.zeros(len(key_word))
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;   
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(key_word)):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;依次确定向量的每个位置的值&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(len(list_word1)):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历key_word中每个词在句子中的出现次数&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; key_word[i] ==&lt;span&gt; list_word1[j]:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 word_vector1[i] += 1
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(list_word2)):
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; key_word[i] ==&lt;span&gt; list_word2[k]:
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 word_vector2[i] += 1
&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(word_vector1)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出向量&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(word_vector2)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; word_vector1, word_vector2
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; cosine():
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     v1, v2 =&lt;span&gt; get_word_vector()
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; float(np.sum(v1 * v2))/(np.linalg.norm(v1) *&lt;span&gt; np.linalg.norm(v2)) 
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(cosine())
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;4、运行结果&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1019336/201808/1019336-20180802121540914-780531101.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Aug 2018 04:18:00 +0000</pubDate>
<dc:creator>J.mg</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jm-15/p/9406425.html</dc:identifier>
</item>
<item>
<title>es5的小方法Object.defineProperty - Wyshon</title>
<link>http://www.cnblogs.com/wuweixin/p/9406293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuweixin/p/9406293.html</guid>
<description>&lt;p&gt;es5 的Object.defineProperty() 用来给一个对象定义一个属性。vue的双向绑定原理就是基于defineProperty的访问器属性实现的。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;使用语法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Object.defineProperty(obj, key, descriptor)&lt;/code&gt; 需要定义传入三个参数，这样就可以给对象obj定义一个key。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;obj: object类型，需要定义属性的对象&lt;/li&gt;
&lt;li&gt;key: string类型，属性的名称&lt;/li&gt;
&lt;li&gt;descriptor: object类型， 一个描述符，也是重点关注的参数&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;descriptor-&quot;&gt;descriptor 参数&lt;/h3&gt;
&lt;p&gt;第三个参数是一个对象有六个键值。分别是: configurable(boolean, 默认true), enumerable(boolean, 默认true), writable(boolean, 默认true), value(any, 默认undefined), get(function, 默认undefined), set(function, 默认undefined) 。其中writable, value任意一个和get, set任一一个都不可以同时存在。为什么呢？ 关于红宝书上的介绍，一上来就是一段教科书的描述，比较晦涩。将defineProperty方法定义的属性分为两种类型：数据属性和访问器属性。 所以descriptor参数的不同决定了相应的属性的类型。 故descriptor有两种方式&lt;/p&gt;
&lt;p&gt;描述数据属性(平时用obj.name = '123', 其实就是默认用这种方式定义的):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    configurable: false, // 默认为true, 描述能否被改变，比如delete或者修改成访问器属性
    enumerable： false, // 默认为true, 描述能否被 in 枚举，比如for-in
    writable: false, // 默认true, 描述是否能被更改
    value: [1, 2, 3], // 默认undefined, 就是属性的值
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;描述访问器属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    configurable: false, // 默认为true, 描述能否被改变，比如delete或者修改成访问器属性
    enumerable： false, // 默认为true, 描述能否被 in 枚举，比如for-in
    get: function() {  return this.name }, // 默认undefined, getter函数
    set: function(newVal) { this.name = newVal }, // 默认undefined, setter函数
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;简单实操&lt;/h2&gt;
&lt;p&gt;直接在chrome下进行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var obj = {};
Object.defineProperty(obj, 'name', {
    configurable: false, // 默认为true, 描述能否被改变，比如delete或者修改成访问器属性
    enumerable: false, // 默认为true, 描述能否被for-in枚举
    writable: false, // 默认true, 描述是否能被更改
    value: 'wython' // 默认undefined, 就是属性的值
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果 &lt;img src=&quot;https://user-images.githubusercontent.com/15258919/43560638-0ddc46fe-9646-11e8-97dd-b78a0dfc67be.png&quot; alt=&quot;image&quot;/&gt; 可以看到是定义了一个属性name.这种方式和obj.name = 'wython'; 其实没啥区别。在这里面我把configrable, enumerable, writable改成false。 所以如果参数去改值，或者遍历, 都是不行的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for(const i in obj) { console.log(i) }  // 结果: undefined
delete obj.name; // 无效
obj.name = 'Another wython'; // 无效&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;-&quot;&gt;尝试下访问器属性的定义方式&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;Object.defineProperty(obj, '_name', {
    configurable: true,
    enumerable: true,
    get: function() { return this.name },
    set: function(newVal) {
        // 我们可以尝试更改name的值，因为是不可更改所以是无效的
        this.name = newVal;
    }
})
// 验证
obj._name  = 1; // 无效，原因是访问器属性监听的是不可更改的name属性&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以说访问器属性监听的是另一个属性，如果监听的是自身，会报堆栈溢出的错误。&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object.defineProperty(obj, '_self', {
    configurable: true,
    enumerable: true,
    get: function() { return this._self },
    set: function(newVal) {
        // 我们可以尝试更改name的值，因为是不可更改所以是无效的
        this._self = newVal;
    }
})
obj._self;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/15258919/43561217-a021f764-9648-11e8-8575-008cb482f60e.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多的实例，可以自己尝试。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;说实话，defineProperty方法平时几乎不用。毕竟现在工作上很多东西已经实现好了。我们可以用setter的这种方式触发notity。类似于观察者模式的方式监听属性，实现双向数据绑定的作用。小中见大，细节的东西也是很重要的。这个方法的兼容性是IE9. IE8下面有些问题。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Aug 2018 03:50:00 +0000</pubDate>
<dc:creator>Wyshon</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuweixin/p/9406293.html</dc:identifier>
</item>
<item>
<title>PHP-CPP开发扩展（五） - 飞鸿影~</title>
<link>http://www.cnblogs.com/52fhy/p/9388764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52fhy/p/9388764.html</guid>
<description>&lt;p&gt;PHP-CPP是一个用于开发PHP扩展的C++库。本节讲解如何在C++中实现PHP类。&lt;/p&gt;
&lt;h2 id=&quot;类和对象&quot;&gt;类和对象&lt;/h2&gt;
&lt;h3 id=&quot;类和对象-1&quot;&gt;类和对象&lt;/h3&gt;
&lt;p&gt;怎样在PHP-CPP里写出PHP的类呢？很简单，看下面的例子：&lt;br/&gt;&lt;code&gt;main.cpp&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;/**
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/7
 */
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;phpcpp.h&amp;gt;

/**
 *  Counter class that can be used for counting
 */
class Counter : public Php::Base
{
private:
    /**
     *  The initial value
     *  @var    int
     */
    int _value = 0;

public:
    /**
     *  C++ constructor and destructor
     */
    Counter() = default;
    virtual ~Counter() = default;

    /**
     *  Update methods to increment or decrement the counter
     *  Both methods return the NEW value of the counter
     *  @return int
     */
    Php::Value increment() { return ++_value; }
    Php::Value decrement() { return --_value; }

    /**
     *  Method to retrieve the current counter value
     *  @return int
     */
    Php::Value value() const { return _value; }
    
    //类的静态成员函数
    static Php::Value gettime() {return time(NULL);}
};

/**
 *  Switch to C context to ensure that the get_module() function
 *  is callable by C programs (which the Zend engine is)
 */
extern &quot;C&quot; {
    /**
     *  Startup function that is called by the Zend engine 
     *  to retrieve all information about the extension
     *  @return void*
     */
    PHPCPP_EXPORT void *get_module() {
    
        // 必须是static类型，因为扩展对象需要在PHP进程内常驻内存
        static Php::Extension extension(&quot;helloworld&quot;, &quot;1.0.0&quot;);
        
        //初始化导出类
        Php::Class&amp;lt;Counter&amp;gt; counter(&quot;Counter&quot;);
        
        //注册导出类的可访问普通函数
        counter.method&amp;lt;&amp;amp;Counter::increment&amp;gt; (&quot;increment&quot;);
        counter.method&amp;lt;&amp;amp;Counter::decrement&amp;gt; (&quot;decrement&quot;);
        counter.method&amp;lt;&amp;amp;Counter::value&amp;gt; (&quot;value&quot;);
        
        //注册导出类的可访问静态函数
        counter.method&amp;lt;&amp;amp;Counter::gettime&amp;gt;(&quot;gettime&quot;);

        //注册导出类，使用右值引用方式，优化资源使用
        extension.add(std::move(counter));
        
        // 返回扩展对象指针
        return extension;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，C++类必须继承自&lt;code&gt;Php::Base&lt;/code&gt;；其次，当我们将类添加到扩展对象时，还必须指定要从PHP访问的所有方法；最后再注册导出类。&lt;/p&gt;
&lt;p&gt;我们先测试：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;/**
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/7
 */
$counter = new Counter;
echo 'result of increment() = '. $counter-&amp;gt;increment() . PHP_EOL;
echo 'result of increment() = '. $counter-&amp;gt;increment() . PHP_EOL;
echo 'result of decrement() = '. $counter-&amp;gt;decrement() . PHP_EOL;
echo 'result of value() = '. $counter-&amp;gt;value() . PHP_EOL;
echo 'result of gettime() = '. Counter::gettime() . PHP_EOL;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;result of increment() = 1
result of increment() = 2
result of decrement() = 1
result of value() = 1
result of gettime() = 1531621728&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;访问修饰符&quot;&gt;访问修饰符&lt;/h3&gt;
&lt;p&gt;我们还可以对导出的方法添加访问修饰符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//初始化导出类
Php::Class&amp;lt;Counter&amp;gt; counter(&quot;Counter&quot;);

//注册导出类的可访问普通函数
counter.method&amp;lt;&amp;amp;Counter::increment&amp;gt; (&quot;increment&quot;, Php::Private, {
    Php::ByVal(&quot;a&quot;, Php::Type::Numeric)
});
counter.method&amp;lt;&amp;amp;Counter::decrement&amp;gt; (&quot;decrement&quot;, Php::Protected, {
    Php::ByVal(&quot;a&quot;, Php::Type::Numeric)
});
counter.method&amp;lt;&amp;amp;Counter::value&amp;gt; (&quot;value&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Php::Class::method&lt;/code&gt;第二个参数支持设置访问修饰符，默认是public；第三个参数和普通函数一样，支持设置参数类型。&lt;/p&gt;
&lt;p&gt;支持的访问修饰符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;extern PHPCPP_EXPORT const int Static;
extern PHPCPP_EXPORT const int Abstract;
extern PHPCPP_EXPORT const int Final;
extern PHPCPP_EXPORT const int Public;
extern PHPCPP_EXPORT const int Protected;
extern PHPCPP_EXPORT const int Private;
extern PHPCPP_EXPORT const int Const;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有一点需要注意：C++里要导出的方法，必须全是Public的， 即使我们在PHP中将它们标记为私有或受保护。因为我们写的方法由PHP-CPP库调用，如果将它们设为私有，它们将对库不可见。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;抽象类final类&quot;&gt;抽象类、Final类&lt;/h3&gt;
&lt;p&gt;声明类为Final很简单，只需要在初始化导出类的时候声明一下即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Php::Class&amp;lt;Counter&amp;gt; counter(&quot;Counter&quot;, Php::Final);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么怎么声明一个抽象类呢？上面的例子里&lt;code&gt;Php::Class::method&lt;/code&gt;都传入了真正的C ++方法的地址，但是抽象方法通常没有实现，那么我们需要怎么提供指向方法的指针？幸运的是，在PHP-CPP里注册抽象方法不用提供指向C ++方法的指针。&lt;/p&gt;
&lt;p&gt;示例：&lt;br/&gt;抽象类原申明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/7
 */
#include &amp;lt;phpcpp.h&amp;gt;

//类声明
class MyAbstract : public Php::Base{};

extern &quot;C&quot; {
    
    PHPCPP_EXPORT void *get_module() 
    {
        // 必须是static类型，因为扩展对象需要在PHP进程内常驻内存
        static Php::Extension extension(&quot;helloworld&quot;, &quot;1.0.0&quot;);
        
        //初始化导出类
        Php::Class&amp;lt;MyAbstract&amp;gt; my_abstract(&quot;MyAbstract&quot;, Php::Abstract);
        
        //注册抽象方法：如果不给出C++方法的地址，该方法自动变成抽象方法
        my_abstract.method(&quot;myAbstractMethod&quot;, { 
            Php::ByVal(&quot;a&quot;, Php::Type::String, true) 
        });
        
        extension.add(std::move(my_abstract));
        
        // 返回扩展对象指针
        return extension;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在test.php尝试去实例化&lt;code&gt;MyAbstract&lt;/code&gt;类，提示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PHP Fatal error:  Uncaught Error: Cannot instantiate abstract class MyAbstract&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注：官方示例里初始化导出类里没有加&lt;code&gt;Php::Abstract&lt;/code&gt;,测试的时候发现还是可以实例化的，只是调用抽象方法才报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;构造函数和析构函数&quot;&gt;构造函数和析构函数&lt;/h3&gt;
&lt;p&gt;在C++代码里，PHP的构造函数和析构函数本质上是普通方法。明白了这点，就不难实现了。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/7
 */
#include &amp;lt;phpcpp.h&amp;gt;

/**
 *  Simple counter class
 */
class Counter : public Php::Base
{
private:
    /**
     *  Internal value
     *  @var int
     */
    int _value = 0;

public:
    /**
     *  c++ constructor
     */
    Counter() = default;

    /**
     *  c++ destructor
     */
    virtual ~Counter() = default;

    /**
     *  php &quot;constructor&quot;
     *  @param  params
     */
    void __construct(Php::Parameters &amp;amp;params)
    {
        // copy first parameter (if available)
        if (!params.empty()) _value = params[0];
    }

    /**
     *  functions to increment and decrement
     */
    Php::Value increment() { return ++_value; }
    Php::Value decrement() { return --_value; }
    Php::Value value() const { return _value; }
};

/**
 *  Switch to C context so that the get_module() function can be
 *  called by C programs (which the Zend engine is)
 */
extern &quot;C&quot; {
    /**
     *  Startup function for the extension
     *  @return void*
     */
    PHPCPP_EXPORT void *get_module() {
        static Php::Extension myExtension(&quot;my_extension&quot;, &quot;1.0&quot;);

        // description of the class so that PHP knows which methods are accessible
        Php::Class&amp;lt;Counter&amp;gt; counter(&quot;Counter&quot;);
        counter.method&amp;lt;&amp;amp;Counter::__construct&amp;gt;(&quot;__construct&quot;);
        counter.method&amp;lt;&amp;amp;Counter::increment&amp;gt;(&quot;increment&quot;);
        counter.method&amp;lt;&amp;amp;Counter::decrement&amp;gt;(&quot;decrement&quot;);
        counter.method&amp;lt;&amp;amp;Counter::value&amp;gt;(&quot;value&quot;);

        // add the class to the extension
        myExtension.add(std::move(counter));

        // return the extension
        return myExtension;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要构造函数为私有的，只需要在注册的时候加个flag：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;counter.method&amp;lt;&amp;amp;Counter::__construct&amp;gt;(&quot;__construct&quot;, Php::Private);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要禁止被clone，可以：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// alternative way to make an object unclonable
counter.method(&quot;__clone&quot;, Php::Private);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;接口&quot;&gt;接口&lt;/h3&gt;
&lt;p&gt;接口(Interface)由于不需要具体方法的实现，我们可以通过与定义类的方式类似的方式来实现。唯一的区别是我们不使用&lt;code&gt;Php::Class&amp;lt;YourClass&amp;gt;&lt;/code&gt;，而是一个&lt;code&gt;Php::Interface&lt;/code&gt;实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//初始化
Php::Interface interface(&quot;MyInterface&quot;);

//添加成员方法
interface.method(&quot;myMethod&quot;, { 
    Php::ByVal(&quot;value&quot;, Php::Type::String, true) 
});

//注册到扩展
extension.add(std::move(interface));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;继承&quot;&gt;继承&lt;/h3&gt;
&lt;h4 id=&quot;implement-实现&quot;&gt;implement 实现&lt;/h4&gt;
&lt;p&gt;我们除了可以在PHP代码去实现接口或者继承类，也可以在C++里实现。该&lt;code&gt;Php::Class&amp;lt;YourClass&amp;gt;&lt;/code&gt;对象有&lt;code&gt;extends()&lt;/code&gt;和&lt;code&gt;implements()&lt;/code&gt;，可用于指定基类和实现的接口。我们需要传入之前配置的类或接口。我们来看一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/7
 */
#include &amp;lt;phpcpp.h&amp;gt;
#include &amp;lt;iostream&amp;gt;

class MyClass : public Php::Base
{
    public:
        Php::Value myMethod(Php::Parameters &amp;amp;params){
            Php::out &amp;lt;&amp;lt; &quot;MyClass&quot; &amp;lt;&amp;lt; std::endl;
            return params;
        }
};

extern &quot;C&quot; {
    
    PHPCPP_EXPORT void *get_module() 
    {
        static Php::Extension extension(&quot;helloworld&quot;, &quot;1.0.0&quot;);
        
        //定义接口
        Php::Interface interface(&quot;MyInterface&quot;);
        interface.method(&quot;myMethod&quot;, { 
            Php::ByVal(&quot;value&quot;, Php::Type::String, true) 
        });
        extension.add(std::move(interface));

        // 注册一个自定义类
        Php::Class&amp;lt;MyClass&amp;gt; myClass(&quot;MyClass&quot;);

        // 实现接口定义
        myClass.implements(interface);
        myClass.method&amp;lt;&amp;amp;MyClass::myMethod&amp;gt;(&quot;myMethod&quot;, {
            Php::ByVal(&quot;value&quot;, Php::Type::String, true) 
        });
        extension.add(std::move(myClass));

        
        // 返回扩展对象指针
        return extension;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$obj = new MyClass();
var_dump($obj-&amp;gt;myMethod(11));&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;extends-继承&quot;&gt;extends 继承&lt;/h4&gt;
&lt;p&gt;PHP的继承与C++的继承没有直接关系，必须显示使用&lt;code&gt;Php::Class::extends()&lt;/code&gt;进行继承。&lt;/p&gt;
&lt;p&gt;还是接着上面的例子说明。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/7
 */
#include &amp;lt;phpcpp.h&amp;gt;
#include &amp;lt;iostream&amp;gt;

class MyClass : public Php::Base
{
    public:
        Php::Value myMethod(Php::Parameters &amp;amp;params){
            Php::out &amp;lt;&amp;lt; &quot;MyClass&quot; &amp;lt;&amp;lt; std::endl;
            return params;
        }
};

class MySubClass : public Php::Base{
};

extern &quot;C&quot; {
    
    PHPCPP_EXPORT void *get_module() 
    {
        static Php::Extension extension(&quot;helloworld&quot;, &quot;1.0.0&quot;);
        
        //定义接口
        Php::Interface interface(&quot;MyInterface&quot;);
        interface.method(&quot;myMethod&quot;, { 
            Php::ByVal(&quot;value&quot;, Php::Type::String, true) 
        });
        

        // 注册一个自定义类
        Php::Class&amp;lt;MyClass&amp;gt; myClass(&quot;MyClass&quot;);

        // 实现接口定义
        myClass.implements(interface);
        myClass.method&amp;lt;&amp;amp;MyClass::myMethod&amp;gt;(&quot;myMethod&quot;, {
            Php::ByVal(&quot;value&quot;, Php::Type::String, true) 
        });
        
        Php::Class&amp;lt;MySubClass&amp;gt; mySubClass(&quot;MySubClass&quot;);
        mySubClass.extends(myClass);
        
        extension.add(std::move(interface));
        extension.add(std::move(mySubClass));
        extension.add(std::move(myClass));
        
        // 返回扩展对象指针
        return extension;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：注册类(&lt;code&gt;extension.add&lt;/code&gt;)需要放到extends方法的后面，也就是不能先注册父类再使用extends，否则无法继承。建议实际编程的时候注册统一放到最后面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;魔术方法&quot;&gt;魔术方法&lt;/h3&gt;
&lt;p&gt;在PHP-CPP里，仅&lt;code&gt;__construct()&lt;/code&gt;需要显示的在&lt;code&gt;get_module()&lt;/code&gt;里注册，其他的魔术方法像&lt;code&gt;__get()&lt;/code&gt;、&lt;code&gt;__set()&lt;/code&gt;、&lt;code&gt;__call()&lt;/code&gt;等都不需要注册。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/7
 */
#include &amp;lt;phpcpp.h&amp;gt;

/**
 *  A sample class, that has some pseudo properties that map to native types
 */
class User : public Php::Base
{
private:
    /**
     *  Name of the user
     *  @var    std::string
     */
    std::string _name;

    /**
     *  Email address of the user
     *  @var    std::string
     */
    std::string _email;

public:
    /**
     *  C++ constructor and C++ destructpr
     */
    User() = default;
    virtual ~User() = default;

    /**
     *  Get access to a property
     *  @param  name        Name of the property
     *  @return Value       Property value
     */
    Php::Value __get(const Php::Value &amp;amp;name)
    {
        // check if the property name is supported
        if (name == &quot;name&quot;) return _name;
        if (name == &quot;email&quot;) return _email;

        // property not supported, fall back on default
        return Php::Base::__get(name);
    }

    /**
     *  Overwrite a property
     *  @param  name        Name of the property
     *  @param  value       New property value
     */
    void __set(const Php::Value &amp;amp;name, const Php::Value &amp;amp;value) 
    {
        // check the property name
        if (name == &quot;name&quot;) 
        {
            // store member
            _name = value.stringValue();
        }

        // we check emails for validity
        else if (name == &quot;email&quot;)
        {
            // store the email in a string
            std::string email = value;

            // must have a '@' character in it
            if (email.find('@') == std::string::npos) 
            {
                // email address is invalid, throw exception
                throw Php::Exception(&quot;Invalid email address&quot;);
            }

            // store the member
            _email = email;
        }

        // other properties fall back to default
        else
        {
            // call default
            Php::Base::__set(name, value);
        }
    }

    /**
     *  Check if a property is set
     *  @param  name        Name of the property
     *  @return bool
     */
    bool __isset(const Php::Value &amp;amp;name) 
    {
        // true for name and email address
        if (name == &quot;name&quot; || name == &quot;email&quot;) return true;

        // fallback to default
        return Php::Base::__isset(name);
    }

    /**
     *  Remove a property
     *  @param  name        Name of the property to remove
     */
    void __unset(const Php::Value &amp;amp;name)
    {
        // name and email can not be unset
        if (name == &quot;name&quot; || name == &quot;email&quot;) 
        {
            // warn the user with an exception that this is impossible
            throw Php::Exception(&quot;Name and email address can not be removed&quot;);
        }

        // fallback to default
        Php::Base::__unset(name);
    }
};

/**
 *  Switch to C context to ensure that the get_module() function
 *  is callable by C programs (which the Zend engine is)
 */
extern &quot;C&quot; {
    /**
     *  Startup function that is called by the Zend engine 
     *  to retrieve all information about the extension
     *  @return void*
     */
    PHPCPP_EXPORT void *get_module() {

        // extension object
        static Php::Extension myExtension(&quot;my_extension&quot;, &quot;1.0&quot;);

        // description of the class so that PHP knows 
        // which methods are accessible
        Php::Class&amp;lt;User&amp;gt; user(&quot;User&quot;);

        // add the class to the extension
        myExtension.add(std::move(user));

        // return the extension
        return myExtension;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
/**
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/7
 */

// initialize user and set its name and email address
$user = new User();
$user-&amp;gt;name = &quot;John Doe&quot;;
$user-&amp;gt;email = &quot;john.doe@example.com&quot;;

// show the email address
echo($user-&amp;gt;email.&quot;\n&quot;);

// remove the email address (this will cause an exception)
unset($user-&amp;gt;email);
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（未完待续）&lt;/p&gt;
&lt;p&gt;想第一时间获取最新动态，欢迎关注关注&lt;code&gt;飞鸿影的博客(fhyblog)&lt;/code&gt;，不定期为您呈现技术干货。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Aug 2018 03:44:00 +0000</pubDate>
<dc:creator>飞鸿影~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52fhy/p/9388764.html</dc:identifier>
</item>
</channel>
</rss>