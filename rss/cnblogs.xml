<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>浅入浅出数据结构（25）——最小生成树问题 - NSpt</title>
<link>http://www.cnblogs.com/mm93/p/8437939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mm93/p/8437939.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　上一篇博文我们提到了图的最短路径问题：&lt;a href=&quot;http://www.cnblogs.com/mm93/p/8434056.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/mm93/p/8434056.html&lt;/a&gt;。而最短路径问题可以说是这样的一个问题：路已经修好了，该怎么从这儿走到那儿？但是在和图有关的问题中，还有另一种有趣的问题：修路的成本已经知道了，该怎么修路才能尽可能节约成本，同时将这些地方都连起来？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比如我们知道有这么几个城市，它们互相之间还没有路：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210001535232-401997267.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;309&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　经过实地考察后，发现可以修的路以及各条路的修路成本如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210001612888-1278258659.png&quot; alt=&quot;&quot; width=&quot;441&quot; height=&quot;301&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是我们的预算有限，需要在修路时尽可能的省钱（也就是尽量减小所有边的权重之和），同时保证图中每一个城市总是能到达图中任意一个城市，该怎么修路呢？对于上图来说，其中一个方案是这样的，其总共的修路成本（即总权重）为8：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210022925060-1492888559.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;305&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另一个方案是这样的，略有不同，不过总成本也是8：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210022940670-234443385.png&quot; alt=&quot;&quot; width=&quot;457&quot; height=&quot;311&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　像这样的问题，就是我们今天要讨论的最小生成树问题。为了更准确地说明什么是最小生成树，我们需要先了解一个概念：连通。&lt;span&gt;对于一个无向图而言，如果每个顶点到每个其它顶点都存在路径，则该无向图是连通的&lt;/span&gt;。而对于有向图而言，道理相同又稍有变化，&lt;span&gt;在有向图中，若每个顶点到每个其它顶点都存在可行的路径，则该有向图是强连通的&lt;/span&gt;。比如下图就不是一个强连通的有向图，其中非v0顶点无法到达v0顶点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210003534982-322536928.png&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;299&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是如果我们将上面这个有向图的边都变为无向边，我们就会得到一个无向图，此无向图即该有向图的基础图（underlying graph）。如果一个有向图非强连通，但是其基础图是连通的，我们就称该有向图是弱连通的。上面这个有向图就是一个弱连通的有向图。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　明白了什么是连通之后，接下来我们说说最小生成树是什么：&lt;span&gt;在一个连通的无向图的所有边中，挑选出足以使所有顶点连通的那些边，且这些边的总权重不能更低，则这些边与所有顶点构成的图就是最小生成树&lt;/span&gt;。“最小”的意思是其总权重是最小的，“生成”则是因为这个树是从一个无向图中找出来的，也即生成的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　等等_(:з」∠)_  不是说“这些边与所有顶点构成的图”吗，怎么就成了树？原因是这样的，如果一个无向图是连通的，那么我们就能找出满足上述条件的那个图，而如果那个图存在，那它一定是一棵树（树是特殊的图嘛，这一点应该要懂的），比如本文前面所找出的最小生成图，显然是一棵树：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210022925060-1492888559.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;305&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为什么称最后找出来的顶点与边的集合为最小生成树，我们已经知道了，而为什么最后找出来的一定是树……咱能不纠结吗 (￣.￣)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好了，接下来讨论下一个问题：有向图可以找出最小生成树吗？答案是可以，只要有向图是强连通的。并且寻找有向图的最小生成树的过程也是基本一样的，因为无向图本就是以有向图的形式存储的（一条无向边拆成两条有向边）。不过因为本文并不打算给出可运行的代码，所以我们的讨论以无向图为基准，主要关注算法的思路，并且不考虑所给图非连通的情况。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　想要在图中找出最小生成树，有两种算法可供选择：Prim算法和Kruskal算法。因为Prim算法与寻找最短路径的Dijkstra算法非常非常非常像，所以我们先来讨论一下Prim算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Prim算法的思路是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　1.任选一个顶点，将其标为已知，即表示该顶点已在树中&lt;/span&gt;（Dijkstra算法中，起点由我们指定）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;2.找出所有已知顶点邻接的未知顶点，其中与任一已知顶点的邻接边权重最小的未知顶点，我们将其标为已知，同时将其preV设为与其邻接边最小的已知顶点，且其distance设为该邻接边的权重&lt;/span&gt;（在Dijkstra算法中，我们用的是“指向”，因为要考虑到有向图的情况，此外，Dijkstra算法中，我们将被标为已知的未知顶点的distance设为与其相连的已知顶点的distance加上边的权重）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;3.反复执行第二步，直至不存在已知顶点邻接了未知顶点为止。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;抽象的说，Prim算法就是随机选一个顶点，将其拉进原先为空的树中，然后不断地通过尽可能小的边将其他顶点拉进这棵树中&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　老样子，上述说法晦涩难懂 (￣.￣)。所以我们需要实际的走一遍来加深一下理解，以下图为例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210001612888-1278258659.png&quot; alt=&quot;&quot; width=&quot;441&quot; height=&quot;301&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　假设我们以v3作为起点，则图初始化后的状态如下（顶点旁有红圈表示该顶点已知，红圈中即该顶点的preV，顶点的distance我们暂不考虑）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210021804060-571283390.png&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;325&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着，我们找出所有已知顶点（v3）邻接的所有未知顶点：v0、v1、v2、v4、v5、v6。发现与已知顶点邻接边最小的未知顶点是v1、v4，其中未知顶点v1与已知顶点v3的邻接边权重为1，未知顶点v4与已知顶点v3的邻接边权重也为1，我们任选其一即可，比如选择v1，然后将v1设为已知，v1.preV=v3：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210021842138-1637992873.png&quot; alt=&quot;&quot; width=&quot;485&quot; height=&quot;336&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，我们找出所有已知顶点（v1、v3）邻接的所有未知顶点：v0、v2、v4、v5、v6，发现与已知顶点邻接边最小的未知顶点是v0、v4，其中未知顶点v0与已知顶点v1的邻接边权重为1，未知顶点v4与已知顶点v1或v3的邻接边权重为1，我们任选其一，比如v4，然后将v4设为已知，v4.preV=v1（也可以是v4.preV=v3）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210021917045-1515457215.png&quot; alt=&quot;&quot; width=&quot;547&quot; height=&quot;338&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，我们找出所有已知顶点（v1、v3、v4）邻接的所有未知顶点：v0、v2、v5、v6，发现与已知顶点邻接边最小的未知顶点是v0、v6，其中未知顶点v0与已知顶点v1的邻接边权重为1，未知顶点v6与已知顶点v4的邻接边权重为1，我们选v6，将v6设为已知，v6.preV=v4：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210021947295-204920019.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;345&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，我们找出所有已知顶点邻接的所有未知顶点：v0、v2、v5，其中与已知顶点的邻接边最小的是v0，未知顶点v0与已知顶点v1的邻接边权重为1，我们将v0设为已知，v0.preV=v1：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210022127466-620905538.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;345&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，找出所有已知顶点邻接的所有未知顶点：v2、v5，发现其中未知顶点v5与已知顶点v6的邻接边权重最小为2，所以我们将v5设为已知，v5.preV=v6：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210022043685-161852740.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;323&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，找出所有已知顶点邻接的所有未知顶点：v2，其中未知顶点v2与已知顶点v5的邻接边权重最小，所以我们将v2设为已知，v2.preV=v5:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210022240513-545632804.png&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;343&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，发现已经没有哪个已知顶点邻接了未知顶点，所以算法结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来，我们只要进行这两步操作就可以得出最小生成树：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.将每个顶点与其preV相连的边标为已知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.将非已知的边删去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　将每个顶点与其preV相连的边标为已知（注意，v3的preV是自身，此情况我们不做任何操作即可）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210022652591-1262408705.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;344&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　删去非已知的边：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210023124466-1971240916.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;330&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　当然，在实际编程中，有可能并不会执行这两个操作，我们只要在将最小生成树的相关信息保存在pathTable中即可，本例中算法结束后pathTable应为如下（与Dijkstra算法使用的pathTable略有不同：没有distance域）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210034028966-846246497.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然，我们也可以使用和Dijkstra算法时一样的pathTable，即加上distance域，不过在计算最小生成树时，一个顶点的distance域应该是其与preV邻接的边的权重：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210034239310-1763671745.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在我们走一遍Prim算法时，我们发现v4.preV既可以设为v3，也可以设为v1，这就已经说明了一点：&lt;span&gt;一个图的最小生成树并不一定是唯一的。不过还要注意的是：一个图即便有多个最小生成树，它们的总权重也应该是一样的。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　如果你回顾一遍Prim算法和Dijkstra算法，就会发现，&lt;span&gt;Prim算法与Dijkstra算法的区别可以说就两个：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.Prim算法的“起点”是任选的，Dijkstra算法是给定的&lt;/span&gt;&lt;span&gt;（毕竟要找的是单源最短路径）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.Prim算法在将一个未知顶点设为已知时，其distance设为其与已知顶点的最小邻接边的weight，而Dijkstra算法则是设为已知顶点.distance+weight&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　换句话说，Prim算法就是稍稍修改了一下的Dijkstra算法。如果你仔细观察我们用Prim算法生成的树，你会发现从v3出发到任意顶点的路径恰好是v3到该顶点的最短路径：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210023124466-1971240916.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;330&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来本应讨论Kruskal算法，但是我忽然发现我之前忘了写一篇关于树的集合与不相交集的博文(⊙ˍ⊙)。如果要讨论Kruskal算法，这两个预备知识是必不可少的，而如果这两个知识也要讲解的话，博文就太长了Orz。所以我只简单说说Kruskal的思路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在Prim算法中，我们是以已知顶点（即已在最小生成树中的顶点）为基础，不断地将未知顶点拉进树中。而&lt;span&gt;Kruskal算法则是另一种思路：以当前最小的边为基础，不断地将未知顶点拉进树中&lt;/span&gt;（这个过程可能产生多棵树）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以下图为例，我们走一遍Kruskal算法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210001612888-1278258659.png&quot; alt=&quot;&quot; width=&quot;441&quot; height=&quot;301&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们需要将边按权重从小到大排序，才能找“当前最小边”：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210041545341-1712963884.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先是处理当前最小边[v0，v1]，其所连接的两个顶点均未知，所以我们将它们均设为已知，并连起来：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210041626763-916031321.png&quot; alt=&quot;&quot; width=&quot;301&quot; height=&quot;224&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后处理下一个当前最小边[v1，v3]，其所连接的v3未知，将v3设为已知，连起来：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210041711920-1137418933.png&quot; alt=&quot;&quot; width=&quot;307&quot; height=&quot;228&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着处理边[v3，v4]，其连接的v4未知，将v4设为已知，连起来：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210041854279-1712894404.png&quot; alt=&quot;&quot; width=&quot;313&quot; height=&quot;233&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着处理边[v1，v4]，其连接的两个顶点均为已知，故跳过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着处理边[v4，v6]，其连接的v6未知，将v6设为已知，连起来：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210042020451-1293991106.png&quot; alt=&quot;&quot; width=&quot;332&quot; height=&quot;241&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着处理边[v2，v5]，其连接的v2和v5均为未知，所以将v2、v5均设为已知，连起来（注意，此时产生了两棵树）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210042147935-1265177550.png&quot; alt=&quot;&quot; width=&quot;344&quot; height=&quot;243&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着处理边[v5，v6]，其连接的顶点均为已知，但是v5和v6处于不同的树，所以我们将其连起来（这部分的相关判断和处理需要树的集合知识，以及不相交集数据结构）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127778/201802/1127778-20180210042342560-786238665.png&quot; alt=&quot;&quot; width=&quot;346&quot; height=&quot;245&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来处理的所有边都是所连接顶点已知，且所连接顶点处于同一棵树中，所以均会跳过，然后算法结束。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　没有掌握住博文的顺序和铺垫，实在是失败￣△￣&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不过Kruskal算法的思路我想我应该讲清楚了，就是Dijkstra算法和Prim算法的讲解可能太生硬了一些，但是细细地读、细细地理解、细细地过一遍，应该还是能明白的◑ω◐&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　这个系列的博文的主体部分到这儿就算结束了，从第一篇博文一路看到这儿的话，基本的数据结构和算法应该都能掌握。而像什么B+树、红黑树、算法设计技巧等更特殊的知识我没有算在主体部分中，以后可能会以“浅入浅出数据结构（附）”的标题形式写出。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 20:44:00 +0000</pubDate>
<dc:creator>NSpt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mm93/p/8437939.html</dc:identifier>
</item>
<item>
<title>【蓝桥杯单片机08】定时器的基本原理与应用 - 小蜜蜂老师</title>
<link>http://www.cnblogs.com/ALittleBee/p/8437448.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ALittleBee/p/8437448.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【蓝桥杯单片机08】定时器的基本原理与应用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;广东职业技术学院  欧浩源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、什么是定时/计数器？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    在没有钟表的时候，定时的方式通过有一注香的时间，或者一桶水的时间。前者烧香不断减少是减法，后者滴水不断增加是加法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;定时/计数器，是一种能够对内部时钟信号或外部输入信号进行计数，当计数值达到设定要求时，向CPU提出中断处理请求，从而实现定时或者计数功能的外设。定时/计数器的最基本工作原理是进行计数。作为定时器时，计数信号的来源选择周期性的内部时钟脉冲；用作计数器时，计数信号的来源选择非周期性的外部输入信号。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    不管是定时器还是计数器，&lt;span&gt;&lt;strong&gt;本质上&lt;/strong&gt;&lt;/span&gt;都是&lt;span&gt;&lt;strong&gt;计数器&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    定时器的工作原理与计数初值计算，可以参考以下例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1172284/201802/1172284-20180210000329716-1790431675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、51单片机的定时/计数器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    51单片机有两个定时/计数器T0和T1，为16位加法计数器，由低8位TLx和高8位THx两个寄存器组成，最大计数值为65535个计数脉冲。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;该加1计数器的&lt;span&gt;&lt;strong&gt;计数脉冲来源&lt;/strong&gt;&lt;/span&gt;有2个：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;1&amp;gt; 系统时钟振荡器输出的12分频。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;2&amp;gt; T0或T1引脚输入的外部脉冲信号。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    每接收到一个计数脉冲，计数器就会加1，当计数值累计至全为1时（8位255，13位8191，16位65535），再输入一个计数脉冲，计数器便会溢出回零，并且计数器的溢出是TCON寄存器的TF0或TF1位置1，同时向内核提出中断请求。如果定时/计数器工作于定时模式，则表示间隔定时时间到，如果工作与计数模式，则表示计数值已满。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    假设单片机的外部晶振为12MHz，那么，经过12分频后输入计数器的计数脉冲为1MHz，即每个脉冲的周期为1us。因此定时器T0的16位工作模式最大的定时时间为65535us，65.5ms。如果要定时10ms的话，计数器就不能够从0开始计数了，必须给它一个计数初值。怎么计算这个初值呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    要定时10ms，则相当于计数10000个脉冲后计数器的值就到达65535了，那么开始计数的这个地方就是计数初值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;65535 - 10000 = 55535 = 0xd8ef&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    把这个计算得到的初值写入TH0和TL0寄存器即可：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;TH0 = 0xd8；&lt;/strong&gt;&lt;/span&gt;或者 &lt;span&gt;&lt;strong&gt;TH0 = (65535 - 10000) / 256;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;TL0 = 0xef;&lt;/strong&gt;    &lt;/span&gt;或者 &lt;span&gt;&lt;strong&gt;TL0 = (65535 - 10000) % 256;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、定时/计数器相关的寄存器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    与定时/计数器相关的寄存器除了计数初值寄存器THx和TLx之外，就是TMOD寄存器和TCON寄存器，务必掌握。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;1&amp;gt; &lt;span&gt;&lt;strong&gt;TMOD&lt;/strong&gt;&lt;/span&gt;模式控制寄存器，不能进行位寻址，只能字节操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1172284/201802/1172284-20180210000421201-1605085270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &amp;lt;2&amp;gt; &lt;span&gt;&lt;strong&gt;TCON&lt;/strong&gt;&lt;/span&gt;中断标志寄存器，参考&lt;span&gt;&lt;strong&gt;【蓝桥杯单片机07】&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、定时/计数器的编程思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;在定时/计数器的程序设计中，通常有两个函数：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;初始化函数&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;&lt;strong&gt;中断服务函数&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;  在初始化函数中，一般需要进行以下几个配置：&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;1&amp;gt; 配置工作模式，即对TMOD寄存器编程。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;2&amp;gt; 计算技术初值，即对THx和TLx寄存器进行赋值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;3&amp;gt; 使能定时/计数器中断，即ET0或ET1置1。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;4&amp;gt; 打开总中断，即EA =1。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;5&amp;gt; 启动定时器，即TR0或TR1置1。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    在中断服务函数中，一般需要进行以下的编程：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;1&amp;gt; 如果不是自动重装模式，需要对THx和TLx重新赋值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;2&amp;gt; 进行间隔定时到达的逻辑处理（越少越好）。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    其程序框架和代码编写基本上差不多：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2017.cnblogs.com/blog/1172284/201802/1172284-20180210000512123-860994186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5、单元训练题目&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1172284/201802/1172284-20180210000547420-597488810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6、实现源码参考&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reg52.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  

sbit HC138_A &lt;/span&gt;= P2^&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;    
sbit HC138_B &lt;/span&gt;= P2^&lt;span&gt;6&lt;/span&gt;&lt;span&gt;;    
sbit HC138_C &lt;/span&gt;= P2^&lt;span&gt;7&lt;/span&gt;&lt;span&gt;;    

sbit LED1 &lt;/span&gt;= P0^&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;    
sbit LED2 &lt;/span&gt;= P0^&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;    

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Init74HC138(unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt; n)
{
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(n)
    {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;:
            HC138_A &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            HC138_B &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            HC138_C &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;:
            HC138_A &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            HC138_B &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            HC138_C &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;:
            HC138_A &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            HC138_B &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            HC138_C &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;:
            HC138_A &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            HC138_B &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            HC138_C &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;:
            HC138_A &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            HC138_B &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            HC138_C &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Init_Timer0()
{
    TMOD &lt;/span&gt;= &lt;span&gt;0x01&lt;/span&gt;;                                       
    TH0 = (&lt;span&gt;65536&lt;/span&gt; - &lt;span&gt;50000&lt;/span&gt;) / &lt;span&gt;256&lt;/span&gt;;        
    TL0 = (&lt;span&gt;65536&lt;/span&gt; - &lt;span&gt;50000&lt;/span&gt;) % &lt;span&gt;256&lt;/span&gt;&lt;span&gt;;
    ET0 &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;;                                                
    EA = &lt;span&gt;1&lt;/span&gt;;                                                    
    TR0 = &lt;span&gt;1&lt;/span&gt;;                                                
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;
unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SeviceTimer0() interrupt &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
{
    TH0 &lt;/span&gt;= (&lt;span&gt;65536&lt;/span&gt; - &lt;span&gt;50000&lt;/span&gt;) / &lt;span&gt;256&lt;/span&gt;&lt;span&gt;;
    TL0 &lt;/span&gt;= (&lt;span&gt;65536&lt;/span&gt; - &lt;span&gt;50000&lt;/span&gt;) % &lt;span&gt;256&lt;/span&gt;&lt;span&gt;;
    count&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(count == &lt;span&gt;10&lt;/span&gt;)                        
&lt;span&gt;    {
        LED1 &lt;/span&gt;= ~&lt;span&gt;LED1;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(count == &lt;span&gt;20&lt;/span&gt;)                        
&lt;span&gt;    {
        LED2 &lt;/span&gt;= ~&lt;span&gt;LED2;
        count &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;
main()
{
    Init74HC138(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    Init_Timer0();
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、定时器进阶强化训练&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1172284/201802/1172284-20180210000640013-871146784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 09 Feb 2018 16:24:00 +0000</pubDate>
<dc:creator>小蜜蜂老师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ALittleBee/p/8437448.html</dc:identifier>
</item>
<item>
<title>Laravel 5.4.36 session 没有保存成功问题 - Sunlight1992</title>
<link>http://www.cnblogs.com/Sunlight1992/p/8437189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Sunlight1992/p/8437189.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;span&gt;session使用注意点   &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;  　　工作中使用的是session默认的文件缓存  在使用过发现  session()-&amp;gt;put(&quot;key&quot;,&quot;values&quot;)  发现  没有设置成功  最后翻源码发现是使用文件缓存时候需要使用save() 方法才能持久化到数据库中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 源码:vendor/laravel/framework/src/Illuminate/Session/Store.php&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Save the session data to storage.
     *
     * @return bool
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; save()
    {
        &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;ageFlashData();

        &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;handler-&amp;gt;write(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;getId(), &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;prepareForStorage(
            &lt;/span&gt;&lt;span&gt;serialize&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;attributes)
        ));

        &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;started = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于使用文件缓存 因此write方法调用的源码：vendor/laravel/framework/src/Illuminate/Session/FileSessionHandler.php&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * {@inheritdoc}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; write(&lt;span&gt;$sessionId&lt;/span&gt;, &lt;span&gt;$data&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;$this&lt;/span&gt;-&amp;gt;files-&amp;gt;put(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;path.'/'.&lt;span&gt;$sessionId&lt;/span&gt;, &lt;span&gt;$data&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果有什么问题或者疑问欢迎留言  &lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 15:54:00 +0000</pubDate>
<dc:creator>Sunlight1992</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Sunlight1992/p/8437189.html</dc:identifier>
</item>
<item>
<title>Spring基础篇——bean的自动化装配 - 陈本布衣</title>
<link>http://www.cnblogs.com/chenbenbuyi/p/8245495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenbenbuyi/p/8245495.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;上篇博文讲Spring的IOC容器时说道，虽然容器功能强大&lt;span&gt;，但容器本身只是个空壳，需要我们主动放入装配对象，并告诉它对象之间的协作关系，然后容器才能按照我们的指示发挥它的魔力，完成装配bean的使命。这里，我们把Spring创建应用对象之间的协作关系的行为成为装配。Spring提供了很多装配&lt;span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;的方式供我们在开发中选择，我们常用到的有三种装配机制：自动装配、Java注解和XML配置。通常我们将第一种称为隐式的装配机制，后面两种为显示的装配机制。实际应用中，基于便利性考虑，首选的肯定是隐式的自动化装配机制，只有当需要注入的bean的源码不是由自己的程序来维护，而是引入第三方的应用组件的时候，才考虑显示的方式装配bean。当然，各种装配方式在实际应用中是可以自由选择搭配的，编码过程中也不必拘泥哪一种，适用就好。本篇博文先来讲述隐式的装配机制——bean的自动化装配。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;你一定很好奇Spring是怎么来实现其自动化装配机制的，其实Spring主要通过下面两个方面来实现：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;组件扫描——通过开启组件扫描功能让Spring可以自动发现应用上下文中的bean;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;自动装配——自动满足组件之间的依赖关系。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;下面，我们分别来看看Spring如何通过&lt;strong&gt;组件扫描&lt;/strong&gt;和&lt;strong&gt;自动装配&lt;/strong&gt;来为我们的应用程序自动化的装配bean。我们先定义一个汽车接口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.facade;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drive();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;　　组件扫描&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　组件扫描的要义在于通过扫描控制，让Spring自动的去发现应用程序中的bean。不过程序中的对象那么多，Spring怎么知道哪些对象是需要它去管理创建的呢？这就涉及到Spring的一个组件注解——@Component，&lt;span&gt;被该注解标注的类即为Spring的组件类，Spring容器加载过程中会自动的为该类创建&lt;/span&gt;bean（&lt;span&gt;PS:实际上Spring的组件注解按照语义化的分类还有@Controller @Repository @Service等等,分别作用于控制层、持久层和业务层，此处仅是举例演示，不做区分讲解&lt;/span&gt;）。所以，我们可以将接口的一个实现标注上该注解，表明实现类是要被Spring创建实例的——&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; QQCar &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drive() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;开QQ车&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;不过，Spring的注解扫描默认是不开启的，所以我们还需要显示的配置注解启动。这里同样有两种方式，Java注解和XML的方式，我们分别展示出来——&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Java配置类&lt;span&gt;CarConfig&lt;/span&gt; ：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ComponentScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarConfig {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;XML配置文件applicationContext.xml：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/context 
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;启动注解扫描&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;spring&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　接下来我们编写测试类，看看Spring是不是自动的去发现了我们注解为组件的bean并为我们创建了对象——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.config.CarConfig;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.QQCar;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.junit.Assert.assertNotNull;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * 注解释义：
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * @RunWith(SpringJUnit4ClassRunner.class)  测试在Spring环境中运行
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * @ContextConfiguration  上下文配置注解，指定配置文件（Java类或XML文件）的位置
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@ContextConfiguration(classes = CarConfig.class) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载Java配置类的方式&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; @ContextConfiguration(locations = &quot;classpath:resource/applicationContext.xml&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载XML配置的方式&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarTest {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; QQCar car ;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; carTest(){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        assertNotNull(car);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;虽然现在的编程趋势是越来越多的使用Java注解的方式，但是上面的测试你会发现，通过XML注解的方式能够测试成功，而Java注解的方式却是失败的，测试会抛出NoSuchBeanDefinitionException的异常，表示没有QQCar的组件定义，也就是Spring没有发现它，Why? 原因也很简单，那就是&lt;strong&gt;基于Java注解的方式启动的注解扫描默认情况下只能扫描配置类所在的包以及其的子包&lt;/strong&gt;，如果要明确扫描其它包中的组件，需要在启动扫描的注解 @ComponetScan 中显示的注明，如&lt;span&gt;改成 @ComponentScan(&quot;spring.impl&quot;)，上诉的测试就能通过了。如果有多个包要扫描，可以这样配置：&lt;span class=&quot;cnblogs_code&quot;&gt;@ComponentScan(basePackages = {&quot;spring.impl&quot;,&quot;spring.test&quot;})&lt;/span&gt;  不过这样字符串的表示方式是类型不安全的，而且写死包名的方式不利于代码重构，我们可以指定包中所含的类或接口来指定要扫描的包，于是可以这样标注: &lt;span class=&quot;cnblogs_code&quot;&gt;@ComponentScan(basePackageClasses = QQCar.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt; ,多个包同样可以用{}来以数组形式的表示。不过这样对重构依然不友好，最好的方式就是在要扫描的包中定义一个空标接口，该接口仅仅用来指定包扫描的范围，如此将重构的影响降到最低。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;　　自动装配&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　前文的讲述只是阐明如何将一个类定义成Spring的组件并启动Spring的组件扫描，而且我们已经通过测试证实，Spring确实扫描到了我们指定的组件类并为我们创建了对象。不过，创建的对象只是独立的存在，并没有和其他对象产生依赖协作；实际应用中，对象之间的依赖协作是再常见不过了，而要将Spring通过组件扫描为我们创建的对象根据实际业务建立起相互的依赖协作，就需要利用Spring的&lt;strong&gt;自动装配&lt;/strong&gt;。便于演示，我们再定义一个Man类,Man的工作就是开车,我们先通过构造器注入的方式来满足依赖，看Spring是否会给我们自动注入我们需要的Car的实例对象——&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Man {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man() {
    }

    @Autowired
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man(QQCar car) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        car.drive();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;测试方法——&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.config.CarConfig;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.Man;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; @ContextConfiguration(classes = CarConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarTest {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    Man man;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; carTest() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        man.work();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;如以上代码，测试当然是成功的，在测试类中，Man作为组件类被Spring扫描并创建了一个对象实例，该实例调用work方法的时候，需要Car的实例对象，而我们在有参构造函数上通过 @Autowired 注解表明了对象的依赖关系，程序运行过程中，Spring会自动为我们注入Car的实例对象来满足对象依赖，这就是自动装配的精要所在。实际上，&lt;strong&gt;不只是构造器上可以用 @Autowired 注解，在属性的Setter方法上，甚至普通的方法上，都可以用@Autowired 注解来满足对象之间的依赖&lt;/strong&gt;，实现自动注入的功能——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Man {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造器实现自动装配
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Autowired&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man(QQCar car) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Setter方法实现自动装配
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @Autowired&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCar(QQCar car) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通方法实现自动装配&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insertCar(QQCar car) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        car.drive();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;我们将Man类中添加不同的方法测试，依然是可以成功的。不过有一点要注意，在非构造器实现自动装配的时候，虽然我们没有自己new对象，但Spring创建实例会通过Man的默认的构造器，此时的Man类中如果定义了有参构造器，就一定要把默认构造器构造出来，不然会抛无默认构造器的异常，&lt;strong&gt;记住：一定养成类中写默认构造器的习惯，便于扩展。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;　　自动装配的歧义性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　  如果你足够细心，你会发现博主上面满足自动装配的测试代码中，注入的Car并没有采用多态的写法，代码显得很低级。其实我是为了测试通过，故意注入了具体的实现，实际业务中当然不会这么局限的去写代码。因为博主Car的接口还有一个奔驰车的实现类BenzCar，如果用多态的写法，自动装配会有产生歧义性问题，会抛 NoUniqueBeanDefinitionException 异常。那么，面对这种歧义性，如何去解决呢？你一定知道Spring容器管理的每个bean都会有一个ID作为唯一标识，在上面的示例中，我们描述QQCar类为Spring的组件的时候并没有明确的设置ID,但是&lt;strong&gt;Spring默认会将组件类的类名首字母小写来作为bean的ID&lt;/strong&gt;,而我们也可根据我们自己的业务需要自定义ID标识——&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;span&gt; spring.impl;

&lt;span&gt;import&lt;span&gt; org.springframework.stereotype.Component;
&lt;span&gt;import&lt;span&gt; spring.facade.Car;
&lt;span&gt;//&lt;span&gt;这里指定 chenbenbuyi 为组件的ID 
@Component(&quot;chenbenbuyi&quot;&lt;span&gt;)
&lt;span&gt;public &lt;span&gt;class QQCar &lt;span&gt;implements&lt;span&gt; Car {
    @Override
    &lt;span&gt;public &lt;span&gt;void&lt;span&gt; drive() {
        System.out.println(&quot;开QQ车&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　可是测试发现，这并没有解决接口参数在自动装配时的歧义性问题，因为在组件上自定义ID是一种后发行为，当你让Spring在装配阶段从多个接口实现中选择要自动注入的对象实例时，Spring无法选择——就好比你只跟我说你要开一辆车，每辆车也都有唯一的车牌号，但我还是不知道你要开什么车。怎么办呢？这里有多种解决方案，我们可以通过 @Primary注解将我们明确需要自动注入的实现类标注为首选的bean，就想这样——&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Primary;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@Primary
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BenzCar &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drive() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;开奔驰车&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;当自动装配的时候，Spring面对歧义性时，会优先选择被标注为首选的bean进行自动注入。当然，我们还可以采用限定符注解，在使用@Autowired 完成自动装配的时候限定只让某个bean作为自动注入的bean——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Man {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通方法实现自动装配&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     @Qualifier(&quot;chenbenbuyi&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;限定ID为 chenbenbuyi 的bean被装配进来&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insertCar(Car car) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        car.drive();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 &lt;span&gt;自&lt;/span&gt;&lt;span&gt;此，关于Spring的自动装配就阐述得差不多了，下一节系列文章会接着讲解Spring的另外两种常用的装配机制——&lt;span&gt;Java注解和XML配置。博文所述皆为原创，如要转载，请注明出处；如果阐述得不恰当的地方，欢迎指教，不胜感激。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 15:17:00 +0000</pubDate>
<dc:creator>陈本布衣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenbenbuyi/p/8245495.html</dc:identifier>
</item>
<item>
<title>解决AspNet Zero Core 5.0.1无法运行的问题 - Smile.X</title>
<link>http://www.cnblogs.com/xajh/p/8428818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xajh/p/8428818.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　最近在研究AspNet Zero Core 5.0.1时发现VS点击调试后就自动退出了，从ABP QQ群里得知作者加入了licensecode校验。经过一个周左右断断续续的折腾，算是破解了吧。原本想把加密类完全反编译出来，后来发现有些方法反编译不过来，所以有些方法就直接注释掉实现了(关键方法未能反编译，比较遗憾)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/xajh/p/8428818.html#Introduction&quot;&gt;一、说明&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/xajh/p/8428818.html#runeffect&quot;&gt;二、运行效果&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/xajh/p/8428818.html#tools&quot;&gt;三、工具软件&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/xajh/p/8428818.html#Decompile&quot;&gt;四、反编译过程&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/xajh/p/8428818.html#GithubAddress&quot;&gt;五、源码Github地址&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一&lt;span&gt;、说明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;如果对反编译不感兴趣的话，可以直接从github下载下来源码之后，把ABP文件下的两个工程Abp.AspNetZeroCore、Abp.AspNetZeroCore.Web编译一下拿到dll直接将AspNet Zero Core 5.0.1工程里的对应引用替换掉就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　拿到AspNet Zero Core 5.0.1源码后会发现有两个应用的dll在ABP github上是没有源码的，一个是在工程MyCompanyName.AbpZeroTemplate.Core里引用的Abp.AspNetZeroCore，另一个是在工程MyCompanyName.AbpZeroTemplate.Web.Core里引用的Abp.AspNetZeroCore.Web。分析之后做校验的代码在Abp.AspNetZeroCore这个dll中，具体方法为AbpAspNetZeroCoreModule类的PostInitialize方法中调用了另一个类AspNetZeroLicenseChecker的Check方法，破解的话直接将PostInitialize注释掉或去掉Check方法中的代码实现即可。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180209222724982-1831700046.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、&lt;strong&gt;运行效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;破解后的软件运行截图，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　服务端：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207225623123-516155359.jpg&quot; alt=&quot;&quot; width=&quot;728&quot; height=&quot;395&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　前端界面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207225927873-1098425656.jpg&quot; alt=&quot;&quot; width=&quot;712&quot; height=&quot;399&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、工具软件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　反编译过程中，我使用了两个软件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.Resharper套件之一，JetBrains dotPeek 2017.3.2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2.ILSpy version 3.0.1.3459。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、反编译过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;4.1.找到他们&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　取得源码用VS还原nuget包之后，会在系统盘目录(C:\Users\Administrator\.nuget\packages)中找到这两个dll(Abp.AspNetZeroCore.dll,Abp.AspNetZeroCore.Web.dll)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207232436216-1950758597.png&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;168&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;4.2 使用dotPeek反编译并导出工程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　将两个dll使用dotPeek反编译，然后在dotPeek的程序集管理其中，选中工程在右键菜单中选择Export to Project&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207232749123-191114321.png&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;241&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　反编译完成之后比较尴尬的是生成工程的.net版本为.net framework 2.0，我们自己创建个.Net Standard工程然后把反编译出来的文件拷贝到创建的解决方案里就可以了。两个dll的处理方法类似。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　工程建立完之后引入到源代码里，引入之后我的工程目录结构如下所示，为了调试方便我把对ABP类库的引用都替换成了源代码工程引用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207234034904-1607781476.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;     4.3  反编译Abp.AspNetZeroCore.Web.dll&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;这个dll比较简单，先从简单的入手吧，这个dll中主要就反编译一个类就可以了，如下图 　&lt;/span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207234453763-669434181.png&quot; alt=&quot;&quot; width=&quot;900&quot; height=&quot;413&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　这个类中4,5两处没看明白有什么用途，直接删掉了；2,3两处其实就是对应类实例的属性所以ctx.set_User(authenticateResult.get_Principal())直接改为ctx.User=val.Principal，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　authenticateResult.get_Succeeded() &amp;amp;&amp;amp; authenticateResult.get_Principal() != null直接改为val.Succeeded &amp;amp;&amp;amp; val.Principal != null。return 语句UseExtensions.Use这块儿实际&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上是方法参数app的扩展方法。所以整段代码整理之后如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207235052857-1653214729.png&quot; alt=&quot;&quot; width=&quot;766&quot; height=&quot;276&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个dll主要反编译这一个类就可以了，其他反编译的类不需要做额外处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt;  4.4 反编译Abp.AspNetZeroCore.dll&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　这个就比较费劲了，一是代码量大，二是有些代码没看懂怎么反编译，这个dll主要反编译下面两个类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207235343888-912342492.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  先看AspNetZeroBaseLicenseChecker这个类，这个类是AspNetZeroLicenseChecker类的基类，拿类的构造函数当 典型说一下一些个人的经验吧，未调整的反编译代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180209215106170-15585835.png&quot; alt=&quot;&quot; width=&quot;1051&quot; height=&quot;655&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对照上图标记：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.这个特性暂未发现有什么用处，直接去掉；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.这个方法有对应的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;   [MethodImpl(MethodImplOptions.NoInlining)]
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; iZ5hxHC38E0NlGy6Ai([In] &lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj0)
    {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) ((AspNetZeroConfiguration) obj0).LicenseCode;
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　实际上就是获取了调用参数的一个特性，所以可以直接修改为  this.LicenseCode = configuration.LicenseCode;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.这个循环稍微麻烦一点，按照执行步骤一步一步走就行了，名字混淆的方法直接用方法实现替换，这种代码少的好一些，理不乱，有些很长就有点儿头疼了，这整段代码搞来搞去其实就是两句，整理后的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;protected&lt;/span&gt; AspNetZeroBaseLicenseChecker(AspNetZeroConfiguration configuration, IAbpZeroConfig abpZeroConfig, &lt;span&gt;string&lt;/span&gt; configFilePath = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.LicenseCode =&lt;span&gt; configuration.LicenseCode;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._abpZeroConfig =&lt;span&gt; abpZeroConfig;
        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　其他的方法都可以按类似方式处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　AspNetZeroLicenseChecker这个类反编译方法类似，但是这个类中的Check方法就搞不定了，dotPeek反编译后的代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180209220842263-695249057.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　红色方框中圈住的部分实在搞不懂是怎么回事儿。各位园友如果有思路的话，可以提供一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、源码Github地址&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;反编译后的代码放到github上了，有兴趣的朋友可以下载下来研究一下，&lt;span&gt;&lt;strong&gt;有问题欢迎留言讨论&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;https://github.com/YSmileX/AspNetZeroCore&quot; target=&quot;_blank&quot;&gt;https://github.com/YSmileX/AspNetZeroCore&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 09 Feb 2018 14:45:00 +0000</pubDate>
<dc:creator>Smile.X</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xajh/p/8428818.html</dc:identifier>
</item>
<item>
<title>python中的线程 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/8437027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/8437027.html</guid>
<description>&lt;h2 id=&quot;线程的创建&quot;&gt;1.线程的创建&lt;/h2&gt;
&lt;h3 id=&quot;通过thread类直接创建&quot;&gt;1.1 通过&lt;code&gt;thread&lt;/code&gt;类直接创建&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time
    
    def foo(n):
        time.sleep(n)
        print(&quot;foo func:&quot;,n)
    
    def bar(n):
        time.sleep(n)
        print(&quot;bar func:&quot;,n)
    
    s1=time.time()
    
    #创建一个线程实例t1,foo为这个线程要运行的函数
    t1=threading.Thread(target=foo,args=(3,))
    t1.start()    #启动线程t1
    
    #创建一个线程实例t2,bar为这个线程要运行的函数
    t2=threading.Thread(target=bar,args=(5,))
    t2.start()    #启动线程t2
    
    print(&quot;ending&quot;)
    
    s2=time.time()
    
    print(&quot;cost time:&quot;,s2-s1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段程序里，一个函数会先休眠几秒钟，然后再打印一句话，第二个函数也是先休眠几秒钟，然后打印一句话。&lt;/p&gt;
&lt;p&gt;接着程序会实例化两个线程，并调用两个函数来执行，最后会打印程序问总共执行了多少时间&lt;/p&gt;
&lt;p&gt;程序运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ending
cost time: 0.002000093460083008
foo func: 3
bar func: 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序会先运行父线程，打印&lt;code&gt;&quot;ending&quot;&lt;/code&gt;,然后打印程序执行父线程的时间，最后才会运行子线程&lt;/p&gt;
&lt;h3 id=&quot;通过thread类来继承式创建&quot;&gt;1.2 通过&lt;code&gt;thread&lt;/code&gt;类来继承式创建&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time
    
    # 定义MyThread类，其继承自threading.Thread这个父类
    class MyThread(threading.Thread): 
    
        def __init__(self):
            threading.Thread.__init__(self)
    
        def run(self):
            print(&quot;ok&quot;)
            time.sleep(2)
            print(&quot;end t1&quot;)
    
    # 对类进行实例化
    t1=MyThread()
    
    # 启动线程
    t1.start()
    print(&quot;ending&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;thread类的一些常用方法&quot;&gt;2. Thread类的一些常用方法&lt;/h2&gt;
&lt;h3 id=&quot;join在子线程完成之前主线程将一直被阻塞&quot;&gt;2.1 &lt;code&gt;join()&lt;/code&gt;:在子线程完成之前，主线程将一直被阻塞****&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;线程的join方法必须在子线程的start方法之后定义&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在第一个例子中加入两行代码，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time
    
    
    def foo(n):
        time.sleep(n)
        print(&quot;foo func:&quot;,n)
    
    def bar(n):
        time.sleep(n)
        print(&quot;bar func:&quot;,n)
    
    s1=time.time()
    t1=threading.Thread(target=foo,args=(3,))
    t1.start()
    
    t2=threading.Thread(target=bar,args=(5,))
    t2.start()
    
    t1.join()       # 阻塞t1线程
    t2.join()       # 阻塞t2线程
    
    print(&quot;ending&quot;)
    s2=time.time()
    
    print(&quot;cost time:&quot;,s2-s1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次执行程序，运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foo func: 3
bar func: 5
ending
cost time: 5.002285957336426&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行到子线程t1中的foo方法时会睡眠3秒钟，与此同时，子线程t2也在睡眠&lt;/p&gt;
&lt;p&gt;等到子线程t1睡眠完成后，开始打印foo函数中的print语句，然后子线程t1执行完成&lt;/p&gt;
&lt;p&gt;2秒钟之后，子线程t2睡眠完成，开始打印bar函数中的print语句，然后子线程t2也执行完成。&lt;/p&gt;
&lt;p&gt;而在这之前，主线程一直处于阻塞状态。等到子线程执行完成之后主线程才会执行&lt;/p&gt;
&lt;h3 id=&quot;setdeamontrue&quot;&gt;2.2 setDeamon(True)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;setDaemon方法作用是将进程声明为守护线程，必须在`start()`方法调用之前，&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不设置为守护线程，程序会被无限挂起&lt;/p&gt;
&lt;p&gt;在程序执行过程中，执行一个主线程，主线程又创建一个子线程时，主线程和子线程会分别运行。&lt;/p&gt;
&lt;p&gt;当主线程运行完成时，会检验子线程是否执行完成，如果子线程执行完成，则主线程会等待子线程完成后再退出。&lt;/p&gt;
&lt;p&gt;但是有的时候只要主线程执行完成之后，不管子线程是否执行完成，都和主线程一起退出，这个就需要调用&lt;code&gt;setDeamon&lt;/code&gt;方法了。&lt;/p&gt;
&lt;p&gt;拿第一个例子来说吧，现在我想让子线程t1和t2随同主线程关闭，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time
    
    def foo(n):
        print(&quot;foo start&quot;)
        time.sleep(n)
        print(&quot;foo end...&quot;)
    
    def bar(n):
        print(&quot;bar start&quot;)
        time.sleep(n)
        print(&quot;bar end...&quot;)
    
    s1 = time.time()
    t1 = threading.Thread(target=foo, args=(3,))
    t1.setDaemon(True)
    t1.start()
    
    t2 = threading.Thread(target=bar, args=(5,))
    t2.setDaemon(True)
    t2.start()
    
    print(&quot;ending&quot;)
    s2 = time.time()
    
    print(&quot;cost time:&quot;, s2 - s1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行结果如下 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foo start
bar start
ending
cost time: 0.003000020980834961&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，把t1和t2都声明为守护线程后，程序自上而下执行，先执行子线程t1中的foo方法，打印foo函数中的第一条打印语句，然后子线程t1进入到睡眠状态。&lt;/p&gt;
&lt;p&gt;然后子线程t2执行，打印bar函数中的第一条print语句，然后子线程t2进入睡眠状态，程序切换到主线程运行&lt;/p&gt;
&lt;p&gt;主线程打印完&quot;ending&quot;语句，发现子线程t1和t2已经被设置为守护线程，所以主线程不需要再等待两个子线程执行完成，而是立即结束，打印整个程序的执行时间。&lt;/p&gt;
&lt;p&gt;整个程序就跟随主线程一起关闭了。&lt;/p&gt;
&lt;h3 id=&quot;子线程的一些其他方法&quot;&gt;2.3 子线程的一些其他方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;isAlive()           #判断一个线程是否是活动线程
getName()           #返回线程的名字
setName()           #设置线程的名字&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time
    
    def foo(n):
        time.sleep(n)
        print(&quot;foo func:&quot;, n)
    
    def bar(n):
        time.sleep(n)
        print(&quot;bar func:&quot;, n)
    
    s1 = time.time()
    t1 = threading.Thread(target=foo, args=(3,))
    t1.setDaemon(True)
    
    print(&quot;线程还未启动时，判断t1是否是活动的线程：&quot;, t1.isAlive())  # 线程还未启动，所以是False
    t1.start()  # 启动线程
    print(&quot;线程已启动时，判断t1是否是活动的线程：&quot;, t1.isAlive())  # 线程已启动，所以是True
    print(&quot;修改前的线程名为：&quot;,t1.getName())  # 获取线程名
    t1.setName(&quot;t1&quot;)        #设置线程名
    print(&quot;修改后的线程名为：&quot;,t1.getName())  # 获取线程名
    
    t1.join()
    
    print(&quot;线程执行完成时，判断t1是不否是活动的线程：&quot;, t1.isAlive())  # 线程已执行完成，所以是False
    
    # print(threading.activeCount())
    print(&quot;ending&quot;)
    s2 = time.time()
    
    print(&quot;cost time:&quot;, s2 - s1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;线程还未启动时，判断t1是否是活动的线程： False
线程已启动时，判断t1是否是活动的线程： True
修改前的线程名为： Thread-1
修改后的线程名为： t1
foo func: 3
线程执行完成时，判断t1是不否是活动的线程： False
ending
cost time: 3.001171588897705&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;threading模块提供的一些方法&quot;&gt;3.threading模块提供的一些方法&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;threading.currentThread()   #返回当前的线程变量
threading.enumerate()       #返回一个包含正在运行的线程的列表，不包括启动前和终止后的线程
threading.activeCount()     #返回正在运行的线程数量，等同于len(threading.enumerate())&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time

    def foo(n):
        time.sleep(n)
        print(&quot;foo func:&quot;, n)

    def bar(n):
        time.sleep(n)
        print(&quot;bar func:&quot;, n)

    s1 = time.time()
    t1 = threading.Thread(target=foo, args=(3,))
    t1.setDaemon(True)
    t1.start()

    t2 = threading.Thread(target=bar, args=(5,))
    t2.setDaemon(True)
    t2.start()

    print(&quot;程序中正在运行的线程数量：&quot;,threading.activeCount())
    print(&quot;程序中当前的线程变量：&quot;,threading.currentThread())
    print(&quot;当前正在运行的线程的列表：&quot;,threading.enumerate())
    print(&quot;ending&quot;)
    s2 = time.time()

    print(&quot;cost time:&quot;, s2 - s1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;程序中正在运行的线程数量： 3
程序中当前的线程变量： &amp;lt;_MainThread(MainThread, started 7064)&amp;gt;
当前正在运行的线程的列表： [&amp;lt;_MainThread(MainThread, started 7064)&amp;gt;, &amp;lt;Thread(Thread-1, started daemon 6384)&amp;gt;, &amp;lt;Thread(Thread-2, started daemon 2640)&amp;gt;]
ending
cost time: 0.002000093460083008&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 09 Feb 2018 14:26:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/8437027.html</dc:identifier>
</item>
<item>
<title>[搬运] DotNetAnywhere:可供选择的 .NET 运行时 - 张很水</title>
<link>http://www.cnblogs.com/chenug/p/8436819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenug/p/8436819.html</guid>
<description>&lt;blockquote readability=&quot;1.5760869565217&quot;&gt;
&lt;p&gt;原文 : &lt;a href=&quot;http://mattwarren.org/2017/10/19/DotNetAnywhere-an-Alternative-.NET-Runtime/&quot;&gt;DotNetAnywhere: An Alternative .NET Runtime&lt;/a&gt;&lt;br/&gt;作者 : &lt;a href=&quot;https://github.com/mattwarren/&quot;&gt;Matt Warren&lt;/a&gt;&lt;br/&gt;译者 : &lt;a href=&quot;https://www.jianshu.com/u/910143584bd2&quot;&gt;张很水&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我最近在收听一个名为&lt;a href=&quot;https://www.dotnetrocks.com/&quot;&gt;DotNetRock&lt;/a&gt; 的优质播客，其中有以&lt;a href=&quot;http://knockoutjs.com/&quot;&gt;Knockout.js&lt;/a&gt;而闻名的&lt;a href=&quot;https://twitter.com/stevensanderson&quot;&gt;Steven Sanderson&lt;/a&gt; 正在讨论 &lt;a href=&quot;https://www.dotnetrocks.com/?show=1455&quot;&gt;&quot; WebAssembly And Blazor &quot;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;也许你还没听过，&lt;a href=&quot;https://github.com/SteveSanderson/Blazor&quot;&gt;Blazor&lt;/a&gt; 正试图凭借&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt;的魔力将 .NET 带入到浏览器中。如果您想了解更多信息，Scott Hanselmen 已经在 &lt;a href=&quot;https://www.hanselman.com/blog/NETAndWebAssemblyIsThisTheFutureOfTheFrontend.aspx&quot;&gt;&quot; .NET和WebAssembly——这会是前端的未来吗? &quot;&lt;/a&gt;一文中做了一番介绍。( 点击查看该文的&lt;a href=&quot;http://geek.csdn.net/news/detail/233214&quot;&gt;翻译&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;尽管 WebAssembly 非常酷炫，然而更让我感兴趣的是 Blazor 如何使用&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere&quot;&gt;DotNetAnywhere&lt;/a&gt;作为底层的 .NET 运行时。本文将讨论DotNetAnywhere 是什么，能做什么，以及同完整的 .NET Framework 做比较。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;首先值得指出的是，DotNetAnywhere (DNA) 被设计为一个完全兼容的 .NET 运行时，可以运行被完整的.NET 框架编译的 dll 和 exe 。除此之外 (至少在理论上) &lt;strong&gt;支持&lt;/strong&gt; 以下的&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere#supported-net-runtime-features&quot;&gt;.NET 运行时的功能&lt;/a&gt;，真是令人激动!&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;泛型&lt;/li&gt;
&lt;li&gt;垃圾收集和析构&lt;/li&gt;
&lt;li&gt;弱引用&lt;/li&gt;
&lt;li&gt;完整的异常处理 - try/catch/finally&lt;/li&gt;
&lt;li&gt;PInvoke&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;委托&lt;/li&gt;
&lt;li&gt;事件&lt;/li&gt;
&lt;li&gt;可空类型&lt;/li&gt;
&lt;li&gt;一维数组&lt;/li&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;另外对于&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection&quot;&gt;反射&lt;/a&gt;提供&lt;strong&gt;部分支持&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;非常有限的只读方法&lt;br/&gt;typeof(), GetType(), Type.Name, Type.Namespace, Type.IsEnum(),&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;最后，还有一些目前不支持的功能：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;属性&lt;/li&gt;
&lt;li&gt;大部分的反射方法&lt;/li&gt;
&lt;li&gt;多维数组&lt;/li&gt;
&lt;li&gt;Unsafe 代码&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/issues?q=is%3Aissue+is%3Aclosed&quot;&gt;各种各样的错误或缺少的功能&lt;/a&gt;可能会让代码无法在 DotNetAnywhere下运行，但其中一些已经被&lt;a href=&quot;https://github.com/SteveSanderson/Blazor/pulls?utf8=%E2%9C%93&amp;amp;q=is:pr&quot;&gt;Blazor 修复&lt;/a&gt;，所以值得时不时检查 Blazor 的发布版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如今，DotNetAnywhere 的原始仓库&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere#this-project-is-inactive-no-issues-or-prs-will-be-dealt-with&quot;&gt;不再活跃&lt;/a&gt; (最后一个持续的活动是在2012年1月)，所以未来任何的开发或错误修复都可能在 Blazor 的仓库中执行。如果你曾经在 DotNetAnywhere 中修复过某些东西，可以考虑在那里发一个PR。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更新：&lt;/strong&gt;还有其他版本的各种错误修复和增强：&lt;/p&gt;

&lt;p&gt;我觉得 DotNetAnywhere 运行时最令人印象深刻的一点是 &lt;strong&gt;只由一个人开发&lt;/strong&gt;，并且 &lt;strong&gt;只用了 40,000 行代码&lt;/strong&gt;！反观，完整的 .NET 框架仅是垃圾收集器就&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/src/gc/gc.cpp&quot;&gt;有将近37000 行代码&lt;/a&gt; ( 更多信息请我之前发布的&lt;a href=&quot;http://mattwarren.org/2017/03/23/Hitchhikers-Guide-to-the-CoreCLR-Source-Code/#overall-stats&quot;&gt;CoreCLR 源代码漫游指南&lt;/a&gt; )。&lt;/p&gt;
&lt;h2 id=&quot;机器码---共-17710-行&quot;&gt;机器码 - 共 17,710 行&lt;/h2&gt;
&lt;h2 id=&quot;托管代码---共-28783-行&quot;&gt;托管代码 - 共 28,783 行&lt;/h2&gt;
&lt;h2 id=&quot;关键组件&quot;&gt;关键组件&lt;/h2&gt;
&lt;p&gt;接下来，让我们看一下 DotNetAnywhere 中的关键组件，正是我们了解怎么兼容 .NET 运行时的好办法。同样我们也能看到它与微软 .NET Framework 的差异。&lt;/p&gt;
&lt;h2 id=&quot;加载-.net-dll&quot;&gt;加载 .NET dll&lt;/h2&gt;
&lt;p&gt;DotNetAnywhere 所要做的第一件事就是加载、解析包含在 .dll 或者.exe 中的 &lt;strong&gt;元数据和代码。&lt;/strong&gt;这一切都存放在&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/MetaData.c&quot;&gt;MetaData.c&lt;/a&gt;中，主要是在&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/MetaData.c#L302-L484&quot;&gt;LoadSingleTable(..)&lt;/a&gt; 函数中。通过添加一些调试代码，我能够从一般的 .NET dll 中获取所有类型的 &lt;strong&gt;元数据&lt;/strong&gt; 摘要，这是一个非常有趣的列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MetaData contains     1 Assemblies (MD_TABLE_ASSEMBLY)
MetaData contains     1 Assembly References (MD_TABLE_ASSEMBLYREF)
MetaData contains     0 Module References (MD_TABLE_MODULEREF)

MetaData contains    40 Type References (MD_TABLE_TYPEREF)
MetaData contains    13 Type Definitions (MD_TABLE_TYPEDEF)
MetaData contains    14 Type Specifications (MD_TABLE_TYPESPEC)
MetaData contains     5 Nested Classes (MD_TABLE_NESTEDCLASS)

MetaData contains    11 Field Definitions (MD_TABLE_FIELDDEF)
MetaData contains     0 Field RVA's (MD_TABLE_FIELDRVA)
MetaData contains     2 Propeties (MD_TABLE_PROPERTY)
MetaData contains    59 Member References (MD_TABLE_MEMBERREF)
MetaData contains     2 Constants (MD_TABLE_CONSTANT)

MetaData contains    35 Method Definitions (MD_TABLE_METHODDEF)
MetaData contains     5 Method Specifications (MD_TABLE_METHODSPEC)
MetaData contains     4 Method Semantics (MD_TABLE_PROPERTY)
MetaData contains     0 Method Implementations (MD_TABLE_METHODIMPL)
MetaData contains    22 Parameters (MD_TABLE_PARAM)

MetaData contains     2 Interface Implementations (MD_TABLE_INTERFACEIMPL)
MetaData contains     0 Implementation Maps? (MD_TABLE_IMPLMAP)

MetaData contains     2 Generic Parameters (MD_TABLE_GENERICPARAM)
MetaData contains     1 Generic Parameter Constraints (MD_TABLE_GENERICPARAMCONSTRAINT)

MetaData contains    22 Custom Attributes (MD_TABLE_CUSTOMATTRIBUTE)
MetaData contains     0 Security Info Items? (MD_TABLE_DECLSECURITY)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多关于 &lt;strong&gt;元数据&lt;/strong&gt; 的资料请参阅 &lt;a href=&quot;https://iobservable.net/blog/2013/05/12/introduction-to-clr-metadata/&quot;&gt;介绍 CLR 元数据&lt;/a&gt;，&lt;a href=&quot;https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-pe-headers/&quot;&gt;解析.NET 程序集—–关于 PE 头文件&lt;/a&gt; 和 &lt;a href=&quot;https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/&quot;&gt;ECMA 标准&lt;/a&gt; 等文章。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;执行-.net-il&quot;&gt;执行 .NET IL&lt;/h2&gt;
&lt;p&gt;DotNetAnywhere 的另一大功能是 &quot;即时编译器&quot; (JIT)，即执行 IL 的代码，从 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT_Execute.c&quot;&gt;JIT_Execute.c&lt;/a&gt;和&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT.c&quot;&gt;JIT.c&lt;/a&gt; 中开始执行。在 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT.c#L232-L1606&quot;&gt;JITit(..) 函数&lt;/a&gt; 的主入口中 &quot;执行循环&quot;，其中最令人印象深刻的是在一个 1,374 行代码的 &lt;code&gt;switch&lt;/code&gt; 中就有 200 多个 &lt;code&gt;case&lt;/code&gt; !!&lt;/p&gt;
&lt;p&gt;从更高的层面看，它所经历的整个过程如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-5d0ebf77d8b76dd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;NET IL - DNA JIT Op-Codes&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与定义在 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/CIL_OpCodes.h&quot;&gt;CIL_OpCodes.h&lt;/a&gt; (&lt;code&gt;CIL_XXX&lt;/code&gt;) .NET IL 操作码 ( Op-Codes)  不同，DotNetAnywhere JIT 操作码 (Op-Codes) 是定义在 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT_OpCodes.h&quot;&gt;JIT_OpCodes.h&lt;/a&gt; (&lt;code&gt;JIT_XXX&lt;/code&gt;)中。&lt;/p&gt;
&lt;p&gt;有趣的是这部分 JIT 代码是 DotNetAnywhere 中唯一一处&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT_Execute.c#L184-L204&quot;&gt;使用汇编编写&lt;/a&gt; ，并且只是 &lt;code&gt;win32&lt;/code&gt; 。 它允许使用 &lt;code&gt;jump&lt;/code&gt; 或者 &lt;code&gt;goto&lt;/code&gt; 在 C 源码中跳转标签,所以当 IL 指令被执行时，实际上并不会离开 &lt;code&gt;JITit(..)&lt;/code&gt; 函数，控制（流程）只是从一处移动到别处，不必进行完整的方法调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifdef __GNUC__

#define GET_LABEL(var, label) var = &amp;amp;&amp;amp;label

#define GO_NEXT() goto **(void**)(pCurOp++)

#else
#ifdef WIN32

#define GET_LABEL(var, label) \
    { __asm mov edi, label \
    __asm mov var, edi }

#define GO_NEXT() \
    { __asm mov edi, pCurOp \
    __asm add edi, 4 \
    __asm mov pCurOp, edi \
    __asm jmp DWORD PTR [edi - 4] }

#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;il-差异&quot;&gt;IL 差异&lt;/h2&gt;
&lt;p&gt;在完整的 .NET framework 中，所有的 IL 代码在被 CPU 执行之前都是由  &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-tutorial.md&quot;&gt;Just-in-Time Compiler (JIT)&lt;/a&gt; 转换为机器码。&lt;/p&gt;
&lt;p&gt;如你所见, DotNetAnywhere &quot;解释&quot; (interprets) IL时是逐条执行指令，甚至会调用 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT.c&quot;&gt;JIT.c&lt;/a&gt; 文件来完成。 &lt;strong&gt;没有机器码&lt;/strong&gt; 被反射发出 (emitted) ,所以这个命名还是有点奇怪!?&lt;/p&gt;
&lt;p&gt;或许这只是一个差异，但实在是无法让我搞清楚它是如何进行 &quot;解释&quot; (interpreting) 代码和 &quot;即时编译&quot; (JITting)，即使我再阅读完下面的文章还是不得其解!! (有人能指教一下吗?)&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;垃圾回收&quot;&gt;垃圾回收&lt;/h2&gt;
&lt;p&gt;所有关于 DotNetAnywhere 的垃圾回收(GC) 代码都在 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/Heap.c&quot;&gt;Heap.c&lt;/a&gt; 中，而且还是 600 行易于阅读的代码。给你一个概览吧，下面是它暴露的函数列表:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void Heap_Init();
void Heap_SetRoots(tHeapRoots *pHeapRoots, void *pRoots, U32 sizeInBytes);
void Heap_UnmarkFinalizer(HEAP_PTR heapPtr);
void Heap_GarbageCollect();
U32 Heap_NumCollections();
U32 Heap_GetTotalMemory();

HEAP_PTR Heap_Alloc(tMD_TypeDef *pTypeDef, U32 size);
HEAP_PTR Heap_AllocType(tMD_TypeDef *pTypeDef);
void Heap_MakeUndeletable(HEAP_PTR heapEntry);
void Heap_MakeDeletable(HEAP_PTR heapEntry);

tMD_TypeDef* Heap_GetType(HEAP_PTR heapEntry);

HEAP_PTR Heap_Box(tMD_TypeDef *pType, PTR pMem);
HEAP_PTR Heap_Clone(HEAP_PTR obj);

U32 Heap_SyncTryEnter(HEAP_PTR obj);
U32 Heap_SyncExit(HEAP_PTR obj);

HEAP_PTR Heap_SetWeakRefTarget(HEAP_PTR target, HEAP_PTR weakRef);
HEAP_PTR* Heap_GetWeakRefAddress(HEAP_PTR target);
void Heap_RemovedWeakRefTarget(HEAP_PTR target);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gc-差异&quot;&gt;GC 差异&lt;/h2&gt;
&lt;p&gt;就像我们对比 JIT/Interpreter 一样, 在 GC 上的差异同样可见。&lt;/p&gt;
&lt;h4 id=&quot;conservative-gc&quot;&gt;Conservative GC&lt;/h4&gt;
&lt;p&gt;首先，DotNetAnywhere 的 GC 是 &lt;a href=&quot;https://stackoverflow.com/questions/7629446/conservative-garbage-collector&quot;&gt;Conservative GC&lt;/a&gt;。简单地说，这意味着它不知道 (或者说肯定) 内存的哪些区域是对象的引用/指针，还是一个随机数 (看起来像内存地址)。而在.NET Framework 中 JIT 收集这些信息并存在&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/src/inc/gcinfo.h&quot;&gt;GCInfo structure&lt;/a&gt;中，所以它的 GC 可以有效利用，而 DotNetAnywhere 是做不到。&lt;/p&gt;
&lt;p&gt;相反, 在 &lt;code&gt;标记(Mark)&lt;/code&gt; 的阶段，GC &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/Heap.c#L278-L345&quot;&gt;获取所有可用的 &quot; 根 (roots) &quot;&lt;/a&gt;, 将一个对象中的所有内存地址视为 &quot;潜在的&quot; 引用(因此说它是 &quot;&lt;em&gt;conservative&lt;/em&gt;&quot;)。然后它必须查找每个可能的引用，看看它是否真的指向 &quot;对象的引用&quot;。通过跟踪 &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_andersson.aspx&quot;&gt;平衡二叉搜索树&lt;/a&gt; (按内存地址排序) 来执行操作, 流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-c000e860ea48b322.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Binary Tree with Pointers into the Heap&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，这意味着所有的对象引用在分配时都必须存储在二叉树中，这会增加分配的开销。另外还需要额外的内存，每个堆多占用 20 个字节。我们看看 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/Heap.c#L58-L83&quot;&gt;&lt;code&gt;tHeapEntry&lt;/code&gt; 的数据结构&lt;/a&gt; (所有的指针占用 4 字节, &lt;code&gt;U8&lt;/code&gt; 等于 1 字节，而 &lt;code&gt;padding&lt;/code&gt; 可忽略不计)， &lt;code&gt;tHeapEntry *pLink[2]&lt;/code&gt; 是启用二叉树查找所需的额外数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct tHeapEntry_ {
    // Left/right links in the heap binary tree
    tHeapEntry *pLink[2];
    // The 'level' of this node. Leaf nodes have lowest level
    U8 level;
    // Used to mark that this node is still in use.
    // If this is set to 0xff, then this heap entry is undeletable.
    U8 marked;
    // Set to 1 if the Finalizer needs to be run.
    // Set to 2 if this has been added to the Finalizer queue
    // Set to 0 when the Finalizer has been run (or there is no Finalizer in the first place)
    // Only set on types that have a Finalizer
    U8 needToFinalize;
    
    // unused
    U8 padding;

    // The type in this heap entry
    tMD_TypeDef *pTypeDef;

    // Used for locking sync, and tracking WeakReference that point to this object
    tSync *pSync;

    // The user memory
    U8 memory[0];
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么 DotNetAnywhere 这样做呢?   DotNetAnywhere的作者&lt;a href=&quot;https://github.com/chrisdunelm&quot;&gt;Chris Bacon&lt;/a&gt; 是这样 &lt;a href=&quot;https://github.com/SteveSanderson/Blazor/pull/7#discussion_r136719427&quot;&gt;解释&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;告诉你吧，整个堆代码确实需要重写，减少每个对象的内存开销，并且不需要分配二叉树。一开始设计 GC 时没有考虑那么多,（现在做的话）会增加很多代码。这是我一直想做的事情，但从来没有动手。&lt;strong&gt;为了尽快使用 GC 而只好如此。&lt;/strong&gt; 在最初的设计中完全没有 GC。它的速度非常快，以至于内存也会很快用完。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多 &quot;Conservative&quot; 机制和 &quot;Precise&quot; GC机制的细节请看:&lt;/p&gt;
&lt;h3 id=&quot;gc-只做了-标记-扫描-不会做压缩&quot;&gt;&lt;strong&gt;GC 只做了 &quot;标记-扫描&quot;, 不会做压缩&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在 GC 方面另一个不同的行为是它不会在回收后做任何内存 &lt;strong&gt;压缩&lt;/strong&gt; ，正如 Steve Sanderson 在 &lt;a href=&quot;https://github.com/SteveSanderson/Blazor/blob/master/src/Blazor.Runtime/Interop/ManagedGCHandle.cs#L40-L43&quot;&gt;working on Blazor&lt;/a&gt; 中所说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;在服务器端执行期间，我们实际上并不需要任何内存固定 (pin)，在客户端执行过程中并没有任何互操作，所有的东西（实际上）都是固定的。&lt;strong&gt;因为 DotNetAnywhere 的 GC只做标记扫描,没有任何压缩阶段。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;此外，当一个对象被分配给 DotNetAnywhere 时，只是调用了 &lt;a href=&quot;http://www.cplusplus.com/reference/cstdlib/malloc/&quot;&gt;malloc()&lt;/a&gt;, 它的代码细节在 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/Heap.c#L468&quot;&gt;Heap_Alloc(..) 函数&lt;/a&gt; 中。所以它也没有&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/garbage-collection.md#physical-representation-of-the-managed-heap&quot;&gt;&quot;Generations&quot; 或者 &quot;Segments&quot;&lt;/a&gt; 的概念，你在 .NET Framework GC 中见到的如 &quot;Gen 0&quot;、&quot;Gen 1&quot; 或者 &quot;大对象堆&quot; 等都不会出现。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;最后，我们来看看线程模型，它与 .NET Framework 中的线程模型截然不同。&lt;/p&gt;
&lt;h2 id=&quot;线程差异&quot;&gt;线程差异&lt;/h2&gt;
&lt;p&gt;DotNetAnywhere (表面上)乐于为你创建线程并执行代码, 然而这只是一种幻觉. 事实上它只会跑在 &lt;strong&gt;一个线程&lt;/strong&gt; 中， 不同的线程之间 &lt;strong&gt;切换上下文&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-f2cb400017eda542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Thread Usage Explanation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以通过下面的代码了解, ( 引用自 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/Thread.c#L112-L236&quot;&gt;Thread_Execute() 函数&lt;/a&gt;)将  &lt;code&gt;numInst&lt;/code&gt; 设置为 &lt;code&gt;100&lt;/code&gt; 并传入 &lt;code&gt;JIT_Execute(..)&lt;/code&gt; 中:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (;;) {
    U32 minSleepTime = 0xffffffff;
    I32 threadExitValue;

    status = JIT_Execute(pThread, 100);
    switch (status) {
        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个有趣的副作用是 DotNetAnywhere 中&lt;code&gt;corlib&lt;/code&gt; 的实现代码将变得非常简单。如&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/corlib/System.Threading/Interlocked.cs#L28&quot;&gt;&lt;code&gt;Interlocked.CompareExchange()&lt;/code&gt; 函数&lt;/a&gt;的&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/System.Threading.Interlocked.c#L26-L37&quot;&gt;内部实现&lt;/a&gt; 所示, 你所期待的同步就缺失了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tAsyncCall* System_Threading_Interlocked_CompareExchange_Int32(
            PTR pThis_, PTR pParams, PTR pReturnValue) {
    U32 *pLoc = INTERNALCALL_PARAM(0, U32*);
    U32 value = INTERNALCALL_PARAM(4, U32);
    U32 comparand = INTERNALCALL_PARAM(8, U32);

    *(U32*)pReturnValue = *pLoc;
    if (*pLoc == comparand) {
        *pLoc = value;
    }

    return NULL;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;作为性能测试, 我将使用&lt;a href=&quot;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;amp;lang=csharpcore&amp;amp;id=1&quot;&gt;C# 最简版本&lt;/a&gt; 实现的 &lt;a href=&quot;http://benchmarksgame.alioth.debian.org/u64q/binarytrees.html&quot;&gt;基于二叉树的计算机语言基准测试&lt;/a&gt;做对比。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：DotNetAnywhere 旨在运行于低内存设备，所以不意味着能与完整的 .NET Framework具有相同的性能。对比结果时切记!!&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;net-framework-4.6.1---0.36-seconds&quot;&gt;.NET Framework, 4.6.1 - 0.36 seconds&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;Invoked=TestApp.exe 15
stretch tree of depth 16         check: 131071
32768    trees of depth 4        check: 1015808
8192     trees of depth 6        check: 1040384
2048     trees of depth 8        check: 1046528
512      trees of depth 10       check: 1048064
128      trees of depth 12       check: 1048448
32       trees of depth 14       check: 1048544
long lived tree of depth 15      check: 65535

Exit code      : 0
Elapsed time   : 0.36
Kernel time    : 0.06 (17.2%)
User time      : 0.16 (43.1%)
page fault #   : 6604
Working set    : 25720 KB
Paged pool     : 187 KB
Non-paged pool : 24 KB
Page file size : 31160 KB&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dotnetanywhere---54.39-seconds&quot;&gt;DotNetAnywhere - 54.39 seconds&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;Invoked=dna TestApp.exe 15
stretch tree of depth 16         check: 131071
32768    trees of depth 4        check: 1015808
8192     trees of depth 6        check: 1040384
2048     trees of depth 8        check: 1046528
512      trees of depth 10       check: 1048064
128      trees of depth 12       check: 1048448
32       trees of depth 14       check: 1048544
long lived tree of depth 15      check: 65535

Total execution time = 54288.33 ms
Total GC time = 36857.03 ms
Exit code      : 0
Elapsed time   : 54.39
Kernel time    : 0.02 (0.0%)
User time      : 54.15 (99.6%)
page fault #   : 5699
Working set    : 15548 KB
Paged pool     : 105 KB
Non-paged pool : 8 KB
Page file size : 13144 KB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，DotNetAnywhere 在这个基准测试中运行速度并不快（0.36秒/ 54秒）。然而，如果我们对比另一个基准测试，它的表现就好很多。DotNetAnywhere 在分配对象（&lt;code&gt;类&lt;/code&gt;）时有很大的开销，而在使用&lt;code&gt;结构&lt;/code&gt;时就不那么明显了。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Elapsed Time (secs)&lt;/td&gt;
&lt;td&gt;3.1&lt;/td&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;GC Collections&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;67&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Total GC time (msecs)&lt;/td&gt;
&lt;td&gt;983.59&lt;/td&gt;
&lt;td&gt;439.73&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;最后，我要感谢 &lt;a href=&quot;https://github.com/chrisdunelm&quot;&gt;Chris Bacon&lt;/a&gt;。DotNetAnywhere 真是一个伟大的代码库，对于我们实现 .NET 运行时很有帮助。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;请在 &lt;a href=&quot;https://news.ycombinator.com/item?id=15514519&quot;&gt;Hacker News&lt;/a&gt;的 &lt;a href=&quot;https://www.reddit.com/r/programming/comments/77frgh/dotnetanywhere_an_alternative_net_runtime/&quot;&gt;/r/programming&lt;/a&gt; 中讨论本文。&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Fri, 09 Feb 2018 13:07:00 +0000</pubDate>
<dc:creator>张很水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenug/p/8436819.html</dc:identifier>
</item>
<item>
<title>【OCR技术系列之三】大批量生成文字训练集 - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8436820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8436820.html</guid>
<description>&lt;p&gt;放假了，终于可以继续可以静下心写一写OCR方面的东西。上次谈到文字的切割，今天打算总结一下我们怎么得到用于训练的文字数据集。如果是想训练一个手写体识别的模型，用一些前人收集好的手写文字集就好了，比如中科院的&lt;a href=&quot;http://www.nlpr.ia.ac.cn/databases/handwriting/Offline_database.html&quot;&gt;这些数据集&lt;/a&gt;。但是如果我们只是想要训练一个专门用于识别印刷汉字的模型，那么我们就需要各种印刷字体的训练集，那怎么获取呢？借助强大的图像库，自己生成就行了！&lt;/p&gt;
&lt;p&gt;先捋一捋思路，生成文字集需要什么步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;确定你要生成多少字体，生成一个记录着汉字与label的对应表。&lt;/li&gt;
&lt;li&gt;确定和收集需要用到的字体文件。&lt;/li&gt;
&lt;li&gt;生成字体图像，存储在规定的目录下。&lt;/li&gt;
&lt;li&gt;适当的数据增强。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第三步的生成字体图像最为重要，如果仅仅是生成很正规的文字，那么用这个正规文字集去训练模型，第一图像数目有点少，第二模型泛化能力比较差，所以我们需要对字体图像做大量的图像处理工作，以增大我们的印刷体文字数据集。&lt;/p&gt;
&lt;p&gt;我总结了一下，我们可以做的一些图像增强工作有这些：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;文字扭曲&lt;/li&gt;
&lt;li&gt;背景噪声（椒盐）&lt;/li&gt;
&lt;li&gt;文字位置（设置文字的中心点）&lt;/li&gt;
&lt;li&gt;笔画粘连（膨胀来模拟）&lt;/li&gt;
&lt;li&gt;笔画断裂（腐蚀来模拟）&lt;/li&gt;
&lt;li&gt;文字倾斜（文字旋转）&lt;/li&gt;
&lt;li&gt;多种字体&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;做完以上增强后，我们得到的数据集已经非常庞大了。&lt;/p&gt;
&lt;p&gt;现在开始一步一步生成我们的3755个汉字的印刷体文字数据集。&lt;/p&gt;
&lt;h2 id=&quot;一生成汉字与label的对应表&quot;&gt;一、生成汉字与label的对应表&lt;/h2&gt;
&lt;p&gt;这里的汉字、label映射表的生成我使用了pickel模块，借助它生成一个id:汉字的映射文件存储下来。&lt;br/&gt;这里举个小例子说明怎么生成这个“汉字：id”映射表。&lt;/p&gt;
&lt;p&gt;首先在一个txt文件里写入你想要的汉字，如果对汉字对应的ID没有要求的话，我们不妨使用该汉字的排位作为其ID，比如“一二三四五”中，五的ID就是00005。如此类推，把汉字读入内存，建立一个字典，把这个关系记录下来，再使用pickle.dump存入文件保存。&lt;/p&gt;
&lt;h2 id=&quot;二收集字体文件&quot;&gt;二、收集字体文件&lt;/h2&gt;
&lt;p&gt;字体文件上网收集就好了，但是值得注意的是，不是每一种字体都支持汉字，所以我们需要筛选出真正适合汉字生成的字体文件才可以。我一共使用了十三种汉字字体作为我们接下来汉字数据集用到的字体，具体如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210217982-1742939776.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，如果需要进一步扩大数据集来增强训练得到的模型的泛化能力，可以花更多的时间去收集各类汉字字体，那么模型在面对各种字体时也能从容应对，给出准确的预测。&lt;/p&gt;
&lt;h2 id=&quot;三文字图像生成&quot;&gt;三、文字图像生成&lt;/h2&gt;
&lt;p&gt;首先是定义好输入参数，其中包括输出目录、字体目录、测试集大小、图像尺寸、图像旋转幅度等等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def args_parse():
    #解析输入参数
    parser = argparse.ArgumentParser(
        description=description, formatter_class=RawTextHelpFormatter)
    parser.add_argument('--out_dir', dest='out_dir',
                        default=None, required=True,
                        help='write a caffe dir')
    parser.add_argument('--font_dir', dest='font_dir',
                        default=None, required=True,
                        help='font dir to to produce images')
    parser.add_argument('--test_ratio', dest='test_ratio',
                        default=0.2, required=False,
                        help='test dataset size')
    parser.add_argument('--width', dest='width',
                        default=None, required=True,
                        help='width')
    parser.add_argument('--height', dest='height',
                        default=None, required=True,
                        help='height')
    parser.add_argument('--no_crop', dest='no_crop',
                        default=True, required=False,
                        help='', action='store_true')
    parser.add_argument('--margin', dest='margin',
                        default=0, required=False,
                        help='', )
    parser.add_argument('--rotate', dest='rotate',
                        default=0, required=False,
                        help='max rotate degree 0-45')
    parser.add_argument('--rotate_step', dest='rotate_step',
                        default=0, required=False,
                        help='rotate step for the rotate angle')
    parser.add_argument('--need_aug', dest='need_aug',
                        default=False, required=False,
                        help='need data augmentation', action='store_true')   
    args = vars(parser.parse_args()) 
    return args
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来需要将我们第一步得到的对应表读入内存，因为这个表示ID到汉字的映射，我们在做一下转换，改成汉字到ID的映射，用于后面的字体生成。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#将汉字的label读入，得到（ID：汉字）的映射表label_dict
label_dict = get_label_dict()

char_list=[]  # 汉字列表
value_list=[] # label列表
for (value,chars) in label_dict.items():
    print (value,chars)
    char_list.append(chars)
    value_list.append(value)

# 合并成新的映射关系表：（汉字：ID）
lang_chars = dict(zip(char_list,value_list)) 
font_check = FontCheck(lang_chars) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们对旋转的角度存储到列表中，旋转角度的范围是[-rotate,rotate].&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if rotate &amp;lt; 0:
    roate = - rotate

if rotate &amp;gt; 0 and rotate &amp;lt;= 45:
    all_rotate_angles = []
    for i in range(0, rotate+1, rotate_step):  
        all_rotate_angles.append(i)
    for i in range(-rotate, 0, rotate_step):
        all_rotate_angles.append(i)
    #print(all_rotate_angles)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在说一下字体图像是怎么生成的，首先我们使用的工具是PIL。PIL里面有很好用的汉字生成函数，我们用这个函数再结合我们提供的字体文件，就可以生成我们想要的数字化的汉字了。我们先设定好我们生成的字体颜色为黑底白色，字体尺寸由输入参数来动态设定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210320013-473428024.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 生成字体图像
class Font2Image(object):

    def __init__(self,
                 width, height,
                 need_crop, margin):
        self.width = width
        self.height = height
        self.need_crop = need_crop
        self.margin = margin

    def do(self, font_path, char, rotate=0):
        find_image_bbox = FindImageBBox()
        # 黑色背景
        img = Image.new(&quot;RGB&quot;, (self.width, self.height), &quot;black&quot;)
        draw = ImageDraw.Draw(img)
        font = ImageFont.truetype(font_path, int(self.width * 0.7),)
        # 白色字体
        draw.text((0, 0), char, (255, 255, 255),
                  font=font)
        if rotate != 0:
            img = img.rotate(rotate)
        data = list(img.getdata())
        sum_val = 0
        for i_data in data:
            sum_val += sum(i_data)
        if sum_val &amp;gt; 2:
            np_img = np.asarray(data, dtype='uint8')
            np_img = np_img[:, 0]
            np_img = np_img.reshape((self.height, self.width))
            cropped_box = find_image_bbox.do(np_img)
            left, upper, right, lower = cropped_box
            np_img = np_img[upper: lower + 1, left: right + 1]
            if not self.need_crop:
                preprocess_resize_keep_ratio_fill_bg = \
                    PreprocessResizeKeepRatioFillBG(self.width, self.height,
                                                    fill_bg=False,
                                                    margin=self.margin)
                np_img = preprocess_resize_keep_ratio_fill_bg.do(
                    np_img)
            # cv2.imwrite(path_img, np_img)
            return np_img
        else:
            print(&quot;img doesn't exist.&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们写两个循环，外层循环是汉字列表，内层循环是字体列表，对于每个汉字会得到一个image_list列表，里面存储着这个汉字的所有图像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (char, value) in lang_chars.items():  # 外层循环是字
    image_list = []
    print (char,value)
    #char_dir = os.path.join(images_dir, &quot;%0.5d&quot; % value)
    for j, verified_font_path in enumerate(verified_font_paths):    # 内层循环是字体   
        if rotate == 0:
            image = font2image.do(verified_font_path, char)
            image_list.append(image)
        else:
            for k in all_rotate_angles: 
                image = font2image.do(verified_font_path, char, rotate=k)
                image_list.append(image)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将image_list中图像按照比例分为训练集和测试集存储。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        test_num = len(image_list) * test_ratio
        random.shuffle(image_list)  # 图像列表打乱
        count = 0
        for i in range(len(image_list)):
            img = image_list[i]
            #print(img.shape)
            if count &amp;lt; test_num :
                char_dir = os.path.join(test_images_dir, &quot;%0.5d&quot; % value)
            else:
                char_dir = os.path.join(train_images_dir, &quot;%0.5d&quot; % value)

            if not os.path.isdir(char_dir):
                os.makedirs(char_dir)

            path_image = os.path.join(char_dir,&quot;%d.png&quot; % count)
            cv2.imwrite(path_image,img)
            count += 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写好代码后，我们执行如下指令，开始生成印刷体文字汉字集。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; python gen_printed_char.py --out_dir ./dataset --font_dir ./chinese_fonts --width 30 --height 30 --margin 4 --rotate 30 --rotate_step 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析一下上述指令的附属参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;--out_dir 表示生成的汉字图像的存储目录&lt;/li&gt;
&lt;li&gt;--font_dir 表示放置汉字字体文件的路径&lt;/li&gt;
&lt;li&gt;--width --height 表示生成图像的高度和宽度&lt;/li&gt;
&lt;li&gt;--margin 表示字体与边缘的间隔&lt;/li&gt;
&lt;li&gt;--rotate 表示字体旋转的范围，[-rotate,rotate]&lt;/li&gt;
&lt;li&gt;--rotate_step 表示每次旋转的间隔&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;生成这么一个3755个汉字的数据集的所需的时间还是很久的，估计接近一个小时。其实这个生成过程可以用多线程、多进程并行加速，但是考虑到这种文字数据集只需生成一次就好，所以就没做这方面的优化了。数据集生成完我们可以发现，在dataset文件夹下得到train和test两个文件夹，train和test文件夹下都有3755个子文件夹，分别存储着生成的3755个汉字对应的图像，每个子文件的名字就是该汉字对应的id。随便选择一个train文件夹下的一个子文件夹打开，可以看到所获得的汉字图像，一共634个。&lt;/p&gt;
&lt;p&gt;dataset下自动生成测试集和训练集&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210356545-1280275168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试集和训练集下都有3755个子文件夹，用于存储每个汉字的图像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210507951-532205948.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成出来的汉字图像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210545763-206700772.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;额外的图像增强&quot;&gt;额外的图像增强&lt;/h2&gt;
&lt;p&gt;第三步生成的汉字图像是最基本的数据集，它所做的图像处理仅有旋转这么一项，如果我们想在数据增强上再做多点东西，想必我们最终训练出来的OCR模型的性能会更加优秀。我们使用opencv来完成我们定制的汉字图像增强任务。&lt;/p&gt;
&lt;p&gt;因为生成的图像比较小，仅仅是30*30，如果对这么小的图像加噪声或者形态学处理，得到的字体图像会很糟糕，所以我们在做数据增强时，把图片尺寸适当增加，比如设置为100×100，再进行相应的数据增强，效果会更好。&lt;/p&gt;
&lt;h3 id=&quot;噪点增加&quot;&gt;噪点增加&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def add_noise(cls,img):
    for i in range(20): #添加点噪声
        temp_x = np.random.randint(0,img.shape[0])
        temp_y = np.random.randint(0,img.shape[1])
        img[temp_x][temp_y] = 255
    return img&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;适当腐蚀&quot;&gt;适当腐蚀&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def add_erode(cls,img):
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(3, 3))    
    img = cv2.erode(img,kernel) 
    return img&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;适当膨胀&quot;&gt;适当膨胀&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def add_dilate(cls,img):
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(3, 3))    
    img = cv2.dilate(img,kernel) 
    return img&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后做随机扰动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def do(self,img_list=[]):
    aug_list= copy.deepcopy(img_list)
    for i in range(len(img_list)):
        im = img_list[i]
        if self.noise and random.random()&amp;lt;0.5:
            im = self.add_noise(im)
        if self.dilate and random.random()&amp;lt;0.25:
            im = self.add_dilate(im)
        if self.erode and random.random()&amp;lt;0.25:
            im = self.add_erode(im)    
        aug_list.append(im)
    return aug_list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入指令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python gen_printed_char.py --out_dir ./dataset2 --font_dir ./chinese_fonts --width 100 --height 100 --margin 10 --rotate 30 --rotate_step 1 --need_aug&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种生成的图像如下图所示，第一数据集扩大了两倍，第二图像的丰富性进一步提高，效果还是明显的。当然，如果要获得最好的效果，还需要调一下里面的参数，这里就不再详细说明了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210644091-99882600.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们所需的印刷体汉字数据集已经成功生成完毕，下一步要做的就是利用这些数据集设计一个卷积神经网络做文字识别了！完整的代码可以在&lt;a href=&quot;https://github.com/AstarLight/CPS-OCR-Engine/blob/master/ocr/gen_printed_char.py&quot;&gt;我的github&lt;/a&gt;获取。&lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 13:07:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8436820.html</dc:identifier>
</item>
<item>
<title>浅入浅出数据结构（24）——最短路径问题 - NSpt</title>
<link>http://www.cnblogs.com/mm93/p/8434056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mm93/p/8434056.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　上一篇博文我们提到了图的最短路径问题：两个顶点间的最短路径该如何寻找？其实这个问题不应该叫“最短”路径问题，而应该叫“最便宜”路径问题，因为有时候我们会为图中的边赋权（weight），也叫权重，相当于经过一条边的“代价”，一般为正数。比如下图（边旁的数字即该边的权重）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208160653498-811264307.png&quot; alt=&quot;&quot; width=&quot;419&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如果单纯考虑一条路径上边的条数，那么从v0到v6的最短路径应该是：v0-v3-v6。但是如果考虑边的权重，从v0到v6的“最便宜”路径应该是：v0-v1-v4-v6，其总权重为3（路径中所有边的权重之和），而如果走v0-v3-v6的路径，总权重将是11。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　边有权重的图我们称之为赋权图，反之称为无权图，赋权图显然可以比无权图应用于更多场合，比如用赋权图来表示城市间公路，权重越大路况越差，或者权重越大，过路费用越高等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实不考虑权重的最短路径问题就是所有边的权重都是1的“最便宜”路径问题，比如将上图的所有边去掉权重后的无权图也可以这样表示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208160940591-978365534.png&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　方便起见，我们就将“最便宜”路径称为最短路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来让我们先从简单的无权情况开始，看看如何找两个顶点间的最短路径。不过到了这一步，一件有意思的事情需要说明一下，那就是：&lt;span&gt;找X到Y的最短路径，比找X到所有顶点的最短路径更慢&lt;/span&gt;（有权无权都是如此）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　出现这个情况的原因我们可以简单的分析一波：找X到Y的最短路径，最直接的做法就是令程序从X出发沿着可行的边不断的走，直到走到Y处为止，但是当走到Y处时，没人能保证刚刚走的那条路就是最短的，除非你走遍了整个图的顶点，换句话说，你要确定走到Y处且走的路径是最短的，你就得走遍所有顶点，而且在这个过程中你必须不断记录各个路径的长度，不然当你发现到一个顶点有多条路径时怎么比较它们呢？所以，你要找X到Y的最短路径，你就得找出X到所有顶点的最短路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然，也存在专门寻找点对点最短路径的思路，但是目前来说，单独找X到Y的最短路径不会比找X到所有顶点的最短路径更快，所以我们接下来探讨的问题其实都是：单源最短路径问题。即给定一个起点（源），求出其与所有顶点的最短路径。有了到所有顶点的最短路径，我们自然也就有了到给定顶点Y的最短路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对无权图进行单源最短路径寻找的思路，就是我们上面所说的“最直接的做法”。为了更方便讲解，我们假定若存在边（A，B），则B是被A“指向”的顶点。那么&lt;span&gt;对无权图进行单源最短路径寻找就是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们将起点的路径长设为0，其他顶点路径长设为负数（也可以是其他不可能的值，图例中用？表示），下例以v1作为起点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208220616045-605300545.png&quot; alt=&quot;&quot; width=&quot;462&quot; height=&quot;281&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着我们将起点所指向的顶点的路径长设为1，可以肯定的是，只有被路径长为0的起点所指向的顶点的路径长为1，本例中即v3和v4：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208220657888-1622004471.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来，我们将路径长为1的顶点（v3和v4）所指向的顶点的路径长设为2，同样可以肯定，只有被路径长为1的顶点所指向的顶点的路径长为2。不过此时会遇到一个问题：v3是v4所指向的顶点，但v3的路径长显然不应该被设为2。所以我们&lt;strong&gt;需要对已知路径长的顶点设一个“已知”标记&lt;/strong&gt;，已知的顶点不再更改其路径长，具体做法在给出代码时将写明。本例中，路径长要被设为2的顶点是v2、v5、v6：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209011001263-772371778.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后我们继续这样的步骤，将路径长为2的顶点所指向的顶点的路径长设为3。不过本例中路径长为2的顶点所指向的顶点中已经没有未知顶点了，所以算法结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上述步骤随着图的规模变大而变多，但不难发现其规律就是：&lt;span&gt;将路径长为i的顶点所指向的未知顶点的路径长设为i+1，i从0开始，结束条件即：当前路径长为i的顶点没有指向其它顶点，或所指向的顶点均为已知。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要注意的是结束条件的说法，我们并没有要求所有顶点都变为已知，因为确定某顶点为起点后，是有可能存在某个顶点无法由起点出发然后到达的，比如我们的例子中的v0，不存在从v1到v0的路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来要做的事情就是用代码实现我们所说的思路，此时我们需要注意是我们并不想在图上直接动手脚，因为图可能还有他用，并且直接在图上动手脚也不方便，因为图中顶点可能并没有用于表示是否已知的域和用于表示从起点到自身的最短路径长的域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以我们的做法是将最短路径的计算结果存于一个线性表中，其结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208223153138-69311074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中“一行”为线性表中的一个元素，每一行的四个单元格就是一个元素中的四个域：顶点、是否已知、与起点最短路径长、最短路径中自身的前一个顶点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么之前计算最短路径的过程用这个表来表示的话，就是下面这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208224018170-1589269912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208224106732-306823562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208224155810-2073817000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当我们想知道从起点到顶点Y的最短路径时，我们只需要找到Y顶点，查看其distance域即可知道，而想知道整条路径是怎么走的，我们也只要追溯Y的preV直到起点即可知道。下面是输出起点到给定终点的最短路径的一个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//路径表中的元素定义，我们假设顶点vx即数字x，所以元素没有vertex域&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; pathNode
{
    &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; known;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; distance;
    &lt;span&gt;size_t&lt;/span&gt; preV;
}

&lt;span&gt;//路径表&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; pathNode pathTable[numVertex];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; printPath(size_t end,&lt;span&gt;struct&lt;/span&gt; node*&lt;span&gt; pathTable)
{
    size_t preV&lt;/span&gt;=&lt;span&gt;pathTable[end].preV;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pathTable[preV].distance!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        printPath(preV,pathTable);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,preV);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,end);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　下面是上述无权最短路径思路的一个简单伪代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无权最短路径计算，图存于邻接表graph，结果存入pathTable，起点即start&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; unweightedPath(Node* graph,&lt;span&gt;struct&lt;/span&gt; pathNode*&lt;span&gt; pathTable,size_t  start)
{
    pathTable[start].known&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    pathTable[start].distance&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若pathTable[x].distance为0，则其preV是无用的，我们不予理睬

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化pathTable中的其他元素

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;curDis即当前距离，我们要做的是令distance==curDis的顶点所指的未知顶点的distance=curDis+1&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; curDis=&lt;span&gt;0&lt;/span&gt;;curDis&amp;lt;numVertex;++&lt;span&gt;curDis)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;numVertex;++&lt;span&gt;i)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!pathTable[i].known&amp;amp;&amp;amp;pathTable[i].distance==&lt;span&gt;curDis)
            {
                pathTable[i].known&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历pathTable[i]所指向的顶点X&lt;/span&gt;
&lt;span&gt;                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;pathTable[X].known)
                    {
                        pathTable[X].preV&lt;/span&gt;=&lt;span&gt;i;
                        pathTable[X].distance&lt;/span&gt;=curDis+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                    }
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　与上一篇博文的拓扑排序一样，上面的最短路径算法还有改进空间。当我们寻找符合distance==curDis条件的顶点时，我们用的是直接遍历数组的方法，这使得我们的算法时间复杂度达到了O(n&lt;sub&gt;v&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;)（n&lt;sub&gt;v&lt;/sub&gt;为顶点个数），所以&lt;span&gt;我们要改进的就是“寻找符合条件的顶点”的过程&lt;/span&gt;。我们可以创建一个队列来存储“需要处理的顶点”，该队列初始时只有起点，当我们修改了某个未知顶点的distance后，我们就将该顶点入队，而当我们令curDis递增后再次寻找distance==curDis的顶点时，我们只需要令队列元素出队即可获取到想要的顶点。这个过程口述难以表达清楚，下面是应该足够清晰了的伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无权最短路径计算，图存于邻接表graph，结果存入pathTable，起点即start&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; unweightedPath(Node* graph,&lt;span&gt;struct&lt;/span&gt; pathNode*&lt;span&gt; pathTable,size_t  start)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化pathTable

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建队列pendingQueue
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将起点start入队&lt;/span&gt;
&lt;span&gt;
    size_t curVertex;&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;empty(pendingQueue))
    {
        curVertex&lt;/span&gt;=&lt;span&gt;Dequeue(pendingQueue);
        pathTable[curVertex].known&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历curVertex指向的顶点X&lt;/span&gt;
&lt;span&gt;        {
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;pathTable[X].known)
           {
               pathTable[X].distance&lt;/span&gt;=pathTable[curVertex].distance+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
               pathTable[X].preV&lt;/span&gt;=&lt;span&gt;curVertex;
               Enqueue(X,pendingQueue);
           }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这样一来，我们就将无权最短路径算法的时间复杂度由O(n&lt;sub&gt;v&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;)降低到了O(n&lt;sub&gt;v&lt;/sub&gt;+n&lt;sub&gt;e&lt;/sub&gt;)（n&lt;sub&gt;e&lt;/sub&gt;即边的条数）。此外，上述算法对于无向有圈图也是一样生效的，原因就不赘述了，道理是简单的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来的问题是如何对有权图进行单源最短路径的寻找。有权图的最短路径显然比无权图要难找，原因在于我们不能套用无权算法的思路，直接令已知顶点所指未知顶点的distance=curDis+weight（weight即两顶点间路径的权重，此处简写），以下图为例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208160653498-811264307.png&quot; alt=&quot;&quot; width=&quot;419&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　若我们令v0作为起点，然后令v0所指的未知顶点的distance=v0.distance+weight，那么v3的distance就会变成5，可是实际上v3的distance应改为2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　解决的思路是：&lt;span&gt;我们罗列出所有已知顶点指向的所有未知顶点，看这些未知顶点中谁的distance被修改后会是最小的，最小的那个我们就修改其distance，并认为它已知。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以上图为例，我们一步步走一遍来加深一下理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先是正常的初始化（我们将边的权重也标识出来），假设起点为v0：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004313451-758816477.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着我们罗列出所有已知顶点（只有v0）指向的所有未知顶点：v1、v2、v3。然后发现若修改它们的distance，则v1.distance=v0.distance+1=1，v2.distance=v0.distance+3=3，v3.distance=v0.distance+5=5。显然v1被修改后的distance是未知顶点中最小的，所以我们只修改v1的distance，并将v1设为已知，v2、v3不动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004335545-896153487.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;323&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着我们继续罗列出所有已知顶点（v0、v1）指向的所有未知顶点：v2、v3、v4。然后发现若修改它们的distance，则v2.distance=v0.distance+3=3，v4.distance=v1.distance+1=2，v3.distance=v1.distance+1=2（虽然v0也指向v3，但是通过v0到v3的路径长大于从v1到v3，所以v3的distance取其小者），其中v3和v4的新distance并列最小，我们任选其一比如v4，然后只修改v4的distance，并将v4设为已知，其它不动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004354029-860824386.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，我们罗列出所有已知顶点（v0、v1、v4）指向的所有未知顶点：v2、v3、v6，发现若修改，则v2.distance=3，v3.distance=2，v6.distance=3，所以我们只修改v3的distance，并将v3设为已知：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004419170-1563798837.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，我们罗列出所有已知顶点（v0、v1、v3、v4）指向的所有未知顶点：v2、v5、v6，发现若修改，则v2.distance=3，v5.distance=10，v6.distance=3，我们在v2和v6中任选一个如v2，只修改v2.distance，并将v2设为已知：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004637623-1867903903.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，我们罗列出所有已知顶点指向的所有未知顶点：v5、v6，发现若修改，则v5.distance=5，v6.distance=3，所以我们只修改v6：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004812420-376295739.png&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，罗列出的未知顶点只有v5，若修改，其distance=5，我们将其修改并设为已知，算法结束：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004938295-1066667231.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　其实&lt;span&gt;上述算法的核心部分就是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.找到所有已知顶点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.将所有已知顶点指向的所有未知顶点罗列出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.计算这些未知顶点的最小distance，然后再确定其中新distance最小的顶点X&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.只修改X的distance，并将X设为已知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.回到第二步，若所有已知顶点都没有指向未知顶点，则结束&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而这个算法就是Dijkstra算法的雏形。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Dijkstra算法核心部分简化的说法就是：找到所有可确定distance的未知顶点中新distance最小的那个，修改它并将它设为已知。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　用伪代码描述就是这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有权最短路径计算，图存于邻接表graph，结果存入pathTable，起点即start&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; weightedPath(Node* graph,&lt;span&gt;struct&lt;/span&gt; pathNode*&lt;span&gt; pathTable,size_t  start)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化pathNode数组&lt;/span&gt;
&lt;span&gt;    
    size_t curV;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到可确定distance的未知顶点中新distance最小的那个，存入curV，若没有则跳出循环
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;令pathNode[curV].distance和pathNode[curV].prev修改为正确的值&lt;/span&gt;
        pathNode[curV].known=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　可以确定的是，Dijkstra算法也可以应用于无权图，只要给无权图中的每条边加个值为1的权重即可。并且如果你将无权算法与Dijkstra算法进行对比，就会发现那个无权算法其实就是Dijkstra算法的“特例”，在无权算法中，我们之所以不需要去找“distance最小的未知顶点”，是因为我们可以肯定已知顶点所指向的未知顶点就是“distance最小的未知顶点”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不用想都知道，Dijkstra算法中的循环中的两行伪代码其实意味着大量的操作：找到可以确定distance的未知顶点，计算它们的distance，比较出最小的那个，修改……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　显然，Dijkstra算法的核心部分是可以改进的，改进的思路与无权算法也很相像，即“&lt;span&gt;加快寻找符合条件的顶点的过程&lt;/span&gt;”。其中一种改进方式是计算出未知顶点的新distance后，将{未知顶点，新distance}对插入到以distance为关键字的优先队列中，而不是直接抛弃非最小distance的那些未知顶点（这是一个很大的浪费）。这样在下一次寻找“distance最小的未知顶点”时，我们可以通过优先队列的出队来获得，从而避免了遍历整个数组来寻找目标的情况。这个想法要细化实现的话，还有不少坑要避开，不过我写到这儿时深感表达之困难与疲惫，所以这篇博文就此打住，如果博文中有什么不对之处，可以在评论区指出，谢谢~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　附：如果有权图中存在权重为负值的情况，则计算单源最短路径将会更加困难，不过可以确定的是，如果有权图中存在圈与负权边，且负权边在圈中，使得圈的路径长为负，那么单源最短路径的计算是无法进行的，因为你可以在这个圈中永远走下去来使路径长不断“减小”。解决有负值权重边的图的最短路径算法是在Dijkstra的算法上进行改进得来的，本文不予讲解（或许以后会有一篇文章介绍），有兴趣的可以自行搜索。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 12:50:00 +0000</pubDate>
<dc:creator>NSpt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mm93/p/8434056.html</dc:identifier>
</item>
<item>
<title>1.C和C++区别,以及const分析 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8436731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8436731.html</guid>
<description>&lt;p&gt;&lt;span&gt;从本章起开始从0学习C++,本章主要内容:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;/span&gt;C和C++的基本区别&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2)&lt;/strong&gt;&lt;/span&gt;C和C++的const区别&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.C++&lt;span&gt;和&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; C++更强调语言的实用性,所有变量都可以在需要时再定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;100&lt;/span&gt;;i++);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1.2&lt;/strong&gt;&lt;/span&gt; C++不允许定义多个同名全局变量,而C却可以重复定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.3&lt;/span&gt;&lt;/strong&gt; C++的register只是个兼容作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.4&lt;/span&gt;&lt;/strong&gt; C++的所有标识符都必须有声明类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;比如&lt;/span&gt;,&lt;span&gt;在&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;f():  &lt;span&gt;表示&lt;/span&gt;默认&lt;span&gt;返回值是&lt;/span&gt;int,&lt;span&gt;可以接受任意个&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;型参数的函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;C++&lt;span&gt;中&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int f() int f(void)表示&lt;span&gt;都一样&lt;/span&gt;&lt;span&gt;,没有&lt;/span&gt;&lt;span&gt;参数&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;返回值为&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;型的函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int f(i): &lt;span&gt;由于&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;没声明类型&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会报错&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1.5 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;结构体&lt;/span&gt;升级&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如,&lt;span&gt;在&lt;/span&gt;C&lt;span&gt;中&lt;/span&gt;定义一个结构体:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
typedef student_type student;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; student_type{
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
};

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; student student_info={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Li&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
student  student2&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;而在&lt;/span&gt;C++&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;只需要这么写&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; student_type{
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
};

student_type student2&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;};   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不需要strcut再次声明&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;C&lt;span&gt;和&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. C&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 &lt;span&gt;介绍&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C&lt;span&gt;语言中的&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;只是让变量变为&lt;span&gt;只读属性&lt;/span&gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;其本质还是变量&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;不是真正意义上的常量&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;span&gt;只有&lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt;枚举定义的才是常量&lt;/span&gt;&lt;span&gt;).&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;:&lt;/strong&gt;&lt;/span&gt;const&lt;span&gt;变量不能被直接赋值&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;但是可以通过&lt;span&gt;指针&lt;/span&gt;来修改&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;变量&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于&lt;/span&gt;const&lt;span&gt;&lt;span&gt;局部变量&lt;/span&gt;会存在&lt;span&gt;栈&lt;/span&gt;里&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;而&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;&lt;span&gt;全局变量&lt;/span&gt;会存在&lt;span&gt;只读存储区&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以我们可以通过指针来修改&lt;/span&gt;const&lt;span&gt;局部变量&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;但是修改&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;全局变量&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会使程序崩溃&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1)&lt;span&gt;实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;-&lt;/span&gt;&lt;span&gt;通过指针来修改&lt;/span&gt;&lt;span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;局部变量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;代码如下&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;const局部变量&lt;/span&gt;

    &lt;span&gt;int&lt;/span&gt;* p = (&lt;span&gt;int&lt;/span&gt;*)&amp;amp;&lt;span&gt;c;
    &lt;/span&gt;*p = &lt;span&gt;5&lt;/span&gt;;          &lt;span&gt;//通过指针&lt;/span&gt;&lt;span&gt;修改const变量&lt;/span&gt;
&lt;span&gt;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, c);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180209194256373-615092994.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2)&lt;span&gt;实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;-&lt;/span&gt;&lt;span&gt;通过指针来修改&lt;/span&gt;&lt;span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;全局变量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;代码如下&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;const全局变量&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;* p = (&lt;span&gt;int&lt;/span&gt;*)&amp;amp;&lt;span&gt;c;
    &lt;/span&gt;*p = &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改const变量&lt;/span&gt;&lt;span&gt;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, c);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180209194309482-3268690.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于指针修改只读存储区的数据&lt;/span&gt;,&lt;span&gt;所以导致程序崩溃&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. C++&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;C++&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,const&lt;/span&gt;&lt;span&gt;变量则是真正的&lt;span&gt;常量&lt;/span&gt;了&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;定义时会将其放入&lt;span&gt;符号表&lt;/span&gt;中&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以编译途中遇到使用&lt;/span&gt;const&lt;span&gt;变量时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;则直接从符号表中取出常量&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;只要当该&lt;/span&gt;const&lt;span&gt;变量为全局&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;extern&lt;/span&gt;&lt;span&gt;声明过&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;,&lt;/span&gt;&lt;span&gt;或者被使用&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&lt;span&gt;操作符&lt;/span&gt;时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;才会被分配存储空间&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来&lt;/span&gt;,&lt;span&gt;我们以一个例子来分析存储空间&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;代码如下&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;const局部变量&lt;/span&gt;

    &lt;span&gt;int&lt;/span&gt;* p = (&lt;span&gt;int&lt;/span&gt;*)&amp;amp;c; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用&amp;amp;操作符,会分配空间&lt;/span&gt;

    *p = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;  

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c = %d,*p=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c,*&lt;span&gt;p);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180209194331295-2107653097.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;79&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;为什么输出结果会有两个不同的值?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这是因为使用&lt;/span&gt;&amp;amp;c&lt;span&gt;时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会从符号表中取出&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;的值&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;并将&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;存在一个新的分配空间地址里&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;所以&lt;/span&gt;*p&lt;span&gt;修改的只是&lt;span&gt;分配出来的空间&lt;/span&gt;地址内容&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;而&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;还是常量&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 const&lt;span&gt;和&lt;/span&gt;&lt;span&gt;define&lt;/span&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;是不是感觉&lt;/span&gt;C++&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;和&lt;/span&gt; &lt;span&gt;define&lt;/span&gt;&lt;span&gt;宏定义一样？其实不一样&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;const&lt;span&gt;常量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/span&gt;     &lt;/span&gt;&lt;span&gt;由编译器处理&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;它会对&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;常量进行类型检查和作用域检查&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;define&lt;span&gt;宏定义&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;由预处理器处理&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;直接进行文本替换&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;不会进行各种检查&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;(&lt;span&gt;预处理器是执行编译器之前运行的程序&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;用来删除注释&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;宏变量转换等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来&lt;/span&gt;,&lt;span&gt;我们以一个例子来分析&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;define&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;代码如下&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; f()
{
    &lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; a 3        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义宏&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;4&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义局部变量&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{  
    f();   
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a=%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;b=%d&quot;,b);&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180209194339591-239308695.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这是因为执行预处理器时&lt;/span&gt;,&lt;span&gt;会将遇见到的所有&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;变为&lt;/span&gt;&lt;span&gt;3,&lt;/span&gt;&lt;span&gt;所以&lt;span&gt;编译器&lt;/span&gt;看到的是&lt;/span&gt;&lt;span&gt;printf(&quot;a=%d&quot;,3);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而取消&lt;span&gt;//printf(&quot;b=%d&quot;,b);&lt;/span&gt; &lt;span&gt;屏蔽后&lt;/span&gt;,&lt;span&gt;程序则会报错&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;是因为&lt;/span&gt;b&lt;span&gt;的作用域只在&lt;/span&gt;f()&lt;span&gt;函数里有效&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 &lt;span&gt;指针&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;指针&lt;/span&gt;const&lt;span&gt;分为两种&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;底层&lt;/span&gt;&lt;span&gt;const,&lt;/span&gt; &lt;span&gt;顶层&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(&lt;span&gt;&lt;span&gt;普通变量的&lt;/span&gt;&lt;span&gt;const(&lt;/span&gt;&lt;span&gt;或引用&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;永远是顶层&lt;/span&gt;&lt;span&gt;const,&lt;/span&gt;&lt;span&gt;也就是说&lt;/span&gt;&lt;span&gt;,const int&lt;/span&gt; &lt;span&gt;和&lt;/span&gt;&lt;span&gt;int const&lt;/span&gt;&lt;span&gt;本质都一样&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;底层&lt;/span&gt;&lt;span&gt;const&lt;strong&gt;&lt;span&gt;(&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;位于&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;左侧&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;常量指针&lt;/span&gt;,&lt;span&gt;表示指向的对象是个常量&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;不能修改其内容&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;只能更改指针指向的地址&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但是可以通过其它方式修改内容&lt;/span&gt;,&lt;span&gt;例如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; a=&lt;span&gt;1&lt;/span&gt;,b=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *p=&amp;amp;a;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;底层const

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;*p=2;              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误,无法修改*p指向的a里面内容&lt;/span&gt;
&lt;span&gt;
a&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确,通过其它方法来修改*p的内容&lt;/span&gt;&lt;span&gt;
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*&lt;span&gt;p);

p&lt;/span&gt;=&amp;amp;b;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确,可以更改指针指向的地址&lt;/span&gt;&lt;span&gt;
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*p);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;顶层&lt;/span&gt;&lt;span&gt;const&lt;span&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;位于&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;右侧&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;指针常量&lt;/span&gt;,&lt;span&gt;表示不能更改指针指向的地址&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;只能修改其内容&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;定义时必须被初始化&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;和引用非常相似&lt;/span&gt;,&lt;span&gt;例如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; a=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int *const p;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误,没有被初始化&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;const&lt;/span&gt; p=&amp;amp;a;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶层const

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p=&amp;amp;b;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误,不能更改指针指向的地址&lt;/span&gt;

*p=&lt;span&gt;2&lt;/span&gt;;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确,修改a的值等于2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 本章结束,下章来学习:  &lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/8436764.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;C++中的bool类型,三目运算符,引用&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 12:12:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8436731.html</dc:identifier>
</item>
</channel>
</rss>