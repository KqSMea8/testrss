<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java并发（8）- 读写锁中的性能之王：StampedLock - knock_小新</title>
<link>http://www.cnblogs.com/konck/p/9691538.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/konck/p/9691538.html</guid>
<description>&lt;p&gt;在上一篇《你真的懂ReentrantReadWriteLock吗？》中我给大家留了一个引子，一个更高效同时可以避免写饥饿的读写锁---StampedLock。StampedLock实现了不仅多个读不互相阻塞，同时在读操作时不会阻塞写操作。&lt;/p&gt;
&lt;p&gt;为什么StampedLock这么神奇？能够达到这种效果，它的核心思想在于，在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样。这种操作方式决定了StampedLock在读线程非常多而写线程非常少的场景下非常适用，同时还避免了写饥饿情况的发生。这篇文章将通过以下几点来分析StampedLock。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;StampedLock的官方使用示例分析&lt;/li&gt;
&lt;li&gt;源码分析：读写锁共享的状态量&lt;/li&gt;
&lt;li&gt;源码分析：写锁的释放和获取&lt;/li&gt;
&lt;li&gt;源码分析：悲观读锁的释放和获取&lt;/li&gt;
&lt;li&gt;性能测试&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;stampedlock的官方使用示例分析&quot;&gt;StampedLock的官方使用示例分析&lt;/h2&gt;
&lt;p&gt;先来看一个官方给出的StampedLock使用案例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Point {

    private double x, y;
    
    private final StampedLock stampedLock = new StampedLock();
    
    //写锁的使用
    void move(double deltaX, double deltaY){
        
        long stamp = stampedLock.writeLock(); //获取写锁
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            stampedLock.unlockWrite(stamp); //释放写锁
        }
    }
    
    //乐观读锁的使用
    double distanceFromOrigin() {
        
        long stamp = stampedLock.tryOptimisticRead(); //获得一个乐观读锁
        double currentX = x;
        double currentY = y;
        if (!stampedLock.validate(stamp)) { //检查乐观读锁后是否有其他写锁发生，有则返回false
            
            stamp = stampedLock.readLock(); //获取一个悲观读锁
            
            try {
                currentX = x;
            } finally {
                stampedLock.unlockRead(stamp); //释放悲观读锁
            }
        } 
        return Math.sqrt(currentX*currentX + currentY*currentY);
    }
    
    //悲观读锁以及读锁升级写锁的使用
    void moveIfAtOrigin(double newX,double newY) {
        
        long stamp = stampedLock.readLock(); //悲观读锁
        try {
            while (x == 0.0 &amp;amp;&amp;amp; y == 0.0) {
                long ws = stampedLock.tryConvertToWriteLock(stamp); //读锁转换为写锁
                if (ws != 0L) { //转换成功
                    
                    stamp = ws; //票据更新
                    x = newX;
                    y = newY;
                    break;
                } else {
                    stampedLock.unlockRead(stamp); //转换失败释放读锁
                    stamp = stampedLock.writeLock(); //强制获取写锁
                }
            }
        } finally {
            stampedLock.unlock(stamp); //释放所有锁
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先看看第一个方法move，可以看到它和ReentrantReadWriteLock写锁的使用基本一样，都是简单的获取释放，可以猜测这里也是一个独占锁的实现。需要注意的是 在获取写锁是会返回个只long类型的stamp，然后在释放写锁时会将stamp传入进去。这个stamp是做什么用的呢？如果我们在中间改变了这个值又会发生什么呢？这里先暂时不做解释，后面分析源码时会解答这个问题。&lt;/p&gt;
&lt;p&gt;第二个方法distanceFromOrigin就比较特别了，它调用了tryOptimisticRead，根据名字判断这是一个乐观读锁。首先什么是乐观锁？乐观锁的意思就是先假定在乐观锁获取期间，共享变量不会被改变，既然假定不会被改变，那就不需要上锁。在获取乐观读锁之后进行了一些操作，然后又调用了validate方法，这个方法就是用来验证tryOptimisticRead之后，是否有写操作执行过，如果有，则获取一个读锁，这里的读锁和ReentrantReadWriteLock中的读锁类似，猜测也是个共享锁。&lt;/p&gt;
&lt;p&gt;第三个方法moveIfAtOrigin，它做了一个锁升级的操作，通过调用tryConvertToWriteLock尝试将读锁转换为写锁，转换成功后相当于获取了写锁，转换失败相当于有写锁被占用，这时通过调用writeLock来获取写锁进行操作。&lt;/p&gt;
&lt;p&gt;看过了上面的三个方法，估计大家对怎么使用StampedLock有了一个初步的印象。下面就通过对StampedLock源码的分析来一步步了解它背后是怎么解决锁饥饿问题的。&lt;/p&gt;
&lt;h2 id=&quot;源码分析读写锁共享的状态量&quot;&gt;源码分析：读写锁共享的状态量&lt;/h2&gt;
&lt;p&gt;从上面的使用示例中我们看到，在StampedLock中，除了提供了类似ReentrantReadWriteLock读写锁的获取释放方法，还提供了一个乐观读锁的获取方式。那么这三种方式是如何交互的呢？根据AQS的经验，StampedLock中应该也是使用了一个状态量来标志锁的状态。通过下面的源码可以证明这点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 用于操作state后获取stamp的值
private static final int LG_READERS = 7;
private static final long RUNIT = 1L;               //0000 0000 0001
private static final long WBIT  = 1L &amp;lt;&amp;lt; LG_READERS; //0000 1000 0000
private static final long RBITS = WBIT - 1L;        //0000 0111 1111
private static final long RFULL = RBITS - 1L;       //0000 0111 1110
private static final long ABITS = RBITS | WBIT;     //0000 1111 1111
private static final long SBITS = ~RBITS;           //1111 1000 0000

//初始化时state的值
private static final long ORIGIN = WBIT &amp;lt;&amp;lt; 1;       //0001 0000 0000

//锁共享变量state
private transient volatile long state;
//读锁溢出时用来存储多出的毒素哦
private transient int readerOverflow;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的源码中除了定义state变量外，还提供了一系列变量用来操作state，用来表示读锁和写锁的各种状态。为了方便理解，我将他们都表示成二进制的值，长度有限，这里用低12位来表示64的long，高位自动用0补齐。要理解这些状态的作用，就需要具体分析三种锁操作方式是怎么通过state这一个变量来表示的，首先来看看获取写锁和释放写锁。&lt;/p&gt;
&lt;h2 id=&quot;源码分析写锁的释放和获取&quot;&gt;源码分析：写锁的释放和获取&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public StampedLock() {
    state = ORIGIN; //初始化state为 0001 0000 0000
}

public long writeLock() {
    long s, next; 
    return ((((s = state) &amp;amp; ABITS) == 0L &amp;amp;&amp;amp; //没有读写锁
                U.compareAndSwapLong(this, STATE, s, next = s + WBIT)) ? //cas操作尝试获取写锁
            next : acquireWrite(false, 0L));    //获取成功后返回next，失败则进行后续处理，排队也在后续处理中
}

public void unlockWrite(long stamp) {
    WNode h;
    if (state != stamp || (stamp &amp;amp; WBIT) == 0L) //stamp值被修改，或者写锁已经被释放，抛出错误
        throw new IllegalMonitorStateException();
    state = (stamp += WBIT) == 0L ? ORIGIN : stamp; //加0000 1000 0000来记录写锁的变化，同时改变写锁状态
    if ((h = whead) != null &amp;amp;&amp;amp; h.status != 0)
        release(h);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里先说明两点结论：读锁通过前7位来表示，每获取一个读锁，则加1。写锁通过除前7位后剩下的位来表示，每获取一次写锁，则加1000 0000，这两点在后面的源码中都可以得倒证明。&lt;br/&gt;初始化时将state变量设置为0001 0000 0000。写锁获取通过&lt;code&gt;((s = state) &amp;amp; ABITS)&lt;/code&gt;操作等于0时默认没有读锁和写锁。写锁获取分三种情况：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;没有读锁和写锁时，state为0001 0000 0000&lt;br/&gt;0001 0000 0000 &amp;amp; 0000 1111 1111 = 0000 0000 0000 // 等于0L，可以尝试获取写锁&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有一个读锁时，state为0001 0000 0001&lt;br/&gt;0001 0000 0001 &amp;amp; 0000 1111 1111 = 0000 0000 0001 // 不等于0L&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有一个写锁，state为0001 1000 0000&lt;br/&gt;0001 1000 0000 &amp;amp; 0000 1111 1111 = 0000 1000 0000 // 不等于0L&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;获取到写锁，需要将s + WBIT设置到state，也就是说每次获取写锁，都需要加0000 1000 0000。同时返回s + WBIT的值&lt;br/&gt;0001 0000 0000 + 0000 1000 0000 = 0001 1000 0000&lt;/p&gt;
&lt;p&gt;释放写锁首先判断stamp的值有没有被修改过或者多次释放，之后通过&lt;code&gt;state = (stamp += WBIT) == 0L ? ORIGIN : stamp&lt;/code&gt;来释放写锁，位操作表示如下：&lt;br/&gt;&lt;code&gt;stamp += WBIT&lt;/code&gt;&lt;br/&gt;0010 0000 0000 = 0001 1000 0000 + 0000 1000 0000&lt;br/&gt;这一步操作是重点！！！写锁的释放并不是像ReentrantReadWriteLock一样+1然后-1，而是通过再次加0000 1000 0000来使高位每次都产生变化，为什么要这样做？直接减掉0000 1000 0000不就可以了吗？这就是为了后面乐观锁做铺垫，让每次写锁都留下痕迹。&lt;/p&gt;
&lt;p&gt;大家可以想象这样一个场景，字母A变化为B能看到变化，如果在一段时间内从A变到B然后又变到A，在内存中自会显示A，而不能记录变化的过程，这也就是CAS中的ABA问题。在StampedLock中就是通过每次对高位加0000 1000 0000来达到记录写锁操作的过程，可以通过下面的步骤理解：&lt;br/&gt;第一次获取写锁：&lt;br/&gt;0001 0000 0000 + 0000 1000 0000 = 0001 1000 0000&lt;br/&gt;第一次释放写锁：&lt;br/&gt;0001 1000 0000 + 0000 1000 0000 = 0010 0000 0000&lt;br/&gt;第二次获取写锁：&lt;br/&gt;0010 0000 0000 + 0000 1000 0000 = 0010 1000 0000&lt;br/&gt;第二次释放写锁：&lt;br/&gt;0010 1000 0000 + 0000 1000 0000 = 0011 0000 0000&lt;br/&gt;第n次获取写锁：&lt;br/&gt;1110 0000 0000 + 0000 1000 0000 = 1110 1000 0000&lt;br/&gt;第n次释放写锁：&lt;br/&gt;1110 1000 0000 + 0000 1000 0000 = 1111 0000 0000&lt;br/&gt;可以看到第8位在获取和释放写锁时会产生变化，也就是说第8位是用来表示写锁状态的，前7位是用来表示读锁状态的，8位之后是用来表示写锁的获取次数的。这样就有效的解决了ABA问题，留下了每次写锁的记录，也为后面乐观锁检查变化提供了基础。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;acquireWrite&lt;/code&gt;方法这里不做具体分析，方法非常复杂，感兴趣的同学可以网上搜索相关资料。这里只对该方法做下简单总结，该方法分两步来进行线程排队，首先通过随机探测的方式多次自旋尝试获取锁，然后自旋一定次数失败后再初始化节点进行插入。&lt;/p&gt;
&lt;h2 id=&quot;源码分析悲观读锁的释放和获取&quot;&gt;源码分析：悲观读锁的释放和获取&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public long readLock() {
    long s = state, next;  
    return ((whead == wtail &amp;amp;&amp;amp; (s &amp;amp; ABITS) &amp;lt; RFULL &amp;amp;&amp;amp; //队列为空，无写锁，同时读锁未溢出，尝试获取读锁
                U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) ?   //cas尝试获取读锁+1
            next : acquireRead(false, 0L));     //获取读锁成功，返回s + RUNIT，失败进入后续处理，类似acquireWrite
}

public void unlockRead(long stamp) {
    long s, m; WNode h;
    for (;;) {
        if (((s = state) &amp;amp; SBITS) != (stamp &amp;amp; SBITS) ||
            (stamp &amp;amp; ABITS) == 0L || (m = s &amp;amp; ABITS) == 0L || m == WBIT)
            throw new IllegalMonitorStateException();
        if (m &amp;lt; RFULL) {    //小于最大记录值（最大记录值127超过后放在readerOverflow变量中）
            if (U.compareAndSwapLong(this, STATE, s, s - RUNIT)) {  //cas尝试释放读锁-1
                if (m == RUNIT &amp;amp;&amp;amp; (h = whead) != null &amp;amp;&amp;amp; h.status != 0)
                    release(h);
                break;
            }
        }
        else if (tryDecReaderOverflow(s) != 0L) //readerOverflow - 1
            break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;悲观读锁的获取和ReentrantReadWriteLock类似，不同在于StampedLock的读锁很容易溢出，最大只有127，超过后通过一个额外的变量readerOverflow来存储，这是为了给写锁留下更大的空间，因为写锁是在不停增加的。悲观读锁获取分下面四种情况：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;没有读锁和写锁时，state为0001 0000 0000&lt;br/&gt;// 小于 0000 0111 1110，可以尝试获取读锁&lt;br/&gt;0001 0000 0000 &amp;amp; 0000 1111 1111 = 0000 0000 0000&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有一个读锁时，state为0001 0000 0001&lt;br/&gt;// 小于 0000 0111 1110，可以尝试获取读锁&lt;br/&gt;0001 0000 0001 &amp;amp; 0000 1111 1111 = 0000 0000 0001&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有一个写锁，state为0001 1000 0000&lt;br/&gt;// 大于 0000 0111 1110，不可以获取读锁&lt;br/&gt;0001 1000 0000 &amp;amp; 0000 1111 1111 = 0000 1000 0000&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;读锁溢出，state为0001 0111 1110&lt;br/&gt;// 等于 0000 0111 1110，不可以获取读锁&lt;br/&gt;0001 0111 1110 &amp;amp; 0000 1111 1111 = 0000 0111 1110&lt;br/&gt;读锁的释放过程在没有溢出的情况下是通过&lt;code&gt;s - RUNIT&lt;/code&gt;操作也就是-1来释放的，当溢出后则将readerOverflow变量-1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;乐观读锁的获取和验证&quot;&gt;乐观读锁的获取和验证&lt;/h2&gt;
&lt;p&gt;乐观读锁因为实际上没有获取过锁，所以也就没有释放锁的过程，只是在操作后通过验证检查和获取前的变化。源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//尝试获取乐观锁
public long tryOptimisticRead() {
    long s;
    return (((s = state) &amp;amp; WBIT) == 0L) ? (s &amp;amp; SBITS) : 0L;
}

//验证乐观锁获取之后是否有过写操作
public boolean validate(long stamp) {
    //该方法之前的所有load操作在内存屏障之前完成，对应的还有storeFence()及fullFence()
    U.loadFence();  
    return (stamp &amp;amp; SBITS) == (state &amp;amp; SBITS);  //比较是否有过写操作
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;乐观锁基本原理就时获取锁时记录state的写状态，然后在操作完成之后检查写状态是否有变化，因为写状态每次都会在高位留下记录，这样就避免了写锁获取又释放后得不到准确数据。获取写锁记录有三种情况：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;没有读锁和写锁时，state为0001 0000 0000&lt;br/&gt;//((s = state) &amp;amp; WBIT) == 0L) true&lt;br/&gt;0001 0000 0000 &amp;amp; 0000 1000 0000 = 0000 0000 0000&lt;br/&gt;//(s &amp;amp; SBITS)&lt;br/&gt;0001 0000 0000 &amp;amp; 1111 1000 0000 = 0001 0000 0000&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有一个读锁时，state为0001 0000 0001&lt;br/&gt;//((s = state) &amp;amp; WBIT) == 0L) true&lt;br/&gt;0001 0000 0001 &amp;amp; 0000 1000 0000 = 0000 0000 0000&lt;br/&gt;//(s &amp;amp; SBITS)&lt;br/&gt;0001 0000 0001 &amp;amp; 1111 1000 0000 = 0001 0000 0000&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有一个写锁，state为0001 1000 0000&lt;br/&gt;//((s = state) &amp;amp; WBIT) == 0L) false&lt;br/&gt;0001 1000 0000 &amp;amp; 0000 1000 0000 = 0000 1000 0000&lt;br/&gt;//0L&lt;br/&gt;0000 0000 0000&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;验证过程中是否有过写操作，分四种情况&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;写过一次&lt;br/&gt;0001 0000 0000 &amp;amp; 1111 1000 0000 = 0001 0000 0000&lt;br/&gt;0010 0000 0000 &amp;amp; 1111 1000 0000 = 0010 0000 0000 //false&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;未写过，但读过&lt;br/&gt;0001 0000 0000 &amp;amp; 1111 1000 0000 = 0001 0000 0000&lt;br/&gt;0001 0000 1111 &amp;amp; 1111 1000 0000 = 0001 0000 0000 //true&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;正在写&lt;br/&gt;0001 0000 0000 &amp;amp; 1111 1000 0000 = 0001 0000 0000&lt;br/&gt;0001 1000 0000 &amp;amp; 1111 1000 0000 = 0001 1000 0000 //false&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;之前正在写，无论是否写完都不会为0L&lt;br/&gt;0000 0000 0000 &amp;amp; 1111 1000 0000 = 0000 0000 0000 //false&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;性能测试&quot;&gt;性能测试&lt;/h2&gt;
&lt;p&gt;分析完了StampedLock的实现原理，这里对StampedLock、ReentrantReadWriteLock以及Synchronized分别在各种场景下进行性能测试，测试的基准代码采用https://blog.takipi.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/ 文章中的代码，首先贴出上述博客中的测试结果,文章中的OPTIMISTIC模式由于采用了“脏读”模式，这里不采用OPTIMISTIC的测试结果，只比较StampedLock、ReentrantReadWriteLock以及Synchronized。&lt;/p&gt;
&lt;p&gt;5个读线程和5个写线程场景：表现最好的是StampedLock的正常模式以及ReentrantReadWriteLock。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/368583/201809/368583-20180922224407901-774890344.png&quot;/&gt;&lt;br/&gt;10个读线程和10个写线程场景：表现最好的是StampedLock的正常模式以及Synchronized。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/368583/201809/368583-20180922224420110-1383860423.png&quot;/&gt;&lt;br/&gt;16个读线程和4个写线程场景：表现最好的是StampedLock的正常模式以及Synchronized。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/368583/201809/368583-20180922224430794-272740897.png&quot;/&gt;&lt;br/&gt;19个读线程和1个写线程场景：表现最好的是Synchronized。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/368583/201809/368583-20180922224442185-1225829405.png&quot;/&gt;&lt;br/&gt;博客评论中还有一种测试场景2000读线程和1个写线程，测试结果如下：&lt;br/&gt;StampedLock ... 12814.2 ReentrantReadWriteLock ... 18882.8 Synchronized ... 22696.4&lt;br/&gt;表现最好的是StampedLock。&lt;/p&gt;
&lt;p&gt;看完了上面的测试，前面3种场景表现最好的都为StampedLock，但第4种情况下StampedLock表现很差，于是我自己对代码又进行了一遍测试，同时鉴于读写锁的大量应用在缓存场景下，读写差距极大，我增加了100个读和1个写的场景。&lt;/p&gt;
&lt;p&gt;测试机器：MAC OS(10.12.6),CPU : 2.4 GHz Intel Core i5,内存：8G 软件版本：JDK1.8&lt;br/&gt;测试结果如下：&lt;br/&gt;19个读线程和1个写线程场景：表现最好的是StampedLock以及Synchronized。&lt;br/&gt;读线程: 19. 写线程: 1. 循环次数: 5. 计算总和: 1000000&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/368583/201809/368583-20180922224449783-418659655.jpg&quot;/&gt;&lt;br/&gt;100个读线程和1个写线程场景：表现最好的是StampedLock以及Synchronized。&lt;br/&gt;读线程: 100. 写线程: 1. 循环次数: 5. 计算总和: 100000&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/368583/201809/368583-20180922224456977-650093318.jpg&quot;/&gt;&lt;br/&gt;通过上述测试，可以发现整体性能平均而言StampedLock和Synchronized相差不大，StampedLock在读写差距加大时稍微有点优势。而ReentrantReadWriteLock性能之差有点出乎意料，基本可以达到抛弃使用的地步了，不知道大家对ReentrantReadWriteLock的使用场景有什么建议？&lt;/p&gt;
&lt;p&gt;同时鉴于原生的Synchronized后期可优化空间比较大，而且在代码复杂性以及安全性上面都具有一定优势，因此在绝大多数场景可以使用Synchronized来进行同步，对性能有一定要求的在某些特定场景下可以使用StampedLock。测试所用代码在我所引用的博客中都可以找到，大家可以自行尝试测试，如果对结果有什么疑问，欢迎在评论中提出。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;br/&gt;&lt;a href=&quot;https://blog.takipi.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/&quot; class=&quot;uri&quot;&gt;https://blog.takipi.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 23:29:00 +0000</pubDate>
<dc:creator>knock_小新</dc:creator>
<og:description>在上一篇《你真的懂ReentrantReadWriteLock吗？》中我给大家留了一个引子，一个更高效同时可以避免写饥饿的读写锁 StampedLock。StampedLock实现了不仅多个读不互相阻</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/konck/p/9691538.html</dc:identifier>
</item>
<item>
<title>内网很安全？错错错！附攻击演示 - 百宝门-SSO顾问</title>
<link>http://www.cnblogs.com/baibaomen/p/intranet-attack.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baibaomen/p/intranet-attack.html</guid>
<description>&lt;p&gt;给企业做单点登录咨询和实施的时候，讲到通信环节的安全性，常听到这种声音：这些系统只在内网使用，不用https没关系！&lt;/p&gt;
&lt;p&gt;包括在我前一篇&lt;a href=&quot;https://www.cnblogs.com/baibaomen/p/http-session-hijack.html&quot; target=&quot;_blank&quot;&gt;《&lt;/a&gt;&lt;a id=&quot;post_title_link_6863822&quot; href=&quot;https://www.cnblogs.com/baibaomen/p/http-session-hijack.html&quot;&gt;看完48秒动画，让你不敢再登录HTTP网站&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/baibaomen/p/http-session-hijack.html&quot; target=&quot;_blank&quot;&gt;》&lt;/a&gt;的评论里，也有不少程序猿觉得我演示的案例，在现实网络中难以实现。&lt;/p&gt;
&lt;p&gt;这个观点非常错误和危险，并且还特别迎合直观：内网屏蔽了绝大部分外部的黑客攻击，应该会安全得多吧？&lt;/p&gt;
&lt;p&gt;为此，我把给企业做培训和顾问时，常会演示的程序，给大家做个分享。&lt;/p&gt;
&lt;p&gt;当内网中有人运行这个程序，你在自己电脑上网会被同事实时“直播”；手机明明连的是公司有“安全”标记的wifi，访问单位OA时竟也会被轻松嗅探走账号密码。大部分人都会目瞪口呆，彻底改变“内网很安全”、“标记了'安全'的公司wifi很安全”的认识。&lt;/p&gt;

&lt;p&gt;这个版本，是在我github开源的HttpHijacker基础上，增加了三个功能：&lt;/p&gt;
&lt;p&gt;1. 网络设备嗅探&lt;/p&gt;
&lt;p&gt;2. ARP欺骗&lt;/p&gt;
&lt;p&gt;3. 数据包转发&lt;/p&gt;
&lt;p&gt;涉及到的都是最基础的网络协议。&lt;/p&gt;

&lt;p&gt;大家在自己电脑运行本程序，可以看到同一局域网段或wifi的上网设备，并选择其中任一设备执行监听。&lt;/p&gt;
&lt;p&gt;被监听设备上的所有http访问，都会实时被该程序监听并记录。&lt;/p&gt;
&lt;p&gt;选择被监听到的任一条记录，点击“劫持选中http会话”，你的浏览器会自动打开该站点，并用被劫持者的账号身份登入，可随意查看和修改数据。&lt;/p&gt;
&lt;p&gt; ——咳咳，考虑到好奇心甚的程序猿们，拿该程序可能造成的影响或者背负的嫌疑，我把程序做了一点限制：代码不开源；监听记录URL做截断；将可劫持的域名限制为attack-demo.baibaomen.com。&lt;/p&gt;

&lt;p&gt;大家要验证和演示http会话劫持，请让其他同事用局域网的电脑或wifi手机，访问http://attack-demo.baibaomen.com，在其中输入任意账号或密码后进入个人设置界面。与此同时，你在电脑上启动监听程序，选择或手动输入同事电脑IP点击监听，将实时监听到该同事的站点浏览情况，选择劫持还将自动以其身份进入被劫持系统，随意查看和操作数据。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/292705/201809/292705-20180925022114456-1122779279.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;程序添加到了&lt;a href=&quot;https://github.com/baibaomen/Baibaomen.HttpHijacker&quot; target=&quot;_blank&quot;&gt;https://github.com/baibaomen/Baibaomen.HttpHijacker&lt;/a&gt;，下载“百宝门内网攻击演示程序.zip”，解压即可运行。程序在本人开源的HttpHijacker上，增加了一些网络攻击的演示功能。&lt;/p&gt;
&lt;p&gt; 程序执行时会在网络上启动ARP攻击，请慎重体验。对于网关上做了MAC地址绑定的网络环境，该攻击一般只会导致目标机器和网关通信的中断（单向MAC欺骗成功）。&lt;/p&gt;

&lt;p&gt;希望通过这个程序的演示，能让大家都意识到网络安全性很脆弱。也藉此给出的警示，能尽快把国外已经先行力推的https，引入我们企业的信息化建设中来。至少，希望在SSO这个把所有鸡蛋（被集成系统的账号密码）都放在一个篮子的场景里，https能尽快成为企业认可的必选项。&lt;/p&gt;

&lt;p&gt;一切未保留原文链接的转载，均属侵权行为： &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 内网很安全？错错错！附攻击程序示例&quot; href=&quot;http://www.cnblogs.com/baibaomen/p/intranet-attack.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/baibaomen/p/intranet-attack.html&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;业务合作或授权协商请邮件：baibaomen@gmail.com。 &lt;/p&gt;


</description>
<pubDate>Mon, 24 Sep 2018 18:52:00 +0000</pubDate>
<dc:creator>百宝门-SSO顾问</dc:creator>
<og:description>给企业做顾问时，常演示这个程序，以暴露大部分企业内网环境的脆弱性。当内网中有人运行这个程序，你在自己电脑上的网站会被同事实时“直播”；手机明明连的是公司有“安全”标记的wifi，访问单位OA时竟然会被</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baibaomen/p/intranet-attack.html</dc:identifier>
</item>
<item>
<title>【强化学习】MOVE37-Introduction（导论） - Mandy鹿</title>
<link>http://www.cnblogs.com/mandylu2018/p/9694533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mandylu2018/p/9694533.html</guid>
<description>&lt;blockquote readability=&quot;8.4815789473684&quot;&gt;
&lt;p&gt;&lt;span&gt;写在前面的话：从今日起，我会边跟着硅谷大牛Siraj的MOVE 37系列课程学习Reinforcement Learning(强化学习算法)，边更新这个系列。课程包含视频和文字，课堂笔记会按视频为单位进行整理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;课程表地址：&lt;a href=&quot;https://github.com/llSourcell/Move_37_Syllabus&quot; target=&quot;_blank&quot;&gt;https://github.com/llSourcell/Move_37_Syllabus&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;带字幕课程视频地址：&lt;a href=&quot;https://www.bilibili.com/video/av31518766&quot; target=&quot;_blank&quot;&gt;https://www.bilibili.com/video/av31518766&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;本课作为导论，大致普及了一下机器学习和强化学习的概念和用途。其次，捎带介绍了一下最常见的监督学习和非监督学习。对机器学习稍有了解的同学们，对这两个概念应该不陌生。如果对此毫无概念的同学们，可以看我下面的简单说明。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;机器学习（Machine Learning)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先，我们要明白，所谓的机器学习就是试图找出输入输出量之间的一个固定关系，以期对以后所有的输入量都能相应地去预测一个输出量。用数学语言来说，就是从一堆已知的x和y之间找出映射f。打个比方，如果我们发现每次穿裙子(x)就一定会下雨(y)，那么这个因果关系就是f；由此，我们就可以根据f这个关系，也就是某天穿没穿裙子，来推断会不会下雨。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;监督学习 (Supervised Learning)&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这里举一个水果分类的例子。这里机器学习算法所要完成的工作，就是要得到水果和水果名称之间的关系。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1334793/201809/1334793-20180924004507050-1585637014.png&quot; alt=&quot;图片来自视频&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;第一步是训练算法，第二步是用测试数据来检验算法的完善度。图中可以看到，这里训练算法时输入的数据是&lt;strong&gt;预先分过类&lt;/strong&gt;的（即打过标签的），所以事先需要&lt;strong&gt;人工参与&lt;/strong&gt;，把未分类的原始数据进行分类。此即是“监督”二字的要义所在，需要人工“监督”才能完成算法的训练。&lt;/p&gt;

&lt;h3&gt;非监督学习 (Unsupervised Learning)&lt;/h3&gt;
&lt;p&gt;同样是以水果举例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1334793/201809/1334793-20180924012632149-451030005.png&quot; alt=&quot;图片来自视频&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同样分为两步，区别在于，这里输入的数据是&lt;strong&gt;未分类&lt;/strong&gt;过的（也未打标签）。机器学习算法需要&lt;strong&gt;自己完成分类的工作&lt;/strong&gt;，并从中找出数据中的模式（往往是我们无法解释和说明的）。非监督学习通常可以用于&lt;strong&gt;聚类&lt;/strong&gt;——识别各个类别之下数据的相似性并由此分类，也可以用于&lt;strong&gt;异常识别&lt;/strong&gt;——例如排除数据集中的异常值（视频中的例子是欺诈性交易）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1334793/201809/1334793-20180924013912398-1504065801.png&quot; alt=&quot;图片来自视频&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里，一句话总结：监督学习适用于事后对数据&lt;strong&gt;阐释性分析&lt;/strong&gt;和对未来的&lt;strong&gt;预测&lt;/strong&gt;，非监督学习则更适合发现数据的&lt;strong&gt;内在规律&lt;/strong&gt;和&lt;strong&gt;结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而，实际情况中的影响因素往往更复杂，要解决的问题也往往不止是确定既有的固定关系。有时，需要我们在没有训练数据的情况根据实际情况去不断优化策略（有点类似于我们人类的熟能生巧）。因此，这里引进了另一个概念：“&lt;strong&gt;强化学习&lt;/strong&gt;”。&lt;/p&gt;

&lt;h3&gt;强化学习 (Reinforcement Learning)&lt;/h3&gt;
&lt;p&gt;这里以选择最优运输路线为例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1334793/201809/1334793-20180924201732641-1744565751.png&quot; alt=&quot;图片来自视频&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可知影响运输结果的因素有很多，包括天气、道路拥堵、交通工具、食品保存等等。同时，我们也&lt;strong&gt;没有先验数据来&lt;/strong&gt;训练算法和检验算法的优越性。那么这里的强化学习算法，就引入了一个&lt;strong&gt;新的维度&lt;/strong&gt;：&lt;strong&gt;时间&lt;/strong&gt;，来帮助我们在实际情况中通过&lt;strong&gt;不断迭代&lt;/strong&gt;来优化算法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1334793/201809/1334793-20180924142119314-130123493.png&quot; alt=&quot;图片来自视频&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;强化学习算法可以说是&lt;strong&gt;介于监督算法和非监督算法之间&lt;/strong&gt;。它既不像非监督算法一样完全不使用标签，也不像监督算法一样预先打好标签，这里的标签是&lt;strong&gt;延时&lt;/strong&gt;（delayed）打上的。就像图中所标出的那样，每个环节的标签T（也可以称为&lt;strong&gt;反馈&lt;/strong&gt;）由下一个环节来标记。&lt;/p&gt;
&lt;p&gt;我个人的理解是，所谓的强化学习算法的&lt;strong&gt;核心&lt;/strong&gt;，就是&lt;strong&gt;一个环环相扣的负反馈系统&lt;/strong&gt;。学过生物的同学大概能理解的意思，生物内部环境的稳态就是通过负反馈机制来实现的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1334793/201809/1334793-20180924235722433-2080783743.png&quot; alt=&quot;图片来自视频&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而当模式识别网络（神经网络）和基于强化学习框架的实时环境结合在一起，就是所谓&lt;strong&gt;深度强化学习&lt;/strong&gt;。我的理解是，和非监督学习算法类似，前者相当于Step1的模式识别部分，而后者相当于Step2——不断提供反馈来优化算法。&lt;/p&gt;
&lt;p&gt;至于这一算法有多牛逼嘛，看阿尔法狗就知道了。&lt;/p&gt;
&lt;p&gt;----------------------------------------------------- &lt;/p&gt;
&lt;p&gt;介绍完这些基本概念后，下面就进入&lt;strong&gt;正题&lt;/strong&gt;了。有一些&lt;strong&gt;数学知识&lt;/strong&gt;必须了解。&lt;/p&gt;

&lt;h3&gt;马尔科夫链 (Markov Chain)&lt;/h3&gt;
&lt;p&gt;对于强化学习来说，马尔科夫链是个很重要的概念。正是基于这个概念，才发展出算法和外界之间&lt;strong&gt;沟通&lt;/strong&gt;和&lt;strong&gt;反馈&lt;/strong&gt;的方式。&lt;/p&gt;
&lt;p&gt;马尔科夫链究竟是什么呢？简单来说，就是用来描述&lt;strong&gt;一连串相互关联的事件（状态）&lt;/strong&gt;的一种抽象模型。其中每个事件（状态）已经发生的前提下，接着会发生哪个事件（切换到哪个状态）的概率分布是&lt;strong&gt;已知&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1334793/201809/1334793-20180925002726290-1910659717.png&quot; alt=&quot;图片来自视频&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好吧，如果概率统计里没学过这一课的同学，估计此时已经百分百晕了。拿现实中的例子来举例，就比方说，天气预报吧。首先我们假定只有两种天气：晴天和雨天，并且前一天下雨后第二天放晴的概率是0.2，继续下雨的概率是0.8；前一天晴天第二天下雨的概率是0.4，继续放晴是0.6。那么，根据今天的天气，我们是不是能把未来七天每天放晴和下雨的概率都算出来了？OK，这未来七天的天气状态，就是一条简单的马尔科夫链。&lt;/p&gt;
&lt;p&gt;必须注意两点，一、我们计算出来的只是概率分布，&lt;strong&gt;依旧无法确定&lt;/strong&gt;给出每天的天气；二、每天的天气概率情况&lt;strong&gt;只取决于前一天&lt;/strong&gt;的天气。&lt;/p&gt;
&lt;p&gt;现在可以结合一下视频里的示意图来看了，这里的转移矩阵（Transition Matrix）给出了状态间互相转移的概率分布，右下角则展示了每多走一步后我们来到A、B、C三个节点的可能性。&lt;/p&gt;

&lt;h3&gt;马尔科夫决策过程（Markov Decision Process）&lt;/h3&gt;
&lt;p&gt;马尔科夫决策过程是马尔科夫链的扩展，在原基础上加入了&lt;strong&gt;行动（Action）&lt;/strong&gt;和&lt;strong&gt;奖励/反馈（Reward）&lt;/strong&gt;。相应的转移矩阵也产生了变化，下一个状态的概率分布 不仅取决于上一个状态还取决于采取的行动。而从环境得到的反馈则告诉我们这一步到底是好（正向反馈）还是坏（负向反馈）——所谓&lt;strong&gt;趋利避害&lt;/strong&gt;，下次就可以避免在同一状态下采取同样的行动。那么最终在不断&lt;strong&gt;最大化奖励&lt;/strong&gt;的过程中，我们就获取了&lt;strong&gt;最优策略&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1334793/201809/1334793-20180925003839263-1393911969.png&quot; alt=&quot;图片来自视频&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;OK，以上就是导论课的所有内容。&lt;/p&gt;
&lt;p&gt;有理解不当或阐述的错误的地方，还望大牛们不吝指正。&lt;/p&gt;
&lt;p&gt;感谢阅读~&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 16:52:00 +0000</pubDate>
<dc:creator>Mandy鹿</dc:creator>
<og:description>写在前面的话：从今日起，我会边跟着硅谷大牛Siraj的MOVE 37系列课程学习Reinforcement Learning(强化学习算法)，边更新这个系列。课程包含视频和文字，课堂笔记会按视频为单位</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mandylu2018/p/9694533.html</dc:identifier>
</item>
<item>
<title>Nginx简单总结 - banananana</title>
<link>http://www.cnblogs.com/George1994/p/9697405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/George1994/p/9697405.html</guid>
<description>&lt;h2&gt;&lt;span&gt;特点总结&lt;/span&gt;&lt;/h2&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;nginx有一个master进程和多个worker进程，master进程是主要用来管理worker进程，管理的内容包括以下内容：接收来自外界的信号，向各个woker进程发送信号，监控worker进程的运行状态，当worker进程退出后，会自动重新启动新的worker进程。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;每个worker进程是相对独立平等的，相互竞争处理一个请求，并且从始至终的处理这个请求，不会出现处理其他进程的请求；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;span&gt;选择NGINX的理由&lt;/span&gt;&lt;/h2&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;底层由epoll（异步阻塞的方式）来实现，可以实现高并发；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;内存消耗少，1w个非活跃的HTTP Keep-Alive连接在Nginx中仅消耗2.5MB的内存；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;成本低廉，BSD协议开源免费；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;配置文件简单易懂；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;支持rewrite重写规则；能根据域名、URL的不同，将HTTP请求分发到不同的后端服务器群组中；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;内置的健康检查功能；即使Nginx proxy后端的某台web服务器宕机了，也不会影响前端访问；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;稳定性高；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;支持热部署；可以长时间的运行，并且可以在不间断服务的情况下，对软件版本进行升级；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;设计极具扩展性；它完全是由多个不同功能、不同层次、不同类型且耦合度极低的模块组成；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;&lt;span&gt;配置结构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;nginx.conf的配置结构包括main全局块、events块、http块、server块、location块；不同模块的执行关系：server继承main，location继承server，upstream既不会继承指令也不会被继承，它有它自己的特殊指令；&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span contenteditable=&quot;true&quot;&gt;&lt;span&gt;指令上下文&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span contenteditable=&quot;true&quot;&gt;&lt;span&gt;解释&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span contenteditable=&quot;true&quot;&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td contenteditable=&quot;true&quot;&gt;&lt;span&gt;&lt;span&gt;与具体业务功能无关的一些参数；比如工作进程数等；&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span contenteditable=&quot;true&quot;&gt;&lt;span&gt;http&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td contenteditable=&quot;true&quot;&gt;&lt;span&gt;&lt;span&gt;与提供http服务相关的一些配置参数；&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span contenteditable=&quot;true&quot;&gt;&lt;span&gt;server&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td contenteditable=&quot;true&quot;&gt;&lt;span&gt;&lt;span&gt;http服务器上支持若干个虚拟主机， 每个虚拟主机对应一个server配置项，配置项中包含该虚拟主机相关的配置；&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span contenteditable=&quot;true&quot;&gt;&lt;span&gt;location&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td contenteditable=&quot;true&quot;&gt;&lt;span&gt;&lt;span&gt;http服务中，某些特定的URL对应的一系列配置项；&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span contenteditable=&quot;true&quot;&gt;&lt;span&gt;mail&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td contenteditable=&quot;true&quot;&gt;&lt;span&gt;&lt;span&gt;实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项；&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;nginx.conf&lt;/span&gt;&lt;/p&gt;
&lt;pre spellcheck=&quot;false&quot; contenteditable=&quot;false&quot;&gt;
&lt;span&gt;&lt;span&gt;# 定义Nginx运行的用户和用户组，默认是nobody&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;user&lt;/span&gt;  nobody;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;# 允许生成的进程数，建议设置为等于CPU总核心数&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;worker_processes&lt;/span&gt;  2;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;# 指定错误日志路径，级别；这个设置可以放入全局块，http块，server块，级别依次为：debug|info|notice|warn|error|crit|alert|emerg&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;error_log&lt;/span&gt;  logs/error.&lt;span&gt;log &lt;/span&gt; info;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;# 工作模式以及连接数上线&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;events&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;use&lt;/span&gt; epoll;  &lt;span&gt;# 时间驱动模型，包括select, poll, epoll, kqueue等&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;worker_connections&lt;/span&gt;  1024;  &lt;span&gt;# 单个work进程允许的最大连接数目&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;# http服务器&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;http&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;#gzip模块设置&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;gzip&lt;/span&gt; on; &lt;span&gt;#开启gzip压缩输出&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;gzip_min_length&lt;/span&gt; 1k; &lt;span&gt;#最小压缩文件大小&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;gzip_buffers&lt;/span&gt; &lt;span&gt;4 16k&lt;/span&gt;; &lt;span&gt;#压缩缓冲区&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;gzip_http_version&lt;/span&gt; 1.0; &lt;span&gt;#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;gzip_comp_level&lt;/span&gt; 2; &lt;span&gt;#压缩等级&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;gzip_types&lt;/span&gt; text/&lt;span&gt;plain application&lt;/span&gt;/&lt;span&gt;x-javascript&lt;/span&gt; text/&lt;span&gt;css application&lt;/span&gt;/xml;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;#压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;gzip_vary&lt;/span&gt; on;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;#limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;# 子配置放到/usr/local/nginx/conf/servers/*/目录下&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;include&lt;/span&gt; /usr/local/nginx/conf/servers/&lt;span&gt;\&lt;/span&gt;*/&lt;span&gt;upstream&lt;/span&gt;.conf;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;include&lt;/span&gt; /usr/local/nginx/conf/servers/&lt;span&gt;\&lt;/span&gt;*/site.conf;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;site.conf&lt;/span&gt;&lt;/p&gt;
&lt;pre contenteditable=&quot;false&quot; spellcheck=&quot;false&quot;&gt;
&lt;span&gt;&lt;span&gt;# 虚拟主机的配置&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;# http接口&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;server&lt;/span&gt; {  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;listen&lt;/span&gt;          &lt;span&gt;80 default_server&lt;/span&gt;;  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;client_max_body_size&lt;/span&gt; 20m;  &lt;span&gt;# 最大上传包&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;server_name&lt;/span&gt;     www.linuxidc.com;  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;access_log&lt;/span&gt;      logs/linuxidc.access.&lt;span&gt;log main&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;# 子配置放到/usr/local/nginx/conf/servers/test/locations/目录下&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;include&lt;/span&gt; /usr/local/nginx/conf/servers/test/locations/&lt;span&gt;\&lt;/span&gt;*.&lt;span&gt;location&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;# https接口&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;# 1. https的固定端口是443，不同于HTTP的80接口&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;# 2. SSL标准需要引入安全证书，所以在 conf 中你需要指定证书和它对应的 key&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;server&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;listen&lt;/span&gt; &lt;span&gt;443 ssl&lt;/span&gt; &lt;span&gt;http2 default_server&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;root&lt;/span&gt; /usr/local/nginx/conf/servers/test/nginx_www/;  &lt;span&gt;# 指定证书的位置&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;include&lt;/span&gt; /usr/local/nginx/conf/servers/common/ssl_config.conf;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;include&lt;/span&gt; /usr/local/nginx/conf/servers/test/https/ssl_rewrite.&lt;span&gt;location&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;include&lt;/span&gt; /usr/local/nginx/conf/servers/test/locations/&lt;span&gt;\&lt;/span&gt;*.&lt;span&gt;location&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;upstream.conf&lt;/span&gt;&lt;/p&gt;
&lt;pre contenteditable=&quot;false&quot; spellcheck=&quot;false&quot;&gt;
&lt;span&gt;&lt;span&gt;# 设定实际的服务器列表，几种负载均衡的方式&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;upstream&lt;/span&gt; &lt;span&gt;mysvr1 &lt;/span&gt;{   &lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;server&lt;/span&gt; 127.0.0.1:7878;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;# 热备(其它所有的非backup机器down或者忙的时候，请求backup机器))&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;server&lt;/span&gt; 192.168.10.121:&lt;span&gt;3333 backup&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;upstream&lt;/span&gt; &lt;span&gt;mysvr2 &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;# weigth参数表示权值，权值越高被分配到的几率越大&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;server&lt;/span&gt; 192.168.1.11:&lt;span&gt;80 weight&lt;/span&gt;=5;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;server&lt;/span&gt; 192.168.1.12:&lt;span&gt;80 weight&lt;/span&gt;=1;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;server&lt;/span&gt; 192.168.1.13:&lt;span&gt;80 weight&lt;/span&gt;=6;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;send_timeout&lt;/span&gt; 90;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;proxy_connect_timeout&lt;/span&gt; 50;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;proxy_send_timeout&lt;/span&gt; 90;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;proxy_read_timeout&lt;/span&gt; 90;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;upstream&lt;/span&gt; &lt;span&gt;https-svr&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;# 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;ip_hash&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;server&lt;/span&gt; 192.168.1.11:90;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;server&lt;/span&gt; 192.168.1.12:90;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;project.location&lt;/span&gt;&lt;/p&gt;
&lt;pre contenteditable=&quot;false&quot; spellcheck=&quot;false&quot;&gt;
&lt;span&gt;&lt;span&gt;# 反向代理的路径，和upstream绑定，location后面绑定映射的路径&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;location&lt;/span&gt; /&lt;span&gt;app1 &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;include&lt;/span&gt; uwsgi_params;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;uwsgi_pass mysvr1&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;location&lt;/span&gt; /&lt;span&gt;passport &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;include&lt;/span&gt; uwsgi_params;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;uwsgi_pass https-svr&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 24 Sep 2018 16:01:00 +0000</pubDate>
<dc:creator>banananana</dc:creator>
<og:description>NGINX简单总结 特点总结 nginx有一个master进程和多个worker进程，master进程是主要用来管理worker进程，管理的内容包括以下内容：接收来自外界的信号，向各个woker进程发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/George1994/p/9697405.html</dc:identifier>
</item>
<item>
<title>css中的position属性值的探究 - NineKit</title>
<link>http://www.cnblogs.com/NineKit/p/9697406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NineKit/p/9697406.html</guid>
<description>&lt;p&gt;css的position属性指定了元素的定位类型，然后通过top，botton，left，right来具体定位。&lt;/p&gt;
&lt;p&gt;在具体定位之前必须使用position属性，否则所有的具体定位属性都无法生效。&lt;/p&gt;
&lt;p&gt;position可选择的值一共五个：static ，relative，absolute，fixed，或sticky。&lt;/p&gt;
&lt;p&gt;下面博主将一一进行含代码和运行结果的对比解释&lt;/p&gt;
&lt;p&gt;首先是不设置position属性，可以看到two元素的top的属性并未生效，而颜色属性是有效的，当前位置是默认文档流中的位置，以此为原型对比position改变时的元素位置的变化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./j.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot; id=&quot;one&quot;&amp;gt;One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box&quot; id=&quot;two&quot;&amp;gt;Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box&quot; id=&quot;three&quot;&amp;gt;Three&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;box&quot; id=&quot;four&quot;&amp;gt;Four&amp;lt;/div&amp;gt;  
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box &lt;/span&gt;{&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; inline-block&lt;/span&gt;;&lt;span&gt;

    background&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;&lt;span&gt;
    color&lt;/span&gt;:&lt;span&gt; white&lt;/span&gt;;
  }&lt;span&gt;
  
  #two &lt;/span&gt;{&lt;span&gt;
    top&lt;/span&gt;:&lt;span&gt; 260px&lt;/span&gt;;&lt;span&gt;
    bottom&lt;/span&gt;:&lt;span&gt; 126px&lt;/span&gt;;&lt;span&gt;
    left&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;&lt;span&gt;
    background&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180924234548045-1469819917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;position：static&lt;/p&gt;
&lt;p&gt;在#two的类下添加position：static;如下（后面每处只修改position的值）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  #two &lt;/span&gt;{&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt;static&lt;/span&gt;;&lt;span&gt;
    top&lt;/span&gt;:&lt;span&gt; 260px&lt;/span&gt;;&lt;span&gt;
    bottom&lt;/span&gt;:&lt;span&gt; 126px&lt;/span&gt;;&lt;span&gt;
    left&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;&lt;span&gt;
    background&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180924234830843-226012954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;HTML元素的默认值，即没有定位，元素出现在正常的流中。&lt;/p&gt;
&lt;p&gt;静态定位的元素不会受到 top, bottom, left, right影响。&lt;/p&gt;
&lt;p&gt;这个值既然会使定位属性失效，那么它存在的意义是什么的？&lt;/p&gt;
&lt;p&gt;在网页样式修改的过程中，可以暂时的屏蔽某些元素的位置信息，或者在修改的时候，保留，某些部分的位置信息，便于恢复。&lt;/p&gt;

&lt;p&gt;position：relative&lt;/p&gt;
&lt;p&gt;相对定位，相对与原来正常文档流的位置定位，但是在定位时不改变原来的页面布局，既是相当于只是把定位的元素进行了移动，而移动的对比标准位置就是正常文档流中的位置，而原来的位置会留白。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180924235014136-2057906108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;position ：absolute&lt;/p&gt;
&lt;p&gt;绝对定位，该元素将从普通文档流中删除，并且不会为页面布局中的元素创建空间。他相对于最近已定位的父元素定位。例子中即是根据body元素来定位的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180924235055279-1304619736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;position ：fixed&lt;/p&gt;
&lt;p&gt;固定定位，所谓固定定位和绝对定位相似，一样都会从普通文档流中删除，并且不会为页面布局中的元素创建空间；不一样的是它是固定在视窗上的，是以视窗为定位对象的的，相信大家浏览很多网页时都有这样的感受，网页上部或者下部会有广告不会随着网页的上下滚动而移动，它们是固定在网页上的，并且如果没有设置z-index来修该叠放次序，它们会覆盖网页的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180924235145487-371183709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;position ：sticky&lt;/p&gt;
&lt;p&gt;该元素并不脱离文档流，仍然保留元素原本在文档流中的位置。&lt;/p&gt;
&lt;p&gt;当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 20px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。&lt;/p&gt;
&lt;p&gt;元素固定的相对偏移是相对于离它最近的具有滚动框的父元素，如果父元素都不可以滚动，那么是相对于viewport来计算元素的偏移量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480455/201809/1480455-20180925000031326-895095945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 24 Sep 2018 16:01:00 +0000</pubDate>
<dc:creator>NineKit</dc:creator>
<og:description>css的position属性指定了元素的定位类型，然后通过top，botton，left，right来具体定位。 在具体定位之前必须使用position属性，否则所有的具体定位属性都无法生效。 pos</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NineKit/p/9697406.html</dc:identifier>
</item>
<item>
<title>高并发第十二弹:并发容器J.U.C -- Executor组件FutureTask、ForkJoin - 爱呼吸的鱼</title>
<link>http://www.cnblogs.com/aihuxi/p/9697379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aihuxi/p/9697379.html</guid>
<description>&lt;p&gt;从本章开始就要说 Executor 的东西了.本次讲的是一个很常用的FutureTask,和一个不是那么常用的ForkJoin,我们现在就来介绍吧&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;大部分时候创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。但是这两种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　  所以后期就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。FutureTask又是集大成者.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;一个一个来介绍&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Callable:只有一个带返回值的call方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; {
 
    V call() &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt;&lt;span&gt; task);
&lt;/span&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt;&lt;span&gt; submit(Runnable task, T result);
Future&lt;/span&gt;&amp;lt;?&amp;gt; submit(Runnable task)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一个submit方法里面的参数类型就是Callable。&lt;/p&gt;
&lt;p&gt;　　暂时只需要知道Callable一般是和ExecutorService配合来使用的，具体的使用方法讲在后面讲述。&lt;/p&gt;
&lt;p&gt;　　一般情况下我们使用第一个submit方法和第三个submit方法，第二个submit方法很少使用。&lt;/p&gt;
&lt;h3&gt;Future接口&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Future&amp;lt;V&amp;gt;&lt;span&gt; {
　// 取消任务
  &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; cancel(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; mayInterruptIfRunning);     &lt;br/&gt;//取消状态   
  &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isCancelled();&lt;br/&gt;//是否完成
  &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isDone();&lt;br/&gt;//方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回
  V get() &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException;&lt;br/&gt;// 用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。
  V get(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeout, TimeUnit unit)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException, TimeoutException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说Future提供了三种功能：&lt;/p&gt;
&lt;p&gt;　　1）判断任务是否完成；&lt;/p&gt;
&lt;p&gt;　　2）能够中断任务；&lt;/p&gt;
&lt;p&gt;　　3）能够获取任务执行结果。&lt;/p&gt;
&lt;p&gt;因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。&lt;/p&gt;

&lt;h3&gt;FutureTask&lt;/h3&gt;
&lt;p&gt;FutureTask这个才是真实使用者.FutureTask实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FutureTask&amp;lt;V&amp;gt; &lt;span&gt;implements&lt;/span&gt; RunnableFuture&amp;lt;V&amp;gt;&lt;span&gt; {
    ...
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; RunnableFuture&amp;lt;V&amp;gt; &lt;span&gt;extends&lt;/span&gt; Runnable, Future&amp;lt;V&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; run();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FutureTask的两个构造类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; FutureTask(Callable&amp;lt;V&amp;gt;&lt;span&gt; callable) {
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FutureTask(Runnable runnable, V result) {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;使用实例&lt;/h3&gt;
&lt;p&gt; 方法一:使用Callable&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ExecutorService executor =&lt;span&gt; Executors.newCachedThreadPool();
        Callable&lt;/span&gt;&amp;lt;String&amp;gt; task = &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;&lt;span&gt;() {

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;task 返回结果&quot;&lt;span&gt;;
            }
        };
        Future&lt;/span&gt;&amp;lt;String&amp;gt; result =&lt;span&gt; executor.submit(task);
        executor.shutdown();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(result.isDone()) {
            System.out.println(result.get());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 方式二:使用FutureTask&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
FutureTask&amp;lt;String&amp;gt; task = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;&lt;span&gt;() {

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;aaaa&quot;&lt;span&gt;;
            }
        });
        task.run();
        System.out.println(task.get());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;fork/join:&lt;/h3&gt;
&lt;p&gt;Fork/Join框架：在必要的情况下，将一个大任务，进行拆分（fork） 成若干个子任务（拆到不能再拆，这里就是指我们制定的拆分的临界值），再将一个个小任务的结果进行join汇总。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Fork/Join与传统线程池的区别！&lt;/p&gt;
&lt;p&gt;Fork/Join采用“工作窃取模式”，当执行新的任务时他可以将其拆分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随即线程中偷一个并把它加入自己的队列中。&lt;/p&gt;
&lt;p&gt;就比如两个CPU上有不同的任务，这时候A已经执行完，B还有任务等待执行，这时候A就会将B队尾的任务偷过来，加入自己的队列中，对于传统的线程，ForkJoin更有效的利用的CPU资源！&lt;/p&gt;
&lt;p&gt;我们来看一下ForkJoin的实现：实现这个框架需要继承RecursiveTask 或者 RecursiveAction ，RecursiveTask是有返回值的，相反Action则没有&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180502173012969?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plc29uam9rZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;p&gt;局限性：&lt;/p&gt;
&lt;p&gt;1、任务只能使用fork和join作为同步机制，如果使用了其他同步机制，当他们在同步操作时，工作线程就不能执行其他任务了。比如在fork框架使任务进入了睡眠，那么在睡眠期间内在执行这个任务的线程将不会执行其他任务了。&lt;/p&gt;
&lt;p&gt;2、我们所拆分的任务不应该去执行IO操作，如读和写数据文件。&lt;/p&gt;
&lt;p&gt;3、任务不能抛出检查异常。必须通过必要的代码来处理他们。&lt;/p&gt;
&lt;p&gt;框架核心：&lt;/p&gt;
&lt;p&gt;核心有两个类：&lt;/p&gt;
&lt;p&gt;ForkJoinPool | ForkJoinTask ForkJoinPool：负责来做实现，包括工作窃取算法、管理工作线程和提供关于任务的状态以及他们的执行信息。&lt;/p&gt;
&lt;p&gt;ForkJoinTask:提供在任务中执行fork和join的机制。&lt;/p&gt;
&lt;p&gt;测试一下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ForkJoinWork &lt;span&gt;extends&lt;/span&gt; RecursiveTask&amp;lt;Long&amp;gt;&lt;span&gt;{


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Long start;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;起始值&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Long end;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束值&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;  Long critical = 5000L;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;临界值 ,设定不大于这个值就不分裂&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ForkJoinWork(Long start, Long end) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.start =&lt;span&gt; start;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.end =&lt;span&gt; end;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Long compute() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否是拆分完毕&lt;/span&gt;
        Long lenth = end -&lt;span&gt; start;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(lenth&amp;lt;=&lt;span&gt;critical){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果拆分完毕就相加&lt;/span&gt;
            Long sum = 0L&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Long i = start;i&amp;lt;=end;i++&lt;span&gt;){
                sum &lt;/span&gt;+=&lt;span&gt; i;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sum;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有拆分完毕就开始拆分&lt;/span&gt;
            Long middle = (end + start)/2;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算的两个值的中间值&lt;/span&gt;
            ForkJoinWork right = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ForkJoinWork(start,middle);
            right.fork();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拆分，并压入线程队列&lt;/span&gt;
            ForkJoinWork left = &lt;span&gt;new&lt;/span&gt; ForkJoinWork(middle+1&lt;span&gt;,end);
            left.fork();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拆分，并压入线程队列

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; right.join() +&lt;span&gt; left.join();
        }
    }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
             &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l =&lt;span&gt; System.currentTimeMillis();
             ForkJoinPool forkJoinPool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ForkJoinPool();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现ForkJoin 就必须有ForkJoinPool的支持&lt;/span&gt;
             ForkJoinTask&amp;lt;Long&amp;gt; task = &lt;span&gt;new&lt;/span&gt; ForkJoinWork(0L,10000000000L);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数为起始值与结束值&lt;/span&gt;
             Long invoke =&lt;span&gt; forkJoinPool.invoke(task);
             &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l1 =&lt;span&gt; System.currentTimeMillis();
             System.out.println(&lt;/span&gt;&quot;invoke = &quot; + invoke+&quot;  time: &quot; + (l1-&lt;span&gt;l));
        }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ForkJoinWorkTest {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        test();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        test2();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        test3();&lt;/span&gt;
&lt;span&gt;    }
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ForkJoin实现&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; l =&lt;span&gt; System.currentTimeMillis();
        ForkJoinPool forkJoinPool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ForkJoinPool();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现ForkJoin 就必须有ForkJoinPool的支持&lt;/span&gt;
        ForkJoinTask&amp;lt;Long&amp;gt; task = &lt;span&gt;new&lt;/span&gt; ForkJoinWork(0L, 10000000000L);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数为起始值与结束值&lt;/span&gt;
        Long invoke =&lt;span&gt; forkJoinPool.invoke(task);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l1 =&lt;span&gt; System.currentTimeMillis();
        System.out.println(&lt;/span&gt;&quot;ForkJoin实现 time: &quot; + (l1 -&lt;span&gt; l));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 普通线程实现&lt;/span&gt;
        Long x = 0L&lt;span&gt;;
        Long y &lt;/span&gt;= 10000000000L&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Long i = 0L; i &amp;lt;= y; i++&lt;span&gt;) {
            x &lt;/span&gt;+=&lt;span&gt; i;
        }
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l1 =&lt;span&gt; System.currentTimeMillis();
        System.out.println(&lt;/span&gt;&quot;普通线程实现  time: &quot; + (l1 -&lt;span&gt; l));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Java 8 并行流的实现&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; l =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; reduce = LongStream.rangeClosed(0, 10000000000L).parallel().reduce(0&lt;span&gt;, Long::sum);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l1 =&lt;span&gt; System.currentTimeMillis();
        System.out.println(&lt;/span&gt;&quot;Java 8 并行流的实现 time: &quot; + (l1 -&lt;span&gt; l));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;p&gt;　　ForkJoin实现 time: 38798&lt;/p&gt;
&lt;p&gt;普通线程实现 time: 58860&lt;/p&gt;
&lt;p&gt; Java 8 并行流的实现 time: 2375&lt;/p&gt;
&lt;p&gt;我们观察上面可以看出来执行10000000000L的相加操作各自执行完毕的时间不同。观察到当数据很大的时候ForkJoin比普通线程实现有效的多，但是相比之下ForkJoin的实现实在是有点麻烦，这时候Java 8 就为我们提供了一个并行流来实现ForkJoin实现的功能。可以看到并行流比自己实现ForkJoin还要快&lt;/p&gt;
&lt;p&gt;Java 8 中将并行流进行了优化，我们可以很容易的对数据进行并行流的操作，Stream API可以声明性的通过parallel()与sequential()在并行流与穿行流中随意切换！&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 15:59:00 +0000</pubDate>
<dc:creator>爱呼吸的鱼</dc:creator>
<og:description>大部分时候创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。但是这两种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。 Stream API可以声明性的通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aihuxi/p/9697379.html</dc:identifier>
</item>
<item>
<title>设计模式（一）：模板模式 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/9653333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/9653333.html</guid>
<description>&lt;p&gt;实际开发中常常会遇到，代码骨架类似甚至相同，只是具体的实现不一样的场景。例如：流程都有开启、编辑、驳回、结束。每个流程都包含这几个步骤，不同的是不同的流程实例它们的内容不一样。共享单车都是先开锁、骑行、上锁、付款。这些大的步骤固定，不同的是每个实例的具体实现细节不一样。这些类似的业务我们都可以使用模板模式实现。为什么要使用模板模式以及如何使用呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。&lt;br/&gt;&lt;strong&gt;意图&lt;/strong&gt;：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤&lt;br/&gt;&lt;strong&gt;主要解决&lt;/strong&gt;：一些方法通用，却在每一个子类都重新写了这一方法。&lt;br/&gt;&lt;strong&gt;何时使用&lt;/strong&gt;：有一些通用的方法。&lt;br/&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：将这些通用算法抽象出来。&lt;br/&gt;&lt;strong&gt;关键代码&lt;/strong&gt;：在抽象类实现，其他步骤在子类实现。&lt;/p&gt;

&lt;p&gt;我们以生活中买菜做饭的例子来写个Demo，烧饭一般都是买菜、洗菜、烹饪、装盘四大过程。中国自古有八大菜系，制作方式肯定都避不开这四个过程。那在模板模式中如何实现呢？&lt;br/&gt;创建一个抽象类，它的模板方法被设置为 final。&lt;strong&gt;为防止恶意操作，一般模板方法都加上 final 关键词。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractCookingService {
    //买菜
    protected abstract void shopping();
    //清洗
    protected abstract void wash();
    //烹饪
    protected abstract void cooking();
    //装盘
    protected abstract void dishedUp();

    public final void process() {
        shopping();
        wash();
        cooking();
        dishedUp();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建实现了上述抽象类的子类。&lt;br/&gt;// 徽菜烹饪&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 徽菜制作大厨
 */
public class HuiCaiChef extends AbstractCookingService {

    @Override
    protected void shopping() {
        System.out.println(&quot;买菜：新鲜鱼一条，红辣椒五两&quot;);
    }

    @Override
    protected void wash() {
        System.out.println(&quot;清洗：红椒洗净切片，鱼头半分&quot;);
    }

    @Override
    protected void cooking() {
        System.out.println(&quot;烹饪：鱼头水蒸，辣椒过油&quot;);
    }

    @Override
    protected void dishedUp() {
        System.out.println(&quot;装盘：用长形盘子装盛&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;// 川菜烹制&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 川菜制作大厨
 */
public class HuiCaiChef extends AbstractCookingService {

    @Override
    protected void shopping() {
        System.out.println(&quot;买菜：黑猪肉一斤，蒜头5个&quot;);
    }

    @Override
    protected void wash() {
        System.out.println(&quot;清洗：猪肉洗净，蒜头去皮&quot;);
    }

    @Override
    protected void cooking() {
        System.out.println(&quot;烹饪：大火翻炒，慢火闷油&quot;);
    }

    @Override
    protected void dishedUp() {
        System.out.println(&quot;装盘：深碗盛起，热油浇拌&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 TemplatePatternDemo 类执行模板方法 process() 来演示烹饪的定义方式。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TemplatePatternDemo {

    public static void main(String[] args) {
        System.out.println(&quot;----------川菜制作------------&quot;);
        AbstractCookingService chuanCaiService = new ChuanCaiChef();
        chuanCaiService.process();
        System.out.println(&quot;-----------徽菜制作-----------&quot;);
        AbstractCookingService huiCaiService = new HuiCaiChef();
        huiCaiService.process();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行程序，输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;----------川菜制作------------
买菜：新鲜鱼一条，红辣椒五两
清洗：红椒洗净切片，鱼头半分
烹饪：鱼头水蒸，辣椒过油
装盘：用长形盘子装盛
-----------徽菜制作-----------
买菜：黑猪肉一斤，蒜头5个
清洗：猪肉洗净，蒜头去皮
烹饪：大火翻炒，慢火闷油
装盘：深碗盛起，热油浇拌&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上实例可以看出，其实模板模式也没什么高深莫测的，简单来说就是三大步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个抽象类，定义几个抽象方法和一个final修饰的模板方法，而模板方法中设定了抽象方法的执行顺序或逻辑。&lt;/li&gt;
&lt;li&gt;无论子类有多少个，只需要继承该抽象类，实现父类的抽象方法重写自己的业务。&lt;/li&gt;
&lt;li&gt;根据不同的需求创建不同的子类实现，每次调用的地方只需调用模板方法，即可完成特定的模板流程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从以上的分析和Demo我们可以看到，模板方法提高了我们的代码的可维护性和可扩展性。有优点也有缺点。&lt;br/&gt;&lt;strong&gt;优点&lt;/strong&gt;： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。&lt;br/&gt;&lt;strong&gt;缺点&lt;/strong&gt;：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。&lt;br/&gt;&lt;strong&gt;使用场景&lt;/strong&gt;： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>实际开发中常常会遇到，代码骨架类似甚至相同，只是具体的实现不一样的场景。例如：流程都有开启、编辑、驳回、结束。每个流程都包含这几个步骤，不同的是不同的流程实例它们的内容不一样。共享单车都是先开锁、骑行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/9653333.html</dc:identifier>
</item>
<item>
<title>React Native 入门基础知识总结 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/9697178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/9697178.html</guid>
<description>&lt;p&gt;中秋在家闲得无事，想着做点啥，后来想想，为啥不学学 react native。在学习 React Native 时， 需要对前端（HTML，CSS，JavaScript）知识有所了解。对于JS，可以看看阮一峰老师的《&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot;&gt;ECMAScript 6 入门&lt;/a&gt;》这篇文章。里面涉及很多 ES6 的新特性。我之前也是看了阮老师的文章做了一些学习笔记 &lt;a href=&quot;https://www.cnblogs.com/huansky/tag/ES6/&quot; target=&quot;_blank&quot;&gt;ES6 学习笔记&lt;/a&gt;。 &lt;/p&gt;
&lt;h2&gt;1、环境搭建&lt;/h2&gt;
&lt;p&gt;环境搭建中文教程，点击跳转RN中文社区 ：&lt;a href=&quot;http://reactnative.cn/docs/0.40/getting-started.html#content&quot; target=&quot;_blank&quot;&gt;http://reactnative.cn/docs/0.40/getting-started.html#content&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;社区内容讲得很详细，大家跟着操作一步一步来即可，遇到问题，直接百度。也可以看看这篇文章：&lt;a href=&quot;https://www.jianshu.com/p/276cb2c0283a&quot; target=&quot;_blank&quot;&gt;React Native 填坑指南&lt;/a&gt; 会教你如何把坑填平。&lt;/p&gt;
&lt;h2&gt;2、React Native 基础&lt;/h2&gt;
&lt;p&gt;先来看看一个实例，这个地址源码地址：&lt;a href=&quot;https://reactnative.cn/docs/sample-application-movies/&quot; target=&quot;_blank&quot;&gt;示例教程：电影列表&lt;/a&gt;。之所以选择这个例子，是因为它包含了几乎所有的 react native入门基础知识。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
import React, { Component } from &quot;react&quot;&lt;span&gt;;

import { Image, FlatList, StyleSheet, Text, View } from &lt;/span&gt;&quot;react-native&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; REQUEST_URL =
&quot;https://raw.githubusercontent.com/facebook/react-native/0.51-stable/docs/MoviesExample.json&quot;&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class SampleAppMovies extends Component {
    constructor(props) {
        super(props);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
            data: [],
            loaded: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在ES6中，如果在自定义的函数里使用了this关键字，则需要对其进行“绑定”操作，否则this的指向会变为空&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 像下面这行代码一样，在constructor中使用bind是其中一种做法（还有一些其他做法，如使用箭头函数等）&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.fetchData = &lt;span&gt;this&lt;/span&gt;.fetchData.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
}

componentDidMount() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fetchData();
}

fetchData() {
    fetch(REQUEST_URL)
    .then(response &lt;/span&gt;=&amp;gt;&lt;span&gt; response.json())
    .then(responseData &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意，这里使用了this关键字，为了保证this在调用时仍然指向当前组件，我们需要对其进行“绑定”操作&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
          data: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.data.concat(responseData.movies),
          loaded: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      });
    });
}

render() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.loaded) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.renderLoadingView();
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;&lt;span&gt;FlatList
      data&lt;/span&gt;={&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.data}
      renderItem&lt;/span&gt;={&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.renderMovie}
      style&lt;/span&gt;=&lt;span&gt;{styles.list}
      &lt;/span&gt;/&amp;gt;
&lt;span&gt;      );
}

renderLoadingView() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;View style={styles.container}&amp;gt;
      &amp;lt;Text&amp;gt;Loading movies...&amp;lt;/Text&amp;gt;
      &amp;lt;/View&amp;gt;
&lt;span&gt;      );
}

renderMovie({ item }) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; { item }是一种“解构”写法，请阅读ES2015语法的相关文档&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; item也是FlatList中固定的参数名，请阅读FlatList的相关文档&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;View style={styles.container}&amp;gt;
      &amp;lt;&lt;span&gt;Image
      source&lt;/span&gt;=&lt;span&gt;{{ uri: item.posters.thumbnail }}
      style&lt;/span&gt;=&lt;span&gt;{styles.thumbnail}
      &lt;/span&gt;/&amp;gt;
      &amp;lt;View style={styles.rightContainer}&amp;gt;
      &amp;lt;Text style={styles.title}&amp;gt;{item.title}&amp;lt;/Text&amp;gt;
      &amp;lt;Text style={styles.year}&amp;gt;{item.year}&amp;lt;/Text&amp;gt;
      &amp;lt;/View&amp;gt;
      &amp;lt;/View&amp;gt;
&lt;span&gt;      );
}
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; styles =&lt;span&gt; StyleSheet.create({
  container: {
    flex: &lt;/span&gt;1&lt;span&gt;,
    flexDirection: &lt;/span&gt;&quot;row&quot;&lt;span&gt;,
    justifyContent: &lt;/span&gt;&quot;center&quot;&lt;span&gt;,
    alignItems: &lt;/span&gt;&quot;center&quot;&lt;span&gt;,
    backgroundColor: &lt;/span&gt;&quot;#F5FCFF&quot;&lt;span&gt;
},
rightContainer: {
    flex: &lt;/span&gt;1&lt;span&gt;
},
title: {
    fontSize: &lt;/span&gt;20&lt;span&gt;,
    marginBottom: &lt;/span&gt;8&lt;span&gt;,
    textAlign: &lt;/span&gt;&quot;center&quot;&lt;span&gt;
},
year: {
    textAlign: &lt;/span&gt;&quot;center&quot;&lt;span&gt;
},
thumbnail: {
    width: &lt;/span&gt;53&lt;span&gt;,
    height: &lt;/span&gt;81&lt;span&gt;
},
list: {
    paddingTop: &lt;/span&gt;20&lt;span&gt;,
    backgroundColor: &lt;/span&gt;&quot;#F5FCFF&quot;&lt;span&gt;
}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子从电影数据库中取得最近正在上映的 25 部电影，并在一个 &lt;code&gt;FlatList &lt;/code&gt;中展示出来。&lt;/p&gt;

&lt;h3&gt;2.1 import &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import React,{Component} from 'react'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导入‘react’文件里export的一个默认的组件，将其命名为React以及Component这个非默认组件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有其他一些 import 的用法，具体含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;import defaultcomponent form 'XXX'&lt;/span&gt;&lt;/strong&gt;　　　导入 XXX 文件中的默认组件，命名为 defaultcomponent&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;import {a} from 'XXX'&lt;/span&gt;&lt;/strong&gt; 　　导入 XXX 文件中的 a 组件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;import {a as b} from 'XXX'&lt;/span&gt;&lt;/strong&gt; 　　导入 XXX 文件中的a组件，并将其重命名为 b&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;import * as a from 'XXX'&lt;/span&gt;&lt;/strong&gt; 　　导入 XXX 文件中的所有组件，并将其命名为 a，调用具体组件的方式为 a.b、a.c。。。但不包含默认组件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.2 var 定义变量&lt;/h3&gt;
&lt;p&gt;在组件前面，定一个变量 REQUEST_URL 用于保存请求网址，。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.3 export 语句&lt;/h3&gt;
&lt;p&gt;模块的功能有两个关键字: export 和 import。export 用于用户自定义模块。import用于输入其他模块的功能，同时创建命名空间（namespace），防止函数名冲突。&lt;/p&gt;
&lt;p&gt;ES6允许将独立的JS文件作为模块，也就是说，允许一个 JavaScript 脚本文件调用另一个脚本文件。最简单的模块就是一个 JS 文件，里面使用 export 关键字输出变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;profile.js&lt;/span&gt;
    export &lt;span&gt;var&lt;/span&gt; firstName = &quot;Pandora&quot;&lt;span&gt;;
    export &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lastName = &quot;G.Dragon&quot;&lt;span&gt;;
    export &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; year = 1973&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;export还有下面这种写法，两者是等价的&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; firstName = &quot;Pandora&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lastName = &quot;G.Dragon&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; year = 1973&lt;span&gt;;
    export({firstName, lastName, year});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 export 定义模块之后，其他 JS 文件就可以通过 import 关键字加载这个模块（文件）了。加载方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    import {firstName, lastName, year} from './profile'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setHeader(element) {
        element.textContent &lt;/span&gt;= firstName + '' +&lt;span&gt; lastName;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码片段中，使用了 import 关键字接受一个对象——用“{ }”表示。里面指定了要从其他模块中导入的变量。大括号里面的变量名必须与被导入模块对外接口的名称相同。&lt;/p&gt;

&lt;h3&gt;2.4 Class 类&lt;/h3&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;class&lt;/code&gt;关键字，可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;class&lt;/code&gt;写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的“类”改写，就是下面这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Point {
  constructor(x, y) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
  }

  toString() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '(' + &lt;span&gt;this&lt;/span&gt;.x + ', ' + &lt;span&gt;this&lt;/span&gt;.y + ')'&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;上面代码定义了一个“类”，可以看到里面有一个 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;constructor &lt;/code&gt;方法，这就是构造方法，而 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;this &lt;/code&gt;关键字则代表实例对象。也就是说，ES5 的构造函数 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;Point&lt;/code&gt;，对应 ES6 的 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;Point &lt;/code&gt;类的构造方法。&lt;/p&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;Point 类除了构造方法，还定义了一个 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;toString &lt;/code&gt;方法。注意，定义“类”的方法的时候，前面不需要加上 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;function &lt;/code&gt;这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。&lt;/p&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;Class 之间可以通过 &lt;strong&gt;&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;extends &lt;/code&gt;关键字&lt;/strong&gt;实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
class ColorPoint extends Point {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;上面代码定义了一个 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;ColorPoint &lt;/code&gt;类，该类通过 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;extends &lt;/code&gt;关键字，继承了 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;Point &lt;/code&gt;类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;Point &lt;/code&gt;类。下面，我们在 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;ColorPoint &lt;/code&gt;内部加上代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用父类的constructor(x, y)&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; color;
  }

  toString() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.color + ' ' + super.toString(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用父类的toString()&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;上面代码中，&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;constructor &lt;/code&gt;方法和 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;toString &lt;/code&gt;方法之中，都出现了&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;super &lt;/code&gt;关键字，它在这里表示父类的构造函数，用来新建父类的 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;this &lt;/code&gt;对象。&lt;/p&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;&lt;strong&gt;子类必须在 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;constructor &lt;/code&gt;方法中调用 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;super &lt;/code&gt;方法，&lt;/strong&gt;否则新建实例时会报错。这是因为&lt;strong&gt;子类没有自己的 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;this &lt;/code&gt;对象，而是继承父类的 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;this &lt;/code&gt;对象，然后对其进行加工。&lt;/strong&gt;如果不调用&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;super&lt;/code&gt;方法，子类就得不到 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;this &lt;/code&gt;对象。&lt;/p&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;2.5 Props（属性）&lt;/h3&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;p&gt;大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为&lt;code&gt;props&lt;/code&gt;（属性）。&lt;/p&gt;
&lt;p&gt;以常见的基础组件 &lt;code&gt;Image &lt;/code&gt;为例，在创建一个图片时，可以传入一个名为 &lt;code&gt;source &lt;/code&gt;的 prop 来指定要显示的图片的地址，以及使用名为 &lt;code&gt;style &lt;/code&gt;的 prop 来控制其尺寸。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; React, { Component } from 'react'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; { Image } from 'react-native'&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Bananas &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Component {
  render() {
    let pic &lt;/span&gt;=&lt;span&gt; {
      uri: &lt;/span&gt;'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg'&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;Image source={pic} style={{width: 193, height: 110}} /&amp;gt;&lt;span&gt;
    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt; &lt;/h3&gt;
&lt;h3 class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;2.6 state &lt;/h3&gt;
&lt;p&gt; props 是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。 对于需要改变的数据，我们需要使用 state。&lt;/p&gt;
&lt;p&gt;大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为 &lt;code&gt;props&lt;/code&gt;（属性）。&lt;/p&gt;
&lt;p&gt;一般来说，你需要在 constructor 中初始化 &lt;code&gt;state&lt;/code&gt;（译注：这是 ES6 的写法，早期的很多 ES5 的例子使用的是 getInitialState 方法来初始化 state，这一做法会逐渐被淘汰），然后在需要修改时调用 &lt;code&gt;setState&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;提示一些初学者应该牢记的要点：&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.7 react native 生命周期&lt;/h3&gt;
&lt;div readability=&quot;56.078829668282&quot;&gt;
&lt;p&gt;组件的生命周期方法对应着组件的不同生命阶段，通常我们分为三个阶段：组件初始化及挂载阶段、组件运行期阶段及组件卸载阶段。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;初始化及挂载阶段&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一、这是组件类的构造函数，通常在此初始化 state 数据模型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;constructor(props) {
  &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(props);
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key : value&lt;/span&gt;
&lt;span&gt;  };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、表示组件将要加载到虚拟 DOM，在 render 方法之前执行，整个生命周期只执行一次。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentWillMount() {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、表示组件已经加载到虚拟 DOM，在 render 方法之后执行，整个生命周期只执行一次。&lt;span&gt;通常在该方法中完成异步网络请求或者集成其他 JavaScript库。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentDidMount() {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;运行期阶段&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一、在组件接收到其父组件传递的 &lt;code&gt;props &lt;/code&gt;的时候执行,参数为父组件传递的&lt;code&gt;props&lt;/code&gt;。在组件的整个生命周期可以多次执行。通常在此方法接收新的&lt;code&gt;props&lt;/code&gt;值，重新设置 &lt;code&gt;state&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentWillReceiveProps(nextProps) {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key : value&lt;/span&gt;
&lt;span&gt;  });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、在 &lt;code&gt;componentWillReceiveProps(nextProps) &lt;/code&gt;执行之后立刻执行；或者在&lt;code&gt;state&lt;/code&gt;更改之后立刻执行。该方法包含两个参数，分别是 &lt;code&gt;props&lt;/code&gt;和 &lt;code&gt;state&lt;/code&gt;。该方法在组件的整个生命周期可以多次执行。如果该方法返回 &lt;code&gt;false&lt;/code&gt;，则 &lt;code&gt;componentWillUpdate(nextProps, nextState) &lt;/code&gt;及其之后执行的方法都不会执行，组件则不会进行重新渲染。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;shouldComponentUpdate(nextProps, nextState) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、在 &lt;code&gt;shouldComponentUpdate(nextProps, nextState) &lt;/code&gt;函数执行完毕之后立刻调用，该方法包含两个参数，分别是 &lt;code&gt;props &lt;/code&gt;和 &lt;code&gt;state&lt;/code&gt;。&lt;code&gt;render() &lt;/code&gt;函数执行之前调用。该方法在组件的整个生命周期可以多次执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentWillUpdate(nextProps, nextState) {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、在 &lt;code&gt;render() &lt;/code&gt;方法执行之后立刻调用。该方法包含两个参数，分别是 &lt;code&gt;props &lt;/code&gt;和 &lt;code&gt;state&lt;/code&gt;。该方法在组件的整个生命周期可以多次执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentDidUpdate(preProps, preState) {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、&lt;code&gt;render &lt;/code&gt;方法用于渲染组件。在初始化阶段和运行期阶段都会执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;render() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;&amp;lt;View/&amp;gt;&lt;span&gt;
  );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;卸载阶段&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一、在组件由虚拟 DOM 卸载的时候调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentWillUnmount() {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.8 fetch &lt;/h3&gt;
&lt;p&gt;fetch，说白了，就是 XMLHttpRequest 的一种替代方案。如果有人问你，除了 Ajax 获取后台数据之外，还有没有其他的替代方案？答案是还可以使用一种更优的解决方案 fetch。&lt;/p&gt;
&lt;p&gt;到现在为止，fetch 的支持性还不是很好，但是在谷歌浏览器中已经支持了fetch。fetch 挂在在 BOM 中，可以直接在谷歌浏览器中使用。&lt;/p&gt;
&lt;p&gt;查看 fetch 的支持情况：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;fetch的支持情况&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; fetch 方法会返回一个 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;，这种模式可以简化异步风格的代码。如果你想了解 promise 的含义，可以参考文章 ：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/huansky/p/6064402.html&quot;&gt;手把手教你实现一个完整的 Promise&lt;/a&gt; 。带你了解 promise 的本质内核。&lt;/p&gt;
&lt;p&gt;下面我们来写第一个 fetch 获取后端数据的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过fetch获取百度的错误提示页面&lt;/span&gt;
fetch('https://www.baidu.com/search/error.html') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个Promise对象&lt;/span&gt;
  .then((res)=&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res.text() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; res.text()是一个Promise对象&lt;/span&gt;
&lt;span&gt;  })
  .then((res)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    console.log(res) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; res是最终的结果&lt;/span&gt;
  })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是很简单？再来看看 get 和 post 方法的使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过fetch获取百度的错误提示页面&lt;/span&gt;
fetch('https://www.baidu.com/search/error.html?a=1&amp;amp;b=2', { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在URL中写上传递的参数&lt;/span&gt;
    method: 'GET'&lt;span&gt;
  })

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; post 方法，把前面的 get 注释即可
fetch('&lt;/span&gt;&lt;span&gt;https://www.baidu.com/search/error.html&lt;/span&gt;&lt;span&gt;', {
    method: 'POST',
    body: new URLSearchParams([[&quot;foo&quot;, 1],[&quot;bar&quot;, 2]]).toString() // 这里是请求对象
  })
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  .then((res)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res.text()
  })
  .then((res)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    console.log(res)
  })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;React Native 中已经内置了 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XMLHttpRequest API&lt;/a&gt; (也就是俗称的 ajax)。一些基于 XMLHttpRequest 封装的第三方库也可以使用，例如 &lt;a href=&quot;https://github.com/niftylettuce/frisbee&quot;&gt;frisbee&lt;/a&gt; 或是 &lt;a href=&quot;https://github.com/mzabriskie/axios&quot;&gt;axios&lt;/a&gt; 等。但注意不能使用 jQuery，因为 jQuery 中还使用了很多浏览器中才有而 RN 中没有的东西（所以也不是所有 web 中的 ajax 库都可以直接使用）。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.9 样式&lt;/h3&gt;
&lt;div readability=&quot;27.5&quot;&gt;
&lt;h4&gt;style 的定义方式：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、直接在 render（）函数中定义&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo 设置样式一,直接在render中定义样式&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; mStyle = {color:'red',fontSize:34&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&amp;lt;Text style={mStyle}&amp;gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/93Laer &amp;lt;/Text&amp;gt;&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; or 类似于安卓中的匿名内部内&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return&amp;lt;Text style={{color:'red',fontSize:34}}&amp;gt; https://github.com/93Laer &amp;lt;/Text&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;2、方式二，通过 StyleSheet 创建 style，测试多个 style，以哪个为准&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建样式&lt;/span&gt;
const styles =&lt;span&gt; StyleSheet.create({
    bigblue:{
        color:&lt;/span&gt;'blue'&lt;span&gt;,
        fontSize:&lt;/span&gt;34&lt;span&gt;,
        fontWeight:&lt;/span&gt;'bold'&lt;span&gt;
    },
    red:{
        color:&lt;/span&gt;'red'&lt;span&gt;,
        fontSize:&lt;/span&gt;14&lt;span&gt;
    }
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用样式&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;todo 设置样式二，通过StyleSheet创建样式&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt;&amp;lt;Text style={styles.bigblue}&amp;gt; https :&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/93Laer &amp;lt;/Text&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接在组件中传入多个 style 对象,最后显示的效果就不展示了，在结尾直接给出结论&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里通过多种方式定义style，主要是告诉读者定义style的多种方式&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; mStyle = {color:'red',fontSize:34&lt;span&gt;};
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&amp;lt;Text style={[mStyle,{color: 'blue',fontSize:20}]}&amp;gt; https :&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/93Laer &amp;lt;/Text&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 StyleSheet 创建多个 style，并传入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 return&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Text &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;={[styles.bigblue,styles.red]}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; https ://github.com/93Laer &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;strong&gt;结论：&lt;/strong&gt;&lt;span&gt;当设置多个 style 时以最后一个为准，可理解为最后一个将之前的样式覆盖了。也可理解为，style 从 styles 数组中依次拿出 style，并赋值给自己，所以最后一次赋值就会显示效果&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，关于 react native 入门的基础知识就讲解完毕了。&lt;/p&gt;

</description>
<pubDate>Mon, 24 Sep 2018 15:31:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>本文通过一个 react native 的例子来对 react native 入门的基础知识进行了总结，对于初学者只有掌握好这些入门的基础知识，才能更好地继续深入学习。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huansky/p/9697178.html</dc:identifier>
</item>
<item>
<title>依赖配置中心实现注有@ConfigurationProperties的bean相关属性刷新 - 小眼儿</title>
<link>http://www.cnblogs.com/hujunzheng/p/9697282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/9697282.html</guid>
<description>&lt;h2&gt;配置中心是什么&lt;/h2&gt;
&lt;p&gt;　　配置中心，通过key=value的形式存储环境变量。配置中心的属性做了修改，项目中可以通过配置中心的依赖（sdk）立即感知到。需要做的就是如何在属性发生变化时，改变带有@ConfigurationProperties的bean的相关属性。&lt;/p&gt;
&lt;h2&gt;配置中心原理&lt;/h2&gt;
&lt;p&gt;　　在读配置中心源码的时候发现，里面维护了一个Environment，以及ZookeeperPropertySource。当配置中心属性发生变化的时候，清空ZookeeperPropertySource，并放入最新的属性值。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180924231152294-615393343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ZookeeperPropertySource &lt;span&gt;extends&lt;/span&gt; EnumerablePropertySource&amp;lt;Properties&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180924231233563-334472918.png&quot; alt=&quot;&quot; width=&quot;788&quot; height=&quot;472&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ZookeeperPropertySource重写了equals和hahscode方法，根据这两个方法可以判定配置中心是否修改了属性。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180924231301483-521600859.png&quot; alt=&quot;&quot; width=&quot;787&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;动态刷新bean属性原理&lt;/h2&gt;
&lt;h3&gt;实现原理图&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180924231351423-1983348432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;动态刷新bean父类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseConfigCenterBean &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InitializingBean {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(BaseConfigCenterBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置中心是否生效&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; cfgCenterEffect = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isCfgCenterEffect() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.checkCfgCenterEffect();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cfgCenterEffect;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkCfgCenterEffect() {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; tmpCfgCenterEffect = !&lt;span&gt;Objects.isNull(ConfigHelper.getEnvironment());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tmpCfgCenterEffect) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NOSONAR&lt;/span&gt;
            String value = (String) ConfigHelper.getZookeeperPropertySource().getProperty(&quot;cfg.center.effect&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isBlank(value)) {
                tmpCfgCenterEffect &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                tmpCfgCenterEffect &lt;/span&gt;=&lt;span&gt; Boolean.valueOf(value);
            }
        }

        cfgCenterEffect &lt;/span&gt;=&lt;span&gt; tmpCfgCenterEffect;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cfgCenterEffect) {
            String prefix &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getConfigPrefix();
            cfgCenterEffect &lt;/span&gt;=&lt;span&gt; Arrays.stream(ConfigHelper.getZookeeperPropertySource().getPropertyNames())
                    .filter(keyName &lt;/span&gt;-&amp;gt; keyName.indexOf(prefix) == 0&lt;span&gt;)
                    .count() &lt;/span&gt;&amp;gt; 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cfgCenterEffect) {
                LOGGER.info(String.format(&lt;/span&gt;&quot;配置中心没有发现模块=%s, prefix=%s的配置，将使用本地配置...&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getModuleName(), prefix));
            }
        }
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 绑定自身目标
     *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doBind() {
        Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; BaseConfigCenterBean&amp;gt; clazz = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (AopUtils.isCglibProxy(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)) {
            clazz &lt;/span&gt;= (Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; BaseConfigCenterBean&amp;gt;) AopUtils.getTargetClass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
        BaseConfigCenterBean target &lt;/span&gt;= binding(isCfgCenterEffect(), clazz, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDefaultResourcePath());
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.copyProperties(target);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; copyProperties(BaseConfigCenterBean target) {
        ReflectionUtils.doWithFields(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getClass(), field -&amp;gt;&lt;span&gt; {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            field.set(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, field.get(target));
        }, field &lt;/span&gt;-&amp;gt; AnnotatedElementUtils.isAnnotated(field, ConfigField.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 绑定其他目标
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz 目标类
     *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; T doBind(Class&amp;lt;T&amp;gt;&lt;span&gt; clazz) {
        T target &lt;/span&gt;= binding(isCfgCenterEffect(), clazz, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDefaultResourcePath());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (target &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; InitializingBean) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                ((InitializingBean) target).afterPropertiesSet();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                LOGGER.error(String.format(&lt;/span&gt;&quot;属性初始化失败[afterPropertiesSet]， class=%s&quot;&lt;span&gt;, ClassUtils.getSimpleName(clazz), e));
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; T binding(&lt;span&gt;boolean&lt;/span&gt; cfgCenterEffect, Class&amp;lt;T&amp;gt;&lt;span&gt; clazz, String defaultResourcePath) {
        Optional&lt;/span&gt;&amp;lt;PropertySource&amp;gt; propertySource =&lt;span&gt; Optional.empty();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cfgCenterEffect) {
            propertySource &lt;/span&gt;=&lt;span&gt; Optional.ofNullable(ConfigHelper.getZookeeperPropertySource());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Optional&lt;/span&gt;&amp;lt;ResourcePropertySource&amp;gt; resourcePropertySource =&lt;span&gt; ResourceUtils.getResourcePropertySource(defaultResourcePath);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resourcePropertySource.isPresent()) {
                propertySource &lt;/span&gt;=&lt;span&gt; Optional.ofNullable(resourcePropertySource.get());
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (propertySource.isPresent()) {
            T target;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                target &lt;/span&gt;=&lt;span&gt; RelaxedConfigurationBinder
                        .with(clazz)
                        .setPropertySources(propertySource.get())
                        .doBind();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (GeneralException e) {
                LOGGER.error(String.format(&lt;/span&gt;&quot;属性绑定失败， class=%s&quot;&lt;span&gt;, ClassUtils.getSimpleName(clazz)), e);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterPropertiesSet() {
        Class&lt;/span&gt;&amp;lt;?&amp;gt; target = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (AopUtils.isAopProxy(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)) {
            target &lt;/span&gt;= AopUtils.getTargetClass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
        LOGGER.info(String.format(&lt;/span&gt;&quot;%s-&amp;gt;%s模块引入配置中心%s...&quot;, &lt;span&gt;this&lt;/span&gt;.getModuleName(), ClassUtils.getSimpleName(target), (isCfgCenterEffect() ? &quot;生效&quot; : &quot;无效&quot;&lt;span&gt;)));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getModuleName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StringUtils.EMPTY;
    }

    @Subscribe
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; listenRefreshEvent(ConfigCenterUtils.ConfigRefreshEvent refreshEvent) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!refreshEvent.getModuleName().equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getModuleName())) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refreshForEvent();
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过事件进行刷新&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshForEvent();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取本地配置默认路径&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getDefaultResourcePath();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取配置属性的公共前缀&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getConfigPrefix();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1、isCfgCenterEffect方法主要判断项目是否接入了配置中心并且配置中心配有bean中相关的属性。&lt;/p&gt;
&lt;p&gt;　　2、binding方法主要根据isCfgCenterEffect方法的返回值去加载配置中心的properties还是本地的properties。&lt;/p&gt;
&lt;p&gt;　　3、getDefaultResourcePath是主要是获取本地资源的默认路径（在没有接入配置中心的情况下）。&lt;/p&gt;
&lt;p&gt;　　4、getConfigPrefix方法返回bean中配置属性的公共前缀（等同于@ConfigurationProperties中的prefix属性）。&lt;/p&gt;
&lt;p&gt;　　5、refreshForEvent方法主要是在某个bean感知到配置中心更新属性时异步通知其他bean进行属性的更新。&lt;/p&gt;
&lt;h3&gt;bean属性绑定工具类&lt;/h3&gt;
&lt;p&gt;　　动态将propertysource绑定到带有@ConfigurationProperties注解的bean中。&lt;/p&gt;
&lt;p&gt;　　参考 org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; PropertiesConfigurationFactory&amp;lt;T&amp;gt;&lt;span&gt; factory;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RelaxedConfigurationBinder(T object) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; PropertiesConfigurationFactory&amp;lt;&amp;gt;&lt;span&gt;(object));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder(Class&amp;lt;?&amp;gt;&lt;span&gt; type) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; PropertiesConfigurationFactory&amp;lt;&amp;gt;&lt;span&gt;(type));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; with(T object) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;&amp;gt;&lt;span&gt;(object);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt; with(Class&amp;lt;T&amp;gt;&lt;span&gt; type) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;&amp;gt;&lt;span&gt;(type);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder(PropertiesConfigurationFactory&amp;lt;T&amp;gt;&lt;span&gt; factory) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.factory =&lt;span&gt; factory;
        ConfigurationProperties properties &lt;/span&gt;= getMergedAnnotation(factory.getObjectType(), ConfigurationProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        javax.validation.Validator validator &lt;/span&gt;=&lt;span&gt; Validation.buildDefaultValidatorFactory().getValidator();
        factory.setValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringValidatorAdapter(validator));
        factory.setConversionService(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConversionService());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Objects.isNull(properties)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NOSONAR&lt;/span&gt;
&lt;span&gt;            factory.setIgnoreNestedProperties(properties.ignoreNestedProperties());
            factory.setIgnoreInvalidFields(properties.ignoreInvalidFields());
            factory.setIgnoreUnknownFields(properties.ignoreUnknownFields());
            factory.setTargetName(properties.prefix());
            factory.setExceptionIfInvalid(properties.exceptionIfInvalid());
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; setTargetName(String targetName) {
        factory.setTargetName(targetName);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt; setPropertySources(PropertySource&amp;lt;?&amp;gt;&lt;span&gt;... propertySources) {
        MutablePropertySources sources &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutablePropertySources();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (PropertySource&amp;lt;?&amp;gt;&lt;span&gt; propertySource : propertySources) {
            sources.addLast(propertySource);
        }
        factory.setPropertySources(sources);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; setPropertySources(Environment environment) {
        factory.setPropertySources(((ConfigurableEnvironment) environment).getPropertySources());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; setPropertySources(PropertySources propertySources) {
        factory.setPropertySources(propertySources);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; setConversionService(ConversionService conversionService) {
        factory.setConversionService(conversionService);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; setValidator(Validator validator) {
        factory.setValidator(validator);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt; setResolvePlaceholders(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; resolvePlaceholders) {
        factory.setResolvePlaceholders(resolvePlaceholders);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T doBind() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; GeneralException {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; factory.getObject();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; GeneralException(&quot;配置绑定失败！&quot;&lt;span&gt;, ex);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;配置中心工具类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigCenterUtils {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(ConfigCenterUtils.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AsyncEventBus eventBus = &lt;span&gt;new&lt;/span&gt; AsyncEventBus(Executors.newFixedThreadPool(8));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NOSONAR&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Properties cfgProperties;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Environment environment;

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        cfgProperties &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
        cfgProperties.putAll(ConfigHelper.getZookeeperPropertySource().getProperties());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setEnvironment(Environment environment) {
        ConfigCenterUtils.environment &lt;/span&gt;=&lt;span&gt; environment;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getValue(String name) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; PropertiesUtil.getValue(name);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.info(&lt;/span&gt;&quot;配置中心无效， property name=&quot; +&lt;span&gt; name, e);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Objects.isNull(environment)) {
            LOGGER.info(&lt;/span&gt;&quot;environment无效，property name=&quot; +&lt;span&gt; name);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StringUtils.EMPTY;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;environment.containsProperty(name)) {
            LOGGER.info(&lt;/span&gt;&quot;environment无配置 property name=&quot; +&lt;span&gt; name);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StringUtils.EMPTY;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; environment.getProperty(name);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; propertySourceShouldRefresh(String moduleName, ZookeeperPropertySource newPropertySource) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cfgProperties.equals(newPropertySource.getProperties())) {
            cfgProperties.clear();
            cfgProperties.putAll(newPropertySource.getProperties());
            eventBus.post(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigRefreshEvent(moduleName));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T createToRefreshPropertiesBean(Class&amp;lt;T&amp;gt;&lt;span&gt; clazz) {
        Enhancer enhancer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置代理对象父类&lt;/span&gt;
&lt;span&gt;        enhancer.setSuperclass(clazz);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标识Spring-generated proxies&lt;/span&gt;
        enhancer.setInterfaces(&lt;span&gt;new&lt;/span&gt; Class[]{SpringProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置增强&lt;/span&gt;
        enhancer.setCallback((MethodInterceptor) (target, method, args, methodProxy) -&amp;gt;&lt;span&gt; {
            ToRefresh toRefresh &lt;/span&gt;= AnnotationUtils.findAnnotation(method, ToRefresh.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Objects.isNull(toRefresh) ||&lt;span&gt; StringUtils.isBlank(toRefresh.method())) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodProxy.invokeSuper(target, args);
            }
            Method refreshMethod &lt;/span&gt;=&lt;span&gt; ReflectionUtils.findMethod(target.getClass(), toRefresh.method());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Objects.isNull(refreshMethod)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodProxy.invokeSuper(target, args);
            }
            refreshMethod &lt;/span&gt;=&lt;span&gt; BridgeMethodResolver.findBridgedMethod(refreshMethod);
            refreshMethod.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            refreshMethod.invoke(target, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodProxy.invokeSuper(target, args);
        });

        T target &lt;/span&gt;= (T) enhancer.create();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建代理对象&lt;/span&gt;
&lt;span&gt;
        MethodIntrospector.selectMethods(clazz, (ReflectionUtils.MethodFilter) method &lt;/span&gt;-&amp;gt; AnnotatedElementUtils.isAnnotated(method, ToInitial.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;))
                .stream().findFirst().ifPresent(method &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            method.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                method.invoke(target, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                LOGGER.error(String.format(&lt;/span&gt;&quot;初始化异常，class=%s ...&quot;&lt;span&gt;, ClassUtils.getSimpleName(clazz)), e);
            }
        });

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerListener(BaseConfigCenterBean refreshableBean) {
        eventBus.register(refreshableBean);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigRefreshEvent {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String moduleName;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigRefreshEvent(String moduleName) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.moduleName =&lt;span&gt; moduleName;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getModuleName() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; moduleName;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setModuleName(String moduleName) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.moduleName =&lt;span&gt; moduleName;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个工具主要作用：&lt;/p&gt;
&lt;p&gt;　　1、判断配置中心的属性是否发生了变化&lt;/p&gt;
&lt;p&gt;　　2、为BaseConfigCenterBean子类创建代理类，使属性在getter方法时检测属性是否应该刷新。&lt;/p&gt;
&lt;p&gt;　　3、提供将BaseConfigCenterBean类型的对象的注册为guava eventbus的监听对象，使之具有根据刷新事件自动刷新自身属性。&lt;/p&gt;
&lt;h3&gt;bean后置处理器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConfigCenterBeanPostProcessor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanPostProcessor {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessBeforeInitialization(Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (AnnotatedElementUtils.isAnnotated(bean.getClass(), ConfigCenterBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
            BaseConfigCenterBean refreshableBean &lt;/span&gt;=&lt;span&gt; (BaseConfigCenterBean) ConfigCenterUtils.createToRefreshPropertiesBean(bean.getClass());
            ConfigCenterUtils.registerListener(refreshableBean);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; refreshableBean;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessAfterInitialization(Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该后置处理器的作用是对所有BaseConfigCenterBean类型的bean进行处理，生成代理bean，并注册为guava eventbus相应的listener。&lt;/p&gt;
&lt;h3&gt;pojo属性绑定配置中心优雅方案1&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@ConfigCenterBean
@ConfigurationProperties(prefix &lt;/span&gt;= &quot;wx.temporary.qrcode&quot;&lt;span&gt;)
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; QrcodeConstants &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseConfigCenterBean {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(QrcodeConstants.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渠道&lt;/span&gt;
    @ConfigField &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标识该属性来自配置中心&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; channels;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务&lt;/span&gt;
&lt;span&gt;    @ConfigField
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; bizs;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务和渠道映射关系&lt;/span&gt;
&lt;span&gt;    @ConfigField
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel;


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; channelMap;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; bizMap;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; getChannels() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; channels;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setChannels(List&amp;lt;Scene&amp;gt;&lt;span&gt; channels) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channels =&lt;span&gt; channels;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; getBizs() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bizs;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBizs(List&amp;lt;Scene&amp;gt;&lt;span&gt; bizs) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizs =&lt;span&gt; bizs;
    }

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; getChannelMap() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; channelMap;
    }

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; getBizMap() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bizMap;
    }

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; getBiz2Channel() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; biz2Channel;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBiz2Channel(Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.biz2Channel =&lt;span&gt; biz2Channel;
    }

    @ToInitial
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshQrcodeProperties() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.doBind();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性处理&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(channels)) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channelMap =&lt;span&gt; Maps.newHashMap();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channelMap =&lt;span&gt; channels.stream()
                        .collect(Collectors.toMap(channel &lt;/span&gt;-&amp;gt;&lt;span&gt; channel.getType(), Function.identity()));
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(bizs)) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizMap =&lt;span&gt; Maps.newHashMap();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizMap =&lt;span&gt; bizs.stream()
                        .collect(Collectors.toMap(biz &lt;/span&gt;-&amp;gt;&lt;span&gt; biz.getType(), Function.identity()));
            }

            LOGGER.info(String.format(&lt;/span&gt;&quot;%s 刷新成功..., 当前配置=%s...&quot;, &lt;span&gt;this&lt;/span&gt;.getModuleName(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;QrcodeConstants 对象属性绑定失败...&quot;&lt;span&gt;, e);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; toRefresh() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isCfgCenterEffect()) {
                ZookeeperPropertySource propertySource &lt;/span&gt;=&lt;span&gt; ConfigHelper.getZookeeperPropertySource();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ConfigCenterUtils.propertySourceShouldRefresh(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getModuleName(), propertySource)) {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refreshQrcodeProperties();
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;QrcodeConstants 对象属性刷新失败&quot;&lt;span&gt;, e);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新事件调用&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshForEvent() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refreshQrcodeProperties();
    }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地资源文件&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultResourcePath() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;config/qrcode.properties&quot;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性配置 公共前缀（和@ConfigurationProperties prefix 属性一致）&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getConfigPrefix() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;wx.temporary.qrcode&quot;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块名称&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getModuleName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;微信临时二维码配置&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ReflectionToStringBuilder.toString(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;
                , ToStringStyle.JSON_STYLE
                , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                , QrcodeConstants.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Scene {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String type;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String desc;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getType() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; type;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setType(String type) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type =&lt;span&gt; type;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDesc() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; desc;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDesc(String desc) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.desc =&lt;span&gt; desc;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ReflectionToStringBuilder.toString(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;
                    , ToStringStyle.JSON_STYLE
                    , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                    , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                    , Scene.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;pojo属性绑定配置中心优雅方案2&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@ConfigCenterBean
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; QrcodeConstants &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseConfigCenterBean {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(QrcodeConstants.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务和渠道映射关系&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渠道&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; channelMap;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; bizMap;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; QrcodeProperties qrcodeProperties;

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; getChannelMap() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; channelMap;
    }

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; getBizMap() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bizMap;
    }

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; getBiz2Channel() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; biz2Channel;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBiz2Channel(Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.biz2Channel =&lt;span&gt; biz2Channel;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; QrcodeProperties getRawQrcodeProperties() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; qrcodeProperties;
    }

    @ToInitial
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshQrcodeProperties() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            QrcodeProperties qrcodeProperties &lt;/span&gt;= &lt;span&gt;super&lt;/span&gt;.doBind(QrcodeProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Objects.isNull(qrcodeProperties)) {
                LOGGER.error(String.format(&lt;/span&gt;&quot;没有加载到%s配置，请检查配置...&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getModuleName()));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.qrcodeProperties =&lt;span&gt; qrcodeProperties;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性处理&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(qrcodeProperties.channels)) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channelMap =&lt;span&gt; Maps.newHashMap();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channelMap =&lt;span&gt; qrcodeProperties.channels.stream()
                        .collect(Collectors.toMap(channel &lt;/span&gt;-&amp;gt;&lt;span&gt; channel.getType(), Function.identity()));
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(qrcodeProperties.bizs)) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizMap =&lt;span&gt; Maps.newHashMap();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizMap =&lt;span&gt; qrcodeProperties.bizs.stream()
                        .collect(Collectors.toMap(biz &lt;/span&gt;-&amp;gt;&lt;span&gt; biz.getType(), Function.identity()));
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(qrcodeProperties.getBiz2Channel())) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.biz2Channel =&lt;span&gt; Maps.newHashMap();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.biz2Channel =&lt;span&gt; qrcodeProperties.getBiz2Channel();
            }

            LOGGER.info(String.format(&lt;/span&gt;&quot;%s 刷新成功..., 当前配置=%s...&quot;, &lt;span&gt;this&lt;/span&gt;.getModuleName(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;QrcodeConstants 对象属性绑定失败...&quot;&lt;span&gt;, e);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; toRefresh() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isCfgCenterEffect()) {
                ZookeeperPropertySource propertySource &lt;/span&gt;=&lt;span&gt; ConfigHelper.getZookeeperPropertySource();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ConfigCenterUtils.propertySourceShouldRefresh(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getModuleName(), propertySource)) {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refreshQrcodeProperties();
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;QrcodeConstants 对象属性刷新失败&quot;&lt;span&gt;, e);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshForEvent() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refreshQrcodeProperties();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultResourcePath() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;config/qrcode.properties&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getConfigPrefix() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;wx.temporary.qrcode&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getModuleName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;微信临时二维码配置&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ToStringBuilder(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                .append(&lt;/span&gt;&quot;biz2Channel&quot;&lt;span&gt;, biz2Channel)
                .append(&lt;/span&gt;&quot;channelMap&quot;&lt;span&gt;, channelMap)
                .append(&lt;/span&gt;&quot;bizMap&quot;&lt;span&gt;, bizMap)
                .toString();
    }

    @ConfigurationProperties(prefix &lt;/span&gt;= &quot;wx.temporary.qrcode&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QrcodeProperties {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渠道&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; channels;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; bizs;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务和渠道映射关系&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; getChannels() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; channels;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setChannels(List&amp;lt;Scene&amp;gt;&lt;span&gt; channels) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channels =&lt;span&gt; channels;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; getBizs() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bizs;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBizs(List&amp;lt;Scene&amp;gt;&lt;span&gt; bizs) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizs =&lt;span&gt; bizs;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; getBiz2Channel() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; biz2Channel;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBiz2Channel(Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.biz2Channel =&lt;span&gt; biz2Channel;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Scene {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String type;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String desc;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getType() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; type;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setType(String type) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type =&lt;span&gt; type;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDesc() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; desc;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDesc(String desc) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.desc =&lt;span&gt; desc;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ReflectionToStringBuilder.toString(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;
                    , ToStringStyle.JSON_STYLE
                    , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                    , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                    , Scene.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　方案1和方案2略有不同，针对一些属性，我们需要做一些逻辑处理。方案1中将源属性和逻辑之后的属性都放在了同一类中，方案二则是将源属性单独放到一个静态类中，最终处理过后的属性放在了目标类中。另外二者的doBind方法也是有区别的，仔细看一下BaseConfigCenterBean这个类就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; title=&quot;动物小伙伴拍手祝贺动图&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wGnwDnq84NiaLA3ibqa1JW7dibHoSLXcIbBdDUsHDoLVIGDKZHkE28nlRu5mdTtQicw8xr8uN4RvOvk1CQe9GYIUSA/640?wx_fmt=gif&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-ratio=&quot;0.09363957597173145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wGnwDnq84NiaLA3ibqa1JW7dibHoSLXcIbBdDUsHDoLVIGDKZHkE28nlRu5mdTtQicw8xr8uN4RvOvk1CQe9GYIUSA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;566&quot; data-order=&quot;0&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;     就先分享这么多了，更多分享请关注我们的技术公众吧！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　 参考文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/4Mpm8E8DdbgD2egTBrEznA&quot; target=&quot;_blank&quot;&gt;算法和技术SHARING&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 15:26:00 +0000</pubDate>
<dc:creator>小眼儿</dc:creator>
<og:description>配置中心是什么 配置中心，通过key=value的形式存储环境变量。配置中心的属性做了修改，项目中可以通过配置中心的依赖（sdk）立即感知到。需要做的就是如何在属性发生变化时，改变带有@Configu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/9697282.html</dc:identifier>
</item>
<item>
<title>ZooKeeper概念与应用 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/9697237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/9697237.html</guid>
<description>&lt;p&gt;Zookeeper是开源的分布式协调服务，提供了分布式数据一致性的解决方案。&lt;/p&gt;
&lt;p&gt;Zookeeper 可用作配置中心和分布式锁服务，在 Dubbo、Kafka、Spark等分布式集群上得到广泛应用。&lt;/p&gt;

&lt;p&gt;Zookeeper的数据模型为树状结构，树的节点被称作ZNode。&lt;/p&gt;
&lt;p&gt;Zookeeper使用路径来唯一标识ZNode，类似于Unix文件系统中的绝对路径。路径必须以&lt;code&gt;/&lt;/code&gt;开头，由Unicode字符串组成，如&lt;code&gt;/myapp/master/0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每一个ZNode维护着三部分数据:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stat: 节点状态信息，包括版本、更改时间、访问控制等&lt;/li&gt;
&lt;li&gt;data: 节点的内容数据，Zookeeper限制每个节点数据不超过1M。Zookeeper设计用来进行协调调度，请勿在其中存放大量数据。&lt;/li&gt;
&lt;li&gt;children: 该ZNode的子节点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个节点都有独立的访问控制列表(Access Control List, ACL), 来控制用户对本节点的访问权限。&lt;/p&gt;
&lt;p&gt;每个ZNode都维护着三个版本号:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dataVersion: 节点数据版本号&lt;/li&gt;
&lt;li&gt;cversion: 子节点版本号&lt;/li&gt;
&lt;li&gt;aclVersion: 节点访问控制列表版本号&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所有的写操作都会使相应的版本号增加。写操作必须指定要更新的ZNode的版本号，版本号不一致会导致写入失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zxid&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有对Zookeeper状态的改变都会产生一个Zxid(ZooKeeper Transaction Id），Zxid全局有序。&lt;/p&gt;
&lt;p&gt;Zxid为标识事件发生的先后顺序: 即事件A发生早于事件B，那么事件A的Zxid定小于事件B的Zxid。&lt;/p&gt;
&lt;p&gt;每个ZNode维护两个Zxid:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cZxid: Znode创建&lt;/li&gt;
&lt;li&gt;mZxid: Znode最近修改&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Zxid是一个64位的数字, 高32位表示Zookeeper集群leader, 低32位表示逻辑顺序。每次leader改变后, 新产生的Zxid高32位都会改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Zookeeper中的节点分为两种:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;临时节点: 临时节点依赖于创建节点的会话(Session), 一旦Session结束临时节点会被自动删除。临时节点不允许拥有子节点&lt;/li&gt;
&lt;li&gt;永久节点: 永久节点生存期不依赖于客户端会话，只有客户端执行删除操作时才会删除。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Zookeeper 可以创建顺序子节点，即创建子节点时在路径结尾添加一个自增的32位 id, 该id在该节点的父节点下是唯一的。&lt;/p&gt;
&lt;h2 id=&quot;watch&quot;&gt;Watch&lt;/h2&gt;
&lt;p&gt;Zookeeper 所有的读操作getData(), getChildren()和 exists()都可以设置 Watch 触发器。&lt;/p&gt;
&lt;p&gt;Watch 触发器是一次性的，当触发器通知了一次状态变化后消失，不会通知状态的再次变化。&lt;/p&gt;
&lt;p&gt;Zookeeper 与客户端之间通过 Tcp Socket 进行通信， Zookeeper 会主动将时间通知客户端。&lt;/p&gt;
&lt;p&gt;Zookeeper 保证客户端只有首先收到了Watch通知后，才会感知到它所设置监视的znode发生了变化。&lt;/p&gt;
&lt;p&gt;Zookeeper 支持三种类型的watch:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;exists: 被监视的Znode 创建、删除、数据改变时被触发&lt;/li&gt;
&lt;li&gt;getData: 被监视的Znode 删除、数据改变时被触发&lt;/li&gt;
&lt;li&gt;getChildren: 被监视的Znode 删除、创建子节点、删除子节点时被触发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ZooKeeper 是具有较高一致性的分布式协调服务，它提供以下保证:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原子性: 所有操作具有原子性&lt;/li&gt;
&lt;li&gt;分布式一致性： 从任意节点中读取到的数据都是一致的&lt;/li&gt;
&lt;li&gt;顺序一致性: 从一个客户端来的更新请求会被顺序执行&lt;/li&gt;
&lt;li&gt;持久性: 写操作一旦成功，直到被覆盖为止持续有效&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Zookeeper 使用数据副本和崩溃恢复机制保证数据安全和集群高可用性。&lt;/p&gt;
&lt;p&gt;Zookeeper 使用基于 Paxos 算法的 ZAB协议(Zookeeper Atomic Broadcast)进行写操作，保证集群数据的一致性。&lt;/p&gt;
&lt;h2 id=&quot;配置中心&quot;&gt;配置中心&lt;/h2&gt;
&lt;p&gt;我们可以将系统中通用配置信息写入 ZNode 中，客户端启动时从 Zookeeper 获取配置数据并监视配置节点的变化，当配置发生改变 Zookeeper 会通知所有的客户端获取最新数据，从而实现在线更新配置。&lt;/p&gt;
&lt;p&gt;适合使用Zookeeper维护的配置通常:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据量较小&lt;/li&gt;
&lt;li&gt;在运行时动态发生变化&lt;/li&gt;
&lt;li&gt;各客户端读取到数据需要相同&lt;/li&gt;
&lt;li&gt;具有顺序一致性，客户端只要读取到新版本的数据，此后就不能读取到旧版本数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当服务启动时，服务提供者可以在Zookeeper的相应路径下创建临时节点，并在节点中写入服务配置信息。服务关闭(崩溃)时，临时节点自动删除。&lt;/p&gt;
&lt;p&gt;客户端启动时从 ZooKeeper 读取服务提供者信息从而实现自动的服务发布/移除功能。&lt;/p&gt;
&lt;h2 id=&quot;分布式锁&quot;&gt;分布式锁&lt;/h2&gt;
&lt;p&gt;Zookeeper 的临时节点可以维护客户端持有锁的状态，加锁失败的客户端可以使用 Watch 机制监视锁的释放情况，实现阻塞等待加锁。&lt;/p&gt;
&lt;p&gt;Zookeeper 的顺序节点可以实现一个简单的队列，可以利用此特性实现公平锁。客户端在锁节点下创建顺序子节点，持有最小子节点的客户端成功加锁，加锁失败的客户端 Watch 前一个顺序子节点，从而实现先到先得的公平锁机制。&lt;/p&gt;
&lt;h2 id=&quot;命名服务&quot;&gt;命名服务&lt;/h2&gt;
&lt;p&gt;ZooKeeper 的顺序节点可以生成全局唯一ID, 我们可以利用该ID为服务命名。相对于UUID, 该名称较短且可以保证绝不重复。&lt;/p&gt;
&lt;h2 id=&quot;master选举&quot;&gt;Master选举&lt;/h2&gt;
&lt;p&gt;与分布式公平锁应用类似，ZooKeeper 可以维护集群 Master。&lt;/p&gt;
&lt;p&gt;集群中所有可以成为 Master 的进程都在 Zookeeper 中的指定路径下创建顺序子节点，持有最小子节点的进程成为Master。&lt;/p&gt;
&lt;p&gt;集群中所有进程都 Watch 指定路径下节点的情况，一旦发生变化则重新读取最小子节点的持有者作为Master。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脑裂问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传统集群实现方案是运行一个备用Master节点，备用Master节点定期向主Master节点发送ping请求，若能及时收到主Master的ack响应则认为正常。&lt;/p&gt;
&lt;p&gt;若Ack响应超时，备用Master则会取代原主Master成为新的集群主Master节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/793413/201809/793413-20180924230635896-490517406.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若响应超时因为主Master故障导致，备用Master成为新的主节点完全正常。&lt;/p&gt;
&lt;p&gt;若超时因为主备 Master 节点间 ping-ack 网络故障导致，那么主Master工作正常，而备用Master却误认为主Master崩溃而进行取代，那么集群中可能出现多个Master共存的故障(即脑裂故障)。&lt;/p&gt;
&lt;p&gt;若使用 Zookeeper 维护 Master 信息，无论是因为主Master故障还是通信问题导致最小子节点被删除，备用Master持有的节点都会成为最小子节点。&lt;/p&gt;
&lt;p&gt;此时，所有客户端都会受到通知并得知 Master 变更，保证集群中只有一个 Master。&lt;/p&gt;
&lt;p&gt;当崩溃的Master恢复后，它将成为新的备用Master加入集群。&lt;/p&gt;
&lt;p&gt;ZooKeeper 无法避免通信故障导致误判 Master 状态，但是可以保证在任何情况下集群中只有一个 Master 节点。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 15:07:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<og:description>ZooKeeper Node 与 Watch 概念介绍, 及特性和应用场景简介。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Finley/p/9697237.html</dc:identifier>
</item>
</channel>
</rss>