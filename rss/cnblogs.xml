<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>PC逆向之代码还原技术,第一讲基本数据类型在内存中的表现形式.浮点,指针寻址公式 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/9847574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/9847574.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;h2 id=&quot;一丶简介代码还原&quot;&gt;一丶简介代码还原&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;例子一:我们很多人都学习过汇编.但是汇编的核心知识就是我能看的懂.有人拿汇编去做外挂.比如我去追偏移.看着视频去做.然后换一个游戏依然这样.但是终有一天,你可能发现没意思了.因为这些知识都是死的.比如我们想看游戏中,这段代码做了什么事情.这个时候就需要将汇编转为高级代码查看了. IDA的F5插件.一般能做到.但是很多是做不到的. 比如游戏中.这段代码你找到一个对象+多少偏移是什么什么功能.但是会逆向的人.这段代码抠出来.转为高级代码.一看.原来这个意思.+多少是什么作用.另外还实现了什么功能.这个就是核心技术了.为什么别人的外挂功能比较多.你的比较少.其核心就在这里.&lt;/li&gt;
&lt;li&gt;例子二:算法逆向,如一个软件.让你追出注册码.你可能就爆破.但是如果你能把它算法逆出来.那么是不是第一提升了自己,第二,自己可以写注册机专门为这个程序生成注册码了.&lt;/li&gt;
&lt;li&gt;例子三: 如果你是为公司工作.可能某一天,公司需要你进行逆向.发现xx软件的一个功能比较好.此时你需要怎么办.完整的根据汇编去逆向出来这个功能.并且让公司去做出这个功能.这个也是一个很好的例子.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二丶代码还原中的数据类型表现形式&quot;&gt;二丶代码还原中的数据类型表现形式&lt;/h2&gt;
&lt;p&gt;上面说了很多了,那么真正的开始篇幅讲解.&lt;/p&gt;
&lt;h3 id=&quot;整数类型&quot;&gt;1.整数类型&lt;/h3&gt;
&lt;p&gt;C++中整数的基本数据类型有三种, int long short. 在 VC6.0中,int long所占内存都是4字节.&lt;br/&gt;short两个字节. 以16进制为例 int long 分别就是4个字节. short两个字节. 一个字节是8位.&lt;/p&gt;
&lt;h3 id=&quot;无符号整数&quot;&gt;2.无符号整数&lt;/h3&gt;
&lt;p&gt;在内存中,无符号整数是用来表示数值的.如果32位下.那么取值范围是 0x00000000~0xFFFFFFF&lt;br/&gt;10进制: 0~4294967295,因为无符号数,那么最高位就是0填充.所以表示数值比较大.&lt;/p&gt;
&lt;h3 id=&quot;有符号整数&quot;&gt;3.有符号整数&lt;/h3&gt;
&lt;p&gt;有符号整数跟上面无符号整数一样.只不过高位用来表示符号位,其余低位表示数值.这样有符号的整数.表示的数值就只有31位了.范围则是 0x80000000~0x7FFFFFFF 转为十进制: -2147483648~ 2147483647&lt;br/&gt;因为最高位是符号位,可以表示 负数. 例如 -3&lt;br/&gt;在内存中负数都是补码形式表示的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;补码规则: 补码规则则是用0 - 去这个数的绝对值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如: 0 - 3 的结果就是 -3在内存中的表现形式.&lt;br/&gt;因为补码高位为1,要转为真值也是 0 - 补码的形式. 但是一般计算机计算的话,通常都是用补码取反+1进行获得真值. 前边带上符号即可.&lt;/p&gt;
&lt;p&gt;为什么负数取值总比整数取值多一个值.&lt;br/&gt;例如如上:&lt;br/&gt;-2147483648~2147483647&lt;br/&gt;原因:&lt;br/&gt;对于四个字节补码 0x80000000 代表的是-0. 但是对于0来讲. 正负区分没必要.所以0x800000000规定了就是4字节补码最小值了.所以这也是负数比正数多一位的原因.&lt;/p&gt;
&lt;h3 id=&quot;浮点数数据类型&quot;&gt;4.浮点数数据类型&lt;/h3&gt;
&lt;p&gt;关于浮点数存储.科学上有很多争议.有很多存储实数(小数)的方式.不过很少用了.所以我们也不再介绍了&lt;br/&gt;现在是不管如何存储.都分为 定点实数存储 跟 浮点数实数存储 这两种方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定点实数存储&lt;br/&gt;定点实数存储,就是约定整数位和小数位的长度.比如4个字节为例,高2个字节存储整数.低两个字节存储实数.这样的好处是计算的效率高,缺点是存储不灵活.比如存储65536.5 整数部分已经存储不了65536了.&lt;/li&gt;
&lt;li&gt;浮点实数存储&lt;br/&gt;浮点实数存储就是用一部分二进制位存放小数点的位置信息,我们可以称之为指数域其它的数据位用来存储没有小数点时的数据和符号,我们可以称之为数据域丶符号域&lt;br/&gt;如:&lt;br/&gt;67.625 我们可以使用浮点实数存储, 数据域 可以存放67625 小数位置可以记住位置为 10~-3次方 ,对这个数进行访问的时候.只需要计算一下即可.&lt;br/&gt;优缺点: 优点缺点跟第一种是相反的. 80286CPU之前,程序员常常为实数的计算,伤脑筋.最后出来了浮点协处理器.可以协助CPU计算.程序员计算实数的效率就大大的提高了.于是现在 浮点存储的方式就推广了出来&lt;br/&gt;注意: 现在都是第二种方法进行存储的.不是定点存储方式了&lt;/li&gt;
&lt;li&gt;C++中的浮点&lt;br/&gt;在C++当中,有浮点数 float 以及 double用来存储浮点数. float 4个字节. double 8个字节.&lt;br/&gt;由于double空间大,所以精度高. 两种数据类型在内存中同样的是16进制存储.但是与10进制的16进制不同. float dobule 的16进制比较大.&lt;br/&gt;原因:浮点类型并不是将一个浮点小数直接转为二进制进行存储的.而是将浮点小数转换成二进制,重新编码.再进行存储.C/C++中的浮点数是有符号的.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得注意 浮点数转为整数,并不是四舍五入.而是向0取整. 也就是说舍弃小数位.转为整数.&lt;br/&gt;例如: a = 3.78; int b = (int) a; 此时b的值是3. 而不是传统意义上的 4; 因为不是四舍五入.&lt;/p&gt;
&lt;h3 id=&quot;浮点编码&quot;&gt;5.浮点编码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;浮点编码转换.&lt;br/&gt;我们上面说了,浮点数是重新进行编码进行存储的.所以我们只要搞明白了编码.那么就可以自己算出浮点数在内存中怎么表示.或者反转回来.16进制怎么转换为浮点数&lt;/li&gt;
&lt;li&gt;浮点编码采用的是 IEEE规定的编码.&lt;br/&gt;float double转换方式一样. 都是因为表示范围不一样.所以编码方式有些特别.&lt;/li&gt;
&lt;li&gt;1.浮点编码的编码方式&lt;br/&gt;浮点编码,会将一个浮点数转为二进制数.以科学计数法进行区分.分为三部分&lt;br/&gt;1.符号域&lt;br/&gt;2.指数域&lt;br/&gt;3.尾数域&lt;br/&gt;如下图所示:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201810/1197364-20181024190052538-1026544801.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最高位是符号位,表示正负&lt;br/&gt;去掉符号位往后数8位 是指数域.&lt;br/&gt;最后的23位则表示尾数.&lt;/p&gt;
&lt;h4 id=&quot;正数浮点转为十六进制表示&quot;&gt;1.正数浮点转为十六进制表示&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;2.浮点数转为16进制存储&lt;br/&gt;现在我们要把浮点数转为十六进制存储在内存里.转换步骤&lt;br/&gt;1.将一个浮点数转化为二进制&lt;/p&gt;
&lt;p&gt;例如:12.25 转为2进制 = 1100.01&lt;br/&gt;整数直接转为二进制即可. 小数不断 * 2 取整.&lt;br/&gt;例如: 0.25&lt;br/&gt;0.25 * 2 = 0.5 取整 = 0&lt;br/&gt;0.5 * 2 = 1.0 取整就是1&lt;br/&gt;所有12.25 转为二进制表示就是 1100.01&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.计算指数位&lt;br/&gt;计算指数位首先移动小数点位置到符号位置除最高位为1的地方.&lt;br/&gt;也就是符号位也好.不是符号位也好.移动到最高位为1的地方. 7.25 转换之后是&lt;br/&gt;0111.01 移动到最高位则是 1.1101.&lt;/p&gt;
&lt;p&gt;1100.01 移动 1.10001 总共移动了3位.每次移动一位,指数+1&lt;br/&gt;因为指数为移动了三位.所以 3 + 127(8位) = 130 转为二进制 10000010 这个就是指数位.&lt;br/&gt;也就是上图中所说的符号位后面数8位是指数位. 我们上边计算的就是指数位的值.&lt;br/&gt;为什么 +127.因为可能会出现负数.十进制127可以表示二进制的01111111. IEEE浮点编码规定&lt;br/&gt;当指数域&amp;lt; 0111111的时候,就是一个负数.如果大于01111111的时候就是一个正数. 所以01111111为0. IEEE浮点编码规定的.所以只要记住即可. 127即可. 也可以理解为指数域是8位,表示的数值是128.但IEE规定了.所以-1 指数最大值 - 1即可.&lt;/p&gt;
&lt;p&gt;3.计算尾数位&lt;br/&gt;经过上面计算我们符号是1,但是符号位基本不变.因为是正数浮点.所以符号位为0:&lt;br/&gt;指数位为: 130 10000010&lt;br/&gt;现在计算尾数位. 尾数位就是我们移动小数点之后的数值&lt;/p&gt;
&lt;p&gt;1.10001 尾数位就是 10001,但是他不组23位.所以我们补0填充.&lt;/p&gt;
&lt;p&gt;1000 1000 0000 0000 0000 000 补0之后,我们需要从左到右,按照4个字节分开&lt;br/&gt;100 0100 0000 0000 0000 0000 分开之后.&lt;br/&gt;此时加上我们之前的符号位以及指数位&lt;/p&gt;
&lt;p&gt;0100 0001 0100 0100 0000 0000 0000 0000 这是拼接好的.我们转换为16进制进行存储&lt;br/&gt;0x41440000 那么在内存中,我们的浮点数12.25 其实就是16进制 0x41 44 00 00 进行存储的.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201810/1197364-20181024193331351-903793462.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;负数浮点转为十六进制表示.&quot;&gt;2.负数浮点转为十六进制表示.&lt;/h4&gt;
&lt;p&gt;负数跟上边一样.一样计算指数位.也是分为以下步骤&lt;br/&gt;1.转为科学计数法.&lt;br/&gt;2.移动指数位.&lt;br/&gt;3.计算指数位&lt;br/&gt;4.尾数位补零到23位.&lt;br/&gt;5.拼接进行二进制,并且二进制转为16进制.&lt;/p&gt;
&lt;p&gt;1.转为科学计数法&lt;br/&gt;-0.125 = 0.001&lt;br/&gt;2.移动指数位&lt;br/&gt;此时移动指数位是往小数点右边移动,移动到最高位为1的地方.&lt;br/&gt;0.001 =&amp;gt;1.0 移动了三位,计算 -3. 往右边移动就是负数&lt;br/&gt;1.0 则符号位是1代表负数. 指数位是负数.&lt;/p&gt;
&lt;p&gt;3.计算指数位.&lt;br/&gt;上面我们计算指数位是往小数点左边移动.所以指数位去相加.现在是往右边移动.所以相减&lt;br/&gt;127-3 = 124 转为二进制 = 01111100&lt;br/&gt;4.尾数位补零&lt;br/&gt;0000 0000 0000 0000 0000 000&lt;br/&gt;5.符号位 指数位 尾数位 进行拼接&lt;/p&gt;
&lt;p&gt;1011 1110 0000 0000 0000 0000 0000 0000 (总共32位)&lt;br/&gt;转为16进制&lt;br/&gt;0xBE00 0000&lt;br/&gt;所以-0.125 在内存中的16进制则是 0xBE000000&lt;/p&gt;
&lt;h4 id=&quot;正数浮点16进制转为浮点数解析&quot;&gt;3.正数浮点16进制转为浮点数解析&lt;/h4&gt;
&lt;p&gt;我们会转换为16进制那么也要回转换回来&lt;br/&gt;1.16进制拆分为2进制.&lt;br/&gt;2.分出符号位 指数位 尾数位&lt;br/&gt;3.求指数位是负数还是整数&lt;br/&gt;4.移动指数位&lt;/p&gt;
&lt;p&gt;比如我们的12.25f. 十六进制是x41440000&lt;br/&gt;1.16进制转为2进制&lt;br/&gt;0100 0001 0100 0100 0000 0000 0000 0000&lt;br/&gt;2.分出符号位 指数位 尾数位&lt;br/&gt;0 10000010 10001000000000000000000&lt;br/&gt;3.求出指数位&lt;br/&gt;指数位位 10000010 &amp;gt; 01111111 所以可以判断我们的小数是正数&lt;br/&gt;10000010 - 01111111 = 130 - 127 = 3;&lt;br/&gt;得出了我们要移动的位数&lt;br/&gt;4.移动指数位&lt;br/&gt;首先计算出的指数转为2进制 3 = 0011;&lt;/p&gt;
&lt;p&gt;然后反过来.尾数位右移动三位.如下.&lt;br/&gt;100010 &amp;gt;&amp;gt; 3 = 100.010 尾数的最高位不需要.所以补零&lt;/p&gt;
&lt;p&gt;然后加上符号位.&lt;br/&gt;符号位为0.代表是正数.所以+1&lt;br/&gt;1100.010&lt;br/&gt;再举个例子&lt;br/&gt;7.25 在内存的16进制为0x40E8&lt;br/&gt;1.16进制转为二进制&lt;br/&gt;0100 0000 1110 1000 0000 0000 .....&lt;br/&gt;2.计算指数位,尾数需要往右移动纪委&lt;br/&gt;10000001 - 01111111 = 129 - 127 = 2;得出移动2位&lt;br/&gt;3.移动尾数位&lt;br/&gt;因为高位为0,所以代表我们转换的浮点数是正数.最后我们的高位要加上1才可以.&lt;br/&gt;11010 ==&amp;gt;2位 = 11.010&lt;br/&gt;符号位为0.所以高位补1&lt;br/&gt;111.01 这个二进制在转换为10进制得出7.25&lt;/p&gt;
&lt;p&gt;小数转为10进制:&lt;br/&gt;.01是是两位. 分别记位 2的-1次方 2-2次方.&lt;br/&gt;第一位计算: 0 * 1/2-1次方.&lt;br/&gt;第二位计算: 1 * 1/2-2次方即可.&lt;br/&gt;最后结果相加.&lt;br/&gt;如果有三位.那么就是 用第三位数值 * 1/2-3次方即可.&lt;br/&gt;0&lt;em&gt;1/2 + 1&lt;/em&gt; 1/4 = 0.25.所以我们可以推算出是0.25&lt;/p&gt;
&lt;h3 id=&quot;double类型解析.&quot;&gt;4.Double类型解析.&lt;/h3&gt;
&lt;p&gt;double类型转换跟float一样.只不过指数位变成了11位. 剩余的42位表示尾数位.&lt;/p&gt;
&lt;p&gt;2~11次方 - 1;就是用于计算的指数.也就是 1023.&lt;/p&gt;
&lt;h2 id=&quot;三丶浮点汇编&quot;&gt;三丶浮点汇编&lt;/h2&gt;
&lt;h3 id=&quot;浮点栈&quot;&gt;1.浮点栈&lt;/h3&gt;
&lt;p&gt;因为有了浮点协处理器.所以浮点指令的操作有点不同.它是通过浮点寄存器来实现的.&lt;br/&gt;浮点寄存器是通过栈结构来实现的.也称作浮点栈. 由 st(0) - st(7); 其中写st默认就是st(0)&lt;br/&gt;操作任意浮点栈就需要加上序号 st(7);&lt;br/&gt;值得注意的是浮点栈是循环栈. 也就是说st(0)出栈的数据.会放到st(7)中.这样依次使用.&lt;/p&gt;
&lt;h3 id=&quot;浮点汇编&quot;&gt;2.浮点汇编&lt;/h3&gt;
&lt;p&gt;针对协处理器.也提供的相应的汇编进行操作.&lt;br/&gt;分别是 fld类指令 fst 指令. 以及 fcom fadd等指令&lt;br/&gt;都是大写&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;压栈指令&lt;br/&gt;FLD IN 将浮点数IN 压入浮点栈&lt;br/&gt;FILD IN 将整数压入浮点栈 mem32/64 80&lt;br/&gt;FLDZ 默认压入0,浮点栈是0&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;出栈指令&lt;br/&gt;FST OUT 将浮点栈顶(st(0))的值给OUT存储. out可以是 mem32/64,但是不出栈&lt;br/&gt;FSTP OUT 同FST out保存值,但是会出栈.&lt;br/&gt;FISTP OUT 出栈,并且以整数的形式给OUT存储.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;栈比较&lt;br/&gt;也可以进行栈中的值比较.用来更改标志位.&lt;br/&gt;FCOM IN 将IN地址的内容.与浮点栈顶比较(st(0));&lt;br/&gt;FTST 比较栈顶(st(0)); 是否为空.&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;浮点加法&lt;br/&gt;FADD IN 将St(0)的数据于in做加法. 值保存在 栈顶st(0);中.&lt;br/&gt;FADDP st(N),st 将st(n)栈中的数据于st(0)中的数据进行运算.浮点栈有7个.那么N的取值就是0~7;&lt;br/&gt;先执行一次出栈冬枣.然后相加结果放在 st(0)中存储.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用内联浮点汇编实现加法&quot;&gt;3.使用内联浮点汇编实现加法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;浮点做加法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;int main(int argc, char* argv[])
{
    float a = 11.25;
    float c = 12.35;
    float d = 13.25f;
    float b = 0.0f;
    __asm{
        fld dword ptr[ebp - 0x4];
        fld dword ptr[ebp - 0x8];
        fld dword ptr[ebp - 0xc];
        faddp st(1),st(0)
        fstp  dword ptr[ebp - 0x10];
    }
    printf(&quot;%f \r\n&quot;,b);
    
    return 0; 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现结果:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201810/1197364-20181025015243872-1366126688.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浮点做返回值&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;float GetFloatValue()
{   
    return 12.25f;

}
int main(int argc, char* argv[])
{
    int value = GetFloatValue();
    
    return 0; 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观看汇编,汇编分为两层.一层是调用内.一层是调用外.&lt;br/&gt;调用内: 也就是GetFloatValue()函数内部.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   push        ebp
   mov         ebp,esp
   sub         esp,40h
   push        ebx
   push        esi
   push        edi
   lea         edi,[ebp-40h]
   mov         ecx,10h
   mov         eax,0CCCCCCCCh
   rep stos    dword ptr [edi]
   fld         dword ptr [__real@4@4002c400000000000000 (00423fd0)]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要看最后一样. fld 内存的值. 其实就是把我们的浮点数转为IEE编码.放到内存中.&lt;br/&gt;其实就是放到内存中.&lt;/p&gt;
&lt;p&gt;外层调用: 就是调用完毕之后.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0040EB1D   call        __ftol (004010ec)
0040EB22   mov         dword ptr [ebp-4],eax
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用完毕之后,会使用 _ftol. 浮点数转为整数进行转化.下面的返回值放到我们的局部变量中&lt;br/&gt;所以以后看到这样操作.我们就要明白. 返回值是float或者double类型.进行了转换.&lt;br/&gt;_ftol内部&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;004010EC   push        ebp
004010ED   mov         ebp,esp
004010EF   add         esp,0F4h
;浮点异常检查
004010F2   wait
004010F3   fnstcw      word ptr [ebp-2]
004010F6   wait
004010F7   mov         ax,word ptr [ebp-2]
004010FB   or          ah,0Ch
004010FE   mov         word ptr [ebp-4],ax
00401102   fldcw       word ptr [ebp-4]
;从str(0)中取出八个字节放到局部变量 ebp -och中. 所以后面是qword ptr代表8个字节.
;将st(0);从栈中弹出.
00401105   fistp       qword ptr [ebp-0Ch]
00401108   fldcw       word ptr [ebp-2]
;下方 eax edx同用,eax保存4字节的整数部分. edx则保存小数部分.
0040110B   mov         eax,dword ptr [ebp-0Ch]
0040110E   mov         edx,dword ptr [ebp-8]
平展返回.
00401111   leave
00401112   ret&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内部则是进行浮点转化.比较等等.&lt;/p&gt;
&lt;h2 id=&quot;四丶布尔类型&quot;&gt;四丶布尔类型&lt;/h2&gt;
&lt;p&gt;布尔类型就是0 跟 1 表示.在内存中就是这样的表示形式. 0就是 false 1就是true&lt;/p&gt;
&lt;h2 id=&quot;地址丶指针丶引用表达形式&quot;&gt;地址丶指针丶引用表达形式&lt;/h2&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;地址&lt;br/&gt;在C++中,使用地址需要使用&amp;amp;取地址符号. 取一个变量所在的内存地址.&lt;/li&gt;
&lt;li&gt;指针&lt;br/&gt;指针的本质就是存储地址的.只不过有类型一说.表示我已什么方式存储这个地址. 比如&lt;br/&gt;char szBuff[10] = {1,2,3...};&lt;br/&gt;char &lt;em&gt;sz = szBuffer; 那么sz保存的是szBuffer的地址.只不过a按照1个字节解释.&lt;br/&gt;比如 sz++,因为是char类型.所以地址就是+1, 如果是int类型解释+1就是+4个字节.&lt;br/&gt;如果对其去内容&lt;/em&gt; sz那么此时的值是2.因为是char &lt;em&gt;类型解释的地址 sz++&lt;/em&gt; sz就是3&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;引用&lt;br/&gt;在C++中,创建引用 TYPE &amp;amp; a = szBuffer; 创建引用的时候必须给变量给初始化.&lt;br/&gt;本质就是一个变量的别名.在内存中其实就是对地址 取内容的操作.&lt;/p&gt;
&lt;h3 id=&quot;指针的寻址方式&quot;&gt;1.指针的寻址方式&lt;/h3&gt;
&lt;p&gt;关于指针.我们说过有不同的表达形式. 例如 BYTE * short &lt;em&gt;...&lt;br/&gt;因为指针有不同的表达形式.所以自增自减都会产生偏移计算.&lt;br/&gt;例如:&lt;br/&gt;mov eax,byte ptr[ebp - 0xc];&lt;br/&gt;mov ebx,byte ptr[ebp - 0xb];&lt;br/&gt;mov ecx,byte ptr[ebp - 0xa];&lt;br/&gt;....&lt;br/&gt;所以我们可以总结一条寻址公式&lt;br/&gt;目的地址 = 首地址 + sizeof(type)&lt;/em&gt; n的值.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目的地址就是我们要进行寻址目的.&lt;br/&gt;sizeof(type) 就是你的数据类型大小&lt;br/&gt;n的值就是你的偏移量.&lt;br/&gt;例如一个数组:&lt;br/&gt;char szBuf[10] = {1,2...7,8,9,10};&lt;br/&gt;我们想要得到下标为8的位置的的值怎么获得.&lt;br/&gt;高级代码: int a = szbuf[8];完了.&lt;br/&gt;因为有公式,我们可以不用这样写.&lt;br/&gt;写成如下:&lt;br/&gt;目的地址 = 首地址 + sizeof(type) *n; 套公式&lt;/p&gt;
&lt;p&gt;szbuffer = szbuffer + sizeof(char) * 8;&lt;br/&gt;此时szBuffer的地址就是指向数组下表为8的位置.我们对其取内容即可获取其值.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int main(int argc, char* argv[])
{
    char szBuf[10] = {1,2,3,4,5,6,7,8,9,10};
    char *dst = szBuf + sizeof(char) * 8;
    printf(&quot;Value = %d\r\n&quot;,*dst);
    system(&quot;pause&quot;);
    
    return 0; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201810/1197364-20181025022807543-1067982908.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Oct 2018 18:27:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>[toc] 代码还原技术 一丶简介代码还原 例子一:我们很多人都学习过汇编.但是汇编的核心知识就是我能看的懂.有人拿汇编去做外挂.比如我去追偏移.看着视频去做.然后换一个游戏依然这样.但是终有一天,你</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/9847574.html</dc:identifier>
</item>
<item>
<title>Go基础系列(4)：导入包和初始化阶段 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9847554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9847554.html</guid>
<description>&lt;h2 id=&quot;import导入包&quot;&gt;import导入包&lt;/h2&gt;
&lt;h3 id=&quot;搜索路径&quot;&gt;搜索路径&lt;/h3&gt;
&lt;p&gt;import用于导入包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;mypkg&quot;
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译器会根据上面指定的相对路径去搜索包然后导入，这个相对路径是从GOROOT或GOPATH(workspace)下的src下开始搜索的。&lt;/p&gt;
&lt;p&gt;假如go的安装目录为&lt;code&gt;/usr/local/go&lt;/code&gt;，也就是说&lt;code&gt;GOROOT=/usr/local/go&lt;/code&gt;，而GOPATH环境变量&lt;code&gt;GOPATH=~/mycode:~/mylib&lt;/code&gt;，那么要搜索&lt;code&gt;net/http&lt;/code&gt;包的时候，将按照&lt;strong&gt;如下顺序&lt;/strong&gt;进行搜索：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/usr/local/go/srcnet/http
~/mycode/src/net/http
~/mylib/src/net/http&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是&lt;code&gt;go install&lt;/code&gt;搜索不到mypkg包时的一个报错信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;can't load package: package mypkg: cannot find package &quot;mypkg&quot; in any of:
        /usr/lib/go-1.6/src/mypkg (from $GOROOT)
        /golang/src/mypkg (from $GOPATH)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，go总是先从&lt;code&gt;GOROOT&lt;/code&gt;出先搜索，再从&lt;code&gt;GOPATH&lt;/code&gt;列出的路径顺序中搜索，只要一搜索到合适的包就理解停止。当搜索完了仍搜索不到包时，将报错。&lt;/p&gt;
&lt;p&gt;包导入后，就可以使用这个包中的属性。使用&lt;code&gt;包名.属性&lt;/code&gt;的方式即可。例如，调用fmt包中的Println函数&lt;code&gt;fmt.Println&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;包导入的过程&quot;&gt;包导入的过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201810/733013-20181023224911978-1960747966.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先从main包开始，如果main包中有import语句，则会导入这些包，如果要导入的这些包又有要导入的包，则继续先导入所依赖的包。重复的包只会导入一次，就像很多包都要导入fmt包一样，但它只会导入一次。&lt;/p&gt;
&lt;p&gt;每个被导入的包在导入之后，都会先将包的可导出函数(大写字母开头)、包变量、包常量等声明并初始化完成，然后如果这个包中定义了init()函数，则自动调用init()函数。init()函数调用完成后，才回到导入者所在的包。同理，这个导入者所在包也一样的处理逻辑，声明并初始化包变量、包常量等，再调用init()函数(如果有的话)，依次类推，直到回到main包，main包也将初始化包常量、包变量、函数，然后调用init()函数，调用完init()后，调用main函数，于是开始进入主程序的执行逻辑。&lt;/p&gt;
&lt;h3 id=&quot;别名导入和特殊的导入方法&quot;&gt;别名导入和特殊的导入方法&lt;/h3&gt;
&lt;p&gt;当要导入的包重名时会如何？例如&lt;code&gt;network/convert&lt;/code&gt;包用于转换从网络上读取的数据，&lt;code&gt;file/convert&lt;/code&gt;包用于转换从文件中读取的数据，如果要同时导入它们，当引用的时候指定&lt;code&gt;convert.FUNC()&lt;/code&gt;，这个convert到底是哪个包？&lt;/p&gt;
&lt;p&gt;可以为导入的包添加一个名称属性，为包设置一个别名。例如，除了导入标准库的fmt包外，自己还定义了一个mypkg/fmt包，那么可以如下导入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    myfmt &quot;mypkg/fmt&quot;
)

func main() {
    fmt.Println()
    myfmt.myfunc()   // 使用别名进行访问
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不想在访问包属性的时候加上包名，则import导入的时候，可以为其设置特殊的别名：点(.)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import (
    . &quot;fmt&quot;
)

func main() {
    Println()    // 无需包名，直接访问Println
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时要访问fmt中的属性，&lt;strong&gt;必须&lt;/strong&gt;不能使用包名fmt。&lt;/p&gt;
&lt;p&gt;go要求import导入的包必须在后续中使用，否则会报错。如果想要避免这个错误，可以在包的前面加上下划线：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import (
    &quot;fmt&quot;
    _ &quot;net/http&quot;
    &quot;mypkg&quot;
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在当前包中就无需使用&lt;code&gt;net/http&lt;/code&gt;包。其实这也是为包进行命名，只不过命名为&quot;_&quot;，而这个符号又正好表示丢弃赋值结果，使得这成为一个匿名包。&lt;/p&gt;
&lt;blockquote readability=&quot;5.8819444444444&quot;&gt;
&lt;p&gt;**下划线(_)**&lt;br/&gt;在go中，下划线出现的频率非常高，它被称为blank identifier，可以用于赋值时丢弃值，可以用于保留import时的包，还可以用于丢弃函数的返回值。详细内容可参见官方手册：&lt;a href=&quot;https://golang.org/doc/effective_go.html#blank&quot; class=&quot;uri&quot;&gt;https://golang.org/doc/effective_go.html#blank&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;导入而不使用看上去有点多此一举，但并非如此。因为导入匿名包仅仅表示无法再访问其内的属性。但导入这个匿名包的时候，会进行一些初始化操作(例如init()函数)，如果这个初始化操作会影响当前包，那么这个匿名导入就是有意义的。&lt;/p&gt;
&lt;h2 id=&quot;远程包&quot;&gt;远程包&lt;/h2&gt;
&lt;p&gt;现在通过分布式版本控制系统进行代码共享是一种大趋势。go集成了从gti上获取远程代码的能力。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go get github.com/golang/example&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在import语句中也可以使用，首先从GOPATH中搜索路径，显然这是一个URL路径，于是调用go get进行fetch，然后导入。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import (
    &quot;fmt&quot;
    &quot;github.com/golang/example&quot;
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当需要从git上获取代码的时候，将调用&lt;code&gt;go get&lt;/code&gt;工具自动进行fetch、build、install。如果workspace中已经有这个包，那么将只进行最后的install阶段，如果没有这个包，将保存到GOPATH的第一个路径中，并build、install。&lt;/p&gt;
&lt;p&gt;go get是递归的，所以可以直接fetch整个代码树。&lt;/p&gt;
&lt;h2 id=&quot;常量和变量的初始化&quot;&gt;常量和变量的初始化&lt;/h2&gt;
&lt;p&gt;Go中的常量在编译期间就会创建好，即使是那些定义为函数的本地常量也如此。常量只允许是数值、字符(runes)、字符串或布尔值。&lt;/p&gt;
&lt;p&gt;由于编译期间的限制，定义它们的表达式必须是编译器可评估的常量表达式(constant expression)。例如，&lt;code&gt;1&amp;lt;&amp;lt;3&lt;/code&gt;是一个常量表达式，而&lt;code&gt;math.Sin(math.Pi/4)&lt;/code&gt;则不是常量表达式，因为涉及了函数math.Sin()的调用过程，而函数调用是在运行期间进行的。&lt;/p&gt;
&lt;p&gt;变量的初始化和常量的初始化差不多，但初始化的变量允许是&quot;需要在执行期间计算的一般表达式&quot;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var (
    home   = os.Getenv(&quot;HOME&quot;)
    user   = os.Getenv(&quot;USER&quot;)
    gopath = os.Getenv(&quot;GOPATH&quot;)
)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;init函数&quot;&gt;init()函数&lt;/h2&gt;
&lt;p&gt;Go中除了保留了main()函数，还保留了一个init()函数，这两个函数都不能有任何参数和返回值。它们都是在特定的时候自动调用的，无需我们手动去执行。&lt;/p&gt;
&lt;p&gt;还是这张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201810/733013-20181023224911978-1960747966.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个包中都可以定义init函数，甚至可以定义多个，但建议每个包只定义一个。每次导入包的时候，在导入完成后，且变量、常量等声明并初始化完成后，将会调用这个包中的init()函数。&lt;/p&gt;
&lt;p&gt;对于main包，如果main包也定义了init()，那么它会在main()函数之前执行。当main包中的init()执行完之后，就会立即执行main()函数，然后进入主程序。&lt;/p&gt;
&lt;p&gt;所以，init()经常用来初始化环境、安装包或其他需要在程序启动之前先执行的操作。如果import导入包的时候，发现前面命名为下划线&lt;code&gt;_&lt;/code&gt;了，一般就说明所导入的这个包有init()函数，且导入的这个包除了init()函数外，没有其它作用。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Oct 2018 17:41:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>import导入包 搜索路径 import用于导入包： 编译器会根据上面指定的相对路径去搜索包然后导入，这个相对路径是从GOROOT或GOPATH(workspace)下的src下开始搜索的。 假如g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9847554.html</dc:identifier>
</item>
<item>
<title>WPF 内存泄漏优化经历 - Johar</title>
<link>http://www.cnblogs.com/Johar/p/9847163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johar/p/9847163.html</guid>
<description>&lt;p&gt;最近公司有个CS客户端程序，有个登录界面，有个程序的主界面，程序支持注销功能，但是在注销后，客户端的内存一直以40M-50M的速度递增，因此猜测，应该是WPF程序出现了内存泄漏。下面主要记录优化内存泄漏的整个历程：&lt;/p&gt;
&lt;p&gt;1.使用VS2013的性能和诊断找到问题点&lt;/p&gt;
&lt;p&gt;在VS2013菜单分析-》性能和诊断，打开的界面如下，并勾选内存使用率选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436823/201810/436823-20181025001806880-837477016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击开始，启动程序，界面如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436823/201810/436823-20181025002014672-774855134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;登录后，等待程序资源全部获取后，单击VS2013中拍摄快照&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436823/201810/436823-20181025002235909-2119412534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注销后，再次单击拍摄快照按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436823/201810/436823-20181025002402083-531109591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重复上述两个步骤若干次后，关闭软件，内存分析工具会自动进行分析，分析后的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436823/201810/436823-20181025002651560-1388315295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择快照报告数据查看依据，托管堆和堆，我写的程序中是在堆中发现快照2比快照会有40多M内存的上升，上面的图片是优化后的。点击上升的内存，可以进入快照1和快照2内存的对比的表格：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436823/201810/436823-20181025003121282-1974061049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从这个前后内存的对比中，找到是由于主界面的在注销时关闭，再次登录后，主界面重新创建显示，里面ocx的内存发生泄漏。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Oct 2018 16:34:00 +0000</pubDate>
<dc:creator>Johar</dc:creator>
<og:description>最近公司有个CS客户端程序，有个登录界面，有个程序的主界面，程序支持注销功能，但是在注销后，客户端的内存一直以40M-50M的速度递增，因此猜测，应该是WPF程序出现了内存泄漏。下面主要记录优化内存泄</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Johar/p/9847163.html</dc:identifier>
</item>
<item>
<title>Requests爬虫 - 渔单渠</title>
<link>http://www.cnblogs.com/yudanqu/p/9847048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudanqu/p/9847048.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;之前写过一个urllib的爬虫方法，这个库是python内建的，从那篇文章也可以看到，使用起来很繁琐。现在更流行的一个爬虫库就是requests，他是基于urllib3封装的，也就是将之前比较繁琐的步骤封装到一块，更适合人来使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该库中主要有7个方法：request() get() head() post() put() patch() delete()   他们的作用也就是他们的字面意思（例如：get获取网页信息，post提交信息等等），具体的可以自行查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面先从最简单的使用开始，尽可能的用例子展示他都可以干什么。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; r = requests.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.icourse163.org/home.htm?userId=1021614219#/home/course&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; get方法，从网页上获取信息&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; r.status_code  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; http请求的返回状态，为200时表示正常访问&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(r.encoding)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从HTTPheader中猜测的响应内容编码方式&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(r.apparent_encoding)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从内容分析出响应内容编码方式（备选编码方式）&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上面使用get方法就已经得到了网页信息，返回值时200。r字母代表着response，也就是访问网页的响应。网页内的信息可能会有汉字等等，为了方便以后使用，在开始就先说明一下这个，encoding和apparent_encoding在上面解释了，最后是为了使用一个可以把网页正确解析的编码格式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般来说，可以使用r.encoding = 'utf-8'或者r.encoding = r.apparent_encoding。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 已经访问到了网页，那么就要看一下提取到的内容&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; r.text  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; http响应内容的字符串形式，url对应的页面内容&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; r.headers  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回响应的头部信息&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; r.content  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; http响应内容的二进制形式&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; r.json  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回json格式，需要提前导入json包&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　其中二进制格式，可以方便的存储一些图片格式等等的数据，例如需要下载一个照片，可以使用‘wb’格式写到文件当中，当然也可以直接使用库中的方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　在我们爬取一些网页的时候，经常会遇到一系列的问题，访问不到页面，禁止访问之类的，或者一些自身代码的一些问题。如果代码量很多，或者具体一点，比如正在从网站爬取一些照片。当跑到其中一张图片时没有正常的访问到，那么整个程序就卡在这里了。后续的照片也就无法爬取了。这当然不是我们想要的，因此就需要一些对异常的处理，让他出现异常时，继续执行后续的程序。异常捕获在python的基础里面已经有了，就是用那个在这里应用一下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; requests.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ReadTimeout, ConnectionError, RequestException
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     response = requests.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://httpbin.org/get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, timeout = 0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response.status_code)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; ReadTimeout:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Timeout&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; ConnectionError:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Connection error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; RequestException:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　如果是刚接触的人可能看到这么多长串的字符有些记不清，其实也可以先不去管他是什么样的异常，只要是异常就反馈回来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　response.raise_for_status()   这个方法可以捕获异常，使得出现异常时就会跳到except中执行，而不影响整体进程。下面是一个通用的格式来捕获异常。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getHtmlText(url):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         r =&lt;span&gt; requests.get(url)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         r.raise_for_status()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果状态不是200，引发HTTPError异常&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         r.encoding = r.apparent_encoding  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不论headers中是否要求编码格式，都从内容中找到实际编码格式，确保顺利解码&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r.text
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;产生异常&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(getHtmlText(url))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　爬取京东上面商品的页面。理一下思路：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先要导入网络请求的包（requests）--&amp;gt;通过get方法访问网页--&amp;gt;捕获一下异常看看是否正常访问到页面--&amp;gt;如果返回200，确定编码格式--&amp;gt;通过response.text查看一下得到的内容是不是想要的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://item.jd.com/8578888.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     r =&lt;span&gt; requests.get(url)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    r.raise_for_status()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     r.encoding =&lt;span&gt; r.apparent_encoding
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(r.text[:500])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 由于网页内容比较多，[:500] 表示只看其从0到500个字节的内容&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;爬取失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　上面访问的网站并没有什么防护，但是现在越来越多的网站都是有各种各样的反爬虫机制，其中一种简单的方法就是通过发送请求时头文件中的内容来判断。通过response.headers可以找到访问时候的User-Agent为requests，也就是告诉网站是通过爬虫来访问的。这么明显，当然有些网站会阻止访问。这时候有一个办法，就是用一个浏览器来模拟一下，替换掉User-Agent中的内容。网上搜会有很多，或者直接从你电脑上的浏览器中检查，来查看你的浏览器在访问网页时显示的User-Agent是什么样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过headers，传入一个字典，例如：{&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 OPR/26.0.1656.60&quot;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实，如果还不放心的话，可以搜一些User-Agent，每次通过随机抽取其中的一个来访问网页，来避免被网站发现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面套用上面给出的框架来写这个爬虫：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟浏览器爬取信息&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.amazon.cn/dp/B074BNFY1H/ref=cngwdyfloorv2_recs_0?pf_rd_p=d0690322-dfc8-4e93-ac2c-8e2eeacbc49e&amp;amp;pf_rd_s=desktop-2&amp;amp;pf_rd_t=36701&amp;amp;pf_rd_i=desktop&amp;amp;pf_rd_m=A1AJ19PSB66TGU&amp;amp;pf_rd_r=2JDNVB7YD5ZF07YQSRQ6&amp;amp;pf_rd_r=2JDNVB7YD5ZF07YQSRQ6&amp;amp;pf_rd_p=d0690322-dfc8-4e93-ac2c-8e2eeacbc49e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     headers = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 OPR/26.0.1656.60&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     r = requests.get(url, headers =&lt;span&gt; headers)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(r.request.headers) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 起初发现503错误，因为亚马逊会限制爬虫，当使用爬虫时，会在头部显示request代理。因此用一个新的user-agent代替原来的&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    r.raise_for_status()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     r.encoding =&lt;span&gt; r.apparent_encoding
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(r.text[:500&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;爬取失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当访问长时间未响应时就不再等待，因为毕竟爬虫时为了提高效率&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; requests.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ReadTimeout
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     response = requests.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://httpbin.org/get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, timeout = 0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    response.raise_for_status()
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Timeout&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在访问网站时有可能你没有遵守该robots协议，面临被封IP的风险，这样该IP就不能再访问了，大概过段时间才把你从黑名单中拿出来，这时候就用到了IP代理，这个大概介绍一下，因为本人也是初学，能力有限&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; proxies =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;***************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; response = requests.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.taobao.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, proxies=&lt;span&gt;proxies)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(response.status_code)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　这是浏览器缓存，就是我们在之前访问过该网站后，后留下一下脚印，例如之前请求到的一些信息，或者提交，比如需要登录的网站，短时间内再次进入时候不需要再次输入账户密码。因此http请求要从很远的服务器中拉取你要的信息，当然效率不会很高，所以，他就会在本地的浏览器中暂且保留一段时间的信息，这段时间内登录就是从本地来得到网页响应，也会相对快一些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在爬虫的时候，尤其是需要登录才能访问的页面，为了让他可以自动化的一直爬取信息，就可以预先找到登录后在该网页留下的脚印，来放到你的爬虫里，让其自动登录爬取。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; response = requests.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(response.cookies)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以直接调用方法得到当前访问页面时的cookie&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在需要登录的网页时，我们需要同时请求多个端口来实现，可以用到requests.session()，看一个例子体会一下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; s =&lt;span&gt; requests.Session()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; s.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/cookies/set/****/*****&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; response = s.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/cookies&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在访问页面的同时打开之前的cookie请求。如果使用requests的get方法的话，你会发现，第一次请求之后，第二次的get是开启的一个新的请求，而不是针对同一个对象，因此不能实现&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(response.text)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这点东西并没有讲清楚，待我再好好学一下再解释。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 24 Oct 2018 16:03:00 +0000</pubDate>
<dc:creator>渔单渠</dc:creator>
<og:description>一、request入门 之前写过一个urllib的爬虫方法，这个库是python内建的，从那篇文章也可以看到，使用起来很繁琐。现在更流行的一个爬虫库就是requests，他是基于urllib3封装的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudanqu/p/9847048.html</dc:identifier>
</item>
<item>
<title>Windows与Linux相互远程桌面连接 - Surpassme</title>
<link>http://www.cnblogs.com/surpassme/p/9847001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surpassme/p/9847001.html</guid>
<description>&lt;p&gt;    对于远程桌面连接Linux，大家可能会第一时间想到使用VNC,，远程桌面Windows，大家第一时间会想到使用Windows自带的远程桌面。那么有没有办法，使得在Linux中可以远程Windows，在Windows中远程桌面Linux？今天就跟大家一起探讨一下Linux与Windows相互远程。以CentOS6.6为例，步骤如下所示：&lt;/p&gt;
&lt;h4 id=&quot;使用windows远程桌面连接linux&quot;&gt;使用Windows远程桌面连接Linux&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、检查服务器是否安装GNome&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# rpm -qa | grep desktop&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果在查询的结果中未出现gnome-desktop，则需要配置安装源，安装GNOME图形界面，命令：yum -y groupinstall &quot;X Window System&quot; &quot;Chinese Support&quot; &quot;Desktop&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;2、安装VNCServer，并进行配置VNCServer和设置密码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# rpm -ivh tigervnc-server-1.1.0-18.el6.x86_64.rpm #本地安装VNCServer
[root@admin /]# vncpasswd #设置VNC登录密码
[root@admin /]# vim /etc/sysconfig/vncservers #修改配置VNC
[root@admin /]# chkconfig vncserver on #配置开机启动
[root@admin /]# service vncserver restart #启动VNC服务&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[root@admin /]# yum -y install epel-release&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;5、安装xrdp&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# yum -y install xrdp&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;6、修改xrdp配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# vim /etc/xrdp/xrdp.ini
max_bpp=32 #将默认的24修改为32&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;7、启动xrdp服务并设置为开机启动&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /] chkconfig xrdp on
[root@admin /] service xrdp start&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以上均为在线安装，如需要离线安装，可到网站中：http://www.rpmfind.net/ 搜索xrdp选择适合自己系统的版本下载&lt;br/&gt;[root@admin /] rpm -ivh xrdp-0.6.1-5.el6.x86_64.rpm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;8、测试远程桌面&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-7a0ebf14973ef55e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;01Windows远程Linux桌面.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用linux远程桌面连接windows&quot;&gt;使用Linux远程桌面连接Windows&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、确认Linux已经安装GNome图形桌面&lt;/li&gt;
&lt;li&gt;2、配置需要被远程的Windows允许远程桌面连接&lt;/li&gt;
&lt;li&gt;3、在Windows防火墙中放行远程桌面端口（Windows默认端口为3389）&lt;/li&gt;
&lt;li&gt;4、在Linux安装远程连接包&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# yum -y install rdesktop
[root@admin /]# yum -y install tsclient&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;5、在&lt;strong&gt;应用程序&lt;/strong&gt;-&amp;gt;&lt;strong&gt;Internet&lt;/strong&gt;-&amp;gt;打开&lt;strong&gt;终端服务器客户机&lt;/strong&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;6、点击&lt;strong&gt;Add Connection&lt;/strong&gt;，选择&lt;strong&gt;Windows Terminal Service&lt;/strong&gt;，依次填写Name、Host、Username、Password&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果Windows远程桌面端口不是3389，则填写时使用格式&lt;strong&gt;IP:端口&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;7、保存配置后，在主界面双击刚才保存的会话配置即可&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-f4d112d279819c84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;02Linux远程Windows.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用linux远程桌面连接linux&quot;&gt;使用Linux远程桌面连接Linux&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、确认Linux已经安装GNome图形桌面&lt;/li&gt;
&lt;li&gt;2、在Linux防火墙中放行远程桌面端口（默认端口初始值为5900+连接ID）并在被远程服务器中安装配置VNCServer&lt;/li&gt;
&lt;li&gt;3、在Linux安装远程连接包&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@admin /]# yum -y install rdesktop
[root@admin /]# yum -y install tsclient&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;小提示&quot;&gt;小提示&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;在Linux中不管是远程Windows还是Linux，如果出现全屏，不知道如何退出全屏时，可使用以下方法
1、Linux远程Linux
   使用 F8 键，此时会弹出VNC菜单，点击&quot;Exit Viewer&quot;或去掉&quot;Full Screen&quot;前面的勾选即可
2、Linux远程Windows
   使用组合键Crtl+Alt+Enter即可退出全屏&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;本文同步在微信订阅号上发布，如各位小伙伴们喜欢我的文章，也可以关注我的微信订阅号：woaitest，或扫描下面的二维码添加关注：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3349421-2a0edd703123621d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyQRCode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Oct 2018 15:48:00 +0000</pubDate>
<dc:creator>Surpassme</dc:creator>
<og:description>    对于远程桌面连接Linux，大家可能会第一时间想到使用VNC,，远程桌面Windows，大家第一时间会想到使用Windows自带的远程桌面。那么有没有办法，使得在Linux</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surpassme/p/9847001.html</dc:identifier>
</item>
<item>
<title>Java解析XML文件的常用方法介绍 - 闵立</title>
<link>http://www.cnblogs.com/min-li/p/9773201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/min-li/p/9773201.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　XML是一个可扩展标记语言。很多时候我们需要进行数据交换，同时也存在跨平台使用，XML文件对这些需求提供了很好的帮助！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于Java来说，XML常见的用途就是保存数据和配置，这就涉及了对XML文件的增删改查操作！&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　Java常见的XML解析方式分为DOM解析、SAX解析、DOM4j解析，下面是这三种解析方式的优缺点：&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;　　1、DOM解析 &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　方便遍历，随机访问某一个节点，修改XML。缺点是一次性读取到内存。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　2、SAX解析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　从上至下一个个节点去解析，触发事件（调用相应的方法）来进行处理。不能对xml进行修改。占用内存小。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　3、DOM4j&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　第三方的开源的解析工具，方便使用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;XML文件：(src/name.xml)&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;张三&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;李四&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;25&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;王五&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　下面我就来介绍DOM和DOM4j来解析上面的XML文件的方法：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.parsers.DocumentBuilder;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.parsers.DocumentBuilderFactory;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.parsers.ParserConfigurationException;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.Transformer;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.TransformerConfigurationException;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.TransformerException;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.TransformerFactory;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.dom.DOMSource;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.transform.stream.StreamResult;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.w3c.dom.Document;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.w3c.dom.Element;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.w3c.dom.Node;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.w3c.dom.NodeList;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.xml.sax.SAXException;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DOM {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             DocumentBuilderFactory dbf =&lt;span&gt; DocumentBuilderFactory.newInstance();
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建DOM解析器工厂&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;             DocumentBuilder db =&lt;span&gt; dbf.newDocumentBuilder();
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用DOM解析器工厂的newDocumentBuilder()方法得到DOM解析器对象&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;             Document doc = db.parse(&quot;src\\name.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用DOM解析器对象parse(String uri)方法得到Document对象&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;             NodeList nl = doc.getElementsByTagName(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Document对象的getElementsByTagName(String tagname)方法得到NodeList对象&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;             * 遍历XML中的元素
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nl.getLength(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;                 Node node =&lt;span&gt; nl.item(i);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过NodeList的item(int index)方法得到NodeList中的Node对象&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;                 Element element =&lt;span&gt; (Element) node;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Node对象强制转换的方法得到Element对象&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;                 String id = element.getAttribute(&quot;id&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Element对象的getgetAttribute(String name)方法得到id属性值&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;                System.out.println(id);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印id属性值&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;                 String age = element.getElementsByTagName(&quot;age&quot;).item(0&lt;span&gt;).getTextContent();
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Element对象的getElementsByTagName(String name)方法得到age的属性值&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;                System.out.println(age);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印age&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;             * 添加元素到XML中
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;             Element root =&lt;span&gt; doc.getDocumentElement();
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Document对象的getDocumentElement()方法得到根节点&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;             Element newname = doc.createElement(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Document对象的createElement(String tagName)方法得到新的name元素&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;             newname.setAttribute(&quot;id&quot;, &quot;小明&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过调用Element对象的setAttribute(String name,String value)方法为id赋值&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;             Element newage = doc.createElement(&quot;age&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过Document对象的createElement(String tagName)方法得到新的age元素&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;             newage.setTextContent(&quot;18&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过调用Element对象的setTextContent(String textContent)方法为age赋值&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;            newname.appendChild(newage);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加age到name中&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            root.appendChild(newname);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加name到根节点中&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;             * 修改XML中的元素
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nl.getLength(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                 Element fixname =&lt;span&gt; (Element) nl.item(i);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到要修改的Element对象&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;                 String fixnewname = fixname.getAttribute(&quot;id&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取到要修改对象的id属性值&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;                 * 判断name是否为要修改的对象
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (fixnewname.equals(&quot;小明&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                     Element sex = doc.createElement(&quot;sex&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建新的Element对象&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;                     sex.setAttribute(&quot;sex&quot;, &quot;男&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给新的Element对象的属性赋值&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;                    fixname.appendChild(sex);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加新的Element(sex)对象到Element(fixname)对象中&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;             * 删除XML中的元素
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;             root.removeChild(root.getChildNodes().item(7&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先通过根节点访问子节点，得到Node对象，然后调用根节点的removeChild(Node oldChild)方法删除元素&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;             * 将更改写入到XML文件中
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;             TransformerFactory tf =&lt;span&gt; TransformerFactory.newInstance();
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用TransformerFactory的newInstance()方法得到TransformerFactory对象&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;             Transformer t =&lt;span&gt; tf.newTransformer();
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用TransformerFactory对象的newTransformer()方法得到Transformer对象&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;             t.transform(&lt;span&gt;new&lt;/span&gt; DOMSource(doc), &lt;span&gt;new&lt;/span&gt; StreamResult(&quot;src\\name.xml&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Transformer对象的transform(Source xmlSource,Result
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; outputTarget)方法将修改写入到name.xml文件中&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParserConfigurationException e) {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SAXException e) {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TransformerConfigurationException e) {
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TransformerException e) {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;遍历运行结果：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;张三
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 20
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;李四
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 25
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;王五
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 30
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;添加运行结果：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;张三&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;李四&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;25&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;王五&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;小明&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;18&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改运行结果：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;张三&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;李四&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;25&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;王五&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;小明&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;18&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sex &lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;=&quot;男&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除运行结果：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;张三&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;李四&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;25&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;王五&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;使用DOM4j解析需要添加第三方工具包，具体网址：&lt;a href=&quot;https://dom4j.github.io/&quot;&gt;DOM4j&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.Document;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.DocumentException;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.Element;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.io.SAXReader;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.dom4j.io.XMLWriter;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileNotFoundException;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileOutputStream;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.UnsupportedEncodingException;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DOM4j {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             SAXReader sr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SAXReader();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             Document doc = sr.read(&quot;src\\name.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             Element root =&lt;span&gt; doc.getRootElement();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             List&amp;lt;Element&amp;gt; name = root.elements(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Element names : name) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 System.out.println(names.attributeValue(&quot;id&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 List&amp;lt;Element&amp;gt; age = names.elements(&quot;age&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Element ages : age) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                    System.out.println(ages.getText());
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             Element newname = root.addElement(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             newname.addAttribute(&quot;id&quot;, &quot;小明&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             Element newage = newname.addElement(&quot;age&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             newage.setText(&quot;18&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             root.remove(name.get(3&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写入&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             XMLWriter xw = &lt;span&gt;new&lt;/span&gt; XMLWriter(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;src\\name.xml&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            xw.write(doc);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (DocumentException e) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;运行结果上同。&lt;/h3&gt;
</description>
<pubDate>Wed, 24 Oct 2018 15:46:00 +0000</pubDate>
<dc:creator>闵立</dc:creator>
<og:description>XML是一个可扩展标记语言。很多时候我们需要进行数据交换，同时也存在跨平台使用，XML文件对这些需求提供了很好的帮助！ 对于Java来说，XML常见的用途就是保存数据和配置，这就涉及了对XML文件的增</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/min-li/p/9773201.html</dc:identifier>
</item>
<item>
<title>Spring Boot + Spring Cloud 构建微服务系统（八）：分布式链路追踪（Sleuth、Zipkin） - 朝雨忆轻尘</title>
<link>http://www.cnblogs.com/xifengxiaoma/p/9838067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xifengxiaoma/p/9838067.html</guid>
<description>&lt;h2&gt;技术背景&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在微服务架构中，随着业务发展，系统拆分导致系统调用链路愈发复杂，一个看似简单的前端请求可能最终需要调用很多次后端服务才能完成，那么当整个请求出现问题时，我们很难得知到底是哪个服务出了问题导致的，这时就需要解决一个问题，如何快速定位服务故障点，于是，分布式系统调用链追踪技术就此诞生了。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;zipkin&quot;&gt;ZipKin&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Zipkin 是一个由Twitter公司提供并开放源代码分布式的跟踪系统，它可以帮助收集服务的时间数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个服务向zipkin报告定时数据，zipkin会根据调用关系通过Zipkin UI生成依赖关系图，展示了多少跟踪请求经过了哪些服务，该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可非常方便的监测系统中存在的瓶颈。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Zipkin提供了可插拔数据存储方式：In-Memory、MySql、Cassandra以及Elasticsearch。我们可以跟根据需求选择不同的存储方式，生成环境一般都需要持久化。我们这里采用elasticsearch作为zipkin的数据存储器。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud-sleuth&quot;&gt;Spring Cloud Sleuth&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;一般而言，一个分布式服务追踪系统，主要有三部分组成：数据收集、数据存储和数据展示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring Cloud Sleuth为服务之间的调用提供链路追踪，通过Sleuth可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长。从而让我们可以很方便的理清各微服务间的调用关系。此外，Sleuth还可以帮助我们：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;耗时分析: 通过Sleuth可以很方便的了解到每个采样请求的耗时，从而分析出哪些服务调用比较耗时。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可视化错误: 对于程序未捕捉的异常，可以通过集成Zipkin服务界面上看到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链路优化: 对于调用比较频繁的服务，可以针对这些服务实施一些优化措施。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;spring cloud sleuth可以结合zipkin，将信息发送到zipkin，利用zipkin的存储来存储信息，利用zipkin ui来展示数据。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud-sleuth&quot;&gt;实现案例&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在早前的Spring Cloud版本里是需要自建zipkin服务端的，但是从SpringCloud2.0 以后，官方已经不支持自建Server了，改成提供编译好的jar包供用户使用。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;因为我用的是2.0以后的版本，自建Servcer的方式请自行百度。这里我们是使用docker方式部署zipkin服务，并采用elasticsearch作为zipkin的数据存储器。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;下载镜像&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 此前请先安装好docker环境，使用以下命令分别拉取zipkin和elasticsearch镜像。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker pull openzipkin/&lt;span&gt;zipkin
docker pull docker.elastic.co&lt;/span&gt;/elasticsearch/elasticsearch:&lt;span&gt;6.3&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过 docker images 查看下载镜像。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023175917378-795615735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;编写启动文件&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;创建如下文件夹结构。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;dockerfile
    &lt;/span&gt;|-&lt;span&gt; elasticsearch
    &lt;/span&gt;|    |-&lt;span&gt; data
    &lt;/span&gt;|- docker-compose.yml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;docker-compose.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
version: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
services:

  elasticsearch:
    image:  docker.elastic.co&lt;/span&gt;/elasticsearch/elasticsearch:&lt;span&gt;6.3&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    container_name: elasticsearch
    restart: always
    networks:
      &lt;/span&gt;-&lt;span&gt; elk
    ports:
      &lt;/span&gt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9200:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
      - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9300:9300&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    volumes:
       &lt;/span&gt;- ../elasticsearch/data:/usr/share/elasticsearch/&lt;span&gt;data

  zipkin:
    image: openzipkin&lt;/span&gt;/&lt;span&gt;zipkin:latest
    container_name: zipkin
    restart: always
    networks:
      &lt;/span&gt;-&lt;span&gt; elk
    ports:
      &lt;/span&gt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9411:9411&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    environment:
      &lt;/span&gt;- STORAGE_TYPE=&lt;span&gt;elasticsearch
      &lt;/span&gt;- ES_HOSTS=&lt;span&gt;elasticsearch

networks:
    elk:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;关于docker-compose.yml 文件格式及相关内容请自行百度了解。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动服务&quot;&gt;启动服务&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;命令模式进入dockerfile目录，执行启动命令如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker-compose up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行过程如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023180914441-550778626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行完成之后，通过 docker ps 命令查看，发现zipkin和elasticsearch确实启动起来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023181024523-1903628665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里，zipkin服务端就搭建起来了，访问 &lt;a href=&quot;http://localhost:9411/&quot; target=&quot;_blank&quot;&gt;http://localhost:9411&lt;/a&gt;，效果如下，因为还没有客户端，所以还没有数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023183311160-1565397107.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;zipkin服务端已经搭建完成了，接下来我们来实现客户端。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;添加依赖&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;修改 spring-cloud-consul-consumer 项目Maven配置，添加zipkin依赖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pom.xml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;添加配置&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;修改配置文件，添加如下zipkin配置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  zipkin:
    &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;-url: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:9411/&lt;/span&gt;
&lt;span&gt;  sleuth:
    sampler:
      probability: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; #样本采集量，默认为0.&lt;span&gt;1&lt;/span&gt;，为了测试这里修改为1，正式环境一般使用默认值。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;application.yml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023182301712-874693967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;测试效果&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;先后启动注册中心、服务提供者、服务消费者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反复访问几次 &lt;a href=&quot;http://localhost:8521/ribbon/call&quot; target=&quot;_blank&quot;&gt;http://localhost:8521/ribbon/call&lt;/a&gt;，产生zipkin数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023183743036-1166860662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再次访问 &lt;a href=&quot;http://localhost:9411/&quot; target=&quot;_blank&quot;&gt;http://localhost:9411&lt;/a&gt;， 发现出现了我们刚刚访问的服务，选择并点击追踪。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023183936285-1127654176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 点击追踪之后，页面显示了相关的服务调用信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023184247825-1110368264.png&quot; alt=&quot;&quot; width=&quot;728&quot; height=&quot;328&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击调用记录查看详情页面，可以看到每一个服务所耗费的时间和顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181023185137607-1402828876.png&quot; alt=&quot;&quot; width=&quot;722&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;源码下载&lt;/h2&gt;
&lt;p&gt;码云：&lt;a href=&quot;https://gitee.com/liuge1988/spring-cloud-demo.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/liuge1988/spring-cloud-demo.git&lt;/a&gt;&lt;a href=&quot;https://gitee.com/liuge1988/kitty&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/xifengxiaoma/&quot; target=&quot;_blank&quot;&gt;朝雨忆轻尘&lt;/a&gt;&lt;br/&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/xifengxiaoma/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/xifengxiaoma/ &lt;/a&gt;&lt;br/&gt;版权所有，欢迎转载，转载请注明原文作者及出处。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Oct 2018 15:11:00 +0000</pubDate>
<dc:creator>朝雨忆轻尘</dc:creator>
<og:description>技术背景 在微服务架构中，随着业务发展，系统拆分导致系统调用链路愈发复杂，一个看似简单的前端请求可能最终需要调用很多次后端服务才能完成，那么当整个请求出现问题时，我们很难得知到底是哪个服务出了问题导致</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xifengxiaoma/p/9838067.html</dc:identifier>
</item>
<item>
<title>朱晔和你聊Spring系列S1E9：聊聊Spring的那些注解 - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/9846846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/9846846.html</guid>
<description>&lt;p&gt;本文我们来梳理一下Spring的那些注解，如下图所示，大概从几方面列出了Spring的一些注解：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/10/24/166a687687198766?w=830&amp;amp;h=762&amp;amp;f=png&amp;amp;s=310293&quot;/&gt;&lt;br/&gt;如果此图看不清楚也没事，请运行下面的代码输出所有的结果。&lt;br/&gt;Spring目前的趋势是使用注解结合Java代码而不是配置来定义行为、属性、功能、规则和扩展点，因此梳理注解也是梳理Spring功能点的很好的方式，全面的梳理可以补足我们知识点的漏洞。&lt;/p&gt;
&lt;h2 id=&quot;查找所有注解&quot;&gt;查找所有注解&lt;/h2&gt;
&lt;p&gt;首先，我们来创建一个项目，使用SPRING INITIALIZR生成一个引入Spring各种组件的项目模板，然后引入如下工具包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.reflections&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;reflections&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.9.11&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个反射工具包，我们可以创建一个Spring Boot应用程序，以一行代码打印出所有Spring框架的注解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.reflections.Reflections;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import java.lang.annotation.Annotation;

@Component
public class ScanAnnotationRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        new Reflections(&quot;org.springframework&quot;)
                .getSubTypesOf(Annotation.class)
                .stream()
                .map(clazz-&amp;gt;clazz.getName())
                .sorted()
                .forEach(System.out::println);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果这里就不给出了，下面我们逐一进行梳理其中的一些重要注解。&lt;/p&gt;
&lt;h2 id=&quot;有关注解&quot;&gt;有关注解&lt;/h2&gt;
&lt;p&gt;Java的Annotation注解（类似于C#的Attribute特性），说白了就是给代码打上标签的能力。我们可以配置这个标签的保留阶段，仅源代码，源代码+字节码，源代码+字节码+运行时。通过引入注解，我们可以简单快速赋予代码生命力，大大提高代码可读性和扩展性。注解本身不具有任何能力，只是一个标签，但是我们可以定义各种标签然后实现各种标签处理器来对类、方法、属性甚至参数等进行功能扩展、功能开启、属性定义、行为定义、规则定义、关联处理、元数据定义等等。在实现各种框架的时候，我们经常会自定义标签方便框架使用者仅仅通过在合适的地方引入合适的注解来启用（或自定义）框架的一些能力并应用到我们的程序中。&lt;/p&gt;
&lt;p&gt;不仅仅是框架的作者会大量使用注解，在之前的系列文章中我们也多次自定义注解，我们有通过定义@Metrics注解配合Spring AOP来为程序启动打点、日志、异常等功能，我们有通过定义@Sign注解配合Spring MVC的ResponseBodyAdvice进行数据签名功能，我们还经常会定义各种自定义注解配合Spring MVC的HandlerMethodArgumentResolver进行权限的校验等等功能。采用这种模式，我们的核心业务逻辑可以保持清晰干净，通过注解配合AOP赋予代码额外的能力。&lt;/p&gt;
&lt;p&gt;你可能会说，注解还是有侵入性，我们需要耦合框架定义的那些注解，这个问题其实是无解的，100%无侵入性也代表了可读性的降低，代码的功能和能力应当聚合在一起，这也就是为什么Spring现在也不建议采用XML来做配置。Java核心类库并没有什么注解，好在Spring已经有了大量注解，而Spring也变为了Java开发的标准，所以其实我们很多时候如果希望自己的框架（RPC啥的）完全没有侵入性的话可以借用Spring的那些注解@Autowired、@Controller、@Service等注解，配合各种包的规范其实我们可以对目标元素的功能识别个八九不离十，完全有可能实现0侵入的功能增强。&lt;/p&gt;
&lt;p&gt;有关如何实现自定义注解不赘述，这里我们简单回顾一下几个元注解（注解的注解）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;@Documented&lt;/strong&gt;：将会在被此注解注解的元素的javadoc文档中列出注解，一般都打上这个注解没坏处&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Target&lt;/strong&gt;：注解能被应用的目标元素，比如类、方法、属性、参数等等，需要仔细思考&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Retention&lt;/strong&gt;：仅在源码保留，还是保留到编译后的字节码，还是到运行时也去加载，超过90%的应用会在运行时去解析注解进行额外的处理，所以大部分情况我们都会设置配置为RetentionPolicy.RUNTIME&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Inherited&lt;/strong&gt;：如果子类没有定义注解的话，能自动从父类获取定义了继承属性的注解，比如Spring的@Service是没有继承特性的，但是@Transactional是有继承特性的，在OO继承体系中使用Spring注解的时候请特别注意这点，理所当然认为注解是能被子类继承的话可能会引起不必要的Bug，需要仔细斟酌是否开启继承&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Repeatable&lt;/strong&gt;：Java 8 引入的特性，通过关联注解容器定义可重复注解，小小语法糖提高了代码可读性，对于元素有多个重复注解其实是很常见的事情，比如某方法可以是A角色可以访问也可以是B角色可以访问，某方法需要定时任务执行，要在A条件执行也需要在B条件执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Native&lt;/strong&gt;：是否在.h头文件中生成被标记的字段，除非原生程序需要和Java程序交互，否则很少会用到这个元注解&lt;br/&gt;现在我们来从几个方面逐一温习一下Spring的那些常用的值得关注的注解。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring核心注解&quot;&gt;Spring核心注解&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先来看一下各种stereotype：按分类定义了由Spring管理的各种组件，&lt;strong&gt;@Controller&lt;/strong&gt;定义表现层组件，&lt;strong&gt;@Service&lt;/strong&gt;定义业务逻辑层组件，&lt;strong&gt;@Repository&lt;/strong&gt;定义数据访问层资源库组件，&lt;strong&gt;@Component&lt;/strong&gt;定义其它组件（比如访问外部服务的组件），之前也说过了随着这些注解功能无区别，但是对组件进行合适的分类意义重大，不仅仅增加可读性而且方便我们通过AOP对不同类型的组件进行更多自动增强&lt;/li&gt;
&lt;li&gt;再来看看IOC相关的一些注解：&lt;strong&gt;@Autowired&lt;/strong&gt;自动装配不用多说了；&lt;strong&gt;@Required&lt;/strong&gt;用于在setter方法标记属性值需要由Spring进行装配，对于目前版本的Spring这个注解已经废弃，现在Spring更推荐使用构造方法注入；&lt;strong&gt;@Qualifier&lt;/strong&gt;用于通过给Bean定义修饰语来注入相应的Bean，和@Autowired一起使用相当于@Resource的效果，当然还有一种常见用法是嵌入其它注解用于对Bean进行区分，然后配合@Autowired一起使用，参见后面提到的Spring Cloud的@LoadBalanced注解；&lt;strong&gt;@Value&lt;/strong&gt;用于注入属性配置或SpEL表达式（前者是我们常见用法，后者可以从其它对象获取值，功能更强大一点）；&lt;strong&gt;@Lookup&lt;/strong&gt;可以实现方法注入，如果我们的类是单例的，但是又希望Spring注入的依赖的对象是Prototype生命周期（每次new一个出来）的，这个时候可以通过此注解进行方法注入&lt;/li&gt;
&lt;li&gt;然后来看一下有关事务的几个注解：&lt;strong&gt;@EnableTransactionManagement&lt;/strong&gt;用于开启事务管理，使用Spring Boot如果引入Spring Data的话不需要手动开启（不过建议大家在使用事务的时候还是通过日志来验证事务管理是否生效）；&lt;strong&gt;@Transactional&lt;/strong&gt;大家都知道用于开启事务以及设置传播性、隔离性、回滚条件等；&lt;strong&gt;@TransactionalEventListener&lt;/strong&gt;用于配置事务的回调方法，可以在事务提交前、提交后、完成后以及回滚后几个阶段接受回调事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Order&lt;/strong&gt;注解可以设置Spring管理对象的加载顺序，在之前介绍AOP的文章中我们看到有的时候我们必须通过设置合理的@Order来合理安排切面的切入顺序避免一些问题，还有在一些业务场景中，我们往往会去定义一组类似于Filter的@Component，然后会从容器获得一组Bean，这个时候业务组件的运行顺序往往会比较重要，也可以通过这个方式进行排序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@AliasFor&lt;/strong&gt;注解可以设置一组注解属性相互作为别名，对于有歧义的时候会使代码更清晰，此外还有一个用途是创建复合注解，Spring MVC的@GetMapping注解就是基于@RequestMapping这个注解创建的复合注解，我们可以很方便得通过这种方式来实现注解的继承&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring上下文注解&quot;&gt;Spring上下文注解&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先来看一下配置相关的一些注解：&lt;strong&gt;@Configuration&lt;/strong&gt;用于标注配置类，启用Java配置方式的Bean配置；&lt;strong&gt;@Bean&lt;/strong&gt;用于配置一个Bean；&lt;strong&gt;@ComponentScan&lt;/strong&gt;（&lt;strong&gt;@ComponentScans&lt;/strong&gt;用于配置一组@ComponentScan，Java 8可以直接使用重复注解特性配置多个@ComponentScan）用于扫描包方式配置Bean；&lt;strong&gt;@PropertySource&lt;/strong&gt;以及 &lt;strong&gt;@PropertySources&lt;/strong&gt;用于导入配置文件；&lt;strong&gt;@Conditional&lt;/strong&gt;用于设置关联的条件类，在合适的时候启用Bean的配置（Spring Boot自动配置根基）；&lt;strong&gt;@Import&lt;/strong&gt;用于导入其它配置类； &lt;strong&gt;@ImportResource&lt;/strong&gt;用于导入非Java配置方式的XML配置；&lt;strong&gt;@Profile&lt;/strong&gt;用于指定在合适的Profile下启用配置；&lt;strong&gt;@Lazy&lt;/strong&gt;用于告知容器延迟到使用的时候实例化Bean（默认情况下容器启动的时候实例化Bean来检查所有的问题）；&lt;strong&gt;@Description&lt;/strong&gt;用于给Bean设置描述；&lt;strong&gt;@Scope&lt;/strong&gt;用于设置Bean的生命周期；&lt;strong&gt;@Primary&lt;/strong&gt;用于在定义了多个Bean的时候指定首选的Bean&lt;/li&gt;
&lt;li&gt;其它一些注解包括：&lt;strong&gt;@EventListener&lt;/strong&gt;用于设置回调方法监听Spring制定的以及自定义的各种事件；&lt;strong&gt;@EnableAspectJAutoProxy&lt;/strong&gt;用于开启支持AspectJ的 &lt;strong&gt;@Aspect&lt;/strong&gt;切面配置支持，使用Spring Boot引入了AOP启动器的话不需要显式开启&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-web注解&quot;&gt;Spring Web注解&lt;/h2&gt;
&lt;p&gt;Spring MVC的各种注解对应了Spring MVC各方面的功能，下面我们来了解一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是三个定义了Bean特殊生命周期的复合注解：&lt;strong&gt;@RequestScope&lt;/strong&gt;、&lt;strong&gt;@SessionScope&lt;/strong&gt;和 &lt;strong&gt;@ApplicationScope&lt;/strong&gt;。在Web应用中，我们可能需要Bean跟随请求、会话和应用程序的声明周期来进行创建，这个时候可以直接使用这三个快捷的复合注解&lt;/li&gt;
&lt;li&gt;接下去可以看到各种 &lt;strong&gt;@XXXMapping&lt;/strong&gt;的注解，分别用于配置HandlerMethod匹配到不同的Http Method，当然不使用这些快捷的注解也是可以的，直接使用@RequestMapping然后手动设置method&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@ResponseStatus&lt;/strong&gt;可以用到方法上也可以用到异常上，前者会直接使请求得到指定的响应代码或原因（可以配合@ExceptionHandler使用），后者可以实现遇到指定异常的时候给出指定的响应代码或原因，&lt;strong&gt;@ResponseBody&lt;/strong&gt;我们实现Restful接口的时候（@RestController）最常用了，把返回内容（序列化后）输出到请求体&lt;/li&gt;
&lt;li&gt;Spring MVC给了我们各种注解方便我们从HTTP请求各种地方获取参数，&lt;strong&gt;@RequestBody&lt;/strong&gt;从请求体（处理复杂数据，比如JSON），&lt;strong&gt;@RequestHeader&lt;/strong&gt;从请求头，&lt;strong&gt;@CookieValue&lt;/strong&gt;从cookie中，&lt;strong&gt;@SessionAttribute&lt;/strong&gt;从会话中，&lt;strong&gt;@RequestAttribute&lt;/strong&gt;从请求的Attribute中（比如过滤器和拦截器手动设置的一些临时数据），&lt;strong&gt;@RequestParam&lt;/strong&gt;从请求参数（处理简单数据，键值对），&lt;strong&gt;@PathVariable&lt;/strong&gt;从路径片段，&lt;strong&gt;@MatrixAttribute&lt;/strong&gt;矩阵变量允许我们采用特殊的规则在URL路径后加参数（分号区分不同参数，逗号为参数增加多个值）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@ControllerAdvice&lt;/strong&gt;是一个重要注解，允许我们在集中的地方配置控制器（有@RequestMapping的方法）相关的增强（&lt;strong&gt;@RestControllerAdvice&lt;/strong&gt;也是差不多的，只是相当于为@ExceptionHandler加上了@ResponseBody）。那么可以应用哪些增强呢？首先是可以用 &lt;strong&gt;@ExceptionHandler&lt;/strong&gt;进行统一的全局异常处理；第二是 &lt;strong&gt;@InitBinder&lt;/strong&gt;用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中；第三是 &lt;strong&gt;@ModelAttribute&lt;/strong&gt;让全局的@RequestMapping都能获得在此处设置的键值对。当然，这里说的@InitBinder和@ExceptionHandler也可以不定义在@ControllerAdvice内部（作为全局开启），定义在Controller内部应用到某个Controller也是可以的&lt;/li&gt;
&lt;li&gt;其它还有一些注解比如：&lt;strong&gt;@CrossOrigin&lt;/strong&gt;可以用到Controller或Method上（需要配合@RequestMapping）设置细粒度的跨域行为&lt;br/&gt;在之前的文章中我们也提到，对于Spring MVC，定义自己的注解应用到参数、方法、控制器上，配合HandlerMethodArgumentResolver、XXAdvise、以及Interceptor实现具体的功能来使用太太常见了，几乎所有的非业务横切关注点，我们都不应该在方法实现中重复任何一行代码。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-boot注解&quot;&gt;Spring Boot注解&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;来看一下上下文相关的注解：&lt;strong&gt;@ConfigurationProperties&lt;/strong&gt;很常用（配合 &lt;strong&gt;@EnableConfigurationProperties&lt;/strong&gt;注解来设置需要启用的配置类），用来自定义配置类和配置文件进行关联；&lt;strong&gt;@DeprecatedConfigurationProperty&lt;/strong&gt;用于标记废弃的配置以及设置替代配置和告知废弃原因；&lt;strong&gt;@ConfigurationPropertiesBinding&lt;/strong&gt;用于指定自定义的转换器用于配置解析的时的类型转换； &lt;strong&gt;@NestedConfigurationProperty&lt;/strong&gt;用于关联外部的类型作为嵌套配置类&lt;/li&gt;
&lt;li&gt;再看看自动配置相关的注解，自动配置是Spring Boot最重要的特性，在之前的系列文章中我有提到一个观点，IOC是好事情，但是把组件内部的一些默认配置以及组件和组件的组装交给外部用户来配置其实是不合理的，组件应当可以自动进行自我配置实现开箱急用，只有需要自定义组件的时候才要求外部来进行个性化配置：&lt;strong&gt;@EnableAutoConfiguration&lt;/strong&gt;注解可以启用自动配置，Spring Boot应用程序一般我们会直接使用复合注解@SpringBootApplication；&lt;strong&gt;@AutoConfigureOrder&lt;/strong&gt;（值越小优先级越高）、&lt;strong&gt;@AutoConfigureAfter&lt;/strong&gt;、&lt;strong&gt;@AutoConfigureBefore&lt;/strong&gt;用于设置自动配置类加载顺序，以及精确控制加载依赖关系，有的时候我们的自动配置需要相互依赖或者会相互干扰，需要手动调节&lt;/li&gt;
&lt;li&gt;最后来看一下十几种配置条件，用好这些注解是实现完善的自动配置的关键：&lt;strong&gt;@ConditionalOnBean&lt;/strong&gt;用于仅当容器中已经包含指定的Bean类型或名称时才匹配条件；&lt;strong&gt;@ConditionalOnClass&lt;/strong&gt;仅当classpath上存在指定类时条件匹配；&lt;strong&gt;@ConditionalOnCloudPlatform&lt;/strong&gt;仅当指定的云平台处于活动状态时条件匹配；&lt;strong&gt;@ConditionalOnExpression&lt;/strong&gt;依赖于SpEL表达式的值的条件元素的配置注解；&lt;strong&gt;@ConditionalOnJava&lt;/strong&gt;基于应用运行的JVM版本的条件匹配；&lt;strong&gt;@ConditionalOnJndi&lt;/strong&gt;基于JNDI可用和可以查找指定位置的条件匹配；&lt;strong&gt;@ConditionalOnMissingBean&lt;/strong&gt;仅当容器中不包含指定的Bean类型或名称时条件匹配；&lt;strong&gt;@ConditionalOnMissingClass&lt;/strong&gt;仅当classpath上不存在指定类时条件匹配；&lt;strong&gt;@ConditionalOnNotWebApplication&lt;/strong&gt; 仅当不是WebApplicationContext（非Web项目）时条件匹配，对应 &lt;strong&gt;@ConditionalOnWebApplication&lt;/strong&gt;；&lt;strong&gt;@ConditionalOnProperty&lt;/strong&gt;是检查指定的属性是否具有指定的值；&lt;strong&gt;@ConditionalOnResource&lt;/strong&gt;表示仅当 classpath 上存在指定资源时条件匹配；&lt;strong&gt;@ConditionalOnSingleCandidate&lt;/strong&gt;仅当容器中包含指定的Bean类并且可以判断只有单个候选者时条件匹配。其实所有这些实现原理都是扩展SpringBootCondition抽象类（实现之前提到的Condition接口），我们完全可以实现自己的条件注解（配合 &lt;strong&gt;@Conditional&lt;/strong&gt;注解关联到自己实现的SpringBootCondition）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-cloud注解&quot;&gt;Spring Cloud注解&lt;/h2&gt;
&lt;p&gt;在介绍本系列文章的第一篇中我们就提到了，Spring Cloud整齐划一通过各种EnableXXX注解开启某个功能，这里就不对这些注解进行说明了，使用Spring Boot组件的功能非常简单，基本就是引POM+EnableXXX+设置配置文件三部曲。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是 Netflix包下的一些注解，各种EnableXXX就不说了，参考前一篇文章，之前没介绍过 &lt;strong&gt;@RibbonClient&lt;/strong&gt;，这个注解用来为负载均衡客户端做一些自定义的配置，可以进一步配置或自定义从哪里获取服务端列表、负载均衡策略、Ping也就是服务鉴活策略等等&lt;/li&gt;
&lt;li&gt;client包下的 &lt;strong&gt;@SpringCloudApplication&lt;/strong&gt;之前文章中我们也没有使用到，这是一个复合注解就是 &lt;strong&gt;@SpringBootApplication&lt;/strong&gt;+ &lt;strong&gt;@EnableDiscoveryClient&lt;/strong&gt;+ &lt;strong&gt;@EnableCircuitBreaker&lt;/strong&gt;，Spring Cloud那堆东西很多，还是自己亲手定义一个一个功能的注解来的踏实； &lt;strong&gt;@LoadBalanced&lt;/strong&gt;注解用于和RestTemplate配合使用构成一个负载均衡的Http客户端，实现原理上其实这个注解是一个@Qualifier注解，Spring会为所有@LoadBalanced的RestTemplate加入一个LoadBalancerInterceptor（实现ClientHttpRequestInterceptor）实现负载均衡&lt;/li&gt;
&lt;li&gt;sleuth包下面的注解和链路跟踪相关，比较常用的是通过 &lt;strong&gt;@SpanName&lt;/strong&gt;手动设置span的名称，其它注解对于业务开发并不常用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;好了，写了本文我发现我看到@已经Markdown的**就眼花，请点赞支持。本文我们通过代码打印出了大部分Spring相关的注解，你也可以通过这个方式熟悉其它框架的注解（毕竟注解是框架赋予我们各种便捷功能的一个重要入口，对注解了解个八九成也往往可以对框架赋予我们的丰富功能了解六七成）。然后我们梳理了一下Spring相关的各种注解，其中主要需要关注的是几方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;元注解，也就是注解的注解&lt;/li&gt;
&lt;li&gt;Spring容器相关的一些注解，包括@Qualifier、@AliasFor、@Order等看似不重要但其实很重要的注解&lt;/li&gt;
&lt;li&gt;Spring Java配置相关的一些注解，包括条件注解&lt;/li&gt;
&lt;li&gt;Spring Boot自动配置相关的一些注解&lt;/li&gt;
&lt;li&gt;很多注解可以同时应用到类型、方法、参数上，有的时候应用到不同的地方作用会略微不一样，这个需要重点关注&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们知道注解其实只是一个标识，注解如何起作用背后的实现原理还是比较多样的，你可以进一步结合本文介绍的Spring的各种注解探寻一下背后实现的原理。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Oct 2018 15:03:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>本文我们来梳理一下Spring的那些注解，如下图所示，大概从几方面列出了Spring的一些注解： 如果此图看不清楚也没事，请运行下面的代码输出所有的结果。 Spring目前的趋势是使用注解结合Java</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecindywang/p/9846846.html</dc:identifier>
</item>
<item>
<title>Python对HDFS的操作(一) - dong66</title>
<link>http://www.cnblogs.com/songdongdong6/p/9846837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songdongdong6/p/9846837.html</guid>
<description>&lt;h2&gt;hdfs的定义:&lt;/h2&gt;
&lt;p&gt;　　Hadoop的分布式文件系统（HDFS）被设计成适合运行通用硬件上的分布式文件系统，它和现有的分布式文件系统有很多的共同点。但同时，它和其它的分布式文件系统的区别也是很明显的，hdfs是一个高容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上使用。HDFS放宽了一部分POSIX(&lt;a href=&quot;https://baike.baidu.com/item/POSIX/3792413?fr=aladdin&quot;&gt;https://baike.baidu.com/item/POSIX/3792413?fr=aladdin&lt;/a&gt;)约束,来实现流式读取文件系统数据的目的。HDFS在最开始是作为Apache Nutch搜索引擎项目的基础架构而开发的。HDFS现在是Apache Hadoop Core项目的一部分，这个项目的地址是：&lt;a href=&quot;http://hadoop.apache.org/core/&quot; target=&quot;_blank&quot;&gt;http://hadoop.apache.org/core/&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;安装：&lt;/h2&gt;
&lt;p&gt;　　因为这里介绍的是python版本的使用，所以需要安装相应的包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
　pip install hdfs
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 基础使用方法：&lt;/h2&gt;
&lt;h3&gt;　　Client---创建集群链接:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; hdfs &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;
client&lt;/span&gt;=Client(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://hdfsip:50070&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　&lt;em class=&quot;property&quot;&gt;class  &lt;/em&gt;&lt;code class=&quot;descclassname&quot;&gt;hdfs.client.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;Client&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;url&lt;/em&gt;, &lt;em&gt;root=None&lt;/em&gt;, &lt;em&gt;proxy=None&lt;/em&gt;, &lt;em&gt;timeout=None&lt;/em&gt;, &lt;em&gt;session=None&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　　　url: ip:端口&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt; 　　　　　  root：指定hdfs根目录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　　　proxy：制定登陆用户的身份&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　　　timout： 设置超时时间&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　　　session：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333418/201810/1333418-20181024220929960-126998217.png&quot; alt=&quot;&quot;/&gt;(官方解释，没弄明白具体意思，也暂时没有用到这个参数，等用到之后再进行补充)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　dir---查看Client所有支持的方法：&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;117&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; dir(client)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt;&lt;code class=&quot;java plain&quot;&gt;[&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__class__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__delattr__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__dict__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__dir__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__doc__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__eq__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__format__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__ge__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__getattribute__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__gt__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;java string&quot;&gt;　　'__hash__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__init__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__le__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__lt__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__module__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__ne__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__new__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__reduce__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__reduce_ex__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__registry__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; 　　&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__repr__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__setattr__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__sizeof__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__str__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__subclasshook__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'__weakref__'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_append'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_create'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_delete'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; 　　&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_get_content_summary'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_get_file_checksum'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_get_file_status'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_get_home_directory'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_list_status'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_mkdirs'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_open'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; 　　&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_proxy'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_rename'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_request'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_session'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_set_owner'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_set_permission'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_set_replication'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_set_times'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'_timeout'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java string&quot;&gt;　　'checksum'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'content'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'delete'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'download'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'from_options'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'list'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'makedirs'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'parts'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'read'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'rename'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'resolve'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'root'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; 　　&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'set_owner'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'set_permission'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'set_replication'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'set_times'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'status'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'upload'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; 　　&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'url'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'walk'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'write'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;　　status---获取指定路径的具体信息：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; client.status(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accessTime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pathSuffix&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;supergroup&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DIRECTORY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;owner&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;childrenNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 4, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;blockSize&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,

 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fileId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 16385, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;replication&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;storagePolicy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;modificationTime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1473023149031, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;permission&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;777&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　status(hdfs_path,strict=True)&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　hdfs_path:就是hdfs的路径&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　strict：当设置为True时，hdfs的路径不存在时，返回异常信息&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　　　　当设置为False时，hdfs的路径不存在时，返回None&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　list---获取指定路径的子目录信息：&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[&quot;test01&quot;,&quot;test02&quot;,&quot;test03&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;       参数说明:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　list(hdfs_path,status=False)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　hdfs_path: hdfs的路径&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　　　status：为True时，同时反hi子目录的状态信息，默认为False&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;　　makedirs--创建目录&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
client.makedirs(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test06&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　makedirs(hdfs_path,permission=None)&lt;/p&gt;
&lt;p&gt;　　　　hdfs_path: 要创建目录&lt;/p&gt;
&lt;p&gt;　　　　permission：对创建的文件夹设置权限&lt;/p&gt;
&lt;h3&gt;　　rename—重命名&lt;/h3&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div id=&quot;highlighter_449617&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;17&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; client.rename(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/new_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gyt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hbase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　rename(hdfs_path, local_path）&lt;/p&gt;
&lt;h3&gt;　delete—删除&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gyt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hbase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; client.delete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/new_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
True
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gyt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hbase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div id=&quot;highlighter_242521&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　delete(hdfs_path,recursive=False)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　　　recursive：删除文件和其子目录，设置为False如果不存在，则会抛出异常，默认为False&lt;/p&gt;
&lt;h3&gt;　upload——上传数据&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hbase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; client.upload(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/bigdata/hadoop/NOTICE.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/NOTICE.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hbase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; client.list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;NOTICE.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　upload(hdfs_path,local_path,overwrite=False,n_threads=1,temp_dir=None,&lt;/p&gt;
&lt;p&gt;　　　　chunk_size=65536,progress=None,cleanup=True,**kwargs)&lt;/p&gt;
&lt;p&gt;　　　　overwrite：是否是覆盖性上传文件&lt;/p&gt;
&lt;p&gt;　　　　n_threads：启动的线程数目&lt;/p&gt;
&lt;p&gt;　　　　temp_dir：当overwrite=true时，远程文件一旦存在，则会在上传完之后进行交换&lt;/p&gt;
&lt;p&gt;　　　　chunk_size：文件上传的大小区间&lt;/p&gt;
&lt;p&gt;　　　　progress：回调函数来跟踪进度，为每一chunk_size字节。它将传递两个参数，文件上传的路径和传输的字节数。一旦完成，-1将作为第二个参数&lt;/p&gt;
&lt;p&gt;　　　　cleanup：如果在上传任何文件时发生错误，则删除该文件&lt;/p&gt;
&lt;h3&gt;　　download——下载&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; client.download(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test/NOTICE.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/NOTICE.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; os.system(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ls /home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
lost&lt;/span&gt;+&lt;span&gt;found  NOTICE.txt  thinkgamer
0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数说明：&lt;/p&gt;
&lt;p&gt;　　　　download(hdfs_path,local_path,overwrite=False,n_threads=1,temp_dir=None,**kwargs)&lt;/p&gt;
&lt;p&gt;　　　　和上传的参数一样&lt;/p&gt;
&lt;h3&gt;　　read——读取文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; with client.read(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test/NOTICE.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as reader:
...     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; reader.read()
...
This product includes software developed by The Apache Software
Foundation (https:&lt;/span&gt;//www.apache.org/&lt;span&gt;).
 
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;　　read(*args,**kwds)&lt;/p&gt;
&lt;p&gt;　　hdfs_path：hdfs路径&lt;/p&gt;
&lt;p&gt;　　offset：设置开始的字节位置&lt;/p&gt;
&lt;p&gt;　　length：读取的长度（字节为单位）&lt;/p&gt;
&lt;p&gt;　　buffer_size：用于传输数据的字节的缓冲区的大小。默认值设置在HDFS配置。&lt;/p&gt;
&lt;p&gt;　　encoding：制定编码&lt;/p&gt;
&lt;p&gt;　　chunk_size：如果设置为正数，上下文管理器将返回一个发生器产生的每一chunk_size字节而不是一个类似文件的对象&lt;/p&gt;
&lt;p&gt;　　delimiter：如果设置，上下文管理器将返回一个发生器产生每次遇到分隔符。此参数要求指定的编码。&lt;/p&gt;
&lt;p&gt;　　progress：回调函数来跟踪进度，为每一chunk_size字节（不可用，如果块大小不是指定）。它将传递两个参数，文件上传的路径和传输的字节数。称为一次与- 1作为第二个参数。&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div id=&quot;highlighter_457657&quot; class=&quot;syntaxhighlighter java&quot; readability=&quot;10&quot;&gt;

&lt;p&gt;　　解决办法是：在配置文件hdfs-site.xml中加入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;property&amp;gt;
  &amp;lt;name&amp;gt;dfs.permissions&amp;lt;/name&amp;gt;
  &amp;lt;value&amp;gt;false&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 重启集群&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


</description>
<pubDate>Wed, 24 Oct 2018 15:01:00 +0000</pubDate>
<dc:creator>dong66</dc:creator>
<og:description>HDFS hdfs的定义: Hadoop的分布式文件系统（HDFS）被设计成适合运行通用硬件上的分布式文件系统，它和现有的分布式文件系统有很多的共同点。但同时，它和其它的分布式文件系统的区别也是很明显</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songdongdong6/p/9846837.html</dc:identifier>
</item>
<item>
<title>Decorator模式（装饰器模式） - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9846783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9846783.html</guid>
<description>&lt;h4 id=&quot;decorator模式&quot;&gt;Decorator模式？&lt;/h4&gt;
&lt;p&gt;假如现在有一块蛋糕，如果只涂上奶油，其他什么都不加，就是奶油蛋糕。如果加上草莓，就是草莓奶油蛋糕。如果再加上一块黑色巧克力板，上面用白色巧克力写上姓名，然后插上代表年龄的蜡烛，就变成了一块生日蛋糕&lt;br/&gt;&lt;strong&gt;像这样不断地为对象添加装饰的设计模式被称为Decorator模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单描述：一个基础共有的对象，你想赋予它什么责者那么你添加相关的职责修饰，这就是装饰器模式&lt;/li&gt;
&lt;li&gt;Java I/O 中使用适配器的：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181024224711956-398105312.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181024224715878-1300642282.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;理清职责&quot;&gt;理清职责&lt;/h4&gt;
&lt;p&gt;作用：对普通的字符串，通过加入边框进行描述&lt;br/&gt;名字============》》说明&lt;br/&gt;Display ||| 用于显示字符串的抽象类&lt;br/&gt;stringDisplay ||| 用于显示单行字符串的类&lt;br/&gt;Border ||| 用于显示装饰边框的抽象类&lt;br/&gt;sideBorder ||| 用于只显示左右边框的类&lt;br/&gt;Fu11Border ||| 用于显示上下左右边框的类&lt;br/&gt;Main ||| 测试程序行为的类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关系对象图：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181024224722956-289640359.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;uml&quot;&gt;UML&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181024224828851-1449443897.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;code&quot;&gt;Code&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class MainT {

    public static void main(String[] args) {

        Display display=new StringDisplay(&quot;hello decorator&quot;);

        display.show();

        Display display1=new SideBorder(display,'#');

        display1.show();

        Display fullBorder = new FullBorder(display1);

        fullBorder.show();

        Display display2=new SideBorder(
                new FullBorder(
                        new FullBorder(
                                new SideBorder(
                                        new FullBorder(
                                                new StringDisplay(&quot;Lets it go&quot;)
                                        ),
                                        '*'
                                )
                        )
                )
        ,'/');
        display2.show();



    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class Display {

    // 获取横向字符数
    public abstract int getColumns();

    // 获取纵向行数
    public abstract int getRows();

    // 获取row行字符
    public abstract String getRowText(int row);

    // 显示
    public final void show(){
        for (int i = 0; i &amp;lt; getRows(); i++) {
            System.out.println(getRowText(i));
        }
    }

}


&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;StringDisplay&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
public class StringDisplay extends Display {

    private String string;

    public StringDisplay(String string) {
        this.string = string;
    }

    @Override
    public int getColumns() {
        return string.getBytes().length;
    }

    @Override
    public int getRows() {
        return 1;
    }

    @Override
    public String getRowText(int row) {
        return row==0? string: null;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;FullBorder&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class FullBorder extends Border {


    public FullBorder(Display display) {
        super(display);
    }

    @Override
    public int getColumns() {
        return display.getColumns()+2;
    }

    @Override
    public int getRows() {
        return display.getRows()+2;
    }

    @Override
    public String getRowText(int row) {

        if(row==0)
            return &quot;+&quot;+makeLine(&quot;-&quot;,display.getColumns())+&quot;+&quot;;
        else if(row==display.getRows()+1)
            return &quot;+&quot;+makeLine(&quot;-&quot;,display.getColumns())+&quot;+&quot;;
        else
            return &quot;|&quot;+display.getRowText(row-1)+&quot;|&quot;;
    }

    private String makeLine(String s, int columns) {
        StringBuffer buffer = new StringBuffer();
        for (int i = 0; i &amp;lt; columns; i++) {
            buffer.append(s);
        }
        return buffer.toString();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;SideBorder&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class SideBorder extends Border {

    private char aChar;

    public SideBorder(Display display,char ch) {
        super(display);
        this.aChar=ch;

    }

    @Override
    public int getColumns() {
        return display.getColumns()+2;
    }

    @Override
    public int getRows() {
        return display.getRows();
    }

    @Override
    public String getRowText(int row) {
        return aChar+display.getRowText(row)+aChar;
    }
}


&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 24 Oct 2018 14:49:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>Decorator模式？ 假如现在有一块蛋糕，如果只涂上奶油，其他什么都不加，就是奶油蛋糕。如果加上草莓，就是草莓奶油蛋糕。如果再加上一块黑色巧克力板，上面用白色巧克力写上姓名，然后插上代表年龄的蜡烛</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9846783.html</dc:identifier>
</item>
</channel>
</rss>