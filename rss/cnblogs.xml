<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用JAVA基础知识制作简易《订单系统》(适用于初学者学习) - 景小生</title>
<link>http://www.cnblogs.com/c0110/p/9344636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c0110/p/9344636.html</guid>
<description>&lt;p&gt;import java.util.Scanner;&lt;br/&gt;public class OrderingMsg {&lt;br/&gt;    public static void main(String[] args) throws Exception {&lt;br/&gt;    Scanner scanner = new Scanner(System.in);&lt;br/&gt;        String[] names = new String[6]; // 订餐人姓名&lt;br/&gt;        String[] dishMsgs = new String[6];// 选择菜品&lt;br/&gt;        int[] numbers = new int[6];// 菜品份数&lt;br/&gt;        int[] times = new int[6]; // 送餐时间&lt;br/&gt;        String[] addresses = new String[6];// 送餐地址&lt;br/&gt;        int[] states = new int[6];// 订单状态 0:已经预定 1：已经完成&lt;br/&gt;        double[] sumPrices = new double[6];// 总金额&lt;br/&gt;        int[] praiseNums = new int[6];&lt;br/&gt;        String[] dishNames = { &quot;北京烤鸭&quot;, &quot;麻婆豆腐&quot;, &quot;松鼠鱼&quot;, &quot;红烧带鱼&quot;, &quot;时令蔬菜&quot;, &quot;辣土豆丝&quot; };&lt;br/&gt;        double[] prices = { 88, 24, 38, 35, 15, 12 };&lt;br/&gt;        System.out.println(&quot;欢迎进入surper订餐系统&quot;);&lt;br/&gt;        int num = -1; // 输入0 默认返回主菜单&lt;br/&gt;        boolean isExit = false;// 默认不退出&lt;br/&gt;        do {&lt;br/&gt;        System.out.println(&quot;**********************&quot;);&lt;br/&gt;            System.out.println(&quot;1:我要订餐&quot;);&lt;br/&gt;            System.out.println(&quot;2:查看餐袋&quot;);&lt;br/&gt;            System.out.println(&quot;3:签收订单&quot;);&lt;br/&gt;            System.out.println(&quot;4:删除订单&quot;);&lt;br/&gt;            System.out.println(&quot;5:我要点赞&quot;);&lt;br/&gt;            System.out.println(&quot;6:退出系统&quot;);&lt;br/&gt;            System.out.println(&quot;**********************&quot;);&lt;br/&gt;            System.out.println(&quot;请选择：&quot;);&lt;br/&gt;            int choice = scanner.nextInt(); //选择你所需要的服务&lt;br/&gt;            switch (choice) {&lt;br/&gt;            case 1:&lt;br/&gt;                System.out.println(&quot;************我要订餐************&quot;);&lt;br/&gt;                boolean empty = false;//作一个标记&lt;br/&gt;                for (int i = 0; i &amp;lt; names.length; i++) { // 订餐人的集合&lt;br/&gt;                    if (names[i] == null) {&lt;br/&gt;                        empty = true;//订单如果是空的，便可以往里加数据&lt;br/&gt;                        System.out.println(&quot;请输入订餐人的姓名：&quot;);&lt;br/&gt;                        names[i] = scanner.next(); // 获取订餐人的姓名&lt;br/&gt;                        System.out.println(&quot;您可以选择下列的菜品：&quot;);&lt;br/&gt;                        System.out.println(&quot;序号\t\t\t菜名\t\t\t单价\t\t\t点赞数&quot;);&lt;br/&gt;                        for (int j = 0; j &amp;lt; dishNames.length; j++) { // 遍历菜品&lt;br/&gt;                            String praiseNum = (praiseNums[j] &amp;gt; 0) ? praiseNums[j]&lt;br/&gt;                                    + &quot;个赞&quot;&lt;br/&gt;                                    : &quot;&quot;;&lt;br/&gt;                            System.out.println(j + 1 + &quot;\t\t\t&quot; + dishNames[j]&lt;br/&gt;                                    + &quot;\t\t\t&quot; + prices[j] + &quot;\t\t\t&quot;&lt;br/&gt;                                    + praiseNum);&lt;br/&gt;                        }&lt;br/&gt;                        // 用户开始点菜，并收集信息&lt;br/&gt;                        System.out.println(&quot;请您选择菜品的编号：&quot;);&lt;br/&gt;                        int choiceName = scanner.nextInt();&lt;br/&gt;                        System.out.println(&quot;请您输入点餐的份数：&quot;);&lt;br/&gt;                        int number = scanner.nextInt();&lt;br/&gt;                        System.out.println(&quot;请您输入送餐的地址：&quot;);&lt;br/&gt;                        String address = scanner.next();&lt;br/&gt;                        System.out.println(&quot;请您输入送餐的时间：&quot;);&lt;br/&gt;                        System.out.println(&quot;本店整点送餐：8点至20点&quot;);&lt;br/&gt;                        int time = scanner.nextInt();&lt;br/&gt;                        double sumPrice = prices[choiceName - 1] * number;&lt;br/&gt;                        double price = (sumPrice &amp;gt;=50) ? 0 : 5;//判断是否收取运费&lt;br/&gt;                        System.out.println(&quot;订单已生成！&quot;);&lt;br/&gt;                        System.out.println(&quot;您定的菜品是：&quot;+ dishNames[choiceName - 1] + &quot;\t&quot; + number+ &quot;份&quot;);&lt;br/&gt;                        System.out.print(&quot;餐费：&quot; + sumPrice);&lt;br/&gt;                        System.out.print(&quot;\t送餐费：&quot; + price);&lt;br/&gt;                        System.out.println(&quot;\t总费用：&quot; + (price + sumPrice));&lt;br/&gt;                        // 把输入的信息塞进数组中&lt;br/&gt;                        times[i] = time; // 时间&lt;br/&gt;                        addresses[i] = address; // 地址&lt;br/&gt;                        sumPrices[i] = (sumPrice + price); // 总金额&lt;br/&gt;                        dishMsgs[i] = dishNames[choiceName - 1]; // 定的菜品&lt;br/&gt;                        states[i] = 0; // 订餐的状态&lt;br/&gt;                        numbers[i] = number; // 份数&lt;br/&gt;                        break;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                if (!empty) {// 餐袋已经满了&lt;br/&gt;                    System.out.println(&quot;餐袋已经满了&quot;);&lt;br/&gt;                }&lt;br/&gt;                break;&lt;br/&gt;            case 2:&lt;br/&gt;                System.out.println(&quot;************查看餐袋************&quot;);&lt;br/&gt;                System.out.println(&quot;编号\t\t订餐人\t\t菜品(份数)\t\t送餐时间 \t\t送餐地址\t\t总金额\t\t状态\t\t点赞数量&quot;);&lt;br/&gt;                for (int i = 0; i &amp;lt; names.length; i++) {&lt;br/&gt;                    if (names[i] != null) { // 有人订餐 的显示&lt;br/&gt;                        String state = (states[i] == 0) ? &quot;已经预定&quot; : &quot;已经完成&quot;; // 获取状态&lt;br/&gt;                        int time = times[i]; // 时间&lt;br/&gt;                        String sumPrice = sumPrices[i] + &quot;元&quot;; // 总金额&lt;br/&gt;                        String address = addresses[i]; // 地址&lt;br/&gt;                        String dishMsg = dishMsgs[i]; // 菜品&lt;br/&gt;                        int count = numbers[i];//份数&lt;br/&gt;                        System.out.println((i + 1) + &quot;\t\t&quot; + names[i] + &quot;\t\t&quot;+ dishMsg + &quot;(&quot; + count + &quot;)&quot; + &quot;\t\t&quot; + time+ &quot; \t\t&quot; + address + &quot;\t\t&quot; + sumPrice+ &quot;\t\t&quot; + state + &quot;\t\t&quot; + praiseNums[i]);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                break;&lt;br/&gt;            case 3:&lt;br/&gt;                System.out.println(&quot;************签收订单************&quot;);&lt;br/&gt;                System.out.println(&quot;请您输入需要签收的订单编号：&quot;);&lt;br/&gt;                int sign = scanner.nextInt(); &lt;br/&gt;                int flag = 0;// 作一个标记，来判断订单是否被签收&lt;br/&gt;                for (int i = 0; i &amp;lt; names.length; i++) {&lt;br/&gt;                    if (names[i] != null &amp;amp;&amp;amp; states[i] == 0) {//有订单并且可以签收&lt;br/&gt;                        states[i] = 1;// 改变状态&lt;br/&gt;                        flag = 1;&lt;br/&gt;                        break; &lt;br/&gt;                    } else if (names[i] != null &amp;amp;&amp;amp; states[i] == 1) {//有订单，并且已被签收&lt;br/&gt;                        flag = 2;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                if (flag == 1) {&lt;br/&gt;                    System.out.println(&quot;订单已经签收！&quot;);&lt;br/&gt;                } else if (flag == 2) {&lt;br/&gt;                    System.out.println(&quot;订单不能重复签收！&quot;);&lt;br/&gt;                } else {&lt;br/&gt;                    System.out.println(&quot;没有找到您的订单！请您核对编号！&quot;);&lt;br/&gt;                }&lt;/p&gt;&lt;p&gt;                break;&lt;br/&gt;            case 4:&lt;br/&gt;                System.out.println(&quot;************删除订单************&quot;);&lt;br/&gt;                System.out.println(&quot;请您输入需要删除的订单编号：&quot;);&lt;br/&gt;                int dealNum = scanner.nextInt();&lt;br/&gt;                int deal = 0; // 作一个标记 来判断订单是否被签收以及是否存在&lt;br/&gt;                for (int i = 0; i &amp;lt; names.length; i++) {&lt;br/&gt;                    if (names[i] != null &amp;amp;&amp;amp; states[dealNum - 1] == 1) { //有订单，并且已签收，可以删除                            &lt;br/&gt;                        // 删除一条信息，将之后的所有信息，依次向前移&lt;br/&gt;                        for (int j = dealNum - 1; j &amp;lt; names.length - 1; j++) {&lt;br/&gt;                            names[j] = names[j + 1]; // 订餐人&lt;br/&gt;                            dishMsgs[j] = dishMsgs[j + 1];// 菜品&lt;br/&gt;                            times[j] = times[j + 1];// 时间&lt;br/&gt;                            addresses[j] = addresses[j + 1];// 地址&lt;br/&gt;                            states[j] = states[j + 1];// 状态&lt;br/&gt;                            numbers[j] = numbers[j + 1];// 份数&lt;br/&gt;                        }&lt;br/&gt;                        deal = 1;&lt;br/&gt;                        break;&lt;br/&gt;                    } else if (names[i] != null &amp;amp;&amp;amp; states[i] == 0) { // 右订单并且订单还没有签收，便不能删除&lt;br/&gt;                        deal = 2;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                if (deal == 1) {&lt;br/&gt;                    System.out.println(&quot;订单已经被删除&quot;);&lt;br/&gt;                } else if (deal == 2) {&lt;br/&gt;                    System.out.println(&quot;订单还没有签收 不允许删除！&quot;);&lt;br/&gt;                } else {&lt;br/&gt;                    System.out.println(&quot;没有找到指定的订单！&quot;);&lt;br/&gt;                }&lt;br/&gt;                break;&lt;br/&gt;            case 5:&lt;br/&gt;                System.out.println(&quot;************我要点赞***************&quot;);&lt;br/&gt;                System.out.println(&quot;编号\t\t\t菜名\t\t\t价格&quot;);&lt;br/&gt;                for (int i = 0; i &amp;lt; dishNames.length; i++) { // 遍历所有的菜名&lt;br/&gt;                    String price = prices[i] + &quot;元&quot;; //价格&lt;br/&gt;                    String name = dishNames[i];//菜名&lt;br/&gt;                    System.out.println((i + 1) + &quot;\t\t\t&quot; + name + &quot;\t\t\t&quot;+ price);&lt;br/&gt;                }&lt;br/&gt;                System.out.println(&quot;请您输入点赞的菜品编号：&quot;);&lt;br/&gt;                int choiceNum = scanner.nextInt();&lt;br/&gt;                praiseNums[choiceNum - 1]++;// 点赞数累加&lt;br/&gt;                System.out.println(&quot;谢谢参与！点赞成功！&quot;);&lt;br/&gt;                break;&lt;br/&gt;            case 6:&lt;br/&gt;               // 退出系统&lt;br/&gt;                isExit = true;&lt;br/&gt;                break;&lt;br/&gt;            default:&lt;br/&gt;                // 退出系统&lt;br/&gt;                isExit = true;&lt;br/&gt;                break;&lt;br/&gt;            }&lt;br/&gt;            if (!isExit) { // 默认这是不退出&lt;br/&gt;                System.out.println(&quot;输入0返回主菜单！&quot;);&lt;br/&gt;                num = scanner.nextInt();&lt;br/&gt;            } else {&lt;br/&gt;                break; // 退出系统&lt;br/&gt;            }&lt;br/&gt;        } while (num == 0);&lt;br/&gt;        System.out.println(&quot;谢谢您的光临！！！！！&quot;);&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;
</description>
<pubDate>Fri, 20 Jul 2018 15:33:00 +0000</pubDate>
<dc:creator>景小生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c0110/p/9344636.html</dc:identifier>
</item>
<item>
<title>JHipster生成微服务架构的应用栈（二）- 认证微服务示例 - 羽客</title>
<link>http://www.cnblogs.com/yorkwu/p/9330665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yorkwu/p/9330665.html</guid>
<description>&lt;blockquote readability=&quot;7.6942675159236&quot;&gt;
&lt;p&gt;本系列文章演示如何用JHipster生成一个微服务架构风格的应用栈。&lt;br/&gt;环境需求：安装好JHipster开发环境的CentOS 7.4（&lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/yorkwu/p/9274474.html&quot; target=&quot;_blank&quot;&gt;参考这里&lt;/a&gt;&lt;/em&gt;）&lt;br/&gt;应用栈名称：appstack&lt;br/&gt;认证微服务： uaa&lt;br/&gt;业务微服务：microservice1&lt;br/&gt;网关微服务：gateway&lt;br/&gt;实体名：role&lt;br/&gt;主机IP：192.168.220.120&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为业务微服务和网关微服务都会依赖uaa，所以首先生成uaa的工程代码。&lt;br/&gt;进入appstack/uaa目录，输入命令后回车：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cd appstack/uaa/
$ jhipster&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;命令行输出jhipster启动信息&quot;&gt;命令行输出JHipster启动信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719165253645-1258004804.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;现在开始问答环节&quot;&gt;现在开始问答环节&lt;/h3&gt;
&lt;h5 id=&quot;which-type-of-application-would-you-like-to-create&quot;&gt;1.1 Which &lt;em&gt;type&lt;/em&gt; of application would you like to create?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择生成的微服务类型&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有4个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;这里选择&lt;code&gt;JHipster UAA server&lt;/code&gt;，这是一种基于OAuth认证机制的微服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180718200454604-708173420.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;what-is-the-base-name-of-your-application&quot;&gt;1.2 What is the base name of your application?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;输入微服务的名称&lt;/strong&gt;&lt;br/&gt;默认名称是当前目录名&lt;code&gt;uaa&lt;/code&gt;，也可以自己输入名称。&lt;br/&gt;&lt;em&gt;注意：名称只能是大小写字母，数字和下划线的任意组合，不允许任何其它字符。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180718200856122-1167005900.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;as-you-are-running-in-a-microservice-architecture-on-which-port-would-like-your-server-to-run-it-should-be-unique-to-avoid-port-conflicts.&quot;&gt;1.3 As you are running in a microservice architecture, on which port would like your server to run? It should be unique to avoid port conflicts.&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;输入微服务的端口号&lt;/strong&gt;&lt;br/&gt;默认端口号是&lt;code&gt;9999&lt;/code&gt;，也可以自己输入端口号，注意不要和别的微服务和进程的端口号冲突。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180718201334227-1070904463.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;what-is-your-default-java-package-name&quot;&gt;1.4 What is your default Java package name?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;输入微服务的java包名&lt;/strong&gt;&lt;br/&gt;根据整个应用栈的目录层级，这里输入包名&lt;code&gt;com.mycompany.appstack&lt;/code&gt;。&lt;br/&gt;&lt;em&gt;注意：包名要符合Java标准规范的要求。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719111844856-857529919.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;which-service-discovery-server-do-you-want-to-use&quot;&gt;1.5 Which service discovery server do you want to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择一个服务发现组件&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有3个选项，使用上下键切换选项。&lt;br/&gt;根据&lt;strong&gt;微服务体系规划&lt;/strong&gt;，这里选择&lt;code&gt;JHipster Registry&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719111851884-1775725355.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;which-type-of-database-would-you-like-to-use&quot;&gt;1.6 Which &lt;em&gt;type&lt;/em&gt; of database would you like to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择使用的数据库类型&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有4个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;可以看到支持的数据库类型很多，这里选择默认选项&lt;code&gt;SQL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719135206569-1491705716.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;which-production-database-would-you-like-to-use&quot;&gt;1.7 Which &lt;em&gt;production&lt;/em&gt; database would you like to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择生产环境中使用的数据库&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有5个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;可以看到目前支持5种SQL数据库，这里选择默认选项&lt;code&gt;MySQL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719135317048-1291307331.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;which-development-database-would-you-like-to-use&quot;&gt;1.8 Which &lt;em&gt;development&lt;/em&gt; database would you like to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择开发环境中使用的数据库&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有3个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;H2调试起来简单，但为了和生产环境保持一致性，这里选择&lt;code&gt;MySQL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719135427770-156826966.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;do-you-want-to-use-the-spring-cache-abstraction&quot;&gt;1.9 Do you want to use the Spring cache abstraction?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;是否需要使用Spring Cache？&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有5个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;根据实际场景需要，可以选择不同缓存组件；这里简单起见，选择&lt;code&gt;No - Warning, when using an SQL database, this will disable the Hibernate 2nd level cache!&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719135734841-771228636.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;would-you-like-to-use-maven-or-gradle-for-building-the-backend&quot;&gt;1.10 Would you like to use Maven or Gradle for building the backend?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择使用Maven还是Gradle来构建微服务&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有2个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;根据自己的开发环境需要，选择相应的构建工具，这里选择默认选项&lt;code&gt;Maven&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140015608-1671063969.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;which-other-technologies-would-you-like-to-use&quot;&gt;1.11 Which other technologies would you like to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择需要用到的技术组件&lt;/strong&gt;&lt;br/&gt;这是一个多选题，有4个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项，使用&lt;strong&gt;空格键&lt;/strong&gt;选中选项，使用&lt;strong&gt;a键&lt;/strong&gt;全选，使用&lt;strong&gt;i键&lt;/strong&gt;取消全选。&lt;br/&gt;根据自己的技术架构规划，选择相应的技术组件，也可以都不选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140116937-1174196637.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;would-you-like-to-enable-internationalization-support&quot;&gt;1.12 Would you like to enable internationalization support?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;是否需要国际化支持？&lt;/strong&gt;&lt;br/&gt;默认选择是&lt;code&gt;Y&lt;/code&gt;，如果不需要，输入&lt;code&gt;n&lt;/code&gt;；这里选择默认选项&lt;code&gt;Y&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140231984-767920127.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;please-choose-the-native-language-of-the-application&quot;&gt;1.13 Please choose the native language of the application&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择国际化支持中的母语&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有37个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;&lt;em&gt;注意：这个问题和上一个问题(1.12)的选择有关联性，上一个问题如果选择&lt;code&gt;n&lt;/code&gt;，这个问题不会出现。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140404496-1180916656.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;please-choose-additional-languages-to-install&quot;&gt;1.14 Please choose additional languages to install&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择国际化支持中的其它语言&lt;/strong&gt;&lt;br/&gt;这是一个多选题，有37个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项，使用&lt;strong&gt;空格键&lt;/strong&gt;选中选项，使用&lt;strong&gt;a键&lt;/strong&gt;全选，使用&lt;strong&gt;i键&lt;/strong&gt;取消全选。&lt;br/&gt;根据自己的业务规划，选择相应的语言，也可以都不选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140508179-1398577723.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;besides-junit-and-jest-which-testing-frameworks-would-you-like-to-use&quot;&gt;1.15 Besides JUnit and Jest, which testing frameworks would you like to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择单元测试工具&lt;/strong&gt;&lt;br/&gt;这是一个多选题，有2个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项，使用&lt;strong&gt;空格键&lt;/strong&gt;选中选项，使用&lt;strong&gt;a键&lt;/strong&gt;全选，使用&lt;strong&gt;i键&lt;/strong&gt;取消全选。&lt;br/&gt;根据自己的技术架构规划，选择相应的技术组件，也可以都不选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140658447-1026914630.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;would-you-like-to-install-other-generators-from-the-jhipster-marketplace&quot;&gt;1.16 Would you like to install other generators from the JHipster Marketplace?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;是否需要从JHipster市场中安装其它的开发工具？&lt;/strong&gt;&lt;br/&gt;默认选择是&lt;code&gt;N&lt;/code&gt;，如果需要启用，输入&lt;code&gt;y&lt;/code&gt;；这里选择默认选项&lt;code&gt;N&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719141910080-469950730.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h3 id=&quot;问答结束开始生成工程代码&quot;&gt;问答结束，开始生成工程代码&lt;/h3&gt;
&lt;p&gt;这个过程，根据电脑性能和网速的不同，通常需要1-3分钟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719144015832-1062939446.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，生成认证微服务工程代码成功完成。可以在appstack/uaa目录下查看所有生成的文件。&lt;/p&gt;

&lt;h3 id=&quot;启动一个数据库容器&quot;&gt;2.1 启动一个数据库容器&lt;/h3&gt;
&lt;p&gt;在命令行，任意目录下，启动一个mysql容器；如果本地没有mysql:5.7.13的镜像，容器启动时会自动去docker store下载镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker container run --name uaa-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d -p 32900:3306 mysql:5.7.13&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在数据库中创建schema&quot;&gt;2.2 在数据库中创建schema&lt;/h3&gt;
&lt;p&gt;通过客户端连接上刚启动的数据库容器，添加一个名为&lt;code&gt;uaa&lt;/code&gt;的schema。微服务启动时会自动在这个schema里面创建数据表。&lt;/p&gt;
&lt;h3 id=&quot;修改微服务的数据库配置&quot;&gt;2.3 修改微服务的数据库配置&lt;/h3&gt;
&lt;p&gt;spring.datasource.url中的端口号&lt;code&gt;32900&lt;/code&gt;，与步骤2.1中&lt;strong&gt;-p&lt;/strong&gt;参数指定的值保持一致。&lt;br/&gt;spring.datasource.url中的schema名称&lt;code&gt;uaa&lt;/code&gt;，与步骤2.2中添加的schema名称保持一致。&lt;br/&gt;spring.datasource.password的值&lt;code&gt;my-secret-pw&lt;/code&gt;，与步骤2.1中&lt;code&gt;MYSQL_ROOT_PASSWORD&lt;/code&gt;参数指定的值保持一致。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cd uaa/
$ vi src/main/resources/config/application-dev.yml
# 修改数据库连接相关配置
spring:
    datasource:
        url: jdbc:mysql://localhost:32900/uaa?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false
        username: root
        password: my-secret-pw&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;构建&quot;&gt;3.1 构建&lt;/h3&gt;
&lt;p&gt;进入uaa目录，输入命令后回车：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cd uaa/
$ mvn -Pdev package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一切正常，命令行会输出构建成功信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719144036321-1699610122.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动&quot;&gt;3.2 启动&lt;/h3&gt;
&lt;p&gt;进入uaa目录，输入命令后回车：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nohup ./target/uaa-0.0.1-SNAPSHOT.war &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;strong&gt;tail&lt;/strong&gt;命令，查看启动日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ tail -f nohup.out&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一切正常，日志会输出启动成功信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719145129249-1508462915.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;注册到jhipster-registry&quot;&gt;3.3 注册到JHipster Registry&lt;/h3&gt;
&lt;p&gt;启动完成后，可以通过浏览器访问&lt;code&gt;http://192.168.220.120:8761&lt;/code&gt;，登录名和密码默认都是&lt;code&gt;admin&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719145656560-834218114.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到在&lt;strong&gt;Instances Registered&lt;/strong&gt;区域，uaa已经注册。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/yorkwu/p/9335968.html&quot; target=&quot;_blank&quot;&gt;JHipster生成微服务架构的应用栈（一）- 准备工作&lt;/a&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;JHipster生成微服务架构的应用栈（二）- 认证微服务示例&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/yorkwu/p/9335937.html&quot; target=&quot;_blank&quot;&gt;JHipster生成微服务架构的应用栈（三）- 业务微服务示例&lt;/a&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/yorkwu/p/9336241.html&quot; target=&quot;_blank&quot;&gt;JHipster生成微服务架构的应用栈（四）- 网关微服务示例&lt;/a&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/yorkwu/p/9336251.html&quot; target=&quot;_blank&quot;&gt;JHipster生成微服务架构的应用栈（五）- 容器编排示例&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Jul 2018 15:28:00 +0000</pubDate>
<dc:creator>羽客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yorkwu/p/9330665.html</dc:identifier>
</item>
<item>
<title>Reactor模式理解 - wangyunfeifeifei</title>
<link>http://www.cnblogs.com/swust-wangyf/p/9344595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swust-wangyf/p/9344595.html</guid>
<description>&lt;p&gt;也可以叫反应器模式或者应答者模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;reactor模式简介&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们先了解一下阻塞I/O与非阻塞I/O&lt;/p&gt;
&lt;h3 id=&quot;io-是非常缓慢的&quot;&gt;I/O 是非常缓慢的&lt;/h3&gt;
&lt;p&gt;I/O绝对是计算机操作中最慢的。访问RAM的事件为ns级别，而访问磁盘或网络上的数据是ms级别的。&lt;/p&gt;
&lt;h3 id=&quot;阻塞io与非阻塞io&quot;&gt;阻塞I/O与非阻塞I/O&lt;/h3&gt;
&lt;p&gt;阻塞I/O的意思是，一个I/O相关的请求发送过来，相对应的函数调用，将阻塞的线程执行，直到操作完成&lt;br/&gt;非阻塞I/O的意思是，一个I/O请求，系统收到后立即返回,然后系统会主动有一个轮询，当I/O请求完毕时，开始执行I/O相关的函数调用。&lt;br/&gt;接下来我用一个经典的例子来描述这两种I/O的区别&lt;/p&gt;
&lt;p&gt;以一个餐饮为例，每一个人来就餐就是一个事件，他会先看一下菜单，然后点餐。就像一个网站会有很多的请求，要求服务器做一些事情。处理这些就餐事件的就需要我们的服务人员了。&lt;/p&gt;
&lt;p&gt;在多线程处理的方式会是这样的：&lt;/p&gt;
&lt;p&gt;一个人来就餐，一个服务员去服务，然后客人会看菜单，点菜。 服务员将菜单给后厨。&lt;/p&gt;
&lt;p&gt;二个人来就餐，二个服务员去服务……&lt;/p&gt;
&lt;p&gt;五个人来就餐，五个服务员去服务……&lt;/p&gt;
&lt;p&gt;这个就是多线程的处理方式，一个事件到来，就会有一个线程服务。很显然这种方式在人少的情况下会有很好的用户体验，每个客人都感觉自己是VIP，专人服务的。如果餐厅一直这样同一时间最多来5个客人，这家餐厅是可以很好的服务下去的。&lt;/p&gt;
&lt;p&gt;来了一个好消息，因为这家店的服务好，吃饭的人多了起来。同一时间会来10个客人，老板很开心，但是只有5个服务员，这样就不能一对一服务了，有些客人就要没有人管了。老板就又请了5个服务员，现在好了，又能每个人都受VIP待遇了。&lt;/p&gt;
&lt;p&gt;越来越多的人对这家餐厅满意，客源又多了，同时来吃饭的人到了20人，老板高兴不起来了，再请服务员吧，占地方不说，还要开工钱，再请人就攒不到钱了。怎么办呢？老板想了想，10个服务员对付20个客人也是能对付过来的，服务员勤快点就好了，伺候完一个客人马上伺候另外一个，还是来得及的。综合考虑了一下，老板决定就使用10个服务人员的线程池啦~~~&lt;/p&gt;
&lt;p&gt;但是这样有一个比较严重的缺点就是，如果正在接受服务员服务的客人点菜很慢，其他的客人可能就要等好长时间了。有些火爆脾气的客人可能就等不了走人了。&lt;/p&gt;
&lt;p&gt;而非阻塞I/O会选择这样做:&lt;/p&gt;
&lt;p&gt;老板后来发现，客人点菜比较慢，大部服务员都在等着客人点菜，其实干的活不是太多。老板能当老板当然有点不一样的地方，终于发现了一个新的方法，那就是：当客人点菜的时候，服务员就可以去招呼其他客人了，等客人点好了菜，直接招呼一声“服务员”，马上就有个服务员过去服务。嘿嘿，然后在老板有了这个新的方法之后，就进行了一次裁员，只留了一个服务员！这就是用单个线程来做多线程的事。&lt;/p&gt;
&lt;h3 id=&quot;事件多路分解器&quot;&gt;事件多路分解器&lt;/h3&gt;
&lt;p&gt;大多数现代操作系统提供了一种本机机制，该机制通过一种有效的方式处理并发和非阻塞资源.这种机制称为&lt;strong&gt;同步事件多路分解器&lt;/strong&gt;或&lt;strong&gt;事件通知借口&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用reactor模式时会发生什么&quot;&gt;使用Reactor模式时会发生什么&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;应用程序向&lt;strong&gt;事件多路分解器&lt;/strong&gt;提交请求来生成新的I/O操作。应用程序还指定一个处理程序，当操作完成时将调用该处理程序。向&lt;strong&gt;事件多路分解器&lt;/strong&gt;提交新请求是一种非阻塞调用，它立即将控制权返回给应用程序&lt;/li&gt;
&lt;li&gt;当一组I/O操作完成时，&lt;strong&gt;事件多路分解器&lt;/strong&gt;将新的事件推入&lt;strong&gt;Event Queue(事件队列)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;此时，&lt;strong&gt;Event Loop&lt;/strong&gt; 遍历&lt;strong&gt;Event Queue(事件队列)&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;对于每个事件，调用关联的处理程序。&lt;/li&gt;
&lt;li&gt;处理程序是应用程序代码的一部分，当它执行完成时将把控制权返还给&lt;strong&gt;Event Loop&lt;/strong&gt;.但是，在处理程序执行过程中可能会请求新的异步操作，从而导致新的操作被插入&lt;strong&gt;事件多路分解器&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;Event Queue(事件队列)&lt;/strong&gt; 中所有项目被处理完时，循环将再次阻塞&lt;strong&gt;事件多路分解器&lt;/strong&gt; ,当有新事件可用时，&lt;strong&gt;事件多路分解器&lt;/strong&gt; 将出发另一个周期.&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 20 Jul 2018 15:18:00 +0000</pubDate>
<dc:creator>wangyunfeifeifei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/swust-wangyf/p/9344595.html</dc:identifier>
</item>
<item>
<title>【react开发】使用swiper插件，loop:true时产生的问题解决方案 - 海瑞菌·博客</title>
<link>http://www.cnblogs.com/wuhairui/p/9343846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhairui/p/9343846.html</guid>
<description>&lt;p&gt;这2天上班遇到的问题：react使用swiper3插件实现banner轮播，其中有个banner图有个click点击事件，而其他的是页面跳转。出现了一个问题：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是&lt;/span&gt;&lt;span&gt;向右滑动到该帧时的&lt;/span&gt;&lt;span&gt;swiper，点击时未触发react的onClick方法。&lt;/span&gt;&lt;/p&gt;
&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;92676&quot; data-color=&quot;#ef7060&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;80%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;因为昨天玩滑板时，手上受了点伤，所以今天没出去玩了，休息一天。于是正好拿来整理下一个技术点。&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;80%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;&lt;strong&gt;这里我们使用简单案例来说明：&lt;/strong&gt;&lt;/p&gt;
&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85638&quot; data-color=&quot;#ef7060&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;text&quot;&gt;错误示范&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;我们先来看看错误代码（其实理论是正确的）：&lt;/p&gt;
&lt;p&gt;组件初始化一个banner数组&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/SZndEqK9_vtRB.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;render中渲染出轮询banner，并给每个banner绑定一个onClick事件，传入参数i&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/s6Nx4cWB_UfBI.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绑定的方法：点击后执行弹出当前为第几个banner&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/OXGDJehS_M6qj.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Swiper对象，初始化为轮播图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/j334IOtS_IJIz.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;照理来讲，我们分别点击这个swiper的每个banner应该会弹出1、2、1、2……的&lt;/p&gt;

&lt;p&gt;但是实际上：&lt;/p&gt;
&lt;p&gt;（点击1、2两图时触发了，但是点击第3图，click方法就没生效了）&lt;/p&gt;
&lt;p&gt;动态图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/QPY2dQxm_Vjep.gif&quot; alt=&quot;GIF.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们来分析一下原因吧：&lt;/p&gt;
&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85638&quot; data-color=&quot;#ef7060&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;text&quot;&gt;原因&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;首先，banner只有2个，照理应该是2个swiper-slide，&lt;/p&gt;
&lt;p&gt;但是在初始化时使用了loop:true&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/NSARUnHs_2AGJ.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;便由swiper插件再复制生成了2个。因此有了4个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/pvtbKYnf_uJ3e.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而新的2个slide是swiper插件生成的，并没有绑定react的事件，所以点击之后没有触发到事件。&lt;/p&gt;
&lt;p&gt;怎么办呢？其实这样的效果已经无法完全使用react处理了。因为插件生成的swiper并不是虚拟dom了。&lt;/p&gt;
&lt;p&gt;所以这里需要使用到部分的dom操作。然后和react连接起来。&lt;/p&gt;
&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85638&quot; data-color=&quot;#ef7060&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;text&quot;&gt;正确示范&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;来看看解决方案吧&lt;/p&gt;
&lt;p&gt;数据一样，第2图中，我们在slide中加入一个属性data-i，这个i就是我们之后要用到方法中参数&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/Ndz2Xmwk_rpFb.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们在初始化之后，给每个slide绑定一个click事件：&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击后拿到之前绑定的i，表示当前点击的是第几个banner，然后再调用组件对象的click方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/sXXjMFWL_sxYH.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（这里的_this代表当前react组件对象，因为前面声明了，这样就又可以从dom操作回到react操作了）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/m2YLfbZP_C5dw.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85638&quot; data-color=&quot;#ef7060&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;text&quot;&gt;运行实例&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;现在我们来看看这个案例：&lt;/p&gt;
&lt;p&gt;请长按识别二维码（点击）打开：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;a href=&quot;http://coding.wuhairui.cn/react/1.html&quot;&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/JW72ZYGz_qkXh.png&quot; title=&quot;82f93fc4b1460f681cc53da6c57fb434.png&quot; alt=&quot;82f93fc4b1460f681cc53da6c57fb434.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;


</description>
<pubDate>Fri, 20 Jul 2018 14:11:00 +0000</pubDate>
<dc:creator>海瑞菌&amp;#183;博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhairui/p/9343846.html</dc:identifier>
</item>
<item>
<title>MapReduce剥洋葱 - sunjavakai</title>
<link>http://www.cnblogs.com/sunjava/p/9343825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunjava/p/9343825.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、&lt;/strong&gt;&lt;strong&gt;大白话&lt;/strong&gt;&lt;strong&gt;MapReduce&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.什么是Map/Reduce，看下面的各种解释：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(1)MapReduce是hadoop的核心组件之一，hadoop要分布式包括两部分，一是分布式文件系统hdfs,一部是分布式计算框，就是mapreduce,缺一不可，也就是说，可以通过mapreduce很容易在hadoop平台上进行分布式的计算编程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(2)Mapreduce是一种编程模型，是一种编程方法，抽象理论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(3)下面是一个关于一个程序员是如何个妻子讲解什么是MapReduce？文章很长请耐心的看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我问妻子：“你真的想要弄懂什么是MapReduce？” 她很坚定的回答说“是的”。 因此我问道：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 你是如何准备洋葱辣椒酱的？（以下并非准确食谱，请勿在家尝试）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 我会取一个洋葱，把它切碎，然后拌入盐和水，最后放进混合研磨机里研磨。这样就能得到洋葱辣椒酱了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 但这和MapReduce有什么关系？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 你等一下。让我来编一个完整的情节，这样你肯定可以在15分钟内弄懂MapReduce.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 好吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我：现在，假设你想用薄荷、洋葱、番茄、辣椒、大蒜弄一瓶混合辣椒酱。你会怎么做呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 我会取薄荷叶一撮，洋葱一个，番茄一个，辣椒一根，大蒜一根，切碎后加入适量的盐和水，再放入混合研磨机里研磨，这样你就可以得到一瓶混合辣椒酱了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 没错，让我们把MapReduce的概念应用到食谱上。Map和Reduce其实是两种操作，我来给你详细讲解下。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Map（映射）: 把洋葱、番茄、辣椒和大蒜切碎，是各自作用在这些物体上的一个Map操作。所以你给Map一个洋葱，Map就会把洋葱切碎。 同样的，你把辣椒，大蒜和番茄一一地拿给Map，你也会得到各种碎块。 所以，当你在切像洋葱这样的蔬菜时，你执行就是一个Map操作。 Map操作适用于每一种蔬菜，它会相应地生产出一种或多种碎块，在我们的例子中生产的是蔬菜块。在Map操作中可能会出现有个洋葱坏掉了的情况，你只要把坏洋葱丢了就行了。所以，如果出现坏洋葱了，Map操作就会过滤掉坏洋葱而不会生产出任何的坏洋葱块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Reduce（化简）:在这一阶段，你将各种蔬菜碎都放入研磨机里进行研磨，你就可以得到一瓶辣椒酱了。这意味要制成一瓶辣椒酱，你得研磨所有的原料。因此，研磨机通常将map操作的蔬菜碎聚集在了一起。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 所以，这就是MapReduce?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 你可以说是，也可以说不是。 其实这只是MapReduce的一部分，MapReduce的强大在于分布式计算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 分布式计算？ 那是什么？请给我解释下吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 没问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 假设你参加了一个辣椒酱比赛并且你的食谱赢得了最佳辣椒酱奖。得奖之后，辣椒酱食谱大受欢迎，于是你想要开始出售自制品牌的辣椒酱。假设你每天需要生产10000瓶辣椒酱，你会怎么办呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 我会找一个能为我大量提供原料的供应商。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我：是的..就是那样的。那你能否独自完成制作呢？也就是说，独自将原料都切碎？ 仅仅一部研磨机又是否能满足需要？而且现在，我们还需要供应不同种类的辣椒酱，像洋葱辣椒酱、青椒辣椒酱、番茄辣椒酱等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 当然不能了，我会雇佣更多的工人来切蔬菜。我还需要更多的研磨机，这样我就可以更快地生产辣椒酱了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我：没错，所以现在你就不得不分配工作了，你将需要几个人一起切蔬菜。每个人都要处理满满一袋的蔬菜，而每一个人都相当于在执行一个简单的Map操作。每一个人都将不断的从袋子里拿出蔬菜来，并且每次只对一种蔬菜进行处理，也就是将它们切碎，直到袋子空了为止。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这样，当所有的工人都切完以后，工作台（每个人工作的地方）上就有了洋葱块、番茄块、和蒜蓉等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子：但是我怎么会制造出不同种类的番茄酱呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我：现在你会看到MapReduce遗漏的阶段—搅拌阶段。MapReduce将所有输出的蔬菜碎都搅拌在了一起，这些蔬菜碎都是在以key为基础的 map操作下产生的。搅拌将自动完成，你可以假设key是一种原料的名字，就像洋葱一样。 所以全部的洋葱keys都会搅拌在一起，并转移到研磨洋葱的研磨器里。这样，你就能得到洋葱辣椒酱了。同样地，所有的番茄也会被转移到标记着番茄的研磨器里，并制造出番茄辣椒酱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上面都是从理论上来说明什么是MapReduce，那么咱们在MapReduce产生的过程和代码的角度来理解这个问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;：如果想统计下过去10年计算机论文出现最多的几个单词，看看大家都在研究些什么，那收集好论文后，该怎么办呢？ &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法一：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      我可以写一个小程序，把所有论文按顺序遍历一遍，统计每一个遇到的单词的出现次数，最后就可以知道哪几个单词最热门了。 这种方法在数据集比较小时，是非常有效的，而且实现最简单，用来解决这个问题很合适。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法二：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       写一个多线程程序，并发遍历论文。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　这个问题理论上是可以高度并发的，因为统计一个文件时不会影响统计另一个文件。当我们的机器是多核或者多处理器，方法二肯定比方法一高效。但是写一个多线程程序要比方法一困难多了，我们必须自己同步共享数据，比如要防止两个线程重复统计文件。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法三：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      把作业交给多个计算机去完成。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　我们可以使用方法一的程序，部署到N台机器上去，然后把论文集分成N份，一台机器跑一个作业。这个方法跑得足够快，但是部署起来很麻烦，我们要人工把程序copy到别的机器，要人工把论文集分开，最痛苦的是还要把N个运行结果进行整合（当然我们也可以再写一个程序）。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法四：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      让MapReduce来帮帮我们吧！ &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　MapReduce本质上就是方法三，但是如何拆分文件集，如何copy程序，如何整合结果这些都是框架定义好的。我们只要定义好这个任务（用户程序），其它都交给MapReduce。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;map函数和reduce函数　　&lt;/span&gt;&lt;br/&gt;&lt;span&gt;map函数和reduce函数是交给用户实现的，这两个函数定义了任务本身。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　map函数：接受一个键值对（key-value pair），产生一组中间键值对。MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　reduce函数：接受一个键，以及相关的一组值，将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二&lt;/strong&gt; &lt;strong&gt;MapReduce&lt;/strong&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;strong&gt;wordcount&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720220956470-294546640.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编程实现wordcount&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_ae37d663-5286-4ebf-87e7-7fc38042653c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ae37d663-5286-4ebf-87e7-7fc38042653c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_ae37d663-5286-4ebf-87e7-7fc38042653c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

 * KEYIN：输入kv数据对中key的数据类型

 * VALUEIN：输入kv数据对中value的数据类型

 * KEYOUT：输出kv数据对中key的数据类型

 * VALUEOUT：输出kv数据对中value的数据类型

 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WordCountMapper &lt;span&gt;extends&lt;/span&gt; Mapper&amp;lt;LongWritable, Text, Text, IntWritable&amp;gt;&lt;span&gt;{

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

          * map方法是提供给map task进程来调用的，map task进程是每读取一行文本来调用一次我们自定义的map方法

          * map task在调用map方法时，传递的参数：

          *             一行的起始偏移量LongWritable作为key

          *             一行的文本内容Text作为value

          &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         @Override

         &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; map(LongWritable key, Text value,Context context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException {

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到一行文本内容，转换成String 类型&lt;/span&gt;
&lt;span&gt;
                   String line &lt;/span&gt;=&lt;span&gt; value.toString();

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将这行文本切分成单词&lt;/span&gt;
&lt;span&gt;
                   String[] words&lt;/span&gt;=line.split(&quot; &quot;&lt;span&gt;);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出&amp;lt;单词，1&amp;gt;&lt;/span&gt;

                   &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String word:words){

                            context.write(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(word), &lt;span&gt;new&lt;/span&gt; IntWritable(1&lt;span&gt;));

                   }

         }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

 * KEYIN：对应mapper阶段输出的key类型

 * VALUEIN：对应mapper阶段输出的value类型

 * KEYOUT：reduce处理完之后输出的结果kv对中key的类型

 * VALUEOUT：reduce处理完之后输出的结果kv对中value的类型

 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WordCountReducer &lt;span&gt;extends&lt;/span&gt; Reducer&amp;lt;Text, IntWritable, Text, IntWritable&amp;gt;&lt;span&gt;{

         @Override

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

          * reduce方法提供给reduce task进程来调用

          *

          * reduce task会将shuffle阶段分发过来的大量kv数据对进行聚合，聚合的机制是相同key的kv对聚合为一组

          * 然后reduce task对每一组聚合kv调用一次我们自定义的reduce方法

          * 比如：&amp;lt;hello,1&amp;gt;&amp;lt;hello,1&amp;gt;&amp;lt;hello,1&amp;gt;&amp;lt;tom,1&amp;gt;&amp;lt;tom,1&amp;gt;&amp;lt;tom,1&amp;gt;

          *  hello组会调用一次reduce方法进行处理，tom组也会调用一次reduce方法进行处理

          *  调用时传递的参数：

          *                     key：一组kv中的key

          *                     values：一组kv中所有value的迭代器

          &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; reduce(Text key, Iterable&amp;lt;IntWritable&amp;gt; values,Context context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException {

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个计数器&lt;/span&gt;

                   &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过value这个迭代器，遍历这一组kv中所有的value，进行累加&lt;/span&gt;

                   &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(IntWritable value:values){

                            count&lt;/span&gt;+=&lt;span&gt;value.get();

                   }

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出这个单词的统计结果&lt;/span&gt;
&lt;span&gt;
                   context.write(key, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IntWritable(count));

         }

}

 

 

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WordCountJobSubmitter {

        

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException, InterruptedException {

                   Configuration conf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration();

                   Job wordCountJob &lt;/span&gt;=&lt;span&gt; Job.getInstance(conf);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重要：指定本job所在的jar包&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.setJarByClass(WordCountJobSubmitter.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置wordCountJob所用的mapper逻辑类为哪个类&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.setMapperClass(WordCountMapper.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置wordCountJob所用的reducer逻辑类为哪个类&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.setReducerClass(WordCountReducer.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置map阶段输出的kv数据类型&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.setMapOutputKeyClass(Text.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                   wordCountJob.setMapOutputValueClass(IntWritable.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置最终输出的kv数据类型&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.setOutputKeyClass(Text.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                   wordCountJob.setOutputValueClass(IntWritable.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要处理的文本数据所存放的路径&lt;/span&gt;
&lt;span&gt;
                   FileInputFormat.setInputPaths(wordCountJob, &lt;/span&gt;&quot;hdfs://192.168.77.70:9000/wordcount/srcdata/&quot;&lt;span&gt;);

                   FileOutputFormat.setOutputPath(wordCountJob, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Path(&quot;hdfs://192.168.77.70:9000/wordcount/output/&quot;&lt;span&gt;));

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交job给hadoop集群&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.waitForCompletion(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

         }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、&lt;/strong&gt; &lt;strong&gt;MapReduce&lt;/strong&gt;&lt;strong&gt;过程详解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MapReduce过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Input --》 Map --》 shuffle --》 Reduce  --》 Output&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221023497-599680482.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MapReduce中，分片、分区、排序和分组（Group）的关系图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221033788-255919925.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于HDFS中存储的一个文件，要进行Map处理前，需要将它切分成多个块，才能分配给不同的MapTask去执行。 分片的数量等于启动的MapTask的数量。默认情况下，分片的大小就是HDFS的blockSize。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Map阶段的对数据文件的切片，使用如下判断逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;  protected long computeSplitSize(long blockSize, long minSize,&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;                                  long maxSize) {&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    return Math.max(minSize, Math.min(maxSize, blockSize));&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;  }&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;blockSize：默认大小是128M（&lt;span&gt;&lt;a href=&quot;https://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml#dfs.blockSize&quot; target=&quot;https://www.cnblogs.com/huqiaoblog/p/_blank&quot;&gt;dfs.blocksize&lt;/a&gt;&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;minSize：默认是1byte（mapreduce.input.fileinputformat.split.minsize）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221147561-1811192624.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxSize：默认值是Long.MaxValue（mapreduce.input.fileinputformat.split.minsize）&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221206186-1805488531.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由此可以看出两个可以自定义的值（minSize和maxSize）与blockSize之间的关系如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当blockSize位于minSize和maxSize 之间时，认blockSize：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221219332-509415270.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当maxSize小于blockSize时，认maxSize：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221227779-1340679478.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当minSize大于blockSize时，认minSize：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221235322-1198081274.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外一个极端的情况，maxSize小于minSize时，认minsize，可以理解为minSize的优先级比maxSize大：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221245180-234042056.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际使用中，建议不要去修改maxSize，通过调整minSize（使他大于blockSize）就可以设定分片（Split）的大小了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总之通过minSize和maxSize的来设置切片大小，使之在blockSize的上下自由调整。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么时候需要调整分片的大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先要明白，HDFS的分块其实是指HDFS在存储文件时的一个参数。而这里分片的大小是为了业务逻辑用的。分片的大小直接影响到MapTask的数量，你可以根据实际的业务需求来调整分片的大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在Reduce过程中，可以根据实际需求（比如按某个维度进行归档，类似于数据库的分组），把Map完的数据Reduce到不同的文件中。分区的设置需要与ReduceTaskNum配合使用。比如想要得到5个分区的数据结果。那么就得设置5个ReduceTask。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自定义Partitioner：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;public class URLResponseTimePartitioner extends Partitioner&amp;lt;Text, LongWritable&amp;gt;{&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    @Override&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    public int getPartition(Text key, LongWritable value, int numPartitions) {&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        String accessPath = key.toString();&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        if(accessPath.endsWith(&quot;.do&quot;)) {&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;            return 0;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        }&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        return 1;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    }&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;然后可以在job中设置partitioner：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;        job.setPartitionerClass(URLResponseTimePartitioner.class);&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        //URLResponseTimePartitioner returns 1 or 0,so num of reduce task must be 2&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        job.setNumReduceTasks(2);&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;两个分区会产生两个最终结果文件：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;[root@centos01 ~]# hadoop fs -ls /access/log/response-time17/12/19 14:53:55 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;Found 3 items-rw-r--r--   2 root supergroup          0 2017-12-19 14:49 /access/log/response-time/_SUCCESS-rw-r--r--   2 root supergroup       7769 2017-12-19 14:49 /access/log/response-time/part-r-00000&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;-rw-r--r--   2 root supergroup      18183 2017-12-19 14:49 /access/log/response-time/part-r-00001&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;其中00000中存放着.do的统计结果，00001则存放其他访问路径的统计结果。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;[root@centos01 ~]# hadoop fs -cat /access/log/response-time/part-r-00001 |more17/12/19 14:55:41 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable//MyAdmin/scripts/setup.php     3857//css/console.css       356//css/result_html.css   628//images/male.png       268//js/tooltipster/css/plugins/tooltipster/sideTip/themes/tooltipster-sideTip-borderless.min.css  1806//js/tooltipster/css/tooltipster.bundle.min.css 6495//myadmin/scripts/setup.php     3857//phpMyAdmin/scripts/setup.php  3857//phpmyadmin/scripts/setup.php  3857//pma/scripts/setup.php 3857&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/404/search_children.js 3827&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/Dashboard.action       3877&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/Homepage.action        3877&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/WdatePicker.js  9371&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/calendar.js     22044&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/lang/zh-cn.js   1089&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/skin/WdatePicker.css    158&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/skin/default/datepicker.css     3486&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/skin/default/img.gif    475&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;要想最终结果中按某个特性排序，则需要在Map阶段，通过Key的排序来实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，想让上述平均响应时间的统计结果按降序排列，实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键就在于这个用于OUTKey的Bean。它实现了Comparable接口，所以输出的结果就是按compareTo的结果有序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于这个类会作为&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;，所以它的&lt;/span&gt;&lt;span&gt;equals&lt;/span&gt;&lt;span&gt;方法很重要，会作为，需要按实际情况重写。这里重写的逻辑是&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;相等则表示是同一个&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;。（虽然&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;相同的情况其实没有，因为之前的&lt;/span&gt;&lt;span&gt;responseTime&lt;/span&gt;&lt;span&gt;统计结果已经把&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;做了&lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;，但是这里还是要注意有这么个逻辑。）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;排序并不是依赖于key的equals！&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;em&gt;  public class URLResponseTime implements WritableComparable&amp;lt;URLResponseTime&amp;gt;{&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    String url;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;long&lt;/em&gt;&lt;em&gt; avgResponseTime;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;void&lt;/em&gt;&lt;em&gt; write(DataOutput out) &lt;/em&gt;&lt;em&gt;throws&lt;/em&gt;&lt;em&gt; IOException {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        out.writeUTF(url);&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        out.writeLong(avgResponseTime);&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;void&lt;/em&gt;&lt;em&gt; readFields(DataInput in) &lt;/em&gt;&lt;em&gt;throws&lt;/em&gt;&lt;em&gt; IOException {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt;.url = in.readUTF();&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt;.avgResponseTime = in.readLong();&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;int&lt;/em&gt;&lt;em&gt; compareTo(URLResponseTime urt) {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt;.avgResponseTime &amp;gt; urt.avgResponseTime ? -1 : 1;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt; String getUrl() {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt; url;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;void&lt;/em&gt;&lt;em&gt; setUrl(String url) {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt;.url = url;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;long&lt;/em&gt;&lt;em&gt; getAvgResponseTime() {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt; avgResponseTime;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;void&lt;/em&gt;&lt;em&gt; setAvgResponseTime(&lt;/em&gt;&lt;em&gt;long&lt;/em&gt;&lt;em&gt; avgResponseTime) {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt;.avgResponseTime = avgResponseTime;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    @Override&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;int&lt;/em&gt;&lt;em&gt; hashCode() {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;final&lt;/em&gt;&lt;em&gt;int&lt;/em&gt;&lt;em&gt; prime = 31;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;int&lt;/em&gt;&lt;em&gt; result = 1;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        result = prime * result + ((url == &lt;/em&gt;&lt;em&gt;null&lt;/em&gt;&lt;em&gt;) ? 0 : url.hashCode());&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt; result;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    @Override&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;boolean&lt;/em&gt;&lt;em&gt; equals(Object obj) {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt; == obj)&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;            &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;true&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (obj == &lt;/em&gt;&lt;em&gt;null&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;            &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;false&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (getClass() != obj.getClass())&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;            &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;false&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        URLResponseTime other = (URLResponseTime) obj;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (url == &lt;/em&gt;&lt;em&gt;null&lt;/em&gt;&lt;em&gt;) {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;            &lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (other.url != &lt;/em&gt;&lt;em&gt;null&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;                &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;false&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        } &lt;/em&gt;&lt;em&gt;else&lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (!url.equals(other.url))&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;            &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;false&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;true&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    @Override&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt; String toString() {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt; url;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;br/&gt;}&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;然后就简单了，在Map和Reduce分别执行简单的写和读操作就行了，没有更多的处理，依赖于Hadoop MapReduce框架自身的特点就实现了排序：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Mapreduce排序分组&quot; href=&quot;https://www.cnblogs.com/sunddenly/p/4009751.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/sunddenly/p/4009751.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、&lt;/strong&gt;&lt;strong&gt;Mapreduce&lt;/strong&gt; &lt;strong&gt;项目实战&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需求：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户行为日志清洗，分析出用户行为链。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现方式：根据用户曝光页面时间排序。（粗略）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自定义分区,分组,排序&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;job.setSortComparatorClass(LogDataSortComparator.&lt;strong&gt;class&lt;/strong&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;job.setGroupingComparatorClass(LogDataGroupingComparator.&lt;strong&gt;class&lt;/strong&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;job.setPartitionerClass(LogDataPartitioner.&lt;strong&gt;class&lt;/strong&gt;);  //自定义分区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221323823-1081956551.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221344536-234911102.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221357825-1209927334.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、&lt;/strong&gt;Hive 设置map 和 reduce 的个数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hive 设置map 和 reduce 的个数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/1130136248wlxk/articles/5352154.html&quot;&gt;https://www.cnblogs.com/1130136248wlxk/articles/5352154.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一、    控制hive任务中的map数: &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.    通常情况下，作业会通过input的目录产生一个或者多个map任务。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;主要的决定因素有： input的文件总个数，input的文件大小，集群设置的文件块大小(目前为128M, 可在hive中通过set dfs.block.size;命令查看到，该参数不能自定义修改)；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.    举例： &lt;/span&gt;&lt;br/&gt;&lt;span&gt;a)    假设input目录下有1个文件a,大小为780M,那么hadoop会将该文件a分隔成7个块（6个128m的块和1个12m的块），从而产生7个map数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;b)    假设input目录下有3个文件a,b,c,大小分别为10m，20m，130m，那么hadoop会分隔成4个块（10m,20m,128m,2m）,从而产生4个map数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;即，如果文件大于块大小(128m),那么会拆分，如果小于块大小，则把该文件当成一个块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.    是不是map数越多越好？ &lt;/span&gt;&lt;br/&gt;&lt;span&gt;答案是否定的。如果一个任务有很多小文件（远远小于块大小128m）,则每个小文件也会被当做一个块，用一个map任务来完成，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;而一个map任务启动和初始化的时间远远大于逻辑处理的时间，就会造成很大的资源浪费。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;而且，同时可执行的map数是受限的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.    是不是保证每个map处理接近128m的文件块，就高枕无忧了？ &lt;/span&gt;&lt;br/&gt;&lt;span&gt;答案也是不一定。比如有一个127m的文件，正常会用一个map去完成，但这个文件只有一个或者两个小字段，却有几千万的记录，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果map处理的逻辑比较复杂，用一个map任务去做，肯定也比较耗时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上面的问题3和4，我们需要采取两种方式来解决：即减少map数和增加map数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何合并小文件，减少map数？ &lt;/span&gt;&lt;br/&gt;&lt;span&gt;    假设一个SQL任务：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         Select count(1) from popt_tbaccountcopy_mes where pt = ‘2012-07-04’;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         该任务的inputdir  /group/p_sdo_data/p_sdo_data_etl/pt/popt_tbaccountcopy_mes/pt=2012-07-04&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         共有194个文件，其中很多是远远小于128m的小文件，总大小9G，正常执行会用194个map任务。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         Map总共消耗的计算资源： SLOTS_MILLIS_MAPS= 623,020&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;         我通过以下方法来在map执行前合并小文件，减少map数：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         set mapred.max.split.size=100000000;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    set mapred.min.split.size.per.node=100000000;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    set mapred.min.split.size.per.rack=100000000;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                 再执行上面的语句，用了74个map任务，map消耗的计算资源：SLOTS_MILLIS_MAPS= 333,500&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         对于这个简单SQL任务，执行时间上可能差不多，但节省了一半的计算资源。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         大概解释一下，100000000表示100M, set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;这个参数表示执行前进行小文件合并，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         前面三个参数确定合并文件块的大小，大于文件块大小128m的，按照128m来分隔，小于128m,大于100m的，按照100m来分隔，把那些小于100m的（包括小文件和分隔大文件剩下的），&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         进行合并,最终生成了74个块。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         &lt;/span&gt;&lt;br/&gt;&lt;span&gt;如何适当的增加map数？ &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;         当input的文件都很大，任务逻辑复杂，map执行非常慢的时候，可以考虑增加Map数，来使得每个map处理的数据量减少，从而提高任务的执行效率。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         假设有这样一个任务：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         Select data_desc,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                count(1),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                count(distinct id),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                sum(case when …),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                sum(case when ...),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                sum(…)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        from a group by data_desc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   如果表a只有一个文件，大小为120M，但包含几千万的记录，如果用1个map去完成这个任务，肯定是比较耗时的，这种情况下，我们要考虑将这一个文件合理的拆分成多个，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   这样就可以用多个map任务去完成。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   set mapred.reduce.tasks=10;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   create table a_1 as &lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   select * from a &lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   distribute by rand(123); &lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   &lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   这样会将a表的记录，随机的分散到包含10个文件的a_1表中，再用a_1代替上面sql中的a表，则会用10个map任务去完成。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   每个map任务处理大于12M（几百万记录）的数据，效率肯定会好很多。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;/span&gt;&lt;br/&gt;&lt;span&gt;   看上去，貌似这两种有些矛盾，一个是要合并小文件，一个是要把大文件拆成小文件，这点正是重点需要关注的地方，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   根据实际情况，控制map数量需要遵循两个原则：使大数据量利用合适的map数；使单个map任务处理合适的数据量；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、    控制hive任务的reduce数： &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.    Hive自己如何确定reduce数： &lt;/span&gt;&lt;br/&gt;&lt;span&gt;reduce个数的设定极大影响任务执行效率，不指定reduce个数的情况下，Hive会猜测确定一个reduce个数，基于以下两个设定：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hive.exec.reducers.bytes.per.reducer（每个reduce任务处理的数据量，默认为1000^3=1G） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;hive.exec.reducers.max（每个任务最大的reduce数，默认为999）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;计算reducer数的公式很简单N=min(参数2，总输入数据量/参数1)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;即，如果reduce的输入（map的输出）总大小不超过1G,那么只会有一个reduce任务；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如：select pt,count(1) from popt_tbaccountcopy_mes where pt = '2012-07-04' group by pt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;            /group/p_sdo_data/p_sdo_data_etl/pt/popt_tbaccountcopy_mes/pt=2012-07-04 总大小为9G多，因此这句有10个reduce&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.    调整reduce个数方法一： &lt;/span&gt;&lt;br/&gt;&lt;span&gt;调整hive.exec.reducers.bytes.per.reducer参数的值；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;set hive.exec.reducers.bytes.per.reducer=500000000; （500M）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select pt,count(1) from popt_tbaccountcopy_mes where pt = '2012-07-04' group by pt; 这次有20个reduce&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         &lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.    调整reduce个数方法二； &lt;/span&gt;&lt;br/&gt;&lt;span&gt;set mapred.reduce.tasks = 15;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select pt,count(1) from popt_tbaccountcopy_mes where pt = '2012-07-04' group by pt;这次有15个reduce&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.    reduce个数并不是越多越好； &lt;/span&gt;&lt;br/&gt;&lt;span&gt;同map一样，启动和初始化reduce也会消耗时间和资源；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;另外，有多少个reduce,就会有多少个输出文件，如果生成了很多个小文件，那么如果这些小文件作为下一个任务的输入，则也会出现小文件过多的问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.    什么情况下只有一个reduce； &lt;/span&gt;&lt;br/&gt;&lt;span&gt;很多时候你会发现任务中不管数据量多大，不管你有没有设置调整reduce个数的参数，任务中一直都只有一个reduce任务；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其实只有一个reduce任务的情况，除了数据量小于hive.exec.reducers.bytes.per.reducer参数值的情况外，还有以下原因：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a)    没有group by的汇总，比如把select pt,count(1) from popt_tbaccountcopy_mes where pt = '2012-07-04' group by pt; 写成 select count(1) from popt_tbaccountcopy_mes where pt = '2012-07-04';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这点非常常见，希望大家尽量改写。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;b)    用了Order by&lt;/span&gt;&lt;br/&gt;&lt;span&gt;c)    有笛卡尔积&lt;/span&gt;&lt;br/&gt;&lt;span&gt;通常这些情况下，除了找办法来变通和避免，我暂时没有什么好的办法，因为这些操作都是全局的，所以hadoop不得不用一个reduce去完成；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;同样的，在设置reduce个数的时候也需要考虑这两个原则：使大数据量利用合适的reduce数；使单个reduce任务处理合适的数据量；&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 20 Jul 2018 14:05:00 +0000</pubDate>
<dc:creator>sunjavakai</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunjava/p/9343825.html</dc:identifier>
</item>
<item>
<title>测试 ASP.NET Core API Controller - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/9343277.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/9343277.html</guid>
<description>&lt;p&gt;本文需要您了解ASP.NET Core MVC/Web API, xUnit以及Moq相关知识.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里有xUnit和Moq的介绍:&lt;span&gt;&lt;strong&gt; &lt;a href=&quot;https://www.cnblogs.com/cgzl/p/9178672.html#test&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/cgzl/p/9178672.html#test&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Controllers可以说是ASP.NET Core MVC/Web API项目的核心, 它们把整个应用都整合到了一起. 可以说Controllers是非常重要的, 所以我们应该对它们做一些测试.&lt;/p&gt;
&lt;p&gt;由于我几乎只做API, 所以本文不包括关于MVC功能的测试, 只包括Controller的API相关功能.&lt;/p&gt;


&lt;p&gt;先举一个简单点的例子:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720192639108-838080366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个Controller相对简单, 它有一个依赖项.&lt;/p&gt;
&lt;p&gt;它一个方法, 返回类型是IActionResult, 又具体分为两种情况.&lt;/p&gt;
&lt;h2&gt;测试返回结果的类型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720193753550-1877016458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先需要new出来一个被测试的RootController, 标准的叫法叫&lt;strong&gt;System Under Test(被测试系统)&lt;/strong&gt;. 它需要一个urlHelper作为依赖项, 那就&lt;strong&gt;Mock&lt;/strong&gt;一个即可.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;每组测试数据都会走一遍构造函数的&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;该测试方法使用的是&lt;strong&gt;Theory&lt;/strong&gt;, 用了4组数据. 执行方法后返回的结果类型应该实现了IActionResult接口, 这里可以用&lt;strong&gt;Assert.IsAssignableFrom&amp;lt;TExpected&amp;gt;(actual)&lt;/strong&gt;来判断.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注: 为了方便, 我使用了resharper&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;测试之前&lt;strong&gt;一定要重新Build&lt;/strong&gt;一下.&lt;/p&gt;
&lt;p&gt;然后再点击resharper在方法旁边提供的测试按钮即可:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720194317899-976170728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图可以看出resharper提供了方便快捷的图标, 在这你可以选择运行或者调试测试.&lt;/p&gt;

&lt;p&gt;测试会通过的, Theory下属的4组数据将被视为4个单独的测试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720194607663-1800554275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;针对该方法的其它测试&lt;/h2&gt;
&lt;p&gt;我又添加了两个测试方法, 来测试该方法的不同路径及返回结果:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720194904963-1019164622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常一个测试方法里应该只有一个Assert. 但是第二方法里面有两个Assert, 这是因为这两个Assert都是测试的同一个行为, 所以我认为这样应该是可以的.&lt;/p&gt;

&lt;p&gt;Rebuild, 测试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720195111521-1113467522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也是OK的.&lt;/p&gt;

&lt;p&gt;看起来针对RootController的GetRoot()方法, 我们好像已经测试了所有可执行的路径. 让我们使用测试代码覆盖率这个功能来确定一下.&lt;/p&gt;
&lt;p&gt;点击resharper在测试类旁边提供的CoverAll按钮:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720195342440-766813130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后会出现单元测试窗口和覆盖率窗口.&lt;/p&gt;

&lt;p&gt;直接看覆盖率窗口:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720195429328-2063363825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到该Controller和方法的覆盖率都是100%了.&lt;/p&gt;

&lt;p&gt;来到被测试的RootController里:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720195611979-529405905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Resharper(实际上是dotCover) 在代码的左边显示出了该行代码是否已经被测试覆盖, 如果都是绿色的就说明都被覆盖了.&lt;/p&gt;

&lt;h2&gt;导出覆盖率结果&lt;/h2&gt;
&lt;p&gt;Resharper的代码覆盖率结果可以导出多种格式:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720195818099-1155148553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;例如导出HTML后也可以查看覆盖率明细:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720195926039-1483773317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720201045131-1312644244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个ProductController略微复杂一点, 首先它需要很多依赖项.&lt;/p&gt;

&lt;p&gt;看它的POST Action方法, 很多地方需要被测试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720205320197-1656942390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;测试ModelState&lt;/h2&gt;
&lt;p&gt;首先可以测试product为null的情况, 但是这个太简单了, 我就不啰嗦了.&lt;/p&gt;
&lt;p&gt;那就测试ModelState.Invalid情况吧:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720203401864-568935552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了让ModelState Invalid, 我手动添加了ModelState的error. 和被测试方法其它必要的参数.&lt;/p&gt;
&lt;p&gt;该方法有三个Assert, 首先判定结果类型是否为UnprocessableEntityObjectResult(422状态码), 然后再判定返回结果包含了ModelState的error.&lt;/p&gt;
&lt;p&gt;该测试会pass, 并会覆盖这部分相关的代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720203753714-810859947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;测试特定方法会被调用&lt;/h2&gt;
&lt;p&gt;这里需要使用moq了, 为了让被测试方法顺利跑完, 我设定Mock版的UnitOfWork的SaveAsync()方法会返回true, (注意这个方法的返回类型是Task&amp;lt;bool&amp;gt;):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720205046976-444152312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后通过moq的Verify()方法判定repository的AddProduct()和unitOfWork的SaveAsync()方法分别被调用了.&lt;/p&gt;

&lt;p&gt;Build, 测试会pass, 覆盖率目前比较大了(但是覆盖率100%并不能说明代码没问题):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720205621173-462289911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;模拟SaveAsync()后的实体数据&lt;/h2&gt;
&lt;p&gt;该项目使用的是EFCore, 在_unitOfWorkSaveAsync()之后, 变量productModel的Id就会有非0值了, 也就是说productModel在_unitOfWorkSaveAsync()方法执行之后发生了变化.&lt;/p&gt;
&lt;p&gt;针对这种情况, 我们可以使用moq的&lt;strong&gt;Callback()&lt;/strong&gt;功能:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720214509227-1457194347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚开始为autoMapper的两次map动作设定了返回值.&lt;/p&gt;
&lt;p&gt;然后在UnitOfWork的SaveAsync()执行后有个Callback()回调, 回调时相当于模拟了EFCore的保存, 把最新的值赋给了productModel(看被测试代码), (其实这里不用Callback也行....).&lt;/p&gt;
&lt;p&gt;随后就是一系列的Assert, 判定某些方法是否执行, 返回类型是否正确, 返回的数据是否正确等.&lt;/p&gt;

&lt;p&gt;Build 测试会通过的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720214849129-356013719.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;其它路径的测试&lt;/h2&gt;
&lt;p&gt;目前该方法还有两处地方没有被覆盖:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720215039007-591190051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以再写两个测试来覆盖它们:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720215449648-26893863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个很简单, 不多介绍了, 注意这里使用了async版本的Assert.Throws().&lt;/p&gt;

&lt;p&gt;这两个测试会pass, 最终该方法的代码覆盖率就达到100%了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180720215638909-2082388330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ASP.NET Core Web API Controller的测试就介绍这些吧.&lt;/p&gt;
</description>
<pubDate>Fri, 20 Jul 2018 14:04:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/9343277.html</dc:identifier>
</item>
<item>
<title>深入理解java虚拟机学习笔记（一）JVM内存模型 - 曦阳x</title>
<link>http://www.cnblogs.com/be-thinking/p/9343800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/be-thinking/p/9343800.html</guid>
<description>&lt;p&gt;        上周末搬家后，家里的宽带一直没弄好，跟电信客服反映了N遍了终于约了个师傅明天早上来迁移宽带，可以结束一个多星期没网的痛苦日子了。这段时间也是各种忙，都一个星期没更新博客了，再不写之前那种状态和激情都要慢慢褪去了，总觉得心里慌的一逼，这怎么行呢？！趁明天周末，在公司电脑上记录下这周的一些学习内容。近期在看一本很经典的java书籍：《深入理解java虚拟机 第二版》，几年前也翻过，但那时候功力不够，不太能看懂就没看了。现在回过头来看，发现确实写的很好，很多知识点都能理解了，而且讲的也很有深度，收获颇多。后期计划按照这本书的内容写出一系列博客，来深入学习和复习下java虚拟机相关的知识。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;     一、JVM内存模型概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;             &lt;/strong&gt; JVM内存模型其实也挺简单的，这里先提2个知识点：&lt;/p&gt;
&lt;p&gt;                    1、组成：java堆，java栈（即虚拟机栈），本地方法栈，方法区和程序计数器。&lt;/p&gt;
&lt;p&gt;                    2、是否共享：其中方法区和堆区是线程共享的，虚拟机栈，本地方法栈和程序计数器是线程私有的，也称线程隔离的，每个区域存储不同的内容。这2个知识点必须牢记，是掌握JVM内存模型的基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                           &lt;img src=&quot;https://images2018.cnblogs.com/blog/1038767/201807/1038767-20180720202101709-739750473.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;      二、程序计数器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;              JVM中的程序计数器是一块很小的内存区域，但是这块内存区域挺有意思的。主要特性有3个：&lt;/p&gt;
&lt;p&gt;              1、存储内容：对于java普通方法（即没用native关键字修饰的方法），存储的是执行过程中当前指令的地址，而对于native方法，这里是空的（undefined），为啥呢？因为调用本地方法的时候可能已经超出了JVM虚拟机的内存地址了。&lt;/p&gt;
&lt;p&gt;              2、线程私有的：为什么程序计数器是线程私有的？根据存储内容也好理解，假如是线程共享的，那多个线程执行的时候，都不知道自己当前线程执行的地址是哪个了，有的线程快，有的线程慢，快的执行完就进入下一步，等慢的线程执行完回来发现自己的地址都变了，岂不乱套？&lt;/p&gt;
&lt;p&gt;              3、是JVM中唯一不会报内存溢出（OutOfMemoryError）的区域。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;      三、虚拟机栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;             &lt;/strong&gt; 虚拟机栈主要存储的是一个个栈帧，每个栈帧中存储的是局部变量表，操作数栈，动态链接和方法出口信息等。其中局部变量表中存储的是方法中定义的一些局部变量，对象的引用，参数，和方法的返回地址等。局部变量表所占用的空间大小在编译期就能确定，在方法运行的时候，并不会改变局部变量表的空间大小，这结合局部变量表存储的内容就很好理解。操作数栈可以理解为对当前操作的数据入出栈，对于64位长度的long和double类型，每个操作数占用2个字宽（slot），其他类型的操作数占用一个字宽（slot）。每个方法调用时都会创建一个栈帧，执行的过程对应的就是一个栈帧在虚拟机栈中从入栈到出栈的过程。有关栈帧的内容可以参考一个网友写的一篇博客：&lt;a href=&quot;https://blog.csdn.net/xtayfjpk/article/details/41924283&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/xtayfjpk/article/details/41924283&lt;/a&gt;，讲的很好很详细。这里放个栈帧的图，看了一目了然。&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://images2018.cnblogs.com/blog/1038767/201807/1038767-20180720205413313-1178313635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;           关于虚拟机栈内存溢出有2种情况：&lt;/p&gt;
&lt;p&gt;           1、线程请求的栈深度 超过了虚拟机允许的深度，会抛出StackOverflowError，所以当我们在代码中看到这个异常时，就应该想到可能是虚拟机栈出了问题。&lt;/p&gt;
&lt;p&gt;           2、如果虚拟机栈可以动态扩展（当前大部分JVM都可以动态扩展，不过JVM也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时，会抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;      四、本地方法栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;         &lt;/strong&gt;  这块知识点比较简单，本地方法栈和虚拟机栈的功能类似，只不过是为JVM调用native方法时服务的，而且JVM对本地方法使用的语言（比如Java调用C语言实现的功能，就需要定义native方法来实现）、使用方式和数据结构都没有强制规定，因此不同的虚拟机可以自由实现。而且HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一。与虚拟机栈类似，本地方法栈也会抛出StackOverflowError和OutOfMemoryError。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;      五、方法区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;           方法区是一个比较重要的区域，java虚拟机规范中把方法区描述为堆的一个逻辑部分，但是为了和Heap（堆区）对应，也称Non-Heap（非堆区）。主要存储的是静态变量，常量（包括运行时常量），类的加载信息和java编译后的代码。这部分空间不需要连续，可以选择固定大小和可扩展，通常在这部分是没有GC的，因为GC回收的都是些静态变量，常量和类的加载信息，这些对象回收效果通常不尽人意，因此可以选择不实现垃圾回收。这块区域也称为持久代，当这块内存不足时，也会报OutOfMemoryError异常。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;      六、堆区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;  Java堆区是JVM内存中最胖的一块区域，因为这里存储的都是对象的实例和数组对象。这块区域是线程共享的，在JVM启动时就会创建，想想如果这么大的空间是线程私有的，那内存不得爆掉吗？按照java虚拟机规范，堆区的内容可以物理上不连续，只要逻辑上连续即可，在实现时可以是固定大小的，也可以是可扩展的，而且通常都是可扩展的，我们常用的内存参数-Xms和-Xmx就是用来调节堆大小的。java堆区按生命周期不同，分为新生代和老年代。新生代又可以细分为Eden和Survivor区，而Survivor又可以细分为Survivor1和Survivor2，这两者通常只使用其中一块，另一块用来GC时保留存活的对象。大部分的new出来的对象都是存放在Eden区，如果是大对象，比如一个很大的数组或者List对象，可以通过JVM参数-XX:PretenureSizeThreshold将超过指定大小的对象直接存入到老年代，需要注意的是，写程序时应该尽量避免朝生夕死的大对象进入老年代，因为相比年轻代的GC，老年代GC的成本更大。Eden和Survivor的默认大小比值的8:1:1，新生代默认的GC算法是复制算法。老年代的默认GC算法是标记整理法。关于这2种GC算法，会在下篇博客讲解。&lt;/p&gt;
&lt;p&gt;当堆中没有足够内存时，会抛出OutOfMemoryError异常。关于堆区的内存模型，可以参考下面的图片：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/1038767/201807/1038767-20180720215650580-432049223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 20 Jul 2018 13:58:00 +0000</pubDate>
<dc:creator>曦阳x</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/be-thinking/p/9343800.html</dc:identifier>
</item>
<item>
<title>多线程（threading module） - Hme</title>
<link>http://www.cnblogs.com/horror/p/9343764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/horror/p/9343764.html</guid>
<description>&lt;p&gt;&lt;strong&gt;线程定义：&lt;/strong&gt;线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程定义：&lt;/strong&gt;An executing instance of a program is called a process.（程序的执行实例称为进程。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程与进程的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1. 线程共享创建它的进程的地址空间; 进程有自己的地址空间。&lt;br/&gt;　　2. 线程可以直接访问其进程的数据段; 进程拥有自己父进程数据段的副本。&lt;br/&gt;　　3. 线程可以直接与其进程的其他线程通信; 进程必须使用进程间通信来与兄弟进程通信。&lt;br/&gt;　　4. 新线程很容易创建; 新流程需要复制父流程。&lt;br/&gt;　　5. 线程可以对同一进程的线程进行相当大的控制; 进程只能控制子进程。&lt;br/&gt;　　6. 对主线程的更改（取消，优先级更改等）可能会影响进程的其他线程的行为; 对父进程的更改不会影响子进程。&lt;/p&gt;

&lt;p&gt;　　--&amp;gt; 全局解释器锁 ：在同一时刻，只能有一个线程进入解释器。&lt;/p&gt;

&lt;h2&gt;3.1 线程的2种调用方式&lt;/h2&gt;
&lt;p&gt;直接调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_b314711c-7df1-4b8c-a724-70a5d7fc6da9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b314711c-7df1-4b8c-a724-70a5d7fc6da9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b314711c-7df1-4b8c-a724-70a5d7fc6da9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; sayhi(num): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义每个线程要运行的函数&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;  
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;running on number:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;num)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  
&lt;span&gt; 8&lt;/span&gt;     time.sleep(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  
&lt;span&gt;12&lt;/span&gt;     t1 = threading.Thread(target=sayhi,args=(1,)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成一个线程实例&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     t2 = threading.Thread(target=sayhi,args=(2,)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成另一个线程实例&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;  
&lt;span&gt;15&lt;/span&gt;     t1.start() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     t2.start() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动另一个线程&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;  
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(t1.getName()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取线程名&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(t2.getName())
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;继承式调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_b119451d-89ef-4943-8512-aa6df6a5f6ce&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b119451d-89ef-4943-8512-aa6df6a5f6ce&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b119451d-89ef-4943-8512-aa6df6a5f6ce&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt;  
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyThread(threading.Thread):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,num):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         threading.Thread.&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.num =&lt;span&gt; num
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; run(self):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义每个线程要运行的函数&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;  
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;running on number:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;self.num)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt;         time.sleep(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;  
&lt;span&gt;18&lt;/span&gt;     t1 = MyThread(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     t2 = MyThread(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    t1.start()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     t2.start()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.2 常用方法（Join/Daemon）&lt;/h2&gt;
&lt;p&gt;　　join() --&amp;gt; 在子线程完成运行之前，这个子线程的父线程将一直被阻塞。&lt;/p&gt;
&lt;p&gt;　　setDaemon(True) --&amp;gt;  将线程声明为守护线程，必须在start() 方法调用之前设置，守护线程随主线程结束而结束。&lt;/p&gt;
&lt;p&gt;其他方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_8e05f277-5aa0-46a5-bf52-a057f838a96e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8e05f277-5aa0-46a5-bf52-a057f838a96e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8e05f277-5aa0-46a5-bf52-a057f838a96e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;threading 模块提供的其他方法：
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; threading.currentThread(): 返回当前的线程变量。&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; run(): 用以表示线程活动的方法。&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; start():启动线程活动。&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; isAlive(): 返回线程是否活动的。&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; getName(): 返回线程名。&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; setName(): 设置线程名。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Method&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.3 同步锁（Lock）&lt;/h2&gt;
&lt;p&gt;　　r = threading.Lock()　　r.acquire() --&amp;gt; 加锁　　r.release() --&amp;gt; 解锁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_c001f697-3bfe-43ee-b983-e4341d8242a6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c001f697-3bfe-43ee-b983-e4341d8242a6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c001f697-3bfe-43ee-b983-e4341d8242a6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; addNum():
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt; num &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在每个线程中都获取这个全局变量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; num-=1&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    lock.acquire()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     temp=&lt;span&gt;num
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--get num:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,num )
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;time.sleep(0.1)&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     num =temp-1 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对此公共变量进行-1操作&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    lock.release()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; num = 100  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设定一个共享变量&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; thread_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; lock=&lt;span&gt;threading.Lock()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     t = threading.Thread(target=&lt;span&gt;addNum)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    t.start()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    thread_list.append(t)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; thread_list: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待所有线程执行完毕&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    t.join()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;final num:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, num )
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.4 线程死锁和递归锁&lt;/h2&gt;
&lt;p&gt;　　在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁，因为系统判断这部分资源都正在使用，所有这两个线程在无外力作用下将一直等待下去。下面是一个死锁的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_fe58a569-6c8b-40de-9735-1d6af869e689&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fe58a569-6c8b-40de-9735-1d6af869e689&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fe58a569-6c8b-40de-9735-1d6af869e689&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; myThread(threading.Thread):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; doA(self):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        lockA.acquire()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(self.name,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gotlockA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.ctime())
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         time.sleep(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        lockB.acquire()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(self.name,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gotlockB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.ctime())
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        lockB.release()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        lockA.release()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; doB(self):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        lockB.acquire()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(self.name,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gotlockB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.ctime())
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        lockA.acquire()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(self.name,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gotlockA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.ctime())
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        lockA.release()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        lockB.release()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        self.doA()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        self.doB()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     lockA=&lt;span&gt;threading.Lock()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     lockB=&lt;span&gt;threading.Lock()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     threads=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        threads.append(myThread())
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; threads:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        t.start()
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; threads:
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         t.join()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;deadLock&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;解决办法：使用递归锁&lt;/p&gt;
&lt;p&gt;　　即重新定义一把锁：lock = threading.RLock() --&amp;gt; 递归锁&lt;/p&gt;
&lt;p&gt;　　将所有的锁替换为递归锁即可。递归锁可以重复加锁。&lt;/p&gt;
&lt;p&gt;　　RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次acquire。直到一个线程所有的acquire都被release，其他的线程才能获得资源。&lt;/p&gt;
&lt;h2&gt;3.5 信号量（Semaphore）--&amp;gt; 相当于一把锁&lt;/h2&gt;
&lt;p&gt;　　信号量用来控制线程并发数的，BoundedSemaphore或Semaphore管理一个内置的计数 器，每当调用acquire()时-1，调用release()时+1。&lt;/p&gt;
&lt;p&gt;　　计数器不能小于0，当计数器为 0时，acquire()将阻塞线程至同步锁定状态，直到其他线程调用release()。(类似于停车位的概念)&lt;/p&gt;
&lt;p&gt;　　BoundedSemaphore与Semaphore的唯一区别在于前者将在调用release()时检查计数 器的值是否超过了计数器的初始值，如果超过了将抛出一个异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_b56c6734-2008-41e1-85ca-58fd8ce5bab6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b56c6734-2008-41e1-85ca-58fd8ce5bab6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b56c6734-2008-41e1-85ca-58fd8ce5bab6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; myThread(threading.Thread):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; semaphore.acquire():
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.name)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             time.sleep(5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            semaphore.release()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     semaphore=threading.Semaphore(5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     thrs=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        thrs.append(myThread())
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; thrs:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         t.start()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Semaphore&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.6 条件变量同步（Condition）--&amp;gt; 锁&lt;/h2&gt;
&lt;p&gt;　　有一类线程需要满足条件之后才能够继续执行，Python提供了threading.Condition 对象用于条件变量线程的支持，它除了能提供RLock()或Lock()的方法外，还提供了 wait()、notify()、notifyAll()方法。&lt;/p&gt;
&lt;p&gt;      lock_con=threading.Condition([Lock/Rlock])： 锁是可选选项，不传入锁，对象自动创建一个RLock()。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;wait()：条件不满足时调用，线程会释放锁并进入等待阻塞；
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;notify()：条件创造后调用，通知等待池激活一个线程；
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; notifyAll()：条件创造后调用，通知等待池激活所有线程。
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_18d51b8d-2fe4-49c7-ae38-3d55c7bb638f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_18d51b8d-2fe4-49c7-ae38-3d55c7bb638f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_18d51b8d-2fe4-49c7-ae38-3d55c7bb638f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; random &lt;span&gt;import&lt;/span&gt;&lt;span&gt; randint
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer(threading.Thread):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;global&lt;/span&gt;&lt;span&gt; L
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             val=randint(0,100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;生产者&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,self.name,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:Append&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;str(val),L)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; lock_con.acquire():
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                L.append(val)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                lock_con.notify()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                lock_con.release()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             time.sleep(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer(threading.Thread):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;global&lt;/span&gt;&lt;span&gt; L
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                lock_con.acquire()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; len(L)==&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    lock_con.wait()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;消费者&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,self.name,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:Delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;str(L[0]),L)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;del&lt;/span&gt;&lt;span&gt; L[0]
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                lock_con.release()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 time.sleep(0.25&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     L=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     lock_con=&lt;span&gt;threading.Condition()
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     threads=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        threads.append(Producer())
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    threads.append(Consumer())
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; threads:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        t.start()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; threads:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         t.join()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Condition Demo&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.7 同步条件（Event）&lt;/h2&gt;
&lt;p&gt;条件同步和条件变量同步差不多意思，只是少了锁功能，因为条件同步设计于不访问共享资源的条件环境。event=threading.Event()：条件环境对象，初始值 为False；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;event.isSet()：返回event的状态值；
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; event.wait()：如果 event.isSet()==&lt;span&gt;False将阻塞线程；
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;event.set()： 设置event的状态值为True，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; event.clear()：恢复event的状态值为False。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_ed4c7a36-9f95-4d77-adfb-b26c02f9d861&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ed4c7a36-9f95-4d77-adfb-b26c02f9d861&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ed4c7a36-9f95-4d77-adfb-b26c02f9d861&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Boss(threading.Thread):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BOSS：今晚大家都要加班到22:00。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         event.isSet() &lt;span&gt;or&lt;/span&gt;&lt;span&gt; event.set()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         time.sleep(5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BOSS：&amp;lt;22:00&amp;gt;可以下班了。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         event.isSet() &lt;span&gt;or&lt;/span&gt;&lt;span&gt; event.set()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Worker(threading.Thread):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        event.wait()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Worker：哎……命苦啊！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         time.sleep(0.25&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        event.clear()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        event.wait()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Worker：OhYeah!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     event=&lt;span&gt;threading.Event()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     threads=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        threads.append(Worker())
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    threads.append(Boss())
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; threads:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        t.start()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; threads:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         t.join()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.8 队列（queue）--&amp;gt;多线程利器&lt;/h2&gt;
&lt;p&gt;queue中的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;创建一个“队列”对象
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; Queue
q &lt;/span&gt;= Queue.Queue(maxsize = 10&lt;span&gt;)
Queue.Queue类即是一个队列的同步实现。队列长度可为无限或者有限。可通过Queue的构造函数的可选参数maxsize来设定队列长度。如果maxsize小于1就表示队列长度无限。

将一个值放入队列中
q.put(&lt;/span&gt;10&lt;span&gt;)
调用队列对象的put()方法在队尾插入一个项目。put()有两个参数，第一个item为必需的，为插入项目的值；第二个block为可选参数，默认为
&lt;/span&gt;1&lt;span&gt;。如果队列当前为空且block为1，put()方法就使调用线程暂停,直到空出一个数据单元。如果block为0，put方法将引发Full异常。

将一个值从队列中取出
q.get()
调用队列对象的get()方法从队头删除并返回一个项目。可选参数为block，默认为True。如果队列为空且block为True，get()就使调用线程暂停，直至有项目可用。如果队列为空且block为False，队列将引发Empty异常。

Python Queue模块有三种队列及构造函数:
&lt;/span&gt;1、Python Queue模块的FIFO队列先进先出。  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; queue.Queue(maxsize)
&lt;/span&gt;2、LIFO类似于堆，即先进后出。             &lt;span&gt;class&lt;/span&gt;&lt;span&gt; queue.LifoQueue(maxsize)
&lt;/span&gt;3、还有一种是优先级队列级别越低越先出来。   &lt;span&gt;class&lt;/span&gt;&lt;span&gt; queue.PriorityQueue(maxsize)

此包中的常用方法(q &lt;/span&gt;=&lt;span&gt; Queue.Queue()):
q.qsize() 返回队列的大小
q.empty() 如果队列为空，返回True,反之False
q.full() 如果队列满了，返回True,反之False
q.full 与 maxsize 大小对应
q.get([block[, timeout]]) 获取队列，timeout等待时间
q.get_nowait() 相当q.get(False)
非阻塞 q.put(item) 写入队列，timeout等待时间
q.put_nowait(item) 相当q.put(item, False)
q.task_done() 在完成一项工作之后，q.task_done() 函数向任务已经完成的队列发送一个信号
q.join() 实际上意味着等到队列为空，再执行别的操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_c27e6a1a-3f1b-4814-94ae-ddc62e6e71bd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c27e6a1a-3f1b-4814-94ae-ddc62e6e71bd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c27e6a1a-3f1b-4814-94ae-ddc62e6e71bd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,queue
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sleep
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; random &lt;span&gt;import&lt;/span&gt;&lt;span&gt; randint
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Production(threading.Thread):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             r=randint(0,100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            q.put(r)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生产出来%s号包子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;r)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Proces(threading.Thread):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             re=&lt;span&gt;q.get()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;吃掉%s号包子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;re)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     q=queue.Queue(10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     threads=&lt;span&gt;[Production(),Production(),Production(),Proces()]
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; threads:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         t.start()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Demo&lt;/span&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 20 Jul 2018 13:46:00 +0000</pubDate>
<dc:creator>Hme</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/horror/p/9343764.html</dc:identifier>
</item>
<item>
<title>5.ASP.NET全栈开发之在Vue中使用前端校验（二） - Gxqsd</title>
<link>http://www.cnblogs.com/Gxqsd/p/9343421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Gxqsd/p/9343421.html</guid>
<description>&lt;p&gt;在全栈开发系列第三篇的时候有讲到使用Vue进行前端验证。在那一篇博文里，详细讲了如何搭建 vuefluentvalidator.js 的过程，并最终把它从需要（实体和实体验证器）到 直接使用，很显然，它很小巧的胜任了工作。（首先声明，这个vuefluentvalidator.js是我上周末也就是7月15号才开始构思和编写的，而我最开始的目的是希望它能轻松完成表单的校验工作，但没想过许多复杂多变的情况。所以这期间出现了多次更改和修正）。目前我已将它上传至github，网址为：https://github.com/gxqsd/vuefluentvalidator。如果你有什么更好的建议，我们可以一起修正。&lt;/p&gt;
&lt;p&gt;回到正题，上一篇结束时，我们已经能让他成功跑起来了。但由于上一篇内容过多，所以还没来得及介绍下如何使用。&lt;/p&gt;
&lt;p&gt;首先我们来看一个例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;vuefluentvalidator.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;https://www.baidu.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;model.name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{model.error.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;model.age&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{model.error.age}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;submit({ev:$event})&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        let vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#box&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            data: {
                validator: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Validator({
                    model: {
                        name: undefined,
                        age: undefined,
                        address: {
                            home: undefined,
                            phone: undefined
                        }
                    },
                    rule: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (than) {
                        than.ruleFor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;名称必填&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                            .MinimumLength(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)
                            .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;最短长度为5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        than.ruleFor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年龄必须&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                            .Number(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
                            .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;必须在0-100岁之间&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;
                    }
                }),
            },
            methods: {
                submit: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ({ ev }) {

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.validator.passValidation()) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }

                    ev.preventDefault();

                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.validator.validation(ev.target);
                }
            },
            computed: {
                model: {
                    get: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.validator.model;
                    }
                }
            }
        });
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个html页面里，我们引入了vue.js 和 vuefluentvalidator.js。&lt;/p&gt;
&lt;p&gt;使用vuefluentvalidator 只需要在data 里 new 一个Validator 。Validator 有两个参数&lt;/p&gt;
&lt;p&gt;第一个是要验证的数据，他可以是一个JSON对象，或者是一个实体对象 ClassName ，实际上我们可以将整个data的数据放入进去。我们传入进去的数据会被创建在其内部的model中，也就是说我们只需要通过validator.model 就能访问我们传进去的数据。&lt;/p&gt;
&lt;p&gt;第二个参数则是一个回调函数，他是用来配置验证规则的函数。&lt;/p&gt;
&lt;p&gt;回调函数默认有一个参数，在validator内部调用时会将this传进来，所以这个参数也就是validator本身。&lt;/p&gt;
&lt;p&gt;通过这个回调函数的参数than，我们就可以进行验证规则的配置。&lt;/p&gt;
&lt;p&gt;目前内置了六种验证规则。他们分别是&lt;/p&gt;
&lt;p&gt;NotEmpty　　　　　　　　非空验证，该方法无参数。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;MinimumLength　　　　　 最小长度验证，有一个参数，设置最小长度&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;p&gt;MaximumLength　　　　　最大长度验证，有一个参数，设置最大长度&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;p&gt;Length　　　　　　　　　 长度范围验证，有2个参数，分别是最小长度和最大长度&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;Must　　　　　　　　　　 自定义验证，有一个参数，回调函数，回调函数会默认传入一个参数validator.model 就是我们在new validator的时候传进去的数据&lt;/p&gt;
&lt;div readability=&quot;34&quot;&gt;
&lt;p&gt;Number　　　　　　　　　整数验证，有2个参数，分别是整数的最小值和最大值。默认值是Number.MinValue和Number.MaxValue&lt;/p&gt;

&lt;p&gt;为什么没有邮箱验证之类的呢？实际上这些东西1是可以自定义，2是表单自带的type=&quot;email&quot;是一个可靠验证。如果你有什么好的意见可以与我联系。&lt;/p&gt;
&lt;p&gt;在配置了每一个验证规则后，我们可以通过WithMessage(&quot;errorMessaeg&quot;)设置错误消息。&lt;/p&gt;
&lt;p&gt;而WithMessage后又可以继续为同一字段配置其他验证规则。&lt;/p&gt;

&lt;p&gt;以上内容是介绍上篇博文结束后的使用方法。&lt;/p&gt;

&lt;p&gt;今天，我想到在讲这一篇前端验证之前，我曾经写过两篇关于服务端验证的内容，其中有讲到&lt;/p&gt;
&lt;p&gt;在实体&lt;/p&gt;
&lt;p&gt;Person中存在一个复杂类型Address&lt;/p&gt;
&lt;div readability=&quot;42.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
public class Person
    {
        /// &amp;lt;summary&amp;gt;
        /// 姓名
        /// &amp;lt;/summary&amp;gt;
        public string Name { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 年龄
        /// &amp;lt;/summary&amp;gt;
        public int Age { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 性别
        /// &amp;lt;/summary&amp;gt;
        public bool Sex { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 地址
        /// &amp;lt;/summary&amp;gt;
        public Address Address { get; set; }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Address
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Home { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Phone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在为Person设置Address的验证规则时，使用了SetValidator方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PersonValidator : AbstractValidator&amp;lt;Person&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PersonValidator()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.RuleFor(p =&amp;gt;&lt;span&gt; p.Name)
                .NotEmpty()
                .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;姓名不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.RuleFor(p =&amp;gt;&lt;span&gt; p.Age)
                .NotEmpty()
                .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年龄不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.RuleFor(p =&amp;gt;&lt;span&gt; p.Address)
                .SetValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AddressValidator());

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么如果我们的对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;model: {
                        name: undefined,
                        age: undefined,
                        address: {
                            home: undefined,
                            phone: undefined
                        }
                    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们该是否也希望这样设置？&lt;/p&gt;
&lt;p&gt;在我分析了后认为在前端js中这种方式不适合，原因是，我们为了简单而省略了验证器，而如果这样的使用方式会让我们需要定义一个AddressValidator。即使你说我们用一个Validator来代替，那也会让代码结构变成&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
than.ruleFor(&quot;name&quot;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&quot;名称必填&quot;&lt;span&gt;)
                            .MinimumLength(&lt;/span&gt;5&lt;span&gt;)
                            .WithMessage(&lt;/span&gt;&quot;最短长度为5&quot;&lt;span&gt;);
                        than.ruleFor(&lt;/span&gt;&quot;age&quot;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&quot;年龄必须&quot;&lt;span&gt;)
                            .Number(&lt;/span&gt;0, 100&lt;span&gt;)
                            .WithMessage(&lt;/span&gt;&quot;必须在0-100岁之间&quot;&lt;span&gt;);
                        than.ruleFor(&lt;/span&gt;&quot;address&quot;&lt;span&gt;)
                            .setValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Validator({
                                model: {
                                    home: undefined,
                                    phone: undefined
                                }, rule: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (than) {
                                    than.ruleFor(&lt;/span&gt;&quot;home&quot;&lt;span&gt;)
                                        .NotEmpty()
                                        .WithMessage(&lt;/span&gt;&quot;家庭住址不能为空&quot;&lt;span&gt;);
                                    than.ruleFor(&lt;/span&gt;&quot;iphone&quot;&lt;span&gt;)
                                        .NotEmpty()
                                        .WithMessage(&lt;/span&gt;&quot;家庭电话不能为空&quot;&lt;span&gt;);
                                }
                            }));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我认为这样的写法，简直糟糕透了，意味着重复又重复。看起来一点都不简洁了，甚至有点麻烦。&lt;/p&gt;
&lt;p&gt;于是我想到了另一种写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
                    rule: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (than) {
                        than.ruleFor(&lt;/span&gt;&quot;name&quot;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&quot;名称必填&quot;&lt;span&gt;)
                            .MinimumLength(&lt;/span&gt;5&lt;span&gt;)
                            .WithMessage(&lt;/span&gt;&quot;最短长度为5&quot;&lt;span&gt;);
                        than.ruleFor(&lt;/span&gt;&quot;age&quot;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&quot;年龄必须&quot;&lt;span&gt;)
                            .Number(&lt;/span&gt;0, 100&lt;span&gt;)
                            .WithMessage(&lt;/span&gt;&quot;必须在0-100岁之间&quot;&lt;span&gt;);
                        than.ruleFor(&lt;/span&gt;&quot;address.home&quot;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&quot;家庭住址不能为空&quot;&lt;span&gt;);
                        than.ruleFor(&lt;/span&gt;&quot;address.phone&quot;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&quot;家庭电话不能为空&quot;&lt;span&gt;);
                    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;咱们key不是叫address吗？那我们要设置address对象的属性的时候直接address.propertyName 这样是不是又简单了一些？&lt;/p&gt;
&lt;p&gt;于是我完成了vuefluentvalidator内部的修改。现我已将他放置在 https://github.com/gxqsd/vuefluentvalidator 你可以下载下来看看有何不同或有何问题，方便我们一起改进。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 20 Jul 2018 12:25:00 +0000</pubDate>
<dc:creator>Gxqsd</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Gxqsd/p/9343421.html</dc:identifier>
</item>
<item>
<title>Spring Cloud 微服务中搭建 OAuth2.0 认证授权服务 - 花儿笑弯了腰</title>
<link>http://www.cnblogs.com/Irving/p/9343377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Irving/p/9343377.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/365537/201807/365537-20180720201800345-320276812.png&quot;&gt;&lt;img title=&quot;149676948363514113&quot; border=&quot;0&quot; alt=&quot;149676948363514113&quot; src=&quot;https://images2018.cnblogs.com/blog/365537/201807/365537-20180720201800716-1120610937.png&quot; width=&quot;1093&quot; height=&quot;608&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8.9505428226779&quot;&gt;
&lt;p&gt;&lt;span&gt;在使用 Spring Cloud 体系来构建微服务的过程中，用户请求是通过网关(ZUUL 或 Spring APIGateway)以 HTTP 协议来传输信息，API 网关将自己注册为 Eureka 服务治理下的应用，同时也从 Eureka 服务中获取所有其他微服务的实例信息。搭建&lt;/span&gt; OAuth2 认证授权服务，并不是给每个微服务调用，而是通过 API 网关进行统一调用来对网关后的微服务做前置过滤，所有的请求都必须先通过 API 网关，API 网关在进行路由转发之前对该请求进行前置校验，实现对微服务系统中的其他的服务接口的安全与权限校验。&lt;span&gt;一般解决用户认证与授权的方法，目前主流的解决方案有 &lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot; target=&quot;_blank&quot;&gt;OAuth2.0&lt;/a&gt;、&lt;a href=&quot;https://openid.net/connect/&quot; target=&quot;_blank&quot;&gt;OIDC(OpenID Connect)&lt;/a&gt; 、&lt;a href=&quot;https://tools.ietf.org/html/rfc2104&quot; target=&quot;_blank&quot;&gt;HMAC&lt;/a&gt;、&lt;a href=&quot;https://jwt.io&quot; target=&quot;_blank&quot;&gt;JWT&lt;/a&gt; 等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;备注&lt;/strong&gt;：&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/Irving/p/4964489.html&quot; target=&quot;_blank&quot;&gt;关于 RESTFUL API 安全认证方式的一些总结&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;OAuth2.0 协议根据使用不同的适用场景，定义了用于四种授权模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Authorization code（授权码模式）&lt;/strong&gt;&lt;br/&gt;标准的 Server 授权模式，非常适合 Server 端的 Web 应用。一旦资源的拥有者授权访问他们的数据之后，他们将会被重定向到 Web 应用并在 URL 的查询参数中附带一个授权码（code）。在客户端里，该 code 用于请求访问令牌（access_token）。并且该令牌交换的过程是两个服务端之前完成的，防止其他人甚至是资源拥有者本人得到该令牌。另外，在该授权模式下可以通过 refresh_token 来刷新令牌以延长访问授权时间，也是最为复杂的一种方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Implicit Grant（隐式模式）&lt;br/&gt;&lt;/strong&gt;该模式是所有授权模式中最简单的一种，并为运行于浏览器中的脚本应用做了优化。当用户访问该应用时，服务端会立即生成一个新的访问令牌（access_token）并通过URL的#hash段传回客户端。这时，客户端就可以利用JavaScript等将其取出然后请求API接口。该模式不需要授权码（code），当然也不会提供refresh token以获得长期访问的入口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Resource Owner Password Credentials（密码模式）&lt;/strong&gt;&lt;br/&gt;自己有一套用户体系，这种模式要求用户提供用户名和密码来交换访问令牌（access_token）。该模式仅用于非常值得信任的用户，例如API提供者本人所写的移动应用。虽然用户也要求提供密码，但并不需要存储在设备上。因为初始验证之后，只需将 OAuth 的令牌记录下来即可。如果用户希望取消授权，因为其真实密码并没有被记录，因此无需修改密码就可以立即取消授权。token本身也只是得到有限的授权，因此相比最传统的 username/password 授权，该模式依然更为安全。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Client Credentials（客户端模式）&lt;br/&gt;&lt;/strong&gt;没有用户的概念，一种基于 APP 的密钥直接进行授权，因此 APP 的权限非常大。它适合像数据库或存储服务器这种对 API 的访问需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/span&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&quot; target=&quot;_blank&quot;&gt;理解 OAuth 2.0&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;15.119804400978&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-security-oauth&quot; target=&quot;_blank&quot;&gt;Spring Security OAuth2&lt;/a&gt;&lt;/span&gt; &lt;span&gt;是建立在&lt;/span&gt; &lt;a href=&quot;https://github.com/spring-projects/spring-security&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Spring Security&lt;/span&gt;&lt;/a&gt; &lt;span&gt;的基础之上 OAuth2.0 协议实现的一个类库，它提供了构建 Authorization Server、Resource Server 和 Client 三种 Spring 应用程序角色所需要的功能，能够更好的集成到 Spring Cloud 体系中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/keycloak/keycloak&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Keycloak&lt;/span&gt;&lt;/a&gt; &lt;span&gt;官方语言来解释，“为现代应用系统和服务提供开源的鉴权和授权访问控制管理”。Keycloak 实现了OpenID，Auth2.0，SAML单点登录协议，同时提供LDAP和Active Directory，以及OpenID Connect, SAML2.0 IdPs，Github，Google 等第三方登录适配功能，能够做到非常简单的开箱即用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;从 4.1 版开始，Spring Boot starter 将基于 Spring Boot 2 adapter。如果您使用的是较旧的 Spring Boot 版本，则可以使用 keycloak-legacy-spring-boot-starter。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;之前提到 Authorization Server、Resource Server 和 Client 之间的关系，下面使用 Spring Security OAuth2 为 Spring Cloud 搭建认证授权服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Authorization Server&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 Authorization Server  的角色中 Spring Security OAuth2 定义了 AuthorizationServerConfigurerAdapter 配置类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AuthorizationServerConfigurerAdapter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AuthorizationServerConfigurer {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AuthorizationServerConfigurerAdapter() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(AuthorizationServerSecurityConfigurer security) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(ClientDetailsServiceConfigurer clients) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(AuthorizationServerEndpointsConfigurer endpoints) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;ClientDetailsServiceConfigurer：用来配置客户端详情信息，一般使用数据库来存储或读取应用配置的详情信息（client_id ，client_secret，redirect_uri 等配置信息）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AuthorizationServerSecurityConfigurer：用来配置令牌端点(Token Endpoint)的安全与权限访问。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AuthorizationServerEndpointsConfigurer：用来配置授权以及令牌（Token）的访问端点和令牌服务（比如：配置令牌的签名与存储方式）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Resource Server&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 Resource Server 的角色中 Spring Security OAuth2 定义了 ResourceServerConfigurerAdapter 配置类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ResourceServerConfigurerAdapter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ResourceServerConfigurer {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResourceServerConfigurerAdapter() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(ResourceServerSecurityConfigurer resources) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(HttpSecurity http) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ((AuthorizedUrl)http.authorizeRequests().anyRequest()).authenticated();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ResourceServerConfigurerAdapter 用于保护 OAuth2 要开放的资源，同时主要作用于client端以及token的认证(&lt;span&gt;&lt;code&gt;&lt;span&gt;Bearer Auth&lt;/span&gt;&lt;/code&gt;)，由于后面 OAuth2 服务端后续还需要提供用户信息，所以也是一个 Resource Server，默认拦截了所有的请求，也可以通过重新方法方式自定义自己想要拦截的资源 URL 地址。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外根据 OAuth2.0 规范，获取票据要支持 Basic 验证与验证用户的账户信息，比如密码模式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
     POST /token HTTP/&lt;span&gt;1.1&lt;/span&gt;&lt;span&gt;
     Host: server.example.com
     Authorization: Basic 1sZCaJks20MzpnMsPOi
     Content&lt;/span&gt;-Type: application/x-www-form-&lt;span&gt;urlencoded
     grant_type&lt;/span&gt;=password&amp;amp;username=irving&amp;amp;password=&lt;span&gt;123456&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以在 WebSecurityConfigurerAdapter 类中重新相应的方法来实现。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;AuthorizationServerConfigurerAdapter&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ResourceServerConfigurerAdapter&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;WebSecurityConfigurerAdapter&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Client&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据 OAuth2.0 规范定义获得票据需要提供 client_id 与 client_secret ，这个过程需要在服务端申请获得，比我新浪与腾讯的联合登录就是采用的授权码模式。一般还是要根据适用的场景给与不同的配置与作用域。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   /*&lt;/span&gt;&lt;span&gt;
    * 配置客户端详情信息(内存或JDBC来实现)
    *
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(ClientDetailsServiceConfigurer clients) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化 Client 数据到 DB&lt;/span&gt;
&lt;span&gt;        clients.jdbc(dataSource)
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; clients.inMemory()&lt;/span&gt;
                .withClient(&quot;client_1&quot;&lt;span&gt;)
                .authorizedGrantTypes(&lt;/span&gt;&quot;client_credentials&quot;&lt;span&gt;)
                .scopes(&lt;/span&gt;&quot;all&quot;,&quot;read&quot;, &quot;write&quot;&lt;span&gt;)
                .authorities(&lt;/span&gt;&quot;client_credentials&quot;&lt;span&gt;)
                .accessTokenValiditySeconds(&lt;/span&gt;7200&lt;span&gt;)
                .secret(passwordEncoder.encode(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;))

                .and().withClient(&lt;/span&gt;&quot;client_2&quot;&lt;span&gt;)
                .authorizedGrantTypes(&lt;/span&gt;&quot;password&quot;, &quot;refresh_token&quot;&lt;span&gt;)
                .scopes(&lt;/span&gt;&quot;all&quot;,&quot;read&quot;, &quot;write&quot;&lt;span&gt;)
                .accessTokenValiditySeconds(&lt;/span&gt;7200&lt;span&gt;)
                .refreshTokenValiditySeconds(&lt;/span&gt;10000&lt;span&gt;)
                .authorities(&lt;/span&gt;&quot;password&quot;&lt;span&gt;)
                .secret(passwordEncoder.encode(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;))

                .and().withClient(&lt;/span&gt;&quot;client_3&quot;).authorities(&quot;authorization_code&quot;,&quot;refresh_token&quot;&lt;span&gt;)
                .secret(passwordEncoder.encode(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;))
                .authorizedGrantTypes(&lt;/span&gt;&quot;authorization_code&quot;&lt;span&gt;)
                .scopes(&lt;/span&gt;&quot;all&quot;,&quot;read&quot;, &quot;write&quot;&lt;span&gt;)
                .accessTokenValiditySeconds(&lt;/span&gt;7200&lt;span&gt;)
                .refreshTokenValiditySeconds(&lt;/span&gt;10000&lt;span&gt;)
                .redirectUris(&lt;/span&gt;&quot;http://localhost:8080/callback&quot;,&quot;http://localhost:8080/signin&quot;&lt;span&gt;)

                .and().withClient(&lt;/span&gt;&quot;client_test&quot;&lt;span&gt;)
                .secret(passwordEncoder.encode(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;))
                .authorizedGrantTypes(&lt;/span&gt;&quot;all flow&quot;&lt;span&gt;)
                .authorizedGrantTypes(&lt;/span&gt;&quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;,&quot;password&quot;, &quot;implicit&quot;&lt;span&gt;)
                .redirectUris(&lt;/span&gt;&quot;http://localhost:8080/callback&quot;,&quot;http://localhost:8080/signin&quot;&lt;span&gt;)
                .scopes(&lt;/span&gt;&quot;all&quot;,&quot;read&quot;, &quot;write&quot;&lt;span&gt;)
                .accessTokenValiditySeconds(&lt;/span&gt;7200&lt;span&gt;)
                .refreshTokenValiditySeconds(&lt;/span&gt;10000&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql&lt;/span&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; clients.withClientDetails(new JdbcClientDetailsService(dataSource));&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;理解上述说的关系后，就可以来实现 OAuth2.0 的相关服务了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;MAVEN&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0.3.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.reporting.outputEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.reporting.outputEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spring-cloud.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Finchley.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spring-cloud.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;Spring Security 与 Security 的 OAuth2 扩展&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-oauth2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-security&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-hystrix&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 将 token 存储在 redis 中 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-jdbc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;8.0.11&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;SpringApplication&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.727626459144&quot;&gt;
&lt;pre&gt;
@SpringCloudApplication &lt;span&gt;&lt;a&gt;//&lt;/a&gt;&lt;/span&gt;&lt;span&gt;@SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MicrosrvOauth2ServerApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(MicrosrvOauth2ServerApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
[/oauth/authorize]
[/oauth/token]
[/oauth/check_token]
[/oauth/confirm_access]
[/oauth/token_key]
[/oauth/error]
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
@EnableAuthorizationServer
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Order(2)&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AuthorizationServerConfiguration &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AuthorizationServerConfigurerAdapter {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AuthenticationManager authenticationManager;

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BCryptPasswordEncoder passwordEncoder;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @Autowired
    private RedisConnectionFactory connectionFactory;

    @Bean
    public RedisTokenStore tokenStore() {
        return new RedisTokenStore(connectionFactory);
    }
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    @Autowired
    @Qualifier(&lt;/span&gt;&quot;dataSource&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DataSource dataSource;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Bean(name = &quot;dataSource&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public DataSource dataSource() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return DataSourceBuilder.create().build();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;
&lt;span&gt;
    @Bean(&lt;/span&gt;&quot;jdbcTokenStore&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JdbcTokenStore getJdbcTokenStore() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdbcTokenStore(dataSource);
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public UserDetailsService userDetailsService(){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return new UserService();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * 配置客户端详情信息(内存或JDBC来实现)
    *
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(ClientDetailsServiceConfigurer clients) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化 Client 数据到 DB&lt;/span&gt;
&lt;span&gt;        clients.jdbc(dataSource)
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; clients.inMemory()&lt;/span&gt;
                .withClient(&quot;client_1&quot;&lt;span&gt;)
                .authorizedGrantTypes(&lt;/span&gt;&quot;client_credentials&quot;&lt;span&gt;)
                .scopes(&lt;/span&gt;&quot;all&quot;,&quot;read&quot;, &quot;write&quot;&lt;span&gt;)
                .authorities(&lt;/span&gt;&quot;client_credentials&quot;&lt;span&gt;)
                .accessTokenValiditySeconds(&lt;/span&gt;7200&lt;span&gt;)
                .secret(passwordEncoder.encode(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;))

                .and().withClient(&lt;/span&gt;&quot;client_2&quot;&lt;span&gt;)
                .authorizedGrantTypes(&lt;/span&gt;&quot;password&quot;, &quot;refresh_token&quot;&lt;span&gt;)
                .scopes(&lt;/span&gt;&quot;all&quot;,&quot;read&quot;, &quot;write&quot;&lt;span&gt;)
                .accessTokenValiditySeconds(&lt;/span&gt;7200&lt;span&gt;)
                .refreshTokenValiditySeconds(&lt;/span&gt;10000&lt;span&gt;)
                .authorities(&lt;/span&gt;&quot;password&quot;&lt;span&gt;)
                .secret(passwordEncoder.encode(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;))

                .and().withClient(&lt;/span&gt;&quot;client_3&quot;).authorities(&quot;authorization_code&quot;,&quot;refresh_token&quot;&lt;span&gt;)
                .secret(passwordEncoder.encode(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;))
                .authorizedGrantTypes(&lt;/span&gt;&quot;authorization_code&quot;&lt;span&gt;)
                .scopes(&lt;/span&gt;&quot;all&quot;,&quot;read&quot;, &quot;write&quot;&lt;span&gt;)
                .accessTokenValiditySeconds(&lt;/span&gt;7200&lt;span&gt;)
                .refreshTokenValiditySeconds(&lt;/span&gt;10000&lt;span&gt;)
                .redirectUris(&lt;/span&gt;&quot;http://localhost:8080/callback&quot;,&quot;http://localhost:8080/signin&quot;&lt;span&gt;)

                .and().withClient(&lt;/span&gt;&quot;client_test&quot;&lt;span&gt;)
                .secret(passwordEncoder.encode(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;))
                .authorizedGrantTypes(&lt;/span&gt;&quot;all flow&quot;&lt;span&gt;)
                .authorizedGrantTypes(&lt;/span&gt;&quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;,&quot;password&quot;, &quot;implicit&quot;&lt;span&gt;)
                .redirectUris(&lt;/span&gt;&quot;http://localhost:8080/callback&quot;,&quot;http://localhost:8080/signin&quot;&lt;span&gt;)
                .scopes(&lt;/span&gt;&quot;all&quot;,&quot;read&quot;, &quot;write&quot;&lt;span&gt;)
                .accessTokenValiditySeconds(&lt;/span&gt;7200&lt;span&gt;)
                .refreshTokenValiditySeconds(&lt;/span&gt;10000&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql&lt;/span&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; clients.withClientDetails(new JdbcClientDetailsService(dataSource));&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(AuthorizationServerEndpointsConfigurer endpoints) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        endpoints
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .tokenStore(new RedisTokenStore(redisConnectionFactory))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .authenticationManager(authenticationManager);&lt;/span&gt;
&lt;span&gt;
           endpoints.authenticationManager(authenticationManager)
                     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置 JwtAccessToken 转换器
                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  .accessTokenConverter(jwtAccessTokenConverter())
                     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;refresh_token 需要 UserDetailsService is required
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   .userDetailsService(userDetailsService)&lt;/span&gt;
&lt;span&gt;                    .allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST)
                    .tokenStore(getJdbcTokenStore());
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configure(AuthorizationServerSecurityConfigurer oauthServer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;curl -i -X POST -H &quot;Accept: application/json&quot; -u &quot;client_1:123456&quot; &lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:5000/oauth/check_token?token=a1478d56-ebb8-4f21-b4b6-8a9602df24ec&lt;/span&gt;
        oauthServer.tokenKeyAccess(&quot;permitAll()&quot;)         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;url:/oauth/token_key,exposes public key for token verification if using JWT tokens&lt;/span&gt;
                   .checkTokenAccess(&quot;isAuthenticated()&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;url:/oauth/check_token allow check token&lt;/span&gt;
&lt;span&gt;                   .allowFormAuthenticationForClients();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用非对称加密算法来对Token进行签名
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JwtAccessTokenConverter jwtAccessTokenConverter() {
        JwtAccessTokenConverter converter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtAccessTokenConverter();
        KeyPair keyPair &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; KeyStoreKeyFactory(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;keystore.jks&quot;), &quot;foobar&quot;&lt;span&gt;.toCharArray())
                .getKeyPair(&lt;/span&gt;&quot;test&quot;&lt;span&gt;);
        converter.setKeyPair(keyPair);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; converter;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
* 提供 user 信息，所以 oauth2-server 也是一个Resource Server
* &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
@EnableResourceServer
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Order(3)&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ResourceServerConfiguration &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ResourceServerConfigurerAdapter  {

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void configure(HttpSecurity http) throws Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        http
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Since we want the protected resources to be accessible in the UI as well we need
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; session creation to be allowed (it's disabled by default in 2.0.6)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .and()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .requestMatchers().anyRequest()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .and()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .anonymous()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .and()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .authorizeRequests()&lt;/span&gt;&lt;span&gt;
////&lt;/span&gt;&lt;span&gt;              .antMatchers(&quot;/product/**&quot;).access(&quot;#oauth2.hasScope('select') and hasRole('ROLE_USER')&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .antMatchers(&quot;/user/**&quot;).authenticated();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须认证过后才可以访问
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void configure(HttpSecurity http) throws Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        http.requestMatchers().anyRequest()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .and()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .authorizeRequests()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .antMatchers(&quot;/api/**&quot;).authenticated();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@EnableWebSecurity
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Order(1)&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebSecurityConfiguration &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; WebSecurityConfigurerAdapter {

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDetailsService userDetailsService(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserService();
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BCryptPasswordEncoder passwordEncoder(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BCryptPasswordEncoder();
    }
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(AuthenticationManagerBuilder auth) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        auth.inMemoryAuthentication()
                .withUser(&lt;/span&gt;&quot;irving&quot;&lt;span&gt;)
                .password(passwordEncoder().encode(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;))
                .roles(&lt;/span&gt;&quot;read&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; auth.userDetailsService(userDetailsService())
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   .passwordEncoder(passwordEncoder());&lt;/span&gt;
&lt;span&gt;    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public static NoOpPasswordEncoder passwordEncoder() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return (NoOpPasswordEncoder) NoOpPasswordEncoder.getInstance();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(HttpSecurity http) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        http
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .formLogin().loginPage(&quot;/login&quot;).permitAll()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .and()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .requestMatchers()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .antMatchers(&quot;/&quot;, &quot;/login&quot;, &quot;/oauth/authorize&quot;, &quot;/oauth/confirm_access&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .and()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .authorizeRequests()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .anyRequest().authenticated();


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        http.requestMatchers()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .antMatchers(&quot;/login&quot;, &quot;/oauth/authorize&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .and()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .authorizeRequests()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .anyRequest().authenticated()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .and()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .formLogin().permitAll();

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     http.csrf().disable();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不拦截 oauth 开放的资源&lt;/span&gt;
&lt;span&gt;        http.requestMatchers()
                .anyRequest()
                .and()
                .authorizeRequests()
                .antMatchers(&lt;/span&gt;&quot;/oauth/**&quot;&lt;span&gt;).permitAll();
    }

    @Override
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AuthenticationManager authenticationManagerBean() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.authenticationManagerBean();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
@RequestMapping(&lt;/span&gt;&quot;/api/user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController {

    @GetMapping(&lt;/span&gt;&quot;/me&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Principal user(Principal principal) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; principal;
    }

    @GetMapping(&lt;/span&gt;&quot;/{name}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserName(@PathVariable String name) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello,&quot;+&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;application.yml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.895988112927&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#logging:
#  level:
#    root: DEBUG
logging:
  level:
      org.springframework: INFO #INFO
      org.springframework.security: DEBUG
spring:
  application:
    name: microsrv&lt;/span&gt;-oauth2-&lt;span&gt;server
  datasource:
    url: jdbc:mysql:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;XXX.XXX.XXX.XXX:3306/oauth2?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;autoReconnect=true&amp;amp;useSSL=false&lt;/span&gt;
&lt;span&gt;    username: root
    password: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!TEST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    driver: com.mysql.cj.jdbc.Driver
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
        minIdle: &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
        idle&lt;/span&gt;-timeout: &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
        maximumPoolSize: &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
server:
  port: &lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;config:
    oauth2:
        # openssl genrsa &lt;/span&gt;-out jwt.pem &lt;span&gt;2048&lt;/span&gt;&lt;span&gt;
        # openssl rsa &lt;/span&gt;-&lt;span&gt;in&lt;/span&gt;&lt;span&gt; jwt.pem
        privateKey: &lt;/span&gt;|
            -----BEGIN RSA PRIVATE KEY-----&lt;span&gt;
            MIICXQIBAAKBgQDNQZKqTlO&lt;/span&gt;/+&lt;span&gt;2b4ZdhqGJzGBDltb5PZmBz1ALN2YLvt341pH6i5
            mO1V9cX5Ty1LM70fKfnIoYUP4KCE33dPnC7LkUwE&lt;/span&gt;/&lt;span&gt;myh1zM6m8cbL5cYFPyP099t
            hbVxzJkjHWqywvQih&lt;/span&gt;/&lt;span&gt;qOOjliomKbM9pxG8Z1dB26hL9dSAZuA8xExjlPmQIDAQAB
            AoGAImnYGU3ApPOVtBf&lt;/span&gt;/TOqLfne+&lt;span&gt;2SZX96eVU06myDY3zA4rO3DfbR7CzCLE6qPn
            yDAIiW0UQBs0oBDdWOnOqz5YaePZu&lt;/span&gt;/&lt;span&gt;yrLyj6KM6Q2e9ywRDtDh3ywrSfGpjdSvvo
            aeL1WesBWsgWv1vFKKvES7ILFLUxKwyCRC2Lgh7aI9GGZfECQQD84m98Yrehhin3
            fZuRaBNIu348Ci7ZFZmrvyxAIxrV4jBjpACW0RM2BvF5oYM2gOJqIfBOVjmPwUro
            bYEFcHRvAkEAz8jsfmxsZVwh3Y&lt;/span&gt;/&lt;span&gt;Y47BzhKIC5FLaads541jNjVWfrPirljyCy1n4
            sg3WQH2IEyap3WTP84&lt;/span&gt;+&lt;span&gt;csCtsfNfyK7fQdwJBAJNRyobY74cupJYkW5OK4OkXKQQL
            Hp2iosJV&lt;/span&gt;/Y5jpQeC3JO/&lt;span&gt;gARcSmfIBbbI66q9zKjtmpPYUXI4tc3PtUEY8QsCQQCc
            xySyC0sKe6bNzyC&lt;/span&gt;+Q8AVvkxiTKWiI5idEr8duhJd589H72Zc2wkMB+a2CEGo+&lt;span&gt;Y5H
            jy5cvuph&lt;/span&gt;/pG/7Qw7sljnAkAy/feClt1mUEiAcWrHRwcQ71AoA0+&lt;span&gt;21yC9VkqPNrn3
            w7OEg8gBqPjRlXBNb00QieNeGGSkXOoU6gFschR22Dzy
            &lt;/span&gt;-----END RSA PRIVATE KEY-----&lt;span&gt;
        # openssl rsa &lt;/span&gt;-&lt;span&gt;in&lt;/span&gt; jwt.pem -&lt;span&gt;pubout
        publicKey: &lt;/span&gt;|
            -----BEGIN PUBLIC KEY-----&lt;span&gt;
            MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDNQZKqTlO&lt;/span&gt;/+&lt;span&gt;2b4ZdhqGJzGBDlt
            b5PZmBz1ALN2YLvt341pH6i5mO1V9cX5Ty1LM70fKfnIoYUP4KCE33dPnC7LkUwE
            &lt;/span&gt;/myh1zM6m8cbL5cYFPyP099thbVxzJkjHWqywvQih/&lt;span&gt;qOOjliomKbM9pxG8Z1dB26
            hL9dSAZuA8xExjlPmQIDAQAB
            &lt;/span&gt;-----END PUBLIC KEY-----&lt;span&gt;
eureka:
  instance:
    preferIpAddress: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
#    instanceId: ${spring.cloud.client.ipAddress}:${server.port}
  client:
    serviceUrl:
      defaultZone: &lt;a href=&quot;http://10.255.131.162:8000/eureka/,http://10.255.131.163:8000/eureka/,http://10.255.131.164:8000/eureka/&quot;&gt;http:&lt;/a&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.255.131.162:8000/eureka/,&lt;/span&gt;&lt;span&gt;http://10.255.131.163&lt;/span&gt;&lt;span&gt;:8000/eureka/,&lt;/span&gt;&lt;span&gt;http://10.255.131.164&lt;/span&gt;&lt;span&gt;:8000/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;客户端模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
POST http://localhost:5000/oauth/token HTTP/1.1&lt;span&gt;
Authorization: Basic Y2xpZW50XzE6MTIzNDU2
&lt;/span&gt;&lt;span&gt;cache&lt;/span&gt;-control: no-&lt;span&gt;cache&lt;/span&gt;&lt;span&gt;
Postman-Token: 86fd25cd-406d-4db1-a67a-eda3cf760ba5
User-Agent: PostmanRuntime&lt;/span&gt;/7.1.1&lt;span&gt;
Accept: *&lt;/span&gt;/&lt;span&gt;*
Host: localhost:&lt;/span&gt;5000&lt;span&gt;
content-&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;: application/&lt;span&gt;x-www-form-urlencoded
accept-encoding: gzip&lt;/span&gt;,&lt;span&gt; deflate
content-length: &lt;/span&gt;29&lt;span&gt;
Connection: keep-alive
grant_type&lt;/span&gt;=&lt;span&gt;client_credentials
HTTP&lt;/span&gt;/1.1 200
&lt;span&gt;{&lt;/span&gt;&quot;access_token&quot;:&quot;a1478d56-ebb8-4f21-b4b6-8a9602df24ec&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;expires_in&quot;:1014,&quot;scope&quot;:&quot;all read write&quot;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;密码模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
POST http://localhost:5000/oauth/token HTTP/1.1&lt;span&gt;
Authorization: Basic Y2xpZW50X3Rlc3Q6MTIzNDU2
&lt;/span&gt;&lt;span&gt;cache&lt;/span&gt;-control: no-&lt;span&gt;cache&lt;/span&gt;&lt;span&gt;
Postman-Token: f97aca16-e2ea-4dda-b51f-eb95caa57560
User-Agent: PostmanRuntime&lt;/span&gt;/7.1.1&lt;span&gt;
Accept: *&lt;/span&gt;/&lt;span&gt;*
Host: localhost:&lt;/span&gt;5000&lt;span&gt;
content-&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;: application/&lt;span&gt;x-www-form-urlencoded
&lt;/span&gt;&lt;span&gt;grant_type&lt;/span&gt;=password&amp;amp;scope=all&amp;amp;username=irving&amp;amp;password=123456&lt;span&gt;
HTTP&lt;/span&gt;/1.1 200
&lt;span&gt;{&lt;/span&gt;&quot;access_token&quot;:&quot;dfe36394-8592-472f-b52b-24739811f6ee&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;refresh_token&quot;:&quot;c150594f-7d00-44cc-bbce-49e1a6e83552&quot;,&quot;expires_in&quot;:7190,&quot;scope&quot;:&quot;all&quot;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;获取资源信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
GET http://localhost:5000/api/user/me?access_token=a1478d56-ebb8-4f21-b4b6-8a9602df24ec HTTP/1.1&lt;span&gt;
Host: localhost:&lt;/span&gt;5000&lt;span&gt;
HTTP&lt;/span&gt;/1.1 200&lt;span&gt;
X-Content-&lt;/span&gt;&lt;span&gt;Type&lt;/span&gt;&lt;span&gt;-Options: nosniff
X-XSS-Protection: &lt;/span&gt;1; &lt;span&gt;mode&lt;/span&gt;=&lt;span&gt;block
&lt;/span&gt;&lt;span&gt;Cache&lt;/span&gt;-Control: no-&lt;span&gt;cache&lt;/span&gt;, no-store, max-age=0,&lt;span&gt; must-revalidate
Pragma: no-&lt;/span&gt;&lt;span&gt;cache&lt;/span&gt;&lt;span&gt;
Expires: &lt;/span&gt;0&lt;span&gt;
X-Frame-Options: DENY
Content-&lt;/span&gt;&lt;span&gt;Type&lt;/span&gt;: application/json;charset=UTF-8
&lt;span&gt;Date&lt;/span&gt;: Fri, 20 Jul 2018 09:21:32&lt;span&gt; GMT
Content-Length: &lt;/span&gt;674&lt;span&gt;
{&lt;/span&gt;&quot;authorities&quot;:[{&quot;authority&quot;:&quot;client_credentials&quot;}],&quot;details&quot;:{&quot;remoteAddress&quot;:&quot;0:0:0:0:0:0:0:1&quot;,&quot;sessionId&quot;&lt;span&gt;:null&lt;/span&gt;,&quot;tokenValue&quot;:&quot;a1478d56-ebb8-4f21-b4b6-8a9602df24ec&quot;,&quot;tokenType&quot;:&quot;Bearer&quot;,&quot;decodedDetails&quot;&lt;span&gt;:null&lt;/span&gt;},&quot;authenticated&quot;&lt;span&gt;:true&lt;/span&gt;,&quot;userAuthentication&quot;&lt;span&gt;:null&lt;/span&gt;,&quot;credentials&quot;:&quot;&quot;,&quot;oauth2Request&quot;:{&quot;clientId&quot;:&quot;client_1&quot;,&quot;scope&quot;:[&quot;all&quot;,&quot;read&quot;,&quot;write&quot;],&quot;requestParameters&quot;:{&quot;grant_type&quot;:&quot;client_credentials&quot;},&quot;resourceIds&quot;:[],&quot;authorities&quot;:[{&quot;authority&quot;:&quot;client_credentials&quot;}],&quot;approved&quot;&lt;span&gt;:true&lt;/span&gt;,&quot;refresh&quot;&lt;span&gt;:false&lt;/span&gt;,&quot;redirectUri&quot;&lt;span&gt;:null&lt;/span&gt;,&quot;responseTypes&quot;:[],&quot;extensions&quot;:{},&quot;refreshTokenRequest&quot;&lt;span&gt;:null&lt;/span&gt;,&quot;grantType&quot;:&quot;client_credentials&quot;},&quot;clientOnly&quot;&lt;span&gt;:true&lt;/span&gt;,&quot;principal&quot;:&quot;client_1&quot;,&quot;name&quot;:&quot;client_1&quot;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;There is no PasswordEncoder mapped for the id “null”问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般是老的项目升到 Spring Boot 2.0 依赖的是 Spring 5，相关的依赖都发生了较大的改动&lt;/span&gt; &lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/5.0.4.RELEASE/reference/htmlsingle/#new&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Spring Security 5.0 New Features&lt;/span&gt;&lt;/a&gt; &lt;span&gt;，Spring Security 重构了 PasswordEncoder 相关的算法 ，原先默认配置的 PlainTextPasswordEncoder（明文密码）被移除了，替代的 BCryptPasswordEncoder ，Client 与 Resource Server 中设计密码的相关都需要采用新的的编码方式（上述代码已采用）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;兼容老版本 明文存储&lt;/span&gt;
&lt;span&gt;@Bean
PasswordEncoder passwordEncoder(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NoOpPasswordEncoder.getInstance();
}

@Bean
PasswordEncoder passwordEncoder(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BCryptPasswordEncoder();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;method_not_allowed(Request method 'GET' not supported)  问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以配置，由于不是 OAuth2.0 规范定义的范畴，调试在密码模式获得票据的时候会报错，不推荐。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OAuthSecurityConfig &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AuthorizationServerConfigurerAdapter {
...
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(AuthorizationServerEndpointsConfigurer endpoints) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    ...
    endpoints.allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add get method&lt;/span&gt;
&lt;span&gt;    ...

    endpoints.tokenServices(tokenServices);
}
...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Token 存储 DB 报错问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;检查数据库 token 相关的字段是否是二进制数据类型(默认是：token LONGVARBINARY)，数据库的脚本可以在 Spring Security OAuth2 官方的项目中找到：&lt;/span&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql&quot;&gt;&lt;span&gt;https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;89&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.574&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] .s.s.o.p.c.ClientCredentialsTokenGranter : Getting access token &lt;span&gt;for&lt;/span&gt;&lt;span&gt;: client_1
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.574&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;] o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL query
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.574&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [&lt;span&gt;select&lt;/span&gt; token_id, token from oauth_access_token where authentication_id = ?&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.575&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;] o.s.jdbc.datasource.DataSourceUtils      : Fetching JDBC Connection from DataSource
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.623&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.623&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] o.s.s.o.p.token.store.JdbcTokenStore     : Failed to &lt;span&gt;find&lt;/span&gt; access token &lt;span&gt;for&lt;/span&gt; authentication org.springframework.security.oauth2.provider.OAuth2Authentication@f5d4467d: Principal: client_1; Credentials: [PROTECTED]; Authenticated: &lt;span&gt;true&lt;/span&gt;; Details: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; Granted Authorities: TRUSTED_CLIENT
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.623&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] o.s.b.f.s.DefaultListableBeanFactory     : Returning cached instance of singleton bean &lt;span&gt;'&lt;/span&gt;&lt;span&gt;scopedTarget.clientDetailsService&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.623&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] o.s.b.f.s.DefaultListableBeanFactory     : Returning cached instance of singleton bean &lt;span&gt;'&lt;/span&gt;&lt;span&gt;scopedTarget.clientDetailsService&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.623&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;] o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL query
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.623&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [&lt;span&gt;select&lt;/span&gt; token_id, token from oauth_access_token where token_id = ?&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.623&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;] o.s.jdbc.datasource.DataSourceUtils      : Fetching JDBC Connection from DataSource
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.650&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.650&lt;/span&gt;  INFO &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] o.s.s.o.p.token.store.JdbcTokenStore     : Failed to &lt;span&gt;find&lt;/span&gt; access token &lt;span&gt;for&lt;/span&gt; token ad587601-e0fd-4dea-8fcc-&lt;span&gt;75144eb74101
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.650&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;] o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.650&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [insert into oauth_access_token (token_id, token, authentication_id, user_name, client_id, authentication, refresh_token) values (?, ?, ?, ?, ?, ?, ?&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.650&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;] o.s.jdbc.datasource.DataSourceUtils      : Fetching JDBC Connection from DataSource
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.651&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] o.s.jdbc.support.lob.DefaultLobHandler   : Set bytes &lt;span&gt;for&lt;/span&gt; BLOB with length &lt;span&gt;691&lt;/span&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.651&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] o.s.jdbc.support.lob.DefaultLobHandler   : Set bytes &lt;span&gt;for&lt;/span&gt; BLOB with length &lt;span&gt;1627&lt;/span&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.665&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;] o.s.jdbc.datasource.DataSourceUtils      : Returning JDBC Connection to DataSource
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.665&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] s.j.s.SQLErrorCodeSQLExceptionTranslator : Unable to translate SQLException with Error code &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1366&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, will now try the fallback translator
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.665&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] o.s.j.s.SQLStateSQLExceptionTranslator   : Extracted SQL state class &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; from value &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HY000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.665&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] .m.m.a.ExceptionHandlerExceptionResolver : Resolving exception from handler [public org.springframework.http.ResponseEntity&amp;lt;org.springframework.security.oauth2.common.OAuth2AccessToken&amp;gt; org.springframework.security.oauth2.provider.endpoint.TokenEndpoint.getAccessToken(java.security.Principal,java.util.Map&amp;lt;java.lang.String, java.lang.String&amp;gt;) throws org.springframework.web.HttpRequestMethodNotSupportedException]: org.springframework.jdbc.UncategorizedSQLException: PreparedStatementCallback; uncategorized SQLException &lt;span&gt;for&lt;/span&gt; SQL [insert into oauth_access_token (token_id, token, authentication_id, user_name, client_id, authentication, refresh_token) values (?, ?, ?, ?, ?, ?, ?)]; SQL state [HY000]; error code [&lt;span&gt;1366&lt;/span&gt;]; Incorrect &lt;span&gt;string&lt;/span&gt; value: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xAC\xED\x00\x05sr...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; column &lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; at row &lt;span&gt;1&lt;/span&gt;; nested exception is java.sql.SQLException: Incorrect &lt;span&gt;string&lt;/span&gt; value: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xAC\xED\x00\x05sr...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; column &lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; at row &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.665&lt;/span&gt; DEBUG &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] .m.m.a.ExceptionHandlerExceptionResolver : Invoking @ExceptionHandler method: public org.springframework.http.ResponseEntity&amp;lt;org.springframework.security.oauth2.common.exceptions.OAuth2Exception&amp;gt;&lt;span&gt; org.springframework.security.oauth2.provider.endpoint.TokenEndpoint.handleException(java.lang.Exception) throws java.lang.Exception
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;:&lt;span&gt;29.667&lt;/span&gt; ERROR &lt;span&gt;20084&lt;/span&gt; --- [nio-&lt;span&gt;5000&lt;/span&gt;-exec-&lt;span&gt;6&lt;/span&gt;] o.s.s.o.provider.endpoint.TokenEndpoint  : Handling error: UncategorizedSQLException, PreparedStatementCallback; uncategorized SQLException &lt;span&gt;for&lt;/span&gt; SQL [insert into oauth_access_token (token_id, token, authentication_id, user_name, client_id, authentication, refresh_token) values (?, ?, ?, ?, ?, ?, ?)]; SQL state [HY000]; error code [&lt;span&gt;1366&lt;/span&gt;]; Incorrect &lt;span&gt;string&lt;/span&gt; value: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xAC\xED\x00\x05sr...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; column &lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; at row &lt;span&gt;1&lt;/span&gt;; nested exception is java.sql.SQLException: Incorrect &lt;span&gt;string&lt;/span&gt; value: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xAC\xED\x00\x05sr...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; column &lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; at row &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

org.springframework.jdbc.UncategorizedSQLException: PreparedStatementCallback; uncategorized SQLException &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; SQL [insert into oauth_access_token (token_id, token, authentication_id, user_name, client_id, authentication, refresh_token) values (?, ?, ?, ?, ?, ?, ?)]; SQL state [HY000]; error code [&lt;span&gt;1366&lt;/span&gt;]; Incorrect &lt;span&gt;string&lt;/span&gt; value: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xAC\xED\x00\x05sr...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; column &lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; at row &lt;span&gt;1&lt;/span&gt;; nested exception is java.sql.SQLException: Incorrect &lt;span&gt;string&lt;/span&gt; value: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xAC\xED\x00\x05sr...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; column &lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; at row &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;票据存 DB 还是 Redis&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据 QPS 来吧，现阶段我们就是使用 DB 来存储，当然 Redis 或 MongoDB 都是比较好的选择（因为 Token 是临时性的，还涉及 Token 的刷新 ，验证合法性，过期等机制，操作会很频繁）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @Autowired
    private RedisConnectionFactory connectionFactory;

    @Bean
    public RedisTokenStore tokenStore() {
        return new RedisTokenStore(connectionFactory);
    }
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    @Autowired
    @Qualifier(&lt;/span&gt;&quot;dataSource&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DataSource dataSource;


    @Bean(&lt;/span&gt;&quot;jdbcTokenStore&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; JdbcTokenStore getJdbcTokenStore() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdbcTokenStore(dataSource);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; configure(AuthorizationServerEndpointsConfigurer endpoints) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        endpoints
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .tokenStore(new RedisTokenStore(redisConnectionFactory))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                .authenticationManager(authenticationManager);&lt;/span&gt;
&lt;span&gt;
           endpoints.authenticationManager(authenticationManager)
                     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置 JwtAccessToken 转换器
                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  .accessTokenConverter(jwtAccessTokenConverter())
                     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;refresh_token 需要 UserDetailsService is required
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   .userDetailsService(userDetailsService)&lt;/span&gt;
&lt;span&gt;                    .allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST)
                    .tokenStore(getJdbcTokenStore());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;a href=&quot;https://github.com/zhouyongtao/spring-cloud-microservice&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;GitHub 代码&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.2872340425532&quot;&gt;
&lt;p&gt;&lt;span&gt;REFER:&lt;br/&gt;如何构建安全的微服务应用&lt;br/&gt;&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/exceptioneye/p/9341011.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/exceptioneye/p/9341011.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 20 Jul 2018 12:12:00 +0000</pubDate>
<dc:creator>花儿笑弯了腰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Irving/p/9343377.html</dc:identifier>
</item>
</channel>
</rss>