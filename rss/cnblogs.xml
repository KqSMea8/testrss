<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>spring 懒加载 - successAndError</title>
<link>http://www.cnblogs.com/han-java/p/9615981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/han-java/p/9615981.html</guid>
<description>&lt;p&gt;&lt;span&gt;所谓&lt;a href=&quot;https://www.baidu.com/s?wd=%E6%87%92%E5%8A%A0%E8%BD%BD&amp;amp;tn=44039180_cpr&amp;amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9PWcYuHwBuWbkm1-9PHcv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHTLrHTsnHfsPjbzPWmzrj6Y&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;懒加载&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;(lazy)&lt;span&gt;就是延时加载，&lt;a href=&quot;https://www.baidu.com/s?wd=%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD&amp;amp;tn=44039180_cpr&amp;amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9PWcYuHwBuWbkm1-9PHcv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHTLrHTsnHfsPjbzPWmzrj6Y&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;延迟加载&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在spring&lt;span&gt;的&lt;span&gt;IOC&lt;span&gt;容器中，可以通过设置&lt;span&gt;&amp;lt;beans default-lazy-init=&quot;XXX&quot;&amp;gt;&amp;lt;/beans&amp;gt;&lt;span&gt;来设置是否为懒加载模式，懒加载的意思就是说是否在&lt;span&gt;spring&lt;span&gt;容器加载的时候将&lt;span&gt;bean&lt;span&gt;加载到容器中。在没有设置的情况下，默认是&lt;span&gt;false&lt;span&gt;的，就是说不使用懒加载模式。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至于为什么要用懒加载呢，就是当我们要访问的数据量过大时，明显用缓存不太合适，&lt;br/&gt;&lt;span&gt;因为&lt;a href=&quot;https://www.baidu.com/s?wd=%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F&amp;amp;tn=44039180_cpr&amp;amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9PWcYuHwBuWbkm1-9PHcv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHTLrHTsnHfsPjbzPWmzrj6Y&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;内存容量&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;有限 &lt;span&gt;，为了减少并发量，减少&lt;a href=&quot;https://www.baidu.com/s?wd=%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90&amp;amp;tn=44039180_cpr&amp;amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9PWcYuHwBuWbkm1-9PHcv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHTLrHTsnHfsPjbzPWmzrj6Y&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;系统资源&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的消耗，&lt;br/&gt;&lt;span&gt;我们让数据在需要的时候才进行加载，这时我们就用到了懒加载。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &amp;lt;filter&amp;gt;&lt;br/&gt;         &amp;lt;filter-name&amp;gt;OpenSessionInViewFilter&amp;lt;/filter-name&amp;gt;&lt;br/&gt;         &amp;lt;filter-class&amp;gt;org.springframework.orm.hibernate4.support.OpenSessionInViewFilter&amp;lt;/filter-class&amp;gt;&lt;br/&gt;          &amp;lt;init-param&amp;gt;&lt;br/&gt;           &amp;lt;param-name&amp;gt;flushMode&amp;lt;/param-name&amp;gt;&lt;br/&gt;            &amp;lt;param-value&amp;gt;AUTO&amp;lt;/param-value&amp;gt;&lt;br/&gt;        &amp;lt;/init-param&amp;gt;&lt;br/&gt;     &amp;lt;/filter&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;     &amp;lt;filter-mapping&amp;gt;&lt;br/&gt;         &amp;lt;filter-name&amp;gt;OpenSessionInViewFilter&amp;lt;/filter-name&amp;gt;&lt;br/&gt;         &amp;lt;url-pattern&amp;gt;*.action&amp;lt;/url-pattern&amp;gt;&lt;br/&gt;     &amp;lt;/filter-mapping&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;这个过滤器可以解决懒加载问题但是必须配置在Struts2的核心的过滤器之前!&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;



</description>
<pubDate>Sun, 09 Sep 2018 15:49:00 +0000</pubDate>
<dc:creator>successAndError</dc:creator>
<og:description>所谓懒加载(lazy)就是延时加载，延迟加载。 在spring的IOC容器中，可以通过设置&lt;beans default-lazy-init=&quot;XXX&quot;&gt;&lt;/bea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/han-java/p/9615981.html</dc:identifier>
</item>
<item>
<title>Spring之AOP - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/9615948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/9615948.html</guid>
<description>&lt;p&gt;一、AOP的引入&lt;br/&gt;这里可以把单个模块当做是一圆柱，假如没有aop，在做日志处理的时候，我们会在每个模块中添加日志或者权限处理，日志或权限类似圆柱体的部分圆柱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909230546751-573513561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般大多数的日志或权限处理代码是相同的，为了实现代码复用，我们可能把日志处理抽离成一个新的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909230622546-1806214387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是这样我们仍然必须手动插入这些方法，而且这两个方法就是强耦合的，假如此时我们不需要这个功能了，或者想换成其他功能，那么就必须一个个修改。&lt;br/&gt;通过动态代理，可以在指定位置执行对应流程。这样就可以将一些横向的功能抽离出来形成一个独立的模块，然后在指定位置插入这些功能。这样的思想，被称为面向切面编程，亦即AOP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909230721814-1012946703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、AOP主要概念&lt;/p&gt;
&lt;p&gt;上小节介绍了引入AOP的好处，本小节来了解下AOP的几个核心概念。&lt;br/&gt;1.横切关注点&lt;br/&gt;AOP把一个业务流程分成几部分，例如权限检查、业务处理、日志记录，每个部分单独处理，然后把它们组装成完整的业务流，每部分被称为切面或关注点。&lt;br/&gt;2.切面&lt;br/&gt;类是对物体特征的抽象，切面就是对横切关注点的抽象。可以每部分抽象成一叠纸一样一层一层的，那每张纸都是一切面。&lt;br/&gt;3.连接点&lt;br/&gt;被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器.其实Spring只支持方法类型的连接点就包含字段和构造器。为啥呢？因为字段它是通过get，set方法，构造器它其实也是方法。Spring只支持方法类型的连接点和连接点是字段或者构造器它们是包含关系。&lt;br/&gt;4.切入点&lt;br/&gt;对连接点进行拦截的定义，连接点可以很多，但并不一定每个连接点都进行操作，比如莲藕，藕段与藕段之间它们是有连接点的，但不一定都切开。&lt;br/&gt;5.通知&lt;br/&gt;通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类，这个有点类似把藕段与藕段断开之后要做的事情，是往里面加蜂蜜还是做什么。&lt;br/&gt;6.目标对象&lt;br/&gt;代理的目标对象，就是动态代理的target,在实际操作中一般会先实现AOP的接口，然后配置这些接口作用到哪些对象上，被作用的对象就是目标对象。&lt;br/&gt;7.织入&lt;br/&gt;切面是独立的，目标对象也是独立的，它们是不耦合的，那它怎么把切面放到目标对象中呢，这时就需要进行织入操作，就类似一中的，怎么把target和打印日志联系到一起呢，那就需要动态代理，在spring中aop.framework.ProxyFactory就是用作织入器，来进行横切逻辑的织入。&lt;br/&gt;8.引入&lt;br/&gt; 不改代码的同时，为类动态的添加方法或字段。&lt;/p&gt;
&lt;p&gt;三、AOP实现&lt;/p&gt;
&lt;p&gt;前面小节主要介绍了AOP的理论知识，本小节通过示例进一步理解Spring中AOP的使用。主要介绍AOP的三种实现方式：经典的基于代理的AOP、AspectJ基于XML的配置、AspectJ基于注解的配置。&lt;/p&gt;
&lt;p&gt;一、经典的基于代理的AOP&lt;/p&gt;
&lt;p&gt;基于代理的AOP主要介绍MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice三个接口的使用。&lt;br/&gt;MethodBeforeAdvice：见名知意，通过方法名就可以猜到是它的作用。方法前拦截器在执行指定方法前调用，参数分别为被调用的方法、执行时被传入的参数、被拦截的bean。&lt;br/&gt;AfterReturningAdvice：返回后拦截器在执行完指定方法并返回之后调用。如果有返回值可以获取到返回值，否则为null。参数分别为方法返回值、被调用的方法、执行时被传入的参数、被拦截的bean。&lt;br/&gt;ThrowsAdvice：异常拦截器在指定方法抛出异常时被调用。该接口并未定义方法，因此不需要实现任何方法。那它是怎么拦截的呢？我们可以查看该接口的定义，在定义类文档中有如下图的说明。如果在实现该接口的类中定义了如public void afterThrowing(Exception ex)、public void afterThrowing(Method method, Object[] args, Object target, Exception ex)方法抛出异常时就会被调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909231146420-422839724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在软件开发中推荐面向接口的编程，所以这里创建了一个IAOPServices接口，并定义了两个方法。withAopMethod方法将使用拦截器拦截的方法，withNoAopMethod方法不会被拦截器拦截。接口代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; basicAop;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IAOPServices {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String withAopMethod() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String withNoAopMethod() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;在AOPServicesImpl类中实现了该接口，并在该类中定义了String类型的description属性，以及对应的getter、setter方法。两个接口方法将返回该description属性的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e04c54d4-1c2a-4bce-8640-c9c8ca428da2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e04c54d4-1c2a-4bce-8640-c9c8ca428da2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e04c54d4-1c2a-4bce-8640-c9c8ca428da2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; basicAop;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AOPServicesImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IAOPServices {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String description;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDescription(String description) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String withAopMethod() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot;AOP函数运行方法:withAopMethod&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(description.trim().length()==0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;description属性不能为空&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String withNoAopMethod() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot;无AOP函数运行方法:withNoAopMethod&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面把要使用AOP拦截的方法准备好了，下面就是定义AOP拦截器方法了。这里在AOPInterceptor类中实现了上面的AfterReturningAdvice,MethodBeforeAdvice,ThrowsAdvice三个接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_f9264553-6d3c-44df-8e33-60f7e1ebcf56&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f9264553-6d3c-44df-8e33-60f7e1ebcf56&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f9264553-6d3c-44df-8e33-60f7e1ebcf56&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; basicAop;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.aop.AfterReturningAdvice;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.aop.MethodBeforeAdvice;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.aop.ThrowsAdvice;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AOPInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AfterReturningAdvice,MethodBeforeAdvice,ThrowsAdvice {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterReturning(Object value, Method method, Object[] args, Object instance) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        
        System.out.println(&lt;/span&gt;&quot;方法&quot;+method.getName()+&quot;运行结束,返回值为:&quot;+&lt;span&gt;value);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; before(Method method, Object[] args, Object instance) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        System.out.println(&lt;/span&gt;&quot;执行MethodBeforeAdvice，即将执行的方法:&quot;+&lt;span&gt;method.getName());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(instance &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AOPServicesImpl)
        {
            String description&lt;/span&gt;=&lt;span&gt;((AOPServicesImpl)instance).getDescription();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(description==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;description属性不能为null&quot;&lt;span&gt;);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterThrowing(Exception ex){
        System.out.println(&lt;/span&gt;&quot;抛出了异常:&quot;+&lt;span&gt;ex.getMessage());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterThrowing(Method method, Object[] args, Object target, Exception ex){
        System.out.println(&lt;/span&gt;&quot;方法&quot;+method.getName()+&quot;抛出了异常:&quot;+&lt;span&gt;ex.getMessage());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这里要拦截的方法和拦截器都准备好了，那怎么将该拦截器用于拦截该方法呢？这里就需要进行配置。首先在pom.xml中引入依赖，这里引入spring-aop、spring-context。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b61b36f0-7806-4914-9894-610cf9817abd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b61b36f0-7806-4914-9894-610cf9817abd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b61b36f0-7806-4914-9894-610cf9817abd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.demo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;BasicAOP&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spring.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.0.0.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spring.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-context&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-aop&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;实际上Spring无法将Services实现类与拦截器直接组装，因为没有对应的setter、getter方法。安装时借助 Spring中的代理类，将自定义拦截器注入到NameMatchMethodPointcutAdvisor类中的advice属性中，再将定义好的NameMatchMethodPointcutAdvisor对象注入到ProxyFactoryBean。这里将自定义的AOPInterceptor拦截器注入到NameMatchMethodPointcutAdvisor中，然后将NameMatchMethodPointcutAdvisor对象注入到ProxyFactoryBean中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_60fb42f5-16f6-44eb-9a57-ad6a3265fd51&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_60fb42f5-16f6-44eb-9a57-ad6a3265fd51&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_60fb42f5-16f6-44eb-9a57-ad6a3265fd51&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd
           http://www.springframework.org/schema/aop
           http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;aopInterceptor&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;advice&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;basicAop.AOPInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mappedName&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;withAopMethod&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;aopService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptorNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aopInterceptor&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;target&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;basicAop.AOPServicesImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;description&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;basicAop&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;从Spring容器中获取IAOPServices对象，并分别执行IAOPServices中的两个方法。Spring会在withAopMethod()方法前后添加拦截器，在withNoAopMethod()方法前后并不会添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_117927ed-1226-410d-9f2a-1067004dd2b6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_117927ed-1226-410d-9f2a-1067004dd2b6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_117927ed-1226-410d-9f2a-1067004dd2b6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; basicAop;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;



&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;applicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        IAOPServices services&lt;/span&gt;=(IAOPServices)context.getBean(&quot;aopService&quot;&lt;span&gt;);
        services.withAopMethod();
        services.withNoAopMethod();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909231758245-1094614868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、AspectJ基于XML的配置&lt;br/&gt;AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。我们还是利用IAOPServices接口、AOPServicesImpl类实现AspectJ基于XML的AOP编程。下表是AspectJ主要的配置元素。使用AspectJ时需要引入两个依赖项aopalliance、aspectjweaver。在引入这两个依赖项时需要注意，有时报错误，更新下两个依赖项的版本就好了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e2ff9b31-98eb-489f-ac14-599f6023f9e0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e2ff9b31-98eb-489f-ac14-599f6023f9e0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e2ff9b31-98eb-489f-ac14-599f6023f9e0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;com.demo&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;AutoScanAOP&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;spring.version&amp;gt;5.0.0.RELEASE&amp;lt;/spring.version&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
      &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;aopalliance&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;aopalliance&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mvnrepository.com/artifact/org.aspectj/aspectjweaver --&amp;gt;&lt;/span&gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.8.11&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;176&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;AOP&lt;span&gt;配置元素&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;390&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:config&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;顶层的&lt;span&gt;AOP&lt;/span&gt;&lt;span&gt;配置元素，大多数的&lt;/span&gt;&lt;span&gt;&amp;lt;aop:*&amp;gt;&lt;/span&gt;&lt;span&gt;元素必须包含在&lt;/span&gt;&lt;span&gt;&amp;lt;aop:config&amp;gt;&lt;/span&gt;&lt;span&gt;元素内&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:aspect&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot;&gt;
&lt;p&gt;定义切面&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:aspect-autoproxy&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;启用&lt;span&gt;@AspectJ&lt;/span&gt;&lt;span&gt;注解驱动的切面&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:pointcut&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot;&gt;
&lt;p&gt;定义切点&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:advisor&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot;&gt;
&lt;p&gt;定义&lt;span&gt;AOP&lt;/span&gt;&lt;span&gt;通知器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:before&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot;&gt;
&lt;p&gt;定义&lt;span&gt;AOP&lt;/span&gt;&lt;span&gt;前置通知&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:after&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;定义&lt;span&gt;AOP&lt;/span&gt;&lt;span&gt;后置通知（不管被通知的方法是否执行成功）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:after-returning&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;定义成功返回后的通知&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:after-throwing&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;定义抛出异常后的通知&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:around&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot;&gt;
&lt;p&gt;定义&lt;span&gt;AOP&lt;/span&gt;&lt;span&gt;环绕通知&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:declare-parents&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;为被通知的对象引入额外的接口，并透明地实现&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里定义了XMLAdvice拦截器方法，用于演示前置、后置、成功返回、异常返回、环绕通知。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_2256f8cf-3788-411b-98ee-032d038faad0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2256f8cf-3788-411b-98ee-032d038faad0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2256f8cf-3788-411b-98ee-032d038faad0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Services;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.JoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; XMLAdvice {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeAdvice() {
        System.out.println(&lt;/span&gt;&quot;前置通知执行了&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterAdvice() {
        System.out.println(&lt;/span&gt;&quot;后置通知执行了&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturnAdvice(String result) {
        System.out.println(&lt;/span&gt;&quot;返回通知执行了&quot; + &quot;运行业务方法返回的结果为&quot; +&lt;span&gt; result);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        String result &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;环绕通知开始执行了&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
            result &lt;/span&gt;=&lt;span&gt; (String) proceedingJoinPoint.proceed();
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();
            System.out.println(&lt;/span&gt;&quot;环绕通知执行结束了&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;执行业务方法共计：&quot; + (end - start) + &quot;毫秒。&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {

        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; throwingAdvice(JoinPoint joinPoint, Exception e) {
        StringBuffer stringBuffer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
        stringBuffer.append(&lt;/span&gt;&quot;异常通知执行了.&quot;&lt;span&gt;);
        stringBuffer.append(&lt;/span&gt;&quot;方法:&quot;).append(joinPoint.getSignature().getName()).append(&quot;出现了异常.&quot;&lt;span&gt;);
        stringBuffer.append(&lt;/span&gt;&quot;异常信息为:&quot;&lt;span&gt;).append(e.getMessage());
        System.out.println(stringBuffer.toString());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面把拦截器定义完成，之后就是把定义好的拦截器与Services关联在一起。使用AOP配置元素将Services与拦截器中的方法关联上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_8a2e357f-f157-45c3-bf47-ca34bcf929b8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8a2e357f-f157-45c3-bf47-ca34bcf929b8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8a2e357f-f157-45c3-bf47-ca34bcf929b8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;span&gt;
xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/mvc
http://www.springframework.org/schema/mvc/spring-mvc.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd
&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;serviceImplA&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;Services.AOPServicesImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;description&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;basicAop&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;serviceAspectBean&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;Services.XMLAdvice&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:aspect &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;serviceAspect&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;serviceAspectBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:pointcut &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; expression&lt;/span&gt;&lt;span&gt;=&quot;execution(* Services.*.withAop*(..))&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:before &lt;/span&gt;&lt;span&gt;pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;beforeAdvice&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;    
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:after &lt;/span&gt;&lt;span&gt;pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;afterAdvice&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;   
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:after-returning &lt;/span&gt;&lt;span&gt;pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;afterReturnAdvice&quot;&lt;/span&gt;&lt;span&gt; returning&lt;/span&gt;&lt;span&gt;=&quot;result&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;     
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:around &lt;/span&gt;&lt;span&gt;pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;aroundAdvice&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;     
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:after-throwing &lt;/span&gt;&lt;span&gt;pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;throwingAdvice&quot;&lt;/span&gt;&lt;span&gt; throwing&lt;/span&gt;&lt;span&gt;=&quot;e&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:aspect&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;配置完之后还是和经典的基于代理的AOP一样，运行代码从Spring容器中获取IAOPServices对象，并分别执行IAOPServices中的两个方法。Spring会在withAopMethod()方法前后添加拦截器，在withNoAopMethod()方法前后并不会添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_5bce50f3-2ce5-401c-86f4-d5d70e1703bd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5bce50f3-2ce5-401c-86f4-d5d70e1703bd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5bce50f3-2ce5-401c-86f4-d5d70e1703bd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; AspectJAOP;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; Services.IAOPServices;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;applicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        IAOPServices services&lt;/span&gt;=(IAOPServices)context.getBean(&quot;serviceImplA&quot;&lt;span&gt;);
        services.withAopMethod();
        services.withNoAopMethod();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909233205903-1679002581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、AspectJ基于注解的配置&lt;br/&gt;AspectJ基于XML的配置还是需要在XML中配置AOP元素，现在一般提倡使用注解来进行编程，AspectJ也提供了基于注解的实现方式。基于注解的AOP配置其实和基于XML的一样，可以参照基于XML的来进行理解。这里定义了AnnontationAdvice，并用@Aspect注解定义切面。在XML中的配置元素改成了注解关键字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_fcb1ec9c-5987-4b4b-a384-1a9586c7ef04&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fcb1ec9c-5987-4b4b-a384-1a9586c7ef04&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fcb1ec9c-5987-4b4b-a384-1a9586c7ef04&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Services;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.JoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.After;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.AfterReturning;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.AfterThrowing;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Around;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Aspect;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
@Aspect
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnnontationAdvice {
    
    @Before(&lt;/span&gt;&quot;execution(* Services.*.withAop*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeAdvice() {
        System.out.println(&lt;/span&gt;&quot;前置通知执行了&quot;&lt;span&gt;);
    }

    @After(&lt;/span&gt;&quot;execution(* Services.*.withAop*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterAdvice() {
        System.out.println(&lt;/span&gt;&quot;后置通知执行了&quot;&lt;span&gt;);
    }

    @AfterReturning(value&lt;/span&gt;=&quot;execution(* Services.*.withAop*(..))&quot;,returning=&quot;result&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturnAdvice(String result) {
        System.out.println(&lt;/span&gt;&quot;返回通知执行了&quot; + &quot;运行业务方法返回的结果为&quot; +&lt;span&gt; result);
    }
    
    @Around(value&lt;/span&gt;=&quot;execution(* Services.*.withAop*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        String result &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;环绕通知开始执行了&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
            result &lt;/span&gt;=&lt;span&gt; (String) proceedingJoinPoint.proceed();
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();
            System.out.println(&lt;/span&gt;&quot;环绕通知执行结束了&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;执行业务方法共计：&quot; + (end - start) + &quot;毫秒。&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {

        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    @AfterThrowing(value&lt;/span&gt;=&quot;execution(* Services.*.withAop*(..))&quot;,throwing=&quot;e&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; throwingAdvice(JoinPoint joinPoint, Exception e) {
        StringBuffer stringBuffer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
        stringBuffer.append(&lt;/span&gt;&quot;异常通知执行了.&quot;&lt;span&gt;);
        stringBuffer.append(&lt;/span&gt;&quot;方法:&quot;).append(joinPoint.getSignature().getName()).append(&quot;出现了异常.&quot;&lt;span&gt;);
        stringBuffer.append(&lt;/span&gt;&quot;异常信息为:&quot;&lt;span&gt;).append(e.getMessage());
        System.out.println(stringBuffer.toString());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在配置文件中只需配置下自动扫描的包名，并配置下&amp;lt;aop:aspectj-autoproxy&amp;gt;即可，比XML的配置简单一些。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3dc09446-d728-4074-b4e8-8d6c2a68a672&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3dc09446-d728-4074-b4e8-8d6c2a68a672&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3dc09446-d728-4074-b4e8-8d6c2a68a672&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;span&gt;
xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/mvc
http://www.springframework.org/schema/mvc/spring-mvc.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd
&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置自动扫描的包 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;Services&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context:component-scan&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 自动为切面方法中匹配的方法所在的类生成代理对象。 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:aspectj-autoproxy&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:aspectj-autoproxy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;serviceImplA&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;Services.AOPServicesImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;description&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;basicAop&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;最后还是从Spring容器中获取IAOPServices对象，并分别执行IAOPServices中的两个方法。运行结果如下图，从打印的日志可以看到拦截器拦截了withAopMethod()方法，withNoAopMethod()并未拦截。&lt;/p&gt;
&lt;p&gt;运行结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909234326432-768894538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 09 Sep 2018 15:45:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>一、AOP的引入这里可以把单个模块当做是一圆柱，假如没有aop，在做日志处理的时候，我们会在每个模块中添加日志或者权限处理，日志或权限类似圆柱体的部分圆柱。 一般大多数的日志或权限处理代码是相同的，为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/9615948.html</dc:identifier>
</item>
<item>
<title>mysql执行sql语句过程 - 精品唯居</title>
<link>http://www.cnblogs.com/liyasong/p/mysql_zhixingguocheng.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liyasong/p/mysql_zhixingguocheng.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　开发人员基本都知道，我们的数据存在数据库中（目前最多的是mysql和oracle，由于作者更擅长mysql，所以这里默认数据库为mysql），服务器通过sql语句将查询数据的请求传入到mysql数据库。数据库拿到sql语句以后。都是进行了哪些操作呢？这里向大家介绍下我的个人的理解，欢迎大家评论区批评指正。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;流程概述&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　mysql得到sql语句后，大概流程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.sql的解析器：负责解析和转发sql&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.预处理器：对解析后的sql树进行验证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.查询优化器：得到一个执行计划&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.查询执行引擎：得到数据结果集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.将数据放回给调用端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流程图如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1104082/201809/1104082-20180909231508219-1821647882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;分发器及缓存阶段&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　首先，如果系统的缓存功能开启着的话，sql语句进入mysql后，sql进行判断，是否为select关键字。如果是，那么先去查询缓存中进行查询，如果在查询缓存中可以命中sql语句，那么直接返回查询缓存中的查询语句对应的value值（在缓存中，把查询语句做一个hash运算，结果作为key值，查询的结果集为value）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果命中缓存的话，查询速度是相当快的。但是查询缓存也有它相应的缺点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，开启缓存的话，服务器会消耗大量的内存空间；其次，缓存有的时候并不适用；最后，有的情况下，开启缓存也不会将对应的sql语句写入缓存。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;缓存不适用的情况：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　缓存的锁的力度比较大，而且对于动态sql的支持度不够。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　缓存在数据进行更新的时候，是进行的表级锁，更新结束后，会把所有与更新内容相关的缓存全部删除。所以，如果表的写入比较多的话，缓存是比较浪费性能的。如果写入特别多，可能缓存反而会导致mysql变慢。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;查询不到缓存的情况：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　1.查询条件有不确定数据：如now ，current_time等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.缓存对大小写敏感，如select * from test 和SELECT* FROM test 就不会解析为同一条sql&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;查询带来的额外开销：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　1.开始前需要先检查缓存是否命中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.结果输出的时候，需要额外进行数据的缓存操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.写入数据时，mysql会将对应表的所有缓存都设置为失效。当缓存内存较大的时候，会导致系统消耗较大。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;sql的解析器与预处理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　sql解析器是在命令分发之后，将对应的sql语句，解析为sql解析树。sql解析树是Mysql本身内部的语法规则和解析查询。验证是否使用错误的关键字，sql语法顺序是否正确等。（语法层面的错误）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　解析完成后，进行查询语句预处理器，根据mysql的规则，检查解析树是否合法。（表格是否存在，别名是否有歧义等）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;查询优化器&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　查询优化器获取到执行计划然后由查询执行引擎执行相应的操作。查询优化器，是数据库l的一个核心模块，分为cbo和rbo两种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中，rbo是基于规则的优化器。（rbo在oracle早期版本中使用，现在也保留，不过默认为cbo。mysql没有rbo优化器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这些规则是硬编码在数据库的代码中的。rbo会根据输入的sql语句可以匹配到的优先级最高的规则去作为执行计划。例如：在rbo中有这么一条规则：有索引的情况下，使用索引。那么所有的带有索引的表在执行的时候，都会走索引。rbo最大的问题在于，通过固定规则来决定执行计划。并不会考虑sql中涉及的对象的数量和分布。有可能选出来的规则不是最优的执行计划。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　cbo 是基于成本的优化器（基于统计信息），从目标诸多的执行路径中选择一个成本最小的执行路径来作为执行计划。成本指的是mysql根据相关的统计信息，算出来sql语句对应的io，cpu等的消耗的一个估计值。计算过程涉及到索引、表、行等数据，过程比较复杂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.查询优化器使用统计信息为sql选择执行计划。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.mysql没有数据直方图，也无法手工删除统计信息。（oracle有）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.在服务器曾有查询优化器，却没有保存数据和索引统计信息。统计信息由存储引擎实现，不同的存储引擎会存储不同的统计信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.统计信息分为索引的统计信息和表的统计信息。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;查看统计信息&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　索引统计信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　show index from table 或information_schema.statistics表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　表统计信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　show table status like 或 information_schema.tables表&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;查询执行引擎+返回数据给客户端&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　得到执行计划后，根据已有的执行计划，查询执行引擎，mysql的SQL Layer层，调用Storage Engine Layer层的接口，从mysql的存储引擎中获取到相对应的结果集，然后返回给用户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　执行完成后，将结果返回给客户端，如果是查询语句，并且开启了缓存，那么，mysql会同时将结果集放到查询缓存中。然后将查到的结果集返回。如果是增删改操作，那么返回执行语句后受影响的行数。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>精品唯居</dc:creator>
<og:description>开发人员基本都知道，我们的数据存在数据库中（目前最多的是mysql和oracle，由于作者更擅长mysql，所以这里默认数据库为mysql），服务器通过sql语句将查询数据的请求传入到mysql数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liyasong/p/mysql_zhixingguocheng.html</dc:identifier>
</item>
<item>
<title>Scala的映射和元组操作 - codegeekgao</title>
<link>http://www.cnblogs.com/codegeekgao/p/9615925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codegeekgao/p/9615925.html</guid>
<description>&lt;h2 id=&quot;映射和元组操作&quot;&gt;映射和元组操作&lt;/h2&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;    // 构造一个不可变的MAP映射，类似与key -&amp;gt; value这样的组合叫做对偶
    val score = Map(&quot;Jack&quot; -&amp;gt; 12, &quot;Bob&quot; -&amp;gt; 20)
    // 也可以这种创建一个Map映射
    val score1 = Map((&quot;Jack&quot;, 12), (&quot;Bob&quot;, 20))
    // 根据key获取value，类似java中的map.get(key)若是获取一个不存在的key则会报错而不是null
    println(score(&quot;Jack&quot;))
    // 获取元素不存在给出无元素提醒
    val flag = if (score.contains(&quot;haha&quot;)) score.get(&quot;haha&quot;) else &quot;no such element&quot;
    val flag1 = score.getOrElse(&quot;haha&quot;, &quot;no such element&quot;)
    // 创建可变Map
    val score = scala.collection.mutable.Map(&quot;Jack&quot; -&amp;gt; 12, &quot;Bob&quot; -&amp;gt; 20)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更新映射中的值&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;在可变的映射中，可以更新某个映射的值，在=号左侧使用():
// 更新可变的Map的值
scores(&quot;Bob&quot;) = 10
// 添加新的key-value
scores(&quot;haha&quot;)=7
// 也可以使用+=操作和创建映射关系
scores +=(&quot;Michael&quot; -&amp;gt; 22)
// 移除某个键对应的值
score -=(&quot;Michael&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;迭代映射&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;for((k,v) &amp;lt;- 映射) 这种可以得到每一个的键值对
// 和java一样可以使用keySet和values方法，values方法将会返回一个iterable
score.keySet // 返回类似(&quot;Bob&quot;,&quot;Michael&quot;)
// 获取map的value
for (v &amp;lt;- score.values) println(v)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;排序映射&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;操作映射时，需要选定一个实现---哈希表或者平衡树，默认情况Scala中式hash表，若想顺序访问所有的键，因此需要一个树形映射&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;val scores = scala.collection.immutable.SortedMap(&quot;Bob&quot; -&amp;gt; 10,&quot;michael&quot; -&amp;gt; 12)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;与java的互操作&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// import scala.collection.javaConversions.mapAsScalaMap 然后指定Scala映射类型触发转换
val scores:scala.collection.mutable.Map[String,Int] = new java.util.TreeMap[String,Int]
// import scala.collection.javaConversions.propertiesAsScalaMap
val props :scala.collection.Map[String,String] = System.getProperties()
// 以上都是将java的map转为Scala的map，可以将Scala的map转为java的mao
import scala.collection.javaConversions.mapAsJavaMap&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;映射式键值对的集合，对偶式元组(tuple)的最简单的形态---而元组式不同类型值得聚集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;(1,95.27,&quot;Bob&quot;) 是一个元组类型为(Int,Double,java.lang.String)可以方法_1,_2,_3访问元组例如以下元组：
    val l = (1,2.34,&quot;哈哈&quot;)
    println(l._2)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;拉链操作&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// 使用元组可以将他们映射起来使用zip方法
    val symbols = Array(&quot;&amp;lt;&quot;,&quot;-&quot;,&quot;&amp;gt;&quot;)
    val counts = Array(2,10,2)
    val pairs = symbols.zip(counts)
    println(pairs.toBuffer)
    // 打印&amp;lt;&amp;lt;----------&amp;gt;&amp;gt;
    for ((s,n) &amp;lt;- pairs) Console.print(s * n)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 09 Sep 2018 15:42:00 +0000</pubDate>
<dc:creator>codegeekgao</dc:creator>
<og:description>映射和元组操作 构造Map 更新映射中的值 迭代映射 scala val scores = scala.collection.immutable.SortedMap(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codegeekgao/p/9615925.html</dc:identifier>
</item>
<item>
<title>SQL 经典题型解答(2) - 我不</title>
<link>http://www.cnblogs.com/wobu/p/9615917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wobu/p/9615917.html</guid>
<description>&lt;p&gt;2、查询&quot;01&quot;课程比&quot;02&quot;课程成绩低的学生的信息及课程分数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT a.*,b.C,b.score
from student a 
INNER JOIN (SELECT a.* FROM 
(SELECT * from sc  WHERE sc.C IN    ('01')) a 
INNER JOIN (SELECT * FROM sc  WHERE sc.C IN ('02')) b
ON a.s = b.s
WHERE a.score &amp;lt; b.score 
)b
on a.s= b.s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;只要修改&lt;code&gt;a.score &amp;gt; b.score&lt;/code&gt;为&lt;code&gt;a.score &amp;lt; b.score&lt;/code&gt;即可，需要注意的是第一个&lt;code&gt;INNER JOIN&lt;/code&gt;中必须有&lt;code&gt;SELECT a.* FROM&lt;/code&gt;，用以形成一个表格。&lt;br/&gt;&lt;code&gt;INNER JOIN&lt;/code&gt;函数的语法：&lt;br/&gt;&amp;gt;&lt;code&gt;SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name=table2.column_name;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序运行结果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230701/201809/1230701-20180909233332610-597899904.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT
    a.s,
    a.Sname,
    b.avgscore 
FROM
    student AS a
    INNER JOIN ( SELECT sc.s, avg( sc.score ) AS avgscore FROM sc GROUP BY sc.s ) AS b ON a.s = b.s 
WHERE
    b.avgscore &amp;gt; 60&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;首先通过表 sc 算出每个同学的平均成绩，然后再与表 student 连接，得出结果&lt;br/&gt;求平均成绩的函数 &lt;code&gt;AVG()&lt;/code&gt; 用来返回某一个数值列的平均值。&lt;br/&gt;&lt;code&gt;GROUP BY&lt;/code&gt; 语句用于结合结合函数，根据一个或多个列队结果进行分组计算&lt;br/&gt;&lt;code&gt;GROUP BY&lt;/code&gt; 语句在程序中表示根据 sc 表的 s 列求平均值，即求每个同学的平均成绩.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序运行结果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230701/201809/1230701-20180909233352483-1666897470.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT
    a.s,
    a.Sname,
    b.avgscore 
FROM
    student AS a
    INNER JOIN ( SELECT sc.s, avg( sc.score ) AS avgscore FROM sc GROUP BY sc.s ) AS b ON a.s = b.s 
WHERE
    b.avgscore &amp;lt; 60&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;修改最后的 &lt;code&gt;b.avgscore &amp;gt; 60&lt;/code&gt; 为 &lt;code&gt;b.avgscore &amp;lt; 60&lt;/code&gt; 即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序运行结果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230701/201809/1230701-20180909233407086-1353774338.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT a.s,a.sname,b.sumscore,b.countcourse
from student a 
INNER JOIN (SELECT s,sum(score) as sumscore, count(score) as countcourse from sc GROUP BY s) b
on a.s = b.s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;首先先从表 sc 中求出每个同学的总成绩和选课总数，然后再和 student 表连接得出结果&lt;br/&gt;&lt;code&gt;sum()&lt;/code&gt; 函数返回某一列数值的总和。&lt;br/&gt;&lt;code&gt;count()&lt;/code&gt; 函数返回某一列的行数。&lt;br/&gt;通过这两个函数结合 &lt;code&gt;GROUP BY&lt;/code&gt; 语句，即可求出选课总数和课程总成绩。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序运行结果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230701/201809/1230701-20180909233422655-2104649453.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;6、 查询 &quot;李&quot; 姓老师的数量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT COUNT(tname) FROM teacher
WHERE Tname LIKE '李%'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详解:&lt;/p&gt;
&lt;blockquote readability=&quot;4.35&quot;&gt;
&lt;p&gt;通过 &lt;code&gt;count()&lt;/code&gt; 函数对表 teacher 中的 tname 列操作，通过 &lt;code&gt;WHERE&lt;/code&gt; 语句限制条件，&lt;br/&gt;&lt;code&gt;LIKE&lt;/code&gt; 语句用法 &lt;a href=&quot;http://www.runoob.com/sql/sql-like.html&quot;&gt;菜鸟教程 --- LIKE 操作符&lt;/a&gt;，&lt;a href=&quot;http://www.runoob.com/sql/sql-wildcards.html&quot;&gt;SQL 通配符&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序运行结果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230701/201809/1230701-20180909233441944-2039109461.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;7、查询学过 &quot;张三&quot; 老师授课的同学的信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT
    a.* 
FROM
    student a
    INNER JOIN (
    SELECT
        a.s 
    FROM
        sc a
        INNER JOIN (
        SELECT
            b.C 
        FROM
            teacher a
            INNER JOIN course b ON a.T = b.T 
            AND a.Tname IN ( '张三' ) 
        ) b ON a.c = b.C 
    ) b ON a.s = b.s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详解:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;首先连接表 teacher 和表 course 得到 “张三”老师的授课编号 C ,代码:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;SELECT a.*,b.Cname,b.C FROM teacher a
INNER JOIN course b
ON a.T = b.T AND a.Tname IN ('张三')&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;然后连接表 sc 得到学习课程 C 的学生编号，最后连接表 student 得到学生信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序运行结果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230701/201809/1230701-20180909233502911-1548570104.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;8、查询没学过 &quot;张三&quot; 老师授课的同学的信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT
    a.* 
FROM
    student a 
WHERE
    a.S NOT IN (
    SELECT
        a.s 
    FROM
        sc a
        INNER JOIN (
        SELECT
            b.C 
        FROM
            teacher a
            INNER JOIN course b ON a.T = b.T 
            AND a.Tname IN ( '张三' ) 
        ) b ON a.c = b.C 
    )N a.c = b.C 
    ) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;和上一题一样首先找到学过 “张三” 老师课程的学生编号，然后从表 student 中选出学生编号 &lt;code&gt;NOT IN&lt;/code&gt; 这些编号中的学生信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序运行结果:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230701/201809/1230701-20180909233855707-1935746978.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;9、查询学过编号为 &quot;01&quot; 并且也学过编号为 &quot;02&quot; 的课程的同学的信息&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解法一&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;SELECT a.* FROM student a
INNER JOIN 
(SELECT s FROM sc WHERE c = '01') b 
ON a.s = b.s
INNER JOIN 
(SELECT s FROM sc WHERE c = '02') c
ON a.s = c.s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;表 b 表示从表 sc 中选出学习课程 “01”的学生编号，表 c 表示从表 sc 中选出学习课程 “02” 的学生编号，通过 &lt;code&gt;INNER JOIN&lt;/code&gt; 函数将表 student 与 b ,c 连接，即可得到最终结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序运行结果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230701/201809/1230701-20180909233953851-1340412710.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;解法二：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;SELECT
    c.* 
FROM
    sc AS a,
    sc AS b,
    student AS c 
WHERE
    a.S = b.S 
    AND a.C = '01' 
    AND b.C = '02' 
    AND c.S = a.S&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详解：&lt;br/&gt;&amp;gt; 直接通过 &lt;code&gt;WHERE&lt;/code&gt; 语句进行条件判断。&lt;/p&gt;
&lt;p&gt;程序运行结果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230701/201809/1230701-20180909233956421-880637872.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;10、查询学过编号为&quot;01&quot;但是没有学过编号为&quot;02&quot;的课程的同学的信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT
    a.* 
FROM
    student a
    INNER JOIN ( SELECT s FROM sc WHERE C = '01' AND s NOT IN ( SELECT s FROM sc WHERE c = '02' ) ) b ON a.s = b.s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;首先查找学过编号为 “02” 课程的学生编号 ,然后查找学过编号为 “01” 课程的学生编号，通过 &lt;code&gt;NOT IN&lt;/code&gt; 语句找到不在学过 “02” 课程的学生编号，最后与表 student 连接找到学生信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序运行结果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230701/201809/1230701-20180909234031356-1870552385.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;部分答案参考自：&lt;a href=&quot;https://yq.aliyun.com/articles/230074&quot;&gt;SQL 经典五十道题&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 15:41:00 +0000</pubDate>
<dc:creator>我不</dc:creator>
<og:description>2、查询</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wobu/p/9615917.html</dc:identifier>
</item>
<item>
<title>mybatis自定义类型处理器-TypehHandler - xwlmdd</title>
<link>http://www.cnblogs.com/xwlhyy1072552712/p/9615877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xwlhyy1072552712/p/9615877.html</guid>
<description>&lt;p&gt;   当大家使用mybatis作为持久层框架时，在存储和查询数据时，只需要在mapper.xml文件中配置好对应字段的JdbcType和JavaType，mybatis就可以帮我们转化对应的类型。这背后是有mybatis内置的类型转换器做转换（可见源码TypeHandlerRegistry）。但是有时候，我们会对某些字段做特殊处理，比如&lt;strong&gt;加密和解密&lt;/strong&gt;、&lt;strong&gt;状态转换&lt;/strong&gt;、&lt;strong&gt;类型转换&lt;/strong&gt;等。这个时候我们需要自定义类型转换器。&lt;/p&gt;
&lt;h5 id=&quot;一原理&quot;&gt;一、原理&lt;/h5&gt;
&lt;p&gt;   使用场景：mybatis在预处理语句（PreparedStatement）中设置一个参数时，或者从结果集（ResultSet）中取出一个值时，都会用到TypeHandler。它的作用就是将java类型（javaType）转化为jdbc类型（jdbcType），或者将jdbc类型（jdbcType）转化为java类型（javaType）。&lt;/p&gt;
&lt;h5 id=&quot;二自定义类型处理器&quot;&gt;二、自定义类型处理器&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;实现TypeHandler接口或者继承BaseTypehandler&lt;br/&gt;TypeHandler是一个接口，它定义了如下四个方法，实现类必须去实现，方法如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    void setParameter(PreparedStatement var1, int var2, T var3,JdbcType var4) throws SQLException;

    T getResult(ResultSet var1, String var2) throws SQLException;

    T getResult(ResultSet var1, int var2) throws SQLException;

    T getResult(CallableStatement var1, int var2) throws SQLException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;setParameter：通过preparedStatement对象设置参数，将T类型的数据存入数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;getResult：通过列名或者下标来获取结果数据，也可以通过CallableStatement获取数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;三案例自定义敏感字段加解密处理器&quot;&gt;三、案例（自定义敏感字段加解密处理器）&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;MyTypeHandler实现TypeHandler接口&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package com.mdd.mybatis.typehandle;

import com.mdd.mybatis.util.DESUtil;
import org.apache.commons.lang3.StringUtils;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;

import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class MyTypeHandle implements TypeHandler&amp;lt;String&amp;gt; {
    private static String KEY = &quot;123456&quot;;

    @Override
    public void setParameter(PreparedStatement preparedStatement, int i, String s, JdbcType jdbcType) throws SQLException {
        try {
            String encrypt = DESUtil.encrypt(s, KEY);
            preparedStatement.setString(i, encrypt);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public String getResult(ResultSet resultSet, String s) throws SQLException {
        String result = resultSet.getString(s);
        if (StringUtils.isNotEmpty(result)) {
            try {
                return DESUtil.decrypt(result, KEY);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    @Override
    public String getResult(ResultSet resultSet, int i) throws SQLException {
        String result = resultSet.getString(i);
        if (StringUtils.isNotEmpty(result)) {
            try {
                return DESUtil.decrypt(result, KEY);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    @Override
    public String getResult(CallableStatement callableStatement, int i) throws SQLException {
        String result = callableStatement.getString(i);
        if (StringUtils.isNotEmpty(result)) {
            try {
                return DESUtil.decrypt(result, KEY);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return result;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置注册自定义处理器（mybatis.cfg.xml）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    &amp;lt;!--自定义类型处理器--&amp;gt;
    &amp;lt;typeHandlers&amp;gt;
        &amp;lt;typeHandler handler=&quot;com.mdd.mybatis.typehandle.MyTypeHandle&quot;&amp;gt;&amp;lt;/typeHandler&amp;gt;
    &amp;lt;/typeHandlers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用自定义处理器（mapper文件）&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;
&amp;lt;mapper namespace=&quot;com.mdd.mybatis.dao.UserDao&quot; &amp;gt;
    &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.mdd.mybatis.dao.vo.User&quot;&amp;gt;
        &amp;lt;id column=&quot;user_id&quot; property=&quot;userId&quot; jdbcType=&quot;VARCHAR&quot;/&amp;gt;
        &amp;lt;result column=&quot;name&quot; property=&quot;name&quot; typeHandler=&quot;com.mdd.mybatis.typehandle.MyTypeHandle&quot;/&amp;gt;
        &amp;lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot;/&amp;gt;
        &amp;lt;result column=&quot;age&quot; property=&quot;age&quot; jdbcType=&quot;INTEGER&quot;/&amp;gt;
    &amp;lt;/resultMap&amp;gt;

    &amp;lt;sql id=&quot;Base_Column_List&quot; &amp;gt;
     user_id,name,password, age
    &amp;lt;/sql&amp;gt;

    &amp;lt;insert id=&quot;saveUser&quot;&amp;gt;
      INSERT INTO t_user(user_id,name, password, age) VALUES (
        #{userId,jdbcType=VARCHAR},#{name,jdbcType=VARCHAR},
        #{password,jdbcType=VARCHAR},#{age,jdbcType=INTEGER}
      )
    &amp;lt;/insert&amp;gt;

    &amp;lt;insert id=&quot;saveUserWithType&quot;&amp;gt;
      INSERT INTO t_user(user_id,name, password, age) VALUES (
        #{userId,jdbcType=VARCHAR},#{name,typeHandler=com.mdd.mybatis.typehandle.MyTypeHandle},
        #{password,jdbcType=VARCHAR},#{age,jdbcType=INTEGER}
      )
    &amp;lt;/insert&amp;gt;

    &amp;lt;select id=&quot;queryUser&quot; resultMap=&quot;BaseResultMap&quot;&amp;gt;
      select * from t_user where user_id = #{userId,jdbcType=VARCHAR}
    &amp;lt;/select&amp;gt;

&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的配置，自定义的TypeHandler就会生效，敏感字段的加解密在dao层就可以解决，对上层业务无感，使用相当方便，也更加灵活。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参考 http://www.mybatis.org/mybatis-3/configuration.html#typeHandler&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 09 Sep 2018 15:35:00 +0000</pubDate>
<dc:creator>xwlmdd</dc:creator>
<og:description>   当大家使用mybatis作为持久层框架时，在存储和查询数据时，只需要在mapper.xml文件中配置好对应字段的JdbcType和JavaType，mybatis就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xwlhyy1072552712/p/9615877.html</dc:identifier>
</item>
<item>
<title>深入浅出的webpack4构建工具---浏览器前端资源缓存(十一) - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/9615822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/9615822.html</guid>
<description>&lt;p&gt;&lt;strong&gt;阅读目录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/tugenhua0707/p/9615822.html#_labe1_0&quot;&gt;一. 理解使用hash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/tugenhua0707/p/9615822.html#_labe1_1&quot;&gt;二：理解使用chunkhash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/tugenhua0707/p/9615822.html#_labe1_2&quot;&gt;三：对第三方库打包后使用缓存&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/tugenhua0707/p/9615822.html#_labe1_3&quot;&gt;四：contenthash&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一. 理解使用hash&lt;/p&gt;
&lt;p&gt;   一般情况下，对于前端静态资源，浏览器访问的时候希望资源都能够进行缓存，当第二次及以后进入页面的时候，页面就可以直接使用缓存资源，这样的话，页面打开速度很快，提高了用户体验同时也节省了带宽资源。而其中最为常见的一种最大化利用缓存的形式就是为静态资源加上hash, 使用一个不会重复的标识符来达到资源可以永久缓存的目的。&lt;/p&gt;
&lt;p&gt;浏览器缓存方法有很多种，那么下面我们分别使用hash, chunkhash和contenthash来理解下。&lt;/p&gt;
&lt;p&gt;在理解hash, chunkhash和contenthash之前，我们首先看看我们项目的基本架构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;### 目录结构如下：
demo1                                       # 工程名
&lt;/span&gt;|   |---&lt;span&gt; dist                               # 打包后生成的目录文件             
&lt;/span&gt;|   |---&lt;span&gt; node_modules                       # 所有的依赖包
&lt;/span&gt;|   |---&lt;span&gt; js                                 # 存放所有js文件
&lt;/span&gt;|   | |--&lt;span&gt; demo1.js  
&lt;/span&gt;|   | |--&lt;span&gt; main.js                           # js入口文件
&lt;/span&gt;|   |---&lt;span&gt; webpack.config.js                  # webpack配置文件
&lt;/span&gt;|   |---&lt;span&gt; webpack.dll.config.js              # 打包第三方依赖的库文件
&lt;/span&gt;|   |---&lt;span&gt; index.html                         # html文件
&lt;/span&gt;|   |---&lt;span&gt; styles                             # 存放所有的css样式文件   
&lt;/span&gt;|   | |--&lt;span&gt; main.styl                         # main.styl文件   
&lt;/span&gt;|   | |--&lt;span&gt; index.styl                        
&lt;/span&gt;|   |---&lt;span&gt; .gitignore  
&lt;/span&gt;|   |---&lt;span&gt; README.md
&lt;/span&gt;|   |---&lt;span&gt; package.json
&lt;/span&gt;|   |--- .babelrc                           # babel转码文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1. 理解使用hash&lt;/strong&gt;&lt;br/&gt;hash的默认长度为20个字符，可以使用[hash:8]这样的方式来配置，代表hash使用8个字符来表示。&lt;/p&gt;
&lt;p&gt;webpack.config.js 配置代码如下(入口文件分别为main和demo1)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入口文件&lt;/span&gt;
&lt;span&gt;  entry: {
    main: &lt;/span&gt;'./js/main.js'&lt;span&gt;,
    demo1: &lt;/span&gt;'./js/demo1.js'&lt;span&gt;
  },
  output: {
    filename: &lt;/span&gt;'[name].[hash].js'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将输出的文件都放在dist目录下&lt;/span&gt;
    path: path.resolve(__dirname, 'dist'&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在dist目录打包成如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909231427818-1264011676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上可以看到，main.js中hash编码和demo1.js中的hash编码是一模一样的。现在我改下main.js代码后，继续打包一下可以看到如下信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909231454548-328023631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，demo1.js代码其实我并没有改动，但是它因为main.js代码改动了导致他的hash编码也改变了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hash理解为：当每次修改任何一个文件后，所有文件打包后的hash值都是一样的，所以假如只是修改了任何一个文件，整个项目的文件缓存都将失效。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;hash为什么会这样呢？要理解这个问题，首先我们需要理解 the module identifier。webpack默认会为各个模块分配一个id作为标识，用来处理模块之间的依赖关系，但是默认的id命名规则则是根据模块引入的顺序，赋予一个整数 (1,2,3..). 由于该hash是基于整个 module identifier序列计算得到的，因此js打包的时候使用该hash，所有的值都一样的，但是任意删除或者修改任何一个文件的时候，都会对整个id序列造成影响，从而改变hash的值。&lt;/p&gt;

&lt;p&gt;二：理解使用chunkhash&lt;/p&gt;
&lt;p&gt;上面的hash有这个缺点，因此chunkhash出现了，它就是解决这个问题而出现的。我们接下来再把配置改成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  entry: {
    main: &lt;/span&gt;'./js/main.js'&lt;span&gt;,
    demo1: &lt;/span&gt;'./js/demo1.js'&lt;span&gt;
  },
  output: {
    filename: &lt;/span&gt;'[name].[chunkhash].js'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将输出的文件都放在dist目录下&lt;/span&gt;
    path: path.resolve(__dirname, 'dist'&lt;span&gt;)
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们继续运行打包完后，变成如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909231644307-1793845076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这时候main.js和demo1.js中的hash编码不一样了，因此接下来我们继续随便修改下main.js代码，继续打包如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909231707153-568825512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上可以看到，我们只是改变了下 main.js代码，demo1.js代码并没有改变，因此main.js代码的hash编码值改变了，demo1.js的hash值编码并没有改变，因此当某个文件改变的时候，只会重新请求该文件，未改变的文件不会重新请求，会缓存里面读取。&lt;/p&gt;

&lt;p&gt;三：对第三方库打包后使用缓存&lt;/p&gt;
&lt;p&gt;通过上面使用chunkhash, 因此对于一些常用的库，第三方文件我们也可以使用chunkhash这么做，这样一来的话，第三方库文件在浏览器中会加载很快，因此对于第三方库文件我打算输出到 项目中另一个文件内，比如叫plugins文件夹内，比如如下webpack.dll.config.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
const path = require('path'&lt;span&gt;);
const DllPlugin &lt;/span&gt;= require('webpack/lib/DllPlugin'&lt;span&gt;);

module.exports &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入口文件&lt;/span&gt;
&lt;span&gt;  entry: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 项目中用到该两个依赖库文件&lt;/span&gt;
    jquery: ['jquery'&lt;span&gt;],
    echarts: [&lt;/span&gt;'echarts'&lt;span&gt;]
  },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出文件&lt;/span&gt;
&lt;span&gt;  output: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件名称&lt;/span&gt;
    filename: '[name].dll.[chunkhash].js'&lt;span&gt;, 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将输出的文件放到dist目录下&lt;/span&gt;
    path: path.resolve(__dirname, './plugins'&lt;span&gt;),

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     存放相关的dll文件的全局变量名称，比如对于jquery来说的话就是 _dll_jquery, 在前面加 _dll
     是为了防止全局变量冲突。
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    library: &lt;/span&gt;'_dll_[name]'&lt;span&gt;
  },
  mode: &lt;/span&gt;'development'&lt;span&gt;,
  plugins: [
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用插件 DllPlugin&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DllPlugin({
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
       该插件的name属性值需要和 output.library保存一致，该字段值，也就是输出的 manifest.json文件中name字段的值。
       比如在jquery.manifest文件中有 name: '_dll_jquery'
      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      name: &lt;/span&gt;'_dll_[name]'&lt;span&gt;,

      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 生成manifest文件输出的位置和文件名称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      path: path.join(__dirname, &lt;/span&gt;'./plugins', '[name].manifest.json'&lt;span&gt;)
    })
  ]
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;webpack.config.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;94&quot;&gt;
&lt;pre&gt;
const path = require('path'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取css的插件&lt;/span&gt;
const ExtractTextPlugin = require('extract-text-webpack-plugin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清除dist目录下的文件&lt;/span&gt;
const ClearWebpackPlugin = require('clean-webpack-plugin'&lt;span&gt;);

const webpack &lt;/span&gt;= require('webpack'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入打包html文件&lt;/span&gt;
const HtmlWebpackPlugin = require('html-webpack-plugin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 DllReferencePlugin&lt;/span&gt;
const DllReferencePlugin = require('webpack/lib/DllReferencePlugin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入HappyPack插件 &lt;/span&gt;
const HappyPack = require('happypack'&lt;span&gt;);

module.exports &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入口文件&lt;/span&gt;
&lt;span&gt;  entry: {
    main: &lt;/span&gt;'./js/main.js'&lt;span&gt;,
    demo1: &lt;/span&gt;'./js/demo1.js'&lt;span&gt;
  },
  output: {
    filename: &lt;/span&gt;'[name].[chunkhash].js'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将输出的文件都放在dist目录下&lt;/span&gt;
    path: path.resolve(__dirname, 'dist'&lt;span&gt;)
  },
  module: {
    rules: [
      {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则去匹配&lt;/span&gt;
        test: /\.styl$/&lt;span&gt;,
        use: ExtractTextPlugin.extract({
          fallback: {
            loader: &lt;/span&gt;'style-loader'&lt;span&gt;
          },
          use: [
            {
              loader: &lt;/span&gt;'css-loader'&lt;span&gt;,
              options: {}
            },
            {
              loader: &lt;/span&gt;'postcss-loader'&lt;span&gt;,
              options: {
                ident: &lt;/span&gt;'postcss'&lt;span&gt;,
                plugins: [
                  require(&lt;/span&gt;'postcss-cssnext'&lt;span&gt;)(),
                  require(&lt;/span&gt;'cssnano'&lt;span&gt;)(),
                  require(&lt;/span&gt;'postcss-pxtorem'&lt;span&gt;)({
                    rootValue: &lt;/span&gt;16&lt;span&gt;,
                    unitPrecision: &lt;/span&gt;5&lt;span&gt;,
                    propWhiteList: []
                  }),
                  require(&lt;/span&gt;'postcss-sprites'&lt;span&gt;)()
                ]
              }
            },
            {
              loader: &lt;/span&gt;'stylus-loader'&lt;span&gt;,
              options: {}
            }
          ]
        })
      },
      {
        test: &lt;/span&gt;/\.css$/&lt;span&gt;,
        use: ExtractTextPlugin.extract({
          use: [&lt;/span&gt;'happypack/loader?id=css-pack'&lt;span&gt;]
        })
      },
      {
        test: &lt;/span&gt;/\.(png|jpg)$/&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: '[name].[ext]'
        }
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        use: [&lt;/span&gt;'happypack/loader?id=image'&lt;span&gt;]
      },
      {
        test: &lt;/span&gt;/\.js$/&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将对.js文件的处理转交给id为babel的HappyPack的实列&lt;/span&gt;
        use: ['happypack/loader?id=babel'&lt;span&gt;],
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; loader: 'babel-loader',&lt;/span&gt;
        exclude: path.resolve(__dirname, 'node_modules') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 排除文件&lt;/span&gt;
&lt;span&gt;      }
    ]
  },
  resolve: {
    extensions: [&lt;/span&gt;'*', '.js', '.json'&lt;span&gt;]
  },
  devtool: &lt;/span&gt;'cheap-module-eval-source-map'&lt;span&gt;,
  devServer: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; contentBase: path.join(__dirname, &quot;dist&quot;),&lt;/span&gt;
    port: 8081&lt;span&gt;,
    host: &lt;/span&gt;'0.0.0.0'&lt;span&gt;,
    headers: {
      &lt;/span&gt;'X-foo': '112233'&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hot: true,&lt;/span&gt;
    inline: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; open: true,&lt;/span&gt;
    overlay: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    stats: &lt;/span&gt;'errors-only'&lt;span&gt;
  },
  mode: &lt;/span&gt;'development'&lt;span&gt;,
  plugins: [
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlWebpackPlugin({
      template: &lt;/span&gt;'./index.html' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模版文件&lt;/span&gt;
&lt;span&gt;    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ClearWebpackPlugin(['dist'&lt;span&gt;]),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExtractTextPlugin({
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从js文件中提取出来的 .css文件的名称&lt;/span&gt;
&lt;span&gt;      filename: `main.[chunkhash].css`
    }),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 告诉webpack使用了哪些第三方库代码&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DllReferencePlugin({
      context: path.join(__dirname),
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; jquery 映射到json文件上去&lt;/span&gt;
      manifest: require('./plugins/jquery.manifest.json'&lt;span&gt;)
    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DllReferencePlugin({
      context: path.join(__dirname),
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; echarts 映射到json文件上去&lt;/span&gt;
      manifest: require('./plugins/echarts.manifest.json'&lt;span&gt;)
    }),

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***   使用HappyPack实例化    ****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用唯一的标识符id来代表当前的HappyPack 处理一类特定的文件&lt;/span&gt;
      id: 'babel'&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如何处理.js文件，用法和Loader配置是一样的&lt;/span&gt;
      loaders: ['babel-loader'&lt;span&gt;]
    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
      id: &lt;/span&gt;'image'&lt;span&gt;,
      loaders: [{
        loader: require.resolve(&lt;/span&gt;'url-loader'&lt;span&gt;),
        options: {
          limit: &lt;/span&gt;10000&lt;span&gt;,
          name: &lt;/span&gt;'[name].[ext]'&lt;span&gt;
        }
      }]
    }),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理styl文件&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
      id: &lt;/span&gt;'css-pack'&lt;span&gt;,
      loaders: [&lt;/span&gt;'css-loader'&lt;span&gt;]
    })
  ]
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打包后变成如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909231901288-595667269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三方库文件一般情况下不会轻易更改，因此我们在页面上引用的时候，直接把hash编码值带上，当第二次浏览器访问的时候，第三方库文件会直接从缓存里面读取(除js缓存时间过期以外)，这样的话，浏览器加载速度会更快。&lt;/p&gt;

&lt;p&gt;四：contenthash&lt;/p&gt;
&lt;p&gt;如上，第三方库文件已经解决了使用缓存了，但是css文件并没有，比如在main.js代码内部应用了 main.styl， main.js代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
require('../styles/main.styl'&lt;span&gt;);

$(&lt;/span&gt;'#app').html('欢迎你来我的博客'&lt;span&gt;);

console.log(&lt;/span&gt;'这是main.js'&lt;span&gt;);
console.log(&lt;/span&gt;22333&lt;span&gt;);   
require(&lt;/span&gt;'./demo1.js');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909231955592-1422902358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;main.js 和 main.css 的hash编码是一样，因此我现在继续更改main.js, 随便加一行代码，然后继续打包，会看到main.css的hash编码也会跟着改变，其实main.css的文件并没有更改，其实我是想main.css直接还是使用缓存就好。&lt;br/&gt;也就是说 更改那个文件，就对那个文件使用新的hash编码。没有更改过的文件，hash编码不变。&lt;/p&gt;
&lt;p&gt;main.js 代码变为如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
require('../styles/main.styl'&lt;span&gt;);

$(&lt;/span&gt;'#app').html('欢迎你来我的博客'&lt;span&gt;);

console.log(&lt;/span&gt;'这是main.js'&lt;span&gt;);
console.log(&lt;/span&gt;22333&lt;span&gt;);   
require(&lt;/span&gt;'./demo1.js'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新增一行代码&lt;/span&gt;
console.log(22333111); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后继续打包，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909232052662-1046763475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以看到main.css的hash编码是跟着 main.js 编码变动的。&lt;/p&gt;
&lt;p&gt;其实根本原因还是 module identifier，因为 main.js 新引入的模块main.styl, 它改变了以后所有模块的 id 值，所以 main.css 文件中引入的模块值发生了改变，于是 main.styl 的 chunkhash 也随着发生改变。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，contenthash就出来了。&lt;/p&gt;
&lt;p&gt;首先要分离css，之前是使用 extract-text-webpack-plugin 插件，现在我们为了使用 contenthash，因此需要使用mini-css-extract-plugin插件就可以了。具体配置代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 mini-css-extract-plugin 插件 &lt;/span&gt;
const MiniCssExtractPlugin = require('mini-css-extract-plugin'&lt;span&gt;);

module.exports &lt;/span&gt;=&lt;span&gt; {
  module: {
    {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则去匹配&lt;/span&gt;
      test: /\.styl$/&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
      use: ExtractTextPlugin.extract({
        fallback: {
          loader: 'style-loader'
        },
        use: [
          {
            loader: 'css-loader',
            options: {}
          },
          {
            loader: 'postcss-loader',
            options: {
              ident: 'postcss',
              plugins: [
                require('postcss-cssnext')(),
                require('cssnano')(),
                require('postcss-pxtorem')({
                  rootValue: 16,
                  unitPrecision: 5,
                  propWhiteList: []
                }),
                require('postcss-sprites')()
              ]
            }
          },
          {
            loader: 'stylus-loader',
            options: {}
          }
        ]
      })
      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      use: [
        MiniCssExtractPlugin.loader,
        {
          loader: &lt;/span&gt;'css-loader'&lt;span&gt;,
          options: {}
        },
        {
          loader: &lt;/span&gt;'postcss-loader'&lt;span&gt;,
          options: {
            ident: &lt;/span&gt;'postcss'&lt;span&gt;,
            plugins: [
              require(&lt;/span&gt;'postcss-cssnext'&lt;span&gt;)(),
              require(&lt;/span&gt;'cssnano'&lt;span&gt;)(),
              require(&lt;/span&gt;'postcss-pxtorem'&lt;span&gt;)({
                rootValue: &lt;/span&gt;16&lt;span&gt;,
                unitPrecision: &lt;/span&gt;5&lt;span&gt;,
                propWhiteList: []
              }),
              require(&lt;/span&gt;'postcss-sprites'&lt;span&gt;)()
            ]
          }
        },
        {
          loader: &lt;/span&gt;'stylus-loader'&lt;span&gt;,
          options: {}
        }
      ]
    },
    {
      test: &lt;/span&gt;/\.css$/&lt;span&gt;,
      use: [
        MiniCssExtractPlugin.loader,
        &lt;/span&gt;'happypack/loader?id=css-pack'&lt;span&gt;
      ]
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
      use: ExtractTextPlugin.extract({
        use: ['happypack/loader?id=css-pack']
      })
      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
  },
  plugins: [
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MiniCssExtractPlugin({
      filename: &lt;/span&gt;'[name].[contenthash:8].css'&lt;span&gt;
    })
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此webpack.config.js 所有代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;109&quot;&gt;
&lt;pre&gt;
const path = require('path'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取css的插件&lt;/span&gt;
const ExtractTextPlugin = require('extract-text-webpack-plugin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 mini-css-extract-plugin 插件 &lt;/span&gt;
const MiniCssExtractPlugin = require('mini-css-extract-plugin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清除dist目录下的文件&lt;/span&gt;
const ClearWebpackPlugin = require('clean-webpack-plugin'&lt;span&gt;);

const webpack &lt;/span&gt;= require('webpack'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入打包html文件&lt;/span&gt;
const HtmlWebpackPlugin = require('html-webpack-plugin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 DllReferencePlugin&lt;/span&gt;
const DllReferencePlugin = require('webpack/lib/DllReferencePlugin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入HappyPack插件 &lt;/span&gt;
const HappyPack = require('happypack'&lt;span&gt;);

module.exports &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入口文件&lt;/span&gt;
&lt;span&gt;  entry: {
    main: &lt;/span&gt;'./js/main.js'&lt;span&gt;,
    demo1: &lt;/span&gt;'./js/demo1.js'&lt;span&gt;
  },
  output: {
    filename: &lt;/span&gt;'[name].[chunkhash].js'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将输出的文件都放在dist目录下&lt;/span&gt;
    path: path.resolve(__dirname, 'dist'&lt;span&gt;)
  },
  module: {
    rules: [
      {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则去匹配&lt;/span&gt;
        test: /\.styl$/&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        use: ExtractTextPlugin.extract({
          fallback: {
            loader: 'style-loader'
          },
          use: [
            {
              loader: 'css-loader',
              options: {}
            },
            {
              loader: 'postcss-loader',
              options: {
                ident: 'postcss',
                plugins: [
                  require('postcss-cssnext')(),
                  require('cssnano')(),
                  require('postcss-pxtorem')({
                    rootValue: 16,
                    unitPrecision: 5,
                    propWhiteList: []
                  }),
                  require('postcss-sprites')()
                ]
              }
            },
            {
              loader: 'stylus-loader',
              options: {}
            }
          ]
        })
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        use: [
          MiniCssExtractPlugin.loader,
          {
            loader: &lt;/span&gt;'css-loader'&lt;span&gt;,
            options: {}
          },
          {
            loader: &lt;/span&gt;'postcss-loader'&lt;span&gt;,
            options: {
              ident: &lt;/span&gt;'postcss'&lt;span&gt;,
              plugins: [
                require(&lt;/span&gt;'postcss-cssnext'&lt;span&gt;)(),
                require(&lt;/span&gt;'cssnano'&lt;span&gt;)(),
                require(&lt;/span&gt;'postcss-pxtorem'&lt;span&gt;)({
                  rootValue: &lt;/span&gt;16&lt;span&gt;,
                  unitPrecision: &lt;/span&gt;5&lt;span&gt;,
                  propWhiteList: []
                }),
                require(&lt;/span&gt;'postcss-sprites'&lt;span&gt;)()
              ]
            }
          },
          {
            loader: &lt;/span&gt;'stylus-loader'&lt;span&gt;,
            options: {}
          }
        ]
      },
      {
        test: &lt;/span&gt;/\.css$/&lt;span&gt;,
        use: [
          MiniCssExtractPlugin.loader,
          &lt;/span&gt;'happypack/loader?id=css-pack'&lt;span&gt;
        ]
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        use: ExtractTextPlugin.extract({
          use: ['happypack/loader?id=css-pack']
        })
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      },
      {
        test: &lt;/span&gt;/\.(png|jpg)$/&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: '[name].[ext]'
        }
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        use: [&lt;/span&gt;'happypack/loader?id=image'&lt;span&gt;]
      },
      {
        test: &lt;/span&gt;/\.js$/&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将对.js文件的处理转交给id为babel的HappyPack的实列&lt;/span&gt;
        use: ['happypack/loader?id=babel'&lt;span&gt;],
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; loader: 'babel-loader',&lt;/span&gt;
        exclude: path.resolve(__dirname, 'node_modules') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 排除文件&lt;/span&gt;
&lt;span&gt;      }
    ]
  },
  resolve: {
    extensions: [&lt;/span&gt;'*', '.js', '.json'&lt;span&gt;]
  },
  devtool: &lt;/span&gt;'cheap-module-eval-source-map'&lt;span&gt;,
  devServer: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; contentBase: path.join(__dirname, &quot;dist&quot;),&lt;/span&gt;
    port: 8081&lt;span&gt;,
    host: &lt;/span&gt;'0.0.0.0'&lt;span&gt;,
    headers: {
      &lt;/span&gt;'X-foo': '112233'&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hot: true,&lt;/span&gt;
    inline: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; open: true,&lt;/span&gt;
    overlay: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    stats: &lt;/span&gt;'errors-only'&lt;span&gt;
  },
  mode: &lt;/span&gt;'development'&lt;span&gt;,
  plugins: [
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlWebpackPlugin({
      template: &lt;/span&gt;'./index.html' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模版文件&lt;/span&gt;
&lt;span&gt;    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ClearWebpackPlugin(['dist'&lt;span&gt;]),
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    new ExtractTextPlugin({
      // 从js文件中提取出来的 .css文件的名称
      filename: `[name].[contenthash:8].css`
    }),
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MiniCssExtractPlugin({
      filename: &lt;/span&gt;'[name].[contenthash:8].css'&lt;span&gt;
    }),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 告诉webpack使用了哪些第三方库代码&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DllReferencePlugin({
      context: path.join(__dirname),
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; jquery 映射到json文件上去&lt;/span&gt;
      manifest: require('./plugins/jquery.manifest.json'&lt;span&gt;)
    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DllReferencePlugin({
      context: path.join(__dirname),
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; echarts 映射到json文件上去&lt;/span&gt;
      manifest: require('./plugins/echarts.manifest.json'&lt;span&gt;)
    }),

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***   使用HappyPack实例化    ****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用唯一的标识符id来代表当前的HappyPack 处理一类特定的文件&lt;/span&gt;
      id: 'babel'&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如何处理.js文件，用法和Loader配置是一样的&lt;/span&gt;
      loaders: ['babel-loader'&lt;span&gt;]
    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
      id: &lt;/span&gt;'image'&lt;span&gt;,
      loaders: [{
        loader: require.resolve(&lt;/span&gt;'url-loader'&lt;span&gt;),
        options: {
          limit: &lt;/span&gt;10000&lt;span&gt;,
          name: &lt;/span&gt;'[name].[ext]'&lt;span&gt;
        }
      }]
    }),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理styl文件&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
      id: &lt;/span&gt;'css-pack'&lt;span&gt;,
      loaders: [&lt;/span&gt;'css-loader'&lt;span&gt;]
    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.HashedModuleIdsPlugin()
  ]
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过如上配置后，我们再打包一下看下如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909232206600-1123973183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我修改main.js代码后，再进行打包，会生成文件如下，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909232219957-1556114302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们继续改下main.styl代码，继续打包，看是否main.css的hash编码的变化，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909232236222-782835049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上我们可以看到修改main.styl后，main.js代码的hash变化也发生变化了。&lt;/p&gt;
&lt;p&gt;因此在打包js中，我们需要使用 contenthash 就可以了，配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入口文件&lt;/span&gt;
&lt;span&gt;  entry: {
    main: &lt;/span&gt;'./js/main.js'&lt;span&gt;,
    demo1: &lt;/span&gt;'./js/demo1.js'&lt;span&gt;
  },
  output: {
    filename: &lt;/span&gt;'[name].[contenthash].js'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将输出的文件都放在dist目录下&lt;/span&gt;
    path: path.resolve(__dirname, 'dist'&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此webpack.config.js所有代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;109&quot;&gt;
&lt;pre&gt;
const path = require('path'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取css的插件&lt;/span&gt;
const ExtractTextPlugin = require('extract-text-webpack-plugin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 mini-css-extract-plugin 插件 &lt;/span&gt;
const MiniCssExtractPlugin = require('mini-css-extract-plugin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清除dist目录下的文件&lt;/span&gt;
const ClearWebpackPlugin = require('clean-webpack-plugin'&lt;span&gt;);

const webpack &lt;/span&gt;= require('webpack'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入打包html文件&lt;/span&gt;
const HtmlWebpackPlugin = require('html-webpack-plugin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 DllReferencePlugin&lt;/span&gt;
const DllReferencePlugin = require('webpack/lib/DllReferencePlugin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入HappyPack插件 &lt;/span&gt;
const HappyPack = require('happypack'&lt;span&gt;);

module.exports &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入口文件&lt;/span&gt;
&lt;span&gt;  entry: {
    main: &lt;/span&gt;'./js/main.js'&lt;span&gt;,
    demo1: &lt;/span&gt;'./js/demo1.js'&lt;span&gt;
  },
  output: {
    filename: &lt;/span&gt;'[name].[contenthash].js'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将输出的文件都放在dist目录下&lt;/span&gt;
    path: path.resolve(__dirname, 'dist'&lt;span&gt;)
  },
  module: {
    rules: [
      {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则去匹配&lt;/span&gt;
        test: /\.styl$/&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        use: ExtractTextPlugin.extract({
          fallback: {
            loader: 'style-loader'
          },
          use: [
            {
              loader: 'css-loader',
              options: {}
            },
            {
              loader: 'postcss-loader',
              options: {
                ident: 'postcss',
                plugins: [
                  require('postcss-cssnext')(),
                  require('cssnano')(),
                  require('postcss-pxtorem')({
                    rootValue: 16,
                    unitPrecision: 5,
                    propWhiteList: []
                  }),
                  require('postcss-sprites')()
                ]
              }
            },
            {
              loader: 'stylus-loader',
              options: {}
            }
          ]
        })
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        use: [
          MiniCssExtractPlugin.loader,
          {
            loader: &lt;/span&gt;'css-loader'&lt;span&gt;,
            options: {}
          },
          {
            loader: &lt;/span&gt;'postcss-loader'&lt;span&gt;,
            options: {
              ident: &lt;/span&gt;'postcss'&lt;span&gt;,
              plugins: [
                require(&lt;/span&gt;'postcss-cssnext'&lt;span&gt;)(),
                require(&lt;/span&gt;'cssnano'&lt;span&gt;)(),
                require(&lt;/span&gt;'postcss-pxtorem'&lt;span&gt;)({
                  rootValue: &lt;/span&gt;16&lt;span&gt;,
                  unitPrecision: &lt;/span&gt;5&lt;span&gt;,
                  propWhiteList: []
                }),
                require(&lt;/span&gt;'postcss-sprites'&lt;span&gt;)()
              ]
            }
          },
          {
            loader: &lt;/span&gt;'stylus-loader'&lt;span&gt;,
            options: {}
          }
        ]
      },
      {
        test: &lt;/span&gt;/\.css$/&lt;span&gt;,
        use: [
          MiniCssExtractPlugin.loader,
          &lt;/span&gt;'happypack/loader?id=css-pack'&lt;span&gt;
        ]
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        use: ExtractTextPlugin.extract({
          use: ['happypack/loader?id=css-pack']
        })
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      },
      {
        test: &lt;/span&gt;/\.(png|jpg)$/&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: '[name].[ext]'
        }
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        use: [&lt;/span&gt;'happypack/loader?id=image'&lt;span&gt;]
      },
      {
        test: &lt;/span&gt;/\.js$/&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将对.js文件的处理转交给id为babel的HappyPack的实列&lt;/span&gt;
        use: ['happypack/loader?id=babel'&lt;span&gt;],
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; loader: 'babel-loader',&lt;/span&gt;
        exclude: path.resolve(__dirname, 'node_modules') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 排除文件&lt;/span&gt;
&lt;span&gt;      }
    ]
  },
  resolve: {
    extensions: [&lt;/span&gt;'*', '.js', '.json'&lt;span&gt;]
  },
  devtool: &lt;/span&gt;'cheap-module-eval-source-map'&lt;span&gt;,
  devServer: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; contentBase: path.join(__dirname, &quot;dist&quot;),&lt;/span&gt;
    port: 8081&lt;span&gt;,
    host: &lt;/span&gt;'0.0.0.0'&lt;span&gt;,
    headers: {
      &lt;/span&gt;'X-foo': '112233'&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hot: true,&lt;/span&gt;
    inline: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; open: true,&lt;/span&gt;
    overlay: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    stats: &lt;/span&gt;'errors-only'&lt;span&gt;
  },
  mode: &lt;/span&gt;'development'&lt;span&gt;,
  plugins: [
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlWebpackPlugin({
      template: &lt;/span&gt;'./index.html' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模版文件&lt;/span&gt;
&lt;span&gt;    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ClearWebpackPlugin(['dist'&lt;span&gt;]),
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    new ExtractTextPlugin({
      // 从js文件中提取出来的 .css文件的名称
      filename: `[name].[contenthash:8].css`
    }),
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MiniCssExtractPlugin({
      filename: &lt;/span&gt;'[name].[contenthash:8].css'&lt;span&gt;
    }),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 告诉webpack使用了哪些第三方库代码&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DllReferencePlugin({
      context: path.join(__dirname),
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; jquery 映射到json文件上去&lt;/span&gt;
      manifest: require('./plugins/jquery.manifest.json'&lt;span&gt;)
    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DllReferencePlugin({
      context: path.join(__dirname),
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; echarts 映射到json文件上去&lt;/span&gt;
      manifest: require('./plugins/echarts.manifest.json'&lt;span&gt;)
    }),

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***   使用HappyPack实例化    ****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用唯一的标识符id来代表当前的HappyPack 处理一类特定的文件&lt;/span&gt;
      id: 'babel'&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如何处理.js文件，用法和Loader配置是一样的&lt;/span&gt;
      loaders: ['babel-loader'&lt;span&gt;]
    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
      id: &lt;/span&gt;'image'&lt;span&gt;,
      loaders: [{
        loader: require.resolve(&lt;/span&gt;'url-loader'&lt;span&gt;),
        options: {
          limit: &lt;/span&gt;10000&lt;span&gt;,
          name: &lt;/span&gt;'[name].[ext]'&lt;span&gt;
        }
      }]
    }),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理styl文件&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
      id: &lt;/span&gt;'css-pack'&lt;span&gt;,
      loaders: [&lt;/span&gt;'css-loader'&lt;span&gt;]
    }),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; new webpack.HashedModuleIdsPlugin()&lt;/span&gt;
&lt;span&gt;  ]
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;webpack.config.js 代码如上配置，首先我们先打包完成后，查看打包后的文件如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909232336353-934165543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们随便改动下main.js文件，可以看到如下对应main.js的hash编码发生改动，如下代码文件：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909232402842-2068464282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着我们继续改动下main.styl文件中的代码，可以看到如下图demo1.js和main.js的hash编码并没有改动，&lt;br/&gt;只有main.css文件的hash编码发生改动了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201809/561794-20180909232417874-800597951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/webpack-all-demo/tree/master/hash&quot; target=&quot;_blank&quot;&gt;查看github上的代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 15:25:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>深入浅出的webpack4构建工具---浏览器前端资源缓存(十一)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/9615822.html</dc:identifier>
</item>
<item>
<title>堆排序 Rust实现 - 弱冠</title>
<link>http://www.cnblogs.com/kwebi/p/9615805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kwebi/p/9615805.html</guid>
<description>&lt;h2 id=&quot;堆排序&quot;&gt;堆排序&lt;/h2&gt;
&lt;p&gt;堆是一个数组，可以看成一颗二叉树&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;struct Heap(Vec&amp;lt;i32&amp;gt;);

impl Heap {
    //父节点索引
    fn parent(i: usize) -&amp;gt; usize {
        i / 2
    }
    //左子节点索引
    fn left(i: usize) -&amp;gt; usize {
        2 * i
    }
    //右子节点索引
    fn right(i: usize) -&amp;gt; usize {
        2 * i + 1
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;首先要能维护最大堆排序通常用最大堆&quot;&gt;首先要能维护最大堆(排序通常用最大堆)&lt;/h3&gt;
&lt;p&gt;思路就是找出该节点和两个子节点的最大节点&lt;br/&gt;如果该节点为最大，则结束，否则，先交换，然后继续判断子节点&lt;br/&gt;递归实现起来更简单&lt;br/&gt;具体实现如下&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;impl Heap {
    fn heap_size(&amp;amp;self) -&amp;gt; usize {
        self.0.len()
    }
    fn max_heapify(&amp;amp;mut self, mut i: usize) {
        loop {
            let l = Heap::left(i);
            let r = Heap::right(i);
            let mut largest;
            if l &amp;lt;= self.heap_size() &amp;amp;&amp;amp; self.0[l - 1] &amp;gt; self.0[i - 1] {
                largest = l;
            } else {
                largest = i;
            }
            if r &amp;lt;= self.heap_size() &amp;amp;&amp;amp; self.0[r - 1] &amp;gt; self.0[largest - 1] {
                largest = r;
            }

            if largest == i {
                break;
            } else {
                let tmp = self.0[i - 1];
                self.0[i - 1] = self.0[largest - 1];
                self.0[largest - 1] = tmp;
            }
            i = largest;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构建最大堆&quot;&gt;构建最大堆&lt;/h3&gt;
&lt;p&gt;依次对每个节点都进行维护即可构建最大堆&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;impl Heap {
    fn build_max_heap(&amp;amp;mut self) {
        for i in (1..self.heap_size() + 1).rev() {
            self.max_heapify(i);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;堆排序-1&quot;&gt;堆排序&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;先构建一个最大堆&lt;/li&gt;
&lt;li&gt;交换第一个和最后一个元素的值&lt;/li&gt;
&lt;li&gt;缩小堆空间&lt;/li&gt;
&lt;li&gt;对第一个节点进行堆维护&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;impl Heap {
    fn heap_sort(&amp;amp;mut self) {
        let len = self.heap_size();
        self.build_max_heap();
        let mut v = Vec::with_capacity(self.heap_size());
        for i in (2..len + 1).rev() {
            let tmp = self.0[0];
            self.0[0] = self.0[i - 1];
            v.insert(0, tmp);
            let len = self.heap_size();
            self.0.truncate(len - 1);
            self.max_heapify(1);
        }
        self.0.append(&amp;amp;mut v);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;整个堆排序时间复杂度为O(nlgn)&lt;/li&gt;
&lt;li&gt;构建堆时间复杂度为O(n)&lt;/li&gt;
&lt;li&gt;每次维护堆为O(lgn)， 总共调用n-1次&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 09 Sep 2018 15:21:00 +0000</pubDate>
<dc:creator>弱冠</dc:creator>
<og:description>堆排序 堆是一个数组，可以看成一颗二叉树 首先要能维护最大堆(排序通常用最大堆) 思路就是找出该节点和两个子节点的最大节点 如果该节点为最大，则结束，否则，先交换，然后继续判断子节点 递归实现起来更简</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kwebi/p/9615805.html</dc:identifier>
</item>
<item>
<title>人成长中必须知道的20个故事 [转载] - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9615785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9615785.html</guid>
<description>&lt;h2&gt;写在前面：&lt;/h2&gt;
&lt;p&gt;在我的学生时代，非常喜欢这种小文。他们应该属于那种心灵鸡汤吧，或者说充满了正能量。品读他们时，就像在欣赏一首音乐，滋润人的心田，给人积极向上的力量。毕业后，也许因为我们性格已养成，业务因为太忙碌了，也许因为不再纯真了，总之，是和这类美文疏远了，邂逅的次数是越来越少。今天偶然翻起，仍触动不已。&lt;/p&gt;
&lt;p&gt;故，记于此，共赏之，告于己，勤看之。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;     1  断箭&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;不相信自己的意志，永远也做不成将军。&lt;/strong&gt;&lt;br/&gt;　   春秋战国时代，一位父亲和他的儿子出征打战。父亲已做了将军，儿子还只是马前卒。又一阵号角吹响，战鼓雷鸣了，父亲庄严地托起一个箭囊，其中插着一只箭。父亲郑重对儿子说：“这是家袭宝箭，配带身边，力量无穷，但千万不可抽出来。”&lt;br/&gt;　　那是一个极其精美的箭囊，厚牛皮打制，镶着幽幽泛光的铜边儿，再看露出的箭尾。一眼便能认定用上等的孔雀羽毛制作。儿子喜上眉梢，贪婪地推想箭杆、箭头的模样，耳旁仿佛嗖嗖地箭声掠过，敌方的主帅应声折马而毙.&lt;br/&gt;　　果然，配带宝箭的儿子英勇非凡，所向披靡。当鸣金收兵的号角吹响时，儿子再也禁不住得胜的豪气，完全背弃了父亲的叮嘱，强烈的欲望驱赶着他呼一声就拔出宝箭，试图看个究竟。骤然间他惊呆了。&lt;br/&gt;　　一只断箭，箭囊里装着一只折断的箭。&lt;br/&gt;　　我一直刳着只断箭打仗呢！儿子吓出了一身冷汗，仿佛顷刻间失去支柱的房子，轰然意志坍塌了。&lt;br/&gt;　　结果不言自明，儿子惨死于乱军之中。&lt;br/&gt;　　拂开蒙蒙的硝烟，父亲拣起那柄断箭，沉重地啐一口道：“不相信自己的意志，永远也做不成将军。”&lt;br/&gt;　　把胜败寄托在一只宝箭上，多么愚蠢，而当一个人把生命的核心与把柄交给别人，又多么危险！比如把希望寄托在儿女身上；把幸福寄托在丈夫身上；把生活保障寄托在单位身上……&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        温馨提示：自己才是一只箭，若要它坚韧，若要它锋利，若要它百步穿杨，百发百中，磨砺它，拯救它的都只能是自己。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;      2  生命的价值&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;        &lt;strong&gt;不要让昨日的沮丧令明天的梦想黯然失色！&lt;/strong&gt;&lt;br/&gt;        在一次讨论会上，一位著名的演说家没讲一句开场白，手里却高举着一张20美元的钞票。&lt;br/&gt;面对会议室里的200个人，他问：“谁要这20美元？”一只只手举了起来。他接着说：“我打算把这20美元送给你们中的一位，但在这之前，请准许我做一件事。”他说着将钞票揉成一团，然后问：“谁还要？”仍有人举起手来。&lt;br/&gt;　　他又说：“那么，假如我这样做又会怎么样呢？”他把钞票扔到地上，又踏上一只脚，并且用脚碾它。尔后他拾起钞票，钞票已变得又脏又皱。&lt;br/&gt;　　“现在谁还要？”还是有人举起手来。&lt;br/&gt;　　“朋友们，你们已经上了一堂很有意义的课。无论我如何对待那张钞票，你们还是想要它，因为它并没贬值，它依旧值20美元。人生路上，我们会无数次被自己的决定或碰到的逆境击倒、欺凌甚至碾得粉身碎骨。我们觉得自己似乎一文不值。但无论发生什么，或将要发生什么，在上帝&lt;br/&gt;的眼中，你们永远不会丧失价值。在他看来，肮脏或洁净，衣着齐整或不齐整，你们依然是无价之宝。”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        温馨提示：生命的价值不依赖我们的所作所为，也不仰仗我们结交的人物，而是取决于我们本身！我们是独特的——永远不要忘记这一点！&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;     3  昂起头来真美&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;        &lt;strong&gt;别看它是一条黑母牛，牛奶一样是白的。&lt;/strong&gt;&lt;br/&gt;        珍妮是个总爱低着头的小女孩，她一直觉得自己长得不够漂亮。有一天，她到饰物店去买了只绿色蝴蝶结，店主不断赞美她戴上蝴蝶结挺漂亮，珍妮虽不信，但是挺高兴，不由昂起了头，急于让大家看看，出门与人撞了一下都没在意。&lt;br/&gt;　　珍妮走进教室，迎面碰上了她的老师，“珍妮，你昂起头来真美！”老师爱抚地拍拍她的肩说。&lt;br/&gt;　　那一天，她得到了许多人的赞美。她想一定是蝴蝶结的功劳，可往镜前一照，头上根本就没有蝴蝶结，一定是出饰物店时与人一碰弄丢了。&lt;br/&gt;　　自信原本就是一种美丽，而很多人却因为太在意外表而失去很多快乐。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        温馨提示：无论是贫穷还是富有，无论是貌若天仙，还是相貌平平，只要你昂起头来，快乐会使你变得可爱——人人都喜欢的那种可爱。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;     4  为生命画一片树叶&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;strong&gt; 只要心存相信，总有奇迹发生，希望虽然渺茫，但它永存人世。&lt;/strong&gt;&lt;br/&gt;       美国作家欧;亨利在他的小说《最后一片叶子》里讲了个故事：病房里，一个生命垂危的病人从房间里看见窗外的一棵树，在秋风中一片片地掉落下来。病人望着眼前的萧萧落叶，身体也随之每况愈下，一天不如一天。她说：“当树叶全部掉光时，我也就要死了。”一位老画家得知后，用彩笔画了一片叶脉青翠的树叶挂在树枝上。&lt;br/&gt;　　最后一片叶子始终没掉下来。只因为生命中的这片绿，病人竟奇迹般地活了下来。&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       温馨提示：人生可以没有很多东西，却唯独不能没有希望。希望是人类生活的一项重要的价值。有希望之处，生命就生生不息！&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;     5  飞翔的蜘蛛&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;        &lt;strong&gt;信念是一种无坚不催的力量，当你坚信自己能成功时，你必能成功。&lt;/strong&gt;&lt;br/&gt;        一天，我发现，一只黑蜘蛛在后院的两檐之间结了一张很大的网。难道蜘蛛会飞？要不，从这个檐头到那个檐头，中间有一丈余宽，第一根线是怎么拉过去的？后来，我发现蜘蛛走了许多弯路--从一个檐头起，打结，顺墙而下，一步一步向前爬，小心翼翼，翘起尾部，不让丝沾到地面的沙石或别的物体上，走过空地，再爬上对面的檐头，高度差不多了，再把丝收紧，以后也是如此。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         温馨提示：蜘蛛不会飞翔，但它能够把网凌结在半空中。它是勤奋、敏感、沉默而坚韧的昆虫，它的网制得精巧而规矩，八卦形地张开，仿佛得到神助。这样的成绩，使人不由想起那些沉默寡言的人和一些深藏不露的智者。于是，我记住了蜘蛛不会飞翔，但它照样把网结在空中。奇迹是执着者造成的。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;    6  阴影是条纸龙&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;        &lt;strong&gt;人生中，经常有无数来自外部的打击，但这些打击究竟会对你产生怎样的影响，最终决定权在你手中。&lt;/strong&gt;&lt;br/&gt;        祖父用纸给我做过一条长龙。长龙腹腔的空隙仅仅只能容纳几只蝗虫，投放进去，它们都在里面死了，无一幸免！祖父说：“蝗虫性子太躁，除了挣扎，它们没想过用嘴巴去咬破长龙，也不知道一直向前可以从另一端爬出来。因而，尽管它有铁钳般的嘴壳和锯齿一般的大腿，也无济于事。&lt;br/&gt;”当祖父把几只同样大小的青虫从龙头放进去，然后关上龙头，奇迹出现了：仅仅几分钟，小青虫们就一一地从龙尾爬了出来。&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        温馨提示：命运一直藏匿在我们的思想里。许多人走不出人生各个不同阶段或大或小的阴影，并非因为他们天生的个人条件比别人要差多远，而是因为他们没有思想要将阴影纸龙咬破，也没有耐心慢慢地找准一个方向，一步步地向前，直到眼前出现新的洞天。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;      7  成功并不像你想像的那么难&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;         并不是因为事情难我们不敢做，而是因为我们不敢做事情才难的。&lt;/strong&gt;&lt;br/&gt;         1965年，一位韩国学生到剑桥大学主修心理学。在喝下午茶的时候，他常到学校的咖啡厅或茶座听一些成功人士聊天。这些成功人士包括诺贝尔奖获得者，某一些领域的学术权威和一些创造了经济神话的人，这些人幽默风趣，举重若轻，把自己的成功都看得非常自然和顺理成章。时间长了，他发现，在国内时，他被一些成功人士欺骗了。那些人为了让正在创业的人知难而退，普遍把自己的创业艰辛夸大了，也就是说，他们在用自己的成功经历吓唬那些还没有取得成功的人。&lt;br/&gt;　　作为心理系的学生，他认为很有必要对韩国成功人士的心态加以研究。1970年，他把《成功并不像你想像的那么难》作为毕业论文，提交给现代经济心理学的创始人威尔;布雷登教授。布雷登教授读后，大为惊喜，他认为这是个新发现，这种现象虽然在东方甚至在世界各地普遍存在，但此前还没有一个人大胆地提出来并加以研究。惊喜之余，他写信给他的剑桥校友--当时正坐在韩国政坛第一把交椅上的人--朴正熙。他在信中说，“我不敢说这部著作对你有多大的帮助，但我敢肯定它比你的任何一个政令都能产生震动。”&lt;br/&gt;　　后来这本书果然伴随着韩国的经济起飞了。这本书鼓舞了许多人，因为他们从一个新的角度告诉人们，成功与“劳其筋骨，饿其体肤”、“三更灯火五更鸡”、“头悬梁，锥刺股”没有必然的联系。只要你对某一事业感兴趣，长久地坚持下去就会成功，因为上帝赋予你的时间和智慧够你圆满做完一件事情。后来，这位青年也获得了成功，他成了韩国泛业汽车公司的总裁。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      温馨提示：人世中的许多事，只要想做，都能做到，该克服的困难，也都能克服，用不着什么钢铁般的意志，更用不着什么技巧或谋略。只要一个人还在朴实而饶有兴趣地生活着，他终究会发现，造物主对世事的安排，都是水到渠成的。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;      8  永远的坐票&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;         &lt;strong&gt;生活真是有趣：如果你只接受最好的，你经常会得到最好的。&lt;/strong&gt;&lt;br/&gt;        有一个人经常出差，经常买不到对号入坐的车票。可是无论长途短途，无论车上多挤，他总能找到座位。&lt;br/&gt;　　他的办法其实很简单，就是耐心地一节车厢一节车厢找过去。这个办法听上去似乎并不高明，但却很管用。每次，他都做好了从第一节车厢走到最后一节车厢的准备，可是每次他都用不着走到最后就会发现空位。他说，这是因为像他这样锲而不舍找座位的乘客实在不多。经常是在他落座的车厢里尚余若干座位，而在其他车厢的过道和车厢接头处，居然人满为患。&lt;br/&gt;　　他说，大多数乘客轻易就被一两节车厢拥挤的表面现象迷惑了，不大细想在数十次停靠之中，从火车十几个车门上上下下的流动中蕴藏着不少提供座位的机遇；即使想到了，他们也没有那一份寻找的耐心。眼前一方小小立足之地很容易让大多数人满足，为了一两个座位背负着行囊挤来挤去有些人也觉得不值。他们还担心万一找不到座位，回头连个好好站着的地方也没有了。与生活中一些安于现状不思进取害怕失败的人，永远只能滞留在没有成功的起点上一样，这些不愿主动找座位的乘客大多只能在上车时最初的落脚之处一直站到下车。&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         温馨提示：自信、执着、富有远见、勤于实践，会让你握有一张人生之旅永远的坐票。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;     9  心中的顽石&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;        &lt;strong&gt;阻碍我们去发现、去创造的，仅仅是我们心理上的障碍和思想中的顽石。&lt;/strong&gt;&lt;br/&gt;       从前有一户人家的菜园摆着一颗大石头，宽度大约有四十公分，高度有十公分。到菜园的人，不小心就会踢到那一颗大石头，不是跌倒就是擦伤。&lt;br/&gt;　　儿子问：“爸爸，那颗讨厌的石头，为什么不把它挖走？”&lt;br/&gt;　　爸爸这么回答：“你说那颗石头喔？从你爷爷时代，就一直放到现在了，它的体积那么大，不知道要挖到到什么时候，没事无聊挖石头，不如走路小心一点，还可以训练你的反应能力。”&lt;br/&gt;　　过了几年，这颗大石头留到下一代，当时的儿子娶了媳妇，当了爸爸。&lt;br/&gt;　　有一天媳妇气愤地说：“爸爸，菜园那颗大石头，我越看越不顺眼，改天请人搬走好了。”&lt;br/&gt;　　爸爸回答说：“算了吧！那颗大石头很重的，可以搬走的话在我小时候就搬走了，哪会让它留到现在啊？”&lt;br/&gt;　　媳妇心底非常不是滋味，那颗大石头不知道让她跌倒多少次了。&lt;br/&gt;　　有一天早上，媳妇带着锄头和一桶水，将整桶水倒在大石头的四周。&lt;br/&gt;　　十几分钟以后，媳妇用锄头把大石头四周的泥土搅松。&lt;br/&gt;　　媳妇早有心理准备，可能要挖一天吧，谁都没想到几分钟就把石头挖起来，看看大小，这颗石头没有想像的那么大，都是被那个巨大的外表蒙骗了。&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       温馨提示：你抱着下坡的想法爬山，便无从爬上山去。如果你的世界沉闷而无望，那是因为你自己沉闷无望。改变你的世界，必先改变你自己的心态。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;     10  追求忘我&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;       &lt;strong&gt;不要把自己当做鼠，否则肯定被猫吃。&lt;/strong&gt;&lt;br/&gt;       1858年，瑞典的一个富豪人家生下了一个女儿。然而不久，孩子染患了一种无法解释的瘫痪症，丧失了走路的能力。&lt;br/&gt;　　一次，女孩和家人一起乘船旅行。船长的太太给孩子讲船长有一只天堂鸟，她被这只鸟的描述迷住了，极想亲自看一看。于是保姆把孩子留在甲板上，自己去找船长。孩子耐不住性子等待，她要求船上的服务生立即带她去看天堂鸟。那服务生并不知道她的腿不能走路，而只顾带着她一道去看那只美丽的小鸟。奇迹发生了，孩子因为过度地渴望，竟忘我地拉住服务生的手，慢慢地走了起来。从此，孩子的病便痊愈了。女孩子长大后，又忘我地投入到文学创作中，最后成为第一位荣获诺贝尔文学奖的女性，也就是茜尔玛;拉格萝芙。&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         温馨提示：忘我是走向成功的一条捷径，只有在这种环境中，人才会超越自身的束缚，释放出最大的能量。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;      11  乐观者与悲观者&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;         &lt;strong&gt;乐观者在每次危难中都看到了机会，而悲观的人在每个机会中都看到了危难。&lt;/strong&gt;&lt;br/&gt;        父亲欲对一对孪生兄弟作“性格改造”，因为其中一个过分乐观，而另一个则过分悲观。一天，他买了许多色泽鲜艳的新玩具给悲观孩子，又把乐观孩子送进了一间堆满马粪的车房里。&lt;br/&gt;　　第二天清晨，父亲看到悲观孩子正泣不成声，便问：“为什么不玩那些玩具呢？”&lt;br/&gt;　　“玩了就会坏的。”孩子仍在哭泣。&lt;br/&gt;　　父亲叹了口气，走进车房，却发现那乐观孩子正兴高采烈地在马粪里掏着什么。&lt;br/&gt;　　“告诉你，爸爸。”那孩子得意洋洋地向父亲宣称，“我想马粪堆里一定还藏着一匹小马呢！”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         温馨提示：乐观者与悲观者之间，其差别是很有趣的：乐观者看到的是油炸圈饼，悲观者看到的是一个窟窿。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;     12  勇于冒险&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;        &lt;strong&gt;对于那些害怕危险的人，危险无处不在。&lt;/strong&gt;&lt;br/&gt;        有一天，龙虾与寄居蟹在深海中相遇，寄居蟹看见龙虾正把自己的硬壳脱掉，只露出娇嫩的身躯。寄居蟹非常紧张地说：“龙虾，你怎可以把唯一保护自己身躯的硬壳也放弃呢？难道你不怕有大鱼一口把你吃掉吗？以你现在的情况来看，连急流也会把你冲到岩石去，到时你不死才怪呢？”&lt;br/&gt;　　龙虾气定神闲地回答：“谢谢你的关心，但是你不了解，我们龙虾每次成长，都必须先脱掉旧壳，才能生长出更坚固的外壳，现在面对的危险，只是为了将来发展得更好而作出准备。”&lt;br/&gt;　　寄居蟹细心思量一下，自己整天只找可以避居的地方，而没有想过如何令自己成长得更强壮，整天只活在别人的护荫之下，难怪永远都限制自己的发展。&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        温馨提示：每个人都有一定的安全区，你想跨越自己目前的成就，请不要划地自限，勇于接受挑战充实自我，你一定会发展得比想像中更好。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;     13  再试一次&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;strong&gt; 什么东西比石头还硬，或比水还软？然而软水却穿透了硬石，坚持不懈而已。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      有个年轻人去微软公司应聘，而该公司并没有刊登过招聘广告。见总经理疑惑不解，年轻人用不太娴熟的英语解释说自己是碰巧路过这里，就贸然进来了。总经理感觉很新鲜，破例让他一试。面试的结果出人意料，年轻人表现糟糕。他对总经理的解释是事先没有准备，总经理以为他不过是找个托词下台阶，就随口应道：“等你准备好了再来试吧”。 　　一周后，年轻人再次走进微软公司的大门，这次他依然没有成功。但比起第一次，他的表现要好得多。而总经理给他的回答仍然同上次一样：“等你准备好了再来试。”就这样，这个青年先后5次踏进微软公司的大门，最终被公司录用，成为公司的重点培养对象。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        温馨提示：也许，我们的人生旅途上沼泽遍布，荆棘丛生；也许我们追求的风景总是山重水复，不见柳暗花明；也许，我们前行的步履总是沉重、蹒跚；也许，我们需要在黑暗中摸索很长时间，才能找寻到光明；也许，我们虔诚的信念会被世俗的尘雾缠绕，而不能自由翱翔；也许，我们高贵的灵魂暂时在现实中找不到寄放的净土……那么，我们为什么不可以以勇敢者的气魄，坚定而自信地对自己说一声“再试一次！” 。再试一次，你就有可能达到成功的彼岸！&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;     14  天道酬勤&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;strong&gt;  没有人能只依靠天分成功。上帝给予了天分，勤奋将天分变为天才。&lt;/strong&gt;&lt;br/&gt;        曾国藩是中国历史上最有影响的人物之一，然他小时候的天赋却不高。有一天在家读书，对一篇文章重复不知道多少遍了，还在朗读，因为，他还没有背下来。这时候他家来了一个贼，潜伏在他的屋檐下，希望等读书人睡觉之后捞点好处。可是等啊等，就是不见他睡觉，还是翻来复去地读那篇文章。贼人大怒，跳出来说，“这种水平读什么书？”然后将那文章背诵一遍，扬长而去！&lt;br/&gt;　　贼人是很聪明，至少比曾先生要聪明，但是他只能成为贼，而曾先生却成为毛爷爷都钦佩的人：“近代最有大本夫源的人。”&lt;br/&gt;　　“勤能补拙是良训，一分辛苦一分才。”那贼的记忆力真好，听过几遍的文章都能背下来，而且很勇敢，见别人不睡觉居然可以跳出来“大怒”，教训曾先生之后，还要背书，扬长而去。但是遗憾的是，他名不经传，曾先生后来启用了一大批人才，按说这位贼人与曾先生有一面之交，大可去施展一二，可惜，他的天赋没有加上勤奋，变得不知所终。&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       温馨提示：伟大的成功和辛勤的劳动是成正比的，有一分劳动就有一分收获，日积月累，从少到多，奇迹就可以创造出来。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;     15  好学不倦&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;        &lt;strong&gt;只有一个洞穴的老鼠很快被捉。&lt;/strong&gt;&lt;br/&gt;        在一个漆黑的晚上，老鼠首领带领着小老鼠出外觅食，在一家人的厨房内，垃圾桶之中有很多剩余的饭菜，对于老鼠来说，就好像人类发现了宝藏。&lt;br/&gt;　　正当一大群老鼠在垃圾桶及附近范围大挖一顿之际，突然传来了一阵令它们肝胆俱裂的声音，那就是一头大花猫的叫声。它们震惊之余，更各自四处逃命，但大花猫绝不留情，不断穷追不舍，终于有两只小老鼠走避不及，被大花猫捉到，正要向它们吞噬之际，突然传来一连串凶恶的狗吠声，令大花猫手足无措，狼狈逃命。&lt;br/&gt;　　大花猫走后，老鼠首领施施然从垃圾桶后面走出来说：“我早就对你们说，多学一种语言有利无害，这次我就因而救了你们一命。”&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       温馨提示：“多一门技艺，多一条路。”不断学习实在是成功人士的终身承诺。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;    16  居安思危&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;       &lt;strong&gt;洪水未到先筑堤，豺狼未来先磨刀。&lt;/strong&gt;&lt;br/&gt;       一只野狼卧在草上勤奋地磨牙，狐狸看到了，就对它说：“天气这么好，大家在休息娱乐，你也加入我们队伍中吧！”野狼没有说话，继续磨牙，把它的牙齿磨得又尖又利。狐狸奇怪地问道：“森林这么静，猎人和猎狗已经回家了，老虎也不在近处徘徊，又没有任何危险，你何必那么用劲磨牙呢？”野狼停下来回答说：“我磨牙并不是为了娱乐，你想想，如果有&lt;br/&gt;       一天我被猎人或老虎追逐，到那时，我想磨牙也来不及了。而平时我就把牙磨好，到那时就可以保护自己了。”&lt;br/&gt;     &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      温馨提示：做事应该未雨绸缪，居安思危，这样在危险突然降临时，才不至于手忙脚乱。“书到用时方恨少”，平常若不充实学问，临时抱佛脚是来不及的。也有人抱怨没有机会，然而当升迁机会来临时，再叹自己平时没有积蓄足够的学识与能力，以致不能胜任，也只好后悔莫及。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;    17  困境即是赐予&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;        &lt;strong&gt;一个障碍，就是一个新的已知条件，只要愿意，任何一个障碍，都会成为一个超越自我的契机。&lt;/strong&gt;&lt;br/&gt;       有一天，素有森林之王之称的狮子，来到了天神面前：“我很感谢你赐给我如此雄壮威武的体格、如此强大无比的力气，让我有足够的能力统治这整座森林。”&lt;br/&gt;　　天神听了，微笑地问：“但是这不是你今天来找我的目的吧！看起来你似乎为了某事而困扰呢！”&lt;br/&gt;　　狮子轻轻吼了一声，说：“天神真是了解我啊！我今天来的确是有事相求。因为尽管我的能力再好，但是每天鸡鸣的时候，我总是会被鸡鸣声给吓醒。神啊！祈求您，再赐给我一个力量，让我不再被鸡鸣声给吓醒吧！”&lt;br/&gt;　　天神笑道：“你去找大象吧，它会给你一个满意的答复的。”&lt;br/&gt;　　狮子兴匆匆地跑到湖边找大象，还没见到大象，就听到大象跺脚所发出的“砰砰”响声。&lt;br/&gt;　　狮子加速地跑向大象，却看到大象正气呼呼地直跺脚。&lt;br/&gt;　　狮子问大象：“你干嘛发这么大的脾气？”&lt;br/&gt;　　大象拼命摇晃着大耳朵，吼着：“有只讨厌的小蚊子，总想钻进我的耳朵里，害我都快痒死了。”&lt;br/&gt;　　狮子离开了大象，心里暗自想着：“原来体型这么巨大的大象，还会怕那么瘦小的蚊子，那我还有什么好抱怨呢？毕竟鸡鸣也不过一天一次，而蚊子却是无时无刻地骚扰着大象。这样想来，我可比他幸运多了。”&lt;br/&gt;　　狮子一边走，一边回头看着仍在跺脚的大象，心想：“天神要我来看看大象的情况，应该就是想告诉我，谁都会遇上麻烦事，而它并无法帮助所有人。既然如此，那我只好靠自己了！反正以后只要鸡鸣时，我就当做鸡是在提醒我该起床了，如此一想，鸡鸣声对我还算是有益处呢？”&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       温馨提示：在人生的路上，无论我们走得多么顺利，但只要稍微遇上一些不顺的事，就会习惯性地抱怨老天亏待我们，进而祈求老天赐给我们更多的力量，帮助我们度过难关。但实际上，老天是最公平的，就像它对狮子和大象一样，每个困境都有其存在的正面价值。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;    18  永远的一课&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;        &lt;strong&gt;面对困难，许多人戴了放大镜，但和困难拼搏一番，你会觉得，困难不过如此&lt;/strong&gt;。&lt;br/&gt;        那天的风雪真暴，外面像是有无数发疯的怪兽在呼啸厮打。雪恶狠狠地寻找袭击的对象，风呜咽着四处搜索。&lt;br/&gt;　　大家都在喊冷，读书的心思似乎已被冻住了。一屋的跺脚声。&lt;br/&gt;　　鼻头红红的欧阳老师挤进教室时，等待了许久的风席卷而入，墙壁上的《中学生守则》一鼓一顿，开玩笑似的卷向空中，又一个跟头栽了下来。&lt;br/&gt;　　往日很温和的欧阳老师一反常态：满脸的严肃庄重甚至冷酷，一如室外的天气。&lt;br/&gt;　　乱哄哄的教室静了下来，我们惊异地望着欧阳老师。&lt;br/&gt;　　“请同学们穿上胶鞋，我们到操场上去。”&lt;br/&gt;　　几十双眼睛在问。&lt;br/&gt;　　“因为我们要在操场上立正五分钟。”&lt;br/&gt;　　即使欧阳老师下了“不上这堂课，永远别上我的课”的恐吓之词，还是有几个娇滴滴的女生和几个很横的男生没有出教室。&lt;br/&gt;　　操场在学校的东北角，北边是空旷的菜园，再北是一口大塘。&lt;br/&gt;　　那天，操场、菜园和水塘被雪连成了一个整体。&lt;br/&gt;　　矮了许多的篮球架被雪团打得“啪啪”作响，卷地而起的雪粒雪团呛得人睁不开眼张不开口。脸上像有无数把细窄的刀在拉在划，厚实的衣服像铁块冰块，脚像是踩在带冰碴的水里。&lt;br/&gt;　　我们挤在教室的屋檐下，不肯迈向操场半步。&lt;br/&gt;　　欧阳老师没有说什么，面对我们站定，脱下羽绒衣，线衣脱到一半，风雪帮他完成了另一半。“在操场上去，站好！”欧阳老师脸色苍白，一字一顿地对我们说。&lt;br/&gt;　　谁也没有吭声，我们老老实实地到操场排好了三列纵队。&lt;br/&gt;　　瘦削的欧阳老师只穿一件白衬褂，衬褂紧裹着的他更显单薄。&lt;br/&gt;　　后来，我们规规矩矩地在操场站了五分多钟。&lt;br/&gt;　　在教室时，同学们都以为自己敌不过那场风雪，事实上，叫他们站半个小时，他们顶得住，叫他们只穿一件衬衫，他们也顶得住。&lt;br/&gt;       &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       温馨提示：正如生命中的许多伤痛一样，其实并不如自己想像的那么严重。如果不把它当回事，它是不会很痛的。你觉得痛，那是因为你自以为伤口在痛，害怕伤口的痛。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;&lt;span&gt;    19  大海里的船&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;       &lt;strong&gt;在大海上航行的船没有不带伤的。&lt;/strong&gt;&lt;br/&gt;       英国劳埃德保险公司曾从拍卖市场买下一艘船，这艘船1894年下水，在大西洋上曾138次遭遇冰山，116次触礁，13次起火，207次被风暴扭断桅杆，然而它从没有沉没过。&lt;br/&gt;　　劳埃德保险公司基于它不可思议的经历及在保费方面给带来的可观收益，最后决定把它从荷兰买回来捐给国家。现在这艘船就停泊在英国萨伦港的国家船舶博物馆里。&lt;br/&gt;　　不过，使这艘船名扬天下的却是一名来此观光的律师。当时，他刚打输了一场官司，委托人也于不久前自杀了。尽管这不是他的第一次失败辩护，也不是他遇到的第一例自杀事件，然而，每当遇到这样的事情，他总有一种负罪感。他不知该怎样安慰这些在生意场上遭受了不幸的人。&lt;br/&gt;　　当他在萨伦船舶博物馆看到这艘船时，忽然有一种想法，为什么不让他们来参观参观这艘船呢？于是，他就把这艘船的历史抄下来和这艘船的照片一起挂在他的律师事务所里，每当商界的委托人请他辩护，无论输赢，他都建议他们去看看这艘船。&lt;br/&gt;　　它使我们知道：在大海上航行的船没有不带伤的。&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      温馨提示：虽然屡遭挫折，却能够坚强地百折不挠地挺住，这就是成功的秘密。&lt;br/&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;    20 驴的哲学&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;       &lt;strong&gt;人生必须渡过逆流才能走向更高的层次，最重要的是永远看得起自己。&lt;/strong&gt;&lt;br/&gt;       有一天某个农夫的一头驴子，不小心掉进一口枯井里，农夫绞尽脑汁想办法救出驴子，但几个小时过去了，驴子还在井里痛苦地哀嚎着。&lt;br/&gt;　　最后，这位农夫决定放弃，他想这头驴子年纪大了，不值得大费周章去把它救出来，不过无论如何，这口井还是得填起来。于是农夫便请来左邻右舍帮忙一起将井中的驴子埋了，以免除它的痛苦。&lt;br/&gt;　　农夫的邻居们人手一把铲子，开始将泥土铲进枯井中。当这头驴子了解到自己的处境时，刚开始哭得很凄惨。但出人意料的是，一会儿之后这头驴子就安静下来了。农夫好奇地探头往井底一看，出现在眼前的景象令他大吃一惊：&lt;br/&gt;　　当铲进井里的泥土落在驴子的背部时，驴子的反应令人称奇──它将泥土抖落在一旁，然后站到铲进的泥土堆上面！&lt;br/&gt;　　就这样，驴子将大家铲倒在它身上的泥土全数抖落在井底，然后再站上去。很快地，这只驴子便得意地上升到井口，然后在众人惊讶的表情中快步地跑开了！&lt;br/&gt;       &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       温馨提示：就如驴子的情况，在生命的旅程中，有时候我们难免会陷入“枯井”里，会被各式各样的“泥沙”倾倒在我们身上，而想要从这些“枯井”脱困的秘诀就是：将“泥沙”抖落掉，然后站到上面去！&lt;/p&gt;

</description>
<pubDate>Sun, 09 Sep 2018 15:16:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>写在前面： 在我的学生时代，非常喜欢这种小文。他们应该属于那种心灵鸡汤吧，或者说充满了正能量。品读他们时，就像在欣赏一首音乐，滋润人的心田，给人积极向上的力量。毕业后，也许因为我们性格已养成，业务因为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9615785.html</dc:identifier>
</item>
<item>
<title>Coursera概率图模型（Probabilistic Graphical Models）第四周编程作业分析 - 小石学CS</title>
<link>http://www.cnblogs.com/polaris-shi/p/9615766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/polaris-shi/p/9615766.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Decision Making&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作决策&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这一周的内容在老版本的CS228课程中，是作为第六周的一个小节讲的（老版本的CS229只有9周的课程），而在概率图模型的教材里边对应的是第22章效用和决策。也就是说，这一周的课程更多的是对之前所学知识的一种应用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.记号和定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用影响图来表现本周所学的内容，如下图所示：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1441944/201809/1441944-20180909231247414-1044896590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其中，X表示随机变量，D表示决策节点，U表示效用节点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.已知决策规则的期望效用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们可以将随机变量与决策节点一起看做一个贝叶斯网络，并只保留效用节点的父节点，即对其它节点用VariableElimination函数进行变量消除，将所得因子的val值与效用节点的val值相乘即可。公式如下式所示：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1441944/201809/1441944-20180909231247829-193926956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;SimpleCalcExpectedUtility.m 简单计算期望效用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%

%&lt;span&gt; YOUR CODE HERE

&lt;/span&gt;%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&lt;span&gt;

V &lt;/span&gt;= unique([F(:).&lt;span&gt;var&lt;/span&gt;&lt;span&gt;]);

Z &lt;/span&gt;= setdiff(V, U.&lt;span&gt;var&lt;/span&gt;&lt;span&gt;);

Fnew &lt;/span&gt;=&lt;span&gt; VariableElimination(F, Z);

 

Ffinal &lt;/span&gt;= Fnew(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ii = &lt;span&gt;2&lt;/span&gt;&lt;span&gt; : length(Fnew)

　　Ffinal &lt;/span&gt;=&lt;span&gt; FactorProduct(Ffinal, Fnew(ii));

end

 

Ffinal.val &lt;/span&gt;= Ffinal.val /&lt;span&gt; sum(Ffinal.val);

 

U_reorder_val &lt;/span&gt;=&lt;span&gt; zeros(size(U.val));

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ii = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; : prod(U.card)

　　U_reorder_val(ii) &lt;/span&gt;= GetValueOfAssignment(U, IndexToAssignment(ii, U.card), Ffinal.&lt;span&gt;var&lt;/span&gt;&lt;span&gt;);

end

 

EU &lt;/span&gt;= Ffinal.val * U_reorder_val&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.基于期望效用因子最大化期望效用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上一章的公式可以变形如下式：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1441944/201809/1441944-20180909231248226-1752367428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们需要计算的期望效用，就是式中的&lt;img src=&quot;https://images2018.cnblogs.com/blog/1441944/201809/1441944-20180909231248579-192711763.png&quot; alt=&quot;&quot;/&gt;部分。这里我们可以将随机变量与效用节点一起看做一个贝叶斯网络，将网络中与决策节点无关的变量消除，其剩余因子的因子积就是我们要求的最大期望效用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;CalculateExpectedUtilityFactor.m 计算期望效用因子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%

%&lt;span&gt; YOUR CODE HERE...

&lt;/span&gt;%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&lt;span&gt;

F &lt;/span&gt;=&lt;span&gt; [I.RandomFactors, I.UtilityFactors];

 

V &lt;/span&gt;= unique([F(:).&lt;span&gt;var&lt;/span&gt;&lt;span&gt;]);

Z &lt;/span&gt;= setdiff(V, I.DecisionFactors(&lt;span&gt;1&lt;/span&gt;).&lt;span&gt;var&lt;/span&gt;&lt;span&gt;);

Fnew &lt;/span&gt;=&lt;span&gt; VariableElimination(F, Z);

 

EUF &lt;/span&gt;= Fnew(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ii = &lt;span&gt;2&lt;/span&gt;&lt;span&gt; : length(Fnew)

　　EUF &lt;/span&gt;=&lt;span&gt; FactorProduct(EUF, Fnew(ii));

end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;OptimizeMEU.m 优化最大期望效用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里就是取效用最大的决策方案。注意一下多个决策节点时OptimalDecisionRule.var的含义。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
OptimalDecisionRule =&lt;span&gt; CalculateExpectedUtilityFactor(I);

 

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; length(OptimalDecisionRule.&lt;span&gt;var&lt;/span&gt;) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

　　[MEU, index] &lt;/span&gt;=&lt;span&gt; max(OptimalDecisionRule.val);

　　OptimalDecisionRule.val &lt;/span&gt;=&lt;span&gt; zeros(size(OptimalDecisionRule.val));

　　OptimalDecisionRule.val(index) &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;

　　assignments &lt;/span&gt;= IndexToAssignment(&lt;span&gt;1&lt;/span&gt; : prod(OptimalDecisionRule.card(&lt;span&gt;1&lt;/span&gt; : end - &lt;span&gt;1&lt;/span&gt;)), OptimalDecisionRule.card(&lt;span&gt;1&lt;/span&gt; : end - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));

　　MEU &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ii = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; : OptimalDecisionRule.card(end)

　　　　indices1 &lt;/span&gt;= AssignmentToIndex([assignments, ii * ones(size(assignments, &lt;span&gt;1&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)], OptimalDecisionRule.card);

　　　　[meu, indices2] &lt;/span&gt;=&lt;span&gt; max(OptimalDecisionRule.val(indices1));

　　　　MEU &lt;/span&gt;= MEU +&lt;span&gt; meu;

　　　　OptimalDecisionRule.val(indices1) &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

　　　　OptimalDecisionRule.val(indices1(indices2)) &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

　　end

end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.多效用因子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们还往往会遇到不止一个效用节点的情况，如下图所示：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1441944/201809/1441944-20180909231248802-1423399542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这种情况下，我们当然是选择能够使多个效用节点期望值的和最大的决策啦。我们有两种处理方案：一种是直接求出每一个效用节点的期望值，之后直接加和即可；另一种是利用下式所示的公式对效用节点进行变形，之后直接计算最大期望效用即可。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上述的两种方法都会要用到因子求和函数，这个函数在这一周的作业中并没有提供……但是，可以在第七周的作业PA-Exact-Inference-Release中找到，函数名为FactorSum.m，直接把函数的全部内容复制在我们这一周的作业后边就好。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;FactorSum.m 因子求和&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第七周作业提供的代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
function C =&lt;span&gt; FactorSum(A, B)

 

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isempty(A.&lt;span&gt;var&lt;/span&gt;)), C = B; &lt;span&gt;return&lt;/span&gt;&lt;span&gt;; end;

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isempty(B.&lt;span&gt;var&lt;/span&gt;)), C = A; &lt;span&gt;return&lt;/span&gt;&lt;span&gt;; end;

 

[dummy iA iB] &lt;/span&gt;= intersect(A.&lt;span&gt;var&lt;/span&gt;, B.&lt;span&gt;var&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ~&lt;span&gt;isempty(dummy)

    assert(all(A.card(iA) &lt;/span&gt;== B.card(iB)), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Dimensionality mismatch in factors&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

end

 

C.&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; = union(A.&lt;span&gt;var&lt;/span&gt;, B.&lt;span&gt;var&lt;/span&gt;&lt;span&gt;);

 

 

[dummy, mapA] &lt;/span&gt;= ismember(A.&lt;span&gt;var&lt;/span&gt;, C.&lt;span&gt;var&lt;/span&gt;&lt;span&gt;);

[dummy, mapB] &lt;/span&gt;= ismember(B.&lt;span&gt;var&lt;/span&gt;, C.&lt;span&gt;var&lt;/span&gt;&lt;span&gt;);

 

C.card &lt;/span&gt;= zeros(&lt;span&gt;1&lt;/span&gt;, length(C.&lt;span&gt;var&lt;/span&gt;&lt;span&gt;));

C.card(mapA) &lt;/span&gt;=&lt;span&gt; A.card;

C.card(mapB) &lt;/span&gt;=&lt;span&gt; B.card;

 

C.val &lt;/span&gt;= zeros(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,prod(C.card));

 

assignments &lt;/span&gt;= IndexToAssignment(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:prod(C.card), C.card);

indxA &lt;/span&gt;=&lt;span&gt; AssignmentToIndex(assignments(:, mapA), A.card);

indxB &lt;/span&gt;=&lt;span&gt; AssignmentToIndex(assignments(:, mapB), B.card);

 

C.val &lt;/span&gt;= A.val(indxA) +&lt;span&gt; B.val(indxB);

 

end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;OptimizeWithJointUtility.m 联合效用优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%

%&lt;span&gt; YOUR CODE HERE

&lt;/span&gt;%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&lt;span&gt;

U &lt;/span&gt;= I.UtilityFactors(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ii = &lt;span&gt;2&lt;/span&gt;&lt;span&gt; : length(I.UtilityFactors)

    U &lt;/span&gt;=&lt;span&gt; FactorSum(U, I.UtilityFactors(ii));

end

I.UtilityFactors &lt;/span&gt;=&lt;span&gt; U;

[MEU, OptimalDecisionRule] &lt;/span&gt;= OptimizeMEU(I);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;OptimizeLinearExpectations.m 线性期望优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%

%&lt;span&gt; YOUR CODE HERE

&lt;/span&gt;%

% A decision rule &lt;span&gt;for&lt;/span&gt; D assigns, &lt;span&gt;for&lt;/span&gt; each joint assignment to D&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s parents,&lt;/span&gt;

% probability &lt;span&gt;1&lt;/span&gt; to the best option &lt;span&gt;from&lt;/span&gt; the EUF &lt;span&gt;for&lt;/span&gt;&lt;span&gt; that joint assignment

&lt;/span&gt;% to D&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s parents, and 0 otherwise. Note that when D has no parents, it is&lt;/span&gt;

% a degenerate &lt;span&gt;case&lt;/span&gt; we can handle separately &lt;span&gt;for&lt;/span&gt;&lt;span&gt; convenience.

&lt;/span&gt;%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&lt;span&gt;

OptimalDecisionRule &lt;/span&gt;= &lt;span&gt;struct&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;card&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, []);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ii = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; : length(I.UtilityFactors)

I_ &lt;/span&gt;=&lt;span&gt; I;

I_.UtilityFactors &lt;/span&gt;=&lt;span&gt; I.UtilityFactors(ii);

EUF_ &lt;/span&gt;=&lt;span&gt; CalculateExpectedUtilityFactor(I_);

OptimalDecisionRule &lt;/span&gt;=&lt;span&gt; FactorSum(OptimalDecisionRule, EUF_);

end

 

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; length(OptimalDecisionRule.&lt;span&gt;var&lt;/span&gt;) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

    [MEU, index] &lt;/span&gt;=&lt;span&gt; max(OptimalDecisionRule.val);

    OptimalDecisionRule.val &lt;/span&gt;=&lt;span&gt; zeros(size(OptimalDecisionRule.val));

    OptimalDecisionRule.val(index) &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;

    assignments &lt;/span&gt;= IndexToAssignment(&lt;span&gt;1&lt;/span&gt; : prod(OptimalDecisionRule.card(&lt;span&gt;1&lt;/span&gt; : end - &lt;span&gt;1&lt;/span&gt;)), OptimalDecisionRule.card(&lt;span&gt;1&lt;/span&gt; : end - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));

    MEU &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ii = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; : OptimalDecisionRule.card(end)

        indices1 &lt;/span&gt;= AssignmentToIndex([assignments, ii * ones(size(assignments, &lt;span&gt;1&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)], OptimalDecisionRule.card);

        [meu, indices2] &lt;/span&gt;=&lt;span&gt; max(OptimalDecisionRule.val(indices1));

        MEU &lt;/span&gt;= MEU +&lt;span&gt; meu;

        OptimalDecisionRule.val(indices1) &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        OptimalDecisionRule.val(indices1(indices2)) &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    end

end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;交作业的截图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1441944/201809/1441944-20180909231249231-1756288174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这两周诸事繁杂，所以概率图的学习进度放缓了些，下周开始要保持正常进度才行……&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 15:13:00 +0000</pubDate>
<dc:creator>小石学CS</dc:creator>
<og:description>Decision Making 作决策 这一周的内容在老版本的CS228课程中，是作为第六周的一个小节讲的（老版本的CS229只有9周的课程），而在概率图模型的教材里边对应的是第22章效用和决策。也就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/polaris-shi/p/9615766.html</dc:identifier>
</item>
</channel>
</rss>