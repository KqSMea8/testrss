<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>sql server 2016新特性 查询存储（Query Store）的性能影响 - fooa_fooa</title>
<link>http://www.cnblogs.com/fooa1098/p/9628246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fooa1098/p/9628246.html</guid>
<description>&lt;p&gt;前段时间给客户处理性能问题，遇到一个新问题，&lt;/p&gt;
&lt;p&gt;客户的架构用的是 alwayson ,并且硬件用的是4路96核心，内存1T ，全固态闪存盘，sql server 2016 。&lt;/p&gt;
&lt;p&gt;问题  描述  &lt;/p&gt;
&lt;p&gt;     客户经常出现系统卡住的现象，从当时跟踪的语句执行情况看 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/983767/201809/983767-20180911153856082-1390651445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是被卡住了，但每次的阻塞源头都不一样，当时临时的解决方法是把主副本做切换，然后再切换回来。&lt;/p&gt;

&lt;p&gt;事后对系统事件及sqlserver 的日志进行分析，发现如下报错：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/983767/201809/983767-20180911153455120-696522913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/983767/201809/983767-20180911155649864-1134362240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 根据当时的等待资源及报错信息，怀疑是开了 查询存储（Query Store） 造成的，随后发现客户这里的 数据库中果真是开了 Query Store 选项， &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/983767/201809/983767-20180911154519787-81422309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了验证是否与 Query Store 有关，我们经与客户协商，把这个选项关掉，目前已经运行两周了，卡慢现象没有在发生。&lt;/p&gt;
&lt;p&gt;顺便提一下，客户的系统非常复杂数据量也很大，有些过程的代码有400行以上，所以生成的计划也相当的可观，应该是在这种情况下造成 Query Store 不但不能有性能的提升，反而消耗了相当可观的服务器资源，所以 Query Store并不是开启就是最优的选择，要根据自身的系统情况而定。&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 07:55:00 +0000</pubDate>
<dc:creator>fooa_fooa</dc:creator>
<og:description>前段时间给客户处理性能问题，遇到一个新问题， 客户的架构用的是 alwayson ,并且硬件用的是4路96核心，内存1T ，全固态闪存盘，sql server 2016 。 问题 描述 客户经常出现系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fooa1098/p/9628246.html</dc:identifier>
</item>
<item>
<title>Spring系列(四) 面向切面的Spring - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/9628086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/9628086.html</guid>
<description>&lt;p&gt;除了IOC外, AOP是Spring的另一个核心. Spring利用AOP解决应用横切关注点(cross-cutting concern)与业务逻辑的分离, 目的是解耦合. 横切关注点是指散布于代码多处的同一种功能, 比如日志, 事务, 安全, 缓存等.&lt;/p&gt;
&lt;h2 id=&quot;aop编程的基本概念&quot;&gt;AOP编程的基本概念&lt;/h2&gt;
&lt;p&gt;在OOP中, 如果要复用同一功能, 一般的做法是使用继承或委托. 继承容易导致脆弱的对象体系, 而委托实现起来比较麻烦, 需要对委托对象进行复杂调用. AOP提供了另外一种思路, 使用AOP我们仍然可以在一个地方定义功能, 并通过声明的方式告知何处以哪种方式使用这个功能. 这样我们既可以对功能做统一管理和维护, 同时也简化了业务逻辑模块, 使其更关注自身的业务逻辑. 此外, AOP还可以将新的功能行为添加到现有对象.&lt;/p&gt;
&lt;h3 id=&quot;spring中aop的术语&quot;&gt;Spring中AOP的术语&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;切面(Aspect): 切面定义了横切关注点的功能以及使用该功能的声明. 它包含了另外两个术语, 通知(Advice, 功能逻辑代码)和切点(Pointcut,声明). 切面定义了它是什么(what), 以及在何时何处(when,where)完成其功能.&lt;/li&gt;
&lt;li&gt;通知(Advice): 通知定义了切面的具体功能, 以及何时使用.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;when,何时使用? 前置(Before), 后置(After), 返回(After-returning), 异常(After-throwing), 环绕(Around)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;切点(Pointcut): 定义了切面定义的功能在哪里(Where)发生作用, 看起来就像从某个点把切面插入进去一样. 切点应该属于连接点中的一个或多个.&lt;/li&gt;
&lt;li&gt;连接点(Join point): 定义了程序执行过程中可以应用切面的具体时机, 比如方法调用前, 调用后, 结果返回时, 异常抛出时等, 通常某个具体切面只会选择其中一个或几个连接点作为切点.&lt;/li&gt;
&lt;li&gt;引入(Introduction): 为现有的类添加新的方法或属性叫引入.&lt;/li&gt;
&lt;li&gt;织入(Weaving): 织入是把切面应用到目标对象并创建新代理对象的过程.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;织入的方式有三种:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;编译期: 需要特殊的编译器支持, 如AspectJ的织入编译器&lt;/li&gt;
&lt;li&gt;类加载期: 需要特殊的类加载器ClassLoader&lt;/li&gt;
&lt;li&gt;运行时: Spring AOP 使用该方式织入. AOP容器为对象动态创建一个代理对象.&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;spring-对-aop的支持&quot;&gt;Spring 对 AOP的支持&lt;/h3&gt;
&lt;p&gt;Spring对AOP的支持很多借鉴了AspectJ的方式.&lt;/p&gt;
&lt;p&gt;Spring支持四种方式的织入:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基于代理的经典AOP; (方式太老旧, 不建议使用)&lt;/li&gt;
&lt;li&gt;纯POJO切面;(需要XML配置)&lt;/li&gt;
&lt;li&gt;@AspectJ 注解驱动的切面; (没啥说的,很好用)&lt;/li&gt;
&lt;li&gt;注入式AspectJ切面;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;前三种都是基于动态代理实现, 因此Spring对AOP的支持局限于方法拦截. 如果前三种满足不了需求(比如拦截构造器方法或者字段修改), 可以使用第四种.&lt;/li&gt;
&lt;li&gt;与AspectJ不同, Spring的切面就是Java类, Spring使用运行时动态代理, 而AspectJ需要学习特殊的语法以支持特殊的编译器织入.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;通过切点来选择连接点&quot;&gt;通过切点来选择连接点&lt;/h2&gt;
&lt;p&gt;Spring 借鉴了AspectJ的切点表达式语言. 如前所述, Spring基于动态代理,只能在方法上拦截, 所以Spring只支持这个层面的表达式来定义.&lt;/p&gt;
&lt;p&gt;spring支持的AspectJ指示器如下, 其中execution来执行匹配, 其他均为限制匹配的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/794700/201809/794700-20180911153931944-1454366414.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切点表达式更多使用可以参考&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pointcuts&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring新增了个bean()指示器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用注解创建切面&quot;&gt;使用注解创建切面&lt;/h2&gt;
&lt;p&gt;一. 定义切面类, 并用 &lt;code&gt;@Aspect&lt;/code&gt;注解, 该注释用来标记这个类是个切面&lt;/p&gt;
&lt;p&gt;二. 定义切面的方法(what), 并使用注解标记方法(when), 可用的注解: &lt;code&gt;@Before&lt;/code&gt;,&lt;code&gt;@After&lt;/code&gt;,&lt;code&gt;@AfterReturning&lt;/code&gt;,&lt;code&gt;@AfterThrowing&lt;/code&gt;,&lt;code&gt;@Around&lt;/code&gt;(功能最强大,后面将单独使用这种通知)&lt;/p&gt;
&lt;p&gt;一,二步完成后的代码:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Aspect
public class Audience{

    @Before(&quot;execution(** com.xlx.Performance.perform(...))&quot;)
    public void silencephone(){
        System.out.println(&quot;silencephone&quot;);
    }

    @Before(&quot;execution(** com.xlx.Performance.perform(...))&quot;)
    public void takeSeats(){
        System.out.println(&quot;takeSeats&quot;);
    }

    @AfterReturning(&quot;execution(** com.xlx.Performance.perform(...))&quot;)
    public void applause(){
        System.out.println(&quot;applause&quot;);
    }

    @AfterThrowing(&quot;execution(** com.xlx.Performance.perform(...))&quot;)
    public void refund(){
        System.out.println(&quot;refund&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中切面表达式被重复定义了四次, 无论如何这已经是重复代码了, 下一步优化一下.&lt;/p&gt;
&lt;p&gt;三. 使用注解&lt;code&gt;@Pointcut&lt;/code&gt;定义切点&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Aspect
public class Audience{

    //定义切点并修改其他方法重用该切点
    @Pointcut(&quot;execution(** com.xlx.Performance.perform(...))&quot;)
    public void performance(){

    }

    @Before(&quot;performance()&quot;)
    public void silencephone(){
        System.out.println(&quot;silencephone&quot;);
    }

    @Before(&quot;performance()&quot;)
    public void takeSeats(){
        System.out.println(&quot;takeSeats&quot;);
    }

    @AfterReturning(&quot;performance()&quot;)
    public void applause(){
        System.out.println(&quot;applause&quot;);
    }

    @AfterThrowing(&quot;performance()&quot;)
    public void refund(){
        System.out.println(&quot;refund&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@Aspect&lt;/code&gt;注解的类依然是个普通java类, 它可以被装配为bean&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public Audience getAudience(){
    return new Audience();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;四. 使用&lt;code&gt;@EnableAspectJAutoProxy&lt;/code&gt;注解启用自动代理功能, 如果是XML Config ,对应的节点是&lt;code&gt;&amp;lt;aop:aspectj-autoproxy /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@ComponentScan // 包扫描
@EnableAspenctJAutoProxy // 启动自动代理
public class MyConfig{

    // 如果Audience上加了@Component就不需要这个代码了
    @Bean
    public Audience getAudience(){
        return new Audience();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;五. 使用环绕通知&lt;code&gt;@Around&lt;/code&gt;, 环绕通知同时兼具了&lt;code&gt;@Before&lt;/code&gt;,&lt;code&gt;@After&lt;/code&gt; ... 等注解的方法的功能, 下面代码演示了这种能力. 如可以使用它记录方法执行时长.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Aspect
public class Audience{

    //定义切点并修改其他方法重用该切点
    @Pointcut(&quot;execution(** com.xlx.Performance.perform(...))&quot;)
    public void performance(){

    }

    @Around(&quot;performance()&quot;)
    public void silencephone(ProcdedingJoinPoint jp){
        System.out.println(&quot;silencephone&quot;);
        System.out.println(&quot;takeSeats&quot;);
        try{
            // 如果不是刻意为之, 一定要记得调用jp.proceed();否则实际的方法Performance.perform()将会阻塞
            jp.proceed();
            System.out.println(&quot;applause&quot;);
        }catch(Exception e){
            System.out.println(&quot;refund&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;六. 参数传递 , 在切点表达式中使用&lt;code&gt;args(paramName)&lt;/code&gt;结合切点方法可以为切面方法传递参数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Aspect
public class Audience{

    //定义切点并修改其他方法重用该切点
    @Pointcut(&quot;execution(** com.xlx.Performance.perform(int) &amp;amp;&amp;amp; args(actornum)))&quot;)
    public void performance(int actornum){

    }

    @Before(&quot;performance(actornum)&quot;)
    public void countActor(int actornum){
        System.out.println(&quot;countActor&quot;+actornum);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通过注解引用新功能&quot;&gt;通过注解引用新功能&lt;/h2&gt;
&lt;p&gt;除了拦截对象已有的方法调用, 还可以使用AOP来为对象添加新的属性和行为(引入). 其实现就是通过动态代理生成代理类来实现.&lt;/p&gt;
&lt;p&gt;一. 定义要添加的功能接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Encoreable{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二. 定义切面(引入) &lt;code&gt;@Aspect&lt;/code&gt;注解切面类. &lt;code&gt;@DeclareParents&lt;/code&gt;注解功能接口静态变量&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Aspect
public class EncoreableIntroducer{
    // 可以解释为: 为Performace的所有子类引入接口Encoreable, 并使用默认实现类DefaultEncoreableImpl
    @DeclareParents(value=&quot;xlx.Performace+&quot;,defaultImpl=DefaultEncoreableImpl.class)
    public static Encoreable encoreable;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于xml配置的切面&quot;&gt;基于XML配置的切面&lt;/h2&gt;
&lt;p&gt;如果没有办法为类添加注解, 比如没有源代码, 那就不得不使用xml来配置了.&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect ref=&quot;aspectBean&quot;&amp;gt;
        &amp;lt;aop:pointcut id=&quot;pcId&quot; expression=&quot;execution(** com.xlx.Performance.perform(int) and args(actornum)))&quot; /&amp;gt;
        &amp;lt;aop:before pointcut-ref=&quot;pcId&quot; method=&quot;count&quot; /&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect&amp;gt;
        &amp;lt;aop:declare-parents type-matching=&quot;xlx.Performace+&quot; implement-interface=&quot;xlx.Encoreable&quot; delegate-ref=&quot;defaultImpl&quot; /&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;aspectj-注入&quot;&gt;AspectJ 注入&lt;/h2&gt;
&lt;p&gt;使用AspectJ注入的方式可以解决使用动态代理无法解决的问题(应该比较少见,大多应用使用Spring AOP就可以实现了), 但需要使用AspectJ的特殊语法. 定义好的类需要用xml配置为bean, 使用&lt;code&gt;factory-method=&quot;aspectOf&quot;&lt;/code&gt;属性来制定bean的产生方式.&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean factory-method=&quot;aspectOf&quot; class=&quot;...ClassName&quot;&amp;gt;
    &amp;lt;property name=&quot;other&quot; ref=&quot;otherref&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 11 Sep 2018 07:40:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>除了IOC外, AOP是Spring的另一个核心. Spring利用AOP解决应用横切关注点(cross cutting concern)与业务逻辑的分离, 目的是解耦合. 横切关注点是指散布于代码多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/9628086.html</dc:identifier>
</item>
<item>
<title>Istio技术与实践6：Istio如何为服务提供安全防护能力 - PaaS小魔仙</title>
<link>http://www.cnblogs.com/hwpaas/p/9628000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hwpaas/p/9628000.html</guid>
<description>&lt;p&gt;凡是产生连接关系，就必定带来安全问题，人类社会如此，服务网格世界，亦是如此。&lt;/p&gt;
&lt;p&gt;今天，我们就来谈谈Istio第二主打功能&lt;strong&gt;---&lt;/strong&gt;保护服务。&lt;/p&gt;
&lt;p&gt;那么，便引出3个问题：&lt;/p&gt;
&lt;p&gt;l  &lt;a href=&quot;https://www.huaweicloud.com/product/cce.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Istio&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;凭什么保护服务？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;l  &lt;strong&gt;Istio&lt;/strong&gt;&lt;strong&gt;具体&lt;/strong&gt;&lt;strong&gt;如何保护服务？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;l  &lt;strong&gt;如何告诉Istio发挥保护能力？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将单体应用程序分解为一个个服务，为大型软件系统的开发和维护带来了诸多好处，比如更好的灵活性、可伸缩性和可复用性。但这也带来了一些安全问题：&lt;/p&gt;
&lt;p&gt;l  为了抵御中间人攻击，需要对流量进行加密&lt;/p&gt;
&lt;p&gt;l  为了提供灵活的服务访问控制，需要 mTLS（双向的安全传输层协议）和细粒度的访问策略&lt;/p&gt;
&lt;p&gt;l  要审计谁在什么时候做了什么，需要审计工具&lt;/p&gt;
&lt;p&gt;Istio 尝试提供全面的安全解决方案来解决这3个问题。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1428026/201809/1428026-20180911152917781-1726570633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，&lt;/p&gt;
&lt;p&gt;Istio 安全的三大目标是：&lt;/p&gt;
&lt;p&gt;l  默认安全（Security by default）：应用程序代码和基础结构，无需更改。&lt;/p&gt;
&lt;p&gt;l  深度防御（Defense in depth）：与现有安全系统集成，提供多层防御。&lt;/p&gt;
&lt;p&gt;l  零信任网络（Zero-trust network）：在不受信任的网络上，构建安全解决方案。&lt;/p&gt;
&lt;p&gt;为了实现这3个目标，Istio 安全功能提供了4大守护系统：&lt;/p&gt;
&lt;p&gt;l  强大的身份（Identity）系统&lt;/p&gt;
&lt;p&gt;l  健壮的策略（Policy）系统&lt;/p&gt;
&lt;p&gt;l  认证，授权和审计（AAA：Authentication，Authorization，Accounting）系统，用于保护服务和数据&lt;/p&gt;
&lt;p&gt;l  透明的 TLS 加密（Encryption）系统。&lt;/p&gt;
&lt;p&gt;就保护对象而言，Istio 安全系统可以抵御来自内部或外部的威胁，这些威胁主要针对服务网格内的端点（Endpoints），通信（Communication），平台（Platform）和数据（Data）。&lt;/p&gt;

&lt;p&gt;在安全方面，Istio具备3个远大的目标，配备了4大守护系统，那么它到底是通过怎样的架构实现这个目标的呢，又通过什么样的安全基础设施，和kubernetes配合呢？&lt;/p&gt;
&lt;h2&gt;2.1      Istio安全架构&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1428026/201809/1428026-20180911152937858-1121562017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，与Istio的4大守护系统相对应，Istio 中涉及安全的组件有：&lt;/p&gt;
&lt;p&gt;l  &lt;strong&gt;Pilot&lt;/strong&gt; ：将授权策略和安全命名信息分发给代理&lt;/p&gt;
&lt;p&gt;l  &lt;strong&gt;Proxy&lt;/strong&gt; ：实现客户端和服务端之间的安全通信&lt;/p&gt;
&lt;p&gt;l  &lt;strong&gt;Citadel&lt;/strong&gt; ：用于密钥和证书管理&lt;/p&gt;
&lt;p&gt;l  &lt;strong&gt;Mixer&lt;/strong&gt; ：管理授权和审计&lt;/p&gt;
&lt;p&gt;由此可见，Pilot不仅负责流量规则和策略的分发，还负责安全相关策略的下发，有点像皇上的贴身太监，负责宣读圣旨；Proxy有点像各州属的州官，负责奉天承运；Citadel有点像玉玺和虎符，负责鉴真去假；Mixer有点像三省六部，负责授权审计。&lt;/p&gt;
&lt;h2&gt;2.2      两个安全基本概念&lt;/h2&gt;
&lt;h3&gt;2.2.1        Identity&lt;/h3&gt;
&lt;p&gt;身份（Identity）是几乎所有安全基础架构的基本概念。在服务和服务的通信开始前，双方必须用其身份信息交换凭证，以达到相互认证的目的。在客户端，根据安全命名（secure naming）信息，检查服务端的标识，以查看它是否是该服务的授权运行程序；在服务端，服务端可以根据授权策略（authorization policies）信息，确定客户端可以访问哪些数据，审计其在什么时间访问了什么，拒绝未授权客户端的访问。&lt;/p&gt;
&lt;p&gt;在 Istio 身份模型中，Istio 使用一流的服务标识来确定服务的身份。这为表示人类用户，单个服务或一组服务提供了极大的灵活性和粒度。在没有此类身份的平台上，Istio 可以使用可以对服务实例进行分组的其他身份，例如服务名称。&lt;/p&gt;
&lt;p&gt;不同平台上的 Istio 服务标识：&lt;/p&gt;
&lt;p&gt;l  Kubernetes: Kubernetes 服务帐户&lt;/p&gt;
&lt;p&gt;l  GKE/GCE: 可以使用 GCP 服务帐户&lt;/p&gt;
&lt;p&gt;l  AWS: AWS IAM 用户/角色 帐户&lt;/p&gt;
&lt;p&gt;l  On-premises (non-Kubernetes): 用户帐户，自定义服务帐户，服务名称，istio 服务帐户或 GCP 服务帐户。&lt;/p&gt;
&lt;p&gt;做个类比，京东和天猫都有自己的一套非常成熟的服务账户系统，淘宝只需要复用天猫的账户系统即可，无需重新开发一套，这样我们就可以用天猫的账号，直接登录淘宝。而Istio也更倾向于复用业界一流的服务账户系统，如Kubernetes和AWS的，但也可以自定义服务账户，并按需复用Kubernetes的账户系统。&lt;/p&gt;
&lt;h3&gt;2.2.2  PKI &lt;/h3&gt;
&lt;p&gt;Istio PKI（Public Key Infrastructure）建立在 Istio Citadel 之上，可为每个工作负载提供安全且强大的工作负载标识。Istio 使用 X.509 证书来携带 SPIFFE 格式的身份信息。PKI 还可以大规模自动化地进行密钥和证书轮换。&lt;/p&gt;
&lt;p&gt;Istio 支持在 Kubernetes pod 和本地计算机上运行的服务。目前，Istio为每个方案使用不同的证书密钥配置机制，下面试举例Kubernetes方案的配置过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Citadel 监视 Kubernetes apiserver，为每个现有和新的服务帐户创建 SPIFFE 证书和密钥对。 Citadel 将证书和密钥对存储为 Kubernetes secrets。&lt;/li&gt;
&lt;li&gt;创建 pod 时，Kubernetes 会根据其服务帐户通过 Kubernetes secret volume 将证书和密钥对挂载到 pod。&lt;/li&gt;
&lt;li&gt;Citadel 监视每个证书的生命周期，并通过重写 Kubernetes secret 自动轮换证书。&lt;/li&gt;
&lt;li&gt;Pilot 生成安全命名信息，该信息定义了哪些服务帐户可以运行某个服务。接着Pilot 将安全命名信息传递给 Envoy。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如上一章节所言，Istio基于控制面组件，引入了一流的服务账户系统，结合强大的PKI，实现了对服务网格的安全守护。同时，Istio也开放了接口，让我们可以进行精细化的配置，全方位满足我们对服务的安全需求。&lt;/p&gt;
&lt;p&gt;服务安全，总是离不开两个具体过程：认证（Authentication）和鉴权（Authorization）。Istio通过Policy和MeshPolicy文件，实现对认证相关功能的定义；通过RbacConfig、ServiceRole和ServiceRoleBinding文件，实现对鉴权相关功能的启用和定义。&lt;/p&gt;
&lt;p&gt;让我们举个几个通俗的例子来区分认证和鉴权：&lt;/p&gt;
&lt;p&gt;进火车站需要提供身份证和火车票，身份证可以证明你就是你，这是认证；火车票可以证明你有权上那趟火车，这是授权。&lt;/p&gt;
&lt;p&gt;又例如，你要访问自己淘宝的购物车，需要先登录，这是认证。你要访问朋友的购物车，就需要他的允许，这是授权。&lt;/p&gt;
&lt;p&gt;再例如，有经验的朋友能发现浏览器经常会面对两个错误码：401和403。通常而言，401就是未登录的意思，需要认证；403就是禁止访问的意思，需要授权。&lt;/p&gt;
&lt;h2&gt;3.1      认证&lt;/h2&gt;
&lt;p&gt;Istio 提供两种类型的身份认证：&lt;/p&gt;
&lt;p&gt;l  传输身份认证，也称为服务到服务身份认证：对直连客户端进行验证。Istio 提供双向TLS作为传输身份认证的全栈解决方案。我们可以轻松启用此功能，而无需更改服务代码。这个解决方案：&lt;/p&gt;
&lt;p&gt;l  为每个服务提供强大的身份认定，以实现跨群集和跨云的互操作性。&lt;/p&gt;
&lt;p&gt;l  保护服务到服务通信和最终用户到服务通信。&lt;/p&gt;
&lt;p&gt;l  提供密钥管理系统，以自动执行密钥和证书生成，分发和轮换。&lt;/p&gt;
&lt;p&gt;l  来源身份认证，也称为终端用户身份认证：对来自终端用户或设备的原始客户端请求进行验证。Istio 通过 JSON Web Token（JWT）、Auth0、Firebase Auth、Google Auth 和自定义身份认证来简化开发者的工作，使之轻松实现请求级别的身份认证。&lt;/p&gt;
&lt;p&gt;在这两种情况下，Istio 都通过自定义 Kubernetes API 将身份认证策略存储在 Istio 配置存储（Istio config store）中。Pilot会在适当的时候进行同步，为每个Proxy更新其最新状态以及密钥。此外，Istio 支持在许可模式下进行身份认证，以帮助我们理解策略变更前后，服务的安全状态是如何变化的。&lt;/p&gt;
&lt;h3&gt;3.1.1        认证架构&lt;/h3&gt;
&lt;p&gt;我们可以使用身份认证策略，为 Istio 网格中接收请求的服务指定身份认证要求。我们使用 .yaml 文件来配置策略，策略将保存在 Istio 配置存储中。在任何策略变更后，Pilot 会将新策略转换为适当的配置，下发给Envoy，告知其如何执行所需的身份认证机制。Pilot 可以获取公钥并将其附加到 JWT 进行配置验证。或者，Pilot 提供 Istio 系统管理的密钥和证书的路径，并将它们安装到负载 Pod 中，以进行双向 TLS。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1428026/201809/1428026-20180911153006506-620145652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文多次提到双向TLS认证，让我们理解一下其在Istio里的实现。Istio 通过客户端和服务端各自配备的Envoy进行通信，也就是说，客户端和服务端的流量，是被各自的Envoy接管了的。对于客户端调用服务端，遵循的步骤是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Istio 将出站流量从客户端重新路由到客户端的本地 Envoy。&lt;/li&gt;
&lt;li&gt;客户端 Envoy 与服务端 Envoy 开始双向 TLS 握手。在握手期间，客户端 Envoy 还执行安全命名检查，以验证服务证书中提供的服务帐户是否有权运行目标服务。&lt;/li&gt;
&lt;li&gt;客户端 Envoy 和服务端 Envoy 建立了一个双向的 TLS 连接，Istio 将流量从客户端 Envoy 转发到服务端 Envoy。&lt;/li&gt;
&lt;li&gt;授权后，服务端 Envoy 通过本地 TCP 连接将流量转发到服务端的服务。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;3.1.2        认证策略配置&lt;/h3&gt;
&lt;p&gt;和其他的 Istio 配置一样，可以用 .yaml 文件的形式来编写认证策略，然后使用 Istioctl 二进制工具进行部署。如下图的配置，通过配置Policy文件，对reviews服务进行了传输身份认证的配置，要求其必须使用双向TLS做认证。&lt;/p&gt;
&lt;p&gt;apiVersion: &quot;authentication.Istio.io/v1alpha1&quot;&lt;/p&gt;
&lt;p&gt;kind: &quot;Policy&quot;&lt;/p&gt;
&lt;p&gt;metadata:&lt;/p&gt;
&lt;p&gt;  name: &quot;reviews&quot;&lt;/p&gt;
&lt;p&gt;spec:&lt;/p&gt;
&lt;p&gt;  targets:&lt;/p&gt;
&lt;p&gt;  - name: reviews&lt;/p&gt;
&lt;p&gt;    peers:&lt;/p&gt;
&lt;p&gt;  - mtls: {}&lt;/p&gt;
&lt;h2&gt;3.2      授权&lt;/h2&gt;
&lt;p&gt;Istio 的授权功能，也称为基于角色的访问控制（RBAC），为 Istio 服务网格中的服务提供命名空间级别，服务级别和方法级别的访问控制。它的特点是：&lt;/p&gt;
&lt;p&gt;l  基于角色的语义，简单易用。&lt;/p&gt;
&lt;p&gt;l  包含服务到服务和终端用户到服务两种授权模式。&lt;/p&gt;
&lt;p&gt;l  通过自定义属性灵活定制授权策略，例如条件，角色和角色绑定。&lt;/p&gt;
&lt;p&gt;l  高性能，因为 Istio 授权功能是在 Envoy 里执行的。&lt;/p&gt;
&lt;h3&gt;3.2.1        授权架构&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1428026/201809/1428026-20180911153024066-608406288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图显示了基本的 Istio 授权架构。和认证的生效过程一样，运维人员使用.yaml文件指定 Istio 授权策略。部署后，Istio 将策略保存在Istio Config Store中。Pilot 会一直监视 Istio 授权策略的变更，如果发现任何更改，它将获取更新的授权策略，并将 Istio 授权策略分发给与服务实例位于同一 pod 内的 Envoy 代理。&lt;/p&gt;
&lt;p&gt;每个 Envoy 代理都运行一个授权引擎，该引擎在运行时授权请求。当请求到达代理时，授权引擎根据当前授权策略评估请求上下文，并返回授权结果ALLOW或DENY。&lt;/p&gt;
&lt;h3&gt;3.2.2        授权策略配置&lt;/h3&gt;
&lt;p&gt;我们可以使用 RbacConfig 启用授权策略，并使用ServiceRole和ServiceRoleBinding配置授权策略。&lt;/p&gt;
&lt;p&gt;RbacConfig是一个网格维度的单例，其固定名称值为default，也就是说我们只能在网格中配置一个RbacConfig实例。与其他 Istio 配置对象一样，RbacConfig被定义为Kubernetes CustomResourceDefinition (CRD)对象。&lt;/p&gt;
&lt;p&gt;在RbacConfig中，运算符可以指定mode值，它可以是：&lt;/p&gt;
&lt;p&gt;l  OFF：禁用 Istio 授权。&lt;/p&gt;
&lt;p&gt;l  ON：为网格中的所有服务启用了 Istio 授权。&lt;/p&gt;
&lt;p&gt;l  ON_WITH_INCLUSION：仅对包含字段中指定的服务和命名空间启用 Istio 授权。&lt;/p&gt;
&lt;p&gt;l  ON_WITH_EXCLUSION：除了排除字段中指定的服务和命名空间外，网格中的所有服务都启用 Istio 授权。&lt;/p&gt;
&lt;p&gt;在以下示例中，为default命名空间启用了 Istio 授权，。&lt;/p&gt;
&lt;p&gt;apiVersion: &quot;rbac.Istio.io/v1alpha1&quot;&lt;/p&gt;
&lt;p&gt;kind: RbacConfig&lt;/p&gt;
&lt;p&gt;metadata:&lt;/p&gt;
&lt;p&gt;  name: default&lt;/p&gt;
&lt;p&gt;  namespace: Istio-system&lt;/p&gt;
&lt;p&gt;spec:&lt;/p&gt;
&lt;p&gt;  mode: 'ON_WITH_INCLUSION'&lt;/p&gt;
&lt;p&gt;  inclusion:&lt;/p&gt;
&lt;p&gt;    namespaces: [&quot;default&quot;]&lt;/p&gt;
&lt;p&gt;针对服务和命名空间启用授权后，我们还需要配置具体的授权策略，这通过配置ServiceRole和ServiceRoleBinding实现。与其他 Istio 配置对象一样，它们同样被定义为CRD对象。&lt;/p&gt;
&lt;p&gt;ServiceRole定义了一组访问服务的权限。ServiceRoleBinding向特定对象授予 ServiceRole，例如用户，组或服务。&lt;/p&gt;
&lt;p&gt;ServiceRole 和 ServiceRoleBinding 组合规定了： 允许谁在哪些条件下做什么，具体而言：&lt;/p&gt;
&lt;p&gt;l  谁指的是 ServiceRoleBinding 中的 subject 部分。&lt;/p&gt;
&lt;p&gt;l  做什么指的是 ServiceRole 中的 rule 部分。&lt;/p&gt;
&lt;p&gt;l  哪些条件指的是我们可以在 ServiceRole 或 ServiceRoleBinding 中使用Istio Attributes指定的 condition 部分。&lt;/p&gt;
&lt;p&gt;让我们再举一个简单的例子，如下图，ServiceRole和 ServiceRoleBinding的配置规定：将所有用户（user=“*”）绑定为（products-viewer）角色，这个角色可以对products这个服务发起GET或HEAD请求，但是其限制条件是请求头必须包含version，且值为v1或v2。&lt;/p&gt;
&lt;p&gt;apiVersion: &quot;rbac.Istio.io/v1alpha1&quot;&lt;/p&gt;
&lt;p&gt;kind: ServiceRole&lt;/p&gt;
&lt;p&gt;metadata:&lt;/p&gt;
&lt;p&gt;  name: products-viewer&lt;/p&gt;
&lt;p&gt;  namespace: default&lt;/p&gt;
&lt;p&gt;spec:&lt;/p&gt;
&lt;p&gt;  rules:&lt;/p&gt;
&lt;p&gt;  - services: [&quot;products&quot;]&lt;/p&gt;
&lt;p&gt;methods: [&quot;GET&quot;, &quot;HEAD&quot;]&lt;/p&gt;
&lt;p&gt;    constraints:&lt;/p&gt;
&lt;p&gt;    - key: request.headers[version]&lt;/p&gt;
&lt;p&gt;      values: [&quot;v1&quot;, &quot;v2&quot;]&lt;/p&gt;
&lt;p&gt;---&lt;/p&gt;
&lt;p&gt;apiVersion: &quot;rbac.Istio.io/v1alpha1&quot;&lt;/p&gt;
&lt;p&gt;kind: ServiceRoleBinding&lt;/p&gt;
&lt;p&gt;metadata:&lt;/p&gt;
&lt;p&gt;  name: binding-products-allusers&lt;/p&gt;
&lt;p&gt;  namespace: default&lt;/p&gt;
&lt;p&gt;spec:&lt;/p&gt;
&lt;p&gt;  subjects:&lt;/p&gt;
&lt;p&gt;  - user: &quot;*&quot;&lt;/p&gt;
&lt;p&gt;  roleRef:&lt;/p&gt;
&lt;p&gt;    kind: ServiceRole&lt;/p&gt;
&lt;p&gt;    name: &quot;products-viewer&quot;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;至此，我们做个简单的总结：&lt;/strong&gt;单体应用程序拆分成成千上百个服务后，带来了安全问题，Istio尝试在由服务组成的服务网格里，加入了一套全栈解决方案。这套方案里，Istio默默处理了大部分安全基础设施，但也暴露了认证和授权两个功能让用户进行自定义配置。我们通过Policy、MeshPolicy以及RbacConfig、ServiceRole、ServiceRoleBinding就可以完成对认证和授权环节所有功能的配置，而不需要侵入地改动任何服务的代码。&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 07:32:00 +0000</pubDate>
<dc:creator>PaaS小魔仙</dc:creator>
<og:description>凡是产生连接关系，就必定带来安全问题，人类社会如此，服务网格世界，亦是如此。 今天，我们就来谈谈Istio第二主打功能 保护服务。 那么，便引出3个问题： l Istio凭什么保护服务？ l Isti</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hwpaas/p/9628000.html</dc:identifier>
</item>
<item>
<title>vue axios数据请求get、post方法的使用 - 旭i丿</title>
<link>http://www.cnblogs.com/nixu/p/9627782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nixu/p/9627782.html</guid>
<description>&lt;p&gt;我们常用的有get方法以及post方法，下面简单的介绍一下这两种请求方法&lt;/p&gt;
&lt;p&gt;vue中使用axios方法我们先安装axios这个方法&lt;/p&gt;
&lt;p&gt;npm install --save axios&lt;/p&gt;
&lt;p&gt;安装之后采用按需引入的方法，哪个页面需要请求数据就在哪个页面里引入一下。&lt;/p&gt;
&lt;p&gt;import axios from 'axios'&lt;/p&gt;
&lt;p&gt;引入之后我们就可以进行数据请求了，在methods中创建一个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;methods：{
2 &lt;span&gt;    getInfo（）{
3         let url = &quot;url&quot;
4         axios.get(url).then((res)=&amp;gt;&lt;span&gt;{
5 &lt;span&gt;            console.log(res)
6 &lt;span&gt;        })      
7 &lt;span&gt;    }  
8 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们在mounted这个生命周期中进行调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;mounted（）{
2     this&lt;span&gt;.getInfo()  
3 }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以在控制台中查看数据，以上是一个简单的get方法数据请求，下面继续介绍一下post方法的使用，其实post和get的使用没有什么区别只是再加上一个参数就可以了，看一下我们的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 1 &lt;span&gt;methods：{
 2 &lt;span&gt;    postInfo（）{
 3         let url = &quot;url&quot;
 4         let params=new URLSearchParams();//这个方法在axios的官网中有介绍，除了这个方法还有qs这个方法
 5         params.append(&quot;key&quot;&lt;span&gt;,index) 
 6         params.append(&quot;key&quot;&lt;span&gt;,index)
 7         axios.post(url,params).then((res)=&amp;gt;&lt;span&gt;{
 8 &lt;span&gt;            console.log(res)
 9 &lt;span&gt;        })
10 &lt;span&gt;    }    
11 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样在mounted这个生命周期中进行调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;mounted（）{
2     this&lt;span&gt;.postInfo()
3 }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 11 Sep 2018 07:08:00 +0000</pubDate>
<dc:creator>旭i丿</dc:creator>
<og:description>我们常用的有get方法以及post方法，下面简单的介绍一下这两种请求方法 vue中使用axios方法我们先安装axios这个方法 npm install --save axios 安装之后采用按需引入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nixu/p/9627782.html</dc:identifier>
</item>
<item>
<title>vue基础知识整理 - 青賢</title>
<link>http://www.cnblogs.com/endymion/p/9627728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endymion/p/9627728.html</guid>
<description>&lt;h2 id=&quot;实例-vue是由实例组成的&quot;&gt;实例-vue是由实例组成的&lt;/h2&gt;
&lt;p&gt;根实例&lt;br/&gt;组件也是实例&lt;/p&gt;
&lt;p&gt;以$开头的单词都是代表着vue的实例属性实例方法&lt;/p&gt;
&lt;h2 id=&quot;vue实例中的生命周期钩子&quot;&gt;vue实例中的生命周期钩子&lt;/h2&gt;
&lt;p&gt;8个生命周期函数&lt;br/&gt;这几个函数不用放到methods里面&lt;/p&gt;
&lt;h2 id=&quot;计算属性&quot;&gt;计算属性&lt;/h2&gt;
&lt;p&gt;尽量使用计算属性而不是watch！&lt;/p&gt;
&lt;p&gt;可以配合着计算属性使用setter和getter&lt;/p&gt;
&lt;h2 id=&quot;绑定样式&quot;&gt;绑定样式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;对于非行内样式&lt;br/&gt;方法一：&lt;br/&gt;&lt;code&gt;:class=“{becomeRed: isActivated}”&lt;/code&gt;&lt;br/&gt;其中isActivated放到data里面，如果是true，就有becomeRed这个class，否则就没有。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方法二：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;:class=“[becomeRed]”

data:{ becomeRed: “”}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;becomeRed里面放类名&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于行内样式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;:style=“styleObj”
//或
:style=“[styleObj,
{fontSize: '20px'}]”

data:{
    styleObj:{
        color:”black”
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;v-if和v-show&quot;&gt;v-if和v-show&lt;/h2&gt;
&lt;p&gt;后者只是隐藏而已，dom元素还在；前者直接杀掉dom元素。&lt;/p&gt;
&lt;p&gt;使用后者性能更高。&lt;br/&gt;如果要使用v-if，而且這個要隱藏的組件以後還會顯示，我們可以在這個組件標籤裡面加上一個&lt;code&gt;v-once&lt;/code&gt;，以此來增加性能，不讓這個組件死掉。&lt;/p&gt;
&lt;h2 id=&quot;v-if和v-else&quot;&gt;v-if和v-else&lt;/h2&gt;
&lt;p&gt;两个东西要连着写！&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;数组&lt;/h2&gt;
&lt;p&gt;如果想改变数组，界面跟着变。不能使用方括号来改。&lt;br/&gt;有三种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用数组遍历函数&lt;/li&gt;
&lt;li&gt;改变数组的引用&lt;/li&gt;
&lt;li&gt;set方法：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;Vue.set(vm.userInfo,1,5)
//或
vm.$set(vm.userInfo,2,10)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;template占位符&quot;&gt;template占位符&lt;/h2&gt;
&lt;p&gt;起一个包裹的作用&lt;/p&gt;
&lt;h2 id=&quot;向对象中注入新的属性&quot;&gt;向对象中注入新的属性&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;改变对象的引用&lt;/li&gt;
&lt;li&gt;set方法：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;Vue.set(vm.userInfo,”address”,”beijing”)
//或
vm.$set(vm.userInfo,”address”,”beijing”)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用自定义组件时&quot;&gt;使用自定义组件时&lt;/h2&gt;
&lt;h3 id=&quot;is属性&quot;&gt;is属性&lt;/h3&gt;
&lt;p&gt;在table、ul、select下面使用自定义标签时，使用is属性解决模板标签的bug&lt;/p&gt;
&lt;h3 id=&quot;data&quot;&gt;data&lt;/h3&gt;
&lt;p&gt;不应该是个对象，而是个函数，返回content，这样的话，返回一个引用，每个子组件都可以拥有独立的数据，互不干扰。&lt;/p&gt;
&lt;h2 id=&quot;获取dom&quot;&gt;获取dom&lt;/h2&gt;
&lt;h3 id=&quot;对原生标签&quot;&gt;对原生标签&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ref=‘hello’

this.$refs.hello&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对自定义标签&quot;&gt;对自定义标签&lt;/h3&gt;
&lt;p&gt;使用ref返回的是引用。&lt;/p&gt;
&lt;h2 id=&quot;父子组件的数据传递&quot;&gt;父子组件的数据传递&lt;/h2&gt;
&lt;h3 id=&quot;父传子&quot;&gt;父传子&lt;/h3&gt;
&lt;p&gt;通过属性的形式传递数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;counter :count = &quot;0&quot;&amp;gt;&amp;lt;/counter&amp;gt;//传数字


    &amp;lt;counter count = &quot;1&quot;&amp;gt;&amp;lt;/counter&amp;gt;//传字符串&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单向数据流：&lt;br/&gt;父组件可以向子组件传递数据，但是子组件不能修改父组件传过来的东西。因为有可能其他组件还在使用父组件传递过来的数据，会影响其他组件。&lt;/p&gt;
&lt;p&gt;如果要修改，得copy一份副本，修改这个副本&lt;/p&gt;
&lt;h3 id=&quot;子传父&quot;&gt;子传父&lt;/h3&gt;
&lt;p&gt;激发事件emit&lt;/p&gt;
&lt;h2 id=&quot;参数校验&quot;&gt;参数校验&lt;/h2&gt;
&lt;p&gt;props后面不写数组了，改写成一个对象，like this：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;props: {
    content: {
        type: String,
        validator: function(value) {
            return (value.length &amp;gt; 5)
        }
    },
    index: Number,
    num: [String,Number],
    fuck: {
        type: String,
        required: false,
        default: 'default value'
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;props特性&quot;&gt;props特性&lt;/h2&gt;
&lt;p&gt;父组件向子组件传属性，子组件在props里面刚好声明了，即父传子接。&lt;br/&gt;父组件和子组件有一种对应特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这个传递属性不会在dom上显示；&lt;/li&gt;
&lt;li&gt;子组件接受了props后，子组件就可以使用差值表达式将其显示出来。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;非props特性&quot;&gt;非props特性&lt;/h2&gt;
&lt;p&gt;父组件向子组件传属性，但是子组件在props里面却没有声明该属性。&lt;br/&gt;即父传子不接。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;子组件没办法获取该属性的内容，因为没有获取；&lt;/li&gt;
&lt;li&gt;非props特性会显示在dom元素里面的。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;如何给自定义组件绑定原生事件&quot;&gt;如何给自定义组件绑定原生事件？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;方法一：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;给子组件绑定一个原生事件，触发子组件函数；&lt;/li&gt;
&lt;li&gt;在子组件函数里面监听，然后$emit一个自定义事件给自定义组件即可&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;方法二：&lt;br/&gt;直接在自定义事件上面加native修饰符，这样写：&lt;br/&gt;&lt;code&gt;@click.native = “handleClick”&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何解决复杂的组件间传值&quot;&gt;如何解决复杂的组件间传值？&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;vuex&lt;/li&gt;
&lt;li&gt;发布订阅模式（总线机制/Bus/观察者模式）&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总线机制&quot;&gt;总线机制&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;child content=&quot;旭凤&quot;&amp;gt;&amp;lt;/child&amp;gt;
    &amp;lt;child content=&quot;锦觅&quot;&amp;gt;&amp;lt;/child&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;

    Vue.prototype.bus = new Vue();

    Vue.component('child',{
      data: function() {
        return {selfContent: this.content}
      },
      props: ['content'],
      template: &quot;&amp;lt;div @click='handleChildClick'&amp;gt;{{selfContent}}&amp;lt;/div&amp;gt;&quot;,
      methods: {
        handleChildClick: function() {
          this.bus.$emit('change', this.selfContent);
        }
      },
      mounted: function() {
        var that = this;
        this.bus.$on('change', function(msg) {
          that.selfContent = msg;
        })
      }
    });

    var app = new Vue({
      el: '#app'
    });
  &amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;插槽&quot;&gt;插槽&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;slot&amp;gt;默认内容&amp;lt;/slot&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;具名插槽&quot;&gt;具名插槽&lt;/h3&gt;
&lt;p&gt;给插槽起一个名字，插到指定的位置&lt;/p&gt;
&lt;h3 id=&quot;作用域插槽&quot;&gt;作用域插槽&lt;/h3&gt;
&lt;p&gt;当子组件做循环或某一部分它的dom结构应该由外部传进来的时候，使用作用域插槽。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;sweet&amp;gt;
      &amp;lt;template slot-scope='props'&amp;gt;
        &amp;lt;h1&amp;gt;{{props.item}}&amp;lt;/h1&amp;gt;
      &amp;lt;/template&amp;gt;
    &amp;lt;/sweet&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;

    Vue.component('sweet',{
      data: function() {
        return {
          list: ['錦覓', '旭鳳', '潤玉']
        }
      },
      template:
      `&amp;lt;div&amp;gt;
        &amp;lt;ul&amp;gt;
          &amp;lt;slot
            v-for='item in list'
            :item='item'
          &amp;gt;&amp;lt;/slot&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/div&amp;gt;`
    })
    var app = new Vue({
      el: '#app'
    });
  &amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;動態組件&quot;&gt;動態組件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;component :is=“type”&amp;gt;&amp;lt;/component&amp;gt;&lt;/code&gt;&lt;br/&gt;這個type是根實例data裡面的一個屬性，用於替換component變成你自定義過的自定義組件。&lt;/p&gt;
&lt;p&gt;可以用於替代v-if的效果！&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;動畫&quot;&gt;動畫&lt;/h2&gt;
&lt;p&gt;过渡动态效果&lt;/p&gt;
&lt;h3 id=&quot;渐入&quot;&gt;渐入&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/09/06/5b9144610c7e9.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;渐出&quot;&gt;渐出&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/09/06/5b914486504a0.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;transition name='fade'&amp;gt;
      &amp;lt;div v-show='seen'&amp;gt;香蜜沉沉烬如霜&amp;lt;/div&amp;gt;
    &amp;lt;/transition&amp;gt;
    &amp;lt;button type=&quot;button&quot; @click='handleBtnClick'&amp;gt;change&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;

&amp;lt;style&amp;gt;
    .fade-enter, .fade-leave-to{
      opacity: 0;
    }

    .fade-enter-active, .fade-leave-active{
      transition: opacity 3s;
    }
  &amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;animate.css&quot;&gt;Animate.css&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;keyframes自定义的标签动画&lt;/li&gt;
&lt;li&gt;导入animate库&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;transition
         name=&quot;fade&quot;
         enter-active-class=&quot;animated swing&quot;
         leave-active-class=&quot;animated shake&quot;
      &amp;gt;
        &amp;lt;div v-show='seen'&amp;gt;香蜜沉沉烬如霜&amp;lt;/div&amp;gt;
      &amp;lt;/transition&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;如何让刷新之后自动显示动画&quot;&gt;如何让刷新之后自动显示动画？&lt;/h4&gt;
&lt;p&gt;在transition标签里面加上这么两个属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;appear

appear-active-class=“animated swing”&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;如何让keyframes动画和transiton动画融合在一起&quot;&gt;如何让keyframes动画和transiton动画融合在一起？&lt;/h4&gt;
&lt;p&gt;都放到enter和leave的那两个active class里面去。&lt;/p&gt;
&lt;h4 id=&quot;两者时间不统一如何设定动画时间&quot;&gt;两者时间不统一，如何设定动画时间？&lt;/h4&gt;
&lt;p&gt;在transition标签里面加上这么几条属性即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;:duration=“{enter: 5000, leave: 10000}”

//或
:duration=&quot;1000&quot;

//或
type=&quot;transition&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;js动画&quot;&gt;js动画&lt;/h3&gt;
&lt;p&gt;使用js动画钩子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;transition
         name=&quot;fade&quot;
         @before-enter=&quot;handleBeforeEnter&quot;
         @enter=&quot;handleEnter&quot;
         @after-enter=&quot;handleAfterEnter&quot;
      &amp;gt;
        &amp;lt;div v-show='seen'&amp;gt;香蜜沉沉烬如霜&amp;lt;/div&amp;gt;
      &amp;lt;/transition&amp;gt;

methods: {
          handleBtnClick: function() {
            this.seen = !this.seen
          },
          handleBeforeEnter: function(el) {
            el.style.color = 'pink';
          },
          handleEnter: function(el, done) {
            setTimeout(()=&amp;gt;{
              el.style.color = 'blue'
            },2000);
            setTimeout(()=&amp;gt;{
              done()
            },4000);
          },
          handleAfterEnter: function(el) {
            el.style.color = 'red'
          }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用velocity.js来创作js动画&quot;&gt;使用velocity.js来创作js动画&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  methods: {
          handleBtnClick: function() {
            this.seen = !this.seen
          },
          handleBeforeEnter: function(el) {
            el.style.opacity = 0;
          },
          handleEnter: function(el, done) {
            Velocity(el,{
              opacity: 1
            },{
              duration: 1000,
              complete: done
            })
          },
          handleAfterEnter: function(el) {
            console.log('4s是垃圾！')
          },

          handleBeforeLeave: function(el) {
            el.style.opacity = 1;
          },
          handleLeave: function(el, done) {
            Velocity(el,{
              opacity: 0
            },{
              duration: 1000,
              complete: done
            })
          },
          handleAfterLeave: function(el) {
            console.log('我走了！')
          }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多元素过渡效果&quot;&gt;多元素过渡效果&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;對原生組件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;style&amp;gt;
      .fade-enter, .fade-leave-to {
        opacity: 0;
      }
      .fade-enter-active, .fade-leave-active {
        transition: opacity 1s;
      }
    &amp;lt;/style&amp;gt;


  &amp;lt;transition
         name=&quot;fade&quot;
         mode=&quot;out-in&quot;
      &amp;gt;
        &amp;lt;div v-if='seen' key='flower'&amp;gt;錦覓&amp;lt;/div&amp;gt;
        &amp;lt;div v-else key='bird'&amp;gt;旭鳳&amp;lt;/div&amp;gt;
      &amp;lt;/transition&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;對自定義組件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;child v-if=“show”&amp;gt;&amp;lt;/child&amp;gt;
&amp;lt;child-one v-else&amp;gt;&amp;lt;/child-one&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;對動態組件&lt;br/&gt;直接用component標籤替換這兩child，就可以直接使用。效果一樣哦。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;列表過渡&quot;&gt;列表過渡&lt;/h3&gt;
&lt;p&gt;使用transition-group標籤代替transition標籤，來包裹列表，其他部分使用起來和前面一樣。&lt;/p&gt;
&lt;h4 id=&quot;原理&quot;&gt;原理&lt;/h4&gt;
&lt;p&gt;相當於在每一個表項div外面包裹了一個transition標籤，對它使用一些如v-enter的class。&lt;/p&gt;
&lt;h3 id=&quot;動畫封裝&quot;&gt;動畫封裝&lt;/h3&gt;
&lt;p&gt;不用css動畫了，用js動畫。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/09/07/5b91f19407ae4.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 07:00:00 +0000</pubDate>
<dc:creator>青賢</dc:creator>
<og:description>实例 vue是由实例组成的 根实例 组件也是实例 以$开头的单词都是代表着vue的实例属性实例方法 vue实例中的生命周期钩子 8个生命周期函数 这几个函数不用放到methods里面 计算属性 尽量使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/endymion/p/9627728.html</dc:identifier>
</item>
<item>
<title>css布局 - 垂直居中布局的一百种实现方式（更新中...） - xing.org1^</title>
<link>http://www.cnblogs.com/padding1015/p/9577958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/padding1015/p/9577958.html</guid>
<description>&lt;h2&gt;&lt;span&gt;首先将垂直居中的现象和实现方式两大方向细分类如下：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911135156217-921247337.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来逐条累加不同情况下的垂直居中实现。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;一、父元素高度固定时，单行文本 | 图片的垂直居中&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1. line-height行高简单粗暴实现法：line-height：Npx（N = 与元素高度相同的值）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. vertical-middle上场：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、父元素高度固定时，多行文本的垂直居中&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1. 帮多行文本找一个继父来领养他，让继父弥补父元素给他带来的伤害（行高和水平居中对齐的样式修改）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. margin负边距简单处理一下底部小“裂痕”&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、父元素高度 不 固定时，单行文本 | 图片的绝对垂直居中&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1. 新增兄弟节点实力辅助，目标元素轻松上王者&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、父元素高度 不 固定时，多行文本的绝对垂直居中&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1. 新增兄弟节点实力辅助，目标元素轻松上王者&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;五、目标元素宽高固定时，元素的水平垂直居中（经典弹层布局有宽高）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 1. absolute定位飘起来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2. 上左50%方位值，先让左上角处于视图中心点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3. margin负边距，再让身子中心点挪到视图中心点&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;六、目标元素宽高也不固定时，元素依然水平垂直居中（经典弹层布局无宽高）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 1. absolute定位飘起来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2. 上左50%方位值，先让左上角处于视图中心点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3. translate -50%偏移，实现自动化偏移相应数值到中心点&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;七、图片和多行文本的 两列垂直居中（经典布局难题）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1. 两端对齐交给爹地&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 兄弟齐心，vertical-align: middle;实现居中布局&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;八、堪称万能钥匙的公共垂直居中解法。无视父元素高度是否固定！无视文字多少行！&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;（一）灵魂辅助的vertical-align:middle值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二）拥有家世渊源的table来救场&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）带着尚方宝剑的display: table-cell&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（四）小机灵鬼儿translate对应方向上的-50%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（五）flex大大一句话 水平垂直全拿下&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;&lt;strong&gt;一、最简单的，父元素高度固定的单行文本&lt;/strong&gt;&lt;strong&gt;(或单个图片)&lt;/strong&gt;&lt;strong&gt;垂直居中&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; 实现方式：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、&lt;strong&gt;line-height行高简单粗暴实现法：&lt;/strong&gt;&lt;strong&gt;line-height：Npx（N = 与元素高度相同的值）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;正如N的值那样，这种解决方法就是要盒模型是有高度设置的。举例：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;假如设计稿元素高度是300px，行高就设置为300px，这样，就可以实现垂直居中的问题。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.box1{

    text-align: center;

    line-height: 300px;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;如图：&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911141308472-1973937831.png&quot; alt=&quot;&quot;/&gt; &lt;span&gt;影视二字就可以垂直居中了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;可行性分析&lt;/strong&gt;&lt;/span&gt;：就像图片中看到的那样，只有两个字，他们排在一行不会换行。所以实际应用中要确保一定是单行文本不会换行。因为一旦换行的话，行高就会应用于文字，由于行高过大的原因，会导致剩下的文字跑出画面了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;如右图：&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911141333166-1526862360.png&quot; alt=&quot;&quot;/&gt; &lt;span&gt;这种情况也可以使用overflow：hidden；做一下保障措施。不过治标不治本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;另外补充一点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;有人看到这个现象可能会想是因为line-height导致的，那我给文字包裹一个框比如span，然后给span文字元素单独设置一个正常的行高不久可以了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;真的可以了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;看图：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911141453402-573592604.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;中间文字部分就是span包裹的，并设置如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.box1 {
    text-align: center;
    line-height: 300px;
}
.span1 {
    line-height: 21px;
    display: inline-block;
}　
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;结果怎么样呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;不仅文字和行数少一点的时候，不能完全的垂直居中。甚至文字再多会有这样的现象：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911141815580-2134771717.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;可见这种假设不合理。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;所以单独设置一个行高就解决垂直居中问题看似大快人心，但是代码很不健壮，只局限于特别个别的情况。经不起考验。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;那好，现在我直接使用这个方法实现一个宽高固定的图片垂直居中应该也很赞了吧？！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;结果一顿操作这个结果我很不满意：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911141852799-2131427746.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;这不用比较也知道，我的图片没有上下垂直居中啊！毛线。那个标题还那么深，实例打脸。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;但究竟是因为什么呢？我往图片后边写了一个x辅助理解，这下明白了吧！&lt;strong&gt;图片默认是文本基线对其的。&lt;/strong&gt;文本垂直居中，就到垂直正中间那里。但是图片底部为了与文字底部对其，所以留给顶部的空间就不多了。没有x的时候会有一个空白的换行节点在捣鬼，这也是为什么单独文字的时候看不出毛病，单独图片使用同样的方法却有问题的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911141925943-753258833.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;啊，这就是听张鑫旭老师讲课的收获！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;接下来，要实现单个图片的垂直居中效果我只需要让图片和文字水平一条线垂直对其就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. &lt;strong&gt;vertical-middle上场：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.box1 {
    text-align: center;
    line-height: 300px;
}
img {
    vertical-align: middle;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;line-height配合vertical-align，搞定。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;但是真的要1像素走查的时候，你又会发现，这种做法还是不能完全完全的垂直居中，底部还是差那么一两像素。这个问题接下来再说。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、&lt;strong&gt;父元素高度固定的多行文本垂直居中&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这种效果其实和中间只有一个图片一个道理，因为你需要帮多行文本找一个继父来领养他，所以结构上就是这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;content-box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;我是多行文本。多行文本水平垂直居中的原理跟上一页图片的实现是一样的，区别在于要把多行文本所在的容器的display水平转换成和图片一样的，也就是inline-block，以及重置外部继承的text-align和line-height属性值。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;中间content这个元素就好比一个图片，要实现他的水平垂直居中，那么他就得变成一个inline-block元素，（图片本身就是inline-block所以在上一段才没有强调。）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.content-box {
    line-height: 300px;
    text-align: center;
}
.content {
    width: 500px;
    display: inline-block;
    vertical-align: middle;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;不出乎意料的这里出现了上边两个出现过的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.因为父元素行高的原因，content内部行高过高导致文字行距过大：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911142224668-617254906.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以content内部就要单独设置行高以覆盖继承自父元素的值：&lt;span&gt;ling-height:21px;&lt;/span&gt;（一般改为比字体大小大个4、5像素即可。）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2. &lt;/span&gt;&lt;span&gt;因为父元素要对inline-block的子元素content实行&lt;span&gt;text-align：center；&lt;/span&gt;限制，导致content内部的文字都居中了，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以需要&lt;span&gt;text-align:left;&lt;/span&gt;纠正。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哇，我惊喜的发现，现在文字行数增多或减少，好像真的看上去垂直居中了哎！&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;等等，高兴的太早，又发现和单个图片垂直居中的相同问题，顶部和底部预留的空间好像不一般多啊！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911142517585-1477877905.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红框是我加的before、after等伪类，以显示的让我们看到上下的剩余空间相差多少。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一点真的和之前的图片问题很接近：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911142544020-959031934.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我把两个例子的代码挪到一个html页面，惊奇的发现，底部剩余空间都是比顶部少4像素！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是，一不做二不休，我直接使用margin负值让元素再之前的基础上向上4像素，竟真的实现了绝对的垂直居中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911142605012-2023343954.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结：要想绝对的垂直居中，有了上边的核心代码设置外，还要加一个&lt;span&gt;margin-top: -4px;&lt;/span&gt;就可以啦！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;不过具体情况具体分析，换个页面，字体大小不一样，对行高的影响也不一样，自然偏差也不一定是4像素，新的负数值再重新计算即可。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;1、父子齐心，line-height断难题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;2、鼎鼎大名，margin负边距。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;span&gt;可行性分析：&lt;/span&gt;这种再根据当前页或当前元素字体大小调整margin负边距大小值的做法实属有点不妥。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;不过还好最近跟大神学了一招“万能胶”。这里暂且按下不表。请看下文如何不动声色且完美的解决这偏差的几像素。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、&lt;strong&gt;父元素高度不固定，单行文本居中&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;既然父元素高度不固定，那肯定就没有line-height秀的机会了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;（特别说明，第三条系列中的父元素height值只是为了撑开然后填充背景色看的。高度不确定不代表没有高度，所以这里是高度值随意改变，内部子元素永远垂直居中的独秀专场）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;那我们派谁打头阵呢？只见父元素眯眼一想，span，让你的vertical-align出来表演一下吧！我再给你生个小弟弟你们一起秀！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;h3&gt;1. 单个图片的绝对垂直居中&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911142857118-290369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;不卖关子，直接上代码和解释：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://img1.mukewang.com/user/57a6f85b00013c7202090209-100-100.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;assist&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.box {
    height: 200px;
    text-align: center;
    background: #f5f5f5;
    border: 1px solid #eee;
}
img {
    /* 第一步，元素inline-block化，因为图片本身是所以省去。 */
    /* display:inline-block; */
    /* 第三步，图片和辅助元素同时垂直居中对齐 */
    vertical-align: middle;
}
span.assist {
    /* 第二步，0宽度100%高度的辅助元素 */
    display: inline-block;
    height: 100%;
    /* 第三步，图片和辅助元素同时垂直居中对齐 */
    vertical-align: middle;
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;所谓三步走策略，这里偷懒把注释都写进代码里了。越是经典的解决方法越是直接背诵就好了。我就不喋喋不休分散看官的注意力了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;再不懂的去慕课网听张老师的课程。链接(3分27秒左右)：&lt;a href=&quot;https://www.imooc.com/video/10407%20%20%20&quot; target=&quot;_blank&quot;&gt;https://www.imooc.com/video/10407&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;p&quot;&gt;&lt;span&gt; 2. &lt;/span&gt;&lt;span&gt;单行文本的绝对垂直居中&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911143308711-1001283029.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box box2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;txts&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;      大小不固定的文字垂直居中
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;      多行文本也可以哦！
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.box2 span.txts {
    /* inline-block化，形成块状整体才适用垂直居中。 */
    display: inline-block;
    vertical-align: middle;
}
.box2 i {
    display: inline-block;
    height: 100%;
    vertical-align: middle;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;这里css有偷懒，只是针对文本的设置，其他普通公用设置见上边第1条单个图片绝对垂直居中那里。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;四、父元素高度不固定，多行文本居中&lt;/span&gt;&lt;/h2&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt; 还是给文本生个小弟弟陪他玩耍：&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;主体元素inline-block化&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;0宽度100%高度辅助元素&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;vertical-align：middle&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;见第三条第二点。同理，单行文本换成多行即可。。&lt;/span&gt;。&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;五、&lt;strong&gt;目标元素宽高固定的水平垂直居中（经典弹层布局）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911143547921-834586662.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;这个很常见了，就不多说什么了：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;直接上代码:&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;author&quot; content=&quot;guojufeng@ xing.org1^&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;宽高确定的正经弹层&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    .mask{
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      background: rgba(0,0,0,.5);
    }
    .layer{
      width: 300px;
      height: 300px;
      position: absolute;
      top: 50%;
      left: 50%;
      /* margin: -150px auto auto -150px; */
      margin-top: -150px;
      margin-left: -150px;


      text-align: center;
      background: #fff;
      border-radius: 8px;
    }
    span{
      padding: 100px;
      display: inline-block;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;我是body里的内容，哦吼吼！xing.org1^&amp;lt;/h1&amp;gt;
  &amp;lt;!-- 蒙层 --&amp;gt;
  &amp;lt;div class=&quot;mask&quot;&amp;gt;
    &amp;lt;!-- 弹层 - 垂直居中实现 --&amp;gt;
    &amp;lt;div class=&quot;layer xingorg1&quot;&amp;gt;
      &amp;lt;span&amp;gt;我是宽高固定的弹层元素，我实现了垂直居中。&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;p&quot;&gt;&lt;span&gt;六、目标元素宽高也不固定的水平垂直居中（经典弹层布局）&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911143735241-474355112.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;这次重点说说来救场的transform：translate(负值%);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;css3中，translate就是指定元素像对应方向偏移，x是水平偏移，y是垂直方向的偏移，因为这篇是方法汇总，不做过多介绍，请自行查看w3c或实验。也看移驾这篇文章：&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/9550142.html&quot;&gt;&lt;span&gt;https://www.cnblogs.com/padding1015/p/9550142.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;不过他又一个&lt;span&gt;&lt;strong&gt;屌炸天的特性&lt;/strong&gt;&lt;/span&gt;是，当偏移数值的单位为百分比的时候，会相对于本身的长宽来计算偏移值。比如元素的宽度是300px的时候，我们都知道想要让他再向左移动50%宽度，配合上left：50%；就能实现居中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;刚好，translateX(-50%)自动计算得到的就是50%宽度的值。所以，我们不需要知道目标元素的宽高也一样能实现居中了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;对于这一特性，这个慕课网问答这里讲的很好：http://www.imooc.com/qadetail/129282&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911143844981-2071145723.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;他除了适用于这个弹层的场景，同样适用于其他场景的居中。因为即使不浮动，translate移动对兄弟元素没有影响。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;请看：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911143902949-41591191.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;这种现象和margin移动不一样。只不过其他场景使用translate有点大材小用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;关键点分析：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;利用&lt;/strong&gt;&lt;strong&gt;transform来实现垂直居中布局&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;box盒使用固定宽度的width+margin auto，实现水平居中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;position：relative，top： 50%；实现垂直方向的偏移。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;因为没有高度固定，所以无法确切的使用margin-top负值实现垂直居中&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;但是css3中的transform的translate属性，会自动根据盒子高度计算偏移值。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;所以：&lt;strong&gt;position:relative;&lt;/strong&gt;  +  &lt;strong&gt;top: 50%;&lt;/strong&gt;  +  &lt;strong&gt;transform:translateY(-50%)；&lt;/strong&gt;可以实现垂直方向的绝对居中效果。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;如果将relative换成absolute，想实现水平垂直居中的弹窗效果时：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;因为固定宽度，可以使用margin负值，即margin-left： -300px;实现水平布局。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;但是，学习就要举一反三，我们同样可以&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;利用&lt;/strong&gt;&lt;strong&gt;transform来实现水平居中布局&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;position: absolute;

left: 50%;

transform: translateX(-50%);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;一样可以实现！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; 那么，如果跟之前的垂直居中合并起来的话，transform是不是也可以写一条呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
transform: translate(-50%,-50%);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好了，废话说的再多也不如贴源码运行一探究竟：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;author&quot; content=&quot;guojufeng@ xing.org1^&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;translateY实现垂直居中&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    html,
    body,
    ul {
      height: 100%;
      margin: 0;
    }
    .mask {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      background: rgba(0, 0, 0, .5);
    }

    .layer {
      position: absolute;
      top: 50%;
      left: 50%;
      /* transform: translateX(-50%) translateY(-50%); 这种写法也可以，相当于写两个translate*/
      transform: translate(-50%,-50%);
      text-align: center;
      background: #fff;
      border-radius: 8px;
    }
    .box {
      /* width: 500px;*/
      /* height: 350px;  */
      padding: 30px 10px;
      background: rgba(255, 51, 255, 0.2901960784313726);
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;我是body里的内容，哦吼吼！xing.org1^&amp;lt;/h1&amp;gt;
  &amp;lt;h1&amp;gt;translate负值实现元素的水平垂直居中&amp;lt;/h1&amp;gt;
  &amp;lt;!-- 蒙层 --&amp;gt;
  &amp;lt;div class=&quot;mask&quot;&amp;gt;
    &amp;lt;!-- 弹层 - 垂直居中实现 --&amp;gt;
    &amp;lt;div class=&quot;layer xingorg1&quot;&amp;gt;
      &amp;lt;div class=&quot;box&quot;&amp;gt;
        &amp;lt;ul&amp;gt;
          &amp;lt;li&amp;gt;关键点&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;left: 0;
            right: 0;
            bottom: 0;
            margin: auto;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;top: 50%;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;transform: translateY(-50%);&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;这些li是为了撑开box的高度&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;p&quot;&gt;&lt;span&gt;七、图片和多行文本两列的垂直居中（经典布局难题）&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;p&quot;&gt;&lt;span&gt;1、兄弟们一起 vertical-align：middle；&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;先看诱惑人的结果，就是不管文字单行还是多行，不管图片改成多大，都能实现的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911144333375-1639944926.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;然后再说解决方法。核心就是用了&lt;span&gt; vertical-align:middle;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;html结构：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单行文字&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://img1.mukewang.com/user/57a6f85b00013c7202090209-40-40.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;多行文字&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;文字文字文字文字&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;文字文字文字文字&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://img1.mukewang.com/user/57a6f85b00013c7202090209-40-40.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;因为vertical-align只对inline/inline-block元素起作用，而浮动会让元素block水平化，就不能使用vertical-align对齐了&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://img1.mukewang.com/user/57a6f85b00013c7202090209-40-40.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;关键点1：外边的box实现两端对齐&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为vertical-align只对inline/inline-block元素起作用，而浮动会让元素block水平化，就不能使用vertical-align对齐了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以这里才用&lt;span&gt;  text-align: justify;  &lt;/span&gt;附加给父元素，实现图文的两端对齐效果&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;关键点2：文本span元素  &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vertical-align: middle;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;这里文本因为需要有个宽度值限制，所以inline-block化了，要知道，不是必须即可。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;关键点3：img元素&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vertical-align: middle;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;
&lt;h2 class=&quot;p&quot;&gt;&lt;span&gt;八、堪称万能钥匙的公共垂直居中解法。无视父元素高度是否固定！无视文字多少行！&lt;/span&gt;&lt;/h2&gt;

&lt;h3&gt;&lt;span&gt;（一）&lt;strong&gt;灵魂辅助的vertical-align:middle值&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;具体见上边第三条的例子，用一个span空标签放到需要垂直居中元素的后边或者前边，作为辅助兄弟元素。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;同时给这个辅助元素和目标元素&lt;span&gt;vertical-align:middle;&lt;/span&gt;  &lt;span&gt;display:inline-block;&lt;/span&gt;一顿操作即可。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;css 中有一个用于竖直居中的属性 vertical-align，在父元素设置此样式时，会对inline-block类型的子元素都有用。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;（二）&lt;strong&gt;拥有家世渊源的&lt;/strong&gt;&lt;strong&gt;table&lt;/strong&gt;&lt;strong&gt;来救场&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;就像上例中辅助元素的vertical-align原理一样，td 标签默认情况下就默认设置了 vertical-align 为 middle，所以我们不需要显式地设置，使用table布局就可以完成完美的自动水平垂直居中了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;但是这种布局方式毕竟拘束，在实现垂直居中后，还需要一大堆的代码把tabel的样子抹掉。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;所以知道有这种方法，平时根本不用也没必要用，我也不去实践了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;（三）&lt;strong&gt;带着尚方宝剑的display: table-cell&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;即，设置块级元素的 display 为 table-cell。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;之所以说display:table-cell; 是带着尚方宝剑的，是因为这么做就相当于设置为表格单元显示。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;但这种方法兼容性比较差，只是提供大家学习参考。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注意 IE6、7 并不支持这个样式, 兼容性比较差。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;看我是否可以居中。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;看我是否可以居中。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;看我是否可以居中。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt; .container {
    height:300px;
    background:#ccc;
    display:table-cell;
    /*IE8以上及Chrome、Firefox*/
    vertical-align:middle;
    /*IE8以上及Chrome、Firefox*/
}
&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;这种方法的好处是不用添加多余的无意义的标签，但缺点也很明显，它的兼容性不是很好，不兼容 IE6、7而且这样修改display的block变成了table-cell，破坏了原有的块状元素的性质。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;（四）&lt;strong&gt;小机灵鬼儿&lt;/strong&gt;&lt;strong&gt;translate&lt;/strong&gt;&lt;strong&gt;对应方向上的-50%&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;具体原理和使用方法及案例见上边。不再赘述。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;（五）&lt;strong&gt;flex大大一句话 水平垂直全拿下&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180911145043557-579836212.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;p&quot;&gt;&lt;span&gt;这个相信不用我说，大家一看就明白怎么回事了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;Flex弹性盒布局属性，此系列中还有两个属性&lt;strong&gt;justify-content&lt;/strong&gt; 和 &lt;strong&gt;align-items&lt;/strong&gt; 分别用于实现水平居中和垂直居中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;具体flex的学习可以参考这两篇：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;Flex 布局教程：语法篇  作者： &lt;a href=&quot;http://www.ruanyifeng.com/&quot;&gt;阮一峰&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&quot;&gt;&lt;span&gt;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;Flex 布局教程：实例篇&lt;/span&gt;&lt;span&gt;作者： &lt;a href=&quot;http://www.ruanyifeng.com/&quot;&gt;阮一峰&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-examples.html&quot;&gt;&lt;span&gt;http://www.ruanyifeng.com/blog/2015/07/flex-examples.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;简易的代码见下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;author&quot; content=&quot;guojufeng@ xing.org1^&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;万能方法&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div class=&quot;flex xingorg1&quot;&amp;gt;
    &amp;lt;span&amp;gt;前端小学生~ _xing.org1^&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;flex xingorg1&quot;&amp;gt;
      &amp;lt;span&amp;gt;不会搞艺术的程序员不是好的设计师 _xing.org1^ 不会搞艺术的程序员不是好的设计师 _xing.org1^ &amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;style&amp;gt;
    .flex{
      margin-bottom: 10px;
      padding: 20px;
      width: 300px;
      height: 300px;
      background: #f5f5f5;
      border: 1px solid #eee;
      /* flex写法 */
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
  &amp;lt;/style&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;虽说古老的&lt;/span&gt;ie不支持这种布局，但是写上hack后，用在移动端的项目中简直完美啊。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小程序不就默认这么写的么。&lt;/span&gt;&lt;/p&gt;







&lt;p&gt;&lt;span&gt;2018-09-11 12:42:49&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;声明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　请尊重博客园原创精神，转载或使用图片请注明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　博主：xing.org1^&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　出处：http://www.cnblogs.com/padding1015/&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 11 Sep 2018 06:54:00 +0000</pubDate>
<dc:creator>xing.org1^</dc:creator>
<og:description>垂直居中的元素处境有很多种情况，父元素高度确不确定、文本是单行还是多行、两列图文又想垂直居中等等不同的情况。 但是垂直居中的方法也有很多种情况！table原理、line-height原理、verti</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/padding1015/p/9577958.html</dc:identifier>
</item>
<item>
<title>Scala的文件读写操作与正则表达式 - codegeekgao</title>
<link>http://www.cnblogs.com/codegeekgao/p/9627644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codegeekgao/p/9627644.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在本篇博客中你将会学习并了解常用的文件处理任务，例如读取文件的一行文本，本博客的要点包含：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;Source.fromFile(...).getLines.toArray 输出文件所有行&lt;/li&gt;
&lt;li&gt;Source.fromFile(...).mkString 以字符串形式输出文件内容&lt;/li&gt;
&lt;li&gt;将字符串转换为数字，可以使用toInt或toDouble方法&lt;/li&gt;
&lt;li&gt;使用java的PrintWriter写入文本文件&lt;/li&gt;
&lt;li&gt;“正则”.r是一个Regex对象&lt;/li&gt;
&lt;li&gt;若你的正则表达式包含反斜杠或者引号，请用&quot;&quot;&quot;...&quot;&quot;&quot;&lt;/li&gt;
&lt;li&gt;正则模式包含分组，可以使用for(regex(变量1...,变量2)&amp;lt;- 字符串)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本篇博客要点如下：&lt;/p&gt;
&lt;h4 id=&quot;读取行&quot;&gt;读取行&lt;/h4&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// 读取文件所有的行，可以调用scala.io.Source对象的getLines方法：
val source = Source.fromFile(&quot;a.txt&quot;,&quot;utf-8&quot;)
val lineIterator = source.getLines
结果是迭代器可以使用for循环处理这些行
for(i &amp;lt;- lineIterator) println(i)
也可以使用迭代器应用toArray或toBuffer方法，将这些行放到数组力或者数组缓冲行中，若想将读取的的文件作为一个字符串，只需val conents = source.mkString
下面是简单的代码实例：读取桌面上的a.txt

object ReadFile {
  def main(args: Array[String]): Unit = {
    val read = new ReadFile()
    val resource: String = &quot;C:\\Users\\DonnieGao\\Desktop\\a.txt&quot;
    val encode = &quot;UTF-8&quot;
    read.readFile(resource, encode)
    println(read.readFileToStr(resource, encode))
  }
}

class ReadFile {
  /**
    * 一行行读取文件的内容
    *
    * @param resource 文件路径
    * @param code     文件编码格式
    */
  def readFile(resource: String, code: String): Unit = {
    var source: BufferedSource = null
    try {
      // 获取文件的Source对象，第一个参数是文件的路径，第二个文件的编码格式
      source = Source.fromFile(resource, code)
      val lineIterator = source.getLines()
      while (true) {
        if (lineIterator.hasNext) {
          println(lineIterator.next())
        } else {
          return
        }
      }
    } finally {
      // 释放资源
      source.close()
    }
  }

  /**
    * 将文本文件所有内容作为字符串
    *
    * @param resource 文件路径
    * @param code     文件编码格式
    * @return
    */
  def readFileToStr(resource: String, code: String): String = {
    // 获取文件的Source对象，第一个参数是文件的路径，第二个文件的编码格式
    var source: BufferedSource = null
    try {
      source = Source.fromFile(resource, code)
      source.mkString
    } finally {
      source.close()
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;读取字符&quot;&gt;读取字符&lt;/h4&gt;
&lt;p&gt;要将文件中读取单个字符，可以把Source对象当作迭代器，若仅仅只是想查看字符可以调用Source对象的buffered方法。&lt;/p&gt;
&lt;h4 id=&quot;读取词法单元和数字&quot;&gt;读取词法单元和数字&lt;/h4&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;读取源文件中所有空格隔开的词法单元
val tokens = source.mkString.split(&quot;\\s+&quot;)
若有个基本都是浮点型的文件，可以将其读取到数组中：
val numbers = for (w &amp;lt;- tokens) yield w.toDouble 或者也可 
val numbers = token.map(_.toDouble)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;读取二进制文件&quot;&gt;读取二进制文件&lt;/h4&gt;
&lt;p&gt;Scala并没有提供读取二进制文件的方法，可以使用java读取二进制的方法，代码示例&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;val file = new File(fileName)
val in = new FileInputStream(file)
val bytes = new Array[Byte](file.length.toInt)
in.read(bytes)
in.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;写入文本文件&quot;&gt;写入文本文件&lt;/h4&gt;
&lt;p&gt;Scala没有内建对写入文件的支持，可借助java进行文件写入操作例如使用java.io.PrintWriter&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;  /**
    * Scala写入文借助java的PrintWriter
    */
  def write(): Unit = {
    val out = new PrintWriter(&quot;C:\\Users\\DonnieGao\\Desktop\\test.txt&quot;)
    for (i &amp;lt;- 0 to 100) out.println(i)
    out.close()
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;访问文件目录&quot;&gt;访问文件目录&lt;/h4&gt;
&lt;p&gt;Scala中没有直接访问某个目录下的所有文件的方式或者递归遍历有目录的类&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;  /**
    * 使用java列举下所有的文件夹
    * @param dir 文件目录路径
    */
  def dir(dir:String) = {
    val dirFile = new File(dir)
   val arrayFile= dirFile.listFiles()
    for (i &amp;lt;- arrayFile){println(arrayFile.toBuffer)}
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;序列化&quot;&gt;序列化&lt;/h4&gt;
&lt;p&gt;在java中声明一个可以被序列号的类通常是下面这种：&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;public class Person implements java.io.Serializable {
    private static final long serialVersionUID = 4436475322569107137L;
}

Scala中声明一个可以被序列化的类通常是下面这种：
@SerialVersionUID(12356L) class ReadFile extends Serializable {
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h4&gt;
&lt;p&gt;Scala中提供了正则操作处理scala.util.matching.Regex让这件事情可以变得简单。构造一个Regex对象，用String类的r方法即可&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;object RegexDemo {

  def main(args: Array[String]): Unit = {
    // 初始化正则对象
    val numPattern = &quot;[0-9]+&quot;.r
    val regex = &quot;13 welcome to beijing&quot;
    // findAllIn方法返回遍历所有匹配的迭代器，可以在for循环中使用
    for (matchString &amp;lt;- numPattern.findAllIn(regex)) {
      println(matchString)
    }
    // 查询字符串首个匹配项
    println(numPattern.findFirstIn(regex))
    // 检查某个字符串的开始部分能匹配，可以使用findPrefixOf
    println(numPattern.findPrefixOf(regex))
  }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 11 Sep 2018 06:53:00 +0000</pubDate>
<dc:creator>codegeekgao</dc:creator>
<og:description>在本篇博客中你将会学习并了解常用的文件处理任务，例如读取文件的一行文本，本博客的要点包含： 1. Source.fromFile(...).getLines.toArray 输出文件所有行 2. So</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codegeekgao/p/9627644.html</dc:identifier>
</item>
<item>
<title>[原创]颠覆传统网站开发模式的web服务器 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/9627449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/9627449.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201809/1136672-20180911004432096-695802899.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;之前发过一篇文章，当时的想法现在看来真的不是很明确，得到了很多批评。不过，批评有利有弊，由此我又仔细思考了很多，最终明确了自己究竟要做什么。特厚着脸皮发出正式版文档！&lt;br/&gt;下面废话较多，大家直接看第3条思想即可理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;缘由&quot;&gt;1、缘由&lt;/h2&gt;
&lt;p&gt;以Java web举例，现在的网站系统开发模式，对于web端和服务端的数据交互以及页面渲染，无外乎两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一种是交给后端处理，Jsp，Freemark模板引擎之流，这种开发模式需要前端人员做好静态页面交给后端去处理一些其它工作。这种开发模式到如今也依旧流行，这也是招聘Java web程序员要求也要会HTML、JS、CSS的原因。到现在基本上都是采用这种开发模式，注意这种模式并非真正的前后端分离！&lt;/li&gt;
&lt;li&gt;另一种是交给前端处理，前端全部完成web端的页面渲染工作。要知道的是，前端处理只能使用JS，一些前端JS模板引擎也有不少，Vue等，无论再花哨，本质依旧是JS。不可忽视的是，完全依赖JS处理前端页面是存在弊端的，比如SEO问题。&lt;/li&gt;
&lt;li&gt;总的来说，两种方式有利有弊。如果你在实际开发中涉及到我上面说的第一种，需要后端再对前端页面进行处理，那么可以使用 Jerry 来解决这部分的分工，实现完全前后端分离。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;定义&quot;&gt;2、定义&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Jerry是帮助前后端完全分离的工具，它可以帮助后端工程师只做后端，前端工程师只做前端。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;思想&quot;&gt;3、思想&lt;/h2&gt;
&lt;p&gt;简单来说，以往的模式是请求后端接口，后端进行处理后返回一个页面给浏览器。前后端并没有进行彻底分离，比如还在使用后端模板引擎（FreeMark，Thymeleaf）或JSP。为什么Web开发不能像Android等移动端开发一样真正前后端分离呢？&lt;/p&gt;
&lt;p&gt;上述开发模式是后端提供接口（也就是网址），经过处理得到一些数据，然后经过模板引擎的一系列渲染，填充数据，再把完成的HTML页面返回给浏览器。流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201809/1136672-20180911004501483-371386647.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jerry 的思想就是把这部分的流程进行拆分。&lt;/strong&gt;流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201809/1136672-20180911004516382-138141652.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也许你会说，Cookie 怎么办？会话如何保持？我想说，Jerry 服务器会相当认真的执行代理的角色。把客户端的HTTP请求的方法、Cookie、参数原封不动的发送给服务端。服务端发送回来的响应也会把Set-Cookie响应给客户端。（笔者想到的就是Cookie比较常用，若思考欠缺，欢迎指正。）理论上说，Jerry的方案是可行的。&lt;/p&gt;
&lt;h2 id=&quot;模式&quot;&gt;4、模式&lt;/h2&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;一种完全真正的前后端分离，Jerry采用如今最流行的JSON作为前后端数据交互的接口。&lt;/p&gt;
&lt;p&gt;对后端工程师来说，只需要关心接口的实现，不需要再接触前端页面，甚至不要求懂HTML，JS等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;只做接口有什么优势？一套接口适用web、Android、ios各个平台，这对软件项目的可扩展性大大提升。不可否认的是，现在依旧有些网站采用后端直接返回html片段的开发模式，这对软件的扩展性非常不利。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对前端工程师来说，任务脉络更为清晰而简洁。不像以前只需要做好页面，更需要使用FreeMark等处理动态交互。这在之前是由后端工程师来做的。可以说是完全颠覆以往。把网站开发做成像安卓开发一样的前后端分明。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果你已经有了成熟的前后端分离方案，自然不需要Jerry，如果你们的后端工程师还需要再去写FreeMark，Thymeleaf等，则可以考虑使用Jerry达到更彻底的前后端分离。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;场景&quot;&gt;5、场景&lt;/h2&gt;
&lt;p&gt;你既可以把Jerry部署在实际项目中使用，当做一个前端服务器。&lt;/p&gt;
&lt;p&gt;如果你真的不想在线上部署Jerry，那你可以在开发过程中，交由前端开发人员去使用Jerry。&lt;/p&gt;
&lt;p&gt;把原来的前端只做静态页面然后交由后端去渲染的工作改为全部让前端去做，然后在上线时再把写过FreeMark语法的HTML文件放到后端项目中。&lt;/p&gt;
&lt;h2 id=&quot;优势&quot;&gt;5、优势&lt;/h2&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;启动快！&lt;/p&gt;
&lt;p&gt;响应快，配置后台监控，响应时间一览无遗。&lt;/p&gt;
&lt;p&gt;优先读取各种文件的缓存，使用EhCache实现。&lt;/p&gt;
&lt;p&gt;对于后端接口，使用加权负载均衡。&lt;/p&gt;
&lt;p&gt;对于日志监控等耗时而且响应无关的操作，全部运行在其它线程。&lt;/p&gt;
&lt;p&gt;如果你还有其它加快速度的方法，欢迎留言。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;轻量级！没有过多依赖，大部分功能能自己实现就自己写。全部依赖如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Netty&lt;/li&gt;
&lt;li&gt;slf4j + logback&lt;/li&gt;
&lt;li&gt;fastjson&lt;/li&gt;
&lt;li&gt;ehcache&lt;/li&gt;
&lt;li&gt;junit4&lt;/li&gt;
&lt;li&gt;freemark&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自带监控系统。对页面的响应速度以及HTTP信息一览无遗。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;引擎&quot;&gt;6、引擎&lt;/h2&gt;
&lt;p&gt;Jerry 使用 FreeMark 作为模板引擎。也就是说，原来需要后端工程师使用freemark去渲染页面，现在变为前端工程师去使用。&lt;/p&gt;
&lt;p&gt;例如，服务端接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;message&quot;: &quot;响应成功&quot;,
    &quot;state&quot;: {
        &quot;message&quot;: &quot;ok&quot;,
    },
    &quot;data&quot;: [{
        &quot;time&quot;: &quot;2018-04-25 13:25:07&quot;,
    }, {
        &quot;time&quot;: &quot;2018-04-25 13:25:07&quot;,
    }]

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTML页面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    message：${message}&amp;lt;br&amp;gt;
    com: ${com}&amp;lt;br&amp;gt;
    data[0].time：${data[0].time}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它用法请参考FreeMark学习网站：&lt;a href=&quot;http://freemarker.foofun.cn/&quot;&gt;FreeMark开发手册&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;监控&quot;&gt;7、监控&lt;/h2&gt;
&lt;p&gt;监控系统对各个页面与文件的响应耗时与请求信息进行监控，监控频率可以在全局配置文件中进行自定义配置，默认为10s。&lt;/p&gt;
&lt;p&gt;对于监控日志可以自定义输出目录，目录只支持相对路径（也就是只能在webapps目录下），监控日志格式为JSON。&lt;/p&gt;
&lt;p&gt;默认提供的监控页面位于webapps/manage项目下。默认访问：&lt;a href=&quot;http://ip%E5%9C%B0%E5%9D%80:8888/manage&quot; class=&quot;uri&quot;&gt;http://ip地址:8888/manage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后台监控页面预览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201809/1136672-20180911004809840-1264683670.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;监控系统运行流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201809/1136672-20180911004821433-1527512489.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;负载均衡&quot;&gt;8、负载均衡&lt;/h2&gt;
&lt;p&gt;Jerry 对于静态资源全部做了缓存，FreeMark本身就带有缓存。对于FreeMark页面的后端接口支持使用加权负载均衡。如果你想体验加权负载均衡，可以把缓存时间设置为1。然后不断刷新页面。关于如何设置负载均衡，请参考接口配置。&lt;/p&gt;
&lt;h2 id=&quot;全局配置&quot;&gt;9、全局配置&lt;/h2&gt;
&lt;p&gt;全局配置文件位于config目录下，使用默认UTF-8编码进行读取。详细配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#开启端口
port=8888
#默认首页
index=index.html
#默认项目
project=ROOT
#全局404模板(webapps/)
404=/template/404.html
#接口配置文件名，要求内容为Json
config=page.json
#接口配置文件的编码
js_charset=UTF-8
#解析接口响应的编码
jk_charset=UTF-8
#请求接口超时时间ms
timeout=10000
#freemark文件编码
fm_charset=UTF-8
#监控刷新频率(毫秒/ms)
monitor=10000
#监控文件目录(webapps/)
monitorLog=/manage/log.json
#缓存:最大存储元素个数
maxElementsInMemory=10000
#缓存:最大发呆时间(秒/s)
timeToIdleSeconds=120
#缓存:最大存活时间(秒/s)
timeToLiveSeconds=600
#控制台日志级别INFO/DEBUG
level=INFO&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Jerry把所有的web项目与页面都放在了webapps下，服务器也只会响应webapps目录下的文件。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关于全局404模板，默认即可。不过也支持自定义。&lt;/li&gt;
&lt;li&gt;关于接口配置文件，默认page.json。你可以自定义，但一定必须是json内容，而且位于项目根目录下（如ROOT/page.json）。&lt;/li&gt;
&lt;li&gt;接口配置文件的编码就是page.json文件的读取时的编码格式。默认utf-8&lt;/li&gt;
&lt;li&gt;freemark文件编码是设置处理freemark文件的编码。&lt;/li&gt;
&lt;li&gt;监控刷新频率。最低为1s，默认10s。&lt;/li&gt;
&lt;li&gt;上面缓存的意思是在有效的600秒(10分钟)内，如果连续120秒(2分钟)未访问缓存，则缓存失效。就算有访问，也只会存活600秒。&lt;/li&gt;
&lt;li&gt;当你想查看运行日志时，切换为debug即可。默认info。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;接口配置&quot;&gt;10、接口配置&lt;/h2&gt;
&lt;p&gt;先看一下示范文件，下面进行讲解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[
  {
    &quot;page&quot;: &quot;index.html&quot;,
    &quot;id&quot;: &quot;je&quot;,
    &quot;inter&quot;: [
      {
        &quot;link&quot;: &quot;https://www.kuaidi100.com/query?type=shentong&amp;amp;postid=3374107234608&amp;amp;id=1&quot;,
        &quot;weight&quot;: 1
      },
      {
        &quot;link&quot;: &quot;https://www.kuaidi100.com/query?type=yuantong&amp;amp;postid=801371015800473775&amp;amp;id=1&quot;,
        &quot;weight&quot;: 2
      }
    ]
  },
  {
    &quot;page&quot;: &quot;admin/index.html&quot;,
    &quot;id&quot;: &quot;je&quot;,
    &quot;inter&quot;: [
      {
        &quot;link&quot;: &quot;https://www.kuaidi100.com/query?type=shentong&amp;amp;postid=3374107234608&amp;amp;id=1&quot;,
        &quot;weight&quot;: 1
      }
    ]
  }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;page&lt;/td&gt;
&lt;td&gt;HTML文件路径。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;ID名称。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;inter&lt;/td&gt;
&lt;td&gt;后端接口对象，可以定义多个实现负载均衡。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;link&lt;/td&gt;
&lt;td&gt;后端接口实际地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;weight&lt;/td&gt;
&lt;td&gt;权重，用于负载均衡。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在Jerry正式版中，采用FreeMark作为模板引擎，一个（FreeMark）HTML文件只能有一个配置。&lt;/p&gt;
&lt;h2 id=&quot;一些其它问题&quot;&gt;12、一些其它问题&lt;/h2&gt;
&lt;h3 id=&quot;linux与windows&quot;&gt;1，Linux与Windows&lt;/h3&gt;
&lt;p&gt;在Linux部署Jerry服务器，访问文件严格区分大小写。而在Windows对大小写不敏感。&lt;/p&gt;
&lt;p&gt;举个例子，访问/ROOT和/ROOt时，在Windows是可以的，在Linux是失败的。&lt;/p&gt;
&lt;p&gt;如果在使用中您还遇到了其它Bug，欢迎在我的Git或者博客给我留言。&lt;/p&gt;
&lt;h3 id=&quot;关于编码&quot;&gt;2，关于编码&lt;/h3&gt;
&lt;p&gt;全项目默认UTF-8，不过也提供配置支持自定义。&lt;/p&gt;
&lt;p&gt;对于不需要语法处理的HTML文件来说，不涉及编码问题。&lt;/p&gt;
&lt;p&gt;对于需要语法处理的HTML文件，统一配置在config配置文件。&lt;/p&gt;
&lt;p&gt;若出现乱码，请检查你的配置。&lt;/p&gt;
&lt;h3 id=&quot;如何启动&quot;&gt;3，如何启动&lt;/h3&gt;
&lt;p&gt;请在Git克隆/下载本项目压缩包，解压后只需保留以下3个目录或文件，其它全部删除即可：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/config&lt;/li&gt;
&lt;li&gt;/webapps&lt;/li&gt;
&lt;li&gt;JerryServer-0.0.1-SNAPSHOT.jar&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后在控制台或命令行执行&lt;code&gt;java -jar JerryServer-0.0.1-SNAPSHOT.jar&lt;/code&gt;即可运行。&lt;/p&gt;
&lt;p&gt;Linux系统如使其在后台运行，在末尾加个&lt;code&gt;&amp;amp;&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;然后使用的问题，一般来说，只需要把web项目放到webapps下，项目根目录新建page.json接口配置即可。&lt;br/&gt;关于接口配置详细参数上面已经说明。然后在HTML页面使用FreeMark语法获取后端数据。例子：&lt;/p&gt;
&lt;p&gt;API接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
       &quot;message&quot;: &quot;ok&quot;,
       &quot;data&quot;: [
           {
               &quot;time&quot;: &quot;2018-09-06 16:57:43&quot;,
           }
        ]
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTML页面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;p&amp;gt;
    message：${message}&amp;lt;br&amp;gt;
    data[0].time：${data[0].time}
&amp;lt;/p&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;是不是造nginx的轮子&quot;&gt;4，是不是造Nginx的轮子&lt;/h3&gt;
&lt;p&gt;关于这一点很明确，不是。来看下面的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201809/1136672-20180911004840142-530438849.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;更新日志&quot;&gt;13、更新日志&lt;/h2&gt;
&lt;p&gt;2018/9/8：修复接口数据为数组解析失败的BUG。&lt;/p&gt;
&lt;p&gt;2018/9/9：升级改版，主要是把接口配置简化。实行一个页面一个接口配置的策略。&lt;/p&gt;
&lt;p&gt;把接口和页面进行绑定。访问页面的method、header和body就是请求接口的method、header和body。&lt;/p&gt;
&lt;p&gt;支持GET请求，POST请求等。&lt;/p&gt;
&lt;p&gt;关于请求体类型，除了 multipart/form-data 格式，binary二进制流（图片等），其余格式都支持。默认UTF-8解码与编码。&lt;/p&gt;
&lt;p&gt;2018/9/10：去掉JSOUP依赖，使用HttpURLConnection进行网络请求。&lt;/p&gt;
&lt;h2 id=&quot;尾声&quot;&gt;14、尾声&lt;/h2&gt;
&lt;h3 id=&quot;禁止申请专利&quot;&gt;禁止申请专利！&lt;/h3&gt;
&lt;p&gt;还有，感谢支持！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;若使用出现Bug等问题，请到以下地址留言评论，或者加入QQ群交流。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我的博客：&lt;a href=&quot;https://yueshutong.cnblogs.com/&quot; class=&quot;uri&quot;&gt;https://yueshutong.cnblogs.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/yueshutong/JerryServer/&quot; class=&quot;uri&quot;&gt;https://github.com/yueshutong/JerryServer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitee：&lt;a href=&quot;https://gitee.com/zyzpp/JerryServer&quot; class=&quot;uri&quot;&gt;https://gitee.com/zyzpp/JerryServer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开源中国：&lt;a href=&quot;https://www.oschina.net/p/jerryserver&quot; class=&quot;uri&quot;&gt;https://www.oschina.net/p/jerryserver&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/zyzpp/JerryServer/stargazers&quot;&gt;&lt;img src=&quot;https://gitee.com/zyzpp/JerryServer/badge/star.svg?theme=dark&quot; alt=&quot;star&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201809/1136672-20180908175944599-678005720.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 06:29:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>Jerry Server 正式版1.0.0 文档 之前发过一篇文章，当时的想法现在看来真的不是很明确，得到了很多批评。不过，批评有利有弊，由此我又仔细思考了很多，最终明确了自己究竟要做什么。特厚着脸皮</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/9627449.html</dc:identifier>
</item>
<item>
<title>Java并发基础-并发工具类(二) - aidodoo</title>
<link>http://www.cnblogs.com/aidodoo/p/9627357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aidodoo/p/9627357.html</guid>
<description>&lt;p&gt;本系列文章主要讲解&lt;code&gt;Java&lt;/code&gt;并发相关的内容，包括同步、锁、信号量、阻塞队列、线程池等，整体思维导图如下：&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/concurrent2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系列文章列表：&lt;/p&gt;
&lt;p&gt;本文主要以实例讲解&lt;code&gt;Semaphore&lt;/code&gt;、阻塞队列等内容。&lt;/p&gt;
&lt;h2 id=&quot;semaphore&quot;&gt;Semaphore&lt;/h2&gt;
&lt;h3 id=&quot;基本概念和用途&quot;&gt;基本概念和用途&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Semaphore&lt;/code&gt;常称信号量，其维护了一个许可集，可以用来控制线程并发数。线程调用&lt;code&gt;acquire()&lt;/code&gt;方法去或者许可证，然后执行相关任务，任务完成后，调用&lt;code&gt;release()&lt;/code&gt;方法释放该许可证，让其他阻塞的线程可以运行。&lt;br/&gt;&lt;code&gt;Semaphore&lt;/code&gt;可以用于流量控制，尤其是一些公共资源有限的场景，比如数据库连接。假设我们上面的账户余额管理中的账户修改操作涉及到去更改&lt;code&gt;mysql&lt;/code&gt;数据库,为了避免数据库并发太大，我们进行相关限制。&lt;br/&gt;&lt;strong&gt;常用方法&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;Semaphore(int permits)&lt;/code&gt;：构造方法，初始化许可证数量&lt;br/&gt;&lt;code&gt;void acquire()&lt;/code&gt;：获取许可证&lt;br/&gt;&lt;code&gt;void release()&lt;/code&gt;：释放许可证&lt;br/&gt;&lt;code&gt;int availablePermits()&lt;/code&gt; ：返回此信号量中当前可用的许可证数。&lt;br/&gt;&lt;code&gt;int getQueueLength()&lt;/code&gt;：返回正在等待获取许可证的线程数。&lt;br/&gt;&lt;code&gt;boolean hasQueuedThreads()&lt;/code&gt; ：是否有线程正在等待获取许可证。&lt;br/&gt;&lt;code&gt;void reducePermits(int reduction)&lt;/code&gt; ：减少reduction个许可证。是个protected方法。&lt;br/&gt;&lt;code&gt;Collection getQueuedThreads()&lt;/code&gt; ：返回所有等待获取许可证的线程集合。是个protected方法。&lt;/p&gt;
&lt;h3 id=&quot;运行示例&quot;&gt;运行示例&lt;/h3&gt;
&lt;p&gt;虽然在代码中设置了&lt;code&gt;20&lt;/code&gt;个线程去运行，但同时设置了许可证的数量为&lt;code&gt;5&lt;/code&gt;，因而实际的最大并发数还是&lt;code&gt;5&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.aidodoo.java.concurrent;

import java.util.concurrent.*;

/**
 * Created by zhangkh on 2018/9/9.
 */
public class SemaphoreDemo {
    public static void main(String[] args){
        Semaphore semaphore=new Semaphore(5);
        ExecutorService executorService = Executors.newFixedThreadPool(20);
        Account account=new Account();
        for(int i=0;i&amp;lt;20;i++){
            SpenderWithSemaphore spender = new SpenderWithSemaphore(account, semaphore);
            executorService.submit(spender);
        }

        executorService.shutdown();
    }
}
class SpenderWithSemaphore implements Runnable {
    private final Account account;
    private final Semaphore semaphore;

    public SpenderWithSemaphore(Account account, Semaphore semaphore) {
        this.account = account;
        this.semaphore = semaphore;
    }

    @Override
    public void run() {
        try{
            semaphore.acquire();
            System.out.println(String.format(&quot;%s get a premit at time %s,change and save data to mysql&quot;,Thread.currentThread().getName(),System.currentTimeMillis()/1000));
            Thread.sleep(2000);
        }catch (InterruptedException e){
            e.printStackTrace();
        }finally {
//            System.out.println(String.format(&quot;%s release a premit&quot;,Thread.currentThread().getName()));
            semaphore.release();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取许可证后，模拟操作&lt;code&gt;mysql&lt;/code&gt;，我们让线程睡眠&lt;code&gt;2&lt;/code&gt;秒，程序输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pool-1-thread-2 get a premit at time 1536480858,change and save data to mysql
pool-1-thread-5 get a premit at time 1536480858,change and save data to mysql
pool-1-thread-3 get a premit at time 1536480858,change and save data to mysql
pool-1-thread-4 get a premit at time 1536480858,change and save data to mysql
pool-1-thread-1 get a premit at time 1536480858,change and save data to mysql
pool-1-thread-8 get a premit at time 1536480860,change and save data to mysql
pool-1-thread-7 get a premit at time 1536480860,change and save data to mysql
pool-1-thread-6 get a premit at time 1536480860,change and save data to mysql
pool-1-thread-9 get a premit at time 1536480860,change and save data to mysql
pool-1-thread-10 get a premit at time 1536480860,change and save data to mysql
pool-1-thread-11 get a premit at time 1536480862,change and save data to mysql
pool-1-thread-13 get a premit at time 1536480862,change and save data to mysql
pool-1-thread-12 get a premit at time 1536480862,change and save data to mysql
pool-1-thread-14 get a premit at time 1536480862,change and save data to mysql
pool-1-thread-15 get a premit at time 1536480862,change and save data to mysql
pool-1-thread-16 get a premit at time 1536480864,change and save data to mysql
pool-1-thread-17 get a premit at time 1536480864,change and save data to mysql
pool-1-thread-19 get a premit at time 1536480864,change and save data to mysql
pool-1-thread-18 get a premit at time 1536480864,change and save data to mysql
pool-1-thread-20 get a premit at time 1536480864,change and save data to mysql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到前面&lt;code&gt;5&lt;/code&gt;个线程同一时间&lt;code&gt;1536480858&lt;/code&gt;获得许可证，然后执行操作，并不是&lt;code&gt;20&lt;/code&gt;个线程一起操作，这样能降低对&lt;code&gt;mysql&lt;/code&gt;数据库的影响。&lt;br/&gt;如果把上面&lt;code&gt;Semaphore&lt;/code&gt;的构造方法中的许可证数量改为&lt;code&gt;20&lt;/code&gt;，大家可以看到&lt;code&gt;20&lt;/code&gt;个线程的运行时间基本一致。&lt;/p&gt;
&lt;h3 id=&quot;源码实现&quot;&gt;源码实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Semaphore&lt;/code&gt;实现直接基于&lt;code&gt;AQS&lt;/code&gt;，有公平和非公平两种模式。公平模式即按照调用&lt;code&gt;acquire()&lt;/code&gt;的顺序依次获得许可证，遵循&lt;code&gt;FIFO&lt;/code&gt;(先进先出)，非公平模式是抢占式的，谁先抢到先使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Semaphore(int permits, boolean fair) {
    sync = fair ? new FairSync(permits) : new NonfairSync(permits);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;获取许可证&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;acquire()&lt;/code&gt;方法最终调用父类&lt;code&gt;AQS&lt;/code&gt;中的&lt;code&gt;acquireSharedInterruptibly&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) &amp;lt; 0)              //(1)
        doAcquireSharedInterruptibly(arg);      //(2)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(1):调用&lt;code&gt;tryAcquireShared&lt;/code&gt;，尝试去获取许可证&lt;br/&gt;(2):如果获取失败，则调用&lt;code&gt;doAcquireSharedInterruptibly&lt;/code&gt;，将线程加入到等待队列中&lt;br/&gt;&lt;code&gt;tryAcquireShared&lt;/code&gt;方法由&lt;code&gt;Semaphore&lt;/code&gt;的内部类，同时也是&lt;code&gt;AQS&lt;/code&gt;的子类去实现，即&lt;code&gt;NonfairSync&lt;/code&gt;和&lt;code&gt;FairSync&lt;/code&gt;，下面我们以&lt;code&gt;NonfairSync&lt;/code&gt;为例说明其实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected int tryAcquireShared(int acquires) {
    return nonfairTryAcquireShared(acquires);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;nonfairTryAcquireShared&lt;/code&gt;方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        int available = getState();             //(1)
        int remaining = available - acquires;   //(2)
        if (remaining &amp;lt; 0 ||
            compareAndSetState(available, remaining)) (3)
            return remaining;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(1):获取&lt;code&gt;state&lt;/code&gt;的值，也就是总许可证数量&lt;br/&gt;(2):计算本次申请后，剩余的许可证数量&lt;br/&gt;(3):如果剩余的许可证数量大于&lt;code&gt;0&lt;/code&gt;且通过&lt;code&gt;CAS&lt;/code&gt;将&lt;code&gt;state&lt;/code&gt;的值修改成功后，返回剩余的许可证数量,否则继续循环阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;释放许可证&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;release()&lt;/code&gt;方法的调用最终会调用父类&lt;code&gt;AQS&lt;/code&gt;的&lt;code&gt;releaseShared()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {        //(1)
        doReleaseShared();              //(2)
        return true;
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(1):尝试释放许可证&lt;br/&gt;(2):如果释放许可证成功，则通知阻塞的线程，让其执行&lt;br/&gt;&lt;code&gt;tryReleaseShared&lt;/code&gt;方法很简单，基本上是&lt;code&gt;nonfairTryAcquireShared&lt;/code&gt;的逆过程，即增加许可证的数量，并通过&lt;code&gt;CAS&lt;/code&gt;修改&lt;code&gt;state&lt;/code&gt;的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        int current = getState();
        int next = current + releases;
        if (next &amp;lt; current) // overflow
            throw new Error(&quot;Maximum permit count exceeded&quot;);
        if (compareAndSetState(current, next))
            return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;blockingqueue&quot;&gt;BlockingQueue&lt;/h2&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;阻塞队列主要是解决如何高效安全传输数据的问题，此外能降低程序耦合度，让代码逻辑更加清晰。&lt;br/&gt;其继承了&lt;code&gt;Queue&lt;/code&gt;，并在其基础上支持了两个附加的操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当队列为空时，获取元素的线程会阻塞，等待队列变为非空&lt;/li&gt;
&lt;li&gt;当队列满时，添加元素的线程会阻塞，等待队列可用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比较典型的使用场景是生产者和消费者。&lt;br/&gt;&lt;code&gt;BlockingQueue&lt;/code&gt;根据对于不能立即满足但可能在将来某一时刻可以满足的操作，提供了不同的处理方法，进而导致众多的&lt;code&gt;api&lt;/code&gt;操作：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;3&quot; cellspacing=&quot;1&quot;&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td align=&quot;center&quot;&gt;Throws exception&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Special value&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Blocks&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Times out&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Insert&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;add(e)&lt;/td&gt;
&lt;td&gt;offer(e)&lt;/td&gt;
&lt;td&gt;put(e)&lt;/td&gt;
&lt;td&gt;offer(e, time, unit)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Remove&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;remove()&lt;/td&gt;
&lt;td&gt;poll()&lt;/td&gt;
&lt;td&gt;take()&lt;/td&gt;
&lt;td&gt;poll(time, unit)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Examine&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;element()&lt;/td&gt;
&lt;td&gt;peek()}&lt;/td&gt;
&lt;td&gt;not applicable&lt;/td&gt;
&lt;td&gt;not applicable&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;Throws exception&lt;/code&gt;:指当阻塞队列满时候，再往队列里插入元素，会抛出&lt;code&gt;IllegalStateException&lt;/code&gt;异常。当队列为空时，从队列里获取元素时会抛出&lt;code&gt;NoSuchElementException&lt;/code&gt;异常&lt;br/&gt;&lt;code&gt;Special value&lt;/code&gt;:插入方法会返回是否成功，成功则返回&lt;code&gt;true&lt;/code&gt;。移除方法，则是从队列里拿出一个元素，如果没有则返回&lt;code&gt;null&lt;/code&gt;&lt;br/&gt;&lt;code&gt;Blocks&lt;/code&gt;：当阻塞队列满时，如果生产者线程往队列里&lt;code&gt;put&lt;/code&gt;元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里&lt;code&gt;take&lt;/code&gt;元素，队列也会阻塞消费者线程，直到队列可用。&lt;br/&gt;&lt;code&gt;Time out&lt;/code&gt;：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。&lt;/p&gt;
&lt;h3 id=&quot;整体架构和类图&quot;&gt;整体架构和类图&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;并发包根据不同的结构和功能提供了不同的阻塞队列，整体类图如下：&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/BlockQueue1.png&quot;/&gt;&lt;br/&gt;其中&lt;code&gt;BlockingQueue&lt;/code&gt;有如下子类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt; ：一个由数组结构组成的有界阻塞队列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DelayQueue&lt;/code&gt;：一个使用优先级队列实现的无界阻塞队列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PriorityBlockingQueue&lt;/code&gt; ：一个支持优先级排序的无界阻塞队列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SynchronousQueue&lt;/code&gt;：一个不存储元素的阻塞队列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedBlockingQueue&lt;/code&gt; ：一个由链表结构组成的有界阻塞队列。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中&lt;code&gt;BlockingDeque&lt;/code&gt;有一个子类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;：一个由链表结构组成的双向阻塞队列。&lt;br/&gt;&lt;code&gt;BlockingDeque&lt;/code&gt;作为双端队列，针对头部元素，还提供了如下方法：&lt;/li&gt;
&lt;/ul&gt;&lt;table border=&quot;1&quot; cellpadding=&quot;3&quot; cellspacing=&quot;1&quot; readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; colspan=&quot;5&quot;&gt;&lt;strong&gt;First Element (Head)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td&gt;Throws exception&lt;/td&gt;
&lt;td&gt;Special value&lt;/td&gt;
&lt;td&gt;Blocks&lt;/td&gt;
&lt;td&gt;Times out&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;Insert&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;addFirst(e)&lt;/td&gt;
&lt;td&gt;offerFirst(e)&lt;/td&gt;
&lt;td&gt;putFirst(e)&lt;/td&gt;
&lt;td&gt;offerFirst(e, time, unit)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Remove&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;removeFirst()&lt;/td&gt;
&lt;td&gt;pollFirst()&lt;/td&gt;
&lt;td&gt;takeFirst()&lt;/td&gt;
&lt;td&gt;pollFirst(time, unit)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Examine&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;getFirst()&lt;/td&gt;
&lt;td&gt;peekFirst()&lt;/td&gt;
&lt;td&gt;not applicable&lt;/td&gt;
&lt;td&gt;not applicable&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;针对尾部元素&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; colspan=&quot;5&quot;&gt;&lt;strong&gt;Last Element (Tail)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td&gt;Throws exception&lt;/td&gt;
&lt;td&gt;Special value&lt;/td&gt;
&lt;td&gt;Blocks&lt;/td&gt;
&lt;td&gt;Times out&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Insert&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;addLast(e)&lt;/td&gt;
&lt;td&gt;offerLast(e)&lt;/td&gt;
&lt;td&gt;putLast(e)&lt;/td&gt;
&lt;td&gt;offerLast(e, time, unit)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Remove&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;removeLast()&lt;/td&gt;
&lt;td&gt;pollLast()&lt;/td&gt;
&lt;td&gt;takeLast()&lt;/td&gt;
&lt;td&gt;pollLast(time, unit)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Examine&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;getLast()&lt;/td&gt;
&lt;td&gt;peekLast()&lt;/td&gt;
&lt;td&gt;not applicable&lt;/td&gt;
&lt;td&gt;not applicable&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;h3 id=&quot;使用示例&quot;&gt;使用示例&lt;/h3&gt;
&lt;p&gt;一个典型的生产者和消费者实例如下，一个&lt;code&gt;BlockingQueue&lt;/code&gt;可以安全地与多个生产者和消费者一起使用，&lt;code&gt;Producer&lt;/code&gt;线程调用&lt;code&gt;NumerGenerator&lt;/code&gt;.&lt;code&gt;getNextNumber()&lt;/code&gt;生成自增整数，不断地写入数字，然后&lt;code&gt;Consumer&lt;/code&gt;循环消费。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.aidodoo.java.concurrent;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by zhangkh on 2018/7/17.
 */
public class BlockingQueueDemo {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue queue = new ArrayBlockingQueue(1024,true);
        ExecutorService executorService = Executors.newFixedThreadPool(20);
        for (int i = 0; i &amp;lt; 5; i++) {
            executorService.submit(new Producer(queue));
        }
        for (int i = 0; i &amp;lt; 3; i++) {
            executorService.submit(new Consumer(queue));
        }
        Thread.sleep(30 * 1000L);
        executorService.shutdown();
    }
}

class Producer implements Runnable {
    Logger logger = LoggerFactory.getLogger(Producer.class.getName());
    protected BlockingQueue queue = null;
    public Producer(BlockingQueue queue) {
        this.queue = queue;
    }
    @Override
    public void run() {
        try {
            for(int i=0;i&amp;lt;3;i++){
                int num = NumerGenerator.getNextNumber();
                queue.put(num);
                Thread.sleep(1000);
                logger.info(&quot;{} producer put {}&quot;, Thread.currentThread().getName(), num);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


class Consumer implements Runnable {
    Logger logger = LoggerFactory.getLogger(Consumer.class.getName());

    protected BlockingQueue queue = null;

    public Consumer(BlockingQueue queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            while (true) {
                int ele = (int) queue.take();
                logger.info(&quot;{} Consumer take {}&quot;, Thread.currentThread().getName(), ele);
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class NumerGenerator{
    private static AtomicInteger count = new AtomicInteger();
    public static Integer getNextNumber(){
        return count.incrementAndGet();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;18/09/10 14:34:33 INFO concurrent.Consumer: pool-1-thread-6 Consumer take 1
18/09/10 14:34:33 INFO concurrent.Consumer: pool-1-thread-7 Consumer take 2
18/09/10 14:34:33 INFO concurrent.Consumer: pool-1-thread-8 Consumer take 3
18/09/10 14:34:34 INFO concurrent.Producer: pool-1-thread-3 producer put 3
18/09/10 14:34:34 INFO concurrent.Producer: pool-1-thread-2 producer put 2
18/09/10 14:34:34 INFO concurrent.Producer: pool-1-thread-1 producer put 1
18/09/10 14:34:34 INFO concurrent.Producer: pool-1-thread-5 producer put 5
18/09/10 14:34:34 INFO concurrent.Producer: pool-1-thread-4 producer put 4
18/09/10 14:34:34 INFO concurrent.Consumer: pool-1-thread-6 Consumer take 4
18/09/10 14:34:34 INFO concurrent.Consumer: pool-1-thread-8 Consumer take 5
18/09/10 14:34:34 INFO concurrent.Consumer: pool-1-thread-7 Consumer take 6
18/09/10 14:34:35 INFO concurrent.Producer: pool-1-thread-3 producer put 6
18/09/10 14:34:35 INFO concurrent.Producer: pool-1-thread-1 producer put 8
18/09/10 14:34:35 INFO concurrent.Producer: pool-1-thread-2 producer put 7
18/09/10 14:34:35 INFO concurrent.Producer: pool-1-thread-5 producer put 9
18/09/10 14:34:35 INFO concurrent.Producer: pool-1-thread-4 producer put 10
18/09/10 14:34:35 INFO concurrent.Consumer: pool-1-thread-6 Consumer take 7
18/09/10 14:34:35 INFO concurrent.Consumer: pool-1-thread-8 Consumer take 8
18/09/10 14:34:35 INFO concurrent.Consumer: pool-1-thread-7 Consumer take 9
18/09/10 14:34:36 INFO concurrent.Producer: pool-1-thread-1 producer put 12
18/09/10 14:34:36 INFO concurrent.Producer: pool-1-thread-3 producer put 11
18/09/10 14:34:36 INFO concurrent.Producer: pool-1-thread-5 producer put 14
18/09/10 14:34:36 INFO concurrent.Producer: pool-1-thread-4 producer put 15
18/09/10 14:34:36 INFO concurrent.Producer: pool-1-thread-2 producer put 13
18/09/10 14:34:36 INFO concurrent.Consumer: pool-1-thread-6 Consumer take 10
18/09/10 14:34:36 INFO concurrent.Consumer: pool-1-thread-8 Consumer take 11
18/09/10 14:34:36 INFO concurrent.Consumer: pool-1-thread-7 Consumer take 12
18/09/10 14:34:37 INFO concurrent.Consumer: pool-1-thread-6 Consumer take 13
18/09/10 14:34:37 INFO concurrent.Consumer: pool-1-thread-7 Consumer take 14
18/09/10 14:34:37 INFO concurrent.Consumer: pool-1-thread-8 Consumer take 15&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他&lt;code&gt;BlockingQueue&lt;/code&gt;子类的使用可参考对应的&lt;code&gt;Java&lt;/code&gt; &lt;code&gt;Api&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;p&gt;由于&lt;code&gt;BlockingQueue&lt;/code&gt;相关的子类众多，我们仅以&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;从源码角度分析相关实现。&lt;br/&gt;&lt;strong&gt;构造方法&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;中定义的成员变量如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final Object[] items; 
int takeIndex;
int putIndex;
int count;
final ReentrantLock lock;
private final Condition notEmpty;
private final Condition notFull;
transient Itrs itrs = null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各变量的解释如下，以便了解后续的代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;items&lt;/code&gt;用于存储具体的元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;takeIndex&lt;/code&gt;元素索引,用于记录下次获取元素的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;putIndex&lt;/code&gt;元素索引，用于记录下次插入元素的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;用于记录当前队列中元素的个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;notEmpty&lt;/code&gt;条件变量，此处为获取元素的条件，即队列不能为空，否则线程阻塞&lt;/li&gt;
&lt;li&gt;&lt;code&gt;notFull&lt;/code&gt;条件变量，此处为插入元素的条件，即队列不能已满，否则线程阻塞&lt;/li&gt;
&lt;li&gt;&lt;code&gt;itrs&lt;/code&gt;用于维护迭代器相关内容&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;内部结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/ArrayBlockingQueue1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构造方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ArrayBlockingQueue(int capacity) {
    this(capacity, false);  //(1)                               
}

public ArrayBlockingQueue(int capacity, boolean fair) {
    if (capacity &amp;lt;= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];      //(2)               
    lock = new ReentrantLock(fair);
    notEmpty = lock.newCondition();         //(3)
    notFull =  lock.newCondition();         //(4)
}
public ArrayBlockingQueue(int capacity, boolean fair,
                          Collection&amp;lt;? extends E&amp;gt; c) {
    this(capacity, fair);

    final ReentrantLock lock = this.lock;
    lock.lock(); // Lock only for visibility, not mutual exclusion
    try {
        int i = 0;
        try {
            for (E e : c) {                 //(5)
                checkNotNull(e);
                items[i++] = e;
            }
        } catch (ArrayIndexOutOfBoundsException ex) {
            throw new IllegalArgumentException();
        }
        count = i;
        putIndex = (i == capacity) ? 0 : i;
    } finally {
        lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(1):默认情况下，非公平模式，即抢占式&lt;br/&gt;(2):数组初始化&lt;br/&gt;(3)/(4):条件变量初始化&lt;br/&gt;(5):如果构造方法中，含有初始化集合的话，则将对应元素添加到内部数组，并更改&lt;code&gt;count&lt;/code&gt;和&lt;code&gt;putIndex&lt;/code&gt;的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入数据&lt;/strong&gt;&lt;br/&gt;插入数据，我们主要看&lt;code&gt;put()&lt;/code&gt;方法的实现，重点看生产者和消费者插入和获取数据时，线程何时阻塞，同时又何时唤醒。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void put(E e) throws InterruptedException {
    checkNotNull(e);                        //(1)
    final ReentrantLock lock = this.lock;   //(2)
    lock.lockInterruptibly();
    try {
        while (count == items.length)
            notFull.await();                //(3)
        enqueue(e);
    } finally {
        lock.unlock();                      //(4)
    }
}

private void enqueue(E x) {
final Object[] items = this.items;
    items[putIndex] = x;                    //(5)
    if (++putIndex == items.length)         //(6)
        putIndex = 0;
    count++;                                //(7)
    notEmpty.signal();                      //(8)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(&lt;code&gt;1&lt;/code&gt;):非空检查，插入的元素不能为&lt;code&gt;null&lt;/code&gt;,否则抛出&lt;code&gt;NullPointerException&lt;/code&gt;&lt;br/&gt;(&lt;code&gt;2&lt;/code&gt;):获取互斥锁&lt;br/&gt;(&lt;code&gt;3&lt;/code&gt;):如果当前队列的元素个数等于队列总长度，即队列已满，则通过条件变量，释放和&lt;code&gt;notFull&lt;/code&gt;相关的锁，当前线程阻塞。当前线程唤醒的条件如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其他某个线程调用此 &lt;code&gt;Condition&lt;/code&gt; 的 &lt;code&gt;signal()&lt;/code&gt; 方法，并且碰巧将当前线程选为被唤醒的线程；&lt;/li&gt;
&lt;li&gt;或者其他某个线程调用此 &lt;code&gt;Condition&lt;/code&gt; 的 &lt;code&gt;signalAll()&lt;/code&gt; 方法；&lt;/li&gt;
&lt;li&gt;或者其他某个线程中断当前线程，且支持中断线程的挂起；&lt;/li&gt;
&lt;li&gt;或者发生“虚假唤醒”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(5):如果队列未满，则将元素添加的&lt;code&gt;putIndex&lt;/code&gt;索引的位置&lt;br/&gt;(6):&lt;code&gt;putIndex&lt;/code&gt;增加&lt;code&gt;1&lt;/code&gt;后和队列长度相等，即已到达队列尾部，则&lt;code&gt;putIndex&lt;/code&gt;置&lt;code&gt;0&lt;/code&gt;&lt;br/&gt;(7):队列已有元素数量加&lt;code&gt;1&lt;/code&gt;&lt;br/&gt;(8):通知&lt;code&gt;notEmpty&lt;/code&gt;条件变量，唤醒等待获取元素的线程&lt;br/&gt;(4):释放互斥锁&lt;br/&gt;可以看到&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;每次插入元素后，都会去唤醒等待获取元素的线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取数据&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;take()&lt;/code&gt;方法源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;   //(1)
    lock.lockInterruptibly();
    try {
        while (count == 0)                  
            notEmpty.await();               //(2)
        return dequeue();
    } finally {
        lock.unlock();                      //(9)
    }
}

private E dequeue() {
    final Object[] items = this.items;
    @SuppressWarnings(&quot;unchecked&quot;)
    E x = (E) items[takeIndex];             //(3)
    items[takeIndex] = null;                //(4)
    if (++takeIndex == items.length)
        takeIndex = 0;                      //(5)
    count--;                                //(6)
    if (itrs != null)
        itrs.elementDequeued();             //(7)
    notFull.signal();                       //(8)
    return x;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(1):获取互斥锁&lt;br/&gt;(2):如果&lt;code&gt;count&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;，即队列为空，则释放互斥锁，然后挂起当前线程&lt;br/&gt;(3):根据&lt;code&gt;takeIndex&lt;/code&gt;索引到数组中获取具体的值,并赋值给&lt;code&gt;x&lt;/code&gt;&lt;br/&gt;(4):赋值完成后，&lt;code&gt;takeIndex&lt;/code&gt;索引位置数据置&lt;code&gt;null&lt;/code&gt;，便于回收&lt;br/&gt;(5):&lt;code&gt;takeIndex&lt;/code&gt;加&lt;code&gt;1&lt;/code&gt;，然后和队列长度比较，如果相等，即已经读取到队列尾部，&lt;code&gt;takeIndex&lt;/code&gt;置&lt;code&gt;0&lt;/code&gt;&lt;br/&gt;(6):获取后，将队列元素个数&lt;code&gt;count&lt;/code&gt;减&lt;code&gt;1&lt;/code&gt;&lt;br/&gt;(7):维护和&lt;code&gt;queue&lt;/code&gt;相关的迭代器&lt;br/&gt;(8):唤醒等待插入元素的线程&lt;br/&gt;(9):释放互斥锁&lt;br/&gt;可以看到&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;每次获取元素后，都会唤醒等待插入元素的线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;br/&gt;在分析源码前，我们先看在一个迭代器的示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.aidodoo.java.concurrent;

import java.util.Iterator;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

/**
 * Created by zhangkh on 2018/9/10.
 */
public class ArrayBlockingQueueIterDemo {
        public static void main(String[] args) throws InterruptedException{
            BlockingQueue&amp;lt;String&amp;gt; queue=new ArrayBlockingQueue(5);
            queue.put(&quot;hadoop&quot;);
            queue.put(&quot;spark&quot;);
            queue.put(&quot;storm&quot;);
            queue.put(&quot;flink&quot;);

            Iterator&amp;lt;String&amp;gt; iterator1 = queue.iterator();
            System.out.println( queue.take());
            System.out.println(queue.take());
            System.out.println(queue.take());
            System.out.println();
            while(iterator1.hasNext()) {
                System.out.println(iterator1.next());
            }
            System.out.println();
            Iterator&amp;lt;String&amp;gt; iterator2 = queue.iterator();
            while(iterator2.hasNext()) {
                System.out.println(iterator2.next());
            }
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hadoop
spark
storm

hadoop
flink

flink&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们结合这个示例来具体分析数据插入和获取时，内部成员变量的值&lt;br/&gt;当分别插入&lt;code&gt;hadoop&lt;/code&gt;、&lt;code&gt;spark&lt;/code&gt;、&lt;code&gt;storm&lt;/code&gt;、&lt;code&gt;flink&lt;/code&gt;四个元素后，内部变量的值如下：&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/ArrayBlockingQueueIter2.png&quot;/&gt;&lt;br/&gt;此时，&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;的成员变量的值&lt;code&gt;itrs&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;。&lt;br/&gt;调用&lt;code&gt;iterator()&lt;/code&gt;方法后,源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Iterator&amp;lt;E&amp;gt; iterator() {
    return new Itr();                   //(1)
}

Itr() {
lastRet = NONE;
final ReentrantLock lock = ArrayBlockingQueue.this.lock;
lock.lock();                            //(2)
try {
    if (count == 0) {                   //(3)
        cursor = NONE;
        nextIndex = NONE;
        prevTakeIndex = DETACHED;
    } else {
        final int takeIndex = ArrayBlockingQueue.this.takeIndex;
        prevTakeIndex = takeIndex;
        nextItem = itemAt(nextIndex = takeIndex);   //(4)
        cursor = incCursor(takeIndex);              //(5)
        if (itrs == null) {
            itrs = new Itrs(this);                  //(6)
        } else {
            itrs.register(this);                    //(7)
            itrs.doSomeSweeping(false);
        }
        prevCycles = itrs.cycles;
    }
} finally {
    lock.unlock();                                  //(8)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;(1):调用内部类&lt;code&gt;Itr&lt;/code&gt;的构造方法&lt;br/&gt;(2):获取外部类即&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;的锁&lt;br/&gt;(3):没有没有元素，初始化变量值。内部类&lt;code&gt;Itr&lt;/code&gt;的成员变量如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/** Index to look for new nextItem; NONE at end */
private int cursor;

/** Element to be returned by next call to next(); null if none */
private E nextItem;

/** Index of nextItem; NONE if none, REMOVED if removed elsewhere */
private int nextIndex;

/** Last element returned; null if none or not detached. */
private E lastItem;

/** Index of lastItem, NONE if none, REMOVED if removed elsewhere */
private int lastRet;

/** Previous value of takeIndex, or DETACHED when detached */
private int prevTakeIndex;

/** Previous value of iters.cycles */
private int prevCycles;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4):将外部类的&lt;code&gt;takeIndex&lt;/code&gt;赋值给内部类&lt;code&gt;nextIndex&lt;/code&gt;，并获取数组具体的值赋值给&lt;code&gt;nextItem&lt;/code&gt;&lt;br/&gt;(5):计算游标&lt;code&gt;cursor&lt;/code&gt;的下个值，其中&lt;code&gt;incCursor&lt;/code&gt;方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private int incCursor(int index) {
    // assert lock.getHoldCount() == 1;
    if (++index == items.length)
        index = 0;
    if (index == putIndex)
        index = NONE;
    return index;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(6):注册，主要是维护链表&lt;br/&gt;(7):清理&lt;code&gt;itrs&lt;/code&gt;&lt;br/&gt;(8):释放外部类的互斥锁&lt;br/&gt;在上面的示例中，调用&lt;code&gt;iterator()&lt;/code&gt;方法后，&lt;code&gt;Itr&lt;/code&gt;的内部变量值如下：&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/ArrayBlockingQueueIter3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于后面三次调用了&lt;code&gt;queue&lt;/code&gt;.&lt;code&gt;take()&lt;/code&gt;，依次输出&lt;code&gt;hadoop&lt;/code&gt;、&lt;code&gt;spark&lt;/code&gt;、&lt;code&gt;storm&lt;/code&gt;后，相关成员变量的值见图片标识，重点关注&lt;code&gt;takeIndex&lt;/code&gt;=&lt;code&gt;3&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当调用&lt;code&gt;next()&lt;/code&gt;方法时，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public E next() {
    final E x = nextItem;
    if (x == null)
        throw new NoSuchElementException();
    final ReentrantLock lock = ArrayBlockingQueue.this.lock;
    lock.lock();
    try {
        if (!isDetached())          //(1)
            incorporateDequeues();
        lastRet = nextIndex;
        final int cursor = this.cursor;
        if (cursor &amp;gt;= 0) {
            nextItem = itemAt(nextIndex = cursor);
            this.cursor = incCursor(cursor);
        } else {
            nextIndex = NONE;
            nextItem = null;
        }
    } finally {
        lock.unlock();
    }
    return x;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中(1)处的&lt;code&gt;isDetached&lt;/code&gt;方法如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean isDetached() {
    // assert lock.getHoldCount() == 1;
    return prevTakeIndex &amp;lt; 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们示例中初始化&lt;code&gt;Itr&lt;/code&gt;的时候的&lt;code&gt;prevTakeIndex&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;，故&lt;code&gt;isDetached&lt;/code&gt;返回为&lt;code&gt;false&lt;/code&gt;,程序将调用&lt;code&gt;incorporateDequeues&lt;/code&gt;方法，根据注释我们也知道，该方法主要是调整和迭代器相关的内部索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Adjusts indices to incorporate all dequeues since the last
 * operation on this iterator.  Call only from iterating thread.
 */
private void incorporateDequeues() {
    final int cycles = itrs.cycles;
    final int takeIndex = ArrayBlockingQueue.this.takeIndex;
    final int prevCycles = this.prevCycles;
    final int prevTakeIndex = this.prevTakeIndex;

    if (cycles != prevCycles || takeIndex != prevTakeIndex) {
        final int len = items.length;
        // how far takeIndex has advanced since the previous
        // operation of this iterator
        long dequeues = (cycles - prevCycles) * len
            + (takeIndex - prevTakeIndex);

        // Check indices for invalidation
        if (invalidated(lastRet, prevTakeIndex, dequeues, len))
            lastRet = REMOVED;
        if (invalidated(nextIndex, prevTakeIndex, dequeues, len))
            nextIndex = REMOVED;
        if (invalidated(cursor, prevTakeIndex, dequeues, len))
            cursor = takeIndex;

        if (cursor &amp;lt; 0 &amp;amp;&amp;amp; nextIndex &amp;lt; 0 &amp;amp;&amp;amp; lastRet &amp;lt; 0)
            detach();
        else {
            this.prevCycles = cycles;
            this.prevTakeIndex = takeIndex;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;cursor&lt;/code&gt; = &lt;code&gt;takeIndex&lt;/code&gt;这句代码，将外部内的&lt;code&gt;takeIndex&lt;/code&gt;赋值给&lt;code&gt;cursor&lt;/code&gt;,这样子将队列和迭代器数据读取进行了同步。&lt;br/&gt;对于&lt;code&gt;iterator1&lt;/code&gt;,第一次调用&lt;code&gt;next()&lt;/code&gt;方法时，&lt;code&gt;cursor&lt;/code&gt;被赋值为&lt;code&gt;3&lt;/code&gt;首先将&lt;code&gt;nextItem&lt;/code&gt;的值保持在&lt;code&gt;x&lt;/code&gt;变量中，即&lt;code&gt;hadoop&lt;/code&gt;字符串。&lt;br/&gt;然后设置&lt;code&gt;nextItem&lt;/code&gt;和&lt;code&gt;cursor&lt;/code&gt;的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nextItem = itemAt(nextIndex = cursor);
this.cursor = incCursor(cursor);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置完成后，&lt;code&gt;nextItem&lt;/code&gt;为&lt;code&gt;flink&lt;/code&gt;,&lt;code&gt;cursor&lt;/code&gt;为-&lt;code&gt;1&lt;/code&gt;。&lt;br/&gt;最后返回保存在&lt;code&gt;x&lt;/code&gt;变量中的值，即返回&lt;code&gt;hadoop&lt;/code&gt;字符串。&lt;br/&gt;第二次调用&lt;code&gt;next()&lt;/code&gt;方法时，输出的值即上次保存的&lt;code&gt;nextItem&lt;/code&gt;值，即&lt;code&gt;flink&lt;/code&gt;字符串。&lt;br/&gt;迭代器运行过程中，相关变量内容如下：&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/ArrayBlockingQueueIter4.png&quot;/&gt;&lt;br/&gt;至于&lt;code&gt;iterator2&lt;/code&gt;迭代器，各位可以自己去分析，不再赘述。&lt;/p&gt;
&lt;p&gt;本文主要以实例讲解&lt;code&gt;Semaphore&lt;/code&gt;、阻塞队列，并分析了相关核心源码实现。&lt;/p&gt;
&lt;p&gt;本文参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://it-ebooks.info/book/3916/&quot;&gt;Java 7 Concurrency Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ifeve.com/concurrency-modle-seven-week-1/&quot;&gt;concurrency-modle-seven-week&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/concurrency-models.html&quot;&gt;java-concurrency&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tutorials.jenkov.com/java-util-concurrent/lock.html&quot;&gt;java-util-concurrent&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/&quot;&gt;java se 8 apidoc&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;关于作者&lt;br/&gt;爱编程、爱钻研、爱分享、爱生活&lt;br/&gt;关注分布式、高并发、数据挖掘&lt;br/&gt;如需捐赠，请扫码&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/sqm.jpg&quot; width=&quot;256&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 06:14:00 +0000</pubDate>
<dc:creator>aidodoo</dc:creator>
<og:description>并发工具类 本系列文章主要讲解 并发相关的内容，包括同步、锁、信号量、阻塞队列、线程池等，整体思维导图如下： 系列文章列表：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aidodoo/p/9627357.html</dc:identifier>
</item>
<item>
<title>从壹开始前后端分离 [ Vue2.0+.NET Core2.1] 二十║Vue基础终篇：组件详解+项目说明 - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/9622031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/9622031.html</guid>
<description>&lt;p&gt;新的一天又开始啦，大家也应该看到我的标题了，是滴，Vue基础基本就到这里了，咱们回头看看这一路，如果你都看了，并且都会写了，那么现在你就可以自己写一个Demo了，如果再了解一点路由，ajax请求（这里是axios），那么你就可以准备面试前端了，哈哈，当然没有这么夸张，往后的路还很长，至少咱们基础都会了。&lt;/p&gt;
&lt;p&gt;这里咱们再温习下之前讲了哪些基础知识：&lt;/p&gt;
&lt;p&gt;《&lt;a id=&quot;post_title_link_9580807&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9580807.html&quot;&gt;十五 ║Vue前篇：了解JS面向对象原理 &amp;amp; 学会嵌套字面量等4种函数定义 &amp;amp; this指向&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;《&lt;a id=&quot;post_title_link_9585766&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9585766.html&quot;&gt;十六  ║Vue前篇：ES6知识详细说明 &amp;amp; 如何在JS中进行模块化编程&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;《&lt;a id=&quot;post_title_link_9593740&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9593740.html&quot;&gt;十七  ║Vue基础：第一次页面引入Vue.js，了解 Vue实例是如何通过数据驱动来操作DOM的&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;《&lt;a id=&quot;post_title_link_9602077&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9602077.html&quot;&gt;十八  ║Vue基础: 学习了常用的十大指令并一一举例，然后了解到了Vue的计算属性，侦听器，当然还有过滤器&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;《&lt;a id=&quot;post_title_link_9611632&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9611632.html&quot;&gt;十九  ║Vue基础: 通过样式的动态绑定，进一步学习Vue是如何操作DOM的，然后深入了解生命周期的八个阶段，以及其中的职能&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;一共是五篇，基本已经涵盖了Vue的基础知识，今天呢，再说完组件以后，明天就正式开始搭建本地脚手架，终于开始安装软件了[ 哭笑 ]，我这几天考虑了一下，在之后的讲解中，可能需要两个小项目的讲解，第一个就是我现在自己用到的一个，大家其实也可以看看 &lt;a href=&quot;http://vue.blog.azlinli.com/#/&quot; target=&quot;_blank&quot;&gt;http://vue.blog.azlinli.com&lt;/a&gt;（买的服务器不好，首次加载慢），也不是啥隐私，这个是我之前练习的时候自己瞎玩的，只有首页和详情页，用的数据就是咱们在之前系列里讲到的.net core api，这个可能在本周，或者本周末说到，主要的就是把之前的讲解给穿起来，然后再说下如何使用路由 v-router 和 ajax请求——axios，这样我这个项目就说到这里，&lt;strong&gt;然后第二个也是一个博客系统&lt;/strong&gt;，用的是一套数据，只不过是用到了 Nuxt 框架了，基本结构又发生了变化，项目整体被封装了，更趋于工程化，至于为什么要用到这个，就是因为它可以解决 MVVM 前后端分离的 SEO 的老大难的问题，大家可以先问问度娘，到时候都会说到滴。好啦，开始今天的基础篇最后一章节 —— 深入了解下组件。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180910200841987-1265075961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;1、注册组件&lt;/h3&gt;
&lt;p&gt;上篇文件我们也说到了，注册组件的其中一个办法就是 &lt;code&gt;Vue.component()&lt;/code&gt;方法，先传入一个自定义组件的名字，然后传入这个组件的配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 Vue.component(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mycomponent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{
    template: `&lt;/span&gt;&amp;lt;div&amp;gt;我的组件&amp;lt;/div&amp;gt;&lt;span&gt;`,
    data () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        message: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;老张的哲学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      }
    }
  })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义好后，我们就可以在Vue实例所定义的DOM元素内使用它（就是我们在new vue的时候的 el 节点），这里我们的页脚组件，全局组件，可以在其他地方使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;mycomponent&amp;gt;&amp;lt;/mycomponent&amp;gt;
    &amp;lt;my-component&amp;gt;&amp;lt;/my-component&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意要在vue实例之前去定义，不然渲染页面的时候，会报错
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个名为 footer-vue 的新组件&lt;/span&gt;
 Vue.component(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;footer-vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
     template: `
             &lt;/span&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;footer-vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                 &amp;lt;p&amp;gt;&lt;span&gt;2018&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;LZ&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s Blog&amp;lt;/a&amp;gt; - Hosted by &amp;lt;a href=&quot;#&quot; style=&quot;font-weight: bold&quot;&amp;gt;Coding Pages&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
                 &amp;lt;p&amp;gt;
                     &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;京ICP备00000000号&amp;lt;/a&amp;gt;
                 &amp;lt;/p&amp;gt;
             &amp;lt;/div&amp;gt;&lt;span&gt;
             `,
     data () {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
             message: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
         }
     }
 })

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没错，vue实例所定义的DOM元素就是这个，超过了这个区域，定义的组件会无效&lt;/span&gt;
&lt;span&gt;    data: {
    },
  })
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个时候，我们定义的组件是一个全局的组件，也就是说如果我们定义了多个 vue实例，我们都可以使用这一个组件，这就是全局的，当然，既然有全局的，我们也有局部的（我们对联系方法定义局部组件，表示只有在当前页面的app元素内使用）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    data: {
    },
    components: {
          &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;my-component&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
         template: `
             &lt;/span&gt;&amp;lt;ul &lt;span&gt;class&lt;/span&gt; =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contact-list non-style-list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
     &amp;lt;li&amp;gt;
         &amp;lt;b &lt;span&gt;class&lt;/span&gt; =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;twitter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;TWITTER&amp;lt;/b&amp;gt;: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;@laozhang&amp;lt;/a&amp;gt;
     &amp;lt;/li&amp;gt;
     &amp;lt;li&amp;gt;
         &amp;lt;b &lt;span&gt;class&lt;/span&gt; =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;weibo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;微博&amp;lt;/b&amp;gt;: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;@laozhang&amp;lt;/a&amp;gt;
     &amp;lt;/li&amp;gt;
     &amp;lt;li&amp;gt;
         &amp;lt;b &lt;span&gt;class&lt;/span&gt; =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhihu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;知乎&amp;lt;/b&amp;gt;: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;lt;/a&amp;gt;
     &amp;lt;/li&amp;gt;
     &amp;lt;li&amp;gt;
         &amp;lt;b &lt;span&gt;class&lt;/span&gt; =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;GITHUB&amp;lt;/b&amp;gt;: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://github.com/anjoy8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;anjoy8&amp;lt;/a&amp;gt;
     &amp;lt;/li&amp;gt;
     &amp;lt;li&amp;gt;
         &amp;lt;b &lt;span&gt;class&lt;/span&gt; =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;EMAIL&amp;lt;/b&amp;gt;: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mailto:laozhang@azlinli.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;randypriv at azlinli&amp;lt;/a&amp;gt;
     &amp;lt;/li&amp;gt;
 &amp;lt;/ul&amp;gt;&lt;span&gt;
             `,&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　data () {&lt;br/&gt;　　　　　　　　　　return {&lt;br/&gt;　　　　　　　　　　　　　　message: 'hello world two'&lt;br/&gt;　　　　　　　　　　}&lt;br/&gt;　　　　　　}&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;      }
    }
  })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2、组件的规范定义——单个根元素 + 函数 &lt;/h3&gt;
&lt;p&gt;观察一下上边两种写法与的特点，大家应该也能说出来：&lt;/p&gt;
&lt;p&gt;相同点：组件的模板只能有一个根节点，或者说根标签只能有一个（第一个的根元素是 &amp;lt;div&amp;gt;，第二个根元素是 &amp;lt;ul&amp;gt;），如果定义成这样就是不允许的，这里是两个根元素 &amp;lt;div&amp;gt; 和 &amp;lt;a&amp;gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
template: `&amp;lt;div&amp;gt;我的地盘听我的，哈哈，只能在当前我的Vue实例中使用&amp;lt;/div&amp;gt;
&amp;lt;a&amp;gt;我的一个标签&amp;lt;/a&amp;gt;&lt;br/&gt;　　　　　　`,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;p&gt;我们看到在定义组件的时候和平时定义的data不一样，这里的&lt;strong&gt;定义一定要是一个函数&lt;/strong&gt;，因为如果像Vue实例那样，传入一个对象，由于JS中对象类型的变量实际上保存的是对象的&lt;code&gt;引用&lt;/code&gt;，所以当存在多个这样的组件时，会共享数据，导致一个组件中数据的改变会引起其他组件数据的改变。而使用一个返回对象的函数，每次使用组件都会创建一个新的对象，这样就不会出现&lt;strong&gt;共享数据&lt;/strong&gt;的问题来了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 Vue.component(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;footer-vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
     template: `
             &lt;/span&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;footer-vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                 &amp;lt;p&amp;gt;
                     &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;京ICP备00000000号&amp;lt;/a&amp;gt;
                 &amp;lt;/p&amp;gt;
             &amp;lt;/div&amp;gt;&lt;span&gt;
             `,
     data ：{
             message: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们用普通属性的方法&lt;/span&gt;
&lt;span&gt;     }
 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果我们按照一个&lt;strong&gt;属性的写法&lt;/strong&gt;的话，页面会成功的报了一个这样的错误，而且大家注意，这个错误是出现在哪里的，没错就是&lt;strong&gt;挂载结束前&lt;/strong&gt;，也就是说，和实例化数据没影响，但是在挂载到页面，页面渲染的时候，出现了这个错误，所以大家在初学的时候，还是要多了解下生命周期的概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180910233335415-573295997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt; 注意：因为组件是可复用的 Vue 实例，所以它们与 &lt;code&gt;new Vue&lt;/code&gt; 接收相同的选项，例如 &lt;code&gt;data&lt;/code&gt;、&lt;code&gt;computed&lt;/code&gt;、&lt;code&gt;watch&lt;/code&gt;、&lt;code&gt;methods&lt;/code&gt; 以及生命周期钩子等。仅有的例外是像 &lt;code&gt;el&lt;/code&gt; 这样根实例特有的选项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;3、另外一种注册方式，通过 全局API：&lt;code&gt;Vue.extend()创建，然后由component来注册，两步&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  extend 创建组件&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; MyComponent =&lt;span&gt; Vue.extend({
  template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;A custom component!&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; component注册 组件&lt;/span&gt;
Vue.component(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;my-component&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, MyComponent);&lt;span&gt;//使用到了 extend 创建的组件
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#example&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  data: {
       
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 两种写法没有什么太多的区别，基本来说&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;extend 是构造创建一个组件的语法器，你给它参数 他给你创建一个组件， 然后这个组件，你可以作用到Vue.component 这个全局注册方法里， 也可以在任意vue模板里使用apple组件&lt;/p&gt;
&lt;p&gt;var apple = Vue.extend({ &lt;br/&gt;…. &lt;br/&gt;}) &lt;br/&gt;Vue.component(‘apple’,apple)&lt;/p&gt;
&lt;p&gt;你可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件&lt;/p&gt;
&lt;p&gt;new Vue({ &lt;br/&gt;components:{ &lt;br/&gt;apple:apple &lt;br/&gt;} &lt;br/&gt;})&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;可见上边的定义过程比较繁琐，也可以不用每次都调用两个，可以直接用 Vue.component 创建 ，也可以取组件 例如下&lt;/p&gt;
&lt;p&gt;var apple = Vue.component(‘apple’)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;4、动态组件 &lt;/h3&gt;
&lt;p&gt;你一定在开发中会遇到这样的需求，就是一个banner的切换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180911144233477-2003586616.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们这时候可以使用动态组件，很容易实现这个需求，通过 Vue 的 &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; 元素加一个特殊的 &lt;code&gt;is&lt;/code&gt; 特性来实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&amp;gt;
&amp;lt;component v-bind:&lt;span&gt;is&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;currentTabComponent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/component&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上述示例中，&lt;code&gt;currentTabComponent&lt;/code&gt; 可以包括&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;已注册组件的名字，或&lt;/li&gt;
&lt;li&gt;一个组件的选项对象&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dynamic-component-demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span&gt;button
    v&lt;/span&gt;-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tab in tabs&lt;/span&gt;&lt;span&gt;&quot;&lt;span&gt;//for 循环展示 banner&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
    v&lt;/span&gt;-bind:key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tab&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    v&lt;/span&gt;-bind:&lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;['tab-button', { active: currentTab === tab }]&lt;/span&gt;&lt;span&gt;&quot;&lt;span&gt;//绑定样式，当前组件增加 active 样式&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
    v&lt;/span&gt;-on:click=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;currentTab = tab&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
  &amp;gt;{{ tab }}&amp;lt;/button&amp;gt;
&lt;span&gt;&amp;lt;!-- 组件的使用 通过currentTabComponent 来动态展示是哪一个组件 --&amp;gt;&lt;/span&gt;
  &amp;lt;&lt;span&gt;component
    v&lt;/span&gt;-bind:&lt;span&gt;is&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;currentTabComponent&lt;/span&gt;&lt;span&gt;&quot;&lt;span&gt;//通过 is 特性，来动态实现组件，核心&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tab&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
  &amp;gt;&amp;lt;/component&amp;gt;
&amp;lt;/div&amp;gt;&lt;span&gt;&lt;span&gt;
//定义三个组件，可以比如是我们的三个页面，&lt;/span&gt;
Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tab-home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, { 
    template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;Home component&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt; //组件1，也就是页面&lt;/span&gt;1
})
Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tab-posts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, { 
    template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;Posts component&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt; //组件2，页面2&lt;/span&gt;
})
Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tab-archive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, { 
    template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;Archive component&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt; //组件3，页面3&lt;/span&gt;
})

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#dynamic-component-demo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  data: {
    currentTab: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;span&gt;//当前banner名称&lt;/span&gt;
    tabs: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Posts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Archive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]&lt;span&gt;//定义三个banner&lt;/span&gt;
  },
  computed: {&lt;span&gt;//计算属性，实时监控获取当然banner的值，并返回到页面&lt;/span&gt;
    currentTabComponent: function () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tab-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentTab.toLowerCase()&lt;span&gt;//组件名称拼串，一定要和上边的三个组件名对应&lt;/span&gt;
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 Vue 中，父子组件的关系可以总结为 &lt;code&gt;prop&lt;/code&gt; 向下传递，&lt;code&gt;事件&lt;/code&gt;向上传递。父组件通过 &lt;code&gt;prop&lt;/code&gt; 给子组件下发数据，子组件通过&lt;code&gt;事件&lt;/code&gt;给父组件发送消息，这里咱们先说下向下传递，通过属性Props属性来完成。&lt;/p&gt;
&lt;h3&gt;1、使用动态属性Props，可以将父组件的数据传递给子组件，从而达到父子通讯的第一步，举个栗子&lt;/h3&gt;
&lt;p&gt;还记得之前咱们说的，Vue 其实就是由许许多多个组件拼接而成，高效复用，相互之间可以传值，但是又不受影响，最常见的应用就是：组件 A 在它的模板中使用了组件 B。它们之间必然需要相互通信：父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告知父组件。大家第一次使用的时候可能会有点儿不舒服，但是使用熟练以后，就会发现真的得心应手，所以咱们就先看看组件是如何通讯的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180911001052196-2134969977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先大家还记得咱们定义的页脚组件么，就是刚刚说到的。咱们看到最下边是备案号，现在想在备案号旁边加上咱的昵称”老张的哲学“，想想很简单嘛，想想肯定不能直接写死数据吧，正好看到页面内定义vue实例的时候，有这个属性嘛，直接放到咱们的页脚组件里，嗯就是这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个名为 footer-vue 的新组件&lt;/span&gt;
  Vue.component(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;footer-vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
      template: `
                  &lt;/span&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;footer-vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                      &amp;lt;p&amp;gt;&lt;span&gt;2018&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;LZ&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s Blog&amp;lt;/a&amp;gt; - Hosted by &amp;lt;a href=&quot;#&quot; style=&quot;font-weight: bold&quot;&amp;gt;Coding Pages&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
                      &amp;lt;p&amp;gt;
                          &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;京ICP备00000000号&lt;span&gt;{{authorHtml}}&lt;/span&gt;&amp;lt;/a&amp;gt;
                      &amp;lt;/p&amp;gt;
                  &amp;lt;/div&amp;gt;&lt;span&gt;
                  `,
      data () {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
              message: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
          }
      }
  })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后满怀开心的刷新页面一看，额报错了：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180911001316281-519473036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后很熟练的必应翻译了一下（这是一个反面教材，大家要好好学习英文，多看国外教程 [苦笑] ），得到这样的：属性或方法  &quot;authorHtml &quot; 不应该是在实例上定义的, 而是在呈现过程中引用的。通过初始化属性, 确保此属性在数据选项或基于类的组件中是被动的。说人话就是，这里不能使用实例上定义的值，好吧，查阅资料发现，组件只能被动的接受父组件的传参数，嗯于是乎我们这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;footer-vue :foo=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/footer-vue&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在自定义的组件上，新增一个动态属性，然后属性的值 author 是父组件的，这个时候父组件就是已经把值给发过去了&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候，我们就需要在子组件里接受一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个名为 footer-vue 的新组件&lt;/span&gt;
 Vue.component(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;footer-vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
     template: `
             &lt;/span&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;footer-vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                 &amp;lt;p&amp;gt;&lt;span&gt;2018&lt;/span&gt; &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;LZ&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s Blog&amp;lt;/a&amp;gt; - Hosted by &amp;lt;a href=&quot;#&quot; style=&quot;font-weight: bold&quot;&amp;gt;Coding Pages&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
                 &amp;lt;p&amp;gt;
                     &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;京ICP备00000000号{{foo}}&amp;lt;/a&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里根据自身的props的参数来赋值&lt;/span&gt;
                 &amp;lt;/p&amp;gt;
             &amp;lt;/div&amp;gt;&lt;span&gt;
             `,
     props: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里根据组件的props属性，来被动接受组件传递来的参数&lt;/span&gt;
&lt;span&gt;     data () {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
             message: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
         }
     }
 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刷新页面，这时候就真正的成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180911003445706-1733604449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、使用静态Props传值&lt;/h3&gt;
&lt;p&gt;这里我们得到的结果和上边的是一样的，直接是一个字符串结果，而不是一个变量属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Vue.component(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明 props&lt;/span&gt;
  props: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 就像 data 一样，prop 也可以在模板中使用
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同样也可以在 vm 实例中通过 this.message 来使用&lt;/span&gt;
  template: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;span&amp;gt;{{ message }}&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
})

&lt;/span&gt;&amp;lt;child message=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老张的哲学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/child&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3、注意大小写的命名的写法&lt;/h3&gt;
&lt;p&gt;注意：HTML 特性是不区分大小写的。所以，当使用的不是字符串模板时，camelCase (驼峰式命名) 的 prop 需要转换为相对应的 kebab-case (短横线分隔式命名)，比如 如何上边的foo 写成了 fooPro ，那我们定义属性的时候，就应该写 foo-pro&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;footer-vue :foo-pro=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/footer-vue&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果我们写了 fooPro 这样的写法，挂载页面的时候，就会警告，并且不会成功渲染&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180911082449474-511681292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201809/1468246-20180911082510077-362309079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你使用字符串模板，则没有这些限制。（字符串模板：指的是在组件选项里用 template:&quot;&quot; 指定的模板，换句话说，写在 js 中的 template:&quot;&quot; 中的就是字符串模板。）&lt;/p&gt;



&lt;p&gt;我们知道，父组件使用 prop 传递数据给子组件。但子组件怎么跟父组件通信呢？这个时候 Vue 的自定义事件系统就派得上用场了。&lt;/p&gt;
&lt;h3&gt; 1、使用 v-on 绑定自定义事件&lt;/h3&gt;
&lt;p&gt;每个 Vue 实例都实现了事件接口，即：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 $on(eventName) 监听事件&lt;/li&gt;
&lt;li&gt;使用 $emit(eventName) 触发事件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Vue 的事件系统与浏览器的 &lt;code&gt;EventTarget API&lt;/code&gt; 有所不同。尽管它们的运行起来类似，但是 &lt;code&gt;$on &lt;/code&gt;和 &lt;code&gt;$emit&lt;/code&gt; 并不是&lt;code&gt;addEventListener&lt;/code&gt; 和&lt;code&gt; dispatchEvent&lt;/code&gt; 的别名。&lt;/p&gt;
&lt;p&gt;另外，父组件可以在使用子组件的地方直接用 &lt;code&gt;v-on&lt;/code&gt; 来监听子组件触发的事件。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;counter-event-example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;p&amp;gt;{{ total }}&amp;lt;/p&amp;gt;
  &amp;lt;button-counter v-on:increment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;incrementTotal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/button-counter&amp;gt;
  &amp;lt;button-counter v-on:increment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;incrementTotal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/button-counter&amp;gt;
&amp;lt;/div&amp;gt;&lt;span&gt;


Vue.component(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;button-counter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
  template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;button v-on:click=&quot;incrementCounter&quot;&amp;gt;{{ counter }}&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  data: function () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      counter: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    }
  },
  methods: {
    incrementCounter: function () {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.counter += &lt;span&gt;1&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.$emit(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;increment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    }
  },
})

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#counter-event-example&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  data: {
    total: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  },
  methods: {
    incrementTotal: function () {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.total += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2、使用自定义事件的表单输入组件&lt;/h3&gt;
&lt;p&gt;自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。要牢记：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;input v-model=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;something&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这不过是以下示例的语法糖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;input
  v&lt;/span&gt;-bind:value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;something&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  v&lt;/span&gt;-on:input=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;something = $event.target.value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以在组件中使用时，它相当于下面的简写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;custom-&lt;span&gt;input
  v&lt;/span&gt;-bind:value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;something&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  v&lt;/span&gt;-on:input=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;something = arguments[0]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;/custom-input&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;custom-input v-model=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;something&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/custom-input&amp;gt;
    &amp;lt;br/&amp;gt;&lt;span&gt;
    {{something}}
&lt;/span&gt;&amp;lt;/div&amp;gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册&lt;/span&gt;
Vue.component(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;custom-input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
  props:[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;something&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
  template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;input type=&quot;text&quot;  v-bind:value=&quot;something&quot; v-on:input=&quot;updateValue($event.target.value)&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  methods:{
      updateValue:function(value){
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$emit(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, value)
      }
  }
})
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  data: {
       something:&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;
  }
  
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;在使用组件时，我们常常要像这样组合它们：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;app&amp;gt;
  &amp;lt;app-header&amp;gt;&amp;lt;/app-header&amp;gt;
  &amp;lt;app-footer&amp;gt;&amp;lt;/app-footer&amp;gt;
&amp;lt;/app&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;app&amp;gt;&lt;/code&gt; 组件不知道它会收到什么内容。这是由使用 &lt;code&gt;&amp;lt;app&amp;gt;&lt;/code&gt; 的父组件决定的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;app&amp;gt;&lt;/code&gt; 组件很可能有它自己的模板。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。使用特殊的 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 元素作为原始内容的插槽。&lt;/p&gt;
&lt;p&gt;一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 无效 --&amp;gt;
&amp;lt;child-component v-show=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;someChildProperty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/child-component&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;正确做法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Vue.component(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child-component&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有效，因为是在正确的作用域内&lt;/span&gt;
  template: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div v-show=&quot;someChildProperty&quot;&amp;gt;Child&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  data: function () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      someChildProperty: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;articleHeader23&quot;&gt;单个插槽&lt;/h3&gt;
&lt;p&gt;假定 my-component 组件有如下模板：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;div&amp;gt;
  &amp;lt;h2&amp;gt;我是子组件的标题&amp;lt;/h2&amp;gt;
  &amp;lt;slot&amp;gt;&lt;span&gt;
    只有在没有要分发的内容时才会显示。
  &lt;/span&gt;&amp;lt;/slot&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;父组件模板：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;div&amp;gt;
  &amp;lt;h1&amp;gt;我是父组件的标题&amp;lt;/h1&amp;gt;
  &amp;lt;my-component&amp;gt;
    &amp;lt;p&amp;gt;这是一些初始内容&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;这是更多的初始内容&amp;lt;/p&amp;gt;
  &amp;lt;/my-component&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;渲染结果：&lt;/p&gt;


&lt;p&gt;今天简单的说了下关于组件的一些问题，因为事件的问题，还没有说完，还在进一步整理当中，大家可以以后进一步的浏览本博文，通过组件的学习，大家在Vue开发的道路上又进了一步，好啦，关于Vue的基础知识就是这么多了，明天开始进入代码练习啦~~&lt;/p&gt;


&lt;p&gt;https://github.com/anjoy8?tab=repositories&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 06:12:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>缘起 新的一天又开始啦，大家也应该看到我的标题了，是滴，Vue基础基本就到这里了，咱们回头看看这一路，如果你都看了，并且都会写了，那么现在你就可以自己写一个Demo了，如果再了解一点路由，ajax请求</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/9622031.html</dc:identifier>
</item>
</channel>
</rss>