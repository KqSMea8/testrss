<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>精进：如何成为一个很厉害的人---思维导图 - 孤舟点点</title>
<link>http://www.cnblogs.com/weijiangbao/p/7968006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weijiangbao/p/7968006.html</guid>
<description>&lt;p&gt;&lt;strong&gt;先来图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133613/201712/1133613-20171203234041991-653074370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;大纲：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;精进：如何成为一个很厉害的人&lt;br/&gt;标记: 作者：采铜（崔翔宇）&lt;/p&gt;
&lt;p&gt;推荐原因:&lt;/p&gt;
&lt;p&gt;2016年首本值得推荐的自我提升类好书，解答了大多数人经常遇到的自我成长中的问题。非常高兴看到，采铜把知乎上的精彩答案进一步扩展成一本心智成长指南，推荐给每一个想成功的青年阅读。——战隼&lt;/p&gt;
&lt;p&gt;采铜老师擅长把艰深晦涩的学术理论，转化成兴味盎然的生活常识；把逻辑严密的理性思维，升华成感动人心的热血情怀。他的工具只有两个：严肃地思考和认真地生活。他是一个思想者和生活家。——动机在杭州&lt;/p&gt;
&lt;p&gt;这不是一本书。这是一柄助强者劈开眼前迷雾的剑。作者居然为这个时代一半左右的都市流行病，拿出了有效的治疗方案……主治在校学生和职场新人的学业不调和前程不通。在这个鸡汤当道的年头里，这本书烧出了一条锋锐的路。——梁边妖&lt;/p&gt;
&lt;p&gt;主要内容：&lt;/p&gt;
&lt;p&gt;盲目的努力，只是一种缓慢的叠加。&lt;/p&gt;
&lt;p&gt;在《精进：如何成为一个很厉害的人》中，作者提出了一种更有效的提升自我的方法：只使用非常小的力量，就能达到意想不到的效果，这便是精进。&lt;br/&gt;这本书为大家提供了时间、选择、行动、学习、思维、才能、成功七个方面的精进路径，只要依循书中的方法反复磨练，便可以日益精进，成为一个很厉害的人，找到实现自我的那条成功之道。&lt;br/&gt;采铜惯于使用手术刀一样的文字，剖析人们思维里的种种禁锢，将现实生活中的问题放于困惑的熔炉中反复冶炼，提炼出知识背后的知识、方法背后的方法。&lt;br/&gt;在这本书中，采铜选取了影响人生的七个关键切面，一一设计出它们的精进路径，帮助人们找到解决问题的支点：只需要非常小的力量，你就可以成为真正的赢家。&lt;/p&gt;
&lt;p&gt;章节剖析&lt;/p&gt;
&lt;p&gt;第一章&lt;br/&gt;——我们应该怎样对待时间&lt;/p&gt;
&lt;p&gt;一、 活在“全部的现在”&lt;/p&gt;
&lt;p&gt;（从当下出发，联结过去与未来）&lt;/p&gt;
&lt;p&gt;二、 对五年后的自己提问&lt;/p&gt;
&lt;p&gt;（如何解决远期与近期未来的冲突？）&lt;/p&gt;
&lt;p&gt;三、 我们总是在重复地抓起沙子&lt;/p&gt;
&lt;p&gt;（把时间花在值得做的事情上）&lt;/p&gt;
&lt;p&gt;四、 “快”与“慢”的自由切换&lt;/p&gt;
&lt;p&gt;（为什么我们的时间永远不够用？）&lt;/p&gt;
&lt;p&gt;第二章 寻找心中的“巴拿马”&lt;br/&gt;——如何做出比好更好的选择&lt;/p&gt;
&lt;p&gt;一、 从终极问题出发&lt;/p&gt;
&lt;p&gt;（以人生终极目标作为首要原则）&lt;/p&gt;
&lt;p&gt;二、 逃离隐含假设的牢笼&lt;/p&gt;
&lt;p&gt;（发现人生中的更多可能选项）&lt;/p&gt;
&lt;p&gt;三、 克服天性中的选择弱势&lt;/p&gt;
&lt;p&gt;（选择太多怎么办？）&lt;/p&gt;
&lt;p&gt;四、 人生是持续而反复的构造&lt;/p&gt;
&lt;p&gt;（校正选择，做出建设性的改变）&lt;/p&gt;
&lt;p&gt;第三章 即刻行动&lt;br/&gt;——改变一切的核心力量&lt;/p&gt;
&lt;p&gt;一、 “现在”就是恰当的时机&lt;/p&gt;
&lt;p&gt;汤姆·布坎南其实在黛西为盖茨比华美的衣衫落泪之前，就有一阵子不喜欢盖茨比了。他的调查使事情更加复杂。原来，盖茨比原是个叫詹姆斯的穷孩子，他的财富都来源于非法活动（赌博，私售酒类），难怪盖茨比有这么多麻烦要应付。&lt;/p&gt;
&lt;p&gt;二、 精益创业的行动启示&lt;/p&gt;
&lt;p&gt;（把“未完成”变成“已完成” ）&lt;/p&gt;
&lt;p&gt;三、 像Photoshop一样分解任务&lt;/p&gt;
&lt;p&gt;（从工作的核心区开始）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;四 、 三行而后思&lt;/p&gt;
&lt;p&gt;（在实践中，通过复盘积累智慧）&lt;/p&gt;
&lt;p&gt;第四章 怎样的学习，才能够直面现实？&lt;br/&gt;——如何成为一个高段位的学习者？&lt;/p&gt;
&lt;p&gt;一、 找到一切学习的向导&lt;/p&gt;
&lt;p&gt;（好的学习者，首先要向自己提问）&lt;/p&gt;
&lt;p&gt;二、 不要只做信息的搬运工&lt;/p&gt;
&lt;p&gt;（通过解码，深入事物的深层）&lt;/p&gt;
&lt;p&gt;三、 技能，才是学习的终点&lt;/p&gt;
&lt;p&gt;（你能够调用的知识有多少？）&lt;/p&gt;
&lt;p&gt;四、 分离的知识，难以解答真正的现实&lt;/p&gt;
&lt;p&gt;（让不同的知识发生化学作用）&lt;/p&gt;
&lt;p&gt;第五章 向未知的无限逼近&lt;br/&gt;——修炼思维，成为真正的利器&lt;/p&gt;
&lt;p&gt;一、 大脑需要“断舍离”&lt;/p&gt;
&lt;p&gt;（ 简化，是清晰思考的前提 ）&lt;/p&gt;
&lt;p&gt;二、 迎接“灵光乍现”的时刻&lt;/p&gt;
&lt;p&gt;（让潜意识为你工作）&lt;/p&gt;
&lt;p&gt;三、 思考可以有自己的形状&lt;/p&gt;
&lt;p&gt;（将思维转化为图像 ）&lt;/p&gt;
&lt;p&gt;四、 世界上没有轻而易举的答案&lt;/p&gt;
&lt;p&gt;（只有极少数的人能做到周密思考）&lt;/p&gt;
&lt;p&gt;第六章 努力，是一种需要学习的才能&lt;br/&gt;——不断优化你的“努力”方式&lt;/p&gt;
&lt;p&gt;一、 努力本身就是一种才能&lt;/p&gt;
&lt;p&gt;（努力需要有效的策略）&lt;/p&gt;
&lt;p&gt;二、 没有突出的长板就是危险&lt;/p&gt;
&lt;p&gt;（专注发展自己的优势才能）&lt;/p&gt;
&lt;p&gt;三、 你是“差不多先生”吗？&lt;/p&gt;
&lt;p&gt;（绝不苟且，才能做到极致）&lt;/p&gt;
&lt;p&gt;四、 挑战是设计出来的&lt;/p&gt;
&lt;p&gt;（不断为自己设计“必要的难度”挑战 ）&lt;/p&gt;
&lt;p&gt;五、 不痛苦地坚持到底&lt;/p&gt;
&lt;p&gt;（只有深入下去，才能培养起真正的兴趣）&lt;/p&gt;
&lt;p&gt;第七章 每一个成功者，都是唯一的&lt;br/&gt;——创造成功，而不是复制成功&lt;/p&gt;
&lt;p&gt;一、 “学渣”与“学霸”都不是好选择&lt;/p&gt;
&lt;p&gt;（做一个主动探索的学习者）&lt;/p&gt;
&lt;p&gt;二、 从“游乐场”到“荒野求生”&lt;/p&gt;
&lt;p&gt;（怎样从大学走向社会？）&lt;/p&gt;
&lt;p&gt;三、 独特性，就是你的核心竞争力&lt;/p&gt;
&lt;p&gt;（请坚持你的与众不同！ ）&lt;/p&gt;
</description>
<pubDate>Sun, 03 Dec 2017 15:42:00 +0000</pubDate>
<dc:creator>孤舟点点</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weijiangbao/p/7968006.html</dc:identifier>
</item>
<item>
<title>微信公众号批量爬取java版 - ljw不想加班</title>
<link>http://www.cnblogs.com/luojiangwen/p/7943696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luojiangwen/p/7943696.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近需要爬取微信公众号的文章信息。&lt;/span&gt;&lt;span&gt;在网上找了找发现微信公众号爬取的难点在于公众号文章链接在pc端是打不开的，要用微信的自带浏览器（拿到微信客户端补充的参数，才可以在其它平台打开），这就给爬虫程序造成很大困扰。&lt;/span&gt;&lt;span&gt;后来在知乎上看到了一位大牛用php写的微信公众号爬取程序，就直接按大佬的思路整了整搞成java的了。改造途中遇到蛮多细节问题，拿出来分享一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;附上大牛文章链接：https://zhuanlan.zhihu.com/c_65943221  写php的或者只需要爬取思路的可以直接看这个，思路写的非常详细。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;系统的基本思路是在安卓模拟器上运行微信，模拟器设置代理，通过代理服务器拦截微信数据，将得到的数据发送给自己的程序进行处理。&lt;/p&gt;
&lt;p&gt;需要准备的环境：nodejs，anyproxy代理，安卓模拟器&lt;/p&gt;
&lt;p&gt;nodejs下载地址：http://nodejs.cn/download/，我下载的是windows版的，下好直接安装就行。安装好后，直接运行C:\Program Files\nodejs\npm.cmd 会自动配置好环境。&lt;/p&gt;
&lt;p&gt;anyproxy安装：按上一步安装好nodejs之后，直接在cmd运行 npm install -g anyproxy 就会安装了&lt;/p&gt;
&lt;p&gt;安卓模拟器随便在网上下一个就好了，一大堆。&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;首先为代理服务器安装证书，anyproxy默认不解析https链接，安装证书后就可以解析了，在cmd执行anyproxy --root 就会安装证书，之后还得在模拟器也下载这个证书。&lt;/p&gt;
&lt;p&gt;然后输入anyproxy -i 命令 打开代理服务。（记得加上参数！）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/987333/201712/987333-20171203213719679-1172091502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;记住这个ip和端口，之后安卓模拟器的代理就用这个。现在用浏览器打开网页：http://localhost:8002/  这是anyproxy的网页界面，用于显示http传输数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/987333/201712/987333-20171201161451180-494977915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击上面红框框里面的菜单，会出一个二维码，用安卓模拟器扫码识别，模拟器（手机）就会下载证书了，安装上就好了。&lt;/p&gt;
&lt;p&gt;现在准备为模拟器设置代理，代理方式设置为手动，代理ip为运行anyproxy机器的ip，端口是8001&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/987333/201712/987333-20171203214012241-390481711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到这里准备工作基本完成，在模拟器上打开微信随便打开一个公众号的文章，就能从你刚打开的web界面中看到anyproxy抓取到的数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/987333/201712/987333-20171201161951836-1805139785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面红框内就是微信文章的链接，点击进去可以看到具体的数据。如果response body里面什么都没有可能证书安装有问题。&lt;/p&gt;
&lt;p&gt;如果上面都走通了，就可以接着往下走了。&lt;/p&gt;
&lt;p&gt;这里我们靠代理服务抓微信数据，但总不能抓取一条数据就自己操作一下微信，那样还不如直接人工复制。所以我们需要微信客户端自己跳转页面。这时就可以使用anyproxy拦截微信服务器返回的数据，往里面注入页面跳转代码，再把加工的数据返回给模拟器实现微信客户端自动跳转。&lt;/p&gt;
&lt;p&gt;打开anyproxy中的一个叫rule_default.js的js文件，windows下该文件在：C:\Users\Administrator\AppData\Roaming\npm\node_modules\anyproxy\lib&lt;/p&gt;
&lt;p&gt;在文件里面有个叫replaceServerResDataAsync: function(req,res,serverResData,callback)的方法，这个方法就是负责对anyproxy拿到的数据进行各种操作。一开始应该只有callback(serverResData)；这条语句的意思是直接返回服务器响应数据给客户端。直接删掉这条语句，替换成大牛写的如下代码。这里的代码我并没有做什么改动，里面的注释也解释的给非常清楚，直接按逻辑看懂就行，问题不大。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; replaceServerResDataAsync: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res,serverResData,callback){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(/mp\/getmasssendmsg/i.test(req.url)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当链接地址为公众号历史消息页面时(第一种页面形式)&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(&quot;开始第一种页面爬取&quot;);&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(serverResData.toString() !== &quot;&quot;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止报错退出程序&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; reg = /msgList = (.*?);/;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义历史消息正则匹配规则&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; ret = reg.exec(serverResData.toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换变量为string&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                     HttpPost(ret[1],req.url,&quot;/InternetSpider/getData/showBiz&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个函数是后文定义的，将匹配到的历史消息json发送到自己的服务器&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; http = require('http'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     http.get('http://xxx/getWxHis', &lt;span&gt;function&lt;/span&gt;(res) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个地址是自己服务器上的一个程序，目的是为了获取到下一个链接地址，将地址放在一个js脚本中，将页面自动跳转到下一页。后文将介绍getWxHis.php的原理。&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                         res.on('data', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(chunk){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                         callback(chunk+serverResData);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将返回的代码插入到历史消息页面中，并返回显示出来&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                        })
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    });
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 }&lt;span&gt;catch&lt;/span&gt;(e){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果上面的正则没有匹配到，那么这个页面内容可能是公众号历史消息页面向下翻动的第二页，因为历史消息第一页是html格式的，第二页就是json格式的。&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(&quot;开始第一种页面爬取向下翻形式&quot;);&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                      &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; JSON.parse(serverResData.toString());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (json.general_msg_list !=&lt;span&gt; []) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         HttpPost(json.general_msg_list,req.url,&quot;/xxx/showBiz&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个函数和上面的一样是后文定义的，将第二页历史消息的json发送到自己的服务器&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                      }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                        console.log(e);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误捕捉&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                     }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     callback(serverResData);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接返回第二页json内容&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(&quot;开始第一种页面爬取 结束&quot;);&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(/mp\/profile_ext\?action=home/i.test(req.url)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当链接地址为公众号历史消息页面时(第二种页面形式)&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; reg = /var msgList = \'(.*?)\';/;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义历史消息正则匹配规则（和第一种页面形式的正则不同）&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ret = reg.exec(serverResData.toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换变量为string&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                 HttpPost(ret[1],req.url,&quot;/xxx/showBiz&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个函数是后文定义的，将匹配到的历史消息json发送到自己的服务器&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; http = require('http'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 http.get('xxx/getWxHis', &lt;span&gt;function&lt;/span&gt;(res) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个地址是自己服务器上的一个程序，目的是为了获取到下一个链接地址，将地址放在一个js脚本中，将页面自动跳转到下一页。后文将介绍getWxHis.php的原理。&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                         res.on('data', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(chunk){
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                         callback(chunk+serverResData);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将返回的代码插入到历史消息页面中，并返回显示出来&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                        })
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                    });
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(e);&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                callback(serverResData);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(/mp\/profile_ext\?action=getmsg/i.test(req.url)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种页面表现形式的向下翻页后的json&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; JSON.parse(serverResData.toString());
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (json.general_msg_list !=&lt;span&gt; []) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                     HttpPost(json.general_msg_list,req.url,&quot;/xxx/showBiz&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个函数和上面的一样是后文定义的，将第二页历史消息的json发送到自己的服务器&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                console.log(e);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            callback(serverResData);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(/mp\/getappmsgext/i.test(req.url)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当链接地址为公众号文章阅读量和点赞量时&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 HttpPost(serverResData,req.url,&quot;/xxx/getMsgExt&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数是后文定义的，功能是将文章阅读量点赞量的json发送到服务器&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;            callback(serverResData);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(/s\?__biz/i.test(req.url) || /mp\/rumor/i.test(req.url)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当链接地址为公众号文章时（rumor这个地址是公众号文章被辟谣了）&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; http = require('http'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                 http.get('http://xxx/getWxPost', &lt;span&gt;function&lt;/span&gt;(res) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个地址是自己服务器上的另一个程序，目的是为了获取到下一个链接地址，将地址放在一个js脚本中，将页面自动跳转到下一页。后文将介绍getWxPost.php的原理。&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;                     res.on('data', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(chunk){
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                         callback(chunk+&lt;span&gt;serverResData);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;                    })
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;                callback(serverResData);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            callback(serverResData);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;callback(serverResData);&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt;     },
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里简单解释一下，微信公众号的历史消息页链接有两种形式：一种以&lt;span data-reactid=&quot;.1.1.2.0.0.0.1.0.1:$reqHeader_host.1&quot;&gt; &lt;span data-reactid=&quot;.1.1.2.0.0.0.1.0.1:$reqHeader_host.2&quot;&gt;mp.weixin.qq.com&lt;/span&gt;&lt;/span&gt;/mp/getmasssendmsg 开头，另一种是 &lt;span data-reactid=&quot;.1.1.2.0.0.0.1.0.1:$reqHeader_host.1&quot;&gt;&lt;span data-reactid=&quot;.1.1.2.0.0.0.1.0.1:$reqHeader_host.2&quot;&gt;mp.weixin.qq.com/&lt;/span&gt;&lt;/span&gt;mp/profile_ext 开头。历史页是可以向下翻的，如果向下翻将触发js事件发送请求得到json数据（下一页内容）。还有公众号文章链接，以及文章的阅读量和点赞量的链接（返回的是json数据），这几种链接的形式是固定的可以通过逻辑判断来区分。这里有个问题就是历史页如果需要全部爬取到该怎么做到。我的思路是通过js去模拟鼠标向下滑动，从而触发提交加载下一部分列表的请求。或者直接利用anyproxy分析下滑加载的请求，直接向微信服务器发生这个请求。但都有一个问题就是如何判断已经没有余下数据了。我是爬取最新数据，暂时没这个需求，可能以后要。如果有需求的可以尝试一下。&lt;/p&gt;
&lt;p&gt;下图是上文中的HttpPost方法内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; HttpPost(str,url,path) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将json发送到服务器，str为json内容，url为历史消息页面地址，path是接收程序的路径和文件名&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     console.log(&quot;开始执行转发操作&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; http = require('http'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        str: encodeURIComponent(str),
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        url: encodeURIComponent(url)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     data = require('querystring'&lt;span&gt;).stringify(data);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; options =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         method: &quot;POST&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         host: &quot;xxx&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意没有http://，这是服务器的域名。&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         port: xxx&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         path: path,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收程序的路径和文件名&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        headers: {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &quot;Content-Length&quot;&lt;span&gt;: data.length
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; req = http.request(options, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         res.setEncoding('utf8'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         res.on('data', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (chunk) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             console.log('BODY: ' +&lt;span&gt; chunk);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     req.on('error', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         console.log('problem with request: ' +&lt;span&gt; e.message);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    req.write(data);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    req.end();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         console.log(&quot;错误信息：&quot;+&lt;span&gt;e);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     console.log(&quot;转发操作结束&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;做完以上工作，接下来就是按自己业务来完成服务端代码了，我们的服务用于接收代理服务器发过来的数据进行处理，进行持久化操作，同时向代理服务器发送需要注入到微信的js代码。针对代理服务器拦截到的几种不同链接发来的数据，我们就需要设计相应的方法来处理这些数据。从anyproxy处理微信数据的js方法replaceServerResDataAsync: function(req,res,serverResData,callback)中，我们可以知道至少需要对公众号历史页数据、公众号文章页数据、公众号文章点赞量和阅读量数据设计三种方法来处理。同时我们还需要设计一个方法来生成爬取任务，完成公众号的轮寻爬取。如果需要爬取更多数据，可以从anyproxy抓取到的链接中分析出更多需要的数据，然后往replaceServerResDataAsync: function(req,res,serverResData,callback)中添加判定，拦截到需要的数据发送到自己的服务器，相应的在服务端添加方法处理该类数据就行了。&lt;/p&gt;
&lt;p&gt;我是用java写的服务端代码。&lt;/p&gt;
&lt;p&gt;处理公众号历史页数据方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getMsgJson(String str ,String url) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UnsupportedEncodingException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        String biz = &quot;&quot;&lt;span&gt;;
        Map&lt;/span&gt;&amp;lt;String,String&amp;gt; queryStrs =&lt;span&gt; HttpUrlParser.parseUrl(url);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(queryStrs != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            biz &lt;/span&gt;= queryStrs.get(&quot;__biz&quot;&lt;span&gt;);
            biz &lt;/span&gt;= biz + &quot;==&quot;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 从数据库中查询biz是否已经存在，如果不存在则插入，
         * 这代表着我们新添加了一个采集目标公众号。
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        List&lt;/span&gt;&amp;lt;WeiXin&amp;gt; results =&lt;span&gt; weiXinMapper.selectByBiz(biz);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(results == &lt;span&gt;null&lt;/span&gt; || results.size() == 0&lt;span&gt;){
            WeiXin weiXin &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WeiXin();
            weiXin.setBiz(biz);
            weiXin.setCollect(System.currentTimeMillis());
            weiXinMapper.insert(weiXin);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(str);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析str变量&lt;/span&gt;
        List&amp;lt;Object&amp;gt; lists = JsonPath.read(str, &quot;['list']&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object list : lists){&lt;/span&gt;
            Object json =&lt;span&gt; list;&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; type = JsonPath.read(json, &quot;['comm_msg_info']['type']&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(type == 49){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;type=49表示是图文消息&lt;/span&gt;
                String content_url = JsonPath.read(json, &quot;$.app_msg_ext_info.content_url&quot;&lt;span&gt;);
                content_url &lt;/span&gt;= content_url.replace(&quot;\\&quot;, &quot;&quot;).replaceAll(&quot;amp;&quot;, &quot;&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得图文消息的链接地址&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; is_multi = JsonPath.read(json, &quot;$.app_msg_ext_info.is_multi&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否是多图文消息&lt;/span&gt;
                Integer datetime = JsonPath.read(json, &quot;$.comm_msg_info.datetime&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图文消息发送时间&lt;/span&gt;
                &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                 * 在这里将图文消息链接地址插入到采集队列库tmplist中
                 * （队列库将在后文介绍，主要目的是建立一个批量采集队列，
                 * 另一个程序将根据队列安排下一个采集的公众号或者文章内容）
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(content_url != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(content_url)){
                        TmpList tmpList &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TmpList();
                        tmpList.setContentUrl(content_url);
                        tmpListMapper.insertSelective(tmpList);
                    }
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
                    System.out.println(&lt;/span&gt;&quot;队列已存在,不插入！&quot;&lt;span&gt;);
                }
                
                &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                 * 在这里根据$content_url从数据库post中判断一下是否重复
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                List&lt;/span&gt;&amp;lt;Post&amp;gt; postList =&lt;span&gt; postMapper.selectByContentUrl(content_url);
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; contentUrlExist = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(postList != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; postList.size() != 0&lt;span&gt;){
                    contentUrlExist &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            
                
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!contentUrlExist){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;'数据库post中不存在相同的$content_url'&lt;/span&gt;
                    Integer fileid = JsonPath.read(json, &quot;$.app_msg_ext_info.fileid&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个微信给的id&lt;/span&gt;
                    String title = JsonPath.read(json, &quot;$.app_msg_ext_info.title&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文章标题&lt;/span&gt;
                    String title_encode = URLEncoder.encode(title, &quot;utf-8&quot;&lt;span&gt;);
                    String digest &lt;/span&gt;= JsonPath.read(json, &quot;$.app_msg_ext_info.digest&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文章摘要&lt;/span&gt;
                    String source_url = JsonPath.read(json, &quot;$.app_msg_ext_info.source_url&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读原文的链接&lt;/span&gt;
                    source_url = source_url.replace(&quot;\\&quot;, &quot;&quot;&lt;span&gt;);
                    String cover &lt;/span&gt;= JsonPath.read(json, &quot;$.app_msg_ext_info.cover&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封面图片&lt;/span&gt;
                    cover = cover.replace(&quot;\\&quot;, &quot;&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                     * 存入数据库
                     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    System.out.println(&quot;头条标题：&quot;+title);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    System.out.println(&quot;微信ID：&quot;+fileid);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    System.out.println(&quot;文章摘要:&quot;+digest);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    System.out.println(&quot;阅读原文链接:&quot;+source_url);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    System.out.println(&quot;封面图片地址:&quot;+cover);                    &lt;/span&gt;
&lt;span&gt;                    
                    Post post &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Post();
                    post.setBiz(biz);
                    post.setTitle(title);
                    post.setTitleEncode(title_encode);
                    post.setFieldId(fileid);
                    post.setDigest(digest);
                    post.setSourceUrl(source_url);
                    post.setCover(cover);
                    post.setIsTop(&lt;/span&gt;1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记一下是头条内容&lt;/span&gt;
&lt;span&gt;                    post.setIsMulti(is_multi);
                    post.setDatetime(datetime);
                    post.setContentUrl(content_url);
                    
                    postMapper.insert(post);
                }
            
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(is_multi == 1){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是多图文消息&lt;/span&gt;
                    List&amp;lt;Object&amp;gt; multiLists = JsonPath.read(json, &quot;['app_msg_ext_info']['multi_app_msg_item_list']&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object multiList : multiLists){
                        Object multiJson &lt;/span&gt;=&lt;span&gt; multiList;                    
                        content_url &lt;/span&gt;= JsonPath.read(multiJson, &quot;['content_url']&quot;).toString().replace(&quot;\\&quot;, &quot;&quot;).replaceAll(&quot;amp;&quot;, &quot;&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图文消息链接地址&lt;/span&gt;
                        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                         * 这里再次根据$content_url判断一下数据库中是否重复以免出错
                         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                        contentUrlExist &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        List&lt;/span&gt;&amp;lt;Post&amp;gt; posts =&lt;span&gt; postMapper.selectByContentUrl(content_url);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(posts != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; posts.size() != 0&lt;span&gt;){
                            contentUrlExist &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!contentUrlExist){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;'数据库中不存在相同的$content_url'&lt;/span&gt;
                            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                             * 在这里将图文消息链接地址插入到采集队列库中
                             * （队列库将在后文介绍，主要目的是建立一个批量采集队列，
                             * 另一个程序将根据队列安排下一个采集的公众号或者文章内容）
                             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt;(content_url != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;&lt;span&gt;.equals(content_url)){
                                TmpList tmpListT &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TmpList();
                                tmpListT.setContentUrl(content_url);
                                tmpListMapper.insertSelective(tmpListT);
                            }
                            
                            String title &lt;/span&gt;= JsonPath.read(multiJson, &quot;$.title&quot;&lt;span&gt;);
                            String title_encode &lt;/span&gt;= URLEncoder.encode(title, &quot;utf-8&quot;&lt;span&gt;);
                            Integer fileid &lt;/span&gt;= JsonPath.read(multiJson, &quot;$.fileid&quot;&lt;span&gt;);
                            String digest &lt;/span&gt;= JsonPath.read(multiJson, &quot;$.digest&quot;&lt;span&gt;);
                            String source_url &lt;/span&gt;= JsonPath.read(multiJson, &quot;$.source_url&quot;&lt;span&gt;);
                            source_url &lt;/span&gt;= source_url.replace(&quot;\\&quot;, &quot;&quot;&lt;span&gt;);
                            String cover &lt;/span&gt;= JsonPath.read(multiJson, &quot;$.cover&quot;&lt;span&gt;);
                            cover &lt;/span&gt;= cover.replace(&quot;\\&quot;, &quot;&quot;&lt;span&gt;);                        
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                            System.out.println(&quot;标题:&quot;+title);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                            System.out.println(&quot;微信ID:&quot;+fileid);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                            System.out.println(&quot;文章摘要:&quot;+digest);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                            System.out.println(&quot;阅读原文链接:&quot;+source_url);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                            System.out.println(&quot;封面图片地址:&quot;+cover);&lt;/span&gt;&lt;span&gt;                            
                            Post post &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Post();
                            post.setBiz(biz);
                            post.setTitle(title);
                            post.setTitleEncode(title_encode);
                            post.setFieldId(fileid);
                            post.setDigest(digest);
                            post.setSourceUrl(source_url);
                            post.setCover(cover);
                            post.setIsTop(&lt;/span&gt;0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记一下不是头条内容&lt;/span&gt;
&lt;span&gt;                            post.setIsMulti(is_multi);
                            post.setDatetime(datetime);
                            post.setContentUrl(content_url);
                            
                            postMapper.insert(post);
                            
                        }
                    }
                }            
            }        
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;处理公众号文章页的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getWxPost() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 当前页面为公众号文章页面时，读取这个程序
         * 首先删除采集队列表中load=1的行
         * 然后从队列表中按照“order by id asc”选择多行(注意这一行和上面的程序不一样)
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        tmpListMapper.deleteByLoad(&lt;/span&gt;1&lt;span&gt;);
        List&lt;/span&gt;&amp;lt;TmpList&amp;gt; queues = tmpListMapper.selectMany(5&lt;span&gt;);&lt;/span&gt;
        String url = &quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(queues != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; queues.size() != 0 &amp;amp;&amp;amp; queues.size() &amp;gt; 1&lt;span&gt;){
            TmpList queue &lt;/span&gt;= queues.get(0&lt;span&gt;);
            url &lt;/span&gt;=&lt;span&gt; queue.getContentUrl();
            queue.setIsload(&lt;/span&gt;1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; tmpListMapper.updateByPrimaryKey(queue);
            System.out.println(&lt;/span&gt;&quot;update result:&quot;+&lt;span&gt;result);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;getpost queues is null?&quot;+queues==&lt;span&gt;null&lt;/span&gt;?&lt;span&gt;null&lt;/span&gt;&lt;span&gt;:queues.size());
            WeiXin weiXin &lt;/span&gt;=&lt;span&gt; weiXinMapper.selectOne();
            String biz &lt;/span&gt;=&lt;span&gt; weiXin.getBiz();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((Math.random()&amp;gt;0.5?1:0) == 1&lt;span&gt;){
                url &lt;/span&gt;= &quot;http://mp.weixin.qq.com/mp/getmasssendmsg?__biz=&quot; + biz + 
                        &quot;#wechat_webview_type=1&amp;amp;wechat_redirect&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼接公众号历史消息url地址（第一种页面形式）&lt;/span&gt;
            }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                url &lt;/span&gt;= &quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;amp;__biz=&quot; + biz + 
                        &quot;#wechat_redirect&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼接公众号历史消息url地址（第二种页面形式）&lt;/span&gt;
&lt;span&gt;            }
            url &lt;/span&gt;= &quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;amp;__biz=&quot; + biz + 
                    &quot;#wechat_redirect&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼接公众号历史消息url地址（第二种页面形式）
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新刚才提到的公众号表中的采集时间time字段为当前时间戳。&lt;/span&gt;
&lt;span&gt;            weiXin.setCollect(System.currentTimeMillis());
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; weiXinMapper.updateByPrimaryKey(weiXin);
            System.out.println(&lt;/span&gt;&quot;getPost weiXin updateResult:&quot;+&lt;span&gt;result);
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; randomTime = &lt;span&gt;new&lt;/span&gt; Random().nextInt(3) + 3&lt;span&gt;;
        String jsCode &lt;/span&gt;= &quot;&amp;lt;script&amp;gt;setTimeout(function(){window.location.href='&quot;+url+&quot;';},&quot;+randomTime*1000+&quot;);&amp;lt;/script&amp;gt;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jsCode;
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;处理公众号点赞量和阅读量的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getMsgExt(String str,String url) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        String biz = &quot;&quot;&lt;span&gt;;
        String sn &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        Map&lt;/span&gt;&amp;lt;String,String&amp;gt; queryStrs =&lt;span&gt; HttpUrlParser.parseUrl(url);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(queryStrs != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            biz &lt;/span&gt;= queryStrs.get(&quot;__biz&quot;&lt;span&gt;);
            biz &lt;/span&gt;= biz + &quot;==&quot;&lt;span&gt;;
            sn &lt;/span&gt;= queryStrs.get(&quot;sn&quot;&lt;span&gt;);
            sn &lt;/span&gt;= &quot;%&quot; + sn + &quot;%&quot;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * $sql = &quot;select * from `文章表` where `biz`='&quot;.$biz.&quot;'
         * and `content_url` like '%&quot;.$sn.&quot;%'&quot; limit 0,1;
         * 根据biz和sn找到对应的文章
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Post post &lt;/span&gt;=&lt;span&gt; postMapper.selectByBizAndSn(biz, sn);
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(post == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;biz:&quot;+&lt;span&gt;biz);
            System.out.println(&lt;/span&gt;&quot;sn:&quot;+&lt;span&gt;sn);
            tmpListMapper.deleteByLoad(&lt;/span&gt;1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;json数据:&quot;+str);&lt;/span&gt;
&lt;span&gt;        Integer read_num;
        Integer like_num;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            read_num &lt;/span&gt;= JsonPath.read(str, &quot;['appmsgstat']['read_num']&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读量&lt;/span&gt;
            like_num  = JsonPath.read(str, &quot;['appmsgstat']['like_num']&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点赞量&lt;/span&gt;
        }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
            read_num &lt;/span&gt;= 123;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读量&lt;/span&gt;
            like_num  = 321;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点赞量&lt;/span&gt;
            System.out.println(&quot;read_num:&quot;+&lt;span&gt;read_num);
            System.out.println(&lt;/span&gt;&quot;like_num:&quot;+&lt;span&gt;like_num);
            System.out.println(e.getMessage());
        }        
        
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 在这里同样根据sn在采集队列表中删除对应的文章，代表这篇文章可以移出采集队列了
         * $sql = &quot;delete from `队列表` where `content_url` like '%&quot;.$sn.&quot;%'&quot; 
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        tmpListMapper.deleteBySn(sn);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后将阅读量和点赞量更新到文章表中。&lt;/span&gt;
&lt;span&gt;        post.setReadnum(read_num);
        post.setLikenum(like_num);
        postMapper.updateByPrimaryKey(post);
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;处理跳转向微信注入js的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getWxHis() {
        String url &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 当前页面为公众号历史消息时，读取这个程序
         * 在采集队列表中有一个load字段，当值等于1时代表正在被读取
         * 首先删除采集队列表中load=1的行
         * 然后从队列表中任意select一行
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        tmpListMapper.deleteByLoad(&lt;/span&gt;1&lt;span&gt;);
        TmpList queue &lt;/span&gt;=&lt;span&gt; tmpListMapper.selectRandomOne();
        System.out.println(&lt;/span&gt;&quot;queue is null?&quot;+&lt;span&gt;queue);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(queue == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列表为空&lt;/span&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 队列表如果空了，就从存储公众号biz的表中取得一个biz，
             * 这里我在公众号表中设置了一个采集时间的time字段，按照正序排列之后，
             * 就得到时间戳最小的一个公众号记录，并取得它的biz
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            WeiXin weiXin &lt;/span&gt;=&lt;span&gt; weiXinMapper.selectOne();
            
            String biz &lt;/span&gt;=&lt;span&gt; weiXin.getBiz();&lt;/span&gt;
            url = &quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;amp;__biz=&quot; + biz + 
                    &quot;#wechat_redirect&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼接公众号历史消息url地址（第二种页面形式）
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新刚才提到的公众号表中的采集时间time字段为当前时间戳。&lt;/span&gt;
&lt;span&gt;            weiXin.setCollect(System.currentTimeMillis());
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; weiXinMapper.updateByPrimaryKey(weiXin);
            System.out.println(&lt;/span&gt;&quot;getHis weiXin updateResult:&quot;+&lt;span&gt;result);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得当前这一行的content_url字段&lt;/span&gt;
            url =&lt;span&gt; queue.getContentUrl();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将load字段update为1&lt;/span&gt;
&lt;span&gt;            tmpListMapper.updateByContentUrl(url);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将下一个将要跳转的$url变成js脚本，由anyproxy注入到微信页面中。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;echo &quot;&amp;lt;script&amp;gt;setTimeout(function(){window.location.href='&quot;.$url.&quot;';},2000);&amp;lt;/script&amp;gt;&quot;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; randomTime = &lt;span&gt;new&lt;/span&gt; Random().nextInt(3) + 3&lt;span&gt;;
        String jsCode &lt;/span&gt;= &quot;&amp;lt;script&amp;gt;setTimeout(function(){window.location.href='&quot;+url+&quot;';},&quot;+randomTime*1000+&quot;);&amp;lt;/script&amp;gt;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jsCode;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上就是对处理代理服务器拦截到的数据进行处理的程序。这里有一个需要注意的问题，程序会对数据库中的每个收录的公众号进行轮循访问，甚至是已经存储的文章也会再次访问，目的是为了一直更新文章的阅读数和点赞数。如果需要抓取大量的公众号建议对添加任务队列的代码进行修改，添加条件限制，否则公众号一多 轮循抓取重复数据将十分影响效率。&lt;/p&gt;
&lt;p&gt;至此就将微信公众号的文章链接全部爬取到，而且这个链接是永久有效而且可以在浏览器打开的链接，接下来就是写爬虫程序从数据库中拿链接爬取文章内容等信息了。&lt;/p&gt;
&lt;p&gt;我是用webmagic写的爬虫，轻量好用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SpiderModel &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; PageProcessor{
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; PostMapper postMapper;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Post&amp;gt;&lt;span&gt; posts;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抓取网站的相关配置，包括编码、抓取间隔、重试次数等&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Site site = Site.me().setRetryTimes(3).setSleepTime(100&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Site getSite() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.site;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(Page page) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        Post post = posts.remove(0&lt;span&gt;);
        String content &lt;/span&gt;= page.getHtml().xpath(&quot;//div[@id='js_content']&quot;&lt;span&gt;).get();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存在和谐文章 此处做判定如果有直接删除记录或设置表示位表示文章被和谐&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(content == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;文章已和谐！&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;postMapper.deleteByPrimaryKey(post.getId());&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        String contentSnap &lt;/span&gt;= content.replaceAll(&quot;data-src&quot;, &quot;src&quot;).replaceAll(&quot;preview.html&quot;, &quot;player.html&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;快照&lt;/span&gt;
        String contentTxt = HtmlToWord.stripHtml(content);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纯文本内容&lt;/span&gt;
&lt;span&gt;        
        Selectable metaContent &lt;/span&gt;= page.getHtml().xpath(&quot;//div[@id='meta_content']&quot;&lt;span&gt;);
        String pubTime &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String wxname &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String author &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(metaContent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            pubTime &lt;/span&gt;= metaContent.xpath(&quot;//em[@id='post-date']&quot;&lt;span&gt;).get();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pubTime != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                pubTime &lt;/span&gt;= HtmlToWord.stripHtml(pubTime);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文章发布时间&lt;/span&gt;
&lt;span&gt;            }
            wxname &lt;/span&gt;= metaContent.xpath(&quot;//a[@id='post-user']&quot;&lt;span&gt;).get();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(wxname != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                wxname &lt;/span&gt;= HtmlToWord.stripHtml(wxname);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;公众号名称&lt;/span&gt;
&lt;span&gt;            }
            author &lt;/span&gt;= metaContent.xpath(&quot;//em[@class='rich_media_meta rich_media_meta_text' and @id!='post-date']&quot;&lt;span&gt;).get();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(author != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                author &lt;/span&gt;= HtmlToWord.stripHtml(author);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文章作者&lt;/span&gt;
&lt;span&gt;            }
        }
        
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;发布时间:&quot;+pubTime);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;公众号名称:&quot;+wxname);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;文章作者:&quot;+author);&lt;/span&gt;
&lt;span&gt;        
        String title &lt;/span&gt;= post.getTitle().replaceAll(&quot;&amp;amp;nbsp;&quot;, &quot;&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文章标题&lt;/span&gt;
        String digest = post.getDigest();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文章摘要&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; likeNum = post.getLikenum();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文章点赞数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; readNum = post.getReadnum();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文章阅读数&lt;/span&gt;
        String contentUrl = post.getContentUrl();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文章链接&lt;/span&gt;
&lt;span&gt;        
        WechatInfoBean wechatBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WechatInfoBean();
        wechatBean.setTitle(title);
        wechatBean.setContent(contentTxt);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纯文本内容&lt;/span&gt;
        wechatBean.setSourceCode(contentSnap);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;快照&lt;/span&gt;
&lt;span&gt;        wechatBean.setLikeCount(likeNum);
        wechatBean.setViewCount(readNum);
        wechatBean.setAbstractText(digest);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;摘要&lt;/span&gt;
&lt;span&gt;        wechatBean.setUrl(contentUrl);
        wechatBean.setPublishTime(pubTime);
        wechatBean.setSiteName(wxname);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;站点名称 公众号名称&lt;/span&gt;
&lt;span&gt;        wechatBean.setAuthor(author);
        wechatBean.setMediaType(&lt;/span&gt;&quot;微信公众号&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;来源媒体类型&lt;/span&gt;
&lt;span&gt;        
        WechatStorage.saveWechatInfo(wechatBean);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标示文章已经被爬取&lt;/span&gt;
        post.setIsSpider(1&lt;span&gt;);
        postMapper.updateByPrimaryKey(post);
        
    }    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startSpider(List&amp;lt;Post&amp;gt;&lt;span&gt; inposts,PostMapper myPostMapper,String... urls){
        
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; startTime, endTime;
        startTime &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        postMapper &lt;/span&gt;=&lt;span&gt; myPostMapper;
        posts &lt;/span&gt;=&lt;span&gt; inposts;
        
        HttpClientDownloader httpClientDownloader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClientDownloader();        
        SpiderModel spiderModel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpiderModel();
        Spider mySpider &lt;/span&gt;=&lt;span&gt; Spider.create(spiderModel).addUrl(urls);
        mySpider.setDownloader(httpClientDownloader);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            SpiderMonitor.instance().register(mySpider);
            mySpider.thread(&lt;/span&gt;1&lt;span&gt;).run();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMException e) {
            e.printStackTrace();
        }
        
        endTime &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        System.out.println(&lt;/span&gt;&quot;爬取时间&quot; + ((endTime - startTime) / 1000) + &quot;秒--&quot;&lt;span&gt;);
        
    }&lt;/span&gt;&lt;span&gt;
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它的一些无关逻辑的存储数据代码就不贴了，这里我把代理服务器抓取到的数据存在了mysql，把自己的爬虫程序爬到的数据存储在了mongodb。&lt;/p&gt;
&lt;p&gt;下面是自己爬取到的公众号号的信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/987333/201712/987333-20171203230151632-675107429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/987333/201712/987333-20171203230218397-1312260200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 03 Dec 2017 15:08:00 +0000</pubDate>
<dc:creator>ljw不想加班</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luojiangwen/p/7943696.html</dc:identifier>
</item>
<item>
<title>谈谈form-data请求格式 - wonyun</title>
<link>http://www.cnblogs.com/wonyun/p/7966967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wonyun/p/7966967.html</guid>
<description>&lt;p&gt;最近一直都比较忙，坚持月月更新博客的计划不得中止了，今天好不容易抽出点时间来说说最近项目中遇到的一个问题，有关request post请求格式中的&lt;strong&gt;multipart/form-data&lt;/strong&gt;格式。&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;最近在项目过程中遇到一个问题，相信大部分人都遇到过：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在后端与前端约定好&lt;strong&gt;application/json&lt;/strong&gt;格式传递数据时，因为后台是&lt;code&gt;go&lt;/code&gt;强类型语言，在定义api接口时，某些字段要求是整型类型，但是对于前端来说输入框或者从url中的search取到的参数都是字符串，不得不进行前端类型转换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;咋一看，对于接口参数比较少的api前端转换没有什么，但是对于一般的交互复杂，参数众多的详情编辑接口，要对大部分参数进行类型转换就是一种吃力不讨好的活。于是想到了另一种的前后端数据交互格式，即&lt;code&gt;multipart/form-data&lt;/code&gt;。这样后端取到前端传递的数据就是数字了(即使前端传递的是字符串)，而不像json格式获取的是字符串。这样，就不需要额外对前端获取的数据进行特殊转换了。下面就来说说form-data。&lt;/p&gt;
&lt;h2 id=&quot;form-data请求格式&quot;&gt;form-data请求格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;multipart/form-data&lt;/code&gt;是基于&lt;strong&gt;post&lt;/strong&gt;方法来传递数据的，并且其请求内容格式为&lt;strong&gt;Content-Type: multipart/form-data&lt;/strong&gt;,用来指定指定的数据编码格式。另外，该格式会生成一个&lt;code&gt;boundary&lt;/code&gt;字符串来分割请求体的post内容。请求头与请求体以一个&lt;code&gt;boundary=${boundary}&lt;/code&gt;来进行分割，具体如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;...
Content-Type: multipart/form-data; boundary=${boundary} 

--${boundary}
...
...

--${boundary}--&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面&lt;code&gt;boundary=${boundary}&lt;/code&gt;之后就是请求体内容了，请求体内容各字段之间以&lt;code&gt;--${boundary}&lt;/code&gt;来进行分割,以&lt;code&gt;--${boundary}--&lt;/code&gt;来接受请求体内容。具体可以参考下面例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryyb1zYhTI38xpQxBK

------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name=&quot;city_id&quot;

1

------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name=&quot;company_id&quot;

2
------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;
Content-Type: image/png

PNG ... content of chrome.png ...
------WebKitFormBoundaryyb1zYhTI38xpQxBK--&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;form-data&lt;/code&gt;格式一般是用来进行文件上传的。使用表单上传文件时，必须让&lt;/p&gt;
&lt;form readability=&quot;41.63683788122&quot;&gt;
&lt;p&gt;表单的 enctype 等于 &lt;code&gt;multipart/form-data&lt;/code&gt;，因为该值默认值为&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;formdata对象&quot;&gt;FormData对象&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;XMLHttpRequest Level 2&lt;/code&gt;添加了一个新的接口FormData。利用FormData对象，我们可以通过JavaScript用一些键值对来模拟一系列表单控件，我们还可以使用XMLHttpRequest的&lt;code&gt;send()&lt;/code&gt;方法来异步的提交这个&quot;表单&quot;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; formData &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;FormData&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;formData&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Groucho&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;formData&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;accountnum&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;123456&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;at&quot;&gt;fetch&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/users'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'POST'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; formData
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面创建了一个FormData对象，通过&lt;a href=&quot;https://github.com/github/fetch&quot;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/a&gt;进行ajax请求时，会自动为其将其转为&lt;code&gt;form-data&lt;/code&gt;格式，无需手动添加格式。&lt;/p&gt;
&lt;h2 id=&quot;对象转formdata对象&quot;&gt;对象转FormData对象&lt;/h2&gt;
&lt;p&gt;对于FormDat对象，像上面那种形式可以直接添加参数比较方便，但是对于对象或者嵌套对象：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; userObj &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;userName&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; ’xxx&lt;span class=&quot;st&quot;&gt;', age: '&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'}&lt;/span&gt;
 &lt;span class=&quot;va&quot;&gt;formData&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;append&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'user'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; userObj)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面形式添加formData参数user，并不会获取到其真正的内容，而是返回userObj的Object.prototype.toString.call(userObj)的值作为user字段的值。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;------&lt;/span&gt;WebKitFormBoundaryyb1zYhTI38xpQxBK
Content&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;Disposition&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; form&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;data&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;user&quot;&lt;/span&gt;

[object Object]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遗憾的是，FormData对象没有像JSON.stringify那样的方法能批量将对象形式转换为对应的形式，formData而言是将对象的&lt;code&gt;key&lt;/code&gt;转换为正确formData请求参数字段名，例如如下对象：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; obj &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'2'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;dt&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; 
    &lt;span class=&quot;dt&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [ 
        &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'xx'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; 
        &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'yy'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    ]
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样转换为FormData对象时，其对应的&lt;strong&gt;key&lt;/strong&gt;应该是下面这样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;a&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
b[c]&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; test
c[][id]&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
c[][name]&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; xx
c[][id]&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
c[][name]&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; yy
c[][info][d]&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，就需要我们自己手动来实现一个转换数据函数，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;objectToFormData&lt;/span&gt; (obj&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; form&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; namespace) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; fd &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; form &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;FormData&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; formKey&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  
  &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; property &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; obj) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;obj&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;hasOwnProperty&lt;/span&gt;(property)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; key &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isArray&lt;/span&gt;(obj) &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'[]'&lt;/span&gt; : &lt;span class=&quot;vs&quot;&gt;`[&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;property&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;]`&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(namespace) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
          formKey &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; namespace &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; key&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
          formKey &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; property&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
      
        &lt;span class=&quot;co&quot;&gt;// if the property is an object, but not a File, use recursivity.&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; obj[property] &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'object'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;(obj[property] &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; File)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;at&quot;&gt;objectToFormData&lt;/span&gt;(obj[property]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; fd&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; formKey)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
          
          &lt;span class=&quot;co&quot;&gt;// if it's a string or a File object&lt;/span&gt;
          &lt;span class=&quot;va&quot;&gt;fd&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;append&lt;/span&gt;(formKey&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; obj[property])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; fd&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，就可以将对象转化为对应的formData的格式了。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://imququ.com/post/four-ways-to-post-data-in-http.html&quot;&gt;四种常见的 POST 提交数据方式&lt;/a&gt;&lt;br/&gt;2、&lt;a href=&quot;http://www.jianshu.com/p/3d7817a2e461&quot;&gt;转换formdata参数格式&lt;/a&gt;&lt;br/&gt;2、&lt;a href=&quot;https://gist.github.com/ghinda/8442a57f22099bdb2e34&quot;&gt;gist&lt;/a&gt;&lt;br/&gt;3、&lt;a href=&quot;https://github.com/github/fetch&quot;&gt;fetch&lt;/a&gt;&lt;/p&gt;
&lt;/form&gt;
</description>
<pubDate>Sun, 03 Dec 2017 15:05:00 +0000</pubDate>
<dc:creator>wonyun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wonyun/p/7966967.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 Canvas 的简易 2D 3D 编辑器 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/7955923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/7955923.html</guid>
<description>&lt;p&gt;不管在任何领域，只要能让非程序员能通过拖拽来实现 2D 和 3D 的设计图就是很牛的，今天我们不需要 3dMaxs 等设计软件，直接用 HT 就能自己写出一个 2D 3D 编辑器，实现这个功能我觉得成就感还是爆棚的，哈哈！只要你会想，能做，就能根据这个编辑器延展成 big thing！&lt;/p&gt;
&lt;p&gt;本例地址：&lt;a href=&quot;http://www.hightopo.com/demo/drag-create-data/&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/demo/drag-create-data/ &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是实现效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201712/591709-20171203192947944-1777944841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们首先将所有需要用到的 json 文件作为矢量图输出，矢量图的好处是组件上的图元缩放都不会失真，并且不再需要为 Retina 显示屏提供不同尺寸的图片， 在 &lt;a href=&quot;http://www.quirksmode.org/blog/archives/2012/07/more_about_devi.html&quot;&gt;devicePixelRatio&lt;/a&gt; 多样化的移动时代， 要实现完美的跨平台，矢量可能是的最低成本的解决方案。&lt;/p&gt;
&lt;p&gt;HT 通过 ht.Default.setImage 函数来注册图片，可以是 base64、jpg、 png 以及 json 格式的图片：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
ht.Default.setImage('edit', 'images/default.json'&lt;span&gt;);
ht.Default.setImage(&lt;/span&gt;'shape', 'images/edit.json'&lt;span&gt;);
ht.Default.setImage(&lt;/span&gt;'edge', 'images/edge.json'&lt;span&gt;);
ht.Default.setImage(&lt;/span&gt;'circle', 'images/circle.json'&lt;span&gt;);
ht.Default.setImage(&lt;/span&gt;'roundRect', 'images/roundRect.json'&lt;span&gt;);
ht.Default.setImage(&lt;/span&gt;'rect', 'images/rect.json');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这边我注册的是顶部工具条的 6 个图片，分别为“编辑”、“不规则图形”、“圆”、“圆角矩形”、“矩形”以及“连线”，功能如其名。主要操作：点击工具条的任意一个图标，在工具条下的空白处拖动鼠标，即可实现绘图。&lt;/p&gt;
&lt;p&gt;那么接下来的步骤就是创建“工具条”，HT 封装了工具条的组件 ht.widget.Toolbar 在这个函数的参数中填入工具条中的元素，具体操作方法请看 &lt;a href=&quot;http://hightopo.com/guide/guide/core/toolbar/ht-toolbar-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 工具条手册&lt;/a&gt;，这边值得注意的一个点是，groupId 是将一个类型的元素分组，分组的好处是在我们选中这个组中的任意一个元素的时候，其他的元素都不选中，就能造成“单选”的效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56.671314741036&quot;&gt;
&lt;pre&gt;
toolbar = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.widget.Toolbar();
toolbar.addItem(createItem(&lt;/span&gt;'edit', 'edit', '编辑', [ &lt;span&gt;new&lt;/span&gt; ht.graph.EditInteractor(graphView)]));&lt;span&gt;//这边最后一个参数数组可放置多个交互器，具体定义请参见 &lt;a href=&quot;http://hightopo.com/guide/guide/core/beginners/ht-beginners-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 入门手册&lt;/a&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;addItem(item, index)可在指定index位置插入新元素，index为空代表插入到最后。&lt;/span&gt;
toolbar.addItem(createItem('shape', 'shape', '不规则图形',  [ &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CreateShapeInteractor(graphView)]));
toolbar.addItem(createItem(&lt;/span&gt;'circle', 'circle', '圆', [ &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CreateNodeInteractor(graphView)]));
toolbar.addItem(createItem(&lt;/span&gt;'roundRect', 'roundRect', '圆角矩形', [ &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CreateNodeInteractor(graphView)]));
toolbar.addItem(createItem(&lt;/span&gt;'rect', 'rect', '矩形', [ &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CreateNodeInteractor(graphView)]));
toolbar.addItem(createItem(&lt;/span&gt;'edge', 'edge', '连线', [ &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CreateEdgeInteractor(graphView)]));
toolbar.getItemById(&lt;/span&gt;'edit').selected = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认选中“编辑”&lt;/span&gt;
toolbar.getSelectBackground = &lt;span&gt;function&lt;/span&gt;(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重载自定义选中背景颜色&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; '#eee'&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面用到的 addItem 函数是向 ht.widget.Toolbar 工具条中添加元素，添加的元素是从 createItem 函数中传回来的元素，我们在这个函数中利用了 vector 矢量创造了一个矩形和一张图片的结合体，我们将之前注册好的矢量图传给这个结合体中的“图片”，然后通过控制这个图片的“渲染颜色”，来过滤工具条选中和非选中状态的颜色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createItem(id, iconName, toolTip, interactorsArr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item =&lt;span&gt; {
        id: id,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具条元素的唯一标示，如果设置可通过getItemById获取&lt;/span&gt;
        unfocusable: &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具条元素是否不可获取焦点，默认鼠标滑过时会显示一个矩形边框，可设置为true关闭此效果&lt;/span&gt;
        icon: iconName,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具条元素的图标&lt;/span&gt;
        toolTip: toolTip,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具条元素的文字提示&lt;/span&gt;
        groupId: 'bar'&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对工具条元素进行分组，同一个分组内的元素选中会自动出现互斥效果&lt;/span&gt;
&lt;span&gt;    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; ht.Default.getImage(iconName);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; width = json ? json.width : 16&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; height = json ? json.height : 16&lt;span&gt;;

    item.icon &lt;/span&gt;=&lt;span&gt; {
        width: width &lt;/span&gt;+ 8&lt;span&gt;,
        height: height &lt;/span&gt;+ 8&lt;span&gt;,
        fitSize: json &lt;/span&gt;? json.fitSize : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        comps: [
            {
                type: &lt;/span&gt;'rect',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组件类型&lt;/span&gt;
                rect: [0, 0, width + 8, height + 8]&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定组件绘制在矢量中的矩形边界&lt;/span&gt;
&lt;span&gt;            },
            {
                type: &lt;/span&gt;'image'&lt;span&gt;,
                name: iconName,
                color: {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渲染颜色，HT系统会自动采用该颜色对图片内容进行渲染&lt;/span&gt;
                    func: (data, view) =&amp;gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '#000'&lt;span&gt;
                    }
                }
            }
        ]
    };

    item.action &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数类型，工具条元素被点击时调用&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; toolbar.getItems().length; i++&lt;span&gt;){
            toolbar.getItems()[i].icon.comps[&lt;/span&gt;1].color = '#000'&lt;span&gt;;
        }
        item.icon.comps[&lt;/span&gt;1].color = '#1E90FF'&lt;span&gt;;
        graphView.setInteractors(interactorsArr);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组合多个交互器&lt;/span&gt;
        graphView.sm().clearSelection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次工具条有点击的时候就清空所有的选中&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; item;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着利用 HT 封装的面板组件 &lt;a href=&quot;http://hightopo.com/guide/guide/core/borderpane/ht-borderpane-guide.html&quot; target=&quot;_blank&quot;&gt;ht.widget.BorderPane&lt;/a&gt; 将整个界面分成两个部分：顶部和底部。我们又利用 HT 封装的 &lt;a href=&quot;http://hightopo.com/guide/guide/core/splitview/ht-splitview-guide.html&quot; target=&quot;_blank&quot;&gt;ht.widget.SplitView&lt;/a&gt; 分割组件将底部分为上下两个部分，最后将这个外边框 borderPane 添加进 body 体中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
splitView = &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(graphView, g3d, 'v', 0.5&lt;span&gt;);
borderPane &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.widget.BorderPane();
borderPane.setTopView(toolbar);
borderPane.setCenterView(splitView);
borderPane.addToDOM();  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个场景都制作完毕，接着就是功能部分。我们把制作“不规则图形”作为一个单独的部分放到 CreateShapeInteractor.js 中，制作“圆”、“圆角矩形”以及“矩形”三个部分分为一个部分放到 CreateNodeInteractor.js 中，将“连线”分为一个部分放到 CreateEdgeInteractor.js 中，接下来我们将对这三个 js 文件一个个解析。&lt;/p&gt;
&lt;p&gt;这三个 js 文件的共同点是通过 HT 封装的继承函数 ht.Default.def 继承并创建新的类，这三个类我们在前面的代码中是有提到的： CreateShapeInteractor、CreateNodeInteractor 以及 CreateEdgeInteractor 类，都大同小异，我们这里重点解析 CreateNodeInteractor.js 文件。&lt;/p&gt;
&lt;p&gt;首先就是要声明定义一个 CreateNodeInteractor 类，就是这三个部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201712/591709-20171203214531319-1425331861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CreateNodeInteractor = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (graphView) {
    CreateNodeInteractor.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, graphView);                
};
ht.Default.def(CreateNodeInteractor, ht.graph.Interactor, { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义类，第一个参数为类名，第二个参数为继承的类，第三个参数为此类的方法&lt;/span&gt;
    &lt;span&gt;//这边重新绘制这个类的方法&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着就是向这个类中添加我们需要的功能，主要的功能是“鼠标点击事件的触发”以及“触摸屏幕事件的触发”，我们通过对事件的监听来绘制图形，首先就是判断鼠标左键或者触屏是否点击：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
handle_touchstart: &lt;span&gt;function&lt;/span&gt; (e) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;触屏 开始点击&lt;/span&gt;
    ht.Default.preventDefault(e);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻止所有的默认交互事件&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (ht.Default.isLeftButton(e)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标左键是否点击&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;._graphView.setFocus(e);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置焦点&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.p1 = &lt;span&gt;this&lt;/span&gt;._graphView.lp(e);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前逻辑坐标点&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.startDragging(e);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用 startDragging 开始拖拽函数 &lt;/span&gt;
&lt;span&gt;    }
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后对鼠标弹起或者触屏是否结束进行事件的判断，并直接生成一个 ht.Node 节点。HT 把单纯的点击事件和拖拽事件分为两种命名格式，单纯的点击事件为 handle_* 方法，拖拽事件是 handleWindow* 方法。上面的代码就是从点击工具条的能触发 CreateNodeInteractor 类的元素开始，到放到界面中生成图元结束。并没有拖拽的过程，会有一个默认的大小：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201712/591709-20171203214729351-230062886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;HT 默认调用 ht.graph.DefaultInteractor 事件，里面有一系列的操作，我们现在要做的拖拽跟这个有冲突，所以在前面我们先将这个默认的事件阻止，获取鼠标点下的第一个点的逻辑坐标和第二个点的逻辑坐标，根据这两个坐标的点生成一个矩形，然后开始绘制节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
handleWindowTouchMove: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    ht.Default.preventDefault(e);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻止事件的默认行为，常用于屏蔽触屏上默认DoubleTap缩放等行为&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.p1) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.p2 = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._graphView.lp(e);
    const rect &lt;/span&gt;= ht.Default.unionPoint(&lt;span&gt;this&lt;/span&gt;.p1, &lt;span&gt;this&lt;/span&gt;.p2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将 p1 和 p2 两个点组合成一个矩形&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.node) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.node.setRect(rect);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!rect.width || !&lt;span&gt;rect.height) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._graphView.dm().beginTransaction();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类似数据库里开启事务，从beginTransaction()到endTransaction()之间所有的修改可被一次性撤销或重做&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.createNode(rect, &lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用 createNode 函数&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在拖拽结束的时候做结束绘制图形的操作，这里我是直接设置绘制结束后就将工具条选中“编辑”的元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
handleWindowTouchEnd: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    ht.Default.preventDefault(e);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._graphView.dm().endTransaction();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类似数据库里结束事务，从beginTransaction()到endTransaction()之间所有的修改可被一次性撤销或重做&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.node &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.p1) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.createNode({
            x: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.p1.x - 25&lt;span&gt;,
            y: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.p1.y - 25&lt;span&gt;,
            width: &lt;/span&gt;50&lt;span&gt;,
            height: &lt;/span&gt;50&lt;span&gt;
        }, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; continuousCreating = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;continuousCreating) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; toolbar.getItems().length; i++&lt;span&gt;){
            toolbar.getItems()[i].selected &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            toolbar.getItems()[i].icon.comps[&lt;/span&gt;1].color = '#000'&lt;span&gt;;
        }
       toolbar.getItemById(&lt;/span&gt;'edit').selected = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        toolbar.getItemById(&lt;/span&gt;'edit').icon.comps[1].color = '#1E90FF'&lt;span&gt;;
        borderPane.iv();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._graphView.setEditable(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._graphView.sm().ss(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.node);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.node = &lt;span&gt;this&lt;/span&gt;.p1 = &lt;span&gt;this&lt;/span&gt;.p2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，我们只要知道如何绘制图元就好了，在 HT 中，基础的图元都可以通过设置样式中的 shape 或者 shape3d 来生成不同的图元，我们这边就是通过这种途径，如果想要在界面中生成复杂图形，如：机柜模型，可以参考这篇文章：&lt;a href=&quot;http://www.cnblogs.com/xhload3d/p/7887229.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/xhload3d/p/7887229.html&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
createNode: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(rect, click) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; create instance&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (ht.Default.isFunction(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.type)) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.node = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.type(rect, click);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Node();
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.node.setTall(50);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为 3D 图形做准备，设置其厚度，才会有立体感&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(toolbar.getItemById('circle').selected){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果工具条的 ‘circle’ 被选中&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.node.s({&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 style 样式&lt;/span&gt;
            &quot;shape&quot;: &quot;oval&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;椭圆形，为空时显示为图片，可设置多边形类型参见入门手册&lt;/span&gt;
            &quot;shape.background&quot;: &quot;#D8D8D8&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多边形类型图元背景&lt;/span&gt;
            &quot;shape.border.width&quot;: 1,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多边形类型图元边框宽度&lt;/span&gt;
            &quot;shape.border.color&quot;: &quot;#979797&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多边形类型图元边框颜色&lt;/span&gt;
            &quot;shape3d&quot;: &quot;sphere&quot;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为空时显示为六面立方体，其他可选值为box|sphere|cylinder|cone|torus|star|rect|roundRect|triangle|rightTriangle|parallelogram|trapezoid&lt;/span&gt;
&lt;span&gt;        });
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(toolbar.getItemById('roundRect'&lt;span&gt;).selected){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.node.s({
            &lt;/span&gt;&quot;shape&quot;: &quot;roundRect&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;圆角矩形&lt;/span&gt;
            &quot;shape.background&quot;: &quot;#D8D8D8&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;shape.border.width&quot;: 1&lt;span&gt;,
            &lt;/span&gt;&quot;shape.border.color&quot;: &quot;#979797&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;shape3d&quot;: &quot;roundRect&quot;&lt;span&gt;
        });
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(toolbar.getItemById('rect'&lt;span&gt;).selected){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.node.s({
           &lt;/span&gt;&quot;shape&quot;: &quot;rect&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;矩形&lt;/span&gt;
            &quot;shape.background&quot;: &quot;#D8D8D8&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;shape.border.width&quot;: 1&lt;span&gt;,
            &lt;/span&gt;&quot;shape.border.color&quot;: &quot;#979797&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;shape3d&quot;: &quot;rect&quot;&lt;span&gt;
        });
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set bounds&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (click) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.node.setPosition(rect.x + rect.width / 2, rect.y + rect.height / 2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 node 的坐标点&lt;/span&gt;
&lt;span&gt;     }
     &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.node.setRect(rect);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 node 的外矩形边框大小&lt;/span&gt;
&lt;span&gt;     }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add to data model&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;._graphView.dm().add(&lt;span&gt;this&lt;/span&gt;.node);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将这个 node 添加进数据容器 DataModel 中&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 到此，创建 ht.Node 节点的声明全部结束，大家可以根据自己的想象创建你想要的编辑器！&lt;/p&gt;
</description>
<pubDate>Sun, 03 Dec 2017 14:16:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/7955923.html</dc:identifier>
</item>
<item>
<title>【微软大法好】VS Tools for AI全攻略（3） - 姜子瑜</title>
<link>http://www.cnblogs.com/ldzhangyx/p/7967623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ldzhangyx/p/7967623.html</guid>
<description>&lt;p&gt;接着上文，现在我们需要一种穷人的方法来搭建好Azure虚拟机。&lt;/p&gt;
&lt;p&gt;思路很简单，因为AI组件的原理其实是传送了script文件和命令上去，那么我们这个虚拟机只要做好了所有的配置，那么我们就可以将它当作深度学习虚拟机来用了。&lt;/p&gt;
&lt;p&gt;写到这里，我忍不住哀叹一声。买不起外置显卡的穷人，只能绞尽脑汁想这种省钱的办法。&lt;/p&gt;
&lt;p&gt;新建一个Ubuntu 16.04LTS虚拟机。当然选择Windows虚拟机也是可以的，只是不太主流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1037202/201712/1037202-20171203215333304-446155281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择存储之后，使用XShell远程连接虚拟机（这样比较方便）。&lt;/p&gt;
&lt;p&gt;注意此时的虚拟机，GPU约等于没有，所以我们不得不运行CPU版本。所以这个虚拟机的性能会比较差，但是虚拟机此时也可以拿来用作其他事情，比如当作私有云盘，或者是tizi。&lt;/p&gt;
&lt;p&gt;具体的安装步骤可以查看http://www.cnblogs.com/ldzhangyx/p/7624771.html&lt;/p&gt;
&lt;p&gt;下面的操作以Ubuntu版本为准，Windows版本的配置方法类似。&lt;/p&gt;
&lt;p&gt;我们打开VS installer，安装Azure SDK。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1037202/201712/1037202-20171203215923476-712735973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;安装完成之后的主要步骤参见：https://github.com/Microsoft/vs-tools-for-ai/blob/master/docs/tensorflow-vm.md&lt;/p&gt;
&lt;p&gt;这里做出中文的说明。&lt;/p&gt;
&lt;p&gt;1，打开你的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1037202/201712/1037202-20171203220226804-1047305166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2，选择服务器资源管理器，使用SSH连接好你的虚拟机。（记得提前给你的虚拟机设置静态IP）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1037202/201712/1037202-20171203220428413-1012102344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1037202/201712/1037202-20171203220539944-339700366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;连接完成之后你可以发现Remote machine里多了你的虚拟机。你可以点进去看看你虚拟机的文件。&lt;/p&gt;

&lt;p&gt;3，提交一个Job。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1037202/201712/1037202-20171203220629991-972301993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在解决方案管理器里提交job，有几个参数需要注意一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1037202/201712/1037202-20171203221536569-163455782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;cluster是你的虚拟机名字。在第三行有一个Job Name必须写，你选一个自己喜欢的名字就好，作为job的区分标识。&lt;/p&gt;
&lt;p&gt;下面这些参数有些复杂，但是如果你直接提交的话，将会报类似的错误。&lt;/p&gt;
&lt;p&gt;点击这里查看所有的Jobs：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1037202/201712/1037202-20171203220848991-224244246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如果你选择了Python2/3双版本共存，可能会出现这样的错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1037202/201712/1037202-20171203221233460-1588080758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;原因出在这里：&lt;/p&gt;
&lt;p&gt;如果我们在Summit的时候填写的是python，那么虚拟机会执行python tensorflowapplication.py这一条指令。&lt;/p&gt;
&lt;p&gt;而我们之前为了方便，安装了Python3使得两版本共存，那么python调用的其实是python2.要使虚拟机调用Python3，我们只需要这么修改：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1037202/201712/1037202-20171203221133335-1003452712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样我们就可以使用Python3了。&lt;/p&gt;
&lt;p&gt;提交，查看结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1037202/201712/1037202-20171203221305101-1765862488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你要在执行的时候指定一些参数，也是在类似的地方进行调整。&lt;/p&gt;

</description>
<pubDate>Sun, 03 Dec 2017 14:14:00 +0000</pubDate>
<dc:creator>姜子瑜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ldzhangyx/p/7967623.html</dc:identifier>
</item>
<item>
<title>Java中net.sf.json包关于JSON与对象互转的坑 - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/7967603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/7967603.html</guid>
<description>&lt;p&gt;　　在Web开发过程中离不开数据的交互，这就需要规定交互数据的相关格式，以便数据在客户端与服务器之间进行传递。数据的格式通常有2种：1、xml；2、JSON。通常来说都是使用JSON来传递数据。本文正是介绍在Java中JSON与对象之间互相转换时遇到的几个问题以及相关的建议。 首先明确对于JSON有两个概念：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;JSON对象（JavaScript Object Notation，JavaScript对象表示法）。这看似只存是位JavaScript所定制的，但它作为一种语法是独立于语言以及平台的。只是说通常情况下我们在客户端（浏览器）向服务器端传递数据时，使用的是JSON格式，而这个格式是用于表示JavaScript对象。它是由一系列的“key-value”组成，如 {“id”: 1, “name”: “kevin”}，这有点类似Map键值对的存储方式。在Java中所述的JSON对象，实际是指的JSONObject类，这在各个第三方的JSONjar包中通常都以这个名字命名，不同jar包对其内部实现略有不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;JSON字符串。JSON对象和JSON字符串之间的转换是序列化与反序列化的过程，这就是好比Java对象的序列化与反序列化。在网络中数据的传递是通过字符串，或者是二进制流等等进行的，也就是说在客户端（浏览器）需要将数据以JSON格式传递时，此时在网络中传递的是字符串，而服务器端在接收到数据后当然也是字符串（String类型），有时就需要将JSON字符串转换为JSON对象再做下一步操作（String类型转换为JSONObject类型）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　以上两个概念的明确就基本明确了JSON这种数据格式，或者也称之为JSON语法。Java中对于JSON的jar包有许多，最最“常用”的是“net.sf.json”提供的jar包了，本文要着重说的就是这个坑包，虽然坑，却有着广泛的应用。其实还有其他优秀的JSON包供我们使用，例如阿里号称最快的JSON包——fastjson，还有谷歌的GSON，还有jackson。尽量，或者千万不要使用“net.sf.json”包，不仅有坑，而且已经很老了，老到都没法在IDEA里下载到源码，Maven仓库里显示它2010年在2.4版本就停止更新了。下面就谈我已知的“net.sf.json”的2个bug（我认为这是bug），以及这2个bug是如何产生的。&lt;/p&gt;

&lt;h2&gt;1. 在Java对象转换JSON对象时，get开头的所有方法会被转换&lt;/h2&gt;
&lt;p&gt;　　这是什么意思呢，例如现有以下Java对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; sfjson;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/12/1.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;Long&amp;gt;&lt;span&gt; courseIds;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Long&amp;gt;&lt;span&gt; getCourseIds() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; courseIds;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCourseIds(List&amp;lt;Long&amp;gt;&lt;span&gt; courseIds) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.courseIds =&lt;span&gt; courseIds;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String getSql() {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此类中获取sql语句的方法，并没有对应的属性字段&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;this is sql.&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在我们将Student对象转换成JSON对象的时候，希望转换后的JSON格式应该是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &quot;id&quot;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &quot;courseIds&quot;: [1, 2, 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然而在使用“net.sf.json”包的&lt;strong&gt;JSONObject json = JSONObject.fromObject(student);&lt;/strong&gt; API转换后的结果却是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201712/630246-20171203220146179-1969474551.png&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;28&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　也就是说可以猜测到的是，“net.sf.json”获取Java对象中public修饰符get开头的方法，并将其后缀定义为JSON对象的“key”，而将get开头方法的返回值定义为对应key的“value”，注意是public修饰符get开头的方法，且有返回值。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;我认为这是不合理的转换规则。&lt;/strong&gt;如果我在Java对象中定义了一个方法，仅仅因为这个方法是“get”开头，且有返回值就将其作为转换后JSON对象的“key-value”，那岂不是暴露出来了？或者在返回给客户端（浏览器）时候就直接暴露给了前端的Console控制台？作者规定了这种转换规则，我想的大概原因是：既然你定义为了public方法，且命名为get，那就是有意将此方法暴露出来让调用它的客户端有权获取。但我仍然认为这不合理，甚至我定义它是一个bug。我这么定义也许也不合理，因为据我实测发现，不仅是“net.sf.json”包会按照这个规则进行转换，fastjson和jackson同样也是照此规则，唯独谷歌的GSON并没有按照这个规则进行对象向JSON转换。&lt;/p&gt;
&lt;p&gt;　　通过JSONObject json = JSONObject.fromObject(student);将构造好的Student对象转换为JSON对象，Student如上文所述。 进入此方法后会继续调用fromObject(Object, JsonConfig)的重载方法，在此重载方法中会通过instanceOf判断待转换的Object对象是否是枚举、注解等类型，这些特殊类型会有特别的判断方法。在这里是一个普通的Java POJO对象，所以会进入到_fromObject(Object, JsonConfig)，在这个方法中会有一些判断，而最后则通过调用defaultBeanProcessing创建JSON对象。这个方法是关键，在里面还继续会通过PropertyUtils.getPropertyDescriptors(bean)方法获取“属性描述符”，实际上就是获取带get的方法，它在这里封装成了PropertyDescriptor。这Student这个类中会获取4个，分别是：getClass、getId、getCourseIds、getSql。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201712/630246-20171203220311726-856302469.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其实PropertyDescriptor封装得已经很详细了，什么读写方法都已经赋值了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201712/630246-20171203220844991-235810843.png&quot; alt=&quot;&quot; width=&quot;575&quot; height=&quot;454&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　例如这个getSql方法已经被解析成了上图的PropertyDescriptor。之后的通过这个类将一些方法过滤掉，例如getClass方法不是POJO中的方法，所以并不需要将它转换成JSON对象。而PropertyDescriptor的获取是通过BeanInfo#getPropertyDescriptors，而BeanInfo的获取则又是通过new Introspector(beanClass, null, USE_ALL_BEANINFO).getBeanInfo();不断深入最后就会到达如下方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; BeanInfo getBeanInfo() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IntrospectionException {
    …
    MethodDescriptor mds[] &lt;/span&gt;= getTargetMethodInfo();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个方法中会调用getPublicDeclaredMethods，可以看到确实是查找public方法，而且是所有public方法，包括wait等&lt;/span&gt;
    PropertyDescriptor pds[] = getTargetPropertyInfo();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照一定的规则进行过滤，过滤规则全在这个方法里了，就是选择public修饰符带有get前缀和返回值的方法&lt;/span&gt;
   …
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对net.sf.json的源码简要分析了一下，发现确实如猜想的那样，具体的源码比较多篇幅有限需自行查看跟踪。&lt;/p&gt;
&lt;h2&gt;2. 在JSON对象转换Java对象时，List&amp;lt;Long&amp;gt;会出现转换错误&lt;/h2&gt;
&lt;p&gt;　　标题一句话解释不清楚，这个问题，我很确定地认为它是一个bug。&lt;/p&gt;
&lt;p&gt;　　现在有{&quot;id&quot;: 1, &quot;courseIds&quot;: [1,2,3]}的JSON字符串，需要将它转换为上文中提到的Student对象，在Student对象中有int和List&amp;lt;Long&amp;gt;类型的两个属性字段，也就是说这个JSON字符串应该转换为对应的数据类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
String json = &quot;{\&quot;id\&quot;: 1, \&quot;courseIds\&quot;: [1,2,3]}&quot;&lt;span&gt;;
Student student &lt;/span&gt;= (Student) JSONObject.toBean(JSONObject.fromObject(json), Student.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
System.out.println(student.getCourseIds().get(&lt;/span&gt;0) &lt;span&gt;instanceof&lt;/span&gt; Long);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的输出结果应该是true，然而遗憾的是却是&lt;strong&gt;false&lt;/strong&gt;。准确来说在编译时是Long型，而在运行时却是Integer。这不得不说就是一个坑了，另外三个JSON包都未出现这种错误。所以我确定它是一个bug。来看看这个bug在net.sf.json是怎么发生的，同样需要自行对比源码进行查看。我在打断点debug不断深入的时候发现了net.sf.json对于整型数据的处理时，发现了这个方法&lt;strong&gt;NumberUtils#createNumber&lt;/strong&gt;，这个类是从字符串中取出数据时判断它的数据类型，本意是想如果数字后面带有“L”或“l”则将其处理为Long型，从这里来看最后的结果应该是对的啊。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;case&lt;/span&gt; 'L'&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'l'&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dec == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; exp == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (numeric.charAt(0) == '-' &amp;amp;&amp;amp; isDigits(numeric.substring(1)) ||&lt;span&gt; isDigits(numeric))) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; createLong(numeric);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NumberFormatException var11) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; createBigInteger(numeric);
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NumberFormatException(str + &quot; is not a valid number.&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　的确到目前为止net.sf.json通过数字后的标识符准确地判断了数据类型，问题出就出在获得了这个值以及它的数据类型后需要将它存入JSONObject中，而存入的过程中有&lt;strong&gt;JSONUtils#transformNumber&lt;/strong&gt;这个方法的存在，这个方法的存在，至少在目前看来纯属画蛇添足。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Number transformNumber(Number input) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (input &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Float) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Double(input.toString());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (input &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Short) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(input.intValue());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (input &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Byte) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(input.intValue());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (input &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Long) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Long max = &lt;span&gt;new&lt;/span&gt; Long(2147483647L&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (input.longValue() &amp;lt;= max.longValue() &amp;amp;&amp;amp; input.longValue() &amp;gt;= -2147483648L) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;就算原类型是Long型，但是只要它在Integer范围，那么就最终还是会转换为Integer。&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(input.intValue());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; input;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的这段代码很清晰的显示了元凶所在，不论是Long型（Integer范围内的Long型），包括Byte、Short都会转换为Integer。尚不明白这段代码的意义在哪里。前面又要根据数字后的字母确定准确的数据类型，后面又要将准确的数据类型转换一次，这就导致了开头提到的那个bug。这个问题几乎是无法回避，所以最好的办法就是不要用。&lt;/p&gt;
&lt;p&gt;　　这两个坑是偶然间发现，建议还是不要使用早已没有维护的net.sf.json的JSON包，另外有一点，net.sf.json包对JSON格式的校验并不那么严格，如果这样的格式“{&quot;id&quot;: 1, &quot;courseIds&quot;: &quot;[1,2,3]&quot;}”，在其他三个包是会抛出异常的，但net.sf.json则不会。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 03 Dec 2017 14:10:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/7967603.html</dc:identifier>
</item>
<item>
<title>python自动发邮件库yagmail - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/7967213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/7967213.html</guid>
<description>&lt;h2 id=&quot;一般发邮件方法&quot;&gt;#### 一般发邮件方法&lt;/h2&gt;
&lt;p&gt;我以前在通过Python实现自动化邮件功能的时候是这样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; smtplib
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; email.mime.text &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; MIMEText
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; email.header &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Header

&lt;span class=&quot;co&quot;&gt;# 发送邮箱服务器&lt;/span&gt;
smtpserver &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'smtp.sina.com'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 发送邮箱用户/密码&lt;/span&gt;
user &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'username@sina.com'&lt;/span&gt;
password &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'123456'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 发送邮箱&lt;/span&gt;
sender &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'username@sina.com'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 接收邮箱&lt;/span&gt;
receiver &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'receive@126.com'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 发送邮件主题&lt;/span&gt;
subject &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Python email test'&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 编写HTML类型的邮件正文&lt;/span&gt;
msg &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; MIMEText(&lt;span class=&quot;st&quot;&gt;'&amp;lt;html&amp;gt;&amp;lt;h1&amp;gt;你好！&amp;lt;/h1&amp;gt;&amp;lt;/html&amp;gt;'&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'html'&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'utf-8'&lt;/span&gt;)
msg[&lt;span class=&quot;st&quot;&gt;'Subject'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Header(subject, &lt;span class=&quot;st&quot;&gt;'utf-8'&lt;/span&gt;)


&lt;span class=&quot;co&quot;&gt;# 连接发送邮件&lt;/span&gt;
smtp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; smtplib.SMTP()
smtp.&lt;span class=&quot;ex&quot;&gt;connect&lt;/span&gt;(smtpserver)
smtp.login(user, password)
smtp.sendmail(sender, receiver, msg.as_string())
smtp.quit()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实，这段代码也并不复杂，只要你理解使用过邮箱发送邮件，那么以下问题是你必须要考虑的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你登录的邮箱帐号/密码&lt;/li&gt;
&lt;li&gt;对方的邮箱帐号&lt;/li&gt;
&lt;li&gt;邮件内容（标题，正文，附件）&lt;/li&gt;
&lt;li&gt;邮箱服务器（SMTP.xxx.com/pop3.xxx.com）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;yagmail-实现发邮件&quot;&gt;#### yagmail 实现发邮件&lt;/h2&gt;
&lt;p&gt;yagmail 可以更简单的来实现自动发邮件功能。&lt;/p&gt;
&lt;p&gt;github项目地址: &lt;a href=&quot;https://github.com/kootenpv/yagmail&quot; class=&quot;uri&quot;&gt;https://github.com/kootenpv/yagmail&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install yagmail&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;简单例子&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; yagmail

&lt;span class=&quot;co&quot;&gt;#链接邮箱服务器&lt;/span&gt;
yag &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; yagmail.SMTP( user&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;user@126.com&quot;&lt;/span&gt;, password&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1234&quot;&lt;/span&gt;, host&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'smtp.126.com'&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# 邮箱正文&lt;/span&gt;
contents &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'This is the body, and here is just text http://somedomain/image.png'&lt;/span&gt;,
            &lt;span class=&quot;co&quot;&gt;'You can find an audio file attached.'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'/local/path/song.mp3'&lt;/span&gt;]

&lt;span class=&quot;co&quot;&gt;# 发送邮件&lt;/span&gt;
yag.send(&lt;span class=&quot;st&quot;&gt;'taaa@126.com'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'subject'&lt;/span&gt;, contents)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总共四行代码搞定，是不是比上面的例子简单太多了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给多个用户发送邮件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 发送邮件&lt;/span&gt;
yag.send([&lt;span class=&quot;st&quot;&gt;'aa@126.com'&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'bb@qq.com'&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'cc@gmail.com'&lt;/span&gt;], &lt;span class=&quot;st&quot;&gt;'subject'&lt;/span&gt;, contents)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要将接收邮箱 变成一个list即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送带附件的邮件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 发送邮件&lt;/span&gt;
yag.send(&lt;span class=&quot;st&quot;&gt;'aaaa@126.com'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'发送附件'&lt;/span&gt;, contents, [&lt;span class=&quot;st&quot;&gt;&quot;d://log.txt&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;d://baidu_img.jpg&quot;&lt;/span&gt;])&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要添加要发送的附件列表即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201712/311516-20171203211816866-144551015.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我都快感动哭了，到哪儿去找这么良心库去？简单的有点不像编程语言！&lt;/p&gt;
</description>
<pubDate>Sun, 03 Dec 2017 13:22:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/7967213.html</dc:identifier>
</item>
<item>
<title>springboot学习（二）——springmvc配置使用 - 十二页</title>
<link>http://www.cnblogs.com/page12/p/7967290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/page12/p/7967290.html</guid>
<description>&lt;p&gt;以下内容，如有问题，烦请指出，谢谢&lt;/p&gt;
&lt;p&gt;上一篇讲解了springboot的helloworld部分，这一篇开始讲解如何使用springboot进行实际的应用开发，基本上寻着spring应用的路子来讲，从springmvc以及web开发讲起。&lt;br/&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/1.5.8.RELEASE/reference/htmlsingle/&quot;&gt;官方文档&lt;/a&gt;中在helloworld和springmvc之间还有一部分内容，主要讲了spring应用的启动、通用配置以及日志配置相关的内容，其中关于通用配置的部分对于springboot来说是个很重要的内容，这部分等到后面在细说下，有了一定的应用能力，到时候理解起来轻松些。&lt;/p&gt;
&lt;p&gt;先来回顾下springmvc是怎么使用的。&lt;br/&gt;首先需要配置DispatcherServlet，一般是在web.xml中配置&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;dispatcherServlet&lt;span class=&quot;kw&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span class=&quot;kw&quot;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;load-on-startup&amp;gt;&lt;/span&gt;1&lt;span class=&quot;kw&quot;&gt;&amp;lt;/load-on-startup&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;dispatcherServlet&lt;span class=&quot;kw&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/&lt;span class=&quot;kw&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一点在springboot中就不需要手动写xml配置了，springboot的autoconfigure会默认配置成上面那样，servlet-name并不是一个特别需要注意的属性，因此可以不用太关心这个属性是否一致。&lt;br/&gt;具体的初始化是在 org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration中完成的，对应的一些配置在 org.springframework.boot.autoconfigure.web.ServerProperties 以及&lt;br/&gt;org.springframework.boot.autoconfigure.web.WebMvcProperties，后面讲一些常用的配置，不常用的就自己看源码了解吧，就不细说了。&lt;/p&gt;
&lt;p&gt;然后是ViewResolver，也就是视图处理的配置。在springmvc中，一般是在springmvc的xml配置中添加下列内容&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- ViewResolver --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;viewClass&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.springframework.web.servlet.view.JstlView&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;prefix&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/WEB-INF/jsp/&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;suffix&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;.jsp&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;低版本的spring需要加上viewClass，高版本的spring会自动检测是否使用JstlView，因此这个属性通常并不需要手动配置，主要关心prefix和suffix。另外高版本的springmvc也不需要手动指定 HandlerMapping 以及&lt;br/&gt;HandlerAdapter ，这两个也不需要显式声明bean。&lt;/p&gt;
&lt;p&gt;如何在springboot中配置ViewResolver，主要有两种方法。&lt;br/&gt;一种是在application.properties中配置，这是springboot中标准的配置方法。&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外一种是springmvc中的代码式配置，这种也是现在比较流行的配置方式，不显式指定配置文件，配置即代码的思想，脚本语言python js scala流行的配置方式。&lt;br/&gt;代码是配置的主要操作就是自己写代码来为mvc配置类中的某个方法注入bean或者直接覆盖方法，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package pr.study.springboot.configure.mvc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Bean;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Configuration;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.view.InternalResourceViewResolver;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SpringMvcConfigure &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; WebMvcConfigurerAdapter {

    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; InternalResourceViewResolver &lt;span class=&quot;fu&quot;&gt;viewResolver&lt;/span&gt;(){
        InternalResourceViewResolver viewResolver = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;InternalResourceViewResolver&lt;/span&gt;();
        viewResolver.&lt;span class=&quot;fu&quot;&gt;setPrefix&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/WEB-INF/jsp/&quot;&lt;/span&gt;);
        viewResolver.&lt;span class=&quot;fu&quot;&gt;setSuffix&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;.jsp&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// viewResolver.setViewClass(JstlView.class); // 这个属性通常并不需要手动配置，高版本的Spring会自动检测&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; viewResolver;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的视图使用的是jsp，这时需要在pom.xml中添加新的依赖。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.tomcat.embed&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;tomcat-embed-jasper&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;provided&lt;span class=&quot;kw&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码也相应的改写下，返回视图时，&lt;a href=&quot;mailto:不能使用@ResponseBody&quot;&gt;不能使用@ResponseBody&lt;/a&gt;，&lt;a href=&quot;mailto:也就是不能使用@RestController&quot;&gt;也就是不能使用@RestController&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package pr.study.springboot.controller;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Controller;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.ModelAndView;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//@RestController&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Controller&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HelloWorldController {

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/hello&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ModelAndView &lt;span class=&quot;fu&quot;&gt;hello&lt;/span&gt;() {
        ModelAndView mv = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ModelAndView&lt;/span&gt;();
        mv.&lt;span class=&quot;fu&quot;&gt;addObject&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;msg&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;this a msg from HelloWorldController&quot;&lt;/span&gt;);
        mv.&lt;span class=&quot;fu&quot;&gt;setViewName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;helloworld&quot;&lt;/span&gt;);;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; mv;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还要新建jsp文件，路径和使用普通的tomcat部署一样，要在src/main/webapp目录下新建jsp的文件夹，这里路径不能写错。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode jsp&quot;&gt;
&lt;code class=&quot;sourceCode jsp&quot;&gt;&amp;lt;%@ page&lt;span class=&quot;ot&quot;&gt; language&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;java&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; contentType&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;text/html; charset=UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; pageEncoding&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;%&amp;gt;
&amp;lt;&lt;span class=&quot;ot&quot;&gt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&lt;/span&gt;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta&lt;span class=&quot;ot&quot;&gt; http-equiv&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;text/html; charset=UTF-8&quot;&lt;/span&gt;&amp;gt;
&amp;lt;title&amp;gt;helloworld&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;p&amp;gt;${msg}&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;springboot使用嵌入式Servlet容器，对jsp支持有限，官方是推荐使用模板引擎来代替jsp。&lt;/p&gt;
&lt;p&gt;第三点讲下比较重要的springmvc拦截器（HandlerInterceptor）。&lt;br/&gt;拦截器在springmvc中有重要的作用，它比servlet的Filter功能更强大（拦截器中可以编程的地方更多）也更好使用，缺点就是它只能针对springmvc，也就是dispatcherServlet拦截的请求，不是所有servlet都能被它拦截。&lt;br/&gt;springmvc中添加拦截器配置如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;mvc:interceptors&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;pr.study.springboot.aop.web.interceptor.Interceptor1&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;mvc:interceptor&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;mvc:mapping&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; path=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/users&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;mvc:mapping&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; path=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/users/**&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;pr.study.springboot.aop.web.interceptor.Interceptor2&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/mvc:interceptor&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/mvc:interceptors&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interceptor1拦截所有请求，也就是/**，Interceptor2只拦截/users开头的请求。&lt;br/&gt;在springboot中并没有提供配置文件的方式来配置拦截器（HandlerInterceptor），因此需要使用springmvc的代码式配置，配置如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package pr.study.springboot.configure.mvc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Bean;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Configuration;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.web.servlet.view.InternalResourceViewResolver;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import pr.study.springboot.aop.web.interceptor.Interceptor1;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import pr.study.springboot.aop.web.interceptor.Interceptor2;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SpringMvcConfigure &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; WebMvcConfigurerAdapter {

    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; InternalResourceViewResolver &lt;span class=&quot;fu&quot;&gt;viewResolver&lt;/span&gt;(){
        InternalResourceViewResolver viewResolver = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;InternalResourceViewResolver&lt;/span&gt;();
        viewResolver.&lt;span class=&quot;fu&quot;&gt;setPrefix&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/WEB-INF/jsp/&quot;&lt;/span&gt;);
        viewResolver.&lt;span class=&quot;fu&quot;&gt;setSuffix&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;.jsp&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// viewResolver.setViewClass(JstlView.class); // 这个属性通常并不需要手动配置，高版本的Spring会自动检测&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; viewResolver;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addInterceptors&lt;/span&gt;(InterceptorRegistry registry) {
        registry.&lt;span class=&quot;fu&quot;&gt;addInterceptor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Interceptor1&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;addPathPatterns&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/**&quot;&lt;/span&gt;);
        registry.&lt;span class=&quot;fu&quot;&gt;addInterceptor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Interceptor2&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;addPathPatterns&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/users&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;addPathPatterns&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/users/**&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;addInterceptors&lt;/span&gt;(registry);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第四点讲下静态资源映射。&lt;br/&gt;一些简单的web应用中都是动静混合的，包含许多静态内容，这些静态内容并不需要由dispatcherServlet进行转发处理，不需要进行拦截器等等的处理，只需要直接返回内容就行。springmvc提供了静态资源映射这个功能，在xml中配置如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;resources&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; mapping=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/**&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; location=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/res/&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;springboot中有两种配置，一种是通过配置文件application.properties指定&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;# default is: /, &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;
#spring.resources.static-locations=classpath:/res/
# the 'staticLocations' is equal to 'static-locations'
#spring.resources.staticLocations=classpath:/res/

# default is /**
#spring.mvc.staticPathPattern=/**&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外一种是springmvc的代码式配置&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SpringMvcConfigure &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; WebMvcConfigurerAdapter {

    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; InternalResourceViewResolver &lt;span class=&quot;fu&quot;&gt;viewResolver&lt;/span&gt;() {
        InternalResourceViewResolver viewResolver = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;InternalResourceViewResolver&lt;/span&gt;();
        viewResolver.&lt;span class=&quot;fu&quot;&gt;setPrefix&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/WEB-INF/jsp/&quot;&lt;/span&gt;);
        viewResolver.&lt;span class=&quot;fu&quot;&gt;setSuffix&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;.jsp&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// viewResolver.setViewClass(JstlView.class); // 这个属性通常并不需要手动配置，高版本的Spring会自动检测&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; viewResolver;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addInterceptors&lt;/span&gt;(InterceptorRegistry registry) {
        registry.&lt;span class=&quot;fu&quot;&gt;addInterceptor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Interceptor1&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;addPathPatterns&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/**&quot;&lt;/span&gt;);
        registry.&lt;span class=&quot;fu&quot;&gt;addInterceptor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Interceptor2&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;addPathPatterns&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/users&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;addPathPatterns&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/users/**&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;addInterceptors&lt;/span&gt;(registry);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addResourceHandlers&lt;/span&gt;(ResourceHandlerRegistry registry) {
        &lt;span class=&quot;co&quot;&gt;// addResourceHandler指的是访问路径，addResourceLocations指的是文件放置的目录  &lt;/span&gt;
        registry.&lt;span class=&quot;fu&quot;&gt;addResourceHandler&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/**&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;addResourceLocations&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;classpath:/res/&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两种方式效果一样，配置后访问正确的静态文件都不会被拦截器拦截。&lt;br/&gt;当然，静态文件不被拦截的方法还有很多，比如使用其他的servlet来转发静态文件，拦截器（HandlerInterceptor）的exclude，dispatcherServlet拦截/*.do等等方式，这里就不细说了。&lt;/p&gt;
&lt;p&gt;今天就到此为止，springmvc以及Web的还有不少内容，下期在说&lt;br/&gt;因为Demo比较简单，这里就没有贴运行结果的图，相关代码如下：&lt;br/&gt;&lt;a href=&quot;https://gitee.com/page12/study-springboot/tree/springboot-2/&quot; class=&quot;uri&quot;&gt;https://gitee.com/page12/study-springboot/tree/springboot-2/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/page12/study-springboot/tree/springboot-2&quot; class=&quot;uri&quot;&gt;https://github.com/page12/study-springboot/tree/springboot-2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一些有既可以通过application.properties配置，又可以使用代码式配置的，都注释掉了application.properties中的配置，试运行时可以切换下。&lt;/p&gt;
</description>
<pubDate>Sun, 03 Dec 2017 13:02:00 +0000</pubDate>
<dc:creator>十二页</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/page12/p/7967290.html</dc:identifier>
</item>
<item>
<title>[Machine Learning]学习笔记-Neural Networks - Messier</title>
<link>http://www.cnblogs.com/messier/p/7967245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/messier/p/7967245.html</guid>
<description>&lt;h2 id=&quot;引子&quot;&gt;引子&lt;/h2&gt;
&lt;p&gt;对于一个特征数比较大的非线性分类问题，如果采用先前的回归算法，需要很多相关量和高阶量作为输入，算法的时间复杂度就会很大，还有可能会产生过拟合问题，如下图：&lt;br/&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1fl9tf830ugj31g80rsqd5.jpg&quot;/&gt;&lt;br/&gt;这时就可以选择采用神经网络算法。&lt;br/&gt;神经网络算法最早是人们希望模仿大脑的学习功能而想出来的。&lt;br/&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fl9tpet8xuj31880qa1ab.jpg&quot;/&gt;&lt;br/&gt;一个神经元，有多个树突(Dendrite)作为信息的输入通道，也有多个轴突（Axon）作为信息的输出通道。一个神经元的输出可以作为另一个神经元的输入。神经元的概念和多分类问题的分类器概念很相近，都是可以接收多个输入，在不同的权值(weights)下产生出多个不同的输出。&lt;/p&gt;
&lt;h2 id=&quot;模型表示&quot;&gt;模型表示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1fl9u4csok8j31bm0s2jym.jpg&quot; alt=&quot;模型示意图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模型可以写成如下形式:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{bmatrix}x_0 \newline x_1 \newline x_2 \newline \end{bmatrix}\rightarrow\begin{bmatrix}\ \ \ \newline \end{bmatrix}\rightarrow h_\theta(x) \]&lt;/span&gt;&lt;br/&gt;上图可以称为&lt;strong&gt;单隐层前馈网络&lt;/strong&gt;，由&lt;strong&gt;输入层&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;,&lt;strong&gt;输出层&lt;/strong&gt;和它们之间的&lt;strong&gt;隐含层&lt;/strong&gt;构成。&lt;/p&gt;
&lt;p&gt;每个输出层都有一个&lt;strong&gt;权重矩阵(weights matrix)&lt;/strong&gt;和一个&lt;strong&gt;偏置单元(bias unit)&lt;/strong&gt;，用来计算输出。&lt;/p&gt;
&lt;h2 id=&quot;前向传播&quot;&gt;前向传播&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1255455112.cossh.myqcloud.com/2017-12-03-081226.jpg&quot;/&gt;&lt;br/&gt;首先回顾一下Logistic Regression的单分类问题中&lt;span class=&quot;math inline&quot;&gt;\(h_\theta\)&lt;/span&gt;的计算：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*}\begin{bmatrix}x_0 \newline x_1 \newline x_2\end{bmatrix} \rightarrow\begin{bmatrix}g(z^{(2)})\end{bmatrix} \rightarrow h_\Theta(x)\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以写为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[z^{(2)}=\omega^{(2)}a^{(1)}+b^{(2)}\\\ a^{(2)}=g(z^{(2)})\\\ h_\theta(x)=a^{(2)} \]&lt;/span&gt;&lt;br/&gt;而神经网络的前向传播，也就是在此基础上增加了层数，让一层的输出作为下一层的输入：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[z^{(i)}=\omega^{(i)}a^{(i-1)}+b^{(i)}\\\ a^{(i)}=g(z^{(i)})\\\ z^{(i+1)}=\omega^{(i+1)}a^{(i)}+b^{(i+1)}\\\ ... \]&lt;/span&gt;&lt;br/&gt;需要注意的是，每一层有多个单元，所以这里面的权重也是个二维矩阵。&lt;/p&gt;
&lt;h2 id=&quot;反向传播backpropagation&quot;&gt;反向传播（Backpropagation）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1255455112.cossh.myqcloud.com/2017-12-03-081418.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;直观理解&quot;&gt;直观理解&lt;/h3&gt;
&lt;p&gt;但给予初始的偏置单元和权重矩阵后，预测值会不太理想。&lt;br/&gt;那么，如何使预测值符合真实值呢？&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[z^{(i)}=\omega^{(i)}a^{(i-1)}+b^{(i)}\]&lt;/span&gt;&lt;br/&gt;可以发现，可以通过改变每一层的&lt;span class=&quot;math inline&quot;&gt;\(a,\omega,b\)&lt;/span&gt;来改变最终的输出，但实际上&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;是不能直接改变的。&lt;br/&gt;所以本质上要做的就是改变&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;来使预测值接近真实值。&lt;br/&gt;思路和之前的logistic regression和线性回归模型一样，也是先构建代价函数，然后通过梯度下降法使代价方程的值降到最低点，也就得到了合适的&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;。&lt;br/&gt;而使用梯度下降法时，需要计算每个&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;的梯度，梯度的绝对值越大，说明当前的代价函数对该参数的改变越敏感，改变这个参数使代价函数下降的越快。&lt;/p&gt;
&lt;h3 id=&quot;微积分公式推导&quot;&gt;微积分公式推导&lt;/h3&gt;
&lt;p&gt;以&lt;a href=&quot;https://www.bilibili.com/video/av16577449/index_2.html#page=2&quot;&gt;3B1B视频&lt;/a&gt;中的网络为例：&lt;br/&gt;&lt;img src=&quot;https://blog-1255455112.cossh.myqcloud.com/2017-12-03-103241.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代价方程可以由最后一层的激活值&lt;span class=&quot;math inline&quot;&gt;\(a^{(L)}\)&lt;/span&gt;和真实值y的均方误差:&lt;span class=&quot;math inline&quot;&gt;\((a^{(L)}-y)^2\)&lt;/span&gt;表示。（PS：这里L=4,有些教材计算均方误差时乘上&lt;span class=&quot;math inline&quot;&gt;\(1/2\)&lt;/span&gt;）&lt;br/&gt;然后，我们要求解&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;的梯度。&lt;br/&gt;在这里以&lt;span class=&quot;math inline&quot;&gt;\(\frac{C_0}{\partial \omega^{(L)}}\)&lt;/span&gt;为例:&lt;/p&gt;
&lt;p&gt;求梯度，也就是求代价函数对参数变化的敏感度。&lt;br/&gt;可以发现，改变&lt;span class=&quot;math inline&quot;&gt;\(\omega^{(L)}\)&lt;/span&gt;，会先影响到&lt;span class=&quot;math inline&quot;&gt;\(z^{(L)}\)&lt;/span&gt;,然后再影响到&lt;span class=&quot;math inline&quot;&gt;\(a^{(L)}\)&lt;/span&gt;,最后影响&lt;span class=&quot;math inline&quot;&gt;\(C_0\)&lt;/span&gt;。&lt;br/&gt;利用这个特性，可以将&lt;span class=&quot;math inline&quot;&gt;\(\frac{C_0}{\partial \omega^{(L)}}\)&lt;/span&gt;分解：&lt;br/&gt;&lt;img src=&quot;https://blog-1255455112.cossh.myqcloud.com/2017-12-03-104922.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是所谓的链式法则(Chain rule):&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{split} \frac{C_0}{\partial \omega^{(L)}}=&amp;amp;\frac{\partial z^{(L)}}{\partial \omega^{(L)}}\frac{\partial a^{(L)}}{\partial z^{(L)}}\frac{\partial C_0}{\partial a^{(L)}}\\\ =&amp;amp;a^{L-1}\sigma\prime(z^{(L)})2(a^{(L)}-y) \end{split}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样也可以求得&lt;span class=&quot;math inline&quot;&gt;\(b^{(L)}\)&lt;/span&gt;的梯度：&lt;br/&gt;&lt;img src=&quot;https://blog-1255455112.cossh.myqcloud.com/2017-12-03-112154.png&quot;/&gt;&lt;br/&gt;以上的网络每层只有一个神经元，如果有多个单元的话，以上的公式也是成立的。&lt;br/&gt;之前提过，权重矩阵是二维的，可以给两个下标&lt;span class=&quot;math inline&quot;&gt;\(j,k\)&lt;/span&gt;表示&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;:&lt;br/&gt;&lt;img src=&quot;https://blog-1255455112.cossh.myqcloud.com/2017-12-03-113339.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://blog-1255455112.cossh.myqcloud.com/2017-12-03-113636.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;链式法则更新如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split}\frac{C_0}{\partial \omega_{jk}^{(L)}}&amp;amp;= \frac{\partial z_j^{(L)}}{\partial \omega_{jk}^{(L)}}\frac{\partial a_j^{(L)}}{\partial z_j^{(L)}}\frac{\partial C_0}{\partial a_j^{(L)}}\\ &amp;amp;=a^{L-1}_k \sigma\prime(z^{(L)}_j)2(a^{(L)}_j-y_j) \end{split}\]&lt;/span&gt;&lt;br/&gt;而要把这个公式递推到其它层求&lt;span class=&quot;math inline&quot;&gt;\(\frac{C}{\partial \omega_{jk}^{(l)}}\)&lt;/span&gt;时，只需要变动公式中的&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial C}{\partial a_j^{(l)}}\)&lt;/span&gt;即可。&lt;br/&gt;总结如下：&lt;br/&gt;&lt;img src=&quot;https://blog-1255455112.cossh.myqcloud.com/2017-12-03-123439.png&quot;/&gt;&lt;br/&gt;所以，可以发现，计算梯度时，前两项&lt;span class=&quot;math inline&quot;&gt;\(a^{l-1}_k ,\sigma\prime(z^{(l)}_j)\)&lt;/span&gt;是可以直接算出的，而最后一项，则可以先计算出&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial C0}{\partial a_j^{(L)}}\)&lt;/span&gt;，然后一层层向前传播即可，反向传播大概也就是这么个意思吧。&lt;br/&gt;Andrew&lt;a href=&quot;https://www.coursera.org/learn/machine-learning/supplement/pjdBA/backpropagation-algorithm&quot;&gt;机器学习&lt;/a&gt;课程中给出了计算方法，也可以按这个思路去理解了。&lt;br/&gt;&lt;img src=&quot;https://blog-1255455112.cossh.myqcloud.com/2017-12-03-124213.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tips随机梯度下降法stochastic-gradient-descent&quot;&gt;TIPS:随机梯度下降法（Stochastic gradient descent）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1255455112.cossh.myqcloud.com/2017-12-03-124525.png&quot;/&gt;&lt;br/&gt;在之前的batch model中，每次更新权值都要遍历所有的样本然后取均值，这样效率太低，可以把样本分成数个大小相等的mini-batch，每次遍历完一个mini-batch，就更新下权值，虽然下降的路线未必最短，但速度上提升不少，这就是随机梯度下降算法。&lt;/p&gt;
</description>
<pubDate>Sun, 03 Dec 2017 12:52:00 +0000</pubDate>
<dc:creator>Messier</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/messier/p/7967245.html</dc:identifier>
</item>
<item>
<title>JSONP原理解析 - liuyongjia</title>
<link>http://www.cnblogs.com/liuyongjia/p/7967119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyongjia/p/7967119.html</guid>
<description>&lt;p&gt;我工作以来接触的第一个项目就是前后端分离的，前端静态文件有自己独立域名，通过接口来获取数据进行渲染等操作。&lt;br/&gt;跨域的方法不需要多言，随便一搜，就有很多，但最常用不外乎jsonp和CORS。jsonp着重于前端，也算是前端Hack技巧，CORS重于后端，服务端需要配置的地方会较多。&lt;br/&gt;这篇解析一下jsonp的实现原理。&lt;/p&gt;

&lt;p&gt;基本原理很容易说明白，在html页面中有一些标签是不受跨域限制的，比如img，script，link等。如果把我们需要的数据，放在一个js文件里面，这时，我们就能突破浏览器同源的限制。&lt;/p&gt;
&lt;h2 id=&quot;创建script标签&quot;&gt;创建script标签&lt;/h2&gt;
&lt;p&gt;《高性能JavaScript》中提到了动态脚本元素，作者写道：&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;文件在该元素被添加到页面时开始下载。这种技术的重点在于：无论何时启动下载，文件的下载和执行过程不会阻塞页面其他进程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;使用动态脚本节点下载文件时，返回的代码通常会立刻执行（除了Firefox和Oprea，它们会等待此前所有动态脚本节点执行完毕。）当脚本自执行时，这种机制运行正常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;引用1保证了JSONP请求的时候不会阻塞主线程，引用2保证了JSONP代码在加载完成后，立刻自执行时不会出错。&lt;/p&gt;
&lt;h2 id=&quot;callback&quot;&gt;callback&lt;/h2&gt;
&lt;p&gt;服务端在接收到GET请求之后，通常要判断是否有callback参数，如果有，则需要在返回的数据外面加上一个方法名和括号。例如，发起如下请求：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://www.a.com/getSomething?callback=jsonp0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么服务端就会返回如下内容：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;jsonp0&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:{}}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显，由于这是在动态加载的Script标签中包含的内容，那么这就是一段自执行代码，这段代码只有一个函数被调用———jsonp0。&lt;br/&gt;当然，有执行，则必须先创建，否则就会报错。创建这一步，就需要在调用前执行。&lt;br/&gt;具体实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;jsonp&lt;/span&gt; (url&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; successCallback&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; errorCallback&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; completeCallback) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 声明对象，需要将函数声明至全局作用域&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;jsonp0&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;successCallback&lt;/span&gt;(data)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (completeCallback) &lt;span class=&quot;at&quot;&gt;completeCallback&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 创建script标签，并将url后加上callback参数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; 
        script &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'script'&lt;/span&gt;)
        &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; url &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;url&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;indexOf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'?'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'?'&lt;/span&gt; : &lt;span class=&quot;st&quot;&gt;'&amp;amp;'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'callback=jsonp0'&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;script&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; url&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;head&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;parentNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;insertBefore&lt;/span&gt;(script&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;head&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 等到script加载完毕以后，就会自己执行&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面基本上完成了一个jsonp方法的核心，此时，jsonp0是我们声明好的一个函数，如果服务端正常回传的时候，就会执行jsonp0函数，里面的successCallback回调也会执行。&lt;/p&gt;
&lt;h2 id=&quot;完善一下&quot;&gt;完善一下&lt;/h2&gt;
&lt;p&gt;在实际情况下，通常会有许多个jsonp的请求同时调用，&lt;br/&gt;那么既然jsonp0就能满足我们的需要，为什么常常看到jsonp1，jsonp2等等依次累加的代码呢？&lt;br/&gt;这是因为，请求可能是很多个异步进行。在第一次执行jsonp方法时，window.jsonp0是函数A，此时去加载js文件，在js未加载完毕的情况下，又调用了一次jsonp方法，此时，window.jsonp0指向了函数B。那么等到两次的js加载完毕以后，都会执行第二次的回调。&lt;br/&gt;所以，我们需要对callback的名字做一个区别处理，累加就能满足需要。&lt;br/&gt;修改一下代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; jsonpCounter &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;jsonp&lt;/span&gt; (url&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; successCallback&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; errorCallback&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; completeCallback) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; jsId &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'jsonp'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; jsonpCounter&lt;span class=&quot;op&quot;&gt;++;&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;// 声明对象，需要将函数声明至全局作用域&lt;/span&gt;
    window[jsId] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;successCallback&lt;/span&gt;(data)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (completeCallback) &lt;span class=&quot;at&quot;&gt;completeCallback&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;clean&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 创建script标签，并将url后加上callback参数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; 
        script &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'script'&lt;/span&gt;)
        &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; url &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;url&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;indexOf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'?'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'?'&lt;/span&gt; : &lt;span class=&quot;st&quot;&gt;'&amp;amp;'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'callback='&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; jsId
    &lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;script&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; url&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;head&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;parentNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;insertBefore&lt;/span&gt;(script&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;head&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 等到script加载完毕以后，就会自己执行&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;//在执行完我们这个方法以后，会有很多script标签出现在head之前，我们需要手动的删除掉他们。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;clean&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;script&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;parentNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;removeChild&lt;/span&gt;(script)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        window[jsId] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{};&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入了累加和清理之后，还有一个重要的地方需要处理，就是错误回调。正常来说，我们通常请求jsonp时，会设定一个超时时间，如果超过这个时间以后，就抛出超时异常。&lt;br/&gt;实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; jsonpCounter &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;jsonp&lt;/span&gt; (url&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; successCallback&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; errorCallback&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; completeCallback&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; timeout) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 略去上面写过的代码&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; 
        timeout &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; timeout &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; timer
    &lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (timeout) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        timer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (errorCallback) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;errorCallback&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'timeout'&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;clean&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; timeout)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;clean&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;script&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;parentNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;removeChild&lt;/span&gt;(script)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        window[jsId] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{};&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (timer) &lt;span class=&quot;at&quot;&gt;clearTimeout&lt;/span&gt;(timer)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，基本上就完成了jsonp的全部功能，剩下的可能需要做一些兼容的修改，才算是一个完整的jsonp方法。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;《高性能JavaScript》&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;npm上的一个jsonp实现，&lt;a href=&quot;https://www.npmjs.com/package/jsonp&quot;&gt;JSONP&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 03 Dec 2017 12:21:00 +0000</pubDate>
<dc:creator>liuyongjia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyongjia/p/7967119.html</dc:identifier>
</item>
</channel>
</rss>