<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>表单数据验证方法（一）—— 使用validate.js实现表单数据验证 - CherishTheYouth</title>
<link>http://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_903.html</guid>
<description>&lt;h3&gt;&lt;span&gt;摘要：使用validate.js在前端实现表单数据提交前的验证&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 　&lt;span&gt;　好久没写博客了，真的是罪过，以后不能这样了，只学习不思考，学的都是白搭，希望在博客园能记录下自己学习的点滴，虽然记录的都是些浅显的技术，但能起到巩固自己和稍微帮助一下和我一样的菜鸡也是不错的，哈哈，不好意思，闲话扯多了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今天想把之前学的表单验证的方法复习一遍，因为明天的工作中要用到，而且好久没复习了，都快忘记了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在是学的ASP.NET，关于表单验证，目前知道的，除了以前那种傻瓜式的每个表单选项都用一个函数去验证之外，有两种方法是比较方便的，今天先介绍一下第一种，在前端实现表单验证的方法——基于validate.js的表单验证方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;注意哟，以下我都用截图的方式挂出代码，然后最后会把完整代码贴出来，提供复制粘贴，小伙伴不要急着敲哦！&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.下载和引入validate.js&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们需要下载一份validate.js文件，这个文件可以去JQuery官网或者csdn等网站下载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903225617417-291726500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下载好之后，新建一个html文件，然后先后将jquery.js文件和validate.js引入html代码，我这里新建一个名为formCheck.html的文件，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903230237804-467797902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;这里为了待会的表单表现的好看一些，我引入了layui.css的样式文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.建立表单&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903232754699-352383217.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903233022205-533468087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt; 3.使用validate.js实现表单数据的验证&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 同样，我们直接看代码截图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903233434669-708133478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;除了这些检验方式，validate.js里还封装了包括&lt;strong&gt;邮箱格式验证，电话号码格式验证&lt;/strong&gt;等验证犯法，使用方法和上图中的&lt;strong&gt;number&lt;/strong&gt;一致，想进一步了解的同学可以自行查看具体的js内容哦。&lt;/span&gt;&lt;span&gt;上图中的代码，rules部分限定了输入数据的规范，message则设定了错误提示信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;4.查看结果&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903234018954-2057798329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1454180/201809/1454180-20180903234049872-938667503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　 这种验证方法还是非常简单和方便的，借助一个js插件，轻松搞定数据验证，希望这个简单的demo能帮到何我一样的菜鸡哦，先写到这里啦，要睡了，晚安哦！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对了，差点忘了奉上完整代码了，请笑纳：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;title&amp;gt;前端表单验证&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;         &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-v2.3.0/layui/css/layui.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;span&gt; 7&lt;/span&gt;         &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt; 8&lt;/span&gt;         &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;js/jquery.validate.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt; 9&lt;/span&gt;         &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-v2.3.0/layui/layui.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt;10&lt;/span&gt;         &amp;lt;style type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;11&lt;/span&gt;             #form-&lt;span&gt;box{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                width: 700px;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                height: 300px;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                margin: auto;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                position: relative;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                top: 100px;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &amp;lt;/style&amp;gt;
&lt;span&gt;19&lt;/span&gt;     &amp;lt;/head&amp;gt;
&lt;span&gt;20&lt;/span&gt;     &amp;lt;body&amp;gt;
&lt;span&gt;21&lt;/span&gt;         &amp;lt;form action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;formCheck.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;22&lt;/span&gt;             &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-box&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form layui-form-pane&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;23&lt;/span&gt;                 &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;24&lt;/span&gt;                     &amp;lt;label &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;用户名&amp;lt;/label&amp;gt;
&lt;span&gt;25&lt;/span&gt;                     &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-input-inline&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;26&lt;/span&gt;                        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;27&lt;/span&gt;                     &amp;lt;/div&amp;gt;       
&lt;span&gt;28&lt;/span&gt;                  &amp;lt;/div&amp;gt;
&lt;span&gt;29&lt;/span&gt;                  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;30&lt;/span&gt;                     &amp;lt;label &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;密码&amp;lt;/label&amp;gt;
&lt;span&gt;31&lt;/span&gt;                     &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-input-inline&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;32&lt;/span&gt;                        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passWord&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;33&lt;/span&gt;                     &amp;lt;/div&amp;gt;   
&lt;span&gt;34&lt;/span&gt;                  &amp;lt;/div&amp;gt;
&lt;span&gt;35&lt;/span&gt;                  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-form-item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;                   
&lt;span&gt;36&lt;/span&gt;                        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;frmSubmit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layui-btn layui-btn-primary layui-btn-normal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;span&gt;37&lt;/span&gt;                  &amp;lt;/div&amp;gt;
&lt;span&gt;38&lt;/span&gt;             &amp;lt;/div&amp;gt;
&lt;span&gt;39&lt;/span&gt;         &amp;lt;/form&amp;gt;
&lt;span&gt;40&lt;/span&gt;     &amp;lt;/body&amp;gt;
&lt;span&gt;41&lt;/span&gt;     &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        $(function(){
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).validate({
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                    rules: {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                        userName: {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                             required: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该项表示该字段为必填项&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                             maxlength: &lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示该字段的最大长度为5&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                        },
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                        passWord: {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                             required: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                             number: &lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示该字段必须为数字&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                    },
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                    messages: {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                        userName: {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                             required: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*必填&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                             maxlength: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*最多5个字符&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                        },
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                        passWord: {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                             required: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*必填&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                             number: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*必须是合法的数字&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                    }                    
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;                })        
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;67&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt; 希望能帮到你哦！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的eMail:3074596466@qq.com&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Mon, 03 Sep 2018 15:48:00 +0000</pubDate>
<dc:creator>CherishTheYouth</dc:creator>
<og:description>使用validate.js在前端实现表单数据提交前的验证</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_903.html</dc:identifier>
</item>
<item>
<title>北京周末去哪儿 —— 天安门广场 - 一 定 会 去 旅 行</title>
<link>http://www.cnblogs.com/jying/p/9415523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jying/p/9415523.html</guid>
<description>&lt;p&gt;对于第一次来北京的游客，天安门都是必去的一站，毕竟那是祖国首都最中心的地方，心脏。&lt;/p&gt;
&lt;p&gt;对于来北京工作的奋斗者，早晚你会去看看它。&lt;/p&gt;
&lt;p&gt;本文主要针对周末逛北京的群体，对于外来游客，改天我会单独开贴。&lt;/p&gt;
&lt;p&gt;不同于外来游客，作为本地“居住民”而游览这座城市，应该怀着一种慢悠悠的休闲，只有这样你才能体味观察到那种京味，假如你像个外来游客一样匆匆而过，拍张照证明到此一游，那我奉劝你看完本文再去重游一遍吧~~&lt;/p&gt;
&lt;p&gt;天安门广场适合上午游览，如果你能在6点后8点前赶到的话，那时候在我看来是一天中最好的时候，看升国旗的刚刚散去，旅游团还没赶到，阳光打在天安门城楼上也刚刚好的和煦，其实没有必要去看升国旗，因为真的是太早了，作为本地“居住民”恐怕只有紧挨在附近的才能赶到，其他的要么是外来旅游住在酒店的，要么还听说过通宵一晚等待的，也听说过半夜往那骑行或步行的。&lt;/p&gt;

&lt;p&gt;如下图，游览整个天安门广场的路线图建议为：天安门广场——毛主席纪念堂——天安门城楼——端门左出口——王府井大街。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/362679/201809/362679-20180901121456729-1890800791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;希望大家在游览时听从服务人员指挥，爱护环境，小声言语，文明游览，成年人请随身携带身份证。&lt;/p&gt;
&lt;p&gt;1、到达天安门广场最近的地铁出口是1号线天安门东站和天安门西站，2号线的前门站，因为进入天安门广场需要安检，所以我推荐的到达时间是6点-8点游客较少，当然11点之前到达都是可以的，但如果要去看毛爷爷的话就必须11点前了，因为12点后闭馆。&lt;/p&gt;
&lt;p&gt;　  天安门广场虽然只是个广场，但因为它是中国人们心中的首都广场，又有每天的升国旗，新闻联播中每天出境的人民英雄纪念碑，所以置身其中感觉很神圣。&lt;/p&gt;
&lt;p&gt;2、毛爷爷纪念堂（免票），严格安检，禁止携带打火机/火柴/刀具等危险品，门口会全部没收，而且是&lt;span&gt;单行道进出&lt;/span&gt;，所以没收后无法再取回，吸烟者提前注意，钥匙/硬币等铁器需要拿出口袋检查，大包需要寄存，所以最好的方式是有一个人学做雷锋放弃进去参观在外面背包。毛爷爷纪念堂&lt;span&gt;开馆时间8:00—12:00（下午闭馆）&lt;/span&gt;，其中暑假7月1日至8月31日7:00—11:00点（下午闭馆），另外&lt;span&gt;每周一全天闭馆&lt;/span&gt;。入馆不准开口说话，请大家怀着缅怀的心情入馆瞻仰，不要嬉皮笑脸的。&lt;br/&gt;&lt;span&gt;　　a．瞻仰、参观须凭有效证件（可能是身份证也可能不需要）&lt;span&gt;免费&lt;/span&gt;排队入场。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　b．自觉接受安全检查。严禁携带危险物品入场。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　c．&lt;span&gt;严禁携带手提包、背包、照相机、摄像机、水杯、饮料&lt;/span&gt;等物品入场。带有上述物品者请先到存包处寄存。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　d．注意衣着整洁、得体，脱帽瞻仰。&lt;span&gt;穿背心、拖鞋者谢绝入场。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　e．注意保持安静。&lt;span&gt;请关闭手机或将手机调至静音状态，不要大声喧哗、嬉笑打闹。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 　　f．注意保持环境整洁。严禁吸烟，严禁随地吐痰、&lt;span&gt;严禁嚼吐口香糖&lt;/span&gt;，严禁乱扔烟头、果皮、纸屑等废弃物，严禁翻越栏杆、踩踏花坛和草坪。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、大家可以在广场拍拍照，以天安门为背景，以人民大会堂为背景，以人民英雄纪念碑为背景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/362679/201809/362679-20180901121510640-1118485384.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、天安门广场与天安门城楼中间是长安街，所以可以走地下走廊穿过，天安门城楼前斜侧其实也是拍照的好地点，在天安门广场拍摄时距离有点远背景人还巨多，但是在天安门城楼前正面拍摄又太近显示不下整个城楼，所以斜侧60-80度是最好的角度位置，去晚了背景都是人需要抢占拍照位置哦~~&lt;/p&gt;
&lt;p&gt;5、天安门城楼那个门是可以免费进入的，不收费的~~但是&lt;span&gt;下午3点关门&lt;/span&gt;，所以这也是推荐上午去的原因之一。另外这个门是&lt;span&gt;单行道，进去后不能原路退回&lt;/span&gt;。小时候学课文，什么华表，金水桥都专门赞美一段，等你到了看一眼根本不吸引人……天安门城楼可以上去（收费，需寄存包裹），所以空手的有兴趣的可以上去看看，但是我没上去过~~&lt;/p&gt;
&lt;p&gt;6、穿过天安门城楼一直往前走，到端门往里属于故宫就收费啦，可以选择左门出，顺路往前走，路旁有卖老冰棍的，1块一根~~一直走就能到王府井大街，这时候差不多就是正午啦，这么有名的地方当然没啥便宜吃饭地方，景点那些快餐量少又贵还不好吃，所以不如直接王府井找有吃饭一条街的商场，便宜的话比如庆丰包子，比如吉野家，带妹子的话建议呷哺，相对便宜还不丢面。吃完饭有兴趣的还可以在王府井逛逛，男生可以转转王府井的apply实体店。&lt;/p&gt;
&lt;p&gt;7、打道回府，大约下午3，4点的时候就可以打道回府啦~~干嘛要回家那么晚呢，轻轻松松日常闲逛才是享受生活嘛~~&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;天安门广场线路就介绍到这里啦，以下为个人指数感受，满分都是10星：&lt;/p&gt;
&lt;p&gt;推荐指数：8星（毕竟是首都的中心的中心）&lt;br/&gt;交通指数：8星（主要安检什么的排队耗时）&lt;br/&gt;团体指数：8星（互拍照片必不可少）&lt;br/&gt;家庭指数：8星（我真的觉得这是一个家庭一起活动一起步行的很好路线，前提是家庭成员体力上能走完）&lt;br/&gt;情侣指数：7星（只要体力好，走一走很美好~~前提是妹子愿意跟你走这么远）&lt;br/&gt;食物指数：4星（主要吃饭贵远，富人自动屏蔽）&lt;br/&gt;休闲指数：5星（要走很多路，要看很多人）&lt;/p&gt;
&lt;p&gt;最佳游览季节：3月1号-5月10号，8月15号-10月30&lt;/p&gt;



</description>
<pubDate>Mon, 03 Sep 2018 15:44:00 +0000</pubDate>
<dc:creator>一 定 会 去 旅 行</dc:creator>
<og:description>对于第一次来北京的游客，天安门都是必去的一站，毕竟那是祖国首都最中心的地方，心脏。 对于来北京工作的奋斗者，早晚你会去看看它。 本文主要针对周末逛北京的群体，对于外来游客，改天我会单独开贴。 不同于外</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jying/p/9415523.html</dc:identifier>
</item>
<item>
<title>详解JS中DOM 元素的 attribute 和 property 属性 - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9581851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9581851.html</guid>
<description>&lt;h4 id=&quot;一表亲戚attribute和property&quot;&gt;一、'表亲戚':attribute和property&lt;/h4&gt;
&lt;p&gt;为什么称attribute和property为'表亲戚'呢?因为他们既有共同处,也有不同点.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;attribute&lt;/code&gt; 是 dom 元素在文档中作为 html 标签拥有的属性；&lt;br/&gt;&lt;code&gt;property&lt;/code&gt; 是 dom 元素在 js 中作为对象拥有的属性。&lt;/p&gt;
&lt;p&gt;从定义上可以看出:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的&lt;/li&gt;
&lt;li&gt;但是对于自定义的属性来说，他们是不同步的.(自定义属性不会自动添加到property)&lt;/li&gt;
&lt;li&gt;property 的值可以改变；attribute 的值不能改变&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;二&quot;&gt;二、&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;分别打印两个值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;打印attribute属性&lt;/strong&gt;&lt;br/&gt;直接把div标签当作对象,用'.'输出即是property属性&lt;br/&gt;但是注意!&lt;span&gt;property是不能输出自定义属性的&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//html
&amp;lt;div class=&quot;divClass&quot; id=&quot;divId&quot; &amp;gt;&amp;lt;/div&amp;gt;

//js
window.onload = function(){
    var divId = document.getElementById('divId');
    console.log(divId.id);
    console.log(divId.add)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201809/1414709-20180903222314862-922982860.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看见attributes对应的值,我们打印一下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(divId.attributes[0]);       //打印 class=&quot;divClass&quot;
console.log(divId.attributes.class)     //打印 class=&quot;divClass&quot;

console.log(divId.getAttribute('class'))    //打印divClass
console.log(divId.getAttribute('id'))    //打印divId&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现上面两组值是相等的.&lt;/p&gt;
&lt;p&gt;虽然都可以取值,但《js高级程序设计》中提到，为了方便操作，建议大家用setAttribute()和getAttribute()来操作即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打印property&lt;/strong&gt;&lt;br/&gt;html自带的dom属性会自动转换成property,但是自定义的属性没有这个'权利'&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;divClass&quot; id=&quot;divId&quot; addUserDefine=&quot;zidingyi&quot;&amp;gt;&amp;lt;/div&amp;gt;

console.log(divId.class);           //打印 divClass
console.log(divId.addUserDefine)    //打印 undefined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201809/1414709-20180903223422977-698780892.png&quot;/&gt;&lt;br/&gt;打开Elements的properties可以看到,dom存在的属性,property同样继承了,而&lt;code&gt;addUserDefine&lt;/code&gt;却没有出现在&lt;span&gt;property&lt;/span&gt;中&lt;/p&gt;
&lt;p&gt;property:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var obj = {};
Object.defineProperty(obj,'name',{
    value:'Property'
})

console.log(obj.name)   //打印 Property&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三用例子解析两者赋值&quot;&gt;三、用例子解析两者赋值&lt;/h4&gt;
&lt;p&gt;如果我们修改了property的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//html
&amp;lt;input value=&quot;initValue&quot; id=&quot;ipt&quot;/&amp;gt;

//js
window.onload = function(){
    var ipt = document.getElementById('ipt');

    ipt.value = 'changeValue'
    console.log(ipt.value);
    console.log(ipt.getAttribute('value'));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;猜一下结果??&lt;br/&gt;答案是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(ipt.value);         //changeValue
console.log(ipt.getAttribute('value'));     //initValue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再来看看input的值&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201809/1414709-20180903230918526-1680293703.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;难以置信?&lt;br/&gt;我们再来看看从修改attribute入手&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//html
&amp;lt;input value=&quot;initValue&quot; id=&quot;ipt&quot;/&amp;gt;

//js
window.onload = function(){
    var ipt = document.getElementById('ipt');

    ipt.setAttribute('value','changeValue')
    console.log(ipt.value);
    console.log(ipt.getAttribute('value'));

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(ipt.value);         //changeValue
console.log(ipt.getAttribute('value'));     //changeValue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;property比attribute'霸道',估计是'表哥'&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;property和attribute两者是属于单方面通信,即:&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;1.property能够从attribute中得到同步；
2.attribute不会同步property上的值；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再啰嗦一句:&lt;br/&gt;对属性Property可以赋任何类型的值，而对特性Attribute只能赋值字符串！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
//js
var obj = {
    value : false,
}

var ipt = document.getElementById('ipt');

obj.value = true;       //property更改
ipt.setAttribute('value',true)  //attribute更改

console.log(typeof obj.value);  //boolean
console.log(obj.value)          //true

console.log(typeof ipt.value)   //string
console.log(ipt.value);         //true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大吉大利,感谢阅读,欢迎纠正！&lt;/p&gt;
</description>
<pubDate>Mon, 03 Sep 2018 15:24:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、'表亲戚':attribute和property 为什么称attribute和property为'表亲戚'呢?因为他们既有共同处,也有不同点. 是 dom 元素在文档中作为 html 标签拥有的属</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9581851.html</dc:identifier>
</item>
<item>
<title>跟厂长学PHP7内核（六）：生命周期之请求初始化阶段 - 了不起的厂长</title>
<link>http://www.cnblogs.com/enochzzg/p/9581544.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enochzzg/p/9581544.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上篇文章我们分析了生命周期的模块初始化阶段，大部分是初始化全局变量和各种宏的定义，今天我们来学习一下五大生命周期的第二阶段--请求初始化阶段（php_request_startup）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们先对请求初始化阶段内的函数做个概览。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;php_output_activate()&lt;/td&gt;
&lt;td&gt;重置输出全局变量，初始化输出相关堆栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;zend_activate()&lt;/td&gt;
&lt;td&gt;初始化Zend引擎&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;sapi_activate()&lt;/td&gt;
&lt;td&gt;初始化SG宏，调各sapi钩子函数activate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;zend_signal_activate()&lt;/td&gt;
&lt;td&gt;信号处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;zend_set_timeout()&lt;/td&gt;
&lt;td&gt;设置超时时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;php_hash_environment()&lt;/td&gt;
&lt;td&gt;初始化PHP请求的全局变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;zend_activate_modules()&lt;/td&gt;
&lt;td&gt;调用各扩展定义的request_startup钩子函数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;php_output_activate&quot;&gt;2.1、php_output_activate&lt;/h2&gt;
&lt;p&gt;重新为output_globals分配内存，初始化与输出处理程序相关的堆栈，并将OG宏的flags设置为激活状态。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/output.c
PHPAPI int php_output_activate(void)
{
#ifdef ZTS
    memset((*((void ***) ZEND_TSRMLS_CACHE))[TSRM_UNSHUFFLE_RSRC_ID(output_globals_id)], 0, sizeof(zend_output_globals));
#else
    memset(&amp;amp;output_globals, 0, sizeof(zend_output_globals));
#endif

    zend_stack_init(&amp;amp;OG(handlers), sizeof(php_output_handler *));
    OG(flags) |= PHP_OUTPUT_ACTIVATED;

    return SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;zend_activate&quot;&gt;2.2、zend_activate&lt;/h2&gt;
&lt;p&gt;zend引擎的初始化，主要作用为重置垃圾回收、初始化编译器、初始化执行器、初始化扫描器。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;gc_reset()&lt;/td&gt;
&lt;td&gt;重置垃圾回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;init_compiler()&lt;/td&gt;
&lt;td&gt;初始化编译器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;init_executor()&lt;/td&gt;
&lt;td&gt;初始化执行器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;startup_scanner()&lt;/td&gt;
&lt;td&gt;初始化扫描器&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;sapi_activate&quot;&gt;2.3、sapi_activate&lt;/h2&gt;
&lt;p&gt;对SG宏内的一些变量进行初始化，并调用当前sapi_module_struct中定义的钩子函数activate()以及input_filter_init()，但是在cli模式下，这两个钩子函数都没有实现，返回了null。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//main/SAPI.c
SAPI_API void sapi_activate(void)
{
    zend_llist_init(&amp;amp;SG(sapi_headers).headers, sizeof(sapi_header_struct), (void (*)(void *)) sapi_free_header, 0);
    SG(sapi_headers).send_default_content_type = 1;

    /*
    SG(sapi_headers).http_response_code = 200;
    */
    SG(sapi_headers).http_status_line = NULL;
    SG(sapi_headers).mimetype = NULL;
    SG(headers_sent) = 0;
    ZVAL_UNDEF(&amp;amp;SG(callback_func));
    SG(read_post_bytes) = 0;
    SG(request_info).request_body = NULL;
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;php_hash_environment&quot;&gt;2.4、php_hash_environment&lt;/h2&gt;
&lt;p&gt;为http_globals分配内存，初始化auto_globals，解析请求参数并存放到全局变量中。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;PHPAPI int php_hash_environment(void)
{
    memset(PG(http_globals), 0, sizeof(PG(http_globals)));
    zend_activate_auto_globals();
    if (PG(register_argc_argv)) {
        php_build_argv(SG(request_info).query_string, &amp;amp;PG(http_globals)[TRACK_VARS_SERVER]);
    }
    return SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;zend_activate_modules&quot;&gt;2.5、zend_activate_modules&lt;/h2&gt;
&lt;p&gt;该函数通过遍历注册在module_registry的所有模块，调用每个模块的钩子函数request_startup()进行初始化。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;ZEND_API void zend_activate_modules(void) /* {{{ */
{
    zend_module_entry **p = module_request_startup_handlers;

    while (*p) {
        zend_module_entry *module = *p;

        if (module-&amp;gt;request_startup_func(module-&amp;gt;type, module-&amp;gt;module_number)==FAILURE) {
            zend_error(E_WARNING, &quot;request_startup() for %s module failed&quot;, module-&amp;gt;name);
            exit(1);
        }
        p++;
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 03 Sep 2018 14:23:00 +0000</pubDate>
<dc:creator>了不起的厂长</dc:creator>
<og:description>上篇文章我们分析了生命周期的模块初始化阶段，大部分是初始化全局变量和各种宏的定义，今天我们来学习一下五大生命周期的第二阶段 请求初始化阶段（php_request_startup）。 一、概览 我们先</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enochzzg/p/9581544.html</dc:identifier>
</item>
<item>
<title>Python抽象类（abc模块） - rongz</title>
<link>http://www.cnblogs.com/Rongze-blog/p/9581521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rongze-blog/p/9581521.html</guid>
<description>&lt;p&gt;1.抽象类概念&lt;/p&gt;
&lt;p&gt;抽象类是一个特殊的类，只能被继承，不能实例化&lt;/p&gt;
&lt;p&gt;2.为什么要有抽象类&lt;/p&gt;
&lt;p&gt;其实在未接触抽象类概念时，我们可以构造香蕉、苹果、梨之类的类，然后让它们继承水果这个的基类，水果的基类包含一个eat函数。&lt;/p&gt;
&lt;p&gt;但是你有没有想过，我们可以将香蕉、苹果、梨实例化，去吃香蕉、苹果、梨。但是我们却不能将水果实例化，因为我们无法吃到叫水果的这个东西。&lt;/p&gt;
&lt;p&gt;所以抽象类中只能有抽象方法（没有实现功能），该类不能被实例化，只能被继承，且子类必须实现抽象方法。&lt;/p&gt;
&lt;p&gt;3.抽象类的作用&lt;/p&gt;
&lt;p&gt;在不同的模块中通过抽象基类来调用，可以用最精简的方式展示出代码之间的逻辑关系，让模块之间的依赖清晰简单。&lt;/p&gt;
&lt;p&gt;抽象类的编程，让每个人可以关注当前抽象类的方法和描述，而不需要考虑过多的实现细节，这对协同开发有很大意义，也让代码可读性更高。&lt;/p&gt;
&lt;p&gt;4.抽象类的使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; abc  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用abc模块实现抽象类&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt; File(metaclass=abc.ABCMeta):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; abc.ABCMeta是实现抽象类的一个基础类&lt;/span&gt;
    @abc.abstractmethod  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义抽象方法，无需实现功能&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt; Txt(File):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 子类继承抽象类，但是必须定义read方法将抽象类中的read方法覆盖&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;文本数据的读取方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


txt1 &lt;/span&gt;=&lt;span&gt; Txt()
txt1.read()  &lt;/span&gt;
&lt;span&gt;
txt2 &lt;/span&gt;=&lt;span&gt; File()
txt2.read()
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;文本数据的读取方法
Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:/python/ftp_work/test.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 20, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;span&gt;
    txt2 &lt;/span&gt;=&lt;span&gt; File()
TypeError: Can&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t instantiate abstract class File with abstract methods read&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然将抽象类实例化报错了，得到了我们想要的结果&lt;/p&gt;
&lt;p&gt;5.abc模块在Python2&amp;amp;3的兼容问题&lt;/p&gt;
&lt;p&gt;为解决兼容性问题，我们需要引入six模块&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;通用做法。&lt;/p&gt;
&lt;p&gt;@six.add_metaclass(MetaClass) 的作用是在不同版本的Python之间提供一个优雅的声明类的metaclass的手段，事实上不用它也可以，只是使用了它代码更为整洁明了。&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;import six&lt;/p&gt;

&lt;p&gt;@six.add_metaclass(Meta)&lt;/p&gt;
&lt;p&gt;class MyClass(object):&lt;/p&gt;
&lt;p&gt;    pass&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;在Python 3 等价于&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;import six&lt;/p&gt;

&lt;p&gt;class MyClass(object, metaclass = Meta):&lt;/p&gt;
&lt;p&gt;    pass&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;在Python 2.x (x &amp;gt;= 6)中等价于&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;import six&lt;/p&gt;

&lt;p&gt;class MyClass(object):&lt;/p&gt;
&lt;p&gt;    __metaclass__ = Meta&lt;/p&gt;
&lt;p&gt;    pass&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;或者直接调用装饰器，&lt;/p&gt;
&lt;p&gt;这里也能看出来装饰器就是个方法包装而已。&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;import six&lt;/p&gt;

&lt;p&gt;class MyClass(object):&lt;/p&gt;
&lt;p&gt;    pass&lt;/p&gt;
&lt;p&gt;MyClass  = six.add_metaclass(Meta)(MyClass)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 03 Sep 2018 14:20:00 +0000</pubDate>
<dc:creator>rongz</dc:creator>
<og:description>1.抽象类概念 抽象类是一个特殊的类，只能被继承，不能实例化 2.为什么要有抽象类 其实在未接触抽象类概念时，我们可以构造香蕉、苹果、梨之类的类，然后让它们继承水果这个的基类，水果的基类包含一个eat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Rongze-blog/p/9581521.html</dc:identifier>
</item>
<item>
<title>Java中自定义注解 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/9576466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/9576466.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-1547&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;33&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;随着springboot的流行，以前基于XML的spring配置用的越来越少，JavaConfig形式使用的越来越多，类似于:&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-998&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;hljs-line&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AppConfig {
 
　　@Bean(name&lt;/span&gt;=&quot;helloBean&quot;&lt;span&gt;)
　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HelloWorld helloWorld() {
　　   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HelloWorldImpl();
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看出更多的是基于注解(Annotation)实现的，包括springboot的入口类**Application。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-4522&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;hljs-line&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ComponentScan(&lt;/span&gt;&quot;com.alibaba.trade&quot;&lt;span&gt;)
@EnableAutoConfiguration&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(exclude = {PageHelperAutoConfiguration.class})&lt;/span&gt;
&lt;span&gt;@ServletComponentScan
@EnableTransactionManagement
@EnableDiscoveryClient
@EnableWebMvc
@MapperScan(&lt;/span&gt;&quot;com.alibaba.trade.shared.mapper&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TradeApplication &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SpringBootServletInitializer {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
            SpringApplication.run(TradeApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Java注解不仅让我们减少了项目中XML文件，方便了维护，同时也使我们代码更简洁。那么项目中我们如何阅读注解以及如何创造自己的注解呢？&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-2291&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;39&quot;&gt;
&lt;h2 id=&quot;注解说明&quot;&gt;注解说明&lt;/h2&gt;
&lt;p&gt;Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法&lt;strong&gt;元数据&lt;/strong&gt;。为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java注解可以通过反射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;注解本身没有具体的功能，它相当于一个标注，而这个标注具体的作用和意义需要我们自己实现。一般都是先判断类或属性是否被该注解修饰再通过反射来获取注解属性再实现具体业务功能。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-5412&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;37&quot;&gt;
&lt;h3 id=&quot;内置注解&quot;&gt;内置注解&lt;/h3&gt;
&lt;p&gt;Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;1、作用在代码的注解是&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;@Override&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@Deprecated&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; - 标记过时方法。如果使用该方法，会报编译警告。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@SuppressWarnings&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; - 指示编译器去忽略注解中声明的警告。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、作用在其他注解的注解(或者说&lt;strong&gt;元注解&lt;/strong&gt;)是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;@Retention&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@Documented&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; - 标记这些注解是否包含在用户文档中。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@Target&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; - 标记这个注解应该是哪种 Java 成员。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@Inherited&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; - 标记这个注解是继承于哪个注解类(默认注解并没有继承于任何子类)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、从 Java 7 开始，额外添加了 3 个注解:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;@SafeVarargs&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@FunctionalInterface&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; - Java 8 开始支持，标识一个匿名函数或函数式接口。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@Repeatable&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-5413&quot; class=&quot;wmd-preview-section preview-content&quot;&gt;
&lt;h4 id=&quot;元注解&quot;&gt;元注解&lt;/h4&gt;
&lt;p&gt;1、&lt;strong&gt;@Retention&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-5414&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;@Retention&lt;/span&gt; annotation指定标记注释的存储方式：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RetentionPolicy.SOURCE - 标记的注释仅保留在源级别中，并由编译器忽略。&lt;/li&gt;
&lt;li&gt;RetentionPolicy.CLASS - 标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。&lt;/li&gt;
&lt;li&gt;RetentionPolicy.RUNTIME - 标记的注释由JVM保留，因此运行时环境可以使用它。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、&lt;strong&gt;@Documented&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;@Documented&lt;/span&gt;  注释表明，无论何时使用指定的注释，都应使用Javadoc工具记录这些元素（默认情况下，注释不包含在Javadoc中）。有关更多信息，请参阅 Javadoc工具页面。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;@Target&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-5415&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;41&quot;&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;@Target&lt;/span&gt;  注释标记另一个注释，以限制可以应用注释的Java元素类型。目标注释指定以下元素类型之一作为其值。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ElementType.TYPE 可以应用于类的任何元素。&lt;/li&gt;
&lt;li&gt;ElementType.FIELD 可以应用于字段或属性。&lt;/li&gt;
&lt;li&gt;ElementType.METHOD 可以应用于方法级注释。&lt;/li&gt;
&lt;li&gt;ElementType.PARAMETER 可以应用于方法的参数。&lt;/li&gt;
&lt;li&gt;ElementType.CONSTRUCTOR 可以应用于构造函数。&lt;/li&gt;
&lt;li&gt;ElementType.LOCAL_VARIABLE 可以应用于局部变量。&lt;/li&gt;
&lt;li&gt;ElementType.ANNOTATION_TYPE 可以应用于注释类型。&lt;/li&gt;
&lt;li&gt;ElementType.PACKAGE 可以应用于包声明。&lt;/li&gt;
&lt;li&gt;ElementType.TYPE_PARAMETER&lt;/li&gt;
&lt;li&gt;ElementType.TYPE_USE&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4、&lt;strong&gt;@Inherited&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;@Inherited&lt;/span&gt;  注释表明注释类型可以从超类继承。当用户查询注释类型并且该类没有此类型的注释时，将查询类的超类以获取注释类型（默认情况下不是这样）。此注释仅适用于类声明。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;strong&gt;@Repeatable&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;br/&gt;Repeatable Java SE 8中引入的，&lt;code&gt;@Repeatable&lt;/code&gt;注释表明标记的注释可以多次应用于相同的声明或类型使用(即可以重复在同一个类、方法、属性等上使用)。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-1722&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;60.5&quot;&gt;
&lt;h2 id=&quot;自定义注解&quot;&gt;自定义注解&lt;/h2&gt;
&lt;p&gt;Java中自定义注解和创建一个接口相似，自定义注解的格式是以@interface为标志的。&lt;/p&gt;
&lt;div class=&quot;hljs-line&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; SPI {
 
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
    * default extension name
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们知道java.lang.annotation包中有一个Annotation的接口，它是所有注解类型扩展的公共接口。那我们是否可以直接通过实现该接口来实现自定义注解呢？&lt;/p&gt;
&lt;div class=&quot;hljs-line&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Annotation;
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyAnnotation &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Annotation {
 
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Annotation&amp;gt;&lt;span&gt; annotationType() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;发现Annotation接口中只有一个annotationType的方法，而且通过Annotation源码的注释我们可以发现答案是不能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201809/1162587-20180903010146877-1929355949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;汉译即为：Annotaion被所有注解类型继承，但是要注意：手动扩展继承此接口的接口不会定义注解类型。另请注意，此接口本身不定义注解类型。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;自定义注解的使用场景很多，我们在造轮子写框架的过程经常会使用到，例如我最近就遇到了一个业务场景：像一些编辑业务信息的接口，产品要求信息编辑后的新旧值对比，对比的业务功能，我们的实现方式是拿到前端填写的Form表单(新值)和数据库中查询出来的Dto(旧值)通过反射技术获取到相同属性字段名，再比较属性值就可以得出新旧值。得到值之后我们也知道该字段的Dto中的字段名，但是如何将比较得到的新旧值字段的中文名返回给前端呢？例如：&lt;/p&gt;
&lt;div class=&quot;hljs-line&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Stedent {
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略setter,getter&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;比较后我们的结果是 name : “xiaoming “-&amp;gt; “daming”，age : 24 -&amp;gt; 26。但是我们不能直接将name和age返回给前端，他们需要的格式是：姓名: “xiaoming “-&amp;gt; “daming”，年龄 : 24 -&amp;gt; 26。这时候就可以考虑自定义一个注解&lt;code&gt;@FieldName&lt;/code&gt;,&lt;/p&gt;
&lt;div class=&quot;hljs-line&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Deprecated
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FieldName {

    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后将该注解加在属性字段上面&lt;/p&gt;
&lt;div class=&quot;hljs-line&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
 
    @FieldName(value &lt;/span&gt;= &quot;姓名&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
 
    @FieldName(value &lt;/span&gt;= &quot;年龄&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
 
    @FieldName(value &lt;/span&gt;= &quot;性别&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略setter,getter&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;之后就可以通过反射获取该字段中文名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 oldField 属性值与 newField 属性值的内容不相同&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isEmpty(newValue)) {
    Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
    String newFieldName &lt;/span&gt;=&lt;span&gt; newField.getName();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newField.isAnnotationPresent(ApiModelProperty.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
        ApiModelProperty apiModelPropertyAnno &lt;/span&gt;= newField.getAnnotation(ApiModelProperty.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        newFieldName &lt;/span&gt;=&lt;span&gt; apiModelPropertyAnno.value();
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (newField.isAnnotationPresent(FieldName.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
        FieldName fieldNameAnno &lt;/span&gt;= newField.getAnnotation(FieldName.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        newFieldName &lt;/span&gt;=&lt;span&gt; fieldNameAnno.name();
    }
        map.put(FIELD_NAME, newFieldName);
        map.put(OLD_VALUE, oldValue);
        map.put(NEW_VALUE, newValue);
        list.add(map);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Mon, 03 Sep 2018 14:06:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>前言 随着springboot的流行，以前基于XML的spring配置用的越来越少，JavaConfig形式使用的越来越多，类似于: @Configuration public class AppCo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/9576466.html</dc:identifier>
</item>
<item>
<title>Python从菜鸟到高手（5）：数字 - 银河使者</title>
<link>http://www.cnblogs.com/nokiaguy/p/9581449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nokiaguy/p/9581449.html</guid>
<description>&lt;h3 id=&quot;基础知识&quot;&gt;1 基础知识&lt;/h3&gt;
&lt;p&gt;  Python语言与其他编程语言一样，也支持四则运算（加、减、乘、除），以及圆括号运算符。在Python语言中，数字分为整数和浮点数。整数就是无小数部分的数，浮点数就是有小数部分的数。例如，下面的代码是标准的四则运算表达式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2 + 4
4 * 5 + 20
5.3 / 7
(30 + 2) * 12
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  如果要计算两个数的除法，不管分子和分母是整数还是浮点数，使用除法运算符（/）的计算结果都是浮点数。例如1/2的计算结果是0.5，2/2的计算结果是1.0。要想让Python解释器执行整除操作，可以使用整除运算符，也就是两个斜杠（//）。使用整除运算符后，1 // 2的计算结果是0，2 // 2的结果是1。&lt;/p&gt;
&lt;p&gt;  整除运算符不仅能对整数执行整除操作，也能对浮点数执行整除操作，在执行整除操作时，分子分母只要有一个是浮点数，那么计算结果就是浮点数。例如，1.0 // 2的计算结果是0.0，2.0 // 2的结果是1.0。&lt;/p&gt;
&lt;p&gt;  除了四则运算符外，Python还提供了两个特殊的运算符：%（取余运算符）和**（幂运算符）。取余运算符用于对整数和浮点数执行取余操作。例如，5 % 2的计算结果是1，而5.0 % 2的计算结果是1.0。从这一点可以看出，%和//类似，只要分子分母有一个是浮点数，计算结果就是浮点数。&lt;/p&gt;
&lt;p&gt;  幂运算符用于计算一个数值的幂次方。例如，2 ** 3的计算结果是8，3.2 ** 2的计算结果是10.24。&lt;/p&gt;
&lt;p&gt;  到现在为止，一共介绍了8个运算符，它们是圆括号（(…)）加（+）、减（-）、乘（*）、除（/）、整除（//）、取余（%）和幂运算符（**）。其中减号（-）也可以用于负号（一元运算符），所以现在涉及到9个运算符。既然涉及到这么多运算符，那么就有一个优先级的问题，也就是说，同一个表达式中包含有多个不同的运算符，需要先计算优先级高的运算符，如果优先级相同个，那么就按从左向右的顺序执行。&lt;/p&gt;
&lt;p&gt;  这9个运算符的优先级顺序如下图所示。越靠前优先级越高，同一行的运算符的优先级相同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://geekori.com/images/editorUpload/18-08/uploadImg_195401533740560.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  下面的代码演示了Python语言中运算符的使用方法，在编写Python代码时，应该注意运算符的优先级问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(2 + 4)                        #  运算结果：6
print(126 - 654)                    #  运算结果：-528
print(6 + 20 * 4)                   #  运算结果：86
print((20 + 54) * 30)               #  运算结果：2220
print(1/2)                          #  运算结果：0.5
print(1//2)                     #  运算结果：0
print(3/2)                          #  运算结果：1.5
print(3//2)                     #  运算结果：1
print(4**3)                     #  运算结果：64
print(3 + 5 * -3 ** 4 - (-5)**2)    #  运算结果：-427
#  用变量操作数值
x = 30
y = 50
k = 10.2
print(x + y * k)                    #  运算结果：540.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;大整数&quot;&gt;2 大整数&lt;/h3&gt;
&lt;p&gt;  对于有符号32位整数来说，可表示的最大值是2147483647（2^31 -1），可表示的最小值是-2147483648（-2^31），如果超过这个范围，有符号32位整数就会溢出。不过在Python语言中，可以处理非常大的整数，并不受位数限制。例如，下面表达式的输出结果就超出了32位整数的范围。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(2 ** 35)      # 输出2的35次幂，输出结果是34359738368&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  让我们再换个更大的数，看看会不会溢出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(2**630  * 100000)     # 2的630次幂再乘10万&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  上面这行代码的输出结果如下：&lt;/p&gt;
&lt;p&gt;445550841564667501820426914619169074696604346410992180720624269326101090547722401025968047980212050759633038044296328838934443820446820117016861457004122479321483854917994624031530682836582400000&lt;/p&gt;
&lt;p&gt;  很显然，Python语言仍然可以正确处理2**630 * 100000的计算结果。因此，在Python语言中使用数字不需要担心溢出，因为Python语言可以处理非常大的数字，这也是为什么很多人使用Python语言进行科学计算和数据分析的主要原因之一。&lt;/p&gt;
&lt;h3 id=&quot;二进制八进制和十六进制&quot;&gt;3. 二进制、八进制和十六进制&lt;/h3&gt;
&lt;p&gt;  Python语言可以表示二进制、八进制和十六进制数。表示这3个进制的数，必须以0开头，然后分别跟着表示不同进制的字母。表示二进制的字母是b，表示八进制的字母是o（这是英文字母中小写的o，不要和数字0搞混了），表示十六进制的字母是x。因此，二进制数的正确写法是0b110011，八进制数的正确写法是0o56432，十六进制数的正确写法是0xF765A。&lt;/p&gt;
&lt;p&gt;  除了这3种进制外，前面章节一直使用的是十进制。因此，Python语言一共可以表示4种进制：二进制、八进制、十进制和十六进制。Python语言提供了一些函数用于在这4种进制数之间进行转换。&lt;/p&gt;
&lt;p&gt;  如果是从其他进制转换到十进制，需要使用int函数，该函数有两个参数，含义如下：&lt;/p&gt;
&lt;p&gt;• 第1个参数：字符串类型，表示待转换的二进制、八进制或十六进制数。参数值只需要指定带转换的数即可，不需要使用前缀，如二进制直接指定11011，不需要指定0b11011。&lt;/p&gt;
&lt;p&gt;• 第2个参数：数值类型，表示第1个参数值的进制，例如，如果要将二进制转换为十进制，第2个参数值就是2。&lt;/p&gt;
&lt;p&gt;  int函数返回一个数值类型，表示转换后的十进制数。&lt;/p&gt;
&lt;p&gt;  下面的代码将二进制数110011转换为十进制数，并输出返回结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(int(&quot;110011&quot;,2))    // 输出结果：51&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  如果要从十进制转换到其他进制，需要分别使用bin、oct和hex函数。bin函数用于将十进制数转换为二进制数；oct函数用于将十进制数转换为八进制数，hex函数用于将十进制数转换十六进制数。这3个函数都接收一个参数，就是待转换的十进制数。不过要注意，这3个函数的参数值也可以是二进制数、八进制数和十六进制数，也就是说，这3个函数可以在二进制、八进制、十进制和十六进制之间互转。&lt;/p&gt;
&lt;p&gt;  下面的代码将十进制数54321转换为十六进制数，并输出转换结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(hex(54321))       # 输出结果：0xd431&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的代码演示了Python语言中二进制、八进制、十进制和十六进制数之间的转换。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(0b110011)             # 输出二进制数
print(0o123)                    # 输出八进制数
print(0xF15)                    # 输出十六进制数
print(bin(12))                  # 十进制转二进制，输出结果：0b1100
print(int(&quot;10110&quot;,2))           # 二进制转十进制，输出结果：22
print(int(&quot;0xF35AE&quot;,16))        # 十六进制转十进制，输出结果：996782
print(hex(54321))               # 十进制转十六进制，输出结果：0xd431
print(bin(0xF012E))         # 十六进制转二进制，输出结果：0b11110000000100101110
print(hex(0b1101101))           # 二进制转十六进制，输出结果：0x6d
print(oct(1234))                # 十进制转八进制，输出结果：0o2322
print(int(&quot;76532&quot;, 8))          # 八进制转十进制，输出结果：32090
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://geekori.com/images/editorUpload/18-08/uploadImg_111721533772757.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://product.dangdang.com/25333314.html&quot;&gt;《Python从菜鸟到高手》开始转载了，敬请关注&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://product.dangdang.com/25333314.html&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13614258-818574e26abb8a4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;数字的格式化输出&quot;&gt;4 数字的格式化输出&lt;/h3&gt;
&lt;p&gt;  在输出数字时，有时需要对其进行格式化。例如，在输出12.34时，只希望保留小数点后1位数字，也就是12.3，或整数位按6位输出，不足前面补0，也就是000012.34。Python语言中提供了format函数用于对数字进行格式化。format函数有两个参数，含义如下：&lt;/p&gt;
&lt;p&gt;• 第1个参数：要格式化的数字。&lt;/p&gt;
&lt;p&gt;• 第2个参数：格式字符串。&lt;/p&gt;
&lt;p&gt;  format函数的返回值就是数字格式化后的字符串。&lt;/p&gt;
&lt;p&gt;  下面的代码演示了format函数在格式化数字方面的应用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x = 1234.56789
# 小数点后保留两位数，输出结果：'1234.57'
print(format(x, '0.2f'))      
# 数字在12个字符长度的区域内右对齐，并保留小数点后1位数字，
# 输出结果：'      1234.6'      
print(format(x, '&amp;gt;12.1f'))          
# 数字在12个字符长度的区域内左对齐，并保留小数点后3位数字，紧接着输出20，
# 输出结果：'1234.568     20'
print(format(x, '&amp;lt;12.3f'), 20)
# 数字在12个字符长度的区域内右对齐，并保留小数点后1位数字，数字前面补0，
# 输出结果：'0000001234.6'
print(format(x, '0&amp;gt;12.1f'))
# 数字在12个字符长度的区域内左对齐，并保留小数点后1位数字，数字后面补0，
# 输出结果：'1234.6000000'
print(format(x, '0&amp;lt;12.1f'))
# 数字在12个字符长度的区域内中心对齐，并保留小数点后2位数字，紧接着输出3，
# 输出结果：'   1234.57   3'
print(format(x, '^12.2f'),3)
# 每千位用逗号（,）分隔，输出结果：1,234.56789
print(format(x, ','))
# 每千位用逗号（,）分隔，并保留小数点后2位数字，输出结果：1,234.57
print(format(x, ',.2f'))
# 用科学计数法形式输出数字，输出结果：1.234568e+03
print(format(x, 'e'))
# 用科学计数法形式输出数字，尾数保留小数点后2位数字，输出结果：1.23E+03
print(format(x, '0.2E'))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://geekori.com/images/editorUpload/18-08/uploadImg_429321533772953.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.51cto.com/androidguy/2165688&quot;&gt;《Python从菜鸟到高手》已经出版，开始连载了，购买送视频课程&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Sep 2018 14:06:00 +0000</pubDate>
<dc:creator>银河使者</dc:creator>
<og:description>Python语言与其他编程语言一样，也支持四则运算（加、减、乘、除），以及圆括号运算符。在Python语言中，数字分为整数和浮点数。整数就是无小数部分的数，浮点数就是有小数部分的数。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nokiaguy/p/9581449.html</dc:identifier>
</item>
<item>
<title>静态代理和动态代理 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9581294.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9581294.html</guid>
<description>&lt;h2 id=&quot;代理模式静态代理&quot;&gt;代理模式（静态代理）&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;代理模式是为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义上也不算好理解， 上一个 《大话设计模式》 的图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180903215339515?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;代理模式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Subject 类（一般是抽象类或接口）， 定义了一个方法。&lt;/p&gt;
&lt;p&gt;RealSubject 类实现了这个接口， 正常的情况我们只需要 new 出这个类的实例对象， 然后调用这个方法就可以了。&lt;/p&gt;
&lt;p&gt;但是， 如果我们有需求说想要在这个方法的前面和后面进行一些操作， 那么，原始的方法已经无法满足了。&lt;/p&gt;
&lt;p&gt;以租房子打比方：&lt;/p&gt;
&lt;p&gt;房东李老板有一套房子， 他打算出租， 但是带人看了几次房子以后， 发现自己没有那么多时间。 于是他把房子委托给了中介公司小王， 小王帮他带人看房子，然后收取中介费。&lt;/p&gt;
&lt;p&gt;在该例子中， 房子是李老板的， 他（RealSubject）将租房子这个权限委托给了小王（Proxy）。&lt;/p&gt;
&lt;h3 id=&quot;抽象&quot;&gt;抽象&lt;/h3&gt;
&lt;p&gt;首先， 抽象出房东这个接口， 而李老板是它的具体实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Landlord {
    boolean rental();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;具体对象&quot;&gt;具体对象&lt;/h3&gt;
&lt;p&gt;房东是一个抽象意义上的概念， 而李老板， 是一个具有意义上的房东， 我们称之为是房东的一个实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LandlordImpl implements Landlord {

    public boolean rental() {
        System.out.println(&quot;李老板的房子出租啦&quot;);
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代理对象&quot;&gt;代理对象&lt;/h3&gt;
&lt;p&gt;代理代表真实对象的功能以及在此基础上添加访问控制。&lt;/p&gt;
&lt;p&gt;那就是中介小王， 他获得了李老板的授权， 可以带人去看房子， 但李老板明确了自己的条件， 房租至少5000， 如果是美女可以考虑降一点（小王就代表李老板进行一些过滤（访问控制））。&lt;/p&gt;
&lt;p&gt;如果租客满意了， 打算租房子就跟小王说。 小王当然想租客租给租客， 有佣金嘛。但是， 具体的房子租不租还是要看房东。&lt;/p&gt;
&lt;p&gt;我们就可以定义中介小王是房东的代理对象。他代表租房子以及访问控制。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LandlordProxy implements Landlord{
    private final Landlord landlord;

    public LandlordProxy(Landlord landlord) {
        this.landlord = landlord;
    }

    public boolean rental() {
        beforeRental();
        if (landlord.rental()) {
            afterRental();
        }
        return false;
    }

    private void afterRental() {
        System.out.println(&quot;收取佣金&quot;);
    }

    private void beforeRental() {
        System.out.println(&quot;带人看房子&quot;);
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果有一天， 李老板觉得一天最多接受 5 次看房。&lt;/p&gt;
&lt;p&gt;那显然， 这是需要在小王那进行控制的。那么我们的类就可以这么改&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LandlordProxy implements Landlord{
    private final Landlord landlord;

    private static final int NUM_ALLOWED = 5;

    private int numPersons = 1;

    public LandlordProxy(Landlord landlord) {
        this.landlord = landlord;
    }

    public boolean rental() {
        if (numPersons &amp;lt; NUM_ALLOWED) {
            System.out.println(&quot;今天李老板不接客了&quot;);
        } else {
            beforeRental();
            numPersons++;
            if (landlord.rental()) {
                afterRental();
            }
        }

        return false;
    }

    private void afterRental() {
        System.out.println(&quot;收取佣金&quot;);
    }

    private void beforeRental() {
        System.out.println(&quot;带人看房子&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代理对象的特征是&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;和被代理对象实现了同一个接口；&lt;/li&gt;
&lt;li&gt;内部含有一个被代理对象的示例；&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;真实对象可以专注于自己的业务逻辑控制；&lt;/li&gt;
&lt;li&gt;非业务逻辑相关的部分， 可以通过代理类来处理；&lt;/li&gt;
&lt;li&gt;隐藏了真实的对象， 对外只暴露代理对象。&lt;/li&gt;
&lt;li&gt;扩展性：由于实现了相同的接口， 因此被代理对象的逻辑不管如何变化， 代理对象都不需要更改。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;使用场合&quot;&gt;使用场合&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;控制对真实对象的访问；&lt;/li&gt;
&lt;li&gt;实现日志记录；&lt;/li&gt;
&lt;li&gt;统计对象的访问数量；&lt;/li&gt;
&lt;li&gt;等等。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;一些思考&quot;&gt;一些思考&lt;/h3&gt;
&lt;p&gt;在代理对象内部， 真实对象是什么时候被初始化的， 以及初始化的对象是由谁产生的？&lt;/p&gt;
&lt;p&gt;在我看过的代码和书籍中， 有如下几种， 对此我也是很困惑， 以下是我的一些见解&lt;/p&gt;
&lt;h4 id=&quot;不推荐&quot;&gt;不推荐&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;将真实对象在代理对象构造函数内部初始化出来。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public LandlordProxy() {
    landlord = new LandlordImpl();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;构造函数不做改变， 在使用方法时&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public boolean rental() {
    if(landlord==null){
        landlord = new LandlordImpl(); 
    }
    if (numPersons &amp;lt; NUM_ALLOWED) {
        System.out.println(&quot;今天李老板不接客了&quot;);
    } else {
        beforeRental();
        numPersons++;
        if (landlord.rental()) {
            afterRental();
        }
    }

    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上两种的思想都是在代理对象内部对真实对象进行初始化， 我个人不是很赞同这种做法。&lt;/p&gt;
&lt;p&gt;如果我们代理对象代理的不仅仅是李老板， 又代理了王老板， 那么怎么办？要写两个基本一模一样的代理类？&lt;/p&gt;
&lt;h4 id=&quot;推荐做法&quot;&gt;推荐做法&lt;/h4&gt;
&lt;p&gt;就是我们使用的， 在构造函数中传入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public LandlordProxy(Landlord landlord) {
        this.landlord = landlord;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将真实对象的初始化交给调用者来进行。&lt;/p&gt;
&lt;p&gt;这样， 不管是什么老板， 他们可以自己管理自己的租房方法， 但是相同的工作由代理来做， 而只需要一个代理类。实现了代码的复用。&lt;/p&gt;
&lt;h2 id=&quot;动态代理&quot;&gt;动态代理&lt;/h2&gt;
&lt;p&gt;如果是一两个方法需要进行代理， 我们使用静态代理那挺好。&lt;/p&gt;
&lt;p&gt;但如果我们的接口中有 20 个方法， 每个方法都需要在前后加上前后的逻辑， 比如说记录一下日志。那么， 我们就一直需要做一些重复性的工作， 相同的代码需要写很多遍， 不单单是写的时候痛苦， 后面维护起来也很难受。&lt;/p&gt;
&lt;p&gt;基于此， 动态代理诞生了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在程序运行时运用反射机制动态创建代理类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Java 中， 实现动态代理很简单&lt;/p&gt;
&lt;h4 id=&quot;定义一个实现invocationhandler的类&quot;&gt;定义一个实现&lt;code&gt;InvocationHandler&lt;/code&gt;的类&lt;/h4&gt;
&lt;p&gt;如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DynamicProxy implements InvocationHandler {

    private Object target;

    public DynamicProxy(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(System.currentTimeMillis() + &quot; 进入了方法&quot;);
        // 中间是这个方法
        Object result = method.invoke(target, args);
        System.out.println(System.currentTimeMillis() + &quot; 方法执行完毕&quot;);
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;target&lt;/code&gt; 是我们需要代理的真实对象， 该参数一样建议在构造函数中传入。&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;invoke&lt;/code&gt; 方法，方法内部在前后实现我们需要的逻辑， 中间就是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object result = method.invoke(target, args);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后返回 &lt;code&gt;result&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h3 id=&quot;调用定义的类&quot;&gt;调用定义的类&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; public static void main(String[] args) {
    Landlord landlord = new LandloadImpl();
    DynamicProxy dynamicProxy = new DynamicProxy(landlord);
    // 这一步是关键
    Landlord landlordProxy = (Landlord) Proxy.newProxyInstance(
            landlord.getClass().getClassLoader(),
            landlord.getClass().getInterfaces(),
            dynamicProxy
    );
    landlordProxy.rental();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实我们就是要使用 JDK 给我们提供的 &lt;code&gt;newProxyInstance&lt;/code&gt; 函数， 该函数返回对应代理的对象的接口， 我们调用相应的方法即可。&lt;/p&gt;
&lt;h3 id=&quot;优化&quot;&gt;优化&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;newProxyInstance&lt;/code&gt; 方法需要传入的参数可以进一步进行优化。&lt;/p&gt;
&lt;p&gt;我们在 &lt;code&gt;DynamicProxy&lt;/code&gt;方法中， 可以加入该函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)
public &amp;lt;T&amp;gt; T getProxy() {
    return (T)Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            this
    );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在我们获得代理对象时候就简单很多，&lt;code&gt;main&lt;/code&gt; 函数可以改写成这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    Landlord landlord = new LandloadImpl();
    DynamicProxy dynamicProxy = new DynamicProxy(landlord);
    Landlord landlordProxy = dynamicProxy.getProxy();
    landlordProxy.rental();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态代理为我们带来了方便， 但是呢， JDK 所提供的动态代理， 我们通过 newProxyInstance 函数可以知道， &lt;strong&gt;被代理的对象必须要实现某个接口&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果我们要代理的对象没有接口怎么办？&lt;/p&gt;
&lt;p&gt;后续文章打算讲一下 CGLIB 和 Sping Aop 是怎么为我们打开一个新的世界的。&lt;/p&gt;
&lt;h2 id=&quot;代理之故事的结局&quot;&gt;代理之故事的结局&lt;/h2&gt;
&lt;p&gt;最后中介小王和李老板的故事结局是怎么样的呢？&lt;/p&gt;
&lt;p&gt;程序员小H租了房子， 李老板和小王按规定各付中介费1750， 最后小王、李老板和小H商量了一下， 不走公司的流程， 各付1000元就好了。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Sep 2018 13:58:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>代理模式（静态代理） 代理模式是为其他对象提供一种代理以控制对这个对象的访问。 定义上也不算好理解， 上一个 《大话设计模式》 的图。 Subject 类（一般是抽象类或接口）， 定义了一个方法。 R</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9581294.html</dc:identifier>
</item>
<item>
<title>.NetCore实践爬虫系统（一）解析网页内容 - 从此启程</title>
<link>http://www.cnblogs.com/fancunwei/p/9581168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9581168.html</guid>
<description>&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;58&quot;&gt;
&lt;h3 data-source-line=&quot;1&quot; id=&quot;爬虫系统的意义&quot;&gt;爬虫系统的意义&lt;/h3&gt;

&lt;p data-source-line=&quot;2&quot;&gt;爬虫的意义在于采集大批量数据，然后基于此进行加工/分析，做更有意义的事情。谷歌，百度，今日头条，天眼查都离不开爬虫。&lt;/p&gt;
&lt;/div&gt;&lt;p data-source-line=&quot;4&quot;&gt;今天我们来实践一个最简单的爬虫系统。根据Url来识别网页内容。&lt;/p&gt;</description>
<pubDate>Mon, 03 Sep 2018 13:32:00 +0000</pubDate>
<dc:creator>从此启程</dc:creator>
<og:description>爬虫系统的意义 爬虫的意义在于采集大批量数据，然后基于此进行加工/分析，做更有意义的事情。谷歌，百度，今日头条，天眼查都离不开爬虫。 爬虫的意义在于采集大批量数据，然后基于此进行加工/分析，做更有意义</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9581168.html</dc:identifier>
</item>
<item>
<title>springMVC 学习笔记（一）：spring 入门 - 希希里之海</title>
<link>http://www.cnblogs.com/weixuqin/p/9581119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weixuqin/p/9581119.html</guid>
<description>&lt;h2 id=&quot;springmvc-学习笔记一spring-入门&quot;&gt;springMVC 学习笔记（一）：spring 入门&lt;/h2&gt;
&lt;h3 id=&quot;什么是-springmvc&quot;&gt;什么是 springMVC&lt;/h3&gt;
&lt;p&gt;springMVC 是 spring 框架的一个模块，springMVC 和 spring 无需通过中间整合层进行整合。springMVC 是一个基于 mvc 的 web 框架。&lt;/p&gt;
&lt;p&gt;在 spring 中如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx2.sinaimg.cn/mw690/007el5a4gy1fuv8kb40moj30oa0hx429.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;springmvc-组件及工作流程&quot;&gt;springMVC 组件及工作流程&lt;/h3&gt;
&lt;h5 id=&quot;组件&quot;&gt;组件&lt;/h5&gt;
&lt;p&gt;springMVC 的主要组件大致有以下这些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前端控制器 DispatcherServlet: 接收请求，响应结果，相当于转发器。该组件能减少其他组件之间的耦合度。&lt;/li&gt;
&lt;li&gt;处理器映射器 HandlerMapping：根据请求的 url 查找 Handler。&lt;/li&gt;
&lt;li&gt;处理器适配器 HandlerAdapter: 按照特定规则去执行 Handler。&lt;/li&gt;
&lt;li&gt;处理器 Handler：指定要执行的程序。&lt;/li&gt;
&lt;li&gt;视图解析器 View resolver：进行视图解析，根据视图名解析成真正的视图。&lt;/li&gt;
&lt;li&gt;视图 View：View 是一个接口，实现类支持不同的 View 类型。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;工作流程图&quot;&gt;工作流程图&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/mw690/007el5a4gy1fuv8sp9bv4j30nw0badgy.jpg&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;工作流程&quot;&gt;工作流程&lt;/h5&gt;
&lt;p&gt;1 发起请求到前端控制器 DispatcherServlet；&lt;/p&gt;
&lt;p&gt;2 前端控制器请求 HandlerMapping 查找 Handler ,可以根据 xml 配置，注解进行查找；&lt;/p&gt;
&lt;p&gt;3 处理器映射器 HandlerMapping 向前端控制器返回 Handler；&lt;/p&gt;
&lt;p&gt;4 前端控制器调用处理器适配器去执行 Handler；&lt;/p&gt;
&lt;p&gt;5 处理器适配器去执行 Handler；&lt;/p&gt;
&lt;p&gt;6 Handler 执行完成给适配器返回 ModelAndView，其中 ModelAndView 是 springMVC 框架的一个底层对象，包括 Model 和 view；&lt;/p&gt;
&lt;p&gt;7 处理器适配器向前端控制器返回 ModelAndView；&lt;/p&gt;
&lt;p&gt;8 前端控制器去请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(jsp)；&lt;/p&gt;
&lt;p&gt;9 视图解析器向前端控制器返回 View；&lt;/p&gt;
&lt;p&gt;10 前端控制器进行视图渲染，视图渲染将模型数据（在 ModelAndView对象中）填充到 request 域；&lt;/p&gt;
&lt;p&gt;11 前端控制器向用户响应结果。&lt;/p&gt;
&lt;p&gt;简单来说，就是遵循 MVC软件架构模式。&lt;/p&gt;
&lt;h3 id=&quot;入门程序&quot;&gt;入门程序&lt;/h3&gt;
&lt;p&gt;举个栗子，编写个程序来实现 springMVC 的功能。&lt;/p&gt;
&lt;p&gt;在这里我们还是在 IntellJ IDEA 中使用 maven 来快速搭建开发环境。&lt;/p&gt;
&lt;p&gt;打开 idea，创建新项目，选择 maven，勾选 create from archetype，选中 webapp选框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/mw690/007el5a4gy1fuv9krq8akj30rb0fvgq0.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一路选择后， maven便帮我们自动生成了一个简单的 web 文件夹，但这个并不是 maven 标准结构，我们选择 File -&amp;gt; Project Structure -&amp;gt; Modules，修改文件结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/mw690/007el5a4gy1fuv9sblwqjj30uc0jmdid.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改 pom.xml，添加 springMVC 及相关的依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;dependencies&amp;gt;

    &amp;lt;!-- springmvc 框架 --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${org.springframework-version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- jsp操作 --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- servlet支持 --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- standard包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.taglibs&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;taglibs-standard-impl&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2.5&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

  &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置前端控制器，修改 web.xml：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&amp;gt;

  &amp;lt;!-- springmvc 前端控制器 --&amp;gt;
  &amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;!-- contextConfigLocation 配置 springMVC 加载的配置文件（配置处理器映射器,适配器等等）
     若不配置,默认加载 WEB-INF/servlet 名称-servlet(springmvc-servlet.xml)
     --&amp;gt;
    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;WEB-INF/springmvc-servlet.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
  &amp;lt;/servlet&amp;gt;

  &amp;lt;!-- 拦截请求 --&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;*.action&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建映射文件 springmvc-servlet.xml , 配置 Handler, 处理器映射器，处理器适配器，视图解析器等：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/mvc
       http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;
    &amp;lt;!-- 配置Handler --&amp;gt;
    &amp;lt;bean name=&quot;/queryItems.action&quot; class=&quot;cn.itcast.ssm.controller.ItemsController&quot;/&amp;gt;

    &amp;lt;!-- 处理器映射器 将 bean 的 name 作为 url 进行查找,需要在配置 Handler 时指定 beanname（就是 url） --&amp;gt;
    &amp;lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&amp;gt;

    &amp;lt;!-- 处理器适配器 所有处理器适配器都实现了HandlerAdapter 接口 --&amp;gt;
    &amp;lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&amp;gt;

    &amp;lt;!-- 视图解析器 解析 jsp 解析,默认使用 jstl 标签,classpath 下要有jstl 的包 --&amp;gt;
    &amp;lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后创建 pojo 类 Items.java 和 controller 类 ItemsController.java，这里我们没有连接数据库，作为演示，直接在 pojo 类中填充静态数据即可：&lt;/p&gt;
&lt;p&gt;Items.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.itcast.ssm.po;

import java.util.Date;

public class Items {
    private Integer id;

    private String name;

    private Float price;

    private String pic;

    private Date createtime;

    private String detail;
    
    //getter 和 setter 方法...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ItemsController.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.itcast.ssm.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import cn.itcast.ssm.po.Items;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import java.util.ArrayList;
import java.util.List;

// 实现 controller 接口的处理器
public class ItemsController implements Controller {

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        //调用 service 查找数据库,查询商品列表,这里使用静态数据模拟
        List&amp;lt;Items&amp;gt; itemsList = new ArrayList&amp;lt;Items&amp;gt;();

        //向 list中填充静态数据
        Items items_1 = new Items();
        items_1.setName(&quot;联想笔记本&quot;);
        items_1.setPrice(6000f);
        items_1.setDetail(&quot;ThinkPad T439 联想笔记本电脑!&quot;);

        Items items_2 = new Items();
        items_2.setName(&quot;苹果手机&quot;);
        items_2.setPrice(5000f);
        items_2.setDetail(&quot;iphone6苹果手机!&quot;);

        itemsList.add(items_1);
        itemsList.add(items_2);

        //返回 ModelAndView
        ModelAndView modelAndView = new ModelAndView();
        //相当与 request 的 setAttribute 方法, 在 jsp 页面中通过 itemsList 取数据
        modelAndView.addObject(&quot;itemsList&quot; ,itemsList);

        //指定视图
        modelAndView.setViewName(&quot;WEB-INF/jsp/items/itemsList.jsp&quot;);

        return modelAndView;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建 jsp 文件，设计页面布局：&lt;/p&gt;
&lt;p&gt;itemsList.jsp：&lt;/p&gt;
&lt;pre class=&quot;jsp&quot;&gt;
&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&amp;gt;
&amp;lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&amp;gt;
&amp;lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&quot;fmt&quot;%&amp;gt;
&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
&amp;lt;title&amp;gt;查询商品列表&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt; 
&amp;lt;form action=&quot;${pageContext.request.contextPath }/item/queryItem.action&quot; method=&quot;post&quot;&amp;gt;
查询条件：
&amp;lt;table width=&quot;100%&quot; border=1&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;input type=&quot;submit&quot; value=&quot;查询&quot;/&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
商品列表：
&amp;lt;table width=&quot;100%&quot; border=1&amp;gt;
&amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;商品名称&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;商品价格&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;生产日期&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;商品描述&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;操作&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;c:forEach items=&quot;${itemsList }&quot; var=&quot;item&quot;&amp;gt;
&amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;${item.name }&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;${item.price }&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;${item.detail }&amp;lt;/td&amp;gt;
    
    &amp;lt;td&amp;gt;&amp;lt;a href=&quot;${pageContext.request.contextPath }/item/editItem.action?id=${item.id}&quot;&amp;gt;修改&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;

&amp;lt;/tr&amp;gt;
&amp;lt;/c:forEach&amp;gt;

&amp;lt;/table&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件目录结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/mw690/007el5a4gy1fuwm9yq5jmj308m0cnmxz.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的代码到这里便写完了，接下来我们来配置 Tomcat，部署Tomcat 发布我们的网页。&lt;/p&gt;
&lt;p&gt;点击 Run -&amp;gt; Edit Configurations , 打开控制面板后，点击右上角的 + ，添加 Tomcat。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/mw690/007el5a4ly1fuwmm8ml0mj30f40eddi6.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加好 Tomcat 后，点击 Configure，添加下载解压好的 Tomcat 文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/mw690/007el5a4gy1fuwmiwmmytj30th0ilq5f.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击控制面板的 Deployment 选项，添加后缀为exploded 的 Artifact 文件，并按下图所示，设置 On 'update' action 和 On frame deactivation 为 Update classes and resources 热部署方式，这样修改代码后，就不需要重新启动 Tomcat 便能加载修改后的页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/mw690/007el5a4ly1fuwnhslmyfj30tf0ilmzx.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们启动 Tomcat，打开浏览器，输入相应的网址，便能看到我们的 springMVC 程序了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/mw690/007el5a4ly1fuwnlc6gj9j30zk06bmyj.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，一个完整的 springMVC 程序便被我们实现出来了。&lt;/p&gt;
&lt;h3 id=&quot;springmvc-的坑&quot;&gt;springMVC 的坑&lt;/h3&gt;
&lt;p&gt;最后再讲一下我编写这个入门程序遇到的坑（捂脸）。&lt;/p&gt;
&lt;p&gt;1 最好使用 Tomcat8.0以上版本，如果使用7.0版本，javax.servlet-api 需要3.0版本及以下，同时还需修改 web.xml 中的声明：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;web-app version=&quot;3.1&quot; 改为 web-app version=&quot;3.0&quot;&lt;/p&gt;
&lt;p&gt;web-app_3_1.xsd 改为 web-app_3_0.xsd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2 使用的 jstl 的 jar 包，如果使用 maven 导入，注意使用：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个源，别使用 &lt;code&gt;javax.servlet.jsp.jstl&lt;/code&gt; 中的，不然会报以下错误：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;java.lang.NoClassDefFoundError: javax/servlet/jsp/jstl/core/LoopTag&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 03 Sep 2018 13:22:00 +0000</pubDate>
<dc:creator>希希里之海</dc:creator>
<og:description>springMVC 学习笔记（一）：spring 入门 什么是 springMVC springMVC 是 spring 框架的一个模块，springMVC 和 spring 无需通过中间整合层进行整</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weixuqin/p/9581119.html</dc:identifier>
</item>
</channel>
</rss>