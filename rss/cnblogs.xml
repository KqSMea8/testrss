<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>HashMap实现原理 - 大大控</title>
<link>http://www.cnblogs.com/huangbw/p/7658959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangbw/p/7658959.html</guid>
<description>&lt;p&gt;学习笔记之HashMap篇，简单学习了解HashMap的实现原理和扩容。&lt;/p&gt;
&lt;p&gt;大家都知道HashMap处理数据很快，时间复杂度O(1)，那么是怎么做到的呢？那就先了解一下常见数据结构。&lt;/p&gt;
&lt;p&gt;一般来说，我们把存储结构分为两种个，顺序存储结构和链式存储结构，那我们就以最常见的两种，数组和链表为例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组采用的一段连续的存储单元来存储数据，我们可以通过数组的下表来进行查找数据，时间复杂度为O(1)，如果通过给定的值来查找需要遍历数组，所以时间复杂度为O(n)，当然在有序的情况下我们可以加速这个对比过程，通过二分查找可以实现时间复杂度O(logn)，插入删除元素的话需要一个一个处理元素位置，所以也是O(n)级别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链表的话存储数据不需要连续的存储单元，只需要在当前数据中存储下一个来实现链表，这样我们无法像数组那样通过下表查找，在查找数据时只能一个一个往后找，所以时间复杂度为O(n)，但是链表的优势就在于插入删除操作只需要处理一下结点的引用就可以了，所以时间复杂度O(1)。&lt;/p&gt;

&lt;p&gt;既然数组和链表各有优势，那我们能不能结合他们的优势呢？哈希表应运而生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哈希表简单介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面说到了数组可以通过下标查找数据，时间复杂度O(1)，哈希表就利用这个优势，所以哈希表的主干就是一个数组，那么问题来了，我知道下标才能快速取啊，然而我现在只有值，怎么通过存储元素的值来确定他的下标呢？这里，我们就要通过哈希函数来把这个元素值映射到对应的下标，至于这个函数，我们就不详细介绍了，简单来说就是取这个元素值的哈希值来做模运算从而获得下表位置，通过这个位置来实现快速读取。说到了哈希函数，这个函数的设计尤为关键，直接影响到性能，因为这个函数设计的不好，可能导致很多数存储在了同一个下标下。那么看到这又该发现问题了，一个下标下怎么存储很多元素呢？这便是哈希冲突的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哈希冲突&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如上面所讲，哈希冲突就是我们在通过哈希函数来计算下标的时候出现了重复，当一个元素要存进去的时候发现里面已经被占了，这便是哈希冲突，也被叫做哈希碰撞。我们前面也说过了，数组需要连续的存储单元来存储数据，所以再好的哈希函数的设计也不可能做到不出现哈希冲突，所以就出现了几种解决哈希冲突的方法：开放定址法，在散列函数法，还有链地址法。&lt;/p&gt;
&lt;p&gt;我们的HashMap使用的就是链地址法，也就是主干为一个数组，而在每个位置上存放的又是一个链表，这实际上就是一个链表散列的数据结构。这也就是前面我说哈希函数设计的好坏直接影响性能的一个原因，哈希函数的设计原则是要做到计算简单和散列地址分布均匀，分布不均匀导致的结果就是一个位置上出现一个很长的链表，我们找到这个位置再去寻找数据的时候有需要遍历链表上的数据来寻找，这就导致了读取数据的性能下降。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashMap的实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们一起看一点源码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;extends&lt;/span&gt; AbstractMap&amp;lt;K,V&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先来看定义，HashMap类继承了AbstractMap类，实现了Map，Cloneable和Serializable接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * The default initial capacity - MUST be a power of two.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; aka 16&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * The maximum capacity, used if a higher value is implicitly specified
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * by either of the constructors with arguments.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * MUST be a power of two &amp;lt;= 1&amp;lt;&amp;lt;30.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * The load factor used when none specified in constructor.
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = 0.75f;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里看定义的几个常量，DEFAULT_INITIAL_CAPACITY是默认初始容量16，MAXIMUM_CAPACITY最大容量2的30次方，DEFAULT_LOAD_FACTOR默认加载因子0.75。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * The number of key-value mappings contained in this map.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * The next size value at which to resize (capacity * load factor).
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@serial&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If table == EMPTY_TABLE then this is the initial capacity at which the
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; table will be created when inflated.&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * The load factor for the hash table.
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@serial&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * The number of times this HashMap has been structurally modified
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * Structural modifications are those that change the number of mappings in
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * the HashMap or otherwise modify its internal structure (e.g.,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * rehash).  This field is used to make iterators on Collection-views of
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * the HashMap fail-fast.  (See ConcurrentModificationException).
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; modCount;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看几个比较重要的变量：&lt;/p&gt;
&lt;p&gt;size是指当前哈希表中键值对的数量，源码中还有size()方法来返回了这个变量size。&lt;/p&gt;
&lt;p&gt;threshold在源码中的注释为The next size value at which to resize (capacity * load factor).如果我没理解错的话threshold是指下一个要进行扩容的值，通常是容量*加载因子。&lt;/p&gt;
&lt;p&gt;loadFactor就是哈希表的加载因子。&lt;/p&gt;
&lt;p&gt;modCount是用来快速失败的一个值，因为HashMap不是线程安全的，所以当多个线程导致了HashMap内部结构发生改变时，需要抛出异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        V value;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt;&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;         * Creates new entry.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         Entry(&lt;span&gt;int&lt;/span&gt; h, K k, V v, Entry&amp;lt;K,V&amp;gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             value =&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             next =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             key =&lt;span&gt; k;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             hash =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; K getKey() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; key;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; V getValue() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; V setValue(V newValue) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             V oldValue =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             value =&lt;span&gt; newValue;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object o) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry))
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             Map.Entry e =&lt;span&gt; (Map.Entry)o;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             Object k1 =&lt;span&gt; getKey();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             Object k2 =&lt;span&gt; e.getKey();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (k1 == k2 || (k1 != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; k1.equals(k2))) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 Object v1 =&lt;span&gt; getValue();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 Object v2 =&lt;span&gt; e.getValue();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (v1 == v2 || (v1 != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; v1.equals(v2)))
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Objects.hashCode(getKey()) ^&lt;span&gt; Objects.hashCode(getValue());
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; getKey() + &quot;=&quot; +&lt;span&gt; getValue();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;         * This method is invoked whenever the value in an entry is
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;         * overwritten by an invocation of put(k,v) for a key k that's already
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;         * in the HashMap.
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; recordAccess(HashMap&amp;lt;K,V&amp;gt;&lt;span&gt; m) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;         * This method is invoked whenever the entry is
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;         * removed from the table.
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; recordRemoval(HashMap&amp;lt;K,V&amp;gt;&lt;span&gt; m) {
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一部分代码很长，这是HashMap中的一个内部类Entry，前面我们也说到HashMap是数组加链表的结构，主干数组上每个位置就是Entry，Entry就是HashMap中的一个基本组成元素。&lt;/p&gt;
&lt;p&gt;这段源码中后面的类中的方法就不详细研究了，看一下2-5行定义的几个变量，首先是key和value，每个Entry中就是一个key-value键值对。&lt;/p&gt;
&lt;p&gt;第4行next，这个next存储就是指向下一个Entry的引用，就是通过这个next形成了一个单链表的结构，进而形成了主干数组上放链表的HashMap的结构。&lt;/p&gt;
&lt;p&gt;第5行hash，对key的hashcode值进行hash运算后得到。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一行代码就是HashMap的主干数组。&lt;/p&gt;
&lt;p&gt;下面看一下HashMap的存取&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashMap中的存取&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getForNullKey();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt; entry =&lt;span&gt; getEntry(key);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; == entry ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : entry.getValue();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; V getForNullKey() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (size == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e.key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先是get方法，当key等于null的时候，调用getForNullKey方法。那我们先来看getForNullKey方法，首先判断当前HashMap的当前元素数量，如果为0返回null，否则的话先定位到主干数组下标为0的位置，然后遍历Entry链表，一个一个找key为null的那一个，如果有，返回对应的value值，如果没有，返回null。&lt;/p&gt;
&lt;p&gt;那当key不是null的时候，调用了一个getEntry的方法，源码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; getEntry(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (size == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; hash = (key == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : hash(key);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[indexFor(hash, table.length)];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;              e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;              e =&lt;span&gt; e.next) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            Object k;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;12&lt;/span&gt;                 ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和上面的getForNullKey方法很相似，先看size是否为0，然后用hash方法得到hash，然后通过indexFor的方法传入hash和数组长度得到这个key所存储的下标位置，然后遍历Entry数组，寻找那个要找的key，返回这个Entry，如果没有则返回null。&lt;/p&gt;
&lt;p&gt;再回到上面代码，得到这个Entry以后再返回他的value。&lt;/p&gt;
&lt;p&gt;这其中一些细节是没有深入研究的，先明白大体过程，慢慢深入了解细节。&lt;/p&gt;
&lt;p&gt;下面看put方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (table ==&lt;span&gt; EMPTY_TABLE) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            inflateTable(threshold);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; putForNullKey(value);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            Object k;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || &lt;span&gt;key.equals(k))) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 e.recordAccess(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        addEntry(hash, key, value, i);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * Offloaded version of put for null keys
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; V putForNullKey(V value) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[0]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e.key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 e.recordAccess(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         addEntry(0, &lt;span&gt;null&lt;/span&gt;, value, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先判断数组是否{}空数组，如果是的话，进行数组填充为数组分配实际存储空间，如果要存储的键值对中key为null，调用putForNullKey方法，大体操作过程就是在下标为0的地方遍历该位置上的Entry链表，如果发现已经存在null这个key，那就覆盖掉以前的value，如果没有，那就创建一个新的Entry接在链表上。&lt;/p&gt;
&lt;p&gt;同样的，如果不为null进行的操作也基本类似，获得hash，通过hash和数组长度获取下标，定位到下标对应的Entry链表遍历对比，已经存在就覆盖，没有就创建新的接在后面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashMap的扩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先得知道什么时候扩容，就是当当前size达到阈值，也就是前面提到的threshold，容量*加载因子时，就要自动扩容了。&lt;/p&gt;
&lt;p&gt;这里要提到的就是resize，重新计算容量，当我们不停地向HashMap中添加元素时，HashMap内部数组无法装下更多元素，就需要扩大数组的长度来装更多的元素，当然，数组无法扩容，所以我们使用的方法就是用一个更大的数组来代替小的数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; resize(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newCapacity) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Entry[] oldTable =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; oldTable.length;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (oldCapacity ==&lt;span&gt; MAXIMUM_CAPACITY) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             threshold =&lt;span&gt; Integer.MAX_VALUE;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         Entry[] newTable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[newCapacity];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        transfer(newTable, initHashSeedAsNeeded(newCapacity));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         table =&lt;span&gt; newTable;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         threshold = (&lt;span&gt;int&lt;/span&gt;)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先上resize方法的源码，先引用扩容前的数组，得到长度，然后第4行的if，是判断扩容前的数组是否已经达到最大值MAXIMUM_CAPACITY，也就是2的30次方，如果已经到了，那就修改阈值为Integer.MAX_VALUE，也就是int的最大值2的31次方减1，这样以后就不在扩容了。如果还没达到最大值，那先new一个新的Entry数组，调用transfer方法将数据放入新数组，然后将HashMap中的table属性引用这个新数组，然后得到新的阈值。&lt;/p&gt;
&lt;p&gt;这里使用了transfer方法来拷贝，下面看一下这个方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; transfer(Entry[] newTable, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; rehash) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; newCapacity =&lt;span&gt; newTable.length;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt;&lt;span&gt; e : table) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; e) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 Entry&amp;lt;K,V&amp;gt; next =&lt;span&gt; e.next;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rehash) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     e.hash = &lt;span&gt;null&lt;/span&gt; == e.key ? 0&lt;span&gt; : hash(e.key);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(e.hash, newCapacity);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 e.next =&lt;span&gt; newTable[i];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 newTable[i] =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 e =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;transfer方法首先引用了旧的Entry数组，遍历这个旧数组，每循环一次，用Entry对象e获取到这个元素，并且将数组中该位置的Entry对象的引用释放，然后嵌套了一个do-while循环遍历链表，当前上的元素重新计算在新数组中对应的下标，断开与后一个之间的连接，指向目标位置（这样的结果就是发生哈希冲突时元素往同一个下标上位置放的时候会插入到链表头，先放的会放到尾部），然后将该元素放在数组上，e再指向next，直到把链表中的每个元素重新分配，然后外层循环继续循环到旧数组的下一个下标处。&lt;/p&gt;
&lt;p&gt;看起来很乱，通俗点讲就是俩循环遍历了数组上的每个链表上的每个元素，重新计算了他们在新数组的位置并且挪过去。这就是一个rehash再散列的过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这一篇就到这，大佬们的支持是我努力学习的动力，哪里有问题请多帮我指正。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 15:23:00 +0000</pubDate>
<dc:creator>大大控</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangbw/p/7658959.html</dc:identifier>
</item>
<item>
<title>Angular和Spring Boot一起做个项目 - 大明二代</title>
<link>http://www.cnblogs.com/xiao2/p/7663806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiao2/p/7663806.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;最近由于公司人员调整，我不得不去转去做前端，被迫用三周的时间学习Angular，同时需要做一个简单的Web聊天室。对于前端不一点感冒的我而言，其实还算一个不小的挑战。在三周的过程中，我遇到很多的困难，其中一个困难是如何将Aangular和我已会的Java体系相结合。我不太习惯前后端分离，还是希望可以能够将页面和Java代码写在一个项目里，算得上一个落伍的执着吧。&lt;/p&gt;
&lt;p&gt;Angular(包括2和4)是从AngularJs1.x升级而来，但是不提供向下兼容。Anuglar2(和4)和AngularJs1.x的一个很大不同，便是Angular使用了TypeScript，而1.x则使用了JavaScript，也是两者不能兼容的一个很重要的原因(如果有其他的原因的话)。目前现代浏览器均不直接支持TypeScript(可能存在间接支持的情况，不确定的事情还是不要打保票了)，因此，我不能像AngularJs1.x那样，直接将Angular引入到JSP中。查过很多资料，按照别人的思路将Angular和JavaWeb(以SpirngMVC为主)项目结合起来，但是看着别人说是可以跑通的，但是自己怎么跑都不行，就算直接用别人的源代码也行，搞得我相当郁闷。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;虽然通过查找资料没有解决我的问题，但是我还是获得很大收获。TypeScript毕竟是JavaScript的一个超集，本质上还是JavaScript。Angular虽然是用TypeScript写的，但是在编译之后本质上和html、css、js文件没有什么两样，因此我没有必要将Angular的代码放进JavaWeb里面，而是将Angular编译之后的静态文件放入JavaWeb项目中就可以了。&lt;/p&gt;
&lt;p&gt;在我这个项目中我使用Spring Boot作为后端的框架，maven作为构建工具，&lt;a href=&quot;mailto:那么在main目录下使用@angular/cli工具新建一个angular项目&quot;&gt;那么在main目录下使用@angular/cli工具新建一个angular项目&lt;/a&gt;，名字就叫做angular吧。Spring Boot项目中一般将静态资源放在resources目录下的static文件夹中，为了方便编译，可以把Angular中的.angular-cli.json文件中apps下的outDir设置为“../resources/static”。&lt;/p&gt;
&lt;p&gt;Angular页面使用VSCode开发，Spring Boot则使用idea。当我们启动项目或打包的时候需要使用ng build去编译angular代码，由于我修改.angular-cli.json的配置，编译后的代码将不会放在默认的dist目录下，而是在spring boot中的resources的static文件夹中了。&lt;/p&gt;
&lt;h2 id=&quot;源代码&quot;&gt;源代码&lt;/h2&gt;
&lt;p&gt;感谢你容忍我烂到天际的文笔看到现在，这是&lt;a href=&quot;https://github.com/damingerdai/web-qq&quot;&gt;源代码&lt;/a&gt;，希望对你有所帮助。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 15:19:00 +0000</pubDate>
<dc:creator>大明二代</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiao2/p/7663806.html</dc:identifier>
</item>
<item>
<title>提纲挈领webrtc之vad检测 - DyLanCao</title>
<link>http://www.cnblogs.com/dylancao/p/7663755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dylancao/p/7663755.html</guid>
<description>&lt;p&gt;　　顾名思义，VAD（Voice Activity Detection）算法的作用是检测是否是人的语音，它的使用&lt;/p&gt;
&lt;p&gt;范围极广，降噪，语音识别等领域都需要有vad检测。vad检测有很多方法，这里我们之介绍一&lt;/p&gt;
&lt;p&gt;下webrtc里面的vad检测。&lt;/p&gt;
&lt;p&gt;　　webrtc的vad检测原理是根据人声的频谱范围，把输入的频谱分成六个子带&lt;/p&gt;
&lt;p&gt;（80Hz~250Hz，250Hz~500Hz,500Hz~1K,1K~2K,2K~3K,3K~4K。） 分别计算这六个子带的、&lt;/p&gt;
&lt;p&gt;能量。然后使用高斯模型的概率密度函数做运算，得出一个对数似然比函数。对数似然比分为&lt;/p&gt;
&lt;p&gt;全局和局部，全局是六个子带之加权之和，而局部是指每一个子带则是局部，所以语音判决会&lt;/p&gt;
&lt;p&gt;先判断子带，子带判断没有时会判断全局，只要有一方过了，就算有语音。&lt;/p&gt;
&lt;p&gt;　　webrtc的vad检测代码比较简洁，核心代码只在三个文件中。&lt;/p&gt;
&lt;p&gt;webrtc_vad.c 该文件是用户调用的API函数，使用vad一般只需要调用该里面的函数即可。&lt;/p&gt;
&lt;p&gt;使用函数：WebRtcVad_Create  WebRtcVad_Init 申请内存和初始化一些参数。&lt;/p&gt;
&lt;p&gt;使用函数：WebRtcVad_set_mode 设置vad要处理的采样率，一般是8000或16000&lt;/p&gt;
&lt;p&gt;使用函数：WebRtcVad_Process 核心函数，完成检测是否有人声的核心。&lt;/p&gt;
&lt;p&gt;vad_core.c 该文件是webrtc_vad.c 文件中函数的实现代码，也是vad最深层的核心代码，&lt;/p&gt;
&lt;p&gt;有兴趣的话可以研究一下。这里不做展开。&lt;/p&gt;
&lt;p&gt;　　使用方法：&lt;/p&gt;
&lt;p&gt;　　初始化调用：&lt;/p&gt;
&lt;p&gt;　　WebRtcVad_Create（）；&lt;/p&gt;
&lt;p&gt;　　WebRtcVad_Init（）；&lt;/p&gt;
&lt;p&gt;　　WebRtcVad_set_mode（）；&lt;/p&gt;
&lt;p&gt;　　处理调用：&lt;/p&gt;
&lt;p&gt;　　WebRtcVad_Process（）；&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;　　这里共有三种帧长可以用到，分别是80/10ms，160/20ms，240/30ms。其它采样率&lt;/p&gt;
&lt;p&gt;的48k，32k，24k，16k会重采样到8k来计算VAD。之所以选择上述三种帧长度，是因为语&lt;/p&gt;
&lt;p&gt;音信号是短时平稳信号，其在10ms~30ms之间可看成平稳信号，高斯马尔科夫等比较&lt;/p&gt;
&lt;p&gt;的信号处理方法基于的前提是信号是平稳的，在10ms~30ms，平稳信号处理方法是可&lt;/p&gt;
&lt;p&gt;以使用的。&lt;/p&gt;
&lt;p&gt;　　从vad的代码中可以看出，实际上，系统只处理默认10ms,20ms,30ms长度的数据，&lt;/p&gt;
&lt;p&gt;其它长度的数据没有支持，笔者修改过可以支持其它在10ms-30ms之间长度的帧长度&lt;/p&gt;
&lt;p&gt;发现也是可以的。&lt;/p&gt;
&lt;p&gt;　　vad检测共四种模式，用数字0~3来区分，激进程度与数值大小正相关。&lt;br/&gt;0: Normal，1：low Bitrate， 2：Aggressive；3：Very Aggressive 可以根据实际的使用&lt;/p&gt;
&lt;p&gt;在初始化的时候可以配置。&lt;/p&gt;
&lt;p&gt;　　自问自答：&lt;/p&gt;
&lt;p&gt;　　问题一：为什么子带是从80HZ开始的？&lt;/p&gt;
&lt;p&gt;　　答复：我国交流电标准是220V~50Hz，电源50Hz的干扰会混入麦克风采集到的数据中且物理震动也会带来影响，所以取了80Hz以上的信号。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 15:03:00 +0000</pubDate>
<dc:creator>DyLanCao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dylancao/p/7663755.html</dc:identifier>
</item>
<item>
<title>Linux上mysql的安装与配置 - 珂儿吖</title>
<link>http://www.cnblogs.com/keerya/p/7663742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keerya/p/7663742.html</guid>
<description>

&lt;p&gt;&lt;span&gt;　　 &lt;span&gt;在我们使用Linux的过程中，可能会使用到数据库。那么，数据库的安装与配置就是我们需要掌握的了~所以呢，这篇博客小编就来给大家唠唠数据库的安装与配置。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    说到编译安装，小编脑海里浮现的第一个方法就是yum源安装（见实验一），毕竟，我们使用最多的安装方法就是这个了~当然，我们还有别的方法，比如二进制安装（见实验二），所以接下来我们就来详细说说这两种方法。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　首先，我们来看看使用yum源安装MySQL的优缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　优点：&lt;/strong&gt;&lt;/span&gt;安装方便快捷，安装方式简单&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　缺点：&lt;/strong&gt;&lt;/span&gt;太过于死板，定死了各个文件的位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，我们就开始我们的实验：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、打开官方网站，上边有各种版本的yum源，找到自己想要的版本设置yum源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官网：&lt;a href=&quot;https://downloads.mariadb.org/mariadb/repositories/&quot;&gt;&lt;span&gt;https://downloads.mariadb.org/mariadb/repositories/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225925168-221918411.png&quot; alt=&quot;&quot;/&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如果没有网络的话，就使用光盘里的yum源安装即可，都是一样的~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、如果我们使用官网上的版本，就要按照官网的提示来配置我们的yum源，接下来，我们就以上图选择的版本来安装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[root@centos7 ~]# vim /etc/yum.repos.d/centos7.repo [mariadb]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;name = MariaDB&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;baseurl = &lt;a href=&quot;http://yum.mariadb.org/10.2/centos7-amd64&quot;&gt;http://yum.mariadb.org/10.2/centos7-amd64&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;gpgcheck=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    编辑好yum源以后，记得使用&quot;yum clean all&quot;清除缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、我们在此使用光盘中的yum源安装，如果大家有兴趣使用官网的源，可以参照上一步的配置，接下来的安装过程也都是一样的~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;yum安装和开启服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@centos7 &lt;span&gt;yum&lt;/span&gt;.repos.d]# &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; mariadb-server -y    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;安装mariadb&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Loaded plugins: fastestmirror, langpacks
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;Loading mirror speeds from cached hostfile
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;Resolving Dependencies
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; --&amp;gt;&lt;span&gt; Running transaction check
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; ---&amp;gt; Package mariadb-server.x86_64 &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;52&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.el7 will be installed
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; --&amp;gt;&lt;span&gt; Finished Dependency Resolution
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;Dependencies Resolved
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; =====================================================================================================================================
&lt;span&gt;12&lt;/span&gt; &lt;span&gt; Package                             Arch                        Version                             Repository                 Size
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; =====================================================================================================================================
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;Installing:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  mariadb-server                      x86_64                      &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;52&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7                      base                       &lt;span&gt;11&lt;/span&gt;&lt;span&gt; M
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;Transaction Summary
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; =====================================================================================================================================
&lt;span&gt;19&lt;/span&gt; Install  &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Package
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; Total download size: &lt;span&gt;11&lt;/span&gt;&lt;span&gt; M
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; Installed size: &lt;span&gt;56&lt;/span&gt;&lt;span&gt; M
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;Downloading packages:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;Running transaction check
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;Running transaction test
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;Transaction test succeeded
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;Running transaction
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;   Installing : &lt;span&gt;1&lt;/span&gt;:mariadb-server-&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;52&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7.x86_64                                                                              &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;   Verifying  : &lt;span&gt;1&lt;/span&gt;:mariadb-server-&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;52&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el7.x86_64                                                                              &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;Installed:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;   mariadb-server.x86_64 &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;52&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.el7                                                                                               
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; Complete!
&lt;span&gt;35&lt;/span&gt; [root@centos7 &lt;span&gt;yum&lt;/span&gt;.repos.d]# systemctl start mariadb    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启服务&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; [root@centos7 &lt;span&gt;yum&lt;/span&gt;.repos.d]# ss -nutl        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看服务端口开启状态&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; Netid State      Recv-Q Send-&lt;span&gt;Q                   Local Address:Port                                  Peer Address:Port              
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; udp   UNCONN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;                                    *:&lt;span&gt;5353&lt;/span&gt;                                             *:*                  
&lt;span&gt;39&lt;/span&gt; udp   UNCONN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;                            &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;323&lt;/span&gt;                                              *:*                  
&lt;span&gt;40&lt;/span&gt; udp   UNCONN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;                                    *:&lt;span&gt;60083&lt;/span&gt;                                            *:*                  
&lt;span&gt;41&lt;/span&gt; udp   UNCONN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;                                  ::&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;323&lt;/span&gt;                                             :::*                  
&lt;span&gt;42&lt;/span&gt; tcp   LISTEN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;50&lt;/span&gt;                                   *:&lt;span&gt;3306&lt;/span&gt;                                             *:*                  
&lt;span&gt;43&lt;/span&gt; tcp   LISTEN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;                                  *:&lt;span&gt;111&lt;/span&gt;                                              *:*                  
&lt;span&gt;44&lt;/span&gt; tcp   LISTEN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;                                  *:&lt;span&gt;22&lt;/span&gt;                                               *:*                  
&lt;span&gt;45&lt;/span&gt; tcp   LISTEN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;                          &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;631&lt;/span&gt;                                              *:*                  
&lt;span&gt;46&lt;/span&gt; tcp   LISTEN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;100&lt;/span&gt;                          &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;                                               *:*                  
&lt;span&gt;47&lt;/span&gt; tcp   LISTEN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;                                 :::&lt;span&gt;111&lt;/span&gt;                                             :::*                  
&lt;span&gt;48&lt;/span&gt; tcp   LISTEN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;                                 :::&lt;span&gt;22&lt;/span&gt;                                              :::*                  
&lt;span&gt;49&lt;/span&gt; tcp   LISTEN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;                                ::&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;631&lt;/span&gt;                                             :::*                  
&lt;span&gt;50&lt;/span&gt; tcp   LISTEN     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;100&lt;/span&gt;                                ::&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;                                              :::*  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225925902-1270634258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询端口对应的进程信息 lsof -i :3306 或 netstat -tnlp | grep 3306&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225926355-556490530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开启服务后，会多一个&lt;strong&gt;mysql&lt;/strong&gt;的用户，我们可以查询一下，它的家目录的作用是存放数据库，也就是存放数据库中的每个表：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225926762-1242544665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之所以会生成这个用户，是因为在安装maria包时，执行了一个脚本，所以，如果我们使用二进制安装，则需手动创建用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;rpm -q --scripts mariadb-server 查看这个脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225927059-864719375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    截图只截取了一小部分，主要是为了告诉大家有创建用户的这个过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、执行&quot;mysql&quot;命令来运行数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    首先我们将用户切换至任一普通用户：su - keer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    然后执行&quot;mysql&quot;命令来运行数据库：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225927449-753685577.png&quot; alt=&quot;&quot;/&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们可以看出，我们可以匿名登录，而且即使我们切换成了普通用户，我们运行数据库以后，依然默认是root登录，可以对数据库进行查看以及删除等操作，这样无疑是很不安全的，所以就需要进行我们的下一步操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、运行安全脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;/usr/bin/mysql_secure_installation&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225927934-268275029.png&quot; alt=&quot;&quot;/&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225928434-335841751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    运行过安全脚本以后，我们在用普通用户来登录试试看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225928762-1251562776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们再来使用root登录一次，命令为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    mysql -u root -p (passwd) 密码可以直接加在后面，也可以运行后再输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225929137-549803076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们可以看出，这样就可以登录至数据库了，以后我们还可以创建其他账户来登录，我们的安全机制已经实现！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    实验完成！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;安装之前要确保自己系统上没有mariadb服务，有老版本可以先卸掉&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、rpm -qi mariadb 可以查询官网&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225929699-1951170808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;去官网下载自己想要的版本 &lt;a href=&quot;http://mariadb.org&quot;&gt;&lt;span&gt;http://mariadb.org&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在虚拟机中把下好的包上传（rz），并对其进行解包解压缩：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;tar xvf&lt;/strong&gt; mariadb-10.2.8-linux-x86_64.tar.gz &lt;strong&gt;-C /usr/local/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（不像编译安装一样，解包可以放在任何目录，&lt;span&gt;&lt;strong&gt;这个二进制安装必须指定在这个目录&lt;/strong&gt;&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解压的过程略久，大家耐心等待~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、去查看文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cd /usr/local/ 进入解开压缩包的目录，发现mariadb的目录名字不符合要求，所以我们可以直接修改名字，也可以创建一个软连接，创建软连接命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ln -s mariadb-10.2.8-linux-x86_64/ mysql&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225930043-2033055706.png&quot; alt=&quot;&quot;/&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、创建mysql用户（很重要！一定不能忘！）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;useradd&lt;/strong&gt; &lt;strong&gt;-d&lt;/strong&gt; /app/mysqldb &lt;strong&gt;-r -m -s&lt;/strong&gt; /sbin/nologin &lt;strong&gt;mysql&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、创建修改配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    进入mysql文件夹，查看support-files文件夹中的内容，发现里面有我们的配置文件，但是配置文件不应该在这个目录下，应该放在/etc/mysql/下，所以，我们要创建这个目录，并把配置文件复制进去，具体的操作如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@centos7 local]# cd mysql/
&lt;span&gt; 2&lt;/span&gt; [root@centos7 mysql]# &lt;span&gt;ls&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; bin      COPYING.thirdparty  data               include         lib  mysql-test  README-wsrep  share      support-&lt;span&gt;files
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; COPYING  CREDITS             EXCEPTIONS-CLIENT  INSTALL-BINARY  &lt;span&gt;man&lt;/span&gt;  README.md   scripts       sql-&lt;span&gt;bench
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; [root@centos7 mysql]# &lt;span&gt;ls&lt;/span&gt; support-files/
&lt;span&gt; 6&lt;/span&gt; binary-configure  my-huge.cnf             my-large.cnf   my-small.cnf         mysql-log-&lt;span&gt;rotate  policy     wsrep_notify
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; magic             my-innodb-heavy-4G.cnf  my-&lt;span&gt;medium.cnf  mysqld_multi.server  mysql.server      wsrep.cnf
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; [root@centos7 mysql]# &lt;span&gt;mkdir&lt;/span&gt; /etc/&lt;span&gt;mysql
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt;: cannot create directory ‘/etc/&lt;span&gt;mysql’: File exists
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; [root@centos7 mysql]# &lt;span&gt;cp&lt;/span&gt; support-files/my-huge.cnf /etc/mysql/my.cnf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;    接下来我们来修改配置文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vim /etc/mysql/my.cnf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[mysqld]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;datadir = /app/mysqldb&lt;/strong&gt;        　　//指定总目录，必须的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;innodb_file_per_table = on         //让每一个表数据库都是一个文件，方便管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;skip_name_resolve = on             //忽略名字的反向解析，加快速度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225930434-338472212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、执行脚本，创建系统数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cd /usr/local/mysql 一定要在这个目录下执行脚本，因为脚本写死了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;./scripts/mysql_install_db &lt;strong&gt;--user=&lt;/strong&gt;mysql &lt;strong&gt;--datadir=&lt;/strong&gt;/app/mysqldb 执行脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完成后就会在/app/mysqldb/ 生成mysql系统数据库&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6、把服务脚本复制过去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cp support-files/mysql.server /etc/init.d/mysqld&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;chkconfig --add mysqld 设置服务在哪个运行级别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;chkconfig --list mysqld&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225930887-1162159768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    设置完毕后，我们开启服务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225931199-314290870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开启服务失败，我们通过提示的命令来查看失败原因：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;systemctl status mysqld.service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;journalctl -xe&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看过后发现，是因为我们缺少日志文件，而且这个日志文件须有读写权限，接下来我们就来创建：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、创建配置文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@centos7 mysql]# &lt;span&gt;mkdir&lt;/span&gt; /var/log/mariadb/
&lt;span&gt;2&lt;/span&gt; [root@centos7 mysql]# &lt;span&gt;touch&lt;/span&gt; /var/log/mariadb/&lt;span&gt;mariadb.log
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@centos7 mysql]# &lt;span&gt;chown&lt;/span&gt; mysql /var/log/mariadb/mariadb.log
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;创建完文件以后，我们再来开启一次试试看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225931543-489452232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务开启成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，我们来设置一下PATH：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@centos7 mysql]# vim /etc/profile.d/mysql.&lt;span&gt;sh&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; PATH=/usr/local/mysql/&lt;span&gt;bin:$PATH
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [root@centos7 mysql]# . /etc/profile.d/mysql.&lt;span&gt;sh&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;8、运行安全初始化脚本，同上实验，注意路径发生了改变，现在的安全脚本路径为：&lt;span&gt;/usr/local/mysql/bin/mysql_secure_installation&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225932043-703356098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1204916/201710/1204916-20171013225932496-822854070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    实验完成~&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 15:03:00 +0000</pubDate>
<dc:creator>珂儿吖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/keerya/p/7663742.html</dc:identifier>
</item>
<item>
<title>动态IP解析 - 康行天下</title>
<link>http://www.cnblogs.com/makefile/p/ddns.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/makefile/p/ddns.html</guid>
<description>&lt;p&gt;本文介绍两种方便获取主机动态IP的方式(DDNS,IP报告网页),并给出相应的代码实现.&lt;br/&gt;shell脚本获取本机IP,执行上传操作和更新DNS操作.定期执行通过crontab或者systemd等服务.&lt;/p&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt;
&lt;p&gt;远程访问具有动态IP的公网或内网主机时,如果通过ip进行访问,由于公网IP总是在变化,我们不得不每次去查看新的ip地址,往往这个重复的过程比较麻烦.&lt;br/&gt;远程主机联网的方式有所不同,主要有以下几种情形:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;远程主机是通过PPPoE拨号上网,通常获取到动态的私有网络(内网)地址&lt;/li&gt;
&lt;li&gt;远程主机直接获取到的是动态公网ipv4地址.&lt;/li&gt;
&lt;li&gt;.在教育网中通常还能获得动态的公网ipv6地址.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;又可以简易地分成两类: 配有公网ip的主机与仅配置内网ip的主机.&lt;br/&gt;&lt;strong&gt;内网主机访问方式&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;反向隧道&lt;br/&gt;对于躲在NAT之后的内网主机,比较方便的方式是在内网主机建立到公网主机的&lt;code&gt;反向隧道&lt;/code&gt;,命令行建立反向隧道工具有:ssh,ngrok,tmate等,参考我之前的反向隧道的文章. 这些工具往往都能在ip发生改变后自动重建连接.&lt;br/&gt;缺点是我们需要一台拥有公网ip的主机,并且时刻保持隧道长连接,另外由于远程访问内网主机需要经过这个公网主机中转,速度变慢.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内网穿透&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过公网服务器得到内网主机在NAT设备的转码地址,然后可以建立p2p的连接.QQ,TeamViewer即是类似原理.前提是内网容易穿透.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;路由器端口映射&lt;br/&gt;外网IP和端口映射到内网:在路由器的「转发规则」页面添加外网的端口到内网某主机端口的映射.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本着只要有不断重复的麻烦事就用脚本实现的原则,我们通过一些脚本来方便我们的工作.&lt;/p&gt;
&lt;h2 id=&quot;ddns-动态域名ip解析&quot;&gt;DDNS (动态域名IP解析)&lt;/h2&gt;
&lt;h3 id=&quot;ip报告收集脚本&quot;&gt;IP报告/收集脚本&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IP报告脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过linux的ip命令获取到本机的公网ip以及通过网站获取本机的外网ip,然后上传到自建的php服务器上.&lt;/p&gt;
&lt;p&gt;脚本使用了本地文件记录前一次变更的ip地址,当ip发生变化才执行网络操作.文件保存在内存文件系统或临时文件中.&lt;br/&gt;reportIP.sh&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#!/bin/bash
# __author__ = fyk
# get global ipv6 &amp;amp; ipv4 address,
# note that both ipv6 &amp;amp; ipv4 addr may have more than 1.

# grep -v to exclude temporary ipv6 privacy addr.
ip6s=$(ip -6 addr |grep 'global'|grep -v 'tmpaddr'|awk '{print $2}'|sed 's/\/.*//' | uniq)
ip4s_local=$(ip -4 a | grep global |awk '{print $2}' | uniq) # local v4 ips ,public or prive ips that behind NAT
ips_pub=$(curl -s ifconfig.me) # there are lots of websites supplying IP echo services
ip_data=$ips_pub' '${ip6s}' '${ip4s_local}
#echo $ip_data
IP_FILE='/dev/shm/lastip97451' # or in /tmp .etc
ip_data_old=$(cat $IP_FILE 2&amp;gt; /dev/null) # for non-exist file,content is null
if [ &quot;$ip_data&quot; != &quot;$ip_data_old&quot; ];then
        echo 'IP changed,push to remote.'
        #echo $ip_data &amp;gt; $IP_FILE # update the file
        params='k=fyk'
        cnt=0
        for ip in $ip_data;do
                echo $ip
                params=$params&quot;&amp;amp;ip$cnt=$ip&quot; # shell will handle &amp;amp; specially,so we first trans &amp;amp; to %26
                ((cnt=cnt+1))
        done
        params=&quot;n=$cnt&amp;amp;$params&quot;
        sever_addr=&quot;http://x.makefile.tk/&quot;
        #echo ${sever_addr}
        curl -G -d &quot;$params&quot; &quot;$sever_addr&quot;

else echo 'IP unchanged.'
fi
# TODO:增加断网重连&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;php收集脚本&lt;/strong&gt;&lt;br/&gt;提供的服务地址形式是:&lt;code&gt;http://x.makefile.tk/?k=password&amp;amp;n=2&amp;amp;p0=x.x.x.x&amp;amp;p1=x.x.x.x&lt;/code&gt;,其中n是ip地址个数,p0,p1,...分别是单独的ip,参数k为了简单地防止一些人捣乱.直接访问&lt;code&gt;http://x.makefile.tk/&lt;/code&gt;将能看到上一次保存的ip地址.&lt;/p&gt;
&lt;p&gt;下面是index.php代码,通过文件来记录ip地址,不能够并发写入.同shell报告脚本一样可以使用内存文件来加快读写速度.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;&lt;span class=&quot;ot&quot;&gt;?&lt;/span&gt;php
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; !&lt;span class=&quot;fu&quot;&gt;function_exists&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'sys_get_temp_dir'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;))&lt;/span&gt; {
  &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sys_get_temp_dir&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;!&lt;span class=&quot;fu&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$_ENV&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'TMP'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]))&lt;/span&gt; { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;realpath&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$_ENV&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'TMP'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt; }
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;!&lt;span class=&quot;fu&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$_ENV&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'TMPDIR'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]))&lt;/span&gt; { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;realpath&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$_ENV&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'TMPDIR'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt; }
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;!&lt;span class=&quot;fu&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$_ENV&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'TEMP'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]))&lt;/span&gt; { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;realpath&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$_ENV&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'TEMP'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt; }
    &lt;span class=&quot;kw&quot;&gt;$tempfile&lt;/span&gt;=&lt;span class=&quot;fu&quot;&gt;tempnam&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;uniqid&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;file_exists&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$tempfile&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;))&lt;/span&gt; {
    &lt;span class=&quot;fu&quot;&gt;unlink&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$tempfile&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;realpath&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;dirname&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$tempfile&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;));&lt;/span&gt;
    }
  }
}
&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;?php&lt;/span&gt; 
&lt;span class=&quot;co&quot;&gt;//echo &quot;QUERY_STRING: &quot; . $_SERVER['QUERY_STRING'];&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//echo &quot;&amp;lt;br&amp;gt;&quot;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//$temp_file = tempnam(sys_get_temp_dir(), 'Tux');&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//$temp_file = sys_get_temp_dir() . 'ip97845';&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//$temp_file = '/dev/shm/ip97845';//seems to be frequently erased by cloud host.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;$temp_file&lt;/span&gt; = &lt;span class=&quot;st&quot;&gt;'ip97845'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//if has param of n,then save ip to file&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;isset&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$_GET&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'n'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]))&lt;/span&gt;{
    &lt;span class=&quot;kw&quot;&gt;$n&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;$_GET&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'n'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;isset&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$_GET&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'k'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]))&lt;/span&gt;{
        &lt;span class=&quot;kw&quot;&gt;$key&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;$_GET&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'k'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;];&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//for simple security&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$key&lt;/span&gt; == &lt;span class=&quot;st&quot;&gt;'password'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{
            &lt;span class=&quot;kw&quot;&gt;$myfile&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$temp_file&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;w&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;die&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Unable to open file!&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$x&lt;/span&gt;=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$x&lt;/span&gt;&amp;lt;&lt;span class=&quot;kw&quot;&gt;$n&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$x&lt;/span&gt;++&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;$ip_idx&lt;/span&gt; = &lt;span class=&quot;st&quot;&gt;'ip'&lt;/span&gt; . &lt;span class=&quot;kw&quot;&gt;$x&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;$ip_idx&lt;/span&gt; . &lt;span class=&quot;st&quot;&gt;&quot;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$_GET&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$ip_idx&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;]&amp;lt;br&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;fwrite&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$myfile&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
            }
            &lt;span class=&quot;fu&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$myfile&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'save ip ok!&amp;lt;br&amp;gt;'&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
        }&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'key error'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    }&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'no key error'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    
}&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;{ &lt;span class=&quot;co&quot;&gt;// read from file&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;$myfile&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$temp_file&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;die&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Unable to open file!&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;fread&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$myfile&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;filesize&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$temp_file&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$myfile&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
}


&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Your INFO:&amp;lt;br&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;IP: &quot;&lt;/span&gt; . &lt;span class=&quot;kw&quot;&gt;$_SERVER&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'REMOTE_ADDR'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;br&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;UA: &quot;&lt;/span&gt; . &lt;span class=&quot;kw&quot;&gt;$_SERVER&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'HTTP_USER_AGENT'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;br&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于这种web应用,使用网络上各种php建站即可.&lt;/p&gt;
&lt;h3 id=&quot;公用dns服务&quot;&gt;公用DNS服务&lt;/h3&gt;
&lt;p&gt;准备:购买公网域名,域名设置DNS解析服务为Dnspod或CloudFlare.本文的代码使用CloudFlare的API动态修改DNS记录.&lt;/p&gt;
&lt;p&gt;思路是修改IP报告脚本,将更新的IP更新的公共的DNS服务上.&lt;/p&gt;
&lt;p&gt;ipv6-dns.sh 代码:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#!/bin/bash
# __author__ = fyk
# get global ipv6 &amp;amp; ipv4 address,
# note that both ipv6 &amp;amp; ipv4 addr may have more than 1.

# get variables in dns.conf which includes cloudflare info
# source dns.conf
if [ -z &quot;$1&quot; ] ;then
        echo 'please specify conf file'
        exit 0
else
        source $1
fi

# grep -v to exclude temporary ipv6 privacy addr.
ip6s=$(ip -6 addr |grep 'global'|grep -v 'tmpaddr'|awk '{print $2}'|sed 's/\/.*//')
#for my own needs,i only use ipv6
#ip4s=$(ip -4 a | grep global |awk '{print $2}')
for ip in $ip6s;do
        ip_data=$ip
        break # only use first one
done
#ip_data=${ip6s}' '${ip4s}
#echo $ip_data

API_URL=&quot;https://api.cloudflare.com/client/v4&quot;
CURL=&quot;curl -s \
  -H Content-Type:application/json \
  -H X-Auth-Key:$AUTH_KEY \
  -H X-Auth-Email:$AUTH_EMAIL &quot;

update_dns(){
UPDATE_DATA=$(cat &amp;lt;&amp;lt; EOF
{ &quot;type&quot;: &quot;AAAA&quot;,
  &quot;name&quot;: &quot;$DOMAIN_NAME&quot;,
  &quot;content&quot;: &quot;$2&quot;,
  &quot;proxied&quot;: false }
EOF
)
        #&quot;ttl&quot;: 1, # let it be Automatic
        echo &quot;update dns: $DOMAIN_NAME -&amp;gt; $2&quot;
        $CURL -X PUT &quot;$API_URL/zones/$ZONE_ID/dns_records/$1&quot; -d &quot;$UPDATE_DATA&quot; &amp;gt; /tmp/cloudflare-ddns.json
}
IP_FILE='/dev/shm/lastip9745' # or in /tmp .etc
ip_data_old=$(cat $IP_FILE 2&amp;gt; /dev/null) # for non-exist file,content is null
if [ &quot;$ip_data&quot; == &quot;$ip_data_old&quot; ];then
        echo 'IP unchanged.'
        exit 0
fi
echo 'IP changed,push to remote.'
if [ -z &quot;$REC_ID&quot; ] ; then
        RECS=$($CURL &quot;$API_URL/zones/$ZONE_ID/dns_records?name=$DOMAIN_NAME&quot;)
        echo $RECS
        REC_ID=$(echo &quot;$RECS&quot; | sed -e 's/[{}]/\n/g' | sed -e 's/,/\n/g' | grep '&quot;id&quot;:&quot;' | cut -d'&quot;' -f4)
        echo &quot;REC_ID=$REC_ID&quot;
fi
update_dns &quot;$REC_ID&quot; &quot;$ip_data&quot;
echo $ip_data &amp;gt; $IP_FILE # update the file&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;脚本中通过source dns.conf读取了配置信息:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# this is Cloudflare api info for DDNS
# !!do not leave space around =
AUTH_EMAIL=&amp;lt;cloudflare-auth-email&amp;gt;
#This is your *Global API Key* under Cloudflare account settings
AUTH_KEY=&amp;lt;cloudflare-auth-key&amp;gt;
#Zone ID:can be find out there: &amp;lt;https://www.cloudflare.com/a/overview/&amp;gt;
ZONE_ID=&amp;lt;DNS Zone&amp;gt;
DOMAIN_NAME=&quot;lab.makefile.tk&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体API使用方法查阅https://api.cloudflare.com&lt;/p&gt;
&lt;h3 id=&quot;自建dns服务&quot;&gt;自建DNS服务&lt;/h3&gt;
&lt;p&gt;准备:外网服务器B,搭建bind9服务用来提供DNS服务&lt;/p&gt;
&lt;p&gt;借助于IP报告/收集脚本,在服务器B上不断更新域名解析.&lt;/p&gt;
&lt;p&gt;客户端机器C，手动设置DNS服务地址为B的IP.这种方式的优点是域名想怎么写就怎么写.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.fens.me/vps-ip-dns/&quot;&gt;示意图&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/606386/201710/606386-20171013225453887-1598143483.png&quot; alt=&quot;DDNS&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过DNS服务可以实现与著名的&lt;code&gt;花生壳&lt;/code&gt;相类似的服务，而且成本低，“自主、可控”：) 。&lt;/p&gt;
&lt;p&gt;关于&lt;strong&gt;域名解析ttl&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;TTL是英语Time-To-Live的简称，意思为一条域名解析记录在DNS服务器中的存留时间。当各地的DNS服务器接受到解析请求时，就会向域名指定的NS服务器发出解析请求从而获得解析记录；在获得这个记录之后，记录会在DNS服务器中保存一段时间，这段时间内如果再接到这个域名的解析请求，DNS服务器将不再向NS服务器发出请求，而是直接返回刚才获得的记录；而这个记录在DNS服务器上保留的时间，就是TTL值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果域名的IP经常变更,那么减小TTL的值,如果很少改变,调大成几个小时都行.&lt;br/&gt;将TTL设为1,表示'Automatic',如Cloudflare的DNS会在约5分钟内push出去.&lt;/p&gt;
&lt;h3 id=&quot;邮件通知&quot;&gt;邮件通知&lt;/h3&gt;
&lt;p&gt;发送邮件.适合于ip更新不太频繁的情形,通过代码发送邮件的代码很简便,Python,Java等语言均有方便的实现.&lt;/p&gt;
&lt;h3 id=&quot;cron定时执行&quot;&gt;cron定时执行&lt;/h3&gt;
&lt;p&gt;执行&lt;code&gt;crontab -e&lt;/code&gt;将会编辑用户的crontab文件,其创建/tmp下的临时文件进行编辑,保存后将会提交到系统目录下(/var/spool/cron),这种设计方式类似visudo,目的是先检查用户的输入,防止错误的输入带来的破坏.系统重启后/tmp下的文件会删除,而crontab不会丢失.&lt;br/&gt;也可以使用自定义的crontab文件导入到系统任务中:`crontab /path/to/cronfile&lt;br/&gt;文件内容如下,注意使用绝对路径:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0 */1 * * * /home/s05/fyk/ip/ipv6-dns.sh /home/s05/fyk/ip/dns.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;crontab无需重启会立即生效.&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本文代码地址&lt;/strong&gt;: &lt;a href=&quot;https://github.com/makefile/CharmScript/tree/master/DDNS&quot; class=&quot;uri&quot;&gt;https://github.com/makefile/CharmScript/tree/master/DDNS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其它资源&lt;/strong&gt;:&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 14:56:00 +0000</pubDate>
<dc:creator>康行天下</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/makefile/p/ddns.html</dc:identifier>
</item>
<item>
<title>DotNetCore跨平台~配置文件与配置代码如何共存 - 张占岭</title>
<link>http://www.cnblogs.com/lori/p/7663708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lori/p/7663708.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lori/p/7154409.html&quot; target=&quot;_blank&quot;&gt;回到目录&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;古人云《一山不容二虎》，而进行dotnet core时代之后，我们可以看到这样的一些官方的DEMO，它将数据连接串和其它配置项都直接硬编码在代码里，即在startup中进行定义，试问你在生产环境如何兼容！当然，你会说，可以在对应appsettings里进行配置，说它是对应的appsettings，是因为dotnet core下的配置文件有环境的区分，一般使用以下名称来表示不同的环境：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开发环境，Development&lt;/li&gt;
&lt;li&gt;预发布环境，Staging&lt;/li&gt;
&lt;li&gt;生产环境，Production&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于二者，配置文件和硬编码配置如何进行选择，如果两者都设置了，那到底应该以谁为准呢？大叔认为，如果二者都设置了，那以配置文件为准，当配置文件没有定义时，再以硬编码配置为准，这就是他们的优先级，原因有下面几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;硬编码方便在开发环境去调试&lt;/li&gt;
&lt;li&gt;在指定运行环境后，配置文件根据环境的不同，选择不同的配置&lt;/li&gt;
&lt;li&gt;优化级，配置文件 &lt;span&gt;优于&lt;/span&gt; 硬编码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面是仓储服务在注册时，选择配置的策略，当然，你可以把这种逻辑做成一种装饰，感觉更好。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EFOptionsExtension : ILindOptionsExtension
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Action&amp;lt;RepositoryOptions&amp;gt;&lt;span&gt; _configure;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; EFOptionsExtension(Action&amp;lt;RepositoryOptions&amp;gt;&lt;span&gt; configure)
        {
            _configure &lt;/span&gt;=&lt;span&gt; configure;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFOptions();
            _configure&lt;/span&gt;?.Invoke(options);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;装饰&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (oConfigFileHelper.Get&amp;lt;EFOptions&amp;gt;&lt;span&gt;().ConnString&lt;/span&gt; != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置文件优先硬编码&lt;/span&gt;
&lt;span&gt;            {
                options.ConnString &lt;/span&gt;= ConfigFileHelper.Get&amp;lt;EFOptions&amp;gt;&lt;span&gt;().ConnString;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ConfigFileHelper.Get&amp;lt;EFOptions&amp;gt;&lt;span&gt;().DbType&lt;/span&gt; !=&lt;span&gt; DbType.None)
            {
                options.DbType &lt;/span&gt;= ConfigFileHelper.Get&amp;lt;EFOptions&amp;gt;&lt;span&gt;().DbType;
            }
            services.AddSingleton&lt;/span&gt;&amp;lt;ILogger, FileLogger&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;日志&lt;/span&gt;
            services.AddSingleton(options);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ef配置&lt;/span&gt;
            services.AddTransient(&lt;span&gt;typeof&lt;/span&gt;(DbContext), options.DbContextType);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册数据上下文，实例模式&lt;/span&gt;
            services.AddTransient(&lt;span&gt;typeof&lt;/span&gt;(IRepository&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(EFRepository&amp;lt;&amp;gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册数据仓储&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在我们进行发布之后，一般把dotnet core发布到linux或者直接放在docker容器里运行，这时只要设置对应的环境变量即可，非常方便！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ENV ASPNETCORE_ENVIRONMENT=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Production&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置完成后，dotnet core会自己选择对应的appsettings.Production.json文件进行加载！&lt;/p&gt;
&lt;p&gt;感谢咱们阅读！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lori/p/7154409.html&quot; target=&quot;_blank&quot;&gt;回到目录&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 13 Oct 2017 14:52:00 +0000</pubDate>
<dc:creator>张占岭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lori/p/7663708.html</dc:identifier>
</item>
<item>
<title>JDownload:  一款可以从网络上下载文件的小程序第四篇(整体架构描述) - cs小学生</title>
<link>http://www.cnblogs.com/junhuster/p/JDownload4.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/junhuster/p/JDownload4.html</guid>
<description>&lt;p&gt;　　时间过得真快，距离本系列博客第一篇的发布已经过去9个月了，本文是该系列的第四篇博客，将对JDownload做一个整体的描述与介绍。恩，先让笔者把记忆拉回到2017年年初，那会笔者在看Unix环境高级编程这本书，其中有些章节是socket相关的，这引起了我很大的兴趣。然后有一天，看着屏幕上正在下载文件的迅雷，突然灵光一闪，要不自己也写个下载工具吧，正所谓学以致用嘛，然后网上简单搜索了一下，发现是可行的，于是乎就开始着手实现之。该系列的第一篇博客实现了一个基本的http站点迷你下载工具，第二篇加入了断点续传功能，第三篇加入了多线程的功能。本篇将从总体上对JDownload做一个描述，以图形的方式来展示一下JDownload的工作流程，因此笔者建议读者先阅读一下该系列的另外三篇博客：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JWebFileTrans: 一款可以从网络上下载文件的小程序(一)  &lt;a href=&quot;http://www.cnblogs.com/junhuster/p/JWebFileTrans.html&quot; target=&quot;_blank&quot;&gt;链接请点击我&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JWebFileTrans(JDownload): 一款可以从网络上下载文件的小程序(二)  &lt;a href=&quot;http://www.cnblogs.com/junhuster/p/JDownload.html&quot; target=&quot;_blank&quot;&gt;链接请点击我&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JWebFileTrans(JDownload): 一款可以从网络上下载文件的小程序(三)，多线程断点下载  &lt;a href=&quot;http://www.cnblogs.com/junhuster/p/JDownload3.html&quot; target=&quot;_blank&quot;&gt;链接请点击我&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　GitHub代码链接&lt;a href=&quot;https://github.com/junhuster/JDownload&quot; target=&quot;_blank&quot;&gt;请点击我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PS: 本篇博客是博客园用户“cs小学生”的原创作品，转载请注明原作者和原文链接，谢谢。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1095958/201710/1095958-20171013192423027-1767862363.png&quot; alt=&quot;&quot; width=&quot;907&quot; height=&quot;544&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　如上图所示，描述了JDownload从快车官网上下载“快车”软件的整个执行流程图，图中的数字标志了执行的先后顺序。诸如6-1,6-2之类的表示这几个步骤的关系比较紧密，6表示都属于同一个大操作，后面的1,2,3,4，表示在这个大操作的内部的执行顺序。在图中每一个线程都会经历6-1,2,3,4的这样一个执行流过程，但是为了防止图变得太过稠密而影响美观，只有线程1完整标志出了6-1,2,3,4这几个标识符，其他几个线程也会经历这几个过程，但是图中省略了这几个标识符。当然对于步骤6，图中的线程是并行执行的。&lt;/p&gt;
&lt;p&gt;　　接下来让我们从标识符1开始，来走一遍整个下载过程：&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1.  解析http链接&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　首先是用户输入下载链接“http://www.flashget.com/apps/flashget3.7.0.1222cn.exe”给JDownload，然后如图最上端的矩形框所示，JDownload会从这个链接里面解析出3个部分，分别是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; URL: www.flashget.com，通过该URL可以得到对应的ip地址&lt;/li&gt;
&lt;li&gt;服务端资源路径：/apps/flashget3.7.0.1222cn.exe&lt;/li&gt;
&lt;li&gt;文件名：flashget3.7.0.1222cn.exe&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　相信学过计算机网络这门课程的童鞋应该记得：ip地址和端口号唯一标志了一台计算机上面的一个服务，所谓服务比如80端口对应的是http服务，端口号21对应的是ftp服务等等。想象一下，我们要下载的东西必定存储在网络中的某台计算机上，但是这台计算机上很可能存在着很多服务，比如http服务、ftp服务、邮箱服务，由于这些服务是用约定好的端口号来标志的，而我们已经知道下载的东西在http站点上，所以我们向端口号80请求下载文件即可。那么端口号80我们已经知道了，服务器的ip地址怎么找呢？其实linux库函数getaddrinfo()就具备通过域名来查找ip地址的功能，具体使用请参考APUE.&lt;/p&gt;
&lt;p&gt;　　前面我们说过，通过GET可以向http站点请求下载文件，我们每一次向服务器请求文件的一部分，然后不断地请求，最后就可以把整个文件下载下来。所以我们需要知道文件的大小是多少，每一次下载多少字节量的数据，这样我们就可以知道总共需要下载多少次。文件的大小可以通过HEAD命令来向服务器查询，每次下载的量我们可以自定义比如500kb等。Get、Head命令都会收到服务器发过来的一个描述文件信息的头部，而对于Get来说，头部数据后面紧跟着就是文件的真正数据，这正是我们要下载的目标。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;      sprintf(send_buffer,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,path);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      strcat(send_buffer,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; HTTP/1.1\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;      strcat(send_buffer,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;host: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;     strcat(send_buffer,host_ip);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;      strcat(send_buffer,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;     strcat(send_buffer,port);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;     strcat(send_buffer,buffer_range);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;      strcat(send_buffer, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nKeep-Alive: 200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;      strcat(send_buffer,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nConnection: Keep-Alive\r\n\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码便是构造Get命令的代码，其中的path就是我们解析出来的服务端资源路径，host_ip就是通过getaddrinfo(url)得到的ip地址，buffer_range表示要下载的文件的范围，比如第1字节到第1000字节。这些格式化的信息要通过Linux send()函数发送给服务端，然后我们通过recv()函数接收服务端发送过来的响应。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.  创建断点文件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　什么是断点文件呢？以大家最熟悉的迅雷为例，没有下载完的文件，下次可以启动迅雷接着下载，而不用从头开始下载，其实是迅雷记住了上次下载中断时的一些信息，而我们的断点文件就是用来还原上次下载中断时的现场，以便我们可以继续上次结束的地方接着下载，也即断点续传。&lt;/p&gt;
&lt;p&gt;　　顺着流程图中的数字2我们来到一个矩形小方框，从框里的内容我们可以得知我们需要对文件进行分片，所谓的分片也即把整个文件分成N等分，然后其中的每m个等分组成一个task，这样的话就会有N/m个task,后续将会创建一些线程，每一个线程负责下载其中的若干task. 为了完成这件事情，我们首先来到数字3标志的执行流：向服务器发起连接，发送HEAD请求、服务器响应请求向客户端发送信息。根据这些信息，JDownlaod就可以对文件进行分片，然后创建断点文件了。&lt;/p&gt;
&lt;p&gt;　　顺着图中数字4标志的箭头，我们为快车创建了一个断点文件：flashget.exe.jbp. 正如上文所述，断点文件时用来恢复下载现场用的，因此要记录一下关键信息。最开头的部分记录了文件的大小、被分成了多少个task(后续每一个线程会下载其中的1个或多个task)、每一个分片的大小、分片的数目。紧接着后面挨个描述了每一个task(或者part)的信息，以part-n为例，该task包含了第(n-1)*6到第n*6个分片，当前已经下载完成了1个分片，该task包含一个168字节的数据，168不足一个分片的大小，因此单独拿出来描述(图中的数据只是一个示意，并不是真实数据)。当然只有最后一个task才会出现不足一个分片的情况。显然有了这些信息，不管下载的过程何时中断，以及中断多少次，我们都可以恢复现场。&lt;/p&gt;
&lt;p&gt;　　断点文件创建完毕后，我们沿着图中的数字5表示的箭头，在本地磁盘创建同名文件，为后续接收socket发来的数据做准备。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.  多线程下载&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　  从图中我们可以看出，创建了3个线程用于下载文件，以线程1为例，从数字6-1处可以看到，先从断点文件里读取part-0处的信息，得知需要下载第1到6个分片，而且当前并没有已经下载完毕的分片。于是沿着6-2，线程向服务端挨个请求这6个分片的数据。收到数据后沿着6-3将文件数据写到对应的offset处。这里多个线程是并发写入文件的，由于每一个线程写入的范围并没有交集，所以不需要用锁来保护数据的一致性。从图中可以看出线程1将分片1,2写入了文件中，紧接着沿着数字6-4线程应该更新断点文件，具体是更新当前已经下载了多少个分片的那个字段，这样如果文件没有下载完毕，下次重新启动的时候可以从接着已经下载的分片继续下载，而不用重复下载。&lt;/p&gt;
&lt;p&gt;　　当然，未下载完成的文件，下次继续下载时就不用执行数字1,2,3标志的过程了，而是直接读取断点文件，创建线程，每个线程从断点文件里面读取自己分配到的task，如果该task分配已下载完毕则忽略，否则接着上次下载的地方继续下载。&lt;/p&gt;

&lt;p&gt;　　  在前几篇博客里面，我们以文字和代码片段的形式叙述了JDownload的实现过程，而本篇博客以图形的方式展示了JDownload的整体概貌，并且顺着图形走了一条完整的下载路径。主要涉及到下载链接的解析、断点文件的设计、多线程的运用。在未来可能会考虑添加FTP的支持。&lt;/p&gt;
&lt;p&gt;　　  时间过得真快啊，距离写关于JDownload的第一篇博客已经过去了9个月。&lt;/p&gt;
&lt;p&gt;         联系方式：https://github.com/junhuster/ &lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 14:12:00 +0000</pubDate>
<dc:creator>cs小学生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/junhuster/p/JDownload4.html</dc:identifier>
</item>
<item>
<title>JAVA提高三：反射总结 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/7659210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/7659210.html</guid>
<description>&lt;p&gt;&lt;span&gt;为前期学习过反射，再这里再次复习总结下：【转载请说明来源：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: JAVA提高三：反射总结&quot; href=&quot;http://www.cnblogs.com/pony1223/p/7659210.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/pony1223/p/7659210.html&lt;/a&gt; 】&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Class是一个类,他代表一类事物,它代表一类什么样的事物呢? Java 程序中的各个java类属于同一类事物,描述这类事物的java类名就是Class.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思考:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;众多的人可以用一个什么类表示? Person&lt;/span&gt;&lt;br/&gt;&lt;span&gt;众多的类用一个什么类来表示?    答案是Class&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道Person代表一个人,一个人有他的身高,体重等属性,有叫,喊等方法,人还有他的父类,它的构造方法.接口等.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;那么Class类呢?他是所有类的类.那么他可以干什么呢?他可以获取某一个类的属性,方法,父类,构造方法,接口等....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1)Class的本质是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们现在定义两个对象：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Person p1 = new Person();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Person p2 = new Person();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;那如何获取这两个对象的Class类呢?用Class cls1 = new Class()可以么?不可以,因为Class跟们就没有这个构造方法.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;Class类在内存中代表的就是一段字节码&lt;/strong&gt;,那什么是字节码呢?&lt;strong&gt;当我们在源程序用到Person这个类的时候,首先把这个类编译成class文件以后,存放到硬盘上,这些class文件其实就是一堆二进制代码,要把这一堆二进制代码加载到内存中来,然后才可以去创建一个个对象.&lt;/strong&gt;当我在程序中用好多java类,有Person类,Math类,Date类,我又到这三个类,那么在内容中会有几个字节码呢?有三份字节码,每一份字节码就是Class的一个实例对象.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Class cls1 = Date.class;//代表Date类的字节码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Class cls2 = Pserson.class;//代表Person类的字节码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2)那如何来得到这个Class呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一种&lt;/strong&gt;,就是类.class;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二种&lt;/strong&gt;得到字节码的方式是,用这个类的实例p1.getClass(),也可以返回这个类对应的字节码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三种&lt;/strong&gt;方式:Class.forName(&quot;java.lang.String&quot;),里面需要制定类的完整的名字,这个方法的作用也是得到java.lang.String类的字节码.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Class.forName()的作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;39&quot;&gt;
&lt;p&gt;&lt;span&gt;返回指定类的字节码.返回的方式有两种.第一种.这个字节码曾经被加载过,已经保存在java虚拟机中了,直接返回.另一种是,java虚拟机中还没有这个字节码,则用类加载器去加载,把加载进来的字节码就会存在java虚拟机里面了.以后要在等到这份字节码就不用再加载了.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将类转变成字节码有以上三种形式,而在反射中使用最多的是第三种方法,Class.forName(name),因为写源程序的时候,还不知道类的名字,可以作为变量传递.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;九个预定义Class实例对象：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;java中有八个基本类型(int ,byte,long,float,double,short,char,boolean,)和void,他们也对应有Class对象&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201710/401339-20171013075030184-2072329864.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结:一个类的Class字节码只存在一份.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Class.isPrimitive()方法.判断一个类型是否是基本的数据类型.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201710/401339-20171013075202402-1491000145.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201710/401339-20171013075225059-1461430839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;总结:只要在源程序中出现的类型,都有各自的Class实例对象,例如:int[], void...&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第一种官方理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;反射是指在运行状态中，对于任意一个类，都可以获取到这个类的所有属性和方法；对于任意一个对象，都能够调用这个对象的任意方法和属性；这种动态获取信息及动态调用对象的方法，称为JAVA语言的反射机制。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二种个人理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;反射,就是把Java类中的各个成分映射成相应的Java类.&lt;/strong&gt;我们想想,一个类身上有什么,有包,有方法,有属性,有构造方法,有接口.而这些方法相应的又返回一个类.看下面这个api,通过Class的方法可以得到什么.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201710/401339-20171013080035965-1639880676.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201710/401339-20171013080148543-621468077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.javaenhance;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Constructor;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReflectTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception 
    {
        String str &lt;/span&gt;= &quot;abc&quot;&lt;span&gt;;
        Class clz1 &lt;/span&gt;= String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        Class clz2 &lt;/span&gt;=&lt;span&gt; str.getClass();
        Class clz3 &lt;/span&gt;= Class.forName(&quot;java.lang.String&quot;&lt;span&gt;);
        System.out.println(clz1 &lt;/span&gt;==&lt;span&gt;  clz2);
        System.out.println(clz1 &lt;/span&gt;==&lt;span&gt;  clz3);
        getConstructor();
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 目前String 类型中有很多构造方法，我想要找到获取构造方法为StringBuffer类型的一个
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception 
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; SecurityException 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getConstructor() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SecurityException, Exception
    {
        String.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.getConstructor(StringBuffer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么上面的获取到构造方法有什么用呢？&lt;/span&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 通常，我们创建String 对象为 String abc = new String(new StringBuffer(&quot;abc&quot;)) 方式，
         * 下面我们通过反射来实现：
         *  1.加载类
         *  2.解析类
         *  
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Constructor constructor &lt;/span&gt;= String.&lt;span&gt;class&lt;/span&gt;.getConstructor(StringBuffer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        String str &lt;/span&gt;=  (String) constructor.newInstance(&lt;span&gt;new&lt;/span&gt; StringBuffer(&quot;abc&quot;&lt;span&gt;));
        System.out.println(str);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;具体的原理，如何使用可以参考：http://www.cnblogs.com/pony1223/p/7445950.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 四、成员变量的反射&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成员变量的反射，在这里我们先定义一个类，用于讲解成员变量的反射。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package study.javaenhance.util;&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReflectPoint {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Date birthday = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String str1 = &quot;ball&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String str2 = &quot;basketball&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String str3 = &quot;itcast&quot;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ReflectPoint(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
    }
    
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; prime = 31&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result = 1&lt;span&gt;;
        result &lt;/span&gt;= prime * result +&lt;span&gt; x;
        result &lt;/span&gt;= prime * result +&lt;span&gt; y;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; obj)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getClass() !=&lt;span&gt; obj.getClass())
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReflectPoint other =&lt;span&gt; (ReflectPoint) obj;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x !=&lt;span&gt; other.x)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (y !=&lt;span&gt; other.y)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; str1 + &quot;:&quot; + str2 + &quot;:&quot; +&lt;span&gt; str3;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getX() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setX(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getY() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; y;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setY(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getBirthday() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; birthday;
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBirthday(Date birthday) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.birthday =&lt;span&gt; birthday;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来，我们要采用反射的方式来获取其中的x 成员和 y成员&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成员变量的反射
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.首先我们先初始化一下ReflectPoint类的xy值,以便反射的时候获取其值&lt;/span&gt;
        ReflectPoint rp = &lt;span&gt;new&lt;/span&gt; ReflectPoint(2,4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.要反射,后续加载类&lt;/span&gt;
        Field xField = rp.getClass().getField(&quot;x&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.解析类&lt;/span&gt;
        System.out.println(xField.get(rp));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上述会出现一个错误：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Exception in thread &quot;main&quot; java.lang.NoSuchFieldException: x&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at java.lang.Class.getField(Class.java:1520)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at study.javaenhance.ReflectTest.main(ReflectTest.java:25)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 也就是说找不到这个，为什么呢？很明显，因为是私有的，因此需要采用另外一个方法来获取，修改如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ReflectPoint rp = &lt;span&gt;new&lt;/span&gt; ReflectPoint(2,4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.要反射,后续加载类&lt;/span&gt;
        Field xField = rp.getClass().getDeclaredField(&quot;x&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.解析类&lt;/span&gt;
        System.out.println(xField.get(rp));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Exception in thread &quot;main&quot; java.lang.IllegalAccessException: Class study.javaenhance.ReflectTest can not access a member of class study.javaenhance.util.ReflectPoint with modifiers &quot;private&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:65)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at java.lang.reflect.Field.doSecurityCheck(Field.java:960)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at java.lang.reflect.Field.getFieldAccessor(Field.java:896)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at java.lang.reflect.Field.get(Field.java:358)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at study.javaenhance.ReflectTest.main(ReflectTest.java:27)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在是看到，却没法拿到，需要修改访问的权限打开，修改为如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ReflectPoint rp = &lt;span&gt;new&lt;/span&gt; ReflectPoint(2,4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.要反射,后续加载类&lt;/span&gt;
        Field xField = rp.getClass().getDeclaredField(&quot;x&quot;&lt;span&gt;);
        xField.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.解析类&lt;/span&gt;
        System.out.println(xField.get(rp));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于非私有的成员变量，没有这么麻烦，如下即可：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成员变量的反射
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.首先我们先初始化一下ReflectPoint类的xy值,以便反射的时候获取其值&lt;/span&gt;
        ReflectPoint rp = &lt;span&gt;new&lt;/span&gt; ReflectPoint(2,4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.要反射,后续加载类&lt;/span&gt;
        Field xField = rp.getClass().getDeclaredField(&quot;x&quot;&lt;span&gt;);
        xField.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.解析类&lt;/span&gt;
&lt;span&gt;        System.out.println(xField.get(rp));
        Field yField &lt;/span&gt;= ReflectPoint.&lt;span&gt;class&lt;/span&gt;.getField(&quot;y&quot;&lt;span&gt;);
        System.out.println(yField.get(rp));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面做一个小例子，我们看到ReflectPoint类中有很多成员变量，我们现在要做的是将String类型的成员变量的值中含b的字母替换称为a,如：ball 替换为aall&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; changeStringValue(Object rp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;思路:1.反射获取要所有的成员变量  2.获取成员变量的类型判断是否为String类型 3.如果是则获取其值 4.替换 5.回填&lt;/span&gt;
        Field[] fields =&lt;span&gt; rp.getClass().getFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Field field : fields) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(field.getType() == String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
            {
                String oldValue &lt;/span&gt;=&lt;span&gt; (String) field.get(rp);
                String newValue &lt;/span&gt;= oldValue.replace(&quot;b&quot;, &quot;a&quot;&lt;span&gt;);
                field.set(rp, newValue);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;客户端调用代码：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
ReflectPoint rp = &lt;span&gt;new&lt;/span&gt; ReflectPoint(2,4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.要反射,后续加载类&lt;/span&gt;
        Field xField = rp.getClass().getDeclaredField(&quot;x&quot;&lt;span&gt;);
        xField.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.解析类&lt;/span&gt;
&lt;span&gt;        System.out.println(xField.get(rp));
        Field yField &lt;/span&gt;= ReflectPoint.&lt;span&gt;class&lt;/span&gt;.getField(&quot;y&quot;&lt;span&gt;);
        System.out.println(yField.get(rp));
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;案例:changeStringValue&lt;/span&gt;
&lt;span&gt;        System.out.println(rp);
        changeStringValue(rp);
        System.out.println(rp);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;br/&gt;4&lt;br/&gt;ball:basketball:itcast&lt;br/&gt;aall:aasketaall:itcast&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、成员方法的反射&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法的反射&lt;/span&gt;
        Method methodCharAt = String.&lt;span&gt;class&lt;/span&gt;.getMethod(&quot;charAt&quot;, &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        System.out.println(methodCharAt.invoke(str, &lt;/span&gt;1&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;兼容JDK5.0之前的写法&lt;/span&gt;
        System.out.println(methodCharAt.invoke(str, &lt;span&gt;new&lt;/span&gt; Object[]{2}));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看出还是比较简单的和成员的方式差不多，但是下面需要注意的是，如果有一个类，我们需要通过反射的方式去调用main方法，该如何去做呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先定义一个类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestArguments{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String arg : args){
            System.out.println(arg);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最先想到的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用main方法,不采用TestArguments.main(new String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;}); 这种方式,因为有些场景我们的类是传入的是你运行期才知道的&lt;/span&gt;
        Class clazz = Class.forName(&quot;study.javaenhance.TestArguments&quot;&lt;span&gt;);
        Method method &lt;/span&gt;=  clazz.getMethod(&quot;main&quot;,String[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为main方法是静态方法,所以第一个参数传入的为null&lt;/span&gt;
        method.invoke(&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt; String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201710/401339-20171013204458871-1568882465.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么会这样呢？我们本身的使用其实是正确的，只是因为SUN公司的JDK5.0的可变参数出现后，为了兼容以前的数组方式所以出现了上面的错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在JDK5.0前：public Object invoke(Object obj, Object... args)   是采用的为 public Object invoke(Object obj, Object[] obj)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;采用的数组方式进行的接受，那么这个时候你传入的是String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;} 那么它正好和Object[] obj匹配，因为在1.5前就会开始拆分，那么就变成了传入了3个String类的参数到了main方法上面，因此这个时候就参数类型个数无法匹配了，所以就出现了上面的错误了，如何修改匹配呢？方式如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用main方法,不采用TestArguments.main(new String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;}); 这种方式,因为有些场景我们的类是传入的是你运行期才知道的&lt;/span&gt;
        Class clazz = Class.forName(&quot;study.javaenhance.TestArguments&quot;&lt;span&gt;);
        Method method &lt;/span&gt;=  clazz.getMethod(&quot;main&quot;,String[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为main方法是静态方法,所以第一个参数传入的为null
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;method.invoke(null,new String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样拆开后就是main方法想要的参数了&lt;/span&gt;
        method.invoke(&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt; Object[]{&lt;span&gt;new&lt;/span&gt; String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&lt;span&gt;}});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样就是一个对象传入了,不需要拆了&lt;/span&gt;
        method.invoke(&lt;span&gt;null&lt;/span&gt;,(Object)&lt;span&gt;new&lt;/span&gt; String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、数组与Object的关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看下面的例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组与Object的关系&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; [] a1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{1,2,3&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; [] a2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[4&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[][] a3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[2][3&lt;span&gt;];
        String [] a4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&lt;span&gt;};
        
        System.out.println(a1.getClass() &lt;/span&gt;== a2.getClass());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(a1.getClass() == a4.getClass());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(a1.getClass() == a3.getClass());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
        System.out.println(a1.getClass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[I&lt;/span&gt;
        System.out.println(a1.getClass().getSuperclass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.Object&lt;/span&gt;
        System.out.println(a4.getClass().getSuperclass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.Object&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从上面的例子说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具有相同的维数和元素类型的数组属于同一个类型，即具有相同的Class实例对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代表数组的Class实例对象的个头Superclass方法返回的父类为Object类对应的class&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;基本类型的一维数组可以被当做Object类型使用个，不能当做Object[]类型使用；非基本类型的一维数组，既可以当做Object类使用，又可以当做Object[]类型使用 --- 这句话需要理解一下,参考下面的代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组与Object的关系&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; [] a1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{1,2,3&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; [] a2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[4&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[][] a3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[2][3&lt;span&gt;];
        String [] a4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&lt;span&gt;};
        
        System.out.println(a1.getClass() &lt;/span&gt;== a2.getClass());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(a1.getClass() == a4.getClass());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(a1.getClass() == a3.getClass());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
        System.out.println(a1.getClass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[I&lt;/span&gt;
        System.out.println(a1.getClass().getSuperclass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.Object&lt;/span&gt;
        System.out.println(a4.getClass().getSuperclass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.Object&lt;/span&gt;
&lt;span&gt;        
        Object aObj1 &lt;/span&gt;= a1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为a1 是一个int[] 类型的数组所以是object类型&lt;/span&gt;
        Object aObj2 = a4;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为a4 是一个String[]类型的数组所以是Object类型
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object[] aObj3 = a1;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错,因为a1 是一个int[]数组里面的元素都是int型,不是Object类型所以不可以如果改成包装类就可以&lt;/span&gt;
        Object[] aObj4 = a3; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a3 是一个二维数组,那么里面的一维数组就是一个Object类型,所以可以匹配Object[]代表里面每个元素类型为Object&lt;/span&gt;
        Object[] aObj5 = a4; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String[] 里面的每一个元素都是String类型，也是Object类型 所以可以匹配.&lt;/span&gt;
&lt;span&gt;        
        System.out.println(a1);
        System.out.println(a4);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们发现最后a1 和 a4 的输出是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[I@87816d&lt;br/&gt;[Ljava.lang.String;@422ede&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个是什么东西呢？我们找下JDK文档看下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Class 的getName 方法中说明如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201710/401339-20171013212540668-412710157.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;即代表的是int类型的数组和String类型的数组，但我们肯定不希望输出这个样子，我们希望的看到的是里面的值，那么肯定有人会说用遍历的方法遍历出来，当然这是一种方法，但没有简单的方法吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 七、数组的反射应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面提到了遗留的问题，我们本节来解决，解决前我们先学习两个类：Array类 和Arrays类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Array&lt;/code&gt; 类提供了动态创建和访问 Java 数组的方法。&lt;/span&gt;&lt;span&gt;需要说明下Array 是 数组的反射类，处于反射包下面，所以我们看到引用类型下对于类，我们是用Class  对于数组我们是用Array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Arrays 此类包含用来操作数组（比如排序和搜索）的各种方法。此类还包含一个允许将数组作为列表来查看的静态工厂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们现在就是要利用Arrays类中的asList方法来完成显示的目的.&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组与Object的关系&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; [] a1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{1,2,3&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; [] a2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[4&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[][] a3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[2][3&lt;span&gt;];
        String [] a4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&lt;span&gt;};
        
        System.out.println(a1.getClass() &lt;/span&gt;== a2.getClass());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(a1.getClass() == a4.getClass());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(a1.getClass() == a3.getClass());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
        System.out.println(a1.getClass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[I&lt;/span&gt;
        System.out.println(a1.getClass().getSuperclass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.Object&lt;/span&gt;
        System.out.println(a4.getClass().getSuperclass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.Object&lt;/span&gt;
&lt;span&gt;        
        Object aObj1 &lt;/span&gt;= a1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为a1 是一个int[] 类型的数组所以是object类型&lt;/span&gt;
        Object aObj2 = a4;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为a4 是一个String[]类型的数组所以是Object类型
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object[] aObj3 = a1;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错,因为a1 是一个int[]数组里面的元素都是int型,不是Object类型所以不可以如果改成包装类就可以&lt;/span&gt;
        Object[] aObj4 = a3; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a3 是一个二维数组,那么里面的一维数组就是一个Object类型,所以可以匹配Object[]代表里面每个元素类型为Object&lt;/span&gt;
        Object[] aObj5 = a4; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String[] 里面的每一个元素都是String类型，也是Object类型 所以可以匹配.&lt;/span&gt;
&lt;span&gt;        
        System.out.println(a1);
        System.out.println(a4);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Array应用&lt;/span&gt;
&lt;span&gt;        System.out.println(Arrays.asList(a1));
        System.out.println(Arrays.asList(a4));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[[I@87816d]&lt;br/&gt;[a, b, c]&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么呢？如果对前面的数组与Object 关系理解的话，这里就清楚了，因为在5.0之前没有可变参数，因此传入的a1 是int[]  这个时候在Object[] 数组接受的时候发现Object[] = a1 这个是不匹配的,因此这个时候它无法处理，于是会走可变参数可变参数的时候，于是会当做一个参数处理,那么就是List集合里面直接添加这个数组了，然后结果显示为[[I@hashCode 了；而String[] 传入的时候，因为Object[] = String[] 是匹配的于是会走5.0前的方式,于是会拆分,那么List集合中就添加了3个元素,所以就显示出了上述的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;那么现在有一个需求：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;写一个方法，传递一个参数，判断这个参数是一个数组，还是一个普通类型，如果是普通类型，我就直接把他打印出来。如果是数组，我们就遍历后把值打印出来。（好处，就是不用每次都去for循环,只需要调用这个方法即可，公共性）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printObject(Object obj)
    {
        Class clazz &lt;/span&gt;=&lt;span&gt; obj.getClass();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(clazz.isArray())
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是数组,利用数组的反射类Array类来进行相关操作&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; Array.getLength(obj);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;len;i++&lt;span&gt;){
                System.out.println(Array.get(obj, i));
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            System.out.println(obj);
        }
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;即完成了之前的遗留问题.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到此基本的反射应用总结到这里，最后附上全代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.javaenhance;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Array;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Constructor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; study.javaenhance.util.ReflectPoint;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReflectTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception 
    {
        String str &lt;/span&gt;= &quot;abc&quot;&lt;span&gt;;
        Class clz1 &lt;/span&gt;= String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        Class clz2 &lt;/span&gt;=&lt;span&gt; str.getClass();
        Class clz3 &lt;/span&gt;= Class.forName(&quot;java.lang.String&quot;&lt;span&gt;);
        System.out.println(clz1 &lt;/span&gt;==&lt;span&gt;  clz2);
        System.out.println(clz1 &lt;/span&gt;==&lt;span&gt;  clz3);
        getConstructor();
        
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成员变量的反射
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.首先我们先初始化一下ReflectPoint类的xy值,以便反射的时候获取其值&lt;/span&gt;
        ReflectPoint rp = &lt;span&gt;new&lt;/span&gt; ReflectPoint(2,4&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.要反射,后续加载类&lt;/span&gt;
        Field xField = rp.getClass().getDeclaredField(&quot;x&quot;&lt;span&gt;);
        xField.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.解析类&lt;/span&gt;
&lt;span&gt;        System.out.println(xField.get(rp));
        Field yField &lt;/span&gt;= ReflectPoint.&lt;span&gt;class&lt;/span&gt;.getField(&quot;y&quot;&lt;span&gt;);
        System.out.println(yField.get(rp));
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;案例:changeStringValue&lt;/span&gt;
&lt;span&gt;        System.out.println(rp);
        changeStringValue(rp);
        System.out.println(rp);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法的反射&lt;/span&gt;
        Method methodCharAt = String.&lt;span&gt;class&lt;/span&gt;.getMethod(&quot;charAt&quot;, &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        System.out.println(methodCharAt.invoke(str, &lt;/span&gt;1&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;兼容JDK5.0之前的写法&lt;/span&gt;
        System.out.println(methodCharAt.invoke(str, &lt;span&gt;new&lt;/span&gt; Object[]{2&lt;span&gt;}));
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用main方法,不采用TestArguments.main(new String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;}); 这种方式,因为有些场景我们的类是传入的是你运行期才知道的&lt;/span&gt;
        Class clazz = Class.forName(&quot;study.javaenhance.TestArguments&quot;&lt;span&gt;);
        Method method &lt;/span&gt;=  clazz.getMethod(&quot;main&quot;,String[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为main方法是静态方法,所以第一个参数传入的为null
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;method.invoke(null,new String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样拆开后就是main方法想要的参数了&lt;/span&gt;
        method.invoke(&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt; Object[]{&lt;span&gt;new&lt;/span&gt; String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&lt;span&gt;}});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样就是一个对象传入了,不需要拆了&lt;/span&gt;
        method.invoke(&lt;span&gt;null&lt;/span&gt;,(Object)&lt;span&gt;new&lt;/span&gt; String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&lt;span&gt;});
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组与Object的关系&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; [] a1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{1,2,3&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; [] a2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[4&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[][] a3 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[2][3&lt;span&gt;];
        String [] a4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&lt;span&gt;};
        
        System.out.println(a1.getClass() &lt;/span&gt;== a2.getClass());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(a1.getClass() == a4.getClass());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(a1.getClass() == a3.getClass());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
        System.out.println(a1.getClass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[I&lt;/span&gt;
        System.out.println(a1.getClass().getSuperclass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.Object&lt;/span&gt;
        System.out.println(a4.getClass().getSuperclass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.Object&lt;/span&gt;
&lt;span&gt;        
        Object aObj1 &lt;/span&gt;= a1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为a1 是一个int[] 类型的数组所以是object类型&lt;/span&gt;
        Object aObj2 = a4;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为a4 是一个String[]类型的数组所以是Object类型
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object[] aObj3 = a1;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错,因为a1 是一个int[]数组里面的元素都是int型,不是Object类型所以不可以如果改成包装类就可以&lt;/span&gt;
        Object[] aObj4 = a3; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a3 是一个二维数组,那么里面的一维数组就是一个Object类型,所以可以匹配Object[]代表里面每个元素类型为Object&lt;/span&gt;
        Object[] aObj5 = a4; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String[] 里面的每一个元素都是String类型，也是Object类型 所以可以匹配.&lt;/span&gt;
&lt;span&gt;        
        System.out.println(a1);
        System.out.println(a4);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Array应用&lt;/span&gt;
&lt;span&gt;        System.out.println(Arrays.asList(a1));
        System.out.println(Arrays.asList(a4));    
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写一个方法，传递一个参数，判断这个参数是一个数组，还是一个普通类型，如果是普通类型，我就直接把他打印出来。如果是数组，我们就遍历后把值打印出来&lt;/span&gt;
&lt;span&gt;        printObject(a1);
        
        printObject(a4);
        
        printObject(&lt;/span&gt;&quot;xyz&quot;&lt;span&gt;);
        
    }

    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printObject(Object obj)
    {
        Class clazz &lt;/span&gt;=&lt;span&gt; obj.getClass();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(clazz.isArray())
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是数组,利用数组的反射类Array类来进行相关操作&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; Array.getLength(obj);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;len;i++&lt;span&gt;){
                System.out.println(Array.get(obj, i));
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            System.out.println(obj);
        }
        
    }


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; changeStringValue(Object rp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;思路:1.反射获取要所有的成员变量  2.获取成员变量的类型判断是否为String类型 3.如果是则获取其值 4.替换 5.回填&lt;/span&gt;
        Field[] fields =&lt;span&gt; rp.getClass().getFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Field field : fields) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(field.getType() == String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
            {
                String oldValue &lt;/span&gt;=&lt;span&gt; (String) field.get(rp);
                String newValue &lt;/span&gt;= oldValue.replace(&quot;b&quot;, &quot;a&quot;&lt;span&gt;);
                field.set(rp, newValue);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 目前String 类型中有很多构造方法，我想要找到获取构造方法为StringBuffer类型的一个
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception 
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; SecurityException 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getConstructor() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SecurityException, Exception
    {
        String.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.getConstructor(StringBuffer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么上面的获取到构造方法有什么用呢？&lt;/span&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 通常，我们创建String 对象为 String abc = new String(new StringBuffer(&quot;abc&quot;)) 方式，
         * 下面我们通过反射来实现：
         *  1.加载类
         *  2.解析类
         *  
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Constructor constructor &lt;/span&gt;= String.&lt;span&gt;class&lt;/span&gt;.getConstructor(StringBuffer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        String str &lt;/span&gt;=  (String) constructor.newInstance(&lt;span&gt;new&lt;/span&gt; StringBuffer(&quot;abc&quot;&lt;span&gt;));
        System.out.println(str);
    }

}


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestArguments{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String arg : args){
            System.out.println(arg);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;参考资料：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;张孝祥Java基础增强&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 14:02:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/7659210.html</dc:identifier>
</item>
<item>
<title>从头编写 asp.net core 2.0 web api 基础框架 (4) EF配置 - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/7661805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/7661805.html</guid>
<description>&lt;p&gt;第1部分：&lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7637250.html&quot; target=&quot;_blank&quot;&gt; http://www.cnblogs.com/cgzl/p/7637250.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第2部分：&lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7640077.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/7640077.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第3部分：&lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7652413.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/7652413.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github源码地址：&lt;a href=&quot;https://github.com/solenovex/Building-asp.net-core-2-web-api-starter-template-from-scratch&quot; target=&quot;_blank&quot;&gt;https://github.com/solenovex/Building-asp.net-core-2-web-api-starter-template-from-scratch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前三部分弄完，我们已经可以对内存数据进行CRUD的基本操作，并且可以在asp.net core 2中集成Nlog了。&lt;/p&gt;
&lt;p&gt;下面继续：&lt;/p&gt;

&lt;p&gt;Entity Framework 是&lt;strong&gt;ORM（Object-Relational-Mapping）&lt;/strong&gt;。ORM是一种让你可以使用面向对象的范式对数据库进行查询和操作。&lt;/p&gt;
&lt;p&gt;简单的情况下，ORM可以把数据库中的表和Model对象一一映射起来；也有比较复杂的情况，ORM允许使用OO（面向对象）功能来做映射，例如：Person作为基类，Employee作为Person的派生类，他们俩可以在数据库中映射成一个表；或者在没有继承的情况下，数据库中的一个表可能和多个类有映射关系。&lt;/p&gt;
&lt;p&gt;EF Core 不是 EF6的升级版，这个大家应该知道，EF Core是轻量级、具有很好的扩展性的，并且是跨平台的EF版本。&lt;/p&gt;
&lt;p&gt;EF Core 目前有很多Providers，所以支持很多种数据库，包括：&lt;strong&gt;MSSQL，SQLite，SQL Compact，Postgres，MySql，DB2&lt;/strong&gt;等等。而且还有一个内存的Provider，用于测试和开发。开发UWP应用的时候也可以使用EF Core（用SQLite Provider）。&lt;/p&gt;
&lt;p&gt;EF Core支持两种模式：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Code First&lt;/strong&gt;&lt;/span&gt;：简单理解为 先写C#（Model），然后生成数据库。&lt;/p&gt;
&lt;p&gt;Database First：现在数据库中建立表，然后生成C#的Model。&lt;/p&gt;
&lt;p&gt;由于用asp.net core 2.0开发的项目基本都是新项目，所以建议使用Code First。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Entity&lt;/strong&gt;就是普通的C#类，就像Dto一样。Dto是与外界打交道的Model，entity则不一样，有一些Dto的计算属性我们并不像保存在数据库中，所以entity中没有这些属性；而数据从entity传递到Dto后某些属性也会和数据库里面的形式不一样。&lt;/p&gt;
&lt;p&gt;首先把我们原来的Product和Material这两个Dto的名字重构一下，改成ProductDto和MaterialDto。&lt;/p&gt;
&lt;p&gt;建立一个Entities文件夹，在里面建立Product.cs：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreBackend.Api.Entities
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;DbContext&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;EFCore使用一个&lt;strong&gt;&lt;span&gt;DbContext&lt;/span&gt;&lt;/strong&gt;和数据库打交道，它代表着和数据库之间的一个Session，可以用来查询和保存我们的entities。&lt;/p&gt;
&lt;p&gt;DbContext需要一个Provider，以便能访问数据库（这里我们就用LocalDB吧）。&lt;/p&gt;
&lt;p&gt;我们就建立一个DbContext吧（大一点的项目会使用多个DbContext）。建立MyContext并集成DbContext：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreBackend.Api.Entities
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContext : &lt;span&gt;DbContext&lt;/span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public DbSet&amp;lt;Product&amp;gt; Products { get; set&lt;/span&gt;&lt;span&gt;&lt;span&gt;; }&lt;/span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们为Product建立了一个类型为DbSet&amp;lt;T&amp;gt;的属性，它可以用来查询和保存实例（针对DbSet的Linq查询语句将会被解释成针对数据库的查询语句）。&lt;/p&gt;
&lt;p&gt;因为我们需要使用这个MyContext，所以就需要先在Container中注册它，然后就可以在依赖注入中使用了。&lt;/p&gt;
&lt;p&gt;打开Startup.cs，修改ConfigureServices，添加这一句话:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;services.AddDbContext&amp;lt;MyContext&amp;gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用AddDbContext这个Extension method为MyContext在Container中进行注册，它默认的生命周期使Scoped。&lt;/p&gt;
&lt;p&gt;但是它如何连接数据库？这就需要连接字符串，我们需要为DbContext提供连接字符串，这里有两种方式。&lt;/p&gt;
&lt;p&gt;第一种是在MyContext中override OnConfiguring这个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreBackend.Api.Entities
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Product&amp;gt; Products { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlServer(&quot;xxxx connection string&quot;);
            base&lt;/span&gt;&lt;span&gt;&lt;span&gt;.OnConfiguring(optionsBuilder);
        }&lt;/span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的参数optionsBuilder提供了一个UseSqlServer()这个方法，它告诉Dbcontext将会被用来连接Sql Server数据库，在这里就可以提供连接字符串，这就是第一种方法。&lt;/p&gt;
&lt;p&gt;第二种方法：&lt;/p&gt;
&lt;p&gt;先大概看一下DbContext的源码的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DbContext : IDisposable, IInfrastructure&amp;lt;IServiceProvider&amp;gt;&lt;span&gt;, IDbContextDependencies, IDbSetCache, IDbContextPoolable
    {
        &lt;/span&gt;&lt;span&gt;public DbContext([NotNullAttribute] DbContextOptions options);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有一个Constructor带有一个DbContextOptions参数，那我们就在MyContext种建立一个Constructor，并overload这个带有参数的Constructor。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreBackend.Api.Entities
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public MyContext(DbContextOptions&amp;lt;MyContext&amp;gt; options)
            :base(options)
        {
            
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Product&amp;gt; Products { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方法相对第一种的优点是：&lt;strong&gt;它可以在我们注册MyContext的时候就提供options&lt;/strong&gt;，显然这样做比第一种override OnConfiguring更合理。&lt;/p&gt;
&lt;p&gt;然后返回Startup：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; DEBUG&lt;span&gt;
            services.AddTransient&lt;/span&gt;&amp;lt;IMailService, LocalMailService&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;#else&lt;/span&gt;&lt;span&gt;
            services.AddTransient&lt;/span&gt;&amp;lt;IMailService, CloudMailService&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
            &lt;span&gt;var connectionString = @&quot;Server=(localdb)\MSSQLLocalDB;Database=ProductDB;Trusted_Connection=True&quot;;
            services.AddDbContext&amp;lt;MyContext&amp;gt;(o =&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; o.UseSqlServer(connectionString));&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用AddDbContext的另一个overload的方法，它可以带一个参数，在里面调用UseSqlServer。&lt;/p&gt;
&lt;p&gt;关于连接字符串，我是用的是LocalDb，实例名是MSSQLLocalDB。可以在命令行查询本机LocalDb的实例，使用sqllocaldb info：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013190723730-1696137737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以通过VS的Sql Server Object Explorer查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013190916277-1714870782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;连接字符串中的ProductDb是数据库名；连接字符串的最后一部分表示这是一个受信任的连接，也就是说使用了集成验证，在windows系统就是指windows凭证。&lt;/p&gt;
&lt;h2&gt;生成数据库&lt;/h2&gt;
&lt;p&gt;因为我们使用的是Code First，所以如果还没有数据库的话，它应该会自动建立一个数据库。&lt;/p&gt;
&lt;p&gt;打开MyContext：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; MyContext(DbContextOptions&amp;lt;MyContext&amp;gt;&lt;span&gt; options)
            :&lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options)
        {
            &lt;span&gt;Database.EnsureCreated();&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个Constructor在被依赖注入的时候会被调用，在里面写Database.&lt;strong&gt;EnsureCreated&lt;/strong&gt;()。其中Database是DbContext的一个属性对象。&lt;/p&gt;
&lt;p&gt;EnsureCreated()的作用是，如果有数据库存在，那么什么也不会发生。但是如果没有，那么就会创建一个数据库。&lt;/p&gt;
&lt;p&gt;但是现在就运行的话，并不会创建数据库，因为没有创建MyContext的实例，也就不会调用Constructor里面的内容。&lt;/p&gt;
&lt;p&gt;那我们就建立一个临时的Controller，然后注入MyContext，此时就调用了MyContext的Constructor：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreBackend.Api.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestController: Controller
    {
        &lt;/span&gt;&lt;span&gt;private MyContext _context;

        public TestController(MyContext context)
        {
            _context =&lt;/span&gt;&lt;span&gt;&lt;span&gt; context;
        }&lt;/span&gt;

        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用Postman访问Get这个Action后，我们可以从Debug窗口看见一些创建数据库和表的Sql语句：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013192334340-1591241491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们查看一下Sql Server Object Explorer:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013192503246-398811604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到数据库建立好了，里面还有dbo.Products这个表。&lt;/p&gt;
&lt;p&gt;Database.EnsureCreated()确实可以保证创建数据库，但是随着代码不断被编写，我们的Model不断再改变，数据库应该也随之改变，而EnsureCreated()就不够了，这就需要&lt;strong&gt;迁移（&lt;span&gt;Migration&lt;/span&gt;）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过迁移之前，我们先看看Product这个表的具体字段属性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013192848793-1490511744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Product的Id作为了主键，而Name这个字符串的长度是max，而Price没有精度限制，这样不行。我们需要对Model生成的表的字段进行限制！&lt;/p&gt;
&lt;p&gt;解释一下：Product这个entity中的Id，根据约定（Id或者ProductId）会被视为映射表的主键，并且该主键是自增的。&lt;/p&gt;
&lt;p&gt;如果不使用Id或者ProductId这两个名字作为主键的话，我们可以通过两种方式把该属性设置成为主键：Data Annotation注解和Fluet Api。我只在早期使用Data Annotation，后来一直使用Fluent Api，所以我这里只介绍Fluent Api吧。&lt;/p&gt;

&lt;p&gt;针对Product这个entity，我们要把它映射成一个数据库的表，所以针对每个属性，可能需要设定一些限制，例如最大长度，是否必填等等。&lt;/p&gt;
&lt;p&gt;针对Product，我们可以在MyContext里面&lt;strong&gt;override OnModelCreating&lt;/strong&gt;这个方法，然后这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity&amp;lt;Product&amp;gt;().HasKey(x =&amp;gt; x.Id);
            modelBuilder.Entity&amp;lt;Product&amp;gt;().Property(x =&amp;gt; x.Name).IsRequired().HasMaxLength(50);
            modelBuilder.Entity&amp;lt;Product&amp;gt;().Property(x =&amp;gt; x.Price).HasColumnType(&quot;decimal(8,2)&quot;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行表示设置Id为主键（其实我们并不需要这么做）。然后Name属性是必填的，而且最大长度是50。最后Price的精度是8，2，数据库里的类型为decimal。&lt;/p&gt;
&lt;p&gt;fluent api有很多方法，具体请查看文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/ef/core/modeling/&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/ef/core/modeling/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后，我们就会发现一个严重的问题。如果项目里面有很多entity，那么所有的fluent api配置都需要写在OnModelCreating这个方法里，那太多了。&lt;/p&gt;
&lt;p&gt;所以我们改进一下，使用&lt;span&gt;&lt;strong&gt;IEntityTypeConfiguration&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;/span&gt;。建立一个叫ProductConfiguration的类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProductConfiguration&lt;span&gt; : IEntityTypeConfiguration&amp;lt;Product&amp;gt;&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(EntityTypeBuilder&amp;lt;Product&amp;gt;&lt;span&gt; builder)
        {
            &lt;span&gt;builder.HasKey(x &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&amp;gt; x.Id);
            builder.Property(x =&amp;gt; x.Name).IsRequired().HasMaxLength(50);
            builder.Property(x =&amp;gt; x.Price).HasColumnType(&quot;decimal(8,2)&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把刚才在MyContext里写的配置都移动到这里，然后修改一些MyContext的OnModelCreating方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
           &lt;span&gt; modelBuilder.ApplyConfiguration(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; ProductConfiguration());&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是把ProductConfiguration里面写的配置加载进来，和之前的效果是一样的。&lt;/p&gt;
&lt;p&gt;但是项目中如果有很多entities的话也需要写很多行代码，更好的做法是写一个方法，可以加载所有实现了IEntityTypeConfiguration&amp;lt;T&amp;gt;的实现类。在老版的asp.net web api 2.2里面有一个方法可以从某个Assembly加载所有继承于EntityTypeConfiguration的类，但是entity framework core并没有提供类似的方法，以后我们自己写一个吧，现在先这样。&lt;/p&gt;
&lt;p&gt;然后把数据库删掉，重新生成一下数据库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013194848371-1040609538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很好！&lt;/p&gt;

&lt;p&gt;随着代码的更改，数据库也会跟着变，所有EnsureCreated()不满足要求。migration就允许我们把数据库从一个版本升级到另一个版本。那我们就研究一下，首先把数据库删了，然后创建第一个迁移版本。&lt;/p&gt;
&lt;p&gt;打开Package Manager Console，做个迁移 &lt;strong&gt;&lt;span&gt;Add-Migration&lt;/span&gt;&lt;/strong&gt; xxx：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013195943324-1235124736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Add-Migration 然后接着是一个你起的名字。&lt;/p&gt;
&lt;p&gt;然后看一下VS的Solution Explorer 会发现生成了一个Migrations目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013200142434-890873419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面有两个文件，一个是Snapshot，它是目前entity的状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreBackend.Api.Migrations
{
    [DbContext(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MyContext))]
    &lt;/span&gt;&lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContextModelSnapshot : ModelSnapshot
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BuildModel(ModelBuilder modelBuilder)
        {
&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; warning disable 612, 618&lt;span&gt;
            modelBuilder
                .HasAnnotation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProductVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.0.0-rtm-26452&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .HasAnnotation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServer:ValueGenerationStrategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, SqlServerValueGenerationStrategy.IdentityColumn);

            modelBuilder.Entity(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CoreBackend.Api.Entities.Product&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b =&amp;gt;&lt;span&gt;
                {
                    b.Property&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        .ValueGeneratedOnAdd();

                    b.Property&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        .IsRequired()
                        .HasMaxLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);

                    b.Property&lt;/span&gt;&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        .HasColumnType(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;decimal(8,2)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    b.HasKey(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    b.ToTable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Products&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                });
&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; warning restore 612, 618&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是当前Product这个Model的状态细节，包括我们通过Fluent Api为其添加的映射限制等。&lt;/p&gt;
&lt;p&gt;另一个文件是xxxx_ProductInfoDbInitialMigration，下划线后边的部分就是刚才Add-Migration命令后边跟着的名字参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreBackend.Api.Migrations
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductInfoDbInitialMigration : Migration
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Products&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                columns: table &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                {
                    Id &lt;/span&gt;= table.Column&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(type: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, nullable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                        .Annotation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SqlServer:ValueGenerationStrategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, SqlServerValueGenerationStrategy.IdentityColumn),
                    Name &lt;/span&gt;= table.Column&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(type: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nvarchar(50)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, maxLength: &lt;span&gt;50&lt;/span&gt;, nullable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;),
                    Price &lt;/span&gt;= table.Column&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(type: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;decimal(8,2)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, nullable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                },
                constraints: table &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    table.PrimaryKey(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PK_Products&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x =&amp;gt;&lt;span&gt; x.Id);
                });
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Products&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面包含着migration builder需要的代码，用来迁移这个版本的数据库。里面有Up方法，就是从当前版本升级到下一个版本；还有Down方法，就是从下一个版本再退回到当前版本。&lt;/p&gt;
&lt;p&gt;我们也可以不使用 Add-Migration命令，手写上面这些代码也行，我感觉还是算了吧。&lt;/p&gt;
&lt;p&gt;另外还有一件事，那就是要保证迁移migration都有效的应用于数据库了，那就是另一个命令 &lt;strong&gt;&lt;span&gt;Update-Database&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先等一下，我们也可以使用代码来达到同样的目的，打开MyContext：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; MyContext(DbContextOptions&amp;lt;MyContext&amp;gt;&lt;span&gt; options)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options)
        {
            &lt;span&gt;Database.Migrate();&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把之前的EnsureCreated改成Database.Migrate(); 如果数据库还没删除，那就最后删除一次。&lt;/p&gt;
&lt;p&gt;运行，并除法TestController：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013203405449-1725661554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后会看见Product表，除此之外还有一个__EFMigrationHistory表，看看有啥：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013203508012-629074399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个表里面保存了哪些迁移已经被应用于这个数据库了。这也保证了Database.Migrate()或者Update-database命令不会执行重复的迁移migration。&lt;/p&gt;
&lt;p&gt;我们再弄个迁移，为Product添加一个属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreBackend.Api.Entities
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public string Description { get; set&lt;/span&gt;&lt;span&gt;&lt;span&gt;; }&lt;/span&gt;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProductConfiguration : IEntityTypeConfiguration&amp;lt;Product&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(EntityTypeBuilder&amp;lt;Product&amp;gt;&lt;span&gt; builder)
        {
            builder.HasKey(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Id);
            builder.Property(x &lt;/span&gt;=&amp;gt; x.Name).IsRequired().HasMaxLength(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
            builder.Property(x &lt;/span&gt;=&amp;gt; x.Price).HasColumnType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;decimal(8,2)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;span&gt;builder.Property(x &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&amp;gt; x.Description).HasMaxLength(200&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013203827262-892501701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行Add-Migration后，会在Migrations目录生成了一个新的文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreBackend.Api.Migrations
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AddDescriptionToProduct : Migration
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(
                name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                table: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Products&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nvarchar(200)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                maxLength: &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;,
                nullable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                table: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Products&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后这次执行Update-Database命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013203925934-447721279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加上verbose参数就是显示执行过程的明细而已。&lt;/p&gt;
&lt;p&gt;不用运行，看看数据库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013204206465-979720444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Description被添加上了，然后看看迁移表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013204231449-1915084937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前差不太多了，但还有一个安全隐患。它是：&lt;/p&gt;

&lt;p&gt;保存连接字符串，你可能会想到appSettings.json，但这不是一个好的想法。在本地开发的时候还没有什么问题（使用的是集成验证），但是你要部署到服务器的时候，数据库连接字符串可能包括用户名和密码（Sql Server的另一种验证方式）。加入你不小心把appSettings.json或写到C#里面的连接字符串代码提交到了Git或TFS，那么这个用户名和密码包括服务器的名称可能就被暴露了，这样做很不安全。&lt;/p&gt;
&lt;p&gt;我们可以这样做，首先针对开发环境（development environment）把C#代码中的连接字符串拿掉，把它放到appSettings.json里面。然后针对正式生产环境（production environment），我们使用环境变量来保存这些敏感数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发环境：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;appSettings.json:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;mailSettings&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;mailToAddress&quot;: &quot;admin__json@qq.com&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;mailFromAddress&quot;: &quot;noreply__json@qq.com&quot;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;connectionStrings&quot;: {
    &quot;productionInfoDbConnectionString&quot;: &quot;Server=(localdb)\\MSSQLLocalDB;Database=ProductDB;Trusted_Connection=True&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
  }&lt;/span&gt; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Startup.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        public &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
#&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; DEBUG
            services.AddTransient&lt;/span&gt;&amp;lt;IMailService, LocalMailService&amp;gt;&lt;span&gt;();
#&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            services.AddTransient&lt;/span&gt;&amp;lt;IMailService, CloudMailService&amp;gt;&lt;span&gt;();
#endif
            &lt;/span&gt;&lt;span&gt;var connectionString = Configuration[&quot;connectionStrings:productionInfoDbConnectionString&quot;];
            services.AddDbContext&amp;lt;MyContext&amp;gt;(o =&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; o.UseSqlServer(connectionString));&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后你可以设断点看看connectionString的值。目前项目的环境变量是Production，先改成Development：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013205711168-925609026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后断点调试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013210021871-599230830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这两个JsonConfigurationProvider就是appSettings的两个文件的配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013210025496-925955560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就是appSettings.json，里面包含着我们刚才添加的连接字符串。&lt;/p&gt;
&lt;p&gt;由于当前是Development环境，所以如果你查看另外一个JsonConfigurationProvider的话，会发现它里面的值是空的（Data数是0）.&lt;/p&gt;
&lt;p&gt;所以没有问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产环境：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在项目的属性--Debug里面，我们看到了环境变量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013210501980-2122405917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而这个环境变量，我们可以在程序中读取出来，所以可以在这里添加连接字符串：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013211006730-1483886114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意它的key，要和appSettings.json里面的整体结构一致；Value呢应该是给一个服务器的数据库的字符串，这里就随便弄个假的吧。别忘了把Development改成Production。&lt;/p&gt;
&lt;p&gt;然后调试一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013211133184-945242120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错。如果你仔细调试一下看看的话：就会从EnvironmentVariablesConfigurationProvider的第64个找到我们刚才写到连接字符串：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013211400637-1624420579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是还没完。&lt;/p&gt;
&lt;p&gt;打开项目的launchSettings.json：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013211547746-190067103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你会发现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;iisSettings&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;windowsAuthentication&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;anonymousAuthentication&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;iisExpress&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;applicationUrl&quot;: &quot;http://localhost:60835/&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;sslPort&quot;: 0&lt;span&gt;
    }
  },
  &lt;/span&gt;&quot;profiles&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;IIS Express&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;commandName&quot;: &quot;IISExpress&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;launchBrowser&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;environmentVariables&quot;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;connectionStrings:productionInfoDbConnectionString&quot;: &quot;Server=.;Database=ProductDB;UserId=sa;Password=pass;&quot;,
        &lt;/span&gt;&quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Production&quot;&lt;span&gt;
      }
    },
    &lt;/span&gt;&quot;CoreBackend.Api&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;commandName&quot;: &quot;Project&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;launchBrowser&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;environmentVariables&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;&lt;span&gt;
      },
      &lt;/span&gt;&quot;applicationUrl&quot;: &quot;http://localhost:60836/&quot;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;连接字符串在这里。这个文件一般都会源码控制给忽略，也不会在发布的时候发布到服务器。那么服务器怎么读取到这个连接字符串呢？？？&lt;/p&gt;
&lt;p&gt;看上面调试EnvironmentVariablesConfigurationProvider的值，会发现里面有几十个变量，这些基本都不是来自launchSettings.json，它们是从系统层面上定义的！！&lt;/p&gt;
&lt;p&gt;这回我们这样操作：&lt;/p&gt;
&lt;p&gt;把launchSettings里面的连接字符串去掉：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;iisSettings&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;windowsAuthentication&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;anonymousAuthentication&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;iisExpress&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;applicationUrl&quot;: &quot;http://localhost:60835/&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;sslPort&quot;: 0&lt;span&gt;
    }
  },
  &lt;/span&gt;&quot;profiles&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;IIS Express&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;commandName&quot;: &quot;IISExpress&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;launchBrowser&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;environmentVariables&quot;&lt;span&gt;: {&lt;/span&gt;&quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Production&quot;&lt;span&gt;
      }
    },
    &lt;/span&gt;&quot;CoreBackend.Api&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;commandName&quot;: &quot;Project&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;launchBrowser&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;environmentVariables&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;&lt;span&gt;
      },
      &lt;/span&gt;&quot;applicationUrl&quot;: &quot;http://localhost:60836/&quot;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后这里自然也就没有了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013212116637-616006937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在任何json文件都没有敏感信息了。&lt;/p&gt;
&lt;p&gt;现在我们要把连接字符串添加到系统变量中。&lt;/p&gt;
&lt;p&gt;在win10搜索框输入 envi：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013212419996-1523003106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击上面的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013212435465-1310066343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击环境变量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013212445340-126315671.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面上边是用户的变量，下面是系统的变量，这就是刚才EnvironmentVariableConfigurationProvider里面调试出来的那一堆环境变量。&lt;/p&gt;
&lt;p&gt;而这个地方就是在你应该服务器上添加连接字符串的地方。再看一下调试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013212817496-1645880107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Environment的Provider在第4个位置，appSettings.production.json的在第3个位置。也就是说如果appSettings.Product.json和系统环境变量都有一样Key的连接字符串，那么程序会选择系统环境变量的值，因为它是后边的配置会覆盖前边的配置。&lt;/p&gt;
&lt;p&gt;在系统环境变量中添加：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013213158762-339922065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后调试运行（需要重启VS，以便新添加的系统环境变量生效）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013213454668-1812381282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，没问题！&lt;/p&gt;

&lt;p&gt;目前EF Core还没有内置的方法来做种子数据。那么自己写：&lt;/p&gt;
&lt;p&gt;建立一个MyContextExtensions.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreBackend.Api.Entities
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContextExtensions
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; EnsureSeedDataForContext(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; MyContext context)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (context.Products.Any())
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; products = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Product&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product
                {
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;牛奶&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Price &lt;/span&gt;= &lt;span&gt;2.5f&lt;/span&gt;&lt;span&gt;,
                    Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是牛奶啊&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product
                {
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;面包&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Price &lt;/span&gt;= &lt;span&gt;4.5f&lt;/span&gt;&lt;span&gt;,
                    Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是面包啊&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product
                {
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;啤酒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Price &lt;/span&gt;= &lt;span&gt;7.5f&lt;/span&gt;&lt;span&gt;,
                    Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是啤酒啊&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            };
            context.Products.AddRange(products);
            context.SaveChanges();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是个Extension method，如果数据库没有数据，那就弄点种子数据，AddRange可以添加批量数据到Context（被Context追踪），但是到这还没有插入到数据库。使用SaveChanges会把数据保存到数据库。&lt;/p&gt;
&lt;p&gt;然后再Startup的Configure方法中调用这个method：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory,
            &lt;span&gt;MyContext myContext&lt;/span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; loggerFactory.AddProvider(new NLogLoggerProvider());&lt;/span&gt;
&lt;span&gt;            loggerFactory.AddNLog();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseExceptionHandler();
            }

           &lt;span&gt; myContext.EnsureSeedDataForContext();&lt;/span&gt;

            app.UseStatusCodePages();

            app.UseMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先注入MyContext，然后调用这个extension method。&lt;/p&gt;
&lt;p&gt;然后把系统环境变量中的连接字符串删了把，并且把项目属性Debug中改成Development，这时候需要重启VS，因为一般环境变量是在软件启动的时候附加到其内存的，软件没关的情况下如果把系统环境变量给删了，在软件的内存中应该还是能找到该环境变量，所以软件得重启才能获取最新的环境变量们。重启VS，并运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171013214946543-962068912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;种子数据进去了！&lt;/p&gt;

&lt;p&gt;先写到这吧!!!!&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 13:54:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/7661805.html</dc:identifier>
</item>
<item>
<title>由支付宝抄袭想到的 - alexander.bruce.lee</title>
<link>http://www.cnblogs.com/accipiter/p/7663385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/accipiter/p/7663385.html</guid>
<description>&lt;p&gt;　　支付宝小程序抄袭事件，已经过去一段时间了,有些人还在臆测，如果支付宝不抄袭，你们知道支付宝搞了个小程序？即使如此，可是，现在写代码的程序员的水平有没有提升了？抄袭是不是还是第一生产力了？毫无疑问的是，做事的第一反映是快速的抄袭，这样能够很快的实现别人很久才实现的事情，或者稍微动动思想，那么就能做的更好，不是有描述某家的名言“一直在抄袭，从未被告倒！”。越抄越好！&lt;/p&gt;
&lt;p&gt;　　这个事情对于我最多的感悟，不是抄袭。倒是时代的淘汰，大家都知道10年左右兴起的移动互联网，一群人都奔移动开发去了，后来的大数据，各个公司都在大谈特谈大数据。还有马云一直高呼的DT时代，一群人都去做大数据开发了。这才几年的光景，那些都已经成为了历史，而今兴起的AI、是人工智能，不管是工作的、还是学生，好像大家生来都是搞人工智能的。哎，时代的发展，对于个人来说，个人是那么的渺小和随波逐流！即使马云，即使顶级公司，也是如此！&lt;/p&gt;
&lt;p&gt;　　这半年，我看了某top学校的教务系统，根据一个四六级漏洞拿到了全校学生的某些信息。系统一个烂字了得！&lt;/p&gt;
&lt;p&gt;　　这半年，我根据某公司后台系统，拿到了某些关键信息。他们程序员还在惊诧好多事情搞不定～。系统一个烂字了得！&lt;/p&gt;
&lt;p&gt;　　这半年，我根据某大型移动社交，拿到了用户的信息。软件一个烂字了得！&lt;/p&gt;
&lt;p&gt;　　这半年，我根据某大型移动新闻APP，拿到了各种评论等数据。软件一个烂字了得！&lt;/p&gt;
&lt;p&gt;　　……&lt;/p&gt;
&lt;p&gt; 　　就软件都做成这样的，大家还都在搞什么人工智能，等等！听起来很牛逼，很高大上的东西，实际代码拿出来，就是一个“烂”字。&lt;/p&gt;
&lt;p&gt;　　当然，每当，我回头去看自己的代码，也是觉得自己的代码一个烂字了得。&lt;/p&gt;
&lt;p&gt;　　当然，有时候我也去向人工智能转！&lt;/p&gt;
&lt;p&gt;　　时代发展的齿轮，不是一个螺丝钉能左右的！&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 13:29:00 +0000</pubDate>
<dc:creator>alexander.bruce.lee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/accipiter/p/7663385.html</dc:identifier>
</item>
</channel>
</rss>