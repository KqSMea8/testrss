<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>面向对象实现多图轮播效果 - 夜色中的烟雨楼</title>
<link>http://www.cnblogs.com/developerL/p/moreBanner.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/developerL/p/moreBanner.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; move(obj,mjson,time,callback,cv){
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;     cv = cv || 'linear'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; startVal=&lt;span&gt;{};
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; endVal=&lt;span&gt;{};
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; mjson){
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         startVal[key]=&lt;span&gt;parseInt(getStyle(obj,key));
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         endVal[key]=&lt;span&gt;parseInt(mjson[key]);
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; startTime=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     
&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;alert(typeof startVal);&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(startVal);&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; timer=setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; t=&lt;span&gt;new&lt;/span&gt; Date()-startTime;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;经过了多长时间                   &lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; d=time;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;持续时间&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;         
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(t&amp;gt;=&lt;span&gt;d){
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             t=&lt;span&gt;d;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;            clearInterval(timer);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; mjson){
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; b=startVal[key];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始值&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; c=endVal[key]-b;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;变化量&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; s=&lt;span&gt;Tween[cv](t,b,c,d);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             obj.style[key]=s+&quot;px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(t==&lt;span&gt;d){
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;             callback &amp;amp;&amp;amp;&lt;span&gt; callback.call(obj);
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;obj.style[attr]=s+&quot;px&quot;;&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(obj.style[attr]);&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;     },13&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取样式方法（对于IE和非IE浏览器做了兼容）&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getStyle(obj,attr){
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; obj.currentStyle?&lt;span&gt;obj.currentStyle[attr]:getComputedStyle(obj)[attr];
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; Tween =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    t:当前时间
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    b:初始值
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    c:变化量
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;    d:持续时间
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;     linear: &lt;span&gt;function&lt;/span&gt; (t, b, c, d){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;匀速&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; c*t/d + b;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;     easeIn: &lt;span&gt;function&lt;/span&gt;(t, b, c, d){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加速曲线&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; c*(t/=d)*t + b;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     easeOut: &lt;span&gt;function&lt;/span&gt;(t, b, c, d){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;减速曲线&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -c *(t/=d)*(t-2) + b;
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     easeBoth: &lt;span&gt;function&lt;/span&gt;(t, b, c, d){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加速减速曲线&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((t/=d/2) &amp;lt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; c/2*t*t + b;
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -c/2 * ((--t)*(t-2) - 1) + b;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     easeInStrong: &lt;span&gt;function&lt;/span&gt;(t, b, c, d){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加加速曲线&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; c*(t/=d)*t*t*t + b;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     easeOutStrong: &lt;span&gt;function&lt;/span&gt;(t, b, c, d){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;减减速曲线&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -c * ((t=t/d-1)*t*t*t - 1) + b;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     easeBothStrong: &lt;span&gt;function&lt;/span&gt;(t, b, c, d){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加加速减减速曲线&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((t/=d/2) &amp;lt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; c/2*t*t*t*t + b;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -c/2 * ((t-=2)*t*t*t - 2) + b;
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     elasticIn: &lt;span&gt;function&lt;/span&gt;(t, b, c, d, a, p){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正弦衰减曲线（弹动渐入）&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t === 0&lt;span&gt;) { 
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; b; 
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ( (t /= d) == 1 ) {
&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; b+&lt;span&gt;c; 
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;p) {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             p=d*0.3&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!a || a &amp;lt;&lt;span&gt; Math.abs(c)) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             a =&lt;span&gt; c; 
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; s = p/4;
&lt;span&gt; 86&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; s = p/(2*Math.PI) * Math.asin (c/&lt;span&gt;a);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;     elasticOut: &lt;span&gt;function&lt;/span&gt;(t, b, c, d, a, p){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正弦增强曲线（弹动渐出）&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t === 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ( (t /= d) == 1 ) {
&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; b+&lt;span&gt;c;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;p) {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             p=d*0.3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!a || a &amp;lt;&lt;span&gt; Math.abs(c)) {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             a =&lt;span&gt; c;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; s = p / 4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; s = p/(2*Math.PI) * Math.asin (c/&lt;span&gt;a);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;    },    
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;     elasticBoth: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(t, b, c, d, a, p){
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t === 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ( (t /= d/2) == 2&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; b+&lt;span&gt;c;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;p) {
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;             p = d*(0.3*1.5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ( !a || a &amp;lt;&lt;span&gt; Math.abs(c) ) {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;             a =&lt;span&gt; c; 
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; s = p/4;
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; s = p/(2*Math.PI) * Math.asin (c/&lt;span&gt;a);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t &amp;lt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; - 0.5*(a*Math.pow(2,10*(t-=1)) * 
&lt;span&gt;128&lt;/span&gt;                     Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; a*Math.pow(2,-10*(t-=1)) * 
&lt;span&gt;131&lt;/span&gt;                 Math.sin( (t*d-s)*(2*Math.PI)/p )*0.5 + c + b;
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;     backIn: &lt;span&gt;function&lt;/span&gt;(t, b, c, d, s){     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回退加速（回退渐入）&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; s == 'undefined'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;         s = 1.70158&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; c*(t/=d)*t*((s+1)*t - s) + b;
&lt;span&gt;138&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;     backOut: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(t, b, c, d, s){
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; s == 'undefined'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             s = 3.70158;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回缩的距离&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
&lt;span&gt;144&lt;/span&gt; &lt;span&gt;    }, 
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;     backBoth: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(t, b, c, d, s){
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; s == 'undefined'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;             s = 1.70158&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((t /= d/2 ) &amp;lt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
&lt;span&gt;151&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
&lt;span&gt;153&lt;/span&gt; &lt;span&gt;    },
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;     bounceIn: &lt;span&gt;function&lt;/span&gt;(t, b, c, d){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹球减振（弹球渐出）&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; c - Tween['bounceOut'](d-t, 0, c, d) +&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;    },       
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;     bounceOut: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(t, b, c, d){
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((t/=d) &amp;lt; (1/2.75&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; c*(7.5625*t*t) +&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (t &amp;lt; (2/2.75)) {
&lt;span&gt;161&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b;
&lt;span&gt;162&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (t &amp;lt; (2.5/2.75)) {
&lt;span&gt;163&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b;
&lt;span&gt;164&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b;
&lt;span&gt;166&lt;/span&gt; &lt;span&gt;    },      
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;     bounceBoth: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(t, b, c, d){
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t &amp;lt; d/2) {
&lt;span&gt;169&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Tween['bounceIn'](t*2, 0, c, d) * 0.5 +&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Tween['bounceOut'](t*2-d, 0, c, d) * 0.5 + c*0.5 +&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; };
&lt;/pre&gt;</description>
<pubDate>Sat, 22 Sep 2018 07:34:00 +0000</pubDate>
<dc:creator>夜色中的烟雨楼</dc:creator>
<og:description>面向对象写轮播</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/developerL/p/moreBanner.html</dc:identifier>
</item>
<item>
<title>Office加载项对Excel进行读写操作 - AlvinNiu</title>
<link>http://www.cnblogs.com/alvin-niu/p/9690179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alvin-niu/p/9690179.html</guid>
<description>&lt;p&gt;转载自我的&lt;a href=&quot;https://alvin.onloading.cn/2018/09/22/office-web-range/&quot;&gt;个人主页&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在开发ExcelWeb插件的时候，一大亮点就是可以在web项目中操作Excel，读取Excel的内容，也可以将服务端的数据写入的 Excel中，大大方便的用户使用Excel，提高工作效率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ranges&quot;&gt;Ranges&lt;/h2&gt;
&lt;p&gt;Ranges表示Excel的区域，例如一个单元格的区域是=A1,多个单元格的区域，B1:B4表示连续的4个单元格，对Excel 内容的读写，即是对Ranges的读写。&lt;/p&gt;
&lt;h3 id=&quot;ranges的属性&quot;&gt;Ranges的属性&lt;/h3&gt;
&lt;ul readability=&quot;-0.96681922196796&quot;&gt;&lt;li&gt;address，表示Ranges的地址，例如：A1，B1:B4&lt;/li&gt;
&lt;li&gt;values,二维数组，表示区域的实际值&lt;/li&gt;
&lt;li&gt;texts,二维数组，表示区域的展示值&lt;/li&gt;
&lt;li&gt;formulas,二维数组，表示区域的公式，excel可以使用公式，使用之后，看到的值是公式计算之后的值，如果想要知道使用了那些公式，就需要使用formulas属性&lt;/li&gt;
&lt;li&gt;format，区域的字体格式，可以该表文字字体，颜色，也可以改变区域的背景色。&lt;/li&gt;
&lt;li readability=&quot;0.93062200956938&quot;&gt;
&lt;p&gt;numberFormat,二维数组，区域的格式，有文本、日期、数值等，和Excel右击设置单元格的格式里所有的格式一致&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.6847826086957&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;General&lt;/td&gt;
&lt;td&gt;General&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Currency&lt;/td&gt;
&lt;td&gt;$#,##0.00;[Red]$#,##0.00&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Accounting&lt;/td&gt;
&lt;td&gt;&lt;em&gt;($* #,##0.00&lt;/em&gt;);&lt;em&gt;($* (#,##0.00);&lt;/em&gt;($* &quot;-&quot;??&lt;em&gt;);&lt;/em&gt;(@_)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;m/d/yy&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Time&lt;/td&gt;
&lt;td&gt;[$-F400]h:mm:ss am/pm&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Percentage&lt;/td&gt;
&lt;td&gt;0.00%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Fraction&lt;/td&gt;
&lt;td&gt;# ?/?&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Scientific&lt;/td&gt;
&lt;td&gt;0.00E+00&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Text&lt;/td&gt;
&lt;td&gt;@&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Special&lt;/td&gt;
&lt;td&gt;;;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Custom&lt;/td&gt;
&lt;td&gt;#,##0_);&lt;a href=&quot;http://www.cnblogs.com/alvin-niu/p/9690179.html#,%23%230&quot;&gt;Red&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;0.42424242424242&quot;&gt;&lt;td&gt;来源&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://stackoverflow.com/questions/20648149/what-are-numberformat-options-in-excel-vba&quot;&gt;Stack Overflow上的回答&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;ranges的方法&quot;&gt;Ranges的方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;load(),表示接下来你要使用哪个属性，需要在此处表明，例如，你要使用address，则 range.load('address')。&lt;/li&gt;
&lt;li&gt;clear(),清空该区域&lt;/li&gt;
&lt;li&gt;delete(),删除该区域，并指定是否需要下面的值上移，或者右面的值左移，参数枚举值如下：
&lt;ul&gt;&lt;li&gt;Excel.DeleteShiftDirection.up:删除后，下面的值，向上移动填充空值&lt;/li&gt;
&lt;li&gt;Excel.DeleteShiftDirection.left:删除后，右面的值，向左移动填充空值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;select()，选中该区域&lt;/li&gt;
&lt;li&gt;copyFrom(),将指定区域的值复制给当前区域&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;具体用法&quot;&gt;具体用法&lt;/h3&gt;
&lt;p&gt;准备工作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先在vue中要安装excel-addin&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;npm install excel-addin --save&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在index.html中假如office.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;  &amp;lt;script src=&quot;https://appsforoffice.microsoft.com/lib/1/hosted/office.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果想要在Excel初始化时做些什么，还需要在main.js中假如下面的代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;const Office = window.Office
Office.initialize = () =&amp;gt; {
    //初始化内容
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;操作Excel的行为均要写在特定方法里，即：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//其中context表示Excel的上下文，操作Excel的东西均通过该参数
 Excel.run(function(context) {
     //此处写操作Excel的方法
     //处理完之后要提交，Excel才会识别，另外所有的//读写数据的操作均在，
     //context.sync().then(=&amp;gt;{
         //此处读写数据
     })
     return context.sync()
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;写入&quot;&gt;写入&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    write: function() {
      Excel.run(function(context) {
        //获取指定名字的工作薄sheet
        // var sheet = context.workbook.worksheets.getItem('sheetName')
        //获取当前活动工作薄
        var sheet = context.workbook.worksheets.getActiveWorksheet()
        var data = [
          ['Product', 'Qty', 'Unit Price', 'Total Price'],
          ['Almonds', '2', '7.5', '15'],
          ['Coffee', '1', '34.5', '34.5'],
          ['Chocolate', '5', '9.56', '47.8'],
          ['', '', '', '97.3']
        ]
        //此二维数组的长度要和数据的保持一致，否则无效
        var formats = [
          ['@', '@', '@', '@'], //设置格式为文本
          ['0.00', '0.00', '0.00', '0.00'],
          ['0.00', '0.00', '0.00', '0.00'],
          ['0.00', '0.00', '0.00', '0.00'],
          ['0.00', '0.00', '0.00', '0.00']
        ]

        var range = sheet.getRange('A1:D5')
        //选中该区域
        range.select()
        // 设置背景色和字体
        range.format.fill.color = '#4472C4'
        range.format.font.color = 'white'
        //设置区域的格式
        range.numberFormat = formats

        //表示加载values属性，如果不加载在下面是不可以使用的
        range.load('values')

        return context.sync().then(function() {
          //写入方法必须在该方法内执行才有效
          range.values = data
        })
      }).catch(_this.errorHandler)
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;读取数据&quot;&gt;读取数据&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;read: function() {
      let _this = this
      Excel.run(function(context) {
        //获取指定名字的工作薄sheet
        // var sheet = context.workbook.worksheets.getItem('sheetName')
        // 获取当前选中的单元格
        var range = context.workbook.getSelectedRange()
        //获取当前选中的单元格
        //表示加载以下属性，如果不加载在下面是不可以使用的
        range.load('values')
        range.load('address')
        range.load('formulas')
        range.load('text')

        return context.sync().then(function() {
          //写入方法必须在该方法内执行才有效
          _this.content = {
            values: range.values,
            formulas: range.formulas,
            address: range.address,
            texts: range.text
          }
          console.log(_this.content)
        })
      }).catch(_this.errorHandler)
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除某一行数据&quot;&gt;删除某一行数据&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;deleteOne: function() {
      let _this = this
      Excel.run(function(context) {
        //获取指定名字的工作薄sheet
        // var sheet = context.workbook.worksheets.getItem('sheetName')
        // 获取当前选中的单元格
        var sheet = context.workbook.worksheets.getActiveWorksheet()
        var range = sheet.getRange('A2:D2')
        range.delete(Excel.DeleteShiftDirection.up)
        //提交操作
        return context.sync()
      }).catch(_this.errorHandler)
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;清空所有数据&quot;&gt;清空所有数据&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;clear: function() {
      let _this = this
      Excel.run(function(context) {
        //获取指定名字的工作薄sheet
        // var sheet = context.workbook.worksheets.getItem('sheetName')
        // 获取当前选中的单元格
        var sheet = context.workbook.worksheets.getActiveWorksheet()
        var range = sheet.getRange('A1:D4')
        range.clear()
        //提交操作
        return context.sync()
      }).catch(_this.errorHandler)
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/office/dev/add-ins/excel/excel-add-ins-ranges#delete-a-range-of-cells&quot;&gt;Excel JavaScrip API&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;项目地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/AlvinNiu/ExcelWebAddInDemo&quot;&gt;项目链接&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Sat, 22 Sep 2018 07:18:00 +0000</pubDate>
<dc:creator>AlvinNiu</dc:creator>
<og:description>转载自我的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alvin-niu/p/9690179.html</dc:identifier>
</item>
<item>
<title>npm包的更新说明，你还敢不看吗 - 潇湘待雨</title>
<link>http://www.cnblogs.com/pqjwyn/p/9690130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pqjwyn/p/9690130.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;平时工作少不了依赖一些第三方的npm包，站在各位大牛的肩膀上来更好的写bug，此外还可以学习各位大佬们的各种设计思路和优雅实现。不过npm包虽好，但使用之前也要多加甄别，特别是相同包的不同版本之间的差别，可能一不小心，原本用的飞起的轮子就会让我们笑不出来。下面用两次惨痛的线上问题来给大家提个醒。&lt;/p&gt;
&lt;h2 id=&quot;版本依赖符号&quot;&gt;版本依赖符号&lt;/h2&gt;
&lt;p&gt;在描述问题之前，先谈一下npm的包管理控制。&lt;br/&gt;假设我们依赖一个npm包 a 常见的依赖符号有下面这么几种&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
&quot;dependencies&quot;: {
  &quot;a&quot;:&quot;5.6.1&quot;,
  &quot;a&quot;:&quot;&amp;gt;=5.6.1&quot;,
  &quot;a&quot;:&quot;&amp;gt;5.6.1&quot;,
  &quot;a&quot;:&quot;&amp;lt;=5.6.1&quot;,
  &quot;a&quot;:&quot;&amp;lt;5.6.1&quot;,
  &quot;a&quot;:&quot;~5.6.1&quot;,
  &quot;a&quot;:&quot;^5.6.1&quot;
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们安装的npm包依赖有大概下面这么几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;version 匹配具体版本 例如：a:5.6.1&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;|&amp;gt;=|&amp;lt;|&amp;lt;= version 大于或者小于5.6.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;~version 大致相当于当前版本 即 5.6.X 均可以 5.7.1不可以&lt;/li&gt;
&lt;li&gt;^version 兼容版本 兼容的是中间的版本，例如5.7.X不包括 6.X.X&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/npm/node-semver&quot;&gt;详细区别请查看&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;根据上面的安装标识，npm会默认去拉去符合规定的最新版本。&lt;/strong&gt;&lt;br/&gt;当我们执行npm i 时 默认的版本依赖关系是&quot;a&quot;:&quot;^5.6.1&quot;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;npm i a -s //默认安装的依赖符号是 &quot;a&quot;:&quot;^5.6.1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是npm的版本控制规范，有规范也要我们去遵循才可以生效。&lt;/p&gt;
&lt;h3 id=&quot;开发者版本控制&quot;&gt;开发者版本控制&lt;/h3&gt;
&lt;p&gt;我们发布npm包的时候，版本标识是package.json中的version&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&quot;version&quot;: &quot;0.0.1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说对于测试版本，都是0.X.X的版本(当然也可以有例外，例如react，最高到0.14.X，突然来了个15.X.X)&lt;br/&gt;成熟版本会从1.X.X开始。&lt;br/&gt;如果有bug或者功能更新的时候，可不能随便更新，要根据对使用者的影响程度来进行版本更新。&lt;/p&gt;
&lt;h4 id=&quot;版本更新策略&quot;&gt;版本更新策略&lt;/h4&gt;
&lt;p&gt;从我们团队来说版本更新策略如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bugfix 原有功能和api无变动&lt;br/&gt;最后一位小版本更新&lt;/li&gt;
&lt;li&gt;功能更新，新增api等，但是老版本依旧可以使用&lt;br/&gt;中间一位版本更新&lt;/li&gt;
&lt;li&gt;不兼容更新，老版本无法使用&lt;br/&gt;最前面的大版本升级&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更复杂一点的可以通过tag来控制不同包具体可以参考&lt;a href=&quot;https://cnodejs.org/topic/537b47d1cbcc39634983b739&quot; class=&quot;uri&quot;&gt;https://cnodejs.org/topic/537b47d1cbcc39634983b739&lt;/a&gt;来了解&lt;/p&gt;
&lt;h3 id=&quot;使用者&quot;&gt;使用者&lt;/h3&gt;
&lt;p&gt;结合前面提到的，npm 默认的兼容版本安装，成熟npm包来说，更新策略一般都是考虑使用者的。&lt;br/&gt;会进行比较严谨的版本控制，但是我们新项目使用的时候，如果觉得老的包有用，直接npm i 之前可要思量一下，是否进行了打的版本升级。&lt;/p&gt;
&lt;h2 id=&quot;问题示例&quot;&gt;问题示例&lt;/h2&gt;
&lt;h3 id=&quot;一query-string-6.x版本不支持低版本&quot;&gt;一、query-string 6.x版本不支持低版本&lt;/h3&gt;
&lt;h4 id=&quot;问题描述&quot;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;上线一个月左右的一个项目，突然接到反馈，某个页面正常渲染之后，无法选中某个某个模块。&lt;/p&gt;
&lt;h4 id=&quot;问题定位&quot;&gt;问题定位&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;问题复现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接到反馈之后，立即拿起手边的手机进行复现，心里还说这么明显的问题竟然发生了，赶紧分分钟干掉。&lt;br/&gt;结果发现手边的手机都无法复现这种情况&lt;/p&gt;
&lt;p&gt;这时候怀疑是不是app版本问题，试着让用户升级下app。&lt;br/&gt;结果发现依旧存在相同问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确认问题机型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这时候询问发现机型为oppo，没有仔细去看具体型号。&lt;br/&gt;赶紧拿了个oppo r17测试机，发现依然不存在相关问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是否网络问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为使用的是公司内网，切换到手机4g，依然无法复现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;操作系统版本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这时候怀疑是旧版本不兼容最新语法，不过我们的js都是经过处理的，应该不会存在，不过还是确认了下用户操作系统，安卓4.6&lt;/p&gt;
&lt;p&gt;因为身边手机版本都较高，无法复现，不复现就很难定位。这时候想起来我司有个云真机平台，终于找到了个低版本的oppo，app运行都有点卡的那种。。。上面终于复现了。赶紧去调试，发现点击的时候报错:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Uncaught SyntaxError: Use of const in strict mode.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这下确认是es6没有被转义的问题了&lt;/p&gt;
&lt;h4 id=&quot;问题解决&quot;&gt;问题解决&lt;/h4&gt;
&lt;p&gt;不过这里还有点疑问，我们项目本身将src下的源码进行了处理的。如果说没有成功，那么多用到const的地方，应该一开始就报错。这下就让我我有点头疼了。&lt;/p&gt;
&lt;p&gt;仔细想了想，可能是第三方npm包没有经过转义处理，不过引了那么多的包，确定还是太难了。webpack打包之后的代码生产环境下是压缩的，简直不能看。&lt;/p&gt;
&lt;h5 id=&quot;本地打包&quot;&gt;本地打包&lt;/h5&gt;
&lt;p&gt;还好webpck4提供了不同的mode方式，可以直接使用 --mode development指定打包，这样是没有压缩过的。&lt;br/&gt;对比发现，const出现在query-string相关逻辑中，直接本地打开查看，发现就是其6.X的版本有要求。&lt;/p&gt;
&lt;p&gt;🔥 Want to strengthen your core JavaScript skills and master ES6?&lt;br/&gt;I would personally recommend this awesome ES6 course by Wes Bos.&lt;br/&gt;Also check out his Node.js, React, Sublime courses.&lt;/p&gt;
&lt;p&gt;可以从其tag中看到，&lt;a href=&quot;https://github.com/sindresorhus/query-string/blob/v5.0.1/index.js&quot;&gt;原本使用的5.x是基于es5的&lt;/a&gt;，18年五月份升级了&lt;a href=&quot;https://github.com/sindresorhus/query-string/blob/v6.0.0/index.js&quot;&gt;6.x&lt;/a&gt;，抛弃了支持es5，要求限制环境。&lt;/p&gt;
&lt;h4 id=&quot;问题原因&quot;&gt;问题原因&lt;/h4&gt;
&lt;p&gt;原本使用过该模块用来解析和序列化请求参数，所以新项目就直接安装了该依赖。&lt;br/&gt;安装的时候，如果没有指定版本，npm会默认获取最新版本，所以安装了6.x的版本。&lt;br/&gt;这时候我们没有去查看是否已经有大版本的更新。&lt;br/&gt;但目前大部分新型手机已经支持es6，所以在开发测试和上线的过程中，不会出现该问题。&lt;br/&gt;只有在部分低版本的手机，才会发现。&lt;/p&gt;
&lt;h3 id=&quot;二antd-upload组件不显示已上传图片&quot;&gt;二、antd upload组件不显示已上传图片&lt;/h3&gt;
&lt;h4 id=&quot;问题描述-1&quot;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;同事做的一个项目用到了antd的upload组件，发现测试环境可以显示后端返回的图片，但是线上不可以，因为同事休假，本着团结互助，积极接锅的精神，就拿过来改了。&lt;/p&gt;
&lt;h4 id=&quot;本地复现&quot;&gt;本地复现&lt;/h4&gt;
&lt;p&gt;首先拉代码到本地，然后本地测试，依然还是没有问题的。&lt;br/&gt;这样情况，还是对比下环境依赖。因为这里比较明显是upload的问题，所以我们只关注antd就好。&lt;br/&gt;对比测试环境和线上可以看到确实版本有差别：&lt;br/&gt;beta和本地是3.1.4 线上是3.5.4&lt;br/&gt;在本地限定版本之后可以发现问题修复。&lt;/p&gt;
&lt;h4 id=&quot;问题原因-1&quot;&gt;问题原因&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;代码跟进去可以看到：&lt;br/&gt;3.5.4版本做了个限制：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//图片后缀名必须为以下其一
 (webp|svg|png|gif|jpg|jpeg|bmp)$/.test(extension)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我们返回的缩略图地址没有后缀，所以不会显示。&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我们项目里面的版本依赖的写法是兼容版本写法：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&quot;antd&quot;: &quot;^3.1.4&quot;&lt;/code&gt;
&lt;/pre&gt;
因为3.5.4和3.1.4都是符合要求的。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;antd的版本升级策略是说的过去的毕竟不是大改动，正常情况下图片无外乎其中之一，这么小的概略就被我们碰上了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;
&lt;p&gt;吃一堑长一智，所以在使用npm包的时候一定要结合实际情况认真筛选是否适用，对于部分已经使用过的npm包，新项目使用的时候一定要注意是否有大版本变动。&lt;br/&gt;对于问题，首先还是要复现问题，为了更好的复现，最好保证各种版本都一致才能更好的定位。&lt;br/&gt;定位之后就比较好解决了。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Sep 2018 07:00:00 +0000</pubDate>
<dc:creator>潇湘待雨</dc:creator>
<og:description>npm包的更新说明，你还敢不看吗 前言 平时工作少不了依赖一些第三方的npm包，站在各位大牛的肩膀上来更好的写bug，此外还可以学习各位大佬们的各种设计思路和优雅实现。不过npm包虽好，但使用之前也要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pqjwyn/p/9690130.html</dc:identifier>
</item>
<item>
<title>音频算法之小黄人变声 附完整C代码 - cpuimage</title>
<link>http://www.cnblogs.com/cpuimage/p/9690112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cpuimage/p/9690112.html</guid>
<description>&lt;p&gt;前面提及到《&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/cpuimage/p/9538448.html&quot;&gt;大话音频变声原理 附简单示例代码&lt;/a&gt;》与《&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl07_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/cpuimage/p/8321878.html&quot;&gt;声音变调算法PitchShift(模拟汤姆猫) 附完整C++算法实现代码&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;都稍微讲过变声的原理和具体实现。&lt;/p&gt;
&lt;p&gt;大家都知道，算法从实现到最后工程应用，中间的环节和问题特别多。&lt;/p&gt;
&lt;p&gt;尤其是编码的架构设计，好的数据结构和代码逻辑封装肯定是可复用，组件化的。&lt;/p&gt;
&lt;p&gt;前几天写完《&lt;a id=&quot;homepage1_HomePageDays_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/cpuimage/p/9683296.html&quot;&gt;音频识别算法思考与阶段性小结&lt;/a&gt;》的时候，&lt;/p&gt;
&lt;p&gt;我也提及到了。&lt;/p&gt;
&lt;p&gt;会做一些算法编码优化相关的分享。&lt;/p&gt;
&lt;p&gt;而有时候我总觉得文字表达很苍白，&lt;/p&gt;
&lt;p&gt;所以我尽可能地把代码写得简洁易懂，&lt;/p&gt;
&lt;p&gt;一方面是便于基础差的朋友学习。&lt;/p&gt;
&lt;p&gt;另一方面也是为了自己在编码以及思考的时候，能更加清晰。&lt;/p&gt;
&lt;p&gt;当然，变声算法绝大多数朋友都会选择一些开源的或者商业sdk去做二次开发。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.fmod.com/&quot; target=&quot;_blank&quot;&gt;https://www.fmod.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.surina.net/soundtouch/&quot; target=&quot;_blank&quot;&gt;https://www.surina.net/soundtouch/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但如果仅仅停留在使用的阶段，它就是一个黑盒子。&lt;/p&gt;
&lt;p&gt;知其然，却不知其所以然。&lt;/p&gt;
&lt;p&gt;是远远不够的。&lt;/p&gt;
&lt;p&gt;有时候我们是要站在巨人的肩膀上去看到更美丽的风景。&lt;/p&gt;
&lt;p&gt;但是，我希望是一群人，而不是一个人。&lt;/p&gt;
&lt;p&gt;也许大家也发现了，我写的大多数算法，是纯c无第三方依赖的。&lt;/p&gt;
&lt;p&gt;是不是就会怀疑，我就只会写c语言？&lt;/p&gt;
&lt;p&gt;不是的，我所掌握的编程语言：&lt;/p&gt;
&lt;p&gt;主要： c,c++,python,汇编 &lt;/p&gt;
&lt;p&gt;其次：pascal,c#,js,lua,go等&lt;/p&gt;
&lt;p&gt;编程语言只是一个工具，关键还是算法思路。&lt;/p&gt;
&lt;p&gt;用纯c写的主要目的，是为了破除一些第三方依赖，&lt;/p&gt;
&lt;p&gt;不要一知半解地使用黑盒子。&lt;/p&gt;
&lt;p&gt;当然，其次的好处就是跨平台，便携，可复用。&lt;/p&gt;
&lt;p&gt;这样，一切了然于心。&lt;/p&gt;
&lt;p&gt;为什么不可以造轮子呢？&lt;/p&gt;
&lt;p&gt;只要你造的轮子是有用的，&lt;/p&gt;
&lt;p&gt;不管是用于观赏用于学习还是其他用途。&lt;/p&gt;
&lt;p&gt;在我了解到一些音频算法的思路之后，&lt;/p&gt;
&lt;p&gt;变声算法的思路，&lt;/p&gt;
&lt;p&gt;我觉得它的思路非常适用于扩展到大多数音频算法实现，&lt;/p&gt;
&lt;p&gt;而且可复用度比较高。&lt;/p&gt;
&lt;p&gt;所以，将它梳理开源，就显得特别有意义。&lt;/p&gt;
&lt;p&gt;而大家可以基于这个实现，进一步去改进或者学习 音频算法，&lt;/p&gt;
&lt;p&gt;例如降噪，增益等等。&lt;/p&gt;
&lt;p&gt;因为这个编码实现的设计是完全可以适用到音频算法应用场景的。&lt;/p&gt;
&lt;p&gt;逻辑也非常清晰。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/pitchshift&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/pitchshift&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然为了便于一些朋友的学习使用，&lt;/p&gt;
&lt;p&gt;示例代码提供一个简易的实现，&lt;/p&gt;
&lt;p&gt;模拟变声为小黄人。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Audio Processing \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blog:http://cpuimage.cnblogs.com/ \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pitch Shifting Using The Fourier Transform\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (argc &amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *in_file = argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    uint32_t sampleRate &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    uint64_t totalSampleCount &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    uint32_t channels &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *data_in = wavRead_s16(in_file, &amp;amp;sampleRate, &amp;amp;totalSampleCount, &amp;amp;&lt;span&gt;channels);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data_in !=&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; pitchShift = &lt;span&gt;0.9f&lt;/span&gt;&lt;span&gt;;
        size_t ms &lt;/span&gt;= &lt;span&gt;50&lt;/span&gt;&lt;span&gt;;
        size_t overSampling &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
        size_t frameSize &lt;/span&gt;= sampleRate * ms / &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
        frameSize &lt;/span&gt;+= frameSize % &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
        planData pitchPlanData &lt;/span&gt;= {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; startTime =&lt;span&gt; now();
        makePlanData(frameSize, overSampling, sampleRate, &lt;/span&gt;&amp;amp;&lt;span&gt;pitchPlanData);
        pitchshift(pitchShift, data_in, data_in, totalSampleCount, &lt;/span&gt;&amp;amp;&lt;span&gt;pitchPlanData);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; turn to minion pitch&lt;/span&gt;
&lt;span&gt;        {
            totalSampleCount &lt;/span&gt;/= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *samples =&lt;span&gt; data_in;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; totalSampleCount; i++&lt;span&gt;) {
                data_in[i] &lt;/span&gt;= samples[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                samples &lt;/span&gt;+= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; time_interval =&lt;span&gt; calcElapsed(startTime, now());
        freePlanData(&lt;/span&gt;&amp;amp;&lt;span&gt;pitchPlanData);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time interval: %f ms\n &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (time_interval * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;));
    }
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; drive[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; dir[&lt;span&gt;256&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; fname[&lt;span&gt;256&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; ext[&lt;span&gt;256&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; out_file[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
    splitpath(in_file, drive, dir, fname, ext);
    sprintf(out_file, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s%s%s_out%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, drive, dir, fname, ext);
    wavWrite_s16(out_file, data_in, sampleRate, totalSampleCount);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data_in) {
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(data_in);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;press any key to exit.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    getchar();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不做多解释，大家可以参阅pitchshift函数的实现，&lt;/p&gt;
&lt;p&gt;主要实现位于文件PitchShift.h。&lt;/p&gt;
&lt;p&gt;整个算法不到200行，逻辑非常清晰，&lt;/p&gt;
&lt;p&gt;已经做了一定程度上的工程化优化。&lt;/p&gt;
&lt;p&gt;当然还有很大的改进空间，&lt;/p&gt;
&lt;p&gt;不过这份代码，更多的意义在于学习。&lt;/p&gt;
&lt;p&gt;授人以鱼不如授人以渔。&lt;/p&gt;
&lt;p&gt;若有其他相关问题或者需求也可以邮件联系俺探讨。&lt;/p&gt;
&lt;p&gt;邮箱地址是: &lt;br/&gt;gaozhihan@vip.qq.com&lt;/p&gt;
</description>
<pubDate>Sat, 22 Sep 2018 06:50:00 +0000</pubDate>
<dc:creator>cpuimage</dc:creator>
<og:description>前面提及到《大话音频变声原理 附简单示例代码》与《声音变调算法PitchShift(模拟汤姆猫) 附完整C++算法实现代码》 都稍微讲过变声的原理和具体实现。 大家都知道，算法从实现到最后工程应用，中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cpuimage/p/9690112.html</dc:identifier>
</item>
<item>
<title>安卓app开发-05-Android xml布局详细介绍 - 肖朋伟</title>
<link>http://www.cnblogs.com/xpwi/p/9690113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xpwi/p/9690113.html</guid>
<description>&lt;h2 id=&quot;安卓app开发-05-android-xml布局详细介绍&quot;&gt;安卓app开发-05-Android xml布局详细介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;虽然说有 墨刀，墨客 这些图形化开发工具来做 Android 的界面设计，但是我们还是离不开要去学习做安卓原生app，学习 xml 布局还是必要的&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;准备&quot;&gt;（1）准备&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;首先我们要了解 android 到底有那些布局，和每个布局类型的区别&lt;/li&gt;
&lt;li&gt;学习时最好打开 Android Studio 打开 xml 文件对应看一下&lt;/li&gt;
&lt;li&gt;配置参数的详细含义不用着急全部理解，放在文章后面，可收藏做查阅【可通过目录跳转】&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;学习目标&quot;&gt;（2）学习目标&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;学习下xml的布局文件具体写法。这一节我们要绘制如下图所示的界面&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018092213482779?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;线性布局-linearlayout&quot;&gt;（3）线性布局 LinearLayout&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;线性布局分两种。一种是水平布局，一种是垂直布局。下面我们根据上图举例子&lt;/li&gt;
&lt;li&gt;上图代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot;
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt;
    &amp;lt;TextView android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/note_title&quot;
        android:layout_width=&quot;wrap_content&quot; android:padding=&quot;10dp&quot;&amp;gt;&amp;lt;/TextView&amp;gt;
    &amp;lt;LinearLayout android:layout_height=&quot;fill_parent&quot;
        android:layout_width=&quot;fill_parent&quot; android:layout_weight=&quot;1&quot;&amp;gt;
        &amp;lt;EditText android:id=&quot;@+id/EditText02&quot; android:layout_width=&quot;fill_parent&quot;
            android:layout_height=&quot;fill_parent&quot; android:gravity=&quot;left&quot;
            android:hint=&quot;@string/edithint&quot;&amp;gt;&amp;lt;/EditText&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
    &amp;lt;LinearLayout android:layout_height=&quot;fill_parent&quot;
        android:layout_width=&quot;fill_parent&quot; android:layout_weight=&quot;2&quot;
        android:gravity=&quot;center&quot;
        android:orientation=&quot;horizontal&quot;&amp;gt;
     &amp;lt;ImageButton android:id=&quot;@+id/ImageButton01&quot; android:layout_width=&quot;72dp&quot; android:layout_height=&quot;72dp&quot; android:src=&quot;@drawable/sketchy_paper_003&quot; android:layout_margin=&quot;3dp&quot;&amp;gt;&amp;lt;/ImageButton&amp;gt; &amp;lt;ImageButton android:id=&quot;@+id/ImageButton02&quot; android:layout_width=&quot;72dp&quot; android:layout_height=&quot;72dp&quot; android:src=&quot;@drawable/sketchy_paper_004&quot; android:layout_margin=&quot;3dp&quot;&amp;gt;&amp;lt;/ImageButton&amp;gt; &amp;lt;ImageButton android:id=&quot;@+id/ImageButton03&quot; android:layout_width=&quot;72dp&quot; android:layout_height=&quot;72dp&quot; android:src=&quot;@drawable/sketchy_paper_007&quot; android:layout_margin=&quot;3dp&quot;&amp;gt;&amp;lt;/ImageButton&amp;gt; &amp;lt;ImageButton android:id=&quot;@+id/ImageButton04&quot; android:layout_width=&quot;72dp&quot; android:layout_height=&quot;72dp&quot; android:src=&quot;@drawable/sketchy_paper_011&quot; android:layout_margin=&quot;3dp&quot;&amp;gt;&amp;lt;/ImageButton&amp;gt; &amp;lt;/LinearLayout&amp;gt; &amp;lt;/LinearLayout&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可以看到，上图是由三部分组成。在大的LinearLayout从上而下垂直分布着三个内容：TextView，LinearLayout，LinearLayout。所以总体的 LinearLayout 是垂直布局&lt;/li&gt;
&lt;li&gt;下面我们来看水平布局&lt;/li&gt;
&lt;li&gt;其实就是上图中的最下面那个 LinearLayout。四个图标平行排列。&lt;br/&gt;android:orientation=&quot;horizontal&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;相对布局-relativelayout&quot;&gt;（4）相对布局 RelativeLayout&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这个布局相对简单一点。一般来讲利用ADT自己拖放按钮就可以。基本上可以随意布局。如下图所示&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180922135531823?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;上图代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;
    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
    tools:context=&quot;.MainActivity&quot; &amp;gt;
 
    &amp;lt;Button
        android:id=&quot;@+id/button1&quot;
        style=&quot;?android:attr/buttonStyleSmall&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentLeft=&quot;true&quot;
        android:layout_alignParentTop=&quot;true&quot;
        android:text=&quot;Button&quot; /&amp;gt;
 
    &amp;lt;Button
        android:id=&quot;@+id/button2&quot;
        style=&quot;?android:attr/buttonStyleSmall&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignBaseline=&quot;@+id/button1&quot;
        android:layout_alignBottom=&quot;@+id/button1&quot;
        android:layout_alignParentRight=&quot;true&quot;
        android:layout_marginRight=&quot;14dp&quot;
        android:text=&quot;Button&quot; /&amp;gt;
 
    &amp;lt;Button
        android:id=&quot;@+id/button3&quot;
        style=&quot;?android:attr/buttonStyleSmall&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@+id/button1&quot;
        android:layout_centerHorizontal=&quot;true&quot;
        android:layout_marginTop=&quot;97dp&quot;
        android:text=&quot;Button&quot; /&amp;gt;
 
    &amp;lt;Button
        android:id=&quot;@+id/button4&quot;
        style=&quot;?android:attr/buttonStyleSmall&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignLeft=&quot;@+id/button1&quot;
        android:layout_below=&quot;@+id/button3&quot;
        android:layout_marginTop=&quot;89dp&quot;
        android:text=&quot;Button&quot; /&amp;gt;
 
    &amp;lt;Button
        android:id=&quot;@+id/button5&quot;
        style=&quot;?android:attr/buttonStyleSmall&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignLeft=&quot;@+id/button2&quot;
        android:layout_alignTop=&quot;@+id/button4&quot;
        android:text=&quot;Button&quot; /&amp;gt;
 
&amp;lt;/RelativeLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;layout_marginBottom是指控件边以外空下的距离，比如Button1和Button2垂直显示，将Button1中layout_marginBottom = 10dp，那么Button1与Button2之间将有10dp距离&lt;/li&gt;
&lt;li&gt;下面这两句是居左显示和居右显示&lt;br/&gt;android:layout_alignParentLeft=&quot;true&quot;&lt;br/&gt;android:layout_alignParentTop=&quot;true&quot;&lt;/li&gt;
&lt;li&gt;【提示】：相对视图应该是最有用的，具体的操作比较复杂，更多的是通过图形界面拖拉，再用代码微调&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;帧布局-framelayout&quot;&gt;（5）帧布局 FrameLayout&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这个布局很简单，而且感觉有点二二的，哈哈！就是控件一个挨一个在左上角罗列&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180922140307667?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;上图代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &amp;gt;
 
    &amp;lt;Button
        android:id=&quot;@+id/button1&quot;
        style=&quot;?android:attr/buttonStyleSmall&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Button&quot; /&amp;gt;
 
    &amp;lt;Button
        android:id=&quot;@+id/button2&quot;
        android:layout_width=&quot;126dp&quot;
        android:layout_height=&quot;135dp&quot;
        android:text=&quot;Button&quot; /&amp;gt;
 
    &amp;lt;Button
        android:id=&quot;@+id/button3&quot;
        android:layout_width=&quot;194dp&quot;
        android:layout_height=&quot;232dp&quot;
        android:text=&quot;Button&quot; /&amp;gt;

&amp;lt;/FrameLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;绝对布局-absolutelayout&quot;&gt;（6）绝对布局 AbsoluteLayout&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;绝对布局比较容易使用，就是以左上方为原点建立坐标系。每个控件用layout_x和layout_y表示位置。但是据说这种布局比较刚性，不容易适配各种终端，所以要慎用！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180922141601857?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;上图代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;AbsoluteLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &amp;gt;
 
    &amp;lt;Button
        android:id=&quot;@+id/button1&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_x=&quot;44dp&quot;
        android:layout_y=&quot;18dp&quot;
        android:text=&quot;Button&quot; /&amp;gt;
 
    &amp;lt;Button
        android:id=&quot;@+id/button2&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_x=&quot;122dp&quot;
        android:layout_y=&quot;173dp&quot;
        android:text=&quot;Button&quot; /&amp;gt;
 
    &amp;lt;Button
        android:id=&quot;@+id/button3&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_x=&quot;36dp&quot;
        android:layout_y=&quot;133dp&quot;
        android:text=&quot;Button&quot; /&amp;gt;
 
&amp;lt;/AbsoluteLayout&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;表格布局-tablelayout&quot;&gt;（7）表格布局 TableLayout&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;TableLayout有点像一个表格或是矩阵。在布局中加入TableRow，它的属性是horizontal所以每个TableRow只能横放。它里面的每个控件的高都是一样的。下图所示，是加入了一个TableRow和里面的控件&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180922141746378?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;上图代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;TableLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &amp;gt;
 
    &amp;lt;TableRow
        android:id=&quot;@+id/tableRow1&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot; &amp;gt;
 
        &amp;lt;Button
            android:id=&quot;@+id/button1&quot;
            style=&quot;?android:attr/buttonStyleSmall&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;Button&quot; /&amp;gt;
 
        &amp;lt;Button
            android:id=&quot;@+id/button2&quot;
            style=&quot;?android:attr/buttonStyleSmall&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;Button&quot; /&amp;gt;
 
        &amp;lt;Button
            android:id=&quot;@+id/button3&quot;
            style=&quot;?android:attr/buttonStyleSmall&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;Button&quot; /&amp;gt;
            
        &amp;lt;Button
            android:id=&quot;@+id/button4&quot;
            style=&quot;?android:attr/buttonStyleSmall&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;Button&quot; /&amp;gt;

        &amp;lt;TextView
            android:id=&quot;@+id/textView1&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;TextView&quot; /&amp;gt;
    &amp;lt;/TableRow&amp;gt;
 
&amp;lt;/TableLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;xml-配置参数大全&quot;&gt;xml 配置参数大全&lt;/h3&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;第一类:属性值为true或false&lt;/strong&gt;&lt;br/&gt;android:layout_centerHrizontal 水平居中&lt;br/&gt;android:layout_centerVertical 垂直居中&lt;br/&gt;android:layout_centerInparent 相对于父元素完全居中&lt;br/&gt;android:layout_alignParentBottom 贴紧父元素的下边缘&lt;br/&gt;android:layout_alignParentLeft 贴紧父元素的左边缘&lt;br/&gt;android:layout_alignParentRight 贴紧父元素的右边缘&lt;br/&gt;android:layout_alignParentTop 贴紧父元素的上边缘&lt;br/&gt;android:layout_alignWithParentIfMissing 如果对应的兄弟元素找不到的话就以父元素做参照物&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;第二类：属性值必须为id的引用名&lt;/strong&gt;&lt;br/&gt;android:layout_below 在某元素的下方&lt;br/&gt;android:layout_above 在某元素的的上方&lt;br/&gt;android:layout_toLeftOf 在某元素的左边&lt;br/&gt;android:layout_toRightOf 在某元素的右边&lt;br/&gt;android:layout_alignTop 本元素的上边缘和某元素的的上边缘对齐&lt;br/&gt;android:layout_alignLeft 本元素的左边缘和某元素的的左边缘对齐&lt;br/&gt;android:layout_alignBottom 本元素的下边缘和某元素的的下边缘对齐&lt;br/&gt;android:layout_alignRight 本元素的右边缘和某元素的的右边缘对齐&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;第三类：属性值为具体的像素值，如30dip，40px&lt;/strong&gt;&lt;br/&gt;android:layout_marginBottom 离某元素底边缘的距离&lt;br/&gt;android:layout_marginLeft 离某元素左边缘的距离&lt;br/&gt;android:layout_marginRight 离某元素右边缘的距离&lt;br/&gt;android:layout_marginTop 离某元素上边缘的距离&lt;br/&gt;EditText的android:hint 设置EditText为空时输入框内的提示信息。&lt;br/&gt;android:gravity　&lt;br/&gt;android:gravity属性是对该view 内容的限定．比如一个button 上面的text. 你可以设置该text 在view的靠左，靠右等位置．以button为例，android:gravity=&quot;right&quot;则button上面的文字靠右&lt;br/&gt;android:layout_gravity&lt;br/&gt;android:layout_gravity是用来设置该view相对与起父view 的位置．比如一个button 在linearlayout里，你想把该button放在靠左、靠右等位置就可以通过该属性设置．以button为例，android:layout_gravity=&quot;right&quot;则button靠右&lt;br/&gt;android:scaleType：&lt;br/&gt;android:scaleType是控制图片如何resized/moved来匹对ImageView的size。ImageView.ScaleType / android:scaleType值的意义区别：&lt;br/&gt;CENTER /center 按图片的原来size居中显示，当图片长/宽超过View的长/宽，则截取图片的居中部分显示&lt;br/&gt;CENTER_CROP / centerCrop 按比例扩大图片的size居中显示，使得图片长(宽)等于或大于View的长(宽)&lt;br/&gt;CENTER_INSIDE / centerInside 将图片的内容完整居中显示，通过按比例缩小或原来的size使得图片长/宽等于或小于View的长/宽&lt;br/&gt;FIT_CENTER / fitCenter 把图片按比例扩大/缩小到View的宽度，居中显示&lt;br/&gt;FIT_END / fitEnd 把图片按比例扩大/缩小到View的宽度，显示在View的下部分位置&lt;br/&gt;FIT_START / fitStart 把图片按比例扩大/缩小到View的宽度，显示在View的上部分位置&lt;br/&gt;FIT_XY / fitXY 把图片不按比例扩大/缩小到View的大小显示&lt;br/&gt;MATRIX / matrix 用矩阵来绘制，动态缩小放大图片来显示。&lt;br/&gt;** 要注意一点，Drawable文件夹里面的图片命名是不能大写的。&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;android:id 为控件指定相应的ID&lt;br/&gt;android:text 指定控件当中显示的文字，需要注意的是，这里尽量使用strings.xml文件当中的字符串&lt;br/&gt;android:gravity 指定View组件的对齐方式，比如说居中，居右等位置 这里指的是控件中的文本位置并不是控件本身&lt;br/&gt;android:layout_gravity 指定Container组件的对齐方式．比如一个button 在linearlayout里，你想把该button放在靠左、靠右等位置就可以通过该属性设置．以button为 例，android:layout_gravity=&quot;right&quot;则button靠右&lt;br/&gt;android:textSize 指定控件当中字体的大小&lt;br/&gt;android:background 指定该控件所使用的背景色，RGB命名法&lt;br/&gt;android:width 指定控件的宽度&lt;br/&gt;android:height 指定控件的高度&lt;/p&gt;
&lt;p&gt;android:layout_width 指定Container组件的宽度&lt;br/&gt;android:layout_height 指定Container组件的高度&lt;br/&gt;android:layout_weight View中很重要的属性，按比例划分空间&lt;br/&gt;android:padding* 指定控件的内边距，也就是说控件当中的内容&lt;br/&gt;android:sigleLine 如果设置为真的话，则控件的内容在同一行中进行显示&lt;br/&gt;android:scaleType 是控制图片如何resized/moved来匹对ImageView的siz&lt;br/&gt;android:layout_centerHrizontal 水平居中&lt;br/&gt;android:layout_centerVertical 垂直居中&lt;br/&gt;android:layout_centerInparent 相对于父元素完全居中&lt;br/&gt;android:layout_alignParentBottom 贴紧父元素的下边缘&lt;/p&gt;
&lt;p&gt;android:layout_alignParentLeft 贴紧父元素的左边缘&lt;br/&gt;android:layout_alignParentRight 贴紧父元素的右边缘&lt;br/&gt;android:layout_alignParentTop 贴紧父元素的上边缘&lt;br/&gt;android:layout_alignWithParentIfMissing 如果对应的兄弟元素找不到的话就以父元素做参照物&lt;br/&gt;android:layout_below 在某元素的下方&lt;br/&gt;android:layout_above 在某元素的的上方&lt;br/&gt;android:layout_toLeftOf 在某元素的左边&lt;br/&gt;android:layout_toRightOf 在某元素的右边&lt;br/&gt;android:layout_alignTop 本元素的上边缘和某元素的的上边缘对齐&lt;br/&gt;android:layout_alignLeft 本元素的左边缘和某元素的的左边缘对齐&lt;/p&gt;
&lt;p&gt;android:layout_alignBottom 本元素的下边缘和某元素的的下边缘对齐&lt;br/&gt;android:layout_alignRight 本元素的右边缘和某元素的的右边缘对齐&lt;br/&gt;android:layout_marginBottom 离某元素底边缘的距离&lt;br/&gt;android:layout_marginLeft 离某元素左边缘的距离&lt;br/&gt;android:layout_marginRight 离某元素右边缘的距离&lt;br/&gt;android:layout_marginTop 离某元素上边缘的距离&lt;br/&gt;android:paddingLeft 本元素内容离本元素右边缘的距离&lt;br/&gt;android:paddingRight 本元素内容离本元素上边缘的距离&lt;br/&gt;android:hint 设置EditText为空时输入框内的提示信息&lt;br/&gt;android:LinearLayout 它确定了LinearLayout的方向，其值可以为vertical，表示垂直布局horizontal， 表示水平布局&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;android:interpolator&lt;br/&gt;可能有很多人不理解它的用法，文档里说的也不太清楚，其实很简单，看下面：interpolator定义一个动画的变化率（the rate of change）。这使得基本的动画效果(alpha, scale, translate, rotate）得以加速，减速，重复等。用通俗的一点的话理解就是：动画的进度使用 Interpolator 控制。interpolator 定义了动画的变化速度，可以实现匀速、正加速、负加速、无规则变加速等。Interpolator 是基类，封装了所有 Interpolator 的共同方法，它只有一个方法，即 getInterpolation (float input)，该方法 maps a point on the timeline to a multiplier to be applied to the transformations of an animation。Android 提供了几个 Interpolator 子类，实现了不同的速度曲线，如下：&lt;br/&gt;AccelerateDecelerateInterpolator 在动画开始与介绍的地方速率改变比较慢，在中间的时侯加速&lt;br/&gt;AccelerateInterpolator 在动画开始的地方速率改变比较慢，然后开始加速&lt;br/&gt;CycleInterpolator 动画循环播放特定的次数，速率改变沿着正弦曲线&lt;br/&gt;DecelerateInterpolator 在动画开始的地方速率改变比较慢，然后开始减速&lt;br/&gt;LinearInterpolator 在动画的以均匀的速率改变&lt;br/&gt;对于 LinearInterpolator ，变化率是个常数，即 f (x) = x.&lt;br/&gt;public float getInterpolation(float input) {&lt;br/&gt;return input;&lt;br/&gt;}&lt;br/&gt;Interpolator其他的几个子类，也都是按照特定的算法，实现了对变化率。还可以定义自己的 Interpolator 子类，实现抛物线、自由落体等物理效果&lt;/p&gt;
&lt;h3 id=&quot;更多文章链接安卓app开发&quot;&gt;更多文章链接：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/category/8054657&quot;&gt;安卓app开发&lt;/a&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;本笔记不允许任何个人和组织转载&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 22 Sep 2018 06:50:00 +0000</pubDate>
<dc:creator>肖朋伟</dc:creator>
<og:description>安卓app开发 05 Android xml布局详细介绍 虽然说有 墨刀，墨客 这些图形化开发工具来做 Android 的界面设计，但是我们还是离不开要去学习做安卓原生app，学习 xml 布局还是必</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xpwi/p/9690113.html</dc:identifier>
</item>
<item>
<title>断舍离 ——《代码整洁之道》读书笔记 - 小蒋不素小蒋</title>
<link>http://www.cnblogs.com/xjnotxj/p/9690028.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjnotxj/p/9690028.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注1：只看了书的前十章&lt;br/&gt;注2：原书使用的语言为 Java，我改成了 JavaScript&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;h3 id=&quot;代码永不消失&quot;&gt;1、代码永不消失&lt;/h3&gt;
&lt;p&gt;代码就是衔接&lt;strong&gt;人脑理解需求的含糊性&lt;/strong&gt;和&lt;strong&gt;机器指令的精确性&lt;/strong&gt;的桥梁。哪怕未来会有对现在高级编程语言的再一次抽象——但这个抽象规范自身仍旧是代码。&lt;/p&gt;
&lt;p&gt;所以既然代码会一直存在下去，且自己都干了程序员这一行了，就好好的对待它吧。&lt;/p&gt;
&lt;h3 id=&quot;读远比写多&quot;&gt;2、读远比写多&lt;/h3&gt;
&lt;p&gt;当你录下你平时的编码的过程，回放时，你会发现读代码所花的时间远比写的多，甚至超过 10：1。所以整洁的代码会增加&lt;strong&gt;可读性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;对抗拖延症稍后等于永不&quot;&gt;3、对抗拖延症——&lt;strong&gt;稍后等于永不&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;糟糕的代码会导致项目的&lt;strong&gt;难以维护&lt;/strong&gt;。而当你正在写糟糕的代码的时候，心里却圣洁的想：“有朝一日再回来整理”。但现实是残酷的，正如&lt;code&gt;勒布朗（LeBlanc）法则&lt;/code&gt;：稍后等于永不（Later equals never）&lt;/p&gt;
&lt;h3 id=&quot;精益求精&quot;&gt;4、精益求精&lt;/h3&gt;
&lt;p&gt;写代码就跟写文章一样，先自由发挥，再细节打磨。&lt;strong&gt;追求完美&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;大师级程序员把系统当作故事来讲，而不是当作程序来写。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;h3 id=&quot;名副其实&quot;&gt;1、名副其实&lt;/h3&gt;
&lt;p&gt;（×）图表：mapTable&lt;/p&gt;
&lt;p&gt;（√）图表：chart&lt;/p&gt;
&lt;blockquote readability=&quot;3.4375&quot;&gt;
&lt;p&gt;推荐一个根据中文意思帮你起英文变量名的网址：&lt;a href=&quot;http://unbug.github.io/codelf/&quot; class=&quot;uri&quot;&gt;http://unbug.github.io/codelf/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896608/201809/896608-20180922140729379-469329793.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;避免误导&quot;&gt;2、避免误导&lt;/h3&gt;
&lt;h5 id=&quot;不要用专有名词&quot;&gt;（1）不要用专有名词&lt;/h5&gt;
&lt;p&gt;const var = 0;&lt;/p&gt;
&lt;h5 id=&quot;避免细微之处有不同&quot;&gt;（2）避免细微之处有不同&lt;/h5&gt;
&lt;p&gt;XYZControllerForEfficientKeepingOfStrings&lt;/p&gt;
&lt;p&gt;XYZControllerForEfficientHoldingOfStrings&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896608/201809/896608-20180922140741302-2112414664.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;避免废话&quot;&gt;（3）避免废话&lt;/h5&gt;
&lt;p&gt;如果是一个数组类型，就没必要叫 ProductArray&lt;/p&gt;
&lt;p&gt;如果返回值就是数据，就没必要叫 ProductData&lt;/p&gt;
&lt;h5 id=&quot;便于搜索&quot;&gt;（4）便于搜索&lt;/h5&gt;
&lt;p&gt;（×）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if ( team.length === 3 )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（√）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const MAX_NUM_OF_TEAM = 3 ;
……
if ( team.length === MAX_NUM_OF_TEAM )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MAX_NUM_OF_TEAM 比 3 好检索&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;早期流行一种&lt;code&gt;匈牙利语标记法&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;如 arru8NumberList 的前缀 &quot;arru8&quot; 表示变量是一个无符号8位整型数组;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;避免思维映射&quot;&gt;3、避免思维映射&lt;/h3&gt;
&lt;p&gt;类名、参数名用名词：&lt;/p&gt;
&lt;p&gt;member&lt;br/&gt;leader&lt;/p&gt;
&lt;p&gt;方法名用动词：&lt;/p&gt;
&lt;p&gt;getTeam&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;根据 Javabean 的标准，方法名可以加上 get set is 前缀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;每个概念用一个词&quot;&gt;4、每个概念用一个词&lt;/h3&gt;
&lt;p&gt;get fetch 选一个，不要混着用&lt;/p&gt;
&lt;h3 id=&quot;添加有意义的语境&quot;&gt;5、添加有意义的语境&lt;/h3&gt;
&lt;p&gt;如果你要记录 member 的详细住址，会设置了如下几个变量：&lt;/p&gt;
&lt;p&gt;（×）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;addrStreet addrHouseNumber addrCity addrState&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（√）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new Address {
    street,
    houseNumber,
    city,
    state
}&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;h3 id=&quot;尽量短小&quot;&gt;尽量短小&lt;/h3&gt;
&lt;p&gt;函数的缩进层级尽量控制在 1-3 层&lt;/p&gt;
&lt;p&gt;例如要依次读取 A、B、C 三个文件：&lt;/p&gt;
&lt;p&gt;（×）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function test() {
    readFileA(function (err, data) {
        // todo
        readFileB(function (err, data) {
            // todo
            readFileC(function (err, data) {
                // todo
                //……
            });
        });
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（√）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function test() {
    try {
        let re_a = await readFileA();
        let re_b = await readFileB();
        let re_c = await readFileC(); 
    } catch (err) { 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;只做一件事&quot;&gt;只做一件事&lt;/h3&gt;
&lt;p&gt;判断标准：是否可以再拆出一个函数&lt;/p&gt;
&lt;p&gt;（×）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function test() {
    //......
    Session.save();
    //......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（√）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function test() {
    //......
    saveSession();
    //......
}

function saveSession(){ 
    Session.save();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个函数即是一个抽象层，如上面的例子，Session 跟 test 函数不是一个抽象层，所以抽离出来。&lt;/p&gt;
&lt;h3 id=&quot;函数名代替注释&quot;&gt;函数名代替注释&lt;/h3&gt;
&lt;p&gt;长且具有描述性的名字比描述性的长注释好&lt;/p&gt;
&lt;p&gt;（×）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//取出所有满员的团
getSpecialGroup()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（√）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;getGroupOfFullMember()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参数顺序太多记不住怎么办&quot;&gt;参数顺序太多记不住怎么办？&lt;/h3&gt;
&lt;h5 id=&quot;方法一体现在函数名上&quot;&gt;方法一：体现在函数名上&lt;/h5&gt;
&lt;p&gt;（×）assertEqual(expected, actual)&lt;/p&gt;
&lt;p&gt;（√）assertExpectedEqualsActual(expected, actual)&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;现代 IDE 已经具有鼠标移在调用函数名上可以浮窗显示形参列表了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;方法二让参数可以打乱传&quot;&gt;方法二：让参数可以打乱传&lt;/h5&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function getMember({isNew = false,isActivate = false}){
    console.log(&quot;isNew:&quot;+isNew,&quot;, isActivate:&quot;+isActivate)
}

getMember({isNew:true,isActivate:false}) //isNew:true , isActivate:false
//不会因为传参的顺序记错而出错
getMember({isActivate:false,isNew:true}) //isNew:true , isActivate:false

//也支持默认参数
getMember({})   //isNew:false , isActivate:false&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;这里用到了 ES6 的新特性：&lt;code&gt;解构赋值&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let obj = {a:1,b:2};  
let {a,b} = obj;  // a = 1, b = 2&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h5 id=&quot;方法三减少参数&quot;&gt;方法三：减少参数&lt;/h5&gt;
&lt;p&gt;最理想的参数数量 &amp;lt; 3，最好不用输入参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A、布尔值参数 一拆二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（×）getMember(isNew)&lt;/p&gt;
&lt;p&gt;（√） getNewMember() getOldMember()&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里的前提是获取新、老会员的方法体代码不一样，不然还是共用在一个方法通过布尔值比较好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;B、二元函数变一元&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function addSuffix(origin,suffix){
    return origin+&quot;+&quot;+suffix;
} 
console.log(addSuffix(&quot;hello&quot;,&quot;world&quot;));

console.log(&quot;hello&quot;.addSuffix(&quot;world&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常代替返回错误码&quot;&gt;异常代替返回错误码&lt;/h3&gt;
&lt;p&gt;见我另一篇 &lt;a href=&quot;https://www.cnblogs.com/xjnotxj/p/9231297.html&quot;&gt;《 如何做好错误处理？（PHP篇）》&lt;/a&gt; 里面有体现&lt;/p&gt;
&lt;h3 id=&quot;抽离-try-catch-块&quot;&gt;抽离 try / catch 块&lt;/h3&gt;
&lt;p&gt;见我另一篇 &lt;a href=&quot;https://www.cnblogs.com/xjnotxj/p/9231297.html&quot;&gt;《 如何做好错误处理？（PHP篇）》&lt;/a&gt; 里面有体现&lt;/p&gt;
&lt;h3 id=&quot;避免重复&quot;&gt;避免重复&lt;/h3&gt;
&lt;p&gt;否则得修改多处地方&lt;/p&gt;
&lt;h3 id=&quot;结构化编程&quot;&gt;结构化编程&lt;/h3&gt;
&lt;p&gt;（1）每个函数都应该有一个入口和一个出口&lt;/p&gt;
&lt;p&gt;关于（&lt;code&gt;只能有一个 return 语句，在结尾处&lt;/code&gt; / &lt;code&gt;尽快 return，即有多个 return 语句&lt;/code&gt;）的争论：&lt;/p&gt;
&lt;p&gt;《结构化编程》的建议：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function test(is) {
    let result;
    if(is){
        result = true;
    }else{
        result = false;
    } 
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;《重构》的建议：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function test(is) {
    if(is){
        return true;
    }else{
        return false;
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两者写法现在仍有争议，详细的讨论可以点击：&lt;a href=&quot;https://stackoverflow.com/questions/36707/should-a-function-have-only-one-return-statement&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/36707/should-a-function-have-only-one-return-statement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（2）循环中尽量避免有 break 或 continue ，而且决不能出现 goto 语句。&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;尽量用代码表达而不是用注释&quot;&gt;尽量用代码表达，而不是用注释&lt;/h3&gt;
&lt;p&gt;就像上文提到的用详尽的函数名代替注释，或者：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//代码过于追求简洁而导致这里要加详细的注释
if( smodule.getDependSubsystems().contains(subSysMod.getSubSytem()) )

//还不如这里做拆分，取易懂的变量名方便理解，就可以不用加注释或者少加
ArrayList moduleDependees = smodule.getDependSubsystems();
String ourSubSystem = subSysMod.getSubSystem();
if( moduleDependees.contains(ourSubSystem) )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因是：注释存在的越久，随着代码的不断迭代，会离代码的距离越来越远，这个时候好的做法是同时维护代码 + 注释，而注释越多越复杂，&lt;strong&gt;维护的成本&lt;/strong&gt;自然就上升了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注释不能美化糟糕的代码，尽量去优化代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;好注释&quot;&gt;好注释&lt;/h3&gt;
&lt;p&gt;（1）法律信息、许可证、版权、著作权、外链文档的 url&lt;/p&gt;
&lt;p&gt;（2）对意图的解释&lt;/p&gt;
&lt;p&gt;（3）警示&lt;/p&gt;
&lt;p&gt;（4）TODO 注释&lt;/p&gt;
&lt;h3 id=&quot;坏注释&quot;&gt;坏注释&lt;/h3&gt;
&lt;p&gt;（1）只有自己看得懂&lt;/p&gt;
&lt;p&gt;（2）多余的注释&lt;/p&gt;
&lt;p&gt;a、不能提供比代码更多的信息&lt;/p&gt;
&lt;p&gt;b、读的时间比直接看代码还久&lt;/p&gt;
&lt;p&gt;（3）歧义性&lt;/p&gt;
&lt;p&gt;（4）循规蹈矩的注释&lt;/p&gt;
&lt;p&gt;例如用第三方工具生成的注释，很多都是累赘的废话&lt;/p&gt;
&lt;p&gt;（5）日志式、署名式注释&lt;/p&gt;
&lt;p&gt;（×）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//  write by colin
//  fix #201 bug&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（√）&lt;br/&gt;交给 git 记录&lt;/p&gt;
&lt;p&gt;（6）慎用位置标记&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// **********************&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;及时清理不需要的注释&quot;&gt;及时清理不需要的注释&lt;/h3&gt;
&lt;p&gt;（1）越堆越多&lt;/p&gt;
&lt;p&gt;（2）导致以后因看不懂而不敢删&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;向报纸学习&quot;&gt;向报纸学习&lt;/h3&gt;
&lt;p&gt;（1）从上往下读，从左往右读&lt;/p&gt;
&lt;p&gt;（2）源文件在最顶端给出高层次的概念和算法，细节往下逐次展开，直到最底层的函数和细节。&lt;/p&gt;
&lt;h3 id=&quot;垂直格式&quot;&gt;垂直格式&lt;/h3&gt;
&lt;p&gt;（1）善用空白行：人会更容易将目光聚焦到空白行之后的那一行&lt;/p&gt;
&lt;p&gt;（2）函数：调用者放在被调用者上面&lt;/p&gt;
&lt;h3 id=&quot;横向格式&quot;&gt;横向格式&lt;/h3&gt;
&lt;p&gt;（1）缩进&lt;/p&gt;
&lt;p&gt;（2）IDE 中不会出现横向滚动条&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;code&gt;数据结构&lt;/code&gt;和&lt;code&gt;对象&lt;/code&gt;的区别&lt;/p&gt;
&lt;p&gt;数据结构暴露其数据，没有提供有意义的函数。&lt;/p&gt;
&lt;p&gt;对象把数据隐藏在抽象之后，暴露操作数据的函数。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//数据结构
function Point(x,y){
    this.x = x;
    this.y = y;
}  

//对象
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  getX() {
    return this.x;
  }
  setX(x) {
    this.x = x;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;3.9574468085106&quot;&gt;
&lt;p&gt;ES6暂不提供私有变量（虽然有提案），但可以通过其他办法变相实现：&lt;a href=&quot;https://juejin.im/entry/572c0b2d2e958a00667a081d&quot; class=&quot;uri&quot;&gt;https://juejin.im/entry/572c0b2d2e958a00667a081d&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;h3 id=&quot;使用异常而非返回码&quot;&gt;使用异常而非返回码&lt;/h3&gt;
&lt;p&gt;（上文有述）&lt;/p&gt;
&lt;h3 id=&quot;定义异常类&quot;&gt;定义异常类&lt;/h3&gt;
&lt;p&gt;如引用了一个第三方库，它会 throw 自己的几种异常值，但我们可以定义一个异常类，封装好它的几种异常值为一种专门异常，然后再二次 throw 交给上层捕获。&lt;/p&gt;
&lt;h3 id=&quot;别返回-null-值&quot;&gt;别返回 null 值&lt;/h3&gt;
&lt;p&gt;null 值会造成很多不必要的 if 判断&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function getCurrentMember(){  
    let a = DB.getCurrentMember(); 
    if (a){
        return a;
    }else{
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法一：抛异常&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function getCurrentMember(){ 
    let a = DB.getCurrentMember(); 
    if (a){
        return a;
    }else{
        throw Error(&quot;no member&quot;)
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：返回特例值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
function getCurrentMember(){ 
    let a = DB.getCurrentMember(); 
    if (a){
        return a;
    }else{
        return {};
        //return {name : &quot;default&quot;};
    } 
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 22 Sep 2018 06:09:00 +0000</pubDate>
<dc:creator>小蒋不素小蒋</dc:creator>
<og:description>注1：只看了书的前十章 注2：原书使用的语言为 Java，我改成了 JavaScript 第一章 为什么要整洁代码 1、代码永不消失 代码就是衔接 人脑理解需求的含糊性 和 机器指令的精确性 的桥梁。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjnotxj/p/9690028.html</dc:identifier>
</item>
<item>
<title>一起学Hadoop——实现两张表之间的连接操作 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/9689809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/9689809.html</guid>
<description>&lt;p&gt;---恢复内容开始---&lt;/p&gt;
&lt;p&gt;之前我们都是学习使用MapReduce处理一张表的数据（一个文件可视为一张表，hive和关系型数据库Mysql、Oracle等都是将数据存储在文件中）。但是我们经常会遇到处理多张表的场景，不同的数据存储在不同的文件中，因此Hadoop也提供了类似传统关系型数据库的join操作。Hadoop生态组件的高级框架Hive、Pig等也都实现了join连接操作，编写类似SQL的语句，就可以在MapReduce中运行，底层的实现也是基于MapReduce。本文介绍如何使用MapReduce实现join操作，为以后学习hive打下基础。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、Map端连。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;数据在进入到map函数之前就进行连接操作。适用场景：一个文件比较大，一个文件比较小，小到可以加载到内存中。如果两个都是大文件，就会出现OOM内存溢出的异常。实现Map端连接操作需要用到Job类的addCacheFile()方法将小文件分发到各个计算节点，然后加载到节点的内存中。&lt;/p&gt;
&lt;p&gt;下面通过一个例子来实现Map端join连接操作：&lt;br/&gt;1、雇员employee表数据如下：&lt;br/&gt;name gender age dept_no&lt;br/&gt;Tom male 30 1&lt;br/&gt;Tony male 35 2&lt;br/&gt;Lily female 28 1&lt;br/&gt;Lucy female 32 3&lt;/p&gt;
&lt;p&gt;2、部门表dept数据如下：&lt;br/&gt;dept_no dept_name&lt;br/&gt;1 TSD&lt;br/&gt;2 MCD&lt;br/&gt;3 PPD&lt;/p&gt;
&lt;p&gt;代码实现如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; join;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.conf.Configuration;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.conf.Configured;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.fs.FileSystem;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.Job;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.Reducer;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.util.Tool;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; org.apache.hadoop.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.util.ToolRunner;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.Mapper;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileReader;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URI;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.fs.Path;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MapJoin &lt;span&gt;extends&lt;/span&gt; Configured &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Tool {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MapJoinMapper &lt;span&gt;extends&lt;/span&gt; Mapper&amp;lt;LongWritable, Text, Text,NullWritable&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; Map&amp;lt;Integer, String&amp;gt; deptData = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Integer, String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setup(Mapper&amp;lt;LongWritable, Text, Text,NullWritable&amp;gt;.Context context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException {
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.setup(context);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从缓存的中读取文件。&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;             Path[] files =&lt;span&gt; context.getLocalCacheFiles();
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;            Path file1path = new Path(files[0]);&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;             BufferedReader reader = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; FileReader(files[0&lt;span&gt;].toString()));
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             String str = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一行一行读取&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; ((str = reader.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对缓存中的数据以&quot; &quot;分隔符进行分隔。&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;                     String[] splits = str.split(&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把需要的数据放在Map中。注意不能操作Map的大小，否则会出现OOM的异常&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;                     deptData.put(Integer.parseInt(splits[0]), splits[1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;                reader.close();
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; map(LongWritable key, Text value, Mapper&amp;lt;LongWritable, Text, Text,NullWritable&amp;gt;.Context context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException,
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;                InterruptedException {
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取从HDFS中加载的表&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;             String[] values = value.toString().split(&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取关联字段depNo，这个字段是关键&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; depNo = Integer.parseInt(values[3&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据deptNo从内存中的关联表中获取要关联的属性depName&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;             String depName =&lt;span&gt; deptData.get(depNo);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             String resultData = value.toString() + &quot; &quot; +&lt;span&gt; depName;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将数据通过context写入到Reduce中。&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;             context.write(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Text(resultData),NullWritable.get());
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MapJoinReducer &lt;span&gt;extends&lt;/span&gt; Reducer&amp;lt;Text,NullWritable,Text,NullWritable&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; reduce(Text key, Iterable&amp;lt;NullWritable&amp;gt; values,Context context)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException,InterruptedException{
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;            context.write(key,NullWritable.get());
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; run(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         Configuration conf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration();
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         Job job = Job.getInstance(conf, &quot;Total Sort app&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将小表加载到缓存中。&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;         job.addCacheFile(&lt;span&gt;new&lt;/span&gt; URI(args[0&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         job.setJarByClass(MapJoinMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.1 设置输入目录和设置输入数据格式化的类&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;         FileInputFormat.setInputPaths(job,&lt;span&gt;new&lt;/span&gt; Path(args[1&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;         job.setInputFormatClass(TextInputFormat.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.2 设置自定义Mapper类和设置map函数输出数据的key和value的类型&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;         job.setMapperClass(MapJoinMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         job.setMapOutputKeyClass(Text.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         job.setMapOutputValueClass(NullWritable.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.3 设置reduce数量&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;         job.setNumReduceTasks(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置实现了reduce函数的类&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;         job.setReducerClass(MapJoinReducer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置reduce函数的key值&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;         job.setOutputKeyClass(Text.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置reduce函数的value值&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;         job.setOutputValueClass(NullWritable.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断输出路径是否存在，如果存在，则删除&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;         Path mypath = &lt;span&gt;new&lt;/span&gt; Path(args[2&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;         FileSystem hdfs =&lt;span&gt; mypath.getFileSystem(conf);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hdfs.isDirectory(mypath)) {
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             hdfs.delete(mypath, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;         FileOutputFormat.setOutputPath(job, &lt;span&gt;new&lt;/span&gt; Path(args[2&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; job.waitForCompletion(&lt;span&gt;true&lt;/span&gt;) ? 0 : 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; exitCode = ToolRunner.run(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MapJoin(), args);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        System.exit(exitCode);
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行脚本文件如下：：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; /usr/local/src/hadoop-&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;/bin/&lt;span&gt;hadoop jar MapJoin.jar \
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; hdfs:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hadoop-master:8020/data/dept.txt \&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; hdfs:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hadoop-master:8020/data/employee.txt \&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; hdfs:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hadoop-master:8020/mapjoin_output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Lily female 28 1 TSD
Lucy female 32 3 PPD
Tom male 30 1 TSD
Tony male 35 2 MCD&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、Reduce端连接(Reduce side join)。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;数据在Reduce进程中执行连接操作。实现思路：在Map进程中对来自不同表的数据打上标签，例如来自表employee的数据打上a标签，来自文件dept表的数据打上b标签。然后在Reduce进程，对同一个key，来自不同表的数据进行笛卡尔积操作。请看下图，我们对表employee和表dept的dept_no字段进行关联，将dept_no字段当做key。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110616/201809/110616-20180922120242057-1247338788.png&quot; alt=&quot;&quot; width=&quot;992&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在MapReduce中，key相同的数据会放在一起，因此我们只需在reduce函数中判断数据是来自哪张表，来自相同表的数据不进行join。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ReduceJoin &lt;span&gt;extends&lt;/span&gt; Configured &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Tool {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JoinMapper &lt;span&gt;extends&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt;             Mapper&amp;lt;LongWritable,Text,Text,Text&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;         String employeeValue = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; map(LongWritable key, Text value, Context context)
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;                 &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException,InterruptedException {
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;             * 根据命令行传入的文件名，判断数据来自哪个文件，来自employee的数据打上a标签，来自dept的数据打上b标签
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;             String filepath =&lt;span&gt; ((FileSplit)context.getInputSplit()).getPath().toString();
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;             String line =&lt;span&gt; value.toString();
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (line == &lt;span&gt;null&lt;/span&gt; || line.equals(&quot;&quot;)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (filepath.indexOf(&quot;employee&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;                 String[] lines = line.split(&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(lines.length &amp;lt; 4) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;                 String deptNo = lines[3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                 employeeValue = line + &quot; a&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;                 context.write(&lt;span&gt;new&lt;/span&gt; Text(deptNo),&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Text(employeeValue));
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(filepath.indexOf(&quot;dept&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                 String[] lines = line.split(&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(lines.length &amp;lt; 2) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                 String deptNo = lines[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                 context.write(&lt;span&gt;new&lt;/span&gt; Text(deptNo), &lt;span&gt;new&lt;/span&gt; Text(line + &quot; b&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JoinReducer &lt;span&gt;extends&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;             Reducer&amp;lt;Text, Text, Text, NullWritable&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; reduce(Text key, Iterable&amp;lt;Text&amp;gt;&lt;span&gt; values,
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                               Context context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException{
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             List&amp;lt;String[]&amp;gt; lista = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String[]&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             List&amp;lt;String[]&amp;gt; listb = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String[]&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Text val:values) {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 String[] str = val.toString().split(&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后一位是标签位，因此根据最后一位判断数据来自哪个文件，标签为a的数据放在lista中，标签为b的数据放在listb中&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;                 String flag = str[str.length -1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(&quot;a&quot;&lt;span&gt;.equals(flag)) {
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String valueA = str[0] + &quot; &quot; + str[1] + &quot; &quot; + str[2];&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;                    lista.add(str);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&quot;b&quot;&lt;span&gt;.equals(flag)) {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String valueB = str[0] + &quot; &quot; + str[1];&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;                    listb.add(str);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; lista.size(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (listb.size() == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                     String[] stra =&lt;span&gt; lista.get(i);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; listb.size(); j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                         String[] strb =&lt;span&gt; listb.get(j);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                         String keyValue = stra[0] + &quot; &quot; + stra[1] + &quot; &quot; + stra[2] + &quot; &quot; + stra[3] + &quot; &quot; + strb[1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                         context.write(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Text(keyValue), NullWritable.get());
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; run(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         Configuration conf =&lt;span&gt; getConf();
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         GenericOptionsParser optionparser = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GenericOptionsParser(conf, args);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         conf =&lt;span&gt; optionparser.getConfiguration();
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         Job job = Job.getInstance(conf, &quot;Reduce side join&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         job.setJarByClass(ReduceJoin.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.1 设置输入目录和设置输入数据格式化的类
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FileInputFormat.setInputPaths(job,new Path(args[0]));&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;         FileInputFormat.addInputPaths(job, conf.get(&quot;input_data&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         job.setInputFormatClass(TextInputFormat.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.2 设置自定义Mapper类和设置map函数输出数据的key和value的类型&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;         job.setMapperClass(JoinMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;         job.setMapOutputKeyClass(Text.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         job.setMapOutputValueClass(Text.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.3 设置reduce数量&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         job.setNumReduceTasks(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置实现了reduce函数的类&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;         job.setReducerClass(JoinReducer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置reduce函数的key值&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;         job.setOutputKeyClass(Text.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置reduce函数的value值&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;         job.setOutputValueClass(NullWritable.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断输出路径是否存在，如果存在，则删除&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;         Path output_dir = &lt;span&gt;new&lt;/span&gt; Path(conf.get(&quot;output_dir&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         FileSystem hdfs =&lt;span&gt; output_dir.getFileSystem(conf);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hdfs.isDirectory(output_dir)) {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             hdfs.delete(output_dir, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        FileOutputFormat.setOutputPath(job, output_dir);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; job.waitForCompletion(&lt;span&gt;true&lt;/span&gt;) ? 0 : 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; exitCode = ToolRunner.run(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReduceJoin(), args);
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        System.exit(exitCode);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行MapReduce的shell脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; /usr/local/src/hadoop-&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;/bin/&lt;span&gt;hadoop jar ReduceJoin.jar \
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; -Dinput_data=hdfs:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hadoop-master:8020/data/dept.txt,hdfs:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hadoop-master:8020/data/employee.txt \&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; -Doutput_dir=hdfs:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hadoop-master:8020/reducejoin_output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：&lt;br/&gt;1、Map side join的运行速度比Reduce side join快，因为Reduce side join在shuffle阶段会消耗大量的资源。Map side join由于把小表放在内存中，所以执行效率很高。&lt;br/&gt;2、当有一张表的数据很小时，小到可以加载到内存中，那么建议使用Map side join。&lt;/p&gt;

&lt;p&gt;欢迎关注本人公众号了解更多关于大数据方面的知识：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110616/201809/110616-20180922120543588-1023830707.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Sep 2018 04:06:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>恢复内容开始 之前我们都是学习使用MapReduce处理一张表的数据（一个文件可视为一张表，hive和关系型数据库Mysql、Oracle等都是将数据存储在文件中）。但是我们经常会遇到处理多张表的场景</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/9689809.html</dc:identifier>
</item>
<item>
<title>第48节：Java当中的集合框架 - 达叔小生</title>
<link>http://www.cnblogs.com/dashucoding/p/9689769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashucoding/p/9689769.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/11158618-2f1ece50667295cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;标题图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;java当中的集合框架&quot;&gt;Java当中的集合框架&lt;/h2&gt;
&lt;h2 id=&quot;section&quot;&gt;01&lt;/h2&gt;
&lt;p&gt;在我们班里有&lt;code&gt;50&lt;/code&gt;位同学，就有&lt;code&gt;50&lt;/code&gt;位对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
Student[] stus = new Student[20];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果来了一位插班生，该同学因为觉得学&lt;code&gt;IT&lt;/code&gt;行业好，才要求老师转专业的。可以结果没有多余的空位了，数组里的长度都是安排好的，没有空间了。&lt;/p&gt;
&lt;p&gt;为了解决新同学的问题，老师们重新创建一个空间（&lt;strong&gt;重复创建一个新的数组&lt;/strong&gt;），为了能够更好的解决问题，老师提供了可以不断扩大空间（&lt;strong&gt;Java提供了集合，当数据多了，个数不稳定时，可以用集合&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;中，数组的长度是不可以改变的，在数组中存储的是同种类型的元素，可以存储基本数据类型值；但是集合的长度是可以改变的，存储的是对象，对象的类型可以不一样，集合是存储对象的，当数据多，即对象多的时候，可以用集合来存储。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;虽然数组和集合类都是容器&lt;br/&gt;为什么用集合来解决问题，数组难道就不可以吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数组也可以存储对象的，但是因为长度的固定，限制了数组，而集合的长度是可以改变的，&lt;strong&gt;在数组中可以用来存储基本数据类型，而在集合中只能用来存储对象，但是可以存的对象可以是不同类型的对象哦~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;数组可以存放基本数据类型和对象&lt;br/&gt;集合只能存放对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;语言这种面向对象语言中，&lt;strong&gt;对一切事物的体现都可以用对象的形式来表现&lt;/strong&gt;，为了对对象进行方便的操作，&lt;code&gt;Java&lt;/code&gt;就提供了集合这个名词，用来存储对象一种方式。&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;02&lt;/h2&gt;
&lt;h2 id=&quot;类集合框架主体&quot;&gt;类集合框架主体&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;集合框架的构成及分类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-1a80fb43d4ffc4af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;类集合框架主体&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
java.util
类 Vector&amp;lt;E&amp;gt;
java.lang.Object
 -&amp;gt; java.util.AbstractCollection&amp;lt;E&amp;gt;
  -&amp;gt; java.util.AbstractList&amp;lt;E&amp;gt;
   -&amp;gt; java.util.Vector&amp;lt;E&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
public class Vector&amp;lt;E&amp;gt;
extends AbstractList&amp;lt;E&amp;gt;
implements List&amp;lt;E&amp;gt;, RandomAccess,Cloneable,Serializable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;类集框架，那么什么是类集框架，集合的种类有哪些，类集框架的基础结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类集框架是一组类和接口的集合，位于java.util包当中，是用来用户存储和管理对象的，&lt;strong&gt;在这个类集合框架中，我们主要学习的为三大类，分别是集合，列表和映射。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集合，列表，映射&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类集合框架是&lt;code&gt;jdk&lt;/code&gt;提供的一类类和接口，主要掌握集合，列表，映射，&lt;strong&gt;集合是无序的，集合中的元素不允许是重复的，列表是有序的，列表中的元素是允许重复的，映射是以键值对的方式来存储数据，键是不可重复的，值是可以重复的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实在&lt;code&gt;jdk&lt;/code&gt;最早的时候&lt;code&gt;jdk1.0&lt;/code&gt;版的时候，提供的集合是很少的，但是随着发展，到&lt;code&gt;jdk1.2&lt;/code&gt;的时候就变多了，为了营造更多的需求，就有了集合框架。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;所以的根接口为&lt;code&gt;Collection.&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
// 集合框架体系
Iterator
 -&amp;gt;Collection
 -&amp;gt; Map&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
Collection
 -&amp;gt; Set 无序不重复 -&amp;gt; 无序HashSet，需要排序TreeSet
 -&amp;gt; List 有序可重复 -&amp;gt; 查，改ArrayList，增删LinkedList

Map
 -&amp;gt; 无序 HashMap
 -&amp;gt; 排序 TreeMap&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;section-2&quot;&gt;03&lt;/h2&gt;
&lt;h2 id=&quot;顶级iterator和collection&quot;&gt;顶级Iterator和Collection&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Collection&lt;/code&gt;的相关方法，可以去官方下载文档来看哦：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;add(E e)&lt;/td&gt;
&lt;td&gt;返回的是&lt;code&gt;boolean&lt;/code&gt;的类型，确保&lt;code&gt;collection&lt;/code&gt;包含指定的元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;addAll(Collection&amp;lt;? extends E&amp;gt; e)&lt;/td&gt;
&lt;td&gt;返回的是&lt;code&gt;boolean&lt;/code&gt;的类型，将指定&lt;code&gt;collection&lt;/code&gt;中的所有元素添加到&lt;code&gt;collection&lt;/code&gt;中&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;clear()&lt;/td&gt;
&lt;td&gt;返回&lt;code&gt;Void&lt;/code&gt;，移除此&lt;code&gt;collection&lt;/code&gt;中的所有元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;contains(Object o)&lt;/td&gt;
&lt;td&gt;返回&lt;code&gt;boolean&lt;/code&gt;类型，如果此&lt;code&gt;collection&lt;/code&gt;包含指定的元素，则返回&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;containsAll(Collection&amp;lt;?&amp;gt; c)&lt;/td&gt;
&lt;td&gt;返回&lt;code&gt;boolean&lt;/code&gt;类型，如果此&lt;code&gt;collection&lt;/code&gt;包含指定&lt;code&gt;collection&lt;/code&gt;中的所有元素，则返回&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;equals(Object o)&lt;/td&gt;
&lt;td&gt;返回&lt;code&gt;boolean&lt;/code&gt;类型，比较&lt;code&gt;collection&lt;/code&gt;与指定对象是否相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;hashCode()&lt;/td&gt;
&lt;td&gt;返回的是&lt;code&gt;int&lt;/code&gt;类型，返回此 &lt;code&gt;collection&lt;/code&gt; 的哈希码值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;isEmpty()&lt;/td&gt;
&lt;td&gt;返回 &lt;code&gt;boolean&lt;/code&gt;类型，如果此&lt;code&gt;collection&lt;/code&gt;不包含元素，则返回&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;iterator()&lt;/td&gt;
&lt;td&gt;返回&lt;code&gt;Iterater&amp;lt;E&amp;gt;&lt;/code&gt;，返回在此&lt;code&gt;collection&lt;/code&gt;的元素上进行迭代的迭代器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;size()&lt;/td&gt;
&lt;td&gt;返回&lt;code&gt;Int&lt;/code&gt;类型，返回此&lt;code&gt;collection&lt;/code&gt;中的元素数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-cb3a6b1cdd2cae2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Collection接口&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Collection&lt;/code&gt;接口：它定义了集合体系中最共性的功能&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
java.util
接口 Collection&amp;lt;E&amp;gt;
所有超级接口：
Iterable&amp;lt;E&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
public interface Collection&amp;lt;E&amp;gt;
extends Iterable&amp;lt;E&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Collection&lt;/code&gt;接口为层次结构中的根接口，由上方提供的图片得知，&lt;code&gt;Collection&lt;/code&gt;表示为一组对象，这些对象称为&lt;code&gt;Collection&lt;/code&gt;的元素，在这个类集合框架中，我们主要学习的为三大类，分别是集合，列表和映射。&lt;/p&gt;
&lt;p&gt;注意一些&lt;code&gt;collection&lt;/code&gt;允许有重复的元素，有的不允许，有的是有序的，有的是无序的。&lt;/p&gt;
&lt;p&gt;这些都跟三大类有关。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;java&lt;/code&gt;中，&lt;code&gt;jdk&lt;/code&gt;不提供&lt;code&gt;Collection&lt;/code&gt;接口的实现，都是由它的子接口进行实现的。&lt;/p&gt;
&lt;h2 id=&quot;collection是list和set的父类&quot;&gt;Collection是List和Set的父类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-4f00fa21c9c24dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;如图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;List&lt;/code&gt;和&lt;code&gt;Set&lt;/code&gt;也都是由再次向下，由它们的子类接口实现的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
Set 和 HashSet 为Set的实现类 使用
Iterator -&amp;gt; Collection -&amp;gt; Set -&amp;gt; HashSet
Iterator -&amp;gt; Collection -&amp;gt; List -&amp;gt; ArrayList&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来解释：一些&lt;code&gt;collection&lt;/code&gt;允许有重复的元素，有的不允许，有的是有序的，有的是无序的。是因为数据结构的不同。为 &lt;code&gt;-&amp;gt;&lt;/code&gt; 三大类集合，列表，映射&lt;/p&gt;
&lt;p&gt;出现了集合框架，有了很多种容器可以完成很多需求，我们区分容器是&lt;strong&gt;靠着每个容器的数据结构不同&lt;/strong&gt;，去命名了解的。&lt;/p&gt;
&lt;h2 id=&quot;section-3&quot;&gt;04&lt;/h2&gt;
&lt;h2 id=&quot;三大类集合列表映射&quot;&gt;三大类集合，列表，映射&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt;为集合，在集合中的对象是不按照顺序排列的，并且是没有重复的对象的。&lt;br/&gt;&lt;strong&gt;简单为：无序，无重复。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-1d81c78a9c4c2c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Set&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;List&lt;/code&gt;为列表，中在列表中的对象是由顺序的排序的，并且是有重复的对象。&lt;br/&gt;&lt;strong&gt;简单为：有序，有重复。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-8c8e8769707eceaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;List&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;为映射，在集合中的每个元素都有一个键对象和一个值对象，在&lt;code&gt;Map&lt;/code&gt;中键是不可以重复的，值是可以重复的。&lt;br/&gt;&lt;strong&gt;键不可重复，值可以重复；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-d9b8649707e9cfa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Map&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt;为无序集合，无序无重复；&lt;br/&gt;&lt;code&gt;List&lt;/code&gt;为有序集合，有序有重复；&lt;br/&gt;&lt;code&gt;Map&lt;/code&gt;为映射，存储键值对，键不可重复，值可以重复；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;section-4&quot;&gt;05&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Collection&lt;/code&gt;是所有集合类的根接口，有人问那么这个呢？&lt;br/&gt;&lt;code&gt;Collections&lt;/code&gt;，其实这个是集合操作的工具类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
Collection
 -&amp;gt; Set
  -&amp;gt; HashSet
  -&amp;gt; LinkedHashSet
  -&amp;gt; TreeSet

 -&amp;gt; List
  -&amp;gt; ArrayList
  -&amp;gt; Vector
  -&amp;gt; LinkedList

 -&amp;gt; Queue
  -&amp;gt; LinkedList
  -&amp;gt; PriorityQueue

 -&amp;gt; Map
  -&amp;gt; Hashtable
  -&amp;gt; HashMap
  -&amp;gt; TreeMap
  -&amp;gt; LinkedHashMap&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-f8df6e3942f4235b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Collection接口&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
import java.util.List;
import java.util.ArrayList;

public class Demo{
 public static void main(String args[]){
 // 创建列表的实现类对象
  ArrayList&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;String&amp;gt;();
 // 添加数据
 arrayList.add(&quot;a&quot;);
 arrayList.add(&quot;b&quot;);
 arrayList.add(&quot;c&quot;);
// 移除
 arrayList.remove(1);
 // 获取数据
 String s = arrayList.get(1);
 System.out.println(s);
 // 获取长度
 int a = arrayList.size();
 // 打印所有元素
 for(int i=0; i&amp;lt;arrayList.size(); i++){
  String s = arrayList.get(i);
  System.out.println(s);
 }
 }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;HashSet&lt;/code&gt; 为&lt;code&gt;Set&lt;/code&gt;的实现类 使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
import java.util.Set;
import java.util.HashSet;
public class Demo{
 public static void main(String args[]){
  HashSet&amp;lt;String&amp;gt; hashSet = new HashSet&amp;lt;String&amp;gt;();
 Set&amp;lt;String&amp;gt; set = hashSet;
 // 实现类向上转型为接口
 // 同理 Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;String&amp;gt;();
 // 添加元素
 set.add(&quot;a&quot;); 
 set.add(&quot;b&quot;);
 set.add(&quot;c&quot;);
 set.add(&quot;d&quot;);
 // 获取集合中的元素长度
 int a = set.size();
 }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;iterator-接口-迭代器对象&quot;&gt;Iterator 接口 迭代器对象&lt;/h2&gt;
&lt;p&gt;迭代是&lt;code&gt;Java&lt;/code&gt;中的用来表示取元素的名称而已，&lt;code&gt;Iterator&lt;/code&gt; 接口 迭代器对象用来取元素，无论是什么数据结构，最终共性的取出方式，取值是一个一个取的，在之前先要判断是否有值，如果有就取一个，如果没有就&lt;code&gt;over&lt;/code&gt;，不取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
Iterator - &amp;gt; Collection -&amp;gt; Set - &amp;gt; HashSet
hasNext() next()
it.hasNext() 是否还有元素
it.next() 取出元素&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Iterator -&amp;gt; Collection -&amp;gt; List -&amp;gt; ArrayList&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;set-和-hashset-为set的实现类-使用&quot;&gt;Set 和 HashSet 为Set的实现类 使用&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
hasNext() 判断是否还有下一个元素
next() 取出这个元素，然后把游标移动到下一位&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Iterator -&amp;gt; Collection -&amp;gt; Set -&amp;gt; HashSet&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;
public class Demo{
 public static void main(String args[]){
  HashSet&amp;lt;String&amp;gt; hashSet = new HashSet&amp;lt;String&amp;gt;();
 Set&amp;lt;String&amp;gt; set = hashSet;
 // 实现类向上转型为接口
 // 同理 Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;String&amp;gt;();
 // 添加元素
 set.add(&quot;a&quot;); 
 set.add(&quot;b&quot;);
 set.add(&quot;c&quot;);
 set.add(&quot;d&quot;);
 // 迭代器 iterator() 遍历整个set
// 通过迭代器取出集合中的对象
 Iterator&amp;lt;String&amp;gt; it = set.iterator&amp;lt;String&amp;gt;();
 while(it.hasNext){
  String s = it.next();
  System.out.println(s);
 }
 }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt;迭代器 &lt;code&gt;iterator()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
Iterator&amp;lt;E&amp;gt; iterator()
// 返回在此collection的元素上的迭代效果。&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;接口&lt;code&gt;Iterable&amp;lt;E&amp;gt;中的iterator&lt;/code&gt;&lt;br/&gt;在此&lt;code&gt;collection&lt;/code&gt;的元素上进行迭代&lt;br/&gt;&lt;code&gt;iterator()&lt;/code&gt;可以获取具体容器中的迭代器对象&lt;br/&gt;迭代器返回的是&lt;code&gt;Iterator&lt;/code&gt;接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;迭代器的方法&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;hasNext()&lt;/td&gt;
&lt;td&gt;返回&lt;code&gt;boolean&lt;/code&gt;类型，如果有元素可以迭代（取出），则返回&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;next()&lt;/td&gt;
&lt;td&gt;返回&lt;code&gt;E&lt;/code&gt;，返回迭代的下一个元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;remove()&lt;/td&gt;
&lt;td&gt;返回&lt;code&gt;void&lt;/code&gt;，从迭代器中移除迭代器返回的最后一个元素&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;java.util.NoSuchElementException&lt;/code&gt; 没有这个元素异常&lt;br/&gt;&lt;code&gt;it.next()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
public class IteratorDemo{
 public static void mian(String[] args){
  // 创建集合对象
  Collection collection  = new ArrayList();
 // 存储的是对象的引用
 // 集合存储不了基本数据类型
 // collection.add(12); == 内部效果 collection.add(Integer.valueOf(12); // 自动装箱
 // 即在jdk1.5后，存储的是基本数据类型包装类的对象
  collection.add(&quot;ab&quot;);
  collection.add(&quot;bbb&quot;);
  collection.add(&quot;cbbb&quot;);
  collection.add(&quot;dbbbb&quot;);
  // 获取迭代器 iterator()方法
  Iterator it = collection.iterator();
  while(it.hasNext(){
   System.out.println(it.next());
  }
  // 
   //可以转变为
   // for(Iterator it = collection.iterator(); it.hasNext(); ) {}
  //
  // 每个存储对象的长度
  for(Iterator it = collection.iterator(); it.hasNext(); ){
   // 取出对象
   Object object = it.next();
   // 向下转型，才能使用元素的特殊方法
   String str = (String)object;
   // 打印对象长度
   System.out.println(str.length());
  } 
 }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
// 可以使用这个，节省内存
for(java.util.Iterator iterator = collection.iterator(){
 Object object = (Object) iterator.next();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;section-5&quot;&gt;06&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
// 创建一个Student类
public class Student{
 // 定义私有的String变量 name
 private String name;
 // 定义私有的int变量 age
 private int age;
 // 创建构造函数
 public Student(){
  super();
 }
 public Student(String name, int age){
  super();
  this.name = name;
  this.age = age;
 }
 // 创建toString()方法
 @Override
 public String toString(){
  return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
 }
 // 创建getXxx()，setXXX()方法
 public String getName(){
  return name;
 };
 public void setName(String name){
  this.name = name;
 }
 public int getAge(){
  return age;
 }
 public void setAge(int age){
  this.age = age;
 }
 // equals();
 @Override
 public boolean equals(Object obj){
  if(this == obj){
   return; 
  }
  if(! (obj instanceof Student) ){
   throw new ClassCastException(&quot;类型错误&quot;);
  }
   Student stu = (Student)obj;
   return this.name.equals(stu.name) &amp;amp;&amp;amp; this.age == stu.age;
 }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;equals()&lt;/code&gt;方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
public class CollectionDemo {
 public static void main(String[] args){
  // 创建集合对象
 Collection collection = new ArrayList();
 // 添加元素 添加一个地址两次为重复
 Student stu = new Student( &quot;a&quot;,12 );
 collection.add( stu );
 collection.add( new Student(&quot;b&quot;,13) );
 collection.add( new Student(&quot;c&quot;,14) );
 collection.add( new Student(&quot;d&quot;,15) );
 for(Iterator it = collection.iterator(); it.hasNext(); ){
  Student student = (Student) it.next();
  System.out.println(student.getName());
 }
 }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;map-与-hashmapmap的实现类-的使用&quot;&gt;Map 与 HashMap(Map的实现类) 的使用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; 为映射，映射中的每个元素都有一个键对象和一个值对象，在&lt;code&gt;Map&lt;/code&gt;中键是不可以重复的，值是可以重复的。从&lt;code&gt;jdk1.2&lt;/code&gt;有了这个类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
java.util
Interface Map&amp;lt;K,V&amp;gt;
K - the type of keys maintained by this map
V - the type of mapped values&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;是一种对象，将&lt;code&gt;keys&lt;/code&gt;键和&lt;code&gt;values&lt;/code&gt;值建立起一种映射关系，一个&lt;code&gt;map&lt;/code&gt;不能有重复的&lt;code&gt;keys&lt;/code&gt;，每个&lt;code&gt;key&lt;/code&gt;只能唯一映射到一个值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
import java.util.Map;
import java.util.HahMap;
public class Demo{
 public static void main(String args[]){
  HashMap&amp;lt;String,String&amp;gt; hasMap = new  HashMap&amp;lt;String,String&amp;gt;();
  Map&amp;lt;String,String&amp;gt; map = hasMap;
 // 向上转型
 // 同理 Map&amp;lt;Stirng,String&amp;gt; map = new HashMap&amp;lt;String,String&amp;gt;();
 // put() 用来存放键值对
 map.put(&quot;1&quot;,&quot;a&quot;);
 map.put(&quot;2&quot;,&quot;b&quot;);
 map.put(&quot;3&quot;,&quot;c&quot;);
// 获取长度
 int i = map.size();
// 获取键为2的值
 String s = map.get(&quot;2&quot;);
 }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;Map&lt;/code&gt;中键是不可以重复的，值是可以重复的。如果&lt;code&gt;map&lt;/code&gt;中添加一样的键，那么新的值会覆盖老的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Collection&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
public interface List&amp;lt;E&amp;gt;
extends Collection&amp;lt;E&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-e6975ee179b8127a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;简书作者：达叔小生&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
java.util
接口 List&amp;lt;E&amp;gt;
所有超级接口：Collection&amp;lt;E&amp;gt;，Iterable&amp;lt;E&amp;gt;
所有已知实现类：AbstractList，AbstractSequentialList，ArrayList，AttributeList，CopyOnWriteArrayList，LinkedList，RoleList，Vector，Stack。
可以用 ArrayList&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;public interface List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 简书作者：达叔小生
public class ListDemo{
 public static void main(String[] args){
  // List
  List list = new ArrayList();
 // 添加元素
 list.add( new Student(&quot;a&quot;,12) );
 list.add( new Student(&quot;b&quot;,13) );
 list.add( new Student(&quot;c&quot;,14) );
 // 插入元素
 // list.add( 1, new Student(&quot;d&quot;,15) );
 // list.remove(44); 
 // 角标越界IndexOutOfBoundsException)
 // list.set( 2, new Student(&quot;dashucoding&quot;, 16) );
 // 循环出对象
 for(Iterator it = List.iterator(); it.hasNext(); ){
  Student stu = (Student) it.next();
  System.out.println(stu);
 }
 // 获取对象
 Object obj = list.get(1);
 System.out.println(obj);
 // 获取对象
 for(int i = 0; i&amp;lt;list.size(); i++){
  System.out.println(list.get(i));
 }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.6896551724138&quot;&gt;
&lt;p&gt;往后余生，唯独有你&lt;br/&gt;简书作者：达叔小生&lt;br/&gt;90后帅气小伙，良好的开发习惯；独立思考的能力；主动并且善于沟通&lt;br/&gt;简书博客： &lt;a href=&quot;https://www.jianshu.com/u/c785ece603d1&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/u/c785ece603d1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;下面我将继续对 其他知识 深入讲解 ，有兴趣可以继续关注&lt;/li&gt;
&lt;li&gt;小礼物走一走 or 点赞&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 22 Sep 2018 03:46:00 +0000</pubDate>
<dc:creator>达叔小生</dc:creator>
<og:description>Java当中的集合框架 01 在我们班里有 位同学，就有 位对象。 结果来了一位插班生，该同学因为觉得学 行业好，才要求老师转专业的。可以结果没有多余的空位了，数组里的长度都是安排好的，没有空间了。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashucoding/p/9689769.html</dc:identifier>
</item>
<item>
<title>Caffe2源码解析之core - jicanghai</title>
<link>http://www.cnblogs.com/jicanghai/p/9689726.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jicanghai/p/9689726.html</guid>
<description>&lt;p&gt;在对Tensorflow的后端源码进行了拆解（参见&lt;a href=&quot;https://www.cnblogs.com/jicanghai/p/9589412.html&quot;&gt;tensorflow源码解析系列文章索引&lt;/a&gt;）之后，很想跟其它深度学习框架的实现进行对比，根据框架的流行程度，先选择了Pytorch。Pytorch的后端核心是直接复用了Caffe2，因此本文针对Caffe2源码的core模块进行了简单拆解。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;数据存储与表示
&lt;ul&gt;&lt;li&gt;storage&lt;/li&gt;
&lt;li&gt;tensor&lt;/li&gt;
&lt;li&gt;blob&lt;/li&gt;
&lt;li&gt;qtensor&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;操作
&lt;ul&gt;&lt;li&gt;observer observable&lt;/li&gt;
&lt;li&gt;operator&lt;/li&gt;
&lt;li&gt;操作求导&lt;/li&gt;
&lt;li&gt;operator_schema&lt;/li&gt;
&lt;li&gt;context&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;计算图
&lt;ul&gt;&lt;li&gt;graph&lt;/li&gt;
&lt;li&gt;net&lt;/li&gt;
&lt;li&gt;transform&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;运行时
&lt;ul&gt;&lt;li&gt;allocator&lt;/li&gt;
&lt;li&gt;db&lt;/li&gt;
&lt;li&gt;registry&lt;/li&gt;
&lt;li&gt;module&lt;/li&gt;
&lt;li&gt;scope_guard&lt;/li&gt;
&lt;li&gt;workspace&lt;/li&gt;
&lt;li&gt;init&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;storage&quot;&gt;1.1 storage&lt;/h2&gt;
&lt;p&gt;Caffe2中对数据存储的最底层的描述是Storage，它实际上是指向StorageImpl的共享指针，后者包含数据类型、数据指针、容量、数据所在设备等信息。Storage的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using Storage = std::shared_ptr&amp;lt;StorageImpl&amp;gt;;
class StorageImpl {
  public:
    //...
  protected:
    using DataPtr = std::shared_ptr&amp;lt;void&amp;gt;;
    int64_t capacity_ = 0;
    DataType data_type_;
    DataPtr data_ptr_;
    DeviceType device_type_ = CPU;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;tensor&quot;&gt;1.2 tensor&lt;/h2&gt;
&lt;p&gt;Caffe2中的数据统一使用Tensor表示，Tensor由TensorImpl实现，后者包含一个Storage。&lt;/p&gt;
&lt;p&gt;graph LR Tensor--&amp;gt;|包含|TensorImpl TensorImpl--&amp;gt;|包含|Storage Storage--&amp;gt;|指向|StorageImpl&lt;/p&gt;
&lt;p&gt;TensorImpl的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class TensorImpl {
  public:
    //...
  protected:
    using DimVector = std::vector&amp;lt;TIndex&amp;gt;;
    DimVector dims_; //张量的维度
    TIndex size_ = -1; //张量中包含的元素数量
    Storage storage_; //底层存储
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Tensor并非继承自TensorImpl，而是在内部包含了一个指向TensorImpl的指针，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Tensor final {
  protected:
    using TensorImplPtr = c10::intrusive_ptr&amp;lt;TensorImpl, UndefinedTensorImpl&amp;gt;;
    TensorImplPtr impl_;
  //...
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对Tensor的方法调用，通过重定向给TensorImpl实现。&lt;/p&gt;
&lt;h2 id=&quot;blob&quot;&gt;1.3 blob&lt;/h2&gt;
&lt;p&gt;Blob是一个容器，包含了一个指针和这个指针指向内存的数据类型，在Caffe2中，大部分情况下Blob都包含一个指向Tensor的指针。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Blob {
  public:
    //...
  private:
    TypeMeta meta_;
    void* pointer_ = nullptr;
    DestroyCall destroy_ = nullptr;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便对Blob进行传输，定义了其序列化和反序列化的类，分别是BlobSerializerBase和BlobDeserializerBase，以及对应的为Tensor准备的序列化和反序列化类。&lt;/p&gt;
&lt;p&gt;graph TB BlobSerializerBase--&amp;gt;|派生|TensorSerializer BlobDeserializerBase--&amp;gt;|派生|TensorDeserializer&lt;/p&gt;
&lt;h2 id=&quot;qtensor&quot;&gt;1.4 qtensor&lt;/h2&gt;
&lt;p&gt;低精度的张量，为了便于快速进行低精度的整数乘法计算。具体的做法是，用更低的位数来表示整数，比如，用3个bit表示无符号整数，用4个bit表示有符号整数。低精度张量可以在略微损失模型精度的情况下，大大降低计算复杂度和存储空间大小。&lt;/p&gt;

&lt;h2 id=&quot;observer-observable&quot;&gt;2.1 Observer Observable&lt;/h2&gt;
&lt;p&gt;Caffe2使用ObserverBase和Observable两个类实现了观察者模式。ObserverBase是基础观察器，用户可以通过继承此类创建新的观察器，而Observable是可被观察属性，用户可以通过继承此类获得可观察属性。&lt;/p&gt;
&lt;p&gt;ObserverBase提供了观察器的统一接口，比较简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class ObserverBase {
  public:
    virtual void Start() {}
    virtual void Stop() {}
    T* subject() const {
        return subject_;
    }
  protected:
    T* subject_;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，subject_表示被观察对象的指针。&lt;/p&gt;
&lt;p&gt;Observable封装了可被观察属性，内部包含了一个观察器的列表，结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Observable {
  public:
    using Observer = ObserverBase&amp;lt;T&amp;gt;;
    const Observer* AttachObserver(std::unique_ptr&amp;lt;Observer&amp;gt; observer){} //添加观察器
    std::unique_ptr&amp;lt;Observer&amp;gt; DetachObserver(const Observer* observer_ptr){} //解除观察器
    virtual size_t NumObservers() {
        return num_observers_;
    } //观察器的数量
    void StartAllObservers(){} //启动所有观察器
    void StopAllObservers(){} //关闭所有观察器
  private:
    Observer* observer_cache_;
    size_t num_observers_ = 0;
  protected:
    std::vector&amp;lt;std::unique_ptr&amp;lt;Observer&amp;gt;&amp;gt; observer_list_; //观察器列表
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;operator&quot;&gt;2.2 Operator&lt;/h2&gt;
&lt;p&gt;Operator代表操作的具体实现，相当于Tensorflow中的kernel。Operator继承自OperatorBase，而后者继承自Observable，所以在Caffe2中，“操作”本质上是一个可观察的对象。&lt;/p&gt;
&lt;p&gt;graph LR Observable--&amp;gt;|派生|OperatorBase OperatorBase--&amp;gt;|派生|Operator&lt;/p&gt;
&lt;p&gt;OperatorBase类包含了操作需要的基本数据元素和接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class OperatorBase {
  private:
    Workspace* operator_ws_;
    std::shared_ptr&amp;lt;const OperatorDef&amp;gt; operator_def_;
    DeviceOption device_option_;
    std::string engine_;
    std::string type_;
    vector&amp;lt;const Blob*&amp;gt; inputs_;
    vector&amp;lt;Blob*&amp;gt; outputs_;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OperatorBase中包含了输入和输出的内存指针，可见，在Caffe2中，Operator本质上是一个运行时的对象，这与Tensorflow中Op的设计理念不同，在Tensorflow中，Op是一个编译时对象，仅规定了操作的类型和目标，并不包含具体数据，具体的计算实际上是通过Kernel完成的。&lt;/p&gt;
&lt;p&gt;Operator继承自OperatorBase类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Operator : public OperatorBase {
  public:
    bool Run(int stream_id = 0) final {...}
    bool RunAsync(int stream_id = 0) final {...}
    virtual bool RunOnDevice() = 0;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，Run和RunAsync最终都调用了RunOnDevice，完成实际的计算。&lt;/p&gt;
&lt;p&gt;如果我们需要使用一些c10中定义的操作，需要将其转换为在Caffe2中可以调用的操作，可以通过如下的宏进行转换：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;REGISTER_C10_OPERATOR_FOR_CAFFE2_DISPATCH(C10Add, C2MyAddOpName)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述例子中，我们把一个C10Add操作，包装成C2MyAddOpName操作，供我们使用。为了实现这个功能，Caffe2还提供了一个包装类，C10OperatorWrapper。&lt;/p&gt;
&lt;h2 id=&quot;section-4&quot;&gt;2.3 操作求导&lt;/h2&gt;
&lt;p&gt;为了对操作求导，Caffe2推出了一个导数操作生成类，GradientMakerBase，方便用户定义对于某个操作的导数。类包含的数据成员如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//为密集和稀疏的blob提供统一的接口
struct GradientWrapper {
    string dense_;
    string indices_;
    string values_;
    inline bool IsDense(){}
    inline bool IsSparse(){}
    inline bool IsEmpty(){}
};
class GradientMakerBase {
  protected:
    const OperatorDef&amp;amp; def_;
    const vector&amp;lt;GradientWrapper&amp;gt;&amp;amp; g_output_;
    vector&amp;lt;GradientWrapper&amp;gt; g_input_;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，GradientMakerBase仅提供了输入输出，以及原操作。用户可以根据原操作，定制导数。&lt;/p&gt;
&lt;h2 id=&quot;operator_schema&quot;&gt;2.3 operator_schema&lt;/h2&gt;
&lt;p&gt;OpSchema是对操作的静态描述，相当于Tensorflow中的Op，包含的信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class OpSchema {
  private:
    string type_;
    string file_;
    string doc_;
    string onnx_schema_;
    std::vector&amp;lt;Argument&amp;gt; args_{};
    std::vector&amp;lt;std::pair&amp;lt;const char*, const char*&amp;gt;&amp;gt; input_desc_{};
    std::vector&amp;lt;std::pair&amp;lt;const char*, const char*&amp;gt;&amp;gt; output_desc_{};
    int line_ = 0;
    int min_input_ = 0;
    int max_input_ = std::numeric_limits&amp;lt;int&amp;gt;::max();
    int min_output_ = 0;
    int max_output_ = std::numeric_limits&amp;lt;int&amp;gt;::max();
    bool private_ = false;
    bool inputs_can_cross_devices_ = false;
    std::function&amp;lt;bool(int)&amp;gt; num_inputs_allowed = [](int) { return true; }
    std::function&amp;lt;bool(int)&amp;gt; num_outputs_allowed = [](int) { return true; }
    std::function&amp;lt;bool(int,int)&amp;gt; num_inputs_outputs_allowed_ = [](int,int) { return true; }
    std::function&amp;lt;int(int)&amp;gt; calculate_output_;
    std::function&amp;lt;bool(int,int)&amp;gt; inplace_allowed_ = [](int,int){}
    std::function&amp;lt;bool(int,int)&amp;gt; inplace_enforced_ = [](int,int){}
    TensorInferenceFunctionType tensor_inference_function_ = {...}
    std::unique_ptr&amp;lt;CostInferenceFunctionType&amp;gt; cost_inference_function_ = nullptr;
    DeviceInferenceFunctionType device_inference_function_ = {...}
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外Caffe2也提供了一个对于OpSchema的注册类OpSchemaRegistry，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class OpSchemaRegistry {
  private:
    static CaffeMap&amp;lt;string, OpSchema&amp;gt;&amp;amp; map();
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;context&quot;&gt;2.4 context&lt;/h2&gt;
&lt;p&gt;Caffe2中的context，其实就是Tensorflow中的OpKernelContext，为操作的实际计算提供通用的支持，主要包含内存拷贝的接口。所有实际的Context类必须继承自BaseContext，而Caffe2为我们准备了一个标准的Context接口，CPUContext类。另外，也同样为GPU准备了一个CUDAContext类。&lt;/p&gt;
&lt;p&gt;graph LR BaseContext--&amp;gt;|派生|CPUContext BaseContext--&amp;gt;|派生|CUDAContext&lt;/p&gt;

&lt;h2 id=&quot;graph&quot;&gt;3.1 graph&lt;/h2&gt;
&lt;p&gt;Graph表示图的结构，图包含节点，节点包含操作。&lt;/p&gt;
&lt;p&gt;graph LR Graph--&amp;gt;|包含|Node Node--&amp;gt;|包含|OperatorDef&lt;/p&gt;
&lt;p&gt;Node包含的数据成员：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Node {
  public:
    OperatorDef op;
    bool active = true; //操作是否被transformation删除
    std::map&amp;lt;int, std::vector&amp;lt;string&amp;gt;&amp;gt; parents;
    std::vector&amp;lt;int, std::vector&amp;lt;string&amp;gt;&amp;gt; children;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Graph包含的私有数据成员：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Graph {
  private:
    NetDef netdef_;
    std::set&amp;lt;string&amp;gt; external_input_;
    std::set&amp;lt;string&amp;gt; external_output_;
    std::vector&amp;lt;Node&amp;gt; nodes_;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;net&quot;&gt;3.2 net&lt;/h2&gt;
&lt;p&gt;Net是一个可运行的Graph，包含了一个图的所有“操作”，以及它们的上下文。它继承自Observable，本质上是一个可观察的对象。数据成员如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class NetBase : public Observable&amp;lt;NetBase&amp;gt;{
  public:
    virtual bool Run(){...}
    virtual bool RunAsync();
  protected:
    vector&amp;lt;string&amp;gt; external_input_;
    vector&amp;lt;string&amp;gt; external_output_;
    string name_;
    vector&amp;lt;const Event*&amp;gt; events_;
    std::shared_ptr&amp;lt;const NetDef&amp;gt; net_def_;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NetBase派生出了三种子类，第一种是AsyncNetBase，它包含了异步执行网络所必须的数据和接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class AsyncNetBase : public NetBase {
  public:
    bool RunAsync() override;
  protected:
    bool canSchedule(...);
    std::vector&amp;lt;OperatorBase*&amp;gt; operators_;
    std::vector&amp;lt;dag_utils::OperatorNode&amp;gt; operator_nodes_;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; chains_;
    std::vector&amp;lt;dag_utils::OpGraphNode&amp;gt; chain_nodes_;
    dag_utils::ExecutionChains execution_chains_;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种是SimpleNet，它表示了一种对图的单线程的顺序执行模式。 第三种是DAGNetBase，它表示了一种对图的多线程的dag执行模式。 相关的net类形成了一个继承体系：&lt;/p&gt;
&lt;p&gt;graph TB Observable--&amp;gt;|派生|NetBase NetBase--&amp;gt;|派生|AsyncNetBase AsyncNetBase--&amp;gt;|派生|AsyncSchedulingNet NetBase--&amp;gt;|派生|DAGNetBase DAGNetBase--&amp;gt;|派生|DAGNet NetBase--&amp;gt;|派生|SimpleNet DAGNetBase--&amp;gt;|派生|AsyncDAGNet AsyncNetBase--&amp;gt;|派生|AsyncPollingNet&lt;/p&gt;
&lt;h2 id=&quot;transform&quot;&gt;3.3 transform&lt;/h2&gt;
&lt;p&gt;transform是一种针对Caffe2的NetDef结构的操作，它将NetDef作为输入，输出新的经过变换的NetDef。它的工作步骤包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从旧的NetDef中构建一张图，这张图中保存了节点的连接信息；&lt;/li&gt;
&lt;li&gt;在图中匹配指定的模式，找到它想要更改的子图；&lt;/li&gt;
&lt;li&gt;用新的操作替换匹配到的子图；&lt;/li&gt;
&lt;li&gt;根据图构建一个新的NetDef并返回；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Transform功能的实现，依赖于三个功能函数，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PatternRule（模式规则），它决定了对于一张子图和一个节点，是否可以将这个节点加入这个子图中；&lt;/li&gt;
&lt;li&gt;ValidatorRule（验证规则），它决定了一张子图是否是匹配的；&lt;/li&gt;
&lt;li&gt;ReplaceRule（替换规则），它对一张匹配的子图进行替换；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用的模式如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CONNECTED_SUBGRAPH，连接子图，它只能匹配连接的子图。比如对于图(1)--&amp;gt;(2)--&amp;gt;(3)--&amp;gt;(4)，它能够匹配到[2,3]和[4,3]，但不能匹配到[2,4]；&lt;/li&gt;
&lt;li&gt;SORTED_WRT_EXECUTION_ORDER，执行序模式，它只能匹配符合执行顺序的子图，节点之间不一定需要有连接，它比General模式要快，例如对于图(1)--&amp;gt;(2)--&amp;gt;(3)--&amp;gt;(4)，它可以匹配到[2,4],[3,4]，但不能匹配到[3,1]，[4,3]；&lt;/li&gt;
&lt;li&gt;GENERAL，它可以匹配到任何子图，比如，对于图(1)--&amp;gt;(2)--&amp;gt;(3)--&amp;gt;(4)来说，它可以匹配到子图[2,4]，[3,4]，[4,2,1]等；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;allocator&quot;&gt;4.1 allocator&lt;/h2&gt;
&lt;p&gt;内存分配器。&lt;/p&gt;
&lt;p&gt;graph TB CPUAllocator--&amp;gt;|派生|DefaultCPUAllocator CPUAllocator--&amp;gt;|派生|PinnedCPUAllocator&lt;/p&gt;
&lt;h2 id=&quot;db&quot;&gt;4.2 db&lt;/h2&gt;
&lt;p&gt;DB类是对kv存储的抽象。包含了用于读取DB数据的Cursor类，用于写DB数据的Transaction类，DB读取的包裹类DBReader，对DBReader进行序列化和反序列化的DBReaderSerializer和DBReaderDeserializer类。&lt;/p&gt;
&lt;p&gt;graph TB DB--&amp;gt;|读数据时的游标类|Cursor DB--&amp;gt;|写数据时的事务类|Transaction DB--&amp;gt;|读数据包装|DBReader DBReader--&amp;gt;|序列化|DBReaderSerilizer DBReader--&amp;gt;|反序列化|DBReaderDeserilizer&lt;/p&gt;
&lt;h2 id=&quot;registry&quot;&gt;4.3 registry&lt;/h2&gt;
&lt;p&gt;注册类，key为字符串，value可以为任意的类。结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Registry {
  private:
    CaffeMap&amp;lt;SrcType, Creator&amp;gt; registry_;
    CaffeMap&amp;lt;SrcType, string&amp;gt; help_message_;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;module&quot;&gt;4.4 module&lt;/h2&gt;
&lt;p&gt;查看Caffe2已载入的模块，以及载入指定模块。模块指的是动态链接库。&lt;/p&gt;
&lt;h2 id=&quot;scope_guard&quot;&gt;4.5 scope_guard&lt;/h2&gt;
&lt;p&gt;是“初始化即资源获取”原语的实现，它保证了，如果不显式说明，函数的执行就会离开当前的scope。&lt;/p&gt;
&lt;h2 id=&quot;workspace&quot;&gt;4.6 workspace&lt;/h2&gt;
&lt;p&gt;Workspace包含了所有的运行时对象，包括blob和net，它是所有这些对象的拥有者，负责对这些对象进行管理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Workspace {
  private:
    typedef CaffeMap&amp;lt;string, unique_ptr&amp;lt;Blob&amp;gt;&amp;gt; BlobMap;
    BlobMap blob_map_;
    typedef CaffeMap&amp;lt;string, unique_ptr&amp;lt;NetBase&amp;gt;&amp;gt; NetMap;
    NetMap net_map_;
    const string root_folder_;
    const Workspace* shared_;
    std::unordered_map&amp;lt;string, std::pair&amp;lt;const Workspace*, string&amp;gt;&amp;gt; forwarded_blobs_;
    std::unique_ptr&amp;lt;ThreadPool&amp;gt; thread_pool_;
    std::mutex thread_pool_creation_mutex_;
    std::shared_ptr&amp;lt;Bookkeeper&amp;gt; bookkeeper_;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;init&quot;&gt;4.7 init&lt;/h2&gt;
&lt;p&gt;初始化整个Caffe2的运行环境，运行机制是，把需要在环境初始化中运行的函数注册到注册器中，初始化时，会在不同时期运行不同注册器中的函数。核心的函数如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CAFFE2_API bool GlobalInit(int* pargc, char*** argv);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个初始化过程分为三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先运行通过REGISTER_CAFFE2_EARLY_INIT_FUNCTION注册的函数；&lt;/li&gt;
&lt;li&gt;再解析Caffe的命令行参数，并启动日志记录系统；&lt;/li&gt;
&lt;li&gt;最后运行通过REGISTER_CAFFE2_INIT_FUNCTION注册的函数；&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 22 Sep 2018 03:22:00 +0000</pubDate>
<dc:creator>jicanghai</dc:creator>
<og:description>写在前面 在对Tensorflow的后端源码进行了拆解（参见</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jicanghai/p/9689726.html</dc:identifier>
</item>
<item>
<title>OpenCL的buffer以及sub-buffer - willhua</title>
<link>http://www.cnblogs.com/willhua/p/9689716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willhua/p/9689716.html</guid>
<description>&lt;h4 id=&quot;buffersub-buffer和image对比&quot;&gt;buffer，sub-buffer和image对比&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;相同点&lt;/strong&gt;：都是OCL memory对象&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;buffer&lt;/td&gt;
&lt;td&gt;一维&lt;/td&gt;
&lt;td&gt;array of bytes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;sub-buffer&lt;/td&gt;
&lt;td&gt;一维&lt;/td&gt;
&lt;td&gt;views into &lt;strong&gt;buffer&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;二维或者三维&lt;/td&gt;
&lt;td&gt;读写操作、可选的format、sampler及clamp&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;关于buffer的释放问题&quot;&gt;关于buffer的释放问题&lt;/h5&gt;
&lt;p&gt;在OpenCL中，对于&lt;code&gt;cl_mem&lt;/code&gt;对象都是采用&lt;strong&gt;reference-counted&lt;/strong&gt;的模式来控制对相应资源的释放的。OpenCL中增加某个&lt;code&gt;cl_mem&lt;/code&gt;的方法为&lt;code&gt;cl_int clRetainMemObject ( cl_mem memobj)&lt;/code&gt;,而&lt;strong&gt;clCreateBuffer, clCreateSubBuffer, clCreateImage2D, and clCreateImage3D&lt;/strong&gt;都会执行一个 implicit retain。clCreateSubBuffer also performs an implicit retain on the memory object used to create the sub-buffer or image object. 所以，如果一个cl_men对象创建了多个sub-buffer，那么应该对每个sub-buffer都进行&lt;code&gt;clRelaseMemObject&lt;/code&gt;. 降低引用计数的方法为&lt;code&gt;cl_int clReleaseMemObject ( cl_mem memobj)&lt;/code&gt;. 当一个&lt;code&gt;cl_mem&lt;/code&gt;的引用计数变为0，且相关的命令也已经执行完毕，那么OCL就会释放相关资源。&lt;br/&gt;另外，clSetKernelArg并不会retain相关的cl_mem。&lt;/p&gt;
&lt;h5 id=&quot;查询cl_mem对象的相关信息&quot;&gt;查询cl_mem对象的相关信息&lt;/h5&gt;
&lt;p&gt;可以使用&lt;code&gt;clGetMemObjectInfo&lt;/code&gt;查询到&lt;code&gt;cl_mem&lt;/code&gt;对象的各种相关信息。如下的代码查询&lt;code&gt;cl_mem&lt;/code&gt;对象是何种类型：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;cl_int errNum;
cl_mem memory;
cl_mem_object_type type;
// initialize memory object and so on
errNum = clGetMemObjectInfo(
    memory,
    CL_MEM_TYPE,
    sizeof(cl_mem_object_type),
    &amp;amp;type,
    NULL);
switch(type)
{
    case CL_MEM_OBJECT_BUFFER:
    {
        // handle case when object is buffer or sub-buffer
        break;
    }
    case CL_MEM_OBJECT_IMAGE2D:
    case CL_MEM_OBJECT_IMAGE3D:
    {
        // handle case when object is a 2D or 3D image
        break;
    }
    default
        // something very bad has happened
        break;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;buffer的读写&quot;&gt;buffer的读写&lt;/h5&gt;
&lt;p&gt;OpenCL中，host可以使用command来执行对buffer的读写。值得一提的是，在创建buffer的时候，比如使用&lt;code&gt;clCreateBuffer&lt;/code&gt;，使用合适的参数，比如&lt;code&gt;CLK_MEM_COPY_HOST&lt;/code&gt;，也可以实现对buffer资源的写入操作。但是，这种做法起码有三个明显的局限性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只能在创建buffer的时候执行写入，而无法对已经存在的&lt;code&gt;cl_mem&lt;/code&gt;对象执行写入&lt;/li&gt;
&lt;li&gt;只能写，而不能读&lt;/li&gt;
&lt;li&gt;只能写全部的数据，而不能只写部分片段的数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而OCL提供的相关command则可以十分自由的进行各种操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;clEnqueueWriteBuffer：把host的内容写入的buffer region&lt;/li&gt;
&lt;li&gt;clEnqueueReadBuffer：把buffer的内容复制到host内存中&lt;/li&gt;
&lt;li&gt;clEnqueueReadBufferRect：把一个二维或者三维的buffer的部分区域数据复制到host内存&lt;/li&gt;
&lt;li&gt;clEnqueueWriteBufferRect：把host上的数据写入到二维或者三维buffer的局部区域&lt;/li&gt;
&lt;li&gt;clEnqueueCopyBuffer：从一个buffer拷贝数据到另一个buffer，适用于一维的&lt;/li&gt;
&lt;li&gt;clEnqueueCopyBufferRect：从一个buffer拷贝片段数据到另一个buffer片段，适用于二维或者三维的&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;map-buffer-and-sub-buffer&quot;&gt;map buffer and sub-buffer&lt;/h5&gt;
&lt;p&gt;mapping一个buffer或者sub-buffer可以得到一个host指针，这个指针可以直接在host上使用，比如作为参数传给其他函数，但这些函数不会感知到这些内存实际是由OCL管理并利用的。&lt;br/&gt;map使用&lt;code&gt;clEnqueueMapBuffer&lt;/code&gt;，使用完之后需要unmap，使用&lt;code&gt;clEnqueueUnmapMemObject&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://book.douban.com/subject/6419785/&quot;&gt;OpenCL Programming Guide&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Sep 2018 03:18:00 +0000</pubDate>
<dc:creator>willhua</dc:creator>
<og:description>buffer，sub buffer和image对比 相同点 ：都是OCL memory对象 | |维度|特性关键词| | | | | |buffer|一维|array of bytes| |sub b</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willhua/p/9689716.html</dc:identifier>
</item>
</channel>
</rss>