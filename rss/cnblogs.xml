<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>查看Eclipse运行工程时使用的Command Line - 水果味的C</title>
<link>http://www.cnblogs.com/SyMind/p/7798875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SyMind/p/7798875.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、查看使用的Command Line&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.Window -&amp;gt; Show View -&amp;gt; Other... -&amp;gt; Debug&lt;/p&gt;
&lt;p&gt;2.运行工程，然后在Debug视窗中找到运行的工程的主线程，右键菜单 -&amp;gt; Properties&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1138123/201711/1138123-20171107140458247-1746083348.png&quot; alt=&quot;&quot; width=&quot;395&quot; height=&quot;496&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、javaw是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;以下翻译自 https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;        java命令启动一个Java程序。它启动Java运行时环境（JRE）已完成这件事，加载特定的类，然后调用类的main()方法。这个方法必须使用public和static来声明，它一定不能返回任何值，而且它必须接受一个String数组作为参数。这个函数的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         默认情况下，第一个参数是类的完全限定名称而不是java命令的选项的。如果指定了jar选项，它的参数是JAR文件的名称，该文件包含应用程序的类和资源文件。启动类必须由主类清单标头在其源代码中表示。&lt;/p&gt;
&lt;p&gt;        JRE在一下三组位置上搜索启动类（和应用程序所使用的其他类）：启动类路径（ bootstrap class path）, 已安装的扩展（installed extensions）, 和用户的类路径（user's class path）。&lt;/p&gt;
&lt;p&gt;        参数在类文件名或JAR文件名后传递给main()方法。&lt;/p&gt;
&lt;p&gt;        javaw命令与java命令相似，除了用javaw没有相关的控制台窗口。当你不想命令提示窗口出现时使用javaw。javaw如果启动失败，它将显示错误信息在一个对话框中。&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 22:16:00 +0000</pubDate>
<dc:creator>水果味的C</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SyMind/p/7798875.html</dc:identifier>
</item>
<item>
<title>程序员之殇 —— （Are you afraid of me? Don't be.）灵感=神秘感 - 食腐者</title>
<link>http://www.cnblogs.com/scavenger/p/8419913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/scavenger/p/8419913.html</guid>
<description>&lt;p&gt;Are you afraid of me? (你们怕我吗？)&lt;/p&gt;
&lt;p&gt;Don't be.（不用怕）&lt;/p&gt;
&lt;p&gt;I am a programmer who just won't die.(我是不会死的程序员)&lt;/p&gt;

&lt;p&gt;自从跟踪到32位CPU的逻辑地址等同于线性地址，不仅在Windows中，还有在Linux(Android)中，你所看到的、所想到的一切，都不是事实 —— 认识到了这一个层次，编程序的所有神秘感消失了。&lt;/p&gt;
&lt;p&gt;以前，程序运行中崩溃是天大的事 —— 如今，在这神秘感消失之后，只要跟踪堆栈地址即可迎刃而解，因为逻辑地址等同于线性地址。&lt;/p&gt;

&lt;p&gt;64位CPU的来临，是所有程序员的最黑暗的冬天 —— 因为以前所熟悉的压栈调用方式，几乎不再使用 —— 意味着，你的知识，再一次欠费了&lt;/p&gt;

&lt;p&gt;Being a programmer who whispers in the dark, I don't think I can make it this time. (对于，那些在黑暗的程序世界里, 摸索的程序员，我要说，这一次，我真的挺不过去了)&lt;/p&gt;
&lt;p&gt;My door is closing. (我的灵感之门已经关闭)&lt;/p&gt;
&lt;p&gt;There is no hope rising from the ashes. （灰烬中，已经无法燃起希望）&lt;/p&gt;

&lt;p&gt;Life is full of second chances. (但是，生命中，总是充满第二次机会)&lt;/p&gt;
&lt;p&gt;There must be a new place to call home. (是时候开辟新的家园了)&lt;/p&gt;

&lt;p&gt;Good for me. (祝福我吧)&lt;/p&gt;

</description>
<pubDate>Mon, 05 Feb 2018 15:47:00 +0000</pubDate>
<dc:creator>食腐者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/scavenger/p/8419913.html</dc:identifier>
</item>
<item>
<title>Android组件化框架设计与实践 - cryAllen</title>
<link>http://www.cnblogs.com/cr330326/p/8419899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cr330326/p/8419899.html</guid>
<description>&lt;p&gt;在目前移动互联网时代，每个 APP 就是流量入口，与过去 PC Web 浏览器时代不同的是，APP 的体验与迭代速度影响着用户的粘性，这同时也对从事移动开发人员提出更高要求，进而移动端框架也层出不穷。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-752c547daade5343.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;服务端与移动端对比&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图显示的是传统的服务端架构和客户端 App 架构对比。传统的服务端架构中最底下是一个 OS，一般是 Linux，最上面服务端的业务，而中间有非常多的层次可以在架构上，按照我们的意愿搭建中间的各个层次的衔接环节，使得架构具有足够的灵活性和扩展性。但是到了 App 就会面对一个完全不同的现状，App 的OS（Android或iOS）本质上并不是一个很瘦的像 Linux 这样的 OS，而是在 OS 上有一个很重的 App Framework，开发一个普通的客户端应用所要用到的绝大多数接口都在 Framework 里，而上面的业务也是一个非常复杂多样化的业务，最后会发现“架构”是在中间的一个非常尴尬的夹心层，因为会遇到很多在服务端架构中不需要面临的挑战。比如以下两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;体积的制约。体积对用户来说是一个非常敏感的概念，如果我们要在架构上做很多事情的话，通常意味着架构占据的代码量会比较大。在服务端架构中我们可以容忍我们在架构层面去做几十兆的代码。但是对于客户端架构，即使你的架构只有一两兆，对于一个客户端可能都占据了 10%，20%的容量。&lt;/li&gt;
&lt;li&gt;性能的挑战。从性能上来看，对于服务端架构我们通常关注的是吞吐率，我们不会去关注启动速度。一个服务端的启动哪怕是花了一两分钟，只要它运作起来吞吐率足够高，支持的并发能力足够好，响应速度足够快，我们就认为这是一个良好的架构。但客户端不同，客户端的进程对用户而言，往往是一个栈态的，手机里面使用完一个应用，退出之后可能过不了多久就会被回收掉，当用户下次再打开的时候，它会再次启动进程，需要重新完成一次初始化的流程。如果在这个上面做了很多事情的话，会导致程序启动的速度会很慢，在很多用户看来，这就是一种不可接受的用户体验。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户端 APP 与服务端在架构上是有着一定的区别，在选择对客户端架构需要谨慎对待，需要有许多权衡的条件，在此前提上，是否有一种归一的方式呢，可以分而治之，并行开发，把业务分隔成一个个单独的组件，整个架构围绕组件开发，构建也是组件，一切皆组件。答案是有的，那就是打造客户端组件框架。&lt;/p&gt;
&lt;h3 id=&quot;起源为何组件化&quot;&gt;起源，为何组件化&lt;/h3&gt;
&lt;p&gt;客户端 APP 自身在飞速发展，APP 版本不断迭代，新功能不断增加，业务模块数量不断增加，业务上的处理逻辑越变越复杂，同时每个模块代码也变得越来越多，这就引发一个问题，所维护的代码成本越来越高，稍微一改动可能就牵一发而动全身，改个小的功能点就需要回归整个 APP 测试，这就对开发和维护带来很大的挑战。同时原来APP 架构方式是单一工程模式，业务规模扩大，随之带来的是团队规模扩大，那就涉及到多人协作问题，每个移动端软件开发人员势必要熟悉如此之多代码，如果不按照一定的模块组件机制去划分，将很难进行多人协作开发，随着单一项目变大，而且 Andorid 项目在编译代码方面就会变得非常卡顿，在单一工程代码耦合严重，每修改一处代码后都需要重新编译打包测试，导致非常耗时，最重要的是这样的代码想要做单元测试根本无从下手，所以必须要有一个更灵活的架构去代替过去单一工程模式。&lt;/p&gt;
&lt;p&gt;同样这样的问题在我们工作具体项目中处处碰到，就拿我们组内负责的某个移动端 APP 来说，就碰到如下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;代码量膨胀，不利于维护，不利于新功能的开发。&lt;/li&gt;
&lt;li&gt;项目工程构建速度慢，在一些电脑上写两句代码，重新编译测试的话编译速度起码 10-20 分钟，有的甚至更长。&lt;/li&gt;
&lt;li&gt;不同模块之间代码耦合严重，比如消息模块严重耦合视频模块，如果修改视频模块，相应的消息模块也需要修改，不然会产生一连串问题。&lt;/li&gt;
&lt;li&gt;每个模块之间都有引用第三方库，但有些第三方库版本不一致，导致打包 APP 时候代码冗余，容易引起版本冲突。&lt;/li&gt;
&lt;li&gt;有些定制项目如果只需要消息模块，其他模块不需要的话，做不到按需加载打包，因为模块之间有互联依赖。&lt;/li&gt;
&lt;li&gt;现有项目基于以前其他人项目基础上开发，经手的人次过多，存在着不同的代码风格，项目中代码规范乱，类似的功能写法却不一样，导致不统一。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;项目工程架构模式改变是大势所趋，那又该如何做呢？那就是：&lt;strong&gt;打造组件化开发框架&lt;/strong&gt;，用以解决目前所面临问题，在讲解如何打造之前，需要谈谈组件化概念，组件化框架是什么。&lt;/p&gt;
&lt;h3 id=&quot;概念组件化是什么&quot;&gt;概念，组件化是什么&lt;/h3&gt;
&lt;p&gt;问：什么是组件，什么是组件化？&lt;/p&gt;
&lt;p&gt;答：在软件开发领域，&lt;strong&gt;组件（Component）&lt;/strong&gt;是对数据和方法的简单封装，功能单一，高内聚，并且是业务能划分的最小粒度。举个我们生活中常见的例子就是电脑主板上每个元件电容器件，每个元件负责的功能单一、容易组装、即插即拔，但作用有限，需要一定的依赖条件才可使用。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-9bffe938885a485e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;电容元件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么同样，&lt;strong&gt;组件化&lt;/strong&gt; 就是基于组件可重用的目的上，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，使得整个软件系统也做到电路板一样，是单个或多个组件元件组装起来，哪个组件坏了，整个系统可继续运行，而不出现崩溃或不正常现象，做到更少的耦合和更高的内聚。&lt;/p&gt;
&lt;p&gt;问：组件化、模块化容易混淆，两者区别又是什么？&lt;/p&gt;
&lt;p&gt;答：模块化就是将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容，模块我们相对熟悉,比如登录功能可以是一个模块,搜索功能可以是一个模块等等。而组件化就是更关注可复用性，更注重关注点分离，如果从集合角度来看的话，可以说往往一个模块包含了一个或多个组件，或者说模块是一个容器，由组件组装而成。简单来说，组件化相比模块化粒度更小，两者的本质思想都是一致的，都是把大往小的方向拆分，都是为了复用和解耦，只不过模块化更加侧重于业务功能的划分，偏向于复用，组件化更加侧重于单一功能的内聚，偏向于解耦。&lt;/p&gt;
&lt;p&gt;问：组件化能带来什么好处？&lt;/p&gt;
&lt;p&gt;答：简单来说就是提高工作效率，解放生产力，好处如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码简洁，冗余量少，维护方便，易扩展新功能。&lt;/li&gt;
&lt;li&gt;提高编译速度，从而提高并行开发效率。&lt;/li&gt;
&lt;li&gt;避免模块之间的交叉依赖，做到低耦合、高内聚。&lt;/li&gt;
&lt;li&gt;引用的第三方库代码统一管理，避免版本统一，减少引入冗余库。&lt;/li&gt;
&lt;li&gt;定制项目可按需加载，组件之间可以灵活组建，快速生成不同类型的定制产品。&lt;/li&gt;
&lt;li&gt;制定相应的组件开发规范，可促成代码风格规范，写法统一。&lt;/li&gt;
&lt;li&gt;系统级的控制力度细化到组件级的控制力度，复杂系统构建变成组件构建。&lt;/li&gt;
&lt;li&gt;每个组件有自己独立的版本，可以独立编译、测试、打包和部署。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;设计构建组件化框架&quot;&gt;设计，构建组件化框架&lt;/h3&gt;
&lt;p&gt;回到刚开始讲的 APP 单一工程模式，看张常见 APP 单一工程模式架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-f2e5060255c24179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;APP单一工程模式架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是目前比较普遍使用的 Android APP 技术架构，往往是在一个界面中存在大量的业务逻辑，而业务逻辑中充斥着各种网络请求、数据操作等行为，整个项目中也没有模块的概念，只有简单的以业务逻辑划分的文件夹，并且业务之间也是直接相互调用、高度耦合在一起的。单一工程模型下的业务关系，总的来说就是：你中有我，我中有你，相互依赖，无法分离。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-37616b1cdbd791da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;业务模块互相耦合&quot;/&gt;&lt;/p&gt;
&lt;p&gt;组件化的指导思想是：分而治之，并行开发，一切皆组件。要实现组件化，无论采用什么样的技术方式，需要考虑以下七个方面问题：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li&gt;代码解耦。如何将一个庞大的工程分成有机的整体？&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;组件单独运行。因为每个组件都是高度内聚的，是一个完整的整体，如何让其单独运行和调试？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;组件间通信。由于每个组件具体实现细节都互相不了解，但每个组件都需要给其他调用方提供服务，那么主项目与组件、组件与组件之间如何通信就变成关键？&lt;/li&gt;
&lt;li&gt;UI 跳转。UI 跳转指的是特殊的数据传递，跟组件间通信区别有什么不同？&lt;/li&gt;
&lt;li&gt;组件生命周期。这里的生命周期指的是组件在应用中存在的时间，组件是否可以做到按需、动态使用、因此就会涉及到组件加载、卸载等管理问题。&lt;/li&gt;
&lt;li&gt;集成调试。在开发阶段如何做到按需编译组件？一次调试中可能有一两个组件参与集成，这样编译时间就会大大降低，提高开发效率。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;代码隔离。组件之间的交互如果还是直接引用的话，那么组件之间根本没有做到解耦，如何从根本上避免组件之间的直接引用，也就是如何从根本上杜绝耦合的产生？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;组件化架构目标：告别结构臃肿，让各个业务变得相对独立，业务组件在组件模式下可以独立开发，而在集成模式下又可以变为 AAR 包集成到“ APP 壳工程”中，组成一个完整功能的 APP。&lt;/p&gt;
&lt;p&gt;先给出框架设计图，然后再对这七个问题进行一一解答。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-8c6f303047be6182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;A组件化框架架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，&lt;strong&gt;业务组件之间是独立的，互相没有关联&lt;/strong&gt;，这些业务组件在集成模式下是一个个 Library，被 APP 壳工程所依赖，组成一个具有完整业务功能的 APP 应用，但是在组件开发模式下，业务组件又变成了一个个 Application，它们可以独立开发和调试，由于在组件开发模式下，业务组件们的代码量相比于完整的项目差了很远，因此在运行时可以显著减少编译时间。&lt;/p&gt;
&lt;p&gt;各个业务组件通信是通过路由转发，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-2c26405226fd9ed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;路由转发通信&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是组件化工程模型下的业务关系，业务之间将不再直接引用和依赖，而是通过“路由”这样一个中转站间接产生联系。&lt;/p&gt;
&lt;p&gt;那么针对以上提出的七个问题，具体解决如下：&lt;/p&gt;
&lt;p&gt;1，代码解耦问题&lt;/p&gt;
&lt;p&gt;对已存在的项目进行模块拆分，模块分为两种类型，一种是功能组件模块，封装一些公共的方法服务等，作为依赖库对外提供，一种是业务组件模块，专门处理业务逻辑等功能，这些业务组件模块最终负责组装APP。&lt;/p&gt;
&lt;p&gt;2，组件单独运行问题&lt;/p&gt;
&lt;p&gt;通过 &lt;strong&gt;Gradle&lt;/strong&gt; 脚本配置方式，进行不同环境切换。比如只需要把 Apply plugin: 'com.android.library' 切换成Apply plugin: 'com.android.application' 就可以，同时还需要在 AndroidManifest 清单文件上进行设置，因为一个单独调试需要有一个入口的 Activity。比如设置一个变量 isModule，标记当前是否需要单独调试，根据isModule 的取值，使用不同的 gradle 插件和 AndroidManifest 清单文件，甚至可以添加 Application 等 Java 文件，以便可以做一下初始化的操作。&lt;/p&gt;
&lt;p&gt;3，组件间通信问题&lt;/p&gt;
&lt;p&gt;通过接口+实现的结构进行组件间的通信。每个组件声明自己提供的服务 Service API，这些 Service 都是一些接口，组件负责将这些 Service 实现并注册到一个统一的路由 Router 中去，如果要使用某个组件的功能，只需要向Router 请求这个 Service 的实现，具体的实现细节我们全然不关心，只要能返回我们需要的结果就可以了。在组件化架构设计图中 Common 组件就包含了路由服务组件，里面包括了每个组件的路由入口和跳转。&lt;/p&gt;
&lt;p&gt;4，UI 跳转问题&lt;/p&gt;
&lt;p&gt;可以说 UI 跳转也是组件间通信的一种，但是属于比较特殊的数据传递。不过一般 UI 跳转基本都会单独处理，一般通过短链的方式来跳转到具体的 Activity。每个组件可以注册自己所能处理的短链的 Scheme 和 Host，并定义传输数据的格式，然后注册到统一的 UIRouter 中，UIRouter 通过 Scheme 和 Host 的匹配关系负责分发路由。但目前比较主流的做法是通过在每个 Activity 上添加注解，然后通过 APT 形成具体的逻辑代码。目前方式是引用阿里的 &lt;a href=&quot;https://github.com/alibaba/ARouter&quot;&gt;ARouter&lt;/a&gt; 框架，通过注解方式进行页面跳转。&lt;/p&gt;
&lt;p&gt;5，组件生命周期问题&lt;/p&gt;
&lt;p&gt;在架构图中的核心管理组件会定义一个组件生命周期接口，通过在每个组件设置一个配置文件,这个配置文件是通过使用注解方式在编译时自动生成，配置文件中指明具体实现组件生命周期接口的实现类，来完成组件一些需要初始化操作并且做到自动注册，暂时没有提供手动注册的方式。&lt;/p&gt;
&lt;p&gt;6，集成调试问题&lt;/p&gt;
&lt;p&gt;每个组件单独调试通过并不意味着集成在一起没有问题，因此在开发后期我们需要把几个组件机集成到一个 APP 里面去验证。由于经过前面几个步骤保证了组件之间的隔离，所以可以任意选择几个组件参与集成，这种按需索取的加载机制可以保证在集成调试中有很大的灵活性，并且可以加大的加快编译速度。需要注意的一点是，每个组件开发完成之后，需要把 isModule 设置为 true并同步，这样主项目就可以通过参数配置统一进行编译。&lt;/p&gt;
&lt;p&gt;7，代码隔离问题&lt;/p&gt;
&lt;p&gt;如果还是 compile project(xxx:xxx.aar) 来引入组件，我们就完全可以直接使用到其中的实现类，那么主项目和组件之间的耦合就没有消除，那之前针对接口编程就变得毫无意义。我们希望只在 assembleDebug 或者 assembleRelease 的时候把 AAR 引入进来，而在开发阶段，所有组件都是看不到的，这样就从根本上杜绝了引用实现类的问题。&lt;/p&gt;
&lt;p&gt;目前做法是主项目只依赖 Common 的依赖库，业务组件通过路由服务依赖库按需进行查找，用反射方式进行组件加载，然后在主工程中调用组件服务，组件与组件之间调用则是通过接口+实现进行通信，后续规划通过自定义Gradle 插件，通过字节码自动插入组件的依赖进行编译打包，实现自动筛选 assembleDebug 或 assembleRelease 这两个编译命任务，只有属于包含这两个任务的命令才引入具体实现类，其他的则不引入。&lt;/p&gt;
&lt;h3 id=&quot;代码具体项目实践&quot;&gt;代码，具体项目实践&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一，创建工程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，APP空壳工程&lt;/p&gt;
&lt;p&gt;通过AndroidStudio创建一个APP空壳工程，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-88c4fd466fb21038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;APP空壳工程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在 APP 工程添加依赖具体业务组件 Module。比如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-e85a29280a5b0bb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;依赖关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2，具体业务组件Module&lt;/p&gt;
&lt;p&gt;需要遵循一定组件命名规范，为何需要规范呢，因为需要通过组件命名规范来约束和保证组件的统一性和一致性，避免出现冲突。比如登陆组件，那么名称：b(类型)-ga(部门缩写)-login(组件名称)，这就是我们基于共同的约定进行命名的，为后期维护和扩展都带来辨识度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-ef599f6c33ba46be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Login业务组件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二，业务组件配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，build.gradle配置文修改。如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isModule.&lt;span class=&quot;fu&quot;&gt;toBoolean&lt;/span&gt;()) {
    apply plugin: 'com.&lt;span class=&quot;fu&quot;&gt;android&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;application&lt;/span&gt;'
} &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
    apply plugin: 'com.&lt;span class=&quot;fu&quot;&gt;android&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;library&lt;/span&gt;'
}

android {
    compileSdkVersion rootProject.&lt;span class=&quot;fu&quot;&gt;ext&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;compileSdkVersion&lt;/span&gt;
    buildToolsVersion rootProject.&lt;span class=&quot;fu&quot;&gt;ext&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;buildToolsVersion&lt;/span&gt;

    defaultConfig {
        minSdkVersion rootProject.&lt;span class=&quot;fu&quot;&gt;ext&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;minSdkVersion&lt;/span&gt;
        targetSdkVersion rootProject.&lt;span class=&quot;fu&quot;&gt;ext&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;targetSdkVersion&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isModule.&lt;span class=&quot;fu&quot;&gt;toBoolean&lt;/span&gt;()) {
            applicationId &lt;span class=&quot;st&quot;&gt;&quot;com.hik.ga.business.login&quot;&lt;/span&gt;
            versionCode &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
            versionName &lt;span class=&quot;st&quot;&gt;&quot;1.0&quot;&lt;/span&gt;
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;//ARouter&lt;/span&gt;
            javaCompileOptions {
                annotationProcessorOptions {
                    arguments = [ moduleName : project.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() ]
                }
            }
        }
    }

    sourceSets {
        main {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isModule.&lt;span class=&quot;fu&quot;&gt;toBoolean&lt;/span&gt;()) {
                manifest.&lt;span class=&quot;fu&quot;&gt;srcFile&lt;/span&gt; 'src/main/module/AndroidManifest.&lt;span class=&quot;fu&quot;&gt;xml&lt;/span&gt;'
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                manifest.&lt;span class=&quot;fu&quot;&gt;srcFile&lt;/span&gt; 'src/main/AndroidManifest.&lt;span class=&quot;fu&quot;&gt;xml&lt;/span&gt;'
                &lt;span class=&quot;co&quot;&gt;//集成开发模式下排除debug文件夹中的所有Java文件&lt;/span&gt;
                java {
                    exclude 'debug&lt;span class=&quot;co&quot;&gt;/**'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;                }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;            }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    }&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;    buildTypes {&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        release {&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;            minifyEnabled false&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    }&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;dependencies {&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    implementation project(':b-ga-common-function-comlib')&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;    if (!isModule.toBoolean()) {&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        annotationProcessor &quot;com.alibaba:arouter-compiler:${rootProject.annotationProcessor}&quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要有几点说明一下：&lt;/p&gt;
&lt;p&gt;1，通过 isModule.toBoolean() 方法来进行组件间集成模式和组件模式的切换，包括模块是属于Application 还是 Library，由于集成了 ARouter，所以需要对 ARouter 配置文件进行处理。&lt;/p&gt;
&lt;p&gt;2，如果组件模式下， 则需要重新设置 AndroidManifest.xml 文件，里面配置新的Application路径。比如Login组件单独运行 AndroidManifest 清单文件&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&amp;lt;manifest xmlns:android=&lt;span class=&quot;st&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt;=&quot;hik.ga.business.applogin&quot; &amp;gt;

    &amp;lt;application
        android:name=&lt;span class=&quot;st&quot;&gt;&quot;debug.LoginApplication&quot;&lt;/span&gt;
        android:allowBackup=&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;
        android:icon=&lt;span class=&quot;st&quot;&gt;&quot;@mipmap/ic_launcher&quot;&lt;/span&gt;
        android:label=&lt;span class=&quot;st&quot;&gt;&quot;@string/login_btn_str&quot;&lt;/span&gt;
        android:supportsRtl=&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;
        android:theme=&lt;span class=&quot;st&quot;&gt;&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;&lt;/span&gt;&amp;gt;

        &amp;lt;activity
            android:name=&lt;span class=&quot;st&quot;&gt;&quot;hik.ga.business.applogin.login.views.LoginActivity&quot;&lt;/span&gt;
            android:label=&lt;span class=&quot;st&quot;&gt;&quot;@string/login_btn_str&quot;&lt;/span&gt;
            android:launchMode=&lt;span class=&quot;st&quot;&gt;&quot;singleTop&quot;&lt;/span&gt;
            android:screenOrientation=&lt;span class=&quot;st&quot;&gt;&quot;portrait&quot;&lt;/span&gt;
            android:theme=&lt;span class=&quot;st&quot;&gt;&quot;@style/AppTheme.NoActionBarFullScreen&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;intent-filter&amp;gt;
                &amp;lt;action android:name=&lt;span class=&quot;st&quot;&gt;&quot;android.intent.action.MAIN&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;category android:name=&lt;span class=&quot;st&quot;&gt;&quot;android.intent.category.LAUNCHER&quot;&lt;/span&gt; /&amp;gt;
            &amp;lt;/intent-filter&amp;gt;
        &amp;lt;/activity&amp;gt;

    &amp;lt;/application&amp;gt;
&amp;lt;/manifest&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3，实现组件全局应用配置类，这个类的目的是在组件加载时初始化一些组件自身的资源，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; LoginApplicationDelegate &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; IApplicationDelegate {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String TAG = &lt;span class=&quot;st&quot;&gt;&quot;LoginApplicationDelegate&quot;&lt;/span&gt;;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;() {
        EFLog.&lt;span class=&quot;fu&quot;&gt;d&lt;/span&gt;(TAG, &lt;span class=&quot;st&quot;&gt;&quot;*------------------onCreate()----------------&amp;gt;&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;enterBackground&lt;/span&gt;() {
        EFLog.&lt;span class=&quot;fu&quot;&gt;d&lt;/span&gt;(TAG, &lt;span class=&quot;st&quot;&gt;&quot;*------------------enterBackground()----------------&amp;gt;&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;enterForeground&lt;/span&gt;() {
        EFLog.&lt;span class=&quot;fu&quot;&gt;d&lt;/span&gt;(TAG, &lt;span class=&quot;st&quot;&gt;&quot;*------------------enterForeground()----------------&amp;gt;&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;receiveRemoteNotification&lt;/span&gt;(Map&amp;lt;String, String&amp;gt; message) {
        EFLog.&lt;span class=&quot;fu&quot;&gt;d&lt;/span&gt;(TAG, &lt;span class=&quot;st&quot;&gt;&quot;receiveRemoteNotification msg = &quot;&lt;/span&gt; + message);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onTerminate&lt;/span&gt;() {
        EFLog.&lt;span class=&quot;fu&quot;&gt;d&lt;/span&gt;(TAG, &lt;span class=&quot;st&quot;&gt;&quot;*------------------onTerminate()----------------&amp;gt;&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onConfigurationChanged&lt;/span&gt;(Configuration configuration) {
        EFLog.&lt;span class=&quot;fu&quot;&gt;d&lt;/span&gt;(TAG, &lt;span class=&quot;st&quot;&gt;&quot;*------------------onConfigurationChanged()----------------&amp;gt;&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onLowMemory&lt;/span&gt;() {
        EFLog.&lt;span class=&quot;fu&quot;&gt;d&lt;/span&gt;(TAG, &lt;span class=&quot;st&quot;&gt;&quot;*------------------onLowMemory()----------------&amp;gt;&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onTrimMemory&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; var1) {
        EFLog.&lt;span class=&quot;fu&quot;&gt;d&lt;/span&gt;(TAG, &lt;span class=&quot;st&quot;&gt;&quot;*------------------onTrimMemory()----------------&amp;gt;&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三，路由服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，定义公共组件路由API和入口，通过路由服务组件查找，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-fe219baac5388f13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;公共路由服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2，组件路由实现&lt;/p&gt;
&lt;p&gt;每个组件对外提供什么能力，首先需要在路由服务组件创建一个接口文件，如下是登陆组件接口声明和实现。&lt;/p&gt;
&lt;p&gt;Login 接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-12b085cd01eb8102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;定义Login接口&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/788498-1a252fdf67017380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Login接口具体实现&quot;/&gt;&lt;/p&gt;
&lt;p&gt;路由使用：比如我们想从设置页面跳转到登陆页面，使用 Login 接口里的方法，使用如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;ILoginProvider loginService = (ILoginProvider) ARouter.&lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;(RouterPath.&lt;span class=&quot;fu&quot;&gt;ROUTER_PATH_TO_LOGIN_SERVICE&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;navigation&lt;/span&gt;();
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(loginService != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
    loginService.&lt;span class=&quot;fu&quot;&gt;accountToLogin&lt;/span&gt;(AccountActivity.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;总的来说，通过应用组件化框架，使得我们工作中的具体项目变得更轻、好组装、编译构建更快，不仅提高工作效率，同时自我对移动应用开发认知有进一步的提升。因为组件化框架具有通用性，特别适用于业务模块迭代多，量大的大中型项目，是一个很好的解决方案。至于组件化框架之后演化的道路，则是打造组件仓库，完善组件开发规范，丰富组件功能库，有一些粒度大的业务组件可以进一步的细化，对组件功能进行更单一的内聚，同时基于现有组件化框架，便于过度在未来打造插件化框架，进一步升级 APP 动态能力，比如热加载、热修复等，那又是另一种使用场景和设计架构了，其实组件化和插件化框架最大的区别就是在是否具备动态更新能力。&lt;/p&gt;
&lt;p&gt;把项目简化下，github地址：&lt;a href=&quot;https://github.com/cr330326/DemoComponent&quot;&gt;DemoComponent&lt;/a&gt;，感兴趣的可以下过去看看。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;1，&lt;a href=&quot;http://blog.csdn.net/guiying712/article/details/55213884&quot;&gt;Android组件化方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2，&lt;a href=&quot;https://www.jianshu.com/p/1b1d77f58e84&quot;&gt;Android彻底组件化方案实践&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 15:40:00 +0000</pubDate>
<dc:creator>cryAllen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cr330326/p/8419899.html</dc:identifier>
</item>
<item>
<title>------- 软件调试——挫败 QQ.exe 的内核模式保护机制 ------- - f1yin9_0x5hark</title>
<link>http://www.cnblogs.com/flying-shark/p/8419853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-shark/p/8419853.html</guid>
<description>
&lt;p&gt;————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QQ 是一款热门的即时通信（IM）类工具，在安装时刻会向系统分区的 \..\windows\system32\drivers 路径下生成两个驱动程序文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QQProtect.sys 与 QQFrmMgr.sys ，前者是 QQProtect.exe（QQ 安全防护进程，又称 Q 盾）的内核模式组件；后者是一种过滤型驱动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时还会向注册表位置 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\ 创建对应名称的键，其中有重要的两个&lt;span&gt;子键&lt;/span&gt;控制&lt;/span&gt;&lt;span&gt;这两个驱动的加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方&lt;/span&gt;&lt;span&gt;式：“type”与“start”——对于 QQProtect.sys ，其键值分别为 1 和 2，这意味着由 services.exe（服务控制&lt;/span&gt;&lt;span&gt;管理器）自动将 QQProtect.sys 载入内核&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;空&lt;/span&gt;&lt;span&gt;间；&lt;/span&gt;&lt;span&gt;对于 QQFrmMgr.sys，其键值分别为 1 和 1，这意味着在内核初始化期间，由 ntoskrnl.exe 将 QQFrmMgr.sys 载入内核空间，就加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的顺序而言，QQFrmMgr.sys 早于 QQProtect.sys ，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205223240373-1483520590.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;尽管这两个驱动并非 Rootkit 或者恶意软件，但它们确实会 hook 系统服务调度表/Shadow、在 &lt;span&gt;System 进程&lt;/span&gt;中注入内核线程、注&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;册一些通知回调。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以也算是更改了系统的一些关键数据结构来进行非正当活动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文探讨如何使用内核调试器 WinDbg.exe 来检查诸如此类为保护 QQ 进程而采取的内核空间手段，然后把系统还原至“干净”状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试环境是两台真实的计算机（双机物理调试）——&lt;span&gt;运行 Windows 7 的 宿主机（调试机），以及运行 Windows 8.1 的目标机（被调试机，已安装了 QQ）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两者通过以太网线连接进行调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，通过以太网线执行双机物理调试时，对调试机的网卡无特殊要求；但是被调试机的网卡必须被 &lt;/span&gt;&lt;span&gt;Debugging Tools for Windows 所支持（亦即 Kd.exe&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与 WinDbg.exe），而且被调试机上的操作系统版本需要是 windows 8 或者更后面的版本；&lt;/span&gt;&lt;span&gt;调试机上的操作系统需要是 windows xp 或更后面的版本。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用以太网调试的一大好处就是，通信介质获取方便——相较于老旧的串口线（RS-232）以及主板上基本被淘汰的 COM 模块而言，Cat5 标准以上的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网络线随便在电脑城就能买到，而且主板上绝不可能没有网络接口卡使用的 RJ-45 端口。。。。想必以太网调试一定会成为日后的标准！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一方面，我也实施了&lt;span&gt;物理-虚拟机调试&lt;/span&gt;，虚拟机作为被调试机，其上运行 Windows 7，这样不但能够对比出，QQ 驱动针对不同内核版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（Windows 7 是内核版本 6.1 ；Windows 8.1 是内核版本 6.3）所表现出来的逻辑差异，还能够明确 QQ 驱动是否采取了“反虚拟机”&lt;/span&gt;&lt;span&gt;技术，并且揭示它在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;真实机器上的行为！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因此下面的调试过程中，所有与真实机器上不同的结果我都会另行说明。&lt;/span&gt;&lt;span&gt;在开始之前，来过目一下我配置的双机物理调试参数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; cd &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d:\Windows Kits\10\Debuggers\x86&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp; d: &amp;amp;&amp;amp; windbg.exe -n -v -logo d:\networking_physical_host-target_debugging.txt -y SRV*E:\windows8_1_retail_symbols*http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;msdl.microsoft.com/download/symbols -k net:port=60111,key=shayi.1983.gmail.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;其中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❶ &lt;/span&gt;&lt;span&gt;我将 Windows Kits 驱动开发工具包安装到了“d:\Windows Kits”目录下；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❷ 输出调试信息到指定的日志文件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❸ 指定微软的符号服务器 URL，这样调试器就可以通过 HTTP GET 请求，按需从服务器下载并解析特定内核模块中的函数符号；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❹ 以及预先存储在本地的符号文件（可以从 MSDN 站点下载，整个 MSI 封装的符号包大小约为五、六百 MB）所在路径；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （&lt;span&gt;注意，宿主机上内核版本的不同导致需要分别下载对应的符号文件，并指定为调试参数&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❺ 指定通过以太网调试（net），宿主机上开启调试端口为 UDP 的 60111；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❻ 最后的 key 可以任意指定，但其中的 4 个子域之间需要用点号分隔开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于目标机上的对应配置，请各位参见 MSDN 文档，这里就不再赘述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;——————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先在 Windows 8.1 目标机上通过 Process Explorer 浏览到 System 进程中的系统线程，其中有一个 QQ 内核线程是由&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QQFrmMgr.sys &lt;/span&gt;&lt;span&gt;创建的，该线程的启动地址距离所属模块被载入基址的偏移量为 0x5e34 ：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205223811154-517512944.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们的目标是结束该线程的执行，通常的做法是用系统内置的 &lt;span&gt;APC（异步过程调用）&lt;/span&gt;机制来实现。APC 就是运行在特定线程上下文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;例程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从编程角度来讲，调用 KeInitializeApc() 初始化一个 &lt;span&gt;nt!_KAPC&lt;/span&gt; 结构，并将其关联到该 QQ 内核线程的 &lt;span&gt;nt!_KTHREAD&lt;/span&gt; 结构，&lt;/span&gt;&lt;span&gt;设定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该 APC 例程回调为 &lt;/span&gt;&lt;span&gt;&lt;span&gt;PspExitThread()&lt;/span&gt;；&lt;/span&gt;&lt;span&gt;然后利用 KeInsertQueueApc() 通过这个 nt!_KTHREAD 结构来排入该 QQ 内核线程的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;APC 队列，如此一来，&lt;/span&gt;&lt;span&gt;当该 APC 被交付时，&lt;/span&gt;&lt;span&gt;就会在该 QQ 内核线程的执行上下文中调用 PspExitThread()，从而终止掉该 QQ 内&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;核线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而在调试环境下，没有对应的内核 API 可用，所以我们必须手工构造 APC、指定回调函数、关联线程、以及排入队列，如下步骤所&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：查询 System 进程的 nt!_EPROCESS 结构地址；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：定位到其中的线程双向链表头部，然后开始遍历这个链表中的每一个 nt!_ETHREAD 结构，找出那些启动地址位于&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QQFrmMgr.sys &lt;/span&gt;&lt;span&gt;模块空间内的线程：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205224028341-591872758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 相应的 WinDbg 命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; !list &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-t nt!_LIST_ENTRY.FLink -e -x \&quot;r @$t3=@$extret-@$t1; &lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; r @$t4= @$t3+&lt;span&gt;@$t2;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; r @$t5=&lt;span&gt;poi(@$t4);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; .&lt;span&gt;if&lt;/span&gt;(@@((unsigned &lt;span&gt;long&lt;/span&gt;)@$t5&amp;gt;(unsigned &lt;span&gt;long&lt;/span&gt;)&lt;span&gt;0x82000000&lt;/span&gt; &amp;amp;&amp;amp; (unsigned &lt;span&gt;long&lt;/span&gt;)@$t5&amp;lt;(unsigned &lt;span&gt;long&lt;/span&gt;)&lt;span&gt;0x82017b00&lt;/span&gt;)){r @$t3;dt -b nt!&lt;span&gt;_ETHREAD Cid. @$t3; dds @$t4 l1;}; 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; \&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 8565e5c0+@$t0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205224314466-232482037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205224412404-2063064714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：手工构建一个 nt!_KAPC 结构，指定回调函数、关联线程、以及排入队列：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3-1）：查询 QQFrmMgr.sys 模块内部的 section 信息，注意到其中的 .data section 后紧接 INIT section：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205224455920-823370704.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从上图可知，.data section 起始 RVA 为 11800，大小 3C80，结束 RVA 为 15480，这刚好是 INIT section 的起始 RVA。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;INIT section 的属性中，&lt;span&gt;“&lt;span&gt;Discardable”与“Execute Read Write”完美匹配了手工构建 APC 需要的写属性，以及回调函数需要&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;执行属性，所以它是理想&lt;/span&gt;&lt;span&gt;的目标 section。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3-2）：从 INIT section 起始地址初始化 0x200 字节内存，此块区域用于 nt!_KAPC 结构和回调函数&lt;/span&gt;&lt;span&gt;（nt!_KAPC 的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;KernelRoutine&lt;/span&gt; 字段）。如下图所示，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在地址 &lt;span&gt;82015480&lt;/span&gt; 处构造的回调函数调用 PspExitThread() 来结束当前线程&lt;/span&gt;&lt;span&gt;的运行；然后在地址 &lt;span&gt;82015500&lt;/span&gt; 处构造一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nt!_KAPC 结构；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205224640623-1460077245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; r @$t0=&lt;span&gt;82015500&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; r @$t1=&lt;span&gt;8b9ccbc0; 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; r@$t2=&lt;span&gt;82015480&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; ?? ((nt!_KAPC*)@$t0)-&amp;gt;Type=&lt;span&gt;18&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; ?? ((nt!_KAPC*)@$t0)-&amp;gt;Size=sizeof(nt!&lt;span&gt;_KAPC);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; ?? ((nt!_KAPC*)@$t0)-&amp;gt;Thread=&lt;span&gt;@$t1;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; ?? ((nt!_KAPC*)@$t0)-&amp;gt;KernelRoutine=&lt;span&gt;@$t2;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; ?? ((nt!_KAPC*)@$t0)-&amp;gt;Inserted=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; r @$t3=@@(&amp;amp;(((nt!_ETHREAD*)@$t1)-&amp;gt;Tcb.ApcState.ApcListHead[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; r @$t4=@@(&amp;amp;(((nt!_KAPC*)@$t0)-&amp;gt;&lt;span&gt;ApcListEntry));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; r @$t5=@@(((nt!_LIST_ENTRY*)@$t3)-&amp;gt;&lt;span&gt;Flink);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; ?? ((nt!_LIST_ENTRY*)@$t4)-&amp;gt;Flink=&lt;span&gt;@$t5;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; ?? ((nt!_LIST_ENTRY*)@$t4)-&amp;gt;Blink=&lt;span&gt;@$t3;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; ?? ((nt!_LIST_ENTRY*)@$t5)-&amp;gt;Blink=&lt;span&gt;@$t4;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; ?? ((nt!_LIST_ENTRY*)@$t3)-&amp;gt;Flink=&lt;span&gt;@$t4;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; ?? ((nt!_ETHREAD*)@$t1)-&amp;gt;Tcb.ApcState.KernelApcPending=&lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;变量“t1”的值是前面查询到的 QQ 内核线程的 nt!_ETHREAD 结构；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变量“t3”用来定位到 nt!_ETHREAD 结构中的第一个 APC 队列头部（&lt;span&gt;Tcb.ApcState.ApcListHead[0]&lt;/span&gt;）；这个队列头部&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的“Flink”字段&lt;/span&gt;&lt;span&gt;（指向下一个 nt!_KAPC 结构）由变量“t5”存储；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变量“t4”亦即我们构建的 nt!_KAPC 结构中的“&lt;span&gt;ApcListEntry&lt;/span&gt;”字段，它被用来初始化“t5”；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种初始化逻辑类似于下面的 C 代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  KTHREAD.ApcState.ApcListHead[&lt;span&gt;0&lt;/span&gt;]-&amp;gt;Flink = KAPC-&amp;gt;ApcListEntry;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;验证我们的操作是否正确：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205225222857-1751485209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;整个过程的形象图示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205225324388-357548917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了理解 APC 交付的机制，我们在回调函数入口处设置一个断点，然后就能够通过栈回溯信息得知该回调是如何被调用的，按&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下“g”键&lt;/span&gt;&lt;span&gt;恢复目标机器的执&lt;/span&gt;&lt;span&gt;行，等待 APC 交付时触发断点：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205225427248-1318213836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从上图可以看到，这种 APC 交付机制其实并不神秘—— 传递给 PspSystemThreadStartup() 的首个参数就是 QQFrmMgr.sys 创&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建的 &lt;/span&gt;&lt;span&gt;QQ 内核线程的启动地&lt;/span&gt;&lt;span&gt;址，表明它被调度运行了；经过一系列调用后，&lt;span&gt;KiSwapThread() 从它接收到的首个参数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（0x8b9ccbc0，亦即 QQ 内核线程的 nt!_ETHREAD 结构地址）中，&lt;/span&gt;&lt;span&gt;&lt;span&gt;定位到其 APC 队列头部，然后调用链表中第一个 nt!_KAPC&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;结构的&lt;/span&gt;&lt;span&gt;“KernelRoutine”回调，从而触发我们先前设置的断点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按下“g”键继续运行，导致 PspExitThread() 把 QQ 内核线程终止掉然后返回，现在通过 Process Explorer 浏览目标机器上，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System 进程中的系统线程&lt;/span&gt;&lt;span&gt;们，已经找不到 QQFrmMgr.sys+0x5e34 那个线程了，另一方面，也可以在调试机器上验证：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; r @$t0=@@(#FIELD_OFFSET(nt!&lt;span&gt;_EPROCESS, ThreadListHead));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; r @$t1= @@(#FIELD_OFFSET(nt!&lt;span&gt;_ETHREAD, ThreadListEntry));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; r @$t2=@@(#FIELD_OFFSET(nt!&lt;span&gt;_ETHREAD, StartAddress));
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; !list &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-t nt!_LIST_ENTRY.FLink -e -x \&quot;r @$t3=@$extret-@$t1; &lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; r @$t4= @$t3+&lt;span&gt;@$t2; 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; r @$t5=&lt;span&gt;poi(@$t4);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; .&lt;span&gt;if&lt;/span&gt;(@@((unsigned &lt;span&gt;long&lt;/span&gt;)@$t5&amp;gt;(unsigned &lt;span&gt;long&lt;/span&gt;)&lt;span&gt;0x82000000&lt;/span&gt; &amp;amp;&amp;amp; (unsigned &lt;span&gt;long&lt;/span&gt;)@$t5&amp;lt;(unsigned &lt;span&gt;long&lt;/span&gt;)&lt;span&gt;0x82017b00&lt;/span&gt;)){r @$t3;dt -b nt!_ETHREAD Cid. ExitStatus @$t3; dt -b nt!&lt;span&gt;_KTHREAD Header. @$t3; }; 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; \&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 8565e5c0+@$t0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205225814763-1020555222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;——————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结：本篇讨论了如何利用内核提供的基础设施——APC——来挫败 QQ 过滤驱动向内核空间注入的可执行代码，并在基于 &lt;/span&gt;&lt;span&gt;Windows 8.1（NT 6.3 版内&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;核）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;的真实机器上成功实践，限于篇幅，后续博文将介绍如何检测并还原 QQ 驱动修改的其它内核数据结构，&lt;/span&gt;&lt;span&gt;以及清除它安装的钩子例程！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;——————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;

</description>
<pubDate>Mon, 05 Feb 2018 15:20:00 +0000</pubDate>
<dc:creator>f1yin9_0x5hark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-shark/p/8419853.html</dc:identifier>
</item>
<item>
<title>redis通过pipeline提升吞吐量 - zale.tang</title>
<link>http://www.cnblogs.com/littleatp/p/8419796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/8419796.html</guid>
<description>&lt;h2 id=&quot;案例目标&quot;&gt;案例目标&lt;/h2&gt;
&lt;p&gt;简单介绍 redis pipeline 的机制，结合一段实例说明pipeline 在提升吞吐量方面发生的效用。&lt;/p&gt;
&lt;h2 id=&quot;案例背景&quot;&gt;案例背景&lt;/h2&gt;
&lt;p&gt;应用系统在数据推送或事件处理过程中，往往出现数据流经过多个网元；&lt;br/&gt;然而在某些服务中，数据操作对redis 是强依赖的，在最近的一次分析中发现：&lt;br/&gt;&lt;strong&gt;一次数据推送会对 redis 产生近30次读写操作！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数据推送业务中的性能压测中，以数据上报 -&amp;gt; 下发应答为一次事务；&lt;br/&gt;而对于这样的读写模型，redis 的操作过于频繁，很快便导致系统延时过高，吞吐量低下，无法满足目标；&lt;/p&gt;
&lt;p&gt;优化过程 主要针对业务代码做的优化，其中redis 操作经过大量合并，最终降低到原来的1/5，而系统吞吐量也提升明显。&lt;br/&gt;其中，&lt;strong&gt;redis pipeline(管道机制)&lt;/strong&gt; 的应用是一个关键手段。&lt;/p&gt;
&lt;h2 id=&quot;pipeline的解释&quot;&gt;pipeline的解释&lt;/h2&gt;
&lt;p&gt;Pipeline指的是管道技术，指的是客户端允许将多个请求依次发给服务器，过程中而不需要等待请求的回复，在最后再一并读取结果即可。&lt;br/&gt;管道技术使用广泛，例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。&lt;br/&gt;Redis很早就支持管道（pipeline）技术。(因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作Redis)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普通请求模型&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/242916/201802/242916-20180205184814060-1691050944.png&quot;/&gt;&lt;br/&gt;[图-pipeline1]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pipeline请求模型&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/242916/201802/242916-20180205184821607-996015857.png&quot;/&gt;&lt;br/&gt;[图-pipeline2]&lt;/p&gt;
&lt;p&gt;从两个图的对比中可看出，普通的请求模型是同步的，每次请求对应一次IO操作等待；&lt;br/&gt;而Pipeline 化之后所有的请求合并为一次IO，除了时延可以降低之外，还能大幅度提升系统吞吐量。&lt;/p&gt;
&lt;h2 id=&quot;代码实例&quot;&gt;代码实例&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;br/&gt;本地开启50个线程，每个线程完成1000个key的写入，对比pipeline开启及不开启两种场景下的性能表现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关常量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   // 并发任务
    private static final int taskCount = 50;
    // pipeline大小
    private static final int batchSize = 10;
    // 每个任务处理命令数
    private static final int cmdCount = 1000;

    private static final boolean usePipeline = true;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;初始化连接&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxActive(200);
        poolConfig.setMaxIdle(100);
        poolConfig.setMaxWait(2000);
        poolConfig.setTestOnBorrow(false);
        poolConfig.setTestOnReturn(false);

        jedisPool = new JedisPool(poolConfig, host, port);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;并发启动任务，统计执行时间&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) throws InterruptedException {
        init();

        flushDB();

        long t1 = System.currentTimeMillis();
        ExecutorService executor = Executors.newCachedThreadPool();

        CountDownLatch latch = new CountDownLatch(taskCount);
        for (int i = 0; i &amp;lt; taskCount; i++) {
            executor.submit(new DemoTask(i, latch));
        }

        latch.await();
        executor.shutdownNow();

        long t2 = System.currentTimeMillis();

        System.out.println(&quot;execution finish time(s):&quot; + (t2 - t1) / 1000.0);

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DemoTask&lt;/strong&gt; 封装了执行key写入的细节，区分不同场景&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void run() {
            logger.info(&quot;Task[{}] start.&quot;, id);
            try {
                if (usePipeline) {
                    runWithPipeline();
                } else {
                    runWithNonPipeline();
                }
            } finally {
                latch.countDown();
            }

            logger.info(&quot;Task[{}] end.&quot;, id);
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不使用Pipeline的场景比较简单，循环执行set操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            for (int i = 0; i &amp;lt; cmdCount; i++) {
                Jedis jedis = get();
                try {
                    jedis.set(key(i), UUID.randomUUID().toString());
                } finally {
                    if (jedis != null) {
                        jedisPool.returnResource(jedis);
                    }
                }
                if (i % batchSize == 0) {
                    logger.info(&quot;Task[{}] process -- {}&quot;, id, i);
                }
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Pipeline，需要处理分段，如10个作为一批命令执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;         for (int i = 0; i &amp;lt; cmdCount;) {
                Jedis jedis = get();

                try {
                    Pipeline pipeline = jedis.pipelined();
                    int j;
                    for (j = 0; j &amp;lt; batchSize; j++) {
                        if (i + j &amp;lt; cmdCount) {
                            pipeline.set(key(i + j), UUID.randomUUID().toString());
                        } else {
                            break;
                        }
                    }
                    pipeline.sync();
                    logger.info(&quot;Task[{}] pipeline -- {}&quot;, id, i + j);

                    i += j;

                } finally {
                    if (jedis != null) {
                        jedisPool.returnResource(jedis);
                    }
                }

            }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行结果&quot;&gt;运行结果&lt;/h3&gt;
&lt;p&gt;不使用Pipeline，整体执行26s；而使用Pipeline优化后的代码，执行时间仅需要3s！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NoPipeline-stat&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/242916/201802/242916-20180205184840295-630333542.png&quot;/&gt;&lt;br/&gt;[图-nopipeline]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pipeline-stat&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/242916/201802/242916-20180205184856732-300352579.png&quot;/&gt;&lt;br/&gt;[图-pipeline]&lt;/p&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;pipeline机制可以优化吞吐量，但无法提供原子性/事务保障，而这个可以通过Redis-Multi等命令实现。&lt;br/&gt;&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;参考这里&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;部分读写操作存在相关依赖，无法使用pipeline实现，可利用&lt;a href=&quot;https://redis.io/commands/exec&quot;&gt;Script机制&lt;/a&gt;，但需要在可维护性方面做好取舍。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;扩展阅读&quot;&gt;扩展阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://redis.io/topics/pipelining&quot;&gt;官方文档-Redis-Pipelining&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;官方文档-Redis-Transaction&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 15:03:00 +0000</pubDate>
<dc:creator>zale.tang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/8419796.html</dc:identifier>
</item>
<item>
<title>dubbo扩展http协议后FullGC - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/8419637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/8419637.html</guid>
<description>&lt;h3 id=&quot;问题&quot;&gt;问题&lt;/h3&gt;
&lt;p&gt;dubbo内部定制的版本中，在处理大于10K的包的时候，会出现内存溢出的现象&lt;/p&gt;
&lt;p&gt;原因是我们在定制dubbo http协议的时候，使用了jboss包里面的HttpRequestDecoder的http decoder方法来解析http协议内容&lt;br/&gt;该方法在解析非http协议的大内容时，会出现内存溢出的情况&lt;/p&gt;
&lt;p&gt;某个服务因为这个问题，出现了full gc 的情况&lt;/p&gt;
&lt;h3 id=&quot;复现问题&quot;&gt;复现问题&lt;/h3&gt;
&lt;p&gt;根据描述复现该问题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;指定dubbo版本&lt;/li&gt;
&lt;li&gt;dubbo请求，非http请求&lt;/li&gt;
&lt;li&gt;消息体大于10K&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;jvm堆配置，jmap -heap pid&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Heap Configuration:
   MinHeapFreeRatio         = 0
   MaxHeapFreeRatio         = 100
   MaxHeapSize              = 2147483648 (2048.0MB)
   NewSize                  = 44564480 (42.5MB)
   MaxNewSize               = 715653120 (682.5MB)
   OldSize                  = 89653248 (85.5MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造provider和consumer，然后在consumer的入参约100K，启动tomcat（JVM）的时候添加打印gc详细信息的参数，发起调用的时候观察gc情况&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;-XX:+PrintGCDetails -XX:+PrintGCDateStamps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次调用的时候并没有出现Full GC的情况，想着是不是并发有点小，毕竟线上还是有一定并发量的，所以consumer端启动线程来调用，启动线程个数1、10、100、1000，线程数是1000的时候provider侧出现了FullGC的情况&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;2018-01-19T21:01:23.758-0800: [GC (Allocation Failure) [PSYoungGen: 454144K-&amp;gt;696K(468992K)] 1394833K-&amp;gt;1383056K(1867264K), 0.1343399 secs] [Times: user=0.26 sys=0.01, real=0.14 secs] 
2018-01-19T21:01:23.892-0800: [Full GC (Ergonomics) [PSYoungGen: 696K-&amp;gt;0K(468992K)] [ParOldGen: 1382359K-&amp;gt;940805K(1398272K)] 1383056K-&amp;gt;940805K(1867264K), [Metaspace: 52098K-&amp;gt;52098K(1097728K)], 0.2305879 secs] [Times: user=0.54 sys=0.01, real=0.23 secs] 
2018-01-19T21:01:24.629-0800: [Full GC (Ergonomics) [PSYoungGen: 464621K-&amp;gt;0K(468992K)] [ParOldGen: 1382601K-&amp;gt;941472K(1398272K)] 1847223K-&amp;gt;941472K(1867264K), [Metaspace: 52098K-&amp;gt;52098K(1097728K)], 0.2063340 secs] [Times: user=0.59 sys=0.00, real=0.21 secs] 
2018-01-19T21:01:25.305-0800: [Full GC (Ergonomics) [PSYoungGen: 454693K-&amp;gt;0K(468992K)] [ParOldGen: 1383395K-&amp;gt;499265K(1398272K)] 1838088K-&amp;gt;499265K(1867264K), [Metaspace: 52098K-&amp;gt;52098K(1097728K)], 0.1478104 secs] [Times: user=0.34 sys=0.01, real=0.15 secs] 
2018-01-19T21:01:25.945-0800: [Full GC (Ergonomics) [PSYoungGen: 457504K-&amp;gt;0K(468992K)] [ParOldGen: 1383424K-&amp;gt;499950K(1398272K)] 1840928K-&amp;gt;499950K(1867264K), [Metaspace: 52098K-&amp;gt;52098K(1097728K)], 0.1390671 secs] [Times: user=0.36 sys=0.00, real=0.14 secs] 
2018-01-19T21:01:26.585-0800: [Full GC (Ergonomics) [PSYoungGen: 456673K-&amp;gt;0K(468992K)] [ParOldGen: 1384488K-&amp;gt;499639K(1398272K)] 1841162K-&amp;gt;499639K(1867264K), [Metaspace: 52098K-&amp;gt;52098K(1097728K)], 0.1344279 secs] [Times: user=0.32 sys=0.01, real=0.14 secs] &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;jstat -gc pid -t 1s&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Timestamp        S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
         1438.8 1024.0 5120.0  0.0    0.0   443392.0 430848.7 1398272.0   478878.3  53464.0 52117.3 6144.0 5945.4   1733   97.928  949   166.820  264.748
         1440.0 1024.0 5120.0  0.0    0.0   443392.0 435843.6 1398272.0  1321492.8  53464.0 52117.3 6144.0 5945.4   1733   97.928  950   166.962  264.889
         1441.0 1024.0 5120.0  0.0    0.0   443392.0 433460.4 1398272.0   900800.9  53464.0 52117.3 6144.0 5945.4   1733   97.928  952   167.226  265.153
         1441.9 1024.0 5120.0  0.0    0.0   443392.0   0.0    1398272.0   479419.0  53464.0 52117.3 6144.0 5945.4   1733   97.928  954   167.491  265.419
         1443.0 1024.0 5120.0  0.0    0.0   443392.0 438270.0 1398272.0  1324328.4  53464.0 52117.3 6144.0 5945.4   1733   97.928  955   167.632  265.560
         1444.0 1024.0 5120.0  0.0    0.0   443392.0 437239.3 1398272.0   902696.2  53464.0 52117.3 6144.0 5945.4   1733   97.928  957   167.902  265.830
         1445.0 1024.0 5120.0  0.0    0.0   443392.0 440249.7 1398272.0  1326030.9  53464.0 52117.3 6144.0 5945.4   1733   97.928  959   168.046  265.974
         1446.0 1024.0 5120.0  0.0    0.0   443392.0 434997.3 1398272.0   903830.7  53464.0 52117.3 6144.0 5945.4   1733   97.928  960   168.341  266.269
         1447.0 1024.0 5120.0  0.0    0.0   443392.0 423591.6 1398272.0   480931.8  53464.0 52117.3 6144.0 5945.4   1733   97.928  962   168.610  266.537&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;问题原因&quot;&gt;问题原因&lt;/h3&gt;
&lt;p&gt;发生了FullGC，先拿出现在的Heap Dump看看当前JVM的堆内存使用情况&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;jmap -dump:format=b,file=dump.bin pid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到dump文件，拿到MAT中分析下，在dominator_tree视图中找到占用内存较多的对象，这里是byte数组，接下来找到byte数组属于哪一个类，在byte数据上右键&quot;Path To GC Roots&quot; -&amp;gt; &quot;with all reference&quot;就是下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/846961/201802/846961-20180205221931873-1727163326.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到org.jboss.netty.handler.codec.frame.FrameDecoder#cumulation这个对象很大，这个类是HttpRequestDecoder的超类，接下来就是调试源码，查看为什么这个字段会这么大&lt;/p&gt;
&lt;p&gt;找到这个字段的所有引用的地方，查看哪里往byte数组（cumulation这个字段包含一个byte数组）中写，主要是下面两个方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 这个方法只是把原来的cumulation和新增的input复合到一个对象中，CompositeChannelBuffer&lt;/span&gt;
org.&lt;span class=&quot;fu&quot;&gt;jboss&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;netty&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;codec&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;frame&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FrameDecoder&lt;/span&gt;#appendToCumulation
&lt;span class=&quot;co&quot;&gt;// 这个方法会对cumulation重新赋值，并把input写入cumulation中，也就是这个时候byte数组会增大&lt;/span&gt;
org.&lt;span class=&quot;fu&quot;&gt;jboss&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;netty&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;codec&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;frame&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FrameDecoder&lt;/span&gt;#updateCumulation&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;org.jboss.netty.handler.codec.replay.ReplayingDecoder#messageReceived方法中调用上面这两个方法，ReplayingDecoder是HttpRequestDecoder的超类，在接收到请求的时候会调用messageReceived方法，所以在接收到请求的时候就会向cumulation中写数据。&lt;/p&gt;
&lt;p&gt;那么现在问题基本清晰了，不断往byte数组中写数据导致byte数组不断增大，问题应该出在byte数组没有被清空上，所以现在的问题是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么cumulation没有被清空？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查找所有cumulation被清空的方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;org.&lt;span class=&quot;fu&quot;&gt;jboss&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;netty&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;codec&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;replay&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ReplayingDecoder&lt;/span&gt;#cleanup&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看看谁调用了这个方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 连接断开的时候调用这个方法&lt;/span&gt;
org.&lt;span class=&quot;fu&quot;&gt;jboss&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;netty&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;codec&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;frame&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FrameDecoder&lt;/span&gt;#channelDisconnected
&lt;span class=&quot;co&quot;&gt;// 连接关闭的时候调用这个方法&lt;/span&gt;
org.&lt;span class=&quot;fu&quot;&gt;jboss&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;netty&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;codec&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;frame&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FrameDecoder&lt;/span&gt;#channelClosed&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以只有在连接断开或者关闭的时候才会清空cumulation，结论已经呼之欲出了，回到一开始出现的问题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;dubbo请求，非http请求&lt;/li&gt;
&lt;li&gt;大量并发请求&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在接收到dubbo请求的时候，虽然不是http协议，但是还是会执行HttpRequestDecoder这个handler，也就会往cumulation中写数据，但是dubbo协议使用的是长连接（netty维护的长连接），所以dubbo请求的内容都会被加入到cumulation中，直到连接关闭或者断开才会清空，如果并发量大的话就会导致有多个cumulation大对象，如果对空间不够的时候就会引起FullGC。&lt;/p&gt;
&lt;p&gt;而http协议一般都是短连接，或者有超时时间（服务端超时或者客户端超时），这样cumulation就会被及时清空，所以http协议不容易出现这种问题，而dubbo协议更容易出现的原因。&lt;/p&gt;
&lt;h3 id=&quot;解决问题&quot;&gt;解决问题&lt;/h3&gt;
&lt;p&gt;既然是非http请求就不需要使用HttpRequestDecoder做进一步处理，所以新建一个类HttpRequestWrapDecoder继承自HttpRequestDecoder，重写messageReceived方法，在该方法里面判断是否是http请求，如果是http请求才会进一步处理，否则直接返回不处理，执行pipeline中下一个handler&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 14:20:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/8419637.html</dc:identifier>
</item>
<item>
<title>响应式编程的实践 - 张逸</title>
<link>http://www.cnblogs.com/wayfarer/p/summary-of-reactive-programming.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wayfarer/p/summary-of-reactive-programming.html</guid>
<description>&lt;p&gt;响应式编程在前端开发以及Android开发中有颇多运用，然而它的非阻塞异步编程模型以及对消息流的处理模式也在后端得到越来越多的应用。除了Netflix的OSS中大量使用了响应式编程之外，最近阿里也提出Dubbo 3.0版本将全面拥抱响应式编程。&lt;/p&gt;
&lt;p&gt;我之前针对某些项目需求也给出了响应式编程的方案，较好地解决了并行编程与异步编程的问题。不过在深入了解响应式编程之后，我也给出了自己的一些实践总结。&lt;/p&gt;
&lt;h3 id=&quot;响应式编程并非银弹&quot;&gt;响应式编程并非银弹&lt;/h3&gt;
&lt;p&gt;响应式编程并非银弹。事实上在软件领域，Brooks提出的“没有银弹”一说或许将永远生效。当我们在选择使用响应式编程时，一定要明确它的适用场景，主要包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;处理由用户或其他系统发起的事件，如鼠标点击、键盘按键或者物联网设备等无时无刻都在发射信号的情况&lt;/li&gt;
&lt;li&gt;处理磁盘或网络等高延迟的IO数据，且保证这些IO操作是异步的&lt;/li&gt;
&lt;li&gt;业务的处理流程是流式的，且需要高响应的非阻塞操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外，我们当然也可以利用一些响应式编程框架如Rx，简化并发编程与数据流操作的实现。诸如RxJava就提供非常完整的工厂方法，可以将非响应式编程的Iterable、Array以及与响应式编程有一定相关性的Future、Callable转换为Observable或Flowable。&lt;/p&gt;
&lt;h3 id=&quot;理解source的本质&quot;&gt;理解Source的本质&lt;/h3&gt;
&lt;p&gt;Akka Stream将流数据源定义为Source，RxJava则定义为Observable或Flowable。这些响应式编程框架都为Source提供了丰富的operator。其中除了组合流的操作之外，最基本的操作即为：filter、map、flatMap、reduce等。&lt;/p&gt;
&lt;p&gt;粗略看来，这些操作皆为函数式的编程接口，从FP的角度看，我们甚至可以将Source视为一个monad。而站在Java编程的角度看，我们则很容易将Source视为等同于集合的数据结构。更何况，响应式编程实则脱胎于Observer模式与Iterator模式，其中Iterator模式就是针对集合的操作，只不过Observable或Flowable是push模型，而Iterator模式则为pull模型罢了。&lt;/p&gt;
&lt;p&gt;然而这就是本质的区别，即&lt;strong&gt;Source是一个不断发射事件（data、error、complete）的源头，具有时间序列的特点&lt;/strong&gt;，而Iterable则是一个静态的数据结构，在对它进行操作时，该数据结构中存储的数据就已经存在了。&lt;/p&gt;
&lt;h3 id=&quot;合理设计source的粒度&quot;&gt;合理设计Source的粒度&lt;/h3&gt;
&lt;p&gt;在演示Observable或Flowable的API时，我们往往喜欢采用Fluent Interface的方式连续地调用它的operator，形成一个整体的流处理过程。这并非总是合理的。当一个Source被多个operator串联起来的时候，会使得这个Source更加&lt;strong&gt;难以被重用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，在加载网页时，默认发起对后端服务的调用并返回需要的用户信息，若建模为&lt;strong&gt;流A&lt;/strong&gt;，其转换如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;uri ----&amp;gt; user ----&amp;gt; | --&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，有一个鼠标点击事件也会通过随机生成URL发起对后端服务的调用并返回需要的用户信息，倘若建模为&lt;strong&gt;流B&lt;/strong&gt;，其转换如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;click ----&amp;gt; uri ----&amp;gt; user ----&amp;gt; | --&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，这两个流在从uri到user的流处理上出现了重复。如果我们创建的流A与流B并不包含uri到user的转换，就可以通过merge等合并操作将A与B合并，然后再&lt;strong&gt;共同重用从uri到user的转换&lt;/strong&gt;。我们也无需担心创建细粒度流的成本，因为这些流的创建是lazy的，流虽然创建了，对流的操作却不会立即执行。&lt;/p&gt;
&lt;h3 id=&quot;分离操作的逻辑&quot;&gt;分离操作的逻辑&lt;/h3&gt;
&lt;p&gt;无论是哪个响应式框架，都为流（Source）提供了丰富的operator。这些operator多数都支持lambda表达式。在处理简单的业务逻辑时，这样的实现是没有问题的；然而一旦逻辑变得非常复杂，lambda表达式的表达能力就不够了。从编程实践看，lambda表达式本身就应该保持微小的粒度。这时，就应该将这些逻辑单独分离出来，放到单独的类与方法中。&lt;/p&gt;
&lt;p&gt;例如，我们根据device的配置信息去调用远程服务获取设备信息，然后提取信息获得业务需要的指标，对指标进行转换，最后将转换的数据写入到数据库中。结合函数的转换本质，我们可以将这些操作拆分为多个连续的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;deviceConfig --&amp;gt; deviceInfo --&amp;gt; List&amp;lt;extractedInfo&amp;gt; --&amp;gt; transformedInfo --&amp;gt; write&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;倘若这些转换的逻辑非常复杂，就可以将这些逻辑分别封装到DeviceFetcher、DeviceExtractor、DeviceTransformer与DeviceWriter这四个类中，于是代码可以写为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Flowable.&lt;span class=&quot;fu&quot;&gt;fromIterable&lt;/span&gt;(deviceConfigs)
    .&lt;span class=&quot;fu&quot;&gt;parallel&lt;/span&gt;()
    .&lt;span class=&quot;fu&quot;&gt;runOn&lt;/span&gt;(Schedulers.&lt;span class=&quot;fu&quot;&gt;computation&lt;/span&gt;())
    .&lt;span class=&quot;fu&quot;&gt;map&lt;/span&gt;(DeviceFetcher::fetch)
    .&lt;span class=&quot;fu&quot;&gt;flatMap&lt;/span&gt;(DeviceExtractor::extract)
    .&lt;span class=&quot;fu&quot;&gt;map&lt;/span&gt;(DeviceTransformer::transform)
    .&lt;span class=&quot;fu&quot;&gt;sequential&lt;/span&gt;()
    .&lt;span class=&quot;fu&quot;&gt;blockingSubscribe&lt;/span&gt;(info -&amp;gt; DeviceWriter.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(info); err -&amp;gt; &lt;span class=&quot;fu&quot;&gt;log&lt;/span&gt;(err); () -&amp;gt; &lt;span class=&quot;fu&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;done.&quot;&lt;/span&gt;));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一实践提倡将流的操作与每个操作的业务分离开，既能够保证流操作的简单与纯粹，又能保证操作业务的重用与可扩展。&lt;/p&gt;
&lt;h3 id=&quot;api的设计&quot;&gt;API的设计&lt;/h3&gt;
&lt;p&gt;如果我们要设计符合响应式编程设计的API，则应该尽可能保证每个方法都是非阻塞的。要做到这一点，就应该保证每个方法返回的类型是Source或Publisher。例如针对要返回多个数据的流，可以返回&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;或者&lt;code&gt;Flowable&amp;lt;T&amp;gt;&lt;/code&gt;；如果确定只返回一个数据，则可以返回&lt;code&gt;Single&amp;lt;T&amp;gt;&lt;/code&gt;；倘若不确定，则返回&lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;。倘若该API方法仅仅是一个命令，无需返回结果，又需要保证方法是非阻塞的，则可以考虑返回&lt;code&gt;Completable&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从某种意义上说，返回&lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;CompletableFuture&amp;lt;T&amp;gt;&lt;/code&gt;或者&lt;code&gt;CompletableStage&amp;lt;T&amp;gt;&lt;/code&gt;也可以认为是响应式的。这三个类型由于是JDK自身提供的，因此更纯粹。唯一不便的是这些接口没有提供类似Observable那样丰富的operator，但好在Observable与Flowable都提供了&lt;code&gt;fromFuture()&lt;/code&gt;方法对其进行转换，因而这样的设计也是可取的。&lt;/p&gt;
&lt;h3 id=&quot;akka-stream的流拓扑图&quot;&gt;Akka Stream的流拓扑图&lt;/h3&gt;
&lt;p&gt;Akka Stream对流处理的抽象被建模为图。这一设计思想使得流的处理变得更加直观，流的处理变成了“搭积木”游戏。可惜Java的DSL能力实在太弱，如果对比Scala与Java，你会发现GraphDSL对Graph的构造在表现上简直是天壤之别。&lt;/p&gt;
&lt;p&gt;例如这是官方文档中Java版本对Graph的构造：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;RunnableGraph.&lt;span class=&quot;fu&quot;&gt;fromGraph&lt;/span&gt;(GraphDSL.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(builder -&amp;gt; {
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Outlet&amp;lt;Integer&amp;gt; A = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Source.&lt;span class=&quot;fu&quot;&gt;single&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;();
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; UniformFanOutShape&amp;lt;Integer, Integer&amp;gt; B = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Broadcast.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;));
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; UniformFanInShape&amp;lt;Integer, Integer&amp;gt; C = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Merge.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;));
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; FlowShape&amp;lt;Integer, Integer&amp;gt; D = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Flow.&lt;span class=&quot;fu&quot;&gt;of&lt;/span&gt;(Integer.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;map&lt;/span&gt;(i -&amp;gt; i + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; UniformFanOutShape&amp;lt;Integer, Integer&amp;gt; E = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Balance.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;));
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; UniformFanInShape&amp;lt;Integer, Integer&amp;gt; F = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Merge.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;));
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Inlet&amp;lt;Integer&amp;gt; G = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Sink.&amp;lt;Integer&amp;gt;&lt;span class=&quot;fu&quot;&gt;foreach&lt;/span&gt;(System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;::println)).&lt;span class=&quot;fu&quot;&gt;in&lt;/span&gt;();

    builder.&lt;span class=&quot;fu&quot;&gt;from&lt;/span&gt;(F).&lt;span class=&quot;fu&quot;&gt;toFanIn&lt;/span&gt;(C); &lt;span class=&quot;co&quot;&gt;//feedback loop&lt;/span&gt;
    builder.&lt;span class=&quot;fu&quot;&gt;from&lt;/span&gt;(A).&lt;span class=&quot;fu&quot;&gt;viaFanOut&lt;/span&gt;(B).&lt;span class=&quot;fu&quot;&gt;viaFanIn&lt;/span&gt;(C).&lt;span class=&quot;fu&quot;&gt;toFanIn&lt;/span&gt;(F);
    builder.&lt;span class=&quot;fu&quot;&gt;from&lt;/span&gt;(B).&lt;span class=&quot;fu&quot;&gt;via&lt;/span&gt;(D).&lt;span class=&quot;fu&quot;&gt;viaFanOut&lt;/span&gt;(E).&lt;span class=&quot;fu&quot;&gt;toFanIn&lt;/span&gt;(F);
    builder.&lt;span class=&quot;fu&quot;&gt;from&lt;/span&gt;(E).&lt;span class=&quot;fu&quot;&gt;toInlet&lt;/span&gt;(G);

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ClosedShape.&lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;();
})).&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(mat);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下是官方文档中Scala版本对同一个Graph的构造：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;RunnableGraph.&lt;span class=&quot;fu&quot;&gt;fromGraph&lt;/span&gt;(GraphDSL.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;implicit&lt;/span&gt; builder =&amp;gt;
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; A: Outlet[Int]                  = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Source.&lt;span class=&quot;fu&quot;&gt;single&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; B: UniformFanOutShape[Int, Int] = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Broadcast[Int](&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; C: UniformFanInShape[Int, Int]  = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Merge[Int](&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; D: FlowShape[Int, Int]          = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Flow[Int].&lt;span class=&quot;fu&quot;&gt;map&lt;/span&gt;(_ + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; E: UniformFanOutShape[Int, Int] = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Balance[Int](&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; F: UniformFanInShape[Int, Int]  = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Merge[Int](&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; G: Inlet[Any]
  
                C     &amp;lt;~      F
  A  ~&amp;gt;  B  ~&amp;gt;  C     ~&amp;gt;      F
         B  ~&amp;gt;  D  ~&amp;gt;  E  ~&amp;gt;  F
                       E  ~&amp;gt;  G
  ClosedShape
})&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们也看到，倘若在GraphDSL中我们能够将构成Graph的“材料”对象事先创建好，而将build工作统一放在一起，可以在一定程度改进代码的表现力。&lt;/p&gt;
&lt;p&gt;我们可以将Akka Stream的Graph（完整的Graph，称为ClosedShape，是可以运行的，又称之为RunnableShape）看做是流处理的”模具“，至于那些由Inlet与Outlet端口组成的基础Shape，则是设计这些模具的”基础材料“。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模具&lt;/strong&gt;是静态的，&lt;strong&gt;基础材料&lt;/strong&gt;与&lt;strong&gt;组合材料&lt;/strong&gt;是可重用的单元，然后再组合可以重用的&lt;strong&gt;业务单元&lt;/strong&gt;（以函数、类或者接口形式进行封装），这个模具就具有了业务处理能力。如果这个拓扑图过于复杂，我们还可以利用基础Shape组合形成一个个更粗粒度Partial Shap。这些Partial Shape不是封闭的，可以理解为更粗粒度的Source、Sink和Flow，它使得模具的组装变得更加简单。**&lt;/p&gt;
&lt;p&gt;材料、业务单元、模具之间的关系可以形象地用下图来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/526/201802/526-20180205214304607-1386887920.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦流处理的模具打造完毕，打开数据流的”水龙头“，让数据源源不断地流入Graph中，流处理就可以”自动“运行。只要Source没有发出complete或error信号，它就将一直运行下去。Akka Stream之所以将Graph的运行器称之为materializer，大约也是源于这样的隐喻吧。&lt;/p&gt;
&lt;p&gt;使用Akka Stream进行响应式流处理，我建议参考这样的思维。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://iamzhangyi.github.io/2018/02/03/summary-of-reactive-programming/&quot; class=&quot;uri&quot;&gt;https://iamzhangyi.github.io/2018/02/03/summary-of-reactive-programming/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 13:41:00 +0000</pubDate>
<dc:creator>张逸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wayfarer/p/summary-of-reactive-programming.html</dc:identifier>
</item>
<item>
<title>Android开发之漫漫长途 Fragment番外篇——TabLayout+ViewPager+Fragment - 忘了12138</title>
<link>http://www.cnblogs.com/wangle12138/p/8419496.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangle12138/p/8419496.html</guid>
<description>&lt;p&gt;&lt;em&gt;该文章是一个系列文章，是本人在Android开发的漫漫长途上的一点感想和记录，我会尽量按照先易后难的顺序进行编写该系列。该系列引用了《Android开发艺术探索》以及《深入理解Android 卷Ⅰ，Ⅱ，Ⅲ》中的相关知识，另外也借鉴了其他的优质博客，在此向各位大神表示感谢，膜拜！！！&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上一篇文章中我们使用底部导航+Fragment的方式实现了Android主流App中大都存在的设计。并命名其为“Fragment最佳实践”，作为想到单独使用Fragment的用户来说，这个说法并不夸大，它解决了许多用户在使用Fragment时产生的这样那样可见或不可见的问题。不过Fragment还有其他的使用方式，就是我们本章要介绍的。（本来是介绍ListView的，等着ListView的读者不好意思了，我会很快更新的。）&lt;/p&gt;
&lt;p&gt;注：为什么临时插入这一章，因为有读者在上一篇文章中评论了，我觉得大有道理，感谢&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/730v2UJ.png&quot;/&gt;&lt;br/&gt;这里我就不打码了，，哈哈哈哈&lt;/p&gt;

&lt;h2 id=&quot;tablayout的静态使用&quot;&gt;TabLayout的静态使用&lt;/h2&gt;
&lt;p&gt;TabLayout是Android 5.0之后Google提供的一系列Material Design设计规范中的一个控件。我们在布局文件中可以这样使用&lt;br/&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;android.support.design.widget.TabLayout
    android:id=&quot;@+id/tab_layout&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_alignParentBottom=&quot;true&quot;
    app:tabIndicatorHeight=&quot;0dp&quot;
    app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;
    &amp;gt;
    
    &amp;lt;android.support.design.widget.TabItem
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Tab 1&quot;/&amp;gt;
    &amp;lt;android.support.design.widget.TabItem
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Tab 2&quot;/&amp;gt;
    &amp;lt;android.support.design.widget.TabItem
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Tab 3&quot;/&amp;gt;
&amp;lt;/android.support.design.widget.TabLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TabLayout间接继承于ViewGroup，其内可包含0到n个TabItem，这个TabItem就是我们经常使用的标签，其是个自定义View&lt;br/&gt;，这样我们就定义了一个包含3个标签页的TabLayout。其运行结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/F3gISgz.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tablayout的动态使用&quot;&gt;TabLayout的动态使用&lt;/h2&gt;
&lt;p&gt;在布局文件中我们可以很方便定义顶部/底部 导航的布局。我们来看一下在代码中的使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TabActivity extends AppCompatActivity {
    @BindView(R.id.tab_layout)
    TabLayout mTabLayout;
    @BindView(R.id.view_pager)
    ViewPager mViewPager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_tab);
        ButterKnife.bind(this);

        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 1&quot;));
        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 2&quot;));
        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 3&quot;));

        //为TabLayout添加Tab选择事件监听
        mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() {
            @Override
            public void onTabSelected(TabLayout.Tab tab) {//当标签被选择时回调
                
            }

            @Override
            public void onTabUnselected(TabLayout.Tab tab) {//当标签从选择变为非选择时回调

            }

            @Override
            public void onTabReselected(TabLayout.Tab tab) {//当标签被重新选择时回调

            }
        });
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于运行结果我就不上图了，跟上面的运行结果是一样的。&lt;/p&gt;
&lt;h2 id=&quot;tablayout的更多属性&quot;&gt;TabLayout的更多属性&lt;/h2&gt;
&lt;p&gt;关于TabLayout的更多属性以及使用的说明请查看其官方文档。在这里我们只关心TabLayout+ViewPager的化学反应,这个组合也是我们平常在开发中使用最多的。在此之前我们先介绍ViewPager&lt;/p&gt;

&lt;p&gt;先看看官方对ViewPager的说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
Layout manager that allows the user to flip left and right
through pages of data.  You supply an implementation of a
{@link PagerAdapter} to generate the pages that the view shows.


ViewPager is most often used in conjunction with {@link android.app.Fragment}
There are standard adapters implemented for using fragments with the ViewPager,
which cover the most common use cases.  These are
{@link android.support.v4.app.FragmentPagerAdapter} and
{@link android.support.v4.app.FragmentStatePagerAdapter};*/

public class ViewPager extends ViewGroup {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面英文的大致意思是ViewPager是一个布局管理类，这个类呢允许用户左右翻转页面。你必须实现一个PagerAdapter来生成这些显示的页面。ViewPager经常和Fragment一起使用。而且呢Google非常贴心的提供了两个类FragmentPagerAdapter和FragmentStatePagerAdapter来应付那些一般场景。&lt;/p&gt;
&lt;p&gt;其实从ViewPager的说明中，我们基本上就能知道ViewPager是什么以及如何使用了。&lt;/p&gt;

&lt;p&gt;ViewPager继承于ViewGroup，官方指导中就说了，你要自己实现PagerAdapter来生成显示的页面，那么我们来看看这个PagerAdapter&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Base class providing the adapter to populate pages inside of
 * a {@link ViewPager}.  You will most likely want to use a more
 * specific implementation of this, such as
 * {@link android.support.v4.app.FragmentPagerAdapter} or
 * {@link android.support.v4.app.FragmentStatePagerAdapter}.
 *
 * &amp;lt;p&amp;gt;When you implement a PagerAdapter, you must override the following methods
 * at minimum:&amp;lt;/p&amp;gt;
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt;{@link #instantiateItem(ViewGroup, int)}&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;{@link #destroyItem(ViewGroup, int, Object)}&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;{@link #getCount()}&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;{@link #isViewFromObject(View, Object)}&amp;lt;/li&amp;gt;
 * &amp;lt;/ul&amp;gt;
 * /
public abstract class PagerAdapter {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实我们在看一个不太了解的类的时候，通过源码上的关于这个类的说明就可以知道很多信息了。关于PagerAdapter的说明就是如此。&lt;br/&gt;先说了一下PagerAdapter的作用，是一个基类提供适配器给ViewPager中的页面，如果你想使用特定的实现类，那么你可以看两个类FragmentPagerAdapter和FragmentStatePagerAdapter，这两个类继承了PagerAdapter，并实现了其抽象方法。&lt;/p&gt;
&lt;p&gt;后面一段的意思是你如果想自定义你自己的PagerAdapter，那么你最少要实现这4个方法&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;instantiateItem(ViewGroup, int)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;destroyItem(ViewGroup, int, Object)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;getCount()&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;isViewFromObject(View, Object)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们以代码的形式，说明这4个方法的含义以及如何使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private class MyViewPagerAdapter extends PagerAdapter {

    /**
      * 获取View的总数
      *
      * @return View总数
      */
    @Override
    public int getCount() {
        return 0;
    }

    
    /**
     * 为给定的位置创建相应的View。创建View之后,需要在该方法中自行添加到container中。
     *
     * @param container ViewPager本身
     * @param position  给定的位置
     * @return 提交给ViewPager进行保存的实例对象
     */
    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        return super.instantiateItem(container, position);
    }
    
    /**
     * 给定的位置移除相应的View。
     *
     * @param container ViewPager本身
     * @param position  给定的位置
     * @param object    在instantiateItem中提交给ViewPager进行保存的实例对象
     */
    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        super.destroyItem(container, position, object);
    }
 
    
    /**
     * 确认View与实例对象是否相互对应。ViewPager内部用于获取View对应的ItemInfo。
     *
     * @param view   ViewPager显示的View内容
     * @param object 在instantiateItem中提交给ViewPager进行保存的实例对象
     * @return 是否相互对应
     */
    @Override
    public boolean isViewFromObject(View view, Object object) {
        return false;
    }
    

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这4个方法是必须的，，另外还有一些不是必须，但是可能会用到的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 当ViewPager的内容有所变化时,进行调用。
 *
 * @param container ViewPager本身
 */
@Override
public void startUpdate(ViewGroup container) {
    super.startUpdate(container);
}


/**
 * ViewPager调用该方法来通知PageAdapter当前ViewPager显示的主要项,提供给用户对主要项进行操作的方法。
 *
 * @param container ViewPager本身
 * @param position  给定的位置
 * @param object    在instantiateItem中提交给ViewPager进行保存的实例对象
 */
@Override
public void setPrimaryItem(ViewGroup container, int position, Object object) {
    super.setPrimaryItem(container, position, object);
}


/**
 * 较多的用于Design库中的TabLayout与ViewPager进行绑定时,提供显示的标题。
 *
 * @param position 给定的位置
 * @return 显示的标题
 */
@Override
public CharSequence getPageTitle(int position) {
    return super.getPageTitle(position);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上面呢只是列举说明了一下PagerAdapter，看起来有些枯燥，都是些说明，那么我们来看一下实践，ViewPager通畅跟Fragment一起使用，即其所管理的页面通畅是Fragment，所以Google提供了两个适配器FragmentPagerAdapter和FragmentStatePagerAdapter，我们这节分析FragmentPagerAdapter。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /**
 *真是不看不知道，一看吓一跳。FragmentPagerAdapter也是个抽象类，
 *
 */
public abstract class FragmentPagerAdapter extends PagerAdapter {
    private static final String TAG = &quot;FragmentPagerAdapter&quot;;
    private static final boolean DEBUG = false;

    private final FragmentManager mFragmentManager;
    private FragmentTransaction mCurTransaction = null;
    private Fragment mCurrentPrimaryItem = null;

    public FragmentPagerAdapter(FragmentManager fm) {
        mFragmentManager = fm;
    }

    /**
     *抽象方法，看来这个函数要子类自己实现了
     *
     * @param position ViewPager中Item的位置
     * @return 位置相关联的Fragment
     */
    public abstract Fragment getItem(int position);

    @Override
    public void startUpdate(ViewGroup container) {
        if (container.getId() == View.NO_ID) {
            throw new IllegalStateException(&quot;ViewPager with adapter &quot; + this
                    + &quot; requires a view id&quot;);
        }
    }

    /**
     * 为给定的位置创建相应的fragment。创建fragment之后,需要在该方法中自行添加到container中。
     *
     * @param container ViewPager本身
     * @param position  给定的位置
     * @return 提交给ViewPager进行保存的实例对象,这里是Fragment
     */
    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        
        if (mCurTransaction == null) {
            mCurTransaction = mFragmentManager.beginTransaction();
        }
        
        final long itemId = getItemId(position);

       
        String name = makeFragmentName(container.getId(), itemId);
        Fragment fragment = mFragmentManager.findFragmentByTag(name);
        if (fragment != null) {
            if (DEBUG) Log.v(TAG, &quot;Attaching item #&quot; + itemId + &quot;: f=&quot; + fragment);
            mCurTransaction.attach(fragment);
        } else {
            fragment = getItem(position);
            if (DEBUG) Log.v(TAG, &quot;Adding item #&quot; + itemId + &quot;: f=&quot; + fragment);
            mCurTransaction.add(container.getId(), fragment,
                    makeFragmentName(container.getId(), itemId));
        }
        if (fragment != mCurrentPrimaryItem) {
            fragment.setMenuVisibility(false);
            fragment.setUserVisibleHint(false);
        }

        return fragment;
    }

    /**
     * 移除给定的位置相应的fragment。
     *
     * @param container ViewPager本身
     * @param position  给定的位置
     * @param object    在instantiateItem中提交给ViewPager进行保存的实例对象
     */
    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        if (mCurTransaction == null) {
            mCurTransaction = mFragmentManager.beginTransaction();
        }
        if (DEBUG) Log.v(TAG, &quot;Detaching item #&quot; + getItemId(position) + &quot;: f=&quot; + object
                + &quot; v=&quot; + ((Fragment)object).getView());
        mCurTransaction.detach((Fragment)object);
    }

    @Override
    public void setPrimaryItem(ViewGroup container, int position, Object object) {
        Fragment fragment = (Fragment)object;
        if (fragment != mCurrentPrimaryItem) {
            if (mCurrentPrimaryItem != null) {
                mCurrentPrimaryItem.setMenuVisibility(false);
                mCurrentPrimaryItem.setUserVisibleHint(false);
            }
            if (fragment != null) {
                fragment.setMenuVisibility(true);
                fragment.setUserVisibleHint(true);
            }
            mCurrentPrimaryItem = fragment;
        }
    }

    @Override
    public void finishUpdate(ViewGroup container) {
        if (mCurTransaction != null) {
            mCurTransaction.commitNowAllowingStateLoss();
            mCurTransaction = null;
        }
    }

    @Override
    public boolean isViewFromObject(View view, Object object) {
        return ((Fragment)object).getView() == view;
    }

    @Override
    public Parcelable saveState() {
        return null;
    }

    @Override
    public void restoreState(Parcelable state, ClassLoader loader) {
    }

    /**
     * @param position ViewPager中Item的位置
     * @return 唯一的ItemID
     */
    public long getItemId(int position) {
        return position;
    }

    private static String makeFragmentName(int viewId, long id) {
        return &quot;android:switcher:&quot; + viewId + &quot;:&quot; + id;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码比较少，总共也就100多行，逻辑也比较清晰明了，我们来着重分析instantiateItem和destroyItem&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * 为给定的位置创建相应的fragment。创建fragment之后,需要在该方法中自行添加到container中。
     *
     * @param container ViewPager本身
     * @param position  给定的位置
     * @return 提交给ViewPager进行保存的实例对象,这里是Fragment
     */
    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        //开启事务
        if (mCurTransaction == null) {
            mCurTransaction = mFragmentManager.beginTransaction();
        }
        //得到指定位置Item的ID
        final long itemId = getItemId(position);

       //根据id和ViewPager的ID生成item的name
        String name = makeFragmentName(container.getId(), itemId);

        //以name为Tag查找对应的Fragment
        Fragment fragment = mFragmentManager.findFragmentByTag(name);


        if (fragment != null) {//如果找到了
            if (DEBUG) Log.v(TAG, &quot;Attaching item #&quot; + itemId + &quot;: f=&quot; + fragment);
            //调用事务的attach
            mCurTransaction.attach(fragment);
        } else {//没找到
            //通过我们重写的getItem方法得到相应fragment
            fragment = getItem(position);
            if (DEBUG) Log.v(TAG, &quot;Adding item #&quot; + itemId + &quot;: f=&quot; + fragment);

            //调用事务的add方法，并设置Tag
            mCurTransaction.add(container.getId(), fragment,
                    makeFragmentName(container.getId(), itemId));
        }
        //如果frament不等于当前主要的Item

        if (fragment != mCurrentPrimaryItem) {
            //设置其Menu不可见
            fragment.setMenuVisibility(false);
            //设置其不可见
            fragment.setUserVisibleHint(false);
        }

        return fragment;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;instantiateItem方法主要功能是为ViewPager生成Item。&lt;br/&gt;那么destroyItem方法的主要功能是销毁ViwePager内的Item&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        if (mCurTransaction == null) {
            mCurTransaction = mFragmentManager.beginTransaction();
        }
        
        //调用事务的detach方法
        mCurTransaction.detach((Fragment)object);
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;关于FragmentStatePagerAdapter，读者可自行分析，代码也不长。需要注意的地方是，两者对于destroyItem的不同实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void destroyItem(ViewGroup container, int position, Object object) {
    Fragment fragment = (Fragment) object;

    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    if (DEBUG) Log.v(TAG, &quot;Removing item #&quot; + position + &quot;: f=&quot; + object
            + &quot; v=&quot; + ((Fragment)object).getView());
    while (mSavedState.size() &amp;lt;= position) {
        mSavedState.add(null);
    }
    mSavedState.set(position, fragment.isAdded()
            ? mFragmentManager.saveFragmentInstanceState(fragment) : null);
    mFragments.set(position, null);

    //调用事务的remove方法
    mCurTransaction.remove(fragment);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;ViewPager是个ViewGroup，与其他布局LinearLayout或者其他任意的ViewGroup并无本质的不同，它被Google建议与Fragment结伴使用，也是说ViewPager所包裹的是Fragment布局。ViewPager需要适配器PagerAdapter操作Fragment，这一点就像ListView需要适配器操作其内部的Item一样。&lt;/p&gt;
&lt;p&gt;适配器PagerAdapter是个抽象类，并且依照官方说明，我们必须至少实现其4个重要方法。4个方法可能太多，所以Google提供了FragmentPagerAdapter以及FragmentStatePagerAdapter，这两个也是抽象类，不过我们的自定义Adapter只需要实现其中的getItem(int position)方法即可。&lt;/p&gt;
&lt;p&gt;关于FragmentPagerAdapter以及FragmentStatePagerAdapter的不同，我这里再总结一下。&lt;strong&gt;FragmentPagerAdapter销毁item的时候最终调用FragmentTransaction的detach()方法，使用detach()会将view从viewtree中删除,和FragmentStatePagerAdapter中使用的remove()不同,此时fragment的状态依然保持着,在使用attach()时会再次调用onCreateView()来重绘视图,注意使用detach()后fragment.isAdded()方法将返回false。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;实例&quot;&gt;实例&lt;/h2&gt;
&lt;p&gt;更改后的TabActivity对应的布局文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;RelativeLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;

    &amp;lt;!--ViewPager--&amp;gt;
    &amp;lt;android.support.v4.view.ViewPager
        android:id=&quot;@+id/view_pager&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentTop=&quot;true&quot;
        &amp;gt;

    &amp;lt;/android.support.v4.view.ViewPager&amp;gt;
    &amp;lt;!--分割线--&amp;gt;
    &amp;lt;ImageView
        android:id=&quot;@+id/image_1&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;1dp&quot;
        android:background=&quot;#919292&quot;
        android:layout_above=&quot;@+id/tab_layout&quot;/&amp;gt;



    &amp;lt;!--TabLayout--&amp;gt;
    &amp;lt;android.support.design.widget.TabLayout
        android:id=&quot;@+id/tab_layout&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        app:tabIndicatorHeight=&quot;0dp&quot;
        app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;
        &amp;gt;
        
    &amp;lt;/android.support.design.widget.TabLayout&amp;gt;

&amp;lt;/RelativeLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更改后的TabActivity&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TabActivity extends AppCompatActivity {
    @BindView(R.id.tab_layout)
    TabLayout mTabLayout;
    @BindView(R.id.view_pager)
    ViewPager mViewPager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_tab);
        ButterKnife.bind(this);

        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 1&quot;));
        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 2&quot;));
        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 3&quot;));

        //自定义的Adapter继承自FragmentPagerAdapter
        final PagerAdapter adapter = new PagerAdapter
            (getSupportFragmentManager(), mTabLayout.getTabCount());

        //ViewPager设置Adapter
        mViewPager.setAdapter(adapter);

        //为ViewPager添加页面改变监听
        mViewPager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(mTabLayout));

        //为TabLayout添加Tab选择监听
       
        mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() {
            @Override
            public void onTabSelected(TabLayout.Tab tab) {
                mViewPager.setCurrentItem(tab.getPosition());
            }

            @Override
            public void onTabUnselected(TabLayout.Tab tab) {

            }

            @Override
            public void onTabReselected(TabLayout.Tab tab) {

            }
        });
        
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而我们自定义的MyPagerAdapter也非常简单&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyPagerAdapter extends FragmentPagerAdapter {
    //fragment的数量
    int nNumOfTabs;
    public MyPagerAdapter(FragmentManager fm, int nNumOfTabs)
    {
        super(fm);
        this.nNumOfTabs=nNumOfTabs;
    }

    /**
     * 重写getItem方法
     *
     * @param position 指定的位置
     * @return 特定的Fragment
     */
    @Override
    public Fragment getItem(int position) {
        switch(position)
        {
            case 0:
                GoodsFragment tab1=new GoodsFragment();
                return tab1;
            case 1:
                CategoryFragment tab2=new CategoryFragment();
                return tab2;
            case 2:
                TaskFragment tab3=new TaskFragment();
                return tab3;
        }
        return null;
    }

    /**
     * 重写getCount方法
     *
     * @return fragment的数量
     */
    @Override
    public int getCount() {
        return nNumOfTabs;
    }
}&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;ViewPager可通过setOffscreenPageLimit(int limit)函数设置ViewPager预加载的View数目&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void setOffscreenPageLimit(int limit) {
    //DEFAULT_OFFSCREEN_PAGES=1

    if (limit &amp;lt; DEFAULT_OFFSCREEN_PAGES) {
        Log.w(TAG, &quot;Requested offscreen page limit &quot; + limit + &quot; too small; defaulting to &quot;
                + DEFAULT_OFFSCREEN_PAGES);
        limit = DEFAULT_OFFSCREEN_PAGES;
    }
    if (limit != mOffscreenPageLimit) {
        mOffscreenPageLimit = limit;
        populate();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到该函数的源码，当我们传入的limit&amp;lt;1时，limit还是被设置为1，当limit与成员变量mOffscreenPageLimit的值不同时（成员变量mOffscreenPageLimit的默认值为1），更新成员变量mOffscreenPageLimit的值，然后调用populate()函数。&lt;/p&gt;
&lt;p&gt;而这个populate()函数就是给我们的ViewPager准备缓存页面并显示当前页面用的。&lt;/p&gt;
&lt;p&gt;假如说我采用下面的方法调用setOffscreenPageLimit(2),此时ViewPager的简单示意图&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/SE1LTNf.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：从上面的代码也可以看出ViewPager最少会预加载一个页面。在本例中，也是我们在显示TAB1的时候，ViewPager已经加载了TAB2，具体方式是通过instantiateItem方法，该方法内部调用了我们重写的getItem方法，TAB2所表示的Fragment的onCreateView等相关生命周期方法会被回调。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ViewPager的预加载机制其实在某些时候是个很让人不爽的问题，比如我们在Fragment做网络请求数据的时候，我们网络请求的代码通常会放在onCreateView中，我们只是打开第1个Fragment，但是由于ViewPager会加载第2个Fragment，可能也执行了第2个Fragment的网络请求代码。&lt;/p&gt;
&lt;p&gt;而避免上述问题的主要依靠&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void setUserVisibleHint(boolean isVisibleToUser)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;setUserVisibleHint(boolean isVisibleToUser)是Fragment中的一个回调函数。当前Fragment可见时，setUserVisibleHint()回调，其中isVisibleToUser=true。当前Fragment由可见到不可见或实例化时，setUserVisibleHint()回调，其中isVisibleToUser=false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setUserVisibleHint(boolean isVisibleToUser)调用时机&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在Fragment实例化，即在ViewPager中，由于ViewPager默认会预加载左右两个页面。此时预加载页面回调的生命周期流程：setUserVisibleHint() --&amp;gt;onAttach() --&amp;gt; onCreate()--&amp;gt;onCreateView()--&amp;gt; onActivityCreate() --&amp;gt; onStart() --&amp;gt; onResume()&lt;/p&gt;
&lt;p&gt;此时，setUserVisibleHint() 中的参数为false，因为不可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在Fragment可见时，即ViewPager中滑动到当前页面时，因为已经预加载过了，之前生命周期已经走到onResume() ，所以现在只会回调：setUserVisibleHint()。&lt;/p&gt;
&lt;p&gt;此时，setUserVisibleHint() 中的参数为true，因为可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在Fragment由可见变为不可见，即ViewPager由当前页面滑动到另一个页面，因为还要保持当前页面的预加载过程，所以只会回调：setUserVisibleHint()。&lt;/p&gt;
&lt;p&gt;此时，setUserVisibleHint() 中的参数为false，因为不可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;由TabLayout直接跳转到一个未预加载的页面，此时生命周期的回调过程：setUserVisibleHint() --&amp;gt;setUserVisibleHint() --&amp;gt;onAttach() --&amp;gt; onCreate()--&amp;gt;onCreateView()--&amp;gt; onActivityCreate() --&amp;gt; onStart()&lt;br/&gt;--&amp;gt; onResume()&lt;/p&gt;
&lt;p&gt;此时回调了两次setUserVisibleHint() ，一次代表初始化时，传入参数是false，一次代表可见时，传入参数是true。这种情况比较特殊。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;总结：无论何时，setUserVisibleHint()都是先于其他生命周期的调用，并且初始化时调用，可见时调用，由可见转换成不可见时调用，一共三次时机。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们在使用ViewPager+Fragment显示数据的时候，我们通常会把网络请求的操作放在onCreateView-&amp;gt;onResume之间的生命周期内。这可能带来的问题我们上面已经探讨了。那么怎么解决这个问题呢？&lt;/p&gt;

&lt;p&gt;我们在本篇博客中比较详细的探讨了TabLayout+ViewPager+Fragment的使用，我们在许多主流App中都能看到这种顶部、底部导航的效果，并且在此基础上我们探讨了TabLayout+ViewPager+Fragment网络数据加载问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们希望Fragment可见时加载网络数据，不可见时不进行或者取消网络请求。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class BaseFragment extends Fragment {
    protected View rootView;

    private Unbinder mUnbinder;
    //当前Fragment是否处于可见状态标志，防止因ViewPager的缓存机制而导致回调函数的触发
    private boolean isFragmentVisible;
    //是否是第一次开启网络加载
    public boolean isFirst;

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        if (rootView == null)
            rootView = inflater.inflate(getLayoutResource(), container, false);
        mUnbinder = ButterKnife.bind(this, rootView);
        initView();
        //可见，但是并没有加载过
        if (isFragmentVisible &amp;amp;&amp;amp; !isFirst) {
            onFragmentVisibleChange(true);
        }
        return rootView;
    }

    //获取布局文件
    protected abstract int getLayoutResource();


    //初始化view
    protected abstract void initView();


    @Override
    public void setUserVisibleHint(boolean isVisibleToUser) {
        super.setUserVisibleHint(isVisibleToUser);
        if (isVisibleToUser) {
            isFragmentVisible = true;
        }
        if (rootView == null) {
            return;
        }
        //可见，并且没有加载过
        if (!isFirst&amp;amp;&amp;amp;isFragmentVisible) {
            onFragmentVisibleChange(true);
            return;
        }
        //由可见——&amp;gt;不可见 已经加载过
        if (isFragmentVisible) {
            onFragmentVisibleChange(false);
            isFragmentVisible = false;
        }
    }


    @Override
    public void onDestroyView() {
        super.onDestroyView();
        mUnbinder.unbind();
    }

    /**
     * 当前fragment可见状态发生变化时会回调该方法
     * 
     * 如果当前fragment是第一次加载，等待onCreateView后才会回调该方法，其它情况回调时机跟 {@link #setUserVisibleHint(boolean)}一致
     * 在该回调方法中你可以做一些加载数据操作，甚至是控件的操作.
     *
     * @param isVisible true  不可见 -&amp;gt; 可见
     *                  false 可见  -&amp;gt; 不可见
     */
    protected void onFragmentVisibleChange(boolean isVisible) {

    }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们设计抽象基类BaseFragment，所有的公共行为我们都可以在这个基类中定义，那么我们的Fragment是否可见就是其中的一种行为，所以我们上面重写了Fragment的setUserVisibleHint方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class GoodsFragment extends BaseFragment {
    
    @Override
    protected void onFragmentVisibleChange(boolean isVisible) {
        if(isVisible){
            //可见，并且是第一次加载
            lazyLoad();
        }else{
            //取消加载
        }
    }

    private void lazyLoad() {
        if (!isFirst) {
            isFirst = true;
        }
    }


    @Override
    protected int getLayoutResource() {
        return R.layout.fragment_goods;
    }

    @Override
    protected void initView() {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们设计GoodsFragment继承BaseFragment并重写其onFragmentVisibleChange以控制自身的网络请求。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;本篇为读者介绍了另外一种导航页切换的实现，我们使用TabLayout+ViewPager+Fragment的方式，其中读者需要重点理解以下几点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ViewPager是个ViewGroup，它所关机的布局就是通常是我们的Fragment布局。&lt;/li&gt;
&lt;li&gt;ViewPager的预加载机制、可能带来的问题及如何解决。&lt;/li&gt;
&lt;li&gt;理解PagerAdapter，以及如何实现它&lt;/li&gt;
&lt;li&gt;理解Google提供了两个特定场景的PagerAdapter实现类FragmentPagerAdapter以及FragmentStatePagerAdapter,以及他们的主要区别&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;
&lt;p&gt;下篇打算往Fragment中加点东西，ListView&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;此致，敬礼&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 13:29:00 +0000</pubDate>
<dc:creator>忘了12138</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangle12138/p/8419496.html</dc:identifier>
</item>
<item>
<title>模型的元数据Meta  -- Django从入门到精通系列教程 - 刘江liujiangblog.com</title>
<link>http://www.cnblogs.com/feixuelove1009/p/8419493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixuelove1009/p/8419493.html</guid>
<description>&lt;h3 id=&quot;该系列教程系个人原创并完整发布在个人官网刘江的博客和教程&quot;&gt;该系列教程系个人原创，并完整发布在个人官网&lt;a href=&quot;http://www.liujiangblog.com&quot;&gt;刘江的博客和教程&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;所有转载本文者需在顶部显著位置注明原作者及www.liujiangblog.com官网地址&quot;&gt;所有转载本文者，需在顶部显著位置注明原作者及www.liujiangblog.com官网地址。&lt;/h3&gt;
&lt;h3 id=&quot;python及django学习qq群453131687&quot;&gt;Python及Django学习QQ群：453131687&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;模型的元数据，指的是“除了字段外的所有内容”，例如排序方式、数据库表名、人类可读的单数或者复数名等等。所有的这些都是非必须的，甚至元数据本身对模型也是非必须的。但是，我要说但是，有些元数据选项能给予你极大的帮助，在实际使用中具有重要的作用，是实际应用的‘必须’。&lt;/p&gt;
&lt;p&gt;想在模型中增加元数据，方法很简单，在模型类中添加一个子类，名字是固定的&lt;code&gt;Meta&lt;/code&gt;，然后在这个Meta类下面增加各种元数据选项或者说设置项。参考下面的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Ox(models.Model):
    horn_length &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.IntegerField()

    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Meta:         &lt;span class=&quot;co&quot;&gt;# 注意，是模型的子类，要缩进！&lt;/span&gt;
        ordering &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;horn_length&quot;&lt;/span&gt;]
        verbose_name_plural &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;oxen&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的例子中，我们为模型Ox增加了两个元数据‘ordering’和‘verbose_name_plural’，分别表示排序和复数名，下面我们会详细介绍有哪些可用的元数据选项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强调：每个模型都可以有自己的元数据类，每个元数据类也只对自己所在模型起作用。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;abstract&quot;&gt;abstract&lt;/h3&gt;
&lt;p&gt;如果&lt;code&gt;abstract=True&lt;/code&gt;，那么模型会被认为是一个抽象模型。抽象模型本身不实际生成数据库表，而是作为其它模型的父类，被继承使用。具体内容可以参考Django模型的继承。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;app_label&quot;&gt;app_label&lt;/h3&gt;
&lt;p&gt;如果定义了模型的app没有在&lt;code&gt;INSTALLED_APPS&lt;/code&gt;中注册，则必须通过此元选项声明它属于哪个app，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app_label = 'myapp'&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;base_manager_name&quot;&gt;base_manager_name&lt;/h3&gt;
&lt;p&gt;自定义模型的&lt;code&gt;_base_manager&lt;/code&gt;管理器的名字。模型管理器是Django为模型提供的API所在。Django1.10新增。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;db_table&quot;&gt;db_table&lt;/h3&gt;
&lt;p&gt;指定在数据库中，当前模型生成的数据表的表名。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db_table = 'my_freinds'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;友情建议：使用MySQL数据库时，&lt;code&gt;db_table&lt;/code&gt;用小写英文。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;db_tablespace&quot;&gt;db_tablespace&lt;/h3&gt;
&lt;p&gt;自定义数据库表空间的名字。默认值是工程的&lt;code&gt;DEFAULT_TABLESPACE&lt;/code&gt;设置。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;default_manager_name&quot;&gt;default_manager_name&lt;/h3&gt;
&lt;p&gt;自定义模型的&lt;code&gt;_default_manager&lt;/code&gt;管理器的名字。Django1.10新增。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;default_related_name&quot;&gt;default_related_name&lt;/h3&gt;
&lt;p&gt;默认情况下，从一个模型反向关联设置有关系字段的源模型，我们使用&lt;code&gt;&amp;lt;model_name&amp;gt;_set&lt;/code&gt;，也就是源模型的名字+下划线+&lt;code&gt;set&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个元数据选项可以让你自定义反向关系名，同时也影响反向查询关系名！看下面的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Foo(models.Model):
    &lt;span class=&quot;cf&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Bar(models.Model):
    foo &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ForeignKey(Foo)

    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Meta:
        default_related_name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'bars'&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;# 关键在这里&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的使用差别如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; bar = Bar.objects.get(pk=1)
&amp;gt;&amp;gt;&amp;gt; # 不能再使用&quot;bar&quot;作为反向查询的关键字了。
&amp;gt;&amp;gt;&amp;gt; Foo.objects.get(bar=bar)
&amp;gt;&amp;gt;&amp;gt; # 而要使用你自己定义的&quot;bars&quot;了。
&amp;gt;&amp;gt;&amp;gt; Foo.objects.get(bars=bar)&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;get_latest_by&quot;&gt;get_latest_by&lt;/h3&gt;
&lt;p&gt;Django管理器给我们提供有latest()和earliest()方法，分别表示获取最近一个和最前一个数据对象。但是，如何来判断最近一个和最前面一个呢？也就是根据什么来排序呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get_latest_by&lt;/code&gt;元数据选项帮你解决这个问题，它可以指定一个类似 &lt;code&gt;DateField&lt;/code&gt;、&lt;code&gt;DateTimeField&lt;/code&gt;或者&lt;code&gt;IntegerField&lt;/code&gt;这种可以排序的字段，作为latest()和earliest()方法的排序依据，从而得出最近一个或最前面一个对象。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;get_latest_by = &quot;order_date&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;managed&quot;&gt;managed&lt;/h3&gt;
&lt;p&gt;该元数据默认值为True，表示Django将按照既定的规则，管理数据库表的生命周期。&lt;/p&gt;
&lt;p&gt;如果设置为False，将不会针对当前模型创建和删除数据库表。在某些场景下，这可能有用，但更多时候，你可以忘记该选项。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;order_with_respect_to&quot;&gt;order_with_respect_to&lt;/h3&gt;
&lt;p&gt;这个选项不好理解。其用途是根据指定的字段进行排序，通常用于关系字段。看下面的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Question(models.Model):
    text &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.TextField()
    &lt;span class=&quot;co&quot;&gt;# ...&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Answer(models.Model):
    question &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ForeignKey(Question, on_delete&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;models.CASCADE)
    &lt;span class=&quot;co&quot;&gt;# ...&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Meta:
        order_with_respect_to &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'question'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面在Answer模型中设置了&lt;code&gt;order_with_respect_to = 'question'&lt;/code&gt;，这样的话，Django会自动提供两个API，&lt;code&gt;get_RELATED_order()&lt;/code&gt;和&lt;code&gt;set_RELATED_order()&lt;/code&gt;，其中的&lt;code&gt;RELATED&lt;/code&gt;用小写的模型名代替。假设现在有一个Question对象，它关联着多个Answer对象，下面的操作返回包含关联的Anser对象的主键的列表[1,2,3]：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; question = Question.objects.get(id=1)
&amp;gt;&amp;gt;&amp;gt; question.get_answer_order()
[1, 2, 3]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过&lt;code&gt;set_RELATED_order()&lt;/code&gt;方法，指定上面这个列表的顺序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; question.set_answer_order([3, 1, 2])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，关联的对象也获得了两个方法&lt;code&gt;get_next_in_order()&lt;/code&gt;和&lt;code&gt;get_previous_in_order()&lt;/code&gt;，用于通过特定的顺序访问对象，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; answer = Answer.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; answer.get_next_in_order()
&amp;lt;Answer: 3&amp;gt;
&amp;gt;&amp;gt;&amp;gt; answer.get_previous_in_order()
&amp;lt;Answer: 1&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个元数据的作用......还没用过，囧。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;ordering&quot;&gt;ordering&lt;/h3&gt;
&lt;p&gt;最常用的元数据之一了！&lt;/p&gt;
&lt;p&gt;用于指定该模型生成的所有对象的排序方式，接收一个字段名组成的元组或列表。默认按升序排列，如果在字段名前加上字符“-”则表示按降序排列，如果使用字符问号“？”表示随机排列。请看下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ordering = ['pub_date']             # 表示按'pub_date'字段进行升序排列
ordering = ['-pub_date']            # 表示按'pub_date'字段进行降序排列
ordering = ['-pub_date', 'author']  # 表示先按'pub_date'字段进行降序排列，再按`author`字段进行升序排列。&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;permissions&quot;&gt;permissions&lt;/h3&gt;
&lt;p&gt;该元数据用于当创建对象时增加额外的权限。它接收一个所有元素都是二元元组的列表或元组，每个元素都是&lt;code&gt;(权限代码, 直观的权限名称)&lt;/code&gt;的格式。比如下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;permissions = ((&quot;can_deliver_pizzas&quot;, &quot;可以送披萨&quot;),)&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;default_permissions&quot;&gt;default_permissions&lt;/h3&gt;
&lt;p&gt;Django默认给所有的模型设置('add', 'change', 'delete')的权限，也就是增删改。你可以自定义这个选项，比如设置为一个空列表，表示你不需要默认的权限，但是这一操作必须在执行migrate命令之前。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;proxy&quot;&gt;proxy&lt;/h3&gt;
&lt;p&gt;如果设置了&lt;code&gt;proxy = True&lt;/code&gt;，表示使用代理模式的模型继承方式。具体内容与abstract选项一样，参考模型继承章节。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;required_db_features&quot;&gt;required_db_features&lt;/h3&gt;
&lt;p&gt;声明模型依赖的数据库功能。比如['gis_enabled']，表示模型的建立依赖GIS功能。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;required_db_vendor&quot;&gt;required_db_vendor&lt;/h3&gt;
&lt;p&gt;声明模型支持的数据库。Django默认支持&lt;code&gt;sqlite, postgresql, mysql, oracle&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;select_on_save&quot;&gt;select_on_save&lt;/h3&gt;
&lt;p&gt;决定是否使用1.6版本之前的&lt;code&gt;django.db.models.Model.save()&lt;/code&gt;算法保存对象。默认值为False。这个选项我们通常不用关心。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;indexes&quot;&gt;indexes&lt;/h3&gt;
&lt;p&gt;Django1.11新增的选项。&lt;/p&gt;
&lt;p&gt;接收一个应用在当前模型上的索引列表，如下例所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models

class Customer(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)

    class Meta:
        indexes = [
            models.Index(fields=['last_name', 'first_name']),
            models.Index(fields=['first_name'], name='first_name_idx'),
        ]&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;unique_together&quot;&gt;unique_together&lt;/h3&gt;
&lt;p&gt;这个元数据是非常重要的一个！它等同于数据库的联合约束！&lt;/p&gt;
&lt;p&gt;举个例子，假设有一张用户表，保存有用户的姓名、出生日期、性别和籍贯等等信息。要求是所有的用户唯一不重复，可现在有好几个叫“张伟”的，如何区别它们呢？（不要和我说主键唯一，这里讨论的不是这个问题）&lt;/p&gt;
&lt;p&gt;我们可以设置不能有两个用户在同一个地方同一时刻出生并且都叫“张伟”，使用这种联合约束，保证数据库能不能重复添加用户（也不要和我谈小概率问题）。在Django的模型中，如何实现这种约束呢？&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;unique_together&lt;/code&gt;，也就是联合唯一！&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unique_together = (('name', 'birth_day', 'address'),)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，哪怕有两个在同一天出生的张伟，但他们的籍贯不同，也就是两个不同的用户。一旦三者都相同，则会被Django拒绝创建。这一元数据经常被用在admin后台，并且强制应用于数据库层面。&lt;/p&gt;
&lt;p&gt;unique_together接收一个二维的元组((xx,xx,xx,...),(),(),()...)，每一个元素都是一个元组，表示一组联合唯一约束，可以同时设置多组约束。为了方便，对于只有一组约束的情况下，可以简单地使用一维元素，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unique_together = ('name', 'birth_day', 'address')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;联合唯一无法作用于普通的多对多字段。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;index_together&quot;&gt;index_together&lt;/h3&gt;
&lt;p&gt;即将废弃，使用&lt;code&gt;index&lt;/code&gt;元数据代替。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;verbose_name&quot;&gt;verbose_name&lt;/h3&gt;
&lt;p&gt;最常用的元数据之一！用于设置模型对象的直观、人类可读的名称。可以用中文。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;verbose_name = &quot;story&quot;
verbose_name = &quot;披萨&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你不指定它，那么Django会使用小写的模型名作为默认值。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;verbose_name_plural&quot;&gt;verbose_name_plural&lt;/h3&gt;
&lt;p&gt;英语有单数和复数形式。这个就是模型对象的复数名，比如“apples”。因为我们中文通常不区分单复数，所以保持和&lt;code&gt;verbose_name&lt;/code&gt;一致也可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;verbose_name_plural = &quot;stories&quot;
verbose_name_plural = &quot;披萨&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不指定该选项，那么默认的复数名字是&lt;code&gt;verbose_name&lt;/code&gt;加上‘s’&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;label&quot;&gt;label&lt;/h3&gt;
&lt;p&gt;前面介绍的元数据都是可修改和设置的，但还有两个只读的元数据，label就是其中之一。&lt;/p&gt;
&lt;p&gt;label等同于&lt;code&gt;app_label.object_name&lt;/code&gt;。例如&lt;code&gt;polls.Question&lt;/code&gt;，polls是应用名，Question是模型名。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;label_lower&quot;&gt;label_lower&lt;/h3&gt;
&lt;p&gt;同上，不过是小写的模型名。&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 13:28:00 +0000</pubDate>
<dc:creator>刘江liujiangblog.com</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixuelove1009/p/8419493.html</dc:identifier>
</item>
<item>
<title>聊聊构造函数 - -宇泽-</title>
<link>http://www.cnblogs.com/-yu-ze-/p/8419364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-yu-ze-/p/8419364.html</guid>
<description>&lt;h2&gt;JavaScript对象的创建方式&lt;/h2&gt;
&lt;p&gt;在JavaScript中，创建对象的方式包括两种：对象字面量和使用new表达式。对象字面量是一种灵活方便的书写方式，例如：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_384965&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var o1 = {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;p:”I’m in Object literal”,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alertP:function(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alert(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这样，就用对象字面量创建了一个对象o1，它具有一个成员变量p以及一个成员方法alertP。这种写法不需要定义构造函数，因此不在本文的讨论范围之内。这种写法的缺点是，每创建一个新的对象都需要写出完整的定义语句，不便于创建大量相同类型的对象，不利于使用继承等高级特性。&lt;/p&gt;
&lt;p&gt;new表达式是配合构造函数使用的，例如new String(“a string”)，调用内置的String函数构造了一个字符串对象。下面我们用构造函数的方式来重新创建一个实现同样功能的对象，首先是定义构造函数，然后是调用new表达式：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_805455&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function CO(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p = “I’m in constructed object”;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.alertP = function(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alert(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var o2 = newCO();&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;那么，在使用new操作符来调用一个构造函数的时候，发生了什么呢？其实很简单，就发生了四件事：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_281817&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var obj  ={};&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;obj.__proto__ = CO.prototype;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;CO.call(obj);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;obj;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;第一行，创建一个空对象obj。&lt;/p&gt;
&lt;p&gt;第二行，将这个空对象的__proto__成员指向了构造函数对象的prototype成员对象，这是最关键的一步，具体细节将在下文描述。&lt;/p&gt;
&lt;p&gt;第三行，将构造函数的作用域赋给新对象，因此CA函数中的this指向新对象obj，然后再调用CO函数。于是我们就给obj对象赋值了一个成员变量p，这个成员变量的值是” I’min constructed object”。&lt;/p&gt;
&lt;p&gt;第四行，返回新对象obj。当构造函数里包含返回语句时情况比较特殊，这种情况会在下文中说到。&lt;/p&gt;

&lt;h2&gt;正确定义JavaScript构造函数&lt;/h2&gt;
&lt;p&gt;不同于其它的主流编程语言，JavaScript的构造函数并不是作为类的一个特定方法存在的；当任意一个普通函数用于创建&lt;strong&gt;一类&lt;/strong&gt;对象时，它就被称作构造函数，或构造器。一个函数要作为一个真正意义上的构造函数，需要满足下列条件：&lt;/p&gt;
&lt;p&gt;1、 在函数内部对新对象（this）的属性进行设置，通常是添加属性和方法。&lt;/p&gt;
&lt;p&gt;2、 构造函数可以包含返回语句（不推荐），但返回值必须是this，或者其它非对象类型的值。&lt;/p&gt;
&lt;p&gt;上文定义的构造函数CO就是一个标准的、简单的构造函数。下面例子定义的函数C1返回了一个对象，我们可以使用new表达式来调用它，该表达式可以正确返回一个对象：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_894414&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function C1(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;var o = {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;p:”I’m p in C1”&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;o;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var o1 =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;C1();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;alert(o1.p);&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;但这种方式并不是值得推荐的方式，因为对象o1的原型是函数C1内部定义的对象o的原型，也就是Object.prototype。这种方式相当于执行了正常new表达式的前三步，而在第四步的时候返回了C1函数的返回值。该方式同样不便于创建大量相同类型的对象，不利于使用继承等高级特性，并且容易造成混乱，应该摒弃。&lt;/p&gt;
&lt;p&gt;一个构造函数在某些情况下完全可以作为普通的功能函数来使用，这是JavaScript灵活性的一个体现。下例定义的C2就是一个“多用途”函数：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_894269&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function C2(a, b){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p = a + b;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.alertP = function(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alert(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var c2 =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;C2(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;c2.alertP();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;alert(C2(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;));&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;该函数既可以用作构造函数来构造一个对象，也可以作为普通的函数来使用。用作普通函数时，它接收两个参数，并返回两者的相加的结果。为了代码的可读性和可维护性，建议作为构造函数的函数不要掺杂除构造作用以外的代码；同样的，一般的功能函数也不要用作构造对象。&lt;/p&gt;

&lt;h2&gt;为什么要使用构造函数&lt;/h2&gt;
&lt;p&gt;根据上文的定义，在表面上看来，构造函数似乎只是对一个新创建的对象进行初始化，增加一些成员变量和方法；然而构造函数的作用远不止这些。为了说明使用构造函数的意义，我们先来回顾一下前文提到的例子。执行var o2 = new CO();创建对象的时候，发生了四件事情：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_550422&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var obj  ={};&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;obj.__proto__ = CO.prototype;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;CO.call(obj);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;obj;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;我们说最重要的是第二步，将新生成的对象的__prop__属性赋值为构造函数的prototype属性，使得通过构造函数创建的所有对象可以共享相同的原型。这意味着同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的对象。关于原型（prototype）和继承的细节，笔者会再另一篇文章中深入说明。&lt;/p&gt;
&lt;p&gt;在JavaScript标准中，并没有__prop__这个属性，不过它现在已经是一些主流的JavaScript执行环境默认的一个标准属性，用于指向构造函数的原型。该属性是默认不可见的，而且在各执行环境中实现的细节不尽相同，例如IE浏览器中不存在该属性。我们只要知道JavaScript对象内部存在指向构造函数原型的指针就可以了，这个指针是在调用new表达式的时候自动赋值的，并且我们不应该去修改它。&lt;/p&gt;
&lt;p&gt;在构造对象的四个步骤中，我们可以看到，除第二步以外，别的步骤我们无须借助new表达式去实现，因此new表达式不仅仅是对这四个步骤的简化，也是要实现继承的必经之路。&lt;/p&gt;

&lt;h2&gt;容易混淆的地方&lt;/h2&gt;
&lt;p&gt;关于JavaScript的构造函数，有一个容易混淆的地方，那就是原型的constructor属性。在JavaScript中，每一个函数都有默认的原型对象属性prototype，该对象默认包含了两个成员属性：constructor和__proto__。关于原型的细节就不在本文赘述了，我们现在关心的是这个constructor属性。&lt;/p&gt;
&lt;p&gt;按照面向对象的习惯性思维，我们说构造函数相当于“类”的定义，从而可能会认为constructor属性就是该类实际意义上的构造函数，在new表达式创建一个对象的时候，会直接调用constructor来初始化对象，那就大错特错了。new表达式执行的实际过程已经在上文中介绍过了（四个步骤），其中用于初始化对象的是第三步，调用的初始化函数正是“类函数”本身，而不是constructor。如果没有考虑过这个问题，这一点可能不太好理解，那就让我们举个例子来说明一下吧：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_535261&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function C3(a, b){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p = a + b;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.alertP = function(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alert(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function fake(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;100&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;C3.prototype.constructor = fake;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var c3 =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;C3(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;c3.alertP();&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;上述代码手动改变了C3原型中的constructor函数，然而却没有对c3对象的创建产生实质的影响，可见在new表达式中，起初始化对象作用的只能是构造函数本身。那么constructor属性的作用是什么呢？一般来说，我们可以使用constructor属性来测试对象的类型：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_341493&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var myArray = [&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;(myArray.constructor == Array);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这招对于简单的对象是管用的，涉及到继承或者跨窗口等复杂情况时，可能就没那么灵光了：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_473660&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function f() {&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.foo =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function s() {&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.bar =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;; }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;s.prototype =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;f();&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var son =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;s();&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;(son.constructor == s);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;(son.constructor == f);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这样的结果可能跟你的预期不相一致，所以使用constructor属性的时候一定要小心，或者干脆不要用它。&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 12:40:00 +0000</pubDate>
<dc:creator>-宇泽-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-yu-ze-/p/8419364.html</dc:identifier>
</item>
</channel>
</rss>