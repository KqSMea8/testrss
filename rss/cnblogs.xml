<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>iOS Accessibility指南 - zhanggui</title>
<link>http://www.cnblogs.com/zhanggui/p/9258772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggui/p/9258772.html</guid>
<description>&lt;p&gt;开发者经常会为用户开发一些令人充满惊喜的App。但是，开发者真的为每一个潜在的用户都做适配了么？是否每个人都可以真正使用你的APP呢？&lt;br/&gt;设计APP、产品或者任何类型的服务，都要考虑到所有用户，包括视力、运动、学习或者听力有障碍的人。&lt;br/&gt;Apple不断地向开发者提供持续更新的工具，以便在设计的时候考虑到辅助功能。&lt;br/&gt;在这个指南中，你将从一个已经开发完成的APP入手，让其变得更易于访问。你将会学习到以下知识点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何使用VoiceOver&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如何使用Accessibility Inspector&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如何在UIKit中使用accessibility元素&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果让你的APP为残疾人士提供更好的用户体验&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本指南使用的是Swift语言，如果你对Swift了解不多，可以先学习Swift，然后再阅读。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：你需要一台物理设备来进行VoiceOver实验--这个accessibility特性不支持模拟器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;
&lt;p&gt;在学习过程中你用到的Demo APP是一个类似食谱的App，它展示了不同难度级别的食谱，而且可以对你做过的食物进行评分。&lt;br/&gt;你可以从&lt;a href=&quot;https://koenig-media.raywenderlich.com/uploads/2016/09/Recipe_starter.zip&quot;&gt;这里&lt;/a&gt;下载这个Demo APP。在你运行到真机之前，你需要配置相关的签名。(具体配置就不在多说了，如果你想在模拟器运行，则不用配置)。&lt;br/&gt;运行起来之后，可以先对此工程进行简单的了解。下面是对几个类的介绍：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RecipeInstrucationViewController.swift 点击列表的详情页&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;InstructionViewModel.swift是RecipeInstructionsViewController的数据源。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;RecipeCell.swift 是rootviewController的表格中的cell。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Recipe.swift是model对象，代表一个recipe。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;InstructionCell.swift是详情页的cell，一个checkbox+可添加删除线的label。当checkbok选中时，label添加删除线&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;RecipeListViewController.swift是根视图，展示列表&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;了解了本工程的大体结构之后，我们就开始添加一些accessibility特性。&lt;/p&gt;
&lt;h2 id=&quot;为什么是accessibility&quot;&gt;为什么是Accessibility？&lt;/h2&gt;
&lt;p&gt;开始编码之前，我们首先要理解accessibility的好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;无论你是使用的KIF框架还是进行Xcode中的UI测试，设计可访问性的应用程序都可以更轻松地编写功能测试。&lt;/li&gt;
&lt;li&gt;你还可以通过让更多的用户使用你的APP来扩大市场和用户客群。&lt;/li&gt;
&lt;li&gt;如果你为政府机构工作，则需要进行508合规性检测，其中规定所有用户都必须可以使用此APP以及其中的功能。&lt;/li&gt;
&lt;li&gt;此外，如果你做的APP给用户提供了帮助，哪怕微不足道，也会令你很有成就感。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;enabling-voiceover&quot;&gt;Enabling VoiceOver&lt;/h2&gt;
&lt;p&gt;VocieOver screen-reading 工具可以让用户在不看屏幕的情况下和你的软件进行交互，它是专门为有视觉障碍的用户而设计的。&lt;br/&gt;VoiceOver是UI和用户touch输入的链接，它提供了不同组件的可听性描述以及应用程序中所采取操作的可听性反馈。&lt;br/&gt;要想使用VoiceOver，首先打开设置app，然后通用--&amp;gt;辅助功能(Accessibility)--&amp;gt;VoiceOver(旁白)，打开即可。&lt;/p&gt;
&lt;h2 id=&quot;如何使用voiceover&quot;&gt;如何使用VoiceOver&lt;/h2&gt;
&lt;p&gt;打开了VoiceOver，接下来对一些操作手势进行简单的学习：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单击。你可以在屏幕上点击任一点，VoiceOver都会根据项目的可访问属性说出识别信息，后面会详细介绍&lt;/li&gt;
&lt;li&gt;双击将执行选中的选项。&lt;/li&gt;
&lt;li&gt;用力下按可以对表格进行滑动操作&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用voiceover&quot;&gt;使用VoiceOver&lt;/h2&gt;
&lt;p&gt;在设置中打开VoiceOver之后，运行食谱APP到手机，然后你可以按照上面的操作对该APP进行简单操作，你会发现一些问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;图像的描述并不准确，只是读出了图片的名称&lt;/li&gt;
&lt;li&gt;并没有说出每个食谱的困难等级，导致此功能对于使用VoiceOver的用户无效。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来就来解决这两个问题。&lt;/p&gt;
&lt;h2 id=&quot;accessibility辅助功能属性&quot;&gt;Accessibility（辅助功能）属性&lt;/h2&gt;
&lt;p&gt;为了支持可访问性，辅助功能属性是你必须要实现的核心组件。&lt;br/&gt;VoiceOver使用这些属性为用户提供有关应用中显示元素的可听信息。&lt;br/&gt;辅助功能有四个属性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Label：一种是被控件或者视图的方法，例如“后退按钮” 和 “食谱图像”&lt;/li&gt;
&lt;li&gt;Traits：描述元素的状态、行为或用法。按钮的特征可能是”已选中“&lt;/li&gt;
&lt;li&gt;Hint（提示）：描述元素完成的操作，例如：”显示配方详情“&lt;/li&gt;
&lt;li&gt;Frame：元素在屏幕中的frame，格式为CGRect。VoiceOver会说出CGRect的内容&lt;/li&gt;
&lt;li&gt;Value：元素的值，想想一下使用进度条或者滑动条，当前的value可能会读作：”5 out of 100“&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;大多数的UIKit组件都具有这些属性，你需要对属性进行相关的设置使VoiceOver的内容更有意义。&lt;/p&gt;
&lt;h2 id=&quot;accessibility-inspector&quot;&gt;Accessibility Inspector&lt;/h2&gt;
&lt;p&gt;在修复上面所说的两个问题时，你将会用到Xcode的一个工具：Accessibility Inspector。它可以做的事情有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过运行你的APP找到常见的辅助功能问题。&lt;/li&gt;
&lt;li&gt;允许你在检查模式下检查UI元素的辅助功能属性&lt;/li&gt;
&lt;li&gt;提供所有辅助元素的实时预览，而无需离开你的应用&lt;/li&gt;
&lt;li&gt;支持所有平台：macOS、iOS、watchOS和tvOS&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要想打开该工具，直接在Xcode菜单，然后Xcode--&amp;gt;Open Developer Tool--&amp;gt;Accessibility Inspector:&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/accessibility/openaccessibilityInspector.png&quot; alt=&quot;how open Accessibility Inspector&quot;/&gt;&lt;br/&gt;它的主界面是这样的：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/accessibility/interface.png&quot; alt=&quot;主界面&quot;/&gt;&lt;br/&gt;在Target Chooser处，你可以选择不同的设备以及不同的APP。将Recipes工程使用模拟器运行，然后使用该工具选择模拟器。&lt;/p&gt;
&lt;h3 id=&quot;inspection-pointer&quot;&gt;Inspection Pointer&lt;/h3&gt;
&lt;p&gt;选中Inspection Pointer,接下来将鼠标移动到模拟器，你会看到类似VoiceOver一样的选框，你可以使用该工具进行元素查看以及操作。&lt;br/&gt;Inspection Deatil框会展示选中元素的一些信息以及操作:&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/accessibility/detail.png&quot; alt=&quot;详情框内容展示&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;inspector-audit&quot;&gt;Inspector Audit&lt;/h3&gt;
&lt;p&gt;确定你的模拟器还在运行，并且当前展示的是食谱的列表，在inspector中，点击Audit 图标，然后点击Run audit。你会立即发现inspector已经找到一些缺少描述的元素。当你点击一个警告，模拟器中对应的元素会高亮。这种情况下，和cell关联的图片视图没有描述:&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/accessibility/imagenodesc.png&quot; alt=&quot;图片没有描述&quot;/&gt;&lt;br/&gt;如果你点击 ？号的小按钮，你会得到一些建议来如何解决这个问题，你只需要按照它的建议做一些调整即可。&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/accessibility/questionmark.png&quot; alt=&quot;question mark image&quot;/&gt;&lt;br/&gt;你（如果是QA同学）可以点击eye图标然后创建一个截图，方便向RD提交bug:&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/accessibility/screenshot.png&quot; alt=&quot;截图&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;inspector-settings&quot;&gt;Inspector Settings&lt;/h3&gt;
&lt;p&gt;该工具还允许你测试下面的Accessibility设置：&lt;br/&gt;1.Invert Color 反转颜色&lt;br/&gt;2.Reduce Transparency 降低透明度&lt;br/&gt;3.Reduce Motion 减少动画&lt;br/&gt;4.Change font size 改变字体大小&lt;br/&gt;你不再需要返回到设置APP中来设置这些特性。直接在Accessibility Inspector中操作即可。&lt;br/&gt;尽管Accessibility Inspector可以做的事情很多，但是你还是应该手动去测试VoiceOver，来看看用户使用的时候究竟如何表现。&lt;/p&gt;
&lt;h2 id=&quot;给recipe-app添加可访问性操作&quot;&gt;给Recipe APP添加可访问性操作&lt;/h2&gt;
&lt;p&gt;还看一下刚才的图片没有accessibility label。打开Xcode，然后打开RecipeCell.swift，然后添加下面的代码在文件的底部：&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;extension RecipeCell {
    func applyAccessibility(_ recipe: Recipe) {
        foodImageView.accessibilityTraits = UIAccessibilityTraitImage
        foodImageView.accessibilityLabel = recipe.photoDescription
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码添加了确实的辅助功能属性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;accessibilityTraits采用了表征可访问性元素的特性掩码。在这种情况下，UIAccessibilityTraitImage表示它是一个图像&lt;/li&gt;
&lt;li&gt;accessibilityLabel 是用来描述元素。这里用了recipe.photoDescription，它代表对图片的内容描述。可以在VoiceOver中读出。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在RecipeCell中找到configureCell( _ : )，然后添加下面一行代码到方法的结尾：&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;applyAccessibility(recipe)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在真机上运行，（打开VoiceOver）再次点击图像，你就会听到读的内容(为photoDescription)。&lt;br/&gt;这样不是更好吗？不是听到的image，而是提供了详细的图片描述，用户可以想象这种食物，而不是对图片内容一无所知。&lt;/p&gt;
&lt;h2 id=&quot;难以接触的label&quot;&gt;难以接触的Label&lt;/h2&gt;
&lt;p&gt;接下来处理一下食谱难度的label。你需要使这些label可以访问，并且更新它的属性信息，提供有意义的描述。&lt;br/&gt;在RecipeCell.swift中，添加下面的代码到applyAccessibility( _ : ):&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;        difficultyLabel.isAccessibilityElement = true
        difficultyLabel.accessibilityTraits = UIAccessibilityTraitNone
        difficultyLabel.accessibilityLabel = &quot;Difficult Label&quot;
        switch recipe.difficulty {
        case .unknown:
            difficultyLabel.accessibilityValue = &quot;Unkown&quot;
        case .rating(let value):
            difficultyLabel.accessibilityValue = &quot;\(value)&quot;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是对上述代码的一些介绍：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;isAccessibilityElements是一个标识，当为true的时候，该item对accessibility可见。对于大多数的UIKit元素，默认值为true，但是对于UILabel，默认值是false&lt;/li&gt;
&lt;li&gt;accessibilityTraits表示可访问元素。因为不需要交互，只需要将其设置为UIAccessibilityTraitNone即可。&lt;/li&gt;
&lt;li&gt;接下来，你就需要设置VoiceOver读出来的内容了。&quot;Difficulty Level&quot;告知用户这个元素是做什么的&lt;/li&gt;
&lt;li&gt;accessibilityValue是设置困难等级，使元素变得更加有意义&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来打开VoiceOver并重新编辑运行，此时点击困难等级，便会阅读”Difficulty Level 1/2/3/4/5“。&lt;/p&gt;
&lt;h2 id=&quot;再次检查警告&quot;&gt;再次检查警告&lt;/h2&gt;
&lt;p&gt;每次你公开新的辅助功能元素时，再次运行一次。你会发现如下警告：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/accessibility/dynamicfont.png&quot; alt=&quot;字体大小警告&quot;/&gt;&lt;br/&gt;用户将无法改变label字体的大小。点击？号按钮，按照其提供的建议修改即可。&lt;br/&gt;在RecipeCell.swift中的applyAccessibility( _ : )方法底部，添加如下代码：&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;difficultyLabel.font = UIFont.preferredFont(forTextStyle: .body)
difficultyLabel.adjustsFontForContentSizeCategory = true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置preferedFont为body意味着将Label的font设置为正文样式，大小和字体的细节取决于辅助功能设置。adjustsFontForContentSizeCategory是iOS10的新特性，表示当用户更改文本内容大小时，字体应自动更新。&lt;br/&gt;其他的功能自己可以使用真机进行更改查看。其中的Invert Color为反转颜色。具有敏感性、视力不佳或者在某些情况下色盲的用户，可以使用此功能。&lt;br/&gt;此时，使用Inspector工具提供的改变字体大小功能便可以调整字体的大小。&lt;/p&gt;
&lt;h2 id=&quot;recipe-detail-screen&quot;&gt;Recipe Detail Screen&lt;/h2&gt;
&lt;p&gt;接下来看一下食谱的详情页面。你会发现下面的问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;返回按钮并没有很好的描述出navigation buttton,导致用户不知道按钮是做什么用的，设置为返回button可能会更好。&lt;/li&gt;
&lt;li&gt;点击表情，VoiceOver读出的内容无法描述出来按钮具体是做什么的。&lt;/li&gt;
&lt;li&gt;checkbox也没有表达出来相应的意思。相比于内容阅读，用户更关心的是当前的状态是什么含义。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;打开RecipeInstructionsViewController.swift，然后添加下面的代码到viewDidLoad中(assert(recipe != nil)后面)：&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;backButton.accessibilityLabel = &quot;back&quot;
backButton.accessibilityTraits = UIAccessibilityTraitButton&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，VoiceOver将会说出”back button“，而不是”left arrow button“。&lt;br/&gt;还是在这个文件中，使用下面的代码替换isLikedFoot( _ : ):&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;  func isLikedFood(_ liked: Bool) {
    if liked {
        likeButton.setTitle(&quot;😍&quot;, for: .normal)
        likeButton.accessibilityLabel = &quot;like&quot;
        likeButton.accessibilityTraits = UIAccessibilityTraitButton
        didLikeFood = true
    } else {
        likeButton.setTitle(&quot;😖&quot;, for: .normal)
        likeButton.accessibilityLabel = &quot;Dislike&quot;
        likeButton.accessibilityTraits = UIAccessibilityTraitButton
        didLikeFood = false
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样喜欢和不喜欢的按钮便有了比较明显的含义。再次运行可以查看。&lt;br/&gt;接下来就是checklist。打开InstructionCell.swift，然后查看shouldStrikeThroughText( _ : )，替换if strikeThrough为下面代码：&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt; checkmarkButton.isAccessibilityElement = false
    if strikeThrough {
        descriptionLabel.accessibilityLabel = &quot;Complete \(text)&quot;
   attributeString.addAttribute(NSAttributedStringKey.strikethroughStyle, value: 2, range: NSMakeRange(0, attributeString.length))
    }else {
        descriptionLabel.accessibilityLabel = &quot;UnComplete \(text)&quot;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来点击步骤，便可以清楚地告知用户是否完成步骤。&lt;/p&gt;
&lt;h2 id=&quot;结束&quot;&gt;结束&lt;/h2&gt;
&lt;p&gt;这里只是对Accessibility做了一个入门的介绍，告诉用户工具的使用以及简单的关于Accessibility的属性的赋值操作。&lt;/p&gt;
&lt;p&gt;原文整体内容翻译自&lt;a href=&quot;https://www.raywenderlich.com/142058/ios-accessibility-tutorial&quot;&gt;iOS Accessibility Tutorial: Getting Started&lt;/a&gt;，但是里面的内容有所调整。有些内容不代表原作观点。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;1.&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/iPhoneAccessibility/Making_Application_Accessible/Making_Application_Accessible.html#//apple_ref/doc/uid/TP40008785-CH102-SW4&quot;&gt;Making Your iOS App Accessible&lt;/a&gt;&lt;br/&gt;2.&lt;a href=&quot;https://www.raywenderlich.com/142058/ios-accessibility-tutorial&quot;&gt;iOS Accessibility Tutorial: Getting Started&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Jul 2018 07:21:00 +0000</pubDate>
<dc:creator>zhanggui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggui/p/9258772.html</dc:identifier>
</item>
<item>
<title>python单元测试unittest - Luna丶</title>
<link>http://www.cnblogs.com/for-you/p/9258699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/for-you/p/9258699.html</guid>
<description>&lt;p&gt;unittest原名为PyUnit，是由java的JUnit衍生而来。对于单元测试，需要设置预先条件，对比预期结果和实际结果。&lt;/p&gt;
&lt;p&gt;整体结构：&lt;br/&gt;unittest库提供了test cases, test suites, test fixtures，test runner：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;test case&lt;/strong&gt; ：通过继承TestCase类，我们可以创建一个test，或者一组tests，包括测试前准备环境的搭建(setUp)，执行测试代码(run)，以及测试后环境的还原(tearDown)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;test suites&lt;/strong&gt; ： 测试套件,多个测试用例集合在一起,TestSuite也可以嵌套TestSuite。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;test fixtures&lt;/strong&gt; ： setup + test case + teardown结构&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TestLoader&lt;/strong&gt;:用来加载TestCase到TestSuite中，其中的方法从各个地方寻找TestCase，创建它们的实例，然后add到TestSuite中，返回一个TestSuite实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;test runner&lt;/strong&gt;：执行测试用例，其中的run()会执行TestSuite/TestCase。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TextTestResult&lt;/strong&gt;：测试的结果会保存到TextTestResult实例中，包括运行用例数，成功数，失败数等。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/813466/201807/813466-20180703150817335-1852743665.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;写好TestCase，然后由TestLoader加载TestCase到TestSuite，然后由TextTestRunner来运行TestSuite，运行的结果保存在TextTestResult中，整个过程集成在unittest.main模块中。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注:&lt;br/&gt;所有的测试函数以test开头，test_XXX。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的示例：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import unittest
class TestStringMethods(unittest.TestCase):
    def test_upper(self):
        self.assertEqual('foo',upper(),'FOO')
    def test_isupper(self):
        self.assertEqualTure('FOO'.isupper())
        self.assertFalse('Foo'.isupper())
    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(),['hello','world'])
        with self.assertEqualRaise(TypeError):
            s.slipt(2)
if __name__ == '__main__': #unittest.main：为测试提供了入口。
    unittest.main()
    
#运行结果：
...
----------------------------------------------------------------------
Ran 3 tests in 0.064s
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他与unittest类似的单元测试库：&lt;a href=&quot;https://nose.readthedocs.org/en/latest/&quot;&gt;nose&lt;/a&gt;, pytest。&lt;/p&gt;

&lt;p&gt;从命令行中可以运行单元测试的&lt;strong&gt;模块&lt;/strong&gt;，&lt;strong&gt;类&lt;/strong&gt;，甚至单独的&lt;strong&gt;测试方法&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python -m unittest test_module1 test_module2  #同时测试多个module
python -m unittest test_module.TestClass
python -m unittest test_module.TestClass.test_method&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示更详细的测试结果的说明使用&lt;code&gt;-v&lt;/code&gt;flag：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python -m unittest -v test_module&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看所有的命令行选项使用命令&lt;code&gt;python -m unittest -h&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;testcase类&quot;&gt;Testcase类&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;class unittest.TestCase(methodName='runTest')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TestCase的实例是最小的可测试单元。 testcase 是由unittest的&lt;a href=&quot;https://docs.python.org/2/library/unittest.html#unittest.TestCase&quot;&gt;TestCase&lt;/a&gt;类的实例表示的。要编写自己的测试用例必须继承TestCase类,或者使用FunctionTestCase。且Testcase类提供了各种assert的方法来检测预期结果和实际结果。&lt;/p&gt;
&lt;p&gt;看下面的例子(创建一个测试类DefaultWidgetSizeTestCase)：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import unittest
class DefaultWidgetSizeTestCase(unittest.TestCase): #unittest.TestCase表示某个测试函数
    def runTest(self):
        widget = Widget('The widget')
        self.assertEqual(widget.size(), (50, 50), 'incorrect default size')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建实例&lt;br/&gt;建立这样一个测试用例的一个实例,使用该类的构造函数，且不带参数(这样会执行所有的测试方法):&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;testCase = DefaultWidgetSizeTestCase()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们也可以创建多个实例，且每个实例之间都是独立的。&lt;br/&gt;当我们需要对不同的实例执行不同的测试方法时，我们可以将要执行的测试用例方法在创建实例时通过类参数传入。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#建了两个WidgetTestCase的实例，每个实例只运行WidgetTestCase类中的一个测试方法(通过参数传入)
defaultSizeTestCase = WidgetTestCase('test_default_size')
resizeTestCase = WidgetTestCase('test_resize')&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;unittest库提供了很多实用方法来检测程序运行的结果和预期。&lt;/p&gt;
&lt;p&gt;包括三种类型的方法，每一种都覆盖了典型的类型，比如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查相等值&lt;/li&gt;
&lt;li&gt;逻辑比较&lt;/li&gt;
&lt;li&gt;异常&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果给定的assertion通过了，那么测试会执行下一行代码。&lt;br/&gt;如果给定的assertion没有通过，测试会暂停并且生成错误信息。&lt;br/&gt;unittest库提供所有标准的xUnit assert方法。下面列出较重要方法的一部分：&lt;br/&gt;检测元素是否相等：&lt;br/&gt;&lt;code&gt;assertEqual(a,b [,msg])&lt;/code&gt;: 检测a==b,这个方法检查a是否等于b，常用语检测元素属性等。如：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;assertEqual(element.text, &quot;10&quot;)
assertNotEqual(a,b [,smg]):检测a!==b.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检测表达式是否为Ture，或者 False:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;assertTrue(x [,msg])  #检测bool(x) is True.
#如：检测某个元素是否在页面上
#assertTrue(element.is_dispalyed())
assertFalse(x [,msg])  #检测bool(y) is Flase.
assertIsNot(a, b [,msg])  #检测 a is not b.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检测异常&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;assertRaises(exc, fun, *args, **kwds)
assertRaiseRegexp(exc, r, fun, *args, **kwds)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最有可能使用这些方法的是NoSuchElementFoundexception&lt;/p&gt;
&lt;p&gt;检测数字，先四舍五入到指定的小数位数后再进行比较&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;assertAlmostEqual(a, b)   #检测round(a-b,7)==0
assertNotAlmostEqual(a, b)   #检测round(a-b,7)!=0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;逻辑运算&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;assertGreater(a, b)  # 检测a &amp;gt; b.
assertGreaterEqual(a ,b)  # 检测a &amp;gt;= b.
assertLess(a, b)     #检测a &amp;lt; b.
assertLessEqual(a, b)   #检测a &amp;lt;= b.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正则表达式，检测正则是否匹配给定的text&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;assertRegexpMatches(s, r)       #检测r.search(s).
assertNotRegexpMatches(s, r)  #检测not r.search(s).&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检测字符串&lt;br/&gt;&lt;code&gt;assertMultiLineEqual(a, b) #检测string&lt;/code&gt;&lt;br/&gt;检测lists之间是否相等&lt;br/&gt;&lt;code&gt;assertListEqual(a, b) #检测lists&lt;/code&gt;&lt;br/&gt;fail()无条件失败，用户自定义&lt;br/&gt;&lt;code&gt;fail()&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;方法固定装置&quot;&gt;方法固定装置：&lt;/h2&gt;
&lt;p&gt;如果要对一个模块中的每一个测试函数都做同样的初始化操作和结尾清除等操作，那么创建n个测试用例就得写n遍一样的代码，为了减少重复的代码，可以使用下面两个函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;setUp(): 每次执行测试用例之前调用。无参数，无返回值。该方法抛出的异常都视为error，而不是测试不通过。没有默认的实现。&lt;/li&gt;
&lt;li&gt;tearDown(): 每次执行测试用例之后调用。无参数，无返回值。测试方法抛出异常，该方法也正常调用，该方法抛出的异常都视为error，而不是测试不通过。只用setUp()调用成功，该方法才会被调用。没有默认的实现。&lt;br/&gt;通过setup 和 tesrDown组装一个module成为一个固定的测试装置。&lt;br/&gt;注意：如果setup运行抛出错误，则测试用例代码则不会执行。但是，如果setpu执行成功，不管测试用例是否执行成功都会执行teardown。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;class固定装置&quot;&gt;Class固定装置：&lt;/h2&gt;
&lt;p&gt;必须为类实现&lt;br/&gt;&lt;code&gt;setUpClass()&lt;/code&gt;:一个类方法在单个类测试之前运行。setUpClass作为唯一的参数被调用时,必须使用classmethod()作为装饰器。&lt;br/&gt;&lt;code&gt;tearDownClass()&lt;/code&gt;:一个类方法在单个类测试之后运行。setUpClass作为唯一的参数被调用时,必须使用classmethod()作为装饰器。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import unittest
class Test(unittest.TestCase):
    @classmethod
    def setUpClass(cls): #这里的cls是当前类的对象
        cls._connection = createExpensiveConnectionObject()

    @classmethod
    def tearDownClass(cls):
        cls._connection.destroy()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;module固定装置&quot;&gt;Module固定装置：&lt;/h2&gt;
&lt;p&gt;必须为方法实现&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def setUpModule():
    createConnection()

def tearDownModule():
    closeConnection()&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;unittest.TestSuite(tests=())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该类聚合测试用例和测试套件，运行一个TestSuite实例遍历套件,和单独运行每个testcase是相同的。TestSuite对象的行为就像TestCase对象,除了他们不实现一个测试。&lt;br/&gt;一些方法可以将testcase添加到TestSuite实例:&lt;br/&gt;&lt;code&gt;addTest(test)&lt;/code&gt;:Add a TestCase or TestSuite to the suite.&lt;br/&gt;&lt;code&gt;addTests(tests)&lt;/code&gt;:添加所有的tests从可迭代的TestCase和TestSuite实例测试套件。这相当于迭代调用addTest()来添加每个元素。&lt;/p&gt;
&lt;p&gt;根据不同的业务可能需要在不同的module中选择某一个或者几个测试用例，此时可以根据每个测试实例的特征对测试方法打包：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;widgetTestSuite = unittest.TestSuite() #创建一个测试套件实例
widgetTestSuite.addTest(WidgetTestCase('test_default_size')) #添加测试用例到套件，抽取WidgetTestCase类中的test_default_size测试用例添加到testsuite
widgetTestSuite.addTest(WidgetTestCase('test_resize'))  #添加测试用例到套件，抽取WidgetTestCase类中的test_resize测试用例添加到testsuite&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以返回该测试套件的get入口：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def suite():
    suite = unittest.TestSuite()
    suite.addTest(WidgetTestCase('test_default_size'))
    suite.addTest(WidgetTestCase('test_resize'))
    return suite&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者更简洁的写法：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def suite():
    tests = ['test_default_size', 'test_resize']
    return unittest.TestSuite(map(WidgetTestCase, tests))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试套件中也可以包含测试套件：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;suite1 = module1.TheTestSuite()
suite2 = module2.TheTestSuite()
alltests = unittest.TestSuite([suite1, suite2])&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用testloader&quot;&gt;使用TestLoader&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;class unittest.TestLoader&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TestLoader 用来从clases和modules创建test suites，通常也需要创建一个该类的实例，unittest模块提供了一个实例,可以作为unittest.defaultTestLoader共享。使用一个子类或实例,允许定制可配置属性。&lt;br/&gt;该类有以下&lt;a href=&quot;https://docs.python.org/2.7/library/unittest.html#loading-and-running-tests&quot;&gt;方法&lt;/a&gt;:&lt;br/&gt;&lt;code&gt;loadTestsFromTestCase(testCaseClass)&lt;/code&gt;:&lt;br/&gt;&lt;code&gt;loadTestsFromModule(module)&lt;/code&gt;:返回一个给定的模块中所有测试用例，打包成一个套件返回。&lt;br/&gt;.....&lt;/p&gt;
&lt;p&gt;该类创建一个testsuites然后加载一个module并执行其中所有的测试用例，执行的顺序是根据测试用例的名称来的。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;suite = unittest.TestLoader().loadTestsFromTestCase(WidgetTestCase) #执行WidgetTestCase中所有的测试用例&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以将测试用例和测试套件放在一个module中，最好是分开放置，方便重构管理，如果测试策略改变了，也方便维护。&lt;/p&gt;
&lt;p&gt;运行添加的测试套件：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;if __name__ == &quot;__main__&quot;:
    login_test_suite = unittest.TestSuite()
    login_test_suite.addTest(Login('test_xxx'))
    login_test_suite.addTest(Login('test_xxx2'))
    runner = unittest.TextTestRunner()
    runner.run(login_test_suite)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Unittest支持跳过单个的测试方法甚至整个类的测试。使用 skip() decorator来设置特定跳过的条件，如指定操作系统不执行该测试。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;    @unittest.skipIf(mylib.__version__ &amp;lt; (1, 3), &quot;not supported in this library version&quot;)
    def test_format(self):
        # Tests that work for only a certain version of the library.
        pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行的时候如果满足跳过条件，控制台会将后面的说明打印出来，并跳过该测试用例。跳过类也是相似的写法。&lt;br/&gt;也可以自定义skipping装饰器。&lt;/p&gt;
&lt;p&gt;定义预期的失败使用&lt;a href=&quot;https://docs.python.org/2/library/unittest.html#unittest.expectedFailure&quot;&gt;unittest.expectedFailure()&lt;/a&gt;,运行时 ,如果测试失败,测试不算作失败。&lt;/p&gt;

&lt;h2 id=&quot;用例执行顺序&quot;&gt;用例执行顺序&lt;/h2&gt;
&lt;p&gt;unittest的执行的顺序是根据测试用例的名称来的。名称是按照英文字母排序。a-z。&lt;br/&gt;每个测试用例之间的数据最好不要相互依赖，如果一定要相互依赖则调整用力的执行顺序来保证运行的正确性。&lt;br/&gt;要改变运行顺序，可以使用addTest通过测试套件添加测试用例的顺序，运行测试。&lt;/p&gt;

&lt;p&gt;unittest本身并不具备这个功能，需要使用&lt;a href=&quot;https://pypi.python.org/pypi/HTMLTestRunner&quot;&gt;HTMLTestRunner库&lt;/a&gt;&lt;br/&gt;使用步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先需要下载.py文件：&lt;a href=&quot;http://tungwaiyip.info/software/HTMLTestRunner.html&quot;&gt;HTMLTestRunner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;下载后放入python安装目录的lib文件夹下面。&lt;/li&gt;
&lt;li&gt;打开终端进入python交互模式导入HTMLTestRunner ,如果无导入错误显示，则说明添加成功&lt;br/&gt;&lt;code&gt;import HTMLTestRunner&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：python3的stringIO有变化，使用该HTMLTestRunner会报错ImportError: No module named 'StringIO'。这里使用python2.7试验。&lt;/p&gt;
&lt;h2 id=&quot;help查看类帮助信息&quot;&gt;1 help()查看类帮助信息&lt;/h2&gt;
&lt;p&gt;为了说明在报告中显示用例的注释，这里先了解下help()帮助函数。&lt;br/&gt;help帮助信息息都是代码中通过 &lt;code&gt;'''xxx '''&lt;/code&gt; 或者 &lt;code&gt;&quot;&quot;&quot;xxx&quot;&quot;&quot;&lt;/code&gt; 注释符号来标注的。&lt;br/&gt;如我们自定义一个模块helpin.py,并将其放入python目录的lib文件夹下面：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#coding=utf-8
u'''
这是help能够显示的帮助信息
'''
def add(a):
    u&quot;&quot;&quot;这个函数用来输入a的值&quot;&quot;&quot;
    print 'a'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在cmd命令行中，进入python27的交互模式，导入后通过help查看帮助信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import helpin
&amp;gt;&amp;gt;&amp;gt; help(helpin)
Help on module helpin:
NAME
    helpin - 这是help能够显示的帮助信息
FILE
    e:\python27\lib\helpin.py
FUNCTIONS
    add(a)
        这个函数用来输入a的值&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;报告中显示用例的注释&quot;&gt;2 报告中显示用例的注释&lt;/h2&gt;
&lt;p&gt;给报告中的每个测试用例添加注释，来说明该测试用例是用来干什么的，非常有必要。&lt;br/&gt;通过help()函数来查看HTMLTestRunner类的详细说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import HTMLTestRunner
&amp;gt;&amp;gt;&amp;gt; help(HTMLTestRunner) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到该类的注释说明，一个好的开源的框架应该有这样的规范。&lt;/p&gt;
&lt;p&gt;这里在每个测试函数的下方添加上注释：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;    def test_equal(self):
        u'''这里是测试a和b的两个值是否相等'''
        a = 1
        b = 2
        self.assertEqual(a,b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后，打开生成的html文件可以看到，每个测试用例函数的后面有该用例的注释。&lt;/p&gt;
&lt;h2 id=&quot;动态生成需要多次执行的测试报告文件名称&quot;&gt;3 动态生成需要多次执行的测试报告文件名称&lt;/h2&gt;
&lt;p&gt;如果一个测试套件需要多次执行，如果每次执行不去修改测试报告.html的文件名，则每次执行后会将之前的报告覆盖。如果想要保存每次执行的结果而不手动修改报告名称。这里可以使用动态生成文件名的方法。具体的生成可以根据需要来写动态生成的代码。&lt;/p&gt;
&lt;h3 id=&quot;动态时间&quot;&gt;动态时间&lt;/h3&gt;
&lt;p&gt;python 时间函数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;time.time() 获取当前时间戳。&lt;/li&gt;
&lt;li&gt;time.ctime() 当前时间的字符串形式。&lt;/li&gt;
&lt;li&gt;time.localtime() 当前时间的 struct_time 形式。&lt;/li&gt;
&lt;li&gt;time.strftime() 用来获得当前时间，可以将时间格式化为字符串。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;修改之前的代码，将文件名字中添加上当前获取到的时间：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#获取当前时间
now = time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;)


#定义报告文件存放位置,这里将结果放在桌面
outfile = open('C:\\Users\Administrator\\Desktop\\'+ now + '_result.html', &quot;w&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的文件名称以2016-03-09_17_37_26_result.html格式出现。&lt;/p&gt;
&lt;h2 id=&quot;集成多个测试结果&quot;&gt;4 集成多个测试结果&lt;/h2&gt;
&lt;p&gt;目前测试报告只集成到了单个测试文件中，我们的最终目的是将其集成到一个文件中。&lt;br/&gt;之前是通过&lt;code&gt;testunit.addTests()&lt;/code&gt;函数逐个添加。&lt;br/&gt;现在通过&lt;code&gt;unittest.defaultTestLoader.discover()&lt;/code&gt;方法循环遍历添加测试用例。&lt;br/&gt;最后通过&lt;code&gt;runner.run()&lt;/code&gt;方法运行整个测试用例集。&lt;/p&gt;
</description>
<pubDate>Tue, 03 Jul 2018 07:13:00 +0000</pubDate>
<dc:creator>Luna丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/for-you/p/9258699.html</dc:identifier>
</item>
<item>
<title>初次接触CSS变量 - 雨霖月寒</title>
<link>http://www.cnblogs.com/jofun/p/9258416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jofun/p/9258416.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;本文的目的主要是展示CSS变量是如何工作的。&lt;/span&gt;&lt;span&gt;随着Web应用程序变得越来越大，CSS变得越来越大，越来越多，而且很多时候都很乱，&lt;/span&gt;&lt;span&gt;在良好的上下文中使用&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;CSS变量&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，为您提供重用和轻松更改重复出现的CSS属性的机制。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在“纯粹的”CSS支持变量之前，我们有像&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://lesscss.org/&quot;&gt;&lt;span&gt;&lt;span&gt;Less&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;和&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://sass-lang.com/&quot;&gt;&lt;span&gt;&lt;span&gt;Sass&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;这样的预处理器&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;但是它们需要在使用前进行编译，因此（有时）会增加额外的复杂性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;如何定义和使用CSS变量&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从我们最熟悉的语言JavaScript开始：在JavaScript中定义变量使用vars。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;要声明一个简单的JavaScript var，如下内容：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; mainColor = 'red';
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要声明一个CSS变量，您必须在该var的名称前添加一个双短划线。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;body&lt;/span&gt;{&lt;span&gt;
    --color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;现在，为了使用CSS变量的值，我们可以使用&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;var（...）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;函数。如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.demo{
    background:&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;(--&lt;span&gt;color);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;管理&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;CSS变量&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;的最简单方法&lt;/span&gt;&lt;span&gt;是将它们声明为&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;：root&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;伪类。&lt;/span&gt;&lt;span&gt;鉴于CSS变量遵循规则，就像任何其他CSS定义一样，将它们放在：root中将确保所有选择器都可以访问这些变量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;:root{
    &lt;/span&gt;--&lt;span&gt;color:red;
}
            
.demo{
    background:&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;(--&lt;span&gt;color);
}
            
p{
    color:&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;(--&lt;span&gt;color);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;浏览器支持CSS变量？&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;浏览器对CSS变量的支持还算不错的。只是IE浏览器不支持。想查看浏览器兼容性的可以&lt;/span&gt;&lt;a href=&quot;https://caniuse.com/#feat=css-variables&quot; target=&quot;_blank&quot;&gt;点击这里&lt;/a&gt;&lt;/span&gt;，&lt;span&gt;&lt;span&gt;那么您将看到所有主流浏览器都支持开箱即用的CSS变量。&lt;/span&gt;&lt;span&gt;无论是手机还是台式机。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;CSS变量的实质应用&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;示例1 - 管理颜色&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;到目前为止，使用CSS变量的最佳候选者之一是管理网页的颜色。&lt;/span&gt;&lt;span&gt;我们可以将它们放在变量中，而不是一遍又一遍地复制和粘贴相同的颜色。如果有人要求我们更新特定的绿色阴影或使所有按钮变为红色而不是蓝色，那么只需更改该CSS变量的值，就是这样。&lt;/span&gt;&lt;span&gt;您不必搜索和替换该颜色的所有实例。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;列如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;CSS代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;css_vars.css&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
:root &lt;/span&gt;{&lt;span&gt;
  --primary-color&lt;/span&gt;:&lt;span&gt; #ed6564&lt;/span&gt;;&lt;span&gt;
  --accent-color&lt;/span&gt;:&lt;span&gt; #388287&lt;/span&gt;;
}&lt;span&gt;

html &lt;/span&gt;{&lt;span&gt;
  background-color&lt;/span&gt;:&lt;span&gt; var(--primary-color)&lt;/span&gt;;
}&lt;span&gt;

h3 &lt;/span&gt;{&lt;span&gt;
  border-bottom&lt;/span&gt;:&lt;span&gt; 2px solid var(--primary-color)&lt;/span&gt;;
}&lt;span&gt;

button &lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; var(--accent-color)&lt;/span&gt;;&lt;span&gt;
  border&lt;/span&gt;:&lt;span&gt; 1px solid var(--accent-color)&lt;/span&gt;;
}&lt;span&gt;

p &lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; var(--accent-color)&lt;/span&gt;;
}


&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;base.css&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
* &lt;/span&gt;{&lt;span&gt;
  margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
  box-sizing&lt;/span&gt;:&lt;span&gt; border-box&lt;/span&gt;;
}&lt;span&gt;

html &lt;/span&gt;{&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;&lt;span&gt;
  font&lt;/span&gt;:&lt;span&gt; normal 13px/1.5 sans-serif&lt;/span&gt;;&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; #546567&lt;/span&gt;;&lt;span&gt;
  background-color&lt;/span&gt;:&lt;span&gt; var(--primary-color)&lt;/span&gt;;
}&lt;span&gt;

.container &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; #fff&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;
}&lt;span&gt;

h3 &lt;/span&gt;{&lt;span&gt;
  padding-bottom&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;&lt;span&gt;
  margin-bottom&lt;/span&gt;:&lt;span&gt; 15px&lt;/span&gt;;
}&lt;span&gt;

p &lt;/span&gt;{&lt;span&gt;
  background-color&lt;/span&gt;:&lt;span&gt; #fff&lt;/span&gt;;&lt;span&gt;
  margin&lt;/span&gt;:&lt;span&gt; 15px 0&lt;/span&gt;;
}&lt;span&gt;

button &lt;/span&gt;{&lt;span&gt;
  margin&lt;/span&gt;:&lt;span&gt;0 5px&lt;/span&gt;;&lt;span&gt;
  font-size&lt;/span&gt;:&lt;span&gt; 13px&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 8px 12px&lt;/span&gt;;&lt;span&gt;
  background-color&lt;/span&gt;:&lt;span&gt; #fff&lt;/span&gt;;&lt;span&gt;
  border-radius&lt;/span&gt;:&lt;span&gt; 3px&lt;/span&gt;;&lt;span&gt;
  box-shadow&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
  text-transform&lt;/span&gt;:&lt;span&gt; uppercase&lt;/span&gt;;&lt;span&gt;
  font-weight&lt;/span&gt;:&lt;span&gt; bold&lt;/span&gt;;&lt;span&gt;
  cursor&lt;/span&gt;:&lt;span&gt; pointer&lt;/span&gt;;&lt;span&gt;
  opacity&lt;/span&gt;:&lt;span&gt; 0.8&lt;/span&gt;;&lt;span&gt;
  outline&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
}&lt;span&gt;

button:hover &lt;/span&gt;{&lt;span&gt;
  opacity&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;
}&lt;span&gt;

.center &lt;/span&gt;{&lt;span&gt;
  text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;HTML代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;就业协议书&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;就业协议书，全称是《全国普通高等学校毕业生就业协议书》，是由教育部高校学生司统一制订的。根据国家规定，在达成就业意向后，毕业生、用人单位、学校三方必须签订《全国普通高等学校毕业生就业协议书》。就业协议书是具有一定的广泛性和权威性，是学校制订就业方案派遣毕业生、用人单位申请用人指标的主要依据，对签约的三方都有约束力。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;查看详情&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;取消&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击&lt;a href=&quot;http://jsrun.net/WvgKp/edit&quot; target=&quot;_blank&quot;&gt;查看运行结果。&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;&lt;span&gt;示例2 - 删除重复的代码&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通常，您需要构建一些不同的组件变体。&lt;/span&gt;&lt;span&gt;相同的基本样式，略有不同。&lt;/span&gt;&lt;span&gt;让我们使用一些颜色不同的按钮。典型的解决方案是创建一个基类，比如.btn并添加变体类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.btn &lt;/span&gt;{&lt;span&gt;
  border&lt;/span&gt;:&lt;span&gt; 2px solid black&lt;/span&gt;;}&lt;span&gt;

.btn:hover &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; black&lt;/span&gt;;}&lt;span&gt;

.btn.red &lt;/span&gt;{&lt;span&gt;
  border-color&lt;/span&gt;:&lt;span&gt; red
&lt;/span&gt;}&lt;span&gt;
.btn.red:hover &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; red
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在使用它们像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;但是，这会添加一些代码重复。&lt;/span&gt;&lt;span&gt;在.red变体上，我们必须将border-color和background设置为红色。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这中情况可以使用CSS变量轻松修复。如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CSS代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.btn&lt;/span&gt;{&lt;span&gt;
  border-radius&lt;/span&gt;:&lt;span&gt;4px&lt;/span&gt;;&lt;span&gt;
  text-align&lt;/span&gt;:&lt;span&gt;center&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt;.5em&lt;/span&gt;;&lt;span&gt;
  margin-bottom&lt;/span&gt;:&lt;span&gt;0.5em&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt;#fff&lt;/span&gt;;&lt;span&gt;
  border&lt;/span&gt;:&lt;span&gt;1px solid var(--color, black)&lt;/span&gt;;
}&lt;span&gt;

.btn:hover&lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt;#fff&lt;/span&gt;;&lt;span&gt;
  cursor&lt;/span&gt;:&lt;span&gt;pointer&lt;/span&gt;;&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt;var(--color, black)&lt;/span&gt;;
}&lt;span&gt;

.btn.red&lt;/span&gt;{&lt;span&gt;
  --color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;
}&lt;span&gt;

.btn.green&lt;/span&gt;{&lt;span&gt;
  --color&lt;/span&gt;:&lt;span&gt;green&lt;/span&gt;;
}&lt;span&gt;

.btn.blue&lt;/span&gt;{&lt;span&gt;
  --color&lt;/span&gt;:&lt;span&gt;blue&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;HTML代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HMOE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HMOE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn green&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HMOE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn blue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HMOE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;&lt;span&gt;示例3 - 使一些属性可读&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果我们想要创建更复杂的属性值的快捷方式，CSS vars非常适合使用，因此我们不必记住它。CSS属性，如box-shadow，transform和font或其他带有多个参数的CSS规则就是完美的例子。我们可以将属性放在变量中，以便我们可以通过更易读的格式重用它。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;:root &lt;/span&gt;{&lt;span&gt;
  --tiny-shadow&lt;/span&gt;:&lt;span&gt; 4px 4px 2px 0 rgba(0, 0, 0, 0.8)&lt;/span&gt;;&lt;span&gt;
  --animate-right&lt;/span&gt;:&lt;span&gt; translateX(20px)&lt;/span&gt;;
}&lt;span&gt;

li &lt;/span&gt;{&lt;span&gt;
  box-shadow&lt;/span&gt;:&lt;span&gt; var(--tiny-shadow)&lt;/span&gt;;
}&lt;span&gt;

li:hover &lt;/span&gt;{&lt;span&gt;
  transform&lt;/span&gt;:&lt;span&gt; var(--animate-right)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;&lt;span&gt;例4 - 级联变量&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;标准级联规则也适用于CSS变量。因此，如果多次声明自定义属性，则css文件中最低的定义将覆盖其上方的定义。下面的示例演示了动态操作用户操作的属性是多么容易，同时仍然保持代码清晰简洁。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;CSS_var.css文件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre readability=&quot;11&quot;&gt;
&lt;span&gt;.orange-container &lt;/span&gt;{&lt;span&gt;
  --main-text&lt;/span&gt;:&lt;span&gt; 18px&lt;/span&gt;;
}&lt;p&gt;&lt;span&gt;
.orange-container:hover &lt;/span&gt;{&lt;span&gt;
  --main-text&lt;/span&gt;:&lt;span&gt; 22px&lt;/span&gt;;
}&lt;/p&gt;&lt;p&gt;&lt;span&gt;
.red-container:hover &lt;/span&gt;{&lt;span&gt;
  --main-text&lt;/span&gt;:&lt;span&gt; 26px&lt;/span&gt;;
}&lt;/p&gt;&lt;p&gt;&lt;span&gt;
.title &lt;/span&gt;{&lt;span&gt;
  font-size&lt;/span&gt;:&lt;span&gt; var(--title-text)&lt;/span&gt;;
}&lt;/p&gt;&lt;p&gt;&lt;span&gt;
.content &lt;/span&gt;{&lt;span&gt;
  font-size&lt;/span&gt;:&lt;span&gt; var(--main-text)&lt;/span&gt;;
}&lt;span&gt;

.container:hover &lt;/span&gt;{&lt;span&gt;
  --main-text&lt;/span&gt;:&lt;span&gt; 18px&lt;/span&gt;;
}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;base.css文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;* &lt;/span&gt;{&lt;span&gt;
  margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
  box-sizing&lt;/span&gt;:&lt;span&gt; border-box&lt;/span&gt;;
}&lt;span&gt;

html &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; #eee&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;&lt;span&gt;
  font&lt;/span&gt;:&lt;span&gt; 500 14px sans-serif&lt;/span&gt;;&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; #333&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 1.5&lt;/span&gt;;
}&lt;span&gt;

.orange-container &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; orange&lt;/span&gt;;
}&lt;span&gt;

.red-container &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
}&lt;span&gt;

.red-container,
.orange-container &lt;/span&gt;{&lt;span&gt;
  padding-top&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;&lt;span&gt;
  padding-left&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;
}&lt;span&gt;

.container &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; white&lt;/span&gt;;
}&lt;span&gt;

p &lt;/span&gt;{&lt;span&gt;
  transition&lt;/span&gt;:&lt;span&gt; 0.4s&lt;/span&gt;;
}&lt;span&gt;

.title &lt;/span&gt;{&lt;span&gt;
  font-weight&lt;/span&gt;:&lt;span&gt; bold&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;index.html文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;base.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;css_vars.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;orange-container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    Hover orange to make blue bigger.
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;red-container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
         Hover red to make blue even bigger.
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hover on the different color areas to change the size of this text and the title.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击&lt;a href=&quot;http://jsrun.net/LvgKp/edit&quot; target=&quot;_blank&quot;&gt;查看运行结果。&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;&lt;span&gt;示例5 - 具有CSS变量的主题切换器&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;CSS变量的一个好处是它的反应性。&lt;/span&gt;&lt;span&gt;一旦我们更新它，任何具有CSS变量值的属性也会更新。&lt;/span&gt;&lt;span&gt;因此，只需几行Javascript和CSS变量的智能使用，我们就可以制作一个主题切换器机制。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;具有CSS变量的主题切换器&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            
            body &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
              background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; var(--bg, #b3e5fc)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
              color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; var(--bg-text, #37474f)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
              font-family&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; sans-serif&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
              line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1.3&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
            
            .toolbar &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
              text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;toolbar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;dark&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;dark&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;calm&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;calm&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;light&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;light&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Stackoverflow Question&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;I would like to use an external javascript file in another javascript file. For example, I could store all my global variables
        in a globals.js file and then call then from the website logic logic.js. Then in the index.html, i would insert the tag.
        How do I use the globals.js inside the logic.js?
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; root &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.documentElement;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; themeBtns &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.querySelectorAll(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.toolbar &amp;gt; button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            
            themeBtns.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (btn){
              btn.addEventListener(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, handleThemeUpdate);
            });
            
            &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; handleThemeUpdate(e) {
              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (e.target.value) {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                  root.style.setProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--bg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                  root.style.setProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--bg-text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                  &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;calm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                  root.style.setProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--bg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#B3E5FC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                  root.style.setProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--bg-text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#37474F&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                  &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;light&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                  root.style.setProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--bg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                  root.style.setProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--bg-text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                  &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
              }
            }
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击&lt;a href=&quot;http://jsrun.net/wvgKp/edit&quot; target=&quot;_blank&quot;&gt;查看运行结果&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;&lt;span&gt;CSS变量的使用提示&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;像CSS中几乎所有的东西一样，变量也非常简单易用。&lt;/span&gt;&lt;span&gt;以下是一些未包含在示例中的提示，但在某些情况下仍然非常有用：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）css变量区分大小写。下面的示例是两个不同的变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;:root &lt;/span&gt;{&lt;span&gt;
   --color&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;&lt;span&gt;
   --COLOR&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）&lt;span&gt;当您使用var（）函数时，您可以使用第二个参数。&lt;/span&gt;&lt;span&gt;如果找不到自定义属性，将使用第二个参数为默认值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;width: var(--custom-width, 50%);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3）可以直接将CSS变量用于HTML：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--size: 600px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
body {
  max-width: var(--size)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4) 可以在其他CSS var中使用CSS变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--base-red-color: #f00;
--background-gradient: linear-gradient(to top, var(--base-red-color), #222);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5) &lt;span&gt;可以使用媒体查询使CSS变量成为条件。&lt;/span&gt;&lt;span&gt;例如，以下代码根据屏幕大小更改填充的值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;:root &lt;/span&gt;{&lt;span&gt;
    --padding&lt;/span&gt;:&lt;span&gt; 15px 
&lt;/span&gt;}&lt;span&gt;

@media screen and (min-width: 750px) &lt;/span&gt;{&lt;span&gt;
    --padding&lt;/span&gt;:&lt;span&gt; 30px
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6) &lt;span&gt;&lt;span&gt;不要害怕在&lt;/span&gt;&lt;/span&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/calc&quot;&gt;&lt;span&gt;&lt;span&gt;clac()&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; &lt;span&gt;&lt;span&gt;函数中&lt;/span&gt;&lt;span&gt;使用CSS变量&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--text-input-width: 5000px;
max-width: calc(var(--text-input-width) / 2);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当然，CSS变量不是灵丹妙药。&lt;/span&gt;&lt;span&gt;不会解决你在CSS领域遇到的每一个问题。&lt;/span&gt;&lt;span&gt;但是，使用它使您的代码更具可读性和可维护性。此外，它极大地改善了大型文档的易变性。&lt;/span&gt;&lt;span&gt;只需将所有常量设置在一个单独的文件中，当您只想对变量进行更改时，就不必跳过数千行代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 03 Jul 2018 06:27:00 +0000</pubDate>
<dc:creator>雨霖月寒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jofun/p/9258416.html</dc:identifier>
</item>
<item>
<title>sql server 性能调优 I/O开销分析 - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/9257685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/9257685.html</guid>
<description>&lt;h3&gt;一.概述&lt;/h3&gt;
&lt;p&gt;　　IO 内存是sql server最重要的资源，数据从磁盘加载到内存，再从内存中缓存，输出到应用端，在&lt;a href=&quot;https://www.cnblogs.com/MrHSR/p/9073411.html&quot; target=&quot;_blank&quot;&gt;sql server 内存初探&lt;/a&gt;中有介绍。在明白了sqlserver内存原理后，就能更好的分析I/O开销，从而提升数据库的整体性能。 在生产环境下数据库的sqlserver服务启动后一个星期，就可以通过dmv来分析优化。在I/O分析这块可以从物理I/O和内存I/O二方面来分析， 重点分析应在内存I/O上，可能从多个维度来分析，比如从sql server服务启动以来 历史I/O开销总量分析，自执行计划编译以来执行次数总量分析，平均I/0次数分析等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　sys.dm_exec_query_stats&lt;/span&gt;：返回缓存的查询计划，缓存计划中的每个查询语句在该视图中对应一行。当sql server工作负载过重时，该dmv也有可以统计不正确。如果sql server服务重启缓存的数据将会清掉。这个dmv包括了太多的信息像内存扫描数，内存空间数，cpu耗时等，具体查看&lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-query-stats-transact-sql?view=sql-server-2017&quot; target=&quot;_blank&quot;&gt;msdn文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　sys.dm_exec_sql_text：返回的 SQL 文本批处理，它是由指定sql_handle，其中的text列是查询的文本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 按照物理读的页面数排序 前50名&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;TOP&lt;/span&gt; &lt;span&gt;50&lt;/span&gt;&lt;span&gt;
 qs.total_physical_reads,qs.execution_count,
 qs.total_physical_reads&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;qs.execution_count &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;avg I/O&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,
 qs. creation_time,
 qs.max_elapsed_time,
 qs.min_elapsed_time,
 &lt;/span&gt;&lt;span&gt;SUBSTRING&lt;/span&gt;(qt.&lt;span&gt;text&lt;/span&gt;,qs.statement_start_offset&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
 (&lt;/span&gt;&lt;span&gt;CASE&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; qs.statement_end_offset&lt;span&gt;=-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
 &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;LEN&lt;/span&gt;(&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;),qt.&lt;span&gt;text&lt;/span&gt;))&lt;span&gt;*&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
 &lt;span&gt;ELSE&lt;/span&gt; qs.statement_end_offset &lt;span&gt;END&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;qs.statement_start_offset)&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; query_text,
 qt.dbid,dbname&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;DB_NAME&lt;/span&gt;&lt;span&gt;(qt.dbid),
 qt.objectid,
 qs.sql_handle,
 qs.plan_handle
 &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sys.dm_exec_query_stats qs
 &lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt; APPLY sys.dm_exec_sql_text(qs.sql_handle) &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; qt
 &lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; qs.total_physical_reads &lt;span&gt;DESC&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如下图所示：&lt;/p&gt;
&lt;p&gt;　　total_physical_reads:计划自编译后在执行期间所执行的物理读取总次数。&lt;/p&gt;
&lt;p&gt;　　execution_count :计划自上次编译以来所执行的次数。&lt;/p&gt;
&lt;p&gt;　　[avg I/O]:    平均读取的物理次数(页数)。&lt;/p&gt;
&lt;p&gt;　　creation_time:编译计划的时间。 &lt;/p&gt;
&lt;p&gt;        query_text：执行计划对应的sql脚本&lt;/p&gt;
&lt;p&gt;       后面来包括所在的数据库ID：dbid，数据库名称：dbname&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201807/151560-20180703111251581-776196413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;1.2 按照逻辑读的页面数排序 前50名&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;TOP&lt;/span&gt; &lt;span&gt;50&lt;/span&gt;&lt;span&gt;
 qs.total_logical_reads,
 qs.execution_count,
  qs.max_elapsed_time,
 qs.min_elapsed_time,
 qs.total_logical_reads&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;qs.execution_count &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;AVG IO&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;SUBSTRING&lt;/span&gt;(qt.&lt;span&gt;text&lt;/span&gt;,qs.statement_start_offset&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
 (&lt;/span&gt;&lt;span&gt;CASE&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; qs.statement_end_offset&lt;span&gt;=-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; 
 &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;LEN&lt;/span&gt;(&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;),qt.&lt;span&gt;text&lt;/span&gt;)) &lt;span&gt;*&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
  &lt;span&gt;ELSE&lt;/span&gt; qs.statement_end_offset &lt;span&gt;END&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;qs.statement_start_offset)&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) 
  &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;&lt;span&gt; query_text,
 qt.dbid,
 dbname&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;DB_NAME&lt;/span&gt;&lt;span&gt;(qt.dbid),
 qt.objectid,
 qs.sql_handle,
  creation_time,
 qs.plan_handle
 &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sys.dm_exec_query_stats qs
 &lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt; APPLY sys.dm_exec_sql_text(qs.sql_handle) &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; qt
 &lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; qs.total_logical_reads &lt;span&gt;DESC&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201807/151560-20180703114229791-493495159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  通过上面的逻辑内存截图来简要分析下：&lt;/p&gt;
&lt;p&gt;　　从内存扫描总量上看最多的是8311268次页扫描，自执行编译后运行t-sql脚本358次，这里的耗时是毫秒为单位包括最大耗时和最小耗时，平均I/O是23215次（页），该语句文本是一个update 修改，该表数据量大没有完全走索引（权衡后不对该语句做索引覆盖），但执行次数少，且每次执行时间是非工作时间，虽然扫描开销大，但没有影响白天客户使用。&lt;/p&gt;
&lt;p&gt;　　从执行次数是有一个43188次， 内存扫描总量排名39位。该语句虽然只有815条，但执行次数很多，如里服务器有压力可以优化，一般是该语句没有走索引。把文本拿出来如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;Count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;)  &lt;span&gt;AS&lt;/span&gt; TotalCount &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;MEM_FlagshipApply&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
 &lt;span&gt;WITH&lt;/span&gt;(NOLOCK) &lt;span&gt;Where&lt;/span&gt; ((((&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;AND&lt;/span&gt; (&lt;span&gt;[&lt;/span&gt;&lt;span&gt;IsDeleted&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;)) &lt;span&gt;AND&lt;/span&gt; (&lt;span&gt;[&lt;/span&gt;&lt;span&gt;MemType&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;AND&lt;/span&gt; (&lt;span&gt;[&lt;/span&gt;&lt;span&gt;MEMID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面两图一个是分析该语句的执行计划，sqlserver提示缺少索引,另一个是i/o统计扫描了80次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201807/151560-20180703115446894-100310738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201807/151560-20180703115532443-2069742160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 新建索引后在来看看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;NONCLUSTERED&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt;&lt;span&gt; ix_1
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;MEM_FlagshipApply&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; (&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;,&lt;span&gt;[&lt;/span&gt;&lt;span&gt;IsDeleted&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;,&lt;span&gt;[&lt;/span&gt;&lt;span&gt;MemType&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;,&lt;span&gt;[&lt;/span&gt;&lt;span&gt;MEMID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201807/151560-20180703115833567-446782737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201807/151560-20180703115847974-2088123542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 03 Jul 2018 05:46:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/9257685.html</dc:identifier>
</item>
<item>
<title>WindowsAPI每日一练(2) 使用应用程序句柄 - 奶BerBer</title>
<link>http://www.cnblogs.com/LexMoon/p/windowsapi2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/windowsapi2.html</guid>
<description>&lt;p&gt;&lt;span&gt;从上面这段程序就可以看到，_tWinMain是应用程序的入口函数，这里是使用它的宏，定义在tchar.h头文件里，为什么要这样作宏定义的呢？由于Windows的应用程序要适应UNICODE和以前单字符的应用程序，由于Windows这两个API的定义是不一样的，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UNICODE的定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; #define _tWinMain   wWinMain&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单字符的定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; #define _tWinMain   WinMain&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要经过这样的宏定义后，就可以适应不同字符宽度的函数接口了。由于我是采用UNICODE编译的，所以这里使用wWinMain函数定义，下面再把它的定义找出来，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WINAPI&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wWinMain(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    HINSTANCE hInstance,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    HINSTANCE hPrevInstance,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    LPWSTR lpCmdLine,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    int nShowCmd&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里要详细地解释一下函数wWinMain的参数，它有四个参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;hInstance&lt;/strong&gt;是当前应用程序的实例句柄，一般用来区分不同的资源使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;hPrevInstance&lt;/strong&gt;是以前Win98使用的句柄，在Win2000以后的操作系统里都是空值NULL。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;lpCmdLine&lt;/strong&gt;是命令行参数，比如你在Windows开始菜单里运行一个程序，并添加参数在后面，就会传递给应用程序，后面再详细讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;nShowCmd&lt;/strong&gt;是窗口的显示方式，比如最大化显示，最小化显示，还是正常显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Windows运行程序时，是通过运行库里的启动代码来调用wWinMain函数，它是在启动文件里如下调用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#ifdef WPRFLAG&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            mainret = wWinMain(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#else /* WPRFLAG */&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            mainret = WinMain(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#endif /* WPRFLAG */&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                       (HINSTANCE)&amp;amp;__ImageBase,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                       NULL,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                       lpszCommandLine,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                       StartupInfo.dwFlags &amp;amp; STARTF_USESHOWWINDOW&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                        ? StartupInfo.wShowWindow&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                        : SW_SHOWDEFAULT&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                      );&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是操作系统传递给应用程序的值，现在就来演示使用第一个参数hInstance。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请看下面的例子：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;99.569495694957&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;windows.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; WINAPI wWinMain(
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   HINSTANCE hInstance,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; handle to current instance&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   HINSTANCE hPrevInstance,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; handle to previous instance&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   LPSTR lpCmdLine,          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; command line&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt; nCmdShow              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; show state&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{ 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     UNREFERENCED_PARAMETER(hInstance);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     UNREFERENCED_PARAMETER(hPrevInstance); 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     UNREFERENCED_PARAMETER(lpCmdLine);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     UNREFERENCED_PARAMETER(nCmdShow);    
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用应用程序句柄&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;      &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAXSIZE_APPBUF = &lt;span&gt;256&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     TCHAR wAppTitle[MAXSIZE_APPBUF];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     LoadString(hInstance,IDS_APP_TITLE,wAppTitle,MAXSIZE_APPBUF);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得桌面句柄&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     HWND hWnd=&lt;span&gt;GetDesktopWindow();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示第一行信息
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    ::MessageBox(hWnd,&quot;Hello Window&quot;,&quot;Hello Window&quot;,MB_YESNO);&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     MessageBox(hWnd,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello Windows&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,wAppTitle,MB_YESNO);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这个例子是在前面的基础上修改的，主要添加了使用应用程序实例句柄。在第&lt;/span&gt;&lt;span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;&lt;span&gt;行里定义了一个保存应用程序标题的缓冲区，然后在第&lt;/span&gt;&lt;span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&lt;span&gt;行里调用函数&lt;strong&gt;LoadString&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;从应用程序的资源里加载字符串，它的第一个参数就使用到&lt;/span&gt;&lt;span&gt;&lt;span&gt;hInstance&lt;/span&gt;&lt;span&gt;&lt;span&gt;句柄。因此应用程序句柄是表示程序在资源上唯一的标识符。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　作用：从 资源 里加载字符串资源到&lt;a href=&quot;https://baike.baidu.com/item/CString/5015952&quot; target=&quot;_blank&quot; data-lemmaid=&quot;5015952&quot;&gt;CString&lt;/a&gt;对象里。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　函数&lt;strong&gt;LoadString&lt;/strong&gt;声明如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; WINUSERAPI &lt;span&gt;int&lt;/span&gt;&lt;span&gt; WINAPI LoadStringA(
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;__in_opt HINSTANCE hInstance,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;__in UINT uID,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;__out_ecount(cchBufferMax) LPSTR lpBuffer,
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; __in &lt;span&gt;int&lt;/span&gt; nBufferMax);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;参数1: &lt;em&gt;hInstance&lt;/em&gt;是应用程序实例句柄。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参数2: &lt;em&gt;uID&lt;/em&gt;是资源中的字符串编号。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参数3: &lt;em&gt;lpBuffer&lt;/em&gt;是接收从资源里拷贝字符串出来的缓冲区。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参数4: n&lt;em&gt;BufferMax&lt;/em&gt;是指明缓冲的大小。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;hInstance [in]:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Handle to an instance of the module whose executable file contains the string resource. To get the handle to the application itself, use GetModuleHandle(NULL).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;uID [in] :&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Specifies the integer identifier of the string to be loaded.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lpBuffer [out]:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Pointer to the buffer to receive the string.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nBufferMax [in]:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Specifies the size of the buffer, in TCHARs. This refers to bytes for ANSI versions of the function or WCHARs for Unicode versions. The string is truncated and NULL terminated if it is longer than the number of characters specified.&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;If the function succeeds, the return value is the number of TCHARs copied into the buffer, not including the terminating NULL character, or zero if the string resource does not exist. To get extended error information, call GetLastError.&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;Security Alert&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Using this function incorrectly can compromise the security of your application. Incorrect use includes specifying the wrong size in the nBufferMax parameter. For example, if lpBuffer points to a buffer szBuffer which is declared as TCHAR szBuffer[100], then sizeof(szBuffer) gives the size of the buffer in bytes, which could lead to a buffer overflow for the Unicode version of the function. Buffer overflow situations are the cause of many security problems in applications. In this case, using sizeof(szBuffer)/sizeof(TCHAR) or sizeof(szBuffer)/sizeof(szBuffer[0]) would give the proper size of the buffer.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Windows 95/98/Me: LoadStringW is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your application, as outlined in Microsoft Layer for Unicode on Windows 95/98/Me Systems.&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;


&lt;p&gt;&lt;span&gt;Minimum DLL Version: user32.dll&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Header: Declared in Winuser.h, include Windows.h&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Import library: User32.lib&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Minimum operating systems: Windows 95, Windows NT 3.1&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Unicode: Implemented as ANSI and Unicode versions.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看完上面的资料可能大家都蒙了，不知道具体是在做什么，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实这个成员函数是在调用String Table里面定义的信息，&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;para&quot;&gt;&lt;span&gt;也就是说，把String Table中&lt;a href=&quot;https://baike.baidu.com/item/Caption/10401273&quot; target=&quot;_blank&quot; data-lemmaid=&quot;10401273&quot;&gt;Caption&lt;/a&gt;里面的字符串读出来到&lt;a href=&quot;https://baike.baidu.com/item/CString/5015952&quot; target=&quot;_blank&quot; data-lemmaid=&quot;5015952&quot;&gt;CString&lt;/a&gt;对象里。&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;String Table中的ID号及其对应的字符串都是可以自己定义的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;String Table在ResourceView窗口中，也就是ClassView右边那个窗口。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;双击之后就能看到，在最下面的选项中追加新的ID信息。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果还是理解不清楚的话，请自己尝试多读msdn里的英文及例子就明白了。&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;htmledit_views&quot; readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;int LoadString(HINSTANCE hInstance,//应用程序实例句柄&lt;/span&gt;&lt;br/&gt;&lt;span&gt;UINT uID，//资源ID&lt;/span&gt;&lt;br/&gt;&lt;span&gt;LPTSTR lpBuffer,//存放字符串的缓冲区&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int nBufferMax//缓冲区大小&lt;/span&gt;&lt;br/&gt;&lt;span&gt;）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;作用：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;先在资源中加入字符串资源（不管是字符串还是窗口还是按钮），都有一个名字，比如IDC_BUTTON1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然后用这个函数把这个名字作为参数，就可以取出资源中的字符串了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：一、在resource.h中，#define FIREWALL_ALREADY_START           61452&lt;/span&gt;&lt;br/&gt;&lt;span&gt;二、在*.rc文件中：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;STRINGTABLE DISCARDABLE&lt;/span&gt;&lt;br/&gt;&lt;span&gt;BEGIN&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        FIREWALL_ALREADY_START &quot;防火墙已经启动&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;END&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、&lt;/span&gt;&lt;br/&gt;&lt;span&gt;CString str;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    str.LoadString(FIREWALL_ALREADY_START);&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Tue, 03 Jul 2018 05:22:00 +0000</pubDate>
<dc:creator>奶BerBer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/windowsapi2.html</dc:identifier>
</item>
<item>
<title>谈谈我理解的SA——Systems Architecture - kiba518</title>
<link>http://www.cnblogs.com/kiba/p/9207052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kiba/p/9207052.html</guid>
<description>
&lt;p&gt;什么是SA？&lt;/p&gt;
&lt;p&gt;SA即Systems Architecture，是系统体系结构。&lt;/p&gt;
&lt;p&gt;系统体系结构是定义系统的结构、行为和系统视图的概念模型。架构师将其系统的形式化描述或表示出来，以支持结构和行为的推理的方式组织。&lt;/p&gt;
&lt;p&gt;谈起SA，我第一印象总觉得他是一个概念，一个混淆的概念，因为他被提出时就是模糊的。然而随时不断的接触，它其实是会越来越清晰的出现在我们眼前，他是那么的有条理，那么的明确，甚至连动态变化都可以被用文字语言描述。&lt;/p&gt;
&lt;p&gt;我看过一些架构相关的书籍，然而大部分书中描述的内容都是一种作者最熟悉，或者自己创新的结构。当然，它们很有用，但某一种结构或几种组合都不能代表SA，它们只是SA繁衍出来的具体行为的指导思想或结构模板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/243596/201807/243596-20180703084533746-1169543782.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ABSD&lt;/p&gt;
&lt;p&gt;ABSD(architecture-based softwar design)基于体系结构的软件设计。ABSD方法是一个【自顶向下】，【递归细化】的方法。ABSD把整个基于体系结构的软件过程划分为体系结构需求、设计、文档化、复审、实现、演化6个子过程。&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt;什么意思呢？就是在做架构时，有一个正常的顺序：&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt;【需求=&amp;gt;设计=&amp;gt;文档化=&amp;gt;复审=&amp;gt;实现=&amp;gt;演化】&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt;这是一个自顶向下的顺序，但节点之间和节点内部还存在递归，并且每个节点都有自己独特的细化方案。&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt;有兴趣的同学可以百度了解一下ABSD。或者买些相关书籍。&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt;为什么推荐ABSD呢，因为我觉得大多数系统结构，都是基于ABSD扩展的。学会ABSD以后，在阅读其他相关书籍时，会事半功倍。&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt; &lt;/p&gt;
&lt;p&gt;我心中的SA&lt;/p&gt;
&lt;p&gt;SA并不是只有思想，在实践的过程中，我们还要设计或者选择框架，在ABSD中，SA被被分为三个基础元素，分解、风格、模板。然而我觉得风格和模板可以合并，改称为框架，相信很多架构师都有自己的框架，而且可能有很多个框架。&lt;/p&gt;
&lt;p&gt;SA实践时，有很多种方法，步骤也可以不同，书上的概念总是希望将很多内容归纳或归类为一；然而现实中，我们在实现SA时，往往是设计与框架同时进行。所以我觉得实战中，大部分架构师的设计顺序应该是这样的。&lt;/p&gt;
&lt;p&gt;一，分解子系统和功能模块；&lt;/p&gt;
&lt;p&gt;二，设计框架模型；&lt;/p&gt;
&lt;p&gt;三，分析功能模块；&lt;/p&gt;
&lt;p&gt;四，设计框架详细。&lt;/p&gt;
&lt;p&gt;然而现实中不会有这么清晰的边界，真实的情况可能是，这四步也相互穿插，同步进行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/243596/201807/243596-20180703085824287-526489964.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为什么SA的解释那么多？&lt;/p&gt;
&lt;p&gt;这是个很有趣的问题，因为很多人都在用学习，创新SA，他们在尝试为它定义的同时，还尝试将软件设计模式，软件开发方法，软件管理方法，软件风格，软件模板等等概念与SA进行分离，并逐一明确其概念和实现。&lt;/p&gt;
&lt;p&gt;虽然细节很重要，没有细节的SA都是空谈，但如此多的书籍和定义，导致的结果就是，很多人在学习时，需要面对茫茫多的概念，找不到总纲，然后混乱的一沓糊涂。&lt;/p&gt;
&lt;p&gt;我突然想起了王阳明先生的“知行合一”；知行本是一，却被拆分为二，圣贤教人知行，却被后人传为知与行。&lt;/p&gt;
&lt;p&gt;我觉得软件概念目前也存在着这样的情况。例如XP极限编程，如此详细的构建了开发细节，明明是SA的一种，可却被定义为软件开发方法，看起来好像XP和ABSD和ADMEMS是不同的东西了。&lt;/p&gt;
&lt;p&gt;为什么呢，因为很多SA的书籍在编写时，有些书想重点突出设计思想，因为他觉得那是他的亮点，而人员分配，设计模式，并未提及。但依据其思想其实是可以推理出开发测试分工的。再比如，XP重点突出其特殊的人员配置和分工模式，但其分布式模块，独立设计的设计思想也是跃然纸上。&lt;/p&gt;
&lt;p&gt;【PS：但如果你都能依据他的书中的部分内容，推理出整个SA细节，那我觉得你也不需要看他的书了。】&lt;/p&gt;
&lt;p&gt;回到现实中，在茫茫的网络世界里，我们只是因为其突出的侧重点不同，而强行将其分类定义，只是增加后学的学习难度和成本，而已。&lt;/p&gt;

&lt;p&gt;后记&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构重点关注问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理解系统要解决的问题&lt;/p&gt;
&lt;p&gt;认识系统特性与要解决的问题间的关系&lt;/p&gt;
&lt;p&gt;识别系统的核心行为&lt;/p&gt;
&lt;p&gt;整理系统的非功能性需求&lt;/p&gt;
&lt;p&gt;确定架构需求&lt;/p&gt;
&lt;p&gt;管理需求&lt;/p&gt;
&lt;p&gt;规划系统的高层组织&lt;/p&gt;
&lt;p&gt;确定架构机制&lt;/p&gt;
&lt;p&gt;分析用例场景&lt;/p&gt;
&lt;p&gt;演进系统的高层组织并形成组件模型&lt;/p&gt;
&lt;p&gt;规划系统的运行时架构和部署模型&lt;/p&gt;
&lt;p&gt;规划系统的实现模型&lt;/p&gt;
&lt;p&gt;编写核心代码&lt;/p&gt;
&lt;p&gt;验证架构设计&lt;/p&gt;
&lt;p&gt;整理架构文档&lt;/p&gt;
</description>
<pubDate>Tue, 03 Jul 2018 05:05:00 +0000</pubDate>
<dc:creator>kiba518</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kiba/p/9207052.html</dc:identifier>
</item>
<item>
<title>PHP之高性能I/O框架：Libevent（二） - 飞鸿影~</title>
<link>http://www.cnblogs.com/52fhy/p/9258040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52fhy/p/9258040.html</guid>
<description>&lt;h2 id=&quot;event扩展&quot;&gt;Event扩展&lt;/h2&gt;
&lt;p&gt;Event可以认为是替代libevent最好的扩展，因为libevent已经很久不更新了，而Event一直在更新，而且Event支持更多特性，使用起来也比libevent简单。&lt;/p&gt;
&lt;p&gt;Event地址: http://pecl.php.net/package/event&lt;br/&gt;Event文档: http://docs.php.net/event&lt;/p&gt;
&lt;p&gt;和libevent一样，系统需要先安装 Libevent 库，因为都是基于 Libevent 库开发的：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;yum install libevent-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后安装PHP扩展。&lt;/p&gt;
&lt;p&gt;PHP7安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pecl install event&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Event扩展不支持PHP5。&lt;/p&gt;
&lt;p&gt;注：后面的代码示例均使用的&lt;code&gt;php7.1&lt;/code&gt; + &lt;code&gt;event&lt;/code&gt;环境。&lt;/p&gt;
&lt;h3 id=&quot;基本使用&quot;&gt;基本使用&lt;/h3&gt;
&lt;p&gt;我们把&lt;code&gt;libevent_tcp_server.php&lt;/code&gt;的例子改为Event实现的：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;event_tcp_server.php&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php 
/**
 * Created by PhpStorm.
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/6/23
 */
 
$receive = [];
$master = [];
$buffers = [];

$socket = stream_socket_server (&quot;tcp://0.0.0.0:9201&quot;, $errno, $errstr);
if (false === $socket ) {
    echo &quot;$errstr($errno)\n&quot;;
    exit();
}
if (!$socket) die($errstr.&quot;--&quot;.$errno);
//stream_set_blocking($socket,0); //可选
$id = (int)$socket;
$master[$id] = $socket;

echo &quot;waiting client...\n&quot;;


//accept事件回调函数，参数分别是$fd, $events, $arg
function ev_accept($socket, $flag, $base){
    global $receive;
    global $master;
    global $buffers;

    $connection = stream_socket_accept($socket);
    stream_set_blocking($connection, 0);//必须
    $id = (int)$connection;

    echo &quot;new Client $id\n&quot;;

    $event = new Event($base, $connection, Event::READ | Event::PERSIST, 'ev_read', $id); 
    $event-&amp;gt;add();

    $master[$id] = $connection; //根据业务可选
    $receive[$id] = ''; //根据业务可选
    $buffers[$id] = $event; //根据业务可选
}

//read事件回调函数
function ev_read($buffer, $flag, $id)
{
    
    global $receive;
    global $master;
    global $buffers;

    //该方法里的$buffer和$master[$id]指向相同的内容
    // var_dump(func_get_args(), $master[$id] );

    //循环读取并解析客户端消息
    while( 1 ) {
        $read = @fread($buffer, 1024);

        //客户端异常断开
        if($read === '' || $read === false){
            break;
        }

        $pos = strpos($read, &quot;\n&quot;);
        if($pos === false)
        {
            $receive[$id] .= $read;
            // echo &quot;received:&quot;.$read.&quot;;not all package,continue recdiveing\n&quot;;
        }else{
            $receive[$id] .= trim(substr ($read,0,$pos+1));
            $read = substr($read,$pos+1);
            
            switch ( $receive[$id] ){
                case &quot;quit&quot;:
                    echo &quot;client close conn\n&quot;;
                    
                    //关闭客户端连接
                    unset($master[$id]);//断开客户端连接
                    unset($buffers[$id]);//删除事件
                    break;
                default:
                    // echo &quot;all package:\n&quot;;
                    echo $receive[$id].&quot;\n&quot;;
                    break;
            }
            $receive[$id]='';
        }
    }
}

//创建全局event base
$base = new EventBase();
//创建并设置 event：其中$events设置为READ | PERSIST ；回调事件为ev_accept，参数 $base
//PERSIST可以让注册的事件在执行完后不被删除,直到调用Event::del()删除.
$event = new Event($base, $socket, Event::READ | Event::PERSIST, 'ev_accept', $base); 
$event-&amp;gt;add();
echo  &quot;start run...\n&quot;;

//进入事件循环
$base-&amp;gt;loop();

//下面这句不会被执行
echo &quot;This code will not be executed.\n&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现做的改动非常小，而且代码更简洁了。运行脚本后，我们使用telnet测试，效果一模一样。&lt;/p&gt;
&lt;h3 id=&quot;使用buffer&quot;&gt;使用Buffer&lt;/h3&gt;
&lt;p&gt;直接看例子吧，还是基于上面的例子改的，注释里写得很清楚了：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;event_buffer_tcp_server.php&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php 
/**
 * Created by PhpStorm.
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/6/23
 */

$receive = [];
$master = [];
$buffers = [];

$socket = stream_socket_server (&quot;tcp://0.0.0.0:9201&quot;, $errno, $errstr);
if (false === $socket ) {
    echo &quot;$errstr($errno)\n&quot;;
    exit();
}
if (!$socket) die($errstr.&quot;--&quot;.$errno);
//stream_set_blocking($socket,0);//可选
$id = (int)$socket;
$master[$id] = $socket;

echo &quot;waiting client...\n&quot;;


//accept事件回调函数，参数分别是$fd, $events, $arg
function ev_accept($socket, $flag, $base){
    global $receive;
    global $master;
    global $buffers;

    $connection = stream_socket_accept($socket);
    //stream_set_blocking($connection, 0);//可选
    $id = (int)$connection;

    echo &quot;new Client $id\n&quot;;

    //新建EventBuffer 事件
    $event = new EventBufferEvent($base, $connection, 0, 'ev_read', 'ev_write', 'ev_status', $id); 
    $event-&amp;gt;setTimeouts(30, 30); //read and write timeout 
    $event-&amp;gt;setWatermark ( Event::READ, 0, 0xffffff ); //Adjusts read and/or write watermarks
    $event-&amp;gt;setPriority(10);
    $event-&amp;gt;enable(Event::READ | Event::PERSIST);

    $master[$id] = $connection; //如果去掉该行，客户端直接被断开
    $receive[$id] = ''; //如果去掉该行，服务端无法正常收到消息
    $buffers[$id] = $event; //如果去掉该行，客户端强制断开再连接，服务端无法正常收到消息
}

//read事件回调函数，参数分别是EventBufferEvent，arg 
function ev_read($buffer, $id)
{
    
    global $receive;
    global $master;
    global $buffers;

    //该方法里的$buffer和$buffers[$id]指向相同的内容
    // var_dump(func_get_args(), $buffers[$id], $master[$id]);

    //循环读取并解析客户端消息
    while( 1 ) {
        $read = $buffer-&amp;gt;read(65535);
        // var_dump($read);

        //客户端异常断开；这里可能返回NULL
        if($read === '' || $read === false || $read === NULL){
            break;
        }

        $pos = strpos($read, &quot;\n&quot;);
        if($pos === false)
        {
            $receive[$id] .= $read;
            echo &quot;received:&quot;.$read.&quot;;not all package,continue recdiveing\n&quot;;
        }else{
            $receive[$id] .= trim(substr ($read,0,$pos+1));
            $read = substr($read,$pos+1);
            
            switch ( $receive[$id] ){
                case &quot;quit&quot;:
                    echo &quot;client close conn\n&quot;;
                    
                    //关闭客户端连接
                    unset($master[$id]);//断开客户端连接
                    unset($buffers[$id]);//删除事件
                    break;
                default:
                    // echo &quot;all package:\n&quot;;
                    echo $receive[$id].&quot;\n&quot;;
                    break;
            }
            $receive[$id]='';
        }
    }
}

function ev_write($buffer, $id)
{
    echo &quot;$id -- &quot; .&quot;\n&quot;;
}

function ev_status($buffer, $events, $id)
{
    echo &quot;ev_status - &quot;.$events.&quot;\n&quot;;
}

//创建全局event base
$base = new EventBase();
//创建并设置 event：其中$events设置为READ | PERSIST ；回调事件为ev_accept，参数 $base
//PERSIST可以让注册的事件在执行完后不被删除,直到调用Event::del()删除.
$event = new Event($base, $socket, Event::READ | Event::PERSIST, 'ev_accept', $base); 
$event-&amp;gt;add();
echo  &quot;start run...\n&quot;;

//进入事件循环
$base-&amp;gt;loop();

//下面这句不会被执行
echo &quot;This code will not be executed.\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定时器timer&quot;&gt;定时器(Timer)&lt;/h3&gt;
&lt;p&gt;直接看示例：&lt;br/&gt;&lt;code&gt;event_timer.php&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
/**
 * Created by PhpStorm.
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/6/23
 */
 
$base  = new  EventBase ();
$n  =  2 ; //sec

//初始化定时器
$e  =  Event :: timer ( $base , function( $arg ) use (&amp;amp; $e ) {
    echo  &quot; $arg  seconds elapsed\n&quot; ;
     $e -&amp;gt; delTimer ();
},  $n );

//添加定时器
$e -&amp;gt; addTimer ( $n ); //sec

$base -&amp;gt; loop ();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ php event_timer.php 
 2  seconds elapsed&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和&lt;code&gt;libevent&lt;/code&gt;扩展一样，&lt;code&gt;Event::timer&lt;/code&gt;也是对Event的封装：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
/**
 * Created by PhpStorm.
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/6/23
 */
 
$base  = new  EventBase ();
$n  =  2 ; //sec

//初始化定时器
$event = new Event($base, null, Event::TIMEOUT, 'ev_timer',  $n );
$event-&amp;gt;add($n);//sec

function ev_timer($fd, $what, $arg){
    echo  &quot; $arg  seconds elapsed\n&quot; ;
    global $event;
    $event-&amp;gt;del();
}

$base-&amp;gt;loop();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Event提供的定时器精度是秒。&lt;/p&gt;
&lt;h3 id=&quot;信号signal&quot;&gt;信号(Signal)&lt;/h3&gt;
&lt;p&gt;Event 扩展提供了信号（Signal）操作的函数。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
/**
 * Created by PhpStorm.
 * User: 公众号: 飞鸿影的博客(fhyblog)
 * Date: 2018/6/23
 */
 
$base  = new  EventBase ();

//初始化信号事件
$e  =  Event :: signal ( $base , SIGUSR1, function( $signum , $arg ) use (&amp;amp; $e ) {
    echo  &quot; Caught signal $signum\n&quot; ;
    $e-&amp;gt;delSignal(); //移除信号
},  '');

//安装信号
$e -&amp;gt; addSignal (); //sec

//发送信号
posix_kill(posix_getpid (),  SIGUSR1);

$base -&amp;gt; loop ();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比&lt;code&gt;pcntl_signal&lt;/code&gt;，&lt;code&gt;Event :: signal&lt;/code&gt; 高效很多。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;Libevent 非常强大，Event实现了其很多的接口供PHP调用，我这里仅是使用了常用的几个特性。由于Event能参考的资料实在是有限，这章写起来也相对难一些，例子里还是留了一些待再次理解。&lt;/p&gt;
&lt;p&gt;（未完待续）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;推荐&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/ls/1650000011070033?r=bPmCDE&quot;&gt;&lt;strong&gt;Redis 系列讲座合集&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容概要：Redis 最为目前炙手可热的 Key-Value 数据库，常用做缓存、Session共享中间件，分布式锁等等。&lt;br/&gt;本系列课程包括:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/663847/201807/663847-20180703130814555-1017732225.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;讲师是CSDN 博客专家，多年 Redis 使用经验。感兴趣的朋友可以&lt;a href=&quot;https://segmentfault.com/ls/1650000011070033?r=bPmCDE&quot;&gt;点击&lt;/a&gt;试看！&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Tue, 03 Jul 2018 05:01:00 +0000</pubDate>
<dc:creator>飞鸿影~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52fhy/p/9258040.html</dc:identifier>
</item>
<item>
<title>杭州码农图鉴：与某大厂前端从业者的一次推心置腹 - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/9257978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/9257978.html</guid>
<description>&lt;p&gt;首先我与这位来自杭州XX旅游（应大佬要求，城市和公司皆化名，同在南方城市，暂以杭州代替）的前端大佬结缘，是因为我的上一篇文章“聊聊北京大部分前端从业者所面临的困境”。&lt;/p&gt;

&lt;p&gt;图鉴众生相，各位看官随我来~&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;刚入行时的光景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;先来介绍下这位大厂前端er的大概情况吧：&lt;/p&gt;

&lt;p&gt;非计算机专业，2016年毕业，本专业是机械，C++必修，而且C++成绩很好，所以准备做程序员。&lt;/p&gt;

&lt;p&gt;被培训班宣传前端比较吃香，然后就准备先自己自学一段时间，之后再准备报培训的。&lt;/p&gt;

&lt;p&gt;那时候，马上要毕业了，都说找工作压力大，所以准备去培训班之前自学特别认真。&lt;/p&gt;

&lt;p&gt;到了培训班有两天的试听，是个小培训班，感觉同学们水平都很低，完全没我那种认真劲，所以拒绝培训，后来自学的。&lt;/p&gt;

&lt;p&gt;之后某某旅游到我们学校校招，就进去了，总体来说工作前期很顺，刚毕业7K。&lt;/p&gt;

&lt;p&gt;目前从事前端3年，也是90后，一年多没跳槽了。他跟我攀谈起来，我和那个人很像啊，只是我不在北京，也是差不多14K，学的时候也是抱着高程三，JQ+bootstrap，vue和react底层原理大概清楚，但api并不熟。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;对培训班的偏见&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;很多时候，跟新人讲算法还是有点小自豪，但是vue的api还不如刚培训出来的新人厉害。&lt;/p&gt;

&lt;p&gt;公司招人，我去做面试官，有个刚毕业培训出来的应聘者。由于我是自学的，所以对培训出来的同学有偏见，觉得培训出来的都是渣渣。&lt;/p&gt;

&lt;p&gt;但实际上问他问题的时候才发现，他对vue的api非常的熟悉，很多时候api用的恰到好处，虽然说有时候出了bug他不懂底层原理解决起来比较难，需要求助我，但是真的下需求给我们俩，他总比我做的还要快。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;误打误撞的技术栈&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;技术栈的话，一开始自学是硬啃高程三，校招题目基本上都是dom题，js题，算法题，当时在学校刷题用的牛客（不是给他打广告），刷了题库，校招做题一把手。&lt;/p&gt;

&lt;p&gt;到了那家公司之后，刚好react问世，老大说准备找几个人开个试验田试项目，我当时自告奋勇要去。虽然被老大拒绝了，但我不知天高地厚的晚上私信老大，请求能过去帮忙。老大说，看到我这种追求技术的态度还是蛮开心的（当然现在这种态度已经被我丢掉了）&lt;/p&gt;

&lt;p&gt;结果就是我加入了react试验田项目。&lt;/p&gt;

&lt;p&gt;跳槽的时候，简历上写了参与某某公司的开源组件库XX开发，有一定的运气成分，16年毕业就没写jq，直接用了react和vue，再加上算是大公司镀金了，所以跳槽基本薪资翻倍了。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;大佬也有困惑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;前面都很好啊，关键跳槽之后，每天都忙相似的内容，基本上就是一年的经验复用N年，和新人比，基本上没什么优势。&lt;/p&gt;

&lt;p&gt;因为和新人比起来，新人更努力，更熟练，更愿意加班。而我唯独在他们出现bug的时候，可以站出来指点一下，装得自己有点逼格。&lt;/p&gt;

&lt;p&gt;项目也是尽量能不自己做，我就不自己做了。但是这样一直混下去，不知道会怎样。&lt;/p&gt;

&lt;p&gt;感觉时间长了，慢慢地就会被新人代替了吧。想转管理层，但是不知道如何做起。&lt;/p&gt;

&lt;p&gt;包括年后，我其实还是偷偷地投简历了，但是很多公司看到我的期望薪资比较高，就直接不要了。&lt;/p&gt;

&lt;p&gt;我觉得是不是杭州14K就封顶了？但是周围的产品经理都已经20K了。&lt;/p&gt;

&lt;p&gt;跳槽的话，简历我只投了一家，就之前的大公司，HR本来还和我聊聊的，但是我16年离开的时候是7K，18年回去要17K了，结果HR果断不要我了。&lt;/p&gt;

&lt;p&gt;17年我在现在这家公司表现很好，所以才给加了1K。今年我自己都明显感觉到，不如去年那么努力了，为公司做出的贡献也明显不如去年了，我觉得今年不可能给我涨工资了，所以准备离开。&lt;/p&gt;

&lt;p&gt;或者我想着，做一份副业。&lt;/p&gt;

&lt;p&gt;以前我很勤奋，因为我看到了勤奋带来的好处，大学的勤奋让我毕业找到工作，工作的勤奋让我跳槽薪资翻倍。&lt;/p&gt;

&lt;p&gt;但现在呢，感觉很多东西，公司没用到，我就没去学了，或者只是随便看看。因为我不知道，就算我学习了努力了，对我带来的好处在哪儿，比如美团出了mpvue，就算我去看了，也不会给我带来实质性的好处。&lt;/p&gt;

&lt;p&gt;所以我觉得，我为什么要去学，有了这样的心理之后，然后就不那么热爱技术了。&lt;/p&gt;

&lt;p&gt;时间久了，我觉得好像我整个人都变了，和以前完全不一样了。以前的时候，有个新技术出来，我立马很兴奋的去追逐。而现在，我觉得，除非能给我带来收益，或者用得到，才去看。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;有什么想告诉后来者的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;希望他们不要像我这样，要保持热爱学习的心，都说了编程是一个终身学习的过程，特别是前端，变化非常快。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何部署公司级别的项目&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;说说项目吧，像我们公司大型的企业级别的项目，都是前后端分离，联调接口的话，似乎问题不是很大，因为是分别部署的，前后端各有一台服务器。&lt;/p&gt;

&lt;p&gt;而且越是大厂越是流水线，部署用的是“天梯”，先提交到git，然后到天梯点击部署，加上备注，老大那边点击允许部署，就部署上线了。具体内部实现，就是因为是大公司，所以才不知道。&lt;/p&gt;

&lt;p&gt;前端提交到git，然后在天梯里新建项目，项目填上git地址。部署的时候，天梯会自动拉取git里面的内容，并运行npm install &amp;amp; npm run build  ，就自动部署上了。如果是小公司的话，建议用pm2。&lt;/p&gt;

&lt;p&gt;像大公司的项目版本控制用的是gitlab，而不是码云。gitlab更像是游戏私服，服务器是我们自己的，码云会把代码发布到第三方托管平台。&lt;/p&gt;

&lt;p&gt;说到gitlab和pm2，忽然想起来，gitlab是支持自动化部署的。设置master分支只允许管理员操作，然后开发者在dev分支上开发，开发结束后想要合并，就通知管理员。管理员合并到master之后，项目就自动发布上线了。想要回滚的话，也是十分方便。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;去大厂镀金的弊端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;想去大厂镀金的童鞋，我想告诉你们的是：&lt;/p&gt;

&lt;p&gt;镀金有个缺点，就是出来了想再回去就有点难了，比如你去百度镀了金，然后跳槽了，后来你又想回去，有点难。&lt;/p&gt;

&lt;p&gt;像我就是从大厂出来的，大厂人事是互通的，我出来之后，想再回去，投这家大厂另一个部门的简历，人事从资料里就查到我了，知道我去年的薪资，还有当时的离职原因。然后人事可能会因为这个不要你，所以离职原因也要慎重写，不要太实诚。&lt;/p&gt;

&lt;p&gt;实话实说，我当时的离职原因，写的是“薪资太低”。&lt;/p&gt;

&lt;p&gt;所以那个人事不要我。&lt;/p&gt;

&lt;p&gt;当时写的时候，没想到自己还会回去，也没想他们还会查我当时的离职资料。 我从某某旅游离开，又投了某某旅游另一个部门的简历。我们当时一个楼层，前端就上百个，还以为他们不会在意。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;大佬的内心独白&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;说到这里，大佬嘱咐我不要提这家公司，杭州圈子很小，大厂就那么几个。&lt;/p&gt;

&lt;p&gt;除了这家，好像就剩下个某某蜗牛了。这家游戏公司做代理的，旗下有九阴真经、功夫熊猫、黑色沙漠等。&lt;/p&gt;

&lt;p&gt;要不是来杭州发展，我也不知道蜗牛。&lt;/p&gt;

&lt;p&gt;后来我问他，你有想过给某某蜗牛投简历吗？&lt;/p&gt;

&lt;p&gt;他告诉我，没想过，据说比较累。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;令人羡慕的大厂福利&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;大厂的活动蛮多的，环境有点像大学，而且里面都是年轻人，基本见不到多少年龄40+的，如果有，那肯定是管理级别了。&lt;/p&gt;

&lt;p&gt;而传统公司，三四十的就很多。&lt;/p&gt;

&lt;p&gt;大厂有运动会，团建，有时候还会请cosplay程序员鼓励师，有免费零食吃，加班都有加班费或者调休池，小公司很有可能没有。&lt;/p&gt;

&lt;p&gt;周末加班双倍工资，节假日三倍工资，可能小公司也不遵循。&lt;/p&gt;

&lt;p&gt;调休池？我还是第一次听说这个名词，孤陋寡闻了。&lt;/p&gt;

&lt;p&gt;他跟我解释道，就是今天你加班两小时，就攒两小时“调休池”，之后你有事，可以请假两小时，就扣调休池里的时间，比如我买了游乐园的票陪女朋友，就可以加三天班，攒够8小时，调休。（8小时调休一整天）&lt;/p&gt;

&lt;p&gt;当然，前提是你要提前跟老大说，咱们项目不着急的话，我就调休了。小公司的话是没有的，比如我现在的这家公司就没有，加班就是白加。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;校招童鞋的部分现状&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我还跟他说，大厂码农跳槽的话，要不是跳到其他大厂，要不就是去创业公司当cto或者技术负责人。&lt;/p&gt;

&lt;p&gt;他告诉我，其实并不是都是这样，像我这种，刚毕业就去大厂的，基本上就是流水线工人一样。毕竟是校招进去的，没有任何工作经验，大多都是像流水线工人，就负责一小块内容。所以很难跳槽出去就是负责人。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;大厂面试的套路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我继续问他，假如我去面试，向面试官展示分布式部署的项目，会加分吗？&lt;/p&gt;

&lt;p&gt;他说，面试大厂的话，不太会加分，因为前端完全不需要了解分布式，而且就算你是后端，可能都不会加分，因为大公司的分布式都是做好的，就像部署，都是自动化的，分布式也是，有专门的运维负责这块。&lt;/p&gt;

&lt;p&gt;如果我是大厂的负责人，招应届生，我就只会问工作中用得到的，因为基础设施已经相当好了，基本上用不着新人去做，当然了解一下也是可以的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;你理解的前端架构师是什么样的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;对于这个问题，他有自己的见解。&lt;/p&gt;

&lt;p&gt;他说，简单的项目肯定是没什么架构之说的，vue-cli一键就搭建好了。普通公司的，所谓的架构，其实也没什么好架的，就多个项目怎么划分，应该用哪种技术。&lt;/p&gt;

&lt;p&gt;比如要兼容IE，比如有的部门就要求不能用#应该怎样，比如有的后台登录要有权限配置。&lt;/p&gt;

&lt;p&gt;很多公共组件的抽离，可能是需要前端架构师来做的。感觉架构师就技术选型，搭架子，抽组件。而且在小公司，很多时候，你说自己是架构师，别人并不服，因为这些事情别人其实也做得来。&lt;/p&gt;

&lt;p&gt;要多去理解业务，才能把组件抽的更好，而且对业务理解的深刻的人，才会更被领导信任。想做架构师，就不能单纯的画界面写逻辑。&lt;/p&gt;

&lt;p&gt;而且有一点心塞的是，老大很多时候，并不是很信任我们这样的90后，特别是传统企业。如果我说我要做架构师，即使我比别人付出了更多努力，技术水平很高，但也不会被老大重用。因为老大觉得，你没结婚，年轻气盛，思考问题不全面，而且又不稳定，公司的前端框架交给你，你走了怎么办？&lt;/p&gt;

&lt;p&gt;他们印象里，就是没结婚的人，没责任感，不稳定。结了婚的，甚至有了小孩的，压力大，有责任感背负在身，对于公司的价值观端正，就算技术能力稍微一点，影响也不是很大。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在最后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;其实，每个刚入行的前端从业者都有一颗进入大厂的心，听了大佬的一席话，大概你们也能看出如今的现状来，大厂，如围城，城内的人想出去，城外的人想进来。&lt;/p&gt;

&lt;p&gt;自己每走一步，都要想清楚自己要的是什么，选择好哪条路之后，便要坚持走下去，世上没有后悔药。技术人还是要不忘初心，沉淀技术，方能始终。&lt;/p&gt;

&lt;p&gt;感谢这位来自XX旅游的前端大佬的分享，让我们看到了城内的世界。&lt;/p&gt;

&lt;p&gt;---&lt;/p&gt;

&lt;p&gt;更多文章我会第一时间更新在公众号&amp;lt;闰土大叔&amp;gt;里面，欢迎关注~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201806/701424-20180620113303334-885593351.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Jul 2018 04:27:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/9257978.html</dc:identifier>
</item>
<item>
<title>面试：用 Java 实现一个 Singleton 模式 - 南尘</title>
<link>http://www.cnblogs.com/liushilin/p/9257953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liushilin/p/9257953.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;面试：用 Java 实现一个 Singleton 模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;面试系列更新后，终于迎来了我们的第一期，我们也将贴近《剑指 Offer》的题目给大家带来 Java 的讲解，个人还是非常推荐《剑指 Offer》作为面试必刷的书籍的，这不，再一次把这本书分享给大家，PDF 版本在公众号后台回复「剑指Offer」即可获取。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;我们在面试中总会遇到不少设计模式的问题，而设计模式中的 Singleton 模式又是我们最容易出现的考题，大多数人可能在此前已经有充分的了解，但不少人仅仅是停留在比较浅显的层次，今天我们就结合《剑指 Offer》给大家带来更加深入的讲解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;题目：请用 Java 手写一个单例模式代码，希望尽可能考虑地全面。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;不论是 Java 还是 Android 中单例模式肯定是我们经常用到的，所以这道题可能大多数人会第一时间想到饿汉式代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;class &lt;span class=&quot;cm-def&quot;&gt;Singleton {&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-keyword&quot;&gt;final &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;INSTANCE &lt;span class=&quot;cm-operator&quot;&gt;= &lt;span class=&quot;cm-keyword&quot;&gt;new &lt;span class=&quot;cm-variable&quot;&gt;Singleton();&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-variable&quot;&gt;Singleton() {&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;getInstance() {&lt;br/&gt;&lt;span&gt;        &lt;span class=&quot;cm-keyword&quot;&gt;return &lt;span class=&quot;cm-variable&quot;&gt;INSTANCE;&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;上面是典型的饿汉式写法，因为单例的实例被声明成 static 和 final 变量了，所以在第一次加载类到内存中时就会初始化，所以也不会存在多线程问题，但它的缺点非常显而易见，也经常为人诟病。这明显不是一种懒加载模式（lazy initialization），就因为它是 static 和 final 的，所以类会在加载后就被初始化，导致我们代码的健壮性很差，假如后面更改需求，希望在 &lt;span&gt;&lt;code&gt;getInstance()&lt;/code&gt; &lt;span&gt;之前调用某个方法给它设置参数，这个就明显不符合使用场景了，面试官极有可能在看到这个代码后觉得你就是一个只知道完成功能没有大局观的人。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当然还会有不少人直接采用我们的懒汉式代码，这样就解决了延展性和懒加载了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;class &lt;span class=&quot;cm-def&quot;&gt;Singleton {&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;instance;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-variable&quot;&gt;Singleton() {&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;getInstance() {&lt;br/&gt;&lt;span&gt;        &lt;span class=&quot;cm-keyword&quot;&gt;if (&lt;span class=&quot;cm-variable&quot;&gt;instance &lt;span class=&quot;cm-operator&quot;&gt;== &lt;span class=&quot;cm-atom&quot;&gt;null) {&lt;br/&gt;&lt;span&gt;            &lt;span class=&quot;cm-variable&quot;&gt;instance &lt;span class=&quot;cm-operator&quot;&gt;= &lt;span class=&quot;cm-keyword&quot;&gt;new &lt;span class=&quot;cm-variable&quot;&gt;Singleton();&lt;br/&gt;&lt;span&gt;        }&lt;br/&gt;&lt;span&gt;        &lt;span class=&quot;cm-keyword&quot;&gt;return &lt;span class=&quot;cm-variable&quot;&gt;instance;&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;上述代码可能是大多数面试者的解法，包括教科书上也是这么教我们的，但这段代码却存在了一个致命的问题，那就是当多个线程并行调用 &lt;span&gt;&lt;code&gt;getInstance()&lt;/code&gt; &lt;span&gt;的时候，就会创建多个实例，这显然违背了面试官的意思。正好面试官加了一句希望尽可能考虑地全面，所以这样的代码肯定不能虏获面试官的芳心。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;既然要线程安全，那我直接加锁呗。于是并有了下面的代码。他们也是懒汉式的，只不过线程安全了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;class &lt;span class=&quot;cm-def&quot;&gt;Singleton {&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;instance;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-variable&quot;&gt;Singleton() {&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-keyword&quot;&gt;synchronized &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;getInstance() {&lt;br/&gt;&lt;span&gt;        &lt;span class=&quot;cm-keyword&quot;&gt;if (&lt;span class=&quot;cm-variable&quot;&gt;instance &lt;span class=&quot;cm-operator&quot;&gt;== &lt;span class=&quot;cm-atom&quot;&gt;null) {&lt;br/&gt;&lt;span&gt;            &lt;span class=&quot;cm-variable&quot;&gt;instance &lt;span class=&quot;cm-operator&quot;&gt;= &lt;span class=&quot;cm-keyword&quot;&gt;new &lt;span class=&quot;cm-variable&quot;&gt;Singleton();&lt;br/&gt;&lt;span&gt;        }&lt;br/&gt;&lt;span&gt;        &lt;span class=&quot;cm-keyword&quot;&gt;return &lt;span class=&quot;cm-variable&quot;&gt;instance;&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;这样的解法实现了线程安全，但它并不是那么高效，因为在任何时候只能有一个线程去调用 &lt;span&gt;&lt;code&gt;getInstance()&lt;/code&gt; &lt;span&gt;方法，但实际上加锁操作也是耗时的，我们应该尽量地避免使用它。所以自然就引出了双重检验锁。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;class &lt;span class=&quot;cm-def&quot;&gt;Singleton {&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;instance;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-variable&quot;&gt;Singleton() {&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;getInstance() {&lt;br/&gt;&lt;span&gt;        &lt;span class=&quot;cm-keyword&quot;&gt;if (&lt;span class=&quot;cm-variable&quot;&gt;instance &lt;span class=&quot;cm-operator&quot;&gt;== &lt;span class=&quot;cm-atom&quot;&gt;null) {&lt;br/&gt;&lt;span&gt;            &lt;span class=&quot;cm-keyword&quot;&gt;synchronized (&lt;span class=&quot;cm-variable&quot;&gt;Singleton.&lt;span class=&quot;cm-keyword&quot;&gt;class) {&lt;br/&gt;&lt;span&gt;                &lt;span class=&quot;cm-keyword&quot;&gt;if (&lt;span class=&quot;cm-variable&quot;&gt;instance &lt;span class=&quot;cm-operator&quot;&gt;== &lt;span class=&quot;cm-atom&quot;&gt;null) {&lt;br/&gt;&lt;span&gt;                    &lt;span class=&quot;cm-variable&quot;&gt;instance &lt;span class=&quot;cm-operator&quot;&gt;= &lt;span class=&quot;cm-keyword&quot;&gt;new &lt;span class=&quot;cm-variable&quot;&gt;Singleton();&lt;br/&gt;&lt;span&gt;                }&lt;br/&gt;&lt;span&gt;            }&lt;br/&gt;&lt;span&gt;        }&lt;br/&gt;&lt;span&gt;        &lt;span class=&quot;cm-keyword&quot;&gt;return &lt;span class=&quot;cm-variable&quot;&gt;instance;&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;给 instance 分配内存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;调用 Singleton 的构造函数来初始化成员变量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;将 instance 对象指向分配的内存空间（执行完这步 instance 就为非 null 了）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;我们只需要将 instance 变量声明成 volatile 就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;class &lt;span class=&quot;cm-def&quot;&gt;Singleton {&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-keyword&quot;&gt;volatile &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;instance;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-variable&quot;&gt;Singleton() {&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;getInstance() {&lt;br/&gt;&lt;span&gt;        &lt;span class=&quot;cm-keyword&quot;&gt;if (&lt;span class=&quot;cm-variable&quot;&gt;instance &lt;span class=&quot;cm-operator&quot;&gt;== &lt;span class=&quot;cm-atom&quot;&gt;null) {&lt;br/&gt;&lt;span&gt;            &lt;span class=&quot;cm-keyword&quot;&gt;synchronized (&lt;span class=&quot;cm-variable&quot;&gt;Singleton.&lt;span class=&quot;cm-keyword&quot;&gt;class) {&lt;br/&gt;&lt;span&gt;                &lt;span class=&quot;cm-keyword&quot;&gt;if (&lt;span class=&quot;cm-variable&quot;&gt;instance &lt;span class=&quot;cm-operator&quot;&gt;== &lt;span class=&quot;cm-atom&quot;&gt;null) {&lt;br/&gt;&lt;span&gt;                    &lt;span class=&quot;cm-variable&quot;&gt;instance &lt;span class=&quot;cm-operator&quot;&gt;= &lt;span class=&quot;cm-keyword&quot;&gt;new &lt;span class=&quot;cm-variable&quot;&gt;Singleton();&lt;br/&gt;&lt;span&gt;                }&lt;br/&gt;&lt;span&gt;            }&lt;br/&gt;&lt;span&gt;        }&lt;br/&gt;&lt;span&gt;        &lt;span class=&quot;cm-keyword&quot;&gt;return &lt;span class=&quot;cm-variable&quot;&gt;instance;&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;有些人认为使用 &lt;span&gt;&lt;code&gt;volatile&lt;/code&gt; &lt;span&gt;的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 &lt;span&gt;&lt;code&gt;volatile&lt;/code&gt; &lt;span&gt;的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 &lt;span&gt;&lt;code&gt;volatile&lt;/code&gt; &lt;span&gt;变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;但是特别注意在 Java 5 以前的版本使用了 &lt;span&gt;&lt;code&gt;volatile&lt;/code&gt; &lt;span&gt;的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 &lt;span&gt;&lt;code&gt;volatile&lt;/code&gt; &lt;span&gt;屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 &lt;span&gt;&lt;code&gt;volatile&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;那么，有没有一种既有懒加载，又保证了线程安全，还简单的方法呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;当然有，静态内部类，就是一种我们想要的方法。我们完全可以把 Singleton 实例放在一个静态内部类中，这样就避免了静态实例在 Singleton 类加载的时候就创建对象，并且由于静态内部类只会被加载一次，所以这种写法也是线程安全的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;class &lt;span class=&quot;cm-def&quot;&gt;Singleton {&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-keyword&quot;&gt;class &lt;span class=&quot;cm-def&quot;&gt;Holder {&lt;br/&gt;&lt;span&gt;        &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;INSTANCE &lt;span class=&quot;cm-operator&quot;&gt;= &lt;span class=&quot;cm-keyword&quot;&gt;new &lt;span class=&quot;cm-variable&quot;&gt;Singleton();&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;private &lt;span class=&quot;cm-variable&quot;&gt;Singleton() {&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;static &lt;span class=&quot;cm-variable&quot;&gt;Singleton &lt;span class=&quot;cm-variable&quot;&gt;getInstance() {&lt;br/&gt;&lt;span&gt;        &lt;span class=&quot;cm-keyword&quot;&gt;return &lt;span class=&quot;cm-variable&quot;&gt;Holder.&lt;span class=&quot;cm-variable&quot;&gt;INSTANCE;&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;这是我比较推荐的解法，这种写法用 JVM 本身的机制保证了线程安全的问题，同时读取实例的时候也不会进行同步，没什么性能缺陷，还不依赖 JDK 版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;虽说如此，但看《Effective Java》中第三点来说，还是有必要提醒一下：&lt;span&gt;&lt;strong&gt;&lt;span&gt;享有特权的客户端可以借助 &lt;span&gt;&lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; &lt;span&gt;方法，通过反射机制来调用私有构造器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果需要抵御这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;《Effective Java 中文版》PDF 在公众号后台回复「Effective Java」即可获取。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;我们其实还有更简单的枚举单例。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;用过枚举写单例的人都说：&lt;span&gt;&lt;strong&gt;用枚举写单例真是太简单了。&lt;/strong&gt;&lt;span&gt;下面的这段代码就是声明枚举单例的通常做法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt;public &lt;span class=&quot;cm-keyword&quot;&gt;enum &lt;span class=&quot;cm-def&quot;&gt;EasySingleton{&lt;br/&gt;&lt;span&gt;    &lt;span class=&quot;cm-variable&quot;&gt;INSTANCE;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;这是从 Java 1.5 发行版本后就可以实用的单例方法，我们可以通过 &lt;span&gt;&lt;code&gt;EasySingleton.INSTANCE&lt;/code&gt; &lt;span&gt;来访问实例，这比调用 &lt;span&gt;&lt;code&gt;getInstance()&lt;/code&gt; &lt;span&gt;方法简单多了。创建枚举默认就是线程安全的，所以不需要担心 double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;一个总结肯定是必不可少的，上面也只是列举了我们常见的单例实现方式。当然也不完全，比如我们还可以用 static 代码块的方式实现懒汉式代码，但这里就不一一例举了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;就我个人而言，我还是比较推荐用静态内部类的方式使用单例模式，如果涉及到反序列化创建对象的话，不妨也试试枚举呗~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;文章参考链接：http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Jul 2018 04:12:00 +0000</pubDate>
<dc:creator>南尘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liushilin/p/9257953.html</dc:identifier>
</item>
<item>
<title>canvas三角函数模拟水波效果 - 庞永胜</title>
<link>http://www.cnblogs.com/pangys/p/9257777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pangys/p/9257777.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最近项目中，ui设计了个水波效果的背景动画，然而并没有gif或svg动画，开始试着用css实现了一下，动画效果并不是很好，网上查了下基本都是用贝赛尔曲线实现，想起以看的各种前波形图，于是想着用三角函数图像初略模拟一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例效果如下：&lt;/p&gt;


&lt;h2 id=&quot;hsin&quot;&gt;&lt;span&gt;一、绘制sin函数图像&lt;/span&gt;&lt;/h2&gt;
sin函数表达式如下，&lt;br/&gt;&lt;span class=&quot;katex-display&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;y=Asin（wx+φ）+h y= Asin（wx+φ）+h&lt;/span&gt; &lt;span class=&quot;katex-html&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;mord mathit&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathit&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathit&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord cjk_fallback&quot;&gt;（&lt;/span&gt;&lt;span class=&quot;mord mathit&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;mord mathit&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;φ&lt;/span&gt;&lt;span class=&quot;mord cjk_fallback&quot;&gt;）&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;mord mathit&quot;&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;其中&lt;strong&gt;A表示振幅，ω表示角频率（ω=2π/T,T为函数的周期），φ表示初相，h表示图像向y轴正方向平移的长度&lt;/strong&gt;；（这里需要注意一下：h在数学学的本来是表示向上平移的，但在canvas中采用的是屏幕坐标系，即左上角为原点，h则表示向下平移）；&lt;em id=&quot;__mceDel&quot;&gt;绘制代码如下：&lt;br/&gt;（1）添加canvas标签&lt;/em&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;canvas&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;canvas&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;canvas&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）添加css样式,设置canvas宽高&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;html&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;body&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;padding&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;margin&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;100%&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;100%&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;canvas&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;100%&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;100%&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）绘制函数图像&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;hljs javascript&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; canvas = &lt;span class=&quot;hljs-built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;hljs-string&quot;&gt;&quot;canvas&quot;&lt;/span&gt;),&lt;br/&gt;ctx = canvas.getContext(&lt;span class=&quot;hljs-string&quot;&gt;'2d'&lt;/span&gt;),&lt;br/&gt;width = canvas.width = canvas.offsetWidth,&lt;br/&gt;height = canvas.height = canvas.offsetHeight;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; A=&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;,&lt;br/&gt;W=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;,&lt;br/&gt;Q=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;br/&gt;H= height / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;draw&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;ctx.clearRect(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, width, height);&lt;br/&gt;ctx.beginPath();                   &lt;br/&gt;ctx.strokeStyle=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#000&quot;&lt;/span&gt;;            &lt;br/&gt;ctx.lineWidth = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;                 &lt;br/&gt;ctx.moveTo(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, height /&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);          &lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; x &amp;lt;=  width; x++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; y = A*&lt;span class=&quot;hljs-built_in&quot;&gt;Math&lt;/span&gt;.sin(W*x+Q) +H&lt;br/&gt;ctx.lineTo(x, y)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;ctx.stroke();                      &lt;br/&gt;ctx.closePath();                   &lt;br/&gt;})()&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们可以得到以下图像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/966512/201807/966512-20180703114159427-1618540794.png&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;二、为函数图像添加动画&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上面得到的是是一个静态的函数图像，而我们一般见到的的波形图或水波都是随时间连续变化的，这里就要用到上一步中的参数相位φ，（js即代码中的Q） ，我们将φ随时间不断增加或减小，即可得到不同时间的不同图像；使用window.requestAnimationFrame实现帧动画；&lt;br/&gt;修改以上代码为：&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;hljs javascript&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; speed=&lt;span class=&quot;hljs-number&quot;&gt;-0.02&lt;/span&gt;;&lt;p&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;draw&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;window&lt;/span&gt;.requestAnimationFrame(draw);&lt;br/&gt;ctx.clearRect(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, width, height);&lt;br/&gt;ctx.beginPath();&lt;br/&gt;ctx.strokeStyle=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#000&quot;&lt;/span&gt;;&lt;br/&gt;ctx.lineWidth = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;ctx.moveTo(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, height /&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;Q+=speed;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; x &amp;lt;=  width; x++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; y = A*&lt;span class=&quot;hljs-built_in&quot;&gt;Math&lt;/span&gt;.sin(W*x+Q) +H;&lt;br/&gt;ctx.lineTo(x, y);&lt;br/&gt;}&lt;br/&gt;ctx.stroke();&lt;br/&gt;ctx.closePath();&lt;br/&gt;})()&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下（渣渣截图软件）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/966512/201807/966512-20180703114227471-908997432.gif&quot; alt=&quot;&quot; width=&quot;475&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;三、绘制完整填充路径&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;以上路径虽有闭合，但却不满足我们需要填充的部分，直接填充效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/966512/201807/966512-20180703114352048-1578711497.png&quot; alt=&quot;&quot; width=&quot;332&quot; height=&quot;145&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整填充路径应如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/966512/201807/966512-20180703114426422-1077370932.jpg&quot; alt=&quot;&quot; width=&quot;727&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;p&gt;闭合路径后创建一个渐变颜色，作为填充颜色，代码如下：&lt;/p&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;code class=&quot;hljs javascript&quot; readability=&quot;12&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; lingrad = ctx.createLinearGradient(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,width,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);&lt;br/&gt;lingrad.addColorStop(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'rgba(0,186,128,0.8)'&lt;/span&gt;);&lt;br/&gt;lingrad.addColorStop(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'rgba(111,224,195,1)'&lt;/span&gt;);   &lt;p&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;draw&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;window&lt;/span&gt;.requestAnimationFrame(draw);&lt;br/&gt;ctx.clearRect(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, width, height);&lt;br/&gt;ctx.beginPath();&lt;br/&gt;ctx.strokeStyle=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#000&quot;&lt;/span&gt;;&lt;br/&gt;ctx.fillStyle = lingrad;&lt;br/&gt;ctx.lineWidth = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;ctx.moveTo(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, height /&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);  &lt;br/&gt;Q+=speed;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; x &amp;lt;=  width; x++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; y = A*&lt;span class=&quot;hljs-built_in&quot;&gt;Math&lt;/span&gt;.sin(W*x+Q) +H;&lt;br/&gt;ctx.lineTo(x, y);&lt;br/&gt;}&lt;br/&gt;ctx.lineTo(width, height);&lt;br/&gt;ctx.lineTo(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, height);&lt;br/&gt;ctx.fill();&lt;br/&gt;ctx.closePath();&lt;br/&gt;})()&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/966512/201807/966512-20180703114746269-573485568.png&quot; alt=&quot;&quot; width=&quot;374&quot; height=&quot;139&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h-2&quot;&gt;&lt;span&gt;四、完善水波动画&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1、首先可以对上面波形叠加一个频率更高的波形，使波形无规矩&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; s = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;*&lt;span class=&quot;hljs-built_in&quot;&gt;Math&lt;/span&gt;.sin(x/&lt;span class=&quot;hljs-number&quot;&gt;150&lt;/span&gt;)+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; y = A*&lt;span class=&quot;hljs-built_in&quot;&gt;Math&lt;/span&gt;.sin(W*x+Q) +H;&lt;br/&gt;y=y*s;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、再添加一个相位变化不同的波形，其渐变填充与上一个渐变方向相反使其形成相互重叠的阴影效果；并设置路径重叠效果globalCompositeOperation；&lt;/p&gt;
&lt;pre readability=&quot;30.5&quot;&gt;
&lt;code class=&quot;hljs javascript&quot; readability=&quot;55&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; canvas = &lt;span class=&quot;hljs-built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;hljs-string&quot;&gt;&quot;canvas&quot;&lt;/span&gt;),&lt;br/&gt;ctx = canvas.getContext(&lt;span class=&quot;hljs-string&quot;&gt;'2d'&lt;/span&gt;),&lt;br/&gt;width = canvas.width = canvas.offsetWidth,&lt;br/&gt;height = canvas.height = canvas.offsetHeight;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; A=&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;,&lt;br/&gt;W=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; /&lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;,&lt;br/&gt;Q=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;br/&gt;H= height / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; A2=&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;,&lt;br/&gt;W2=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;,&lt;br/&gt;Q2=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;br/&gt;H2= height / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; speed=&lt;span class=&quot;hljs-number&quot;&gt;-0.01&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; speed2=&lt;span class=&quot;hljs-number&quot;&gt;-0.02&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; lingrad = ctx.createLinearGradient(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,width,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);&lt;br/&gt;lingrad.addColorStop(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'rgba(0,186,128,0.8)'&lt;/span&gt;);&lt;br/&gt;lingrad.addColorStop(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'rgba(111,224,195,1)'&lt;/span&gt;);  &lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; lingrad2 = ctx.createLinearGradient(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,width,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);&lt;br/&gt;lingrad2.addColorStop(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'rgba(111,224,195,1)'&lt;/span&gt;);&lt;br/&gt;lingrad2.addColorStop(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'rgba(0,186,128,0.8)'&lt;/span&gt;); &lt;/p&gt;&lt;p&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;draw&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;window&lt;/span&gt;.requestAnimationFrame(draw);&lt;br/&gt;ctx.clearRect(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, width, height);&lt;br/&gt;ctx.beginPath();&lt;br/&gt;ctx.fillStyle = lingrad;&lt;br/&gt;ctx.moveTo(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, height /&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;Q+=speed;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; x &amp;lt;=  width; x++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; s = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;*&lt;span class=&quot;hljs-built_in&quot;&gt;Math&lt;/span&gt;.sin(x/&lt;span class=&quot;hljs-number&quot;&gt;150&lt;/span&gt;)+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; y = A*&lt;span class=&quot;hljs-built_in&quot;&gt;Math&lt;/span&gt;.sin(W*x+Q) +H;&lt;br/&gt;y=y*s;&lt;br/&gt;ctx.lineTo(x, y);&lt;br/&gt;}&lt;br/&gt;ctx.lineTo(width, height);&lt;br/&gt;ctx.lineTo(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, height);&lt;br/&gt;ctx.fill();&lt;br/&gt;ctx.closePath()&lt;br/&gt;ctx.globalCompositeOperation = &lt;span class=&quot;hljs-string&quot;&gt;&quot;destination-over&quot;&lt;/span&gt;&lt;br/&gt;ctx.beginPath();&lt;br/&gt;ctx.fillStyle = lingrad2;&lt;br/&gt;Q2+=speed2;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; x &amp;lt; width; x++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; y = A2*&lt;span class=&quot;hljs-built_in&quot;&gt;Math&lt;/span&gt;.sin(x*W2+Q2) +H2;&lt;br/&gt;ctx.lineTo(x, y);&lt;br/&gt;}&lt;br/&gt;ctx.lineTo(width,height);&lt;br/&gt;ctx.lineTo(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,height);&lt;br/&gt;ctx.fill()&lt;br/&gt;ctx.closePath();&lt;/p&gt;&lt;p&gt;})()&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 03 Jul 2018 03:50:00 +0000</pubDate>
<dc:creator>庞永胜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pangys/p/9257777.html</dc:identifier>
</item>
</channel>
</rss>