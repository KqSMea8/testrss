<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python学习一：序列基础详解 - NiceCui</title>
<link>http://www.cnblogs.com/NiceCui/p/7858473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NiceCui/p/7858473.html</guid>
<description>&lt;p&gt;作者：NiceCui&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文谢绝转载，如需转载需征得作者本人同意，谢谢。&lt;/li&gt;
&lt;li&gt;本文链接：http://www.cnblogs.com/NiceCui/p/7858473.html&lt;/li&gt;
&lt;li&gt;邮箱：moyi@moyibolg.com&lt;/li&gt;
&lt;li&gt;日期：2017-11-18&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Python学习一：序列基础详解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一：序列介绍&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Python中一些类型的变量，就像容器一样，收纳多个数据，序列就像一个有序的队伍，像整齐的万里长城，存储着各种各样的数据，他们按照一定的秩序排列在一起，很威武，很美观，所以说序列是&lt;span&gt;有序的数据集合。&lt;span&gt;序列包含的一个数据被称作序列的一个&lt;span&gt;元素&lt;/span&gt;。序列可以包含一个或者多个元素，也可以没有任何元素的空序列。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;二：序列分类&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;序列有两种，分别是&lt;span&gt;元组&lt;/span&gt;（Tuple）和&lt;span&gt;列表&lt;/span&gt;（&lt;span&gt;&lt;span&gt;List&lt;/span&gt;&lt;/span&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;两者的主要区别是：一旦建立有效的序列，远组的各个元素不可以再被修改和变更，将会变成一组固定的元素。所以元组跟像是一个特殊的表，数据是固定的，很多人都管它叫“定值表”。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;三：元组和列表建立&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Created on 2017年11月18日
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@author: NiceCui
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----------------------tuple 元组------------------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; tuple = (2,3,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;good&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello tuple&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,666,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tuple[0])
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(tuple[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(tuple[2&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(tuple[3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; good&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----------------------List 列表------------------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; list = [1,2,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,6,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list[0])
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list[2&lt;span&gt;])&lt;br/&gt;&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; list&lt;/span&gt;&lt;span&gt;'&lt;br/&gt;'''&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;这是使用eclipse上写的python，不清楚怎么使用eclipse安装python插件的同学可以看看我Python随笔分类中有介绍怎么使用eclipse安装python插件；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装插件教程：&lt;a title=&quot;http://www.cnblogs.com/NiceCui/p/7858107.html&quot; href=&quot;http://www.cnblogs.com/NiceCui/p/7858107.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/NiceCui/p/7858107.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上面的的例子可以看出，同一个序列可以有包含不同类型的元素，这也是python动态类型的一个体现，还有，序列元素不仅可以是基本类型的数据，还可以是另外一个类型的序列。这也是和java语言上有点差别的，使用Python语言书写序列会显得很简单感觉功能十分强大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四：嵌套和固定的展示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;列表内部嵌套列表&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Created on 2017-11-18
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@author: NiceCui
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; next_list = [1,[3,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,4,5&lt;span&gt;]] 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(next_list[0])
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next_list[1&lt;span&gt;][0])
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(next_list[1][1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;'&amp;gt;&amp;gt;&amp;gt; 1'
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;'&amp;gt;&amp;gt;&amp;gt; 3'
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;'&amp;gt;&amp;gt;&amp;gt; hello'
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;元组不能改变数据的缘由，很少去建立一个元组，但是序列可以增加和修改元素，所以序列经常被用作去建立一个空表；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;空列表
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; next_list = []
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五：序列的数据读取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刚才上方的小例子中已经展示了怎么使用下标去找到单个元素，当然还可以通过范围的引用方式去找到多个元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围引用的基本样式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 序列名[下限：上限：步长]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下限表示起始下标，上限表示结尾下标。在起始和结尾下标之间，按照步长的间隔来找到元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果默认步长为1，也即是上限和下限之间的每隔1个元素都会出现在结果中。引用多个元素将成为一个新的序列。接下来做一个小的例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; list = [1,2,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,6,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list[0])
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list[2&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list[:6]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下标 0 ~ 5 的元素都输出&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list[2:]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下标 2 ~ 最后一个 元素都输出&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list[0:6:2]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下标 0 2 4 元素都输出&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list[2:0:-1]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下标 2 1 元素都输出&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; sliced = list[2:0:-1&lt;span&gt;] 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; type(sliced)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 范式引用的结果是一个元组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除此之外Python还提供了一个尾部引用的语法，用于引用序列尾部的元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Created on 2017-11-18
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@author: NiceCui
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; list = [1,2,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,6,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list[-1])   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回序列最后一个元素&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list[-3])   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回序列倒数第三个元素&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(list[1:-1]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回序列倒数第2个元素 和倒数第2个元素&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Sat, 18 Nov 2017 15:55:00 +0000</pubDate>
<dc:creator>NiceCui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NiceCui/p/7858473.html</dc:identifier>
</item>
<item>
<title>【游戏开发】Excel表格批量转换成CSV的小工具 - 马三小伙儿</title>
<link>http://www.cnblogs.com/msxh/p/7858346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/msxh/p/7858346.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-  &lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os,sys,inspect,re
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; xdrlib,xlrd
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 防止中文乱码&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;reload(sys)
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; sys.setdefaultencoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分割符&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; C_SPACE = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结束符&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; C_END = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入路径(存放xls文件的路径）&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; IN_PATH = &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出路径(导出csv文件的路径)&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; OUT_PATH = &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取配置文件&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_config():
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     config_file = open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config.ini&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     cur_line = config_file.readline().rstrip(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; IN_PATH 
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     IN_PATH = cur_line[1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     cur_line = config_file.readline().rstrip(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; OUT_PATH 
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     OUT_PATH = cur_line[1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 过滤路径&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; cur_file_dir(path):
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; os.path.isfile(path):
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         path =&lt;span&gt; os.path.dirname(path)
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; path
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; os.path.abspath(path)
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 搜索指定文件夹下面的文件&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; find_file_by_pattern(pattern=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, base=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, circle=&lt;span&gt;True):  
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找给定文件夹下面所有xls文件&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;     re_file =&lt;span&gt; re.compile(pattern)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一次搜索的时候过滤下路径，递归之后直接搜索base路径即可&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; base == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         base =&lt;span&gt; cur_file_dir(IN_PATH)
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始搜索文件夹：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,base
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储xls文件的列表&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;     final_file_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历指定路径下的文件&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;     cur_list =&lt;span&gt; os.listdir(base)  
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cur_list:
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 忽略一些干扰的文件，如果你还有其他需要忽略的文件，直接在后面继续添加即可&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; item == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.svn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拼接路径&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;         full_path =&lt;span&gt; os.path.join(base, item)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 忽略临时文件&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; full_path.startswith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 筛选出xlsx\xls文件&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; full_path.endswith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;or&lt;/span&gt; full_path.endswith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.xls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt; u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入文件:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; full_path
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             bfile =&lt;span&gt; os.path.isfile(item)
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; os.path.isfile(full_path):
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; re_file.search(full_path):
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;                    final_file_list.append(full_path)  
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                 final_file_list +=&lt;span&gt; find_file_by_pattern(pattern, full_path)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回文件列表&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; final_file_list
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开excel&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; open_excel(file= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;file.xls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         data =&lt;span&gt; xlrd.open_workbook(file)
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception,e:
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt; str(e)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;根据索引获取Excel表格中的数据 参数:file：Excel文件路径, colnameindex：表头列名所在行的索引, by_index：表的索引&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; excel_table_byindex(file=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file.xls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, colnameindex=0, by_index=&lt;span&gt;0):
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     data =&lt;span&gt; open_excel(file)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     table =&lt;span&gt; data.sheets()[by_index]
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     nrows = table.nrows &lt;span&gt;#&lt;/span&gt;&lt;span&gt;行数&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;     ncols = table.ncols &lt;span&gt;#&lt;/span&gt;&lt;span&gt;列数&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;     rowlist =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;     
&lt;span&gt; 90&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;开始读取数据&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; rownum &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(colnameindex, nrows):
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         rowdata =&lt;span&gt; table.row_values(rownum)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; rowdata:
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             collist =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(ncols):
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;                collist.append(rowdata[i])
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;            rowlist.append(collist)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rowlist
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存csv文件&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; savaToCSV(_file, _list, _path):
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;     filename = &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;     content = &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成文件内容&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; collist &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _list:
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(collist)):
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;             v =&lt;span&gt; collist[i]
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             vstr = &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print k,v&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; isinstance(v, float) &lt;span&gt;or&lt;/span&gt;&lt;span&gt; isinstance(v, int):
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 vstr =&lt;span&gt; str(int(v))
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                 vstr =&lt;span&gt; v
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; i &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;                 content = content +&lt;span&gt; C_SPACE
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             content = content +&lt;span&gt; vstr
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;         content = content +&lt;span&gt; C_END
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成文件后缀&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;     fname =&lt;span&gt; os.path.splitext(_file)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     filename = fname[0] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写文件&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; len(filename)&amp;gt;0 &lt;span&gt;and&lt;/span&gt; len(content)&amp;gt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;filename = OUT_PATH + &quot;/&quot; + filename&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输出文件:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; filename
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;         file_object = open(filename, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;        file_object.write(content)
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;        file_object.close()
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; 
&lt;span&gt;134&lt;/span&gt; &lt;span&gt;    read_config()
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;     filelist =&lt;span&gt; find_file_by_pattern()
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; len(filelist) &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;         path = &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历文件生成csv&lt;/span&gt;
&lt;span&gt;139&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt;&lt;span&gt; filelist:
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;             datalist =&lt;span&gt; excel_table_byindex(file, 0)
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; len(datalist)&amp;gt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;                savaToCSV(file, datalist, path)
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有找到任何excel文件！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt; 
&lt;span&gt;146&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;     main()
&lt;/pre&gt;</description>
<pubDate>Sat, 18 Nov 2017 15:27:00 +0000</pubDate>
<dc:creator>马三小伙儿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/msxh/p/7858346.html</dc:identifier>
</item>
<item>
<title>掌握numpy(三) - Wanna_Go</title>
<link>http://www.cnblogs.com/wxshi/p/7858370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxshi/p/7858370.html</guid>
<description>&lt;h2 id=&quot;统计功能&quot;&gt;统计功能&lt;/h2&gt;
&lt;p&gt;前面都是介绍numpy的一些特性，被称为数学运算神器怎么能少了统计功能呢&lt;/p&gt;
&lt;h3 id=&quot;ndarray的方法&quot;&gt;ndarray的方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;a = np.array([[-2.5, 3.1, 7], [10, 11, 12]])
&amp;gt;&amp;gt;print &quot;mean =&quot;, a.mean()
mean = 6.76666666667&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面&lt;code&gt;mean&lt;/code&gt;没有指定参数，是将ndarray中得所有值相加，求得均值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;a.mean(axis=1) #按行求均值
array([  2.53,  11. ]) 
&amp;gt;&amp;gt;a.mean(axis=0) #按列求均值
array([ 3.75,  7.05,  9.5 ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面数据是2维的，如果是多维度的怎么办呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = np.arange(24).reshape(2,3,4)
&amp;gt;&amp;gt;a
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])
&amp;gt;&amp;gt;a.sum(axis=0)
array([[12, 14, 16, 18],# 12=(0+12)
       [20, 22, 24, 26],#20=(4+16)
       [28, 30, 32, 34]])
&amp;gt;&amp;gt;a.sum(axis=1),
array([[12, 15, 18, 21],#12=（0+4+8）
     [48, 51, 54, 57]])
&amp;gt;&amp;gt;a.sum(axis=(0,2))
array([ 60,  92, 124])#60=(0+1+2+3 + 12+14+15+16+18)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一些常用得数值统计方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for func in (a.min,a.max,a.prod,a.std,a.var):
   &amp;gt;&amp;gt; print func.__name__ ,&quot;=&quot;,func()
min = -2.5
max = 12.0
prod = -71610.0    #内积
std = 5.08483584352
var = 25.8555555556&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数值运算方法&quot;&gt;数值运算方法&lt;/h3&gt;
&lt;p&gt;NumPy还 提供了许多常用的数值运算方法，像数值运算中的绝对值、三角和函数、对数等等。这些方法都是&lt;code&gt;element-wise&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = np.array([[-2.5, 3.1, 7], [10, 11, 12]])
for func in (np.abs, np.sqrt, np.exp, np.log, np.sign, np.ceil, np.modf, np.isnan, np.cos):
    print&quot;\n&quot;, func.__name__
    &amp;gt;&amp;gt;print(func(a))
absolute #绝对值
[[  2.5   3.1   7. ]
 [ 10.   11.   12. ]]

sqrt
[[        nan  1.76068169  2.64575131] #不满足运算法则的返回nan
 [ 3.16227766  3.31662479  3.46410162]]

exp
[[  8.20849986e-02   2.21979513e+01   1.09663316e+03]
 [  2.20264658e+04   5.98741417e+04   1.62754791e+05]]

log
[[        nan  1.13140211  1.94591015]
 [ 2.30258509  2.39789527  2.48490665]]

sign
[[-1.  1.  1.]
 [ 1.  1.  1.]]

ceil #向上取整
[[ -2.   4.   7.]
 [ 10.  11.  12.]]

modf #返回的为一个元组=&amp;gt;（小数部分，整数部分）
(array([[-0.5,  0.1,  0. ],
       [ 0. ,  0. ,  0. ]]), array([[ -2.,   3.,   7.],
       [ 10.,  11.,  12.]]))

isnan
[[False False False]
 [False False False]]

cos
[[-0.80114362 -0.99913515  0.75390225]
 [-0.83907153  0.0044257   0.84385396]]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数组的index&quot;&gt;数组的index&lt;/h2&gt;
&lt;h3 id=&quot;一维数组&quot;&gt;一维数组&lt;/h3&gt;
&lt;p&gt;ndarray有着python原生数组的所有特性,例如切片(slice)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a=np.arange(9)
&amp;gt;&amp;gt;a
 array([0, 1, 2, 3, 4, 5, 6, 7, 8])
&amp;gt;&amp;gt;a[2:5]
array([2, 3, 4])
&amp;gt;&amp;gt;a[2:-1]
array([2, 3, 4, 5, 6, 7])
&amp;gt;&amp;gt;a[:2]
 array([0, 1])
&amp;gt;&amp;gt;a[::-1]
 array([8, 7, 6, 5, 4, 3, 2, 1, 0])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然还有原生数组没有的特性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a[2:5]=-1
&amp;gt;&amp;gt;a
array([ 0,  1, -1, -1, -1,  5,  6,  7,  8])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有几点需要注意的&lt;/p&gt;
&lt;ul readability=&quot;17&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;1.不能用以下方式增长或者缩减ndarray数组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
a[2:5] = [1,2,3,4,5,6]  # too long
except ValueError as e:
&amp;gt;&amp;gt;print(e)
cannot copy sequence with size 6 to array axis with dimension 3&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;2.不能删除ndarray数组元素 #原生数组可以&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
del a[2:5]
except ValueError as e:
   &amp;gt;&amp;gt;print(e)
ValueError: cannot delete array elements&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;23&quot;&gt;
&lt;p&gt;3.修改切片数组的内容，原始数组值也发生变化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b = a[3:5]
b[0] = 999
&amp;gt;&amp;gt;b
array([999,   4])
&amp;gt;&amp;gt;a
array([  0,   1,   2, 999,   4,   5,   6,   7,   8])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果确定要拷贝数值，可以使用&lt;code&gt;copy&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b = a[3:5].copy()
b[0] = 999
&amp;gt;&amp;gt;a
array([0, 1, 2, 3, 4, 5, 6, 7, 8])
b
&amp;gt;&amp;gt;array([999,   4])&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;多维数组&quot;&gt;多维数组&lt;/h3&gt;
&lt;p&gt;多维的ndarray有许多神奇的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b = np.arange(24).reshape(4, 6)
&amp;gt;&amp;gt;b
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])
&amp;gt;&amp;gt;b[1,1] #等价与b[1][1]
7
&amp;gt;&amp;gt;b[1,:]#第一行的所有元素
array([ 6,  7,  8,  9, 10, 11])
&amp;gt;&amp;gt;b[:,1]#第一列的所有元素
array([ 1,  7, 13, 19])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;下面的两种写法的不同&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;b[1,:]
array([ 6,  7,  8,  9, 10, 11]) # (6L,)
&amp;gt;&amp;gt;b[1:2,:] 
array([[ 6,  7,  8,  9, 10, 11]])#(1L, 6L)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我只想要多维度数组中的第一行和最后一行/列呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;b[(0,-1),:]
array([[ 0,  1,  2,  3,  4,  5],
       [18, 19, 20, 21, 22, 23]])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的写法等价于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;index = np.array([True,False,False,True])
&amp;gt;&amp;gt;b[index,:]
array([[ 0,  1,  2,  3,  4,  5],
       [18, 19, 20, 21, 22, 23]])&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;np.ix_&quot;&gt;np.ix_&lt;/h3&gt;
&lt;p&gt;上面学习了那么多的知识，我们来要给小测验：数组b中第1行和第3行中第4和第6列的元素([[3,5],[15,17]])该怎么表示呢？&lt;br/&gt;我猜你会这么写&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;b[(0,2),(3,5)]
array([ 3, 17]) 
&amp;gt;&amp;gt;b[[0,2],[3,5]]
array([ 3, 17])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的结果显然不是我们想要的，那么正确的写法是什么呢？这时候就需要&lt;code&gt;ix_&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;index = np.ix_([0,2],[3,5])
&amp;gt;&amp;gt;index
(array([[0],
        [2]]), array([[3, 5]]))
&amp;gt;&amp;gt;b[index]
array([[ 3,  5],
       [15, 17]])&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ndarray的遍历&quot;&gt;ndarray的遍历&lt;/h2&gt;
&lt;p&gt;对数组的遍历是我们经常用的操作，对于numpy数组该由如何遍历呢？&lt;br/&gt;接着使用上面的数组&lt;strong&gt;&lt;code&gt;b&lt;/code&gt;&lt;/strong&gt;,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for i in b:
    &amp;gt;&amp;gt;print 'row:',i
row: [0 1 2 3 4 5]
row: [ 6  7  8  9 10 11]
row: [12 13 14 15 16 17]
row: [18 19 20 21 22 23]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要遍历所有的元素呢&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for i in b.flat:
    &amp;gt;&amp;gt;print 'Element:',i
Element: 0
Element: 1
Element: 2
....
Element: 21
Element: 22
Element: 23
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 18 Nov 2017 15:23:00 +0000</pubDate>
<dc:creator>Wanna_Go</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wxshi/p/7858370.html</dc:identifier>
</item>
<item>
<title>基于.NET CORE微服务框架 -谈谈surging 的messagepack、protobuffer、json.net 序列化 - fanly11</title>
<link>http://www.cnblogs.com/fanliang11/p/7858371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanliang11/p/7858371.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;     surging内部&lt;span class=&quot;col-11 text-gray-dark mr-2&quot;&gt;使用的是高性能RPC远程服务调用，如果用json.net序列化肯定性能上达不到最优，所以后面扩展了protobuf,messagepack序列化组件，以支持RPC二进制传输.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span class=&quot;col-11 text-gray-dark mr-2&quot;&gt;     在这里需要感谢白纸无字Zonciu，新增了&lt;span class=&quot;col-11 text-gray-dark mr-2&quot;&gt;messagepack&lt;/span&gt;序列化，让surging 性能上跨了一大步。此篇文章我们来谈谈messagepack、protobuffer、json.net ，并且性能做下对比&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    开源地址：&lt;a href=&quot;https://github.com/dotnetcore/surging&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnetcore/surging&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  　2.1 surging 使用的是以下序列化组件:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      json.net：surging 使用的是Newtonsoft.Json， 它是基于json格式的序列化和反序列化的组件.官方网站: http://json.codeplex.com/&lt;/p&gt;
&lt;p&gt;      protobuf：surging 使用的是protobuf-net， 它是基于二进制格式的序列化和反序列化的组件.官方网站: https://github.com/mgravell/protobuf-net&lt;/p&gt;
&lt;p&gt;      messagepack：surging 使用的是MessagePack-CSharp， 它是基于二进制格式的序列号和反序列化的组件.官方网站: https://github.com/neuecc/MessagePack-CSharp&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      2.2 各个组件的优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       json.net 有以下优点：&lt;/p&gt;
&lt;p&gt;       侵入性：可以不添加attribute,就能进行序列化操作&lt;/p&gt;
&lt;p&gt;       灵活性：可以灵活性配置，比如允许被序列化的成员自定义名字，屏蔽的非序列化属性成员&lt;/p&gt;
&lt;p&gt;       可读性： 数据格式比较简单, 易于读写&lt;/p&gt;
&lt;p&gt;       依赖性：可以序列化成JObject，无需依赖对象进行序列化和泛型化。&lt;/p&gt;
&lt;p&gt;　　protobuf 有以下优点：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;  　   性能高  序列化后体积相比Json和XML很小，适合RPC二进制传输&lt;br/&gt;　　 跨语言：支持跨平台多语言&lt;br/&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;        兼容性&lt;/span&gt;：消息格式升级和兼容性还不错&lt;br/&gt;        速度快 ：序列化反序列化速度很快，快于Json的处理速速&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     messagepack有以下优点：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;  　   性能高  序列化后体积相比Json和XML很小，适合RPC二进制传输&lt;br/&gt;　　 跨语言：支持跨平台多语言&lt;br/&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;        兼容性：消息格式升级和兼容性还不错&lt;br/&gt;        速度快 ：序列化反序列化速度很快，快于Json的处理速度&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt; 针对于protobuf和messagepack都是基于二进制格式的序列化和反序列化，优点都一样，但是基于messagepack的&lt;/span&gt;&lt;/span&gt;MessagePack-CSharp&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;组件侵入性更小，可以不需要加attribute,而且性能上更优.下一节来看看更组件在surging 中的表现&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;服务端：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot;&gt;（注：如果不加UseProtoBufferCodec和UseMessagePackCodec就是json.net序列化）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var host = new ServiceHostBuilder()
               .RegisterServices(option=&amp;gt; {
                   option.Initialize(); //初始化服务
                   option.RegisterServices();//依赖注入领域服务
                   option.RegisterRepositories();//依赖注入仓储
                   option.RegisterModules();//依赖注入第三方模块
                   option.RegisterServiceBus();//依赖注入ServiceBus
               })
               .RegisterServices(builder =&amp;gt;
               {
                   builder.AddMicroService(option =&amp;gt;
                   {
                       option.AddServiceRuntime();//
                       // option.UseZooKeeperManager(new ConfigInfo(&quot;127.0.0.1:2181&quot;)); //使用Zookeeper管理
                       option.UseConsulManager(new ConfigInfo(&quot;127.0.0.1:8500&quot;));//使用Consul管理
                       option.UseDotNettyTransport();//使用Netty传输
                       option.UseRabbitMQTransport();//使用rabbitmq 传输
                       option.AddRabbitMQAdapt();//基于rabbitmq的消费的服务适配
                     //  option.UseProtoBufferCodec();//基于protobuf序列化传输
                       option.UseMessagePackCodec();//基于MessagePack序列化传输
                       builder.Register(p =&amp;gt; new CPlatformContainer(ServiceLocator.Current));//初始化注入容器
                   });
               })
               .SubscribeAt()     //消息订阅
               .UseServer(&quot;127.0.0.1&quot;, 98)
             //.UseServer(&quot;127.0.0.1&quot;, 98，“true”) //自动生成Token
             //.UseServer(&quot;127.0.0.1&quot;, 98，“123456789”) //固定密码Token
               .UseStartup&amp;lt;Startup&amp;gt;()
               .Build();
               
           using (host.Run())
           {
               Console.WriteLine($&quot;服务端启动成功，{DateTime.Now}。&quot;);
           }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;客户端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;var&lt;/span&gt; host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceHostBuilder()
                .RegisterServices(option &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    option.Initialize();
                    option.RegisterServices();
                    option.RegisterRepositories();
                    option.RegisterModules();
                })
                .RegisterServices(builder &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    builder.AddMicroService(option &lt;/span&gt;=&amp;gt;&lt;span&gt;
                    {
                        option.AddClient();
                        option.AddClientIntercepted(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(CacheProviderInterceptor));
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;option.UseZooKeeperManager(new ConfigInfo(&quot;127.0.0.1:2181&quot;));&lt;/span&gt;
                        option.UseConsulManager(&lt;span&gt;new&lt;/span&gt; ConfigInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1:8500&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                        option.UseDotNettyTransport();
                        option.UseRabbitMQTransport();
                         option.UseProtoBufferCodec();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;option.UseMessagePackCodec();&lt;/span&gt;
                        builder.Register(p =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CPlatformContainer(ServiceLocator.Current));
                    });
                })
                .UseClient()
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                .Build();

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; (host.Run())
            {
                Startup.Test(ServiceLocator.GetService&lt;/span&gt;&amp;lt;IServiceProxyFactory&amp;gt;&lt;span&gt;());
                Startup.TestRabbitMq();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;测试  0  object(注：测试无参数)&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  /// &amp;lt;summary&amp;gt;
        /// 测试
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;serviceProxyFactory&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static void Test(IServiceProxyFactory serviceProxyFactory)
        {
            Task.Run(async () =&amp;gt;
            {
                var userProxy = serviceProxyFactory.CreateProxy&amp;lt;IUserService&amp;gt;(&quot;User&quot;);
                await userProxy.GetUserId(&quot;user&quot;); 
                do
                {
                    Console.WriteLine(&quot;正在循环 1w次调用 GetUser.....&quot;);
                    //1w次调用
                    var watch = Stopwatch.StartNew();
                    for (var i = 0; i &amp;lt; 10000; i++)
                    {
                       var a =userProxy.GetDictionary().Result;
                    }
                    watch.Stop();
                    Console.WriteLine($&quot;1w次调用结束，执行时间：{watch.ElapsedMilliseconds}ms&quot;);
                    Console.ReadLine();
                } while (true);
            }).Wait();
        }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试  1  object(注：测试参数传对象)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
        /// 测试
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;serviceProxyFactory&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static void Test(IServiceProxyFactory serviceProxyFactory)
        {
            Task.Run(async () =&amp;gt;
            {

                var userProxy = serviceProxyFactory.CreateProxy&amp;lt;IUserService&amp;gt;(&quot;User&quot;);
                await userProxy.GetUserId(&quot;user&quot;); 
                do
                {
                    Console.WriteLine(&quot;正在循环 1w次调用 GetUser.....&quot;);
                    //1w次调用
                    var watch = Stopwatch.StartNew();
                    for (var i = 0; i &amp;lt; 10000; i++)
                    {
                       var a =userProxy.GetUser(new UserModel { UserId = 1 }).Result;
                    }
                    watch.Stop();
                    Console.WriteLine($&quot;1w次调用结束，执行时间：{watch.ElapsedMilliseconds}ms&quot;);
                    Console.ReadLine();
                } while (true);
            }).Wait();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;测试  10  object(注：测试参数传List 集合对象)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
   /// &amp;lt;summary&amp;gt;
        /// 测试
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;serviceProxyFactory&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static void Test(IServiceProxyFactory serviceProxyFactory)
        {
            Task.Run(async () =&amp;gt;
            {
                var userProxy = serviceProxyFactory.CreateProxy&amp;lt;IUserService&amp;gt;(&quot;User&quot;);
                await userProxy.GetUserId(&quot;user&quot;);
                var list = new List&amp;lt;UserModel&amp;gt;();
                for(int i=0;i&amp;lt;10;i++)
                {
                    list.Add(new UserModel { UserId = 1, Age = 18, Name = &quot;fanly&quot; });
                }
                do
                {
                    Console.WriteLine(&quot;正在循环 1w次调用 GetUser.....&quot;);
                    //1w次调用
                    var watch = Stopwatch.StartNew();
                    for (var i = 0; i &amp;lt; 10000; i++)
                    {
                       var a =userProxy.Get(list).Result;
                    }
                    watch.Stop();
                    Console.WriteLine($&quot;1w次调用结束，执行时间：{watch.ElapsedMilliseconds}ms&quot;);
                    Console.ReadLine();
                } while (true);
            }).Wait();
        }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试100 object&lt;/strong&gt;(注：测试参数传List 集合对象)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 　　 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 测试
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceProxyFactory&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test(IServiceProxyFactory serviceProxyFactory)
        {
            Task.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; () =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userProxy = serviceProxyFactory.CreateProxy&amp;lt;IUserService&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; userProxy.GetUserId(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;UserModel&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;100&lt;/span&gt;;i++&lt;span&gt;)
                {
                    list.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; UserModel { UserId = &lt;span&gt;1&lt;/span&gt;, Age = &lt;span&gt;18&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fanly&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
                }
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在循环 1w次调用 GetUser.....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1w次调用&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; watch =&lt;span&gt; Stopwatch.StartNew();
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++&lt;span&gt;)
                    {
                       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt;userProxy.Get(list).Result;
                    }
                    watch.Stop();
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1w次调用结束，执行时间：{watch.ElapsedMilliseconds}ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    Console.ReadLine();
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            }).Wait();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过以上测试代码，我们得到了如下的测试结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/192878/201711/192878-20171118230918468-635087163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      通过上图，可以发现messagepack不管是小数据量还是大数据量都保持比较稳定的性能，而json.net 在100object平均已经达到了1.1ms，和messagepack、protobuffer比差太多，而 protobuffer在此次测试中表现的极其不稳定只有在1 object 和100 object 性能比较不错，但是与messagepack比还是相差比较大。所以我建议还是使用messagepack，性能上更优，侵入性也非常低&lt;/p&gt;
&lt;p&gt;我们来看看性能最优的messagepack 详细测试数据&lt;/p&gt;
&lt;p&gt;o object:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/192878/201711/192878-20171118231240796-978766808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1 object:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/192878/201711/192878-20171118231259874-1159970578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 10 object:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/192878/201711/192878-20171118231317796-1066219958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;100 object&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/192878/201711/192878-20171118231329952-984246673.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;table-wrap&quot; readability=&quot;8&quot;&gt;
&lt;h2&gt;6、总结&lt;/h2&gt;
&lt;p&gt;surging 已经完成JWT验证和AppSecret验证，下篇文章会详细介绍surging 身份认证，如感兴趣请多关注或者加入QQ群：615562965&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Sat, 18 Nov 2017 15:23:00 +0000</pubDate>
<dc:creator>fanly11</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanliang11/p/7858371.html</dc:identifier>
</item>
<item>
<title>python 中 urlparse 模块介绍 - 菜鸡_堃</title>
<link>http://www.cnblogs.com/xie-kun/p/7858358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xie-kun/p/7858358.html</guid>
<description>&lt;p&gt;urlparse模块主要是用于解析url中的参数  对url按照一定格式进行 拆分或拼接 &lt;/p&gt;
&lt;p&gt;1.urlparse.urlparse&lt;/p&gt;
&lt;p&gt;将url分为6个部分，返回一个包含6个字符串项目的元组：协议、位置、路径、参数、查询、片段。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import urlparse
url_change = urlparse.urlparse('https://i.cnblogs.com/EditPosts.aspx?opt=1')
print url_change
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果为：&lt;/p&gt;
&lt;p&gt;ParseResult(scheme='https', netloc='i.cnblogs.com', path='/EditPosts.aspx', params='', query='opt=1', fragment='')&lt;/p&gt;
&lt;p&gt;其中 scheme 是协议  netloc 是域名服务器  path 相对路径  params是参数，query是查询的条件&lt;/p&gt;

&lt;p&gt;urlparse.parse_qs(urlparse.urlparse(url).query)&lt;/p&gt;
&lt;p&gt;这个是获取urlparse分割后元祖中的某一项  urlparse.urlparse(url).query   获取查询条件&lt;/p&gt;
&lt;p&gt;parse_qs 有几种实现&lt;/p&gt;
&lt;p&gt;urlparse.parse_qs 返回字典&lt;br/&gt;urlparse.parse_qsl 返回列表&lt;/p&gt;

&lt;p&gt;2. urlparse.urlsplit&lt;/p&gt;
&lt;p&gt;和urlparse差不多，将url分为5部分，返回一个包含5个字符串项目的元组：协议、位置、路径、查询、片段。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urlparse
url_change &lt;/span&gt;= urlparse.urlsplit(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://i.cnblogs.com/EditPosts.aspx?opt=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; url_change
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SplitResult(scheme='https', netloc='i.cnblogs.com', path='/EditPosts.aspx', query='opt=1', fragment='')&lt;/p&gt;
&lt;p&gt;其中 scheme 是协议  netloc 是域名服务器  path 相对路径 query是查询的条件 &lt;/p&gt;

&lt;p&gt;3.urlparse.urljoin&lt;/p&gt;
&lt;p&gt;将相对的地址组合成一个url，对于输入没有限制，开头必须是http://，否则将不组合前面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urlparse
new_url &lt;/span&gt;= urlparse.urljoin(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://baidu.com/ssss/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;88888&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; new_url
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出 https://baidu.com/ssss/88888&lt;/p&gt;
&lt;p&gt;如果输入错误信息 如  new_url = urlparse.urljoin('122','88888')    并不会将两者合并   输出‘88888’&lt;/p&gt;

&lt;p&gt;最后一点 urlparse 这个模块在 python 3.0 中 已经改名为 urllib.parse  &lt;/p&gt;
&lt;p&gt;官方文档地址  http://docs.python.org/library/urlparse.html&lt;/p&gt;

</description>
<pubDate>Sat, 18 Nov 2017 15:19:00 +0000</pubDate>
<dc:creator>菜鸡_堃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xie-kun/p/7858358.html</dc:identifier>
</item>
<item>
<title>别想太多，去做吧 - wangjia_yql</title>
<link>http://www.cnblogs.com/wdado/p/do_it_now.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wdado/p/do_it_now.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;想太多&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　发现自己真是有好多想做事情。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　想坚持写博客。可是，半年来输出没几篇，反倒一直在纠结该在哪个博客平台写，嫌这个平台技术烂，嫌这个平台展示难看，搞半天最后自己买域名买服务器搭了个 Hexo 。一年的服务器，都快到期，自己却没写几篇文章，你说我是继续续服务器呢？还是。。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　想运营一个公众号，半年前申请了，当天趁热写了点东西，再也没后文了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　想学一门新语言，很早之前就有这个想法，去年想学学PHP，今年想学 GO。中间还纠结过到底学什么语言好，几乎每个月都去看知乎编程语言的评价撕逼，对每种语言的优缺点倒是有了大致的了解。新语言的学习却一直提不上日程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;想学一学前端，想学学PS，想学学摄影……&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;恍然大悟&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span&gt;　　某天刷知乎，问题用哪个平台写技术博客比较好。看到一个回答大概是，先写出来再说。我恍然大悟，问题的核心是去写，而不是博客平台啊。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;好吧，反思一下，自己是什么情况呢？想太多，做太少，典型的空想派！不要一直去想啊想，先动手啊。先解决核心的东西，再去 care 其他的次要的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;去做吧&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　那就先从博客这个事情开始吧。我决定先把焦点放在写上，我选择了博客园。开源中国和CSDN都用过一段时间，个人觉得广告多、展示效果一般，没什么好感。AWS 的 Hexo 需要倒腾，有服务器成本、维护成本、不容易被人看到、不容易评论交流等等，好吧，先停用了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　写博客，博客园做主体，同步到微信公众号，暂定每周一篇，共勉。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 18 Nov 2017 14:32:00 +0000</pubDate>
<dc:creator>wangjia_yql</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wdado/p/do_it_now.html</dc:identifier>
</item>
<item>
<title>机器学习之支持向量机（一）：支持向量机的公式推导 - 追寻的鹿</title>
<link>http://www.cnblogs.com/pursued-deer/p/7857306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pursued-deer/p/7857306.html</guid>
<description>&lt;p&gt;&lt;strong&gt;注：关于支持向量机系列文章是借鉴大神的神作，加以自己的理解写成的；若对原作者有损请告知，我会及时处理。转载请标明来源。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;序：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我在支持向量机系列中主要讲支持向量机的公式推导，第一部分讲到推出拉格朗日对偶函数的对偶因子α；第二部分是SMO算法对于对偶因子的求解；第三部分是核函数的原理与应用，讲核函数的推理及常用的核函数有哪些；第四部分是支持向量机的应用，按照机器学习实战的代码详细解读。&lt;/p&gt;
&lt;h2&gt;1 认识向量机&lt;/h2&gt;
&lt;p&gt;支持向量机是处理数据分类问题，目的是学会一个二分类的函数模型，属于监督式学习的方法，被广泛应用于统计分类和回归分析。通过建立一个超平面对样本数据进行分类，超平面涉及到凸优化及核函数的应用，而对于怎么找到最优的超平面就是这部分要讲的内容。&lt;/p&gt;
&lt;h2&gt;2 线性分类&lt;/h2&gt;
&lt;p&gt;假设数据样本集是线性可分，即存在一个超平面将其分成两类。以下推导的过程都是基于线性可分，非线性分类是在线性分类加上一个松弛因子，下面开始线性分类的推导。&lt;/p&gt;
&lt;h3&gt;2.1 线性分类的标号&lt;/h3&gt;
&lt;p&gt;在之前的Logistic 回归算法中，我们是把数据分成 0 和 1 ，而这里为了以后的推导式子的通用性，采用 -1 和 1 两类。分类函数为 f (x) = ω&lt;sup&gt;T&lt;/sup&gt;x + b ,其中 ω = （ω&lt;sub&gt;1&lt;/sub&gt; ，ω&lt;sub&gt;2 &lt;/sub&gt;，... , ω&lt;sub&gt;n&lt;/sub&gt;），x = (x&lt;sub&gt;1&lt;/sub&gt;, x&lt;sub&gt;2&lt;/sub&gt; , ... ,x&lt;sub&gt;n&lt;/sub&gt;)。通俗的讲支持向量机的解决的问题是找到最好的分类超平面，例如，在二维平面中其超平面就是一根直线，如下图所示在能将两类分开的直线中找到最佳的直线。评判直线的最佳的标准是：在能分类的情况下，样本点与直线的距离越远，说明直线就越佳。这就引出函数间隔和几何间隔对选取的直线的评判。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118134619796-728710137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2 函数间隔和几何间隔&lt;/h3&gt;
&lt;p&gt;  一般而言，一个点距离超平面的远近可以表示为分类预测的确信或准确程度。在超平面 w&lt;sup&gt;T&lt;/sup&gt;x+b=0 确定的情况下，|w&lt;sup&gt;T&lt;/sup&gt;x+b| 能够相对的表示点x到距离超平面的远近，而 w&lt;sup&gt;T&lt;/sup&gt;x+b 的符号与类标记 y 的符号是否一致表示分类是否正确，所以，可以用量 y(w&lt;sup&gt;T&lt;/sup&gt;x+b) 的正负性来判定或表示分类的正确性和确信度。即，y(w&lt;sup&gt;T&lt;/sup&gt;x+b) &amp;gt; 0 时分类正确；y(w&lt;sup&gt;T&lt;/sup&gt;x+b) &amp;lt; 0 时分类错误。&lt;/p&gt;
&lt;h4&gt;2.2.1 函数间隔&lt;/h4&gt;
&lt;p&gt; 超平面 f ( x ) 关于样本点（x &lt;sup&gt;(i)&lt;/sup&gt; , y &lt;sup&gt;(i)&lt;/sup&gt;）的函数间隔：&lt;span id=&quot;MathJax-Span-321&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-337&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-338&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-339&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-340&quot; class=&quot;munderover&quot;&gt;&lt;span id=&quot;MathJax-Span-341&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-342&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-343&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-344&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-345&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-346&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-347&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-348&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-349&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-350&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-351&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-352&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-353&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-354&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-355&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-356&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-357&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-358&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-359&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-360&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-361&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-362&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-363&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-364&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-365&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-366&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-367&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-368&quot; class=&quot;mi&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118141015546-1388234786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于样本集中的每个样本点都与超平面有函数间隔，但只能选取最小值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118141210968-1378448597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118141538562-1468937624.png&quot; alt=&quot;&quot; width=&quot;16&quot; height=&quot;21&quot;/&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-55-Frame&quot; class=&quot;MathJax&quot;&gt;是为了最大化间隔，&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118141538562-1468937624.png&quot; alt=&quot;&quot; width=&quot;16&quot; height=&quot;21&quot;/&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-56-Frame&quot; class=&quot;MathJax&quot;&gt;表示关于超平面与训练集中样本的函数间隔最小值，下面只要最大化&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118141538562-1468937624.png&quot; alt=&quot;&quot; width=&quot;16&quot; height=&quot;21&quot;/&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-57-Frame&quot; class=&quot;MathJax&quot;&gt;即可。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-55-Frame&quot; class=&quot;MathJax&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-56-Frame&quot; class=&quot;MathJax&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-57-Frame&quot; class=&quot;MathJax&quot;&gt;注意到函数间隔实际上并不能表示点到超平面的距离，因为当超平面&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-58-Frame&quot; class=&quot;MathJax&quot;&gt;&lt;span id=&quot;MathJax-Span-427&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-428&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-429&quot; class=&quot;mo&quot;&gt;(ω&lt;span id=&quot;MathJax-Span-430&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-431&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-432&quot; class=&quot;mi&quot;&gt;b&lt;span id=&quot;MathJax-Span-433&quot; class=&quot;mo&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;参数扩大相同的倍数后，如&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-59-Frame&quot; class=&quot;MathJax&quot;&gt;&lt;span id=&quot;MathJax-Span-434&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-435&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-436&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-437&quot; class=&quot;mn&quot;&gt;2ω&lt;span id=&quot;MathJax-Span-438&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-439&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-440&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-441&quot; class=&quot;mi&quot;&gt;b&lt;span id=&quot;MathJax-Span-442&quot; class=&quot;mo&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，超平面的位置并没有改变，但是函数间隔也变大了相同的倍数&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-60-Frame&quot; class=&quot;MathJax&quot;&gt;&lt;span id=&quot;MathJax-Span-443&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-444&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-445&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-446&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-447&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-448&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-449&quot; class=&quot;munderover&quot;&gt;&lt;span id=&quot;MathJax-Span-450&quot; class=&quot;mi&quot;&gt;γ&lt;span id=&quot;MathJax-Span-451&quot; class=&quot;mo&quot;&gt;^&lt;span id=&quot;MathJax-Span-452&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-453&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-454&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-455&quot; class=&quot;mi&quot;&gt;i&lt;span id=&quot;MathJax-Span-456&quot; class=&quot;mo&quot;&gt;)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt; 2.2.2 几何间隔&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118141943999-962485598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，样本点A的坐标为 x &lt;sup&gt;(i)&lt;/sup&gt; ，A 到超平面的垂直距离为 γ&lt;sup&gt;(i)&lt;/sup&gt; ，超平面的单位法向量是 ω / || ω || ，B点是超平面上一点且是A点的投影，则 B 点的坐标 x&lt;sup&gt;(i)&lt;/sup&gt; - γ&lt;sup&gt;(i)&lt;/sup&gt; ω / || ω || ，将其带入超平面方程 f (x) = ω&lt;sup&gt;T&lt;/sup&gt; x + b =0 .&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118143412281-1752151781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果分类正确，则 y&lt;sup&gt;(i)&lt;/sup&gt; 与 f( x&lt;sup&gt;(i)&lt;/sup&gt;) 符号相同，几何间隔是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118143711562-1860381032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;超平面与样本集的几何间隔是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118143849171-663106261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上所述，函数间隔与几何间隔的关系有：&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118144024827-2142019561.png&quot; alt=&quot;&quot;/&gt; ， 若|| ω || = 1，那么函数间隔与几何间隔相同。&lt;/p&gt;
&lt;h3&gt;2.3 间隔最大化&lt;/h3&gt;
&lt;p&gt;现在又进一步，由原来的求一个超平面到现在求超平面的最大间隔。通过函数间隔与几何间隔的定义知利用几何间隔衡量最佳的标准是合适的，因为几何间隔是真正意义上的距离，如同我们求点到平面的距离一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118145444218-904646687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来再介绍一个概念：支持向量。如下图所示，假设中间的红线是超平面，那么虚线上的样本点就是支持向量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118150614312-1673897115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样一来，我们就可以定义间隔最大化：&lt;/p&gt;
&lt;p&gt;                                           max &lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118150309906-1592430497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;需要满足的条件是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118150109906-610404131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 间隔的有效的样本点是支持向量的点，即是&lt;strong&gt;符合函数间隔等于 1 的点&lt;/strong&gt;。那么就可以对间隔的最大化可以为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118150851249-549193610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，s.t.，即subject to的意思，它导出的是约束条件。&lt;/p&gt;
&lt;h3&gt;2.4 向对偶问题转化&lt;/h3&gt;
&lt;p&gt; 由上面的式子经过变化，得到凸优化问题，即 将max 1/ || ω || 转化成求 min 1/2 || ω || &lt;sup&gt;2&lt;/sup&gt; ，两者是等价的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118151826077-134288371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转化到这个形式后，我们的问题成为了一个凸优化问题，或者更具体的说，因为现在的目标函数是二次的，约束条件是线性的，所以它是一个凸二次规划问题。这个问题可以用任何现成的QP的优化包进行求解，归结为一句话即是：&lt;strong&gt;在一定的约束条件下，目标最优，损失最小。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了用解决QP问题的常规方法之外，还可以通过求解对偶问题得到最优解，这就是线性可分条件下支持向量机的对偶算法，这样做的优点在于：一者对偶问题往往更容易求解；二者可以自然的引入核函数，进而推广到非线性分类问题。&lt;/p&gt;
&lt;p&gt;现在要对凸优化进行求解，现在给出的经验求解方法是，通过求解对偶问题得到最优解。对偶问题是什么?这就要引出拉格朗日函数，将约束条件融合到目标函数中，通过给每个约束条件加上一个拉格朗日乘子 α 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118153233140-426917280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118153323171-434635767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们的目标函数变成了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118153500109-1897521300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对这个公式的理解：在满足约束条件（即样本点为支持向量）下，最大的几何间隔中取最小的值。max L(w,b,a) 是得到支持向量的样本点，然后再这些样本点中找到min 1/2 || w ||&lt;sup&gt;2 &lt;/sup&gt;的最小值（最大间隔）。&lt;/p&gt;
&lt;p&gt;注意了，对偶问题出来了（p* 是原来的问题，d* 是对偶问题），将最小最大的位置交换，得到下面的式子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118154505546-1022778467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;交换之后的问题就不等价了，有以下关系：d* &amp;lt;= p* 。但在满足某些条件下（KKT条件），两者是相等的。现在我们把对偶问题得出了，但怎么对偶问题进行求解呢？继续向下看，最终的目标式子就要出来了。&lt;/p&gt;
&lt;h3&gt;2.5 对偶问题的求解&lt;/h3&gt;
&lt;p&gt; 上述可知，原来问题与对偶问题的等价条件是满足某些条件，条件就是KKT 。不知道KKT 条件没关系，现在你只需要明白原来问题是满足KKT条件，KKT 条件在核函数中讲解。而求解这个对偶学习问题，分为3个步骤：1、让L（ω, b,  α）关于 ω 和 b 的最小化；2、求 α 的极大；3、利用SMO算法求解对偶因子（α）。这里主要讲1 和 2 ，步骤 3 在第二部分讲。&lt;/p&gt;
&lt;p&gt;步骤 1 ： 固定 α ，然后L（ω, b,  α）对 ω 、b 求偏导，另其偏导数等于零。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118161405999-1059000818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把结果带入L：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118161447593-1332022133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118161510906-764611694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的推导过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118161623374-974415436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤2 ：对 α 求极大，通过步骤 1 已经把 变量 ω 、b  消去，函数只有 α。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118162056468-263717091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们把对偶因子求出，那么我们就可以得到最佳的超平面 f (x) = ω&lt;sup&gt;T&lt;/sup&gt; x + b ;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118162432187-1056909560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b 根据KKT条件 ，α&lt;sub&gt;i&lt;/sub&gt; [ y&lt;sup&gt;(i)&lt;/sup&gt;(ω&lt;sup&gt;T&lt;/sup&gt;x&lt;sup&gt;(i)&lt;/sup&gt; + b ) -1] =0, i =1, 2 ,..., m ，其中必然存在一个αj 不等于0 ，y&lt;sup&gt;(j)&lt;/sup&gt;(ω&lt;sup&gt;T&lt;/sup&gt;x&lt;sup&gt;(j)&lt;/sup&gt; + b )=1 ,两边同乘以 y&lt;sup&gt;(j) &lt;/sup&gt;可得：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b = y&lt;sup&gt;(j)&lt;/sup&gt; - Σ&lt;sub&gt;i=1&lt;/sub&gt;&lt;sup&gt;m&lt;/sup&gt;α&lt;sub&gt;i&lt;/sub&gt; y&lt;sup&gt;(i)&lt;/sup&gt; x&lt;sup&gt;(i)&lt;/sup&gt;x&lt;sup&gt;(j)  , 也可以对所有满足条件的b加权平均。&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到这里我们把目标函数 f(x) 的求解转化成对对偶因子的求解，正如 July 大神总结的一样。下部分对SMO算法求解过程的推导。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1231022/201711/1231022-20171118164506577-427094200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;支持向量机通俗导论（理解SVM的三层境界）http://blog.csdn.net/macyang/article/details/38782399/&lt;/p&gt;
&lt;p&gt;【机器学习详解】SVM解二分类,多分类,及后验概率输出 &lt;a href=&quot;http://blog.csdn.net/luoshixian099/article/details/51073885&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/luoshixian099/article/details/51073885&lt;/a&gt; &lt;/p&gt;

</description>
<pubDate>Sat, 18 Nov 2017 14:02:00 +0000</pubDate>
<dc:creator>追寻的鹿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pursued-deer/p/7857306.html</dc:identifier>
</item>
<item>
<title>使用MS Test做单元测试 - Yang-Fei</title>
<link>http://www.cnblogs.com/yang-fei/p/7858078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yang-fei/p/7858078.html</guid>
<description>&lt;p&gt;声明：本篇博客翻译自：http://www.c-sharpcorner.com/article/unit-testing-with-ms-tests-in-c-sharp/&lt;/p&gt;
&lt;p&gt;写在翻译之前：&lt;/p&gt;
&lt;p&gt;依然清晰的记得刚工作的第一个项目中，在完成一个功能模块开发后，师傅让我把代码做一下单元测试。当时一脸“懵懂”。心里的疑惑油然而生，测试不应该是测试人员做的吗？然后就写了一些测试用例把功能简单过了一遍。过了几天后，师傅问我单元测试完成了吗？我很自信的告诉师傅搞定了。师傅让我把单元测试的代码提交到服务器上，他想Review一下！我更加疑惑了，对师傅说，单元测试还要写代码呀？:(&lt;/p&gt;
&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;很多初级开发工程师都会有这样的困惑：谁应该来做单元测试。单元测试应该是由开发者来完成的。&lt;/p&gt;
&lt;h2&gt;单元测试：&lt;/h2&gt;
&lt;p&gt;通过一些代码来测试一个方法/函数的行为。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/622438/201711/622438-20171118205640718-799324396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;为什么需要单元测试：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通常情况下，一个软件项目会长期运行/维护/更新，这个时间至少也会有5年的时间；&lt;/li&gt;
&lt;li&gt;在这期间，维护这个程序非常重要；&lt;/li&gt;
&lt;li&gt;任何一个代码的改动都有可能会影响程序的其他功能模块；&lt;/li&gt;
&lt;li&gt;因此在更新程序之间，会需要做大量的回归测试(Regression Testing)，这将花费测试工程师大量的时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;想象一下如果代码修改需要非常频繁，那么花费在回归测试上的精力会非常多，同样的，也会有很大的几率捕捉到功能回退(修改缺陷)的问题。&lt;/p&gt;
&lt;p&gt;回归测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/622438/201711/622438-20171118211503327-1570664601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回归测试是确保当增加了新的修改后，老的功能依旧可以正常使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单元测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/622438/201711/622438-20171118211518796-232999404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单元测试将会最小化回归测试的范围：&lt;/li&gt;
&lt;li&gt;每一个方法/函数都会被一系列的测试方法覆盖，这些测试方法将测试真实方法的功能；&lt;/li&gt;
&lt;li&gt;测试方法会检查下面的场景/行为：
&lt;ul&gt;&lt;li&gt;成功/正常流程&lt;/li&gt;
&lt;li&gt;失败&lt;/li&gt;
&lt;li&gt;异常/错误处理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一个方法可能需要多个测试方法，这取决于测试方法的复杂度；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在代码交付之前，开发者需要确保所有的测试方法均运行通过&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TDD:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/622438/201711/622438-20171118211547374-1216338466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在写产品代码之前先写单元测试代码，然后使用产品代码来填充/覆盖测试代码。最终使测试代码都运行通过。&lt;/p&gt;
&lt;h2&gt;编写测试用例：&lt;/h2&gt;
&lt;p&gt;在C#中有2个测试框架&lt;/p&gt;
&lt;p&gt;我们使用AAA模式来编写单元测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/622438/201711/622438-20171118213316484-458507038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安排所以必须的前置条件和输入；&lt;/li&gt;
&lt;li&gt;在测试代码中操作被测试对象和方法；&lt;/li&gt;
&lt;li&gt;断言期待的结果；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;右击解决方案浏览器，选择Unit Test Project并添加：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/622438/201711/622438-20171118214934421-1119040909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Employee类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class Employee
    {
        public string GetName(string firstName, string lastName)
        {
            return string.Concat(firstName, &quot; &quot;, lastName);
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 单元测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    [TestClass]
    public class EmpoyeeFunctionalTest
    {
        [TestMethod]
        public void GetNameTest()
        {
            // Arrange
            Employee employee = new Employee();
            string firstName = &quot;Jimmy&quot;;
            string lastName = &quot;Yang&quot;;
            string expacted = &quot;Jimmy Yang&quot;;
            string actual = string.Empty;

            // Act
            actual = employee.GetName(firstName, lastName);

            // Assert
            Assert.AreEqual(expacted, actual);
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 希望上述内容能够帮助你对单元测试有一个概念性的认识。&lt;/p&gt;
&lt;p&gt;感谢您的阅读！翻译的不到位之处还望指正。谢谢~&lt;/p&gt;

</description>
<pubDate>Sat, 18 Nov 2017 13:53:00 +0000</pubDate>
<dc:creator>Yang-Fei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yang-fei/p/7858078.html</dc:identifier>
</item>
<item>
<title>虚拟化技术总览 - bakari</title>
<link>http://www.cnblogs.com/bakari/p/7857967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bakari/p/7857967.html</guid>
<description>&lt;h2 id=&quot;虚拟化本质上是软硬件层的抽象&quot;&gt;虚拟化本质上是软/硬件层的抽象&lt;/h2&gt;
&lt;p&gt;说起虚拟化，相信大家应该都不陌生，像虚拟内存、Java 虚拟机、Android 模拟器这些都是虚拟化技术的体现，为什么这样说，这个就要回到虚拟化技术的本质上——&lt;strong&gt;虚拟化就是由位于下层的软件模块，根据上层的软件模块的期待，抽象（虚拟）出一个虚拟的软件或硬件模块，使上一层软件直接运行在这个与自己期待完全一致的虚拟环境上&lt;/strong&gt;。从这个意义上来看，虚拟化既可以是软件层的抽象，又可以是硬件层的抽象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201711/431521-20171118211032656-1003535650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以说，像虚拟内存、Java 虚拟机、Android 模拟器这些都属于是软件虚拟化技术，而硬件虚拟化技术更多的应用就是在云计算领域。从提出至今，虚拟化技术已经出现了多种实现方式，这些不同的方式其实就是软件和硬件的不同组合。本文主要就是对这些实现方式进行一个总览，形成一个总体认识，方便后面的学习。&lt;/p&gt;
&lt;h2 id=&quot;vmm&quot;&gt;VMM&lt;/h2&gt;
&lt;p&gt;VMM 全称是 Virtual Machine Monitor，虚拟机监控系统，也叫 Hypervisor，是虚拟化层的具体实现。主要是以软件的方式，实现一套和物理主机环境完全一样的虚拟环境，物理主机有的所有资源，包括 CPU、内存、网络 IO、设备 IO等等，它都有。这样的方式相当于 VMM 对物理主机的资源进行划分和隔离，使其可以充分利用资源供上层使用。虚拟出的资源以虚拟机的形式提供服务，一个虚拟机本质上和一台物理机没有什么区别，可以跑各种操作系统，在之上再跑各种应用。这种方式无疑是计算机历史上非常里程碑的一步，你想想，以前可能要买多台服务器才能解决的事，现在只用一台就解决了。&lt;/p&gt;
&lt;p&gt;虚拟机通常叫做&lt;strong&gt;客户机（guest）&lt;/strong&gt;，物理机叫&lt;strong&gt;宿主机（host）&lt;/strong&gt;，VMM 处在中间层，既要负责对虚拟资源的管理，包括虚拟环境的调度，虚拟机之间的通信以及虚拟机的管理等，又要负责物理资源的管理，包括处理器、中断、内存、设备等的管理，此外，还要提供一些附加功能，包括定时器、安全机制、电源管理等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201711/431521-20171118211251093-803195240.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;vmm-分类&quot;&gt;VMM 分类&lt;/h2&gt;
&lt;p&gt;VMM 根据平台类型和实现结构有两种不同的分类，按平台类型可以分为&lt;strong&gt;完全虚拟化&lt;/strong&gt;和&lt;strong&gt;类虚拟化&lt;/strong&gt;，完全虚拟化就是 VMM 完全模拟出一个跟物理主机完全一样的环境。但是这个是非常困难的，首先，这需要硬件的支持，而硬件在初期设计的时候，没有那么远的前瞻性，可以预想到为虚拟化提供支持，前次，指令的复杂性，即使通过模拟的方式也很难做到全部指令都模拟。所以，就需要借助其他的一些技术来辅助虚拟化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201711/431521-20171118211323390-1856281936.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件辅助虚拟化&lt;/strong&gt;是通过优先级压缩（Ring Compression）和二进制代码翻译（Binary Translation）这两个技术来完成的。简单讲，RC 基于 CPU 特权级的原理，也就是 guest、VMM 和 host 分别处于不同的特权级上（这个后面讲 CPU 虚拟化的时候会详述），guest 要访问 host 就属于越级访问，会抛异常，这时 VMM 会截获这个异常，并模拟出其可能的行为，从而进行相应处理。但这个问题很明显，就是由于硬件设计的缺陷，有些指令并不能截获，从而导致“漏洞”。&lt;/p&gt;
&lt;p&gt;BT 可以弥补这个缺陷，它通过去扫描 guest 的二进制的代码，将难以虚拟化的指令转为支持虚拟化的指令，从而可以配合 VMM 完成虚拟化功能。这两种方式都是通过「打补丁」的方式来辅助虚拟化，很难再架构上保证完整性。&lt;/p&gt;
&lt;p&gt;所以，后期的硬件厂商就在硬件上对虚拟化提供了支持，有了&lt;strong&gt;硬件辅助的虚拟化&lt;/strong&gt;。通过对硬件本身加入更多的虚拟化功能，就可以截获更多的敏感指令，填补上漏洞。在这一块，Intel 的 VT-x/d 技术和 AMD 的 AMD-V 技术是其中的代表。&lt;/p&gt;
&lt;p&gt;而类虚拟化则是另外一种通过软件来避免漏洞的方式，就是通过修改 guest 操作系统内核代码（API 级）来避免漏洞，这种方式好处就是可以自定义内核的执行行为，某种程度上对性能进行优化。&lt;/p&gt;
&lt;p&gt;上面这种分类仅供了解即可，重点掌握下面这种分类，就是根据 VMM 的实现结构分类，主要分类** Hypervisor 模型（1 型）&lt;strong&gt;和&lt;/strong&gt;宿主模型（2 型）**。&lt;/p&gt;
&lt;p&gt;Hypervisor 模型中 VMM 既是操作系统，也是虚拟化软件，也就是集成了虚拟化功能的操作系统，对上为 guest 提供虚拟化功能，对下管理着所有物理资源，它的优点就是效率高，虚拟机的安全性只依赖于 VMM，缺点就是管理所有的物理资源，意味着 VMM 要承担很多的开发工作，特别是驱动层面的开发，我们知道硬件的 I/O 设备是很多的，这些设备都要有对应的驱动来设配才能为虚拟机提供功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201711/431521-20171118211350531-96650221.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;宿主模型剥离了管理功能和虚拟化功能，虚拟化功能只是作为内核的一个模块来加载，比如 KVM 技术就是其中的佼佼者，KVM 技术可以说是云计算最核心的技术了，后面会经常用到。一般 KVM 只负责 CPU 和内存的虚拟化，I/O 的虚拟化则由另外一个技术来完成，即 Qemu。这些技术都是后面的重点，在这里只是提一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201711/431521-20171118211406062-1954917.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;典型虚拟化产品&quot;&gt;典型虚拟化产品&lt;/h2&gt;
&lt;p&gt;VMware 可以说是虚拟化的鼻祖，现在很多公司都是在模仿 VMware 的产品，相应用过 VMware 虚拟机的朋友应该不陌生了，VMware 提供了很多的虚拟化产品，从服务器到桌面都有很多应用。主要有面向企业级应用的 ESX Server，面向服务端的入门级产品 VMware Server，面向桌面的主打产品 VMware Workstation（这个相信大家经常用），面向苹果系统的桌面产品 VMware Fusion，还有提供整套虚拟应用产品的 VMware vSphere，细分的话还有 VMware vStorage（虚拟存储），VMware vNet（虚拟网络）等。&lt;/p&gt;
&lt;p&gt;Xen 是一款开源虚拟机软件，Xen 结合了 Hypervisor 模型和宿主模型，属于一种混合的虚拟化模型，基于 Xen 的虚拟化产品也有很多，比如 Ctrix、VirtualIron、RedHat 和 Novell 等都有相应的产品。这个一般是研究机构用得多一些，生产环境中大部分用的是 KVM。&lt;/p&gt;
&lt;p&gt;KVM 也是一款开源软件，于 2007 年 2 月被集成到了 Linux 2.6.20 内核中，成为了内核的一部分。KVM 采用的是基于 Intel VT 的硬件辅助虚拟化技术，以及结合 Qemu 来提供设备虚拟化，从实现上看，属于宿主模型。使用 KVM 的厂商很多啊，像我们比较熟悉 VMware Workstation 和 VirtualBox 都在使用，在此就不一一列举了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对云计算感兴趣的小伙伴可以关注我的微信公众号：云计算小白，专注云计算领域，坚持分享干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201711/431521-20171118211625046-1857616046.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 Nov 2017 13:33:00 +0000</pubDate>
<dc:creator>bakari</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bakari/p/7857967.html</dc:identifier>
</item>
<item>
<title>Android Weekly Notes Issue #283 - 圣骑士wind</title>
<link>http://www.cnblogs.com/mengdd/p/android-weekly-notes-issue-283.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengdd/p/android-weekly-notes-issue-283.html</guid>
<description>&lt;p&gt;November 12th, 2017&lt;/p&gt;

&lt;p&gt;本期内容包括Gradle相关的几篇,如封装繁杂依赖的技巧,通过kotlin dsl让gradle支持kotlin,以及gradle入门指南等,还包括RxJava2的迁移介绍,以及关于IoT,图片压缩,Security相关的文章.&lt;br/&gt;AS3.0也正式发布,feature满满,Firebase退出了Rx版本,Kata 测试教程也放出Kotlin版本供大家学习.&lt;/p&gt;
&lt;h2 id=&quot;articles-tutorials&quot;&gt;ARTICLES &amp;amp; TUTORIALS&lt;/h2&gt;

&lt;p&gt;文章介绍了RxJava2的一些变化,如新的类型(Completable,Single,Maybe),Test Observable,特别值得注意的是&lt;code&gt;ErrorHandling&lt;/code&gt;,之前RxJava1可以通过&lt;code&gt;registerErrorHandler&lt;/code&gt;注册,但是只有监听功能,无法Hook(如OnErrorNotImplementedException),程序该崩还得崩.&lt;/p&gt;
&lt;p&gt;新版本通过&lt;code&gt;RxJavaPlugins.setErrorHandler&lt;/code&gt;可以router到所有Rx流中产生的任何异常,包括在onNext/onSuccess中产生的异常,以及没有实现onError发生错误产生的异常.&lt;/p&gt;
&lt;p&gt;值得注意的是,RxJava1会在Rx流结束或者Cancel后吃掉所有后续产生的Throwable,但是RxJava2将会依旧发射错误,这点需要注意,之前不不崩溃的程序可能会出问题,最好自己设置一个handler来catch.&lt;/p&gt;

&lt;p&gt;文章介绍了Hackster.io联合Google搞的一个IoT的比赛,介绍了几个好的创意,如办公室监控,都是字母的表,监控狗狗睡眠的床等等,比较有趣.包含每个项目的Detail信息的链接.&lt;/p&gt;

&lt;p&gt;文章介绍了如何整理与简化我们gradle里面大量的dependencies,安装feature进行划分比较清晰,然后再利用&lt;code&gt;closure delegate&lt;/code&gt;封装,使得&lt;code&gt;implementation&lt;/code&gt;这个关键字可以在我们定义的函数中使用,将我们的dependencies改成大概这个样子.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dependencies {
  ui()
  network()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于如何用&lt;code&gt;closure delegate&lt;/code&gt;定义&lt;code&gt;ui&lt;/code&gt;与&lt;code&gt;network&lt;/code&gt;可以查看作者原文.&lt;/p&gt;

&lt;p&gt;上期有篇文章讲了软硬加速的一些知识,这篇文章讨论Shader(RadialGradient)与Hardware/Software Layer相关的知识.&lt;/p&gt;

&lt;p&gt;Gradle推出了对Kotlin的支持,&lt;code&gt;gradle-kotlin-dsl&lt;/code&gt;,可以用kotlin来写你的gradle文件了,但是由于文档很少很少,作者写了一个demo来帮助大家.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你需要将你的gradle升级到最新.&lt;/li&gt;
&lt;li&gt;你需要给build.gradle加上一个.kts的后缀&lt;/li&gt;
&lt;li&gt;你可以在buildSrc文件夹里面定义一些kotlin类,将一些string的定义放进去,取代之前的&lt;code&gt;ext{...}&lt;/code&gt;的写法.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者介绍了Rx2Firebase的推出对于使用Firebase online database用户带来的福音,再也不用被嵌套回调烦扰.&lt;/p&gt;

&lt;p&gt;文章介绍了如何在FirebaseConsole看到Crashlytics(Fibric),其实就是把你的firic的依赖删掉,换成firebase.&lt;/p&gt;
&lt;p&gt;需要注意的是,他没有数据的migrate,所以fibric上的不会出现在firebase里面.&lt;/p&gt;

&lt;p&gt;文章介绍了Gradle的基本常识,包括每一个block的作用,很适合初学者学习,包括root的build.gradle,以及每一个子项目的build.gradle.&lt;/p&gt;

&lt;p&gt;文章是一个安全系列文章的第三篇,介绍了如何通过&lt;code&gt;KeyguardManager&lt;/code&gt;来要求手机必须设置LockScreen.&lt;br/&gt;还有如何使用&lt;code&gt;Keystore&lt;/code&gt;相关方法创建公钥私钥,通过&lt;code&gt;Cipher&lt;/code&gt;进行加密解密.&lt;br/&gt;Android 18之后,秘钥都是保存在系统服务里,并随着应用的卸载而删除,不像之间必须存在本地文件,存在被extract的风险了.&lt;/p&gt;

&lt;p&gt;文章介绍了原生的&lt;code&gt;Bitmap.createScaledBitmap&lt;/code&gt;在缩放图片时候会产生锯齿,通过&lt;code&gt;BitmapFactory.decode&lt;/code&gt;配合&lt;code&gt;options.inSampleSize&lt;/code&gt;可以达到比较好的效果,但是只支持偶数被缩小,并且Bitmap必须没有解码之前.&lt;/p&gt;
&lt;p&gt;采用&lt;code&gt;RenderScript&lt;/code&gt;进行缩放,可以达到非常好的效果.但是耗时比较多,是createScaledBitmap的30倍.&lt;/p&gt;

&lt;p&gt;AS3.0正式发布,配合gradle 3.0,支持Java8 feature build-in,支持kotlin,支持Instant App...等等新的功能.&lt;/p&gt;

&lt;p&gt;Karumi将Kata挪到了kotlin上,提供了好几个sample帮助学习kotlin测试.&lt;/p&gt;
&lt;p&gt;包括Clean Architecture相关,Espresso相关,Stubbing Http相关等等.&lt;/p&gt;
&lt;h2 id=&quot;libraries-code&quot;&gt;LIBRARIES &amp;amp; CODE&lt;/h2&gt;

&lt;p&gt;优步的跨平台框架.&lt;/p&gt;

&lt;p&gt;View级别的一个BottomSheet.&lt;/p&gt;

&lt;p&gt;Firebase的Rx版本,使用online db更方便&lt;/p&gt;
</description>
<pubDate>Sat, 18 Nov 2017 12:57:00 +0000</pubDate>
<dc:creator>圣骑士wind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mengdd/p/android-weekly-notes-issue-283.html</dc:identifier>
</item>
</channel>
</rss>