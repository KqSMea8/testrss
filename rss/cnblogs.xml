<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>OpenCV基础类型 - 芳舒晴</title>
<link>http://www.cnblogs.com/Shuqing-cxw/p/9217375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Shuqing-cxw/p/9217375.html</guid>
<description>&lt;h3&gt;一、(像素)点(x,y)类型&lt;/h3&gt;
&lt;h4&gt;1.1 C语言 CvPoint结构体&lt;/h4&gt;
&lt;p&gt;CvPoint 类型是一个包含两个int类型的结构体;通常表示某像素点的坐标位置(x,y)&lt;/p&gt;
&lt;p&gt;两个变体类型：&lt;/p&gt;
&lt;p&gt;CvPoint2D32f表示该点坐标(x,y)的数据类型时浮点型；&lt;/p&gt;
&lt;p&gt;CvPoint3D32f表示该点坐标(x,y,z)的数据类型时浮点型；&lt;/p&gt;
&lt;h4&gt;1.2 C++语言  Point类&lt;/h4&gt;
&lt;p&gt;通过模板结构实现，重载了向量vector类代数操作和组合操作&lt;/p&gt;
&lt;p&gt;针对二维和三维存在两种模板结构体Point，数据类型可以为int 或者 float等等&lt;/p&gt;
&lt;p&gt;点类型最大的好处是简单开销小，我们很少对点类型数据进行数据操作，而是用于转换为更多其他的结构类型，例如向量类或者矩阵类;&lt;/p&gt;
&lt;p&gt;点类型声明：Point+维度+类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cc3fac40-7e3e-4c3c-9889-4ab397f1f78a')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_cc3fac40-7e3e-4c3c-9889-4ab397f1f78a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cc3fac40-7e3e-4c3c-9889-4ab397f1f78a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cc3fac40-7e3e-4c3c-9889-4ab397f1f78a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cc3fac40-7e3e-4c3c-9889-4ab397f1f78a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; b- unsigned &lt;span&gt;char&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; s- &lt;span&gt;short&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; i- &lt;span&gt;32&lt;/span&gt;-bit &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; f- &lt;span&gt;32&lt;/span&gt;-bit &lt;span&gt;float&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; d- &lt;span&gt;64&lt;/span&gt;-bit &lt;span&gt;float&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;类型表示&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;Point类的操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;默认构造    Point2i p1;Point3f p2;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;拷贝构造    Point3f p2(p1);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;数值初始化  Point2i p1(x0,x1);Point3f p2(x0,x1,x2);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;转换到Vector类型  (Vec3f) p;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;成员访问   p.x; p.y;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 点积运算   &lt;span&gt;float&lt;/span&gt; x =&lt;span&gt; p1.dot(p2);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 双精度点积 &lt;span&gt;double&lt;/span&gt; x =&lt;span&gt; p1.ddot(p2);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;向量积(仅适用三维)     p1.cross(p2);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;查询是否在某区域(rectangle)内(仅适用二维)     p.inside(r);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 注意： C++&lt;span&gt;Point类转换成C语言结构CvPoint需要注意浮点型数据直接转换为CvPoint会自动四舍五入(CvPoint默认类型为int)；&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二、(图像)大小类型CvSize&lt;/h3&gt;
&lt;h4&gt;2.1 C语言 CvSize结构体&lt;/h4&gt;
&lt;p&gt;CvSize 类型是一个包含两个int类型的结构体;通常表示某图像/区域的宽高大小(width, height)&lt;/p&gt;
&lt;p&gt;数据类型使用浮点型，同样显示指定CVSize2D32f&lt;/p&gt;
&lt;h4&gt;2.2 C++语言  Size类&lt;/h4&gt;
&lt;p&gt;相比Point类，&lt;/p&gt;
&lt;p&gt;1.数据成员不同，Size类成员为width 和 height&lt;/p&gt;
&lt;p&gt;2.不能转换成固定大小的Vector类，但Vector类和Point类可以转换成Size类&lt;/p&gt;
&lt;p&gt;Size类存在三种别名 Size == Size2i、Size2f&lt;/p&gt;
&lt;p&gt;Size类操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;默认构造   Size sz;Size2i sz; Size2f p2;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;拷贝构造   Size sz2(sz1);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;数值初始化   Size sz(w,h);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;成员访问   sz.width; sz.height;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 计算区域面积   sz.area();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、区域矩形大小类型CvRect&lt;/h3&gt;
&lt;h4&gt;3.1 C语言 CvRect结构体&lt;/h4&gt;
&lt;p&gt;CvRect派生于CvPoint和CvSize，包含四个int成员：x,y,width,height;&lt;/p&gt;
&lt;h4&gt;3.2 C++语言 Rect结构体&lt;/h4&gt;
&lt;p&gt;矩形类成员包含Point类成员的x，y表示矩形的左上角，Size类成员width和height表示矩形的大小，Rect类并不继承自Point或Size；&lt;/p&gt;
&lt;p&gt;Rect类操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;默认构造   Rect r;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;拷贝构造   Rect r2(r1);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;数值初始化   Rect r(x, y, w , h);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;点坐标及大小初始化构造 Rect r(p,sz);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;两点初始化构造 Rect r(p1, p2);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;成员访问   r.x; r.y; r.width; r.height;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;计算区域面积 r.area();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;提取左上角点 r.tl();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;提取右下角点 r.br();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;判断点是否在某区域内  r.contains(p);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;重载操作符对象间的运算：
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 矩形1与矩形2的交集              Rect r3 = r1 &amp;amp;&lt;span&gt; r2;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 包含矩形1与矩形2的最小矩形   Rect r3 = r1 |&lt;span&gt; r2;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 平移左上角坐标矩形大小不变    Rect r2 = r1 +&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 放大或缩小矩形大小，左上角点不变 Rect r2 = r1 +&lt;span&gt; sz;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 判断两个矩形是否相等  &lt;span&gt;bool&lt;/span&gt; eq = ( r1 == r2);&lt;span&gt;bool&lt;/span&gt; ne = ( r1 != r2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作计算演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;opencv2/core.hpp&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; cv;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     Rect r1(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     Rect r2(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     Rect r3 = r1 |&lt;span&gt; r2;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     Point p(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     Rect r4 = r1 +&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r3.width = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; r3.width &amp;lt;&amp;lt; endl    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;          &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r3.height= &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; r3.height &amp;lt;&amp;lt; endl   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;          &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r3.area  = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; r3.area() &amp;lt;&amp;lt; endl;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     cout &amp;lt;&amp;lt; r3 &amp;lt;&amp;lt; endl;                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[ 15 x 10 from (5, 5)]&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     cout &amp;lt;&amp;lt; r4 &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;四、图像像素RGBA值CvScalar&lt;/h3&gt;
&lt;h4&gt;4.1 C语言 CvScalar结构体&lt;/h4&gt;
&lt;p&gt;内部存储了四个double型的值，分别为val[0],val[1],val[2],val[3],我们通常用的是前三个，val[0],val[1],val[2]的含义分别是彩色照片的三个通道BGR。R是红色分量，G是绿色分量，B是蓝色分量，a是alpha；&lt;/p&gt;
&lt;p&gt;图像存储的矩阵大小依赖于色彩空间的选用，更准确的说取决于所使用的通道数，在灰度图像中在内存描述如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201806/1289301-20180623154151649-1095425094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于多通道图像，列包含与通道数量一样多的子列。例如，在BGR颜色系统的情况下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201806/1289301-20180623154202625-1989692970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来自：&lt;a href=&quot;https://docs.opencv.org/master/db/da5/tutorial_how_to_scan_images.html&quot; target=&quot;_blank&quot;&gt;https://docs.opencv.org/master/db/da5/tutorial_how_to_scan_images.html&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;4.2 C++语言  Scalar类&lt;/h4&gt;
&lt;p&gt;Scalar类直接继承固定大小的向量Vector类，直接支持向量类的代数操作，成员访问及其它操作特性；&lt;/p&gt;
&lt;p&gt;Scalar类的操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;默认构造      Scalar s;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;拷贝构造      Scalar s2(s1);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;数值初始化    Scalar s(x0); Scalar s(x0,x1,x2,s3);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;数组元素相乘  s1.mul(s2);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 共轭             s1.conj();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;五、补充部分&lt;/h3&gt;
&lt;h4&gt;5.1 旋转矩形类 RotatedRect类&lt;/h4&gt;
&lt;p&gt;在OpenCV C++借口中少数不使用类模板实现的类型之一&lt;/p&gt;
&lt;p&gt;相比Rect类，该类将Point2f称为中心点，Size2f称为大小，另外一个附加的float称为角度(表现为围绕中心点顺时针方向旋转的角度)&lt;/p&gt;
&lt;p&gt;RotatedRect类操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;默认构造     RotatedRect rr();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;拷贝构造     RotatedRect rr2(rr1);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;数值初始化   RotatedRect rr(p,sz,theta);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;两点初始化   RotatedRect rr(p1，p2);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;成员访问     rr.center; rr.size; rr.angle;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 返回4角点坐标 rr.points(pts[&lt;span&gt;4&lt;/span&gt;]);
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5.2固定大小矩阵类 fixed matx类&lt;/h4&gt;
&lt;p&gt;fixed matx类是针对在编译期间已知其维度的且通常处理矩阵代数运算，在栈上分配空间&lt;/p&gt;
&lt;p&gt;与其他类型的关系：&lt;/p&gt;
&lt;p&gt;matx是其他基础类型的核心；&lt;/p&gt;
&lt;p&gt;例如：fixed vector继承自fixed matrix;其它类(如Scalar类)继承自fixed vector，或者针对许多重要操作，它们都依赖于转换成fixed vector;&lt;/p&gt;
&lt;p&gt;如果对象确实是一个大型阵列，比如图像或一组大型点阵列应该使用Mat类;&lt;/p&gt;
&lt;p&gt;Matx类操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;默认构造  Matx33f m33f; Matx43d m43d;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;拷贝构造  Matx22d m22d(n22d);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;数值初始化 Matx21f m(x0,x1); Matx44d m(x0,x1,x2,x3...x15);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 全指定元素 m33f =&lt;span&gt; Matx33f::all(x);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 零矩阵     m23d =&lt;span&gt; Matx23d::zeros();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 一矩阵     m16f =&lt;span&gt; Matx16f::ones();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 单位矩阵   m33f =&lt;span&gt; Matx33f::eye();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 均匀分布矩阵 m33f =&lt;span&gt; Matx33f::randu(min, max);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 正态分布矩阵 m33f =&lt;span&gt; Matx33f::nrandu(mean, variance);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;成员访问  m(i,j), m(i)一个参数仅限于一维矩阵
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 矩阵代数运算 m1 = m0; m0*m1; m0 + m1; m0-&lt;span&gt;m1;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 数乘运算  m*a;a*m;m/a;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5.3固定大小向量类 fixed vector类&lt;/h4&gt;
&lt;p&gt;继承自fixed matrix类，可以看做matx类列数为一的别名；&lt;/p&gt;
&lt;p&gt;该类的设计，便利性在于单顺序范文成员，并定义一些通常mat&lt;/p&gt;
&lt;p&gt;&lt;span&gt;声明&lt;/span&gt;：Vec{2,3,4,6}{b,s,w,i,f,d}&lt;/p&gt;
&lt;p&gt;W- unsigned short&lt;/p&gt;
&lt;p&gt;fixed Vector类操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;默认构造   Vec2s v2s;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;拷贝构造   Vec3f u3f(v3f);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;数值初始化 Vec2f v2f(x0,x1);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;成员访问   v4f(i), v3w[i] 两种操作符都可以
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 向量积    v3f.cross(u3f);
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Written at : &lt;span&gt;2018.06&lt;/span&gt;.&lt;span&gt;23&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 23 Jun 2018 07:48:00 +0000</pubDate>
<dc:creator>芳舒晴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Shuqing-cxw/p/9217375.html</dc:identifier>
</item>
<item>
<title>对话线程 - 成天</title>
<link>http://www.cnblogs.com/chengtian/p/9217396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengtian/p/9217396.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;大部分程序员对线程这个概念印象深刻，不是在项目中用到了线程，而是来自面试官的对话。&lt;/p&gt;
&lt;p&gt;线程和进程的区别是什么？你可以回忆下你当时的答案，可以在评论去写出来大家共享自己的理解。&lt;/p&gt;
&lt;p&gt;&lt;sup&gt;&lt;sub&gt;&lt;strong&gt;&lt;span&gt;进程&lt;/span&gt;&lt;/strong&gt;&lt;/sub&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;运行中的程序实例就叫进程；也就是说一个程序加载到内存后就变成了进程。&lt;/p&gt;
&lt;p&gt;进程空间也称为地址空间。地址空间就是进程要用的所有资源。地址空间的特点自己不能做什么，只提供支持。打个比方。看过演出吗？话剧，歌剧...有个舞台，那些道具和舞台就是地址空间。这些空间本省不能发生任何动作，做动作的只能是演员。而这些演员就是我们将要讲述的线程。&lt;/p&gt;
&lt;p&gt;进程的缺点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在一个时间内只能干一件事情，如果想同时干两件或多件事情，进程就不够用了。比如：有两场电影，你想同时看，并且在不同的房间内。&lt;/li&gt;
&lt;li&gt;如果进程在执行过程中发生阻塞，例如等待输入，整个进程将挂起（暂停），而无法继续执行。这样，即使进程里面有部分工作不依赖于输入数据，也无法进行。为了解决这两个个问题，人们就发明了线程。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;进程延伸阅读。&lt;/p&gt;
&lt;p&gt;最早的操作系统人要等计算机，计算机也要等人的，那个龟速，可以想象；在到批处理的操作系统，就是解决计算机总是在等待人的下一步动作，采用先想好自己要运行的命令，列成一个清单，打印在纸带上，然后交给计算机管理员来一批一批地处理最后在把用户程序运行结果打印出来交给各个用户。。。。。感兴趣的可以看下操作系统相关书籍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449569/201806/449569-20180623145954586-32132493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;线程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道，进程是运转的程序，是为了在&lt;/span&gt;cpu&lt;span&gt;上实现多道编程而发明的一个概念。而如果让进程同时干多件事，办法只能是线程。一个进程中可以有多个线程，那么进程中的资源，线程也可以共享，也有线程本身所独显的资源。如图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/449569/201806/449569-20180623150119204-2020259768.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;

&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;上下文切换&lt;/p&gt;
&lt;p&gt; 在一个抢先式多任务系统中，操作系统小心地确保每一个线程都有机会执行。他依赖硬件的协助以及许多的簿记工作。当硬件计时器认为某个线程已经执行够久了，就会发出一个中断，于是CPU取得目前这个线程的当前状态，即把所有寄存器的内容拷贝到堆栈之中，再把它从堆栈拷贝到一个CONTEXT结构（这样便储存了线程的状态）中，以备以后在用。&lt;/p&gt;
&lt;p&gt; 要切换不谈的线程，操作系统应先切换该线程所隶属的进程的内存（即page directory 和 page tables），然后恢复该线程放在CONTEXT结构中的寄存器值，这整个过程便称为上线文切换&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建线程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    线程需要知道启动运行什么代码，所以它的构造器获取对要执行代码的一个委托。Thread &lt;span&gt;类包含需要使用&lt;/span&gt; &lt;span&gt;ThreadStart （不接收参数）&lt;/span&gt;&lt;span&gt;委托或&lt;/span&gt; &lt;span&gt;ParameterizedThreadStart （接收参数）&lt;/span&gt;&lt;span&gt;委托的构造函数；委托包装在调用&lt;/span&gt; &lt;span&gt;Start&lt;/span&gt; &lt;span&gt;方法时由新线程调用的方法。下面demo使用&lt;/span&gt;ParameterizedThreadStart 委托，然后调用Strart函数传入参数555，启动线程。新线程运行时，主线程在控制台上打印555个‘|’。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 ParameterizedThreadStart tsPara = num =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)num;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
                {
                    Console.ForegroundColor &lt;/span&gt;=&lt;span&gt; ConsoleColor.DarkGreen;
                    Console.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            };
            Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(tsPara); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;带参数&lt;/span&gt;
            thread2.Start(&lt;span&gt;555&lt;/span&gt;&lt;span&gt;);
           
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt; &lt;span&gt;555&lt;/span&gt;; i++&lt;span&gt;)
            {
                Console.ForegroundColor &lt;/span&gt;=&lt;span&gt; ConsoleColor.Red;
                Console.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出1-1&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/449569/201806/449569-20180623150457575-1992703555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    如输出所示，线程时轮流执行，分别打印x个字符，然后发生上下文切换。两个循环并行运行，而不是一个运行完了第二个才开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;线程池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 创建线程和销毁线程是一个昂贵的操作，要耗费大量的时间。由于操作系统必须调度可运行的线程并执行上线文切换，所以太多的线程还对性能不利。为了改善这个情况，clr包含了代码来管理他自己的线程池。线程池是你的应用程序能使用的线程集合。线程池内部会维护一个 操作请求队列。应用程序执行一个异步请求操作时，将一个记录项（entry）追加到线程池的队列中。线程池的代码从这个对立中提取记录项，将这个记录项派发（dispatch）给一个线程池线程。当线程池完成任务后，线程不会被销毁。相反，线程会回到线程池，在哪里进入空闲状态，等待相应另一个请求。由于线程不销毁自身，所以不在再产生额&lt;img src=&quot;file:///C:/Users/CY/AppData/Local/YNote/data/kaixincheng2007@163.com/a77e34cb674f4abf92cd526009343760/clipboard.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;9BE7F019D3A74F06BD251F8DE535DF29&quot; data-attr-org-img-file=&quot;file:///C:/Users/CY/AppData/Local/YNote/data/kaixincheng2007@163.com/a77e34cb674f4abf92cd526009343760/clipboard.png&quot;/&gt;外的性能损失；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449569/201806/449569-20180623150929047-1159462911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用ThreadPool完成上面效果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
WaitCallback callback = num =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)num;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
                {
                    Console.ForegroundColor &lt;/span&gt;=&lt;span&gt; ConsoleColor.DarkGreen;
                    Console.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }

            };

            ThreadPool.QueueUserWorkItem(callback, &lt;/span&gt;&lt;span&gt;555&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;555&lt;/span&gt;; i++&lt;span&gt;)
            {
                Console.ForegroundColor &lt;/span&gt;=&lt;span&gt; ConsoleColor.Red;
                Console.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序结果和上面线程demo输出类似，都是‘-’和 ‘|’&lt;span&gt;字符混合。如果多个不同的作业异步执行，线程池能在单处理器和多处理器计算机上获取更好的执行效率。&lt;/span&gt;&lt;span&gt;效率是通过重用线程来获得的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程池能很好的完成作业，但该作业中不可包括处理长时间运行的作业或者I/O受限的工作。否则正在排队的工作必然会延迟。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实呢.NET4.0引入了任务并行库TPL。在4.5对该API进行了轻微的改进，使用更简单。完全可以不用线程或者线程池这些技术，但是基础的知识点还是要了解下的。TPL可被认为是在线程池之上又一个抽象层，其对程序员隐藏了与线程池交互的底层代码。。。下篇一起探讨下。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Jun 2018 07:41:00 +0000</pubDate>
<dc:creator>成天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengtian/p/9217396.html</dc:identifier>
</item>
<item>
<title>如何高效的编写与同步博客（二）- 快速发布到多个渠道 - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/9217301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/9217301.html</guid>
<description>&lt;h2 id=&quot;系列目录&quot;&gt;系列目录&lt;/h2&gt;
&lt;h2 id=&quot;一.前言&quot;&gt;一.前言&lt;/h2&gt;
&lt;p&gt;我们使用Markdown编写博文，总免不了文章中出现图片，这里的图片有两种类型，一种是放在互联网上的，一种是放在本地的。如果我引用的是互联网上的图片（如 &lt;a href=&quot;https://xxx.com/xxx.png&quot; class=&quot;uri&quot;&gt;https://xxx.com/xxx.png&lt;/a&gt; ），我们在各个渠道发布的时候只需要复制粘贴即可，但是这带来一个问题，如果我们引用图片的网站如果关闭了外链，那我们所发的文章的图片都将会失效，影响文章的质量。如果我们的图片放在本地，那么我们在多个渠道发布的时候，又需要在每个渠道一张张上传图片，岂不是太麻烦，太耗时间了。如果有一个工具能自动解析博文中引用的图片，然后自动上传到对应的渠道，并且把我们博文中引用本地图片的链接改为对应渠道图片的链接，那么我们发布也只用复制粘贴即可，瞬间完成十分高效。这里介绍一下开源项目 &lt;strong&gt;BlogTools&lt;/strong&gt; ，它是一个博文快速多渠道发布工具包，支持博客园、阿里云栖社区、腾讯云+社区、慕课网手记 4种渠道。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/stulzq/BlogTools&quot; class=&quot;uri&quot;&gt;https://github.com/stulzq/BlogTools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得有用，欢迎来个star。&lt;/p&gt;
&lt;h2 id=&quot;二.blogtools的作用&quot;&gt;二.BlogTools的作用&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这套工具只适用于用Markdown写博客或者文章的人群，如果你还不会请花一个小时的时间去熟悉，你就能感受到Markdown给你带来的好处了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用这套工具前，建议先阅读这篇文章：《&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/9043632.html&quot;&gt;如何高效的编写与同步博客&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;BlogTools工具包就是为了解决前言中所述问题，它会解析Markdown文件中的图片，然后上传到对于渠道，并且替换本地链接，下面用几张图来表示：&lt;/p&gt;
&lt;p&gt;1.原文：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150841359-377678505.png&quot; alt=&quot;File&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.转换为 阿里云栖社区 渠道&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150841031-843769616.png&quot; alt=&quot;Aliyun.&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.转换为 慕课网手记 渠道&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150840586-2027949161.png&quot; alt=&quot;Imooc&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要就是减少你到每个渠道去上传图片的操作。你只需复制转换以后的内容，粘贴到对于的渠道即可完成发布。&lt;/p&gt;
&lt;h2 id=&quot;三.各个渠道工具包&quot;&gt;三.各个渠道工具包&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;dotnet-aliyun&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;阿里云栖社区&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.nuget.org/packages/dotnet-aliyun/&quot;&gt;&lt;img src=&quot;https://img.shields.io/nuget/v/dotnet-aliyun.svg?style=flat-square&quot; alt=&quot;Latest version&quot;/&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;dotnet-imooc&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;慕课网手记&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.nuget.org/packages/dotnet-imooc/&quot;&gt;&lt;img src=&quot;https://img.shields.io/nuget/v/dotnet-imooc.svg?style=flat-square&quot; alt=&quot;Latest version&quot;/&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;dotnet-tcloud&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;腾讯云+社区&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.nuget.org/packages/dotnet-tcloud/&quot;&gt;&lt;img src=&quot;https://img.shields.io/nuget/v/dotnet-tcloud.svg?style=flat-square&quot; alt=&quot;Latest version&quot;/&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;dotnet-cnblog&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;博客园&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.nuget.org/packages/dotnet-cnblog/&quot;&gt;&lt;img src=&quot;https://img.shields.io/nuget/v/dotnet-cnblog.svg?style=flat-square&quot; alt=&quot;Latest version&quot;/&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;四.安装&quot;&gt;四.安装&lt;/h2&gt;
&lt;p&gt;使用这套工具需要你的pc具备 .NET Core 2.1版本 SDK 环境或者更高版本。且完全支持跨平台，你可以在.NET Core 支持的任意Linux发行版、Windows、MAC OSX上使用。&lt;/p&gt;
&lt;p&gt;.NET Core SDK 下载地址：&lt;a href=&quot;https://www.microsoft.com/net/learn/get-started/windows&quot; class=&quot;uri&quot;&gt;https://www.microsoft.com/net/learn/get-started/windows&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;阿里云栖社区-工具安装&quot;&gt;1.阿里云栖社区 工具安装&lt;/h3&gt;
&lt;p&gt;打开命令提示符（cmd），输入下面的命令进行安装&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet tool install -g dotnet-aliyun&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150840028-853158925.png&quot; alt=&quot;Aliyun Install&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;慕课网手记-工具安装&quot;&gt;2.慕课网手记 工具安装&lt;/h3&gt;
&lt;p&gt;打开命令提示符（cmd），输入下面的命令进行安装&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet tool install -g dotnet-imooc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150839683-527149087.png&quot; alt=&quot;Imooc Install&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;腾讯云社区-工具安装&quot;&gt;3.腾讯云+社区 工具安装&lt;/h3&gt;
&lt;p&gt;打开命令提示符（cmd），输入下面的命令进行安装&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet tool install -g dotnet-tcloud&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150839410-1804238616.png&quot; alt=&quot;Tcloud Install&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;博客园-工具安装&quot;&gt;4.博客园 工具安装&lt;/h3&gt;
&lt;p&gt;打开命令提示符（cmd），输入下面的命令进行安装&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet tool install -g dotnet-cnblog&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150839148-1328458512.png&quot; alt=&quot;Cnblog Install&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五.卸载&quot;&gt;五.卸载&lt;/h2&gt;
&lt;p&gt;卸载工具的命令格式为：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet tool uninstall -g &amp;lt;工具名称&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六.使用&quot;&gt;六.使用&lt;/h2&gt;
&lt;p&gt;这套工具主要面向写&lt;strong&gt;技术博客&lt;/strong&gt;的人员，所以工具在某些细节的地方并未做处理，比如“登录”。需要用户自己登录以后，提取Cookie给工具使用。&lt;/p&gt;
&lt;h3 id=&quot;阿里云栖社区-工具的使用&quot;&gt;1.阿里云栖社区 工具的使用&lt;/h3&gt;
&lt;h4 id=&quot;使用&quot;&gt;(1).使用&lt;/h4&gt;
&lt;p&gt;获取工具的帮助说明，请执行下面的命令，对每个参数都有说明：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet-aliyun -h&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Usage: dotnet-aliyun [arguments] [options]

Arguments:
  MarkdownFilePath  Required.Your mrkdown File Path.

Options:
  -h|--help         Show help information
  -c|--cookie       Required.Cookie file path.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用命令的格式为：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet-aliyun &amp;lt;Markdown文件路径&amp;gt; -c &amp;lt;cookie文件路径&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet-aliyun c:\blog\test.md -c c:\blog\cookies\aliyun-cookie.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;cookie-的提取&quot;&gt;(2).Cookie 的提取&lt;/h4&gt;
&lt;p&gt;a.使用浏览器登录并访问博客编写的页面：&lt;a href=&quot;https://yq.aliyun.com/articles/new&quot; class=&quot;uri&quot;&gt;https://yq.aliyun.com/articles/new&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;b.打开浏览器的开发者工具并选择 network 选项卡，准备查看上传图片的交互请求。&lt;/p&gt;
&lt;p&gt;c.随便选择一张图片上传&lt;/p&gt;
&lt;p&gt;d.查看这次请求里的Cookie，并保存到文本文件中&lt;/p&gt;
&lt;p&gt;提取Cookie演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150838853-1208514736.png&quot; alt=&quot;Aliyun Cookie&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只复制图中的括号中的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;操作演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150838430-1626596112.gif&quot; alt=&quot;ys&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;慕课网手记-工具的使用&quot;&gt;2.慕课网手记 工具的使用&lt;/h3&gt;
&lt;h4 id=&quot;使用-1&quot;&gt;(1).使用&lt;/h4&gt;
&lt;p&gt;获取工具的帮助说明，请执行下面的命令，对每个参数都有说明：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet-imooc -h&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Usage: dotnet-imooc [arguments] [options]

Arguments:
  MarkdownFilePath  Required.Your mrkdown File Path.

Options:
  -h|--help         Show help information
  -c|--cookie       Required.Cookie file path.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用命令的格式为：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet-imooc &amp;lt;Markdown文件路径&amp;gt; -c &amp;lt;cookie文件路径&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet-imooc c:\blog\test.md -c c:\blog\cookies\imooc-cookie.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;cookie-的提取-1&quot;&gt;(2).Cookie 的提取&lt;/h4&gt;
&lt;p&gt;a.使用浏览器登录并访问博客编写的页面：&lt;a href=&quot;https://www.imooc.com/article/publish&quot; class=&quot;uri&quot;&gt;https://www.imooc.com/article/publish&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;b.打开浏览器的开发者工具并选择 network 选项卡，准备查看上传图片的交互请求。&lt;/p&gt;
&lt;p&gt;c.随便选择一张图片上传&lt;/p&gt;
&lt;p&gt;d.查看这次请求里的Cookie，并保存到文本文件中&lt;/p&gt;
&lt;p&gt;提取Cookie演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150838018-690286870.png&quot; alt=&quot;Imooc Cookie&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只复制图中的括号中的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;操作演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150837569-1657173239.gif&quot; alt=&quot;ys&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;腾讯云社区-工具的使用&quot;&gt;3.腾讯云+社区 工具的使用&lt;/h3&gt;
&lt;h4 id=&quot;使用-2&quot;&gt;(1).使用&lt;/h4&gt;
&lt;p&gt;获取工具的帮助说明，请执行下面的命令，对每个参数都有说明：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet-tcloud -h&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Usage: dotnet-tcloud [arguments] [options]

Arguments:
  MarkdownFilePath  Required.Your mrkdown File Path.

Options:
  -h|--help         Show help information
  -c|--cookie       Required.Cookie file path.
  --uin             Required.
  --csrf            Required.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用命令的格式为：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet-imooc &amp;lt;Markdown文件路径&amp;gt; -c &amp;lt;cookie文件路径&amp;gt; --uin &amp;lt;uin码&amp;gt; --csrf &amp;lt;跨域验证码&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet-tcloud c:\blog\test.md -c c:\blog\cookies\imooc-cookie.txt --uin 55566677 --csrf 7788991&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;cookie-的提取-2&quot;&gt;(2).Cookie 的提取&lt;/h4&gt;
&lt;p&gt;a.使用浏览器登录并访问博客编写的页面：&lt;a href=&quot;https://cloud.tencent.com/developer/article/write&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/article/write&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;b.打开浏览器的开发者工具并选择 network 选项卡，准备查看上传图片的交互请求。&lt;/p&gt;
&lt;p&gt;c.随便选择一张图片上传&lt;/p&gt;
&lt;p&gt;d.查看这次请求里的Cookie，并保存到文本文件中&lt;/p&gt;
&lt;p&gt;e.根据本次上传图片请求url中的参数提取uin码和csrf码&lt;/p&gt;
&lt;p&gt;提取Cookie演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150837052-687841081.png&quot; alt=&quot;Tcloud Cookie&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只复制图中的括号中的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;操作演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201806/668104-20180623150836600-1115329303.gif&quot; alt=&quot;ys&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;博客园-工具的使用&quot;&gt;4.博客园 工具的使用&lt;/h3&gt;
&lt;p&gt;因博客园工具本系列最早的一个工具，使用方法最简单便捷，无需自己提取cookie，是单独开发。详细的使用说明请移步查看：&lt;a href=&quot;https://github.com/stulzq/CnBlogPublishTool&quot; class=&quot;uri&quot;&gt;https://github.com/stulzq/CnBlogPublishTool&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;特殊说明，关于使用js代码 &lt;code&gt;document.cookie&lt;/code&gt; 获取cookie，经测试腾讯云+社区和慕课网手记可以，阿里云栖社区js获取到的cookie无效，因为必须的cookie项设置为了httponly，js无法获取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;七.写在最后&quot;&gt;七.写在最后&lt;/h2&gt;
&lt;p&gt;项目开源地址：&lt;a href=&quot;https://github.com/stulzq/BlogTools&quot; class=&quot;uri&quot;&gt;https://github.com/stulzq/BlogTools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;写这个工具的初衷就是解决博文发布到多个渠道的麻烦，工具不会收集你的任何数据，如有疑问可以查看源码。关于Cookie提取确实是增加了工具使用的复杂度，不过提取的Cookie根据网站登录的选项 “xx天自动登录”，可以让Cookie用很长一段时间，不需要每次发布都去提取。为什么不写自动提取Cookie的代码，那是因为wo lan,bu xiang xie le，如果你有更好的想法，欢迎与我交流。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Jun 2018 07:37:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stulzq/p/9217301.html</dc:identifier>
</item>
<item>
<title>来自运维屌丝内心的声音 - 卡子火</title>
<link>http://www.cnblogs.com/kazihuo/p/9217141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kazihuo/p/9217141.html</guid>
<description>&lt;p&gt;&lt;br/&gt;　　--昨天周五，上海下雨了，六月的夏季在雨水的冲刷下让人心生寒意。将近7点下班，9点到家，一如既往的在下班途中花费了将近两小时。&lt;br/&gt;　　--这两小时不仅是下班的路程时间，有时也是一天当中最闲暇的时间，挤上轰隆隆的地铁，抢上一个座位，闭上双眼，卸下工作包袱，停止运转的大脑，什么都不去想，尽情的放松自我；或者伫立在某个角落，观察着地铁上形形色色的人，同时也丰富下自我大脑中不同人群信息的数据库；或者静静地思考着人生···&lt;br/&gt;　　--回到家时，脚上的鞋子已经可以养鱼了，此刻感到的是生活的不易。情不自禁地把近来的所见所闻，所思所想给好好总结一番。&lt;br/&gt;　　--在童年期，每当过年时，外出务工的亲戚都回来了，大家互相串个门，互相吃个饭，互相扯扯皮，长辈让我印象最深刻的一句话是：要好好读书，以后要像某某某一样出去赚大钱，待在家里没出息！这么多年我也就那样听过来了，光阴似箭，日月如梭，转眼我也出来混了，体验过了才明白：别看过年回家时光鲜亮丽的，其实在外面混的有多艰辛也只有自己知道，其中的酸甜苦辣，其中的人情冷暖，并非三言两语能说透···&lt;br/&gt;　　--当曾经憧憬的月收入过万已不是目标时，发现其实也就辣么回事，刨去衣食住行，月底剩手上的又能有多少？在大城市，早出晚归的生活节奏已成普通人群的标配，但月收入万八千的已经给标上了低等收入水平的标签。试想：以月入万元标准，天天啃馒头的生活方式，一年到头下来估计能攒下的也只不过是这座城市的某个角落的一平米的房。想到这，我默默的告诉自己要努力！&lt;/p&gt;
&lt;p&gt;                                                               &lt;img src=&quot;https://images2018.cnblogs.com/blog/1098305/201806/1098305-20180623141556360-284066823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　--有时来自各方面的压力让自己身心俱疲，然后就莫名地脑海里就像条件反射一样的吐了一大串的《陋室铭》：山不在高，有仙则名；水不在深，有龙则灵。斯是陋室，惟吾德馨。然后自己还会傻里傻气的给拓展：分不在高，能过就行；钱不在多，够花就行；房不在大，能住就行，女友不在美，能牵出手就行···然后自己摸摸自己的后脑勺，突然发现了一个比较尴尬的问题：其实那些东西自己都没有，何来高低、多少、大小、丑美等问题，我滴个乖乖···当看到周围的同学薪资比我高了一倍时，当听到曾经的同学都做了运维总监时，当了解到长得帅还TM贼努力的某某某时，让我在召唤师峡谷（LOL）欢乐的遨游时都带有负罪感。想到这，我默默的告诉自己要努力！&lt;br/&gt;　　--随着年龄的增长，一个人的认知观和价值观都在潜移默化的沉淀，向自己的内心的方向沉淀，随自己内心的思想沉淀···幼儿时，看重的是吃的；童年时，想要的是玩的；青年时，追赶的是分数；而现在，自己想要的突然觉得很多，不敢说出来，只能藏在心里，然后自己为其默默地努力，因为我的未来只能靠我自己！想到这，我还是默默的告诉自己要努力！&lt;/p&gt;
&lt;p&gt;                                                                                                               &lt;img src=&quot;https://images2018.cnblogs.com/blog/1098305/201806/1098305-20180623141808056-1975973143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　--要努力学习，不断的积累知识，让自己的GitHub仓库有东西可存；要持续积累，不断的扩展自己数据量，让自己的MySQL数据库不断壮大；要懂得分享，关闭自身的Iptables，像NFS一样共享自己，才能拥有互补的资格，才能不断成长；要出泥不染，像Docker一样不受外界的影响，任凭其刮风下雨，依然坚定的做好自己；要三省五申，给自己装个Zabbix，时刻自我监控，时刻自己警醒；这就是奋斗，这就是生活，为的是不让别人在与你交流时，你像Nginx一样返回个404；为的是让自己有个一技之长，能够像Keepalived一样成为老大的高可用，能够像Haproxy一样成为老板的负载均衡，能够像Redis一样为同事发出的请求达到迅速响应，能够像Elk一样，具有独到、系统的分析能力为身边的朋友解决问题。当知识积累达到一定程度时，当人生阅历达到一定深度时，我还要考虑给自己配置个Jenkins+Tomcat+Maven，能够面对社会问题和生活琐事等事务处理进行持续化集成的方式解决,然后再嵌套一些人工智能的AI科技···当然，当一个人具备这些能力后，什么金钱，什么地位，什么权利，感觉问题不大，哈哈！！！最后我要告诉自己：I am a superman !!!这就是我的追求，这就是我的理想！！！&lt;br/&gt;　　--想起姑父来我家串门时，总会以教导我的口气告诉我：做人要先做孙子，才能做老子！现在想想，其实真是话糙理不糙！因此，我微笑地仰视一切，是因为我有一颗让世界仰视我的心！！！&lt;/p&gt;
&lt;p&gt;　　--Keep hunger,Keep foolish,Keep moving !因为我想要的东西，都很贵···&lt;/p&gt;
&lt;p&gt;　　                                                                                                      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1098305/201806/1098305-20180623141841356-269891402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 23 Jun 2018 06:21:00 +0000</pubDate>
<dc:creator>卡子火</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kazihuo/p/9217141.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务之基于IdentityServer建立AuthorizationServer - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_01.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623100819093-778772638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　要学习IdentityServer，事先得了解一下基于Token的验证体系，这是一个庞大的主题，涉及到Token，OAuth&amp;amp;OpenID，JWT，协议规范等等等等，园子里已经有很多介绍的文章了，个人觉得solenovex的这一篇文章《&lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7746496.html&quot; target=&quot;_blank&quot;&gt;学习IdentityServer4的预备知识&lt;/a&gt;》言简意赅，可以快速的看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/986268/201710/986268-20171028123246383-1373645510.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;403&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　重点关注一下上面这张图（也是来自solenovex的文章），对于一个User（已注册）来说，他会首先向Authorization Server表明自己的身份（比如输入用户名和密码），然后Authorization Server为其发放了一个token，而这个token就好比是把家里的钥匙配了一把（clone）新的，此后该User就可以访问API请求获取Orders（订单）数据了。当然，实际中可能Authorization Server和API Server不在同一个区域内，它们可能只能遥望对方。此外，User还可以基于这个token去访问第三方服务，第三方服务会使用这个API来访问API Server，向其提供token比提供username&amp;amp;password要安全得多。&lt;/p&gt;

&lt;p&gt;　　IdentityServer4（这里只使用版本号为4）是一个基于OpenID Connect和OAuth 2.0的针对ASP.NET Core 2.0的框架。IdentityServer是将规范兼容的OpenID Connect和OAuth 2.0终结点添加到任意ASP.NET Core应用程序的中间件。通常，你构建（或重新使用）包含登录和注销页面的应用程序，IdentityServer中间件会向其添加必要的协议头，以便客户端应用程序可以使用这些标准协议与其对话。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/9128511-e6493b64b1caf887.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; width=&quot;545&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以用IdentityServer来做啥？&lt;/p&gt;
&lt;p&gt;　　（1）身份验证服务=&amp;gt;官方认证的OpenID Connect实现&lt;/p&gt;
&lt;p&gt;　　（2）单点登录/注销（SSO）&lt;/p&gt;
&lt;p&gt;　　（3）访问受控的API=&amp;gt;为不同的客户提供访问API的令牌，比如：MVC网站、SPA、Mobile App等&lt;/p&gt;
&lt;p&gt;　　（4）等等等......&lt;/p&gt;

&lt;h2&gt;1.1 建立一个ASP.NET Core空Web项目&lt;/h2&gt;
&lt;p&gt;　　建立ASP.NET Core项目，使用Empty空模板。&lt;/p&gt;
&lt;p&gt;　　为了更好地查看日志信息，同时考虑到IISExpress启动起来真的很慢，修改lanuchSettings.json文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;profiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Manulife.DNC.MSAD.IdentityServer4Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;commandName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;launchBrowser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;environmentVariables&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASPNETCORE_ENVIRONMENT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      },
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;applicationUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.2 安装并配置IdentityServer4&lt;/h2&gt;
&lt;p&gt;　　Step1.首先安装IdentityServer4:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;NuGet&amp;gt;Install-Package IdentityServer4　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Step2.配置ASP.NET Core管道，即修改Configure方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        &lt;strong&gt;app.UseIdentityServer();&lt;/strong&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Step3.为了要把IdentityServer注册到容器中，需要对其进行配置，而这个配置中要包含三个信息：&lt;/p&gt;
&lt;p&gt;　　（1）哪些API可以使用这个AuthorizationServer&lt;/p&gt;
&lt;p&gt;　　（2）哪些Client可以使用这个AuthorizationServer&lt;/p&gt;
&lt;p&gt;　　（3）哪些User可以被这个AuthrizationServer识别并授权&lt;/p&gt;
&lt;p&gt;　　这里为了快速演示，我们写一个基于内存的静态类来快速填充上面这些信息（实际中，可以持久化在数据库中通过EF等ORM获取，也可以通过Redis获取）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InMemoryConfiguration
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Define which APIs will use this IdentityServer
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;ApiResource&amp;gt;&lt;span&gt; GetApiResources()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Client Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Product Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Agent Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            };
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Define which Apps will use thie IdentityServer
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt;&lt;span&gt; GetClients()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client.api.service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPasswordAndClientCredentials,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;product.api.service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPasswordAndClientCredentials,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agent.api.service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPasswordAndClientCredentials,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                }
            };
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Define which uses will use this IdentityServer
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;TestUser&amp;gt;&lt;span&gt; GetUsers()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestUser
                {
                    SubjectId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;edison@hotmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;edisonpassword&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestUser
                {
                    SubjectId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;andy@hotmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;andypassword&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestUser
                {
                    SubjectId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;leo@hotmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;leopassword&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            };
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　Step4.对于Token签名需要一对公钥和私钥，不过IdentityServer为开发者提供了一个&lt;em&gt;&lt;strong&gt;AddDeveloperSigningCredential&lt;/strong&gt;&lt;strong&gt;()&lt;/strong&gt;&lt;/em&gt;方法，它会帮我们搞定这个事，并默认存到硬盘中。当切换到生产环境时，还是得使用正儿八经的证书，更换为使用&lt;em&gt;&lt;strong&gt;AddSigningCredential&lt;/strong&gt;&lt;strong&gt;()&lt;/strong&gt;&lt;/em&gt;方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        InMemoryConfiguration.Configuration &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Configuration;

        services.AddIdentityServer()
            .AddDeveloperSigningCredential()&lt;/span&gt;&lt;span&gt;
            .AddTestUsers(InMemoryConfiguration.GetUsers().ToList())
            .AddInMemoryClients(InMemoryConfiguration.GetClients())
            .AddInMemoryApiResources(InMemoryConfiguration.GetApiResources());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.3 获取你心心念念的Token&lt;/h2&gt;
&lt;p&gt;　　Step1.启动刚刚我们建立的AuthorizationServer程序，这里我们绑定的是5000端口。&lt;/p&gt;
&lt;p&gt;　　Step2.启动Postman/SoapUI等API测试工具，通过向HTTP Body中填写数据发起POST请求：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623105426305-1178078262.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623105500992-1995579829.png&quot; alt=&quot;&quot; width=&quot;735&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Step3.发送一个错误的数据，看看返回的是啥？(这里输入了一个不在定义列表中的client_id)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623105734191-395921399.png&quot; alt=&quot;&quot; width=&quot;729&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Step4.查看控制台的日志信息：表示获取Token的这个请求成功了，日志中client_secret和password都是不会直接明文显示的。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623105943474-215563093.png&quot; alt=&quot;&quot; width=&quot;429&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Step5.IdentityServer为我们设置的Grant_Type是ResourceOwnerPasswordAndClientCredentials（点击这里了解=&amp;gt;&lt;a href=&quot;https://www.cnblogs.com/ddrsql/p/7909199.html&quot; target=&quot;_blank&quot;&gt;资源拥有者密码凭据许可&lt;/a&gt;），因此我们还可以使用ClientCredentials（点击这里了解=&amp;gt;&lt;a href=&quot;http://www.cnblogs.com/ddrsql/p/7887083.html&quot; target=&quot;_blank&quot;&gt;客户端凭据许可&lt;/a&gt;），如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623111434460-1581413764.png&quot; alt=&quot;&quot; width=&quot;732&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Step6.再次查看控制台日志信息：这次没有关于User相关的任何信息显示了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623111534382-1475217454.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Step7.基本的开发结束，对于开发阶段，我们使用IdentityServer为开发者提供的临时证书即可，但是后面仍然需要生成一些正儿八经的证书。这里我们通过OpenSSL来生成，首先去&lt;a href=&quot;https://slproweb.com/products/Win32OpenSSL.html&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;下载一个，这里使用的是Win64_1.1版本。打开Powershell或者CMD，输入以下命令：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;cmd&amp;gt;openssl req -newkey rsa:2048 -nodes -keyout cas.clientservice.key -x509 -days 365 -out cas.clientservice.cer&lt;/p&gt;
&lt;p&gt;下面将生成的证书和Key封装成一个文件，以便IdentityServer可以使用它们去正确地签名tokens&lt;/p&gt;
&lt;p&gt;cmd&amp;gt;openssl pkcs12 -export -in cas.clientservice.cer -inkey cas.clientservice.key -out cas.clientservice.pfx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　中途会提示让你输入Export Password，这个password后面会用到，记住它。最终导出后的结果如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623112249456-1763060484.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;82&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里我将其放到了项目结构文件夹中，并设置这个pfx文件为“如果较新则复制”，确保可以在最后生成的目录里边。现在就可以修改一下ConfigureServices()方法了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; basePath =&lt;span&gt; PlatformServices.Default.Application.ApplicationBasePath;
        InMemoryConfiguration.Configuration &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Configuration;

        services.AddIdentityServer()
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.AddDeveloperSigningCredential()&lt;/span&gt;
            &lt;strong&gt;.AddSigningCredential(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; X509Certificate2(Path.Combine(basePath,
                Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Certificates:CerPath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]),
                Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Certificates:Password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;]))&lt;/strong&gt;
          .AddTestUsers(InMemoryConfiguration.GetUsers().ToList())
          .AddInMemoryClients(InMemoryConfiguration.GetClients())
        .AddInMemoryApiResources(InMemoryConfiguration.GetApiResources());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里我将证书的路径和导出密码都写到了配置文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8eb13665-4e14-412e-80ca-ca3072026036')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_8eb13665-4e14-412e-80ca-ca3072026036&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8eb13665-4e14-412e-80ca-ca3072026036&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8eb13665-4e14-412e-80ca-ca3072026036',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8eb13665-4e14-412e-80ca-ca3072026036&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Certificates&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CerPath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;certificate\\cas.clientservice.pfx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;manulife&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　好，配置正儿八经的证书这一步骤Over。&lt;/p&gt;

&lt;h2&gt;4.1 关于QuickStart UI&lt;/h2&gt;
&lt;p&gt;　　IdentityServer为我们提供了一套UI以便使我们能够快速地开发具有基本功能的认证/授权界面，我们可以去这个地址：&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4.Quickstart.UI/tree/release&quot; target=&quot;_blank&quot;&gt;https://github.com/IdentityServer/IdentityServer4.Quickstart.UI/tree/release&lt;/a&gt; 下载，并将其复制到我们的项目目录中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623113229655-167136379.png&quot; alt=&quot;&quot; width=&quot;637&quot; height=&quot;282&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　复制完成后，我们的项目结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623113409280-1211406930.png&quot; alt=&quot;&quot; width=&quot;505&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.2 修改DI方法&lt;/h2&gt;
&lt;p&gt;　　（1）使用MVC与静态文件（由于wwwroot下有很多静态资源文件）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseIdentityServer();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for QuickStart-UI&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;        app.UseStaticFiles();
        app.UseMvcWithDefaultRoute();&lt;/strong&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）注册MVC&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; basePath =&lt;span&gt; PlatformServices.Default.Application.ApplicationBasePath;
        InMemoryConfiguration.Configuration &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Configuration;

        services.AddIdentityServer()
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.AddDeveloperSigningCredential()&lt;/span&gt;
            .AddSigningCredential(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; X509Certificate2(Path.Combine(basePath,
                Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Certificates:CerPath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]),
                Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Certificates:Password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
          .AddTestUsers(InMemoryConfiguration.GetUsers().ToList())
          .AddInMemoryClients(InMemoryConfiguration.GetClients())
          .AddInMemoryApiResources(InMemoryConfiguration.GetApiResources());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for QuickStart-UI&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;        services.AddMvc();&lt;/strong&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.3 Run 　&lt;/h2&gt;
&lt;p&gt;　　（1）首页（这里由于我已经登录，所以这里会把我的账号显示了出来）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623113847713-1671769924.png&quot; alt=&quot;&quot; width=&quot;592&quot; height=&quot;286&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）Logout页，刚刚说到我已经实现Login了，所以我这里Logout一下&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623114041306-737840764.png&quot; alt=&quot;&quot; width=&quot;364&quot; height=&quot;177&quot;/&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623114054010-188788984.png&quot; alt=&quot;&quot; width=&quot;382&quot; height=&quot;179&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）Login页：这里只能识别我们在之前配置的静态User列表中那些User&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623114146567-519221373.png&quot; alt=&quot;&quot; width=&quot;547&quot; height=&quot;372&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　登录之后，显示：&quot;You have not given access to any applications&quot;，表示我们还没有给他授予访问任何API或网站模块的权限。后续我们会创建API和MVC网站来演示如何对其进行授权和访问。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180623114313540-404841867.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;249&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本篇主要简单的介绍了IdentityServer以及如何基于IdentityServer建立一个基本的AuthorizationServer，如何获取Token，以及集成QuickStart UI实现基本的界面展示。后续还会创建API和MVC网站，来和IdentityServer进行集成，以演示如何对User授予访问API和MVC网站的访问权限。&lt;/p&gt;

&lt;p&gt;《&lt;a href=&quot;https://identityserver4.readthedocs.io/en/release/&quot; target=&quot;_blank&quot;&gt;identityserver4官方文档&lt;/a&gt;》&lt;strong&gt;&lt;em&gt;=&amp;gt; 重点关注那些流程图与术语&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ddrsql，《&lt;a href=&quot;https://www.cnblogs.com/ddrsql/p/7909199.html&quot;&gt;IdentityServer4之Resource Owner Password Credentials(资源拥有者密码凭据许可)&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;ddrsql，《&lt;a href=&quot;https://www.cnblogs.com/ddrsql/p/7887083.html&quot;&gt;IdentityServer4之Client Credentials（客户端凭据许可）&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;solenovex，《&lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7746496.html&quot; target=&quot;_blank&quot;&gt;学习Identity Server4的预备知识&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;solenovex，《&lt;a href=&quot;https://www.cnblogs.com/cgzl/p/7780559.html&quot;&gt;使用Identity Server 4建立Authorization Server (1)&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;solenovex，《&lt;a href=&quot;https://www.cnblogs.com/cgzl/p/7788636.html&quot;&gt;使用Identity Server 4建立Authorization Server (2)&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;solenovex，《&lt;a href=&quot;https://www.cnblogs.com/cgzl/p/7793241.html&quot;&gt;使用Identity Server 4建立Authorization Server (3)&lt;/a&gt;》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 23 Jun 2018 04:15:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_01.html</dc:identifier>
</item>
<item>
<title>ES2018正则表达式更新 - wangmeijian</title>
<link>http://www.cnblogs.com/wangmeijian/p/9216033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangmeijian/p/9216033.html</guid>
<description>&lt;p&gt;如果你是一个初学者，这篇文章可以拓展你对正则表达式用法的理解，不过建议你先阅读一些正则表达式入门文章，比如经典的&lt;a href=&quot;http://deerchao.net/tutorials/regex/regex.htm&quot; target=&quot;_blank&quot;&gt;《正则表达式30分钟入门教程》&lt;/a&gt;。如果你对正则表达式有一定的认识，那么这篇文章可以让你了解JavaScript中的新功能。&lt;/p&gt;
&lt;p&gt;随着ES2018的更新，JavaScript正则表达式和其他基于PCRE的正则表达式引擎之间的差距越来越小。&lt;/p&gt;
&lt;p&gt;ES2018有以下四个比较重要的更新：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Lookbehinds&lt;/li&gt;
&lt;li&gt;捕获分组命名&lt;/li&gt;
&lt;li&gt;元字符.匹配换行符&lt;/li&gt;
&lt;li&gt;Unicode转义&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;Lookbehinds断言&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;name&quot;&gt;(?&amp;lt;=exp)也叫&lt;span&gt;&lt;strong&gt;零宽度正回顾后发断言&lt;/strong&gt;&lt;/span&gt;，它&lt;span class=&quot;desc&quot;&gt;断言自身出现的位置的前面能匹配表达式exp&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
/(?&amp;lt;=a)b/  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配字符串b，字符串b前面是字符串a，字符串a不包含在匹配结果内&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/664733/201806/664733-20180622222544138-1234191144.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(?&amp;lt;!exp) &lt;span&gt;&lt;strong&gt;零宽度负回顾后发断言&lt;/strong&gt;&lt;/span&gt;，断言此位置的前面不能匹配表达式exp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/(?&amp;lt;!a)b/  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配字符串b，字符串b前面不是字符串a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/664733/201806/664733-20180622222842370-34864606.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;你会发现在上面两个示例都没有捕获分组。&lt;/span&gt;&lt;span&gt;如要需要捕获分组，可以在要捕获的表达式周围添加括号：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/664733/201806/664733-20180622223558950-32736160.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在此表达式中，生成的正则表达式匹配对象包含&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;索引1下的&lt;/span&gt;&lt;span&gt;捕获&lt;/span&gt;&lt;span&gt;字符a&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;groups属性仍是空的，这就是接下来要说的&lt;/p&gt;
&lt;h2&gt; 捕获分组命名&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/(?&amp;lt;name&amp;gt;content)/  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 语法：匹配content并捕获分组，分组命名为name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了创建一个命名的捕获分组，我们所需要做的就是在括号开始后写一个问号，然后在左右尖括号之间写入捕获的分组名称。&lt;/p&gt;
&lt;p&gt;示例：匹配出字符串“&lt;span class=&quot;crayon-v&quot;&gt;Price&lt;span class=&quot;crayon-o&quot;&gt;: &lt;span class=&quot;crayon-h&quot;&gt;$&lt;span class=&quot;crayon-cn&quot;&gt;19.00&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;”中的货币和价格并分别对分组命名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.table( 
    &lt;/span&gt;/^Price: (?&amp;lt;currency&amp;gt;\$)(?&amp;lt;numPrice&amp;gt;\d+\.\d+)$/&lt;span&gt;
       .exec(&lt;/span&gt;'Price: $15.99'&lt;span&gt;)
       .groups 
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;货币分组名称：currency，价格分组名称numPrice&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/664733/201806/664733-20180622225630728-294591659.png&quot; alt=&quot;&quot; width=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你仍然可以使用数字索引来引用捕获的分组，如果你访问groups属性，则可以读取自定义分组名称来获取对应的值&lt;/p&gt;
&lt;p&gt;自动分组正则表达式反向引用语法：一个反斜杠加分组号，如\1，自定义分组反向引用语法则是：\k&amp;lt;groupName&amp;gt;，命名的捕获组使你的表达式更易于维护&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;元字符.匹配换行符&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这是一个非常简单的更新。&lt;/span&gt;&lt;span&gt;正如您可能知道的那样，在JavaScript正则表达式以及许多PCRE正则表达式中，元字符.不匹配换行符&lt;/span&gt;&lt;/span&gt;&lt;code&gt;\n&lt;/code&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
/./.test('\n'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们测试时可以看到返回false。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在ES2018中，我们可以添加一个s标志，以使点匹配换行符&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
/./s.test('\n'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;确切地说，还有其他行终止符，例如回车符&lt;/span&gt;&lt;/span&gt;&lt;code&gt;\r&lt;/code&gt;&lt;span&gt;&lt;span&gt;，或行分隔符和段落分隔符，它们分别是&lt;/span&gt;&lt;/span&gt;&lt;code&gt;U+2028&lt;/code&gt;&lt;span&gt;&lt;span&gt;和&lt;/span&gt;&lt;/span&gt;&lt;code&gt;U+2029&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Unicode转义&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这是一个文档繁重的主题，因为文档本身详细介绍了此更新的每个细节。&lt;/span&gt;&lt;span&gt;我将链接到&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://github.com/tc39/proposal-regexp-unicode-property-escapes&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;作为参考。&lt;/span&gt;&lt;span&gt;该文档详细介绍了如何将某些unicode字符组与某些表达式匹配，而不使用任何第三方库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在本节中，我们将集中讨论&lt;/span&gt;&lt;span&gt;此更新的&lt;/span&gt;&lt;/span&gt;&lt;em&gt;一些&lt;/em&gt;&lt;span&gt;实际用例，而不是对每个unicode组的详细描述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们从演示开始。&lt;/span&gt;&lt;span&gt;假设你想匹配希腊字符。&lt;/span&gt;&lt;span&gt;在我们决定不使用任何第三方库的情况下，我们在ES2018之前是如何做到的？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;没错，&lt;/span&gt;&lt;span&gt;我们不得不创建字符集。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/[θωερτψυιοπασδφγηςκλζχξωβνμάέήίϊΐόύϋΰώ]/u.test('λ'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还要考虑大写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/[ΘΩΕΡΤΨΥΙΟΠΑΣΔΦΓΗςΚΛΖΧΞΩΒΝΜΆΈΉΊΪΐΌΎΫΰΏ]/u.test('Λ'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ES2018中，我们有一个更简单的符号：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/\p{Script=Greek}/u.test('π'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;\p{Script=Greek}只&lt;/code&gt;&lt;span&gt;&lt;span&gt;匹配希腊字符，&lt;/span&gt;&lt;span&gt;这是一个很好的语义简写。&lt;/span&gt;&lt;span&gt;希腊字符的数量有限，非常像英语。&lt;/span&gt;&lt;span&gt;同时，如果没有Unicode转义，要匹配中文或日文，你必须在那里写一大堆符号。&lt;/span&gt;&lt;span&gt;这个问题通过Unicode转义解决。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果您需要克服JavaScript正则表达式的一些缺点，我仍然鼓励您使用&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://xregexp.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;xRegExp&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;库。&lt;/span&gt;&lt;span&gt;事实上，JavaScript正则表达式引擎并不会那么快取代xRegExp。&lt;/span&gt;&lt;span&gt;与此同时，ES2018正则表达式引擎比之前变得更好，更易维护。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 23 Jun 2018 03:22:00 +0000</pubDate>
<dc:creator>wangmeijian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangmeijian/p/9216033.html</dc:identifier>
</item>
<item>
<title>作为一个.NET开发者，怎么看待和选择层出不穷的新技术，新架构？ - kwklover</title>
<link>http://www.cnblogs.com/kwklover/p/9216584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kwklover/p/9216584.html</guid>
<description>&lt;p&gt;经常在一些技术社区看到这些的问题，一个.NET开发者去求职，看到应聘的公司的技术栈还是比较老的ASP.NET WEBFORM的时候，希望了解未来会否使用ASP.NET MVC的时候，没有获得肯定答复，于是就放弃了这一份机会，以技术选企业，是否必要？&lt;/p&gt;
&lt;p&gt;最近我在开发一个&lt;a href=&quot;https://gitee.com/keke11/OdnShop&quot; target=&quot;_blank&quot;&gt;开源的微商城系统OdnShop&lt;/a&gt;，发布之后，有些用户就问，怎么不是ASP.NET MVC的？不支持MSSQL吗？要上.NET CORE了，诸如此类的问题。当然这些问题并没有标准答案，从技术本质来说，技术只是用来解决业务问题的一种手段，所以技术的新旧并不是考虑的核心，但开发效率，维护成本，稳定性等等确实必须考核，因为他会影响投入，影响收益。&lt;/p&gt;
&lt;p&gt;所以，我想就.NET程序员如何看待新技术，如何选择新技术，提供一种我的思考，希望大家理性思考，理性讨论，不要把某种框架，某种技术作为一种宗教信仰。&lt;/p&gt;

&lt;p&gt;一，WEBFORM OR ASP.NET MVC？&lt;/p&gt;
&lt;p&gt;WEBFORM的本意是很好的，就是希望把桌面开发的那一套拖拉控件的模式借鉴到了WEB开发，如果你开发过WINFORM就应该知道，拖拉控件实现GUI是很方便，当然了要实现很炫酷的GUI的时候，就不容易了，因为需要深入了解控件的原理以及GDI等技术，但是WEB就不同了，HTML+CSS可以实现很美观的界面，只要想的到，都可以做的到，但是因为基于HTML标记语言，多了一个标记，界面就可能发生变化，而基于WEBFROM拖拉出来的控件，经常会生产出一堆的无用的标签导致页面效果达不到预期，为了达到预期目的，反而需要花很多时间了解控件的用法，甚至自己重写控件，这样就失去了原本的意义，开发门槛和开发效率反而没有得到提升。所以ASP.NET MVC就很成了大家希望的新选择了。&lt;/p&gt;
&lt;p&gt;但是我想表达的是MVC是一种好的设计思想，但MVC并不等同与ASP.NET MVC，ASP.NET MVC只是官方提供的一种最佳实践的框架。而且MS的技术体系，有时候往往确实前后的连贯性，想想这些年，MS推出了多少新技术，新框架，很多人花了很多时间去学习，最后可能连个像样的DEMO都没有做出来，那个技术，那个框架已经成为过去式了。&lt;/p&gt;
&lt;p&gt;ASP.NET MVC只是其中一个，我的观点是MVC依然是一种好的思想和理念，会一直存在和发展下来，但是ASP.NET MVC1到ASP.NET MVC6，未来会走向何方，只有MS才知道，所以如果你计划做一个新项目，无论是选择WEBFROM还是ASP.NET MVC都是可以，那种技术你擅长，你熟悉，能否快速提供给客户一个稳定可用的解决方案，那就是一种好的技术，但是如果你计划研发一个产品，我认为WEBFORM和ASP.NET MVC都不是很好的选择，产品的生存周期往往比较长，而MS的技术更新换代就比较频繁，产品总不能年年都重构，年年换框架吧，且不说需要投入大量的人力时间，还可能引入一堆的BUG。所以如何开发产品，我的观点是既可以使用WEBFORM好的一面（比如后台，用控件的方式，有时候开发效率非常高效的），也会借鉴MVC的优秀思想（在前端，更好的实现代码和界面分离等），但尽量不使用太多的框架，而是自己根据产品的发展和需要，自己去实现，比如MVC，完全可以根据自己的需要，实现一种轻量级的MVC框架。&lt;/p&gt;

&lt;p&gt;二，MSSQL OR MYSQL ?&lt;/p&gt;
&lt;p&gt;一直以来，.NET + MSSQL基本是标配，开发.NET系统，基本都会搭配使用MSSQL，但自从用了MYSQL之后，我就很少用回MSSQL，不是说MSSQL不好，而是MSSQL太笨重，某些简单的问题，比如分页，MYSQL就非常容易，MSSQL早期版本还需要搞个存储过程来实现，新版本提供了新的语法，但是又无法向下兼容，但是MYSQL在一些复杂的联合查询是没有MSSQL强大的，具体特性我就不去比较了，毕竟每种数据库各有其优缺点，作为一个普通开发者，也没有办法完全去吃透两种数据库的所有特性，以我个人使用的经验，我觉得企业MIS选MSSQL会比较好，而互联网产品，选MYSQL会更好一些，因为轻量，资源友好型。&lt;/p&gt;

&lt;p&gt;三，.NET OR .NET Core ?&lt;/p&gt;
&lt;p&gt;一直以来，MS的技术只能运行在WIN系统，自从.NET CORE的推出，完全改变了旧有的技术观念，那么.NET CORE是否值得选用，值得期待，我认为：值得！&lt;/p&gt;
&lt;p&gt;首先，拥抱更加开放的技术符合时代潮流，多一种选择，总是好事，当然了，如果你是自己开发的产品，自己用，就只跑WIN也没啥不好！&lt;/p&gt;
&lt;p&gt;其次，我曾经开发一个搜索产品，基于.NET开发的，我遇到很多潜在客户来咨询，他们的网站是使用PHP，跑在Linux上的，问能否支持Linux，如果从开发产品的角度来说，能支持多一种操作系统，意味着更多的潜在客户。&lt;/p&gt;
&lt;p&gt;再次，.NET CORE会不会中途就不了了之，MS的新CEO上台后，MS的发展方向已经很清晰了，WIN的地位已经下降了，公司营收越来越依赖云计算，这说明MS用不着把.NET绑死在WIN上，VS都有MAC版本了，MS已经越来越开放了，不是MS想通了，要开放了，而是开放了能更赚钱，能帮助企业赚钱的方向，企业会放弃，不了了之吗？&lt;/p&gt;

&lt;p&gt;总之，对待新技术，新框架，不要做一个宗教式的技术狂热者，而是做一个理性的实用主义者，慎重选择框架类技术，比如WPF，ASP.NET MVC等，积极拥抱大方向，比如.NET CORE。本文只是我个人的思考，欢迎理性讨论！&lt;/p&gt;
</description>
<pubDate>Sat, 23 Jun 2018 02:47:00 +0000</pubDate>
<dc:creator>kwklover</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kwklover/p/9216584.html</dc:identifier>
</item>
<item>
<title>eKingCloud 从 OpenStack 到 OpenInfra 演进之路 - SammyLiu</title>
<link>http://www.cnblogs.com/sammyliu/p/9216507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sammyliu/p/9216507.html</guid>
<description>&lt;p&gt;本内容首发于 2016/06/21 北京 OpenInfra 大会上本人的演讲&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623101637817-759197042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623101706845-629878035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623101730994-1628296611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623101846584-1394836971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623101939259-841600308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623102019657-919448451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623102044297-680886966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623102109377-369251096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623102208443-1570119162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623102230978-1722112688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623102252256-847569404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623102311048-28098023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623102328093-411844503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623102347602-1536823196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/697113/201806/697113-20180623102441733-1235055843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;em&gt;发文章要求至少150个字，那就把最后一页说明一下吧。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我前面介绍了我们的5大产品，包括企业的私有云架构和实践，包括企业数字化转型。回到这次大会的主题，我也来谈谈对openinfra的一些看法。大家知道，这个会议的前身是openstack大会。为什么现在叫做openinfra大会呢？圈子里面也有很多讨论，openstack 是不是不行了？kubernetes 是不是要一统企业IDC了？&lt;/p&gt;
&lt;p&gt;我这里有个示意图，说明了不同IT时期的一些主流产品和技术。最左边是以PowerVM为代表的大型机和小型机虚拟化时期；下一个是x86虚拟化时期，比如vmware，kvm，xen，hypev； 下一个是基础云时期，比如cloudstack，openstack，ceph，OVS；再下一个是云原生时期，包括docker，Kubernetes，openshift；最后一个是serverless 时期，比如openwhisk。&lt;/p&gt;
&lt;p&gt;看这个图，结合我前面提出那些问题，我大概总结为几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;IT架构一直在变，从大型机到x86，从虚拟化到基础云，到云原生，再到serverless。这个趋势不会改变。&lt;/li&gt;
&lt;li&gt;支撑IT架构的产品和技术也在变。虚拟化时期的各种hypervisor，基础云时期的各种基础云平台，云原生时期的各种容器引擎和管理平台。不同的IT架构需要不同的技术和产品来支撑。&lt;/li&gt;
&lt;li&gt;每个IT架构时期不是割裂的孤立的，不是覆盖关系，而是共存关系。X86出来的时候，大家在讨论大型机和小型机是不是要死了，其实这么多年了它们还活着，而且或者一些非常关键的系统里面。 Openstack一开始出来的时候，大家在讨论vmware是不是要死了，但是实际上现在vmware 还活着，而且活得不错。现在kubernetes 火了，大家又在讨论openstack 是不是要死了，其实它也还没死，而且在一段时间内它有它的地位和适用场景。所以我认为，这些技术和产品不是相克的关系，而是共生关系。&lt;/li&gt;
&lt;li&gt;我们也要看到，一部分技术在萎缩，而一部分技术在发展，这也符合发展规律。我们也要看到大型机和小型机市场在萎缩，逐渐被x86替代。我们也看到物理机环境在被虚拟化环境逐步替代，但是在某些时候，比如跑oracle rac 集群，跑大数据平台，大家还是在用物理机。虚拟化环境在被云环境蚕食。Openstack 其实现在也处于发展逐渐缓慢甚至逐步萎缩时期，逐渐在向容器环境过度。而将来，容器云环境也将会向serverless 过度。这些也符合发展规律。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;再回到我今天分享的内容，我们eking cloud 从cloudstack，到openstack，再到ceph 和 容器云平台，从服务到一体机，其实也是在遵循着这些发展规律，在不断的演进我们的产品。&lt;/p&gt;

</description>
<pubDate>Sat, 23 Jun 2018 02:28:00 +0000</pubDate>
<dc:creator>SammyLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sammyliu/p/9216507.html</dc:identifier>
</item>
<item>
<title>IT咨询顾问:group by与join引发的项目救火 - intsmaze(刘洋)</title>
<link>http://www.cnblogs.com/intsmaze/p/9215581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/intsmaze/p/9215581.html</guid>
<description>&lt;p&gt;我又一次进行了项目救火，这次的原因是group by与join胡乱的堆彻导致的整个业务系统审核流程发生严重的错误。基础的sql表关联，group by,子表都理不清，我也只能对你面带微笑，不想对你解析原因，你就按照我提供给你的模板改你全部的业务sql层（XML文件的sql）吧。&lt;/p&gt;
&lt;h3&gt; 很简单的一对多表关联&lt;/h3&gt;
&lt;p&gt;用户表，customerId代表用户的唯一id,insertTime代表这条数据何时存入的。与之对应的是表单表，外键customerId表明这个保单是哪个客户的，同时unit表明出该保单的机构，insertTime也是插入时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758427/201806/758427-20180622211814790-1832295253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758427/201806/758427-20180622210355588-834530369.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;业务背景&lt;/h3&gt;
&lt;p&gt;前端列表显示出每一天投保的客户信息（客户连续两天投保，则显示两条该客户数据，如上面intsmaze客户），点击每条记录的详情可以查看该客户当天的保单详情。&lt;/p&gt;
&lt;p&gt;审核权限划分:一个客户一天投保的多个保单可能会来自多个出单机构，比如上面intsmaze，06-21的三个保单出自上海，北京，深圳，那么怎么划分，借助group by的&quot;随缘法则&quot;，intsmaze 06-21号就取数据插入顺序最前的上海，特朗普 06-21 就取杭州。&lt;/p&gt;
&lt;p&gt;他们的原产sql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; customer c &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; insurance i
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt; c.customerId&lt;span&gt;=&lt;/span&gt;i.customerId &lt;span&gt;and&lt;/span&gt; c.insertTime&lt;span&gt;=&lt;/span&gt;&lt;span&gt;i.insertTime
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; c.flow&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; c.customerId
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询的结果是两条数据，很显然少了一条intsmaze 06-22号的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758427/201806/758427-20180622211836105-799747248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;虽然有问题，但是感觉很难爆出给用户的，它是怎么出现的了？&lt;/h4&gt;
&lt;p&gt;这要说审核流程了，默认数据进来是初审，用户表的flow是0。&lt;/p&gt;
&lt;p&gt;当用户审核intsmaze的这一条数据后，数据变得如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758427/201806/758427-20180622212054231-785446276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们可以看到flow&lt;span&gt;=&lt;span&gt;'&lt;span&gt;0&lt;span&gt;'&lt;span&gt;初审，intsmaze的unit由上海变成了北京，那是因为这条问题sql隐藏的数据终于出现了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758427/201806/758427-20180622212213885-1714574841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时flow&lt;span&gt;=&lt;span&gt;'&lt;span&gt;1&lt;span&gt;'&lt;span&gt;复审的数据如下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758427/201806/758427-20180622212355355-1670647325.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后有趣的事情来了，审核人员此时又将初审的intsmaze 北京 提交到复审，这个时候复审应该有两条数据，但是他到复审那里还是就看到一条数据。然后就出大事了，最后我就马革裹尸过来救火了。&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;join的时候是几个字段，group by就几个字段，加上insertTime即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; customer c &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; insurance i
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt; c.customerId&lt;span&gt;=&lt;/span&gt;i.customerId &lt;span&gt;and&lt;/span&gt; c.insertTime&lt;span&gt;=&lt;/span&gt;&lt;span&gt;i.insertTime
&lt;/span&gt;&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; c.customerId,c.insertTime
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;unit判断，导致同一条数据两个机构均可审核&lt;/h3&gt;
&lt;p&gt;他的unit的判断放在join后的where条件上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; customer c &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; insurance i
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt; c.customerId&lt;span&gt;=&lt;/span&gt;i.customerId &lt;span&gt;and&lt;/span&gt; c.insertTime&lt;span&gt;=&lt;/span&gt;&lt;span&gt;i.insertTime
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; c.flow='1' and i.unit&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; c.customerId
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这导致一个有趣的问题就是，比如intsmaze 06-21 这个客户，它分别能被北京，上海，深圳三个机构看到，其他机构是看不到。然后就出现一个有趣的现象:&quot;谁动了我的数据，我明明没有审核，为什么到复审了，北京复审页面看到这条数据初审提交人事上海，这是怎么一回事嘛？&quot;。&lt;/p&gt;
&lt;p&gt;这个问题我只显示结果，不想解释，最后附上解决方案。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; customer c &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; insurance i
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt; c.customerId&lt;span&gt;=&lt;/span&gt;i.customerId &lt;span&gt;and&lt;/span&gt; c.insertTime&lt;span&gt;=&lt;/span&gt;&lt;span&gt;i.insertTime
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; c.flow&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; c.customerId
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个客户本来是该上海机构去审核&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758427/201806/758427-20180622213449891-1715698319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可是我发现，如果北京机构人登录，也是可以看到这条记录进行审核&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; customer c &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; insurance i
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt; c.customerId&lt;span&gt;=&lt;/span&gt;i.customerId &lt;span&gt;and&lt;/span&gt; c.insertTime&lt;span&gt;=&lt;/span&gt;&lt;span&gt;i.insertTime
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; c.flow&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; i.unit&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; c.customerId
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758427/201806/758427-20180622213449891-1715698319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;如何解决，子表呗&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; c.customerId,c.insertTime,unit,&lt;span&gt;money&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; customer c &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; insurance i
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt; c.customerId&lt;span&gt;=&lt;/span&gt;i.customerId &lt;span&gt;and&lt;/span&gt; c.insertTime&lt;span&gt;=&lt;/span&gt;&lt;span&gt;i.insertTime
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; c.flow&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; c.customerId
)&lt;/span&gt;&lt;span&gt;temp&lt;/span&gt; 
&lt;span&gt;where&lt;/span&gt; &lt;span&gt;temp&lt;/span&gt;.unit&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终我提供的sql模板如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; c.customerId,c.insertTime,unit,&lt;span&gt;money&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; customer c &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; insurance i
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt; c.customerId&lt;span&gt;=&lt;/span&gt;i.customerId &lt;span&gt;and&lt;/span&gt; c.insertTime&lt;span&gt;=&lt;/span&gt;&lt;span&gt;i.insertTime
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; c.flow&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; c.customerId,c.insertTime
)&lt;/span&gt;&lt;span&gt;temp&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;temp&lt;/span&gt;.unit&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模板提供后，剩下的事情当然不是我去改了，毕竟我已经吐了几口血了。我只负责找出问题，提供解决方案，然后功能顾问就全方位的改自己的sql。我则一旁陪伴直至改完后，系统没有出现他们无法解决的毛病后就离场修身养性咯。&lt;/p&gt;

&lt;p&gt;ps:救了几次火后，我晓得当初为什么我被面试，别人问我你开发中遇到什么奇怪的bug没，我当时真的没有啊，我确实没有遇到什么奇怪的bug,因为你如果真的按照语法规则开发，其实很多问题都是不会出现的。之所以会出现，往往是基础太薄弱，然后也不理解上来就模仿，然后就会出错。&lt;/p&gt;

</description>
<pubDate>Sat, 23 Jun 2018 02:25:00 +0000</pubDate>
<dc:creator>intsmaze(刘洋)</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/intsmaze/p/9215581.html</dc:identifier>
</item>
<item>
<title>BaseProxy:异步http/https中间人 - 七夜的故事</title>
<link>http://www.cnblogs.com/qiyeboy/p/9216433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiyeboy/p/9216433.html</guid>
<description>&lt;p&gt;异步http/https代理,可拦截并修改报文,可以作为中间人工具.仅支持&lt;strong&gt;py3.5+&lt;/strong&gt;.项目地址:&lt;a href=&quot;https://github.com/qiyeboy/BaseProxy&quot;&gt;BaseProxy&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;意义&quot;&gt;意义&lt;/h2&gt;
&lt;p&gt;BaseProxy项目的本意是为了使HTTP/HTTPS拦截更加纯粹,更加易操作,学习成本更低。&lt;/p&gt;
&lt;p&gt;在Python领域,中间人工具非常强大和成功的是MitmProxy,但是有些地方不是很喜欢。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Windows上安装比较费时费力&lt;/li&gt;
&lt;li&gt;功能太多了,可惜我用不到这么多(似乎不是它的错，哈哈)&lt;/li&gt;
&lt;li&gt;随着版本升级,采用插件化框架,需要定制功能,需要写个插件成为它的一部分(我只是想集成它而已).&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此BaseProxy就诞生了,不仅支持HTTPS透明传输,还支持HTTP/HTTPS拦截,简单易用,可以很好地集成到你们的项目中。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;安装非常简单,本项目已经发布到PyPI中...&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip3 install baseproxy&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用配置&quot;&gt;使用配置&lt;/h2&gt;
&lt;h3 id=&quot;启动baseproxy&quot;&gt;启动baseproxy&lt;/h3&gt;
&lt;p&gt;在test文件夹下，有很多测试用例。以startserver.py为例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from baseproxy.proxy import AsyncMitmProxy

baseproxy = AsyncMitmProxy(https=True)

baseproxy.serve_forever()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用上述代码,就可以将HTTPServer运行起来了.对代码的解释如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;https=True&lt;/code&gt;是对https进行解密;&lt;code&gt;https=False&lt;/code&gt;是对于https实行透传&lt;/li&gt;
&lt;li&gt;baseproxy默认运行在8788端口,如果想改变端口的话,修改为&lt;code&gt;AsyncMitmProxy(server_addr=('',port),https=True)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;运行结果如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[2018-06-22 18:46:32] INFO HTTPServer is running at address(  , 8788 )......&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装ca证书&quot;&gt;安装CA证书&lt;/h3&gt;
&lt;p&gt;1.将chrome浏览器代理服务器设置为127.0.0.1:8788,推荐使用SwitchyOmega插件.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiyesafe.com/wp-content/uploads/2018/06/0883f5c67029006e0763da718f7536ba.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.设置好代理,并将baseproxy运行后,访问www.baidu.com.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiyesafe.com/wp-content/uploads/2018/06/b3c200d0d74defb8b80cff3cbd5c48e3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.这时候访问被拒绝,需要安装证书.在当前网页访问 baseproxy.ca,下载证书.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiyesafe.com/wp-content/uploads/2018/06/5929234995d2868ee4928052a70f2f45.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.双击下载的证书,并安装到合法机构中.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiyesafe.com/wp-content/uploads/2018/06/77a823fca5b9a4765bf1f7478851ce0d.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiyesafe.com/wp-content/uploads/2018/06/d993a5e66887de15297afafa5a408349.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://qiyesafe.com/wp-content/uploads/2018/06/d994706e303d68f8a0152d2d510b5997.png&quot;/&gt;&lt;br/&gt;5.接着访问百度就可以了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiyesafe.com/wp-content/uploads/2018/06/c2fb0549a86bd98e26c52c617b0395fb.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：只有&lt;code&gt;https=True&lt;/code&gt;时,才需要安装CA证书。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;开发&quot;&gt;开发&lt;/h2&gt;
&lt;p&gt;经过上一步的使用配置,baseproxy已经可以正常运行了,但是这样是远远不够的.baseproxy还提供了接口,方便开发者对http请求和响应进行修改.&lt;/p&gt;
&lt;h3 id=&quot;接口&quot;&gt;接口&lt;/h3&gt;
&lt;p&gt;baseproxy提供了两个接口,一个是修改请求,一个是修改响应.&lt;/p&gt;
&lt;h4 id=&quot;拦截请求&quot;&gt;拦截请求&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class ReqIntercept(InterceptPlug):

    def deal_request(self,request):
        pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于请求的拦截,需要继承ReqIntercept类,并重写其中的deal_request函数.在deal_request函数的最后,需要将修改后的request参数返回出去.&lt;br/&gt;如果想抛弃这个请求,直接返回None.&lt;/p&gt;
&lt;h4 id=&quot;request参数&quot;&gt;request参数&lt;/h4&gt;
&lt;p&gt;deal_request函数中的request参数类型为Request类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成员变量&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;hostname&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;str&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;域名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;port&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;int&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;command&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;str&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;请求类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;path&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;str&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;请求路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;request_version&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;str&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;HTTP协议版本&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;成员函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    def set_headers(self,headers)
     - headers:类型为dict
     - 用于设置头部&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def get_header(self,key):
    - key:类型为str
    - 用于获取指定头部,返回str&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def get_headers(self):
    - 用于获取整个头部,返回为dict&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def set_header(self,key,value):
    - 头部 key,类型str
    - 头部 value,类型str
    - 用于设置头信息&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def get_body_data(self):
    - 获取请求体内容,返回类型为bytes&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def set_body_data(self,body):
    - 设置请求体内容,body类型为bytes
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;拦截响应&quot;&gt;拦截响应&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class RspIntercept(InterceptPlug):

    def deal_response(self,response):
        pass
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于响应的拦截,需要继承RspIntercept类,并重写其中的deal_response函数.在deal_response函数的最后,需要将修改后的response参数返回出去.&lt;br/&gt;如果想抛弃这个响应,直接返回None.&lt;/p&gt;
&lt;h4 id=&quot;response参数&quot;&gt;response参数&lt;/h4&gt;
&lt;p&gt;deal_response函数中的response参数类型为Response类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成员变量&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;hostname&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;str&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;域名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;port&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;int&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;status&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;int&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;状态码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;reason&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;str&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;状态描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;response_version&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;str&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;HTTP协议版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;request&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;Request&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;响应对应的请求实例&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;成员函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    def set_headers(self,headers)
     - headers:类型为dict
     - 用于设置头部&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def get_header(self,key):
    - key:类型为str
    - 用于获取指定头部,返回str&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def get_headers(self):
    - 用于获取整个头部,返回为dict&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def set_header(self,key,value):
    - 头部 key,类型str
    - 头部 value,类型str
    - 用于设置头信息&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def get_body_data(self):
    - 获取响应体内容,返回类型为bytes&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def set_body_data(self,body):
    - 设置响应体内容,body类型为bytes
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def get_body_str(self,decoding=None):
    - decoding:编码,默认为None,内部采用chardet探测
    - 返回响应体,类型为str.如果无法解码,返回None
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    def set_body_str(self,body_str,encoding=None):
    - encoding:编码,默认为None,内部采用chardet探测
    - 设置响应体,body_str类型为str&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;注册拦截插件&quot;&gt;注册拦截插件&lt;/h3&gt;
&lt;p&gt;将拦截类完成后，需要注册到baseproxy中,需要调用AsyncMitmProxy的register函数.示例如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from baseproxy.proxy import ReqIntercept, RspIntercept, AsyncMitmProxy
__author__ = 'qiye'
__date__ = '2018/6/21 23:35'

class DebugInterceptor(ReqIntercept, RspIntercept):
    def deal_request(self, request):
        return request

    def deal_response(self, response):
        return response

if __name__==&quot;__main__&quot;:

    baseproxy = AsyncMitmProxy(https=False)
    baseproxy.register(DebugInterceptor)
    baseproxy.serve_forever()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小例子&quot;&gt;小例子&lt;/h2&gt;
&lt;p&gt;将淘宝中的所有产品图片换成&lt;strong&gt;我公众号的二维码&lt;/strong&gt;.代码在test文件夹的replace_image.py中,内容如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from baseproxy.proxy import RspIntercept, AsyncMitmProxy



class ImageInterceptor( RspIntercept):

    def deal_response(self, response):
        if response.get_header(&quot;Content-Type&quot;) and 'image' in response.get_header(&quot;Content-Type&quot;):
            with open(&quot;../img/qiye2.jpg&quot;,'rb') as f:
                response.set_body_data(f.read())
        return response


if __name__ == &quot;__main__&quot;:
    baseproxy = AsyncMitmProxy(https=True)
    baseproxy.register(ImageInterceptor)
    baseproxy.serve_forever()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiyesafe.com/wp-content/uploads/2018/06/cb202f3182fe9a5d39820fef4516204b.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考项目&quot;&gt;参考项目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mitmproxy/mitmproxy&quot;&gt;MitmProxy&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/inaz2/proxy2&quot;&gt;proxy2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;福利大放送&quot;&gt;福利大放送&lt;/h2&gt;
&lt;p&gt;关注公众号：&lt;strong&gt;七夜安全博客&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiyesafe.com/wp-content/uploads/2018/05/d929ae9a466c0f5e20148d538bbc8e17.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;回复【1】：领取 Python数据分析 教程大礼包&lt;/li&gt;
&lt;li&gt;回复【2】：领取 Python Flask 全套教程&lt;/li&gt;
&lt;li&gt;回复【3】：领取 某学院 机器学习 教程&lt;/li&gt;
&lt;li&gt;回复【4】：领取 爬虫 教程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;知识星球&lt;/strong&gt;已经50人了，随着人数的增多，价格之后会上涨，越早关注越多优惠。星球的福利有很多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;比如上面的教程，已经提前在知识星球中分享&lt;/li&gt;
&lt;li&gt;可以发表一些问题，大家一块解决&lt;/li&gt;
&lt;li&gt;我之后写的电子书，录制的教学视频，对于知识星球的朋友都是优惠的（基本上免费）&lt;/li&gt;
&lt;li&gt;一些节假日会给大家发个红包或者赠书&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://qiyesafe.com/wp-content/uploads/2018/05/3899727832f58c3e9359943ed9a2e047.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Jun 2018 02:14:00 +0000</pubDate>
<dc:creator>七夜的故事</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiyeboy/p/9216433.html</dc:identifier>
</item>
</channel>
</rss>