<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【Python3爬虫】下载酷狗音乐上的歌曲 - TM0831</title>
<link>http://www.cnblogs.com/TM0831/p/9524243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TM0831/p/9524243.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;经过测试，可以下载要付费下载的歌曲（n_n）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;




&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   打开酷狗音乐的官网，输入想要搜索的歌曲（例如《天后》），然后回车搜索，得到如下页面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1450803/201808/1450803-20180823153049682-1053698732.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    右键检查或者按F12打开开发者工具，点击JS选项，查找到如下信息，FileName就是返回的歌手名和歌曲名信息，我们要将其提取出来：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1450803/201808/1450803-20180823153807713-1628640934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   由于这个网址返回的不是标准的json格式，所以要先进行如下处理，然后再转换成json格式：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;res = requests.get(url).text&lt;/span&gt;&lt;br/&gt;&lt;span&gt;js = json.loads(res[res.index('(') + 1:-2])&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;span&gt;提取到歌曲信息之后，我们输入一个序号代表要下载的歌曲序号，然后把歌曲下载下来就好了。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;运行截图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1450803/201808/1450803-20180823154846716-1814036097.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;附上源码：&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_song(x):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://songsearch.kugou.com/song_search_v2?callback=jQuery112407470964083509348_1534929985284&amp;amp;keyword={}&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;           &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;page=1&amp;amp;pagesize=30&amp;amp;userid=-1&amp;amp;clientver=&amp;amp;platform=WebFilter&amp;amp;tag=em&amp;amp;filter=2&amp;amp;iscorrection=1&amp;amp;privilege_filte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;           &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r=0&amp;amp;_=1534929985286&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(x)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     res =&lt;span&gt; requests.get(url).text
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     js = json.loads(res[res.index(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) + 1:-2&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     data = js[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lists&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(str(i + 1) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(data[i][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FileName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;em&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/em&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     number = int(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n请输入要下载的歌曲序号（输入-1退出程序）: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; number == -1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        exit()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         name = str(data[number - 1][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FileName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;em&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/em&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         fhash = re.findall(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;FileHash&quot;:&quot;(.*?)&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, res)[number - 1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         hash_url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.kugou.com/yy/index.php?r=play/getdata&amp;amp;hash=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; fhash
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         hash_content =&lt;span&gt; requests.get(hash_url)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         play_url = &lt;span&gt;''&lt;/span&gt;.join(re.findall(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;play_url&quot;:&quot;(.*?)&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, hash_content.text))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         real_download_url = play_url.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         with open(name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.mp3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)as fp:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            fp.write(requests.get(real_download_url).content)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;歌曲已下载完成！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     x = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入歌名：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     get_song(x)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 23 Aug 2018 07:52:00 +0000</pubDate>
<dc:creator>TM0831</dc:creator>
<og:description>经过测试，可以下载要付费下载的歌曲（n_n） 准备工作：Python3.5+Pycharm 使用到的库：requests，re，json 步骤： 打开酷狗音乐的官网，输入想要搜索的歌曲（例如《天后》）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TM0831/p/9524243.html</dc:identifier>
</item>
<item>
<title>【玩转开源】BananaPi R2 —— 第三篇 基于Openwrt开发一个简单的路由器 - JackZengLab</title>
<link>http://www.cnblogs.com/topbin/p/9519881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/topbin/p/9519881.html</guid>
<description>&lt;p&gt;      上一篇讲解了R2的网口配置，这一篇我们以BananaPi R2为例子来实现一个简单的路由器；那么一个简单的路由器应该具备什么样的功能呢？最简单的说就是wan+lan+ap这三个功能。&lt;/p&gt;
&lt;p&gt;      首先wan+lan的功能，R2已经默认有了，接下来我们用网桥（bridge）的方式搭建一个无线热点（Ap）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开R2上mt6625（R2上的无线芯片）的ap模式&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
jack@jack: wmt_loader &amp;amp;&lt;span&gt;
jack@jack: stp_uart_launcher &lt;/span&gt;-p /etc/firmware &amp;amp;&lt;span&gt;
jack@jack: &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; A &amp;gt; /dev/wmtWifi &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;打开后，可以看到生成了一个虚拟网口ap0&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
root@LEDE:/# &lt;span&gt;ifconfig&lt;/span&gt; -&lt;span&gt;a
ap0       Link encap:Ethernet  HWaddr &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:4A:BA:&lt;span&gt;50&lt;/span&gt;&lt;span&gt;  
          BROADCAST MULTICAST  MTU:&lt;/span&gt;&lt;span&gt;1500&lt;/span&gt;  Metric:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
          RX packets:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; errors:&lt;span&gt;0&lt;/span&gt; dropped:&lt;span&gt;0&lt;/span&gt; overruns:&lt;span&gt;0&lt;/span&gt; frame:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
          TX packets:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; errors:&lt;span&gt;0&lt;/span&gt; dropped:&lt;span&gt;0&lt;/span&gt; overruns:&lt;span&gt;0&lt;/span&gt; carrier:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
          collisions:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; txqueuelen:&lt;span&gt;1000&lt;/span&gt;&lt;span&gt; 
          RX bytes:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt; B)  TX bytes:&lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt; B)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;接下来，我们需要创建一个无线热点出来，这里我使用的是hostapd（soft AP）的方式去创建，在这里我引申一下hostapd的知识：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
   什么是hostapd？我截取官网一部分解释：hostapd is a user space daemon &lt;span&gt;for&lt;/span&gt; access point and authentication servers. It implements IEEE &lt;span&gt;802.11&lt;/span&gt; access point management, IEEE &lt;span&gt;802&lt;/span&gt;.1X/WPA/WPA2/EAP Authenticators, RADIUS client, EAP server, and RADIUS authentication server. The current version supports Linux (Host AP, madwifi, mac80211-&lt;span&gt;based drivers) and FreeBSD (net80211).
简单说就是hostapd是一个用户空间&lt;sup&gt;1&lt;/sup&gt;的守护进程，AP（access point）遵循IEEE的部分网络和安全协议。
hostapd官网：https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w1.fi/hostapd/&lt;/span&gt;
hostapd相关资料：https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w1.fi/cgit/hostap/plain/hostapd&lt;/span&gt;
&lt;span&gt;
标注1：用户空间是相对于内核空间去区别的，我们平时的操作基本都是在用户空间去进行的，简单的理解就是我们平时操作的Linux系统Gui，命令行，shell脚本，编译运行的C程序等等都是在用户空间的行为。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;以下是hostapd的简单配置：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
root@LEDE:~# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; hostapd.conf 
interface&lt;/span&gt;=&lt;span&gt;ap0        　　 #网口是ap0
bridge&lt;/span&gt;=br-lan       　　  #网桥是br-&lt;span&gt;lan
ssid&lt;/span&gt;=BPI_R2          　　 #SSID即无线信号的名称是BPI-&lt;span&gt;R2
driver&lt;/span&gt;=&lt;span&gt;nl80211      　　  #使用的驱动是nl80211 
country_code&lt;/span&gt;=&lt;span&gt;CN
hw_mode&lt;/span&gt;=&lt;span&gt;g                #使用的是2.4G
channel&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;                #信道是1
wpa_key_mgmt&lt;/span&gt;=WPA-&lt;span&gt;PSK     #加密算法
wpa_passphrase&lt;/span&gt;=ledetest  #创建的无线AP密码&lt;p&gt;关于hostapd.conf文件更多的信息，请查看这里：https://w1.fi/cgit/hostap/plain/hostapd/hostapd.conf
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;配置完成后，执行“hostapd -d hostapd.conf”创建无线热点：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
root@LEDE:~# hostapd -&lt;span&gt;d hostapd.conf 
Configuration &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;: hostapd.conf
[ &lt;/span&gt;&lt;span&gt;6102.269958&lt;/span&gt;] br-lan: port &lt;span&gt;5&lt;/span&gt;&lt;span&gt;(ap0) entered blocking state
[ &lt;/span&gt;&lt;span&gt;6102.275130&lt;/span&gt;] br-lan: port &lt;span&gt;5&lt;/span&gt;&lt;span&gt;(ap0) entered disabled state
[ &lt;/span&gt;&lt;span&gt;6102.280499&lt;/span&gt;&lt;span&gt;] device ap0 entered promiscuous mode
[ &lt;/span&gt;&lt;span&gt;6102.285076&lt;/span&gt;] br-lan: port &lt;span&gt;5&lt;/span&gt;&lt;span&gt;(ap0) entered blocking state
[ &lt;/span&gt;&lt;span&gt;6102.290176&lt;/span&gt;] br-lan: port &lt;span&gt;5&lt;/span&gt;&lt;span&gt;(ap0) entered forwarding state
ap0: interface state UNINITIALIZED&lt;/span&gt;-&amp;gt;&lt;span&gt;COUNTRY_UPDATE
Using interface ap0 with hwaddr &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:4a:ba:&lt;span&gt;50&lt;/span&gt; and ssid &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BPI_R2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
ap0: interface state COUNTRY_UPDATE&lt;/span&gt;-&amp;gt;&lt;span&gt;ENABLED
ap0: AP&lt;/span&gt;-ENABLED 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;看打印的log，可以看出热点以及创建成功了，接下来我用windows系统的笔记本去连接：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/351693/201808/351693-20180823094913673-587120671.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         连接成功，看来Openwrt已经把dhcp服务也配置好了，这里再简单引申一下dhcp服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　dhcp（Dynamic Host Configuration Protocol）动态主机配置协议，其实简单来讲，就是设备连入局域网时，可以动态获取到IP的一种协议。&lt;br/&gt;　　如果没有配置dhcp服务，设备连入局域网后，就获取不到IP，也就上不了Internet。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;我们来看一下R2上的dhcp服务：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
root@LEDE:~# &lt;span&gt;cat&lt;/span&gt; /etc/config/&lt;span&gt;dhcp 
config dnsmasq                         #dnsmasq是一个轻量级的dhcp，dns服务
        option domainneeded &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option boguspriv &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option filterwin2k &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option localise_queries &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option rebind_protection &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option rebind_localhost &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option local &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/lan/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option domain &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option expandhosts &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option nonegcache &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option authoritative &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option readethers &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option leasefile &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/tmp/dhcp.leases&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option resolvfile &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/tmp/resolv.conf.auto&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option nonwildcard &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option localservice &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

config dhcp &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option interface &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option start &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option limit &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option leasetime &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;12h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option dhcpv6 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option ra &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

config dhcp &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option interface &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option ignore &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

config odhcpd &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;odhcpd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option maindhcp &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option leasefile &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/tmp/hosts/odhcpd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option leasetrigger &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/sbin/odhcpd-update&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option loglevel &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        乍看上去，这里的dhcp配置让人有点心生畏惧，其实也不用太担心，我们先来简单看一下这个dhcp的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;我们先暂时略过dnsmasq和odhcpd，后续会添加讲解。
这里配置了两个接口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;和&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;为dhcp的方式，这两个接口必须也是在/etc/config/&lt;span&gt;network中被定义过的。
“wan”配置很简单，不用过多说明，我们来简单分析一下“lan”的配置：
&lt;br/&gt;config dhcp &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        option interface &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   #必须是在/etc/config/&lt;span&gt;network中被定义过的
        option start &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;       #从x.x.x.100开始分配IP
        option limit &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;       #一共有150个IP，也就是说这里的配置是x.x.x.&lt;span&gt;100&lt;/span&gt; - x.x.x.&lt;span&gt;249&lt;/span&gt;&lt;span&gt;
        option leasetime &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;12h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   #最长连接时间
        option dhcpv6 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;             &lt;span&gt;
        option ra &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;server'       &lt;/span&gt;#服务定义的模式是IPv6(RA &amp;amp; DHCPv6)&lt;p&gt;更多细节可以参考这里：https://openwrt.org/docs/guide-user/base-system/dhcp
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        接下来我用手机连接，然后测试R2无线网络的速度，当然这个速度是和R2连接的带宽相关联的，我这里是；&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/351693/201808/351693-20180823100935513-279879027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        看起来网速还算是比较快的；现在，我们就已经成功在R2上面部署了一个具有基础路由功能的Openwrt了。&lt;/p&gt;
&lt;p&gt;        接下来有人可能会遇到这个问题，我的R2关机或者重启了，之前配置好的环境没了，又要重新配置，有没有什么方法可以开机启动后去自动配置我要的环境呢？&lt;/p&gt;
&lt;p&gt;        答案当然是有的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先创建一个启动Ap的脚本&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
vim setup.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;         
#&lt;/span&gt;!/bin/&lt;span&gt;ash
wmt_loader &lt;/span&gt;&amp;amp;&lt;span&gt;
sheep &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
stp_uart_launcher &lt;/span&gt;-p /etc/firmware &amp;amp;
&lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; A &amp;gt; /dev/wmtWifi &amp;amp;
&lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
hostapd &lt;/span&gt;-d hostapd.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;然后再把setup.sh加到Openwrt的启动文件里&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
root@LEDE:~# vim /etc/&lt;span&gt;rc.local
# Put your custom commands here that should be executed once
# the system init finished. By default this &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; does nothing.
cd &lt;/span&gt;/root/             #我的setup.sh是放在/root目录下的，所以要先进入/root目录
&lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;6               &lt;span&gt;#这里sleep 6s是因为在等系统其它服务init完成&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
.&lt;/span&gt;/setup.&lt;span&gt;sh&lt;/span&gt; &amp;amp;&lt;span&gt;
exit &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;然后再套个盒子，接根天线，就有那么点意思了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/351693/201808/351693-20180823102701969-1248836529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        现在，一个简单的路由器产品就完成了。最后，有人可能会问，既然是要做一个路由器产品，不可能老是用命令行去操作吧，再怎么样也要有一个web的页面去配置吧。&lt;/p&gt;
&lt;p&gt;        说的没错，要实现web页面对路由器的配置，这里不得不提到Openwrt的好帮手Luci，那么下一篇我们就来看什么是Luci，以及如何配置。&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;欢迎大家批评指正，转载请注明出处，多谢。&lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 23 Aug 2018 07:44:00 +0000</pubDate>
<dc:creator>JackZengLab</dc:creator>
<og:description>上一篇讲解了R2的网口配置，这一篇我们以BananaPi R2为例子来实现一个简单的路由器；那么一个简单的路由器应该具备什么样的功能呢？最简单的说就是wan+lan+ap这三个功能。 首先wan+la</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/topbin/p/9519881.html</dc:identifier>
</item>
<item>
<title>2018.8.23 2018暑假集训之埃及分数 - lqxssf</title>
<link>http://www.cnblogs.com/qxds/p/9524143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qxds/p/9524143.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/10022&quot; target=&quot;_blank&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要利用这道题演示一下dfs如何进行剪枝&lt;/p&gt;
&lt;p&gt;感谢@si-ri-yang dalao的帮助&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;（1）读入优化 这个就不多解释了&lt;/p&gt;
&lt;p&gt;（2）运算优化 利用gcd算法&lt;/p&gt;
&lt;p&gt;（3）迭代加深 大概就是自己从小到大（贪心）枚举递归次数（共几个分数）&lt;/p&gt;
&lt;p&gt;（4）上下界优化&lt;/p&gt;
&lt;p&gt;每个分数分母的下界：上一个分数的分母+1、当前分母除以分子向上取整的最大值&lt;/p&gt;
&lt;p&gt;（证明：&lt;/p&gt;
&lt;p&gt;　　设待枚举分数为1/t&lt;/p&gt;
&lt;p&gt;　　目前剩余分数为a/b&lt;/p&gt;
&lt;p&gt;　　已知要求1/t&amp;lt;a/b所以t&amp;lt;b/a&lt;/p&gt;
&lt;p&gt;）&lt;/p&gt;
&lt;p&gt;　　　　　　   上界：当前分母除以分子乘以剩余递归深度（把之后所有分数累加到当前分数上）&lt;/p&gt;
&lt;p&gt;上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
inline &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; read()
{
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; f=&lt;span&gt;1&lt;/span&gt;,ans=&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(c&amp;lt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;||c&amp;gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;){&lt;span&gt;if&lt;/span&gt;(c==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)f=-&lt;span&gt;1&lt;/span&gt;;c=&lt;span&gt;getchar();}
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(c&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;c&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;){ans=ans*&lt;span&gt;10&lt;/span&gt;+c-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;c=&lt;span&gt;getchar();}
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; f*&lt;span&gt;ans;
}
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; a,b;
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; deep;
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; x[&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; cx(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; x)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;(x)==x) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;(x);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(x)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; gcd(&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a,&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; b)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(b==&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gcd(b,a%&lt;span&gt;b);
}
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; f=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; xx[&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dfs(&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; be,&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; ans,&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; fz,&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; fm)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fz&amp;lt;&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fm==&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ans==&lt;span&gt;deep)
    {
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fz-fm==&lt;span&gt;0&lt;/span&gt;||fz==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) 
        {
            f&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x[ans]&amp;lt;&lt;span&gt;xx[ans])
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=ans;i++) xx[i]=&lt;span&gt;x[i];
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; i=max(be+&lt;span&gt;1&lt;/span&gt;,cx(fm*&lt;span&gt;1.0&lt;/span&gt;/fz));i&amp;lt;=cx(fm*&lt;span&gt;1.0&lt;/span&gt;/fz*(deep-ans));i++&lt;span&gt;)
    {
        x[ans&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;i;
        dfs(i,ans&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;,i*fz-fm,i*&lt;span&gt;fm);
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    memset(xx,&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(xx));
    a&lt;/span&gt;=read(),b=&lt;span&gt;read();
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; c=&lt;span&gt;gcd(a,b);
    a&lt;/span&gt;/=c,b/=&lt;span&gt;c;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(deep=&lt;span&gt;0&lt;/span&gt;;deep&amp;lt;=&lt;span&gt;1000&lt;/span&gt;;deep++&lt;span&gt;)
    {
        dfs(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,a,b);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(f) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;deep;i++) cout&amp;lt;&amp;lt;xx[i]&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;xx[deep];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 23 Aug 2018 07:42:00 +0000</pubDate>
<dc:creator>lqxssf</dc:creator>
<og:description>又是一道dfs</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qxds/p/9524143.html</dc:identifier>
</item>
<item>
<title>文件的上传和下载--SpringMVC - 一飞要上天</title>
<link>http://www.cnblogs.com/yifeiyaoshangtian/p/9522806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yifeiyaoshangtian/p/9522806.html</guid>
<description>&lt;p&gt;通过&amp;lt;property&amp;gt;元素可以对文件解析类CommonsMultipartResolver的如下属性进行配置。&lt;/p&gt;&lt;p&gt;4）resolverLazily:推迟文件解析，以便在Controller中捕获文件大小异常&lt;/p&gt;&lt;p&gt;注：在配置CommonsMultipartResolver时必须指定该Bean的id为multipartResolver&lt;/p&gt;&lt;p&gt;需要导入支持文件上传的相关JAR包，通过Apache官网地址“http://commons.apache.org/”下载（进入该网址后，在Apache Conmmons Proper下方列表的Components列中找到FileUpload和IO，单击链接后，即可在打开页面找到下载链接）具体如下：&lt;/p&gt;&lt;p&gt;当完成页面表单和文件上传解析器的配置后，在Controller中编写文件上传的方法即可实现文件上传。文件上传的方法代码如下：&lt;/p&gt;&lt;div readability=&quot;156&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileUploadController {
        @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fileUpload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String handleFormUpload(@RequestParam(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) String name,@RequestParam(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filename&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) MultipartFile file,...) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;file.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体的执行方法&lt;/span&gt;
&lt;span&gt;                ...
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uploadSuccess&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转到成功页面&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uploadFailure&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转到失败页面&lt;/span&gt;
&lt;span&gt;        }
    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;在上述代码中，包含一个MultipartFile接口类型的参数file，上传到程序中的文件就是被封装在该参数中的。org.springframework.web.multipart.MultipartFile接口中提供了获取上传文件、文件名称等方法，这些方法及说明如下表01所示：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;方法&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p align=&quot;center&quot;&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;byte[] getBytes()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;以字节数组的形式返回文件的内容&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;String getContentType()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回文件的内容类型&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;InputStream getInputStream()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;读取文件内容，返回一个InputStream流&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;String getName()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;获取多部件form表单的参数名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;String getOriginalFilename()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;获取上传文件的初始化名&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;long getSize()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;获取上传文件的大小，单位是字节&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;boolean isEmpty()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;判断上传的文件是否为空&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;void transferTo(File file)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;将上传文件保存到目标目录下&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;center&quot;&gt;表01：MultipartFile接口中的主要方法&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接下来我们用一个具体的案例来演示文件上传功能的实现，具体步骤如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）在eclipse中创建一个名为fileUpload的动态Web项目，将Spring MVC相关的JAR包以及支持文件上传下载的JAR包添加到项目的lib目录中。添加后的lib目录如图01所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1457568/201808/1457568-20180823105835683-1053754471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;图01：Spring MVC环境下文件上传下载的JAR包&lt;/p&gt;

&lt;p&gt;（2）在web.xml文件中，配置Spring MVC的前端控制器等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;web-app xmlns:xsi=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://xmlns.jcp.org/xml/ns/javaee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; xsi:schemaLocation=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebApp_ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;display-name&amp;gt;fileUpload&amp;lt;/display-name&amp;gt;
  &amp;lt;welcome-file-list&amp;gt;
    &amp;lt;welcome-file&amp;gt;index.html&amp;lt;/welcome-file&amp;gt;
  &amp;lt;/welcome-file-list&amp;gt;
  
  &amp;lt;!-- 配置 DispatcherServlet 前端控制器 --&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    
        &amp;lt;!-- 在此处调用 springmvc.xml 文件 --&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:springmvc-config.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;

        &amp;lt;!-- 在 tomcat 服务器启动的时候，最先加载它 --&amp;gt;
        &amp;lt;load-on-startup&amp;gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;hello&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;*.action&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
  
&amp;lt;/web-app&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）右键fileUpload项目,新建Source Floder文件夹（专门用来存放配置文件等），创建并编写Spring MVC的核心配置文件springmvc-config.xml,如文件01所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;beans xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
    xmlns:aop&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:mvc&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/mvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;
&lt;/span&gt;                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/mvc/spring-mvc.xsd&lt;/span&gt;
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;

    &amp;lt;!-- 定义组件扫描器，指定需要扫描的包 --&amp;gt;
    &amp;lt;context:component-scan &lt;span&gt;base&lt;/span&gt;-package=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.neuedu.controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;!-- 配置注解驱动 --&amp;gt;
    &amp;lt;mvc:annotation-driven /&amp;gt;
    &amp;lt;!-- 定义视图解析器 --&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewResolver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.springframework.web.servlet.view.InternalResourceViewResolver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;!-- 设置前缀 --&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prefix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/WEB-INF/jsp/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
        &amp;lt;!-- 设置后缀 --&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;suffix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.jsp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置文件上传解析器 MultipartResolver --&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multipartResolver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.springframework.web.multipart.commons.CommonsMultipartResolver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;!-- 设置请求编码格式 --&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;defaultEncoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;文件01：springmvc-config.xml&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;（4）在WebContext目录下，创建一个用于上传文件的页面fileUpload.jsp,编辑后如文件02所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;%@ page language=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; contentType=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;title&amp;gt;文件上传&amp;lt;/title&amp;gt;
&amp;lt;script&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否填写上传人并已选择上传文件&lt;/span&gt;
&lt;span&gt;function check(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = document.getElementById(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file = document.getElementById(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(name==&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;){
        alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请填写上传人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(file.length==&lt;span&gt;0&lt;/span&gt;||file==&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;){
        alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请选择上传文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${pageContext.request.contextPath}/fileUpload.action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; enctype=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multipart/form-data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onsubmit=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;return check()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
上传人：&lt;/span&gt;&amp;lt;input id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&amp;lt;br /&amp;gt;&lt;span&gt;
请选择文件：&lt;/span&gt;&amp;lt;input id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uploadfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; multiple=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multiple&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件上传&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件02：fileUpload.jsp&lt;/p&gt;

&lt;p&gt;（5）在WEB-INF目录下，创建jsp文件夹，并在文件夹中创建success.jsp和error.jsp文件，分别在两个文件的&amp;lt;body&amp;gt;元素内编写显示上传成功的信息（如：&quot;文件上传成功！&quot;）和显示上传失败的信息（如&quot;文件上传失败，请重新上传！&quot;）&lt;/p&gt;

&lt;p&gt;（6）在src目录下，创建一个com.neuedu.controller包，在该包下创建一个用于文件上传的控制器类FileUploadController，如文件03所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.neuedu.controller;

import java.io.File;
import java.util.List;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 文件上传
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileUploadController {

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 执行文件上传
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/fileUpload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String handleFormUpload(@RequestParam(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) String name,@RequestParam(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uploadfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) List&amp;lt;MultipartFile&amp;gt;&lt;span&gt; uploadfile,HttpServletRequest request) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断所上传文件是否存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(!uploadfile.isEmpty() &amp;amp;&amp;amp; uploadfile.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环输出上传的文件&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(MultipartFile file : uploadfile) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取上传文件的原始名称&lt;/span&gt;
                String originalFilename =&lt;span&gt; file.getOriginalFilename();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置上传文件的保存地址目录&lt;/span&gt;
                String dirPath = request.getServletContext().getRealPath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/upload/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                File filePath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(dirPath);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果保存文件的地址不存在，就先创建目录&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;filePath.exists()) {
                    filePath.mkdirs();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用UUID重新命名上传的文件名称（上传人_uuid_原始文件名称）&lt;/span&gt;
                String newFilename = name+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+UUID.randomUUID()+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;originalFilename;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用MultipartFile接口的方法完成文件上传到指定位置&lt;/span&gt;
                    file.transferTo(&lt;span&gt;new&lt;/span&gt; File(dirPath +&lt;span&gt; newFilename));
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e) {
                    e.printStackTrace();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转的成功页面&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件03：FileUploadController.java&lt;/p&gt;

&lt;p&gt;（7）将项目发布到Tomcat服务器中并启动，在浏览器中访问地址 http://localhost:8080/fileUpload/fileUpload.jsp，填写上传人，选择文件上传，效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1457568/201808/1457568-20180823153504591-730078868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（8）如果成功上传，此时查看项目的发布目录，即可发现在fileUpload项目中多了一个upload文件夹，该文件夹存放着你所上传的文件，并且以&quot;上传人_uuid_原始文件名称&quot;的形式。&lt;/p&gt;
&lt;p&gt;注意：upload文件夹是在项目的发布路径中，而不是创建的项目所在目录。如果未更改项目的发布路径，则要去工作空间的metadata目录中寻找项目发布目录（路径为：workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\fileUpload\upload）；如果将项目的发布路径已经更改到Tomcat中，则需要在Tomcat的webapps目录中寻找项目。&lt;/p&gt;
&lt;p&gt;至此，文件上传功能的实现演示完毕，整个项目目录如图02所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1457568/201808/1457568-20180823113417536-2062941899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;p&gt;&lt;span&gt;&lt;strong&gt;二．&lt;/strong&gt;&lt;strong&gt;文件下载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;文件下载就是将文件服务器中的文件下载到本机上。在Spring MVC环境中实现文件下载大致可分为如下两个步骤:&lt;/p&gt;
&lt;p&gt;&amp;lt;1&amp;gt;在客户端页面使用一个文件下载的超链接，该链接的href属性要指定后台文件下载的方法和文件名（需要先在文件下载目录中添加一个名称为“1.jpg”的文件），具体代码实例如下：&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&quot;${pageContext.request.contextPath }/download.action?filename=1.jpg&quot;&amp;gt;文件下载&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;2&amp;gt;在后台Controller类中，使用Spring MVC提供的文件下载方法进行文件下载。&lt;/p&gt;
&lt;p&gt;Spring MVC提供了一个ResponseEntity类型的对象，使用它可以定义返回的HttpHeaders对象和HttpStatus对象，通过对这两个对象的设置，即可完成下载文件时所需的配置信息。文件下载的实例代码如下所示:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/&lt;span&gt;download&lt;/span&gt;&quot;&lt;span&gt;)
Public ResponseEntity&lt;/span&gt;&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt;&lt;span&gt; fileDownload(HttpServletRequest request,String filename) throws Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定要下载的文件所在路径&lt;/span&gt;
String path = request.getServletContext().getRealPath(“/upload/&lt;span&gt;”);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建该文件对象&lt;/span&gt;
File file = &lt;span&gt;new&lt;/span&gt; File(Path+File.separator+&lt;span&gt;filename);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应头&lt;/span&gt;
HttpHeaders headers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpHeaders();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知浏览器以下载的方式打开文件&lt;/span&gt;
&lt;span&gt;headers.setContentDispositionFormData(&quot;&lt;span&gt;attachment&lt;/span&gt;&quot;,filename);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义以流的形式下载返回文件数据&lt;/span&gt;
&lt;span&gt;headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Spring MVC框架的ResponseEntity对象封装返回下载数据&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ResponseEntity&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt;&lt;span&gt;(FileUtils.readFileToByteArray(file),headers,HttpStatus.OK);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;接下来我们用一个具体的案例来演示文件下载功能的实现，具体步骤如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(1)按照之前的步骤搭建好环境和配置文件，创建一个页面文件fileDownload.jsp，将上面&amp;lt;1&amp;gt;步骤的代码插入body元素之间，如下文件04所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;%@ page language=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; contentType=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;title&amp;gt;文件下载&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${pageContext.request.contextPath }/fileDownload.action?filename=1.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;文件下载
&lt;/span&gt;&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件04：fileDownload.jsp&lt;/p&gt;

&lt;p&gt;(2)在src下新建com.neuedu.controller包，并在该包下新建FileUploadController，将上面&amp;lt;2&amp;gt;步骤的fileDownload()方法编写在FileUploadController类中。如文件05所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.neuedu.controller;

import java.io.File;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.io.FileUtils;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; fileDownloadController {
    
    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/fileDownload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt;&lt;span&gt; fileDownload(HttpServletRequest request,String filename) throws Exception {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定要下载的文件所在路径&lt;/span&gt;
    String path = request.getServletContext().getRealPath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/upload/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建该文件对象&lt;/span&gt;
    File file = &lt;span&gt;new&lt;/span&gt; File(path+File.separator+&lt;span&gt;filename);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应头&lt;/span&gt;
    HttpHeaders headers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpHeaders();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知浏览器以下载的方式打开文件&lt;/span&gt;
    headers.setContentDispositionFormData(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;attachment&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,filename);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义以流的形式下载返回文件数据&lt;/span&gt;
&lt;span&gt;    headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Spring MVC框架的ResponseEntity对象封装返回下载数据&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ResponseEntity&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt;&lt;span&gt;(FileUtils.readFileToByteArray(file),headers,HttpStatus.OK);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件05：FileUploadController.java&lt;/p&gt;
&lt;p&gt;(3)发布项目并启动Tomcat服务器,在文件下载目录下 &quot;workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\fileDownload&quot;下新建一个文件夹&quot;upload&quot;（命名要和&lt;span&gt;fileDownload&lt;/span&gt;()方法中的&lt;span&gt;指定要下载的文件所在路径&lt;span&gt;一样&lt;/span&gt;&lt;/span&gt;），将一个命名为&quot;1.jpg&quot;（命名要与超链接中的参数filename的属性值一致）的图片拖进upload文件夹中。&lt;/p&gt;
&lt;p&gt;最后，在浏览器中访问地址http://localhost:8080/fileDownload/fileDownload.jsp，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1457568/201808/1457568-20180823152445686-1036838687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击”文件下载“链接后，出现下载提示弹窗，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1457568/201808/1457568-20180823152654234-2123161942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择”保存文件“，并单击”确定“按钮后，即可下载该文件。（在浏览器的下载窗口就可看到所下载的文件啦！！！）&lt;/p&gt;

&lt;p&gt;文件的下载功能的实现演示到此完毕，整个项目目录如图02所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1457568/201808/1457568-20180823153205308-1862530279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;转载请标明出处，谢谢~&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 23 Aug 2018 07:39:00 +0000</pubDate>
<dc:creator>一飞要上天</dc:creator>
<og:description>文件的上传和下载是项目开发中最常用的功能，例如图片的上传和下载、邮件附件的上传和下载等。 接下来，将对Spring MVC环境中文件的上传和下载进行详细的讲解。 一．文件上传 多数文件上传都是通过表单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yifeiyaoshangtian/p/9522806.html</dc:identifier>
</item>
<item>
<title>JVM问题定位的瑞士军刀——JCMD - jianyuan</title>
<link>http://www.cnblogs.com/yflog/p/9524103.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yflog/p/9524103.html</guid>
<description>&lt;p&gt;&lt;code&gt;jcmd&lt;/code&gt;是jdk自带的一个神器，能够很方便的对java程序进行profiling。jcmd其实可以替代很多常用的工具，比如jstak，jmap。接下来让我们了解下什么是jcmd，jcmd能够帮助我们定位什么问题？工作中我们如何使用jcmd。&lt;/p&gt;
&lt;p&gt;从jdk7开始，jcmd就是jdk自带的一个工具。在正确配置了JDK的PATH的情况下，我们可以直接在命令行中执行&lt;code&gt;jcmd&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@vincent-testing ~]# jcmd -h
Usage: jcmd &amp;lt;pid | main class&amp;gt; &amp;lt;command ...|PerfCounter.print|-f file&amp;gt;
   or: jcmd -l
   or: jcmd -h

  command must be a valid jcmd command for the selected jvm.
  Use the command &quot;help&quot; to see which commands are available.
  If the pid is 0, commands will be sent to all Java processes.
  The main class argument will be used to match (either partially
  or fully) the class used to start Java.
  If no options are given, lists Java processes (same as -p).

  PerfCounter.print display the counters exposed by this process
  -f  read and execute commands from the file
  -l  list JVM processes on the local machine
  -h  this help&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用jcmd，我们能做很多事情，比如，抓现场堆栈(dump threads)，抓运行时堆内存(dump heap),采集GC日志，定位高CPU占用问题等。&lt;/p&gt;

&lt;p&gt;在没有jcmd的时候，我们也有很多找出JVM进程的方法，比如：linux下通过ps，使用jdk自带的jps等。使用jcmd，我们同样可以做到：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@vincent-testing ~]# jcmd -l
13714 sun.tools.jcmd.JCmd -l
16324 org.rzo.yajsw.app.WrapperJVMMain
9350 org.rzo.yajsw.app.WrapperJVMMain
9815 org.apache.catalina.startup.Bootstrap start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;jcmd -l&lt;/code&gt;可以列出所有的Java程序，其功能和&lt;code&gt;jps&lt;/code&gt;其实是一样的。&lt;/p&gt;

&lt;p&gt;列出所有的JVM程序，找到你感兴趣的进程id，运行&lt;code&gt;jcmd &amp;lt;PID&amp;gt; help&lt;/code&gt;，看看我们可以做些什么：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@vincent-testing ~]# jcmd 9350 help
9350:
The following commands are available:
JFR.stop
JFR.start
JFR.dump
JFR.check
VM.native_memory
VM.check_commercial_features
VM.unlock_commercial_features
ManagementAgent.stop
ManagementAgent.start_local
ManagementAgent.start
GC.rotate_log
Thread.print
GC.class_stats
GC.class_histogram
GC.heap_dump
GC.run_finalization
GC.run
VM.uptime
VM.flags
VM.system_properties
VM.command_line
VM.version
help

For more information about a specific command use 'help &amp;lt;command&amp;gt;'.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，jcmd给我们提供了很多的功能。这里我们先说几个简单的。&lt;/p&gt;
&lt;h2 id=&quot;抓现场堆栈&quot;&gt;抓现场堆栈&lt;/h2&gt;
&lt;p&gt;相信大部分的Java程序员肯定都用过&lt;code&gt;jstack&lt;/code&gt;，通过&lt;code&gt;jstack&lt;/code&gt;可以dump当前JVM的线程堆栈。通过&lt;code&gt;jstack &amp;lt;PID&amp;gt; Thread.print&lt;/code&gt;可以达到一样的目的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  ~ jcmd 3426 Thread.print
3426:
2018-08-02 21:36:07
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.144-b01 mixed mode):

&quot;Attach Listener&quot; #16 daemon prio=9 os_prio=31 tid=0x00007fd9a43d0000 nid=0xd07 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;NettythreadDeathWatcher-2-1&quot; #15 daemon prio=1 os_prio=31 tid=0x00007fd9a4ca1800 nid=0xa903 waiting on condition [0x0000700005924000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
    at java.lang.Thread.sleep(Native Method)
    at io.netty.util.ThreadDeathWatcher$Watcher.run(ThreadDeathWatcher.java:152)
    at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
    at java.lang.Thread.run(Thread.java:748)

&quot;DestroyJavaVM&quot; #14 prio=5 os_prio=31 tid=0x00007fd9a3b7f800 nid=0x1a03 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE
....  other threads ommited ... &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要在线程dump中包含锁信息，需要加上&lt;code&gt;-l=true&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  ~ jcmd 3426  Thread.print -l=true
3426:
2018-08-02 21:39:08
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.144-b01 mixed mode):

&quot;Attach Listener&quot; #16 daemon prio=9 os_prio=31 tid=0x00007fd9a43d0000 nid=0xd07 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
    - None

&quot;NettythreadDeathWatcher-2-1&quot; #15 daemon prio=1 os_prio=31 tid=0x00007fd9a4ca1800 nid=0xa903 waiting on condition [0x0000700005924000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
    at java.lang.Thread.sleep(Native Method)
    at io.netty.util.ThreadDeathWatcher$Watcher.run(ThreadDeathWatcher.java:152)
    at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
    at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
    - None
.... other threads ommited&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;抓取堆内存&quot;&gt;抓取堆内存&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;➜  ~ jcmd 3426 help GC.heap_dump
3426:
GC.heap_dump
Generate a HPROF format dump of the Java heap.

Impact: High: Depends on Java heap size and content. Request a full GC unless the '-all' option is specified.

Permission: java.lang.management.ManagementPermission(monitor)

Syntax : GC.heap_dump [options] &amp;lt;filename&amp;gt;

Arguments:
    filename :  Name of the dump file (STRING, no default value)

Options: (options must be specified using the &amp;lt;key&amp;gt; or &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; syntax)
    -all : [optional] Dump all objects, including unreachable objects (BOOLEAN, false)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你定位过内存泄漏相关的问题，那么你肯定知道如何dump堆内存，或者查看堆内存中的类分布。通常之前我们使用的工具是&lt;code&gt;jmap&lt;/code&gt;，使用jcmd转存堆内存的方法是使用&lt;code&gt;GC.heap_dump&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;➜  ~ jcmd 3426 GC.heap_dump test.dump
3426:
Heap dump file created&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常情况，在dump堆内存钱会触发一次full GC，如果不希望触发full GC，可以指定参数&lt;code&gt;all=true&lt;/code&gt;，即:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;➜  ~ jcmd 3426 GC.heap_dump test2.dump -all=true
3426:
Heap dump file created&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;统计堆内存使用情况&quot;&gt;统计堆内存使用情况&lt;/h2&gt;
&lt;p&gt;转存堆内存并分析相对来说比较复杂，一个更简单的方法是统计堆中对象的直方图。在没有jcmd的时候，我通常是使用jmap来统计堆中对象的分布，如果想使用jcmd统计堆中对象的分布，使用&lt;code&gt;jcmd &amp;lt;PID&amp;gt; GC.class_histogram&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;jcmd命令中包还有其他很多工具，大家如果感兴趣可以通过&lt;code&gt;jcmd &amp;lt;PID&amp;gt; help &amp;lt;command&amp;gt;&lt;/code&gt;查看。在没有jcmd工具之前，我们通常需要组合使用多个不同的工具进行问题定位，而现在只需要使用jcmd一个命令就可以了。除了替代现有的工具之后，jcmd还支持更高级的profiling功能，录制jfr来分析JVM的性能。&lt;/p&gt;
&lt;blockquote readability=&quot;3.2869565217391&quot;&gt;
&lt;p&gt;[文章同步发布在我的&lt;a href=&quot;https://jianyuan.me/&quot;&gt;个人博客&lt;/a&gt;上，欢迎拍砖。&lt;br/&gt;传送门： &lt;a href=&quot;https://jianyuan.me/2018/08/02/jcmd-intro/&quot;&gt;JVM问题定位的瑞士军刀——JCMD&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 23 Aug 2018 07:37:00 +0000</pubDate>
<dc:creator>jianyuan</dc:creator>
<og:description>`jcmd`是jdk自带的一个神器，能够很方便的对java程序进行profiling。jcmd其实可以替代很多常用的工具，比如jstak，jmap。接下来让我们了解下什么是jcmd，jcmd能够帮助我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yflog/p/9524103.html</dc:identifier>
</item>
<item>
<title>python3-开发进阶Flask的基础（3） - 天王盖地虎宝塔镇河妖</title>
<link>http://www.cnblogs.com/ManyQian/p/9524074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManyQian/p/9524074.html</guid>
<description>&lt;p&gt;上篇我们大概简单描述了一下上下文管理，这篇来具体来说说，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上下管理的request&lt;/li&gt;
&lt;li&gt;上下管理的session&lt;/li&gt;
&lt;li&gt;第三方组件：flask-session&lt;/li&gt;
&lt;li&gt;pymysql操作数据库  数据库连接池&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;一、前奏&lt;/h2&gt;
&lt;h3&gt;1、一个新名词：偏函数   （可以帮你自动传参数）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; functools   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;装饰器用过的模块&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index(a,b):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b

new_fun&lt;/span&gt;=functools.partial(index,666)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;666当作第一个参数&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;原来的调用&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; ret=index(1,2)&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; print(ret)&lt;/span&gt;
ret=new_fun(1)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;偏函数，帮助开发者自动传递参数&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2、super和执行类的区别？&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Base.func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(Base):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;方式一：根据mro的顺序执行方法  &lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; super().func()&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;方式二：主动执行Base类的方法&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Base.func(self)&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo.func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

obj&lt;/span&gt;=&lt;span&gt;Foo()
obj.func()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(obj.&lt;span&gt;__mro__&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3、面向对象中特殊方法 setattr/getattr注意事项：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;self.duoduo={}    直接定于会发现调用__setattr__方法时，还没有生成会报错&lt;/span&gt;
        object.&lt;span&gt;__setattr__&lt;/span&gt;(self,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;duoduo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{})

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setattr__&lt;/span&gt;&lt;span&gt;(self, key, value):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(key,value,self.duoduo)

obj&lt;/span&gt;=&lt;span&gt;Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(obj.duoduo)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;四、栈&lt;/h3&gt;
&lt;p&gt;基于列表实现的一个栈：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Stack(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.data&lt;/span&gt;=&lt;span&gt;[]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; push(self,val):
        self.data.append(val)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pop(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data.pop()

_stack&lt;/span&gt;=&lt;span&gt;Stack()
_stack.push(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大娃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
_stack.push(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;二娃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(_stack.pop())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(_stack.pop())
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5、Local类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; greenlet &lt;span&gt;import&lt;/span&gt; getcurrent as get_ident   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取协程的唯一标记&lt;/span&gt;
&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt; get_ident   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取线程的唯一标记&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Local(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        object.&lt;/span&gt;&lt;span&gt;__setattr__&lt;/span&gt;(self,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;storage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{})

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setattr__&lt;/span&gt;&lt;span&gt;(self, key, value):
        ident&lt;/span&gt;=&lt;span&gt;get_ident()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ident &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.storage:
            self.storage[ident]&lt;/span&gt;=&lt;span&gt;{key,value}
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            self.storage[ident][key]&lt;/span&gt;=&lt;span&gt;value

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getattr__&lt;/span&gt;&lt;span&gt;(self, item):
        ident&lt;/span&gt;=&lt;span&gt;get_ident()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ident &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.storage:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.storage[ident].get(item)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是我们自己写的，我们再去看看flask中的Local类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt; globals  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;点globals&lt;/span&gt;
&lt;span&gt;
_request_ctx_stack &lt;/span&gt;= LocalStack()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;点LocalStack()&lt;/span&gt;
&lt;span&gt;
self._local &lt;/span&gt;= Local()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;点Local&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看看上面导入的模块：一样的，优先协程，然后线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180822170758679-64464407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; __slots__,只能访问什么属性的范围&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180822171721665-1447083584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180822174307424-1665465487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180822182151688-1107817680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;6、全局变量只有在初次加载时执行&lt;/h3&gt;
&lt;h2&gt;二、上下文管理 request&lt;/h2&gt;
&lt;p&gt;1、wsgi   初步处理请求&lt;/p&gt;
&lt;p&gt;2 、 __call__方法   执行wsgi_app &lt;/p&gt;
&lt;p&gt;3、ctx=RequestContextsession,request)   再执行  ctx.push()&lt;/p&gt;
&lt;p&gt;4、LocalStack对象 把ctx对象添加到local中&lt;/p&gt;
&lt;p&gt;5、Local     存数据的时__storage__={'唯一标识'：{stack:[ctx,]}}&lt;/p&gt;
&lt;p&gt;6、视图函数&lt;/p&gt;

&lt;p&gt;上下文管理：session &lt;/p&gt;
&lt;p&gt;就一个流程，别的基本上一样，&lt;/p&gt;
&lt;p&gt;最后通过localstack获取ctx中的session,给session赋值（从cookie中读取数据）&lt;/p&gt;

&lt;h2&gt;三、flask-session &lt;/h2&gt;
&lt;p&gt;先下载第三方的库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip3 install  flask-session
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; flask.sessions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SecureCookieSessionInterface
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; flask_session &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Session

duo&lt;/span&gt;=Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;duo.session_interface=SecureCookieSessionInterface()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;duo.session_interface=RedisSessionInterface()&lt;/span&gt;
duo.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SESSION_TYPE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
duo.config[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SESSION_TYPE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=redis.Redis(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;11.1.11.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,port=6379,password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Session(duo)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们来看看Session里面是什么：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180823085030846-1745585653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;app.session_interface赋值，再来看看sef._get_interface(app)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180823085710488-1568765327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180823085941311-1223886835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这下我们来说说他的原理：&lt;/p&gt;
&lt;p&gt;最开始请求进来的时候，这时是根本没有sesiion,找到他的session,执行open_session&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180823091353042-696179099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行完open_session,就要保存在浏览器上执行save_session&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180823093542021-725115235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存好后，下次再来访问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180823093743170-1216163222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;session 数据保存到redis   session：随机字符串（每个线程或协程都不一样）&lt;/li&gt;
&lt;li&gt;随机字符串返回给用户&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;查看源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; flask_session &lt;span&gt;import&lt;/span&gt; RedisSessionInterface
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;四、数据库连接池&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip3 install DBUtils
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一批连接到连接池，供所有线程共享使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; DBUtils.PooledDB &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PooledDB, SharedDBConnection
POOL &lt;/span&gt;=&lt;span&gt; PooledDB(
    creator&lt;/span&gt;=pymysql,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用链接数据库的模块&lt;/span&gt;
    maxconnections=6,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接池允许的最大连接数，0和None表示不限制连接数&lt;/span&gt;
    mincached=2,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化时，链接池中至少创建的空闲的链接，0表示不创建&lt;/span&gt;
    maxcached=5,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 链接池中最多闲置的链接，0和None不限制&lt;/span&gt;
    maxshared=3,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 链接池中最多共享的链接数量，0和None表示全部共享。&lt;br/&gt;PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少，_maxcached永远为0，&lt;br/&gt;所以永远是所有链接都共享。&lt;/span&gt;
    blocking=True,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错&lt;/span&gt;
    maxusage=None,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一个链接最多被重复使用的次数，None表示无限制&lt;/span&gt;
    setsession=[],  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]&lt;/span&gt;
    ping=&lt;span&gt;0,
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ping MySQL服务端，检查是否服务可用。&lt;br/&gt;# 如：0 = None = never, 1 = default = whenever it is requested, &lt;br/&gt;2 = when a cursor is created, 4 = when a query is executed, 7 = always&lt;/span&gt;
    host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    port&lt;/span&gt;=3306&lt;span&gt;,
    user&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    password&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    database&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    charset&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检测当前正在运行连接数的是否小于最大链接数，如果不小于则：等待或报raise TooManyConnections异常&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 否则&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 则优先去初始化时创建的链接中获取链接 SteadyDBConnection。&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 然后将SteadyDBConnection对象封装到PooledDedicatedDBConnection中并返回。&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果最开始创建的链接没有链接，则去创建一个SteadyDBConnection对象，再封装到PooledDedicatedDBConnection中并返回。&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一旦关闭链接后，连接就返回到连接池让后续线程继续使用。&lt;/span&gt;
    conn =&lt;span&gt; POOL.connection()
    cursor &lt;/span&gt;= conn.cursor(pymysql.cursors.DictCursor)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;pymsql&lt;/span&gt;
    cursor.execute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from tb1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    result &lt;/span&gt;=&lt;span&gt; cursor.fetchall()
    conn.close()


func()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;　　使用数据库要用连接池&lt;/p&gt;
&lt;p&gt; 　  封装SQLHelper&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 07:34:00 +0000</pubDate>
<dc:creator>天王盖地虎宝塔镇河妖</dc:creator>
<og:description>上篇我们大概简单描述了一下上下文管理，这篇来具体来说说， 一、前奏 1、一个新名词：偏函数 （可以帮你自动传参数） 2、super和执行类的区别？ 3、面向对象中特殊方法 setattr/getatt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ManyQian/p/9524074.html</dc:identifier>
</item>
<item>
<title>P2P网络数据处理流程 - 区块链</title>
<link>http://www.cnblogs.com/blockchain/p/9523964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blockchain/p/9523964.html</guid>
<description>&lt;h2&gt;P2P网络数据处理流程&lt;/h2&gt;
&lt;p&gt;监听(ListenLoop)+拨号(Dial) –&amp;gt; 建立连接(SetupConn) –&amp;gt; Enc 握手(doEncHandshake) –&amp;gt; 协议握手(doProtoHandshake) –&amp;gt; 添加Peer Addpeer –&amp;gt; Run Peer&lt;/p&gt;
&lt;h2&gt;1. Enc握手 doEncHandshake&lt;/h2&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_1_1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;监听时接收到Enc握手：receiverEncHandshake&lt;/p&gt;
&lt;p&gt;拨号时发起初始End握手：initiatorEncHandshake&lt;/p&gt;
&lt;p&gt;链接的发起者被称为initiator（主动拨号），链接的被动接受者被成为receiver（被动监听）。 这两种模式下处理的流程是不同的，完成握手后， 生成了一个sec可以理解为拿到了对称加密的密钥。 然后创建了一个newRLPXFrameRW帧读写器，完成加密信道的创建过程。&lt;/p&gt;
&lt;p&gt;initiatorEncHandshake 和receiverEncHandshake有些像，但逻辑处理是相反的过程。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;makeAuthMsg&lt;/h3&gt;
&lt;p&gt;makeAuthMsg这个方法创建了handshake message。 首先对端的公钥可以通过对端的ID来获取。对端的公钥对于发起者来说是知道的；对于接收者来说是不知道的。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_4.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据对端的ID计算出对端公钥remotePub&lt;/li&gt;
&lt;li&gt;生成一个随机的初始值initNonce&lt;/li&gt;
&lt;li&gt;生成一个随机的私钥&lt;/li&gt;
&lt;li&gt;使用自己的私钥和对方的公钥生成的一个共享秘密&lt;/li&gt;
&lt;li&gt;用共享秘密来加密这个initNonce&lt;/li&gt;
&lt;li&gt;这里把发起者的公钥告知对方&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这一步，主要是构建authMsgV4结构体。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;sealEIP8&lt;/h3&gt;
&lt;p&gt;sealEIP8对msg进行rlp的编码，填充一下数据，然后使用对方的公钥把数据进行加密。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;readHandshakeMsg&lt;/h3&gt;
&lt;p&gt;readHandshakeMsg有两个地方调用： 一个是在initiatorEncHandshake，另外一个就是在receiverEncHandshake。 这个方法比较简单， 首先用一种格式尝试解码，如果不行就换另外一种。基本上就是使用自己的私钥进行解码然后调用rlp解码成结构体。 结构体的描述就是authRespV4，里面最重要的就是对端的随机公钥。 双方通过自己的私钥和对端的随机公钥可以得到一样的共享秘密。 而这个共享秘密是第三方拿不到的。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_7.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;secrets&lt;/h3&gt;
&lt;p&gt;secrets函数是在handshake完成之后调用。它通过自己的随机私钥和对端的公钥来生成一个共享秘密,这个共享秘密是瞬时的(只在当前这个链接中存在)。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个函数计算出IngressMAC和EgressMAC用于rlpxFrameRW中ReadMsg，WriteMsg数据的接收发送。&lt;/p&gt;
&lt;h3&gt;数据帧结构&lt;/h3&gt;
&lt;table&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;27&quot;&gt;&lt;td class=&quot;gutter&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;span class=&quot;line-number&quot;&gt;1
&lt;span class=&quot;line-number&quot;&gt;2
&lt;span class=&quot;line-number&quot;&gt;3
&lt;span class=&quot;line-number&quot;&gt;4
&lt;span class=&quot;line-number&quot;&gt;5
&lt;span class=&quot;line-number&quot;&gt;6
&lt;span class=&quot;line-number&quot;&gt;7
&lt;span class=&quot;line-number&quot;&gt;8
&lt;span class=&quot;line-number&quot;&gt;9
&lt;span class=&quot;line-number&quot;&gt;10
&lt;span class=&quot;line-number&quot;&gt;11
&lt;span class=&quot;line-number&quot;&gt;12
&lt;span class=&quot;line-number&quot;&gt;13
&lt;span class=&quot;line-number&quot;&gt;14
&lt;span class=&quot;line-number&quot;&gt;15
&lt;span class=&quot;line-number&quot;&gt;16
&lt;span class=&quot;line-number&quot;&gt;17
&lt;span class=&quot;line-number&quot;&gt;18
&lt;span class=&quot;line-number&quot;&gt;19
&lt;span class=&quot;line-number&quot;&gt;20
&lt;span class=&quot;line-number&quot;&gt;21
&lt;span class=&quot;line-number&quot;&gt;22
&lt;span class=&quot;line-number&quot;&gt;23
&lt;span class=&quot;line-number&quot;&gt;24
&lt;span class=&quot;line-number&quot;&gt;25
&lt;span class=&quot;line-number&quot;&gt;26
&lt;span class=&quot;line-number&quot;&gt;27
&lt;span class=&quot;line-number&quot;&gt;28
&lt;span class=&quot;line-number&quot;&gt;29
&lt;span class=&quot;line-number&quot;&gt;30
&lt;span class=&quot;line-number&quot;&gt;31
&lt;span class=&quot;line-number&quot;&gt;32
&lt;span class=&quot;line-number&quot;&gt;33
&lt;span class=&quot;line-number&quot;&gt;34
&lt;span class=&quot;line-number&quot;&gt;35
&lt;span class=&quot;line-number&quot;&gt;36
&lt;span class=&quot;line-number&quot;&gt;37
&lt;span class=&quot;line-number&quot;&gt;38
&lt;span class=&quot;line-number&quot;&gt;39
&lt;span class=&quot;line-number&quot;&gt;40
&lt;span class=&quot;line-number&quot;&gt;41
&lt;span class=&quot;line-number&quot;&gt;42
&lt;span class=&quot;line-number&quot;&gt;43
&lt;span class=&quot;line-number&quot;&gt;44
&lt;span class=&quot;line-number&quot;&gt;45
&lt;span class=&quot;line-number&quot;&gt;46
&lt;span class=&quot;line-number&quot;&gt;47
&lt;span class=&quot;line-number&quot;&gt;48
&lt;span class=&quot;line-number&quot;&gt;49
&lt;span class=&quot;line-number&quot;&gt;50
&lt;span class=&quot;line-number&quot;&gt;51
&lt;span class=&quot;line-number&quot;&gt;52
&lt;span class=&quot;line-number&quot;&gt;53
&lt;span class=&quot;line-number&quot;&gt;54
&lt;span class=&quot;line-number&quot;&gt;55
&lt;span class=&quot;line-number&quot;&gt;56
&lt;span class=&quot;line-number&quot;&gt;57
&lt;span class=&quot;line-number&quot;&gt;58
&lt;span class=&quot;line-number&quot;&gt;59
&lt;span class=&quot;line-number&quot;&gt;60
&lt;span class=&quot;line-number&quot;&gt;61
&lt;span class=&quot;line-number&quot;&gt;62
&lt;span class=&quot;line-number&quot;&gt;63
&lt;span class=&quot;line-number&quot;&gt;64
&lt;span class=&quot;line-number&quot;&gt;65
&lt;span class=&quot;line-number&quot;&gt;66
&lt;span class=&quot;line-number&quot;&gt;67
&lt;span class=&quot;line-number&quot;&gt;68
&lt;span class=&quot;line-number&quot;&gt;69
&lt;span class=&quot;line-number&quot;&gt;70
&lt;span class=&quot;line-number&quot;&gt;71
&lt;span class=&quot;line-number&quot;&gt;72
&lt;span class=&quot;line-number&quot;&gt;73
&lt;span class=&quot;line-number&quot;&gt;74
&lt;span class=&quot;line-number&quot;&gt;75
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;line&quot;&gt;normal = not chunked
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;  chunked-0 = First frame of a multi-frame packet
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;  chunked-n = Subsequent frames for multi-frame packet
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;  || is concatenate
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;  ^ is xor
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt; 
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;Single-frame packet:
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;header || header-mac || frame || frame-mac
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt; 
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;Multi-frame packet:
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;header || header-mac || frame-0 ||
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;[ header || header-mac || frame-n || ... || ]
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;header || header-mac || frame-last || frame-mac
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt; 
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;header: frame-size || header-data || padding
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;frame-size: 3-byte integer size of frame, big endian encoded (excludes padding)
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;header-data:
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;    normal: rlp.list(protocol-type[, context-id])
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;    chunked-0: rlp.list(protocol-type, context-id, total-packet-size)
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;    chunked-n: rlp.list(protocol-type, context-id)
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;    values:
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;        protocol-type: &amp;lt; 2**16
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;        context-id: &amp;lt; 2**16 (optional for normal frames)
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;        total-packet-size: &amp;lt; 2**32
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;padding: zero-fill to 16-byte boundary
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt; 
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;header-mac: right128 of egress-mac.update(aes(mac-secret,egress-mac) ^ header-ciphertext).digest
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt; 
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;frame:
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;    normal: rlp(packet-type) [|| rlp(packet-data)] || padding
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;    chunked-0: rlp(packet-type) || rlp(packet-data...)
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;    chunked-n: rlp(...packet-data) || padding
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;padding: zero-fill to 16-byte boundary (only necessary for last frame)
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt; 
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;frame-mac: right128 of egress-mac.update(aes(mac-secret,egress-mac) ^ right128(egress-mac.update(frame-ciphertext).digest))
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt; 
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;egress-mac: h256, continuously updated with egress-bytes*
&lt;span class=&quot;line&quot;&gt;
&lt;span class=&quot;line&quot;&gt;ingress-mac: h256, continuously updated with ingress-bytes*&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;2. 协议握手doProtoHandshake&lt;/h2&gt;
&lt;p&gt;这个方法比较简单，加密信道已经创建完毕。 我们看到这里只是约定了是否使用Snappy加密然后就退出了。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个函数，发送给对方 handshakeMsg = 0x00，在readProtocolHandshake中读取接收对方发过来的handshakeMsg。&lt;/p&gt;
&lt;h2&gt;3. RLPX 数据分帧&lt;/h2&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_10.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在完成Encode握手之后，调用newRLPXFrameRW方法创建rlpxFrameRW对象，这的对象提供ReadMsg和WriteMsg方法&lt;/p&gt;
&lt;h3&gt;ReadMsg&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_11.png&quot; alt=&quot;&quot;/&gt;)&lt;/p&gt;
&lt;p&gt;1读取帧头header&lt;/p&gt;
&lt;p&gt;2 验证帧头MAC&lt;/p&gt;
&lt;p&gt;3 获取帧体Frame大小&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_12.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4 读取帧体数据&lt;/p&gt;
&lt;p&gt;5 验证帧体MAC信息&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_13.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_14.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6 解密帧体内容（NewCTR à XORKeyStream）&lt;/p&gt;
&lt;p&gt;7 解码帧体（RLP Decode）&lt;/p&gt;
&lt;p&gt;8 解析帧体结构(msg.Size &amp;amp; msg.Payload)&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_15.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9 snappy解码&lt;/p&gt;
&lt;h3&gt;WriteMsg&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_16.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1 RLP编码msg.Code&lt;/p&gt;
&lt;p&gt;2 如果snappy，就对读取payload并进行snappy编码&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_17.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3 写帧头header （32字节）&lt;/p&gt;
&lt;p&gt;4 写帧头MAC&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_18.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5 写帧体信息（ptype+payload+padding）&lt;/p&gt;
&lt;p&gt;6 写帧体MAC&lt;/p&gt;
&lt;h2&gt;4. runPeer&lt;/h2&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_19.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;newPeerHook，建立peer的钩子函数&lt;/p&gt;
&lt;p&gt;广播PeerEventTypeAdd事件&lt;/p&gt;
&lt;p&gt;运行protocol&lt;/p&gt;
&lt;p&gt;广播PeerEventTypeDrop事件&lt;/p&gt;
&lt;p&gt;删除peer&lt;/p&gt;
&lt;h3&gt;run protocol&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_20.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1 启动协程readLoop，读取消息并根据msg.Code处理消息：&lt;/p&gt;
&lt;p&gt;pingMsg-&amp;gt;pongMsg&lt;/p&gt;
&lt;p&gt;discMsg-&amp;gt;RLP解码msg.Payload返回reason&lt;/p&gt;
&lt;p&gt;其他协议消息处理，根据msg.Code的取值范围，把msg分给注册的协议进行处理。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_21.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2 启动协程pingLoop&lt;/p&gt;
&lt;p&gt;根据pingInterval（15秒）定时发送pingMsg消息&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_22.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3 启动协议&lt;/p&gt;
&lt;p&gt;startProtocols主要功能是启动协程运行注册协议的run函数proto.Run(p, rw)，这个rw参数类型是protoRW，它实现的ReadMsg和WriteMsg增加msg.Code取值范围的处理。不同的protocol有不同的code取值范围，根据offset和Length确定。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;http://assets.wangxiaoming.com/image/p2p_23.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;a href=&quot;http://wangxiaoming.com/blog/2018/06/28/HPB-48-ETH-P2P-Net/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://wangxiaoming.com/blog/2018/06/28/HPB-48-ETH-P2P-Net/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 23 Aug 2018 07:20:00 +0000</pubDate>
<dc:creator>区块链</dc:creator>
<og:description>P2P网络数据处理流程 监听(ListenLoop)+拨号(Dial) –&gt; 建立连接(SetupConn) –&gt; Enc 握手(doEncHandshake) –&gt; 协议握手(do</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blockchain/p/9523964.html</dc:identifier>
</item>
<item>
<title>Java基础-IO - aidodoo</title>
<link>http://www.cnblogs.com/molyeo/p/9523878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/molyeo/p/9523878.html</guid>
<description>&lt;p&gt;本文详细介绍讲述了Java IO的相关内容，主要涉及文件，网络数据流，内存缓冲等的输入输出，版本要求jdk1.8。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;Java的IO包主要关注数据源的读取和输出到目标媒介。示意图如下&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/media.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常用的源数据和目标媒介如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Files&lt;/li&gt;
&lt;li&gt;Pipes&lt;/li&gt;
&lt;li&gt;Network Connections&lt;/li&gt;
&lt;li&gt;In-memory Buffers (e.g. arrays)&lt;/li&gt;
&lt;li&gt;System.in, System.out, System.error&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;流从概念上说一个连续的数据流，既可以从流中读取数据，也可以往流中写入数据。主要分为字节流和字符流，字节流指以字节为单位进行读写，字符流指以字符为单位进行读写。&lt;br/&gt;一个程序需要InputStream或者Reader从数据源读取数据，需要OutputStream或者Writer将数据写入到目标媒介中。示意图如下：&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/source.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;stream特征和分类&quot;&gt;Stream特征和分类&lt;/h2&gt;
&lt;p&gt;Java IO针对不同的业务场景，不同的功能，设计了不同的类，各类用途如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;File Access&lt;/li&gt;
&lt;li&gt;Network Access&lt;/li&gt;
&lt;li&gt;Internal Memory Buffer Access&lt;/li&gt;
&lt;li&gt;Inter-Thread Communication (Pipes)&lt;/li&gt;
&lt;li&gt;Buffering&lt;/li&gt;
&lt;li&gt;Filtering&lt;/li&gt;
&lt;li&gt;Parsing&lt;/li&gt;
&lt;li&gt;Reading and Writing Text (Readers / Writers)&lt;/li&gt;
&lt;li&gt;Reading and Writing Primitive Data (long, int etc.)&lt;/li&gt;
&lt;li&gt;Reading and Writing Objects&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途可以将Java IO流进行如下划分：&lt;/p&gt;
&lt;table width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td colspan=&quot;2&quot;&gt;Byte Based&lt;/td&gt;
&lt;td colspan=&quot;2&quot;&gt;Character Based&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;Input&lt;/td&gt;
&lt;td&gt;Output&lt;/td&gt;
&lt;td&gt;Input&lt;/td&gt;
&lt;td&gt;Output&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Basic&lt;/td&gt;
&lt;td&gt;InputStream&lt;/td&gt;
&lt;td&gt;OutputStream&lt;/td&gt;
&lt;td&gt;Reader&lt;br/&gt;InputStreamReader&lt;/td&gt;
&lt;td&gt;Writer&lt;br/&gt;OutputStreamWriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Arrays&lt;/td&gt;
&lt;td&gt;ByteArrayInputStream&lt;/td&gt;
&lt;td&gt;ByteArrayOutputStream&lt;/td&gt;
&lt;td&gt;CharArrayReader&lt;/td&gt;
&lt;td&gt;CharArrayWriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Files&lt;/td&gt;
&lt;td&gt;FileInputStream&lt;br/&gt;RandomAccessFile&lt;/td&gt;
&lt;td&gt;FileOutputStream&lt;br/&gt;RandomAccessFile&lt;/td&gt;
&lt;td&gt;FileReader&lt;/td&gt;
&lt;td&gt;FileWriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Pipes&lt;/td&gt;
&lt;td&gt;PipedInputStream&lt;/td&gt;
&lt;td&gt;PipedOutputStream&lt;/td&gt;
&lt;td&gt;PipedReader&lt;/td&gt;
&lt;td&gt;PipedWriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Buffering&lt;/td&gt;
&lt;td&gt;BufferedInputStream&lt;/td&gt;
&lt;td&gt;BufferedOutputStream&lt;/td&gt;
&lt;td&gt;BufferedReader&lt;/td&gt;
&lt;td&gt;BufferedWriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Filtering&lt;/td&gt;
&lt;td&gt;FilterInputStream&lt;/td&gt;
&lt;td&gt;FilterOutputStream&lt;/td&gt;
&lt;td&gt;FilterReader&lt;/td&gt;
&lt;td&gt;FilterWriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Parsing&lt;/td&gt;
&lt;td&gt;PushbackInputStream&lt;br/&gt;StreamTokenizer&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;PushbackReader&lt;br/&gt;LineNumberReader&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Strings&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;StringReader&lt;/td&gt;
&lt;td&gt;StringWriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Data&lt;/td&gt;
&lt;td&gt;DataInputStream&lt;/td&gt;
&lt;td&gt;DataOutputStream&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;br/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Data - Formatted&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;PrintStream&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;PrintWriter&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Objects&lt;/td&gt;
&lt;td&gt;ObjectInputStream&lt;/td&gt;
&lt;td&gt;ObjectOutputStream&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Utilities&lt;/td&gt;
&lt;td&gt;SequenceInputStream&lt;br/&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;file类&quot;&gt;File类&lt;/h2&gt;
&lt;p&gt;在讨论Stream的具体使用前，我们先看看IO库里面的File类。&lt;br/&gt;Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等，但File对象却不能直接访问文件内容本身，要查看内容，则需要使用IO流。&lt;br/&gt;通过以下构造方法创建一个File对象。&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;通过给定的父抽象路径名和子路径名字符串创建一个新的File实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  File(File parent, String child);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过将给定路径名字符串转换成抽象路径名来创建一个新 File 实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  File(String pathname) &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  File(String parent, String child) &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过将给定的 file: URI 转换成一个抽象路径名来创建一个新的 File 实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  File(URI uri) &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于其方法均比较简单，不再罗列，具体见&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/&quot; class=&quot;uri&quot;&gt;https://docs.oracle.com/javase/8/docs/api/&lt;/a&gt;。一个具体的实例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.molyeo.java.io;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;

/**
 * Created by zhangkh on 2018/7/19.
 */
public class FileDemo {
    static Logger logger = LoggerFactory.getLogger(FileDemo.class.getName());

    public static void main(String[] args) throws IOException {
        File path = new File(&quot;.&quot;);
        if (path.isDirectory()) {
            logger.info(&quot;root: directory is {}&quot;, path.getAbsolutePath());
            String[] list = path.list();
            Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);
            for (String dirItem : list) {
                File file = new File(path, dirItem);
                if (file.isDirectory()) {
                    logger.info(&quot;child: {} is a directory&quot;, dirItem);
                } else {
                    logger.info(&quot;child: {} is a file&quot;, dirItem);
                }
            }
        } else {
            logger.info(&quot;root is not a directory&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看当前项目，按照字典顺序排序后，再判断其子路径是文件还是目录，并输出相关结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;18/07/19 17:35:12 INFO io.FileDemo: root: directory is D:\workspace_spark\SparkInAction\.
18/07/19 17:35:12 INFO io.FileDemo: child: .idea is a directory
18/07/19 17:35:12 INFO io.FileDemo: child: data is a directory
18/07/19 17:35:12 INFO io.FileDemo: child: libs is a directory
18/07/19 17:35:12 INFO io.FileDemo: child: out is a directory
18/07/19 17:35:12 INFO io.FileDemo: child: pom.xml is a file
18/07/19 17:35:12 INFO io.FileDemo: child: spark-warehouse is a directory
18/07/19 17:35:12 INFO io.FileDemo: child: SparkInAction.iml is a file
18/07/19 17:35:12 INFO io.FileDemo: child: src is a directory
18/07/19 17:35:12 INFO io.FileDemo: child: target is a directory&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;inputstream和outputstream&quot;&gt;InputStream和OutputStream&lt;/h2&gt;
&lt;h3 id=&quot;全局类图&quot;&gt;全局类图&lt;/h3&gt;
&lt;p&gt;在前面表格中，罗列了&lt;code&gt;Java IO&lt;/code&gt;中的流，可以看到相对复杂。我们先看字节流的层次关系。&lt;br/&gt;整体的层次关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/InputStream.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的层次图中，为简便区分，用蓝色表示接口，红色表示抽象类，绿色表示类。&lt;br/&gt;&lt;code&gt;jdk1.8&lt;/code&gt;中，主要通过5个接口来定义区别不同的流，分别是&lt;code&gt;Closeable&lt;/code&gt;,&lt;code&gt;Flushable&lt;/code&gt;,&lt;code&gt;Readable&lt;/code&gt;,&lt;code&gt;Appendable&lt;/code&gt;。其中&lt;code&gt;Closeable&lt;/code&gt;的父类&lt;code&gt;AutoCloseable&lt;/code&gt;接口主要是用于基于&lt;code&gt;try-with-resource&lt;/code&gt;的异常处理。&lt;br/&gt;&lt;code&gt;InputStream&lt;/code&gt;实现&lt;code&gt;Closeable&lt;/code&gt;接口,而&lt;code&gt;Closeable&lt;/code&gt;的父类&lt;code&gt;AutoCloseable&lt;/code&gt;接口主要是用于基于&lt;code&gt;try-with-resource&lt;/code&gt;的异常处理，在后续的示例代码中将会说明。&lt;/p&gt;
&lt;h3 id=&quot;inputstream类图&quot;&gt;InputStream类图&lt;/h3&gt;
&lt;p&gt;具体看&lt;code&gt;InputStream&lt;/code&gt;的类图如下：&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/InputStream201808.png&quot;/&gt;&lt;br/&gt;&lt;code&gt;InputStream&lt;/code&gt;实现&lt;code&gt;Closeable&lt;/code&gt;接口，并有五个子类，而其子类&lt;code&gt;FilterInputStream&lt;/code&gt;作为装饰功能类，类图如下：&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/FilterInputStream.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;输入流使用基本流程&quot;&gt;输入流使用基本流程&lt;/h3&gt;
&lt;p&gt;我们先看一个从文件读取的实例，以了解IO流的使用流程。&lt;br/&gt;我们将上文判断当前项目下的文件是file还是directory的例子改写一下，改写读取当前项目文件夹为data并且以data开头的文件，并输出文件内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.molyeo.java.io;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;

/**
 * Created by zhangkh on 2018/7/20.
 */
public class ByteBasedStream {
    static Logger logger = LoggerFactory.getLogger(ByteBasedStream.class.getName());

    public static void main(String[] args) throws IOException {
        File path = new File(&quot;.&quot;);
        if (path.isDirectory()) {
            logger.info(&quot;root: directory is {}&quot;, path.getAbsolutePath());
            String[] list;

            list = path.list(new DirFilter(&quot;d.*&quot;));
            logger.info(&quot;File after first filter:&quot;);

            for (String dirItem : list) {
                File file = new File(path, dirItem);
                if (file.isDirectory()) {
                    logger.info(&quot;child: {} is a directory&quot;, dirItem);
                    String[] childList = file.list(new DirFilter(&quot;data*.txt&quot;));
                    logger.info(&quot;File after second filter&quot;);
                    for (String childItem : childList) {

                        File childFile = new File(file, childItem);
                        if (childFile.isFile()) {
                            logger.info(&quot;Secondary child: {} is a file&quot;, childItem);
                            logger.info(&quot;start read file {}&quot;, childFile.getCanonicalPath());
                            read(childFile);
                        }
                    }
                } else {
                    logger.info(&quot;child: {} is a file&quot;, dirItem);
                }

            }


        } else {
            logger.info(&quot;root is not a directory&quot;);
        }

    }

    public static void read(File file) throws IOException {
        InputStream inputStream = null;
        try {
            inputStream = new FileInputStream(file);
            int byteData = inputStream.read();
            while (byteData != -1) {
                logger.info(&quot;byteData={}, char result={}&quot;, byteData, (char) byteData);
                byteData = inputStream.read();
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中data.txt文件内容为&lt;code&gt;Hadoop&lt;/code&gt;,程序运行日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;18/08/04 22:19:58 INFO io.ByteBasedStream: root: directory is D:\workspace_spark\SparkInAction\.
18/08/04 22:19:58 INFO io.ByteBasedStream: File after first filter:
18/08/04 22:19:58 INFO io.ByteBasedStream: child: data is a directory
18/08/04 22:19:58 INFO io.ByteBasedStream: File after second filter
18/08/04 22:19:58 INFO io.ByteBasedStream: Secondary child: data.txt is a file
18/08/04 22:19:58 INFO io.ByteBasedStream: start read file D:\workspace_spark\SparkInAction\data\data.txt
18/08/04 22:19:58 INFO io.ByteBasedStream: byteData=72, char result=H
18/08/04 22:19:58 INFO io.ByteBasedStream: byteData=97, char result=a
18/08/04 22:19:58 INFO io.ByteBasedStream: byteData=100, char result=d
18/08/04 22:19:58 INFO io.ByteBasedStream: byteData=111, char result=o
18/08/04 22:19:58 INFO io.ByteBasedStream: byteData=111, char result=o
18/08/04 22:19:58 INFO io.ByteBasedStream: byteData=112, char result=p&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;read()&lt;/strong&gt;&lt;br/&gt;自定义的&lt;code&gt;read&lt;/code&gt;方法输入文件，然后我们构造&lt;code&gt;FileInputStream&lt;/code&gt;实例，通过循环调用&lt;code&gt;read()&lt;/code&gt;方法从&lt;code&gt;FileInputStream&lt;/code&gt;流中读取一个字节的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int byteData=inputStream.read();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据读取后可以将返回的&lt;code&gt;int&lt;/code&gt;类型转换成&lt;code&gt;char&lt;/code&gt;类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;char aChar = (char) data;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果到达流末尾时，&lt;code&gt;read&lt;/code&gt;方法返回-1。此时则可以关闭流。&lt;br/&gt;&lt;strong&gt;read(byte[])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InputStream&lt;/code&gt;包含了2个从&lt;code&gt;InputStream&lt;/code&gt;中读取数据并将数据存储到缓冲数组中的&lt;code&gt;read()&lt;/code&gt;方法，他们分别是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int read(byte[])
int read(byte, int offset, int length)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一次性读取一个字节数组的方式，比一次性读取一个字节的方式快的多，所以，尽可能使用这两个方法代替&lt;code&gt;read()&lt;/code&gt;方法。&lt;br/&gt;&lt;code&gt;read(byte[])&lt;/code&gt;方法会尝试读取与给定字节数组容量一样大的字节数，返回值说明了已经读取过的字节数。如果&lt;code&gt;InputStream&lt;/code&gt;内可读的数据不足以填满字节数组，那么数组剩余的部分将包含本次读取之前的数据。记得检查有多少数据实际被写入到了字节数组中。&lt;br/&gt;&lt;code&gt;read(byte, int offset, int length)&lt;/code&gt;方法同样将数据读取到字节数组中，不同的是，该方法从数组的&lt;code&gt;offset&lt;/code&gt;位置开始，并且最多将&lt;code&gt;length&lt;/code&gt;个字节写入到数组中。同样地，&lt;code&gt;read(byte, int offset, int length)&lt;/code&gt;方法返回一个&lt;code&gt;int&lt;/code&gt;变量，告诉你已经有多少字节已经被写入到字节数组中，所以请记得在读取数据前检查上一次调用&lt;code&gt;read(byte, int offset, int length)&lt;/code&gt;的返回值。&lt;/p&gt;
&lt;p&gt;这两个方法都会在读取到达到流末尾时返回-1。&lt;/p&gt;
&lt;h3 id=&quot;io流异常处理&quot;&gt;IO流异常处理&lt;/h3&gt;
&lt;p&gt;在读取文件的那个例子中，我们看read方法真实有效的代码知识try中的一部分，而实际我们写了很多异常处理的模板方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void read(File file) throws IOException {
    InputStream inputStream = null;
    try {
        inputStream = new FileInputStream(file);
        int byteData = inputStream.read();
        while (byteData != -1) {
            logger.info(&quot;byteData={}, char result={}&quot;, byteData, (char) byteData);
            byteData = inputStream.read();
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (inputStream != null) {
            inputStream.close();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段代码中共有4个地方可能会抛出异常，分别是&lt;code&gt;new FileInputStream(file)&lt;/code&gt;，&lt;code&gt;inputStream.read()&lt;/code&gt;，&lt;code&gt;inputStream.read()&lt;/code&gt;，&lt;code&gt;inputStream.close()&lt;/code&gt;。&lt;br/&gt;想象一下，从try块内部抛出异常。然后finally执行该块，而从finally块抛出的异常如果我们不捕获的话，将在调用堆栈中向上传播。&lt;br/&gt;&lt;code&gt;try-catch-finally&lt;/code&gt;结构显示的关闭流显得单调乏味，并且异常捕获模板代码众多，看着一点都不优雅。在&lt;code&gt;java7&lt;/code&gt;后可以使用&lt;code&gt;try-with-resource&lt;/code&gt;结构来处理，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void read1(File file) throws IOException{
    try(InputStream inputStream=new FileInputStream(file)){
        int byteData = inputStream.read();
        while (byteData != -1) {
            logger.info(&quot;byteData={}, char result={}&quot;, byteData, (char) byteData);
            byteData = inputStream.read();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在&lt;code&gt;read1&lt;/code&gt;方法中实现了和&lt;code&gt;read&lt;/code&gt;方法一样的功能，但代码显得简洁明了。其中在&lt;code&gt;try()&lt;/code&gt;括号内创建了&lt;code&gt;FileInputStream&lt;/code&gt;这个资源，当程序执行离开&lt;code&gt;try{}&lt;/code&gt;块时，该资源将会自动关闭。如果try()括号内有多个资源，资源将按与括号内创建/列出顺序相反的顺序关闭。&lt;br/&gt;IO流中，资源之所以会自动关闭，是因为IO流(包括&lt;code&gt;InputStream&lt;/code&gt;,&lt;code&gt;OutputStream&lt;/code&gt;,&lt;code&gt;Reader&lt;/code&gt;,&lt;code&gt;Writer&lt;/code&gt;)均实现了&lt;code&gt;AutoClosable&lt;/code&gt;接口，具体可参考全局类图。我们也可以将自定义类实现&lt;code&gt;AutoClosable&lt;/code&gt;接口，然后&lt;br/&gt;与&lt;code&gt;try-with-resource&lt;/code&gt;结构一起使用。&lt;/p&gt;
&lt;h3 id=&quot;filterinputstream&quot;&gt;FilterInputStream&lt;/h3&gt;
&lt;p&gt;FilterInputStream主要有4个子类，可以用来修改InputStream的内部行为。&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/FilterInputStream.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4个字类添加的功能如下：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;类名&lt;/td&gt;
&lt;td&gt;功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;DataInputStream&lt;/td&gt;
&lt;td&gt;与DataOutputStream配合使用，以一种&quot;可携带的方式(portable fashion)&quot;从流里读取基础类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BufferedInputStream&lt;/td&gt;
&lt;td&gt;从缓冲区读取，而不是每次要用数据的时候都要进行物理读取&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LineNumberInputStream&lt;/td&gt;
&lt;td&gt;跟踪输入流的行号；有getLineNumber( )和setLineNumber(int)方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PushbackInputStream&lt;/td&gt;
&lt;td&gt;有一个&quot;弹压单字节&quot;的缓冲区，这样你就能把最后读到的那个字节再压回去。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们用BufferedInputStream给FileInputStream方法添加缓存区，改写后的read方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void readWithBuffer(File file) throws IOException{
    try(FileInputStream fileInputStream=new FileInputStream(file);
        BufferedInputStream input=new BufferedInputStream(fileInputStream);
    ){
        int byteData = input.read();
        while (byteData != -1) {
            logger.info(&quot;byteData={}, char result={}&quot;, byteData, (char) byteData);
            byteData = input.read();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;outputstream类图&quot;&gt;OutputStream类图&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;OutputStream&lt;/code&gt;的层次关系如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/OutputStream.png&quot;/&gt;&lt;br/&gt;&lt;code&gt;OutputStream&lt;/code&gt;实现&lt;code&gt;Closeable&lt;/code&gt;和&lt;code&gt;Flushable&lt;/code&gt;接口,其装饰功能子类&lt;code&gt;FilterOutputStream&lt;/code&gt;，类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/FilterOutputStream.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;输出流基本使用流程&quot;&gt;输出流基本使用流程&lt;/h3&gt;
&lt;p&gt;输出流往往和某些数据的目标媒介相关联，比如文件，网络连接，管道等，如下将字符串&lt;code&gt;apache&lt;/code&gt;写入当前项目&lt;code&gt;data&lt;/code&gt;目录下的&lt;code&gt;output.txt&lt;/code&gt;文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.molyeo.java.io;
    
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;

/**
 * Created by zhangkh on 2018/8/5.
 */
public class BytedBasedOutputStream {
    static Logger logger = LoggerFactory.getLogger(ByteBasedInputStream.class.getName());

    public static void main(String[] args) throws IOException {
        File path = new File(&quot;.&quot;);
        File file = new File(path, &quot;data/output.txt&quot;);
        logger.info(file.getAbsolutePath());
        write(file, &quot;apache&quot;);
    }

    public static void write(File file, String content) throws IOException {
        try (FileOutputStream output = new FileOutputStream(file)) {
            byte[] bytesArray = content.getBytes();
            for (int i = 0; i &amp;lt; bytesArray.length; i++) {
                output.write(bytesArray[i]);
                logger.info(&quot;byteData={}, char result={}&quot;, bytesArray[i], (char) bytesArray[i]);
            }
            output.flush();
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;18/08/05 13:00:23 INFO io.BytedBasedOutputStream: D:\workspace_spark\SparkInAction\.\data\output.txt
18/08/05 13:00:23 INFO io.BytedBasedOutputStream: byteData=97, char result=a
18/08/05 13:00:23 INFO io.BytedBasedOutputStream: byteData=112, char result=p
18/08/05 13:00:23 INFO io.BytedBasedOutputStream: byteData=97, char result=a
18/08/05 13:00:23 INFO io.BytedBasedOutputStream: byteData=99, char result=c
18/08/05 13:00:23 INFO io.BytedBasedOutputStream: byteData=104, char result=h
18/08/05 13:00:23 INFO io.BytedBasedOutputStream: byteData=101, char result=e&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OutputStream常用方法如下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;write(byte[])&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;OutputStream&lt;/code&gt;同样包含了将字节数据中全部或者部分数据写入到输出流中的方法，分别是&lt;code&gt;write(byte[])&lt;/code&gt;和&lt;code&gt;write(byte[], int offset, int length)&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;write(byte[])&lt;/code&gt;把字节数组中所有数据写入到输出流中。&lt;br/&gt;&lt;code&gt;write(byte[], int offset, int length)&lt;/code&gt;把字节数据中从&lt;code&gt;offset&lt;/code&gt;位置开始，&lt;code&gt;length&lt;/code&gt;个字节的数据写入到输出流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flush()&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;OutputStream&lt;/code&gt;的&lt;code&gt;flush()&lt;/code&gt;方法将所有写入到&lt;code&gt;OutputStream&lt;/code&gt;的数据冲刷到相应的目标媒介中。比如，如果输出流是&lt;code&gt;FileOutputStream&lt;/code&gt;，那么写入到其中的数据可能并没有真正写入到磁盘中。即使所有数据都写入到了&lt;code&gt;FileOutputStream&lt;/code&gt;，这些数据还是有可能保留在内存的缓冲区中。通过调用&lt;code&gt;flush()&lt;/code&gt;方法，可以把缓冲区内的数据刷新到磁盘(或者网络，以及其他任何形式的目标媒介)中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;close()&lt;/strong&gt;&lt;br/&gt;当你结束数据写入时，需要关闭&lt;code&gt;OutputStream&lt;/code&gt;。通过调用&lt;code&gt;close()&lt;/code&gt;可以达到这一点。因为&lt;code&gt;OutputStream&lt;/code&gt;的各种&lt;code&gt;write()&lt;/code&gt;方法可能会抛出&lt;code&gt;IO&lt;/code&gt;异常，所以你需要把调用&lt;code&gt;close()&lt;/code&gt;的关闭操作方在&lt;code&gt;finally&lt;/code&gt;块中执行。如果使用基于&lt;code&gt;try-with-resource&lt;/code&gt;的异常处理程序则由于实现了&lt;code&gt;AutoCloseable&lt;/code&gt;接口，不用显示关闭。&lt;/p&gt;
&lt;h3 id=&quot;filteroutputstream&quot;&gt;FilterOutputStream&lt;/h3&gt;
&lt;p&gt;FilterOutputStream主要有3个子类，可以用来修改OutputStream的内部行为。&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/FilterOutputStream.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3个字类添加的功能如下：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr&gt;&lt;td&gt;类名&lt;/td&gt;
&lt;td&gt;功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DataOutputStream&lt;/td&gt;
&lt;td&gt;与DataInputStream配合使用，可以用可携带的方式往流里写基本类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BufferedOutputStream&lt;/td&gt;
&lt;td&gt;写入缓冲区，而不是每次往流里写数据，都要进行物理操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PrintStream&lt;/td&gt;
&lt;td&gt;负责生成带格式的输出。DataOutputStrem负责数据的存储，而PrintStream负责数据的显示。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们用&lt;code&gt;BufferedOutputStream&lt;/code&gt;给&lt;code&gt;FileOutputStream&lt;/code&gt;方法添加缓存区，改写后的&lt;code&gt;write&lt;/code&gt;方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void writeWithBuffer(File file, String content) throws IOException {
    try (FileOutputStream fileOutputStream = new FileOutputStream(file);
        BufferedOutputStream output=new BufferedOutputStream(fileOutputStream)
    ) {
        byte[] bytesArray = content.getBytes();
        for (int i = 0; i &amp;lt; bytesArray.length; i++) {
            output.write(bytesArray[i]);
            logger.info(&quot;byteData={}, char result={}&quot;, bytesArray[i], (char) bytesArray[i]);
        }
        output.flush();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;reader和writer&quot;&gt;Reader和Writer&lt;/h2&gt;
&lt;h3 id=&quot;reader类图&quot;&gt;Reader类图&lt;/h3&gt;
&lt;p&gt;Reader类图如下,Reader实现Readable和Closeable接口，根据不同的功能有众多的子类。&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/Reader.png&quot;/&gt;&lt;br/&gt;子类必须实现的方法只有 read() 和 close()&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;read()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int read() throws IOException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于读取单个字符。在字符可用、发生 I/O 错误或者已到达流的末尾前，此方法一直阻塞。用于支持高效的单字符输入的子类应重写此方法。&lt;/p&gt;
&lt;p&gt;返回：作为整数读取的字符，范围在 0 到 65535 之间 ( 0x00-0xffff)，如果已到达流的末尾，则返回 -1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;read(char[] cbuf,int off,int len)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract int read(char[] cbuf,int off,int len) throws IOException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将字符读入数组的某一部分。在某个输入可用、发生 I/O 错误或者到达流的末尾前，此方法一直阻塞。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;参数：  
    cbuf - 目标缓冲区
    off - 开始存储字符处的偏移量
    len - 要读取的最多字符数
返回：
  读取的字符数，如果已到达流的末尾，则返回 -1
抛出：
   IOException - 如果发生 I/O 错误&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;输入字符流使用流程&quot;&gt;输入字符流使用流程&lt;/h3&gt;
&lt;p&gt;这里我们还是读取当前项目data目录下的data.txt文件，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.molyeo.java.io;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;

/**
 * Created by zhangkh on 2018/8/5.
 */
public class CharacterBasedReader {
    static Logger logger = LoggerFactory.getLogger(CharacterBasedReader.class.getName());

    public static void main(String[] args) throws IOException {
        File path = new File(&quot;.&quot;);
        if (path.isDirectory()) {
            logger.info(&quot;root: directory is {}&quot;, path.getAbsolutePath());
            String[] list;

            list = path.list(new DirFilter(&quot;d.*&quot;));
            logger.info(&quot;File after first filter:&quot;);

            for (String dirItem : list) {
                File file = new File(path, dirItem);
                if (file.isDirectory()) {
                    logger.info(&quot;child: {} is a directory&quot;, dirItem);
                    String[] childList = file.list(new DirFilter(&quot;data*.txt&quot;));
                    logger.info(&quot;File after second filter&quot;);
                    for (String childItem : childList) {

                        File childFile = new File(file, childItem);
                        if (childFile.isFile()) {
                            logger.info(&quot;Secondary child: {} is a file&quot;, childItem);
                            logger.info(&quot;start read file {}&quot;, childFile.getCanonicalPath());
                            read(childFile);
                        }
                    }
                } else {
                    logger.info(&quot;child: {} is a file&quot;, dirItem);
                }

            }


        } else {
            logger.info(&quot;root is not a directory&quot;);
        }

    }
    public static void read(File file) throws IOException{
        try(FileReader reader=new FileReader(file)){
            int byteData = reader.read();
            while (byteData != -1) {
                logger.info(&quot;byteData={}, char result={}&quot;, byteData, (char) byteData);
                byteData = reader.read();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;18/08/05 18:45:15 INFO io.CharacterBasedReader: root: directory is D:\workspace_spark\SparkInAction\.
18/08/05 18:45:15 INFO io.CharacterBasedReader: File after first filter:
18/08/05 18:45:15 INFO io.CharacterBasedReader: child: data is a directory
18/08/05 18:45:15 INFO io.CharacterBasedReader: File after second filter
18/08/05 18:45:15 INFO io.CharacterBasedReader: Secondary child: data.txt is a file
18/08/05 18:45:15 INFO io.CharacterBasedReader: start read file D:\workspace_spark\SparkInAction\data\data.txt
18/08/05 18:45:15 INFO io.CharacterBasedReader: byteData=72, char result=H
18/08/05 18:45:15 INFO io.CharacterBasedReader: byteData=97, char result=a
18/08/05 18:45:15 INFO io.CharacterBasedReader: byteData=100, char result=d
18/08/05 18:45:15 INFO io.CharacterBasedReader: byteData=111, char result=o
18/08/05 18:45:15 INFO io.CharacterBasedReader: byteData=111, char result=o
18/08/05 18:45:15 INFO io.CharacterBasedReader: byteData=112, char result=p&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，Java内部使用UTF8编码表示字符串。输入流中一个字节可能并不等同于一个UTF8字符&lt;br/&gt;，如果你从输入流中以字节为单位读取UTF8编码的文本，并且尝试将读取到的字节转换成字符，你可能会得不到预期的结果。&lt;br/&gt;如果输入的文件不是UTF8编码的话，由于FileReader不能指定编码，则需要利用字节流，然后利用转换流将字节流转换为字符流。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InputStream inputStream = new FileInputStream(&quot;D:\workspace_spark\SparkInAction\data\data.txt&quot;);
Reader reader = new InputStreamReader(inputStream, &quot;UTF-8&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;writer类图&quot;&gt;Writer类图&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Writer&lt;/code&gt;的类图如下，主要实现&lt;code&gt;Appendable&lt;/code&gt;,&lt;code&gt;Flushable&lt;/code&gt;,&lt;code&gt;Closeable&lt;/code&gt;接口，根据不同的功能有众多的子类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/Writer.png&quot;/&gt;&lt;br/&gt;主要的api接口如下：&lt;br/&gt;&lt;strong&gt;write(String str)&lt;/strong&gt;&lt;br/&gt;public void write(String str) throws IOException&lt;br/&gt;写入字符串。&lt;br/&gt;参数：&lt;br/&gt;str - 要写入的字符串&lt;br/&gt;抛出：&lt;br/&gt;IOException - 如果发生 I/O 错误&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;write(String str,int off,int len)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void write(String str,int off,int len) throws IOException
写入字符串的某一部分。
参数：
str - 字符串
off - 相对初始写入字符的偏移量
len - 要写入的字符数
抛出：
IndexOutOfBoundsException - 如果 off 或 len 为负，或者 off+len 为负或大于给定字符串的长度
IOException - 如果发生 I/O 错误&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;flush()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract void flush() throws IOException
刷新该流的缓冲。如果该流已保存缓冲区中各种 write() 方法的所有字符，则立即将它们写入预期目标。然后，如果该目标是另一个字符或字节流，则将其刷新。因此，一次 flush() 调用将刷新 Writer 和 OutputStream 链中的所有缓冲区。
如果此流的预期目标是由底层操作系统提供的一个抽象（如一个文件），则刷新该流只能保证将以前写入到流的字节传递给操作系统进行写入，但不保证能将这些字节实际写入到物理设备（如磁盘驱动器）。
抛出：
IOException - 如果发生 I/O 错误&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;输出字符流使用流程&quot;&gt;输出字符流使用流程&lt;/h3&gt;
&lt;p&gt;输出流往往和某些数据的目标媒介相关联，比如文件，网络连接，管道等，如下将字符串apache写入当前项目data目录下的output.txt文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.molyeo.java.io;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Created by zhangkh on 2018/8/5.
 */
public class CharacterBasedWriter {
    static Logger logger = LoggerFactory.getLogger(CharacterBasedWriter.class.getName());

    public static void main(String[] args) throws IOException {
        File path = new File(&quot;.&quot;);
        File file = new File(path, &quot;data/output.txt&quot;);
        logger.info(file.getAbsolutePath());
        write(file, &quot;apache&quot;);

    }

    public static void write(File file, String content) throws IOException {
        try (FileWriter output = new FileWriter(file)) {
            output.write(content);
            output.flush();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例中以文件作为参数构造实例FileWriter,将会新写入的内容将会覆盖原文件。&lt;br/&gt;以下的构造函数取文件名和一个布尔变量作为参数，布尔值表明你是想追加还是覆盖该文件。例子如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Writer writer = new FileWriter(file, true); //appends to file
Writer writer = new FileWriter(file, false); //overwrites file&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用write方法写入具体的值，调用flush接口刷新缓冲区，将数据流传递给操作系统进行写入。&lt;br/&gt;需要注意的是，上述输出的内容编码格式为UTF8,如果要输出其他编码格式，和Reader一样，要利用字节流，然后转换为字符流后以便于操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;OutputStream outputStream = new FileOutputStream(file,charsetName);
Writer writer = new OutputStreamWriter(outputStream);
writer.write(&quot;apache&quot;);
writer.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字节流和字符流转换&quot;&gt;字节流和字符流转换&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;输入字节流转换&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;InputStreamReader&lt;/code&gt;是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集,即&lt;code&gt;UTF-8&lt;/code&gt;编码。&lt;br/&gt;&lt;code&gt;InputStreamReader&lt;/code&gt;的构造函数输入字节流&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public InputStreamReader(InputStream in) {
    super(in);
    try {
        sd = StreamDecoder.forInputStreamReader(in, this, (String)null); // ## check lock object
    } catch (UnsupportedEncodingException e) {
        // The default encoding should always be available
        throw new Error(e);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过调用&lt;code&gt;StreamDecoder&lt;/code&gt;类的&lt;code&gt;forInputStreamReader&lt;/code&gt;方法，设置var2为null&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static StreamDecoder forInputStreamReader(InputStream var0, Object var1, String var2) throws UnsupportedEncodingException {
    String var3 = var2;
    if(var2 == null) {
        var3 = Charset.defaultCharset().name();
    }

    try {
        if(Charset.isSupported(var3)) {
            return new StreamDecoder(var0, var1, Charset.forName(var3));
        }
    } catch (IllegalCharsetNameException var5) {
        ;
    }

    throw new UnsupportedEncodingException(var3);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进而调用类&lt;code&gt;Charset&lt;/code&gt;的&lt;code&gt;defaultCharSet&lt;/code&gt;方法，设置编码格式为UTF-8。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Charset defaultCharset() {
    if (defaultCharset == null) {
        synchronized (Charset.class) {
            String csn = AccessController.doPrivileged(
                new GetPropertyAction(&quot;file.encoding&quot;));
            Charset cs = lookup(csn);
            if (cs != null)
                defaultCharset = cs;
            else
                defaultCharset = forName(&quot;UTF-8&quot;);
        }
    }
    return defaultCharset;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他指定编码格式的构造函数如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public InputStreamReader(InputStream in, String charsetName) throws UnsupportedEncodingException
public InputStreamReader(InputStream in, Charset cs) 
public InputStreamReader(InputStream in, CharsetDecoder dec) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次调用 &lt;code&gt;InputStreamReader&lt;/code&gt; 中的一个 &lt;code&gt;read()&lt;/code&gt; 方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节。&lt;br/&gt;为了达到最高效率，可要考虑在&lt;code&gt;BufferedReader&lt;/code&gt;内包装&lt;code&gt;InputStreamReader&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BufferedReader in = new BufferedReader(new InputStreamReader(System.in));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下我们看一个实例，从控制台输入字符串，并将输入字节流转换为字符流。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.molyeo.java.io;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;

/**
 * Created by zhangkh on 2018/8/22.
 */
public class StreamTransform {
    public static void main(String[] args) {

        String readStr = &quot;&quot;;
        try (InputStreamReader inputStreamReader = new InputStreamReader(System.in, &quot;UTF-8&quot;);
             BufferedReader bufferReader = new BufferedReader(inputStreamReader)
        ) {
            System.out.println(&quot;Please enter a string&quot;);
            readStr = bufferReader.readLine();
            System.out.println(&quot;The input is &quot; + Integer.valueOf(readStr));
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出字节流转换&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;OutputStreamWriter&lt;/code&gt; 是字符流通向字节流的桥梁：可使用指定的 &lt;code&gt;charset&lt;/code&gt; 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。&lt;br/&gt;每次调用 &lt;code&gt;write()&lt;/code&gt; 方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给 &lt;code&gt;write()&lt;/code&gt; 方法的字符没有缓冲。&lt;br/&gt;为了获得最高效率，可考虑将 &lt;code&gt;OutputStreamWriter&lt;/code&gt; 包装到 &lt;code&gt;BufferedWriter&lt;/code&gt; 中，以避免频繁调用转换器。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Writer out = new BufferedWriter(new OutputStreamWriter(System.out));&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;java-io-的一般使用原则&quot;&gt;Java IO 的一般使用原则 ：&lt;/h2&gt;
&lt;h3 id=&quot;按数据来源或去向&quot;&gt;按数据来源或去向&lt;/h3&gt;
&lt;p&gt;文件： FileInputStream, FileOutputStream,FileReader, FileWriter&lt;br/&gt;byte[] ： ByteArrayInputStream, ByteArrayOutputStream&lt;br/&gt;Char[]: CharArrayReader, CharArrayWriter&lt;br/&gt;String: StringBufferInputStream, StringBufferOuputStream，StringReader, StringWriter&lt;br/&gt;网络数据流： InputStream, OutputStream, Reader, Writer&lt;/p&gt;
&lt;h3 id=&quot;按是否格式化输出&quot;&gt;按是否格式化输出&lt;/h3&gt;
&lt;p&gt;格式化输出： PrintStream, PrintWriter&lt;/p&gt;
&lt;h3 id=&quot;按是否要缓冲&quot;&gt;按是否要缓冲&lt;/h3&gt;
&lt;p&gt;缓冲： BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter&lt;/p&gt;
&lt;h3 id=&quot;按数据格式&quot;&gt;按数据格式&lt;/h3&gt;
&lt;p&gt;二进制格式（只要不能确定是纯文本的） : InputStream, OutputStream 及其所有带 Stream 结束的子类。&lt;br/&gt;纯文本格式（含纯英文与汉字或其他编码方式）； Reader, Writer 及其所有带 Reader, Writer 的子类。&lt;/p&gt;
&lt;p&gt;本文详细介绍讲述了Java IO的相关内容，涉及到字节流和字符流的设计，使用原则等。&lt;/p&gt;
&lt;p&gt;本文参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tutorials.jenkov.com/java-io/index.html&quot; class=&quot;uri&quot;&gt;http://tutorials.jenkov.com/java-io/index.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 07:10:00 +0000</pubDate>
<dc:creator>aidodoo</dc:creator>
<og:description>本文详细介绍讲述了Java IO的相关内容，主要涉及文件，网络数据流，内存缓冲等的输入输出等。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/molyeo/p/9523878.html</dc:identifier>
</item>
<item>
<title>数组无法使用 forEach() 方法 - 分号的重要性 - WiseWrong</title>
<link>http://www.cnblogs.com/wisewrong/p/9523857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wisewrong/p/9523857.html</guid>
<description>&lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1059788/201808/1059788-20180823144947682-1083649026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;函数的结构如上图所示，在调用该函数的时候，浏览器报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1059788/201808/1059788-20180823145040480-1050708926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分析原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 js 的语法中，如果语句独占一行，通常可以省略句末的分号&lt;/p&gt;
&lt;p&gt;但实际上 js 解析代码的时候，&lt;strong&gt;&lt;span&gt;只有在句末缺少分号就无法正常运行的时候，才会自动填补分号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果前后的语句能够组成一个语法正确的语句，则不会自动填补分号&lt;/p&gt;
&lt;p&gt;上面的函数中，js 实际处理的代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function test(a, b, c) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = a +&lt;span&gt; b[a, b, c].forEach(function(e){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;通常来讲，如果语句以 &lt;span&gt;&quot;(&quot;、&quot;[&quot;、&quot;/&quot;、&quot;+&quot;、&quot;-&quot;&lt;/span&gt; 开始，该语句极有可能和前一条语句一起解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但如果语句以 &quot;++&quot; 或者 &quot;--&quot; 开始的时候，会优先作为前缀操作符进行解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1059788/201808/1059788-20180823150114913-170036809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图的语句会被解析为 &lt;strong&gt;&lt;span&gt;x; ++y&lt;/span&gt;&lt;/strong&gt; 而不是 &lt;span&gt;&lt;strong&gt;&lt;span&gt;x++; y&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;另外，如果语句以 return、continue、break 结束，js 会在换行处自动填补分号&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1059788/201808/1059788-20180823150439213-323756505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在语句末尾手动添加分号&lt;/p&gt;
</description>
<pubDate>Thu, 23 Aug 2018 07:07:00 +0000</pubDate>
<dc:creator>WiseWrong</dc:creator>
<og:description>问题描述： 函数的结构如上图所示，在调用该函数的时候，浏览器报错： 分析原因： 在 js 的语法中，如果语句独占一行，通常可以省略句末的分号 但实际上 js 解析代码的时候，只有在句末缺少分号就无法正</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wisewrong/p/9523857.html</dc:identifier>
</item>
<item>
<title>Unity物体Mesh(网格)合并,添加BoxCollider，修改Rotation - coocco</title>
<link>http://www.cnblogs.com/caoxen/p/9523662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caoxen/p/9523662.html</guid>
<description>&lt;p&gt;最近刚接触Unity，并且要实战到项目当中，压力是有点大。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;先说一下项目需求：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.在网页上运行。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.跟随鼠标旋转&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.鼠标点击弹出该物体信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;乍一看其实挺简单的，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先unity提供了WebGL，第一条就算解决了。跟随鼠标旋转的其实也就是一段代码，如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MouseView : MonoBehaviour
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; RotationAxes
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         MouseXAndY = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         MouseX = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         MouseY = &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; RotationAxes m_axes =&lt;span&gt; RotationAxes.MouseXAndY;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; m_sensitivityX =&lt;span&gt; 10f;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; m_sensitivityY =&lt;span&gt; 10f;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 水平方向的 镜头转向&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; m_minimumX = -&lt;span&gt;360f;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; m_maximumX =&lt;span&gt; 360f;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 垂直方向的 镜头转向 (这里给个限度 最大仰角为25°)&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; m_minimumY = -&lt;span&gt;25f;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; m_maximumY =&lt;span&gt; 25f;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; m_rotationY =&lt;span&gt; 0f;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use this for initialization&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防止 刚体影响 镜头旋转&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (GetComponent&amp;lt;Rigidbody&amp;gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             GetComponent&amp;lt;Rigidbody&amp;gt;().freezeRotation = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update is called once per frame&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update()
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (Input.GetMouseButton(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        { 
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (m_axes ==&lt;span&gt; RotationAxes.MouseXAndY)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;float&lt;/span&gt; m_rotationX = transform.localEulerAngles.y + Input.GetAxis(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mouse X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) *&lt;span&gt; m_sensitivityX;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 m_rotationY += Input.GetAxis(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mouse Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) *&lt;span&gt; m_sensitivityY;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 m_rotationY =&lt;span&gt; Mathf.Clamp(m_rotationY, m_minimumY, m_maximumY);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;                 transform.localEulerAngles = &lt;span&gt;new&lt;/span&gt; Vector3(-m_rotationY, m_rotationX, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (m_axes ==&lt;span&gt; RotationAxes.MouseX)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 transform.Rotate(&lt;span&gt;0&lt;/span&gt;, Input.GetAxis(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mouse X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) * m_sensitivityX, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                 m_rotationY += Input.GetAxis(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mouse Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) *&lt;span&gt; m_sensitivityY;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                 m_rotationY =&lt;span&gt; Mathf.Clamp(m_rotationY, m_minimumY, m_maximumY);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;                 transform.localEulerAngles = &lt;span&gt;new&lt;/span&gt; Vector3(-m_rotationY, transform.localEulerAngles.y, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三个点击弹出信息，由于刚开始不了解里面的机制（现在也不是很懂）在这里跌了一个跟头，首先点击事件很简单，但是要弹出窗口就突然找不到思路了，在网上找了一大圈得到以下解决方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; click001 : MonoBehaviour {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; WindowShow = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Rect rect = &lt;span&gt;new&lt;/span&gt; Rect(&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;150&lt;/span&gt;, &lt;span&gt;150&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Renderer rend;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fontSize;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; FontStyle fontStyle;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RectOffset margin;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RectOffset padding;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取renderer组件&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         rend = GetComponent&amp;lt;Renderer&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnGUI()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口id  窗口大小  窗口回调（定义窗口内视图） 窗口标题&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (WindowShow)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;项目需要，这是我自己添加的条件&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (gameObject.tag == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 GUI.Window(&lt;span&gt;0&lt;/span&gt;, rect, onWindowOne, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; onWindowOne(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; winId)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;项目需要，这是我自己添加的条件&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (gameObject.tag == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             GUI.Label(&lt;span&gt;new&lt;/span&gt; Rect(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;140&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前窗口是xxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;GUI.Label(new Rect(10, 10, 140, 40), &quot;当前窗口id是&quot; + winId);&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (GUI.Button(&lt;span&gt;new&lt;/span&gt; Rect(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;80&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;按钮1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             Debug.Log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前窗口id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; winId);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义窗体可以活动的范围
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;GUI.DragWindow(new Rect(0, 0, 10000, 10000));&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnMouseDown()
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (WindowShow)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             WindowShow = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             WindowShow = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; }      
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里一切搞定，可惜高兴的不是时候，当我在页面打开的时候，发现中文字体全部消失了，原来unity默认的字体是Arial，我们只需要替换成支持中文的字体即可，在脚本里加上以下代码&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Font font;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;当然，需要在用到字体的位置调用改变量，比如我在这两个位置有用到&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; GUI.skin.window.font = font;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GUI的弹出窗口&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;2&lt;/span&gt; GUI.skin.label.font = font;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个也是GUI弹出窗口里面的内容，但是不这样用，就没有效果，不知道为什么&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;然后这些总算是解决了，不过新的问题又出现了，就是点击事件需要Collider支持，那就添加吧，再添加的过程中我发现这样实在是耗时费力，而且还不精确，然后我就请教了大神，大神一语道破其中的问题所在！&lt;/p&gt;
&lt;p&gt;原来我是把我需要组成一组的元素都放在了一个空Game Object里，如果给它添加BoxCollider，会很麻烦，可以说根本就不适合添加，因为它没有Mesh，也就是网格，所以就需要添加网格，既然它是组合成的一个组，&lt;/p&gt;
&lt;p&gt;所以需要动态的添加网格，当然也需要动态添加BoxCollider，然后当运行以后，我发现物体的位置发生了变化，好吧，那就再控制一下位置，保持和Scene里看到的一致即可，下面是代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Combine_Test : MonoBehaviour
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use this for initialization&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------- 先获取材质 -------------------------
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取自身和所有子物体中所有MeshRenderer组件&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         MeshRenderer[] meshRenderers = GetComponentsInChildren&amp;lt;MeshRenderer&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建材质球数组&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         Material[] mats = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Material[meshRenderers.Length];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; meshRenderers.Length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成材质球数组 &lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             mats[i] =&lt;span&gt; meshRenderers[i].sharedMaterial;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------- 合并 Mesh -------------------------
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取自身和所有子物体中所有MeshFilter组件&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         MeshFilter[] meshFilters = GetComponentsInChildren&amp;lt;MeshFilter&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         CombineInstance[] combine = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CombineInstance[meshFilters.Length];
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; meshFilters.Length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             combine[i].mesh =&lt;span&gt; meshFilters[i].sharedMesh;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;矩阵(Matrix)自身空间坐标的点转换成世界空间坐标的点 &lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             combine[i].transform =&lt;span&gt; meshFilters[i].transform.localToWorldMatrix;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             meshFilters[i].gameObject.SetActive(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为新的整体新建一个mesh&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         transform.GetComponent&amp;lt;MeshFilter&amp;gt;().mesh = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mesh();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并Mesh. 第二个false参数, 表示并不合并为一个网格, 而是一个子网格列表&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         transform.GetComponent&amp;lt;MeshFilter&amp;gt;().mesh.CombineMeshes(combine, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         transform.gameObject.SetActive(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为合并后的新Mesh指定材质 ------------------------------&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         transform.GetComponent&amp;lt;MeshRenderer&amp;gt;().sharedMaterials =&lt;span&gt; mats;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为合并后的新的整体添加BoxCollider ------------------------------&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         BoxCollider bc = gameObject.AddComponent&amp;lt;BoxCollider&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为合并后的新的整体修改rotation ------------------------------&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         transform.localEulerAngles = &lt;span&gt;new&lt;/span&gt; Vector3(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update is called once per frame&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update()
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好的到这里问题基本上都解决了，不过还有一个弹出窗口的问题没有解决，就是没有实现当我点击其他物体或空白处时，窗口消失，这确实是一个不大不小的问题，以后会进一步完善。&lt;/p&gt;
&lt;p&gt;希望路过的大佬能留下您的建议，也希望这篇博文能帮助那些像我一样在网上疯狂找资料的小伙伴&lt;/p&gt;

</description>
<pubDate>Thu, 23 Aug 2018 06:42:00 +0000</pubDate>
<dc:creator>coocco</dc:creator>
<og:description>最近刚接触Unity，并且要实战到项目当中，压力是有点大。 先说一下项目需求： 1.在网页上运行。 2.跟随鼠标旋转 3.鼠标点击弹出该物体信息 乍一看其实挺简单的， 首先unity提供了WebGL，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caoxen/p/9523662.html</dc:identifier>
</item>
</channel>
</rss>