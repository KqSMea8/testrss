<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MyBatis框架原理2：SqlSession运行过程 - AbcBoy</title>
<link>http://www.cnblogs.com/abcboy/p/9656302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abcboy/p/9656302.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;SqlSession session = sqlSessionFactory.openSession();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先通过SqlSessionFactory的openSession方法获取SqlSession接口的实现类DefaultSqlSession对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface SqlSessionFactory {

  SqlSession openSession();

  SqlSession openSession(boolean autoCommit);
  SqlSession openSession(Connection connection);
  SqlSession openSession(TransactionIsolationLevel level);

  SqlSession openSession(ExecutorType execType);
  SqlSession openSession(ExecutorType execType, boolean autoCommit);
  SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level);
  SqlSession openSession(ExecutorType execType, Connection connection);

  Configuration getConfiguration();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SqlSessionFactory接口提供一系列重载的openSession方法，其参数如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;boolean autoCommit：是否开启JDBC事务的自动提交，默认为false。&lt;/li&gt;
&lt;li&gt;Connection：提供连接。&lt;/li&gt;
&lt;li&gt;TransactionIsolationLevel：定义事务隔离级别。&lt;/li&gt;
&lt;li&gt;ExecutorType：定义执行器类型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;DefaultSqlSessionFactory对象调用覆写的openSession方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public SqlSession openSession() {
    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到一个定义了ExecutorType为configuration的默认执行器SIMPLE,事务隔离级别为null,JDBC事务自动提交为false的DefaultSqlSession对象。&lt;/p&gt;

&lt;p&gt;有了DefaultSqlSession对象，以查询一条数据为例，来看一下整个处理过程。&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SqlSession session = sqlSessionFactory.openSession();
try {
  BlogMapper mapper = session.getMapper(BlogMapper.class);
  Blog blog = mapper.selectBlog(101);
} finally {
  session.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MyBatis时序图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1175086/201809/1175086-20180916153325376-669068441.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据MyBatis文档推荐的方法，调用Mapper接口中的方法实现对数据库的操作，上述例子中根据blog ID获取Blog对象。&lt;br/&gt;通过DefaultSqlSession对象的getMapper方法获取的是一个MapperProxy代理对象，这也是Mapper接口不用实现类的原因。当调用BlogMapper中的方法时，由于BlogMapper是一个JDK动态代理对象，它会运行invoke方法，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      //判断代理对象是否是一个类
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
    //生成MapperMethod对象
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    //执行execute方法
    return mapperMethod.execute(sqlSession, args);
  }

  private MapperMethod cachedMapperMethod(Method method) {
    MapperMethod mapperMethod = methodCache.get(method);
    if (mapperMethod == null) {
      mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());
      methodCache.put(method, mapperMethod);
    }
    return mapperMethod;
  }
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;invoke方法判断代理的对象是否是一个类，由于代理对象是一个接口，所以通过cachedMapperMethod生成一个MappedMethod对象，然后执行execute方法，execute方法代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    switch (command.getType()) {
      case INSERT: {
      Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.insert(command.getName(), param));
        break;
      }
      case UPDATE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.update(command.getName(), param));
        break;
      }
      case DELETE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.delete(command.getName(), param));
        break;
      }
      case SELECT:
        if (method.returnsVoid() &amp;amp;&amp;amp; method.hasResultHandler()) {
          executeWithResultHandler(sqlSession, args);
          result = null;
        } else if (method.returnsMany()) {
          result = executeForMany(sqlSession, args);
        } else if (method.returnsMap()) {
          result = executeForMap(sqlSession, args);
        } else if (method.returnsCursor()) {
          result = executeForCursor(sqlSession, args);
        } else {
          Object param = method.convertArgsToSqlCommandParam(args);
          result = sqlSession.selectOne(command.getName(), param);
        }
        break;
      case FLUSH:
        result = sqlSession.flushStatements();
        break;
      default:
        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
    }
    if (result == null &amp;amp;&amp;amp; method.getReturnType().isPrimitive() &amp;amp;&amp;amp; !method.returnsVoid()) {
      throw new BindingException(&quot;Mapper method '&quot; + command.getName() 
          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
    }
    return result;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为这里是根据ID查询一个对象，所以最终调用了DefaultSqlSession的selectOne方法，selectOne方法又调用自身selectList方法，最终将查询操作委托给Executor：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
  public &amp;lt;T&amp;gt; T selectOne(String statement, Object parameter) {
    // Popular vote was to return null on 0 results and throw exception on too many.
    List&amp;lt;T&amp;gt; list = this.&amp;lt;T&amp;gt;selectList(statement, parameter);
    if (list.size() == 1) {
      return list.get(0);
    } else if (list.size() &amp;gt; 1) {
      throw new TooManyResultsException(&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; + list.size());
    } else {
      return null;
    }
  }

public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter) {
    return this.selectList(statement, parameter, RowBounds.DEFAULT);
  }

  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      //根据id获取MappedStatement对象
      MappedStatement ms = configuration.getMappedStatement(statement);
      //wrapCollection方法处理集合参数
      //委托Exector执行SQL
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Executor（执行器），才是真正对JDBC操作的实例，它的结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1175086/201809/1175086-20180916153348200-1416166900.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CachingExecutor: SqlSession默认会调用CachingExecutor执行器的query方法，先从二级缓存获取数据，当无法从二级缓存获取数据时，则委托给BaseExcutor进行操作，CachingExecutor执行过程代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
      throws SQLException {
    //判断是否有二级缓存  
    Cache cache = ms.getCache();
    if (cache != null) {
      flushCacheIfRequired(ms);
      if (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == null) {
        ensureNoOutParams(ms, boundSql);
        @SuppressWarnings(&quot;unchecked&quot;)
        //从二级缓存获取数据
        List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);
        //如果二级缓存没有数据则委托给BaseExcutor进行操作
        if (list == null) {
          list = delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
          tcm.putObject(cache, key, list); // issue #578 and #116
        }
        return list;
      }
    }
    //如果没有二级缓存则委托给BaseExcutor进行操作
    return delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BaseExecutor是一个抽象类，查询操作时BaseExecutor首先从一级缓存获取数据，如果没有则由其子类来进行数据库操作，其query方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    if (queryStack == 0 &amp;amp;&amp;amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List&amp;lt;E&amp;gt; list;
    try {
      queryStack++;
      //从一级缓存获取数据
      list = resultHandler == null ? (List&amp;lt;E&amp;gt;) localCache.getObject(key) : null;
      if (list != null) {
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
        //如果一级缓存没有数据，则从数据库获取
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      // issue #601
      deferredLoads.clear();
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        // issue #482
        clearLocalCache();
      }
    }
    return list;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，我们例子中的查询操作交给了SimpleExecutor这个子类，可以看到SimpleExecutor直接调用了JDBC的代码，最终得到了我们查询的结果，其方法代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      Configuration configuration = ms.getConfiguration();
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      stmt = prepareStatement(handler, ms.getStatementLog());
      return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }

private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
    Statement stmt;
    Connection connection = getConnection(statementLog);
    stmt = handler.prepare(connection, transaction.getTimeout());
    handler.parameterize(stmt);
    return stmt;
  }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 16 Sep 2018 07:39:00 +0000</pubDate>
<dc:creator>AbcBoy</dc:creator>
<og:description>获取SqlSession对象 首先通过SqlSessionFactory的openSession方法获取SqlSession接口的实现类DefaultSqlSession对象。 SqlSessionF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abcboy/p/9656302.html</dc:identifier>
</item>
<item>
<title>redis的缓存穿透 缓存并发 缓存失效 - 皓007</title>
<link>http://www.cnblogs.com/shuchen007/p/9656232.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuchen007/p/9656232.html</guid>
<description>&lt;p&gt;&lt;strong&gt;我们在用缓存的时候，不管是Redis或者Memcached，基本上会通用遇到以下三个问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存穿透&lt;/li&gt;
&lt;li&gt;缓存并发&lt;/li&gt;
&lt;li&gt;缓存失效&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;一、缓存穿透&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;image-package imagebubble&quot;&gt;&lt;img class=&quot;imagebubble-image&quot; src=&quot;https://kshttps0.wiz.cn/ks/note/view/ea26a9ac-82fc-4434-b8e5-50fddacf4aeb/c205b2af-7a6d-48f7-ae95-0c55701726e6/index_files/0.5100524877689032.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Paste_Image.png&lt;/p&gt;
&lt;div class=&quot;image-package imagebubble&quot;&gt;&lt;img class=&quot;imagebubble-image&quot; src=&quot;https://kshttps0.wiz.cn/ks/note/view/ea26a9ac-82fc-4434-b8e5-50fddacf4aeb/c205b2af-7a6d-48f7-ae95-0c55701726e6/index_files/0.17474452406783714.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Paste_Image.png&lt;/p&gt;
&lt;div class=&quot;image-package imagebubble&quot;&gt;&lt;img class=&quot;imagebubble-image&quot; src=&quot;https://kshttps0.wiz.cn/ks/note/view/ea26a9ac-82fc-4434-b8e5-50fddacf4aeb/c205b2af-7a6d-48f7-ae95-0c55701726e6/index_files/0.7928614343032525.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Paste_Image.png&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;br/&gt;上面三个图会有什么问题呢？&lt;/p&gt;
&lt;p&gt;我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。&lt;/p&gt;
&lt;p&gt;那这种问题有什么好办法解决呢？&lt;/p&gt;
&lt;p&gt;要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。&lt;br/&gt;有一个比较巧妙的作法是，可以将这个不存在的key预先设定一个值。&lt;br/&gt;比如，&quot;key&quot; , “&amp;amp;&amp;amp;”。&lt;br/&gt;在返回这个&amp;amp;&amp;amp;值的时候，我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待继续访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是&amp;amp;&amp;amp;，则可以认为这时候key有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;二、缓存并发&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。&lt;/p&gt;
&lt;p&gt;我现在的想法是对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。&lt;/p&gt;
&lt;p&gt;这种情况和刚才说的预先设定值问题有些类似，只不过利用锁的方式，会造成部分请求等待。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;三、缓存失效&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引起这个问题的主要原因还是高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。&lt;/p&gt;
&lt;p&gt;那如何解决这些问题呢？&lt;br/&gt;其中的一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。&lt;/p&gt;
&lt;p&gt;我们讨论的第二个问题时针对同一个缓存，第三个问题时针对很多缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结来看：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、缓存穿透：查询一个必然不存在的数据。比如文章表，查询一个不存在的id，每次都会访问DB，如果有人恶意破坏，很可能直接对DB造成影响。&lt;/p&gt;
&lt;p&gt;2、缓存失效：如果缓存集中在一段时间内失效，DB的压力凸显。这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。&lt;br/&gt;当发生大量的缓存穿透，例如对某个失效的缓存的大并发访问就造成了缓存雪崩。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;四、大家提问汇总&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1、问题1：&lt;/strong&gt;&lt;br/&gt;如何解决DB和缓存一致性问题？&lt;br/&gt;答：当修改了数据库后，有没有及时修改缓存。这种问题，以前有过实践，修改数据库成功，而修改缓存失败的情况，最主要就是缓存服务器挂了。而因为网络问题引起的没有及时更新，可以通过重试机制来解决。而缓存服务器挂了，请求首先自然也就无法到达，从而直接访问到数据库。那么我们在修改数据库后，无法修改缓存，这时候可以将这条数据放到数据库中，同时启动一个异步任务定时去检测缓存服务器是否连接成功，一旦连接成功则从数据库中按顺序取出修改数据，依次进行缓存最新值的修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、问题2：&lt;/strong&gt;&lt;br/&gt;问下缓存穿透那块！例如，一个用户查询文章，通过ID查询，按照之前说的，是将缓存的KEY预先设置一个值，，如果通过ID插过来，发现是预先设定的一个值，比如说是“&amp;amp;&amp;amp;”，那之后的继续等待访问是什么意思，这个ID什么时候会真正被附上用户所需要的值呢？&lt;br/&gt;&lt;strong&gt;答：&lt;/strong&gt;我刚说的主要是咱们常用的后面配置，前台获取的场景。前台无法获取相应的key，则等待，或者放弃。当在后台配置界面上配置了相关key和value之后，那么以前的key &amp;amp;&amp;amp;也自然会被替换掉。你说的那种情况，自然也应该会有一个进程会在某一个时刻，在缓存中设置这个ID，再有新的请求到达的时候，就会获取到最新的ID和value。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、问题3：&lt;/strong&gt;&lt;br/&gt;其实用redis的话，那天看到一个不错的例子，双key，有一个当时生成的一个附属key来标识数据修改到期时间，然后快到的时候去重新加载数据，如果觉得key多可以把结束时间放到主key中，附属key起到锁的功能。&lt;br/&gt;&lt;strong&gt;答：&lt;/strong&gt;这种方案，之前我们实践过。这种方案会产生双份数据，而且需要同时控制附属key与key之间的关系，操作上有一定复杂度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、问题4：&lt;/strong&gt;&lt;br/&gt;多级缓存是什么概念呢？&lt;br/&gt;&lt;strong&gt;答：&lt;/strong&gt;多级缓存就像我今天之前给大家发的文章里面提到了，将ehcache与redis做二级缓存，就像我之前写的文章 &lt;a href=&quot;http://www.jianshu.com/p/2cd6ad416a5a&quot; target=&quot;_blank&quot;&gt;http://www.jianshu.com/p/2cd6ad416a5a&lt;/a&gt; 提到过的。但同样会存在一致性问题，如果我们需要强一致性的话，缓存与数据库同步是会存在时间差的，所以我们在具体开发的过程中，一定要根据场景来具体分析，二级缓存更多的解决是，缓存穿透与程序的健壮性，当集中式缓存出现问题的时候，我们的应用能够继续运行。&lt;/p&gt;

</description>
<pubDate>Sun, 16 Sep 2018 07:15:00 +0000</pubDate>
<dc:creator>皓007</dc:creator>
<og:description>我们在用缓存的时候，不管是Redis或者Memcached，基本上会通用遇到以下三个问题： 缓存穿透 缓存并发 缓存失效 一、缓存穿透 Paste_Image.png Paste_Image.png</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shuchen007/p/9656232.html</dc:identifier>
</item>
<item>
<title>shell编程 - 代码加工者</title>
<link>http://www.cnblogs.com/thoughtful-actors/p/9651554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thoughtful-actors/p/9651554.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　shell就是一个计算机应用程序，跟QQ、微信等类似，但是他主要是提供计算机的操作界面，例如我们所使用Windows操作系统的图形操作界面和cmd.exe命令行操作界面。&lt;span&gt;shell并不是操作系统内核，可以看成是内核外边的壳，可以实现人机友好交互。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;shell同时也可以看成是一种命令语言，本身是用C语言编写的，用shell命令可以编写程序，即我们所说的脚本程序（shell script），所以shell与shell script并不是同一个概念，但通常说shell脚本时就直接说成shell了。在本节所说的shell编程其实就是用shell命令语言编写的shell script。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、分类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　主要分为图形界面shell和命令行式shell两类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　图形界面：Graphical User Interface shell 即 GUI shell，应用最常见，例如个人windows系统大部分都是GUI shell&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　命令行式：Command Line Interface shell ，即CLI shell，个人应用较少，主要是在服务器领域，例如服务器领域的linux操作系统大部分都是CLI shell&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、发展历史&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915163158774-1429761442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、编程风格&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、编程范式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　面向对象：以数据为中心，考虑先如何组织数据，指令服务于数据。&lt;/p&gt;
&lt;p&gt;　　面向过程：以指令为中心，来进行写程序，数据服务于指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、编程语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　低级：汇编语言&lt;/p&gt;
&lt;p&gt;　　高级：需要进行编译解释的语言&lt;/p&gt;
&lt;p&gt;　　　　编译：高级语言--&amp;gt;编译器--&amp;gt;目标代码 &lt;/p&gt;
&lt;p&gt;        　   解释：高级语言--&amp;gt;解释器--&amp;gt;机器代码&lt;/p&gt;
&lt;p&gt;　　可以看出shell脚本语言是高级语言，需要解释器解释后才能执行&lt;/p&gt;
&lt;p&gt;　　程序执行方式：程序最终都是要转成机器代码才能在计算机上执行，机器代码就是二进制指令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、执行模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　顺序执行&lt;/p&gt;
&lt;p&gt;　　循环执行 for while until&lt;/p&gt;
&lt;p&gt;　　选择执行  if elsif  case&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、编程结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、程序形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　整个程序最终就以文本文件的形式存在，就是所说的一个脚本文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、程序组成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一般在脚本顶行添加解释器路径　　#!/bin/bash&lt;/p&gt;
&lt;p&gt;　　变量、数组等基本元素&lt;/p&gt;
&lt;p&gt;　　构成一个表达式&lt;/p&gt;
&lt;p&gt;　　多个表达式构成一个语句&lt;/p&gt;
&lt;p&gt;　　多个语句构成整个脚本文件&lt;/p&gt;
&lt;p&gt;　　结构的核心就是调用指令（堆命令，严重依赖当前环境）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、应用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　重复  批量事务处理  自动化运维  定期任务执行 (crontab)  服务器运行监控&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、程序执行&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、python程序的执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　shell脚本的执行类似于python脚本的执行，我们先来看python文件的执行过程，python脚本的执行分为两类，每一类都有绝对路径与相对路径两种执行方式。&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;1、交互式shell环境下直接执行&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915191214728-706901479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;2、使用解释器执行&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915191947619-1127170589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、shell程序执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;1、在交互式shell环境直接执行&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915201641130-296453247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;2、使用解释器执行&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915201651902-1154877280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;3、前面加点执行&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915201701604-626804710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;4、使用source执行&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915201715813-1016837762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;5、bash的单步执行&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915202808481-576070410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六、shell变量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　变量：是一段内存空间的引用&lt;/p&gt;
&lt;p&gt;　　赋值：变量名=值&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注意&amp;gt;&amp;gt;&lt;/span&gt;变量在赋值是不能再前面带$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、命名规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　变量名只能包含字母、数字和下划线，并且不能以数字开头&lt;/p&gt;
&lt;p&gt;       变量名区分大小写&lt;/p&gt;
&lt;p&gt;       尽量能见名知义&lt;/p&gt;
&lt;p&gt;　　变量不能以数字开头&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、变量分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　局部变量：变量仅对当前Shell进程有效&lt;/p&gt;
&lt;p&gt;　　　　　　　定义变量：Var_Name=&quot;Value&quot;&lt;/p&gt;
&lt;p&gt;　　环境变量：对当前shell进程及其子shell进程有效（但不可跨终端）&lt;/p&gt;
&lt;p&gt;　　　　　　　定义变量：export Var_Name=”Value”&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　或 Var_Name=&quot;Value&quot;   export Var_Name&lt;/p&gt;
&lt;p&gt;　　　　　　环境变量对于当前shell和子shell都有效&lt;/p&gt;
&lt;p&gt;　　　　　　查看系统内置环境变量　　env&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、引用变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　${Var_Name}：引用变量&lt;/p&gt;
&lt;p&gt;　　通常情况下大括号可以省略，可以简写成：$Var_Name&lt;/p&gt;
&lt;p&gt;　　echo $Var_Name ：打印变量的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、撤销变量&lt;/strong&gt;　　unset Var_Name&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915215231658-1785053629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、变量替换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通常情况下大括号可以省略  如果变量名后面要跟如下内容：字符串（包括大小字符串）、数字或下划线，那么变量名就一定要用大括号包起来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915215105367-222583675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、命令替换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　1、$(命令1;命令2......) (有些shell不兼容,tsh)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;2、倒引号 ``，`命令1;命令2......` (兼容性好，但是可读性差) &lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 　   括号或倒引号内命令的执行结果（标准输出）返回给当前shell，相当于产生了一个新的命令，其标准输出可被echo或者被当前shell的命令所使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915215045194-54699412.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、变量在单双引号中的引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　‘’ 单引号: 强引用，变量替换不会进行，变量名不会被替换成变量对应的值     &lt;/p&gt;
&lt;p&gt;　　&quot;&quot; 双引号：弱引用，能够执行变量替换，变量名可以被替换成变量对应的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915215025359-1642418604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9、位置变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　变量形式：$1, $2, $3, ......, $n  （$9以后需要用${10}）&lt;/p&gt;
&lt;p&gt;　　作用：用来接收给shell脚本所传递的参数，第一个参数用$1来获取，第二个参数用$2来获取，......&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;例1：随机在系统内找两个文本文件，分别输出它们空行的数量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915215008072-78495301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10、特殊变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　$0  :  &lt;/strong&gt;脚本名称自身&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　$?  :&lt;/strong&gt;  上一条命令的执行状态       &lt;/p&gt;
&lt;p&gt; 　　　　状态用数字表示：0-255&lt;/p&gt;
&lt;p&gt;          　　　　0：表示成功&lt;/p&gt;
&lt;p&gt;          　　　　1-255：失败，1.2.127.255预留&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　$#&lt;/strong&gt; ： 记录位置参数个数的总和         &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　$*&lt;/strong&gt; ： 详细列出所有的位置参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　$$&lt;/strong&gt; ： 当前所在进程的进程号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915214959573-1262866644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;七、算术运算&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、declare&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915223627685-1172571816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、expr&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915225342332-918576846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、let&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915225701020-1948263896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、$[算数表达式]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915225924249-766310097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、$((算术表达式))&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915230054187-1076082007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、算数运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　单个运算符：+，- ，*，/，%（余数）&lt;/p&gt;
&lt;p&gt;　　组合运算符：+= ，-=，*=，/=，%=&lt;/p&gt;
&lt;p&gt;　　　　　　　　a+=b  -----&amp;gt; a=a+b&lt;/p&gt;
&lt;p&gt;　　　　　　　　a-=b  ------&amp;gt; a=a-b&lt;/p&gt;
&lt;p&gt;　　　　　　　　a*=b --------&amp;gt; a=a*b&lt;/p&gt;
&lt;p&gt;　　　　　　　　a /=b ---------&amp;gt; a=a/b&lt;/p&gt;
&lt;p&gt;　　变量++：a++ ----&amp;gt; a=a+1&lt;/p&gt;
&lt;p&gt;　　变量--：a-- ------&amp;gt; a=a-1&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;注意&lt;/span&gt;：除法只能使用整数部分&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例2：随机选择两个文本，计算出两个文本生效的行数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180915231630650-383860132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;八、交互式输入、输出&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　输入：read  [-p &quot;提示信息&quot;]  变量名&lt;/p&gt;
&lt;p&gt;　　输出：echo $变量名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916101318235-733306759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;九、条件判断&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、比较运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;文件操作符&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　-d：测试是否为目录（Directory）&lt;/p&gt;
&lt;p&gt;　　　　-e：测试目录或文件是否存在（Exist）&lt;/p&gt;
&lt;p&gt;　　　　-f：测试是否为文件（File）&lt;/p&gt;
&lt;p&gt;　　　　-r：测试当前用户是否有权限读取（Read）&lt;/p&gt;
&lt;p&gt;　　　　-w：测试当前用户是否有权限写入（Write）&lt;/p&gt;
&lt;p&gt;　　　　-x：测试当前用户是否可执行（Excute）该文件&lt;/p&gt;
&lt;p&gt;　　　　-L：测试是否为符号连接（Link）文件&lt;/p&gt;
&lt;p&gt; 　　　　可以使用echo $?来判断，0为真，非0为假&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;数字操作符&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　-eq    　-gt   　-ge      -lt    　　-le       -ne&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;              &lt;/strong&gt;等于   大于 大于等于 小于  小于等于  不等于&lt;/p&gt;
&lt;p&gt;　　　　-eq  =  equals to          =&lt;/p&gt;
&lt;p&gt;　　　　-gt   =  great than         &amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　-ge  =   great or equals to   &amp;gt;=&lt;/p&gt;
&lt;p&gt;　　　　-lt   =   less than          &amp;lt;&lt;/p&gt;
&lt;p&gt;　　　　-le   =   less or equals to    &amp;lt;=&lt;/p&gt;
&lt;p&gt;　　　　-ne   =  not equals to       !=,&amp;lt;&amp;gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;字符串操作符&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　=  ：字符串内容相同&lt;/p&gt;
&lt;p&gt;　　　　!= ：字符串内容不同，! 号表示相反的意思&lt;/p&gt;
&lt;p&gt;　　　　-z ：字符串内容为空&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、逻辑运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与：&lt;strong&gt; &lt;/strong&gt;&amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;或：||&lt;/p&gt;
&lt;p&gt;非：！&lt;/p&gt;
&lt;p&gt;0：真&lt;/p&gt;
&lt;p&gt;1：假&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;||&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;！&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;/p&gt;





&lt;p&gt;&lt;strong&gt;3、判断方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;test 条件表达式&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;[ 操作符 文件或目录 ]或者[[ 操作符 文件或目录 ]]（中括号与表达式之间一定要有空格）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916105252048-692661903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;十、循环结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、for循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　格式：&lt;/p&gt;
&lt;p&gt;　　　　for var_Name in 列表; do&lt;/p&gt;
&lt;p&gt;　　　　　　循环体（正常执行的执行命令）&lt;/p&gt;
&lt;p&gt;　　　　　　语句1......&lt;/p&gt;
&lt;p&gt;　　　　done&lt;/p&gt;
&lt;p&gt;　　seq命令：类似于python里的range函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916110019291-2123412951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例3：生成5个空文件，文件名从1到10，后缀”.txt”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916111425500-1000483559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例4：添加user1到5用户，每添加一个显示/etc/passwd的最后一行信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916113153979-575289611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例5：再把例4创建的5个新用户和例3创建的5个空文件删除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916113919226-707604144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例6：求从1加到100的结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916114317469-1190396151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、while循环&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;格式：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　while [条件]; do&lt;/p&gt;
&lt;p&gt;　　　　　　循环体（正常执行的执行命令）&lt;/p&gt;
&lt;p&gt;　　　　　　语句1......&lt;/p&gt;
&lt;p&gt;　　　　done&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 　　&lt;/strong&gt;&lt;em&gt;退出循环：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　break：结束并退出循环&lt;/p&gt;
&lt;p&gt; 　　　   continue：在循环中不执行continue下面的代码，转而进入下一轮循环&lt;/p&gt;
&lt;p&gt; 　　&lt;em&gt;退出脚本：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　exit：常带一个整数给系统，如 exit 0&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例7：计算所有参数的和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916124300046-507434004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、until循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;条件测试不成功即进入循环体&lt;/p&gt;
&lt;p&gt;　　格式：&lt;/p&gt;
&lt;p&gt;　　　　until [条件]; do&lt;/p&gt;
&lt;p&gt;　　　　　　循环体（正常执行的执行命令）&lt;/p&gt;
&lt;p&gt;　　　　　　语句1......&lt;/p&gt;
&lt;p&gt;　　　　　　done&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例8：求1到100所有整数的和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916125143004-1850940904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;十一、选择结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、if条件判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;em&gt;单分支：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;                 if condition; then&lt;/p&gt;
&lt;p&gt;                    statement1&lt;/p&gt;
&lt;p&gt;                    ......&lt;/p&gt;
&lt;p&gt;　　　　   fi&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例9：变量Name是zhangsan，打印欢迎你&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916135730581-75015184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;em&gt;　&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;双分支 ：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;    　　if condition; then&lt;/p&gt;
&lt;p&gt;                    statement1&lt;/p&gt;
&lt;p&gt;    　　else&lt;/p&gt;
&lt;p&gt;                statement2&lt;/p&gt;
&lt;p&gt;    　　fi&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例10：变量Name是zhangsan，打印欢迎你，否则打印不欢迎&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916135716302-967928721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;em&gt;多分支：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;    　　if condition; then&lt;/p&gt;
&lt;p&gt;                    statement1&lt;/p&gt;
&lt;p&gt;    　　elif condition; then&lt;/p&gt;
&lt;p&gt;                    statement2&lt;/p&gt;
&lt;p&gt;    　　　　　...&lt;/p&gt;
&lt;p&gt;    　　else&lt;/p&gt;
&lt;p&gt;                    statementn&lt;/p&gt;
&lt;p&gt;    　　fi&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例11：变量score小于60，打印不及格；60到80之间，打印及格；80到100之间，打印优秀；否则打印分数有误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916135654643-57067843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例12：创建用户，如果创建成功，打印成功；如果失败，打印已存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916135644120-2095126629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例13：for循环打印9*9乘法表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916135633415-1125495736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、case语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;格式 ：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　case  变量引用  in&lt;/p&gt;
&lt;p&gt;　　　　正则表达式1)&lt;/p&gt;
&lt;p&gt;　　　　　　分支1&lt;/p&gt;
&lt;p&gt;　　　　　　;;&lt;/p&gt;
&lt;p&gt;　　　　正则表达式2)&lt;/p&gt;
&lt;p&gt;　　　　　　分支2&lt;/p&gt;
&lt;p&gt;　　　　　　;;&lt;/p&gt;
&lt;p&gt;　　　　正则表达式n)&lt;/p&gt;
&lt;p&gt;　　　　　　分支n&lt;/p&gt;
&lt;p&gt;　　　　　　;;&lt;/p&gt;
&lt;p&gt;　　　　*)&lt;/p&gt;
&lt;p&gt;　　　　　　默认分支&lt;/p&gt;
&lt;p&gt;　　　　　　;;&lt;/p&gt;
&lt;p&gt;　　　　esac&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例14：变量score 在1和9之间太低了，score小于60，打印不及格；60到80之间，打印及格；80到100之间，打印优秀；否则打印分数有误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916140748245-1084774587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;十二、函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;格式：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　function 函数名() {&lt;/p&gt;
&lt;p&gt;　　命令序列&lt;/p&gt;
&lt;p&gt;　　......&lt;/p&gt;
&lt;p&gt;　　return xxx&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;&lt;em&gt;调用&lt;/em&gt;：函数名 [ 参数1 ]  [ 参数2 ] .....&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例15：打印参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354520/201809/1354520-20180916141423209-1237511365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 06:37:00 +0000</pubDate>
<dc:creator>代码加工者</dc:creator>
<og:description>一、简介 1、概念 shell就是一个计算机应用程序，跟QQ、微信等类似，但是他主要是提供计算机的操作界面，例如我们所使用Windows操作系统的图形操作界面和cmd.exe命令行操作界面。shell</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/thoughtful-actors/p/9651554.html</dc:identifier>
</item>
<item>
<title>系统架构-设计模式及架构模式(干货) - 何戈洲</title>
<link>http://www.cnblogs.com/hegezhou_hot/p/9656014.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hegezhou_hot/p/9656014.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;      &lt;strong&gt;博客园首页是需要分享干货的地方，今天早上写的&lt;span&gt;《&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/hegezhou_hot/p/9655146.html&quot;&gt;&lt;span&gt;HRMS(人力资源管理系统)-从单机应用到SaaS应用-系统介绍&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》&lt;/span&gt;内容下架了，所以我就按照相关规定，只分享干货，我把之前写完的内容整理发布上来。这次主要分享一下在架构设计过程中涉及的基础知识，主要是涵盖系统架构方法、架构模式及设计模式，便于大家在后续一起探讨HRMS系统的SaaS模式的架构设计。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;一、设计模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       大家或多或少的都接触并在实际的开发过程中无形中可能都使用了某种设计模式，可能我们并不知道具体的模式叫什么名字，现在讲设计模式的书、案例分享都有很多，管理理论上的内容我这里就不一一复述，整体来说，设计模式分为3类：创建型、结构型、行为型。常见的有23种设计模式，我之前写过一个系列，我相信大家之前也看过，我这里再贴下链接&lt;strong&gt;&lt;span&gt;《&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/hegezhou_hot/archive/2010/11/30/1891672.html&quot;&gt;&lt;strong&gt;&lt;span&gt;设计模式-系列索引&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》，&lt;span&gt;大家感兴趣可以点击查看细节，今天在这里不单独展开设计模式的介绍和说明。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里我选取几个实际开发及设计过程中常用的几个设计模式给出理论教程和代码samples：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;19.028571428571&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;A、01.C#设计模式-抽象工厂模式  &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      &lt;a href=&quot;https://pan.baidu.com/s/1vDPDjaZVDXze2H2zHqzhpg&quot;&gt;PPT-下载&lt;/a&gt;      &lt;a href=&quot;https://pan.baidu.com/s/1fNNFBuLTSW4p_FbkggOxNw&quot;&gt;代码Samples下载&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;B、02.C#设计模式-适配器模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      &lt;a href=&quot;https://pan.baidu.com/s/17irwdeXmw_unZSafuDAhrg&quot;&gt;PPT-下载&lt;/a&gt;      &lt;a href=&quot;https://pan.baidu.com/s/1FGv9d1KrU6mZbRD_OT4KrQ&quot;&gt;代码Samples下载&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;C、03.C#设计模式-观察者模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      &lt;a href=&quot;https://pan.baidu.com/s/1wNSfVSm9qvtt_aSvbNOz6A&quot;&gt;PPT-下载&lt;/a&gt;      &lt;a href=&quot;https://pan.baidu.com/s/1DNZU6IvQpxOug7bPqmRQAg&quot;&gt;代码Samples下载&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;D、04.C#设计模式-代理模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      &lt;a href=&quot;https://pan.baidu.com/s/10yC2CAC1e5t4rWEmTxxNuQ&quot;&gt;PPT-下载&lt;/a&gt;      &lt;a href=&quot;https://pan.baidu.com/s/1bcGille9JLvIO8CtfCRhPg&quot;&gt;代码Samples下载&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;E、05.C#设计模式-模板方法模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      &lt;a href=&quot;https://pan.baidu.com/s/1eiPKWUA5pLGbS20AAX43Mw&quot;&gt;PPT-下载&lt;/a&gt;      &lt;a href=&quot;https://pan.baidu.com/s/1qoEX661Ni6kOX_qmYKmW9A&quot;&gt;代码Samples下载&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;F、06.C#设计模式-外观模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      &lt;a href=&quot;https://pan.baidu.com/s/1fJoBgFmbDEZiLnjNR9_HDQ&quot;&gt;PPT-下载&lt;/a&gt;      &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      &lt;span&gt;&lt;strong&gt;更多内容，请加微信群，我会及时共享到微信群中。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、系统架构方法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;早在2010年始，我便开始筹备并编写了10多篇关于软件架构方面的内容，当时写的深度、理论的完整性及高度，当前来看还差很多，经过这么多年的沉淀，目前我有信心及能力把之前没有写完的系统化的梳理明晰，通过博客的方式呈现出来，在这之前我想还是先把理论的内容给分享出来，便于我们在具体实践的过程中指导具体的设计方法。以便后续更好的推进我们的工作。之前我写过《&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/hegezhou_hot/archive/2010/09/12/1824345.html&quot;&gt;&lt;span&gt;系统架构师-基础到企业应用架构-系列索引&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;》系列，关于《&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/hegezhou_hot/p/9655146.html&quot;&gt;&lt;span&gt;HRMS(人力资源管理系统)-从单机应用到SaaS应用&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》系列可以说是架构方法的实践和延续，也请大家持续关注。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.7542735042735&quot;&gt;
&lt;p&gt;&lt;span&gt;A、&lt;a href=&quot;https://pan.baidu.com/s/1rdj97tCyNZj1bb0XY4mQHA&quot;&gt;01系统架构概述&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B、&lt;a href=&quot;https://pan.baidu.com/s/1RtTqu5mzilPVtR4UQeBTkw&quot;&gt;02系统架构过程1之架构分析&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C、&lt;a href=&quot;https://pan.baidu.com/s/1l3X01kxPQoWHSS3g1UuUHw&quot;&gt;02系统架构过程2之架构分割&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;D、&lt;a href=&quot;https://pan.baidu.com/s/1PHu94mhynQnKiNZrZj0whg&quot;&gt;02系统架构过程3之架构分划&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;E、&lt;a href=&quot;https://pan.baidu.com/s/1h6JZp-EIcP5UmLguKhpwyQ&quot;&gt;02系统架构过程4之非功能目标&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;F、&lt;a href=&quot;https://pan.baidu.com/s/121af9zo_U54RkMfO3uPiHA&quot;&gt;03系统架构1之层次深入&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;G、&lt;a href=&quot;https://pan.baidu.com/s/1eigeIhBHeV9ZLq1GU9UDAg&quot;&gt;03系统架构2之服务深入(SOA架构)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;H、&lt;a href=&quot;https://pan.baidu.com/s/1ij-izlek4qMp27BQ6RG3kw&quot;&gt;03系统架构3之产品线深入&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;I、&lt;a href=&quot;https://pan.baidu.com/s/16D3qzCUZw157dWUAclV1Vw&quot;&gt;03系统架构4之模式深入&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;J、&lt;a href=&quot;https://pan.baidu.com/s/19XqMS-Mh0mQeNXp-xoJMBQ&quot;&gt;04系统架构之六大战术-应对质量属性&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;K、&lt;a href=&quot;https://pan.baidu.com/s/1L8XdruxFqOc1YN0jq77sag&quot;&gt;05系统架构师-十大经验&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;strong&gt;     (请点击标题下载)&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、架构设计过程实践&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      理论需要结合实践，才能够真正的掌握架构设计的要领，前面已经在&lt;span&gt;《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/hegezhou_hot/p/9655146.html&quot;&gt;&lt;span&gt;HRMS(人力资源管理系统)-从单机应用到SaaS应用-系统介绍&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》&lt;/span&gt;开篇中介绍了HRMS系统的行业情况、行业发展趋势及前景、行业内还存在的现状及问题、我们基于这样一个有价值的系统来实践架构设计方式落地。过程中期待大家一起研究交流。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;HRMS(人力资源管理系统)-从单机应用到SaaS应用-架&lt;span&gt;构实践&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;系列》索引&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10.224669603524&quot;&gt;
&lt;p&gt;&lt;span&gt;A、&lt;a href=&quot;https://www.cnblogs.com/hegezhou_hot/p/9655146.html&quot;&gt;HRMS系统介绍&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B、系统架构准备阶段（功能性、非功能性、关键约束）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C、结合场景分析架构模式（概要架构）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;D、确定架构5视图（细化架构）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;E、.NET、Java架构落地实践&lt;/span&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;span&gt;四、更多的系统架构知识及培训材料&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;      &lt;strong&gt;关于更多的系统架构方面的知识，我已建立了交流群，相关资料会第一时间在群里分享，欢迎大家入群互相学习交流：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      &lt;span&gt;微信群：（扫码入群-名额有限）&lt;/span&gt;                                               &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/46256/201809/46256-20180913075705256-2118506841.png&quot; alt=&quot;&quot; width=&quot;364&quot; height=&quot;479&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 05:51:00 +0000</pubDate>
<dc:creator>何戈洲</dc:creator>
<og:description>博客园首页是需要分享干货的地方，今天早上写的《HRMS(人力资源管理系统)-从单机应用到SaaS应用-系统介绍》内容下架了，所以我就按照相关规定，只分享干货，我把之前写完的内容整理发布上来。这次主要分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hegezhou_hot/p/9656014.html</dc:identifier>
</item>
<item>
<title>vue插件开发流程详解-从开发到发布至npm（二） - adouwt</title>
<link>http://www.cnblogs.com/adouwt/p/9655594.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adouwt/p/9655594.html</guid>
<description>&lt;p&gt;　　前记：上一篇 &lt;a title=&quot;vue插件开发流程详解-从开发到发布至npm（一）&quot; href=&quot;https://www.cnblogs.com/adouwt/p/9211003.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/adouwt/p/9211003.html&lt;/a&gt;，（这里感谢博客园的网友，给我点赞推荐了） 说到了一个完整的vue插件开发、发布的流程，总结下来就讲了这么一个事，如何注入vue, 如果封装vue插件，如何测试vue插件，以及如何发布vue插件到npm。但是，这里开发测试到发布是分开在两个项目的，未免有些多余，今天的笔记讲的就是在上一篇的基础上，重新换了一下项目框架，讲开发测试，到打包发布一个完整的项目，这个项目欢迎大家测试使用，一个基于vue上传文件的一个插件，能够显示上传的速度和进度，如果是图片的话，也可以显示上传预览，有bug即时反馈哦！&lt;/p&gt;
&lt;h2&gt;1.项目架构目录：&lt;/h2&gt;
&lt;p&gt;      这里采用的是vue-cli 脚手架，版本是2.**，vue-cli 3.0 已经出来有一段了。今天暂不用3.0 的，回头会详细说上3.0的打包使用。项目目录如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916104551117-1275402870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个项目结构直接用 vue init webapck vue-upload  ,脚手架生的模版，大架构我基本没动，添加了一点自己的配置文件和新加了自己的文件夹。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916105334622-1745484006.png&quot; alt=&quot;&quot; width=&quot;1103&quot; height=&quot;896&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.打包插件源码的配置文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; path = require('path'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webpack = require('webpack'&lt;span&gt;)

module.exports &lt;/span&gt;=&lt;span&gt; {
  &lt;span&gt;entry: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'./src/plugin/ajax-upload.js',
  output: {
    path: path.resolve(__dirname, '../dist'),
    publicPath: '/dist/',
    filename: 'vueAjaxUpload.js',
    library: 'vueAjaxUpload', // library指定的就是你使用require时的模块名，这里便是require(&quot;vueAjaxUpload&quot;)
    libraryTarget: 'umd', //libraryTarget会生成不同umd的代码,可以只是commonjs标准的，也可以是指amd标准的，也可以只是通过script标签引入的。
    umdNamedDefine: true // 会对 UMD 的构建过程中的 AMD 模块进行命名。否则就使用匿名的 define。
&lt;/span&gt;&lt;span&gt;&lt;span&gt;  },&lt;/span&gt;
  module: {
    rules: [
      {
        test: &lt;/span&gt;/\.css$/&lt;span&gt;,
        use: [
          &lt;/span&gt;'vue-style-loader'&lt;span&gt;,
          &lt;/span&gt;'css-loader'&lt;span&gt;
        ],
      },      {
        test: &lt;/span&gt;/\.vue$/&lt;span&gt;,
        loader: &lt;/span&gt;'vue-loader'&lt;span&gt;,
        options: {
          loaders: {
          }
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; other vue-loader options go here&lt;/span&gt;
&lt;span&gt;        }
      },
      {
        test: &lt;/span&gt;/\.js$/&lt;span&gt;,
        loader: &lt;/span&gt;'babel-loader'&lt;span&gt;,
        exclude: &lt;/span&gt;/node_modules/&lt;span&gt;
      },
      {
        test: &lt;/span&gt;/\.(png|jpg|gif|svg)$/&lt;span&gt;,
        loader: &lt;/span&gt;'file-loader'&lt;span&gt;,
        options: {
          name: &lt;/span&gt;'[name].[ext]?[hash]'&lt;span&gt;
        }
      }
    ]
  },
  resolve: {
    alias: {
      &lt;/span&gt;'vue$': 'vue/dist/vue.esm.js'&lt;span&gt;
    },
    extensions: [&lt;/span&gt;'*', '.js', '.vue', '.json'&lt;span&gt;]
  },
  devServer: {
    historyApiFallback: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    noInfo: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    overlay: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  },
  performance: {
    hints: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  },
  devtool: &lt;/span&gt;'#eval-source-map'&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV === 'production'&lt;span&gt;) {
  module.exports.devtool &lt;/span&gt;= '#source-map'
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; http://vue-loader.vuejs.org/en/workflow/production.html&lt;/span&gt;
  module.exports.plugins = (module.exports.plugins ||&lt;span&gt; []).concat([
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DefinePlugin({
      &lt;/span&gt;'process.env'&lt;span&gt;: {
        NODE_ENV: &lt;/span&gt;'&quot;production&quot;'&lt;span&gt;
      }
    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.UglifyJsPlugin({
      sourceMap: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      compress: {
        warnings: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      }
    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.LoaderOptionsPlugin({
      minimize: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    })
  ])
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的配置文件也很简单，主要就是入口文件和输出文件，上面红色标记的部分，我们需要经常修改的也是这个两个参数，下面的打包规则我们可以不用多管。&lt;/p&gt;
&lt;h2&gt;3.package.json 的执行脚本的修改。&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916111033072-425279777.png&quot; alt=&quot;&quot; width=&quot;1102&quot; height=&quot;808&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.开发插件&lt;/h2&gt;
&lt;p&gt; 在plugin下，新建ajax-upload.js ajax-upload.vue。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916114617672-850443399.png&quot; alt=&quot;&quot; width=&quot;867&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ajax-upload.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import upload from './ajax-upload.vue'&lt;span&gt;
let ajaxUpload &lt;/span&gt;=&lt;span&gt; {}
ajaxUpload.install &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (Vue, options) {
  Vue.prototype.$msg &lt;/span&gt;= 'Hello I am test.js'&lt;span&gt;
  Vue.prototype.$myMethod &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (arr) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr.length &amp;lt; 0&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      arr &lt;/span&gt;= arr.join('连接你我'&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr
    }
  }
  Vue.component(upload.name, upload)
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; ajaxUpload
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ajax-upload.vue&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;wt-upload&quot;&amp;gt;
    &amp;lt;div class=&quot;file-area&quot;&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; class=&quot;file&quot; @change=&quot;previewImage($event)&quot; multiple/&amp;gt;
        &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&quot;file&quot; class=&quot;file-label&quot;&amp;gt;选择文件&amp;lt;/label&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div v-show=&quot;options.imagePreview&quot;&amp;gt;
        &amp;lt;div class=&quot;img-preview&quot; ref=&quot;imgPreview&quot;&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;p class=&quot;mt-sm&quot;&amp;gt;
        &amp;lt;button id=&quot;upload&quot; @click=&quot;uploadFile(file)&quot; class=&quot;upload&quot;&amp;gt;上传&amp;lt;/button&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;div class=&quot;progress-area&quot; v-show=&quot;options.showProgress ? options.showProgress : false&quot;&amp;gt;
        &amp;lt;p class=&quot;mb-sm&quot;&amp;gt;进度显示：&amp;lt;/p&amp;gt;
        &amp;lt;div class=&quot;progress&quot;&amp;gt;
          &amp;lt;div class=&quot;progress-bar&quot; id=&quot;progress&quot; ref=&quot;progress&quot;&amp;gt;0%&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;
          &amp;lt;p class=&quot;time&quot; ref=&quot;time&quot;&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'hupload'&lt;span&gt;,
  props: [&lt;/span&gt;'options'&lt;span&gt;],
  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      imgPreview: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
      xhr: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
      loaded: &lt;/span&gt;0&lt;span&gt;,
      ot: &lt;/span&gt;0&lt;span&gt;,
      total: &lt;/span&gt;0&lt;span&gt;,
      oloaded: &lt;/span&gt;0&lt;span&gt;,
      file: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    }
  },
  components: {
  },
  mounted () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.imgPreview = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.imgPreview
  },
  created () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest()
  },
  methods: {
    uploadFile (file) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;file) {
        alert(&lt;/span&gt;'请选择文件'&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.options.limitSize) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (file.files[0].size &amp;gt; (&lt;span&gt;this&lt;/span&gt;.options.limitSize) * 1e6&lt;span&gt;) {
          alert(`文件大小不得超过${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.options.limitSize}M`)
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (file.files[0].size &amp;gt; 10000000&lt;span&gt;) {
          alert(`文件大小不得超过10M`)
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        }
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.options.fileUploadName) {
        alert(&lt;/span&gt;'请配置与后端约定上传的key值'&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.options.url) {
        alert(&lt;/span&gt;'请配置与后端约定的上传接口地址'&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      }
      let formData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormData()
      formData.append(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.options.fileUploadName, file.files[0&lt;span&gt;])
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.xhr.onload = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.uploadSuccess
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.xhr.upload.onprogress = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setProgress
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.xhr.onerror = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.uploadFailed
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.xhr.open('post', &lt;span&gt;this&lt;/span&gt;.options.url, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.xhr.send(formData)
    },
    previewImage (event) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.file =&lt;span&gt; event.target
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.imgPreview.innerHTML = ''
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次重新选择文件的时候，都会去除上次选择产生的img标签&lt;/span&gt;
      let isImg = (event.target.files[0].type).indexOf('image/') &amp;gt; -1
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isImg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是图片 就解析图片预览&lt;/span&gt;
        let img = document.createElement('img'&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.imgPreview.appendChild(img)
        let reader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader()
        reader.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
          img.src &lt;/span&gt;=&lt;span&gt; event.target.result
          img.width &lt;/span&gt;= '200'&lt;span&gt;
        }
        reader.readAsDataURL(event.target.files[&lt;/span&gt;0&lt;span&gt;])
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'为文件选择一个默认的logo'&lt;span&gt;)
      }
    },
    setProgress (event) {
      let progress &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.progress
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; event.total是需要传输的总字节，event.loaded是已经传输的字节。如果event.lengthComputable不为真，则event.total等于0&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (event.lengthComputable) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loaded =&lt;span&gt; event.loaded
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.total =&lt;span&gt; event.total
        let complete &lt;/span&gt;= (event.loaded / event.total * 100).toFixed(1&lt;span&gt;)
        progress.innerHTML &lt;/span&gt;= Math.round(complete) + '%'&lt;span&gt;
        progress.style.width &lt;/span&gt;= complete + '%'&lt;span&gt;
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; let time = document.getElementById('time')&lt;/span&gt;
      let time = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.time
      let nt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Date().getTime() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前时间&lt;/span&gt;
      let pertime = (nt - &lt;span&gt;this&lt;/span&gt;.ot) / 1000
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算出上次调用该方法时到现在的时间差，单位为s&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.ot = &lt;span&gt;new&lt;/span&gt; Date().getTime() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新赋值时间，用于下次计算&lt;/span&gt;
      let perload = event.loaded - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.oloaded
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算该分段上传的文件大小，单位b&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.oloaded = event.loaded &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新赋值已上传文件大小，用以下次计算&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上传速度计算&lt;/span&gt;
      let speed = perload / pertime &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 单位b/s&lt;/span&gt;
      let bspeed =&lt;span&gt; speed
      let units &lt;/span&gt;= 'b/s' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 单位名称&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (speed / 1024 &amp;gt; 1&lt;span&gt;) {
        speed &lt;/span&gt;= speed / 1024&lt;span&gt;
        units &lt;/span&gt;= 'k/s'&lt;span&gt;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (speed / 1024 &amp;gt; 1&lt;span&gt;) {
        speed &lt;/span&gt;= speed / 1024&lt;span&gt;
        units &lt;/span&gt;= 'M/s'&lt;span&gt;
      }
      speed &lt;/span&gt;= speed.toFixed(1&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 剩余时间&lt;/span&gt;
      let resttime = ((event.total - event.loaded) / bspeed).toFixed(1&lt;span&gt;)
      resttime &lt;/span&gt;= resttime &amp;gt; 0 ? resttime : '0'&lt;span&gt;
      time.innerHTML &lt;/span&gt;= '传输速度：' + speed + units + '，剩余时间：' + resttime + 's'&lt;span&gt;
    },
    uploadSuccess () {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.xhr.readyState === 4 &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.xhr.status === 200&lt;span&gt;) {
        setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调给父组件&lt;/span&gt;
          &lt;span&gt;this&lt;/span&gt;.sendMsgToParent('success'&lt;span&gt;)
        }, &lt;/span&gt;1000&lt;span&gt;)
      }
    },
    uploadFailed (err) {
      console.log(err)
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sendMsgToParent({'error'&lt;span&gt;: err})
    },
    sendMsgToParent (msg) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$emit('receiveUploadMsg'&lt;span&gt;, msg)
    }
  }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;

&amp;lt;!-- 公共的样式 --&amp;gt;
&amp;lt;style&amp;gt;&lt;span&gt;
  .mb&lt;/span&gt;-&lt;span&gt;sm {
    margin&lt;/span&gt;-&lt;span&gt;bottom: 10px;
  }
  .mt&lt;/span&gt;-&lt;span&gt;sm {
    margin&lt;/span&gt;-&lt;span&gt;top: 10px;
  }
  .wt&lt;/span&gt;-&lt;span&gt;upload {
    text&lt;/span&gt;-&lt;span&gt;align: left;
  }
  .file&lt;/span&gt;-&lt;span&gt;area {
    width: &lt;/span&gt;80%&lt;span&gt;;
    margin: &lt;/span&gt;0&lt;span&gt; auto;
  }
  .file&lt;/span&gt;-&lt;span&gt;area  .file {
    display: none;
  }
  .wt&lt;/span&gt;-upload  .file-&lt;span&gt;label {
    display: block;
    width: 100px;
    padding: 8px;
    background: #39D2B4;
    color: #fff;
    font&lt;/span&gt;-&lt;span&gt;size: 1em;
    transition: all .4s;
    cursor: pointer;
    text&lt;/span&gt;-&lt;span&gt;align: center;
  }
  .wt&lt;/span&gt;-upload .file-&lt;span&gt;label:hover {
    background: rgb(&lt;/span&gt;123, 219, 200&lt;span&gt;);
  }
  .wt&lt;/span&gt;-upload .file-&lt;span&gt;label:focus {
      background: rgb(&lt;/span&gt;32, 148, 125&lt;span&gt;);
  }
  .wt&lt;/span&gt;-upload .img-&lt;span&gt;preview {
    margin&lt;/span&gt;-&lt;span&gt;top: 20px;
    margin&lt;/span&gt;-&lt;span&gt;bottom: 20px;
  }
  .wt&lt;/span&gt;-upload  .upload,.wt-&lt;span&gt;upload .abort {
    display: inline&lt;/span&gt;-&lt;span&gt;block;
    width: 100px;
    padding: 8px;
    background: #39D2B4;
    color: #fff;
    font&lt;/span&gt;-&lt;span&gt;size: 1em;
    transition: all .4s;
    cursor: pointer;
    outline: none;
    border: none;
  }
  .wt&lt;/span&gt;-&lt;span&gt;upload  .upload:hover {
    background: rgb(&lt;/span&gt;123, 219, 200&lt;span&gt;);
  }
  .wt&lt;/span&gt;-&lt;span&gt;upload .upload:focus {
    background: rgb(&lt;/span&gt;32, 148, 125&lt;span&gt;);
  }
  .wt&lt;/span&gt;-upload .progress-&lt;span&gt;area {
    padding: 20px;
  }
  .wt&lt;/span&gt;-&lt;span&gt;upload .progress {
    display: &lt;/span&gt;-webkit-&lt;span&gt;box;
    display: &lt;/span&gt;-ms-&lt;span&gt;flexbox;
    display: flex;
    height: 1rem;
    overflow: hidden;
    font&lt;/span&gt;-size: 0&lt;span&gt;.75rem;
    background&lt;/span&gt;-&lt;span&gt;color: #e9ecef;
    border&lt;/span&gt;-radius: 0&lt;span&gt;.25rem;
  }
  .wt&lt;/span&gt;-upload  .progress-&lt;span&gt;bar {
    display: &lt;/span&gt;-webkit-&lt;span&gt;box;
    display: &lt;/span&gt;-ms-&lt;span&gt;flexbox;
    display: flex;
    &lt;/span&gt;-webkit-box-&lt;span&gt;orient: vertical;
    &lt;/span&gt;-webkit-box-&lt;span&gt;direction: normal;
    &lt;/span&gt;-ms-flex-&lt;span&gt;direction: column;
    flex&lt;/span&gt;-&lt;span&gt;direction: column;
    &lt;/span&gt;-webkit-box-&lt;span&gt;pack: center;
    &lt;/span&gt;-ms-flex-&lt;span&gt;pack: center;
    justify&lt;/span&gt;-&lt;span&gt;content: center;
    color: #fff;
    text&lt;/span&gt;-&lt;span&gt;align: center;
    background&lt;/span&gt;-&lt;span&gt;color: #007bff;
    transition: width &lt;/span&gt;0&lt;span&gt;.6s ease;
  }
  .wt&lt;/span&gt;-&lt;span&gt;upload .time {
    margin&lt;/span&gt;-&lt;span&gt;top: 10px;
  }
&lt;/span&gt;&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ajax-upload.js的讲解：&lt;/strong&gt; 引入同级目录的ajax-upload.vue ，通过给一个自定义的对象添加install 方法，然后通过vue.component 方法注册到vue。这里也可以给vue,通过原型方法注册变量和方法。这里我们不需要，我们就只做了一个demo；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ajax-upload.vue的讲解：&lt;/strong&gt;里面具体的js业务逻辑不讲解了，就提个 props，和name 的属性，我们通过这个方法接受到父组件（调用该组件的组件）传递过来的参数，然后可以通过我们的定义的方法，如果是必须传递的参数，没有该参数我们就alert 提示;name 属性就是调用的封装的标签。为了减少项目的依赖插件的个数，我们也直接使用css不使用less等。&lt;/p&gt;
&lt;h2&gt;5.本地测试开发的插件的使用：&lt;/h2&gt;
&lt;p&gt;在dev文件夹下新建文件 dev-upload.vue&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916120638555-1798730741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;h2&amp;gt;开发测试&amp;lt;/h2&amp;gt;
        &amp;lt;hupload &lt;strong&gt;&lt;span&gt;:options=options v-on:receiveUploadMsg=&quot;receiveUploadMsg&quot;&lt;/span&gt;&lt;/strong&gt;&amp;gt; &amp;lt;/hupload&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;strong&gt;&lt;span&gt;
import Vue from &lt;/span&gt;'vue'&lt;span&gt;
import hupload from &lt;/span&gt;'../plugin/ajax-upload.js'&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;
Vue.use(hupload)&lt;/strong&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            &lt;span&gt;options: {
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'showProgress': true,
                'imagePreview': true,
                'url': 'str',
                'fileUploadName': 'ajax-upload',
                'limitSize': 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;
            }&lt;/span&gt;
        }
    },
    components: {
    },
    methods: {
        &lt;span&gt;&lt;strong&gt;receiveUploadMsg (msg) {
            console.log(msg)
        }&lt;/strong&gt;&lt;/span&gt;
    }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用组件就不直接在main.js下引入插件，直接在使用该插件的组件中，引入，然后通过vue.use 的方法使用组件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;
import hupload from &lt;/span&gt;'../plugin/ajax-upload.js'&lt;span&gt;
Vue.use(hupload)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用组件，传递参数和接受参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&amp;lt;hupload &lt;strong&gt;:options=options v-on:receiveUploadMsg=&quot;receiveUploadMsg&quot;&lt;/strong&gt;&amp;gt; &amp;lt;/hupload&amp;gt;
&lt;/pre&gt;
&lt;p&gt;这里组件的通信 父组件 -&amp;gt; 子组件， 子组件 -&amp;gt; 父组件 ，通过props 接受到父组件的参数，通过事件的方式接受子组件传递过来的参数。&lt;/p&gt;
&lt;p&gt;当然，要看到这个组件的使用是否正确，就要看页面了，页面路由 vue-router 如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916121906375-1330883652.png&quot; alt=&quot;&quot; width=&quot;854&quot; height=&quot;635&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问页面正常显示，没有报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916122333732-1872930450.png&quot; alt=&quot;&quot; width=&quot;766&quot; height=&quot;419&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;6.打包插件,并本地测试插件&lt;/h2&gt;
&lt;p&gt;上面第5步骤已经展示了插件是可以使用的，接下里就是打包了。&lt;/p&gt;
&lt;p&gt;执行：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;npm run dist&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916122719805-1599714697.png&quot; alt=&quot;&quot; width=&quot;989&quot; height=&quot;450&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 本地测试，先开页面路由：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916123001319-2142285404.png&quot; alt=&quot;&quot; width=&quot;1079&quot; height=&quot;727&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 访问页面，没有报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916123157707-73016308.png&quot; alt=&quot;&quot; width=&quot;1003&quot; height=&quot;618&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上看到了插件的引入方式不同。&lt;/p&gt;
&lt;h2&gt;7.发布插件&lt;/h2&gt;
&lt;p&gt;测试OK了，接下里就是发布了（假设你这里已经登陆npm了），执行命令：&lt;/p&gt;
&lt;p&gt;npm publish&lt;/p&gt;
&lt;p&gt;记住，每发布一次，需要修改package.json 的版本号：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916123735145-800038829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 不然报错。&lt;/p&gt;
&lt;p&gt; 发布完之后，我们就可以转到我们的npm 官网上看看我们的项目。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/vue-ajax-upload&quot; target=&quot;_blank&quot;&gt;https://www.npmjs.com/package/vue-ajax-upload&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916124624640-295456990.png&quot; alt=&quot;&quot; width=&quot;1039&quot; height=&quot;720&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;8.使用插件&lt;/h2&gt;
&lt;h4&gt;安装使用：&lt;/h4&gt;
&lt;h4&gt;npm install vue-ajax-upload --save&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916124948968-352751887.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;36&quot;/&gt;&lt;/p&gt;

&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916125729617-810851630.png&quot; alt=&quot;&quot; width=&quot;1077&quot; height=&quot;833&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 访问页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916125421142-625677961.png&quot; alt=&quot;&quot; width=&quot;869&quot; height=&quot;579&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201809/1102860-20180916130516615-1782550633.png&quot; alt=&quot;&quot; width=&quot;992&quot; height=&quot;436&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　结束语： 这个笔记继上一篇 &lt;a href=&quot;https://www.cnblogs.com/adouwt/p/9211003.html&quot; target=&quot;_blank&quot;&gt;vue插件开发流程详解-从开发到发布至npm（一）&lt;/a&gt;，替换了开发和测试的项目架构。除了在npm 登陆的那快，基本都是可以跳过上一篇，直接看这篇的，这个插件可以显示上传图片预览，上传速度和上传进度，如果需要讲解这部分话，请在下方留言，我会单独开一篇讲解这部分的内容。接下来的任务，还是需要做的vue 插件按需加载插件的方法，尽情期待我下一篇的笔记。如有不足，敬请指教，&lt;/p&gt;
&lt;p&gt;如果觉得好的话，&lt;a href=&quot;https://github.com/adouwt/vue-upload%20&quot; target=&quot;_blank&quot;&gt;https://github.com/adouwt/vue-upload &lt;/a&gt;，麻烦给个star 呀！&lt;/p&gt;
&lt;p&gt;     如需转载，请说明转载出处。&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 05:23:00 +0000</pubDate>
<dc:creator>adouwt</dc:creator>
<og:description>前记：上一篇 https://www.cnblogs.com/adouwt/p/9211003.html，（这里感谢博客园的网友，给我点赞推荐了） 说到了一个完整的vue插件开发、发布的流程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adouwt/p/9655594.html</dc:identifier>
</item>
<item>
<title>Java多线程编程核心技术(二)对象及变量的并发访问 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/9655806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/9655806.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;最近一直在忙比赛，四五个吧，时间有点紧张，博客也没时间更新~ 只能忙里抽闲&lt;/p&gt;
&lt;p&gt;本文属于Java多线程编程系列的第二篇，旨在分享我对多线程编程技术的心得与感悟，顺便做下笔记。&lt;/p&gt;
&lt;p&gt;如果你阅读完比较感兴趣，欢迎关注我，等待更新后续篇章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文主要介绍Java多线程中的同步，也就是如何在Java语言中写出线程安全的程序，如何在Java语言中解决非线程安全的相关问题。&lt;/p&gt;
&lt;h2 id=&quot;synchronized同步方法&quot;&gt;1.synchronized同步方法&lt;/h2&gt;
&lt;p&gt;“非线程安全”其实会在多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是”脏读“，也就是读取到的数据其实是被更改过的。而“线程安全”就是已获得的实例变量的值是经过线程同步处理的，不会出现脏读的现象。&lt;/p&gt;
&lt;h3 id=&quot;方法内的变量为线程安全&quot;&gt;1.1 方法内的变量为线程安全&lt;/h3&gt;
&lt;p&gt;“非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量，则不存在“非线程安全”问题，所得结果也就是“线程安全”的了。&lt;/p&gt;
&lt;h3 id=&quot;实例变量的非线程安全&quot;&gt;1.2 实例变量的非线程安全&lt;/h3&gt;
&lt;p&gt;如果多个线程共同访问1个对象中的实例变量，则有可能出现“非线程安全”问题。&lt;/p&gt;
&lt;p&gt;用线程访问的对象中如果有多个实例对象，则运行的结果有可能出现交叉的情况。&lt;/p&gt;
&lt;p&gt;如果对象仅有一个实例变量，则有可能出现覆盖的情况。&lt;/p&gt;
&lt;p&gt;如果两个线程同时访问一个没有同步的方法，如果两个线程同时操作业务对象中的实例变量，则有可能出现“非线程安全”问题。解决这个问题的方法就是在方法前加关键字synchronized即可。&lt;/p&gt;
&lt;h3 id=&quot;多个对象多个锁&quot;&gt;1.3 多个对象多个锁&lt;/h3&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Run {
    public static void main(String[] args) {
        MyService service1 = new MyService();
        Thread thread1 = new Thread(service1);
        thread1.start();
        MyService service2 = new MyService();
        Thread thread2 = new Thread(service2);
        thread2.start();
    }
}
public class MyService implements Runnable {
    private int i = 0;
    @Override
    synchronized public void run() {
        System.out.println(++i);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面示例是两个线程分别访问同一个类的两个不同实例的相同的同步方法，效果却是以异步的方式运行的。本示例由于创建了2个业务对象，在系统中产生出2个锁，所以运行结果是异步的，打印的效果就是1 1。当我们把线程2的参数service2改成service1，打印结果变为1 2。为什么是这样的结果？&lt;/p&gt;
&lt;p&gt;关键字 synchronized 取得的线程对象都是对象锁，而不是把一段代码或方法（函数）当做锁，所以在上面的示例中，哪个线程先执行带 synchronized 关键字的方法，哪个线程就持有该方法所属对象的锁Lock，那么其他线程只能呈等待状态，前提是多个线程访问的是同一个对象。&lt;/p&gt;
&lt;p&gt;但如果多个线程访问多个对象，则JVM会创建多个锁。&lt;/p&gt;
&lt;h3 id=&quot;synchronized方法与锁对象&quot;&gt;1.4 synchronized方法与锁对象&lt;/h3&gt;
&lt;p&gt;为了证明前面讲的线程锁是对象，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyService implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;begin: &quot;+Thread.currentThread().getName());
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;end&quot;);
    }
}
public class Run {
    public static void main(String[] args) {
        MyService service = new MyService();
        Thread thread1 = new Thread(service,&quot;A&quot;);
        thread1.start();
        Thread thread2 = new Thread(service,&quot;B&quot;);
        thread2.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;begin: B
begin: A
end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在run方法前加入关键字synchronized进行同步处理。再次运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;begin: A
end
begin: B
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的实验得出结论，调用关键字synchronized声明的方法一定是排队运行的。另外需要牢牢记住“共享”这两个字，只有共享资源读写访问才需要同步化，如果不是共享资源，那么基本就没有同步的必要。&lt;/p&gt;
&lt;h3 id=&quot;脏读&quot;&gt;1.5 脏读&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class MyService{
    private String username = &quot;AA&quot;;
    private String password = &quot;aa&quot;;

    public void getValue() {
        System.out.println(Thread.currentThread().getName()+&quot; : &quot;+username+&quot; &quot;+password);
    }

    synchronized public void setValue(String username,String password){
        this.username = username;
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.password = password;
    }
    
    public static void main(String[] args) throws InterruptedException {
        MyService service = new MyService();
        Thread thread1 = new Thread(() -&amp;gt; service.setValue(&quot;BB&quot;,&quot;bb&quot;),&quot;Thread-A&quot;);
        thread1.start();
        Thread.sleep(200);
        Thread thread2 = new Thread(service::getValue,&quot;Thread-B&quot;);
        thread2.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-B : BB aa&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出现脏读是因为getValue方法不是同步的，所以可以在任意时候进行调用。解决方法就是加上同步synchronized关键字，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;synchronized public void getValue() {
   System.out.println(Thread.currentThread().getName()+&quot; : &quot;+username+&quot; &quot;+password);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-B : BB bb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上述示例不仅要知道脏读是通过synchronized关键字解决的，还要知道如下内容：&lt;/p&gt;
&lt;p&gt;当A线程调用实例对象的加入synchronized关键字的 X 方法时，A线程就获得了 X 方法锁，更准确地讲，是获得了对象的锁，所以其他线程必须等A线程执行完毕了才可以调用 X 方法，但B线程可以随意调用其他的非 synchronized 同步方法。&lt;/p&gt;
&lt;p&gt;脏读一定会出现操作实例变量的情况下，这就是不同线程“争抢”实例变量的结果。&lt;/p&gt;
&lt;h3 id=&quot;synchronized锁重入&quot;&gt;1.6 synchronized锁重入&lt;/h3&gt;
&lt;p&gt;关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象后，再次请求此对象锁时是可以再次得到该对象的锁的。这也证明了在一个synchronized方法/块的内部调用本类的其他synchronized方法/块，是永远可以得到锁的。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyService{
    synchronized public void service1(){
        System.out.println(&quot;service1&quot;);
        service2();
    }
    
    synchronized public void service2(){
        System.out.println(&quot;service2&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“可重入锁”的概念是：自己可以再次获取自己的内部锁。可重入锁也支持在父子类继承的环境中。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyServiceChild extends MyService{
    synchronized public void service(){
        System.out.println(&quot;service1&quot;);
        this.service2();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明子类是完全可以通过“可重入锁”调用父类的同步方法的。&lt;/p&gt;
&lt;h3 id=&quot;出现异常锁自动释放&quot;&gt;1.7 出现异常,锁自动释放&lt;/h3&gt;
&lt;p&gt;当一个线程执行的代码出现异常时，其所持有的锁会自动释放。&lt;/p&gt;
&lt;h3 id=&quot;同步不具有继承性&quot;&gt;1.8 同步不具有继承性&lt;/h3&gt;
&lt;p&gt;同步不可以继承。子类继承父类的同步方法时还需要添加synchronized关键字才能保持同步。&lt;/p&gt;
&lt;h2 id=&quot;synchronized同步语句块&quot;&gt;2.synchronized同步语句块&lt;/h2&gt;
&lt;p&gt;用关键字synchronized声明方法在某些情况下是有弊端的，比如A线程调用同步方法执行一个长时间的任务，那么B线程则必须等待比较长的时间。在这样的情况下可以使用synchronized同步语句块来解决。synchronized 方法是对当前对象进行加锁，而 synchronized代码块是对某一个对象进行加锁。&lt;/p&gt;
&lt;h3 id=&quot;synchronized同步代码块的使用&quot;&gt;2.1 synchronized同步代码块的使用&lt;/h3&gt;
&lt;p&gt;当两个并发线程访问同一个对象object中的synchronized(this)同步代码块时，一段时间内只能有一个线程被执行，另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {

    public void service(){
        synchronized (this) {
            System.out.println(Thread.currentThread().getName()+&quot; begin: &quot; + System.currentTimeMillis());
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+&quot; end: &quot; + System.currentTimeMillis());
        }
    }
    public static void main(String[] args) {
        Test test = new Test();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test.service();
            }
        },&quot;Thread-A&quot;).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test.service();
            }
        },&quot;Thread-B&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-A begin: 1537000799741
Thread-A end: 1537000802742
Thread-B begin: 1537000802742
Thread-B end: 1537000805742&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述示例证明了同步synchronized代码块真的是同步的。&lt;/p&gt;
&lt;h3 id=&quot;一半同步一半异步&quot;&gt;2.2 一半同步，一半异步&lt;/h3&gt;
&lt;p&gt;我们把前面的示例代码的service方法改造一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void service(){
        System.out.println(Thread.currentThread().getName()+&quot; begin: &quot; + System.currentTimeMillis());
        synchronized (this) {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+&quot; end: &quot; + System.currentTimeMillis());
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-A begin: 1537001008952
Thread-B begin: 1537001008952
Thread-A end: 1537001011953
Thread-B end: 1537001014954&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本实验说明：不在synchronized代码块中就是异步执行，在synchronized块中就是同步执行。&lt;/p&gt;
&lt;h3 id=&quot;synchronized代码块间的同步性&quot;&gt;2.3 synchronized代码块间的同步性&lt;/h3&gt;
&lt;p&gt;在使用synchronized(this)代码块需要注意的是，当一个线程访问object的一个synchronized(this)同步代码块时，其它线程对同一个object中所有其他synchronized(this)同步访问被阻塞，这说明synchronized使用的“对象监视器”是一个。&lt;/p&gt;
&lt;p&gt;和synchronized关键字修饰的方法一样，synchronize(this)代码块也是锁定的当前对象。&lt;/p&gt;
&lt;h3 id=&quot;将任意对象作为对象监视器&quot;&gt;2.4 将任意对象作为对象监视器&lt;/h3&gt;
&lt;p&gt;多个线程调用同一个对象中得不同名称的synchronized同步方法或synchronized(this)同步代码块时，调用的效果就是按顺序执行，也就是同步的，阻塞的。&lt;/p&gt;
&lt;p&gt;这说明synchronized同步方法或synchronized同步代码块分别有两种作用。&lt;/p&gt;
&lt;p&gt;（1）对其他synchronized同步方法或synchronized(this)同步代码块调用呈阻塞状态。&lt;/p&gt;
&lt;p&gt;（2）同一时间只有一个线程可以执行synchronized同步方法或synchronized(this)同步代码块中的代码。&lt;/p&gt;
&lt;p&gt;在前面我们使用synchronized(this)格式来同步代码块，其实Java还支持对“任意对象”作为“对象监视器”来实现同步的功能。这个”任意对象“大多数是实例变量及方法的参数，使用格式为synchronized(非this对象)。&lt;/p&gt;
&lt;p&gt;根据前面对synchronized(this)同步代码块的作用总结可知，synchronized(非this对象)格式的作用只有1种：synchronized(非this对象 X )同步代码块。&lt;/p&gt;
&lt;p&gt;（1）在多个线程持有”对象监视器“为同一个对象的前提下，同一时间只有一个线程可以执行synchronized(非this对象 X)同步代码块。&lt;/p&gt;
&lt;p&gt;（2）当持有”对象监视器“为同一个对象的前提下，同一时间只有一个线程可以执行synchronized(非this对象X)同步代码块中的代码。&lt;/p&gt;
&lt;p&gt;下面演示下任意对象作为对象监视器的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    private String anyObject = new String();
    public void service(){
        synchronized (anyObject) {
            System.out.println(Thread.currentThread().getName()+&quot; begin: &quot; + System.currentTimeMillis());
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+&quot; end: &quot; + System.currentTimeMillis());
        }
    }
    public static void main(String[] args) {
        Test test = new Test();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test.service();
            }
        },&quot;Thread-A&quot;).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test.service();
            }
        },&quot;Thread-B&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-A begin: 1537008016172
Thread-A end: 1537008019173
Thread-B begin: 1537008019173
Thread-B end: 1537008022173&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;锁非this对象具有一定的优点：如果在一个类中有很多个synchronized方法，这时虽然能实现同步，但会受到阻塞，所以影响运行效率；但如果使用同步代码块锁非this对象，则synchronized(非this)代码块中的程序与同步方法是异步的，不与其他锁this同步方法争抢this锁，则可大大提高运行效率。&lt;/p&gt;
&lt;p&gt;再来看下面的示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    private String anyObject = new String();
    public void service(){
        synchronized (anyObject) {
            System.out.println(Thread.currentThread().getName()+&quot; begin: &quot; + System.currentTimeMillis());
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+&quot; end: &quot; + System.currentTimeMillis());
        }
    }
    synchronized public void service2(){
        System.out.println(Thread.currentThread().getName()+&quot; begin: &quot; + System.currentTimeMillis());
    }
    public static void main(String[] args) {
        Test test = new Test();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test.service();
            }
        },&quot;Thread-A&quot;).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test.service2();
            }
        },&quot;Thread-B&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-A begin: 1537009027680
Thread-B begin: 1537009027681
Thread-A end: 1537009030680&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，使用“synchronized(非this对象x)同步代码块”格式进行同步操作时，对象监视器必须是同一个对象，如果不是同一个对象。如果不是同一个对象监视器，运行的结果就是异步调用了，就会交叉运行。&lt;/p&gt;
&lt;h3 id=&quot;细化三个结论&quot;&gt;2.5 细化三个结论&lt;/h3&gt;
&lt;p&gt;”synchronized(非this对象X)“格式的写法是将x对象本身作为“对象监视器”，这样就可以得出以下3个结论：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当多个线程同时执行synchronized(X){}同步代码块时呈同步效果。&lt;/li&gt;
&lt;li&gt;当其他线程执行X对象中synchronized同步方法时呈同步效果。&lt;/li&gt;
&lt;li&gt;当其他线程执行X对象方法里面的synchronized(this)代码块时也呈现同步效果。&lt;/li&gt;
&lt;li&gt;但需要注意的是，如果其他线程调用不加synchronized关键字的方法时，还是异步调用。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;静态同步synchronized方法与synchronizedclass代码块&quot;&gt;2.6 静态同步synchronized方法与synchronized(class)代码块&lt;/h3&gt;
&lt;p&gt;关键字synchronized还可以在static静态方法上，如果这样写，那是对当前的*.java文件对应的Class类进行持锁。&lt;/p&gt;
&lt;p&gt;下面测试静态同步方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test2 {
    synchronized public static void service() {
        System.out.println(Thread.currentThread().getName() + &quot; begin: &quot; + System.currentTimeMillis());
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &quot; end: &quot; + System.currentTimeMillis());
    }

    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                Test2.service();
            }
        }, &quot;Thread-A&quot;).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                Test2.service();
            }
        }, &quot;Thread-B&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-A begin: 1537011409603
Thread-A end: 1537011412608
Thread-B begin: 1537011412608
Thread-B end: 1537011415608&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;synchronized关键字加到static静态方法上是给Class类上锁，而synchronized关键字加到非static静态方法上是给对象上锁。&lt;/p&gt;
&lt;p&gt;为了验证对象锁和Class锁不是同一个锁，来看下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test2 {
    synchronized public static void service() {
        System.out.println(Thread.currentThread().getName() + &quot; begin: &quot; + System.currentTimeMillis());
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &quot; end: &quot; + System.currentTimeMillis());
    }
    synchronized public void service2(){
        System.out.println(Thread.currentThread().getName() + &quot; begin: &quot; + System.currentTimeMillis());
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &quot; end: &quot; + System.currentTimeMillis());
    }
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                Test2.service();
            }
        }, &quot;Thread-A&quot;).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                new Test2().service2();
            }
        }, &quot;Thread-B&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-A begin: 1537012019151
Thread-B begin: 1537012019152
Thread-A end: 1537012022152
Thread-B end: 1537012022152&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;异步的原因是持有不同的锁，一个是对象锁，另外一个是Class锁，Class锁可以对所有类的实例对象起作用。&lt;/p&gt;
&lt;p&gt;下面我们测试synchronized(class)代码块，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public void service(){
        synchronized (Test.class) {
            System.out.println(Thread.currentThread().getName()+&quot; begin: &quot; + System.currentTimeMillis());
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+&quot; end: &quot; + System.currentTimeMillis());
        }
    }
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                new Test().service();
            }
        },&quot;Thread-A&quot;).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                new Test().service();
            }
        },&quot;Thread-B&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-A begin: 1537011197190
Thread-A end: 1537011200191
Thread-B begin: 1537011200191
Thread-B end: 1537011203191&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同步synchronized(class)代码块的作用其实和synchronized static方法的作用一样。&lt;/p&gt;
&lt;h3 id=&quot;数据类型string的常量池特性&quot;&gt;2.7 数据类型String的常量池特性&lt;/h3&gt;
&lt;p&gt;在JVM中具有String常量池缓存的功能，将synchronized(String)同步块与String联合使用时，要注意常量池以带来的一些例外。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public void service(String str){
        synchronized (str) {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; time: &quot; + System.currentTimeMillis());
            }
        }
    }
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                new Test().service(&quot;AA&quot;);
            }
        },&quot;Thread-A&quot;).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                new Test().service(&quot;AA&quot;);
            }
        },&quot;Thread-B&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-A time: 1537013470535
Thread-A time: 1537013470535
Thread-A time: 1537013470535
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果显示A线程陷入了死循环，而B线程一直在等待未执行。出现这样的结果就是两个持有相同的锁，所以造成B线程不能执行。这就是String常量池带来的问题。因此在大多数情况下，同步synchronized代码块都不使用String作为锁对象，而改用其他，比如new Object()实例化一个Object对象，但它并不放入缓存中。&lt;/p&gt;
&lt;p&gt;改造后的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public void service(Object str){
        synchronized (str) {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; time: &quot; + System.currentTimeMillis());
            }
        }
    }
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                new Test().service(new Object());
            }
        },&quot;Thread-A&quot;).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                new Test().service(new Object());
            }
        },&quot;Thread-B&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-A time: 1537015931981
Thread-A time: 1537015931982
Thread-B time: 1537015931982
Thread-B time: 1537015931982
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;交替打印的原因是持有的锁不是一个。&lt;/p&gt;
&lt;h3 id=&quot;同步synchronized方法无限等待与解决&quot;&gt;2.8 同步synchronized方法无限等待与解决&lt;/h3&gt;
&lt;p&gt;同步方法极易造成死循环。示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    synchronized public void serviceA() {
        System.out.println(Thread.currentThread().getName() + &quot; begin: &quot; + System.currentTimeMillis());
        boolean is = true;
        while (is){

        }
        System.out.println(Thread.currentThread().getName() + &quot; end: &quot; + System.currentTimeMillis());
    }

    synchronized public void serviceB() {
        System.out.println(Thread.currentThread().getName() + &quot; begin: &quot; + System.currentTimeMillis());
        System.out.println(Thread.currentThread().getName() + &quot; end: &quot; + System.currentTimeMillis());
    }

    public static void main(String[] args) {
        Test test = new Test();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test.serviceA();
            }
        }, &quot;Thread-A&quot;).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test.serviceB();
            }
        }, &quot;Thread-B&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程B永远得不到运行的机会，锁死了。&lt;/p&gt;
&lt;p&gt;解决的方法就是使用同步块。更改后的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    private Object objectA = new Object();
    public void serviceA() {
        synchronized (objectA) {
            System.out.println(Thread.currentThread().getName() + &quot; begin: &quot; + System.currentTimeMillis());
            boolean is = true;
            while (is) {

            }
            System.out.println(Thread.currentThread().getName() + &quot; end: &quot; + System.currentTimeMillis());
        }
    }

    private Object objectB = new Object();
    synchronized public void serviceB() {
        synchronized (objectB) {
            System.out.println(Thread.currentThread().getName() + &quot; begin: &quot; + System.currentTimeMillis());
            System.out.println(Thread.currentThread().getName() + &quot; end: &quot; + System.currentTimeMillis());
        }
    }
    ....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多线程的死锁&quot;&gt;2.9 多线程的死锁&lt;/h3&gt;
&lt;p&gt;Java多线程死锁是一个经典问题，因为不同的线程都在等待根本不可能被释放的锁，从而导致所有的任务都无法完成。在多线程技术中，“死锁”是必须避免的，因为这会造成线程的“假死”。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DealThread implements Runnable {
    public String username;
    public Object locak1 = new Object();
    public Object locak2 = new Object();
    public void setFlag(String username){
        this.username = username;
    }

    @Override
    public void run() {
        if (username.equals(&quot;a&quot;)){
            synchronized (locak1){
                System.out.println(&quot;username:&quot;+username);
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (locak2){
                    System.out.println(&quot;按lock1-》lock2执行&quot;);
                }
            }
        }

        if (username.equals(&quot;b&quot;)){
            synchronized (locak2){
                System.out.println(&quot;username:&quot;+username);
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (locak1){
                    System.out.println(&quot;按lock2-》lock1执行&quot;);
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        DealThread dealThread = new DealThread();
        dealThread.setFlag(&quot;a&quot;);
        Thread threadA = new Thread(dealThread);
        threadA.start();
        Thread.sleep(100);
        dealThread.setFlag(&quot;b&quot;);
        Thread threadB = new Thread(dealThread);
        threadB.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果，出现死锁：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;username:a
username:b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;死锁是程序设计的Bug，在设计程序时就需要避免双方互相持有对方的锁的情况。需要说明的是，本实验使用synchronized嵌套的代码结构来实现死锁，其实不使用嵌套的代码结构也会出现死锁，与嵌套不嵌套无任何关系，不要被代码结构所误导。只要互相等待对方释放锁就有可能出现死锁。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;可以使用JDK自带的工具来检测是否有死锁的现象。首先进入CMD命令行界面，再进入JDK的安装文件夹中的&lt;/p&gt;
&lt;p&gt;bin目录，执行jps命令。得到运行的线程Run的id值。再执行jstack命令，查看结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完整命令演示如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D:\Java\jdk1.8.0\bin&amp;gt;jps
8240 Launcher
13252 Jps
12312
7948 DealThread
D:\Java\jdk1.8.0\bin&amp;gt;jstack -l 7948
....

Java stack information for the threads listed above:
===================================================
&quot;Thread-1&quot;:
        at cn.zyzpp.thread2_3.DealThread.run(DealThread.java:39)
        - waiting to lock &amp;lt;0x00000000d6089e80&amp;gt; (a java.lang.Object)
        - locked &amp;lt;0x00000000d6089e90&amp;gt; (a java.lang.Object)
        at java.lang.Thread.run(Thread.java:745)
&quot;Thread-0&quot;:
        at cn.zyzpp.thread2_3.DealThread.run(DealThread.java:25)
        - waiting to lock &amp;lt;0x00000000d6089e90&amp;gt; (a java.lang.Object)
        - locked &amp;lt;0x00000000d6089e80&amp;gt; (a java.lang.Object)
        at java.lang.Thread.run(Thread.java:745)

Found 1 deadlock.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;锁对象的改变&quot;&gt;2.10 锁对象的改变&lt;/h3&gt;
&lt;p&gt;在任何数据类型作为同步锁时，需要注意的是，是否有多个线程同时持有锁对象，如果同时持有锁对象，则这些线程之间就是同步的；如果分别获得锁对象，这些线程之间就是异步的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    private String lock = &quot;123&quot;;
    public void service(){
        synchronized (lock) {
            System.out.println(Thread.currentThread().getName()+&quot; begin: &quot; + System.currentTimeMillis());
            lock = &quot;456&quot;;
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+&quot; end: &quot; + System.currentTimeMillis());
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Test test = new Test();
        new Thread(new Runnable() {
            @Override
            public void run() {
                test.service();
            }
        },&quot;Thread-A&quot;).start();
        Thread.sleep(50);
        new Thread(new Runnable() {
            @Override
            public void run() {
                test.service();
            }
        },&quot;Thread-B&quot;).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-A begin: 1537019992452
Thread-B begin: 1537019992652
Thread-A end: 1537019994453
Thread-B end: 1537019994653&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么是乱序？因为50ms过后线程取得的锁时“456”。&lt;/p&gt;
&lt;p&gt;把lock = &quot;456&quot;放在Thread.sleep(2000)之后，再次运行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread-A begin: 1537020101553
Thread-A end: 1537020103554
Thread-B begin: 1537020103554
Thread-B end: 1537020105558&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程A和线程B持有的锁都是“123”，虽然将锁改成了“456”，但结果还是同步的，因为A和B争抢的锁是“123”。&lt;/p&gt;
&lt;p&gt;还需要提示一下，只要对象不变，即使对象的属性被改变，运行的结果还是同步的。&lt;/p&gt;
&lt;h2 id=&quot;volatile关键字&quot;&gt;3.volatile关键字&lt;/h2&gt;
&lt;p&gt;关键字volatile的主要作用是使变量在多个线程间可见。&lt;/p&gt;
&lt;h3 id=&quot;关键字volatile与死循环&quot;&gt;3.1 关键字volatile与死循环&lt;/h3&gt;
&lt;p&gt;如果不是在多继承的情况下，使用继承Thread类和实现Runnable接口在取得程序运行的结果上并没有多大的区别。如果一旦出现”多继承“的情况，则用实现Runable接口的方式来处理多线程的问题就是很有必要的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PrintString implements Runnable{
    private boolean isContinuePrint = true;

    @Override
    public void run() {
        while (isContinuePrint){
            System.out.println(&quot;Thread: &quot;+Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public boolean isContinuePrint() {
        return isContinuePrint;
    }

    public void setContinuePrint(boolean continuePrint) {
        isContinuePrint = continuePrint;
    }

    public static void main(String[] args) throws InterruptedException {
        PrintString printString = new PrintString();
        Thread thread = new Thread(printString,&quot;Thread-A&quot;);
        thread.start();
        Thread.sleep(100);
        System.out.println(&quot;我要停止它！&quot; + Thread.currentThread().getName());
        printString.setContinuePrint(false);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread: Thread-A
我要停止它！main&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码运行起来没毛病，但是一旦运行在 -server服务器模式中64bit的JVM上时，会出现死循环。解决的办法是使用volatile关键字。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关键字volatile的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解决异步死循环&quot;&gt;3.2 解决异步死循环&lt;/h3&gt;
&lt;p&gt;在研究volatile关键字之前先来做一个测试用例，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PrintString implements Runnable{
    private boolean isRunnning = true;

    @Override
    public void run() {
        System.out.println(&quot;Thread begin: &quot;+Thread.currentThread().getName());
        while (isRunnning == true){
        }
        System.out.println(&quot;Thread end: &quot;+Thread.currentThread().getName());
    }

    public boolean isRunnning() {
        return isRunnning;
    }

    public void setRunnning(boolean runnning) {
        isRunnning = runnning;
    }

    public static void main(String[] args) throws InterruptedException {
        PrintString printString = new PrintString();
        Thread thread = new Thread(printString,&quot;Thread-A&quot;);
        thread.start();
        Thread.sleep(1000);
        printString.setRunnning(false);
        System.out.println(&quot;我要停止它！&quot; + Thread.currentThread().getName());
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JVM有Client和Server两种模式，我们可以通过运行：java -version来查看jvm默认工作在什么模式。我们在IDE中把JVM设置为在Server服务器的环境中，具体操作只需配置运行参数为 &lt;code&gt;-server&lt;/code&gt;。然后启动程序，打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread begin: Thread-A
我要停止它！main&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码 &lt;code&gt;System.out.println(&quot;Thread end: &quot;+Thread.currentThread().getName());&lt;/code&gt;从未被执行。&lt;/p&gt;
&lt;p&gt;是什么样的原因造成将JVM设置为-server就出现死循环呢？&lt;/p&gt;
&lt;p&gt;在启动thread线程时，变量&lt;code&gt;boolean isContinuePrint = true;&lt;/code&gt;存在于公共堆栈及线程的私有堆栈中。在JVM设置为-server模式时为了线程运行的效率，线程一直在私有堆栈中取得isRunning的值是true。而代码thread.setRunning(false);虽然被执行，更新的却是公共堆栈中的isRunning变量值false，所以一直就是死循环的状态。内存结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201809/1136672-20180916121209747-1733781267.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个问题其实就是私有堆栈中的值和公共堆栈中的值不同步造成的。解决这样的问题就要使用volatile关键字了，它主要的作用就是当线程访问isRunning这个变量时，强制性从公共堆栈中进行取值。&lt;/p&gt;
&lt;p&gt;将代码更改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;volatile private boolean isRunnning = true;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread begin: Thread-A
我要停止它！main
Thread end: Thread-A&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过使用volatile关键字，强制的从公共内存中读取变量的值，内存结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201809/1136672-20180916121227347-174019639.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用volatile关键字增加了实例变量在多个线程之间的可见性。但volatile关键字最致命的缺点是不支持原子性。&lt;/p&gt;
&lt;p&gt;下面将关键字synchronized和volatile进行一下比较：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法，以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到很大提升，在开发中使用synchronized关键字的比率还是比较大的。&lt;/li&gt;
&lt;li&gt;多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。&lt;/li&gt;
&lt;li&gt;volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。&lt;/li&gt;
&lt;li&gt;再次重申一下，关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方面来确保线程安全的。&lt;/p&gt;
&lt;h3 id=&quot;volatile非原子性的特征&quot;&gt;3.3 volatile非原子性的特征&lt;/h3&gt;
&lt;p&gt;关键字虽然增加了实例变量在多个线程之间的可见性，但它却不具备同步性，那么也就不具备原子性。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread extends Thread {
    volatile private static int count;
    @Override
    public void run() {
        addCount();
    }

    private void addCount() {
        for (int i = 0;i&amp;lt;100;i++){
            count++;
        }
        System.out.println(count);
    }

    public static void main(String[] args) {
        MyThread[] myThreads = new MyThread[100];
        for (int i=0;i&amp;lt;100;i++){
            myThreads[i] = new MyThread();
        }
        for (int i=0;i&amp;lt;100;i++){
            myThreads[i].start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
8253
8353
8153
8053
7875
7675&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在addCount方法上加入synchronized同步关键字与static关键字，达到同步的效果。&lt;/p&gt;
&lt;p&gt;再次运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;....
9600
9700
9800
9900
10000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键字volatile提示线程每次从共享内存中读取变量，而不是从私有内存中读取，这样就保证了同步数据的可见性。但在这里需要注意的是：如果修改实例变量中的数据，比如i++，也就是比&lt;/p&gt;
&lt;p&gt;i=i+1，则这样的操作其实并不是一个原子操作，也就是非线程安全。表达式i++的操作步骤分解为下面三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从内存中取i的值；&lt;/li&gt;
&lt;li&gt;计算i的值；&lt;/li&gt;
&lt;li&gt;将i值写入到内存中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;假如在第二步计算i值的时候，另外一个线程也修改i的值，那么这个时候就会脏数据。解决的方法其实就是使用synchronized关键字。所以说volatile关键字本身并不处理数据的原子性，而是强制对数据的读写及时影响到主内存中。&lt;/p&gt;
&lt;h3 id=&quot;使用原子类进行i操作&quot;&gt;3.4 使用原子类进行i++操作&lt;/h3&gt;
&lt;p&gt;除了在i++操作时使用synchronized关键字实现同步外，还可以使用AtomicInteger原子类进行实现。&lt;/p&gt;
&lt;p&gt;原子操作是不可分割的整体，没有其他线程能够中断或检查正在原子操作中的变量。它可以在没有锁的情况下做到线程安全。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread extends Thread {
    private static AtomicInteger count = new AtomicInteger(0);
    @Override
    public void run() {
        addCount();
    }

    private static void addCount() {
        for (int i = 0;i&amp;lt;100;i++){
            System.out.println(count.incrementAndGet());
        }
    }

    public static void main(String[] args) {
        MyThread[] myThreads = new MyThread[100];
        for (int i=0;i&amp;lt;100;i++){
            myThreads[i] = new MyThread();
        }
        for (int i=0;i&amp;lt;100;i++){
            myThreads[i].start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;....
9996
9997
9998
9999
10000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功达到累加的效果。&lt;/p&gt;
&lt;h3 id=&quot;原子类也不安全&quot;&gt;3.5 原子类也不安全&lt;/h3&gt;
&lt;p&gt;原子类在具有有逻辑性的情况下输出结果也具有随机性。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread extends Thread {
     private static AtomicInteger count = new AtomicInteger(0);
    @Override
    public void run() {
        addCount();
    }

    private static void addCount() {
        for (int i = 0;i&amp;lt;100;i++){
            count.incrementAndGet();
        }
        System.out.println(count);
    }

    public static void main(String[] args) {
        MyThread[] myThreads = new MyThread[100];
        for (int i=0;i&amp;lt;100;i++){
            myThreads[i] = new MyThread();
        }
        for (int i=0;i&amp;lt;100;i++){
            myThreads[i].start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;....
7900
7200
7300
7100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，打印顺序出错了，出现这样的原因是因为AtomicInteger的方法时原子的，但方法与方法之间的调用却不是原子的。解决这样的问题必须要用同步。&lt;/p&gt;
&lt;h3 id=&quot;synchronized代码块有volatile同步的功能&quot;&gt;3.6 synchronized代码块有volatile同步的功能&lt;/h3&gt;
&lt;p&gt;关键字synchronized可以使多个线程访问同一个资源具有同步性，而且它还具有将线程工作内存中的私有变量与公共内存中的变量同步的功能。&lt;/p&gt;
&lt;p&gt;我们把前面讲到的异步死循环代码改造一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PrintString implements Runnable{
    private boolean isRunnning = true;

    @Override
    public void run() {
        String lock = new String();
        System.out.println(&quot;Thread begin: &quot;+Thread.currentThread().getName());
        while (isRunnning == true){
            synchronized (lock){
                //加与不加的效果就是是否死循环
            }
        }
        System.out.println(&quot;Thread end: &quot;+Thread.currentThread().getName());
    }

    public boolean isRunnning() {
        return isRunnning;
    }

    public void setRunnning(boolean runnning) {
        isRunnning = runnning;
    }

    public static void main(String[] args) throws InterruptedException {
        PrintString printString = new PrintString();
        Thread thread = new Thread(printString,&quot;Thread-A&quot;);
        thread.start();
        Thread.sleep(1000);
        printString.setRunnning(false);
        System.out.println(&quot;我要停止它！&quot; + Thread.currentThread().getName());
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread begin: Thread-A
我要停止它！main
Thread end: Thread-A&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键字synchronized可以保证在同一时刻，只有一个线程可以执行某一个方法或某一个代码块。它包含两个特征：互斥相和可见性。同步synchronized不仅可以解决一个线程看到对象处于不一致的状态，还可以保证进入同步方法或者同步代码块的每个线程，都看到由同一个锁保护之前所有的修改效果。&lt;/p&gt;
&lt;p&gt;学习多线程并发。要着重“外修互斥，内修可见”，这是掌握多线程、学习多线程并发的重要技术点。&lt;/p&gt;
&lt;h2 id=&quot;文末总结&quot;&gt;4.文末总结&lt;/h2&gt;
&lt;p&gt;本文应该着重掌握如下技术点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;synchronized对象监视器为Object时的使用。&lt;/li&gt;
&lt;li&gt;synchronized对象监视器为Class时的使用。&lt;/li&gt;
&lt;li&gt;非线程安全是如何出现的。&lt;/li&gt;
&lt;li&gt;关键字volatile的主要作用。&lt;/li&gt;
&lt;li&gt;关键字volatile与synchronized的区别及使用情况。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考&quot;&gt;5.参考&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;《Java多线程编程核心技术》高洪岩著&lt;/em&gt;&lt;br/&gt;文中若有笔误欢迎评论区指正！&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 04:14:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>最近一直在忙比赛，四五个吧，时间有点紧张，博客也没时间更新~ 只能忙里抽闲 本文属于Java多线程编程系列的第二篇，旨在分享我对多线程编程技术的心得与感悟，顺便做下笔记。 如果你阅读完比较感兴趣，欢迎</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/9655806.html</dc:identifier>
</item>
<item>
<title>JS的发布订阅模式 - Mr.苏</title>
<link>http://www.cnblogs.com/suyuanli/p/9655699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suyuanli/p/9655699.html</guid>
<description>&lt;h4 id=&quot;这里要说明一下什么是发布-订阅模式&quot;&gt;这里要说明一下什么是发布-订阅模式&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;发布-订阅模式里面包含了三个模块，发布者，订阅者和处理中心。这里处理中心相当于报刊办事大厅。发布者相当与某个杂志负责人，他来中心这注册一个的杂志，而订阅者相当于用户，我在中心订阅了这分杂志。每当发布者发布了一期杂志，办事大厅就会通知订阅者来拿新杂志。这样在结合下面的图应该很好理解了。&lt;br/&gt;&lt;img src=&quot;http://blog.suyuanli.ink/1537064455000-553.png&quot; title=&quot;发布订阅图1&quot; alt=&quot;发布订阅图1&quot;/&gt;&lt;/li&gt;
&lt;li&gt;其实就是将发布者和订阅者解耦了，在实际开发中，经常会遇到某个方法内处理很多的逻辑，最简单的就是直接在方法内直接写。这种是高度耦合的面向过程的写法。对于代码维护不友好。而发布-订阅模式就是将两者分离。我触发了某个事件（这里我们将触发该方法定义为事件），我只向调度中心通知，我并不知道调度中心内会怎么处理，有多少个人响应。我只管通知。而订阅者只管在调度中心订阅，有人调用它才响应。&lt;/li&gt;
&lt;li&gt;还有一点就是假设我们有3个js文件，事件触发在a.js内，而响应该事件的在b.js和c.js内，要是用常规调用的方法的话，就要把b.js和c.js的方法传到a.js内。这是一个非常麻烦的操作。而发布-订阅模式是将调度中心挂在了全局，我们只管调用调度中心相应的方法注册和订阅。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;ps：还有一点要注意的，很多人会把观察者模式和发布-订阅模式混淆，其实两者之间还是有点区别的，不过在本文我不会详细讲。&lt;/p&gt;
&lt;h3 id=&quot;下面我们来实现一个发布-订阅模式的类&quot;&gt;下面我们来实现一个发布-订阅模式的类&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Event {
  constructor () {}
  // 首先定义一个事件容器，用来装事件数组（因为订阅者可以是多个）
  handlers = {}

  // 事件添加方法，参数有事件名和事件方法
  addEventListener (type, handler) {
    // 首先判断handlers内有没有type事件容器，没有则创建一个新数组容器
    if (!(type in this.handlers)) {
      this.handlers[type] = []
    }
    // 将事件存入
    this.handlers[type].push(handler)
  }

  // 触发事件两个参数（事件名，参数）
  dispatchEvent (type, ...params) {
    // 若没有注册该事件则抛出错误
    if (!(type in this.handlers)) {
      return new Error('未注册该事件')
    }
    // 便利触发
    this.handlers[type].forEach(handler =&amp;gt; {
      handler(...params)
    })
  }

  // 事件移除参数（事件名，删除的事件，若无第二个参数则删除该事件的订阅和发布）
  removeEventListener (type, handler) {
      // 无效事件抛出
      if (!(type in this.handlers)) {
        return new Error('无效事件')
      }
      if (!handler) {
        // 直接移除事件
        delete this.handlers[type]
      } else {
        const idx = this.handlers[type].findIndex(ele =&amp;gt; ele === handler)
        // 抛出异常事件
        if (idx === undefined) {
          return new Error('无该绑定事件')
        }
        // 移除事件
        this.handlers[type].splice(idx, 1)
        if (this.handlers[type].length === 0) {
          delete this.handlers[type]
        }
      }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok到现在为止就已经实现了基本发布订阅的功能了，其实很简单，如果还有什么奇怪的需求，都可以通通往里面加。&lt;/p&gt;
&lt;h4 id=&quot;希望大家转载时注明出处httpswww.cnblogs.comsuyuanlip9655699.html&quot;&gt;希望大家转载时注明出处：&lt;a href=&quot;https://www.cnblogs.com/suyuanli/p/9655699.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/suyuanli/p/9655699.html&lt;/a&gt;&lt;/h4&gt;
</description>
<pubDate>Sun, 16 Sep 2018 03:36:00 +0000</pubDate>
<dc:creator>Mr.苏</dc:creator>
<og:description>发布-订阅模式里面包含了三个模块，发布者，订阅者和处理中心。这里处理中心相当于报刊办事大厅。发布者相当与某个杂志负责人，他来中心这注册一个的杂志，而订阅者相当于用户，我在中心订阅了这分杂志。每当发布者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suyuanli/p/9655699.html</dc:identifier>
</item>
<item>
<title>一统江湖的大前端（7）React.js-从开发者到工程师 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9632496.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9632496.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;blockquote readability=&quot;13.695652173913&quot;&gt;
&lt;p&gt;首发链接：&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/70f69ca4953111e89fc57ca23e93a89f&quot; class=&quot;uri&quot;&gt;https://bbs.huaweicloud.com/blogs/70f69ca4953111e89fc57ca23e93a89f&lt;/a&gt;&lt;br/&gt;《一统江湖的大前端》系列是自己的前端学习笔记，旨在介绍javascript在非网页开发领域的应用案例和发现各类好玩的js库，不定期更新。如果你对前端的理解还是写写页面绑绑事件，那你真的是有点OUT了，前端能做的事情已经太多了, &lt;code&gt;手机app开发&lt;/code&gt; , &lt;code&gt;桌面应用开发&lt;/code&gt; , &lt;code&gt;用于神经网络人工智能的库&lt;/code&gt; , &lt;code&gt;页面游戏&lt;/code&gt; , &lt;code&gt;数据可视化&lt;/code&gt; , 甚至 &lt;code&gt;嵌入式开发&lt;/code&gt; ，什么火就搞什么,活脱脱一个&lt;strong&gt;蹭热点小能手&lt;/strong&gt;。如果你也觉得前端的日常开发有些枯燥，不妨一起来看看前端的另一番模样。如果本系列对你有用，请为我点赞，支持我继续写作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/11/8e51f4fcdfbab42486dfe2f935d9c971.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/01/c52edd134bda354db3254789a3217b02.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-前端打怪升级指南&quot;&gt;一. 前端打怪升级指南&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/01/c2920bcc65705ed9764221412ab13758.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;br/&gt;许多入职前端的开发者，都是从熟练使用框架进行业务逻辑开发而开始的。说到框架，&lt;code&gt;Vue&lt;/code&gt;,&lt;code&gt;React&lt;/code&gt;,&lt;code&gt;Angular&lt;/code&gt;三大框架都已经圈定了自己的用户群，从粉丝的数量来说，&lt;code&gt;Vue&lt;/code&gt;最多，接着是&lt;code&gt;React&lt;/code&gt;，最后才是&lt;code&gt;Angular&lt;/code&gt;，这样的局面实际上与三个框架本身的优劣并不完全相关。如果你使用过&lt;code&gt;Angular.js1.X&lt;/code&gt;版本，就会明白上述三个框架可以统称为&lt;strong&gt;第二代前端SPA框架&lt;/strong&gt;，从历史的角度来看，它们都用自己的方式解决了&lt;code&gt;Angular.js1.X&lt;/code&gt;在SPA模型的实现中存在的一些问题；从未来的角度看，它们都是在实现尚未标准化的&lt;strong&gt;Web Component&lt;/strong&gt;标准。如果只以&lt;strong&gt;熟练使用API进行业务逻辑开发&lt;/strong&gt;作为衡量标准，那么了解一个框架和了解以上三个框架没有什么实质性的区别，除非面试官自己就是个水货，否则基本不可能因此就多给你一点薪水。&lt;/p&gt;
&lt;p&gt;如果你所在的项目组已经在使用某一个框架，那么对于一个新人来说，你只需要写好分派给自己的业务逻辑任务，阅读组内老鸟的代码，学习团队的组件开发范式并做好笔记，熟悉框架的生态，熟悉各类库的API等等，积累经验提升等级，完成最初的&lt;strong&gt;新手-&amp;gt;前端开发者&lt;/strong&gt;的转职。&lt;/p&gt;
&lt;h3 id=&quot;我应该从哪个框架开始学&quot;&gt;1.1 我应该从哪个框架开始学？&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;许多新手都有这样的疑问，笔者的建议是&lt;code&gt;Vue&lt;/code&gt;-&amp;gt;&lt;code&gt;React&lt;/code&gt;-&amp;gt;&lt;code&gt;Angular&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Vue&lt;/code&gt;是最流行的，语法简洁，社区活跃度高，使用的人数也最多。而且稍复杂的问题几乎都有完整的解决方案，很快就能够上手业务逻辑，并在工作中持续进步，如果你还不是一个熟练的前端开发者，你应该优先学习它。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;React&lt;/code&gt;是第二个你应该学习的框架，它的开发模式实际上和&lt;code&gt;Vue&lt;/code&gt;非常类似，但在&lt;code&gt;Vue&lt;/code&gt;中你还可以只使用&lt;code&gt;ES5&lt;/code&gt;的语法进行开发，而没有&lt;code&gt;ES6&lt;/code&gt;的基本知识，你可能连&lt;code&gt;React&lt;/code&gt;项目的demo阅读起来都有困难（React 从16.0版本已经移除了创建组件的&lt;code&gt;ES5&lt;/code&gt;方法&lt;code&gt;createClass&lt;/code&gt;而推荐使用&lt;code&gt;ES6&lt;/code&gt;的继承来实现），同时浏览器也无法直接运行那些奇怪的代码，你不得不去学习一整套诸如&lt;code&gt;ES6&lt;/code&gt;,&lt;code&gt;Babel&lt;/code&gt;,&lt;code&gt;Nodejs&lt;/code&gt;,&lt;code&gt;Webpack&lt;/code&gt;等等经常听到却没有去研究的东西。学习&lt;code&gt;React&lt;/code&gt;的目的，并不是让你使用另一套&lt;em&gt;API&lt;/em&gt;重构自己的项目，而是强迫自己将技术栈拓展到整个&lt;strong&gt;大前端&lt;/strong&gt;，并开始关注页面开发以外的知识，学习的过程或许很漫长甚至痛苦，但最终你会发现自己的投入都是值得的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Angular&lt;/code&gt;技术栈和生态可以作为选学内容，如果你喜欢&lt;code&gt;Java&lt;/code&gt;那种严谨的编程方式，或许会喜欢这种前后端的技术栈组合，事实上&lt;code&gt;Angular&lt;/code&gt;也是诸多后端同学倒腾前端时的选择(也就是后端全栈工程师)。但从前端开始接触程序开发的开发者可能一时间很难理解&lt;code&gt;Java&lt;/code&gt;中的各级抽象，更不用说设计模式和周边生态了。和前两者相比，&lt;code&gt;Angular&lt;/code&gt;更像是一个学院派的老学究，啰嗦却严谨，它要求你即时是在使用&lt;code&gt;Javascript&lt;/code&gt;这种玩具语言的同时，依旧要用完整的软件工程的思维和流程来编写代码。但无论是否要深入研究，我都建议你能够浏览相关的技术栈和各类博文。&lt;/p&gt;
&lt;p&gt;当能够熟练使用&lt;code&gt;Vue&lt;/code&gt;或&lt;code&gt;React&lt;/code&gt;技术栈和周边生态时，你的能力已经能够称得上是一名&lt;strong&gt;前端开发者&lt;/strong&gt;了，和那些连基本业务逻辑都梳理不清楚的前端菜鸟有了明显的距离。这个时候你需要对自己的未来做出一个选择，太阳况且需要透镜聚焦才能点燃纸张，你也应该将自己的精力集中在更想去做的一个方向。&lt;/p&gt;
&lt;h3 id=&quot;一次转职&quot;&gt;1.2 一次转职&lt;/h3&gt;
&lt;p&gt;请记住，当你有能力做出如下选择的时候，你已经能够胜任&lt;strong&gt;前端开发者&lt;/strong&gt;的大多数工作内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;♕ 职业介绍——前端工程师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端工程师&lt;/strong&gt;的技能书，是基于&lt;code&gt;node.js&lt;/code&gt;开始扩展的。这个阶段的学习中，你需要掌握两个大的技能模块——&lt;code&gt;扩展编写&lt;/code&gt;和&lt;code&gt;前端工程化&lt;/code&gt;，也就是说你需要&lt;strong&gt;尽可能从面向使用者转变为面向开发者和整个前端工程&lt;/strong&gt;。&lt;code&gt;扩展编写&lt;/code&gt;的能力让你可以为团队的其他开发者封装公共模块，&lt;code&gt;前端工程化&lt;/code&gt;可以让团队其他开发者将主要精力专注于前端业务逻辑本身。&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;扩展编写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是指基本的组件抽象能力，你需要掌握为各类框架和工具编写扩展或公共组件的能力，例如编写&lt;code&gt;jQuery&lt;/code&gt;插件,&lt;code&gt;Angularjs&lt;/code&gt;自定义指令,&lt;code&gt;React&lt;/code&gt;组件，&lt;code&gt;webpack&lt;/code&gt;或&lt;code&gt;gulp&lt;/code&gt;功能扩展组件，甚至使用C++为&lt;code&gt;node.js&lt;/code&gt;编写原生扩展等等，甚至可以尝试在自己封装的组件中添加&lt;strong&gt;自定义扩展&lt;/strong&gt;的支持功能，它可以帮助你更好地去使用所选择的技术栈，完成从“面向过程编程”到“面向对象编程”的基本思维方式转变，让你不再需要没完没了地去编写重复的东西。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;前端工程化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是指除代码编写以外的开发，部署，测试，上线及监控等一系列环节的前端工作流的实现。对开发者来说，代码写完测试完就结束了，而对前端工程师来说，代码的编写只是整个工作流中的一个环节而已，要知道并不是你写的代码不报错，就意味着它可以被正确地展现在用户面前。前端的自动化工程提供了整套的代码加工流程，让诸如添加前缀后缀，CSShack，语法转换，图片合并，代码混淆，代码分割等等一系列功能变得自动化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;♕ 职业介绍——初级图形学工程师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果对于掌控整个项目没有什么兴趣，或许你可以考虑&lt;strong&gt;图形学&lt;/strong&gt;的方向，&lt;strong&gt;初级图形学工程师&lt;/strong&gt;的技能书，是基于&lt;code&gt;UI&lt;/code&gt;来扩展的。&lt;strong&gt;图形学&lt;/strong&gt;其实是一个很宽泛的概念，笔者个人的理解的图形学大致是包含&lt;code&gt;数据可视化&lt;/code&gt;,&lt;code&gt;高级UI设计开发&lt;/code&gt;,&lt;code&gt;GIS&lt;/code&gt;,&lt;code&gt;游戏&lt;/code&gt;这几个常见的细分方向。相比于架构方向，图形学更加生动有趣，也更容易带给开发者成就感。你觉得用一堆简陋的素材和创意做出一款游戏和用一大堆框架和依赖做出一个&lt;strong&gt;Hello world&lt;/strong&gt;哪一个更有趣呢？大多数人都会选择前者。但实际上大多数初级的前端开发并没有太多机会去接触这个方向的开发，因为&lt;strong&gt;图形学&lt;/strong&gt;往往需要处理很大的数据集，也就意味着它和&lt;strong&gt;性能&lt;/strong&gt;这两个字直接挂钩，初级的前端大多是不具备这个方向的解决问题能力的。想要在这个职业方向上有所建树，初级阶段需要完成的学习包括：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;数据可视化&lt;/code&gt;的基本实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;能够熟练使用&lt;code&gt;Echarts&lt;/code&gt;或者&lt;code&gt;D3&lt;/code&gt;实现基本的数据可视化展现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;CSS3D&lt;/code&gt;，&lt;code&gt;SVG&lt;/code&gt;，&lt;code&gt;Canvas&lt;/code&gt;的相关开发能力&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你需要重新学习&lt;code&gt;CSS3D&lt;/code&gt;，&lt;code&gt;SVG&lt;/code&gt;，&lt;code&gt;Canvas&lt;/code&gt;这些平时项目中可能并没有用到的技术。因为你所要面临的挑战，不再是调整一下div元素的布局或是修改一下盒模型的尺寸，而是各类矢量图形甚至大数据量的像素点级别的开发。&lt;/p&gt;
&lt;h3 id=&quot;二次转职&quot;&gt;1.3 二次转职&lt;/h3&gt;
&lt;p&gt;请记住，当你有能力做出如下选择的时候，你已经能够胜任&lt;strong&gt;一转职业&lt;/strong&gt;的大多数工作内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;♕ 进阶职业介绍——前端架构师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个前端架构师，需要开始研究各类框架的&lt;code&gt;源代码&lt;/code&gt;，研究其中的&lt;code&gt;数据结构&lt;/code&gt;,&lt;code&gt;设计模式&lt;/code&gt;,&lt;code&gt;核心算法&lt;/code&gt;，并尽可能去从各个环节优化代码的整体性能，并为各类技术问题提供从语言级到架构级的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;♕ 进阶职业介绍——高级图形学工程师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高级图形学工程师的开发工作是需要与设计相辅相成的，把一个表格改造成一个柱状图，那不叫图形学。高级图形学工程师，可以给出不输于设计师的设计作品，可以做出优雅且交互性非常好的前端页面，也可以不断去优化代码性能去加快渲染速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;♕ 进阶职业介绍——游戏工程师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在获得了初级图形学工程师的技能后，再加上&lt;code&gt;高中物理&lt;/code&gt;和&lt;code&gt;高中数学&lt;/code&gt;的知识，就可以胜任前端游戏的开发，使用基于H5的游戏框架开发页游，或者继续将自己的技术栈扩展至&lt;code&gt;cocos2d&lt;/code&gt;或是&lt;code&gt;unity&lt;/code&gt;这种更专业的框架引擎，甚至牛逼到自己开发高性能引擎，一切都取决于你自己的努力和意愿。&lt;/p&gt;
&lt;h3 id=&quot;转职-其他&quot;&gt;1.4 转职-其他&lt;/h3&gt;
&lt;p&gt;当然，在前端进步的过程中，你完全有可能最终成为&lt;strong&gt;后端工程师&lt;/strong&gt;，&lt;strong&gt;项目经理&lt;/strong&gt;，&lt;strong&gt;系统工程师&lt;/strong&gt;，&lt;strong&gt;算法工程师&lt;/strong&gt;等等不同的角色，又或者是进入了诸如&lt;code&gt;人工智能&lt;/code&gt;,&lt;code&gt;大数据分析&lt;/code&gt;,&lt;code&gt;虚拟现实&lt;/code&gt;,&lt;code&gt;增强现实&lt;/code&gt;等某个很热门的方向上继续着自己的探索和成长，但请永远记得，语言本身并不是你进入某个领域的阻碍，&lt;strong&gt;程序=数据结构+算法&lt;/strong&gt;，它并不受制于语言类别，不是只有&lt;code&gt;python&lt;/code&gt;才能搞人工智能，也不是只有&lt;code&gt;C++&lt;/code&gt;才能开发游戏，限制自己的，只有自己的意愿。&lt;/p&gt;
&lt;h2 id=&quot;二.-为什么你应该学习react&quot;&gt;二. 为什么你应该学习React&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;世界上最远的距离不是天堂到地狱，而是需求只有一行&quot;Hello World&quot;，我却搞了好几星期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;技术栈的延伸&quot;&gt;2.1 技术栈的延伸&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;React&lt;/code&gt;带来的不只是一个框架，更是一种新的前端工作流。&lt;/p&gt;
&lt;p&gt;你需要学习&lt;code&gt;ES6&lt;/code&gt;或更新的&lt;code&gt;javascript&lt;/code&gt;规范，才能搞明白&lt;code&gt;React&lt;/code&gt;中一大堆看起来很奇怪的语法；&lt;/p&gt;
&lt;p&gt;你需要学习使用&lt;code&gt;Babel&lt;/code&gt;，好让自己编写的&lt;code&gt;jsx&lt;/code&gt;代码和&lt;code&gt;ES6&lt;/code&gt;语法的代码最终被转译为浏览器能够识别的代码；&lt;/p&gt;
&lt;p&gt;你需要重新学习&lt;code&gt;javascript面向对象编程&lt;/code&gt;来理解组件的基本实现原理；&lt;/p&gt;
&lt;p&gt;你需要加深对&lt;code&gt;javascript基础知识&lt;/code&gt;的理解，才能更好地理解诸如&lt;code&gt;高阶组件&lt;/code&gt;等高级用法的妙处；&lt;/p&gt;
&lt;p&gt;你需要学习&lt;code&gt;Redux&lt;/code&gt;数据管理架构，来了解&lt;em&gt;单向数据流&lt;/em&gt;和&lt;em&gt;数据管理&lt;/em&gt;的思想和实现；&lt;/p&gt;
&lt;p&gt;你需要学习&lt;code&gt;Webpack&lt;/code&gt;，来管理整个前端工程的构建和资源；&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;一个月以后，你终于能够明白&lt;code&gt;React&lt;/code&gt;是如何一步一步在空白的页面上输出一句&quot;Hello World&quot;了。&lt;/p&gt;
&lt;h3 id=&quot;组件化开发&quot;&gt;2.2 组件化开发&lt;/h3&gt;
&lt;p&gt;组件化开发是现代前端开发的一大趋势，你需要在开发中仔细体会&lt;code&gt;React&lt;/code&gt;中组件的意义，如果组件设计的合理，&lt;strong&gt;那么你几乎永远不需要再去修改它&lt;/strong&gt;，而是可以通过&lt;code&gt;高阶组件&lt;/code&gt;等一系列可以互相转换的方式实现对原组件的功能扩展。这种思维的转变会让你在未来的开发中省去很多重复的工作。强制使用的&lt;code&gt;ES6&lt;/code&gt;语法，也可以为以后&lt;code&gt;Java&lt;/code&gt;的学习打好基础。&lt;/p&gt;
&lt;h3 id=&quot;思想的提升&quot;&gt;2.3 思想的提升&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;React&lt;/code&gt;的学习中，你会接触到非常多开发理念或是软件工程相关的思想，也会看到很多细节优化和框架设计方面的东西，对构建工具的使用也会让你逐步熟悉现代化前端开发的流程。这些东西都不是&lt;code&gt;React&lt;/code&gt;独有的，你完全可以将所学习到的编码技术，设计模式，框架知识等应用在其他项目中，另外，对新技术保持一定的敏感性也是一个优秀前端的必备素养。&lt;/p&gt;
&lt;h2 id=&quot;三.-没有实战项目我应该如何学习react&quot;&gt;三. 没有实战项目,我应该如何学习React&lt;/h2&gt;
&lt;p&gt;如果没有一个实战项目，很容易在做完Demo之后就不知所措，而下一次的面试中被问及相关问题时，你也只能心里没底地告诉面试官“了解过”。对于&lt;code&gt;React&lt;/code&gt;的学习，笔者的建议是：&lt;strong&gt;通过关键词来学习核心原理&lt;/strong&gt;（2.1节中提及的关键词应该优先学习）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词1——Virtual DOM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Virtual-DOM，即虚拟DOM树。浏览器在解析文件时，会将&lt;code&gt;html&lt;/code&gt;文档转换为&lt;code&gt;document&lt;/code&gt;对象，在浏览器环境中运行的脚本文件都可以获取到它，通过操作&lt;code&gt;document&lt;/code&gt;对象暴露的接口可以直接操作页面上的DOM节点。但是DOM操作是非常耗性能的，它会导致页面的重绘和重排。为了更好地处理DOM操作，提升项目性能，&lt;code&gt;Virtual-DOM&lt;/code&gt;技术就诞生了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Virtual-DOM&lt;/code&gt;技术是前端高性能的基石，它是真实&lt;code&gt;document&lt;/code&gt;对象的抽象，通过对比新旧&lt;code&gt;Virtual-DOM&lt;/code&gt;的区别，找出发生变化的DOM节点，再利用算法得到最优的DOM节点修改方案，最终再将方案应用在&lt;code&gt;document&lt;/code&gt;对象上来改变页面的展示内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词2——先序深度优先遍历&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是根据&lt;code&gt;Virtual-DOM&lt;/code&gt;来重现真实的DOM节点，还是当数据模型变化后来对比新旧树结构的差异，都需要通过&lt;strong&gt;先序-深度优先算法&lt;/strong&gt;来遍历虚拟DOM树，逐个对比节点信息，从而达到目的。你完全可以在自己实现了&lt;code&gt;Virtual-DOM&lt;/code&gt;以后，尝试将其转换为真实的DOM转换到页面上。同时，基础算法的学习是非常有趣的，如果感兴趣，你也可以尝试去对比深度优先遍历的&lt;strong&gt;递归方法&lt;/strong&gt;和&lt;strong&gt;栈方法&lt;/strong&gt;，去了解&lt;strong&gt;广度优先遍历&lt;/strong&gt;，它们并不难实现，通过DOM这种可见结构来帮助自己学习略显抽象的搜索算法是非常好的学习路径，因为你可以很直观地看到算法的每一步是如何运行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词3——DOM-Diff算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DOM-Diff&lt;/code&gt;算法，是指如何对比两棵虚拟DOM树之间的差异，并把这些差异转换为DOM节点真实变化的算法。&lt;code&gt;React&lt;/code&gt;做了一些能够明显降低算法时间复杂度的假定，让它变得高效。后文推荐的资料中有非常好的深度讲解的博文，其中将元素列表的变化抽象为求解字符串的最小编辑距离(Levenshtein Distance)的部分非常精彩，笔者在此强烈推荐。你可以只去模拟其中1-2中简单的差别类型，来实现一下&lt;code&gt;DOM-Diff&lt;/code&gt;算法，看看能否将虚拟DOM树中的差异同步到自己的页面上。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前端框架几乎都是由【&lt;code&gt;Virtual-DOM&lt;/code&gt;模型 + &lt;code&gt;DOM-Diff&lt;/code&gt;算法 + 生命周期钩子】这样的骨架模型来建立的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;关键词4——Redux架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Redux&lt;/code&gt;是状态管理架构范式&lt;code&gt;Flux&lt;/code&gt;的实现，它并不一定要和&lt;code&gt;React&lt;/code&gt;配合才能使用。直观地来看，状态管理的思想把代码中一个简单的赋值操作搞的异常复杂，你需要搞明白这种对于简洁性的牺牲到底换来的是什么，才能真正确定你是否需要使用&lt;code&gt;Redux&lt;/code&gt;。&lt;strong&gt;状态管理&lt;/strong&gt;和&lt;strong&gt;单向数据流&lt;/strong&gt;的思想以及框架中是如何跟踪状态的同步变更和异步变更是学习的重点。&lt;strong&gt;单向数据流&lt;/strong&gt;和&lt;strong&gt;双向数据绑定&lt;/strong&gt;并没有绝对的优劣之分，它们都有自己的适用场景，你应该在恰当的时候适用恰当的方式，而不是毫无根据地觉得某一个技术很牛逼。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词5——React-Router&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前端路由的基本原理并不复杂，你可以参考笔者的另一篇博文&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/fbf6c64575e711e89fc57ca23e93a89f&quot;&gt;《造轮子-前端路由的基本原理》&lt;/a&gt;去了解。你需要了解的关键点，是&lt;code&gt;React-Router&lt;/code&gt;如何实现按需加载，如何实现前端路由和服务端渲染的兼容，底层的原理是什么。如果能借研究路由的匹配策略好好夯实一下&lt;em&gt;正则表达式&lt;/em&gt;的相关知识那就更好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词6——×××(服务端渲染)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;×××&lt;/code&gt;并不是什么新鲜的技术，事实上在&lt;code&gt;Angularjs1.x&lt;/code&gt;将SPA模型带到人们面前时，前端网页本来就是后端通过模板引擎来渲染，然后把整个HTML结构返回给前端，前端只负责展示就可以了。&lt;code&gt;×××&lt;/code&gt;解决的问题，&lt;strong&gt;是为了解决SPA模型首屏渲染速度慢的问题&lt;/strong&gt;，因为相比于传统的服务端渲染而言，SPA模型在首次访问时需要加载更多的脚本文件，然后才会开始渲染，而脚本加载期间的白屏造成的用户体验是很差的。&lt;code&gt;×××&lt;/code&gt;技术的实质就是将首屏渲染工作转移到服务端以求获得更快的渲染速度的技术，当然如何优雅地使用还涉及很多细节的问题。你需要去了解&lt;code&gt;react-dom&lt;/code&gt;是如何在服务端实现DOM字符串渲染的，事实上它和其他后端的模板引擎并没有本质的区别。你完全可以在自己已经存在的&lt;code&gt;exprss&lt;/code&gt;或&lt;code&gt;KOA&lt;/code&gt;工程中手动实现页面的服务端渲染。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词7——ISOMorphic(同构)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不得不说这是一个逼格很高的概念，它是&lt;code&gt;×××&lt;/code&gt;的升级。同构，实际上就是指&lt;strong&gt;同一套代码既能够运行在浏览器，也能够运行在服务端&lt;/strong&gt;运行。为什么通过SPA模型实现的前端应用要运行在服务端？答案是&lt;strong&gt;给搜索引擎看&lt;/strong&gt;。由于爬虫只爬取静态页面的特点，依赖于&lt;code&gt;ajax&lt;/code&gt;的SPA模型在搜索引擎优化方面有着天然的劣势。我们在浏览器中看到的丰富的内容，在爬虫看来可能只是一堆空白的标签或是没有意义的内容。大型框架均提供了完整的解决方案（&lt;code&gt;Angular&lt;/code&gt;有&lt;code&gt;Angular-Universal&lt;/code&gt;,&lt;code&gt;Vue&lt;/code&gt;有&lt;code&gt;Nuxt.js&lt;/code&gt;，&lt;code&gt;React&lt;/code&gt;有&lt;code&gt;Next.js&lt;/code&gt;）好让你在使用对应的技术栈时更好地实现同构，你可以挑选其中之一来进行简单学习，加深对同构的直观理解。如果有SEO相关的需求，直接去学习使用就好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些关键词并不代表&lt;code&gt;React&lt;/code&gt;的全部精华，但已足够让你为一个真正的&lt;code&gt;React&lt;/code&gt;项目做好准备，甚至你会发现自己对于React的理解，比很多经历过实战项目的开发者还要深刻。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四.-资料推荐&quot;&gt;四. 资料推荐&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;React&lt;/code&gt;全家桶是非常庞大的，笔者自己在学习中阅读到了很多非常优秀的资料，觉得并没有必要再重复去写相关博文，在此将一些必要的或是优质的资源推荐给想要学习的读者们，愿你们在&lt;code&gt;React&lt;/code&gt;学习中获得进步。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/&quot;&gt;1. 阮一峰的ES6教程 http://es6.ruanyifeng.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个推荐可能有点多余，你在网上能找到的许多&lt;code&gt;ES6&lt;/code&gt;的资料都是它的复制版。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.react-china.org/&quot;&gt;2. React中文网 https://doc.react-china.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阅读官方文档是第一步，文档中的【高级】部分似乎在手机上无法显示，需要在PC端阅读。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://reacttraining.com/react-router&quot;&gt;3. React-Router路由文档 https://reacttraining.com/react-router&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从最基本的用法到按需加载和服务端渲染，全部都有对应实例，非常走心的官方文档。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://huziketang.mangojuice.top/books/react&quot;&gt;4. React小书 http://huziketang.mangojuice.top/books/react&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果除官方文档以外，你只有时间读一本书，那便是这本了。开源的45篇博文，通过&lt;strong&gt;问题 + 推演 + 实例&lt;/strong&gt;的方式让你了解&lt;code&gt;React&lt;/code&gt;中每个部分存在的必要性和程序设计的考虑点，无疑是笔者读过的资料里最好的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/livoras/blog/issues/13&quot;&gt;5. 深度解析Virtual-Dom的实现算法 https://github.com/livoras/blog/issues/13&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;讲述Virtual-DOM的非常棒的一篇博文，值得一读，毕竟Virtual-DOM是前端框架的基础。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/camsong/redux-in-chinese&quot;&gt;6. Redux中文文档 https://github.com/camsong/redux-in-chinese&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来自github的文档资源，提供各种格式的电子书。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/KyrieChen/redux-chinese-comment&quot;&gt;7. Redux带中文注释源码https://github.com/KyrieChen/redux-chinese-comment&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;redux的代码并不多，理解了思想和使用方法后，从源代码的编写也能够学习到很多宝贵的经验。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mooc.com/&quot;&gt;8. 慕课网关于React的课程 http://www.mooc.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;慕课网有非常多高质量的&lt;code&gt;React入门课程&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;送个&lt;strong&gt;【彩蛋】&lt;/strong&gt;给阅读到最后的你~~&lt;/p&gt;
&lt;blockquote readability=&quot;7.7127071823204&quot;&gt;
&lt;p&gt;全球最大的同×××友网站&lt;code&gt;github&lt;/code&gt;上，有一个非常棒的&lt;code&gt;awesome&lt;/code&gt;系列的项目，几乎每一个你用到的技术栈，都对应着这样一个导航类的开源项目(例如&lt;a href=&quot;https://github.com/enaqx/awesome-react&quot;&gt;awesome-react&lt;/a&gt;)，其中收录了包含&lt;strong&gt;基础教程&lt;/strong&gt;，&lt;strong&gt;视频教程&lt;/strong&gt;，&lt;strong&gt;插件生态&lt;/strong&gt;，&lt;strong&gt;高级技术&lt;/strong&gt;，&lt;strong&gt;源码解读&lt;/strong&gt;等非常非常多资源的地址，其他的就不用我多说喽~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 16 Sep 2018 03:21:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>首发链接：https://bbs.huaweicloud.com/blogs/70f69ca4953111e89fc57ca23e93a89f 《一统江湖的大前端》系列是自己的前端学习笔记，旨在介绍j</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9632496.html</dc:identifier>
</item>
<item>
<title>十三、智能指针二 - 小胖鼠</title>
<link>http://www.cnblogs.com/chenke1731/p/9655618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenke1731/p/9655618.html</guid>
<description>&lt;h3 id=&quot;smartpointer智能指针重构&quot;&gt;1、&lt;code&gt;SmartPointer&lt;/code&gt;智能指针重构&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需求：使用智能指针&lt;code&gt;SmartPointer&lt;/code&gt;替换单链表&lt;code&gt;LinkList&lt;/code&gt;中的原生指针&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将原生指针更改为智能指针后，解决全部的编译问题，程序还是会出错，问题在于：&lt;code&gt;SmartPointer&lt;/code&gt;的设计方案存在的一些特性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指针的生命周期结束时主动释放堆空间&lt;/li&gt;
&lt;li&gt;一片堆空间最多只能有一个指针标识&lt;/li&gt;
&lt;li&gt;不允许指针运算和指针比较&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需求：创建新的指针指针&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372866/201809/1372866-20180916111950493-1916775622.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pointer&lt;/code&gt;是智能指针的抽象父类（模板）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;纯虚析构函数&lt;code&gt;virtual ~Pointer() = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重载&lt;code&gt;operator -&amp;gt;()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重载&lt;code&gt;operator* ()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;智能指针新的设计方案&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
class Pointer : public Object
{
protected:
    T* m_pointer;
public:
    Pointer(T* p = NULL)
    {
        m_pointer = p;
    }
    T* operator-&amp;gt; ()
    {
        return m_pointer;
    }
    T&amp;amp; operator* ()
    {
        return *m_pointer;
    }
    bool inNull()
    {
        return (m_pointer == NULL);
    }
    T* get()
    {
        return m_pointer;
    }
    // 只要没有实现一个具体的析构函数，Pointer继承于Object，就是一个抽象类
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;SmartPointer&lt;/code&gt;，继承于&lt;code&gt;Pointer&lt;/code&gt;类&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#ifndef SMARTPOINTER_H
#define SMARTPOINTER_H

#include &quot;Pointer.h&quot;

namespace DTLib
{

// 构建一个智能指针模板类
template&amp;lt;typename T&amp;gt;
class SmartPointer : public Pointer&amp;lt;T&amp;gt;
{
public:
    // 构造函数，初始化传参为堆空间地址

    SmartPointer(T* p = NULL) : Pointer&amp;lt;T&amp;gt;(p)   // 调用父类的构造函数的形式
    {
        // 构造函数调用父类的构造函数
    }

    // 拷贝构造函数
    SmartPointer(const SmartPointer&amp;lt;T&amp;gt;&amp;amp; obj)
    {
        this-&amp;gt;m_pointer = obj.m_pointer;
        const_cast&amp;lt;SmartPointer&amp;lt;T&amp;gt;&amp;amp;&amp;gt;(obj).m_pointer = NULL;
        //
    }

    SmartPointer&amp;lt;T&amp;gt;&amp;amp; operator = (const SmartPointer&amp;lt;T&amp;gt;&amp;amp; obj)
    {
        if(this != &amp;amp;obj)
        {
            // 释放掉原来指向的那个堆空间
            // 如果先删除m_pointer指向的堆空间，就有可能导致异常抛出
            // 要保证异常安全性
            // delete m_pointer;
            // 指向新的堆空间
            // m_pointer = obj.m_pointer;
            // 删除obj对象中m_pointer与这个堆空间的关联，保证一个堆空间只有一个指针指向这个堆空间
            // const_cast&amp;lt;SmartPointer&amp;lt;T&amp;gt;&amp;amp;&amp;gt;(obj).m_pointer = NULL;
           
            // 为了异常安全性，用一个临时变量保存this-&amp;gt;pointer指针，方便释放
            T* p = this-&amp;gt;m_pointer;
            this-&amp;gt;m_pointer = obj.m_pointer;
            const_cast&amp;lt;SmartPointer&amp;lt;T&amp;gt;&amp;amp;&amp;gt;(obj).m_pointer = NULL;
            delete p;
        }
        return *this;
    }

    // 析构函数需要冲重写，否则就还是一个抽象类
    ~SmartPointer()
    {
        delete this-&amp;gt;m_pointer;
    }
};

}

#endif // SMARTPOINTER_H&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sharedpointer智能指针&quot;&gt;2、&lt;code&gt;SharedPointer&lt;/code&gt;智能指针&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需求：多个智能指针指向同一片堆空间，并且这些指针支持自动释放&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;SharedPointer&lt;/code&gt;设计要点：类模板&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过计数机制&lt;code&gt;ref&lt;/code&gt;标识堆内存&lt;/li&gt;
&lt;li&gt;堆内存被指向时：&lt;code&gt;ref++&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指针被置空时：&lt;code&gt;ref--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ref == 0&lt;/code&gt;时：释放堆内存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;计数机制原理剖析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1372866/201809/1372866-20180916112007359-2140342834.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3个指针同时指向了堆空间中的统一对象，与对象相关联的计数标识应该是3。如果将&lt;code&gt;shared_pointer_3&lt;/code&gt;置空，应该计数减一，计数变量为2；如果全部置空，计数变量为0，意味着最后一个智能指针要将堆空间里面的对象销毁掉，将堆空间的内存释放。&lt;/p&gt;
&lt;p&gt;虚线矩形框将对象和计数变量框在了一起，意味着每一个堆空间中的对象都和这个计数变量相关联，这个计数变量也位于堆空间里面。在具体实现上计数变量也是在堆空间里面创建的，并且计数变量的生命周期和这个对象的生命周期是完全一致的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SharedPointer&lt;/code&gt;类的声明&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
class SharedPointer : public Pointer&amp;lt;T&amp;gt;
{
protected:
    int* m_ref; // 计数机制成员指针
    // 成员指针指向堆空间里面创建的计数变量
public:
    SharedPointer(T* p = NULL);
    SharedPointer(const SharedPointer&amp;lt;T&amp;gt;&amp;amp; obj);
    
    SharedPointer&amp;lt;T&amp;gt;&amp;amp; operator = (const SharedPointer&amp;lt;T&amp;gt;&amp;amp; obj);

    void clear();   // 当前指针置空

    ~SharedPointer();
    
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于&lt;code&gt;SharedPointer&lt;/code&gt;支持多个对象同时指向一片堆空间，因此必须支持比较操作，使智能指针最大限度上接近原生指针的逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// SharedPointer.h
#ifndef SHAREDPOINTER_H
#define SHAREDPOINTER_H

#include &amp;lt;cstdlib&amp;gt;
#include &quot;Exception.h&quot;
#include &quot;Pointer.h&quot;

namespace DTLib
{
template &amp;lt;typename T&amp;gt;
class SharedPointer : public Pointer&amp;lt;T&amp;gt;
{
protected:
    int* m_ref; // 计数机制成员指针

    // 进行函数封装
    void assign(const SharedPointer&amp;lt;T&amp;gt;&amp;amp; obj)
    {
        this-&amp;gt;m_ref = obj.m_ref;            // 将当前指针对象的ref成员指针指向了对应的计数对象
        this-&amp;gt;m_pointer = obj.m_pointer;    // m_pointer指向对应的堆内存
        // 还不够，注意计数机制，计数变量需要+1
        if (this-&amp;gt;m_ref)
        {// 计数变量合法
            (*this-&amp;gt;m_ref)++;
        }
    }

public:
    // 首先是构造函数对成员变量初始化
    SharedPointer(T* p = NULL) : m_ref(NULL)    // 将指向计数变量的成员指针，初始化为空
    {
        if (p)
        {
            // 首先在堆空间中创建一个计数变量
            // 在堆空间中申请4个字节空间作为存放计数变量的内存空间
            this-&amp;gt;m_ref = static_cast&amp;lt;int*&amp;gt;(std::malloc(sizeof(int)));  // malloc返回类型是void*
            // 判断申请是否成功
            if (this-&amp;gt;m_ref)
            {
                *(this-&amp;gt;m_ref) = 1;     // 意味着参数指针p指向的堆空间已经有了一个SharedPointer智能指针对象来指向了
                this-&amp;gt;m_pointer = p;    // 将成员指针变量指向参数p对应的堆空间
            }
            else
            {// malloc不成功，意味着内存不够用，抛异常
                THROW_EXCEPTION(NoEnoughMemoryException, &quot;No memory to creat SharedPointer object...&quot;);
            }
        }
    }

    SharedPointer(const SharedPointer&amp;lt;T&amp;gt;&amp;amp; obj)
    {
        //this-&amp;gt;m_ref = obj.m_ref;          // 将当前指针对象的ref成员指针指向了对应的计数对象
        //this-&amp;gt;m_pointer = obj.m_pointer;  // m_pointer指向对应的堆内存
        //// 还不够，注意计数机制，计数变量需要+1
        //if (this-&amp;gt;m_ref)
        //{// 计数变量合法
        //  (*this-&amp;gt;m_ref)++;
        //}
        assign(obj);
    }

    // 赋值操作符重载函数
    SharedPointer&amp;lt;T&amp;gt;&amp;amp; operator = (const SharedPointer&amp;lt;T&amp;gt;&amp;amp; obj)
    {
        if (this != &amp;amp;obj)
        {// 避免自赋值
            // 逻辑与拷贝构造类似，但是需要做清空操作
            // 当前的SharedPointer对象已经指向了另一片堆空间了，在做赋值操作前，应该将当前的智能指针对象置空，不再指向任何堆空间
            // 在赋值之前，置空 clear()
            clear();

            //// 可以代码复用，封装内部函数
            //this-&amp;gt;m_ref = obj.m_ref;          
            //this-&amp;gt;m_pointer = obj.m_pointer;          
            //if (this-&amp;gt;m_ref)
            //{
            //  (*this-&amp;gt;m_ref)++;
            //}
            assign(obj);
        }

        return *this;
    }

    void clear()   // 当前指针置空
    {
        T* toDel = this-&amp;gt;m_pointer;
        int* ref = this-&amp;gt; m_ref;

        this-&amp;gt;m_pointer = NULL;
        this-&amp;gt;m_ref = NULL;

        if (ref)
        {// 当前计数变量合法
            (*ref)--;
            if (*ref == 0)
            {// 为0标识该堆空间已经没有任何智能指针对象去指向了，应该释放该堆空间
                free(ref);      // 释放计数变量
                delete toDel;   // 释放堆空间
            }
        }
    }

    ~SharedPointer()
    {
        clear();
    }

};

}

#endif // SHAREDPOINTER_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int main()
{
    SharedPointer&amp;lt;Test&amp;gt; sp0 = new Test();
    SharedPointer&amp;lt;Test&amp;gt; sp1 = sp0;
    
    SharedPointer&amp;lt;Test&amp;gt; sp2 = NULL;

    sp2 = sp1;
    sp2-&amp;gt;value = 100;
    cout &amp;lt;&amp;lt; sp0-&amp;gt;value &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; sp1-&amp;gt;value &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; sp2-&amp;gt;value &amp;lt;&amp;lt; endl;

    cout &amp;lt;&amp;lt; (sp0 == sp2) &amp;lt;&amp;lt; endl;

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;Test()&lt;br/&gt;100&lt;br/&gt;100&lt;br/&gt;100&lt;br/&gt;0&lt;br/&gt;~Test()&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sp0 sp1 sp2&lt;/code&gt;均指向了同一片堆空间，通过&lt;code&gt;sp2-&amp;gt;value&lt;/code&gt;更改值之后，和原生指针效果一样，但是进行指针比较的时候，需要重载比较操作符&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#ifndef SHAREDPOINTER_H
#define SHAREDPOINTER_H

#include &amp;lt;cstdlib&amp;gt;
#include &quot;Exception.h&quot;
#include &quot;Pointer.h&quot;


namespace DTLib
{
template &amp;lt;typename T&amp;gt;
class SharedPointer : public Pointer&amp;lt;T&amp;gt;
{
...
};

// 在全局区重载比较操作符
template &amp;lt;typename T&amp;gt;
bool operator == (const SharedPointer&amp;lt;T&amp;gt;&amp;amp; l, const SharedPointer&amp;lt;T&amp;gt;&amp;amp; r)
{
    return (l.get() == r.get());
    // get()函数不是const成员函数，所以不能被const对象调用
}

template &amp;lt;typename T&amp;gt;
bool operator != (const SharedPointer&amp;lt;T&amp;gt;&amp;amp; l, const SharedPointer&amp;lt;T&amp;gt;&amp;amp; r)
{
    return !(l == r);   // !=操作符重载的实现用上面==操作的实现就可以了
}

}
#endif // SHAREDPOINTER_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;智能指针的使用规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只能用来指向堆空间中的某个变量（对象）&lt;/li&gt;
&lt;li&gt;不同类型的智能指针对象不能混合使用&lt;/li&gt;
&lt;li&gt;不用使用&lt;code&gt;delete&lt;/code&gt;释放智能指针指向的堆空间&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;小结&quot;&gt;3、小结&lt;/h3&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;code&gt;SharedPointer&lt;/code&gt;最大程度地模拟了原生指针的行为&lt;/p&gt;
&lt;p&gt;计数机制确保多个智能指针合法地指向同一片堆空间&lt;/p&gt;
&lt;p&gt;智能指针只能用于指向堆空间中的内存&lt;/p&gt;
&lt;p&gt;不同类型的智能指针不要混合使用&lt;/p&gt;
&lt;p&gt;堆对象的生命周期由智能指针进行管理&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 16 Sep 2018 03:19:00 +0000</pubDate>
<dc:creator>小胖鼠</dc:creator>
<og:description>1、 智能指针重构 需求：使用智能指针 替换单链表 中的原生指针 将原生指针更改为智能指针后，解决全部的编译问题，程序还是会出错，问题在于： 的设计方案存在的一些特性 指针的生命周期结束时主动释放堆空</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenke1731/p/9655618.html</dc:identifier>
</item>
<item>
<title>踩过无数坑实现的哈夫曼压缩（JAVA） - iTryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/9655573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/9655573.html</guid>
<description>&lt;p&gt;最近可能又是闲着没事干了，就想做点东西，想着还没用JAVA弄过数据结构，之前搞过算法，就试着写写哈夫曼压缩了。&lt;/p&gt;
&lt;p&gt;本以为半天就能写出来，结果，踩了无数坑，花了整整两天时间！！orz。。。不过这次踩坑，算是又了解了不少东西，更觉得在开发中学习是最快的了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;话不多说，进入正题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;首先先来讲讲哈夫曼树&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;哈夫曼树属于二叉树，即树的结点最多拥有2个孩子结点。若该二叉树带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，&lt;span&gt;权值较大的结点离根较近。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201809/1413964-20180916100857334-445422994.jpg&quot; alt=&quot;&quot; width=&quot;519&quot; height=&quot;240&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;哈夫曼树的构造&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：&lt;/p&gt;
&lt;p&gt;(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；&lt;/p&gt;
&lt;p&gt;(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；&lt;/p&gt;
&lt;p&gt;(3)从森林中删除选取的两棵树，并将新树加入森林；&lt;/p&gt;
&lt;p&gt;(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201809/1413964-20180916101856001-1146059781.jpg&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;429&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;哈夫曼编码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“HELLO WORLD”，这里用到的字符集为“D,E,H,L,O,R,W”，各字母出现的次数为{1,1,1,3,2,1,1}。现要求为这些字母设计编码。要区别7个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101、110对“D,E,H,L,O,R,W”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。若报文中可能出现26个不同字符，则固定编码长度为5。然而，传送报文时总是希望总长度尽可能短。在实际应用中，各个字符的出现频度或使用次数是不相同的，如A、B、C的使用频率远远高于X、Y、Z，自然会想到设计编码时，&lt;strong&gt;让使用频率高的用短编码，使用频率低的用长编码&lt;/strong&gt;，以优化整个报文编码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201809/1413964-20180916103511550-937068684.jpg&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;314&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时D-&amp;gt;0000 E-&amp;gt;0001 W-&amp;gt;001 H-&amp;gt;110 R-&amp;gt;111 L-&amp;gt;01 0-&amp;gt;02&lt;/p&gt;
&lt;p&gt;固定三位时编码长度为30，而时候哈夫曼编码后，编码长度为27，很明显长度缩小了，得到优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;下面就是代码实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; HuffmanCompress.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package 哈夫曼;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.PriorityQueue;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HuffmanCompress {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; PriorityQueue&amp;lt;HufTree&amp;gt; queue = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; compress(File inputFile, File outputFile) {
        Compare cmp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Compare();
        queue &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PriorityQueue&amp;lt;HufTree&amp;gt;(&lt;span&gt;12&lt;/span&gt;&lt;span&gt;, cmp);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 映射字节及其对应的哈夫曼编码&lt;/span&gt;
        HashMap&amp;lt;Byte, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Byte, String&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i, char_kinds = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; char_tmp, file_len = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        FileInputStream fis &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        FileOutputStream fos &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        DataOutputStream oos &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        HufTree root &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HufTree();
        String code_buf &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 临时储存字符频度的数组&lt;/span&gt;
        TmpNode[] tmp_nodes = &lt;span&gt;new&lt;/span&gt; TmpNode[&lt;span&gt;256&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;256&lt;/span&gt;; i++&lt;span&gt;) {
            tmp_nodes[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TmpNode();
            tmp_nodes[i].weight &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            tmp_nodes[i].Byte &lt;/span&gt;= (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) i;
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            fis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(inputFile);
            fos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(outputFile);
            oos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataOutputStream(fos);

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * 统计字符频度，计算文件长度
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; ((char_tmp = fis.read()) != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                tmp_nodes[char_tmp].weight&lt;/span&gt;++&lt;span&gt;;
                file_len&lt;/span&gt;++&lt;span&gt;;
            }
            fis.close();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 排序，将频度为0的字节放在最后，同时计算除字节的种类，即有多少个不同的字节&lt;/span&gt;
&lt;span&gt;            Arrays.sort(tmp_nodes);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;256&lt;/span&gt;; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tmp_nodes[i].weight == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                HufTree tmp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HufTree();
                tmp.Byte &lt;/span&gt;=&lt;span&gt; tmp_nodes[i].Byte;
                tmp.weight &lt;/span&gt;=&lt;span&gt; tmp_nodes[i].weight;
                queue.add(tmp);
            }
            char_kinds &lt;/span&gt;=&lt;span&gt; i;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (char_kinds == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                oos.writeInt(char_kinds);
                oos.writeByte(tmp_nodes[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Byte);
                oos.writeInt(tmp_nodes[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].weight);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建树&lt;/span&gt;
&lt;span&gt;                createTree(queue);
                root &lt;/span&gt;=&lt;span&gt; queue.peek();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成哈夫曼编码&lt;/span&gt;
                hufCode(root, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;, map);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写入字节种类&lt;/span&gt;
&lt;span&gt;                oos.writeInt(char_kinds);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; char_kinds; i++&lt;span&gt;) {
                    oos.writeByte(tmp_nodes[i].Byte);
                    oos.writeInt(tmp_nodes[i].weight);
                }
                oos.writeInt(file_len);
                fis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(inputFile);
                code_buf &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((char_tmp = fis.read()) != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                    code_buf &lt;/span&gt;+= map.&lt;span&gt;get&lt;/span&gt;((&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) char_tmp);
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (code_buf.length() &amp;gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;) {
                        char_tmp &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;8&lt;/span&gt;; i++&lt;span&gt;) {
                            char_tmp &lt;/span&gt;&amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (code_buf.charAt(i) == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                                char_tmp &lt;/span&gt;|= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                        }
                        oos.writeByte((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) char_tmp);
                        code_buf &lt;/span&gt;= code_buf.substring(&lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最后编码长度不够8位的时候，用0补齐&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (code_buf.length() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                    char_tmp &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; code_buf.length(); ++&lt;span&gt;i) {
                        char_tmp &lt;/span&gt;&amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (code_buf.charAt(i) == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                            char_tmp &lt;/span&gt;|= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                    }
                    char_tmp &lt;/span&gt;&amp;lt;&amp;lt;= (&lt;span&gt;8&lt;/span&gt; -&lt;span&gt; code_buf.length());
                    oos.writeByte((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) char_tmp);
                }
                oos.close();
                fis.close();
            }

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; extract(File inputFile, File outputFile) {
        Compare cmp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Compare();
        queue &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PriorityQueue&amp;lt;HufTree&amp;gt;(&lt;span&gt;12&lt;/span&gt;&lt;span&gt;, cmp);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; file_len = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; writen_len = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        FileInputStream fis &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        FileOutputStream fos &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        DataInputStream ois &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; char_kinds = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        HufTree root&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HufTree();
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; code_tmp;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            fis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(inputFile);
            ois &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataInputStream(fis);
            fos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(outputFile);

            char_kinds &lt;/span&gt;=&lt;span&gt; ois.readInt();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字节只有一种&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (char_kinds == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                code_tmp &lt;/span&gt;=&lt;span&gt; ois.readByte();
                file_len &lt;/span&gt;=&lt;span&gt; ois.readInt();
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((file_len--) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                    fos.write(code_tmp);
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; char_kinds; i++&lt;span&gt;) {
                    HufTree tmp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HufTree();
                    tmp.Byte &lt;/span&gt;=&lt;span&gt; ois.readByte();
                    tmp.weight &lt;/span&gt;=&lt;span&gt; ois.readInt();
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Byte: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+tmp.Byte+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; weight: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;tmp.weight);
                    queue.add(tmp);
                }

                createTree(queue);

                file_len &lt;/span&gt;=&lt;span&gt; ois.readInt();
                root &lt;/span&gt;=&lt;span&gt; queue.peek();
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                    code_tmp &lt;/span&gt;=&lt;span&gt; ois.readByte();
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;8&lt;/span&gt;; i++&lt;span&gt;) {&lt;br/&gt;　　　　　　　　　　　　　　//这里为什么是&amp;amp;128呢？&lt;br/&gt;　　　　　　　　　　　　　　//我们是按编码顺序走的，1向右，0向左，对于一串byte编码有8位，那最高位就是2^7，就是128&lt;br/&gt;　　　　　　　　　　　　　　//所以通过位运算来判断该位是0还是1&lt;br/&gt;　　　　　　　　　　　　　　//之前我想错了，从后面开始走，结果乱码，压缩在这块也卡了好久orz&lt;br/&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((code_tmp&amp;amp;&lt;span&gt;128&lt;/span&gt;)==&lt;span&gt;128&lt;/span&gt;&lt;span&gt;) {
                            root &lt;/span&gt;=&lt;span&gt; root.rchild;
                        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            root &lt;/span&gt;=&lt;span&gt; root.lchild;
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root.lchild == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.rchild == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            fos.write(root.Byte);
                            &lt;/span&gt;++&lt;span&gt;writen_len;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (writen_len ==&lt;span&gt; file_len)
                                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            root &lt;/span&gt;=&lt;span&gt; queue.peek();
                        }
                        code_tmp &lt;/span&gt;&amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (writen_len ==&lt;span&gt; file_len)
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
            fis.close();
            fos.close();

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; createTree(PriorityQueue&amp;lt;HufTree&amp;gt;&lt;span&gt; queue) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (queue.size() &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            HufTree min1 &lt;/span&gt;=&lt;span&gt; queue.poll();
            HufTree min2 &lt;/span&gt;=&lt;span&gt; queue.poll();
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(min1.weight + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; + min2.weight + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            HufTree NodeParent &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HufTree();
            NodeParent.weight &lt;/span&gt;= min1.weight +&lt;span&gt; min2.weight;
            NodeParent.lchild &lt;/span&gt;=&lt;span&gt; min1;
            NodeParent.rchild &lt;/span&gt;=&lt;span&gt; min2;

            queue.add(NodeParent);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; hufCode(HufTree root, String s, HashMap&amp;lt;Byte, String&amp;gt;&lt;span&gt; map) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root.lchild == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; root.rchild == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            root.code &lt;/span&gt;=&lt;span&gt; s;
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;节点&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + root.Byte + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;编码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; s);
            map.put(root.Byte, root.code);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root.lchild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            hufCode(root.lchild, s &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, map);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root.rchild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            hufCode(root.rchild, s &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, map);
        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Compare.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package 哈夫曼;

import java.util.Comparator;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Compare implements Comparator&amp;lt;HufTree&amp;gt;&lt;span&gt;{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(HufTree o1, HufTree o2) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(o1.weight &amp;lt;&lt;span&gt; o2.weight)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(o1.weight &amp;gt;&lt;span&gt; o2.weight)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里涉及到JAVA中优先对列的重载排序，我之前一直按照C++中的重载来写，结果发现发现压缩后的大小是原文件的3倍！！！！然后还一直以为是压缩过程的问题，疯狂看压缩过程哪里错了，最后输出了下各字符的编码才发现问题，耗了我整整一天TAT。。附上一个对优先队列重载讲解的链接&lt;a href=&quot;https://blog.csdn.net/u013066244/article/details/78997869&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u013066244/article/details/78997869&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HufTree.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package 哈夫曼;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HufTree{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; Byte; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以8位为单元的字节&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; weight;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该字节在文件中出现的次数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; String code; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应的哈夫曼编码&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HufTree lchild,rchild;

   
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计字符频度的临时节点&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; TmpNode implements Comparable&amp;lt;TmpNode&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; Byte;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; weight;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(TmpNode arg0) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.weight &amp;lt;&lt;span&gt; arg0.weight)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.weight &amp;gt;&lt;span&gt; arg0.weight)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;test.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package 哈夫曼;

import java.io.File;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        HuffmanCompress sample = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HuffmanCompress();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    File inputFile = new File(&quot;C:\\Users\\long452a\\Desktop\\opencv链接文档.txt&quot;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   File outputFile = new File(&quot;C:\\Users\\long452a\\Desktop\\opencv链接文档.rar&quot;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    sample.compress(inputFile, outputFile);&lt;/span&gt;
        File inputFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\long452a\\Desktop\\opencv链接文档.rar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            File outputFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\long452a\\Desktop\\opencv链接文档1.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
           sample.extract(inputFile, outputFile);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 16 Sep 2018 03:09:00 +0000</pubDate>
<dc:creator>iTryagain</dc:creator>
<og:description>最近可能又是闲着没事干了，就想做点东西，想着还没用JAVA弄过数据结构，之前搞过算法，就试着写写哈夫曼压缩了。 本以为半天就能写出来，结果，踩了无数坑，花了整整两天时间！！orz。。。不过这次踩坑，算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/csu-lmw/p/9655573.html</dc:identifier>
</item>
</channel>
</rss>