<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用 label 控制 Pod 的位置 - 每天5分钟玩转 Docker 容器技术（128） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8440366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8440366.html</guid>
<description>&lt;p&gt;&lt;span&gt;默认配置下，Scheduler 会将 Pod 调度到所有可用的 Node。不过有些情况我们希望将 Pod 部署到指定的 Node，比如将有大量磁盘 I/O 的 Pod 部署到配置了 SSD 的 Node；或者 Pod 需要 GPU，需要运行在配置了 GPU 的节点上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kubernetes 是通过 label 来实现这个功能的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;label 是 key-value 对，各种资源都可以设置 label，灵活添加各种自定义属性。比如执行如下命令标注 k8s-node1 是配置了 SSD 的节点。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl label node k8s-node1 disktype=ssd&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl get node --show-labels&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看节点的 label。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180211055801373-170955724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;disktype=ssd&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 已经成功添加到 k8s-node1，除了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;disktype&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，Node 还有几个 Kubernetes 自己维护的 label。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;disktype&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这个自定义 label，接下来就可以指定将 Pod 部署到 k8s-node1。编辑 nginx.yml：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180211055815560-644365191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在 Pod 模板的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;spec&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 里通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nodeSelector&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定将此 Pod 部署到具有 label &lt;/span&gt;&lt;code&gt;&lt;span&gt;disktype=ssd&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 Node 上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;部署 Deployment 并查看 Pod 的运行节点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180211055831920-908511137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全部 6 个副本都运行在 k8s-node1 上，符合我们的预期。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;要删除 label &lt;/span&gt;&lt;code&gt;&lt;span&gt;disktype&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，执行如下命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl label node k8s-node1 disktype-&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; -&lt;/span&gt; 即删除。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180211055844748-181679813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过此时 Pod 并不会重新部署，依然在 k8s-node1 上运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180211055857716-744053648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;除非在 nginx.yml 中删除 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nodeSelector&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设置，然后通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 重新部署。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180211055910529-1637831181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kubernetes 会删除之前的 Pod 并调度和运行新的 Pod。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Deployment 相关操作就讨论到这里，下一节我们学习 DaemonSet。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 21:39:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8440366.html</dc:identifier>
</item>
<item>
<title>【视频编解码·学习笔记】6. H.264码流分析工程创建 - Simon_Ace</title>
<link>http://www.cnblogs.com/shuofxz/p/8443392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuofxz/p/8443392.html</guid>
<description>&lt;h3 id=&quot;一准备工作&quot;&gt;一、准备工作：&lt;/h3&gt;
&lt;p&gt;新建一个VS工程&lt;strong&gt;SimpleH264Analyzer&lt;/strong&gt;， 修改工程属性参数-&amp;gt; 输出目录：&lt;code&gt;$(SolutionDir)bin\$(Configuration)\&lt;/code&gt;，工作目录：&lt;code&gt;$(SolutionDir)bin\$(Configuration)\&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译一下工程，工程目录下会生成&lt;code&gt;bin&lt;/code&gt;文件夹，其中的debug文件夹中有刚才编译生成的exe文件。将一个.264视频文件拷贝到这个文件夹中（本次使用的仍是&lt;a href=&quot;http://www.cnblogs.com/shuofxz/p/8375837.html&quot;&gt;学习笔记3&lt;/a&gt;中生成的.264文件）。&lt;/p&gt;
&lt;p&gt;将这个文件作为输入参数传到工程中：属性 -&amp;gt; 调试 -&amp;gt; 命令参数：test.264 （最后那个文件名根据自己的改）&lt;/p&gt;
&lt;p&gt;更改目录结构，并新建两个文件&lt;code&gt;Stream.h&lt;/code&gt; &lt;code&gt;Stream.cpp&lt;/code&gt;，更改后目录结构如下：&lt;br/&gt;&lt;img src=&quot;http://ouei1rgxt.bkt.clouddn.com/18-2-4/90330678.jpg?imageMogr2/thumbnail/300x&quot; alt=&quot;1 目录结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Stream.h&lt;/code&gt;头文件中，新建一个类&lt;strong&gt;CStreamFile&lt;/strong&gt;，用来表示&lt;strong&gt;.264&lt;/strong&gt;文件，其中包括构造函数、私有成员变量，及自定义函数。代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#ifndef _STREAM_H_&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define _STREAM_H_&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CStreamFile
{
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    CStreamFile(TCHAR *fileName);
    ~CStreamFile();
    &lt;span class=&quot;co&quot;&gt;// Open API&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; Parse_h264_bitstream();

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt;:
    FILE *m_InputFile;
    TCHAR *m_fileName;
    std::vector&amp;lt;uint8&amp;gt; m_nalVec;
    
    &lt;span class=&quot;co&quot;&gt;// 用来打印日志&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; file_info();
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; file_error(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dex);
    &lt;span class=&quot;co&quot;&gt;// 提取NAL有效数据&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; find_nal_prefix();
};

&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Stream.cpp文件中，实现其构造方法及成员函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &quot;stdafx.h&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &quot;Stream.h&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;namespace&lt;/span&gt; std;

&lt;span class=&quot;co&quot;&gt;// 构造函数完成打开文件操作&lt;/span&gt;
CStreamFile::CStreamFile(TCHAR * fileName)
{
    m_fileName = fileName;
    file_info();
    &lt;span class=&quot;co&quot;&gt;// 打开视频文件（只读二进制）&lt;/span&gt;
    _tfopen_s(&amp;amp;m_InputFile, m_fileName, _T(&lt;span class=&quot;st&quot;&gt;&quot;rb&quot;&lt;/span&gt;));
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (NULL == m_InputFile)
    {
        file_error(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
    }
}

&lt;span class=&quot;co&quot;&gt;// 析构函数完成关闭文件操作&lt;/span&gt;
CStreamFile::~CStreamFile()
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (NULL != m_InputFile)
    {
        fclose(m_InputFile);
        m_InputFile = NULL;
    }
}

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CStreamFile::Parse_h264_bitstream()
{
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CStreamFile::find_nal_prefix()
{
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}

&lt;span class=&quot;co&quot;&gt;// 打印文件信息&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; CStreamFile::file_info()
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (m_fileName)
    {
        wcout &amp;lt;&amp;lt; &lt;span class=&quot;st&quot;&gt;L&quot;File name: &quot;&lt;/span&gt; &amp;lt;&amp;lt; m_fileName &amp;lt;&amp;lt; endl;
    }
}

&lt;span class=&quot;co&quot;&gt;// 打印错误信息&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; CStreamFile::file_error(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; idx)
{
    &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; (idx)
    {
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:
        wcout &amp;lt;&amp;lt; &lt;span class=&quot;st&quot;&gt;L&quot;Error: opening input file failed.&quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;
        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后在主函数中，编写打开文件代码，测试以上代码能否正常执行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &quot;stdafx.h&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &quot;Stream.h&quot;&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; _tmain(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, _TCHAR* argv[])
{
    CStreamFile h264stream(argv[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]);

    &lt;span class=&quot;co&quot;&gt;// 此函数作为最上层函数，执行所有功能（暂时还未写任何功能实现）&lt;/span&gt;
    h264stream.Parse_h264_bitstream();
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译执行后，在cmd窗口中，能够打印出文件名称，即为正确执行。&lt;/p&gt;
&lt;p&gt;接下来，设置一个全局的头文件，用来定义所有文件中都会用到的数据类型。&lt;br/&gt;在&lt;strong&gt;Application&lt;/strong&gt;目录下，新建&lt;code&gt;Global.h&lt;/code&gt;头文件，输入以下代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#ifndef _GLOBAL_H_&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define _GLOBAL_H_&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;  uint8;
&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;   uint32;

&lt;span class=&quot;ot&quot;&gt;#endif &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;// !_GLOBAL_H_&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;code&gt;stdafx.h&lt;/code&gt;文件中，引入刚才新建的头文件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &quot;Global.h&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;二提取nal-unit&quot;&gt;二、提取NAL Unit：&lt;/h3&gt;
&lt;h4 id=&quot;提取nal有效数据&quot;&gt;1. 提取NAL有效数据：&lt;/h4&gt;
&lt;p&gt;实现&lt;em&gt;find_nal_prefix()&lt;/em&gt;函数。实现方法与&lt;a href=&quot;http://www.cnblogs.com/shuofxz/p/8416222.html&quot;&gt;学习笔记4&lt;/a&gt;中代码基本相同，仅修改一些变量名称。（学习笔记4中有详细讲解，这里不再说明）。Stream.cpp文件中，函数实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CStreamFile::find_nal_prefix()
{
    uint8 prefix[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] = { &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; };
    uint8 fileByte;


    m_nalVec.clear();

    &lt;span class=&quot;co&quot;&gt;// 标记当前文件指针位置&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pos = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 标记查找的状态&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; getPrefix = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 读取三个字节&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; idx = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; idx &amp;lt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;; idx++)
    {
        prefix[idx] = getc(m_InputFile);
        &lt;span class=&quot;co&quot;&gt;// 每次读进来的字节 都放入vector中&lt;/span&gt;
        m_nalVec.push_back(prefix[idx]);
    }

    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (!feof(m_InputFile))
    {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((prefix[pos % &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; (prefix[(pos + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) % &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; (prefix[(pos + &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) % &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
        {
            &lt;span class=&quot;co&quot;&gt;// 0x 00 00 01 found&lt;/span&gt;
            getPrefix = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
            m_nalVec.pop_back();
            m_nalVec.pop_back();
            m_nalVec.pop_back();
            &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((prefix[pos % &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; (prefix[(pos + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) % &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; (prefix[(pos + &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) % &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;))
        {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; == getc(m_InputFile))
            {
                &lt;span class=&quot;co&quot;&gt;// 0x 00 00 00 01 found&lt;/span&gt;
                getPrefix = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
                m_nalVec.pop_back();
                m_nalVec.pop_back();
                m_nalVec.pop_back();
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            }
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
        {
            fileByte = getc(m_InputFile);
            prefix[(pos++) % &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] = fileByte;
            m_nalVec.push_back(fileByte);
        }
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; getPrefix;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改Stream.cpp中&lt;em&gt;Parse_h264_bitstream()&lt;/em&gt;函数，循环调用&lt;em&gt;find_nal_prefix()&lt;/em&gt;函数，不断获取起始码之间数据。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CStreamFile::Parse_h264_bitstream()
{
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ret = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    {
        ret = find_nal_prefix();
    } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (ret);

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对此文件编译、调试，查看以上所写代码是否有问题：&lt;br/&gt;第一次循环时，文件指针移动到第一个起始码后；第二次循环时，读取到两个起始码间的有效数据，通过调试可看到如下数据，与&lt;code&gt;test.264&lt;/code&gt;中第一组有效数据相同：&lt;br/&gt;&lt;img src=&quot;http://ouei1rgxt.bkt.clouddn.com/18-2-5/3927233.jpg?imageMogr2/thumbnail/600x&quot; alt=&quot;2 调试数据&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;提取nal-unit-类别&quot;&gt;2. 提取NAL Unit 类别：&lt;/h4&gt;
&lt;p&gt;① 首先提取每一个NAL Unit的类别，修改&lt;em&gt;Parse_h264_bitstream()&lt;/em&gt;函数如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CStreamFile::Parse_h264_bitstream()
{
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ret = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    {
        ret = find_nal_prefix();
        &lt;span class=&quot;co&quot;&gt;// 解析NAL UNIT&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 第一次执行循环的时候，m_nalVec为空，因此加个判断&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (m_nalVec.size())
        {
            &lt;span class=&quot;co&quot;&gt;// 识别NAL Unit类别&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// NAL Unit第一个字节为NAL Header，后面5位表示NAL Type（使用按位与运算，截取后面五位数据）&lt;/span&gt;
            uint8 nalType = m_nalVec[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] &amp;amp; &lt;span class=&quot;bn&quot;&gt;0x1F&lt;/span&gt;;
            wcout &amp;lt;&amp;lt; &lt;span class=&quot;st&quot;&gt;L&quot;NAL Unit Type: &quot;&lt;/span&gt; &amp;lt;&amp;lt; nalType &amp;lt;&amp;lt; endl;
        }
    } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (ret);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译运行后，结果如下：&lt;br/&gt;&lt;img src=&quot;http://ouei1rgxt.bkt.clouddn.com/18-2-5/51378171.jpg?imageMogr2/thumbnail/200x&quot; alt=&quot;3&quot;/&gt;&lt;br/&gt;其所对应的类型为（可从H.264官方文档，表7-1中查到）：&lt;br/&gt;&lt;img src=&quot;http://ouei1rgxt.bkt.clouddn.com/18-2-5/29222958.jpg?imageMogr2/thumbnail/500x&quot; alt=&quot;4&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三nal-unit-解封装&quot;&gt;三、NAL Unit 解封装：&lt;/h3&gt;
&lt;h4 id=&quot;ebsp---rbsp&quot;&gt;1. EBSP -&amp;gt; RBSP：&lt;/h4&gt;
&lt;p&gt;去除竞争校验位（详细概念看&lt;a href=&quot;http://www.cnblogs.com/shuofxz/p/8416227.html&quot;&gt;学习笔记5&lt;/a&gt;）&lt;br/&gt;简而言之，就是去除两个连零后面的03。00 00 03 xx xx xx （其中的03即为竞争校验位，在拆包的时候需要去除）&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;CStreamFile&lt;/strong&gt; 类中添加私有函数 &lt;strong&gt;void ebsp_to_rbsp();&lt;/strong&gt;&lt;br/&gt;函数实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; CStreamFile::ebsp_to_rbsp()
{
    &lt;span class=&quot;co&quot;&gt;// 00 00 03 连续两个00后面的03是防止竞争校验字节，需要去掉&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 在序列中找03，在查看前面两个是不是00，如果是，就去掉03&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (m_nalVec.size() &amp;lt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
    {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (vector&amp;lt;uint8&amp;gt;::iterator itor = m_nalVec.begin() + &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;; itor != m_nalVec.end(); )
    {
        &lt;span class=&quot;co&quot;&gt;// 迭代器增长幅度为空，写在循环内部，方便删除元素&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; == *itor) &amp;amp;&amp;amp; (&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; == *(itor - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) &amp;amp;&amp;amp; (&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; == *(itor - &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)))
        {
            &lt;span class=&quot;co&quot;&gt;// 此处使用erase()时需要注意：&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 1、当调用erase()后Itor迭代器就失效了，变成了一野指针&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 2、而erase()这个函数会返回一个指针，仍指向清除元素的位置，只不过后面所有的数据都向前移动&lt;/span&gt;
            itor = m_nalVec.erase(itor);
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
        {
            itor++;
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;rbsp---sodb&quot;&gt;2. RBSP -&amp;gt; SODB：&lt;/h4&gt;
&lt;p&gt;这里本应还有RBSP -&amp;gt; SODB的部分，也就是去除 &lt;em&gt;rbsp_trailing_bits&lt;/em&gt; ，但对于分析 NAL Body 内部语法元素不会造成实际影响，这部分暂时空缺，有兴趣的可以自己实现一下。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;【对于NAL Body 编码方式的解析，会涉及熵编码知识，将在后续笔记中进行介绍。】&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 14:39:00 +0000</pubDate>
<dc:creator>Simon_Ace</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shuofxz/p/8443392.html</dc:identifier>
</item>
<item>
<title>IntelliJ IDEA使用心得之基础篇 - kagome2014</title>
<link>http://www.cnblogs.com/kagome2014/p/8353148.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kagome2014/p/8353148.html</guid>
<description>
&lt;p&gt;今天和大家分享一个非常好用的Java开发工具-IntelliJ IDEA。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://www.jetbrains.com/idea/&quot; target=&quot;_blank&quot;&gt;https://www.jetbrains.com/idea/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;优秀IDEA教程（不定期更新）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ituring.com.cn/article/37792&quot; target=&quot;_blank&quot;&gt;http://www.ituring.com.cn/article/37792&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;目录：&lt;/p&gt;
&lt;p&gt;1）IntelliJ IDEA使用心得之基础篇；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kagome2014/p/8421780.html&quot; target=&quot;_blank&quot;&gt;2）IntelliJ IDEA使用心得之插件篇；&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kagome2014/p/8443317.html&quot; target=&quot;_blank&quot;&gt;3）IntelliJ IDEA使用心得之快捷键篇；&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kagome2014/p/8431064.html&quot; target=&quot;_blank&quot;&gt;4）IntelliJ IDEA使用心得之Maven项目篇；&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kagome2014/p/8443220.html&quot; target=&quot;_blank&quot;&gt;5）IntelliJ IDEA使用心得之非Maven项目篇；&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kagome2014/p/8443325.html&quot; target=&quot;_blank&quot;&gt;6）IntelliJ IDEA使用心得之问题篇；&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打开IDEA后，可以看到如下界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201801/644257-20180125204635053-446712433.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;402&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择『Open』打开一个已有项目。（项目不需要运行，本篇只介绍工具的配置）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201801/644257-20180125205727600-889495996.png&quot; alt=&quot;&quot; width=&quot;222&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图示，默认是没有勾选『Toolbar』(工具类)、『Tool Buttons』（工具按钮），我们将其都选，就可以显示工具栏和工具按钮侧边栏，如下图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201801/644257-20180129123153343-1867382464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在工具栏中，点击&lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201801/644257-20180129123734265-1953164900.png&quot; alt=&quot;&quot;/&gt;进入IDE设置界面。&lt;/p&gt;

&lt;p&gt;1、File Encodings&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201802/644257-20180205122122623-256201664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图示，我们可以设置IDE的编码和项目的编码，建议二者保持一致。&lt;/p&gt;

&lt;p&gt;2、设置字体、背景色、前景色等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201802/644257-20180205122457857-1585404951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图示，非自定义主题样式不可修改，所以需要先创建自己的主题样式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201802/644257-20180205122740716-1482659070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图示，此处可以设置字体，向大家推荐一款非常好看的字体：Courier New。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201802/644257-20180205123050607-1301751257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图示，此处可设置前景色和背景色（推荐使用护眼色（#CCE8CF））。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201802/644257-20180205123244107-7123555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图示，此处可设置控制台字体。&lt;/p&gt;

&lt;p&gt;3、显示行号、方法分割线&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201802/644257-20180205123643107-1414393332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图示，此处可设置显示行号及方法分割线。&lt;/p&gt;

&lt;p&gt;4、导包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201802/644257-20180205123859201-1070473664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图示，此处可设置自动导包。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201802/644257-20180205124231357-889016627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IDEA会自动分析引入的类，当引入同一个包下的多个类时，会将多个引入合并为*（如java.util.*），但有时我们并不需要这种合并，所以我把上面的值设为1000。&lt;/p&gt;

&lt;p&gt;5、设置自动从源文件定位到文件位置&lt;/p&gt;
&lt;p&gt;在工具按钮侧边栏，点击『Project』&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/644257/201802/644257-20180211181348060-399556440.png&quot; alt=&quot;&quot; width=&quot;1026&quot; height=&quot;544&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 11 Feb 2018 14:04:00 +0000</pubDate>
<dc:creator>kagome2014</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kagome2014/p/8353148.html</dc:identifier>
</item>
<item>
<title>我的第一次项目管理--一次惨痛的教训 - 工藤-新一</title>
<link>http://www.cnblogs.com/gt-xy/p/8443234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gt-xy/p/8443234.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　最近总想发点时间写些东西但抽不出时间，趁着放年假并且今天刚开完项目的年前回顾会议赶紧写出来，其实挺不好意思讲的，有点尴尬。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;莫名的项目负责人：&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　由于公司逐步发展，项目越来越多，没有人有时间来负责这个项目，我的老板们可能看我比较顺眼于是便让我来负责这次的项目开发，于是我便莫名其妙的变成了项目负责人，一开始我是拒绝的，让一个什么都不懂的人来管理项目真的是太可怕了。哦，忘了说明，我们的项目成员就几个人并且每个人都身兼多个项目开发任务，因为是小公司。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;项目工作量的预估：　　&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　当时在做工作量预估的时候参考了像《程序员的职业素养》、《网易一千零一夜》等书上描述的工作量预估方法，将模块细分并采用理想人日来估算，当时算完的时候还觉得估算挺合理的。结果打脸了，我的天，大大超出了项目的预期完成时间。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;我们没有考虑到项目的缓冲时间，如需求改动以及其他优先级更高项目任务开发导致的时间延迟等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;缺乏沟通导致的项目失控：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在确认迭代的工作内容后我们开始了二十天的第一次迭代开发，在这期间我们很少沟通除了有依赖的部分确认下，在我完成工作内容时发现另一模块的开发停止了，他们被指派去做其它优先级更高的任务，项目组的其他成员并不知情。这个时候的我并未发起会议向上层领导反馈协商开发的时间，而是选择催促他们，直到又过了礼拜我发觉他们的开发还是停留在原地于是才让我的领导发起协商。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　将近耽误了一个月的时间，很明显责任在于我，之后我开始觉得站会、周会等的重要性，并开始实施，效果比较显著。这些会议能让项目组所有成员清楚的了解项目的最新进展、各成员的开发状态以及项目风险的评估。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;编码质量不过关：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　上一篇博客也有提到过我们公司目前代码质量的问题，我认为对于代码的质量是研发人员必须保证的，我们需要以让测试人员找不出Bug为目标，尤其是目前我们公司的测试仅仅是在做一些模拟用户行为的测试，并不像《google软件测试之道》中描述的还有软件测试开发人员配合我们测试。&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;有效会议的重要性：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　现在公司大大小小的会议可能都需要最高层领导来参加，根据我最近一段时间参与的会议以及这次项目过程中发起的一些会议，我们在会议前总是没有把会议想要讨论的内容、通过会议我们想实现什么目标、我们需要与会人员什么帮助等，并且会议中没有意识到时间的把控，我们知道会议的成本是非常昂贵的尤其是在有最高层领导的会议上，会议的把控也是今后要努力的一个方向。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;总结：　　&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　写的有点乱，但大致上想讲的也就这些，据说公司三月份测试部门回来七个应届毕业女实习生，据测试部内部消息好像有几个还挺漂亮的，所以，年假这段时间再好好充实下自己，晚安。&lt;/span&gt;&lt;/p&gt;





&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 13:18:00 +0000</pubDate>
<dc:creator>工藤-新一</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gt-xy/p/8443234.html</dc:identifier>
</item>
<item>
<title>webrtc底层一对一连接过程探索（二） - 小小梁的博客</title>
<link>http://www.cnblogs.com/webrtcPC/p/8443208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/webrtcPC/p/8443208.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;一、连接过程继续解读-----fun32&lt;/strong&gt;&lt;strong&gt;解读&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1.1 fun32.02&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&quot;undefined&quot; != &lt;span&gt;typeof&lt;/span&gt; cordova &amp;amp;&amp;amp; (N = !0, D = !0&lt;span&gt;), 
navigator &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; 
navigator.userAgent &lt;/span&gt;&amp;amp;&amp;amp; 
-1 !== navigator.userAgent.indexOf(&quot;Crosswalk&quot;) &amp;amp;&amp;amp;&lt;span&gt;
(N &lt;/span&gt;= !0, D = !0&lt;span&gt;); 
console.info(&lt;/span&gt;'fun32.02==&amp;gt;2252==&amp;gt;2252');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       注：关于函数中的逗号表达式，第一个逗号表达式执行完，不管它成立不成立，都要执行第二字逗号表达示，以最后一个逗号表达式生成的结果或真假为准；但在同一个逗号表达式中，如果是&amp;amp;&amp;amp;连接的，如果第一个（&quot;undefined&quot; != typeof cordova）不成立，就不会执行第二个（(N = !0, D = !0)）了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1）&lt;/span&gt;第一行代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&quot;undefined&quot; != typeof cordova &amp;amp;&amp;amp; (N = !0, D = !0),&lt;/p&gt;
&lt;p&gt;注：&quot;undefined&quot; != typeof cordova这一句为假，后面的(N = !0, D = !0)不执行了，因为&amp;amp;&amp;amp;连接的表达式，必须都为真，总体的结果才为真。这一行，包括以下的几行，是判断一对一的客户端用没用手机，并且用没用crosswalk进行包裹，就是说webrtc代码不仅可以跑在浏览器上，也可以跑在crosswalk框架上。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;第二至四行代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
navigator &amp;amp;&amp;amp;&lt;span&gt; 
navigator.userAgent &lt;/span&gt;&amp;amp;&amp;amp; 
-1 !== navigator.userAgent.indexOf(&quot;Crosswalk&quot;) &amp;amp;&amp;amp;&lt;span&gt;
(N &lt;/span&gt;= !0, D = !0); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;a.)&lt;/span&gt;&lt;/strong&gt; navigator如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211205606013-1417081623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;b.)&lt;/strong&gt;&lt;/span&gt; navigator.userAgent如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
navigator.userAgent:  Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211205730685-2134931315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c.)&lt;/strong&gt; navigator.userAgent.indexOf(&quot;Crosswalk&quot;)如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
navigator.userAgent.indexOf(&quot;Crosswalk&quot;):  -1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211205800420-403837899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：没查到Crosswalk，说明用的不是Crosswalk。这个判断为false，不再往下执行。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1.2  fun32.03&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; V = !N &amp;amp;&amp;amp; (I || L);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：V是false表示PC端不是IE浏览器，true表示PC端是IE浏览器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211205852576-1836009863.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211205901232-932579921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.3 fun32.04&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
V &amp;amp;&amp;amp;

&quot;undefined&quot; != &lt;span&gt;typeof&lt;/span&gt; URL &amp;amp;&amp;amp;&lt;span&gt;

(URL.createObjectURL &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;() {});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1）&lt;/span&gt;V&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;V是false&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;typeof URL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;URL是个函数&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3）&lt;/span&gt;URL.createObjectURL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;URL.createObjectURL是个函数&lt;/p&gt;
&lt;p&gt;总的截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211205959185-1698951617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：总的来说，这一行还是false，因为第一个就是false。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.4 fun32.05&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; W = (!!(window.process &amp;amp;&amp;amp;

                &quot;object&quot; == &lt;span&gt;typeof&lt;/span&gt; window.process &amp;amp;&amp;amp;&lt;span&gt;

                window.process.versions &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;

                window.process.versions[&lt;/span&gt;&quot;node-webkit&quot;]), 50&lt;span&gt;),

        B &lt;/span&gt;= navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./&lt;span&gt;);

console.info(&lt;/span&gt;'fun32.05==&amp;gt;2263==&amp;gt;2263');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1）变量W&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; W = (!!(window.process &amp;amp;&amp;amp;

                &quot;object&quot; == &lt;span&gt;typeof&lt;/span&gt; window.process &amp;amp;&amp;amp;&lt;span&gt;

                window.process.versions &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;

                window.process.versions[&lt;/span&gt;&quot;node-webkit&quot;]), 50),
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：W里面是个逗号表达式，!!一般用来将后面的表达式强制转换为布尔类型的数据（boolean），也就是只能是true或者false;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; a；

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b=!!a;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a默认是undefined。!a是true，!!a则是false，所以b的值是false，而不再是undefined，也非其它值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211210116091-477957090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;变量B&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
B = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：B能匹配出三个变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211210151404-1206671110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.5 fun32.06&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
D &amp;amp;&amp;amp; B &amp;amp;&amp;amp; B[2] &amp;amp;&amp;amp; (W = parseInt(B[2], 10));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1）&lt;/span&gt;D&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;D：用于判断是不是谷歌浏览器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;B&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;B是一个数组，如果是谷歌浏览器，它会产生三个元素。通过运行发现：D &amp;amp;&amp;amp; B=B&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211210247310-1823013905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3）&lt;/span&gt;B[2]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;B[2]：64，表示安装的是64位的浏览器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211210309435-1727312660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：此时，走到这一步了，结果就是64，即：D &amp;amp;&amp;amp; B &amp;amp;&amp;amp; B[2] = B[2]，这建立在D，B都成立的情况下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4）&lt;/span&gt;W = parseInt(B[2], 10)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;parseInt()函数，用于解析一个字符串，并返回一个整数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211210326623-1492918183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211210336982-2130610927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：所以W= parseInt(B[2], 10)= parseInt(64, 10)=60+4=64&lt;/p&gt;
&lt;p&gt;所以整个表达式的值为64&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.6 fun32.07&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; F = 50&lt;span&gt;;

    B &lt;/span&gt;= navigator.userAgent.match(/Firefox\/(.*)/&lt;span&gt;),

    U &lt;/span&gt;&amp;amp;&amp;amp; B &amp;amp;&amp;amp; B[1] &amp;amp;&amp;amp; (F = parseInt(B[1], 10&lt;span&gt;)),

    window.addEventListener &lt;/span&gt;|| (window.addEventListener = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e, n, t) {

        e.attachEvent &lt;/span&gt;&amp;amp;&amp;amp; e.attachEvent(&quot;on&quot; +&lt;span&gt; n, t)

    }),

    window.attachEventListener &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e, n, t, o) {

        e.addEventListener(n, t, o)

    };

console.info(&lt;/span&gt;'fun32.07==&amp;gt;2277==&amp;gt;2277');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1）&lt;/span&gt;var F = 50;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   定义一个变量F，并赋值为50.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;B = navigator.userAgent.match(/Firefox\/(.*)/),&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   用于判断是否为火狐浏览器，输出应该为false为空。截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211210411982-642054430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3）&lt;/span&gt;U &amp;amp;&amp;amp; B &amp;amp;&amp;amp; B[1] &amp;amp;&amp;amp; (F = parseInt(B[1], 10)),&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; U为false，不用往下看了，由上可以B是null，也为假。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331143/201802/1331143-20180211210455279-285311505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4）&lt;/span&gt;监听&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    window.addEventListener || (window.addEventListener = function(e, n, t) {&lt;/p&gt;
&lt;p&gt;        e.attachEvent &amp;amp;&amp;amp; e.attachEvent(&quot;on&quot; + n, t)&lt;/p&gt;
&lt;p&gt;}),&lt;/p&gt;
&lt;p&gt;注：这是一个监听函数，但后面不知为什么，重定义了。用到时，再说吧。&lt;/p&gt;

</description>
<pubDate>Sun, 11 Feb 2018 13:06:00 +0000</pubDate>
<dc:creator>小小梁的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/webrtcPC/p/8443208.html</dc:identifier>
</item>
<item>
<title>项目微管理6 - 经理 - 沙场秋点兵</title>
<link>http://www.cnblogs.com/dxy1982/p/8443057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dxy1982/p/8443057.html</guid>
<description>&lt;p&gt;自从鼬来到PC团队后，四代终于不再是孤家寡人了。&lt;/p&gt;

&lt;p&gt;在经过几个月的磨合以后，四代对鼬的性格和技术水平也有了一定的了解，再加上代码规范和代码审查的初步版本也已经有了，正式的战斗总算可以开始了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;什么是项目经理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;也就在这个时间点上，四代到来后的第一个年关也到了，年终意味着涨薪和年终奖，也意味着总结和回顾，更意味着对来年的规划和思考。&lt;/p&gt;

&lt;p&gt;技术部门每年都有年终总结，今年的人数是历年最多的，总共有十几个人，四代、鼬和大家一样参加了总结并分享了一些话题。在总结中，四代把这小半年的工作整理一下，然后细细的品味了期间发生的各种事项。&lt;/p&gt;

&lt;p&gt;此时，对于首次正式担任项目经理的四代来说，他要思考的最重要的一组问题就是：“到底什么是项目经理？他的作用是什么？他应该怎么做？”&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/109061/201802/109061-20180211201016732-978862047.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;这些问题听起来相当耳熟嘛？确实，接触过PMP考试的兄弟听到这些，可能一下子就能容光焕发，自豪给你背出一大堆精准的关于项目经理和项目管理的定义和流程，然后闪烁着轻飘的眼神斜视着你：小样，哥可是专家。&lt;/p&gt;

&lt;p&gt;对于对各种证书和考证深恶痛绝的四代来说，他自然是不屑于参加这种走形式的考试。不过四代在某一次去一位同事的家里串门的时候，偶然看到了那位同事参加PMP考试的书。&lt;/p&gt;

&lt;p&gt;对于从来对书都很感兴趣的四代来说，他顺手就抄起了那本书，随便的翻看了一下，没想到虽然是考试用书，他居然觉得还挺有意思的，于是就大略的读了一些感兴趣的章节，所以上述的那些答案对四代来说，当然也不是很陌生。&lt;/p&gt;

&lt;p&gt;那么，到底什么是项目经理？&lt;/p&gt;

&lt;p&gt;不扯那些官话和套话，从四代的角度讲，&lt;span&gt;&lt;strong&gt;项目经理就是项目的组织者，组织整个团队完成项目设计，研发，测试，发布，反馈，调整的人&lt;/strong&gt;&lt;/span&gt;！这就是项目经理的作用或者说职责！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;无中生有&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;说起这个问题，四代似乎又回到了多年前的那些时光，在那个时候突然就流行起一个叫“三国杀”的游戏。&lt;/p&gt;

&lt;p&gt;“三国杀”据说是西方“杀人游戏”的衍生版本，四代没玩过杀人游戏，所以也不知道区别是什么。不过四代自初中起就是三国迷，现在更是业余的军事历史爱好者，对于这样一款充满新奇玩法和熟知人物的游戏，基本是没什么抵抗力的。于是在那一段时间，四代一有时间就会召集朋友们厮杀一番。&lt;/p&gt;

&lt;p&gt;在三国杀的众多卡牌中，有一张非常厉害的牌叫做“无中生有”，谁要是打出了这张牌就可以再得到两张牌，是不是很牛？运气好到没朋友的时候，你还有时能连续拿到三张“无中生有”，如果这样，那基本就真的没朋友了。&lt;/p&gt;

&lt;div&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/109061/201802/109061-20180211201351560-1912948385.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;当四代思考项目经理的职责的时候，涌入四代脑中的第一个词汇居然就是“无中生有”！&lt;/p&gt;

&lt;p&gt;四代想了一下，觉得真是太神奇了，用“无中生有”来形容项目经理的职责真是再合适不过了：当产品经理或团队确定了产品的功能后，剩下的可不就是&lt;strong&gt;&lt;span&gt;项目经理聚拢团队，拼凑资源，将产品从一个虚无的概念，一个不能使用的原型，转变为实际的产品，可以使用的软件&lt;/span&gt;&lt;/strong&gt;的过程嘛！&lt;/p&gt;

&lt;p&gt;这个过程其实就是在只有一个目标和画出来的“饼”，毫无秩序的混沌状态下，&lt;strong&gt;&lt;span&gt;组织团队，趟过尸山血海，成功登顶&lt;/span&gt;&lt;/strong&gt;的过程。在这个过程中，他要&lt;strong&gt;&lt;span&gt;独自面对人来人往，进度的迟滞，组员的质疑，上层的期望，在这重重压力之下，最终拿出产品&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;那个越来越重要的人&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;在四代看来，最接近战场的一线项目经理，也就是级别最低的项目经理，是每个公司非常重要的人，他们的重要性甚至超过了其上层的许多人。&lt;/p&gt;

&lt;p&gt;现在的公司扁平化与其说是更加适合管理，更加能应对变化，还不如说是大家看到了一线项目经理的重要性，更加认同一线项目经理的重要性了。&lt;/p&gt;

&lt;p&gt;四代也不记得是哪位老总说的“让听得见炮声的人做决策”了，不过四代却是非常赞同这种说法的；听得见炮声的就是一线的研发团队，这个团队的组织者就是一线项目经理。&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/109061/201802/109061-20180211201801873-139483345.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;弄清楚了互联网时代背景下一线项目经理的重要性和职责后，接下来四代要考虑的就是如何履行项目经理的责任了，也就是项目经理应该怎么干？&lt;/p&gt;

&lt;p&gt;从项目经理的职责来说，项目经理在组织项目研发的过程中，接触的无非是两样，一是产品，二是资源，前者是项目的输出，后者是项目的输入。所以从这个角度来说，&lt;strong&gt;&lt;span&gt;项目经理就是去经营两个方面的内容：产品和资源&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;产品包括项目产出的所有交付品，当然最主要是软件。资源包括参与产品研发的所有相关对象，当然最重要的是人，也就是团队。所以项目管理，最主要的也就是指产品管理和团队管理两方面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;制度建设&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;产品管理包括项目研发的目标，进度，质量管理。团队管理包括团队成员的招聘，培训，激励管理。不管是前者还是后者，首先需要的都是制度上的建设。&lt;/p&gt;

&lt;p&gt;四代是军事历史爱好者，所以四代首先想到的就是从过去的历史中寻找制度建设的灵感。&lt;/p&gt;

&lt;p&gt;话说最近几年，不管是在学术界，还是在民间，都兴起了一股研究秦史的风潮，其中还有些相当不错的作品相继问世，比如《大秦帝国》，《秦谜》等等。&lt;/p&gt;

&lt;p&gt;确实，由于史料的缺失，秦帝国留给我们后代子孙的谜团实在是太多了，比如秦始皇到底是个什么样的人，为什么不设立皇后，如此强大的帝国怎么会在短短几年之间土崩瓦解？这样的问题还有很多，不同的人也有着不同的解读。&lt;/p&gt;

&lt;p&gt;对于秦国的崛起，大家都没什么分歧，公认是源于秦孝公和商鞅这一对好基友开始的商鞅变法。商鞅变法的内容很多，不过归根结底干的就是一件事，那就是制定准则，说的具有现代气息一点就是制度建设。&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/109061/201802/109061-20180211203413966-1658064079.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;说到这里，四代的目光似乎穿透了历史的重重阻隔，又回到了两千多年前的那场惊天动地的改革。这场改革即使是从今天的认知来说也是一场非常成功的转型。&lt;/p&gt;

&lt;p&gt;在整个商鞅变法的过程中，四代记忆最深刻的就是这么几件事：严厉禁止内斗，枪口一致对外；使用爵位制度大幅奖励军功；废除特权阶层，一切以军功来评定。&lt;/p&gt;

&lt;p&gt;说到做到，严格按照法律来执行，这俩好兄弟真正的做到了清除制定制度过程中出现的无数的阻力，从权力核心中的皇室宗亲到普通的平民百姓，不仅是有法可依，而且是有法必依。这些对四代来说是非常具有借鉴意义的。&lt;/p&gt;

&lt;p&gt;如果按照今天“互联网+”时代的玩法对照一下，上面几件事几乎可以直译为：禁止在公司内部搞职场内耗，应该全力开拓新市场；使用股权激励有贡献的员工；没有特权，有功劳的上，没有的下；执行力强。&lt;/p&gt;

&lt;p&gt;经过商鞅变法后，整个秦国的民风发生了翻天覆地的变化。我们这一代人都知道一个词叫“人民战争”，那个时候的秦国人就是这样，人人都被动员了起来。&lt;/p&gt;

&lt;p&gt;私斗没有了，因为会受到严惩，人人想的都是如何在战场上多砍杀几个敌人，因为可以获得爵位，爵位带来的是一系列优惠的待遇，而且人人都平等，一切凭功劳来说话。&lt;/p&gt;

&lt;p&gt;就在这样的制度下，经过几代秦王的不懈努力，秦帝国迅速的在西方崛起，并对东方六国形成了压倒性的优势，最终在远交近攻的策略指导下，对六国各个击破，最终统一全国，建立了一个史无前例的真正的大一统帝国。&lt;/p&gt;

&lt;p&gt;每当想到这一点，四代总是对那个叫秦始皇的人充满钦佩之情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;唯一不变的就是变&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;可是，当十来年之后，始皇帝驾崩之后，秦帝国迅速衰落，在短短几年后，一个叫刘邦的人在错综复杂的形势下，击败了中国历史上赫赫有名的西楚霸王项羽，再次统一全国，建立了叫“汉”的帝国，史书记载：汉承秦制。&lt;/p&gt;

&lt;p&gt;那么问题来了，既然是汉承秦制，说明不是秦制度不好，那么秦国人玩不转的事，刘老三（也有叫刘老四的）为什么能玩的很好呢？&lt;/p&gt;

&lt;p&gt;对于这个问题，四代倾向于同意一种解释：秦制度虽然好，但那是根据当时弱小的秦国量身定制的。&lt;/p&gt;

&lt;p&gt;当秦统一六国后，秦始皇没有对秦制度进行相应的修正就推广到全国，结果很多的制度对一个大帝国根本不适用，比如征召民夫逾期不到者斩！你要知道现在不是在小小的边陲小国了，好不好！在中国这么个大的地方上，就算是现代有高铁和航班的情况下，晚点和延期都是经常的事，何况当时主要还是靠11路的情况下，逾期几天是经常的事好不好！这样就要斩人，当然大家不服了。&lt;/p&gt;

&lt;p&gt;接下来非常有名的两个故事大家就都知道了，一个叫大泽乡起义，一个叫高祖斩白蛇起义，他们起义的原因是一样的，叫“逾期不到”。刘邦建立的汉帝国是承袭了秦国的制度不错，但不是原封不动的照搬，而是针对当时的情景不断进行调整，比如加入黄老的思想，最终达到符合实际情况后才实施下来。&lt;/p&gt;

&lt;p&gt;这种做法时髦的叫法叫：与时俱进！用微生物学上的词汇描述叫：变异！用伟人提的口号叫：批评与自我评判！用商业模式中的话叫：自我颠覆！&lt;/p&gt;

&lt;div&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/109061/201802/109061-20180211204117670-466774547.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;从来没有什么万能的方案能解决所有的问题，也没有什么理想的制度可以应对所有的情况，“事物总是处于不断的变化和发展的过程中”，如果不变，那么就意味着僵化，意味着死亡！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;天花之所以被彻底治愈，是因为它结构稳定，没有进化，即使再强，也好对付。&lt;/p&gt;

&lt;p&gt;流感之所以至今还在肆虐，是因为它结构虽然简单，但是每时每刻都在变异，即使每次变异，你都能找到对应的治疗方案，但是你永远无法提前知道它下一刻的形态，所以就无法防住下一刻它的攻击！就是这么简单，这是伟大的自然辩证法告诉我们的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;项目经理的最重要的职责就是建立团队的基本制度，不断的根据团队的状态调整它们，并严格的执行下去。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;确立了这个基本思路，四代根据目前的状态，开始了团队建设的艰难历程。&lt;/p&gt;

</description>
<pubDate>Sun, 11 Feb 2018 12:58:00 +0000</pubDate>
<dc:creator>沙场秋点兵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dxy1982/p/8443057.html</dc:identifier>
</item>
<item>
<title>【OCR技术系列之四】基于深度学习的文字识别（3755个汉字） - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8443107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8443107.html</guid>
<description>&lt;p&gt;上一篇提到文字数据集的合成，现在我们手头上已经得到了3755个汉字（一级字库）的印刷体图像数据集，我们可以利用它们进行接下来的3755个汉字的识别系统的搭建。用深度学习做文字识别，用的网络当然是CNN，那具体使用哪个经典网络？VGG?RESNET？还是其他？我想了下，越深的网络训练得到的模型应该会更好，但是想到训练的难度以及以后线上部署时预测的速度，我觉得首先建立一个比较浅的网络（基于LeNet的改进）做基本的文字识别，然后再根据项目需求，再尝试其他的网络结构。这次任务所使用的深度学习框架是强大的Tensorflow。&lt;/p&gt;
&lt;h2 id=&quot;网络搭建&quot;&gt;网络搭建&lt;/h2&gt;
&lt;p&gt;第一步当然是搭建网络和计算图&lt;/p&gt;
&lt;p&gt;其实文字识别就是一个多分类任务，比如这个3755文字识别就是3755个类别的分类任务。我们定义的网络非常简单，基本就是LeNet的改进版，值得注意的是我们加入了batch normalization。另外我们的损失函数选择sparse_softmax_cross_entropy_with_logits，优化器选择了Adam，学习率设为0.1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#network: conv2d-&amp;gt;max_pool2d-&amp;gt;conv2d-&amp;gt;max_pool2d-&amp;gt;conv2d-&amp;gt;max_pool2d-&amp;gt;conv2d-&amp;gt;conv2d-&amp;gt;max_pool2d-&amp;gt;fully_connected-&amp;gt;fully_connected&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;def build_graph(top_k):
    keep_prob = tf.placeholder(dtype=tf.float32, shape=[], name='keep_prob')
    images = tf.placeholder(dtype=tf.float32, shape=[None, 64, 64, 1], name='image_batch')
    labels = tf.placeholder(dtype=tf.int64, shape=[None], name='label_batch')
    is_training = tf.placeholder(dtype=tf.bool, shape=[], name='train_flag')
    with tf.device('/gpu:5'):
        #给slim.conv2d和slim.fully_connected准备了默认参数：batch_norm
        with slim.arg_scope([slim.conv2d, slim.fully_connected],
                            normalizer_fn=slim.batch_norm,
                            normalizer_params={'is_training': is_training}):
            conv3_1 = slim.conv2d(images, 64, [3, 3], 1, padding='SAME', scope='conv3_1')
            max_pool_1 = slim.max_pool2d(conv3_1, [2, 2], [2, 2], padding='SAME', scope='pool1')
            conv3_2 = slim.conv2d(max_pool_1, 128, [3, 3], padding='SAME', scope='conv3_2')
            max_pool_2 = slim.max_pool2d(conv3_2, [2, 2], [2, 2], padding='SAME', scope='pool2')
            conv3_3 = slim.conv2d(max_pool_2, 256, [3, 3], padding='SAME', scope='conv3_3')
            max_pool_3 = slim.max_pool2d(conv3_3, [2, 2], [2, 2], padding='SAME', scope='pool3')
            conv3_4 = slim.conv2d(max_pool_3, 512, [3, 3], padding='SAME', scope='conv3_4')
            conv3_5 = slim.conv2d(conv3_4, 512, [3, 3], padding='SAME', scope='conv3_5')
            max_pool_4 = slim.max_pool2d(conv3_5, [2, 2], [2, 2], padding='SAME', scope='pool4')

            flatten = slim.flatten(max_pool_4)
            fc1 = slim.fully_connected(slim.dropout(flatten, keep_prob), 1024,
                                       activation_fn=tf.nn.relu, scope='fc1')
            logits = slim.fully_connected(slim.dropout(fc1, keep_prob), FLAGS.charset_size, activation_fn=None,
                                          scope='fc2')
        # 因为我们没有做热编码，所以使用sparse_softmax_cross_entropy_with_logits
        loss = tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels))
        accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(logits, 1), labels), tf.float32))

        update_ops = tf.get_collection(tf.GraphKeys.UPDATE_OPS)
        if update_ops:
            updates = tf.group(*update_ops)
            loss = control_flow_ops.with_dependencies([updates], loss)

        global_step = tf.get_variable(&quot;step&quot;, [], initializer=tf.constant_initializer(0.0), trainable=False)
        optimizer = tf.train.AdamOptimizer(learning_rate=0.1)
        train_op = slim.learning.create_train_op(loss, optimizer, global_step=global_step)
        probabilities = tf.nn.softmax(logits)

        # 绘制loss accuracy曲线
        tf.summary.scalar('loss', loss)
        tf.summary.scalar('accuracy', accuracy)
        merged_summary_op = tf.summary.merge_all()
        # 返回top k 个预测结果及其概率；返回top K accuracy
        predicted_val_top_k, predicted_index_top_k = tf.nn.top_k(probabilities, k=top_k)
        accuracy_in_top_k = tf.reduce_mean(tf.cast(tf.nn.in_top_k(probabilities, labels, top_k), tf.float32))

    return {'images': images,
            'labels': labels,
            'keep_prob': keep_prob,
            'top_k': top_k,
            'global_step': global_step,
            'train_op': train_op,
            'loss': loss,
            'is_training': is_training,
            'accuracy': accuracy,
            'accuracy_top_k': accuracy_in_top_k,
            'merged_summary_op': merged_summary_op,
            'predicted_distribution': probabilities,
            'predicted_index_top_k': predicted_index_top_k,
            'predicted_val_top_k': predicted_val_top_k}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;模型训练&quot;&gt;模型训练&lt;/h2&gt;
&lt;p&gt;训练之前我们应设计好数据怎么样才能高效地喂给网络训练。&lt;/p&gt;
&lt;p&gt;首先，我们先创建数据流图，这个数据流图由一些流水线的阶段组成，阶段间用队列连接在一起。第一阶段将生成文件名，我们读取这些文件名并且把他们排到文件名队列中。第二阶段从文件中读取数据（使用Reader），产生样本，而且把样本放在一个样本队列中。根据你的设置，实际上也可以拷贝第二阶段的样本，使得他们相互独立，这样就可以从多个文件中并行读取。在第二阶段的最后是一个排队操作，就是入队到队列中去，在下一阶段出队。因为我们是要开始运行这些入队操作的线程，所以我们的训练循环会使得样本队列中的样本不断地出队。&lt;/p&gt;
&lt;p&gt;盗个图说明一下具体的数据读入流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180211200541435-287760110.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;入队操作都在主线程中进行,Session中可以多个线程一起运行。 在数据输入的应用场景中，入队操作是从硬盘中读取输入，放到内存当中，速度较慢。 使用QueueRunner可以创建一系列新的线程进行入队操作，让主线程继续使用数据。如果在训练神经网络的场景中，就是训练网络和读取数据是异步的，主线程在训练网络，另一个线程在将数据从硬盘读入内存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# batch的生成
def input_pipeline(self, batch_size, num_epochs=None, aug=False):
    # numpy array 转 tensor
    images_tensor = tf.convert_to_tensor(self.image_names, dtype=tf.string)
    labels_tensor = tf.convert_to_tensor(self.labels, dtype=tf.int64)
    # 将image_list ,label_list做一个slice处理
    input_queue = tf.train.slice_input_producer([images_tensor, labels_tensor], num_epochs=num_epochs)

    labels = input_queue[1]
    images_content = tf.read_file(input_queue[0])
    images = tf.image.convert_image_dtype(tf.image.decode_png(images_content, channels=1), tf.float32)
    if aug:
        images = self.data_augmentation(images)
    new_size = tf.constant([FLAGS.image_size, FLAGS.image_size], dtype=tf.int32)
    images = tf.image.resize_images(images, new_size)
    image_batch, label_batch = tf.train.shuffle_batch([images, labels], batch_size=batch_size, capacity=50000,
                                                      min_after_dequeue=10000)
    # print 'image_batch', image_batch.get_shape()
    return image_batch, label_batch&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;训练时数据读取的模式如上面所述，那训练代码则根据该架构设计如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def train():
    print('Begin training')
    # 填好数据读取的路径
    train_feeder = DataIterator(data_dir='./dataset/train/')
    test_feeder = DataIterator(data_dir='./dataset/test/')
    model_name = 'chinese-rec-model'
    with tf.Session(config=tf.ConfigProto(gpu_options=gpu_options, allow_soft_placement=True)) as sess:
        # batch data 获取
        train_images, train_labels = train_feeder.input_pipeline(batch_size=FLAGS.batch_size, aug=True)
        test_images, test_labels = test_feeder.input_pipeline(batch_size=FLAGS.batch_size)
        graph = build_graph(top_k=1)  # 训练时top k = 1
        saver = tf.train.Saver()
        sess.run(tf.global_variables_initializer())
        # 设置多线程协调器
        coord = tf.train.Coordinator()
        threads = tf.train.start_queue_runners(sess=sess, coord=coord)

        train_writer = tf.summary.FileWriter(FLAGS.log_dir + '/train', sess.graph)
        test_writer = tf.summary.FileWriter(FLAGS.log_dir + '/val')
        start_step = 0
        # 可以从某个step下的模型继续训练
        if FLAGS.restore:
            ckpt = tf.train.latest_checkpoint(FLAGS.checkpoint_dir)
            if ckpt:
                saver.restore(sess, ckpt)
                print(&quot;restore from the checkpoint {0}&quot;.format(ckpt))
                start_step += int(ckpt.split('-')[-1])

        logger.info(':::Training Start:::')
        try:
            i = 0
            while not coord.should_stop():
                i += 1
                start_time = time.time()
                train_images_batch, train_labels_batch = sess.run([train_images, train_labels])
                feed_dict = {graph['images']: train_images_batch,
                             graph['labels']: train_labels_batch,
                             graph['keep_prob']: 0.8,
                             graph['is_training']: True}
                _, loss_val, train_summary, step = sess.run(
                    [graph['train_op'], graph['loss'], graph['merged_summary_op'], graph['global_step']],
                    feed_dict=feed_dict)
                train_writer.add_summary(train_summary, step)
                end_time = time.time()
                logger.info(&quot;the step {0} takes {1} loss {2}&quot;.format(step, end_time - start_time, loss_val))
                if step &amp;gt; FLAGS.max_steps:
                    break
                if step % FLAGS.eval_steps == 1:
                    test_images_batch, test_labels_batch = sess.run([test_images, test_labels])
                    feed_dict = {graph['images']: test_images_batch,
                                 graph['labels']: test_labels_batch,
                                 graph['keep_prob']: 1.0,
                                 graph['is_training']: False}
                    accuracy_test, test_summary = sess.run([graph['accuracy'], graph['merged_summary_op']],
                                                           feed_dict=feed_dict)
                    if step &amp;gt; 300:
                        test_writer.add_summary(test_summary, step)
                    logger.info('===============Eval a batch=======================')
                    logger.info('the step {0} test accuracy: {1}'
                                .format(step, accuracy_test))
                    logger.info('===============Eval a batch=======================')
                if step % FLAGS.save_steps == 1:
                    logger.info('Save the ckpt of {0}'.format(step))
                    saver.save(sess, os.path.join(FLAGS.checkpoint_dir, model_name),
                               global_step=graph['global_step'])
        except tf.errors.OutOfRangeError:
            logger.info('==================Train Finished================')
            saver.save(sess, os.path.join(FLAGS.checkpoint_dir, model_name), global_step=graph['global_step'])
        finally:
            # 达到最大训练迭代数的时候清理关闭线程
            coord.request_stop()
        coord.join(threads)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行以下指令进行模型训练。因为我使用的是TITAN X，所以感觉训练时间不长，大概1个小时可以训练完毕。训练过程的loss和accuracy变换曲线如下图所示&lt;/p&gt;
&lt;p&gt;然后执行指令，设置最大迭代步数为16002，每100步进行一次验证，每500步存储一次模型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python Chinese_OCR.py --mode=train --max_steps=16002 --eval_steps=100 --save_steps=500&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180211200558513-1239666785.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180211200610107-1684537471.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;模型性能评估&quot;&gt;模型性能评估&lt;/h2&gt;
&lt;p&gt;我们的需要对模模型进行评估，我们需要计算模型的top 1 和top 5的准确率。&lt;/p&gt;
&lt;p&gt;执行指令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python Chinese_OCR.py --mode=validation&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证开始&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180211200621388-1486412015.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后给出预测的top1 和top5正确率如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180211200630388-1401372448.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def validation():
    print('Begin validation')
    test_feeder = DataIterator(data_dir='./dataset/test/')

    final_predict_val = []
    final_predict_index = []
    groundtruth = []

    with tf.Session(config=tf.ConfigProto(gpu_options=gpu_options,allow_soft_placement=True)) as sess:
        test_images, test_labels = test_feeder.input_pipeline(batch_size=FLAGS.batch_size, num_epochs=1)
        graph = build_graph(top_k=5)
        saver = tf.train.Saver()

        sess.run(tf.global_variables_initializer())
        sess.run(tf.local_variables_initializer())  # initialize test_feeder's inside state

        coord = tf.train.Coordinator()
        threads = tf.train.start_queue_runners(sess=sess, coord=coord)

        ckpt = tf.train.latest_checkpoint(FLAGS.checkpoint_dir)
        if ckpt:
            saver.restore(sess, ckpt)
            print(&quot;restore from the checkpoint {0}&quot;.format(ckpt))

        logger.info(':::Start validation:::')
        try:
            i = 0
            acc_top_1, acc_top_k = 0.0, 0.0
            while not coord.should_stop():
                i += 1
                start_time = time.time()
                test_images_batch, test_labels_batch = sess.run([test_images, test_labels])
                feed_dict = {graph['images']: test_images_batch,
                             graph['labels']: test_labels_batch,
                             graph['keep_prob']: 1.0,
                             graph['is_training']: False}
                batch_labels, probs, indices, acc_1, acc_k = sess.run([graph['labels'],
                                                                       graph['predicted_val_top_k'],
                                                                       graph['predicted_index_top_k'],
                                                                       graph['accuracy'],
                                                                       graph['accuracy_top_k']], feed_dict=feed_dict)
                final_predict_val += probs.tolist()
                final_predict_index += indices.tolist()
                groundtruth += batch_labels.tolist()
                acc_top_1 += acc_1
                acc_top_k += acc_k
                end_time = time.time()
                logger.info(&quot;the batch {0} takes {1} seconds, accuracy = {2}(top_1) {3}(top_k)&quot;
                            .format(i, end_time - start_time, acc_1, acc_k))

        except tf.errors.OutOfRangeError:
            logger.info('==================Validation Finished================')
            acc_top_1 = acc_top_1 * FLAGS.batch_size / test_feeder.size
            acc_top_k = acc_top_k * FLAGS.batch_size / test_feeder.size
            logger.info('top 1 accuracy {0} top k accuracy {1}'.format(acc_top_1, acc_top_k))
        finally:
            coord.request_stop()
        coord.join(threads)
    return {'prob': final_predict_val, 'indices': final_predict_index, 'groundtruth': groundtruth}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文字预测&quot;&gt;文字预测&lt;/h2&gt;
&lt;p&gt;刚刚做的那一步只是使用了我们生成的数据集作为测试集来检验模型性能，这种检验是不大准确的，因为我们日常需要识别的文字样本不会像是自己合成的文字那样的稳定和规则。那我们尝试使用该模型对一些实际场景的文字进行识别，真正考察模型的泛化能力。&lt;/p&gt;
&lt;p&gt;首先先编写好预测的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def inference(name_list):
    print('inference')
    image_set=[]
    # 对每张图进行尺寸标准化和归一化
    for image in name_list:
        temp_image = Image.open(image).convert('L')
        temp_image = temp_image.resize((FLAGS.image_size, FLAGS.image_size), Image.ANTIALIAS)
        temp_image = np.asarray(temp_image) / 255.0
        temp_image = temp_image.reshape([-1, 64, 64, 1])
        image_set.append(temp_image)
        
    # allow_soft_placement 如果你指定的设备不存在，允许TF自动分配设备
    with tf.Session(config=tf.ConfigProto(gpu_options=gpu_options,allow_soft_placement=True)) as sess:
        logger.info('========start inference============')
        # images = tf.placeholder(dtype=tf.float32, shape=[None, 64, 64, 1])
        # Pass a shadow label 0. This label will not affect the computation graph.
        graph = build_graph(top_k=3)
        saver = tf.train.Saver()
        # 自动获取最后一次保存的模型
        ckpt = tf.train.latest_checkpoint(FLAGS.checkpoint_dir)
        if ckpt:       
            saver.restore(sess, ckpt)
        val_list=[]
        idx_list=[]
        # 预测每一张图
        for item in image_set:
            temp_image = item
            predict_val, predict_index = sess.run([graph['predicted_val_top_k'], graph['predicted_index_top_k']],
                                              feed_dict={graph['images']: temp_image,
                                                         graph['keep_prob']: 1.0,
                                                         graph['is_training']: False})
            val_list.append(predict_val)
            idx_list.append(predict_index)
    #return predict_val, predict_index
    return val_list,idx_list
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要说明一下，我会把我要识别的文字图像存入一个叫做tmp的文件夹内，里面的图像按照顺序依次编号，我们识别时就从该目录下读取所有图片仅内存进行逐一识别。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 获待预测图像文件夹内的图像名字
def get_file_list(path):
    list_name=[]
    files = os.listdir(path)
    files.sort()
    for file in files:
        file_path = os.path.join(path, file)
        list_name.append(file_path)
    return list_name
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那我们使用训练好的模型进行汉字预测，观察效果。首先我从一篇论文pdf上用截图工具截取了一段文字，然后使用文字切割算法把文字段落切割为单字，如下图，因为有少量文字切割失败，所以丢弃了一些单字。&lt;/p&gt;
&lt;p&gt;从论文中用截图工具截取文字段落。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180211200646013-1848838573.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切割出来的单字，黑底白字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180211200655013-187103228.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行指令,开始文字识别。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; python Chinese_OCR.py --mode=inference &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我使用的是GPU，预测速度非常快，除去系统初始化时间，全部图像预测完成所花费的时间不超过1秒。&lt;/p&gt;
&lt;p&gt;其中打印日志的信息分别是：当前识别的图片路径、模型预测出的top 3汉字（置信度由高到低排列）、对应的汉字id、对应的概率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180211200705841-805305823.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后将所有的识别文字按顺序组合成段落，可以看出，汉字识别完全正确，说明我们的基于深度学习的OCR系统还是相当给力！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180211200717763-1926506184.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此，支持3755个汉字识别的OCR系统已经搭建完毕，经过测试，效果还是很不错。这是一个没有经过太多优化的模型，在模型评估上top 1的正确率达到了99.9%，这是一个相当优秀的效果了，所以说在一些比较理想的环境下的文字识别的效果还是比较给力，但是对于复杂场景的或是一些干扰比较大的文字图像，识别起来的效果可能不会太理想，这就需要针对特定场景做进一步优化。&lt;/p&gt;
&lt;p&gt;完整代码在&lt;a href=&quot;https://github.com/AstarLight/CPS-OCR-Engine&quot;&gt;我的github&lt;/a&gt;获取。&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 12:08:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8443107.html</dc:identifier>
</item>
<item>
<title>毕业之后，心里总会存在这样的一些感想：我该如何给自己一个准确的规划？ - 吴海瑞博客</title>
<link>http://www.cnblogs.com/wuhairui/p/8443004.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhairui/p/8443004.html</guid>
<description>&lt;p&gt;有时候真的感觉很后悔过去没有好好的让自己在外面多经历经历，直到大学毕业那年依旧懵懵懂懂，学生时代的不仅内向而且造成了自闭，只能成为同学们的玩耍对象，被各种嘲讽与奚落，导致总喜欢拖延，大学后喜欢游戏和动漫，但对它们的了解又不深刻，总结也少，其实如果能深入去了解这些东西，并取得一定成果也是非常不错的。可我就是没有做到，导致人越来越宅，没有找到同圈子的朋友，不同的圈子又说不上什么话，心里又没有规划。书上说内向的人是很注重内心思考的，但为啥我一直就想不明白嘞！！！&lt;img src=&quot;https://images2017.cnblogs.com/blog/883015/201802/883015-20180211192918513-1432963980.png&quot; alt=&quot;&quot; width=&quot;109&quot; height=&quot;111&quot;/&gt; excuse me？？？ 就这样，随着时间的推移，和别人的差距就显现出来了。&lt;/p&gt;
&lt;p&gt;91年，毕业3年多了，上班平时都是按部就班，也没有换过公司，看似安逸却无法突破瓶颈，一直一个人走自己的路，想交朋友却又因为经常不知道说什么，没法和大家打成一片没交到知心朋友。（女朋友？what this it？）。和同事们的关系也仅仅是工作上的交流。&lt;/p&gt;
&lt;p&gt;想规划自己但又没有一个准确的规划，虽有大目标，但又不知道如何定小目标一步步走（怎么定，定下来怎么走，是不是真的有效果……），有很多兴趣却又苦于时间不足以及自身能力不足，进步的速度也慢的无语。看鸡汤文感觉没效果又浪费时间。一直在找一直在试，但又处处碰壁。&lt;/p&gt;
&lt;p&gt;有时候真的很羡慕别人有这么好的口才、这么多的经历以及丰富的经验。但我知道这些都是别人花了很多时间和精力去经历而来的，他们在很早就给自己定下了规划，并根据这么规划不断努力下去而来的。&lt;/p&gt;
&lt;p&gt;其实也没什么可以说的，晚是晚了。现在是懂了很多，但是想要改变却变得越来越难了，还是无法正在实施。好比一个菜鸟级别玩家挑战英雄难度副本，没有人带，精英怪就能秒杀你，还有很多小怪的各种围堵攻击。见BOSS都难，高级玩家都在玩竞速了，而我们就只能用失败的次数去堆积一次成功的可能。现实世界又没有外挂。&lt;/p&gt;
&lt;p&gt;说什么时间不够，能力不足，其实就是给自己推脱，一个借口罢了。在有限的时间里，能成长多少就是多少啊，可能你做成功的事情是别人早就会做的事了，但做成功了一件事不就是好事了。&lt;/p&gt;
&lt;p&gt;其实这就是我写给自己看的一篇感想文，心里一边想一边写的，写写改改，但又想有个人能给我指点迷津，才能走出如此的心理困境。也是因为看了&lt;a href=&quot;http://www.cnblogs.com/running-runtu/&quot; target=&quot;_blank&quot;&gt;闰土大叔&lt;/a&gt;的文章才有感而发的。&lt;br/&gt;个人不太会写文章啊。&lt;/p&gt;
&lt;p&gt;可能和我类似的人也有很多吧。不想去做太多对比。其实我很想要一个比较明确的规划，虽然有些晚，但希望2018年能找到，并坚持走下去。&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 11:52:00 +0000</pubDate>
<dc:creator>吴海瑞博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhairui/p/8443004.html</dc:identifier>
</item>
<item>
<title>CTP期货期权交易开发 - TuringM</title>
<link>http://www.cnblogs.com/dengchj/p/8442913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dengchj/p/8442913.html</guid>
<description>&lt;p&gt;综合交易平台（Comprehensive Transaction Platform，CTP）是专门为期货公司开发的一套期货经纪业务管理系统，由交易、风险控制和结算三大系统组成。其中，交易系统主要负责订单处理、行情转发及银期转账业务，系统能够同时连通国内四家期货交易所，支持国内商品期货和股指期货的交易结算业务，并能自动生成、报送保证金监控文件和反洗钱监控文件。&lt;/p&gt;
&lt;h2 id=&quot;一请求接口字段说明必要字段&quot;&gt;一、请求接口字段说明（必要字段）&lt;/h2&gt;
&lt;h3 id=&quot;登录&quot;&gt;1. 登录：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;broker_id:经纪公司代码&lt;/li&gt;
&lt;li&gt;investor_id:投资者代码&lt;/li&gt;
&lt;li&gt;pwd：密码&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;结算单确认&quot;&gt;2. 结算单确认：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;broker_id:经纪公司代码&lt;/li&gt;
&lt;li&gt;investor_id:投资者代码&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;报单录入&quot;&gt;3.报单录入：&lt;/h3&gt;
&lt;h4 id=&quot;必要字段说明&quot;&gt;3.1 必要字段说明&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;broker_id：经纪公司代码&lt;/li&gt;
&lt;li&gt;investor_id：投资者代码&lt;/li&gt;
&lt;li&gt;instrument_id：合约代码&lt;/li&gt;
&lt;li&gt;user_id：若是普通投资者，则同investor_id&lt;/li&gt;
&lt;li&gt;exchange_id：交易所代码&lt;/li&gt;
&lt;li&gt;order_price_type：报单价格条件,&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///任意价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_AnyPrice '1'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///限价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_LimitPrice '2'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最优价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_BestPrice '3'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_LastPrice '4'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价浮动上浮1个ticks&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_LastPricePlusOneTicks '5'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价浮动上浮2个ticks&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_LastPricePlusTwoTicks '6'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价浮动上浮3个ticks&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_LastPricePlusThreeTicks '7'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_AskPrice1 '8'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价浮动上浮1个ticks&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_AskPrice1PlusOneTicks '9'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价浮动上浮2个ticks&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_AskPrice1PlusTwoTicks 'A'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价浮动上浮3个ticks&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_AskPrice1PlusThreeTicks 'B'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_BidPrice1 'C'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价浮动上浮1个ticks&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_BidPrice1PlusOneTicks 'D'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价浮动上浮2个ticks&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_BidPrice1PlusTwoTicks 'E'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价浮动上浮3个ticks&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_BidPrice1PlusThreeTicks 'F'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///五档价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OPT_FiveLevelPrice 'G'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;direction：买卖方向,&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///买&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_D_Buy '0'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_D_Sell '1'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;comb_offset_flag：组合开平标志类型，只需填comb_offset_flag[0],&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///开仓&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OF_Open '0'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///平仓&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OF_Close '1'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///强平&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OF_ForceClose '2'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///平今&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OF_CloseToday '3'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///平昨&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OF_CloseYesterday '4'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///强减&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OF_ForceOff '5'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///本地强平&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_OF_LocalForceClose '6'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;comb_hedge_flag：组合投机套保标志，只需填comb_hedge_flag[0]，&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///投机&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_HFEN_Speculation '1'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///套利&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_HFEN_Arbitrage '2'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///套期保值&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_HFEN_Hedge '3'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;limit_price：价格&lt;/li&gt;
&lt;li&gt;volume_total_original：数量&lt;/li&gt;
&lt;li&gt;time_condition：有效期类型，如当日有效，&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///立即完成，否则撤销&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_TC_IOC '1'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///本节有效&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_TC_GFS '2'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///当日有效&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_TC_GFD '3'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///指定日期前有效&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_TC_GTD '4'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///撤销前有效&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_TC_GTC '5'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///集合竞价有效&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_TC_GFA '6'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;volume_condition：成交量类型，一般填任何数量，&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///任何数量&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_VC_AV '1'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最小数量&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_VC_MV '2'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///全部数量&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_VC_CV '3'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;min_volume：最小成交量1&lt;/li&gt;
&lt;li&gt;contingent_condition：触发条件，&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///立即&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_Immediately '1'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///止损&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_Touch '2'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///止赢&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_TouchProfit '3'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///预埋单&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_ParkedOrder '4'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价大于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_LastPriceGreaterThanStopPrice '5'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价大于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_LastPriceGreaterEqualStopPrice '6'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价小于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_LastPriceLesserThanStopPrice '7'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价小于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_LastPriceLesserEqualStopPrice '8'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价大于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_AskPriceGreaterThanStopPrice '9'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价大于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_AskPriceGreaterEqualStopPrice 'A'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价小于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_AskPriceLesserThanStopPrice 'B'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价小于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_AskPriceLesserEqualStopPrice 'C'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价大于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_BidPriceGreaterThanStopPrice 'D'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价大于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_BidPriceGreaterEqualStopPrice 'E'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价小于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_BidPriceLesserThanStopPrice 'F'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价小于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_BidPriceLesserEqualStopPrice 'H'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;force_close_reason：强平原因，一般填非强平，&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///立即&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_Immediately '1'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///止损&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_Touch '2'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///止赢&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_TouchProfit '3'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///预埋单&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_ParkedOrder '4'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价大于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_LastPriceGreaterThanStopPrice '5'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价大于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_LastPriceGreaterEqualStopPrice '6'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价小于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_LastPriceLesserThanStopPrice '7'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///最新价小于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_LastPriceLesserEqualStopPrice '8'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价大于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_AskPriceGreaterThanStopPrice '9'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价大于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_AskPriceGreaterEqualStopPrice 'A'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价小于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_AskPriceLesserThanStopPrice 'B'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///卖一价小于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_AskPriceLesserEqualStopPrice 'C'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价大于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_BidPriceGreaterThanStopPrice 'D'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价大于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_BidPriceGreaterEqualStopPrice 'E'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价小于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_BidPriceLesserThanStopPrice 'F'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///买一价小于等于条件价&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_CC_BidPriceLesserEqualStopPrice 'H'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;is_auto_suspend：自动挂起标志，1是，0否，一般填0&lt;/li&gt;
&lt;li&gt;user_force_close：用户强平标志，1是，0否，一般填0&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;特别说明&quot;&gt;3.2 特别说明&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如果发送立即限价单：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/// 报单价格条件类型：限价&lt;/span&gt;
OrderPriceType = THOST_FTDC_OPT_LimitPrice;
&lt;span class=&quot;co&quot;&gt;/// 价格：用户设定&lt;/span&gt;
LimitPrice = ……;
&lt;span class=&quot;co&quot;&gt;/// 有效期类型类型：当日有效&lt;/span&gt;
TimeCondition = THOST_FTDC_TC_GFD;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;如果发送立即市价单&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/// 报单价格条件类型：任意价&lt;/span&gt;
OrderPriceType = THOST_FTDC_OPT_AnyPrice;
&lt;span class=&quot;co&quot;&gt;///价格：0&lt;/span&gt;
LimitPrice = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;co&quot;&gt;///有效期类型类型：立即完成，否则撤销&lt;/span&gt;
TimeCondition = THOST_FTDC_TC_IOC;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;如果发送触发单&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///触发条件：用户设定&lt;/span&gt;
ContingentCondition = ……;
&lt;span class=&quot;co&quot;&gt;///止损价：用户设定&lt;/span&gt;
StopPrice = ……;
&lt;span class=&quot;co&quot;&gt;/// 报单价格条件类型：限价&lt;/span&gt;
OrderPriceType = THOST_FTDC_OPT_LimitPrice;
&lt;span class=&quot;co&quot;&gt;/// 价格：用户设定&lt;/span&gt;
LimitPrice = ……;
&lt;span class=&quot;co&quot;&gt;/// 有效期类型类型：当日有效&lt;/span&gt;
TimeCondition = THOST_FTDC_TC_GFD;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;关于平仓：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上期所区分昨仓和今仓。&lt;/p&gt;
&lt;p&gt;平昨仓时，开平标志类型设置为平仓THOST_FTDC_OF_Close&lt;/p&gt;
&lt;p&gt;平今仓时，开平标志类型设置为平今仓THOST_FTDC_OF_CloseToday&lt;/p&gt;
&lt;p&gt;其他交易所不区分昨仓和今仓。&lt;/p&gt;
&lt;p&gt;开平标志类型统一设置为平仓THOST_FTDC_OF_Close&lt;/p&gt;
&lt;h3 id=&quot;撤单&quot;&gt;4. 撤单：&lt;/h3&gt;
&lt;h4 id=&quot;必要字段填写&quot;&gt;4.1 必要字段填写&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;broker_id：经纪公司代码&lt;/li&gt;
&lt;li&gt;investor_id：投资者代码&lt;/li&gt;
&lt;li&gt;instrument_id：合约代码&lt;/li&gt;
&lt;li&gt;user_id：若是普通投资者，则同investor_id&lt;/li&gt;
&lt;li&gt;action_flag：只需填action_flag()[0],撤单THOST_FTDC_AF_Delete&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///删除&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_AF_Delete '0'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///修改&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_AF_Modify '3'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;特别说明-1&quot;&gt;4.2 特别说明&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;报单未在交易所须用（OrderRef+FrontID+SessionID）定位并撤单。&lt;/li&gt;
&lt;li&gt;报单停留在交易所，可用（OrderSysID+ExchangeID）定位并撤单。&lt;/li&gt;
&lt;li&gt;可只填写一个字段，但是&lt;code&gt;若填写字段，则必须正确&lt;/code&gt;，否则无法定位报单。&lt;/li&gt;
&lt;li&gt;以上报单定位字段可在报单通知、成交通知，或者查询报单、查询成交中获得。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;预埋单录入&quot;&gt;5. 预埋单录入：&lt;/h3&gt;
&lt;p&gt;仅在非交易时段报入并在新的交易时段开始时被触发并执行。&lt;/p&gt;
&lt;p&gt;字段参考普通下单，触发条件为预埋单类型。&lt;/p&gt;
&lt;h3 id=&quot;预埋撤单trade_parked_order_action_id-9004&quot;&gt;6. 预埋撤单：trade_parked_order_action_id = 9004&lt;/h3&gt;
&lt;p&gt;仅在非交易时段报入并在新的交易时段开始时被触发并执行。&lt;/p&gt;
&lt;p&gt;字段参考普通撤单。&lt;/p&gt;
&lt;h3 id=&quot;删除预埋单&quot;&gt;7. 删除预埋单：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;broker_id：经纪公司代码&lt;/li&gt;
&lt;li&gt;investor_id：投资者代码&lt;/li&gt;
&lt;li&gt;parked_order_id：预埋单编号&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;删除预埋撤单&quot;&gt;8. 删除预埋撤单：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;broker_id：经纪公司代码&lt;/li&gt;
&lt;li&gt;investor_id：投资者代码&lt;/li&gt;
&lt;li&gt;parked_order_action_id：预埋撤单编号&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;行权委托&quot;&gt;9. 行权委托：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;broker_id：经纪公司代码&lt;/li&gt;
&lt;li&gt;investor_id：投资者代码&lt;/li&gt;
&lt;li&gt;instrument_id：合约代码&lt;/li&gt;
&lt;li&gt;volume：数量&lt;/li&gt;
&lt;li&gt;offset_flag：offset_flag()[0]，开平标志&lt;/li&gt;
&lt;li&gt;hedge_flag：hedge_flag()[0],投机套保标志&lt;/li&gt;
&lt;li&gt;action_type：执行类型，&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///执行&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_ACTP_Exec '1'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///放弃&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_ACTP_Abandon '2'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;posi_direction:保留头寸申请的持仓方向,&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///净&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_PD_Net '1'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///多头&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_PD_Long '2'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///空头&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_PD_Short '3'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;reserve_position_flag:期权行权后是否保留期货头寸的标记，&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///保留&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_EOPF_Reserve '0'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///不保留&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_EOPF_UnReserve '1'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;close_flag：期权行权后生成的头寸是否自动平仓，&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;///自动平仓&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_EOCF_AutoClose '0'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;///免于自动平仓&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define THOST_FTDC_EOCF_NotToClose '1'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;撤销行权委托&quot;&gt;10.撤销行权委托：&lt;/h3&gt;
&lt;p&gt;参考普通撤单&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;broker_id：经纪公司代码&lt;/li&gt;
&lt;li&gt;investor_id：投资者代码&lt;/li&gt;
&lt;li&gt;instrument_id：合约代码&lt;/li&gt;
&lt;li&gt;user_id：若是普通投资者，则同investor_id&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;action_flag：只需填action_flag()[0],撤单THOST_FTDC_AF_Delete&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;exec_order_ref：执行宣告引用&lt;/li&gt;
&lt;li&gt;front_id：前置编号&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;session_id：会话编号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;exec_order_sys_id：执行宣告操作编号&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;exchange_id：交易所编号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;登出&quot;&gt;11. 登出：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;broker_id：经纪公司代码&lt;/li&gt;
&lt;li&gt;user_id：用户代码&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;条件单错误通知&quot;&gt;12. 条件单错误通知：&lt;/h3&gt;
&lt;h3 id=&quot;询价通知&quot;&gt;13. 询价通知：&lt;/h3&gt;
&lt;h3 id=&quot;合约交易状态通知&quot;&gt;14. 合约交易状态通知：&lt;/h3&gt;
&lt;h3 id=&quot;查询类&quot;&gt;15. 查询类：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;查询结算单确认信息：acct_qry_settle_comfirm&lt;/li&gt;
&lt;li&gt;查询结算单：acct_qry_settle_info&lt;/li&gt;
&lt;li&gt;查询投资者：acct_qry_investor&lt;/li&gt;
&lt;li&gt;查询报单：trade_qry_order&lt;/li&gt;
&lt;li&gt;查询成交：trade_qry_trade&lt;/li&gt;
&lt;li&gt;查询投资者持仓：trade_qry_investor_position&lt;/li&gt;
&lt;li&gt;查询投资者交易账户：trade_qry_trading_acct&lt;/li&gt;
&lt;li&gt;查询交易通知：trade_qry_trading_notice&lt;/li&gt;
&lt;li&gt;查询交易编号：trade_qry_trading_code&lt;/li&gt;
&lt;li&gt;查询合约保证金率：trade_qry_instr_margin_rate&lt;/li&gt;
&lt;li&gt;查询合约手续费率：trade_qry_instr_comm_rate&lt;/li&gt;
&lt;li&gt;查询交易所：trade_qry_exchange&lt;/li&gt;
&lt;li&gt;查询产品：trade_qry_product&lt;/li&gt;
&lt;li&gt;查询合约：trade_qry_instrument&lt;/li&gt;
&lt;li&gt;查询转账银行：trade_qry_transfer_bank&lt;/li&gt;
&lt;li&gt;查询投资者持仓明细：trade_qry_inv_pos_detail&lt;/li&gt;
&lt;li&gt;查询投资者组合持仓明细：trade_qry_inv_pos_comb_detail&lt;/li&gt;
&lt;li&gt;查询仓单折抵信息：trade_qry_ewarrant_offset&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;用户口令更新acct_user_pwd_update&quot;&gt;16. 用户口令更新：acct_user_pwd_update&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;broker_id&lt;/li&gt;
&lt;li&gt;user_id：用户代码&lt;/li&gt;
&lt;li&gt;old_password&lt;/li&gt;
&lt;li&gt;new_password&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;资金账户口令更新acct_trade_pwd_update&quot;&gt;17. 资金账户口令更新：acct_trade_pwd_update&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;broker_id&lt;/li&gt;
&lt;li&gt;account_id：投资者账号&lt;/li&gt;
&lt;li&gt;old_password&lt;/li&gt;
&lt;li&gt;new_password&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二ctp交易基本流程和通讯&quot;&gt;二、CTP交易基本流程和通讯&lt;/h2&gt;
&lt;p&gt;下面是大致流程图：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/723735/201802/723735-20180211182117826-1641004920.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通讯模式和数据流&quot;&gt;1. 通讯模式和数据流&lt;/h3&gt;
&lt;p&gt;期货交易数据换协议期货交易数据换协议（ Futures Trading Data Exchange Protocol，FTD），适用于期货交易系统与其下端交易客户端进行交易所需的数据交换和通讯。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对话通讯模式：客户端发起请求，类似C/S模式。&lt;/li&gt;
&lt;li&gt;私有通讯模式：交易系统主动向某个特定的客户端发送信息。例如报单回报。&lt;/li&gt;
&lt;li&gt;广播通讯模式：向所有客户端发出相同的信息。例如行情。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要订阅公有流和私。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公有流：交易所向连接着的客户端发布信息。 比如说合约场上状态公有流：交易所向连接着的客户端发布信息。比如说合约场上状态。&lt;/li&gt;
&lt;li&gt;私有流：交易所向特定客户端发送的信息。 如报单回报，成交回报。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般，CTP系统中对话模式下被返回的消息成为 响应 。而私有模式和广播下被返回的消息称为 回报 。&lt;/p&gt;
&lt;p&gt;每个数据流应该对应一种通讯模式，但是一个通讯模式可能有多个数据流。&lt;/p&gt;
&lt;h3 id=&quot;数据交换方式&quot;&gt;2.数据交换方式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;请求/应答方式：client发出请求，server收到应答。&lt;/li&gt;
&lt;li&gt;发布/订阅方式：发布者发布信息至主题，订阅者从主题订阅消息。发布者和订阅者相对独立，低耦合。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;其他待续&quot;&gt;其他待续&lt;/h2&gt;
</description>
<pubDate>Sun, 11 Feb 2018 10:59:00 +0000</pubDate>
<dc:creator>TuringM</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dengchj/p/8442913.html</dc:identifier>
</item>
<item>
<title>IOLI-crackme0x01-0x05 writeup - 有价值炮灰</title>
<link>http://www.cnblogs.com/pannengzhi/p/2018-02-11-ioli-crackme1-5.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pannengzhi/p/2018-02-11-ioli-crackme1-5.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/676200/201802/676200-20180211175524576-2052806714.png&quot; alt=&quot;Radare2&quot;/&gt;&lt;br/&gt;上一篇开了个头, &lt;a href=&quot;https://www.pppan.net/blog/detail/2018-02-09-play-with-radare2&quot;&gt;使用Radare2并用3中方法来解决crackme0x00&lt;/a&gt;, 由于是第一篇,&lt;br/&gt;所以解释得事无巨细, 今天就稍微加快点步伐, 分析一下另外几个crackme.&lt;/p&gt;
&lt;blockquote readability=&quot;6.0967741935484&quot;&gt;
&lt;p&gt;如果你忘记了crackme的来源, 那就再告诉你一遍, 它们都是来自&lt;a href=&quot;https://github.com/radare/radare2book/tree/master/crackmes/ioli/IOLI-crackme.tar.gz&quot;&gt;IOLI-crackme&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;直接用radare2打开分析:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x080483e4]&amp;gt; pdf @ main
            ;-- main:
/ (fcn) main 113
|   main ();
|           ; var int pInput @ ebp-0x4
|              ; DATA XREF from 0x08048347 (entry0)
|           0x080483e4      55             push ebp
|           0x080483e5      89e5           mov ebp, esp
|           0x080483e7      83ec18         sub esp, 0x18
|           0x080483ea      83e4f0         and esp, 0xfffffff0
|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf
|           0x080483f5      83c00f         add eax, 0xf
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
|           0x08048400      c70424288504.  mov dword [esp], str.IOLI_Crackme_Level_0x01 ; [0x8048528:4]=0x494c4f49 ; &quot;IOLI Crackme Level 0x01\n&quot;
|           0x08048407      e810ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804840c      c70424418504.  mov dword [esp], str.Password: ; [0x8048541:4]=0x73736150 ; &quot;Password: &quot;
|           0x08048413      e804ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x08048418      8d45fc         lea eax, [pInput]
|           0x0804841b      89442404       mov dword [esp + 4], eax
|           0x0804841f      c704244c8504.  mov dword [esp], 0x804854c  ; [0x804854c:4]=0x49006425
|           0x08048426      e8e1feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x0804842b      817dfc9a1400.  cmp dword [pInput], 0x149a  ; [0x149a:4]=-1
|       ,=&amp;lt; 0x08048432      740e           je 0x8048442
[0x080483e4]&amp;gt; ps @ 0x804854c
%d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是scanf获取用户输入, 不过这次是&lt;code&gt;%d&lt;/code&gt;即用户输入一个整数, 然后和0x149a比较, 使用rax2转换数据格式:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rax2 0x149a
5274&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./crackme0x01 
IOLI Crackme Level 0x01
Password: 5274
Password OK :)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;密码正确! 和crackme0x00差不多, 逻辑比较简单.&lt;/p&gt;

&lt;p&gt;先运行一下, 发现和之前一样还是要输入密码. radare2打开:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x080483e4]&amp;gt; pdf @ main
            ;-- main:
/ (fcn) main 144
|   main ();
|           ; var int local_ch @ ebp-0xc
|           ; var int local_8h @ ebp-0x8
|           ; var int local_4h @ ebp-0x4
|           ; var int local_4h_2 @ esp+0x4
|              ; DATA XREF from 0x08048347 (entry0)
|           0x080483e4      55             push ebp
|           0x080483e5      89e5           mov ebp, esp
|           0x080483e7      83ec18         sub esp, 0x18
|           0x080483ea      83e4f0         and esp, 0xfffffff0
|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf
|           0x080483f5      83c00f         add eax, 0xf
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
|           0x08048400      c70424488504.  mov dword [esp], str.IOLI_Crackme_Level_0x02 ; [0x8048548:4]=0x494c4f49 ; &quot;IOLI Crackme Level 0x02\n&quot;
|           0x08048407      e810ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804840c      c70424618504.  mov dword [esp], str.Password: ; [0x8048561:4]=0x73736150 ; &quot;Password: &quot;
|           0x08048413      e804ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x08048418      8d45fc         lea eax, [local_4h]
|           0x0804841b      89442404       mov dword [local_4h_2], eax
|           0x0804841f      c704246c8504.  mov dword [esp], 0x804856c  ; [0x804856c:4]=0x50006425
|           0x08048426      e8e1feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x0804842b      c745f85a0000.  mov dword [local_8h], 0x5a  ; 'Z' ; 90
|           0x08048432      c745f4ec0100.  mov dword [local_ch], 0x1ec ; 492
|           0x08048439      8b55f4         mov edx, dword [local_ch]
|           0x0804843c      8d45f8         lea eax, [local_8h]
|           0x0804843f      0110           add dword [eax], edx
|           0x08048441      8b45f8         mov eax, dword [local_8h]
|           0x08048444      0faf45f8       imul eax, dword [local_8h]
|           0x08048448      8945f4         mov dword [local_ch], eax
|           0x0804844b      8b45fc         mov eax, dword [local_4h]
|           0x0804844e      3b45f4         cmp eax, dword [local_ch]
|       ,=&amp;lt; 0x08048451      750e           jne 0x8048461
[0x080483e4]&amp;gt; ps @ 0x804856c
%d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个就比之前复杂一点, main函数有三个本地变量, &lt;code&gt;local_ch&lt;/code&gt;, &lt;code&gt;local_8h&lt;/code&gt;和&lt;code&gt;local_4h&lt;/code&gt;,&lt;br/&gt;但似乎没有初始值. 由&lt;code&gt;0x08048418~0x08048426&lt;/code&gt;这几句可以发现&lt;code&gt;local_4h&lt;/code&gt;是用户的输入,&lt;br/&gt;且类型为整数.&lt;br/&gt;分析一下用户输入后的逻辑, 先给两个本地变量分别赋值为0x5a和0x1ec, 然后进行数学运算,&lt;br/&gt;先改几个名字方便阅读:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x080483e4]&amp;gt; afv-local_4h_2
[0x080483e4]&amp;gt; afvn local_4h input
[0x080483e4]&amp;gt; afvn local_8h a
[0x080483e4]&amp;gt; afvn local_ch b
[0x080483e4]&amp;gt; pd 10 @ 0x0804842b
0x0804842b      c745f85a0000.  mov dword [a], 0x5a         ; 'Z' ; 90
0x08048432      c745f4ec0100.  mov dword [b], 0x1ec        ; 492
0x08048439      8b55f4         mov edx, dword [b]
0x0804843c      8d45f8         lea eax, [a]
0x0804843f      0110           add dword [eax], edx
0x08048441      8b45f8         mov eax, dword [a]
0x08048444      0faf45f8       imul eax, dword [a]
0x08048448      8945f4         mov dword [b], eax
0x0804844b      8b45fc         mov eax, dword [input]
0x0804844e      3b45f4         cmp eax, dword [b]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新打印scanf之后的10条汇编, 转换成伪代码大意是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int a = 0x5a
int b = 0x1ec
a = b + a
a = a * a
b = a
if input == b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以最后和input比较的是&lt;code&gt;(a+b)*(a+b)=582*582=338724&lt;/code&gt;, 验证一下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./crackme0x02 
IOLI Crackme Level 0x02
Password: 338724
Password OK :)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抬走, 下一个.&lt;/p&gt;

&lt;p&gt;流程和之前一样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./crackme0x03 
IOLI Crackme Level 0x03
Password: 12345
Invalid Password!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过这次似乎里面的字符串被混淆了, 没有找到&lt;code&gt;Invalid Password&lt;/code&gt;出现的地方:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rabin2 -z ./crackme0x03 
000 0x000005ec 0x080485ec  17  18 (.rodata) ascii Lqydolg#Sdvvzrug$
001 0x000005fe 0x080485fe  17  18 (.rodata) ascii Sdvvzrug#RN$$$#=,
002 0x00000610 0x08048610  24  25 (.rodata) ascii IOLI Crackme Level 0x03\n
003 0x00000629 0x08048629  10  11 (.rodata) ascii Password:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;radare2打开并分析main函数, 发现用户输入后调用了test函数, 如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...忽略
|           0x080484c0      c70424298604.  mov dword [esp], str.Password: ; [0x8048629:4]=0x73736150 ; &quot;Password: &quot;
|           0x080484c7      e884feffff     call sym.imp.printf         ; int printf(const char *format)
|           0x080484cc      8d45fc         lea eax, [local_4h]
|           0x080484cf      89442404       mov dword [local_4h_2], eax
|           0x080484d3      c70424348604.  mov dword [esp], 0x8048634  ; [0x8048634:4]=0x6425
|           0x080484da      e851feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x080484df      c745f85a0000.  mov dword [local_8h], 0x5a  ; 'Z' ; 90
|           0x080484e6      c745f4ec0100.  mov dword [local_ch], 0x1ec ; 492
|           0x080484ed      8b55f4         mov edx, dword [local_ch]
|           0x080484f0      8d45f8         lea eax, [local_8h]
|           0x080484f3      0110           add dword [eax], edx
|           0x080484f5      8b45f8         mov eax, dword [local_8h]
|           0x080484f8      0faf45f8       imul eax, dword [local_8h]
|           0x080484fc      8945f4         mov dword [local_ch], eax
|           0x080484ff      8b45f4         mov eax, dword [local_ch]
|           0x08048502      89442404       mov dword [local_4h_2], eax
|           0x08048506      8b45fc         mov eax, dword [local_4h]
|           0x08048509      890424         mov dword [esp], eax
|           0x0804850c      e85dffffff     call sym.test
|           0x08048511      b800000000     mov eax, 0
|           0x08048516      c9             leave
\           0x08048517      c3             ret
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;main函数内同样有三个本地变量, 面对这种多层调用的目标时候, 可以选择深度优先或者广度优先分析,&lt;br/&gt;这里选择深度优先, 即先分析&lt;code&gt;sym.test&lt;/code&gt;函数:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x08048498]&amp;gt; pdf @ sym.test
/ (fcn) sym.test 42
|   sym.test (int arg_8h, int arg_ch);
|           ; arg int arg_8h @ ebp+0x8
|           ; arg int arg_ch @ ebp+0xc
|              ; CALL XREF from 0x0804850c (sym.main)
|           0x0804846e      55             push ebp
|           0x0804846f      89e5           mov ebp, esp
|           0x08048471      83ec08         sub esp, 8
|           0x08048474      8b4508         mov eax, dword [arg_8h]     ; [0x8:4]=-1 ; 8
|           0x08048477      3b450c         cmp eax, dword [arg_ch]     ; [0xc:4]=-1 ; 12
|       ,=&amp;lt; 0x0804847a      740e           je 0x804848a
|       |   0x0804847c      c70424ec8504.  mov dword [esp], str.Lqydolg_Sdvvzrug ; [0x80485ec:4]=0x6479714c ; &quot;Lqydolg#Sdvvzrug$&quot;
|       |   0x08048483      e88cffffff     call sym.shift
|      ,==&amp;lt; 0x08048488      eb0c           jmp 0x8048496
|      |`-&amp;gt; 0x0804848a      c70424fe8504.  mov dword [esp], str.Sdvvzrug_RN ; [0x80485fe:4]=0x76766453 ; &quot;Sdvvzrug#RN$$$#=,&quot;
|      |    0x08048491      e87effffff     call sym.shift
|      |       ; JMP XREF from 0x08048488 (sym.test)
|      `--&amp;gt; 0x08048496      c9             leave
\           0x08048497      c3             ret&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到该函数接受2个参数, 值得一提的是根据(x86)cdecl调用约定, 函数参数通过栈传递,&lt;br/&gt;并且顺序为从右到左. 可以看到test函数中调用了shift函数, 接受1个字符串参数,&lt;br/&gt;估计是解密字符串相关的函数, 先看看它:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x08048498]&amp;gt; pdf @ sym.shift
/ (fcn) sym.shift 90
|   sym.shift (int arg_8h);
|           ; var int local_7ch @ ebp-0x7c
|           ; var int local_78h @ ebp-0x78
|           ; arg int arg_8h @ ebp+0x8
|           ; var int local_4h @ esp+0x4
|              ; CALL XREF from 0x08048491 (sym.test)
|              ; CALL XREF from 0x08048483 (sym.test)
|           0x08048414      55             push ebp
|           0x08048415      89e5           mov ebp, esp
|           0x08048417      81ec98000000   sub esp, 0x98
|           0x0804841d      c74584000000.  mov dword [local_7ch], 0
|              ; JMP XREF from 0x0804844e (sym.shift)
|       .-&amp;gt; 0x08048424      8b4508         mov eax, dword [arg_8h]     ; [0x8:4]=-1 ; 8
|       :   0x08048427      890424         mov dword [esp], eax
|       :   0x0804842a      e811ffffff     call sym.imp.strlen         ; size_t strlen(const char *s)
|       :   0x0804842f      394584         cmp dword [local_7ch], eax  ; [0x13:4]=-1 ; 19
|      ,==&amp;lt; 0x08048432      731c           jae 0x8048450
|      |:   0x08048434      8d4588         lea eax, [local_78h]
|      |:   0x08048437      89c2           mov edx, eax
|      |:   0x08048439      035584         add edx, dword [local_7ch]
|      |:   0x0804843c      8b4584         mov eax, dword [local_7ch]
|      |:   0x0804843f      034508         add eax, dword [arg_8h]
|      |:   0x08048442      0fb600         movzx eax, byte [eax]
|      |:   0x08048445      2c03           sub al, 3
|      |:   0x08048447      8802           mov byte [edx], al
|      |:   0x08048449      8d4584         lea eax, [local_7ch]
|      |:   0x0804844c      ff00           inc dword [eax]
|      |`=&amp;lt; 0x0804844e      ebd4           jmp 0x8048424
|      `--&amp;gt; 0x08048450      8d4588         lea eax, [local_78h]
|           0x08048453      034584         add eax, dword [local_7ch]
|           0x08048456      c60000         mov byte [eax], 0
|           0x08048459      8d4588         lea eax, [local_78h]
|           0x0804845c      89442404       mov dword [local_4h], eax
|           0x08048460      c70424e88504.  mov dword [esp], 0x80485e8  ; [0x80485e8:4]=0xa7325
|           0x08048467      e8e4feffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804846c      c9             leave
\           0x0804846d      c3             ret&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到shift的作用是&lt;code&gt;接受一个字符串-&amp;gt;处理-&amp;gt;printf&lt;/code&gt;, 其实我们可以不用分析shift函数的逻辑,&lt;br/&gt;因为开启gdb一调就知道在test函数中哪个分支是&quot;Password OK&quot;了, 甚至都不用调试, 因为一共就2个分支,&lt;br/&gt;非此即彼, 但秉承着&lt;code&gt;知易行难&lt;/code&gt;的原则, 还是分析了一遍, shift函数伪代码如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; shift(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *src) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i;
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; dst[N];
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; strlen(src); i++) {
        dst[i] = src[i] - &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
    }
    dst[i] = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, dst);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写个python脚本验证下之前rabin2发现&lt;code&gt;.rodata&lt;/code&gt;段的两个字符串解密:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode py&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# /usr/bin/env python2&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# shift.py&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; shift(src):
    dst &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; src:
        dst.append(&lt;span class=&quot;bu&quot;&gt;chr&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;ord&lt;/span&gt;(i)&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;))
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;.join(dst))
shift(&lt;span class=&quot;st&quot;&gt;'Lqydolg#Sdvvzrug$'&lt;/span&gt;)
shift(&lt;span class=&quot;st&quot;&gt;'Sdvvzrug#RN$$$#=,'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python shift.py
Invalid Password!
Password OK!!! :)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK, 现在回到test函数, 这个函数比较简单, 接受2个参数, 如果第二个参数等于第一个参数,&lt;br/&gt;则进入我们想要的分支.&lt;br/&gt;再回到main函数, scanf接受一个整数input, 然后进行数学运算, 如下(重命名了一些变量名称):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0x080484df      c745f85a0000.  mov dword [a], 0x5a         ; 'Z' ; 90
0x080484e6      c745f4ec0100.  mov dword [b], 0x1ec        ; 492
0x080484ed      8b55f4         mov edx, dword [b]
0x080484f0      8d45f8         lea eax, [a]
0x080484f3      0110           add dword [eax], edx
0x080484f5      8b45f8         mov eax, dword [a]
0x080484f8      0faf45f8       imul eax, dword [a]
0x080484fc      8945f4         mov dword [b], eax
0x080484ff      8b45f4         mov eax, dword [b]
0x08048502      89442404       mov dword [esp + 4], eax
0x08048506      8b45fc         mov eax, dword [input]
0x08048509      890424         mov dword [esp], eax
0x0804850c      e85dffffff     call sym.test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转化为人类语言就是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int a = 0x5a, b = 0x1ec;
a = a + b;
b = a * a;
test(input, b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好吧, 结果还是要用输入和&lt;code&gt;(0x5a*0x1ec)^2=338724&lt;/code&gt;比较, 若相等则通过, 验证下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./crackme0x03 
IOLI Crackme Level 0x03
Password: 338724
Password OK!!! :)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;密码和上一题一样, 囧~&lt;/p&gt;

&lt;p&gt;老样子, 直接跳转到main函数然后查看汇编:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x08048509]&amp;gt; pdf @ main
...
0x08048528      c704245e8604.  mov dword [esp], str.IOLI_Crackme_Level_0x04 ; [0x804865e:4]=0x494c4f49 ; &quot;IOLI Crackme Level 0x04\n&quot;
0x0804852f      e860feffff     call sym.imp.printf         ; int printf(const char *format)
0x08048534      c70424778604.  mov dword [esp], str.Password: ; [0x8048677:4]=0x73736150 ; &quot;Password: &quot;
0x0804853b      e854feffff     call sym.imp.printf         ; int printf(const char *format)
0x08048540      8d4588         lea eax, [local_78h]
0x08048543      89442404       mov dword [local_4h], eax
0x08048547      c70424828604.  mov dword [esp], 0x8048682  ; [0x8048682:4]=0x7325
0x0804854e      e821feffff     call sym.imp.scanf          ; int scanf(const char *format)
0x08048553      8d4588         lea eax, [local_78h]
0x08048556      890424         mov dword [esp], eax
0x08048559      e826ffffff     call sym.check
...
[0x08048509]&amp;gt; ps @ 0x8048682
%s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这回main函数挺简单, 主要是scanf输入一个字符串, 然后调用check函数, 汇编如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x080484fb]&amp;gt; pdf @ sym.check
/ (fcn) sym.check 133
|   sym.check (char *input);
|           ; var int local_dh @ ebp-0xd
|           ; var int local_ch @ ebp-0xc
|           ; var int local_8h @ ebp-0x8
|           ; var int local_4h @ ebp-0x4
|           ; arg char * input @ ebp+0x8
|              ; CALL XREF from 0x08048559 (sym.main)
|           0x08048484      55             push ebp
|           0x08048485      89e5           mov ebp, esp
|           0x08048487      83ec28         sub esp, 0x28               ; '('
|           0x0804848a      c745f8000000.  mov dword [local_8h], 0
|           0x08048491      c745f4000000.  mov dword [local_ch], 0
|              ; JMP XREF from 0x080484f9 (sym.check)
|       .-&amp;gt; 0x08048498      8b4508         mov eax, dword [input]      ; [0x8:4]=-1 ; 8
|       :   0x0804849b      890424         mov dword [esp], eax
|       :   0x0804849e      e8e1feffff     call sym.imp.strlen         ; size_t strlen(const char *s)
|       :   0x080484a3      3945f4         cmp dword [local_ch], eax   ; [0x13:4]=-1 ; 19
|      ,==&amp;lt; 0x080484a6      7353           jae 0x80484fb
|      |:   0x080484a8      8b45f4         mov eax, dword [local_ch]
|      |:   0x080484ab      034508         add eax, dword [input]
|      |:   0x080484ae      0fb600         movzx eax, byte [eax]
|      |:   0x080484b1      8845f3         mov byte [local_dh], al
|      |:   0x080484b4      8d45fc         lea eax, [local_4h]
|      |:   0x080484b7      89442408       mov dword [esp + 8], eax
|      |:   0x080484bb      c74424043886.  mov dword [esp + 4], 0x8048638 ; [0x8048638:4]=0x50006425
|      |:   0x080484c3      8d45f3         lea eax, [local_dh]
|      |:   0x080484c6      890424         mov dword [esp], eax
|      |:   0x080484c9      e8d6feffff     call sym.imp.sscanf         ; int sscanf(const char *s, const char *format,   ...)
|      |:   0x080484ce      8b55fc         mov edx, dword [local_4h]
|      |:   0x080484d1      8d45f8         lea eax, [local_8h]
|      |:   0x080484d4      0110           add dword [eax], edx
|      |:   0x080484d6      837df80f       cmp dword [local_8h], 0xf   ; [0xf:4]=-1 ; 15
|     ,===&amp;lt; 0x080484da      7518           jne 0x80484f4
|     ||:   0x080484dc      c704243b8604.  mov dword [esp], str.Password_OK ; [0x804863b:4]=0x73736150 ; &quot;Password OK!\n&quot;
|     ||:   0x080484e3      e8acfeffff     call sym.imp.printf         ; int printf(const char *format)
|     ||:   0x080484e8      c70424000000.  mov dword [esp], 0
|     ||:   0x080484ef      e8c0feffff     call sym.imp.exit           ; void exit(int status)
|     ||:      ; JMP XREF from 0x080484da (sym.check)
|     `---&amp;gt; 0x080484f4      8d45f4         lea eax, [local_ch]
|      |:   0x080484f7      ff00           inc dword [eax]
|      |`=&amp;lt; 0x080484f9      eb9d           jmp 0x8048498
|      |       ; JMP XREF from 0x080484a6 (sym.check)
|      `--&amp;gt; 0x080484fb      c70424498604.  mov dword [esp], str.Password_Incorrect ; [0x8048649:4]=0x73736150 ; &quot;Password Incorrect!\n&quot;
|           0x08048502      e88dfeffff     call sym.imp.printf         ; int printf(const char *format)
|           0x08048507      c9             leave
\           0x08048508      c3             ret&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个函数比之前的复杂一点, 所以我们用视图模式先有个大局观:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x08048484]&amp;gt; VV @ sym.check
[0x08048484]&amp;gt; VV @ sym.check (nodes 6 edges 6 zoom 100%) BB-SUMM mouse:canvas-y mov-speed:5                 


                                       .--------------------.                              
                                       |  0x8048484 ;[ga]   |                              
                                       `--------------------'                              
                                           |                                               
                                        .--'                                               
 .--------------------------------------.                                                  
 |                                      |                                                  
 |                                      |                                                  
 |                                  .---------------------------.                          
 |                                  |  0x8048498 ;[gd]          |                          
 |                                  | 0x0804849e sym.imp.strlen |                          
 |                                  `---------------------------'                          
 |                                          | |                                            
 |                                          | '---------.                                  
 |                        .-----------------'           |                                  
 |                        |                             |                                  
 |                        |                             |                                  
 |                .---------------------------.   .-----------------------------------.    
 |                |  0x80484a8 ;[gg]          |   | [0x80484fb] ;[gc]                 |    
 |                | 0x080484c9 sym.imp.sscanf |   | 0x080484fb str.Password_Incorrect |    
 |                `---------------------------'   | 0x08048502 sym.imp.printf         |    
 |                        | |                     `-----------------------------------'    
 |                        | |                                                              
 |                        | '-------------.                                                
 |        .---------------'               |                                                
 |        |                               |                                                
 |        |                               |                                                
 |.----------------------------.    .--------------------.                                 
 ||  0x80484dc ;[gj]           |    |  0x80484f4 ;[gf]   |                                 
 || 0x080484dc str.Password_OK |    `--------------------'                                 
 || 0x080484e3 sym.imp.printf  |        |                                                  
 || 0x080484ef sym.imp.exit    |        |                                                  
 |`----------------------------'        |                                                  
 |                                      |                                                  
 `--------------------------------------'              &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;radare2在视图模式下可以通过p/P切换视图, 通过O切换asm的类型.&lt;br/&gt;直接按&lt;code&gt;?&lt;/code&gt;键可以查看快捷键的帮助.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们F5一下, 噢忘了没有F5, 那就人肉反编译一下, check函数有4个本地变量,&lt;br/&gt;但还不知道他们的作用, 有一个参数我已经改成了&lt;code&gt;char *input&lt;/code&gt;, 先来个伪代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;local_8h = 0, local_ch = 0;
BEGIN:
if (local_ch &amp;gt;= strlen(input)) {
    printf(&quot;Password Incorrect!\n&quot;);
    return;
}
eax = input + local_ch;
eax = (int)*eax;
(char*)&amp;amp;local_dh[0] = eax;
sscanf(local_dh, &quot;%d&quot;, local_4h);
local_8h = local_4h + local_8h;
if (local_8h != 0xf) {
    local_ch ++;
    goto BEGIN;
}
printf(&quot;Password OK!\n&quot;);
return;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要注意&lt;code&gt;mov byte [local_dh], al&lt;/code&gt;的意思是把eax中的最低字节移动到&lt;code&gt;local_dh&lt;/code&gt;&lt;br/&gt;的第一字节. 也就是说, check对输入的字符串的每个字节都进行sscanf扫描, 如果是个整数&lt;br/&gt;就累加&lt;code&gt;local_8h&lt;/code&gt;里, 只要其等于0xf(=15), 则通过, 所以密码可以有多个, 最简单就是15个1:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./crackme0x04 
IOLI Crackme Level 0x04
Password: 111111111111111
Password OK!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只要满足条件都可以, 比如最短的9+6=15:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./crackme0x04 
IOLI Crackme Level 0x04
Password: 96
Password OK!&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这题和0x04一样, 都是用户输入一个字符串, 然后调用check, 但是check函数有所不同:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x080484c8]&amp;gt; VV @ sym.check (nodes 7 edges 8 zoom 100%) BB-SUMM mouse:canvas-y mov-speed:5                 

                       .--------------------.                                                            
                       |  0x80484c8 ;[ga]   |                                                            
                       `--------------------'                                                            
                           |                                                                             
                        .--'                                                                             
 .----------------------.                                                                                
 |                      |                                                                                
 |                      |                                                                                
 |                  .---------------------------.                                                        
 |                  |  0x80484dc ;[gd]          |                                                        
 |                  | 0x080484e2 sym.imp.strlen |                                                        
 |                  `---------------------------'                                                        
 |                          | |                                                                          
 |                          | '---------.                                                                
 |        .-----------------'           |                                                                
 |        |                             |                                                                
 |        |                             |                                                                
 |.---------------------------.   .-----------------------------------.                                  
 ||  0x80484ec ;[gg]          |   | [0x8048532] ;[gc]                 |                                  
 || 0x0804850d sym.imp.sscanf |   | 0x08048532 str.Password_Incorrect |                                  
 |`---------------------------'   | 0x08048539 sym.imp.printf         |                                  
 |        | |                     `-----------------------------------'                                  
 |        | |                                                                                            
 |        | '---------------------------------------------------------.                                  
 |        '-.                                                         |                                  
 |          |                                                         |                                  
 |          |                                                         |                                  
 |  .-----------------------.                                         |                                  
 |  |  0x8048520 ;[gi]      |                                         |                                  
 |  | 0x08048526 sym.parell |                                         |                                  
 |  `-----------------------'                                         |                                  
 |      |                                                             |                                  
 |      '---------------------------.                                 |                                  
 |                                  | .-------------------------------'                                  
 |                                  | |                                                                  
 |                                  | |
 |                              .--------------------.                                                   
 |                              |  0x804852b ;[gf]   |                                                   
 |                              `--------------------'                                                   
 |                                  |                                                                    
 `----------------------------------'                                                                    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们待会再来看它, check函数里还调用了parell函数, 其流程图如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x08048484]&amp;gt; VV @ sym.parell (nodes 3 edges 2 zoom 100%) BB-NORM mouse:canvas-y mov-speed:5                

                .---------------------------------------------.                                             
                | [0x8048484] ;[gc]                           |                                             
                | (fcn) sym.parell 68                         |                                             
                |   sym.parell (int arg_8h);                  |
                | ; var int local_4h @ ebp-0x4                |                                             
                | ; arg int arg_8h @ ebp+0x8                  |                                             
                |    ; CALL XREF from 0x08048526 (sym.check)  |                                             
                | push ebp                                    |                                             
                | mov ebp, esp                                |                                             
                | sub esp, 0x18                               |                                             
                | lea eax, [local_4h]                         |                                             
                | mov dword [esp + 8], eax                    |                                             
                | mov dword [esp + 4], 0x8048668              |                                             
                | mov eax, dword [arg_8h]                     |                                             
                | mov dword [esp], eax                        |                                             
                | call sym.imp.sscanf;[ga]                    |                                             
                | mov eax, dword [local_4h]                   |                                             
                | and eax, 1                                  |                                             
                | test eax, eax                               |                                             
                | jne 0x80484c6;[gb]                          |                                             
                `---------------------------------------------'                                             
                        | |                                                                                 
                        | '-------------------------.                                                       
          .-------------'                           |                                                       
          |                                         |                                                       
  .--------------------------------------.    .--------------------.                                        
  |  0x80484ae ;[gf]                     |    |  0x80484c6 ;[gb]   |                                        
  |   ; [0x804866b:4]=0x73736150         |    | leave              |                                        
  |   ; &quot;Password OK!\n&quot;                 |    | ret                |                                        
  | mov dword [esp], str.Password_OK     |    `--------------------'                                        
  | call sym.imp.printf;[gd]             |                                                                  
  | mov dword [esp], 0                   |                                                                  
  | call sym.imp.exit;[ge]               |                                                                  
  `--------------------------------------'                                      &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其接受一个参数, 并且经过一顿操作后选择静默返回或者进入正确分支并退出程序.&lt;br/&gt;试着写下伪代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void parrel(arg) {
    int local_4h;
    sscanf(arg, &quot;%d&quot;, &amp;amp;local_4h);
    local_4h &amp;amp;= 1; // 除了最后一位全部清0
    if (local_4h != 0) {
        return;
    }
    printf(&quot;Password_OK\n&quot;);
    exit(0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以猜测arg应该是&lt;code&gt;char *&lt;/code&gt;类型, 该函数意思是将输入转化为整数, 如果结果的最低有效位为1则通过.&lt;br/&gt;现在可以回到check函数了. 该函数有4个本地变量, 姑且先将其命名为a,b,c,d:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/ (fcn) sym.check 120
|   sym.check (int input);
|           ; var int a @ ebp-0xd
|           ; var int b @ ebp-0xc
|           ; var int c @ ebp-0x8
|           ; var int d @ ebp-0x4
|           ; arg int input @ ebp+0x8
|              ; CALL XREF from 0x08048590 (sym.main)
|           0x080484c8      55             push ebp
|           0x080484c9      89e5           mov ebp, esp
|           0x080484cb      83ec28         sub esp, 0x28               ; '('
|           0x080484ce      c745f8000000.  mov dword [c], 0
|           0x080484d5      c745f4000000.  mov dword [b], 0
|              ; JMP XREF from 0x08048530 (sym.check)
|       .-&amp;gt; 0x080484dc      8b4508         mov eax, dword [input]      ; [0x8:4]=-1 ; 8
|       :   0x080484df      890424         mov dword [esp], eax
|       :   0x080484e2      e89dfeffff     call sym.imp.strlen         ; size_t strlen(const char *s)
|       :   0x080484e7      3945f4         cmp dword [b], eax          ; [0x13:4]=-1 ; 19
|      ,==&amp;lt; 0x080484ea      7346           jae 0x8048532
|      |:   0x080484ec      8b45f4         mov eax, dword [b]
|      |:   0x080484ef      034508         add eax, dword [input]
|      |:   0x080484f2      0fb600         movzx eax, byte [eax]
|      |:   0x080484f5      8845f3         mov byte [a], al
|      |:   0x080484f8      8d45fc         lea eax, [d]
|      |:   0x080484fb      89442408       mov dword [esp + 8], eax
|      |:   0x080484ff      c74424046886.  mov dword [esp + 4], 0x8048668 ; [0x8048668:4]=0x50006425
|      |:   0x08048507      8d45f3         lea eax, [a]
|      |:   0x0804850a      890424         mov dword [esp], eax
|      |:   0x0804850d      e892feffff     call sym.imp.sscanf         ; int sscanf(const char *s, const char *format,   ...)
|      |:   0x08048512      8b55fc         mov edx, dword [d]
|      |:   0x08048515      8d45f8         lea eax, [c]
|      |:   0x08048518      0110           add dword [eax], edx
|      |:   0x0804851a      837df810       cmp dword [c], 0x10         ; [0x10:4]=-1 ; 16
|     ,===&amp;lt; 0x0804851e      750b           jne 0x804852b
|     ||:   0x08048520      8b4508         mov eax, dword [input]      ; [0x8:4]=-1 ; 8
|     ||:   0x08048523      890424         mov dword [esp], eax
|     ||:   0x08048526      e859ffffff     call sym.parell
|     `---&amp;gt; 0x0804852b      8d45f4         lea eax, [b]
|      |:   0x0804852e      ff00           inc dword [eax]
|      |`=&amp;lt; 0x08048530      ebaa           jmp 0x80484dc
|      `--&amp;gt; 0x08048532      c70424798604.  mov dword [esp], str.Password_Incorrect ; [0x8048679:4]=0x73736150 ; &quot;Password Incorrect!\n&quot;
|           0x08048539      e856feffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804853e      c9             leave
\           0x0804853f      c3             ret&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到有个反向的跳转, 所以b应该是个循环变量, 重命名为i, 写下伪代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int c = 0;
int i = 0;
int d;
char a[2];
while(1) {
    if (i &amp;gt;= strlen(input)) {
        printf(&quot;Password Incorrect!\n&quot;);
        return;
    }
    (char*)a[0] = input[i];
    (char*)a[1] = 0;
    sscanf(a,&quot;%d&quot;,&amp;amp;d);
    c += d;
    if (c==0x10) {
        parell(input)
    }
    i++;
    continue;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;呃...写得有点渣, 不过能看明白逻辑就行了, 意思就是将输入的每个字符转为整数并累加,&lt;br/&gt;如果累加的结果等于16(0x10)则调用parell函数, 前面分析了parrel的作用是将整个字符串&lt;br/&gt;转换为整数, 并判断其最低有效位是否是0(即该数字是否为偶数), 是偶数则通过.&lt;br/&gt;所以我们要输入的密码应该是个偶数, 而且前X位加起来是16就可以了:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./crackme0x05
IOLI Crackme Level 0x05
Password: 88
Password OK!
$ ./crackme0x05
IOLI Crackme Level 0x05
Password: 88666
Password OK!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完美解决!&lt;/p&gt;

&lt;p&gt;说实话我一开始对汇编还不是很熟悉, 但动手写了几个writeup之后也逐渐有了点感觉.&lt;br/&gt;对于不熟悉的指令, 比如&lt;code&gt;movzx&lt;/code&gt;等可以查看X86的手册, 比如这里:&lt;a href=&quot;http://www.jegerlehner.ch/intel/opcode.html&quot;&gt;Opcode of programming language&lt;/a&gt;,&lt;br/&gt;而对于不熟悉的语法, 比如&lt;code&gt;Size Directives&lt;/code&gt;或者&lt;code&gt;Calling Conventions&lt;/code&gt;, 可以参考&lt;a href=&quot;https://www.cs.virginia.edu/~evans/cs216/guides/x86.html&quot;&gt;x86 Assembly Guide&lt;/a&gt;&lt;br/&gt;以及维基百科. 总之, 熟能生巧, 汇编也不是那么可怕嘛!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;欢迎交流分享, 转载请注明出处&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Feb 2018 10:00:00 +0000</pubDate>
<dc:creator>有价值炮灰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pannengzhi/p/2018-02-11-ioli-crackme1-5.html</dc:identifier>
</item>
</channel>
</rss>