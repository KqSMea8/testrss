<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>环境变量方式使用 Secret - 每天5分钟玩转 Docker 容器技术（158） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8905466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8905466.html</guid>
<description>&lt;p&gt;&lt;span&gt;通过 Volume 使用 Secret，容器必须从文件读取数据，会稍显麻烦，Kubernetes 还支持通过环境变量使用 Secret。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Pod 配置文件示例如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180422063601264-1153460033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建 Pod 并读取 Secret。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180422063610818-1485153781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过环境变量 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SECRET_USERNAME&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SECRET_PASSWORD&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 成功读取到 Secret 的数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要注意的是，环境变量读取 Secret 很方便，但无法支撑 Secret 动态更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Secret 可以为 Pod 提供密码、Token、私钥等敏感数据；对于一些非敏感数据，比如应用的配置信息，则可以用 ConfigMap。下一节我们学习 ConfigMap。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;书籍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Kubernetes》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/26225745440.html&quot;&gt;https://item.jd.com/26225745440.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171205-1512465642434079417.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 22:03:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8905466.html</dc:identifier>
</item>
<item>
<title>Python基础学习（第三周） - 近视的boy</title>
<link>http://www.cnblogs.com/jsaon-li/p/8912623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jsaon-li/p/8912623.html</guid>
<description>&lt;p&gt;集合是一个无序的，不重复的数据组合，它的主要作用如下：&lt;/p&gt;
&lt;p&gt;去重，把一个列表变成集合，就自动去重了&lt;/p&gt;
&lt;p&gt;关系测试，测试两组数据之间的交集，差集，并集等关系&lt;/p&gt;
&lt;h2&gt;集合的写法&lt;/h2&gt;
&lt;p&gt;list_1 = set([1, 3, 4, 6, 7, 12, 5])&lt;/p&gt;
&lt;h2&gt;集合的关系&lt;/h2&gt;
&lt;p&gt;list_1 = set([1, 3, 5, 7, 4, 9, 10])&lt;/p&gt;
&lt;p&gt;list_2 = set([1, 8, 10, 15, 12])&lt;/p&gt;
&lt;h3&gt;集合的交集&lt;/h3&gt;
&lt;p&gt;print(list_1.intersection(list_2)) 等价于 print(list_1 &amp;amp; list_2)&lt;/p&gt;
&lt;p&gt;---&amp;gt;{1, 10}&lt;/p&gt;
&lt;h3&gt;集合的并集&lt;/h3&gt;
&lt;p&gt;print(list_1.union(list_2)) 等价于 print(list_1 | list_2)&lt;/p&gt;
&lt;p&gt;--&amp;gt;{1, 3, 5, 7, 8, 4, 9, 10, 15, 12}&lt;/p&gt;
&lt;h3&gt;集合的差集&lt;/h3&gt;
&lt;p&gt;print(list_1.difference(list_2)) 等价于 print(list_1 - list_2)&lt;/p&gt;
&lt;p&gt;--&amp;gt;{3, 5, 7, 4, 9}&lt;/p&gt;
&lt;h3&gt;集合的子集&lt;/h3&gt;
&lt;p&gt;print(list_1.issubset(list_2))&lt;/p&gt;
&lt;p&gt;list_1是否是list_2的子集&lt;/p&gt;
&lt;h3&gt;集合的父集&lt;/h3&gt;
&lt;p&gt;print(list_1.issuprset(list_2))&lt;/p&gt;
&lt;p&gt;list_1是否是list_2的父集&lt;/p&gt;
&lt;h3&gt;集合的对称差集&lt;/h3&gt;
&lt;p&gt;print(list_1.symmetric_difference(list_2)) 等价于 list_1 ^ list_2&lt;/p&gt;
&lt;p&gt;--&amp;gt;{3, 5, 7, 4, 9, 8, 15, 12}&lt;/p&gt;
&lt;h2&gt;集合的其他函数用法&lt;/h2&gt;
&lt;p&gt;list_2.isdisjoint(list_3) #两个无交集返回true&lt;/p&gt;
&lt;p&gt;list_1.add(4) #集合的添加&lt;/p&gt;
&lt;p&gt;list_1.remove(4) #集合的删除，&lt;span&gt;注意当集合中没有该元素会报错所以我们更多用下这个删除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;list_1,discard(4) #删除，没有该元素则什么都不操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;&lt;span&gt;文件的操作流程&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.打开文件，得到文件句柄并赋给变量一个值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.通过句柄对文件进行操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.关闭文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;f = open(&quot;guangzhou&quot;， &quot;r&quot;, encoding = &quot;utf-8&quot;) #文件句柄&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;data = f.read() #f.readline()读取一行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;f.close()&lt;/p&gt;
&lt;p&gt;这样就把整个文件给读出来了，假如read()两遍，那么第二个read()会读出空的内容，因为当第一个read()执行完成后，这个时候光标位置就处在文件的结束位置，再进行读取的时候也就读不到内容了。&lt;/p&gt;
&lt;h2&gt;文件的操作模式&lt;/h2&gt;
&lt;h3&gt;r:读模式，默认是读模式&lt;/h3&gt;
&lt;p&gt;open(&quot;guangzhou&quot;， &quot;r&quot;, encoding = &quot;utf-8&quot;) &lt;/p&gt;
&lt;h3&gt;w:写模式，打开文件时时创建一个文件，也就是原来的文件没有了&lt;/h3&gt;
&lt;p&gt;open(&quot;guangzhou&quot;， &quot;w&quot;, encoding = &quot;utf-8&quot;)  &lt;/p&gt;
&lt;h3&gt;a:追加模式&lt;/h3&gt;
&lt;p&gt;open(&quot;guangzhou&quot;， &quot;a&quot;, encoding = &quot;utf-8&quot;)  只是不覆盖文件，在文件的后面追加内容，这个模式还不支持读read&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;r+:读写模式，以读和追加的方式来读写，不管光标位置在哪，都在最后面写&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;w+：写读模式，只能在最后面写，不能写到中间，这是硬盘机制&lt;/h3&gt;
&lt;h3&gt;a+:追加读&lt;/h3&gt;
&lt;h3&gt;rb:二进制读，用途网路传输，读取音频视频文件&lt;/h3&gt;
&lt;h3&gt;wb:二进制写&lt;/h3&gt;
&lt;h2&gt;文件从一个文件读取并改变内容保存到另外一个文件&lt;/h2&gt;
&lt;p&gt;f = open(&quot;guangzhou&quot;, &quot;r&quot;, encoding = &quot;utf-8&quot;)&lt;br/&gt;f_new = open(&quot;guanghzou3&quot;, &quot;w&quot;, encoding = &quot;utf-8&quot;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#循环读取文件，且这种效率最高，比readlines()高好多&lt;/span&gt;&lt;br/&gt;for line in f:&lt;br/&gt;　　if &quot;人在广东已经漂泊十年&quot; in line:&lt;br/&gt;　　line = line.replace(&quot;人在广东已经漂泊十年&quot;, &quot;Jason在广东已经漂泊两年&quot;)&lt;br/&gt;　　f_new.write(line)&lt;br/&gt;f.close()&lt;br/&gt;f_new.close()&lt;/p&gt;
&lt;h2&gt;文件的其他方法&lt;/h2&gt;
&lt;p&gt;f = open(&quot;guangzhou&quot;， &quot;r&quot;, encoding = &quot;utf-8&quot;)&lt;/p&gt;
&lt;p&gt;f.tell() #返回光标的位置,该返回的位置是字符的位置&lt;/p&gt;
&lt;p&gt;f.seek(0) #回到某个光标位置&lt;/p&gt;
&lt;h3&gt;flush方法&lt;/h3&gt;
&lt;p&gt;当我们在以写文件的方式打开一个文件的时候，我们执行完一条语句write并不一定写到了硬盘上，它是先存到了内存中，当内存达到一定大小的时候才开始往硬盘上面写，这是因为内存的写速度要比硬盘快的多，但是当某些特定条件下需要实时刷新的话，我们就要用flush进行强制刷新，比如进度条，下面的例子：&lt;/p&gt;
&lt;p&gt;import sys, time&lt;/p&gt;&lt;p&gt;for i in range(20):&lt;br/&gt;　　sys.stdout.write(&quot;*&quot;)&lt;br/&gt;　　sys.stdout.flush()&lt;br/&gt;　　time.sleep(0.1)&lt;/p&gt;
&lt;p&gt;自己可以执行下看一下&lt;/p&gt;
&lt;h2&gt;with语句&lt;/h2&gt;
&lt;p&gt;为了避免文件打开后忘记关闭，可以通过管理上下文，即：&lt;/p&gt;
&lt;p&gt;with open(&quot;guangzhou&quot;, &quot;r&quot;) as f:&lt;/p&gt;
&lt;p&gt;2.7版本之后也支持同时对多个文件管理，即：&lt;/p&gt;
&lt;p&gt;with open(&quot;guangzhou&quot;, &quot;r&quot;) as f, open(&quot;guangzhou2&quot;, &quot;r&quot;) as f2:&lt;/p&gt;


&lt;h2&gt;字符集发展史&lt;/h2&gt;
&lt;p&gt;中国字符集发展：gb2312---&amp;gt;gb18030--&amp;gt;gbk&lt;/p&gt;
&lt;p&gt;国际字符集发展：ascii(英文占用一个字节，不能存中文)--&amp;gt;unicode(英中占用两个字节)--&amp;gt;utf-8(中文占用3个字节，英文一个字节)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376001/201804/1376001-20180423011300121-1418151734.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;函数的定义方法&lt;/h2&gt;
&lt;p&gt;def text(x):&lt;/p&gt;
&lt;p&gt;　　&quot;The function definitions&quot;&lt;/p&gt;
&lt;p&gt;　　x += 1&lt;/p&gt;
&lt;p&gt;　　return x&lt;/p&gt;
&lt;p&gt;函数可以返回多个值，用元组来返回，比如return 1， 3， “hello”， [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], {”name”:&quot;Jason&quot;}  返回其实是（1， 3， “hello”， [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], {”name”:&quot;Jason&quot;}）&lt;/p&gt;
&lt;h2&gt;函数增加参数&lt;/h2&gt;
&lt;p&gt;def text(x,y):&lt;/p&gt;
&lt;p&gt;　　print(x,y)&lt;/p&gt;
&lt;p&gt;调用方式：&lt;/p&gt;
&lt;p&gt;1.text(1, 2)　　　　　　   --&amp;gt;1,2　　位置参数调用&lt;/p&gt;
&lt;p&gt;2.text(x = 2,y = 1)　　　　--&amp;gt;2,1　　关键字参数调用&lt;/p&gt;
&lt;p&gt;3.text(2, y = 1)　　　　　 --&amp;gt;2 , 1&lt;/p&gt;
&lt;p&gt;4. x = 1,&lt;/p&gt;
&lt;p&gt;y = 2&lt;/p&gt;
&lt;p&gt;text(x, y)　　　　　　　　--&amp;gt;1, 2&lt;/p&gt;
&lt;p&gt;5.text(1, x = 2) 报错，x得到了多个值&lt;/p&gt;
&lt;p&gt;6.text(x = 2, 1)报错&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综上所述，当既有位置参数又有关键字参数的时候，关键参数的后面不能有位置参数，且不能给多个参数赋值&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;函数的默认参数&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;1.参数固定&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def text(x, y = 2):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　print(x,y)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;2.参数不固定，接受N个位置参数输出用元组&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def text(*args):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　print(args)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;text(1, 2, 3, 4, 6)或者text(*[1, 2, 3, 4, 6])&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;--&amp;gt;(1, 2, 3, 4, 6) 元组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;3.接受N个关键字参数输出字典方式&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def text(**kwargs):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　print(kwargs)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;text(name = &quot;Jason&quot;, age = 24)　　--&amp;gt;{‘name’:'Jason', 'age':24}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;这些参数可以混合使用，比如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def text(name, *args, **kwargs):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　print(name)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　print(args)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　print(kwargs)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;text(“Jason”, 1, 2, 5, name = &quot;Jason&quot;, age = 24)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;--&amp;gt;Jason&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;(1, 2, 5)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;{'name':&quot;Jason&quot;, 'age':24}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;函数局部变量与全局变量&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在子程序中定义的变量为局部变量，在程序的一开始定的变量为全局变量，全局变量作用域整个程序，局部变量作用域定义该变量的子程序，当全局变量与局部变量同名时，在定义局部变量的子程序中，局部变量起作用，在其他地方全局变量起作用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在子程序中，变量字符串对全局变量的改变对外面没影响，但是，当全局变量为列表字典集合的时候，这个时候改变会影响整个程序的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;高阶函数&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;变量可以指向函数，函数的参数能接受变量，那么一个函数就可以就收另一个函数作为参数，这种函数称之为高阶函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 18:58:00 +0000</pubDate>
<dc:creator>近视的boy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jsaon-li/p/8912623.html</dc:identifier>
</item>
<item>
<title>Django+nginx+uwsgi部署教程（centos7+ubuntu16.4） - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/8911961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/8911961.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;项目部署教程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       &lt;span&gt;&lt;a href=&quot;http://180.76.56.222/&quot;&gt;在线教育平台项目演示地址&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1.原理介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;django&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 一&lt;span&gt;个基于python的开源web框架&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;uwsgi&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 一是一个web服务器，也可以当做中间件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常用高性能代理服务器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;wsgi.py&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;django项目携带的一个wsgi接口文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Nginx是一个Http和反向代理服务器 
什么是反向代理服务器呢？

正向的就是由浏览器主动的想代理服务器发出请求，经代理服务器做出处理后再转给目标服务器
反向的就是不管浏览器同不同意，请求都会经过代理服务器处理再发给目标服务器
这其中的区别就是必须经过Nginx反向代理服务器，这就有了使用Nginx的几个好处：

安全：不管什么请求都要经过代理服务器，这样就避免了外部程序直接攻击web服务器
负载均衡：根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能
提高web服务器的IO性能：这个我也没看懂，总结来说就是请求从客户端传到web服务器是需要时间的，&lt;br/&gt;传递多长时间就会让这个进程阻塞多长时间，而通过反向代理，就可以在反向代理这完整接受请求，然后再&lt;br/&gt;传给web服务器，从而保证服务器性能，而且有的一些简单的事情（比如静态文件）可以直接由反向代理处理，不经过web服务器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;流程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;首先客户端请求服务资源，
nginx作为直接对外的服务接口,接收到客户端发送过来的http请求,会解包、分析，
如果是静态文件请求就根据nginx配置的静态文件目录，返回请求的资源，
如果是动态的请求,nginx就通过配置文件,将请求传递给uWSGI；uWSGI 将接收到的包进行处理，并转发给wsgi，
wsgi根据请求调用django工程的某个文件或函数，处理完后django将返回值交给wsgi，
wsgi将返回值进行打包，转发给uWSGI，
uWSGI接收后转发给nginx,nginx最终将返回值返回给客户端(如浏览器)。
&lt;/span&gt;*注:不同的组件之间传递信息涉及到数据格式和协议的转换
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;. 第一级的nginx并不是必须的，uwsgi完全可以完成整个的和浏览器交互的流程； 
&lt;/span&gt;2&lt;span&gt;. 在nginx上加上安全性或其他的限制，可以达到保护程序的作用； 
&lt;/span&gt;3&lt;span&gt;. uWSGI本身是内网接口，开启多个work和processes可能也不够用，而nginx可以代理多台uWSGI完成uWSGI的负载均衡； 
&lt;/span&gt;4. django在debug=False下对静态文件的处理能力不是很好，而用nginx来处理更加高效。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;centos7的部署&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以全新服务器为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum -&lt;span&gt;y update&lt;p&gt;yum install gcc

yum &lt;/p&gt;&lt;/span&gt;-y install zlib*&lt;span&gt;

yum install openssl&lt;/span&gt;-devel -y
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1.2.ssh安装&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 yum install openssh-server -&lt;span&gt;y

service sshd restart

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;xshell连不上，SSH服务端不允许密码验证。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;服务端开启密码验证的方法：&lt;/span&gt;
&lt;span&gt;
vim &lt;/span&gt;/etc/ssh/&lt;span&gt;sshd_config

把PasswordAuthentication项为yes

重启服务

service sshd restart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.2.mysql安装&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1.安装&lt;/span&gt;
wget http://dev.mysql.com/get/mysql-community-release-el7-5&lt;span&gt;.noarch.rpm
rpm &lt;/span&gt;-ivh mysql-community-release-el7-5&lt;span&gt;.noarch.rpm
yum install mysql&lt;/span&gt;-community-&lt;span&gt;server

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2.重启服务&lt;/span&gt;
&lt;span&gt;service mysqld restart

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3. 设置bind-ip&lt;/span&gt;
&lt;span&gt;
    vim &lt;/span&gt;/etc/&lt;span&gt;my.cnf
    在 [mysqld]:
        下面加一行
        bind&lt;/span&gt;-address = 0.0.0.0

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4.登录mysql&lt;/span&gt;
mysql -&lt;span&gt;u root

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;5. 设置外部ip可以访问&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;mysql中输入命令：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;后面用navicat连接远程服务器mysql的用户名和密码&lt;/span&gt;
GRANT ALL PRIVILEGES ON *.* TO &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED BY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; WITH GRANT OPTION;

FLUSH PRIVILEGES；

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;6.设置mysql密码&lt;/span&gt;
&lt;span&gt;进入mysql：
set password &lt;/span&gt;=password(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;密码123456&lt;/span&gt;
flush privileges;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.3.pip和python3.6的安装&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;安装pip&lt;/span&gt;wget https://bootstrap.pypa.io/get-pip.py  --no-check-&lt;span&gt;certificate

sudo python get&lt;/span&gt;-pip.py
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;安装python3.6&lt;/span&gt;
1&lt;span&gt;. 获取

wget https:&lt;/span&gt;//www.python.org/ftp/python/3.6.2/Python-3.6.2&lt;span&gt;.tgz
tar &lt;/span&gt;-xzvf Python-3.6.2.tgz -C  /&lt;span&gt;tmp
cd  &lt;/span&gt;/tmp/Python-3.6.2/

2. 把Python3.6安装到 /usr/&lt;span&gt;local 目录

.&lt;/span&gt;/configure --prefix=/usr/&lt;span&gt;local
make
make altinstall

&lt;/span&gt;3. 更改/usr/bin/&lt;span&gt;python链接

ln &lt;/span&gt;-s /usr/local/bin/python3.6 /usr/bin/python3
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.4.虚拟环境安装&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
yum install python-setuptools python-&lt;span&gt;devel
pip install virtualenvwrapper

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;编辑.bashrc文件&lt;/span&gt;
vim ~/&lt;span&gt;.bashrc

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加进去&lt;/span&gt;
export WORKON_HOME=$HOME/&lt;span&gt;.virtualenvs
source &lt;/span&gt;/usr/bin/&lt;span&gt;virtualenvwrapper.sh

&lt;/span&gt;#&lt;span&gt;sudo find / -name virtualenvwrapper.sh      查看你的virtualenvwrapper.sh在什么地方&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;重新加载.bashrc文件&lt;/span&gt;
source ~/&lt;span&gt;.bashrc

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;虚拟环境保存的路径&lt;/span&gt;&lt;span&gt;
cd &lt;/span&gt;~/.virtualenvs/&lt;span&gt;      （创建的虚拟环境都会保存在这个目录，前面设置的）

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建指定python版本的虚拟环境方法&lt;/span&gt;
mkvirtualenv -p /usr/local/bin/python3.6 MxOnline
&lt;br/&gt;workon MxShop&lt;br/&gt;&lt;span&gt;#进虚拟环境安装依赖包&lt;br/&gt;&lt;/span&gt;&lt;code&gt;&lt;br/&gt;首先 pip freeze &amp;gt; requirements.txt&lt;/code&gt;&lt;span&gt; 将本地的虚拟环境安装包导出来，上传到服务器&lt;br/&gt;&lt;/span&gt;
pip install -&lt;span&gt;r requirements.txt

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;安装mysqlclient出问题&lt;/span&gt;
&lt;span&gt;
    centos &lt;/span&gt;7&lt;span&gt;：
        yum install python&lt;/span&gt;-devel mariadb-devel -&lt;span&gt;y

    ubuntu：
        sudo apt&lt;/span&gt;-get install libmysqlclient-&lt;span&gt;dev

    然后：
        pip install mysqlclient&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.5.git安装&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum install git

git config &lt;/span&gt;--&lt;span&gt;global&lt;/span&gt; user.name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
git config &lt;/span&gt;--&lt;span&gt;global&lt;/span&gt; user.email &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;youremail@domain.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

cd &lt;/span&gt;~/ &amp;amp;&amp;amp; ssh-keygen -t rsa -C &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你的邮箱&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;提示的信息，直接按enter就行&lt;/span&gt;
&lt;span&gt;
cd .ssh

把公钥文件（id_rsa.pub）中的码复制到github

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;就可以开始clone代码了&lt;/span&gt;
&lt;span&gt;
git clone git@github.com:derek&lt;/span&gt;-zhang123/MxOnline.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;这是我的项目目录和虚拟环境目录&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;项目目录：          /home/gitpackage/MxOnline&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;虚拟环境目录：  /root/.virtualenvs/MxShop&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.6.拉取项目静态文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在django的setting文件中，添加下面一行内容：&lt;/span&gt;
&lt;span&gt;
    STATIC_ROOT &lt;/span&gt;= os.path.join(BASE_DIR, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;运行命令&lt;/span&gt;
    python manage.py collectstatic
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180423012227578-1892220756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; settings中其它需要设置的地方&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
DEBUG =&lt;span&gt; True

ALLOWED_HOSTS &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;自己设置可以访问的域名，‘*’代表所有都可以访问&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.7.uwsgi&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）安装&lt;/p&gt;
&lt;p&gt;进虚拟环境安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;workon MxOnline

pip install uwsgi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）在项目目录下新建uwsgi.ini文件&lt;/p&gt;
&lt;p&gt;MxOnine/uwsgi.ini&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[uwsgi]

socket &lt;/span&gt;=127.0.0.1 :8000&lt;span&gt;
chdir &lt;/span&gt;= /home/gitpackage/&lt;span&gt;MxOnline
module &lt;/span&gt;=&lt;span&gt; MxOnline.wsgi
master &lt;/span&gt;=&lt;span&gt; true
processes &lt;/span&gt;= 4&lt;span&gt;
vacuum &lt;/span&gt;=&lt;span&gt; true
virtualenv &lt;/span&gt;= /root/.virtualenvs/&lt;span&gt;MxShop
logto &lt;/span&gt;= /tmp/mylog.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180423013648569-1395569226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;注：
    chdir：     表示需要操作的目录，也就是项目的目录
    module：    wsgi文件的路径
    processes： 进程数
    virtualenv：虚拟环境的目录&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.8.nginx&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）安装&lt;/p&gt;
&lt;p&gt;这里有安装方法：&lt;code&gt;https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo yum install nginx

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;可能会用到的命令&lt;/span&gt;
&lt;span&gt;service nginx restart
service nginx stop
service nginx start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）配置文件&lt;/p&gt;
&lt;p&gt;在/etc/nginx/conf.d下新建MxOnline.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; the upstream component nginx needs to connect to&lt;/span&gt;
&lt;span&gt;upstream django {
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; server unix:///path/to/your/mysite/mysite.sock; # for a file socket&lt;/span&gt;
server 127.0.0.1:8000; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; for a web port socket (we'll use this first)&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; configuration of the server&lt;/span&gt;
&lt;span&gt;
server {
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; the port your site will be served on&lt;/span&gt;
listen      80&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; the domain name it will serve for&lt;/span&gt;
server_name 180.76.56.222; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; substitute your machine's IP address or FQDN&lt;/span&gt;
charset     utf-8&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; max upload size&lt;/span&gt;
client_max_body_size 75M;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; adjust to taste&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Django media&lt;/span&gt;
location /&lt;span&gt;media  {
    alias &lt;/span&gt;/home/gitpackage/MxOnline/media;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指向django的media目录&lt;/span&gt;
&lt;span&gt;}


location &lt;/span&gt;/&lt;span&gt;static {
    alias &lt;/span&gt;/home/gitpackage/MxOnline/static; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指向django的static目录&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Finally, send all non-media requests to the Django server.&lt;/span&gt;
location /&lt;span&gt; {
    uwsgi_pass  django;
    include     uwsgi_params; &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; the uwsgi_params file you installed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180423011907633-1526321654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;配置好后&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
nginx -t       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;提示success说明没问题&lt;/span&gt;
&lt;span&gt;
service nginx restart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.9.navicat数据传输&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;一切都配置好后，把本地数据库的数据传到服务器上面&lt;/p&gt;
&lt;p&gt;（1）连接你的服务器数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180423014942204-1952279615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）新建项目数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180423015033865-1362675002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）传输数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180423015147631-312788356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;span&gt;数据传输完成，配置也都配置好后，就可以开始访问了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span readability=&quot;2&quot;&gt;#创建超级用户&lt;p&gt;&lt;span&gt;python manage.py createsuperuser&lt;/span&gt;&lt;/p&gt;&lt;p&gt;#&lt;/p&gt;&lt;/span&gt;&lt;span&gt;把uswgi服务开启&lt;/span&gt;&lt;span&gt;uwsgi &lt;/span&gt;--&lt;span&gt;ini uwsgi.ini 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;访问&lt;/span&gt;
http://你的ip地址/
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;strong&gt;&lt;span&gt;ubuntu的基本环境搭建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sudo apt-&lt;span&gt;get update

apt&lt;/span&gt;-&lt;span&gt;get install gcc 

apt&lt;/span&gt;-get install libssl-&lt;span&gt;dev

sudo apt&lt;/span&gt;-&lt;span&gt;get install openssl


apt&lt;/span&gt;-&lt;span&gt;get install zlib1g

apt&lt;/span&gt;-get install zlib1g.dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
sudo apt-get install mysql-&lt;span&gt;server

输入密码

mysql &lt;/span&gt;-u root -&lt;span&gt;p

sudo vim &lt;/span&gt;/etc/mysql/mysql.conf.d/&lt;span&gt;mysqld.cnf

 bind&lt;/span&gt;-address = 0.0.0.0    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加进去&lt;/span&gt;
&lt;span&gt;
sudo service mysql restart

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置远程访问&lt;/span&gt;
&lt;span&gt;
GRANT ALL PRIVILEGES ON &lt;/span&gt;*.* TO &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED BY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; WITH GRANT OPTION;

flush privileges;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; pip和python3.6&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wget https://bootstrap.pypa.io/get-pip.py  --no-check-&lt;span&gt;certificate

sudo python get&lt;/span&gt;-pip.py
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2&lt;span&gt;.tgz

tar &lt;/span&gt;-xzvf Python-3.6.2.tgz -C  /&lt;span&gt;tmp
cd  &lt;/span&gt;/tmp/Python-3.6.2/

2. 把Python3.6安装到 /usr/&lt;span&gt;local 目录

.&lt;/span&gt;/configure --prefix=/usr/&lt;span&gt;local
make
make altinstall

&lt;/span&gt;3. 更改/usr/bin/&lt;span&gt;python链接

ln &lt;/span&gt;-s /usr/local/bin/python3.6 /usr/bin/python3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 虚拟环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pip install virtualenv
pip install virtualenvwrapper

vim &lt;/span&gt;~/&lt;span&gt;.bashrc

export WORKON_HOME&lt;/span&gt;=$HOME/&lt;span&gt;.virtualenvs
source &lt;/span&gt;/usr/local/bin/&lt;span&gt;virtualenvwrapper.sh

source &lt;/span&gt;~/&lt;span&gt;.bashrc&lt;br/&gt;mkvirtualenv MxOnline --python=python3.6

worko MxOnline

sudo apt&lt;/span&gt;-get install libmysqlclient-&lt;span&gt;dev

pip install &lt;/span&gt;-r requirements.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; git&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sudo apt-&lt;span&gt;get update
sudo apt&lt;/span&gt;-&lt;span&gt;get install git

git config &lt;/span&gt;--&lt;span&gt;global&lt;/span&gt; user.name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
git config &lt;/span&gt;--&lt;span&gt;global&lt;/span&gt; user.email &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;youremail@domain.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果安装软件时候报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 E: Sub-process /usr/bin/dpkg returned an error code (1&lt;span&gt;)错误解决

在用apt－get安装软件时出现了类似于
install&lt;/span&gt;-info: No dir file specified; &lt;span&gt;try&lt;/span&gt; --help &lt;span&gt;for&lt;/span&gt; more information.dpkg：处理 gettext (--configure)时出错： 子进程 post-installation script 返回了错误号 1&lt;span&gt; 在处理时有错误发生：
findutils
E: Sub&lt;/span&gt;-process /usr/bin/dpkg returned an error code (1&lt;span&gt;)
办法如下：
&lt;/span&gt;1.$ sudo mv /var/lib/dpkg/info /var/lib/dpkg/info_old //&lt;span&gt;现将info文件夹更名
&lt;/span&gt;2.$ sudo mkdir /var/lib/dpkg/info //&lt;span&gt;再新建一个新的info文件夹
&lt;/span&gt;3.$ sudo apt-get update,再$sudoapt-get -f install //&lt;span&gt;不用解释了吧
&lt;/span&gt;4.$ sudo mv /var/lib/dpkg/info/* /var/lib/dpkg/info_old //&lt;span&gt;执行完上一步操作后会在新的info文件夹下生成一些文件，现将这些文件全部移到info_old文件夹下
&lt;/span&gt;5.$ sudo rm -rf /var/lib/dpkg/info //&lt;span&gt;把自己新建的info文件夹删掉
&lt;/span&gt;6.$ sudo mv /var/lib/dpkg/info_old /var/lib/dpkg/info //&lt;span&gt;把以前的info文件夹重新改回名字
到此问题顺利解决&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;github&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
cd ~/ &amp;amp;&amp;amp; ssh-keygen -t rsa -C &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你的邮箱&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;提示的信息，直接按enter就行&lt;/span&gt;
&lt;span&gt;
cd .ssh

把公钥文件（id_rsa.pub）中的码复制到github

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;就可以开始clone代码了&lt;/span&gt;
&lt;span&gt;
git clone git@github.com:derek&lt;/span&gt;-zhang123/MxOnline.git
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 22 Apr 2018 18:04:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/8911961.html</dc:identifier>
</item>
<item>
<title>(MariaDB/MySQL)之DML(2)：数据更新、删除 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8912026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8912026.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8912026.html#blog1&quot;&gt;&lt;span&gt;1.update语句&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8912026.html#blog2&quot;&gt;&lt;span&gt;2.delete语句&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8912026.html#blog2.1&quot;&gt;&lt;span&gt;2.1 单表删除&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8912026.html#blog2.2&quot;&gt;&lt;span&gt;2.2 多表删除&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8912026.html#blog3&quot;&gt;&lt;span&gt;3.truncate table&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;update用于修改表中记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 单表更新语法：
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; [&lt;span class=&quot;hljs-keyword&quot;&gt;LOW_PRIORITY&lt;/span&gt;] [&lt;span class=&quot;hljs-keyword&quot;&gt;IGNORE&lt;/span&gt;] table_reference 
  [&lt;span class=&quot;hljs-keyword&quot;&gt;PARTITION&lt;/span&gt; (partition_list)]
  &lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; col1={expr1|&lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt;} [,col2={expr2|&lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt;}] ...
  [&lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; where_condition]
  [&lt;span class=&quot;hljs-keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;BY&lt;/span&gt; ...]
  [&lt;span class=&quot;hljs-keyword&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;row_count&lt;/span&gt;]

# 多表更新语法：
&lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; [&lt;span class=&quot;hljs-keyword&quot;&gt;LOW_PRIORITY&lt;/span&gt;] [&lt;span class=&quot;hljs-keyword&quot;&gt;IGNORE&lt;/span&gt;] table_references
    &lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; col1={expr1|&lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt;} [, col2={expr2|&lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt;}] ...
    [&lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; where_condition]&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先简单介绍下各子句和关键字相关的功能，后文将详细解释它们。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;low_priority只对使用表级锁的存储引擎有效(如MyISAM和Aria)，它设置delete语句的优先级低于读操作，使update延迟到没有任何进程访问表的时候才会执行。见：&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8907252.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;(MariaDB/MySQL)MyISAM存储引擎读、写操作的优先级&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;ignore是在更新某行出错的时候忽略错误，继续更新其他行。&lt;/li&gt;
&lt;li&gt;where子句筛选出要更新的行。如果不给定where子句，则update会更新整张表中的所有行。&lt;/li&gt;
&lt;li&gt;order by子句表示先对筛选出来的数据排序，排序后按顺序更新这些行。在更新某些行的时候，使用order by能解决一些错误。&lt;/li&gt;
&lt;li&gt;limit子句表示更新一定数量的行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 单表更新
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; table_name &lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; column1 = value1, column2 = value2 &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按排序更新指定行数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt; book &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; bookcount=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; bookname &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;'ss'&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; bookid &lt;span class=&quot;hljs-keyword&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多表更新。注意，下面的语句会更新&lt;span&gt;&lt;strong&gt;两张表&lt;/strong&gt;&lt;/span&gt;中的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; BOOK,BOOK2 &lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; BOOK.bookcount=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; ,BOOK2.bookcount=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; BOOK.bookid=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;AND&lt;/span&gt; BOOK2.bookid=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于其他表来更新某表数据。注意，下面的语句只更新&lt;span&gt;&lt;strong&gt;一张表&lt;/strong&gt;&lt;/span&gt;中的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt; t,t1 &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; t1.name=&lt;span class=&quot;hljs-string&quot;&gt;'newname'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; t1.id=t2.id;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; name=&lt;span class=&quot;hljs-string&quot;&gt;'newname'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; t.id=(&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;max&lt;/span&gt;(id) &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t1);&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，SQL Server支持下面的update from语法，但是MySQL/MariaDB不支持。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; TScore &lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; mark = mark - &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; 
&lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; TScore a &lt;span class=&quot;hljs-keyword&quot;&gt;JOIN&lt;/span&gt; TSubject b &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; a.subJectID = b.subJectID
&lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; b.subJectName = &lt;span class=&quot;hljs-string&quot;&gt;'软件测试'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;AND&lt;/span&gt; mark &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是关于update需要注意的几种特殊情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1).更新时有键值重复时，可以考虑使用order by子句。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，下面的表：id为主键，不允许重复。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; t(id &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;key&lt;/span&gt;,sex &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;),name &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;));&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;values&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nan'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'longshuai1'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nan'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'longshuai2'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nv'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang1'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nv'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang2'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nv'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang3'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nv'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang4'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nv'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'tun\'er'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nan'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'longshuai3'&lt;/span&gt;);&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的语句将更新失败，因为如果更新成功，主键id将重复。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;update t &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; id=id+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;
ERROR &lt;span class=&quot;hljs-number&quot;&gt;1062&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;23000&lt;/span&gt;): Duplicate entry &lt;span class=&quot;hljs-string&quot;&gt;'7'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;hljs-string&quot;&gt;'PRIMARY'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但使用order by之后，将能正常更新，因为会先排序，然后按降序结果集进行更新。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; id=id+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; id &lt;span class=&quot;hljs-keyword&quot;&gt;desc&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;
+
| id | sex  | name       |
+
|  7 | nv   | xiaofang4  |
|  8 | nv   | tun'er     |
|  9 | nan  | longshuai3 |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(2).一定要注意update中set赋值语句的同时性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多个赋值语句是从左到右评估的，除非&lt;code&gt;sql_mode&lt;/code&gt;指定了&lt;code&gt;SIMULTANEOUS_ASSIGNMENT&lt;/code&gt;模式(从MariaDB 10.3.5开始支持该模式)，这种情况下UPDATE语句是同时评估所有赋值语句的。（注：标准SQL的update赋值语句就是同时性的）&lt;/p&gt;
&lt;p&gt;例如，给定如下表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; tx (c1 &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;, c2 &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;);&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; tx &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的update能正确执行，更新后c2字段的值和c1的值相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; tx &lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; c1=c1+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,c2=c1;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; tx;&lt;/span&gt;
+
| c1   | c2   |
+
|   11 |   11 |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置sql_mode模式SIMULTANEOUS_ASSIGNMENT，再执行相同的更新语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; @@sql_mode=&lt;span class=&quot;hljs-keyword&quot;&gt;CONCAT&lt;/span&gt;(@@sql_mode,&lt;span class=&quot;hljs-string&quot;&gt;',SIMULTANEOUS_ASSIGNMENT'&lt;/span&gt;);&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; tx &lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; c1=c1+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,c2=c1;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; tx;&lt;/span&gt;
+
| c1   | c2   |
+
|   12 |   11 |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(3).更新源和目标相同的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在MariaDB 10.3.2之前，执行下面的update语句会失败。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;update t &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; id=&lt;span class=&quot;hljs-string&quot;&gt;'10'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id=(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t.id)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t)&lt;/span&gt;;  
ERROR &lt;span class=&quot;hljs-number&quot;&gt;1093&lt;/span&gt; (HY000): Table &lt;span class=&quot;hljs-string&quot;&gt;'t'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; specified twice, both &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; a target &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'UPDATE'&lt;/span&gt; and &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; a separate source &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; data
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是从MariaDB 10.3.2开始，允许执行这样的update语句。&lt;/p&gt;


&lt;p&gt;delete用于删除表中记录。可以删除单表数据，也可以删除多表数据。&lt;/p&gt;
&lt;p&gt;先看语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 单表删除语法
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DELETE&lt;/span&gt; [&lt;span class=&quot;hljs-keyword&quot;&gt;LOW_PRIORITY&lt;/span&gt;] [&lt;span class=&quot;hljs-keyword&quot;&gt;QUICK&lt;/span&gt;] [&lt;span class=&quot;hljs-keyword&quot;&gt;IGNORE&lt;/span&gt;] 
    &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; tbl_name [&lt;span class=&quot;hljs-keyword&quot;&gt;PARTITION&lt;/span&gt; (partition_list)]
    [&lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; where_condition]
    [&lt;span class=&quot;hljs-keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;BY&lt;/span&gt; ...]
    [&lt;span class=&quot;hljs-keyword&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;row_count&lt;/span&gt;]
    [RETURNING select_expr 
      [, select_expr ...]]

# 多表语法：
&lt;span class=&quot;hljs-keyword&quot;&gt;DELETE&lt;/span&gt; [&lt;span class=&quot;hljs-keyword&quot;&gt;LOW_PRIORITY&lt;/span&gt;] [&lt;span class=&quot;hljs-keyword&quot;&gt;QUICK&lt;/span&gt;] [&lt;span class=&quot;hljs-keyword&quot;&gt;IGNORE&lt;/span&gt;]
    tbl_name[.*] [, tbl_name[.*]] ...
    &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; table_references
    [&lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; where_condition]
# 或：
&lt;span class=&quot;hljs-keyword&quot;&gt;DELETE&lt;/span&gt; [&lt;span class=&quot;hljs-keyword&quot;&gt;LOW_PRIORITY&lt;/span&gt;] [&lt;span class=&quot;hljs-keyword&quot;&gt;QUICK&lt;/span&gt;] [&lt;span class=&quot;hljs-keyword&quot;&gt;IGNORE&lt;/span&gt;]
    &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; tbl_name[.*] [, tbl_name[.*]] ...
    &lt;span class=&quot;hljs-keyword&quot;&gt;USING&lt;/span&gt; table_references
    [&lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; where_condition]&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先简单介绍下各子句和关键字相关的功能，后文将详细解释它们。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;from子句指定要删除的哪张表中的数据，如果是多表语法，则可能只是提供引用功能，不一定会删除其中的数据。&lt;/li&gt;
&lt;li&gt;low_priority只对使用表级锁的存储引擎有效(如MyISAM和Aria)，它设置delete语句的优先级低于读操作，使delete延迟到没有任何进程访问表的时候才会执行。见：&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8907252.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;(MariaDB/MySQL)MyISAM存储引擎读、写操作的优先级&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;quick是通知存储引擎将删除操作合并起来，存储引擎收到这个通知后，删除多行的操作会合并成一个批，当批的大小达到一定程度之后才一次性删除，一定程度上能提升删除数据的效率。对InnoDB/XtraDB可能无效，但对MyISAM和Aria是有效的。&lt;/li&gt;
&lt;li&gt;ignore是在删除某行出错的时候忽略错误，继续删除其他行。&lt;/li&gt;
&lt;li&gt;where子句筛选出要删除的行。如果不给定where子句，则delete会删除整张表中的所有行。&lt;/li&gt;
&lt;li&gt;order by子句表示先对筛选出来的数据排序，排序后按顺序删除这些行。&lt;/li&gt;
&lt;li&gt;limit子句表示删除一定数量的行。&lt;/li&gt;
&lt;li&gt;returning子句用于返回所删除的行相关的数据。&lt;span&gt;&lt;strong&gt;&lt;em&gt;这是一个MariaDB非常人性化的功能，不仅可以让我们知道删除了哪些行，某些时候还能借此恢复误删除的行。&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;MySQL不支持该功能。&lt;/li&gt;
&lt;li&gt;using子句用于多表删除语法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MySQL/MariaDB中delete语句中必须使用from子句。单表删除时，表名必须放在from子句中，而多表删除语法中，多表是可以放在from子句之前的。习惯了SQL Server的人一开始可能会因此而不习惯，出于方便的原因，SQL Server中的delete往往会不写from子句。&lt;/p&gt;

&lt;h2 id=&quot;2-1-&quot;&gt;2.1 单表删除&lt;/h2&gt;
&lt;p&gt;给定如下表，并插入一些数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; t(id &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;key&lt;/span&gt;,sex &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;),name &lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;));&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;values&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nan'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'longshuai1'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nan'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'longshuai2'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nv'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang1'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nv'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang2'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nv'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang3'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nv'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'xiaofang4'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nv'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'tun\'er'&lt;/span&gt;),
                      (&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'nan'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'longshuai3'&lt;/span&gt;);&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除sex='nv'且id&amp;gt;6的记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; sex=&lt;span class=&quot;hljs-string&quot;&gt;'nv'&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于delete语句而言，order by子句主要结合limit子句使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; id &lt;span class=&quot;hljs-keyword&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用returning子句，可以自定义删除行的时候返回哪些数据。注意，MariaDB 10.3.1之前下面的语句会失败。见下文。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id=(&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;max&lt;/span&gt;(id) &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t) returning &lt;span class=&quot;hljs-keyword&quot;&gt;concat&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;delete id: &quot;&lt;/span&gt;,id) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; maxid;&lt;/span&gt;
+
| maxid        |
+
| &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; id: &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; |
+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者返回删除行的所有字段的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t returning *;&lt;/span&gt;
+
| id | sex  | name      |
+
|  3 | nv   | xiaofang1 |
|  4 | nv   | xiaofang2 |
|  5 | nv   | xiaofang3 |
|  6 | nv   | xiaofang4 |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，下面的delete语句中，删除的是同源同目标数据。在MariaDB 10.3.1之前，delete语句无法删除这样的记录。报错信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delete &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id=(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t)&lt;/span&gt;;
ERROR &lt;span class=&quot;hljs-number&quot;&gt;1093&lt;/span&gt; (HY000): Table &lt;span class=&quot;hljs-string&quot;&gt;'t'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; specified twice, both &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; a target &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'DELETE'&lt;/span&gt; and &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; a separate source &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; data
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但从MariaDB 10.3.1之后，允许删除这样的记录。&lt;/p&gt;

&lt;h2 id=&quot;2-2-&quot;&gt;2.2 多表删除&lt;/h2&gt;
&lt;p&gt;两种语法，一种语法是将表引用放在from子句之前，另一种语法是使用using子句。它们其实是等价的。&lt;/p&gt;
&lt;p&gt;如果下面的语法不明白，请将&lt;code&gt;delete tbl_name&lt;/code&gt;这部分替换成&lt;code&gt;select column_list&lt;/code&gt;来考虑。delete的执行过程和select是一样的，只不过是筛选数据后，一个是对筛选的结果集进一步select，一个是delete筛选出来的结果集。&lt;/p&gt;
&lt;p&gt;下面的语句会删除t和t1两张表中满足id相等的记录。注意，&lt;span&gt;&lt;strong&gt;是两张表中的内容都删除。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; t,t1 &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;join&lt;/span&gt; t1 &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; t.id=t1.id;&lt;/span&gt;
# 等价于
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t,t1 &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;join&lt;/span&gt; t1 &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; t.id=t1.id;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果只是要删除一张表中的内容，但需要引用多张表，则可以参考下面的语句。该语句只会删除t表的内容，不会删除t1表的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; tbl_name1 &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; tbl_name1 &lt;span class=&quot;hljs-keyword&quot;&gt;join&lt;/span&gt; tbl_name2 ....
&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;join&lt;/span&gt; t1 &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; t.id=t1.id;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，删除表t中有的记录，但t1表中没有的记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; t &lt;span class=&quot;hljs-keyword&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;join&lt;/span&gt; t1 &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; t.id=t1.id &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; t1.id &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用了别名，那么和select一样，在delete列表引用表名的时候，需要使用别名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 正确的语法
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DELETE&lt;/span&gt; a1, a2 &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; t1 &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; a1 &lt;span class=&quot;hljs-keyword&quot;&gt;INNER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;JOIN&lt;/span&gt; t2 &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; a2 &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; a1.id=a2.id;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; a1, a2 &lt;span class=&quot;hljs-keyword&quot;&gt;USING&lt;/span&gt; t1 &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; a1 &lt;span class=&quot;hljs-keyword&quot;&gt;INNER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;JOIN&lt;/span&gt; t2 &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; a2 &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; a1.id=a2.id;&lt;/span&gt;

# 错误的语法
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DELETE&lt;/span&gt; t1 &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; a1, t2 &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; a2 &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; t1 &lt;span class=&quot;hljs-keyword&quot;&gt;INNER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;JOIN&lt;/span&gt; t2 &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; a1.id=a2.id;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; t1 &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; a1, t2 &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; a2 &lt;span class=&quot;hljs-keyword&quot;&gt;USING&lt;/span&gt; t1 &lt;span class=&quot;hljs-keyword&quot;&gt;INNER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;JOIN&lt;/span&gt; t2 &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; a1.id=a2.id;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;truncate table&lt;/code&gt;用于清空一张表。&lt;code&gt;truncate table&lt;/code&gt;等价于&lt;code&gt;drop table + re-create table&lt;/code&gt;两个操作，因此它是DDL语句而非DML语句，也因此它需要表的drop权限，且速度比delete表中所有速度要快的多的多，特别是表比较大的时候。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在re-create表的时候，它根据&quot;.frm&quot;文件中的表结构来重建表，因此索引等属性都会保留下来。但auto_increment最近的值会重置，因为该表被删除，它的auto_increment值全被清空。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果表上有其他锁的存在，则&lt;code&gt;truncate table&lt;/code&gt;会失败。&lt;/p&gt;
&lt;p&gt;如果表上有外键引用，则&lt;code&gt;truncate table&lt;/code&gt;会失败。&lt;/p&gt;
&lt;p&gt;如果表上有触发器，则&lt;code&gt;truncate table&lt;/code&gt;不会触发任何触发器。因为MariaDB/MySQL不支持DDL触发器。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8912026.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8912026.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 17:20:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8912026.html</dc:identifier>
</item>
<item>
<title>CentOS7.4 源码安装MySQL8.0 - AF陈</title>
<link>http://www.cnblogs.com/chenqs/p/8911670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqs/p/8911670.html</guid>
<description>&lt;p&gt;&lt;span&gt;MySQL 8 正式版 8.0.11 已发布，官方表示 MySQL 8 要比 MySQL 5.7 快 2 倍，还带来了大量的改进和更快的性能！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下为本人2018.4.23日安装过程的记录。整个过程大概需要一个小时，make &amp;amp;&amp;amp; make install过程需要的时间较长。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　CentOS7.4   64位  最小化安装&lt;/p&gt;

&lt;p&gt;　　1.安装依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;       yum&lt;/span&gt; -y &lt;span&gt;install&lt;/span&gt; &lt;span&gt;wget&lt;/span&gt;  cmake &lt;span&gt;gcc&lt;/span&gt; &lt;span&gt;gcc&lt;/span&gt;-c++ ncurses  ncurses-devel  libaio-devel  openssl openssl-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　2.下载源码包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;       wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cdn.mysql.com&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Downloads/MySQL-8.0/mysql-boost-8.0.11.tar.gz      (此版本带有boost)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.创建mysql用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;       groupadd mysql
       useradd &lt;/span&gt;-r -g mysql -s /bin/&lt;span&gt;false&lt;/span&gt; mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　4.创建安装目录和数据目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      mkdir&lt;/span&gt; -p /usr/local/&lt;span&gt;mysql
&lt;/span&gt;&lt;span&gt;      mkdir&lt;/span&gt; -p /data/mysql
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1.解压源码包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      tar&lt;/span&gt; -zxf mysql-boost-&lt;span&gt;8.0&lt;/span&gt;.&lt;span&gt;11&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz -C /usr/local
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.编译&amp;amp;安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
      cd /usr/local/mysql-&lt;span&gt;8.0&lt;/span&gt;.&lt;span&gt;11&lt;/span&gt;&lt;span&gt;
      cmake . &lt;/span&gt;-DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DSYSCONFDIR=/etc -DMYSQL_TCP_PORT=&lt;span&gt;3306&lt;/span&gt; -DWITH_BOOST=/usr/local/mysql-&lt;span&gt;8.0&lt;/span&gt;.&lt;span&gt;11&lt;/span&gt;/&lt;span&gt;boost 
&lt;/span&gt;&lt;span&gt;      make&lt;/span&gt;  &amp;amp;&amp;amp; &lt;span&gt;make&lt;/span&gt; &lt;span&gt;install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.配置my.cnf文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      cat&lt;/span&gt; /etc/&lt;span&gt;my.cnf
      [mysqld]
      server&lt;/span&gt;-&lt;span&gt;id&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
      port&lt;/span&gt;=&lt;span&gt;3306&lt;/span&gt;&lt;span&gt;
      basedir&lt;/span&gt;=/usr/local/&lt;span&gt;mysql
      datadir&lt;/span&gt;=/data/mysql&lt;br/&gt;　　　 ##请根据实际情况添加参数
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　4.目录权限修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      chown&lt;/span&gt; -R mysql:mysql /usr/local/&lt;span&gt;mysql
&lt;/span&gt;&lt;span&gt;      chown&lt;/span&gt; -R mysql:mysql /data/&lt;span&gt;mysql
&lt;/span&gt;&lt;span&gt;      chmod&lt;/span&gt; &lt;span&gt;755&lt;/span&gt; /usr/local/mysql -&lt;span&gt;R
&lt;/span&gt;&lt;span&gt;      chmod&lt;/span&gt; &lt;span&gt;755&lt;/span&gt; /data/mysql -R
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5.初始化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
      bin/mysqld --initialize --user=mysql --datadir=/data/mysql/&lt;span&gt;
      bin&lt;/span&gt;/mysql_ssl_rsa_setup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　6.启动mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
      bin/mysqld_safe --user=mysql &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　7.修改账号密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
      bin/mysql  -uroot -&lt;span&gt;p
      mysql&lt;/span&gt;&amp;gt; alter user &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; identified by &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;        mysql&amp;gt; show databases;&lt;br/&gt;        +--------------------+&lt;br/&gt;        | Database           |&lt;br/&gt;        +--------------------+&lt;br/&gt;        | information_schema |&lt;br/&gt;        | mysql              |&lt;br/&gt;        | performance_schema |&lt;br/&gt;        | sys                |&lt;br/&gt;        +--------------------+&lt;br/&gt;       4 rows in set (0.00 sec)&lt;/p&gt;
&lt;p&gt;　　　　##添加远程特账号&lt;/p&gt;
&lt;p&gt;　　　　mysql&amp;gt; create user root@'%' identified by '123456';&lt;br/&gt;　　　　Query OK, 0 rows affected (0.08 sec)&lt;/p&gt;
&lt;p&gt;　　　　mysql&amp;gt; grant all privileges on *.* to root@'%';&lt;br/&gt;　　　　Query OK, 0 rows affected (0.04 sec)&lt;/p&gt;
&lt;p&gt;　　　　mysql&amp;gt; flush privileges;&lt;br/&gt;　　　　Query OK, 0 rows affected (0.01 sec)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 　　8.创建软链接(&lt;span&gt;非必要&lt;/span&gt;)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;     ln&lt;/span&gt; -s /usr/local/mysql/bin&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; /usr/local/bin/&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　mysql -h 127.0.0.1 -P 3306 -uroot -p123456 -e &quot;select version();&quot;&lt;br/&gt;　　　　mysql: [Warning] Using a password on the command line interface can be insecure.&lt;br/&gt;　　　　+-----------+&lt;br/&gt;　　　　| version() |&lt;br/&gt;　　　　+-----------+&lt;br/&gt;　　　　| 8.0.11    |&lt;br/&gt;　　　　+-----------+&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 　　9.添加到启动(&lt;span&gt;非必要&lt;/span&gt;)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;     cp&lt;/span&gt; support-files/mysql.server /etc/init.d/mysql.server
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;span&gt;特此说明&lt;/span&gt;：MySQL官方推荐使用二进制安装的方式。（下图为官方文档截图）&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/992708/201804/992708-20180423002421045-2379056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 22 Apr 2018 16:32:00 +0000</pubDate>
<dc:creator>AF陈</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenqs/p/8911670.html</dc:identifier>
</item>
<item>
<title>java的泛型 - nianzhilian</title>
<link>http://www.cnblogs.com/nianzhilian/p/8911565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nianzhilian/p/8911565.html</guid>
<description>&lt;h3&gt;泛型概述&lt;/h3&gt;
&lt;p&gt;先看下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ArrayList al1 = new ArrayList();
        ArrayList al2 = new ArrayList();
        
        al1.add(&quot;hello&quot;);
        al1.add(&quot;world&quot;);       
        al1.add(&quot;abc&quot;);
        al1.add(&quot;hello&quot;);
        al1.add(&quot;1234&quot;);
        al1.add(&quot;abc&quot;);
        al1.add(&quot;hello&quot;);
        
        for(int i = 0;i&amp;lt;al1.size();i++){
                //获取每一项
                String s = (String)al1.get(i);
                if(!al2.contains(s)){
                        al2.add(s);
                }
        }
        for (Object object : al2) {
                System.out.println(object);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 根据集合的用法来存取数据上面看起来很爽的样子  但是如果我们要往集合存取不一样的类型时  往集合里添加数据很方便但是  等到我们取的时候问题很多  会出现不同的类型安全的问题，为了解决这一问题  我们需要限制一个集合只能存取一种类型   这就是我们所说的泛型&lt;/p&gt;
&lt;p&gt;虽然上面的例子取的时候可以将数据统一成 string类型 需要强转类型    因为默认从集合中取数据时返回的都是Object类型（类的鼻祖 所有的类型都继承Object类型并且里面包含了一个自动向上转型 即任何的对象都可以赋值给一个Object类型的变量 但是有个缺点是 Object类型的变量不能直接调用子类中独有的方法  可以用向下转型解决）&lt;/p&gt;
&lt;p&gt;下面来看使用泛型的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ArrayList&amp;lt;String&amp;gt; al1 = new ArrayList&amp;lt;&amp;gt;();
        ArrayList&amp;lt;String&amp;gt; al2 = new ArrayList&amp;lt;&amp;gt;();
        
        al1.add(&quot;hello&quot;);
        al1.add(&quot;world&quot;);       
        al1.add(&quot;abc&quot;);
        al1.add(&quot;hello&quot;);
        al1.add(&quot;1234&quot;);
        al1.add(&quot;abc&quot;);
        al1.add(&quot;hello&quot;);
        
        for(int i = 0;i&amp;lt;al1.size();i++){
                //获取每一项
                String s = al1.get(i);
                if(!al2.contains(s)){
                        al2.add(s);
                }
        }
        for (String s : al2) {
                System.out.println(s);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 总结：&lt;/h3&gt;
&lt;p&gt;1.集合默认可以存任意类型的数据,貌似功能十分强大,  存的时候很爽,取得时候问题很多   类型安全问题&lt;br/&gt;2.解决的思路:限制一个集合中只能存一种类型的数据&lt;br/&gt;3.泛型技术就可以限制一个集合中只能存一种类型的数据&lt;br/&gt;4.怎么使用泛型&lt;br/&gt;  ArrayList&amp;lt;String&amp;gt; al=new ArrayList&amp;lt;String&amp;gt;();&lt;br/&gt;5.使用了泛型后,在取数据的时候根本就不需要进行强制&lt;br/&gt;6.泛型技术出现在JDK5&lt;br/&gt;7.在JDK7的时候,推出了一种简化的写法:菱形写法&lt;br/&gt;  ArrayList&amp;lt;String&amp;gt; al=new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;8.泛型只支持引用数据类型,对于基本数据类型要用他们的包装类&lt;br/&gt;9.所有的集合类都支持泛型&lt;/p&gt;
&lt;h3&gt;泛型的底层原理&lt;/h3&gt;
&lt;p&gt;包括泛型方法、泛型类、泛型接口&lt;/p&gt;
&lt;p&gt;不管是创建泛型方法还是泛型类还是泛型接口都需要遵循以下三点：&lt;/p&gt;
&lt;p&gt;1、声明&lt;/p&gt;
&lt;p&gt;2、使用&lt;/p&gt;
&lt;p&gt;3、赋值类型&lt;/p&gt;
&lt;h3&gt;泛型方法：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/795484/201804/795484-20180423002433829-565662938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;泛型类&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/795484/201804/795484-20180423002540862-2146960074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;泛型接口：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/795484/201804/795484-20180423002636201-1800958365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 16:22:00 +0000</pubDate>
<dc:creator>nianzhilian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nianzhilian/p/8911565.html</dc:identifier>
</item>
<item>
<title>基于 Hexo + GitHub Pages 搭建个人博客（三） - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8911112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8911112.html</guid>
<description>&lt;p&gt;这个系列我们前面已经更新了两篇，点击下列链接可直接访问：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247484100&amp;amp;idx=1&amp;amp;sn=5051ed4c889747259fa00765a1286f62&amp;amp;chksm=fe32210ac945a81c2ce6e8dbaefebc1f44fbde6de3642fe1d61e2e61d292ffa32277dae5528d#rd&quot;&gt;基于 Hexo + GitHub Pages 搭建个人博客（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247484105&amp;amp;idx=1&amp;amp;sn=eee8bc1ab50d4a57292039079986d69d&amp;amp;chksm=fe322107c945a81147bf2eb62fcb270439059944c778154e1af42171d559f22bf99e0f6e8d6c#rd&quot;&gt;基于 Hexo + GitHub Pages 搭建个人博客（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/22/162ee04610bda079?w=5760&amp;amp;h=3840&amp;amp;f=jpeg&amp;amp;s=3141179&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一添加扫描二维码关注功能&quot;&gt;一、添加扫描二维码关注功能&lt;/h3&gt;
&lt;p&gt;打开 themes 目录下的 next 主题配置文件，找到 Wechat Subscriber 标签，将该标签下的配置改成如下形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Wechat Subscriber
wechat_subscriber:
  enabled: true         # 打开图片显示功能
  qcode: /images/wechat-qcode.jpg   # 需要显示的二维码图片
  description: 扫描二维码关注微信公众号，了解更多    # 在图片的底部添加描述&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完成后，切记将所需要扫描的二维码图片放置在 images 文件夹下面，否则系统找不到图片。&lt;/p&gt;
&lt;p&gt;结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/22/162ee049f7a9927d?w=557&amp;amp;h=275&amp;amp;f=png&amp;amp;s=30557&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二添加文章赞赏功能&quot;&gt;二、添加文章赞赏功能&lt;/h3&gt;
&lt;p&gt;打开 themes 目录下的 next 主题配置文件，找到 Reward 标签，将该标签下的配置改成如下形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Reward
reward_comment: 赞赏是最好的支持与鼓励！    # 添加打赏描述
wechatpay: /images/wechatpay.jpg    # 微信收款码图片
alipay: /images/alipay.jpg      # 支付宝收款码图片
#bitcoin: /images/bitcoin.png&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完成后，切记将所需要收款码图片放置在 images 文件夹下面，否则系统找不到图片。&lt;/p&gt;
&lt;p&gt;结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/22/162ee049f9fd4913?w=580&amp;amp;h=352&amp;amp;f=png&amp;amp;s=44249&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;三添加文章版权声明功能&quot;&gt;三、添加文章版权声明功能&lt;/h4&gt;
&lt;p&gt;打开 themes 目录下的 next 主题配置文件，找到 Declare license on posts 标签，将该标签下的配置改成如下形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Declare license on posts
post_copyright:
  enable: true      # 激活版权声明模块
  license: CC BY-NC-SA 3.0  # 版权许可协议
  license_url: https://compassblog.github.io/   # 声明的文章的可点击链接（域名）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完成后，执行如下 主目录下打开 Git Bash 命令窗口，执行如下命令开启 hexo 服务器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hexo s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器访问，显示结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/22/162ee049fb5f655c?w=668&amp;amp;h=216&amp;amp;f=png&amp;amp;s=14066&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;四添加-gitalk-评论系统&quot;&gt;四、添加 Gitalk 评论系统&lt;/h3&gt;
&lt;h4 id=&quot;什么是-gitalk&quot;&gt;1、什么是 Gitalk&lt;/h4&gt;
&lt;p&gt;Gitalk 是一个基于 Github Issue 和 Preact 开发的评论插件，这款评论插件使用 Github 登录，也可以快速提交评论，其实有一款与 Gitalk 类似的评论插件叫 Gitment，然而这款有国内大神编写的评论插件已经不再维护，因此就只能选择国外的 Gitalk 了，并且 Gitalk 支持移动端。&lt;/p&gt;
&lt;h4 id=&quot;为什么要用-gitalk&quot;&gt;2、为什么要用 Gitalk&lt;/h4&gt;
&lt;p&gt;我们知道 hexo 博客 的 Next 主题支持多种评论系统的继承，例如 Disqus，畅言，网易云跟帖，多说，来比力，友说，红杏等评论系统，但是这些评论系统要么不再提供服务，要么需要「科学上网」才能够加载，要么就是龟速加载，好吧，我想说的就是 Gitalk ，现在你明白为啥要用 Gitalk 了？&lt;/p&gt;
&lt;h4 id=&quot;gitalk-评论系统集成&quot;&gt;3、Gitalk 评论系统集成&lt;/h4&gt;
&lt;p&gt;（1）新建一个 GitHub 仓库，用于存放评论的记录，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/22/162ee049fb8428a3?w=771&amp;amp;h=590&amp;amp;f=png&amp;amp;s=47876&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）在 GitHub 上新建一个 OAuth application ： &lt;a href=&quot;https://github.com/settings/applications/new&quot;&gt;点击这里可以直接新建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新建 OAuth application 详细说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Application name //第（1）点建立的仓库名称
Homepage URL //博客地址
Application description //可不填
Authorization callback URL //博客地址&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/22/162ee049fb6ab50c?w=820&amp;amp;h=563&amp;amp;f=png&amp;amp;s=38860&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成后，我们回获得如下图中的相关信息，后面可能会用到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/22/162ee049fbaf681f?w=782&amp;amp;h=430&amp;amp;f=png&amp;amp;s=32958&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）创建 Gitalk 的 swig 文件，在博客的主目录中打开 &lt;code&gt;themes/next/layout/_third-party/comments&lt;/code&gt; 文件夹，新建 gitalk.swig 文件，在文件中配置如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %}
  
  {% if theme.gitalk.enable %}  //_config.yml文件若没有添加enable: true可删除该判断

    {% if theme.gitalk.distractionFreeMode  %}      
      &amp;lt;link rel='stylesheet' href=&quot;https://yiyeti.cc/usr/themes/veryse/css/gitalk.css&quot;&amp;gt;
      &amp;lt;script src=&quot;https://yiyeti.cc/usr/themes/veryse/css/gitalk.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
          var gitalk = new Gitalk({
            clientID:  '{{theme.gitalk.clientID}}', 
            clientSecret: '{{theme.gitalk.clientSecret}}',
            id: window.location.pathname,
            repo: '{{theme.gitalk.repo}}', 
            owner: '{{theme.gitalk.owner}}', 
            admin: '{{theme.gitalk.admin}}', 
            distractionFreeMode: '{{theme.gitalk.distractionFreeMode}}',
          })
          gitalk.render('gitalk-container')
      &amp;lt;/script&amp;gt;
    {% endif %}

  {% endif %}
{% endif %}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）在同样的目录下找到并打开 &lt;code&gt;index.swig&lt;/code&gt; 文件，在文件中配置如下代码引入 gitalk.swig 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% include 'gitalk.swig' %}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）在博客的主目录中打开 &lt;code&gt;themes/next/layout/_partials/&lt;/code&gt; 文件夹，找到并打开 &lt;code&gt;comments.swig&lt;/code&gt; 文件，找到最后一个if分支，即下面这个分支代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% elseif theme.valine.appid and theme.valine.appkey %}
      &amp;lt;div id=&quot;vcomments&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个 if 分支后加一个 Gitalk 的分支，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% elseif theme.gitalk.enable %}
 &amp;lt;div id=&quot;gitalk-container&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）在 &lt;code&gt;themes/next/_config.xml&lt;/code&gt; 主题配置文件中加入如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gitalk:
  enable: true  # 是否开启 Gitalk 评论
  owner:    # GitHub 用户名     
  repo:         #仓库名称
  ClientID: ******
  ClientSecret: ******
  admin:    # GitHub 用户名
  distractionFreeMode: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，Gitalk 评论系统基本就已经集成了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后记：&lt;/strong&gt; 最近 GitHub 限制了访问 label 的长度，即当我们博客文章的标题标签转换成 Issue超过 50 个字符时，Gitalk 评论系统便无法进行初始化，即对我们博客题目有了限制。而对于这个问题的解决，目前的想法是可以通过 md5 转换的方式封装 id，后续如果有好的解决办法，再更新吧。&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;---------------------------------------------&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/22/162ee052f2f34569?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27341&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 15:46:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8911112.html</dc:identifier>
</item>
<item>
<title>测试修改gcs_server_processes参数 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/8910817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/8910817.html</guid>
<description>&lt;p&gt;RAC部署前提是要求各节点的主机硬件一致的，但实际如果碰上一些不规范的客户，经费有限或是扩容时已买不到同样的机器，那么采购的机器会有一些区别，比如RAC各节点的CPU核数有区别，那么默认的gcs_server_processes在各节点之间也可能不同。而我们针对这种情况是建议RAC各节点使用相同的gcs_server_processes参数值，尽可能的确保稳定性。当然，最棒的选择还是用同样的硬件。&lt;/p&gt;

&lt;p&gt;我有一套Oracle 10.2.0.5 RAC (3 nodes)的RAC测试环境，之前每个虚拟机的CPU都是1，如今将节点2的CPU改为4。&lt;br/&gt;然后去看各个节点的cpu和gcs参数：&lt;br/&gt;show parameter cpu&lt;br/&gt;show parameter gcs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--NODE1:
SYS@jy1 &amp;gt;show parameter cpu

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
cpu_count                            integer     1
parallel_threads_per_cpu             integer     2
SYS@jy1 &amp;gt;show parameter gcs

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
gcs_server_processes                 integer     1
SYS@jy1 &amp;gt;

--NODE2:
SYS@jy2 &amp;gt;show parameter cpu

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
cpu_count                            integer     4
parallel_threads_per_cpu             integer     2
SYS@jy2 &amp;gt;show parameter gcs

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
gcs_server_processes                 integer     2
SYS@jy2 &amp;gt;

--NODE3:
SYS@jy3 &amp;gt;show parameter cpu

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
cpu_count                            integer     1
parallel_threads_per_cpu             integer     2
SYS@jy3 &amp;gt;show parameter gcs

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
gcs_server_processes                 integer     1
SYS@jy3 &amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到节点2的gcs_server_processes是2，其余节点都是1。&lt;/p&gt;

&lt;p&gt;在节点2上操作，统一修改gcs_server_processes参数：&lt;br/&gt;alter system set gcs_server_processes = 1 scope=spfile sid='*';&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SYS@jy2 &amp;gt;show parameter pfile

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
spfile                               string      +ZHAOJINGYU/newdg/spfilejy.ora
SYS@jy2 &amp;gt;alter system set gcs_server_processes = 1 scope=spfile sid='*';

System altered.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要重启实例生效。&lt;/p&gt;

&lt;p&gt;可以使用reset回退修改：&lt;br/&gt;alter system reset gcs_server_processes scope=spfile sid='*';&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--reset 回退
SYS@jy2 &amp;gt;alter system reset gcs_server_processes scope=spfile sid='*';   

System altered.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样需要重启生效。&lt;br/&gt;实验过程中看了下ASM实例的这个参数本来都是1，也就是不需要修改，实际大家有类似生产环境可以再确认下这个ASM实例上的gcs_server_processes参数是否都是1。&lt;br/&gt;最后做完实验，将RAC第二节点的CPU数调整回1。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 15:41:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/8910817.html</dc:identifier>
</item>
<item>
<title>Java并发编程：JMM(Java内存模型)和volatile - butterfly100</title>
<link>http://www.cnblogs.com/butterfly100/p/8910553.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/butterfly100/p/8910553.html</guid>
<description>&lt;h2 id=&quot;1-并发编程的3个概念&quot; data-anchor-id=&quot;oq2r&quot;&gt;1. 并发编程的3个概念&lt;/h2&gt;
&lt;p data-anchor-id=&quot;0vf0&quot;&gt;并发编程时，要想并发程序正确地执行，必须要保证原子性、可见性和有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。&lt;/p&gt;
&lt;h3 id=&quot;11-原子性&quot; data-anchor-id=&quot;g1cb&quot;&gt;1.1. 原子性&lt;/h3&gt;
&lt;p data-anchor-id=&quot;8vx1&quot;&gt;原子性：&lt;span&gt;即一个或多个操作要么全部执行并且执行过程中不会被打断，要么都不执行&lt;/span&gt;。&lt;/p&gt;
&lt;p data-anchor-id=&quot;b6pl&quot;&gt;一个经典的例子就是银行转账：从账户A向账户B转账1000元，此时包含两个操作：账户A减去1000元，账户B加上1000元。这两个操作必须具备原子性才能保证转账安全。假如账户A减去1000元之后，操作被打断了，账户B却没有收到转过来的1000元，此时就出问题了。 &lt;/p&gt;
&lt;p data-anchor-id=&quot;b6pl&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;12-可见性&quot; data-anchor-id=&quot;v8c9&quot;&gt;1.2. 可见性&lt;/h3&gt;
&lt;p data-anchor-id=&quot;dwj3&quot;&gt;可见性：&lt;span&gt;即多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的最新值&lt;/span&gt;。&lt;/p&gt;
&lt;p data-anchor-id=&quot;m7h5&quot;&gt;例如下段代码，线程1修改i的值，线程2却没有立即看到线程1修改的i的最新值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程1执行的代码&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
i &lt;/span&gt;= 10&lt;span&gt;;
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程2执行的代码&lt;/span&gt;
j = i;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如执行线程1的是CPU1，执行线程2的是CPU2。当线程1执行&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;i=10&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 时，会将CPU1的高速缓存中i的值赋值为10，却没有立即写入主内存中。此时线程2执行&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;j=i&lt;/code&gt;，会先从主内存中读取i的值并加载到CPU2的高速缓存中，此时主内存中的i=0，那么就会使得j最终赋值为0，而不是10。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;13-有序性&quot; data-anchor-id=&quot;19ds&quot;&gt;1.3. 有序性&lt;/h3&gt;
&lt;p data-anchor-id=&quot;8ee1&quot;&gt;有序性：&lt;span&gt;即程序执行的顺序按代码的先后顺序执行&lt;/span&gt;。&lt;/p&gt;
&lt;p data-anchor-id=&quot;xbc0&quot;&gt;例如下面这段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
i &lt;/span&gt;= 1&lt;span&gt;;
flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在代码顺序上&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;i=1&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 在&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;flag=true&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 前面，而 JVM 在真正执行代码的时候不一定能保证&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;i=1&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 在&lt;code&gt;flag=true&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 前面执行，这里就发生了&lt;strong&gt;&lt;span&gt;&lt;code&gt;指令重排序&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 data-anchor-id=&quot;x8i7&quot;&gt; &lt;/h4&gt;
&lt;h4 id=&quot;指令重排序&quot; data-anchor-id=&quot;x8i7&quot;&gt;指令重排序&lt;/h4&gt;
&lt;p data-anchor-id=&quot;r6h1&quot;&gt;一般是为了提升程序运行效率，编译器或处理器通常会做指令重排序：&lt;/p&gt;
&lt;ul data-anchor-id=&quot;oc9o&quot;&gt;&lt;li&gt;编译器重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序&lt;/li&gt;
&lt;li&gt;处理器重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。CPU 在指令重排序时会考虑指令之间的数据依赖性，如果指令2必须依赖用到指令1的结果，那么CPU会保证指令1在指令2之前执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p data-anchor-id=&quot;y97a&quot;&gt;指令重排序不保证程序中各个语句的执行顺序和代码中的一致，但会保证程序最终执行结果和代码顺序执行的结果是一致的。比如上例中的代码，&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;i=1&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 和&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;flag=true&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 两个语句先后执行对最终的程序结果没有影响，就有可能 CPU 先执行&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;flag=true&lt;/code&gt;，后执行&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;i=1&lt;/code&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-java-内存模型&quot; data-anchor-id=&quot;wznk&quot;&gt;2. java 内存模型&lt;/h2&gt;
&lt;p data-anchor-id=&quot;74bo&quot;&gt;由于 volatile 关键字是与 java 内存模型相关的，因此了解 volatile 前，需要先了解下 java 内存模型相关概念 &lt;/p&gt;
&lt;h3 id=&quot;21-硬件效率与缓存一致性&quot; data-anchor-id=&quot;f4v0&quot;&gt;2.1. 硬件效率与缓存一致性&lt;/h3&gt;
&lt;p data-anchor-id=&quot;k55x&quot;&gt;计算机执行程序时，每条指令都是在 CPU 中执行的，而执行指令过程中，势必涉及到数据的读取和写入。CPU 在与内存交互时，需要读取运算数据、存储结果数据，这些 I/O 操作的速度与 CPU 的处理速度有几个数量级的差距，所以不得不加入一层读写速度尽可能接近 CPU 运算速度的高速缓存（Cache）来作为内存与 CPU 之间的缓冲：将运算需要使用的数据复制到高速Cache中；运算结束后再从高速Cache同步回内存中。这样 CPU 就无需等待缓慢的内存读写了。&lt;/p&gt;
&lt;p data-anchor-id=&quot;xqma&quot;&gt;这在单线程中运行是没有问题的，但在多线程中运行就引入了 &lt;strong&gt;&lt;code&gt;缓存一致性 &lt;/code&gt;&lt;/strong&gt;的问题：在多处理系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个 CPU 的运算任务都涉及同一主内存区域时，将可能导致各自的缓存数据不一致，此时同步回主内存时以谁的数据为准呢？&lt;/p&gt;
&lt;p data-anchor-id=&quot;3hbc&quot;&gt;为了解决缓存一致性问题，通常有两种解决方法：&lt;/p&gt;
&lt;ol data-anchor-id=&quot;3n0c&quot;&gt;&lt;li&gt;在总线加 LOCK# 锁的方式&lt;/li&gt;
&lt;li&gt;缓存一致性协议&lt;/li&gt;
&lt;/ol&gt;&lt;p data-anchor-id=&quot;64sc&quot;&gt;早期的 CPU 中，通过在总线上加 LOCK# 锁的形式来解决，因为 CPU 在和其他部件通信时都是通过总线进行，如果对总线加 LOCK# 锁，也就阻塞了 CPU 对其他部件访问（如内存），而使得只能有一个 CPU 使用这个变量的内存。&lt;/p&gt;
&lt;p data-anchor-id=&quot;64sc&quot;&gt;但这种方式有一个问题，在锁住总线期间，其他 CPU 无法访问内存，导致效率低下。&lt;/p&gt;
&lt;p data-anchor-id=&quot;64sc&quot;&gt;所有就出现了缓存一致性协议，最著名的就是 Intel 的 MESI 协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的， 它的核心思想是：CPU写数据时，如果操作的变量是共享变量（其他 CPU 的高速缓存中也存在该变量的副本），会发出信号通知其他 CPU 将该变量的缓存设置为无效状态，那么当其他 CPU 读取该变量时，就会从内存重新读取。&lt;/p&gt;
&lt;p data-anchor-id=&quot;64sc&quot;&gt;JVM 有自己的内存模型，在访问缓存时，遵循一些协议来解决缓存一致性的问题。&lt;/p&gt;
&lt;p data-anchor-id=&quot;64sc&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;22-主内存和工作内存&quot; data-anchor-id=&quot;4xia&quot;&gt;2.2. 主内存和工作内存&lt;/h3&gt;
&lt;p data-anchor-id=&quot;6ij7&quot;&gt;Java虚拟机规范中试图定义一种 Java 内存模型（JMM, Java Memory Model）来屏蔽硬件和操作系统的内存访问差异，实现 Java 程序在各种平台上达到一致的内存访问效果。&lt;/p&gt;
&lt;p data-anchor-id=&quot;6ij7&quot;&gt;Java 内存模型主要目标：是定义程序中各个变量的访问规则，即存储变量到内存和从内存中取出变量这样的底层细节。为了较好的执行性能，Java 内存模型并没有限制使用 CPU 的寄存器和高速缓存来提升指令执行速度，也没有限制编译器对指令做重排序。也就是说：在 Java 内存模型中，也会存在缓存一致性问题和指令重排序问题。&lt;/p&gt;
&lt;p data-anchor-id=&quot;zqri&quot;&gt;Java 内存模型规定所有的变量（包括实例字段、静态字段、构成数组对象的元素，不包括线程私有的局部变量和方法参数，因为这些不会出现竞争问题）都存储在主内存中，每条线程有自己的工作内存（可与之前将讲的CPU高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存拷贝副本。线程对变量的所有操作（read，write）都必须在工作内存中进行，而不能直接读写主内存中的变量，线程间变量值的传递需要通过主内存来完成。如图所示：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;zqri&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201804/1278254-20180422224635504-447460316.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;zqri&quot;&gt; &lt;/p&gt;
&lt;h3 data-anchor-id=&quot;qqzk&quot;&gt;2.3. JMM如何处理原子性&lt;/h3&gt;
&lt;p data-anchor-id=&quot;az5q&quot;&gt;像以下语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
x = 10;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句1&lt;/span&gt;
y = x;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句2&lt;/span&gt;
x++;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句3&lt;/span&gt;
x = x + 1;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只有语句1才是原子性的操作，其他都不是原子性操作。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;dzoz&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;语句1是直接将10赋值给x变量，也就是说线程执行这个语句时，会直接将10写入到工作内存中。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;dzoz&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;语句2包含了两个操作，先读取x的值，然后将x的值写入到工作内存赋值给y，这两个操作合起来就不是原子性操作了。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;dzoz&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;语句3和4都包括3个操作，先读取x的值，然后加1操作，最后写入新值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;dzoz&quot;&gt;单线程环境下，我们可以认为整个步骤都是原子性的。但多线程环境下则不同，只有基本数据类型的访问读写是具备原子性的，如果还需要提供更大范围的原子性保证，可以使用同步代码块 -- synchronized 关键字。在 synchronized 块之间的操作具备原子性。&lt;/p&gt;
&lt;p data-anchor-id=&quot;dzoz&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;232-保证可见性&quot; data-anchor-id=&quot;pezs&quot;&gt;2.4. JMM如何处理可见性&lt;/h3&gt;
&lt;p data-anchor-id=&quot;op2z&quot;&gt;Java 内存模型是通过变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式实现可见性的。普通变量和 volatile 变量都如此，区别在于：&lt;/p&gt;
&lt;ul&gt;&lt;li data-anchor-id=&quot;op2z&quot;&gt;volatile 特殊规则保证了新值能立即同步回主内存，以及每次改前立即从主内存刷新。因此 volatile 变量保证了多线程操作时变量的可见性&lt;/li&gt;
&lt;li data-anchor-id=&quot;op2z&quot;&gt;而普通变量无法保证这一点，因为普通的共享变量修改后，什么时候同步写回主内存是不确定的，其他线程读取时，此时内存中的可能还是原来的旧值。&lt;/li&gt;
&lt;/ul&gt;&lt;p data-anchor-id=&quot;6kjv&quot;&gt;除了 volatile 变量外，synchronized 和 final 关键字也能实现可见性。&lt;/p&gt;
&lt;p data-anchor-id=&quot;6kjv&quot;&gt;synchronized 同步块的可见性是由：&lt;span&gt;&lt;code&gt;对一个变量执行 unlock 操作前，必须先把此变量同步回主内存中&lt;/code&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 这条规则获得的。&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;6kjv&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;final 可见性是指：&lt;span&gt;&lt;code&gt;被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this的引用传递出去，那在其他线程中就能看见final字段的值&lt;/code&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;6kjv&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;233-保证有序性&quot; data-anchor-id=&quot;yhow&quot;&gt;2.5. JMM如何处理有序性&lt;/h3&gt;
&lt;p data-anchor-id=&quot;n5v3&quot;&gt;Java 程序中天然的有序性可概括为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句指：&lt;span&gt;&lt;code&gt;线程内表现为串行语义&lt;/code&gt;&lt;/span&gt;，后半句是指：&lt;span&gt;&lt;code&gt;指令重排序&lt;/code&gt;现象&lt;/span&gt;和&lt;span&gt;&lt;code&gt;工作内存和主内存同步延迟&lt;/code&gt;现象&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;1f22&quot;&gt;Java 中提供了 volatile 和 synchronized 关键字来保证线程之间操作的有序性。volatile 本身就包含了禁止指令重排序的语义，而 synchronized 是由&lt;span&gt;&lt;code&gt;一个变量在同一时刻只允许一条线程对其 lock 操作&lt;/code&gt;&lt;span&gt;这条&lt;/span&gt;&lt;/span&gt;规则获得，这条规则决定了持有同一个锁的两个同步代码块只能串行的执行。&lt;/p&gt;
&lt;p data-anchor-id=&quot;1f22&quot;&gt; &lt;/p&gt;
&lt;h4 id=&quot;happens-before&quot; data-anchor-id=&quot;vr4o&quot;&gt;happens-before 原则&lt;/h4&gt;
&lt;p data-anchor-id=&quot;8rjs&quot;&gt;Java内存模型中，有序性保证不仅只有 synchronized 和 volatile，否则一切操作都将变得繁琐。Java 中还有一个&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;&lt;span&gt;&lt;code&gt;happens-before 原则&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;，它是判断线程是否安全的主要依据。依靠这个规则，可以保证程序的有序性，如果两个操作的执行顺序无法从 happens-before 原则中推导出来，则他们就不能保证有序性，可以随意重排序。&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;0zs3&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;happens-before(先行发生)&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt; &lt;/span&gt;是 Java 内存模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，那么就是说发生操作B之前，操作A产生的影响能被操作B观察到。影响包括修改内存中共享变量的值、发送了消息、调用了方法等。&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;vdos&quot;&gt;下面是 Java 内存模型下的天然的先行发生关系，这些关系无需任何同步就已经存在：&lt;/p&gt;
&lt;ul data-anchor-id=&quot;5v6u&quot;&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;程序次序规则&lt;/code&gt;&lt;/strong&gt;：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的来说，应该是控制流顺序，而不是代码顺序，因为要考虑分支、循环等结构&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;管程锁定规则&lt;/code&gt;&lt;/strong&gt;：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;volatile变量规则&lt;/code&gt;&lt;/strong&gt;：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;线程启动规则&lt;/code&gt;&lt;/strong&gt;：Thread 对象的 start() 方法先行发生于此线程的每个一个动作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;线程终止规则&lt;/code&gt;&lt;/strong&gt;：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程是否已经终止执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;线程中断规则&lt;/code&gt;&lt;/strong&gt;：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可通过 Thread.isinterrupted() 检测是否有中断发生&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;对象终结规则&lt;/code&gt;&lt;/strong&gt;：一个对象的初始化完成先行发生于他的 finalize() 方法的开始&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;传递规则&lt;/code&gt;&lt;/strong&gt;：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C&lt;/li&gt;
&lt;/ul&gt;&lt;p data-anchor-id=&quot;gy8h&quot;&gt;第一条&lt;code&gt;程序次序原则&lt;/code&gt;，&quot;书写在前面的操作先行发生于书写在后面的操作&quot;，这个应该是一段程序代码的执行在单线程中&lt;strong&gt;看起来是有序的&lt;/strong&gt;，因为虚拟机可能对程序代码中不存在数据依赖性的指令进行重排序，但最终执行结果与顺序执行的结果是一致的。而在多线程中，无法保证程序执行的有序性。&lt;/p&gt;
&lt;p data-anchor-id=&quot;e5mk&quot;&gt;第二条，第三条分别是关于 synchronized同步块 和 volatile 的规则。第四至第七条是关于 Thread 线程的规则。第八条是体现了 happens-before 原则的传递性。&lt;/p&gt;
&lt;p data-anchor-id=&quot;z56b&quot;&gt;下面是一个利用 happens-before 规则判断操作间是否具备顺序性的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value=0&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; setValue() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;ve88&quot;&gt;这段是一段普通的 getter/setter 方法，假如线程A先调用（时间上的先后）了 setValue(1)，然后线程B调用了同一个对象的 getValue()，那么线程B的返回值是什么呢？&lt;/p&gt;
&lt;p data-anchor-id=&quot;xpgo&quot;&gt;我们按以上 happens-before 规则分析：&lt;/p&gt;
&lt;ul&gt;&lt;li data-anchor-id=&quot;xpgo&quot;&gt;由于存在线程A和线程B调用，不在一个线程中，&lt;code&gt;程序次序原则&lt;/code&gt;则不适用；&lt;/li&gt;
&lt;li data-anchor-id=&quot;xpgo&quot;&gt;没有同步快，也没有unlock和lock操作，所以&lt;code&gt;管程锁定规则&lt;/code&gt;不适用；&lt;/li&gt;
&lt;li data-anchor-id=&quot;xpgo&quot;&gt;由于 value 没有被 volatile 修饰，所以&lt;code&gt;volatile变量规则&lt;/code&gt;不适用；&lt;/li&gt;
&lt;li data-anchor-id=&quot;xpgo&quot;&gt;后面的线程启动、终止、中断、终结和这里没有关系；&lt;/li&gt;
&lt;li data-anchor-id=&quot;xpgo&quot;&gt;由于没有适用的 happens-before 规则，最后的传递性也不适用&lt;/li&gt;
&lt;/ul&gt;&lt;p data-anchor-id=&quot;xpgo&quot;&gt;因此，可以判定尽管线程A在操作时间上先与线程B，但无法确定线程B中 getValue() 的返回值，也就是说，这里的操作不是线程安全的。&lt;/p&gt;
&lt;p data-anchor-id=&quot;mxhr&quot;&gt;该如何修复这个问题呢？可以有两种方法：&lt;/p&gt;
&lt;ul data-anchor-id=&quot;ptbd&quot;&gt;&lt;li&gt;将 getter/setter 定义为 synchronized 方法，这样可以套用 &lt;strong&gt;&lt;span&gt;&lt;code&gt;管程锁定规则&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用 volatile 关键字修饰 value，这样可以套用 &lt;span&gt;&lt;strong&gt;&lt;code&gt;volatile变量规则&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-anchor-id=&quot;1wc1&quot;&gt;时间先后顺序和 happens-before 原则之间没有太大的关系，所以当我们衡量并发安全问题时，不要受到时间顺序的干扰，一切应以 happens-before 原则为准。&lt;/p&gt;
&lt;h2 id=&quot;3-volatile-实现原理&quot; data-anchor-id=&quot;lhvs&quot;&gt;3. volatile 实现原理&lt;/h2&gt;
&lt;p data-anchor-id=&quot;4inv&quot;&gt;volatile 关键字是 JVM 提供的最轻量级的同步机制，当一个变量定义为 volatile 后，它将具有普通变量没有的两种特性：&lt;/p&gt;
&lt;ol data-anchor-id=&quot;jrxq&quot;&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;保证此变量对所有线程的可见性&lt;/code&gt;&lt;/span&gt;：当一个线程修改了该变量的值，新值对于其他线程来说是可以立即得知的。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;禁止指令重排序优化&lt;/code&gt;&lt;/span&gt;。普通变量只能保证在方法执行过程中所有依赖赋值结果的地方都能获得正确的结果，而不能保证变量赋值操作的顺序和代码中的顺序一致，这也就是上文中提到的 Java 内存模型中所谓的&quot;线程内表现为串行语义&quot;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;31-volatile-保证原子性吗&quot; data-anchor-id=&quot;345x&quot;&gt;3.1. volatile 保证原子性吗&lt;/h3&gt;
&lt;p data-anchor-id=&quot;6pn7&quot;&gt;基于 volatile 变量的运算在并发下并不一定是线程安全的。因为 Java 里的运算并非原子操作，例如下面是一个 volatile 变量自增运算的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VolatileTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; race = 0&lt;span&gt;;
     
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; increase() {
        race&lt;/span&gt;++&lt;span&gt;;
    }
     
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Thread[] threads &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread[20&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;20; i++&lt;span&gt;){
            threads[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread( &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;10000; i++&lt;span&gt;)
                        increase();
                };
            });
            threads[i].start();
        }

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(Thread.activeCount()&amp;gt;1)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待所有累加的线程都结束&lt;/span&gt;
&lt;span&gt;            Thread.yield();
        System.out.println(race);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码发起了20个线程，每个线程对 race 累加10000次，如果并发正确的话，输出结果应该是200000。而运行完这段代码后，每次输出的结果不一样，都是小于200000。&lt;/p&gt;
&lt;p data-anchor-id=&quot;hspp&quot;&gt;问题就在于 race 通过 volatile 修饰只能保证每次读取的都是最新的值，但不保证 race++ 是原子性的操作，它包括读取变量的初始化，加1操作，将新值同步写到主内存 三步。自增操作的三个子操作可能会分开执行。&lt;/p&gt;
&lt;p data-anchor-id=&quot;f9vc&quot;&gt;假如某时刻 race 值为10，线程A 对 race 做自增操作，先读取 race 的最新值10，此时 volatile 保证了 race 的值在此刻是正确的，但执行加1的时候，其他线程可能已经将 race 的值加大了，此时线程A工作内存中的 race 值就变成了过期的数据，然后将过期较小的新值同步回主内存。此时，多个线程对 race 分别做了一次自增操作，但可能主内存中的 race 值只增加了1。&lt;/p&gt;
&lt;p data-anchor-id=&quot;dakh&quot;&gt;volatile 无法保证对变量的任何操作都是原子性的，可以使用 synchronized 或 java.util.concurrent 中的原子类来修改。&lt;/p&gt;
&lt;p data-anchor-id=&quot;dakh&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;32-volatile-保证可见性吗&quot; data-anchor-id=&quot;u8yi&quot;&gt;3.2. volatile 保证可见性吗&lt;/h3&gt;
&lt;p data-anchor-id=&quot;0fm5&quot;&gt;下面代码，线程A先执行，线程B后执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程A&lt;/span&gt;
&lt;span&gt;boolean&lt;/span&gt; stop = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;stop){
    doSomething();
}
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程B&lt;/span&gt;
stop = &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;x60s&quot;&gt;这段代码在大多数时候，能将线程A中的while循环结束，但有时候也会导致无法结束线程，造成一直while循环。原因在于：前面提到每个线程都有自己的工作内存，线程A运行时，会将 stop=false 的值同步一份在自己的工作内存中。当线程B更新了stop的值为true后，可能还没来得及同步到主内存中，就去做其他事情了。此时线程B中 stop=true 的修改对于线程A是可不见的，导致线程A会一直循环下去。&lt;/p&gt;
&lt;p data-anchor-id=&quot;ptv3&quot;&gt;如果将stop使用 volatile 修饰后，就可以保证线程A能退出循环。在于：使用 volatile 关键字会强制将线程B修改的新值stop立即同步至主内存。当线程B修改时，会导致线程A工作内存中stop的缓存行无效，反映到硬件上，就是CPU的高速缓存中对应的缓存行无效。线程A的工作内存中stop的缓存行无效后，会到主内存中再次读取变量stop的新值。从而 volatile 保证了共享变量的可见性。&lt;/p&gt;
&lt;p data-anchor-id=&quot;ptv3&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;33-volatile-保证有序性吗&quot; data-anchor-id=&quot;ktwb&quot;&gt;3.3. volatile 保证有序性吗&lt;/h3&gt;
&lt;p data-anchor-id=&quot;u4lw&quot;&gt;volatile 可以通过禁止指令重排序来保证有序性，有两层意思：&lt;/p&gt;
&lt;ul data-anchor-id=&quot;355k&quot;&gt;&lt;li&gt;当程序执行到 volatile 变量的读操作或写操作时：在其前面的操作肯定全部已经完成，且结果对后面的操作可见。在其后面的操作肯定还没进行&lt;/li&gt;
&lt;li&gt;指令重排序优化时，不能将 volatile 变量前面的语句放在其后面执行，也不能将 volatile 变量后面的语句放到其前面执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p data-anchor-id=&quot;6r4b&quot;&gt;举个例子如下，flag是 volatile 变量，x/y都是非 volatile 变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
x = 2;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句1&lt;/span&gt;
y = 0;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句2&lt;/span&gt;
flag = &lt;span&gt;true&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句3&lt;/span&gt;
x = 4;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句4&lt;/span&gt;
y = -1;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语句5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;qv4a&quot;&gt;在指令重排序时候，因为flag是 volatile 变量。所以执行到语句3时，语句1和语句2必定是执行完成了，且执行结果对语句3、语句4和语句5是可见的。不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面。语句1和语句2的顺序，语句4和语句5的顺序是不做保证的。&lt;/p&gt;
&lt;p data-anchor-id=&quot;ksu3&quot;&gt;下面是一个指令重排序会干扰程序并发执行的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Map config;
&lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; init = &lt;span&gt;false&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量定义为volatile

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程A执行
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取配置信息，读取完后将init设置为true，以通知其他线程配置使用&lt;/span&gt;
config =&lt;span&gt; loadConfig();
init &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程B执行
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待init为true，代表线程A已经将配置初始化好&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;init) {
    sleep();
}
doSomeThingWhihConfig(config);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用线程A中初始化好的配置信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如 init 变量没有使用 volatile 修饰，可能由于指令重排序的优化，导致线程A最后一句 init=true 提前执行（指这句代码对应的汇编代码被提前执行），这样线程B中使用配置信息的代码就可能出错。而使用 volatile 对 init 变量进行修饰，就可以避免这种情况，因为执行到 init=true 时，可以保证 config 已经初始化好了。&lt;/p&gt;

&lt;div class=&quot;md-section-divider&quot; readability=&quot;18&quot;&gt;
&lt;h3 id=&quot;34-内存屏障&quot; data-anchor-id=&quot;jo6j&quot;&gt;3.4. 内存屏障&lt;/h3&gt;
&lt;p data-anchor-id=&quot;wsr3&quot;&gt;volatile 关键字是如何禁止指令重排序的？关键在于有 volatile 关键字和没有 volatile 关键字所生成的汇编代码，加入 volatile 修饰的变量，&lt;span&gt;赋值后会多执行一个lock前缀指令，这个指令相当于一个&lt;code&gt;内存屏障&lt;/code&gt;&lt;/span&gt;。通过内存屏障实现对内存操作的顺序限制，它提供了3个功能：&lt;/p&gt;
&lt;ul data-anchor-id=&quot;qxf0&quot;&gt;&lt;li&gt;确保指令重排序时不会把后面的指令排到内存屏障之前的位置，也不会把前面的指令排序到内存屏障的后面。这样形成了指令重排序无法越过内存屏障的效果&lt;/li&gt;
&lt;li&gt;强制将对工作内存的修改立即写入主内存&lt;/li&gt;
&lt;li&gt;如果是写操作，会导致其他 CPU 中对应的缓存行无效&lt;/li&gt;
&lt;/ul&gt;&lt;p data-anchor-id=&quot;acrs&quot;&gt;只有一个 CPU 访问内存时，不需要内存屏障；但如果有两个或更多 CPU 访问同一块内存，且其中一个在观察另一个，就需要内存屏障来保证一致性了。&lt;/p&gt;
&lt;p data-anchor-id=&quot;acrs&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;35-volatile-使用场景&quot; data-anchor-id=&quot;bj8h&quot;&gt;3.5. volatile 使用场景&lt;/h3&gt;
&lt;p data-anchor-id=&quot;iavp&quot;&gt;某些情况下，volatile 同步机制的性能确实要优于锁（使用 synchronized 或 java.util.concurrent 包里面的锁），但由于对锁实现的很多优化和消除，使得很难量化的认为 volatile 会比 synchronized 快多少。如果 volatile 和自己比较的话，volatile 读操作的性能消耗与普通变量基本没有什么差别，但写操作可能慢一些，因为它需要在本地代码中插入许多内存屏障指令保证处理器不会乱序执行。即便如此，大多数场景下 volatile 的总开销仍然比锁低，volatile 无法保证操作的原子性，是无法替代 synchronized的。在 volatile 和锁之间选择的唯一依据是 volatile 的语义能否满足场景的需求。通常，使用 volatile 必须具备以下两个条件：&lt;/p&gt;
&lt;ul data-anchor-id=&quot;nge4&quot;&gt;&lt;li&gt;对变量的写操作不依赖于当前值，例如 count++ 这样自增自减操作就不满足这个条件&lt;/li&gt;
&lt;li&gt;该变量没有包含在具有其他变量的不变式中&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2 id=&quot;4-参考&quot; data-anchor-id=&quot;ll02&quot;&gt;4. 参考&lt;/h2&gt;
</description>
<pubDate>Sun, 22 Apr 2018 15:35:00 +0000</pubDate>
<dc:creator>butterfly100</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/butterfly100/p/8910553.html</dc:identifier>
</item>
<item>
<title>邮件服务器的扩展 - MAX_T</title>
<link>http://www.cnblogs.com/wtang/p/8910836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wtang/p/8910836.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是个有趣的小项目.公司有不少系统是使用不同的语言写的,而有些语言调用smtp邮件服务器不是那么方便,那么我们的设想是写一个web app,提供一个POST的数据接口,能够接收email的信息.比如收件人地址,名字,邮件正文等,然后在web app内部再调用smtp服务器发送.公司内部其他系统想要发送邮件的话,只需要发送一个HTTP POST请求就好了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;br/&gt;使用express充当web server，创建路由。&lt;br/&gt;使用nodemailer创建smtp连接，发送邮件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;br/&gt;1. POST数据格式，有好几种，比如application/json, application/w-www/form-urlencoded. 所以在express中要添建相应的middleware来正确的解析提交的数据。&lt;/p&gt;
&lt;p&gt;2. 控制发送email的速度。通过POST接受到数据之后，不是马上发送，而是push到一个array中。然后再在一个同步的环境中，main process中，设置一个timer，间隔发送邮件。在nodejs编程特别要注意，因为好多都是异步的环境，在异步的环境下，是控制不住间隔发送的。&lt;/p&gt;
&lt;p&gt;3. 然后为了提高server接受request的能力，我写了nodejs cluster来fork了4个process来同时接受HTTP POST，但是后来想一想，这些事情可以使用反向代理服务器比如Nginx来做&lt;/p&gt;
&lt;p&gt;4. 因为这个程序是要部署到server上，一直运行的，所以一定要有logger，保存运行数据和错误处理。在Linux上有个deamon程序叫做forever可以帮助布置和收集console.log的日志。不然的话就要自己写一个logger，代替console.log，把日志写到log文件中。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Apr 2018 15:26:00 +0000</pubDate>
<dc:creator>MAX_T</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wtang/p/8910836.html</dc:identifier>
</item>
</channel>
</rss>