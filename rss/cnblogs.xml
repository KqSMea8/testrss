<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Scala编程快速入门系列（一） - Huidoo_Yang</title>
<link>http://www.cnblogs.com/yangp/p/8575705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangp/p/8575705.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;目    录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、Scala概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、Scala数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、Scala函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、Scala集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、Scala伴生对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、Scala trait&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七、Actor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;八、隐式转换与隐式参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;九、Scala JDBC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于整理的篇幅较长，所以文章计划分三次发布。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、Scala概述&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. Scala简介&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　Scala是一种针对JVM将函数和面向对象技术组合在一起的编程语言。所以Scala必须要有JVM才能运行，和Python一样，Scala也是可以面向对象和面向函数的。Scala编程语言近来抓住了很多开发者的眼球。它看起来像是一种纯粹的面向对象编程语言，而又无缝地结合了命令式和函数式的编程风格。Scala的名称表明，它还是一种高度可伸缩的语言。Scala的设计始终贯穿着一个理念：创造一种更好地支持组件的语言。Scala融汇了许多前所未有的特性，而同时又运行于JVM之上。随着开发者对Scala的兴趣日增，以及越来越多的工具支持，无疑Scala语言将成为你手上一件必不可少的工具。Spark最最源生支持的语言是Scala。Spark主要支持java、Scala、Python和R。Scala的底层协议是akka（异步消息传递）。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. Scala安装与开发工具&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　Scala版本使用&lt;a href=&quot;http://www.scala-lang.org/download/2.10.7.html&quot; target=&quot;_blank&quot;&gt;Scala-2.10.x&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　JDK使用jdk-1.8。&lt;/p&gt;
&lt;p&gt;　　开发工具使用&lt;a href=&quot;https://www.jetbrains.com/idea/download/#section=windows&quot; target=&quot;_blank&quot;&gt;Intellij IDEA-2017.3.5&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、Scala数据类型&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. 数据类型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180315195259270-929421610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　scala拥有和java一样的数据类型，和java的数据类型的内存布局完全一致，精度也完全一致。其中比较特殊的类型有Unit，表示没有返回值；Nothing表示没有值，是所有类型的子类型，创建一个类就一定有一个子类是Nothing；Any是所有类型的超类；AnyRef是所有引用类型的超类；注意最大的类是Object。&lt;/p&gt;
&lt;p&gt;　　上表中列出的数据类型都是对象，也就是说scala没有java中的原生类型。在scala是可以对数字等基础类型调用方法的。例如数字1可以调方法，使用1.方法名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180315222601865-1788242421.png&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180315222645076-1594358714.png&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　如上两图所示，可见所有类型的基类与Any。Any之后分为两个AnyVal与AnyRef。其中AnyVal是所有数值类型的父类型，AnyRef是所有引用类型的父类型。&lt;/p&gt;
&lt;p&gt;　　与其他语言稍微有点不同的是，Scala还定义了底类型。其中Null类型是所有引用类型的底类型，及所有AnyRef的类型的空值都是Null；而Nothing是所有类型的底类型，对应Any类型；Null与Nothing都表示空。&lt;/p&gt;
&lt;p&gt;　　在基础类型中只有String是继承自AnyRef的，与Java，Scala中的String也是内存不可变对象，这就意味着，所有的字符串操作都会产生新的字符串。其他的基础类型如Int等都是Scala包装的类型，例如Int类型对应的是Scala.Int只是Scala包会被每个源文件自动引用。&lt;/p&gt;
&lt;p&gt;　　标准类库中的Option类型用样例类来表示拿着可能存在、也可能不存在的值。样例子类Some包装了某个值，例如：Some(“Fred”)；而样例对象None表示没有值；这比使用空字符串的意图更加清晰，比使用null来表示缺少某值的做法更加安全（避免了空指针异常）。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 声明与定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　字段/变量的定义Scala中使用var/val 变量/不变量名称: 类型的方式进行定义，例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
var index1 : Int= 1&lt;span&gt;
val index2 : Int&lt;/span&gt;= 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在Scala中声明变量也可以不声明变量的类型。 &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;常量的声明 val&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　使用val来声明一个常量。与java一样，常量一次赋值不可修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
val name : String=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;//&lt;span&gt;这是完整的写法，可以省略类型，如下所示:
val name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yang2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;//会报错reassignment to val
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;变量的声明 var&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
var name : String = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; //&lt;span&gt;这是完整的写法，可以省略类型，如下所示:
//var name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yang&lt;/span&gt;&lt;span&gt;&quot; &lt;/span&gt;//变量或常量声明时，类型可以省略，Scala内部机制会推断。&lt;span&gt;
name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yang2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;//变量的值可以修改
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;函数的声明 def&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　使用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;span&gt;关键字来声明函数。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; main(args: Array[String]): Unit =&lt;span&gt; {
    println(f)
  }
  val a&lt;/span&gt;=1&lt;span&gt;
  var b&lt;/span&gt;=2
  &lt;span&gt;def&lt;/span&gt; f=a*&lt;span&gt;b
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　def f=a*b;//&lt;/span&gt;&lt;span&gt;只是定义&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;a*b&lt;/span&gt;&lt;span&gt;表达式的名字，并不求值，在使用的时候求值。这里&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Scala&lt;/span&gt;&lt;span&gt;已经推断出了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f函数的返回值&lt;/span&gt;&lt;span&gt;类型了，因为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;a&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;b&lt;/span&gt;&lt;span&gt;都是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Int&lt;/span&gt;&lt;span&gt;，所以&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f&lt;/span&gt;&lt;span&gt;也是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Int&lt;/span&gt;&lt;span&gt;。从控制台可以看出这个效果：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180316002143242-391106044.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　def f=a*b//如果写成val f，这时会直接算出结果。这是定义函数和定义常量的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180316002120215-517673636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 字符串&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　单行注释：//&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;单行字符串&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　同Java&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;多行字符串/多行注释&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　scala中还有类似于python的多行字符串表示方式（三个单引号），用三个双引号表示分隔符，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
val strs=&lt;span&gt;”””&lt;br/&gt;　　多行字符串的第一行

　　多行字符串的第二行

　　多行字符串的第三行”””&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;S字符串&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　S字符串，可以往字符串中传变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180316004048704-1820783393.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;455&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　S字符串可以调用变量/常量，在字符串前面加s，在字符串中使用${变量/常量名的数学表达式}，来调用变量。如图所示，字符串之前不写s，则原样输出。${变量/常量的数学表达式}，如上图所示对常量age进行计算。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;F字符串&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　传入的参数可以进行相应的格式的转化。例如：&lt;/p&gt;
&lt;p&gt;　　先val height = 1.7//声明了一个一位小数的常量身高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180316005822339-1936998717.png&quot; alt=&quot;&quot; width=&quot;575&quot; height=&quot;497&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　println(f&quot;$name%s is $height%.2f meters tall&quot;)//在字符串前加f使用f字符串的功能，包含了s字符串的调用变量的功能，并且在变量名后面跟%格式来格式化变量。例如%s是表示字符串，%.2f是精确到百分位。&lt;/p&gt;
&lt;p&gt;　　println(s&quot;$name%s is $height%.2f meters tall&quot;)//如果这里使用s字符串则只能包含s字符串调用变量的功能，不能使用f字符串格式化的功能。&lt;/p&gt;
&lt;p&gt;　　println(&quot;$name%s is $height%.2f meters tall&quot;)//如果不加s也不加f则原样输出。 &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;R字符串&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　R字符串和Python中的raw字符串是一样的，在java中要原样输出一些带\的字符，如\t、\n等需要在前面再加一个\转义，不然就会输出制表符、回车。比如\n就要写成\\n，才能原样输出\n，但是加上raw则不需要。例如：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180316010712530-776238347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意r字符串的使用是在字符串前面加raw，而不是r。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4. 懒加载&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　在Scala的底层有一个延迟执行功能，其核心是利用懒加载。如下图懒加载常量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180316012517905-284705169.png&quot; alt=&quot;&quot; width=&quot;437&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对比上面两条命令的差异，可以发现没有lazy的命令立即执行，并将1赋给常量x。而带有lazy的命令没有立即执行方法体，而是在后面val a=xl时才执行了方法体的内容。&lt;/p&gt;
&lt;p&gt;　　其中lazy是一个符号，表示懒加载；{println(&quot;I'mtoolazy&quot;);1}，花括号是方法体，花括号中的分号是隔开符，用于隔开两句话，方法体的最后一行作为方法的返回值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180316012947106-100130186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图所示，定义函数的效果和懒加载方式的效果一样，只有在调用的时候才会执行方法体。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、Scala 函数&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. 函数的定义&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;函数定义的一般形式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180316013851899-2014854031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图所示，其中def关键字表示开始一个函数的定义；max是函数名；小括号中的x和y表示参数列表，用逗号隔开；小括号中的参数后面的:类型表示参数的类型；参数列表之后的:类型是函数的返回值类型；等号表示要返回值，如果没有等号和返回值类型就表示不需要返回值，或返回值类型改为Unit也表示不需要返回值；花括号中的内容是方法体，方法体的最后一行将作为函数的返回值，这里的最后一行是x或者y。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;函数定义的简化形式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　省略return（实际已经简化）。Scala中，可以不写return，如果不写return则自动将最后一行作为返回值，如果没有返回值，则函数的返回类型为Unit，类似于Java中void。&lt;/p&gt;
&lt;p&gt;　　函数和变量一样，可以推断返回类型。所以上述函数可以简写成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; max( x : Int, y : Int) = {&lt;span&gt;if&lt;/span&gt;(x &amp;gt; y) x &lt;span&gt;else&lt;/span&gt; y}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里还可以进一步把方法体的花括号也省略，所以函数可以进一步简化为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; max(x : Int, y : Int) = &lt;span&gt;if&lt;/span&gt;(x&amp;gt;y) x &lt;span&gt;else&lt;/span&gt; y
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;案例一（单个参数）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;//&lt;span&gt;  定义sayMyName方法，方法需要一个参数，类型是String，默认值是Jack。方法体前面没有等号，就相当于没有返回值，Unit
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; sayMyName(name : String = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;){
    println(name)
  }
  &lt;/span&gt;//&lt;span&gt;函数的调用需要main函数
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    sayMyName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)//&lt;span&gt;如果没有使用参数sayMyName()则使用默认值张三，如果使用参数&quot;李四&quot;，则输出李四
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;案例二（多个参数，可变参数）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　多个相同类型的参数可以使用*表示，例如(k : Int*)表示多个Int类型的参数，具体数量不确定，类似于java中的可变参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; sumMoreParameter(k : Int*)=&lt;span&gt;{
    var sum&lt;/span&gt;=&lt;span&gt;0
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i &amp;lt;- k){//使用foreach(&amp;lt;-&lt;span&gt;)来遍历元素k
      println(i)
      sum &lt;/span&gt;+=&lt;span&gt; i
    }
    sum
  }
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    println(sumMoreParameter(&lt;/span&gt;3,5,4,6))//&lt;span&gt;这里传递的参数个数可变
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然也可以定义参数个数确定的函数，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; add(a:Int,b:Int) = a+b//&lt;span&gt;省略了方法体的花括号和方法返回值类型
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    println(add(&lt;/span&gt;3,6&lt;span&gt;))
  }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt; 案例三（下划线作参数）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　使用下划线做参数名称&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; add(a:Int,b:Int) = a+&lt;span&gt;b
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; add2 = add(_:Int,3)//&lt;span&gt;调用add方法，使用下划线是一个符号，可以不取变量名，参数的类型是Int
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    println(add2(&lt;/span&gt;5))//这里的结果和add(2,5)=&lt;span&gt;7是一样的。
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;2. 递归函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　递归实际上就是方法自己调自己，也可以看成是递推公式。以阶乘为例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;案例四（递归函数）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; fact(n: Int): Int = &lt;span&gt;if&lt;/span&gt; (n &amp;lt;= 0) 1 &lt;span&gt;else&lt;/span&gt; n * fact(n - 1&lt;span&gt;)//注意这里需要写方法的返回值类型Int，因为递归的方法体里面还有这个函数，所以无法对结果的类型进行推断。
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    println(fac(&lt;/span&gt;6&lt;span&gt;))
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;3. 柯里化函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。有时需要允许他人一会在你的函数上应用一些参数，然后又应用另外的一些参数。例如一个乘法函数，在一个场景需要选择乘数，而另一个场景需要选择被乘数。所以柯里化函数就是将多个参数分开写，写在不同的小括号里，而不是在一个小括号中用逗号隔开。例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;案例五（柯里化函数）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; mulitply(x:Int)(y:Int) = x*&lt;span&gt;y
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    println(mulitply(&lt;/span&gt;2)(4&lt;span&gt;))
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; mulitply(x:Int)(y:Int) = x*&lt;span&gt;y
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; mulitply2 = mulitply(2)_;//&lt;span&gt;柯里化就是把参数可以分开来，把部分函数参数可以用下划线来代替
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    println(mulitply2(&lt;/span&gt;3&lt;span&gt;))
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;4. 匿名函数&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;匿名函数的概念&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　匿名函数就是没有名字的函数。例如 (x : Int, y : Int) =&amp;gt; x * y 。这里有一点要注意，如果在“=&amp;gt;”前加上了这个函数的返回类型，如：(x:Int, y : Int) : Int=&amp;gt; x * y，反而会报错。原因是在一般情况下，Scala编译器会自动推断匿名函数参数的类型，所以可以省略返回类型，因为返回类型对于编译器而言是多余的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;案例六（匿名函数，声明方式&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  val t &lt;/span&gt;= () =&amp;gt; 123
  &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    println(t())&lt;/span&gt;//&lt;span&gt;直接调用t，注意要有小括号
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt;　　匿名函数的标识就是=&amp;gt;，没有方法名，只有一个小括号（这里也没有参数），方法体就是直接返回的123（是{123}的简写）。val t是将声明的这个匿名函数对象付给了常量t。这里看上去像是多此一举，但是因为匿名函数往往是作为参数传给一个函数的，所以匿名函数这样的形式很有必要。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;案例七（匿名函数，做函数的参数）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  val t &lt;/span&gt;= ()=&amp;gt;123//&lt;span&gt;声明了一个匿名函数对象付给了t
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; testfunc(c : ()=&amp;gt;Int ){&lt;span&gt;
    println(c())&lt;/span&gt;
    333&lt;span&gt;
  }
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    println(testfunc(t))&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定义testfunc方法中需要一个参数c，其类型是()=&amp;gt;Int，而()=&amp;gt;Int是匿名函数类型的定义。这个表达式是指传进来参数需要是一个匿名函数，该匿名函数没有参数，返回值是Int，比如t就是这样的匿名函数。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在testfunc中是打印，在方法体里面才真正的调用传进来的函数；传进来的时候只是传进来了一个方法体，并没有正真的调用。只有在里面有了()时才真正的调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;println(testfunc(t))&lt;/span&gt;&lt;span&gt;打印的结果有两行，第一行是123、第二行是()，因为testfunc这个方法没有返回值。如果将函数testfunc方法体前面加个等号就能打印出方法体最后一行（返回值）333。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;案例八（匿名函数，有参匿名函数的声明）&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  val b &lt;/span&gt;= (a:Int)=&amp;gt; a*2;//&lt;span&gt;把一个能将传进来的参数乘以2的匿名函数对象赋给b
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    println(b(&lt;/span&gt;8))//&lt;span&gt;打印的结果为16
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;案例九（匿名函数，有参匿名函数做参数）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; testf1(t: (Int,Int)=&amp;gt;Int )=&lt;span&gt;{
    println(t(&lt;/span&gt;15,15&lt;span&gt;));
  }
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    testf1((a:Int,b:Int)&lt;/span&gt;=&amp;gt;{println(a*b);a*&lt;span&gt;b})//打印的结果为两行225
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt;　　定义的一个以有参匿名函数作为参数的函数testf1，其参数名是t，参数类型是(Int,Int)=&amp;gt;Int这样的匿名函数，它需要两个Int类型的参数经过相应的转化，转为一个Int类型的返回值。&lt;/p&gt;
&lt;p&gt;　　t(15,15)这方法体里才真正的调用匿名函数t，这里的参数是写死的，即在testf1方法里才有真正的数据。但是真正对数据的操作是交给匿名函数的，这就体现了函数式编程的特点。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;5. 嵌套函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　嵌套函数可以认为是复合函数，是def了的一个函数中又def了一个函数。 例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;案例十（嵌套函数）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;//定义一个函数f=(x+y)*&lt;span&gt;z
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; f(x:Int, y:Int ,z:Int) : Int =&lt;span&gt; {
    &lt;/span&gt;//针对需求，要定义个两个数相乘的函数g=a*&lt;span&gt;b，相当于复合函数。
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; g(a:Int, b:Int):Int =&lt;span&gt; {
      a&lt;/span&gt;*&lt;span&gt;b
    }
    g((x&lt;/span&gt;+&lt;span&gt;y),z)
  }
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    println(f(&lt;/span&gt;2,3,5&lt;span&gt;))
  }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;6. 循环函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　和Java的类似，Scala有foreach循环。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;案例十一（foreach循环）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;//定义for_test1方法,使用for循环输出1-&lt;span&gt;50的整数
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;  for_test1() : Unit =&lt;span&gt; {
    &lt;/span&gt;//&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;这个符号表示foreach，使用&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;则包含末尾（闭区间），如果是until则不包含（左闭右开）。这里的to是Scala内建的一个方法。
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i &amp;lt;- 1 to 50 ){ //&lt;span&gt;可以从源码看到to是RichInt类型的方法
      println(i)
    }
  }
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; main(args: Array[String]): Unit =&lt;span&gt; {
    for_test1()
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;案例十二（foreach循环嵌入条件判断）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;//&lt;span&gt;打印1000以内（不含），可以被3整除的偶数。
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;  for_test2() =&lt;span&gt; {
    &lt;/span&gt;//&lt;span&gt;可以直接在for括号里面添加if过滤条件，比Java更简洁。多个条件使用分号隔开
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i &amp;lt;- 0 until 1000 &lt;span&gt;if&lt;/span&gt; (i % 2) == 0 ; &lt;span&gt;if&lt;/span&gt; (i % 3) ==&lt;span&gt; 0 ){
      println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;i)
    }
  }
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    for_test2()
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;7. 分支函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　和Java的switch…case…default分支类似，Scala有match…case…case_结构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;object HelloScala {
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; testmatch(n:Int)=&lt;span&gt;{
    n match {
      case &lt;/span&gt;1 =&amp;gt; {println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ;n}//&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;表示有匿名函数，如果与1匹配上就走这个方法体
      &lt;/span&gt;//        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;在Scala中不需要写break，也不能写break，Scala中没有break关键字。
      case &lt;/span&gt;2 =&amp;gt; println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ;n//&lt;span&gt;方法体的花括号可以省略。
      case _ &lt;/span&gt;=&amp;gt; println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;其他&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;others&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; //&lt;span&gt;case _：default
    }
  }
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(args: Array[String]) {
    println(testmatch(&lt;/span&gt;1))//结果为是1 \n 1&lt;span&gt;
    println(testmatch(0))&lt;/span&gt;//&lt;span&gt;结果为其他 \n others
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 15 Mar 2018 23:07:00 +0000</pubDate>
<dc:creator>Huidoo_Yang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangp/p/8575705.html</dc:identifier>
</item>
<item>
<title>Health Check - 每天5分钟玩转 Docker 容器技术（142） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8571325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8571325.html</guid>
<description>&lt;p&gt;&lt;span&gt;强大的自愈能力是 Kubernetes 这类容器编排引擎的一个重要特性。自愈的默认实现方式是自动重启发生故障的容器。除此之外，用户还可以利用 Liveness 和 Readiness 探测机制设置更精细的健康检查，进而实现如下需求：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;零停机部署。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;避免部署无效的镜像。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;更加安全的滚动升级。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面通过实践学习 Kubernetes 的 Health Check 功能。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;默认的健康检查&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们首先学习 Kubernetes 默认的健康检查机制：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;每个容器启动时都会执行一个进程，此进程由 Dockerfile 的 CMD 或 ENTRYPOINT 指定。如果进程退出时返回码非零，则认为容器发生故障，Kubernetes 就会根据 &lt;/span&gt;&lt;code&gt;&lt;span&gt;restartPolicy&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 重启容器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们模拟一个容器发生故障的场景，Pod 配置文件如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180315060201243-131429618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Pod 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;restartPolicy&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;OnFailure&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，默认为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Always&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;sleep 10; exit 1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 模拟容器启动 10 秒后发生故障。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 创建 Pod，命名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;healthcheck&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180315060211881-1145095866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;过几分钟查看 Pod 的状态：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180315060221237-1450082739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可看到容器当前已经重启了 3 次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的例子中，容器进程返回值非零，Kubernetes 则认为容器发生故障，需要重启。但有不少情况是发生了故障，但进程并不会退出。比如访问 Web 服务器时显示 500 内部错误，可能是系统超载，也可能是资源死锁，此时 httpd 进程并没有异常退出，在这种情况下重启容器可能是最直接最有效的解决方案，那我们如何利用 Health Check 机制来处理这类场景呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答案就是 Liveness 探测，我们下一节学习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://item.jd.com/16936307278.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Mar 2018 21:54:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8571325.html</dc:identifier>
</item>
<item>
<title>2017年终总结 - Jager</title>
<link>http://www.cnblogs.com/jager/p/8446552.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jager/p/8446552.html</guid>
<description>&lt;p&gt;　　迟来的年终总结，没做总觉的欠自己过去一年一个交代，硬着头皮写下来。&lt;/p&gt;
&lt;p&gt;　　2017年的年终总结想了很久，却总结不出1、2、3点来，客观上这一年做了很多事情，比如换了工作，搬家，送闺女上了托儿班，跑了两次的雨天马拉松，等等，但主观上感觉这一年的所有事情都是前一年已经计划好的，没有太多惊喜，自然也就没有什么太多的成就感。&lt;/p&gt;
&lt;p&gt;　　去年年初，因为闺女没在自己身边，家里又抽不出人来带，所以只能想办法，要么请阿姨，要么送托儿所，其实一整年的变化或行动都归结于这个契机。后来想想请阿姨一个月最便宜三千块，不熟悉，不放心，家里还不同意，所以索性送托儿班，早点学点东西不是更好。&lt;/p&gt;
&lt;p&gt;　　决定上幼儿园之后，就开始找学校，附近有个私立幼儿园，是在一个还不错的小区里面，应该算是附近最好的幼儿园了。提前报了名，担心进不去，还特地请朋友找了熟人，本来以为八九不离十的事，最终因为没有招小小班没去成，所以本来想一块搬家到这个小区的事情也只能作罢了。现在看来是个小事，在当时感觉就像开了个玩笑，住在城中村的人都想着住进小区，一个是环境好，另一个则是体面，但最后，失望却不期而遇。&lt;/p&gt;
&lt;p&gt;　　一个偶然的下午，跟老婆在通电话，脑子里突然闪过区政府附近的生活区，那旁边有个很好的私立幼儿园，我马上电话咨询了下，虽然学费有点贵，但我们还是可以接受，关键是还有名额。老婆一下班就过去看房子了，接下来一切都顺理成章了，幼儿园报名，搬家，新的环境，新的起点。。。思路决定出路，虽然是大不了的事，但首先要行动起来，卡住的时候稍微换个思路可能后面就都通了。&lt;/p&gt;
&lt;p&gt;　　换工作，其实年初的时候就已经落实了。关于工作，我觉的是一个人的事情，工作很大程度上跟婚姻一样，合不合适你自己知道就可以了。我感觉自己是个不安于现状中相对比较随遇而安的人，每次换工作都会自我斗争很长时间，在这点上我是个太感性的人，觉的哪里少了我都会转不动，还记得第一份工作离职之后的半年时间里，我还断断续续在帮忙解决项目上的问题，现在想想简直不可思议。&lt;/p&gt;
&lt;p&gt;　　MTDP是最想去的公司，一开始就是朝这个目标准备。面试了很多公司，拿了很多的offer，中间也有很多诱惑，但自己很清楚想要的是什么，从来没在互联网公司待过让人有种莫名的向往。新工作完全符合自己曾经的预期，以及一切关于互联网公司的美好想象，当然这么说是不是有点夸张。。。整洁漂亮的办公区，Mac笔记本，27寸独立显示屏，机械键盘，SONY/BOSS/BEATS降噪耳机，人体工学椅，丰富的图书角，无敌的海景。。。饭点时间都不情愿离开的地方，写出来的每一行代码都显得那么可爱。&lt;/p&gt;
&lt;p&gt;　　但在一个大的互联网平台，高效、懂得取舍是基本要求，否则就会过得很累。很多时候白天一天时间都在开会、过需求，晚上才是工作时间，时间短，要求写出高质量，可扩展的代码，这就要求高效。当然也有闲的时候，可以选择一个研究方向或课题，提升自我和团队。如果做不到高效，可能会长期处在写bug、改bug的恶性循环中，更没有时间去做一些技术探索的工作了。所以聪明和勤奋缺一不可，要以这两个标准一直鞭策自己。&lt;/p&gt;
&lt;p&gt;　　而今年，我在工作和生活的平衡方面就做的很差劲，跑步次数呈指数下跌，一个确实是工作强度较高，另一个是劳累让人变得慵懒，拖拉，但归根结底是信念问题，没有足够坚定。所以想方设法，一口气报了半马，全马，逼自己还是要锻炼。难忘的是，今年的两个马拉松都是雨天，虽然都跑完了，但成绩新低，刻骨铭心。已经跑了连续4年的马拉松，每年都有不一样的感受，心态也都不一样，今年是最充容的一次了，虽然是雨天，虽然成绩新低，但却很享受。雨天马拉松最难的就是出门前往赛场，当你在路上了，你就赢了。&lt;/p&gt;
&lt;p&gt;　　回顾这一年的年初计划，定的太多太具体，没有给人喘息的空间，自由度太多，所以年底注定reach不会多，虽然很多都完成了，但实际上都是自然而然的完成，没有什么计划可言。所以觉的每年的计划不用太过具体，只要确定几个大目标，每个月定时review，就基本OK。关键是review，只有review才能时刻提醒当前与里程碑的差距。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2018年年度目标（每个月review一次）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1 继续写博客，每个月至少一篇技术博客，从三月份开始&lt;/p&gt;
&lt;p&gt;　　2 每天早起，尽量不熬夜（重点）&lt;/p&gt;
&lt;p&gt;　　3 经常运动，篮球锻炼身体，乒乓球锻炼心态（重点）&lt;/p&gt;
&lt;p&gt;　　4 阅读，6本书+笔记（3本技术类+1本英文原著+1本金融+其他）&lt;/p&gt;
&lt;p&gt;　　5 职级考试与Level评定&lt;/p&gt;
&lt;p&gt;　　6 完成家庭计划&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2018，既往不恋，纵情向往，与君共勉！！！&lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 15 Mar 2018 17:19:00 +0000</pubDate>
<dc:creator>Jager</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jager/p/8446552.html</dc:identifier>
</item>
<item>
<title>代码整洁之道--边界 - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/8384535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/8384535.html</guid>
<description>&lt;p&gt;　　我们内部每周都有读书会，最近在读《clean code》，基本上是20分钟左右。总体原则是大家轮流来讲。 我自己也领了其中一章，第八章。这一张特别不巧，书少了3页。整个一章少了一半的内容。于是我自己发挥了一下，希望大家能有所收获。&lt;/p&gt;

&lt;p&gt;从接口到类、工程、系统、框架。在做设计的时候关于边界的基本思路是一致的。就是需要在普适性和集中性中做一个权衡。权衡的结果直接就影响着边界。&lt;/p&gt;
&lt;p&gt;边界的目的是要保证：易于理解，难以被误用。&lt;/p&gt;

&lt;p&gt;边界划分的典型例子：spring&lt;/p&gt;
&lt;p&gt;spring框架是一个分层架构，由7个定义良好的模块组成。每个模块都可以单独存在，或者与其他一个或多个模块联合实现。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img class=&quot;confluence-embedded-image&quot; src=&quot;https://wiki.sankuai.com/download/attachments/1388286736/image2018-3-14%2021%3A40%3A23.png?version=1&amp;amp;modificationDate=1521034823000&amp;amp;api=v2&quot; alt=&quot;&quot; height=&quot;250&quot; data-image-src=&quot;/download/attachments/1388286736/image2018-3-14%2021%3A40%3A23.png?version=1&amp;amp;modificationDate=1521034823000&amp;amp;api=v2&quot; data-unresolved-comment-count=&quot;0&quot; data-linked-resource-id=&quot;1388292272&quot; data-linked-resource-version=&quot;1&quot; data-linked-resource-type=&quot;attachment&quot; data-linked-resource-default-alias=&quot;image2018-3-14 21:40:23.png&quot; data-base-url=&quot;https://wiki.sankuai.com&quot; data-linked-resource-content-type=&quot;image/png&quot; data-linked-resource-container-id=&quot;1388286736&quot; data-linked-resource-container-version=&quot;11&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;核心容器：核心容器提供Spring框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory使用控制反转（IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。&lt;/li&gt;
&lt;li&gt;Spring上下文：Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，例如JNDI、EJB、国际化、校验和调度功能。&lt;/li&gt;
&lt;li&gt;Spring AOP：通过配置管理特性，Spring AOP模块直接将面向方面的编程功能集成到了Spring框架中。所以，可以很容易的使Spring框架管理的任何对象支持AOP。Spring AOP模块为基于Spring的应用程序中的对象提供了事务管理服务。通过使用Spring AOP，不用依赖EJB组件，就可以将声明性事务管理集成到应用程序中。&lt;/li&gt;
&lt;li&gt;Spring DAO：JDBC DAO抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大的降低了需要编写的异常代码数量(例如打开和关闭连接)。Spring DAO的面向JDBC的异常遵从通用的DAO异常层次结构。&lt;/li&gt;
&lt;li&gt;Spring ORM：Spring框架插入了若干个ORM框架，从而提供了ORM的对象关系工具，其中包括JDO、Hibernate和iBatis SQL Map。所有这些都遵从Spring的通用事务和DAO异常层次结构。&lt;/li&gt;
&lt;li&gt;Spring Web模块：Web上下文模块简历在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。所以，Spring框架支持与Jakarta Struts的集成。Web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。&lt;/li&gt;
&lt;li&gt;Spring MVC框架：MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架便成为高度可配置的，MVC容纳了大量视图技术，其中包括JSP、Velocity、Tiles、iText和POI。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;明确的职责是整洁边界的基础。拿Spring的核心容器举例。从上面图中可以看出，核心模块是spring框架中最底层核心的模块，提供了最基本的IoC思想和一些核心工具。想明确边界先要明确概念和职责。&lt;/p&gt;
&lt;p&gt;IoC&lt;/p&gt;
&lt;p&gt;IoC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。是1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中首先提出来的。简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度。&lt;/p&gt;
&lt;p&gt;IoC的别名：依赖注入(DI)&lt;/p&gt;
&lt;p&gt;2004年，Martin Fowler讨论了既然IoC是控制反转，那么到底是哪些方面的控制被反转了呢？经过详细地分析和论证后，他得出了答案：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IoC容器主动注入。于是他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现Ioc的方法：注入。所谓依赖注入，就是由IoC容器在运行期间，动态地将某种依赖关系注入到对象之中。所以，依赖注入和控制反转是从不同的角度来描述同一件事情，就是指通过引入IoC容器，利用依赖关系注入的方式，实现对象之间的解耦。&lt;/p&gt;

&lt;p&gt;到现在spring core的核心边界已经可以确立了。那么再进一步从实现上来剖析边界。&lt;/p&gt;
&lt;p&gt;IoC中最基本的技术就是反射。通俗来讲就是根据给出的类名来动态的声称对象。这种方式可以让对象在生成时才决定到底是哪一种对象。&lt;/p&gt;
&lt;p&gt;IoC容器的工作模式可以看做升级版的工厂模式。然后利用编程语言 的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IoC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立开，目的就是提高灵活性和可维护性。&lt;/p&gt;

&lt;p&gt;好，现在技术实现的主要思想也清晰了。这样在代码分层上会有一个大体的思路，超出边界的设计不会太多了。下面就来具体看看代码。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img class=&quot;confluence-embedded-image&quot; src=&quot;https://wiki.sankuai.com/download/attachments/1388286736/image2018-3-15%2023%3A39%3A40.png?version=1&amp;amp;modificationDate=1521128387079&amp;amp;api=v2&quot; alt=&quot;&quot; height=&quot;250&quot; data-image-src=&quot;/download/attachments/1388286736/image2018-3-15%2023%3A39%3A40.png?version=1&amp;amp;modificationDate=1521128387079&amp;amp;api=v2&quot; data-unresolved-comment-count=&quot;0&quot; data-linked-resource-id=&quot;1394413665&quot; data-linked-resource-version=&quot;1&quot; data-linked-resource-type=&quot;attachment&quot; data-linked-resource-default-alias=&quot;image2018-3-15 23:39:40.png&quot; data-base-url=&quot;https://wiki.sankuai.com&quot; data-linked-resource-content-type=&quot;image/png&quot; data-linked-resource-container-id=&quot;1388286736&quot; data-linked-resource-container-version=&quot;11&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;spring core的工程下面，分为6个package，分别是asm，cglib，core，lang，objenesis和util。&lt;/p&gt;
&lt;p&gt;ASM是一个全功能Java字节码操作与分析框架。可以用来修改已有的class文件或者直接以二进制形式动态生成class。它提供了通用转换与分析算法，自己组合复杂转换与代码分析工具。&lt;/p&gt;
&lt;p&gt;CGLIB是一个强大的、高性能的代码生成库。主要通过对字节码的操作，为对象引入简介级别，以控制对象的访问。&lt;/p&gt;
&lt;p&gt;objenesis本身也是一个强大的java库，主要是用在创建对象上面。它可以不用调用构造函数就创建对象。专门用于实例化一些特殊java对象，如私有构造方法，带参数的构造等不能通过class.newInstance()实例化的。&lt;/p&gt;
&lt;p&gt;前三个都是反射的实现方式。&lt;/p&gt;
&lt;p&gt;lang大家都很熟悉了，是language的缩写，定义了使用的语言，这里具体指JVM。&lt;/p&gt;
&lt;p&gt;core包里具体实现了IoC。&lt;/p&gt;
&lt;p&gt;util包提供了核心工具，基本上就是对象的生成工具，因为IoC的核心作用就是生成对象。&lt;/p&gt;

&lt;p&gt;代码大体框架的边界也定义出来了。下一步看接口。时间关系看最简单的lang包的。&lt;/p&gt;
&lt;p&gt;四个注解接口&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;public @interface UsesSunHttpServer {&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;public @interface UsesJava7 {&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;public @interface UsesJava8 {&lt;br/&gt;}&lt;/p&gt;

&lt;p&gt;public @interface UsesSunMisc {&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;从接口定义就可以看到这是非常符合这个包的职责的。&lt;/p&gt;

&lt;p&gt;再往下具体实现类我就不讲了，主要给大家提供一种思路，整洁的边界是怎样定义出来的。先要从大局上想清楚，然后是一个整体的设计，虽然应用程序的代码天然封装好了设计模式，但是这种理念需要有，这会非常利于写出整洁的代码。代码层次天然表达了设计思路，有人说代码即注释，我看来代码即设计。好的代码会像好的设计文档一样让人读着舒服。&lt;/p&gt;
&lt;p&gt;另外，我选用spring框架代码来说明代码整洁之道，主旨在于我个人觉得要写好代码，持续的去了解自己使用的框架、底层源码是一个应该形成的习惯与基本功。因为只有去不断的反思这些东西做了什么才能更好的用好它。我自己亲身感受的学习思路是先学其所长，然后再自成一派。而写好代码又和写好文章非常类似。我最喜欢举得学好之后自成一派的例子就是古龙，总在开场让人惊艳一把。&lt;/p&gt;
&lt;p&gt;很多他的开场白让人过目不忘。比如我现在还记得《天涯明月刀》的开场白：&lt;/p&gt;
&lt;p&gt;“天涯远不远？”&lt;/p&gt;
&lt;p&gt;“不远！”&lt;/p&gt;
&lt;p&gt;“人就在天涯，天涯怎么会远？”&lt;/p&gt;
&lt;p&gt;“明月是什么颜色？”&lt;/p&gt;
&lt;p&gt;“是蓝的，就像海一样蓝，一样深，一样忧郁。”&lt;/p&gt;
&lt;p&gt;“明月在哪儿？”&lt;/p&gt;
&lt;p&gt;“就在他的心，他的心就是明月。”&lt;/p&gt;
&lt;p&gt;“刀呢？”&lt;/p&gt;
&lt;p&gt;“刀就在他手！”&lt;/p&gt;
&lt;p&gt;“那是一柄什么样的刀？”&lt;/p&gt;
&lt;p&gt;“他的刀如天涯般辽阔寂寞，如明月般皎洁忧郁，有时一刀挥出，又仿佛是空的！”&lt;/p&gt;
&lt;p&gt;“空的？”&lt;/p&gt;
&lt;p&gt;“空空蒙蒙，缥缈虚幻，仿佛根本不存在，又仿佛到处都在。”&lt;/p&gt;
&lt;p&gt;“可是他的刀看来并不快。”&lt;/p&gt;
&lt;p&gt;“不快的刀，怎么能无敌于天下？”&lt;/p&gt;
&lt;p&gt;“因为他的刀已超越了速度的极限！”&lt;/p&gt;
&lt;p&gt;“他的人呢？”&lt;/p&gt;
&lt;p&gt;“人犹未归，人已断肠。”&lt;/p&gt;
&lt;p&gt;“何处是归程？”&lt;/p&gt;
&lt;p&gt;“归程就在他眼前。”&lt;/p&gt;
&lt;p&gt;“他看不见？”&lt;/p&gt;
&lt;p&gt;“他没有去看。”&lt;/p&gt;
&lt;p&gt;“所以他找不到？”&lt;/p&gt;
&lt;p&gt;“现在虽然找不到，迟早总有一天会找到的！”&lt;/p&gt;
&lt;p&gt;“一定会找到？”&lt;/p&gt;
&lt;p&gt;“一定！”&lt;/p&gt;

&lt;p&gt;好，就用古龙的风格总结一下我记住的前八章的《clean code》的内容：首先，要有意义的命名 。其次，格式很重要。然后，代码也有思想流派。最后，整洁代码是艺术。&lt;/p&gt;

&lt;p&gt;总结与思考：&lt;/p&gt;
&lt;p&gt;      我来现在的公司是因为意识到自己格局的问题。之前我看的视野太窄，所以我有强烈的需求想看到更全局性的东西。结果，我却忽视了一个更加显而易见的东西：角度。我所站的角度才更反映我的格局。&lt;/p&gt;
&lt;p&gt;      长久以来，我总是觉得我代表我个人。我最得意的事情从来不是工作上的成就，而是我是一个好妻子，好妈妈，好女儿，好儿媳。我不在乎别人怎么看我，因为我相信我自己，知道一切都会好起来。但是在工作中，我代表更多的是一个集体。代表集体不是简单的从用词的我变成我们。而是我每一个决策给集体带来什么样的影响。我遇到事情，我应该找集体来商讨，而不是觉得自己可以就可以做出决定。&lt;/p&gt;

&lt;p&gt;跑题时间：&lt;/p&gt;
&lt;p&gt;无题1&lt;/p&gt;
&lt;p&gt;　　千辛万苦，&lt;/p&gt;
&lt;p&gt;      千思万绪，&lt;/p&gt;
&lt;p&gt;　　淡然一笑，&lt;/p&gt;
&lt;p&gt;　　默默无语。&lt;/p&gt;
&lt;p&gt;　　感激并怀恨着，&lt;/p&gt;
&lt;p&gt;　　让我变得如此强大的那个人&lt;/p&gt;
&lt;p&gt;无题2&lt;/p&gt;
&lt;p&gt;　　如果注定是擦身而过，不要回头；&lt;/p&gt;
&lt;p&gt;　　哪怕比痛更痛，以后的路都了无生趣，心如死灰；&lt;/p&gt;
&lt;p&gt;　　不回头至少记忆里是笑容；&lt;/p&gt;
&lt;p&gt;　　回头他会看到一双含泪的眼睛&lt;/p&gt;

</description>
<pubDate>Thu, 15 Mar 2018 16:49:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/8384535.html</dc:identifier>
</item>
<item>
<title>Spring MVC执行流程 - xdecode</title>
<link>http://www.cnblogs.com/xdecode/p/8577439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xdecode/p/8577439.html</guid>
<description>
&lt;p&gt;SpringMVC是隶属于Spring Web中的一部分, 属于表现层的框架.&lt;/p&gt;
&lt;p&gt;其使用了MVC架构模式的思想, 将Web层进行职责解耦, 使用请求-响应模型简化Web开发&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201803/1285727-20180316001137290-2128844467.jpg&quot; alt=&quot;&quot; width=&quot;547&quot; height=&quot;434&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SpringMVC通过中央调度器DispatcherServlet，来调用MVC的三大件:Controller、Model、View。&lt;/p&gt;
&lt;p&gt;保证MVC的每一个组件只与DispatcherServlet耦合, 彼此之间独立运行, 降低程序的耦合性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体执行逻辑如下: &lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;浏览器提交请求到中央调度器.&lt;/li&gt;
&lt;li&gt;中央调度器将请求转给处理器映射器.&lt;/li&gt;
&lt;li&gt;处理器映射器根据请求, 找到请求对应的处理器, 并将其封装为处理器执行链返回给中央调度器.&lt;/li&gt;
&lt;li&gt;中央调度器根据处理器执行链中的处理器, 找到能够执行该处理器的适配器.&lt;/li&gt;
&lt;li&gt;适配器调用执行处理器.&lt;/li&gt;
&lt;li&gt;处理器将处理结果以及要跳转的视图封装到一个对象ModelAndView中, 并将其返回给处理器适配器.&lt;/li&gt;
&lt;li&gt;适配器将结果返回给中央调度器.&lt;/li&gt;
&lt;li&gt;中央调度器调用视图解析器, 将ModelAndView中的视图名封装为视图对象.&lt;/li&gt;
&lt;li&gt;视图解析器将封装了的视图对象返回给中央处理器.&lt;/li&gt;
&lt;li&gt;中央调度器调用视图对象, 让其渲染, 即进行数据填充, 形成响应对象.&lt;/li&gt;
&lt;li&gt;中央调度器响应浏览器.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201803/1285727-20180315235005534-1866221427.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;中央调度器, 它用来调用诸如处理器映射器, 适配器, 视图解析器等组件处理用户请求.&lt;/p&gt;
&lt;p&gt;中央调度器的存在降低了组件之间的耦合.&lt;/p&gt;
&lt;h4&gt;HandlerMapping&lt;/h4&gt;
&lt;p&gt;处理器映射器, 负责根据用户请求找到对应的Handler, 即处理器, 并将处理器封装为处理器执行链返回给中央调度器.&lt;/p&gt;
&lt;h4&gt;HandleAdaptor&lt;/h4&gt;
&lt;p&gt;适配器模式, 可以扩展适配器来对更多类型的处理器进行执行, 中央调度器根据不同的处理器自动选择适配器, 以执行处理器.&lt;/p&gt;
&lt;h4&gt;Handler&lt;/h4&gt;
&lt;p&gt;处理器, 即后端控制器. 在DispatcherServlet控制下Handler调用Service层对具体用户请求进行处理.&lt;/p&gt;
&lt;p&gt;Handler一般涉及的是用户具体的业务请求, 充当MVC中的Controller.&lt;/p&gt;
&lt;h4&gt;ViewResolver&lt;/h4&gt;
&lt;p&gt;视图解析器, 负责将处理结果生成View视图, ViewResolver首先将逻辑视图名解析为物理视图名, 即具体页面地址.&lt;/p&gt;
&lt;p&gt;再生成View视图对象, 最后将处理结果通过页面形式展现给用户.&lt;/p&gt;
&lt;p&gt;SpringMVC中提供了多种View视图类型, 例如: JstlView, RedirectView等等.&lt;/p&gt;

</description>
<pubDate>Thu, 15 Mar 2018 16:21:00 +0000</pubDate>
<dc:creator>xdecode</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xdecode/p/8577439.html</dc:identifier>
</item>
<item>
<title>详解QT5.10.0搭载OpenCV3.4.0环境配置步骤说明 - 芳舒晴</title>
<link>http://www.cnblogs.com/Shuqing-cxw/p/8577336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Shuqing-cxw/p/8577336.html</guid>
<description>&lt;p&gt;　　1下载Qt5.10.0 和 Qt Creator 4.5.0软件(&lt;a href=&quot;http://download.qt.io/official_releases/qt/&quot; target=&quot;_blank&quot;&gt;http://download.qt.io/official_releases/qt/&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;　　2.下载opencv3.40 (&lt;a href=&quot;https://opencv.org/releases.html&quot; target=&quot;_blank&quot;&gt;https://opencv.org/releases.html&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;　　3.下载Cmake3.10.1 (&lt;a href=&quot;https://cmake.org/download/&quot; target=&quot;_blank&quot;&gt;https://cmake.org/download/&lt;/a&gt;)&lt;/p&gt;


&lt;p&gt;　　1.qt软件安装与配置&lt;/p&gt;
&lt;p&gt;　　①安装Qt5.10.0，我的安装路径：D:\Qt&lt;/p&gt;
&lt;p&gt;　　注意点：在弹出的“选择组件窗口”中，选择相关组件(支持QtCreator开发方式如下图所以，支持VisualStudio开发方式则增加相应的MSVC对应的版本)，选择组件中关于“Strawberry Perl 5.22.1.3”的不勾选(这个组件在非首次安装时容易报错且当下学习使用不到)，勾选下方工具的MinGw5.3.0设置完毕后，点击“下一步按钮”进入下一步安装即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315233435834-866221951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　②安装Qt Creator 4.5.0软件，安装D:\Qt目录下，选项默认即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234038173-181035231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　③设置环境变量，在系统环境变量path中添加：&lt;/p&gt;
&lt;p&gt;　　D:\Qt\Qt5.10.0\5.10.0\mingw53_32\bin;&lt;/p&gt;
&lt;p&gt;　　D:\Qt\Qt5.10.0\Tools\mingw530_32\bin&lt;/p&gt;
&lt;p&gt;　　2. CMake安装和配置&lt;/p&gt;
&lt;p&gt;　　默认安装，不一定非要安装在C盘，可以放入与QT安装的目录下。&lt;/p&gt;
&lt;p&gt;　　注意点：在安装过程中勾选“为所有用户添加环境变量”：Add CMake to the system PATH for all users 。&lt;/p&gt;
&lt;p&gt;　　3.opencv安装&lt;/p&gt;
&lt;p&gt;　　opencv的安装实际上是解压，解压到用户指定位置，在这里我的目录是D:\Qt,这样安装路径统一在同一个文件夹下。&lt;/p&gt;

&lt;p&gt;　　1.配置CMake编译条件&lt;/p&gt;
&lt;p&gt;　　①打开CMake(cmake-gui)。&lt;/p&gt;
&lt;p&gt;　　②选择OpenCV安装目录下的源码文件：D:\Qt\opencv3.40\opencv\sources&lt;/p&gt;
&lt;p&gt;　　③选择想要编译输出目录文件路径，如统一存在统一目录下，在D:\Qt文件下新建一个opencvbuild3.40 文件夹，选择该路径： D:\Qt\opencvbuild3.40&lt;/p&gt;
&lt;p&gt;　　④点击Configure进行配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234018445-743095305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;            ⑤选择&lt;strong&gt;MinGW Makefiles&lt;/strong&gt;，勾选&lt;strong&gt;Special native compilers&lt;/strong&gt;然后点击Next&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234058456-761904255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            ⑥配置编译器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　在下图1处，C编译器选择D:\Qt\Qt5.10.0\Tools\mingw530_32\bin\gcc.exe；&lt;/p&gt;
&lt;p&gt;　　　　在下图2处，C++编译器选择D:\Qt\Qt5.10.0\Tools\mingw530_32\bin\g++.exe&lt;/p&gt;
&lt;p&gt;　　　　Fortran不用填写，然后点击finish。注意：此过程保证网络畅通，因为需要下载几个文件。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234122401-922935745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;            ⑦等待一会儿后，会有一堆红色出现，勾选WITH_QT和WITH_OPENGL，不能勾选WITH_IPP（默认不勾选），再次点击configure。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234157463-673517365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　注意：若仍有红色出现，再次点击configure直至红色消失(有时需要多次，一般情况下两次即可)。最后，点击Generate按钮，完成后即可关闭CMake。&lt;/p&gt;
&lt;p&gt;　　2. 编译&lt;/p&gt;
&lt;p&gt;　　①在编译之前，在源目录D:\Qt\opencv3.4.0\opencv\source\cmake\下找到OpenCVCompilerOptions.cmake文件。&lt;/p&gt;
&lt;p&gt;　　　　记事本打开文件，找到&lt;strong&gt;add_extra_compiler_option(-Werror=non-virtual-dtor)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　将它注释掉，前面加#变成：#add_extra_compiler_option(-Werror=non-virtual-dtor)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234255924-229608772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　②然后按住快捷键win+R，运行cmd&lt;/p&gt;
&lt;p&gt;　　进入编译输出目录D:\Qt\opencvbuild3.40，然后输入”mingw32-make“命令. 备注：加速编译时间可以使用可选参指令” mingw32-make -j 8 “(处理器是i7-3770为8核)，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234317966-1924791997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意点：编译opencv，此过程时间较长，电脑编译了一个多小时。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234340052-1374081736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　③直到编译结束。然后输入命令：mingw32-make install ，大约一到两分钟就安装完成了。&lt;/p&gt;
&lt;p&gt;　　　注意点：若编译期间出现如下错误：&lt;/p&gt;
&lt;p&gt;　　　　错误: ... windres.exe: unknown option -- W ...&lt;/p&gt;
&lt;p&gt;　　　　根据提示依据如下思路解决： in cmake uncheck ENABLE_PRECOMPILED_HEADERS&lt;/p&gt;
&lt;p&gt;　　　　即：mingw32-make ENABLE_PRECOMPILED_HEADERS -j 8&lt;/p&gt;
&lt;p&gt;　　　　&lt;a href=&quot;http://answers.opencv.org/question/168538/building-opencv-with-mingw-gcc-710-and-cmake-390-windresexe-unknown-option-w/&quot; target=&quot;_blank&quot;&gt;http://answers.opencv.org/question/168538/building-opencv-with-mingw-gcc-710-and-cmake-390-windresexe-unknown-option-w/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　错误：in the file opencv/sources/modules/videoio/src/cap_dshow.cpp, you have the following error : 'sprintf_instead_use_StringCbPrintfA_or_StringCchPrintfA' was not declared in this scope ...&lt;/p&gt;
&lt;p&gt;　　　　解决：put the following line: #define NO_DSHOW_STRSAFE, before the line : #include &quot;DShow.h&quot;&lt;/p&gt;
&lt;p&gt;　　　　即：在D:\Qt\opencv3.4.0\opencv\source\modules\videoio\src\cap_dshow.cpp中，在#include “DShow.h“上一行中插入: #define NO_DSHOW_STRSAFE&lt;/p&gt;
&lt;p&gt;　　　　备注：参考地址：&lt;a href=&quot;https://wiki.qt.io/How_to_setup_Qt_and_openCV_on_Windows&quot; target=&quot;_blank&quot;&gt;https://wiki.qt.io/How_to_setup_Qt_and_openCV_on_Windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234421812-1838082916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　不同版本的OpenCV编译安装后的文件不同，3.4.0版本编译后750M&lt;/p&gt;
&lt;p&gt;　　使用2.4.13.3版本文件有1.98G。若需要裁剪倾向请参考如下博文：&lt;a href=&quot;https://www.cnblogs.com/TooyLee/p/6438070.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/TooyLee/p/6438070.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　备注：想生成目录结构到txt文件，可在cmd中转到某目录，输入tree /f &amp;gt; list.txt&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234444201-2074154456.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234451546-137182608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　①环境变量添加D:\Qt\opencvbuild3.40\install\x86\mingw\bin&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234734420-617845958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　②打开Qt Creator新建项目(非Qt项目，纯C++应用)，命名为OpenCV后，打开OpenCV.pro文件，添加如下语句：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　INCLUDEPATH += D:\Qt\opencvbuild3.40\install\include&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　LIBS += -L D:\Qt\opencvbuild3.40\install\x86\mingw\bin\libopencv_*.dll&lt;/p&gt;
&lt;p&gt;　　LIBS += -L D:\Qt\opencvbuild3.40\install\x86\mingw\lib\libopencv_*.a&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315234759751-1346820160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　③右击项目文件OpenCV文件夹，选择“执行qmake“编译后即可。&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_4822f6e2-92d9-4284-866f-4505c3cc87e6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4822f6e2-92d9-4284-866f-4505c3cc87e6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4822f6e2-92d9-4284-866f-4505c3cc87e6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;opencv2/core/core.hpp&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; cv;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    cv::Mat image;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     std::cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This image is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; image.rows &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; x &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; image.cols &amp;lt;&amp;lt;&lt;span&gt; std::endl;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绝对路径+图片名称&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     image = cv::imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:\\QT Project\\OpenCV\\rose.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (image.empty())
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         std::cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Can’t loading images. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 　　　　 &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     cv::namedWindow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Original Image&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     cv::imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Original Image&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, image);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     cv::waitKey(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;加载图片测试代码段&lt;/span&gt;&lt;/div&gt;



&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1289301/201803/1289301-20180315235301832-1323458736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 15 Mar 2018 15:58:00 +0000</pubDate>
<dc:creator>芳舒晴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Shuqing-cxw/p/8577336.html</dc:identifier>
</item>
<item>
<title>Css Secret 案例Demo全套 - 24k-小清新</title>
<link>http://www.cnblogs.com/wuxiaobin/p/8577323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuxiaobin/p/8577323.html</guid>
<description>&lt;hr/&gt;

&lt;p&gt;去年买了一本CSS揭秘的css专题书，该书揭示了 47 个鲜为人知的 CSS 技巧，主要内容包括背景与边框、形状、 视觉效果、字体排印、用户体验、结构与布局、过渡与动画等。去年买入时，就决定将里面所有Demo案例全部撸一遍，作为自己2018年学习清单中的首项。这个过程中也可以学习到一些比较实用的css技巧，对于工作中css布局上面也有挺大的帮助。&lt;/p&gt;
&lt;p&gt;下面是几种比较有趣的css场景的实现方式：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;饼图(基于transform实现方式)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;picture1&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;20&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/*基于transform的解决方案*/&lt;/span&gt;
    &lt;span class=&quot;fl&quot;&gt;.picture1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;line-height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;text-align:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;transparent&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; yellowgreen&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;background-image:&lt;/span&gt; linear-gradient(to &lt;span class=&quot;dt&quot;&gt;right&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;transparent&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50%&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;#655&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;border-radius:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;/*animation-delay: -20s;*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    @keyframes spin &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;er&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;transform:&lt;/span&gt; rotate(&lt;span class=&quot;dt&quot;&gt;.5turn&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    }
    @keyframes bg &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;er&quot;&gt;50%&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#655&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    }
    &lt;span class=&quot;fl&quot;&gt;.picture1&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;::before&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;content:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;absolute&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;border-radius:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100%&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100%&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; / &lt;span class=&quot;dt&quot;&gt;50%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;inherit&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;transform-origin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;animation:&lt;/span&gt; spin &lt;span class=&quot;dt&quot;&gt;50s&lt;/span&gt; linear infinite,
                   bg &lt;span class=&quot;dt&quot;&gt;100s&lt;/span&gt; step-end infinite&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;animation-play-state:&lt;/span&gt; paused&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;animation-delay:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;inherit&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;javacript&quot;&gt;
&lt;code&gt;    // 基于transform的解决方案
    let picture1 = document.querySelector('.picture1');
    let rate1 = parseFloat(picture1.textContent);
    picture1.style.animationDelay = `-${rate1}s`;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;饼图(基于svg实现方式)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;&amp;lt;svg&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; viewBox=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0 0 32 32&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;circle&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;circle2&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; r=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;16&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; cx=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;16&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; cy=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;16&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/circle&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/svg&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/*基于svg的解决方案*/&lt;/span&gt;
    svg &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;transform:&lt;/span&gt; rotate(&lt;span class=&quot;dt&quot;&gt;-90deg&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; yellowgreen&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;border-radius:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    circle&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;fill:&lt;/span&gt; yellowgreen&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;stroke:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#655&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;stroke-width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;fl&quot;&gt;#circle2&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;stroke-dasharray:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;38&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;插入换行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dl&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dt&amp;gt;&lt;/span&gt;Name:&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dt&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dd&amp;gt;&lt;/span&gt;wushaobin&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dd&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dt&amp;gt;&lt;/span&gt;Email:&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dt&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dd&amp;gt;&lt;/span&gt;739288994@qq.com&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dd&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dd&amp;gt;&lt;/span&gt;12345@qq.com&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dd&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dd&amp;gt;&lt;/span&gt;54321@qq.com&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dd&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dt&amp;gt;&lt;/span&gt;Location:&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dt&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dd&amp;gt;&lt;/span&gt;shenzhen&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dd&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dl&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;    dt,dd &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;inline&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    dd&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;font-weight:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;bold&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    dd+dt&lt;span class=&quot;dv&quot;&gt;::before&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;content:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'\A'&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;white-space:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    dd+dd&lt;span class=&quot;dv&quot;&gt;::before&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;content:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;', '&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;font-weight:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 15 Mar 2018 15:56:00 +0000</pubDate>
<dc:creator>24k-小清新</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuxiaobin/p/8577323.html</dc:identifier>
</item>
<item>
<title>Go实现短url项目 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8576946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8576946.html</guid>
<description>&lt;p&gt;首先说一下这种业务的应用场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把一个长url转换为一个短url网址&lt;/li&gt;
&lt;li&gt;主要用于微博，二维码，等有字数限制的场景&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;主要实现的功能分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把长url的地址转换为短url地址&lt;/li&gt;
&lt;li&gt;通过短url获取对应的原始长url地址&lt;/li&gt;
&lt;li&gt;相同长url地址是否需要同样的短url地址&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里实现的是一个api服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180315224257442-1011943675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;数据库设计&lt;/h2&gt;
&lt;p&gt;数据库的设计其实也没有非常复杂，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180315224054371-193579891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有个设置需要主要就是关于数据库表中id的设计，需要设置为自增的&lt;br/&gt;并且这里有个问题需要提前知道，我们的思路是根据id的值会转换为62进制关于进制转换的代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
// 将十进制转换为62进制   0-9a-zA-&lt;span&gt;Z 六十二进制
func transTo62(id int64)string{
    &lt;/span&gt;// 1 -- &amp;gt; 1
    // 10-- &amp;gt;&lt;span&gt; a
    &lt;/span&gt;// 61-- &amp;gt;&lt;span&gt; Z
    charset :&lt;/span&gt;= &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;&lt;span&gt;
    var shortUrl []&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
    for{
        var result &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
        number :&lt;/span&gt;= id % 62&lt;span&gt;
        result &lt;/span&gt;=&lt;span&gt; charset[number]
        var tmp []&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
        tmp &lt;/span&gt;=&lt;span&gt; append(tmp,result)
        shortUrl &lt;/span&gt;=&lt;span&gt; append(tmp,shortUrl...)
        id &lt;/span&gt;= id / 62
        &lt;span&gt;if&lt;/span&gt; id == 0&lt;span&gt;{
            break
        }
    }
    fmt.Println(string(shortUrl))
    return string(shortUrl)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以这里需要设置一下数据库id的起始值，可以设置的大一点，这样转换为62进制之后不至于太短&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;代码逻辑&lt;/h2&gt;
&lt;p&gt;项目完整的代码git地址：&lt;a href=&quot;https://github.com/pythonsite/go_simple_code/tree/master/short_url&quot;&gt;https://github.com/pythonsite/go_simple_code/tree/master/short_url&lt;/a&gt;&lt;br/&gt;当然这里的代码还有待后面继续做优化，但是这里通过golang内置的net/http 库实现了一个简单的api功能&lt;/p&gt;
&lt;p&gt;代码的目录结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
|&lt;span&gt;____logic
&lt;/span&gt;| |&lt;span&gt;____logic.go
&lt;/span&gt;|&lt;span&gt;____model
&lt;/span&gt;| |&lt;span&gt;____data.go
&lt;/span&gt;|&lt;span&gt;____api
&lt;/span&gt;| |&lt;span&gt;____api.go
&lt;/span&gt;|&lt;span&gt;____client
&lt;/span&gt;| |____client.go
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;logic目录为主要的处理逻辑&lt;br/&gt;model是定义了request和response结构体&lt;br/&gt;api目录为程序的入口程序&lt;br/&gt;client 为测试请求，进行地址的转换&lt;/p&gt;
&lt;p&gt;model 代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package model


type Long2ShortRequest struct {
    OriginUrl string `json:&lt;/span&gt;&quot;origin_url&quot;&lt;span&gt;`
}

type ResponseHeader struct {
    Code &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; `json:&quot;code&quot;&lt;span&gt;`
    Message string `json:&lt;/span&gt;&quot;message&quot;&lt;span&gt;`
}

type Long2ShortResponse struct {
    ResponseHeader
    ShortUrl string `json:&lt;/span&gt;&quot;short_url&quot;&lt;span&gt;`
}

type Short2LongRequest struct {
    ShortUrl string `json:&lt;/span&gt;&quot;short_url&quot;&lt;span&gt;`
}

type Short2LongResponse struct {
    ResponseHeader
    OriginUrl string `json:&lt;/span&gt;&quot;origin_url&quot;&lt;span&gt;`
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;logic的代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package logic

import(
    &lt;/span&gt;&quot;go_dev/11/short_url/model&quot;
    &quot;github.com/jmoiron/sqlx&quot;
    &quot;fmt&quot;
    &quot;crypto/md5&quot;
    &quot;database/sql&quot;&lt;span&gt;
)

var (
    Db &lt;/span&gt;*&lt;span&gt;sqlx.DB
)

type ShortUrl struct {
    Id int64 `db:&lt;/span&gt;&quot;id&quot;&lt;span&gt;`
    ShortUrl string `db:&lt;/span&gt;&quot;short_url&quot;&lt;span&gt;`
    OriginUrl string `db:&lt;/span&gt;&quot;origin_url&quot;&lt;span&gt;`
    HashCode string `db:&lt;/span&gt;&quot;hash_code&quot;&lt;span&gt;`
}

func InitDb(dsn string)(err error) {
    &lt;/span&gt;//&lt;span&gt; 数据库初始化
    Db, err &lt;/span&gt;= sqlx.Open(&quot;mysql&quot;&lt;span&gt;,dsn)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;connect to mysql failed:&quot;&lt;span&gt;,err)
        return
    }
    return
}

func Long2Short(req &lt;/span&gt;*model.Long2ShortRequest) (response *&lt;span&gt;model.Long2ShortResponse, err error) {
    response &lt;/span&gt;= &amp;amp;&lt;span&gt;model.Long2ShortResponse{}
    urlMd5 :&lt;/span&gt;= fmt.Sprintf(&quot;%x&quot;,md5.Sum([]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(req.OriginUrl)))
    var &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;&lt;span&gt; ShortUrl
    err &lt;/span&gt;= Db.Get(&amp;amp;&lt;span&gt;short&lt;/span&gt;,&quot;select id,short_url,origin_url,hash_code from short_url where hash_code=?&quot;&lt;span&gt;,urlMd5)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err ==&lt;span&gt; sql.ErrNoRows{
        err &lt;/span&gt;=&lt;span&gt; nil
        &lt;/span&gt;//&lt;span&gt; 数据库中没有记录，重新生成一个新的短url
        shortUrl,errRet :&lt;/span&gt;=&lt;span&gt; generateShortUrl(req,urlMd5)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; errRet !=&lt;span&gt; nil{
            err &lt;/span&gt;=&lt;span&gt; errRet
            return
        }
        response.ShortUrl &lt;/span&gt;=&lt;span&gt; shortUrl
        return
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        return
    }
    response.ShortUrl &lt;/span&gt;= &lt;span&gt;short&lt;/span&gt;&lt;span&gt;.ShortUrl
    return
}

func generateShortUrl(req &lt;/span&gt;*&lt;span&gt;model.Long2ShortRequest,hashcode string)(shortUrl string,err error){
    result,err :&lt;/span&gt;= Db.Exec(&quot;insert INTO short_url(origin_url,hash_code)VALUES (?,?)&quot;&lt;span&gt;,req.OriginUrl,hashcode)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        return
    }
    &lt;/span&gt;// 0-9a-zA-&lt;span&gt;Z 六十二进制
    insertId,_:&lt;/span&gt;=&lt;span&gt; result.LastInsertId()
    shortUrl &lt;/span&gt;=&lt;span&gt; transTo62(insertId)
    _,err &lt;/span&gt;= Db.Exec(&quot;update short_url set short_url=? where id=?&quot;&lt;span&gt;,shortUrl,insertId)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(err)
        return
    }
    return
}

&lt;/span&gt;// 将十进制转换为62进制   0-9a-zA-&lt;span&gt;Z 六十二进制
func transTo62(id int64)string{
    &lt;/span&gt;// 1 -- &amp;gt; 1
    // 10-- &amp;gt;&lt;span&gt; a
    &lt;/span&gt;// 61-- &amp;gt;&lt;span&gt; Z
    charset :&lt;/span&gt;= &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;&lt;span&gt;
    var shortUrl []&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
    for{
        var result &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
        number :&lt;/span&gt;= id % 62&lt;span&gt;
        result &lt;/span&gt;=&lt;span&gt; charset[number]
        var tmp []&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
        tmp &lt;/span&gt;=&lt;span&gt; append(tmp,result)
        shortUrl &lt;/span&gt;=&lt;span&gt; append(tmp,shortUrl...)
        id &lt;/span&gt;= id / 62
        &lt;span&gt;if&lt;/span&gt; id == 0&lt;span&gt;{
            break
        }
    }
    fmt.Println(string(shortUrl))
    return string(shortUrl)
}


func Short2Long(req &lt;/span&gt;*model.Short2LongRequest) (response *&lt;span&gt;model.Short2LongResponse, err error) {
    response &lt;/span&gt;= &amp;amp;&lt;span&gt;model.Short2LongResponse{}
    var &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;&lt;span&gt; ShortUrl
    err &lt;/span&gt;= Db.Get(&amp;amp;&lt;span&gt;short&lt;/span&gt;,&quot;select id,short_url,origin_url,hash_code from short_url where short_url=?&quot;&lt;span&gt;,req.ShortUrl)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err ==&lt;span&gt; sql.ErrNoRows{
        response.Code &lt;/span&gt;= 404&lt;span&gt;
        return
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        response.Code &lt;/span&gt;= 500&lt;span&gt;
        return
    }
    response.OriginUrl &lt;/span&gt;= &lt;span&gt;short&lt;/span&gt;&lt;span&gt;.OriginUrl
    return
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;api的代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;fmt&quot;
    &quot;encoding/json&quot;
    &quot;go_dev/11/short_url/logic&quot;
    &quot;go_dev/11/short_url/model&quot;&lt;span&gt;
    _ &lt;/span&gt;&quot;github.com/go-sql-driver/mysql&quot;&lt;span&gt;
)

const (
    ErrSuccess &lt;/span&gt;= 0&lt;span&gt;
    ErrInvalidParameter &lt;/span&gt;= 1001&lt;span&gt;
    ErrServerBusy &lt;/span&gt;= 1002&lt;span&gt;
)

func getMessage(code &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) (msg string){
    switch code {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ErrSuccess:
        msg &lt;/span&gt;= &quot;success&quot;
    &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ErrInvalidParameter:
        msg &lt;/span&gt;= &quot;invalid parameter&quot;
    &lt;span&gt;case&lt;/span&gt;&lt;span&gt; ErrServerBusy:
        msg &lt;/span&gt;= &quot;server busy&quot;&lt;span&gt;
    default:
        msg &lt;/span&gt;= &quot;unknown error&quot;&lt;span&gt;
    }

    return
}

&lt;/span&gt;//&lt;span&gt; 用于将返回序列化数据，失败的返回
func responseError(w http.ResponseWriter, code &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) {
    var response model.ResponseHeader
    response.Code &lt;/span&gt;=&lt;span&gt; code
    response.Message &lt;/span&gt;=&lt;span&gt; getMessage(code)

    data, err :&lt;/span&gt;=&lt;span&gt; json.Marshal(response)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        w.Write([]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;(&quot;{\&quot;code\&quot;:500, \&quot;message\&quot;: \&quot;server busy\&quot;}&quot;&lt;span&gt;))
        return
    }

    w.Write(data)
}

&lt;/span&gt;//&lt;span&gt; 用于将返回序列化数据，成功的返回
func responseSuccess(w http.ResponseWriter, data interface{}) {


    dataByte, err :&lt;/span&gt;=&lt;span&gt; json.Marshal(data)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        w.Write([]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;(&quot;{\&quot;code\&quot;:500, \&quot;message\&quot;: \&quot;server busy\&quot;}&quot;&lt;span&gt;))
        return
    }

    w.Write(dataByte)
}

&lt;/span&gt;//&lt;span&gt; 长地址到短地址
func Long2Short(w http.ResponseWriter, r &lt;/span&gt;*&lt;span&gt;http.Request) {
    &lt;/span&gt;//&lt;span&gt; 这里需要说明的是发来的数据是通过post发过来一个json格式的数据
    data, err :&lt;/span&gt;=&lt;span&gt; ioutil.ReadAll(r.Body)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;read all failded, &quot;&lt;span&gt;, err)
        responseError(w, &lt;/span&gt;1001&lt;span&gt;)
        return
    }

    var req model.Long2ShortRequest
    &lt;/span&gt;//&lt;span&gt; 将反序列化的数据保存在结构体中
    err &lt;/span&gt;= json.Unmarshal(data, &amp;amp;&lt;span&gt;req)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;Unmarshal failded, &quot;&lt;span&gt;, err)
        responseError(w, &lt;/span&gt;1002&lt;span&gt;)
        return
    }

    resp, err :&lt;/span&gt;= logic.Long2Short(&amp;amp;&lt;span&gt;req)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;Long2Short failded, &quot;&lt;span&gt;, err)
        responseError(w, &lt;/span&gt;1003&lt;span&gt;)
        return
    }

    responseSuccess(w, resp)
}

&lt;/span&gt;//&lt;span&gt; 短地址到长地址
func Short2Long(w http.ResponseWriter, r &lt;/span&gt;*&lt;span&gt;http.Request) {
    &lt;/span&gt;//&lt;span&gt; 这里需要说明的是发来的数据是通过post发过来一个json格式的数据
    data, err :&lt;/span&gt;=&lt;span&gt; ioutil.ReadAll(r.Body)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;read all failded, &quot;&lt;span&gt;, err)
        responseError(w, &lt;/span&gt;1001&lt;span&gt;)
        return
    }

    var req model.Short2LongRequest
    &lt;/span&gt;//&lt;span&gt; 将反序列化的数据保存在结构体中
    err &lt;/span&gt;= json.Unmarshal(data, &amp;amp;&lt;span&gt;req)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;Unmarshal failded, &quot;&lt;span&gt;, err)
        responseError(w, &lt;/span&gt;1002&lt;span&gt;)
        return
    }

    resp, err :&lt;/span&gt;= logic.Short2Long(&amp;amp;&lt;span&gt;req)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;Long2Short failded, &quot;&lt;span&gt;, err)
        responseError(w, &lt;/span&gt;1003&lt;span&gt;)
        return
    }
    responseSuccess(w, resp)
}

func main(){
    err :&lt;/span&gt;= logic.InitDb(&quot;root:123456@tcp(192.168.50.145:3306)/short_url?parseTime=true&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Printf(&lt;/span&gt;&quot;init db failed,err:%v\n&quot;&lt;span&gt;,err)
        return
    }
    http.HandleFunc(&lt;/span&gt;&quot;/trans/long2short&quot;&lt;span&gt;, Long2Short)
    http.HandleFunc(&lt;/span&gt;&quot;/trans/short2long&quot;&lt;span&gt;, Short2Long)
    http.ListenAndServe(&lt;/span&gt;&quot;:18888&quot;&lt;span&gt;, nil)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;这次通过这个小代码对go也有了一个初步的认识和使用，同时也通过net/http 包实现了api的功能，也对其基本使用有了大致了解&lt;/p&gt;
</description>
<pubDate>Thu, 15 Mar 2018 14:47:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8576946.html</dc:identifier>
</item>
<item>
<title>Spring Boot Actutaur + Telegraf + InFluxDB + Grafana 构建监控平台之应用数据分析 - appleYang</title>
<link>http://www.cnblogs.com/zhikou/p/8576891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhikou/p/8576891.html</guid>
<description>&lt;h2&gt;&lt;span class=&quot;mw-headline&quot;&gt;本节将引入完美的granafa仪表板，&lt;span id=&quot;Monitoring_Zimbra_Collaboration_-_InfluxDB.2C_Telegraf_and_Grafana&quot; class=&quot;mw-headline&quot;&gt;在上节的基础上，&lt;span id=&quot;Monitoring_Zimbra_Collaboration_-_InfluxDB.2C_Telegraf_and_Grafana&quot; class=&quot;mw-headline&quot;&gt;并提出自己的一些监控数据的总结和看法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;mw-headline&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201803/1137026-20180315093157564-1996763056.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;你可以有一个类似于这个的Dashboard，会引入&lt;span id=&quot;Monitoring_Zimbra_Collaboration_-_InfluxDB.2C_Telegraf_and_Grafana&quot; class=&quot;mw-headline&quot;&gt;监控Zimbra协作&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;mw-headline&quot;&gt;　　本节环境采用的是centos7系统，配置跟上节介绍的一样，但是Telegraf是企业级监控加入很多可靠的监控插件，非常有用的一些参数，随之也给自&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mw-headline&quot;&gt;己&lt;span class=&quot;mw-headline&quot;&gt;的监控数据分析带来了复杂度。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Telegraf：它负责收集我们通过配置文件传递的所有数据，Telegraf收集我们配置的输出结果，例如CPU / RAM / LOAD或Nginx，MariaDB等服务。&lt;/li&gt;
&lt;li&gt;InfluxDB：这是Telegraf发送所有这些信息的地方，InfluxDB专门设计用于高效存储大量信息，此外，可以定义信息保留期以防万一出现性能问题&lt;/li&gt;
&lt;li&gt;Grafana：它是仪表板，负责显示InfluxDB存储在数据库中的所有信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span id=&quot;Importing_Dashboard_in_Grafana&quot; class=&quot;mw-headline&quot;&gt;在Grafana中导入仪表板&lt;span class=&quot;mw-headline&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　你可以从这里下载：&lt;a class=&quot;external free&quot; href=&quot;https://grafana.com/dashboards/2846/&quot; rel=&quot;nofollow&quot;&gt;https://grafana.com/dashboards/2846/&lt;/a&gt;        导入它们的步骤如下，转到我们的仪表板，然后按导入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201803/1137026-20180315095545182-1894837941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　输入Zimbra仪表板的ID：2846，我们将自动显示以下内容，选择我们的数据源并将其提供给导入&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201803/1137026-20180315095624561-472960448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　几分钟后，我们可以开始看到一个生动的仪表板，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201803/1137026-20180315100220192-524423951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;数据分析&lt;/h2&gt;
&lt;p&gt;　　Grafana将系统和应用程序的的数据展示出来,就要开始分析数据的意图。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt; 应用程序数据：SpringBoot Actutaur中的metrics收集到的数据指标，通过jolokia拉取数据到telegrafa上代理转给输入到时间序列数据库中（我尝试过直接将指标存入influxdb中，但未找到解决方案，有知道的伙伴可以给我留言）　　　　&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201803/1137026-20180315135737224-1080154770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　补充：jolokia是一个JMX-HTTP桥梁，可替代JSR-160连接器。它是一种基于代理的方法，支持许多平台。&lt;/p&gt;
&lt;p&gt;　　 除了基本的JMX操作外，它还通过独特的功能（如批量请求和细粒度的安全策略）增强了JMX远程处理能力，应用程序的监控直接扩展到jvm。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201803/1137026-20180315140841633-312143253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　特别注意：代理模式只能在需要时使用。代理servlet自身比代理模式更强大，因为它消除了增加整体复杂性和性能的附加层。此外，在代理模式下，某些功能（如合并MBeanServers）也不可用。&lt;/p&gt;
&lt;p&gt;在telegrafa中，开启对应的数据，jolokia采用拉取数据，所以都会在[inputs.jolokia]更改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   [[inputs.jolokia.metrics]]
     name = &quot;类加载次数&quot;&lt;span&gt;
     mbean  = &quot;java.lang:type=ClassLoading&quot;&lt;span&gt;
     attribute = &quot;LoadedClassCount,UnloadedClassCount,TotalLoadedClassCount&quot;&lt;span&gt;
   [[inputs.jolokia.metrics]]
        name = &quot;metrics数据&quot;&lt;span&gt;
        mbean=&quot;org.springframework.boot:type=Endpoint,name=metricsEndpoint&quot;&lt;span&gt;
        attribute = &quot;Data&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　grafana中在数据库中查到的就会有对应由jolokia拉去的数据做下拉列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201803/1137026-20180315144557458-1559619537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统信息：包括处理器数量processors、运行时间uptime和instance.uptime、系统平均负载systemload.average。&lt;/li&gt;
&lt;li&gt;mem.*：内存概要信息，包括分配给应用的总内存数量以及当前空闲的内存数量。这些信息来自java.lang.Runtime。&lt;/li&gt;
&lt;li&gt;heap.*：堆内存使用情况。这些信息来自java.lang.management.MemoryMXBean接口中getHeapMemoryUsage方法获取的java.lang.management.MemoryUsage。&lt;/li&gt;
&lt;li&gt;nonheap.*：非堆内存使用情况。这些信息来自java.lang.management.MemoryMXBean接口中getNonHeapMemoryUsage方法获取的java.lang.management.MemoryUsage。&lt;/li&gt;
&lt;li&gt;threads.*：线程使用情况，包括线程数、守护线程数（daemon）、线程峰值（peak）等，这些数据均来自java.lang.management.ThreadMXBean。&lt;/li&gt;
&lt;li&gt;classes.*：应用加载和卸载的类统计。这些数据均来自java.lang.management.ClassLoadingMXBean。&lt;/li&gt;
&lt;li&gt;gc.*：垃圾收集器的详细信息，包括垃圾回收次数gc.ps_scavenge.count、垃圾回收消耗时间gc.ps_scavenge.time、标记-清除算法的次数gc.ps_marksweep.count、标记-清除算法的消耗时间gc.ps_marksweep.time。这些数据均来自java.lang.management.GarbageCollectorMXBean。&lt;/li&gt;
&lt;li&gt;httpsessions.*：Tomcat容器的会话使用情况。包括最大会话数httpsessions.max和活跃会话数httpsessions.active。该度量指标信息仅在引入了嵌入式Tomcat作为应用容器的时候才会提供。&lt;/li&gt;
&lt;li&gt;gauge.*：HTTP请求的性能指标之一，它主要用来反映一个绝对数值。比如上面示例中的&lt;strong&gt;gauge.response.hello: 5，它表示上一次hello请求的延迟时间为5毫秒。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;counter.*：HTTP请求的性能指标之一，它主要作为计数器来使用，记录了增加量和减少量。如上示例中&lt;strong&gt;counter.status.200.hello: 11，它代表了hello请求返回200状态的次数为11。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;double asterisks（&lt;code class=&quot;literal&quot;&gt;star-star&lt;/code&gt;）来自与Spring MVC匹配的请求&lt;code class=&quot;literal&quot;&gt;/**&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;（通常是静态资源）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;/trace：该端点用来返回基本的HTTP跟踪信息&lt;/li&gt;
&lt;li&gt;/dump：该端点用来暴露程序运行中的线程信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201803/1137026-20180315160157683-527277354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在应用层面只能监控到接口的200，response，400的状态，时间响应上，需要的信息量还不足。可以在telegraf.conf中开启net监控网络等，使用正确的插件帮助我们实现监控需求。&lt;/p&gt;
&lt;p&gt;　　以上都是我个人在实践中的总结和资料整理，如有疑问可以给我留言，我会及时回复您的。&lt;/p&gt;

</description>
<pubDate>Thu, 15 Mar 2018 14:40:00 +0000</pubDate>
<dc:creator>appleYang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhikou/p/8576891.html</dc:identifier>
</item>
<item>
<title>WPF自学入门（七）WPF 初识Binding - 黄昏前黎明后</title>
<link>http://www.cnblogs.com/fly-bird/p/8576748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fly-bird/p/8576748.html</guid>
<description>&lt;p&gt;       今天记录一下Binding的基础和具体的使用方法，说起这个Binding，在WPF中，Binding是很重要的特征，在传统的Windows软件来看，大多数都是UI驱动程序的模式，也可以说事件驱动程序，这个程序模式在工作过几年的程序员中是根深蒂固的，WPF作为Winform的升级，它把UI驱动程序彻底改变了，核心回到了数据驱动程序的模式上面，这样，程序就回到了算法和数据。数据，才是真正需要重点处理的！&lt;/p&gt;
&lt;p&gt;        Binding在数据驱动程序模式中起着至关重要的作用，它最为重要的一个特点就是通讯，连接着前台与后台。首先看一下Binding最简单的使用方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、元素之间的绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221321853-815498956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    这里有3个控件,Slider,TextBox,Label，其中TextBox和Label都作为目标，Slider都作为数据源，把Slider中的值交由两个控件体现，移动滑块，TextBox会自动显示Value的值，也就是FontSize的值。因为两个绑定都设置了双向绑定，所以可以在文本框中输入值，然后丢失焦点，也能反馈回去。&lt;/p&gt;
&lt;p&gt;看一下XAML中的绑定语句，这里用的ElementName就是制定要绑定的对象的名字，Path就是要绑定的依赖项属性，mode就是绑定方式，这里需要说明的是mode有五种方式：&lt;/p&gt;
&lt;p&gt;(1)OneWay 单向绑定&lt;/p&gt;
&lt;p&gt;(2)TwoWay 双向绑定&lt;/p&gt;
&lt;p&gt;(3)OneTime，最初根据源属性值设置目标属性，以后就忽略所有改变，就是说，只进行初始化。&lt;/p&gt;
&lt;p&gt;(4)OneWayToSource，这和OneWay相反&lt;/p&gt;
&lt;p&gt;(5)Default，这是默认形式，它根据目标属性自动设置。&lt;/p&gt;
&lt;p&gt;      如果把TextBox中的值修改成其他的，滑条位置没有改变，字体大小也没有改变，这是什么回事呢？当TextBox失去焦点的时候，就会发生相应的改变了。这是因为这个绑定中的默认更新机制，更新机制Binding.UpdateSourceTrigger，这个属性有4个枚举值&lt;/p&gt;
&lt;p&gt;（1）PropertyChange，当值改变的时候，就更新。&lt;/p&gt;
&lt;p&gt;（2）LostFocus，当时去焦点的时候更新.&lt;/p&gt;
&lt;p&gt;（3）Explicit，当调用BingingExpression.UpdateSource()方法的使用更新，其他情况不会更新。&lt;/p&gt;
&lt;p&gt;（4）Default，默认形式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：以上这四种更新机制的设定，只会影响源数据，而不会影响目标数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221332118-1699150909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二：元素自身的绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     除了可以绑定别的元素，也可以绑定自身的其他属性，例如Slider自身的Opacity属性和自身的Value属性绑定，当滑块向左移动的时候，会逐渐隐藏起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221357716-899189811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三：后台数据与元素之间的绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     前面说了元素之间的绑定和元素自身的绑定，最后重点来了后台数据和前台元素的绑定，这种绑定方式很好地体现了数据驱动程序的运行模式。&lt;/p&gt;
&lt;p&gt;     首先新建Person类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221417300-2068208561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    页面后台代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221426585-952291307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;显示效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221434620-1750228792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       数据的绑定的方式已经写完了。Binding是一条高速公路，那么为了提高数据传递的合法性和有效性，我们要在这条高速公路中建立起一系列的关卡，有的用来转换数据，有的用来校验数据，下面就说一下Binding对数据的校验和转换。&lt;/p&gt;
&lt;p&gt;(一)Binding的数据校验&lt;/p&gt;
&lt;p&gt;     Binding的数据校验工作是派生自ValidationRule类，并且对Validate方法进行重写的自定义类！看一下实例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221443857-1572395500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      先设计一个检验类，它继承ValidationRule类并且重写Validate方法。使用这个类的时候是创建Binding的时候设置校验的。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221454785-1308192878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好了，看一下结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221502583-318968080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      因为设置了值传过去的值不能是超过0~100之间，所以当超过了就显示红色边框。在Binding中，默认是会认为数据源是肯定正确的，所以如果将TextBox作为数据源，而Slider作为目标，数据源输入错误是没有显示的，那么怎么解决这个问题呢，设置VdataValidationRule.ValidatesOnTargetUpdated = true;&lt;/p&gt;

&lt;p&gt;( 二)Binding的数据转换&lt;/p&gt;
&lt;p&gt;       Binding还有另外一种机制称为数据转换，当Source端指定的Path属性值和Target端指定的目标属性不一致的时候，我们可以添加数据转换器（Convert）。上面我们提到的问题实际上就是double和stirng类型相互转换的问题，因为处理起来比较简单，所以WPF类库就自己帮我们做了，但有些数据类型转换就不是WPF能帮我们做的了，当遇到这些情况，我们只能自己动手写Converter，方法是创建一个类并让这个类实现IValueConverter接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221512148-1656706911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;        这个就是日期转换类，它有两个方法：&lt;/p&gt;
&lt;p&gt;       1.当值从绑定源传播给绑定目标时，调用方法Convert&lt;/p&gt;
&lt;p&gt;       2.当值从绑定目标传播给绑定源时，调用此方法ConvertBack，方法ConvertBack的实现必须是方法Convert的反向实现。&lt;/p&gt;
&lt;p&gt;        这两个方法分别在里面写入怎么转换，转换成什么类型就是返回类型。&lt;/p&gt;
&lt;p&gt;下面就是使用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221523674-1181694798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好了，把这个绑定的Converter属性设置成我们设计的转换类的实例就可以了。看一下程序的界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180315221531413-1963773383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 15 Mar 2018 14:17:00 +0000</pubDate>
<dc:creator>黄昏前黎明后</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fly-bird/p/8576748.html</dc:identifier>
</item>
</channel>
</rss>