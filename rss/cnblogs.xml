<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>定时调度系列之Quartz.Net详解 - Yaopengfei</title>
<link>http://www.cnblogs.com/yaopengfei/p/9216229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaopengfei/p/9216229.html</guid>
<description>&lt;p&gt;&lt;span&gt;一. 背景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　我们在日常开发中，可能你会遇到这样的需求：&quot;每个月的3号给用户发信息，提醒用户XXX &quot;、&quot;每天的0点需要统计前一天的考勤记录&quot;、&quot;每个月的1号计算上个月的库存情况&quot;、&quot;定时初始化数据供其它业务使用&quot;、&quot;每隔2分钟轮询查数据库看某业务是否被审核通过，并提示用户&quot; 等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以上需求在开发中都非常常见，但它们仅仅属于低端一点的需求，稍高端一点的需求比如：&quot; 客服派车给调度，如果调度3天内没有执行任何操作，需要提示调度要抓紧派车了 &quot;，到这一步为止看起来和上面的需求并没有什么两样，但如果我要求，系统管理员可以动态配置提示时间呢？即管理员可以配置调度几天没有执行任何操作，系统需要给出提示。这么一改的话，对于一些新手而已，难度就陡然上升了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面我们接着升级需求，系统中有A、B、C、D。。。。等等多个业务，系统管理员可以动态配置每个业务的执行时间情况(如：每隔2s执行一次、每月3号执行一次等等)，并且可以动态的控制每个业务的开启、关闭、暂停、全部关闭、全部暂停等。需求升级到这个程度，估计新手就抓虾了，有一定经验的人但是没有接触过类似框架，面对这样的需求，也需要一点时间去研究。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解惑：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　需求1：也就是我们常说的定时任务，简答一点的可以借助Timer类来实现，对时间要求复杂的需要借助第三方的框架来实现，如：Quartz.Net.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　需求2：需要我们动态配置定时任务的执行时间。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　需求3：需要我们自己搭建一个定时调度框架，然后来动态配置任务的开启、关闭和触发器的情况。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 　　&lt;span&gt;需求三就是我们最终的目标，即我们要搭建一套通用的定时调度框架，可以手动增加定时任务，配置其触发器，手动控制任务的开启、关闭(B/S 架构)；或者C/S架构，最终部署成windows服务的形式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　综上所述：Quartz.Net将是我们的最佳选择。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二. Quartz.Net简介&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;1. Quartz.Net是一个强大、开源、轻量的作业调度框架，是 OpenSymphony 的 Quartz API 的.NET移植，用C#改写，可用于winform和asp.net应用中。它灵活而不复杂。你能够用它来为执行一个作业而创建简单的或复杂的作业调度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它有几大优势：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a.持久化数据库：SQLServer、MySQL、MongoDB、Redis&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b.集群支持：双机热备&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　c.支持Web B/S架构和WinForm C/S架构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　d.trigger可以灵活的控制时间各类苛刻的时间要求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. Quartz.Net框架的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①.引入方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a. 通过NuGet引入搜索Quartz引入相应的程序集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(2.x版本需要会引入三个程序集：Common.Logging、Common.Logging.Core、Quartz和一个xsd文件用于xml配置进行代码提示)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b. 去官网下载源码，通过引入源码的形式进行引入(http://www.quartz-scheduler.net/)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;PS：目前最新版本为3.0.5（2018-06-23）,这里采用的是2.6.1 即2x的最后一个版本，3x起支持.netcore，且基本用法发生了变化，最好使用vs2017&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②.基本使用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a.创建作业调度池(Scheduler)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b.创建一个具体的作业即job (具体的job需要单独在一个文件中执行)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　c.创建并配置一个触发器即trigger &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　d.将job和trigger加入到作业调度池中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　e.开始调度 start&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 官方地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;官网：&lt;a href=&quot;http://www.quartz-scheduler.net/&quot; rel=&quot;nofollow&quot;&gt;http://www.quartz-scheduler.net/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　示例：&lt;a href=&quot;http://www.quartz-scheduler.net/documentation/quartz-2.x/quick-start.html&quot; target=&quot;_blank&quot;&gt;http://www.quartz-scheduler.net/documentation/quartz-2.x/quick-start.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三. 系列章节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　下面我们将一起通过下面的几个章节，系统的学习一下Quartz.Net的基本用法、扩展一些高级配置，并且最终从框架的角度来处理定时调度这一类通用的问题，欢迎广大博友前来交流、指正、学习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　      &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8512273.html&quot;&gt;&lt;span&gt;第一节: Timer的定时任务的复习、Quartz.Net的入门使用、Aop思想的体现 &lt;/span&gt;&lt;/a&gt; :&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8520659.html&quot;&gt;&lt;span&gt;第二节: 比较DateTime和DateTimeOffset两种时间类型并介绍Quartz.Net中用到的几类时间形式(定点、四舍五入、倍数、递增)&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8526358.html&quot;&gt;&lt;span&gt;第三节: Quartz.Net五大构件之Scheduler(创建、封装、基本方法)和Job(创建、关联等)&lt;/span&gt;&lt;/a&gt; :&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8533333.html&quot;&gt;&lt;span&gt;第四节: Quartz.Net五大构件之Trigger通用用法(常用方法、优先级、与job关联等)&lt;/span&gt;&lt;/a&gt; :&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8542771.html&quot;&gt;&lt;span&gt;第五节: Quartz.Net五大构件之Trigger的四大触发类 &lt;/span&gt;&lt;/a&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8545777.html&quot;&gt;&lt;span&gt;第六节: 六类Calander处理六种不同的时间场景&lt;/span&gt;&lt;/a&gt; :&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8549508.html&quot;&gt;&lt;span&gt;第七节:Trigger(SimpleTrigger、CronTrigger)哑火(MisFire)策略&lt;/span&gt;&lt;/a&gt; :&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8561956.html&quot;&gt;&lt;span&gt;第八节: Quartz.Net五大构件之SimpleThreadPool及其四种配置方案&lt;/span&gt;&lt;/a&gt; :&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8573628.html&quot;&gt;&lt;span&gt;第九节: 利用RemoteSheduler实现Scheduler跨服务器的远程控制&lt;/span&gt;&lt;/a&gt; :&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8577934.html&quot;&gt;&lt;span&gt;第十节: 利用SQLServer实现Quartz的持久化和双机热备的集群模式&lt;/span&gt;&lt;/a&gt; :&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8594198.html&quot;&gt;&lt;span&gt;第十一节: 封装通用的定时调度框架，实现新增、删除、开启、暂停计划任务&lt;span&gt;(未完)&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8613198.html&quot;&gt;&lt;span&gt;第十二节: 总结Quartz.Net几种部署模式(IIS、Exe、服务部署【借助TopSelf、服务类】）&lt;/span&gt;&lt;/a&gt; :&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;作       者 : &lt;span&gt;Yaopengfei(姚鹏飞)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;博客地址 : &lt;a href=&quot;http://www.cnblogs.com/yaopengfei/&quot;&gt;&lt;span&gt;http://www.cnblogs.com/yaopengfei/&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;声     明1 : 本人才疏学浅，用郭德纲的话说“我是一个小学生”，如有错误，欢迎讨论，请勿谩骂^_^。&lt;/li&gt;
&lt;li&gt;声     明2 : 原创博客请在转载时保留原文链接或在文章开头加上本人博客地址，如需代码请留下你的评论，加我QQ：604649488 （备注：评论的博客名）&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;/div&gt;

</description>
<pubDate>Fri, 22 Jun 2018 23:46:00 +0000</pubDate>
<dc:creator>Yaopengfei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaopengfei/p/9216229.html</dc:identifier>
</item>
<item>
<title>RabbitMQ入门：路由(Routing) - JAVA开发老菜鸟</title>
<link>http://www.cnblogs.com/sam-uncle/p/9209666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-uncle/p/9209666.html</guid>
<description>&lt;p&gt;在上一篇博客《&lt;a href=&quot;https://www.cnblogs.com/sam-uncle/p/9208008.html&quot; target=&quot;_blank&quot;&gt;RabbitMQ入门：发布/订阅（Publish/Subscribe）&lt;/a&gt;》中，我们认识了fanout类型的exchange，它是一种通过广播方式发送消息的路由器，所有和exchange建立的绑定关系的队列都会接收到消息。但是有一些场景&lt;strong&gt;只需要订阅到一部分消息&lt;/strong&gt;，这个时候就不能使用fanout 类型的exchange了，这个就引出来今天的“猪脚”--Direct Exchange，通过Routing Key来决定需要将消息发送到哪个或者哪些队列中。&lt;/p&gt;
&lt;p&gt;接下来请收看详细内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Direct Exchange（直接路由器）&lt;/li&gt;
&lt;li&gt;多重绑定&lt;/li&gt;
&lt;li&gt;代码实例&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Direct Exchange（直接路由器）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在上文中介绍exchange的时候，对direct exchange进行了简单介绍，它是一种完全按照routing key（路由关键字）进行投递的：当消息中的&lt;strong&gt;routing key&lt;/strong&gt;和队列中的&lt;strong&gt;binding key&lt;/strong&gt;完全匹配时，才进行会将消息投递到该队列中。这里提到了一个routing key和binding key（绑定关键字），是什么东东？&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;routing key:
&lt;p&gt; 在&lt;em&gt;发送消息&lt;/em&gt;的时候，basicPublish的第二个参数就是routing key，由于上次是fanout 类型的exchange 进行广播方式投递，这个字段不会影响投递结果，因此我们这里就传入了“”，但是在direct 类型的exchange中我们就不能传入&quot;&quot;了，需要指定具体的关键字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621155206494-1451951211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;binding key:
&lt;p&gt;我们在前文中&lt;em&gt;建立绑定关系&lt;/em&gt;的时候，queueBind的第三个参数就是绑定关键字&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621154646040-1351865586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们声明direact exchange的时候使用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621155533569-1282683019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;二、多重绑定&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多个队列&lt;/strong&gt;以&lt;strong&gt;相同的绑定键&lt;/strong&gt;绑定到&lt;strong&gt;同一个路由器&lt;/strong&gt;的情况，我们称之为&lt;strong&gt;多重绑定&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;工作模型为（P代表生产者，X代表路由器，红色的Q代表队列，C代表消费者）:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621155733930-1268265769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、代码实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 预备知识了解完了，现在来写个程序感受下。&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;生产者
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogDirectSender {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; exchange名字&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String EXCHANGE_NAME = &quot;directExchange&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
        factory.setHost(&lt;/span&gt;&quot;localhost&quot;&lt;span&gt;);
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.创建连接和通道&lt;/span&gt;
            connection =&lt;span&gt; factory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.为通道声明direct类型的exchange&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(EXCHANGE_NAME, &lt;span&gt;&lt;strong&gt;BuiltinExchangeType.DIRECT&lt;/strong&gt;&lt;/span&gt;);

            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.发送消息到指定的exchange,队列指定为空,由exchange根据情况判断需要发送到哪些队列&lt;/span&gt;
            String routingKey = &quot;debug&quot;&lt;span&gt;;
            String msg &lt;/span&gt;= &quot; hello rabbitmq, I am &quot; +&lt;span&gt; routingKey;
            channel.basicPublish(EXCHANGE_NAME, &lt;span&gt;&lt;strong&gt;routingKey&lt;/strong&gt;&lt;/span&gt;, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, msg.getBytes());
            System.out.println(&lt;/span&gt;&quot;product send a msg: &quot; +&lt;span&gt; msg);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.关闭连接&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (channel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    channel.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
                    e.printStackTrace();
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和上次博客中生产者的区别就是黑字粗体部分：1.路由器类型改为direct 2.消息发布的时候指定了routing key&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8.5&quot;&gt;消费者
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogDirectReciver {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
        factory.setHost(&lt;/span&gt;&quot;localhost&quot;&lt;span&gt;);
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.创建连接和通道&lt;/span&gt;
            connection =&lt;span&gt; factory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.为通道声明direct类型的exchange&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(LogDirectSender.EXCHANGE_NAME, &lt;strong&gt;&lt;span&gt;BuiltinExchangeType.DIRECT&lt;/span&gt;&lt;/strong&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.创建随机名字的队列&lt;/span&gt;
            String queueName =&lt;span&gt; channel.queueDeclare().getQueue();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.建立exchange和队列的绑定关系&lt;/span&gt;
             String[] bindingKeys = { &quot;error&quot;, &quot;info&quot;, &quot;debug&quot;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            String[] bindingKeys = { &quot;error&quot; };&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; bindingKeys.length; i++&lt;span&gt;) {
                channel.queueBind(queueName, LogDirectSender.EXCHANGE_NAME, &lt;span&gt;&lt;strong&gt;bindingKeys[i]&lt;/strong&gt;&lt;/span&gt;);
                System.out.println(&lt;/span&gt;&quot; **** LogDirectReciver keep alive ,waiting for &quot; +&lt;span&gt; bindingKeys[i]);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.通过回调生成消费者并进行监听&lt;/span&gt;
            Consumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleDelivery(String consumerTag, Envelope envelope,
                        com.rabbitmq.client.AMQP.BasicProperties properties, &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取消息内容然后处理&lt;/span&gt;
                    String msg = &lt;span&gt;new&lt;/span&gt; String(body, &quot;UTF-8&quot;&lt;span&gt;);
                    System.out.println(&lt;/span&gt;&quot;*********** LogDirectReciver&quot; + &quot; get message :[&quot; + msg + &quot;]&quot;&lt;span&gt;);
                }
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6.消费消息&lt;/span&gt;
            channel.basicConsume(queueName, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, consumer);

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和上次博客中消费者的区别就是黑字粗体部分：1.路由器类型改为direct 2.建立绑定关系的时候指定了binding key&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;执行消费者，控制台log打印如下：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 **** LogDirectReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; error
 &lt;/span&gt;**** LogDirectReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; info
 &lt;/span&gt;**** LogDirectReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt; debug
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个消费者我们视为消费者1，它会接收error,info,debug三个关键字的消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;将String[] bindingKeys = { &quot;error&quot;, &quot;info&quot;, &quot;debug&quot; };改为String[] bindingKeys = { &quot;error&quot; };，然后再运行一次消费者。控制台log打印如下：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 **** LogDirectReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt; error
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个消费者我们视为消费者2，它只会接收error 关键字的消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;执行生产者，然后将String routingKey = &quot;debug&quot;;的值分别改为“info&quot;和&quot;error&quot;，然后分别执行，这样一共执行了三次生产者
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一次执行：
product send a msg:  hello rabbitmq, I am debug

第二次执行：
product send a msg:  hello rabbitmq, I am info

第三次执行：
product send a msg:  hello rabbitmq, I am error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.5&quot;&gt;再次查看两个消费者的控制台log：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;消费者1：
 &lt;/span&gt;**** LogDirectReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; error
 &lt;/span&gt;**** LogDirectReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; info
 &lt;/span&gt;**** LogDirectReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; debug
&lt;/span&gt;***********&lt;span&gt; LogDirectReciver get message :[ hello rabbitmq, I am debug]
&lt;/span&gt;***********&lt;span&gt; LogDirectReciver get message :[ hello rabbitmq, I am info]
&lt;/span&gt;***********&lt;span&gt; LogDirectReciver get message :[ hello rabbitmq, I am error]

消费者2：
 &lt;/span&gt;**** LogDirectReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; error
&lt;/span&gt;*********** LogDirectReciver get message :[ hello rabbitmq, I am error]
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;查看RabbitMQ管理页面&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621161841104-1025587780.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;exchanges标签页里面多了个direct类型的路由器。进入详细页面：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621161937127-862235709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有4个绑定关系，其中三个的队列是同一个。切换到Queues标签页：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621162219859-262682578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有两个临时队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果关掉消费者1和消费者2，会发现队列自动删除了，绑定关系也不存在了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 22 Jun 2018 22:36:00 +0000</pubDate>
<dc:creator>JAVA开发老菜鸟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sam-uncle/p/9209666.html</dc:identifier>
</item>
<item>
<title>react的生命周期需要知道的。 - 一直在寻</title>
<link>http://www.cnblogs.com/faith3/p/9216165.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/faith3/p/9216165.html</guid>
<description>&lt;h2&gt;1、组件生命周期的执行次数是什么样子的？？？&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   只执行一次： constructor、componentWillMount、componentDidMount

　　执行多次：render 、&lt;span&gt;&lt;strong&gt;子组件的&lt;/strong&gt;&lt;/span&gt;componentWillReceiveProps、componentWillUpdate、componentDidUpdate

　　有条件的执行：componentWillUnmount（页面离开，组件销毁时）

　　不执行的：根组件（ReactDOM.render在DOM上的组件）的componentWillReceiveProps（因为压根没有父组件给传递props）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2、组件的生命周期执行顺序是什么样子的？？？&lt;/h2&gt;
&lt;p&gt;　　假设组件嵌套关系是  App里有parent组件，parent组件有child组件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905482/201806/905482-20180623010305677-1731144297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     如果不涉及到setState更新，第一次渲染的顺序如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905482/201806/905482-20180623010918232-1309924858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
App：   constructor --&amp;gt; componentWillMount --&amp;gt;  render --&amp;gt;&lt;span&gt; 
parent: constructor &lt;/span&gt;--&amp;gt; componentWillMount --&amp;gt;  render --&amp;gt;&lt;span&gt; 
child:    constructor &lt;/span&gt;--&amp;gt; componentWillMount --&amp;gt;  render  --&amp;gt;&lt;span&gt; 
componentDidMount (child) &lt;/span&gt;--&amp;gt;  componentDidMount (parent) --&amp;gt; componentDidMount (App)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   这时候触发App的setState事件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905482/201806/905482-20180623011559357-19784119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
App：   componentWillUpdate --&amp;gt; render --&amp;gt;&lt;span&gt; 
parent: componentWillReceiveProps &lt;/span&gt;--&amp;gt; componentWillUpdate --&amp;gt; render --&amp;gt;&lt;span&gt; 
child:    componentWillReceiveProps &lt;/span&gt;--&amp;gt; componentWillUpdate --&amp;gt; render --&amp;gt;&lt;span&gt;
componentDidUpdate (child) &lt;/span&gt;--&amp;gt;  componentDidUpdate (parent) --&amp;gt; componentDidUpdate (App)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那如果是触发parent的setState呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905482/201806/905482-20180623012011552-2017869092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
parent： componentWillUpdate --&amp;gt; render --&amp;gt;&lt;span&gt; 
child:     componentWillReceiveProps &lt;/span&gt;--&amp;gt; componentWillUpdate --&amp;gt; render --&amp;gt;&lt;span&gt; 
componentDidUpdate (child) &lt;/span&gt;--&amp;gt;  componentDidUpdate (parent) 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那如果是只是触发了child组件自身的setState呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905482/201806/905482-20180623012039074-2037301353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
child： componentWillUpdate --&amp;gt; render --&amp;gt;  componentDidUpdate (child)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;如图：完成前的顺序是从根部到子部，完成时时从子部到根部。（类似于事件机制）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、每个组件的红线（包括初次和更新）生命周期时一股脑执行完毕以后再执行低一级别的红线生命周期。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905482/201806/905482-20180623013527112-2052431114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;第一级别的组件setState是不能触发其父组件的生命周期更新函数，只能触发更低一级别的生命周期更新函数&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;总结起来就如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905482/201806/905482-20180623013925218-118360954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;提问：那么这里提一个问题，如果App里面有多个parent1 parent2 ...，parent里由多个child，那么生命周期执行顺序应该时什么样的？？？？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结论：一套组件（父包括子，子包括孙）执行的时候一个整体，执行完毕在执行下一套，用到这里就是App里先执行parent1和parent1的子，子的子。。。，然后完毕再执行parent2这一套。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; 3、什么时候该用componentWillReceiveProps？&lt;/h2&gt;
&lt;p&gt;    是否每个子组件都需要componentWillReceiveProps生命周期函数来更新数据吗？ 你的原则是？？&lt;/p&gt;

&lt;p&gt;A、开始前首先需要知道componentWillReceiveProps函数有一个参数nextProps，它是一个 &lt;strong&gt;&lt;span&gt;{ 对象 }&lt;/span&gt;&lt;/strong&gt; ，从单词就可以看出它是&lt;strong&gt;&lt;span&gt;update时候&lt;/span&gt;&lt;/strong&gt;（也就是下一次）&lt;span&gt;&lt;strong&gt;父组件传递过来的props&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;B、还要知道 &quot;第一条中&quot; 所讲解的有些生命周期函数只执行一次，而有的执行多次，其中&lt;strong&gt;&lt;span&gt;componentWillReceiveProps执行多次，&lt;/span&gt;&lt;span&gt;而constructor等执行一次&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;C、还需知道在子组件中每次传递过来的&lt;strong&gt;&lt;span&gt;this.props对象其实和componentWillReceiveProps的nextProps是一样的，都是最新的&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;D、由&quot;第一条&quot;得知： componentWillReceiveProps生命周期是在&lt;strong&gt;&lt;span&gt;更新子组件最先执行的&lt;/span&gt;&lt;/strong&gt;，优先于compoentWillUpdate，更优先于render。&lt;/p&gt;
&lt;p&gt;E、render函数里不能使用setState()，否则会造成死循环。&lt;/p&gt;

&lt;p&gt;那么知道了以上呢？  &lt;/p&gt;

&lt;p&gt;由C得知，  this.props  和  componentWillReceiveProps的nextProps都是一样的，通过this.props就可以取到最新的值， 那么componentWillReceiveProps还有必要吗？&lt;/p&gt;
&lt;p&gt;所以：&lt;span&gt;&lt;strong&gt;大部分情况下 componentWillReceiveProps 生命周期函数是没用的，即可以略去不写，因为它确实没什么用&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;但是情况1：&lt;/p&gt;
&lt;p&gt;　　由D得知，componentWillReceiveProps是最先执行的，所以在其内可以setState(｛｝)，在接下来的render中能拿到最新的state后值，再加上B得知，&lt;/p&gt;
&lt;p&gt;如果是下面这种情况： &lt;strong&gt;&lt;span&gt;在constructor函数中初始化了某个state，必须用 componentWillReceiveProps 来更新state，以便render中为新的state值&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905482/201806/905482-20180623024251177-396333695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905482/201806/905482-20180623024601879-1444777769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 情况2：&lt;/p&gt;
&lt;p&gt;　　如果父组件有一些请求，每次参数更新的时候才发请求，同时和子组件的关系比较密切，&lt;/p&gt;
&lt;p&gt;可以将数据请求放在componentWillReceiveProps进行执行，需要传的参数则从(nextProps)中获取。&lt;/p&gt;
&lt;p&gt;而不必将所有的请求都放在父组件中，&lt;span&gt;&lt;strong&gt;于是该请求只会在该组件渲染时才会发出，从而减轻请求负担&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt; 情况3：后续添加；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;结论：&lt;/span&gt; &lt;span&gt;大部分情况下 componentWillReceiveProps 生命周期函数是没用的，即可以略去不写，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;但是在constructor函数中初始化了某个state，必须用 componentWillReceiveProps 来更新state，不可省去，否则render中的state将得不到更新。&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;注意：使用componentWillReceiveProps的时候，不要去向上分发，调用父组件的相关setState方法，否则会成为死循环。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 22 Jun 2018 17:42:00 +0000</pubDate>
<dc:creator>一直在寻</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/faith3/p/9216165.html</dc:identifier>
</item>
<item>
<title>python3解析库lxml - Py.qi</title>
<link>http://www.cnblogs.com/zhangxinqi/p/9210211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxinqi/p/9210211.html</guid>
<description>&lt;p&gt; lxml是python的一个解析库，支持HTML和XML的解析，支持XPath解析方式，而且解析效率非常高&lt;/p&gt;
&lt;p&gt;XPath，全称XML Path Language，即XML路径语言，它是一门在XML文档中查找信息的语言，它最初是用来搜寻XML文档的，但是它同样适用于HTML文档的搜索&lt;/p&gt;
&lt;p&gt;XPath的选择功能十分强大，它提供了非常简明的路径选择表达式，另外，它还提供了超过100个内建函数，用于字符串、数值、时间的匹配以及节点、序列的处理等，几乎所有我们想要定位的节点，都可以用XPath来选择&lt;/p&gt;
&lt;p&gt;XPath于1999年11月16日成为W3C标准，它被设计为供XSLT、XPointer以及其他XML解析软件使用，更多的文档可以访问其官方网站：&lt;a href=&quot;https://www.w3.org/TR/xpath/&quot; target=&quot;_blank&quot;&gt;https://www.w3.org/TR/xpath/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1、python库lxml的安装&lt;/h3&gt;
&lt;p&gt;windows系统下的安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;pip安装&lt;/span&gt;
&lt;span&gt;pip3 install lxml

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;wheel安装&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;下载对应系统版本的wheel文件:http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml&lt;/span&gt;
pip3 install lxml-4.2.1-cp36-cp36m-win_amd64.whl
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;linux下安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install -y epel-release libxslt-devel libxml2-devel openssl-&lt;span&gt;devel

pip3 install lxml&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;验证安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$python3
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;import&lt;/span&gt; lxml
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、XPath常用规则&lt;/h3&gt;
&lt;table dir=&quot;ltr&quot; border=&quot;2&quot; frame=&quot;border&quot; rules=&quot;all&quot; cellspacing=&quot;2&quot; cellpadding=&quot;1&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td&gt;表达式&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;nodename&lt;/td&gt;
&lt;td&gt;选取此节点的所有子节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;从当前节点选取直接子节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;//&lt;/td&gt;
&lt;td&gt;从当前节点选取子孙节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;选取当前节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;..&lt;/td&gt;
&lt;td&gt;选取当前节点的父节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;选取属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;通配符，选择所有元素节点与元素名&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@*&lt;/td&gt;
&lt;td&gt;选取所有属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;[@attrib]&lt;/td&gt;
&lt;td&gt;选取具有给定属性的所有元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;[@attrib='value']&lt;/td&gt;
&lt;td&gt;选取给定属性具有给定值的所有元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;[tag]&lt;/td&gt;
&lt;td&gt;选取所有具有指定元素的直接子节点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;[tag='text']&lt;/td&gt;
&lt;td&gt;选取所有具有指定元素并且文本内容是text节点&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;（1）读取文本解析节点&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

text&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;a属性&amp;lt;/a&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
html&lt;/span&gt;=etree.HTML(text) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化生成一个XPath解析对象&lt;/span&gt;
result=etree.tostring(html,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;解析对象输出代码&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(html))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(result))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;etree会修复HTML文本节点&lt;/span&gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml.etree._Element&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bytes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;a属性&amp;lt;/a&amp;gt;
     &amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;（2）读取HTML文件进行解析&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

html&lt;/span&gt;=etree.parse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,etree.HTMLParser()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;指定解析器HTMLParser会根据文件修复HTML文件中缺失的如声明信息&lt;/span&gt;
result=etree.tostring(html)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;解析成字节&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;result=etree.tostringlist(html) #解析成列表&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(html))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(result))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)

&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml.etree._ElementTree&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bytes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&amp;gt;\n&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div&amp;gt;&amp;amp;#13;\n    &amp;lt;ul&amp;gt;&amp;amp;#13;\n         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&amp;amp;#13;\n         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&amp;amp;#13;\n         &amp;lt;li class=&quot;item-inactive&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;third item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&amp;amp;#13;\n         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&amp;amp;#13;\n         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;amp;#13;\n     &amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;amp;#13;\n &amp;lt;/div&amp;gt;&amp;amp;#13;\n&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;（3）获取所有节点&lt;/h4&gt;
&lt;p&gt;返回一个列表每个元素都是Element类型，所有节点都包含在其中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

html&lt;/span&gt;=etree.parse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,etree.HTMLParser())
result&lt;/span&gt;=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;//代表获取子孙节点，*代表获取所有&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(html))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(result))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)

&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml.etree._ElementTree&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
[&lt;/span&gt;&amp;lt;Element html at 0x754b210048&amp;gt;, &amp;lt;Element body at 0x754b210108&amp;gt;, &amp;lt;Element div at 0x754b210148&amp;gt;, &amp;lt;Element ul at 0x754b210188&amp;gt;, &amp;lt;Element li at 0x754b2101c8&amp;gt;, &amp;lt;Element a at 0x754b210248&amp;gt;, &amp;lt;Element li at 0x754b210288&amp;gt;, &amp;lt;Element a at 0x754b2102c8&amp;gt;, &amp;lt;Element li at 0x754b210308&amp;gt;, &amp;lt;Element a at 0x754b210208&amp;gt;, &amp;lt;Element li at 0x754b210348&amp;gt;, &amp;lt;Element a at 0x754b210388&amp;gt;, &amp;lt;Element li at 0x754b2103c8&amp;gt;, &amp;lt;Element a at 0x754b210408&amp;gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如要获取li节点，可以使用//后面加上节点名称，然后调用xpath()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取所有子孙节点的li节点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;（4）获取子节点&lt;/h4&gt;
&lt;p&gt;通过/或者//即可查找元素的子节点或者子孙节点，如果想选择li节点的所有直接a节点，可以这样使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
result=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li/a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过追加/a选择所有li节点的所有直接a节点，因为//li用于选中所有li节点，/a用于选中li节点的所有直接子节点a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;（5）获取父节点&lt;/h4&gt;
&lt;p&gt;我们知道通过连续的/或者//可以查找子节点或子孙节点，那么要查找父节点可以使用..来实现也可以使用parent::来获取父节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lxml.etree &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HTMLParser
text&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

html&lt;/span&gt;=&lt;span&gt;etree.HTML(text,etree.HTMLParser())
result&lt;/span&gt;=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//a[@href=&quot;link2.html&quot;]/../@class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
result1&lt;/span&gt;=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//a[@href=&quot;link2.html&quot;]/parent::*/@class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result1)


&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;（6）属性匹配&lt;/h4&gt;
&lt;p&gt;在选取的时候，我们还可以用&lt;code&gt;@&lt;/code&gt;符号进行属性过滤。比如，这里如果要选取&lt;code&gt;class&lt;/code&gt;为&lt;code&gt;item-1&lt;/code&gt;的&lt;code&gt;li&lt;/code&gt;节点，可以这样实现:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lxml.etree &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HTMLParser
text&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

html&lt;/span&gt;=&lt;span&gt;etree.HTML(text,etree.HTMLParser())
result&lt;/span&gt;=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[@class=&quot;item-1&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;（7）文本获取&lt;/h4&gt;
&lt;p&gt;我们用XPath中的text()方法获取节点中的文本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

text&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

html&lt;/span&gt;=&lt;span&gt;etree.HTML(text,etree.HTMLParser())
result&lt;/span&gt;=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[@class=&quot;item-1&quot;]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取a节点下的内容&lt;/span&gt;
result1=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[@class=&quot;item-1&quot;]//text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取li下所有子孙节点的内容&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result1)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;（8）属性获取&lt;/h4&gt;
&lt;p&gt;使用@符号即可获取节点的属性，如下：获取所有li节点下所有a节点的href属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
result=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li/a/@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取a的href属性&lt;/span&gt;
result=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li//@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取所有li子孙节点的href属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;（9）属性多值匹配&lt;/h4&gt;
&lt;p&gt;如果某个属性的值有多个时，我们可以使用contains()函数来获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

text1&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li class=&quot;aaa item-0&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;bbb item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

html&lt;/span&gt;=&lt;span&gt;etree.HTML(text1,etree.HTMLParser())
result&lt;/span&gt;=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[@class=&quot;aaa&quot;]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
result1&lt;/span&gt;=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[contains(@class,&quot;aaa&quot;)]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result1)

&lt;/span&gt;&lt;span&gt;#通过第一种方法没有取到值，通过contains（）就能精确匹配到节点了
&lt;/span&gt;&lt;span&gt;[]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第一个&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;（10）多属性匹配&lt;/h4&gt;
&lt;p&gt;另外我们还可能遇到一种情况，那就是根据多个属性确定一个节点，这时就需要同时匹配多个属性，此时可用运用and运算符来连接使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

text1&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li class=&quot;aaa&quot; name=&quot;item&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;aaa&quot; name=&quot;fore&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

html&lt;/span&gt;=&lt;span&gt;etree.HTML(text1,etree.HTMLParser())
result&lt;/span&gt;=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[@class=&quot;aaa&quot; and @name=&quot;fore&quot;]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
result1&lt;/span&gt;=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[contains(@class,&quot;aaa&quot;) and @name=&quot;fore&quot;]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result1)


&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;second item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;second item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;（11）XPath中的运算符&lt;/h4&gt;
&lt;table dir=&quot;ltr&quot; border=&quot;2&quot; frame=&quot;border&quot; rules=&quot;all&quot; cellspacing=&quot;2&quot; cellpadding=&quot;2&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;运算符&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;td&gt;实例&lt;/td&gt;
&lt;td&gt;返回值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;td&gt;age=19 or age=20&lt;/td&gt;
&lt;td&gt;如果age等于19或者等于20则返回true反正返回false&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;与&lt;/td&gt;
&lt;td&gt;age&amp;gt;19 and age&amp;lt;21&lt;/td&gt;
&lt;td&gt;如果age等于20则返回true，否则返回false&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mod&lt;/td&gt;
&lt;td&gt;取余&lt;/td&gt;
&lt;td&gt;5 mod 2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;取两个节点的集合&lt;/td&gt;
&lt;td&gt;//book | //cd&lt;/td&gt;
&lt;td&gt;返回所有拥有book和cd元素的节点集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加&lt;/td&gt;
&lt;td&gt;6+4&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;减&lt;/td&gt;
&lt;td&gt;6-4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;乘&lt;/td&gt;
&lt;td&gt;6*4&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;div&lt;/td&gt;
&lt;td&gt;除法&lt;/td&gt;
&lt;td&gt;8 div 4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;等于&lt;/td&gt;
&lt;td&gt;age=19&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;td&gt;age!=19&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;td&gt;age&amp;lt;19&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;小于或等于&lt;/td&gt;
&lt;td&gt;age&amp;lt;=19&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;大于&lt;/td&gt;
&lt;td&gt;age&amp;gt;19&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;gt;= &lt;/td&gt;
&lt;td&gt;大于或等于&lt;/td&gt;
&lt;td&gt;age&amp;gt;=19&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;此表参考来源:&lt;a href=&quot;http://www.w3school.com.cn/xpath/xpath_operators.asp&quot; data-original-title=&quot;&quot;&gt;http://www.w3school.com.cn/xpath/xpath_operators.asp&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;（12）按序选择&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;有时候，我们在选择的时候某些属性可能同时匹配多个节点，但我们只想要其中的某个节点，如第二个节点或者最后一个节点，这时可以利用中括号引入索引的方法获取特定次序的节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

text1&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li class=&quot;aaa&quot; name=&quot;item&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;aaa&quot; name=&quot;item&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第二个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;aaa&quot; name=&quot;item&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第三个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;aaa&quot; name=&quot;item&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第四个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; 
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

html&lt;/span&gt;=&lt;span&gt;etree.HTML(text1,etree.HTMLParser())

result&lt;/span&gt;=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[contains(@class,&quot;aaa&quot;)]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取所有li节点下a节点的内容&lt;/span&gt;
result1=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[1][contains(@class,&quot;aaa&quot;)]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取第一个&lt;/span&gt;
result2=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[last()][contains(@class,&quot;aaa&quot;)]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取最后一个&lt;/span&gt;
result3=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[position()&amp;gt;2 and position()&amp;lt;4][contains(@class,&quot;aaa&quot;)]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取第一个&lt;/span&gt;
result4=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[last()-2][contains(@class,&quot;aaa&quot;)]/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取倒数第三个&lt;/span&gt;


&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result2)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result3)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result4)


&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第一个&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;第二个&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;第三个&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;第四个&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第一个&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第四个&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第三个&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第二个&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用了last()、position()函数，在XPath中，提供了100多个函数，包括存取、数值、字符串、逻辑、节点、序列等处理功能，它们的具体作用可参考：&lt;a title=&quot;&quot; href=&quot;http://www.w3school.com.cn/xpath/xpath_functions.asp&quot; data-original-title=&quot;&quot;&gt;http://www.w3school.com.cn/xpath/xpath_functions.asp&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;（13）节点轴选择&lt;/h4&gt;
&lt;p&gt;XPath提供了很多节点选择方法，包括获取子元素、兄弟元素、父元素、祖先元素等，示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

text1&lt;/span&gt;=&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li class=&quot;aaa&quot; name=&quot;item&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;aaa&quot; name=&quot;item&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第二个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;aaa&quot; name=&quot;item&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第三个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;aaa&quot; name=&quot;item&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;第四个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; 
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

html&lt;/span&gt;=&lt;span&gt;etree.HTML(text1,etree.HTMLParser())
result&lt;/span&gt;=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[1]/ancestor::*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取所有祖先节点&lt;/span&gt;
result1=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[1]/ancestor::div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div祖先节点&lt;/span&gt;
result2=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[1]/attribute::*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取所有属性值&lt;/span&gt;
result3=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[1]/child::*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取所有直接子节点&lt;/span&gt;
result4=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[1]/descendant::a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取所有子孙节点的a节点&lt;/span&gt;
result5=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[1]/following::*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取当前子节之后的所有节点&lt;/span&gt;
result6=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li[1]/following-sibling::*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取当前节点的所有同级节点&lt;/span&gt;


&lt;span&gt;#
&lt;/span&gt;[&amp;lt;Element html at 0x3ca6b960c8&amp;gt;, &amp;lt;Element body at 0x3ca6b96088&amp;gt;, &amp;lt;Element div at 0x3ca6b96188&amp;gt;, &amp;lt;Element ul at 0x3ca6b961c8&amp;gt;&lt;span&gt;]
[&lt;/span&gt;&amp;lt;Element div at 0x3ca6b96188&amp;gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&amp;lt;Element a at 0x3ca6b96248&amp;gt;&lt;span&gt;]
[&lt;/span&gt;&amp;lt;Element a at 0x3ca6b96248&amp;gt;&lt;span&gt;]
[&lt;/span&gt;&amp;lt;Element li at 0x3ca6b96308&amp;gt;, &amp;lt;Element a at 0x3ca6b96348&amp;gt;, &amp;lt;Element li at 0x3ca6b96388&amp;gt;, &amp;lt;Element a at 0x3ca6b963c8&amp;gt;, &amp;lt;Element li at 0x3ca6b96408&amp;gt;, &amp;lt;Element a at 0x3ca6b96488&amp;gt;&lt;span&gt;]
[&lt;/span&gt;&amp;lt;Element li at 0x3ca6b96308&amp;gt;, &amp;lt;Element li at 0x3ca6b96388&amp;gt;, &amp;lt;Element li at 0x3ca6b96408&amp;gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上使用的是XPath轴的用法，更多轴的用法可参考：&lt;a title=&quot;&quot; href=&quot;http://www.w3school.com.cn/xpath/xpath_axes.asp&quot; data-original-title=&quot;&quot;&gt;http://www.w3school.com.cn/xpath/xpath_axes.asp&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;（14）案例应用：抓取TIOBE指数前20名排行开发语言&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;127&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; requests.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RequestException
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lxml.etree &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ParseError
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; one_to_page(html):
    headers&lt;/span&gt;=&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user-agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.62 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        response&lt;/span&gt;=requests.get(html,headers=&lt;span&gt;headers)
        body&lt;/span&gt;=response.text  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取网页内容&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt; RequestException as e:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;request is error!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,e)
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        html&lt;/span&gt;=etree.HTML(body,etree.HTMLParser())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;解析HTML文本内容&lt;/span&gt;
        result=html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//table[contains(@class,&quot;table-top20&quot;)]/tbody/tr//text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取列表数据&lt;/span&gt;
        pos =&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(20&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i ==&lt;span&gt; 0:
                &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; result[i:5&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; result[pos:pos+5]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回排名生成器数据&lt;/span&gt;
            pos+=5
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt; ParseError as e:
         &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e.position)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; write_file(data):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将数据重新组合成字典写入文件并输出&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data:
        sul&lt;/span&gt;=&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:i[0],
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:i[1&lt;span&gt;],
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:i[2&lt;span&gt;],
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:i[3&lt;span&gt;],
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:i[4&lt;span&gt;]
        }
        with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
            f.write(json.dumps(sul,ensure_ascii&lt;/span&gt;=False) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;必须格式化数据&lt;/span&gt;
&lt;span&gt;            f.close()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(sul)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    url&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.tiobe.com/tiobe-index/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    data&lt;/span&gt;=&lt;span&gt;one_to_page(url)
    revaule&lt;/span&gt;=&lt;span&gt;write_file(data)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; revaule ==&lt;span&gt; None:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        
 
 
        
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()



&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;15.368%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+0.88%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;14.936%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+8.09%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8.337%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+2.61%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5.761%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+1.43%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4.314%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+0.78%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Visual Basic .NET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.762%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+0.65%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;PHP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2.881%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+0.11%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2.495%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-0.53%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2.339%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+2.34%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.452%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-0.70%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ruby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.253%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-0.97%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Objective-C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.181%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-0.78%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Visual Basic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.154%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-0.86%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Perl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.147%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1.16%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.145%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1.06%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Assembly language&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.915%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1.34%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MATLAB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.894%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1.10%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Go&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.879%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1.17%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Delphi/Object Pascal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.875%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1.28%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年6月排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017年6排行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;PL/SQL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;评级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.848%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;变化率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-0.72%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;XPath的更多用法参考：&lt;a title=&quot;&quot; href=&quot;http://www.w3school.com.cn/xpath/index.asp&quot; data-original-title=&quot;&quot;&gt;http://www.w3school.com.cn/xpath/index.asp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;python lxml库的更多用法参考：&lt;a title=&quot;&quot; href=&quot;http://lxml.de/&quot; data-original-title=&quot;&quot;&gt;http://lxml.de/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jun 2018 16:47:00 +0000</pubDate>
<dc:creator>Py.qi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxinqi/p/9210211.html</dc:identifier>
</item>
<item>
<title>基于卷积神经网络的单图像去雨 - LittleYou123</title>
<link>http://www.cnblogs.com/zhang716921/p/9216042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhang716921/p/9216042.html</guid>
<description>&lt;p class=&quot;a&quot; align=&quot;left&quot;&gt;       图像去雨是图像处理和计算机视觉领域共同关心的重要问题，传统的关于图像去雨的图像恢复方法在某些特定的情况下会失效，鉴于深度卷积神经网络（CNN）在计算机视觉领域的迅猛发展及其良好的学习性能，越来越多的研究者将CNN应用到图像恢复领域。本文主要从图像处理和物理模型的研究角度，并结合卷积神经网络技术，对图像去雨技术进行综述。并主要介绍近几年提出的典型的去雨CNN网络的基本原理和研究进展，并对这些方法给出其视觉上的效果和客观的评估数据。&lt;/p&gt;
&lt;p class=&quot;a&quot; align=&quot;left&quot;&gt;        近年来，随着计算机软件和硬件技术的不断发展，计算能力不断增强，对雨天图像进行去雨处理已经成为可能，这反过来又对去雨图像的清晰度和真实感提出了新的要求。在雨天情况下，由于场景的能见度低和背景场景被遮挡，图像中目标的对比度和颜色等特征都会出现不同程度的衰减，导致背景信息（即目标图像）表达不明确，这使得一些视频或图像系统不能正常工作，因此需要消除雨天对图像场景的影响。事实上，图像去雨一直是图像恢复和计算机视觉领域研究的重要内容，其主要应用于视频监控和自动驾驶等领域，因此自动性和实时性就成为了研究关注的重点。本文分析和借鉴了最近的研究热点，从图像处理和物理模型的研究角度，并结合卷积神经网络技术，对图像去雨技术进行综述。&lt;/p&gt;
&lt;p class=&quot;a&quot; align=&quot;left&quot;&gt;    &lt;span&gt;  &lt;span&gt;&lt;strong&gt; 1  基于单图深度联合雨水检测和去除&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       恢复下雨图像在计算机视觉系统的应用中是很重要的，雨水会遮挡背景场景，造成图像形变或者模糊，而且雨水也会产生类似于雾气的大气遮挡效果，明显降低了图像背景的能见度。无论是雨滴密集的暴雨场景还是雨痕带积聚的场景，该团队论文提出的方法都可以良好的从单图像中解决去雨问题。其主要思想在于新的图像雨水模型（Rain model）和基于此雨水模型的深度网络架构。    &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  &lt;/strong&gt;   &lt;span&gt;&lt;strong&gt;1.1&lt;/strong&gt; &lt;strong&gt;雨水图像模型&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       广泛使用的雨水模型,表达式如下所示：&lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180622232408962-1340547170.png&quot; alt=&quot;&quot; width=&quot;67&quot; height=&quot;20&quot;/&gt;,其中B代表背景层，即要获取的目标图像；&lt;strong&gt;S&lt;/strong&gt;代表雨痕层；&lt;strong&gt;O&lt;/strong&gt;代表有雨痕的输入图像（雨痕降质图像）。基于这个模型，图像去雨被认为是“双信号分离问题”，也就是说基于给定的降质图像&lt;strong&gt;O&lt;/strong&gt;，由于背景层和雨痕层的具有各自不同的特点可以实现将两层分离，从而得到目标结果。但是这个模型有两个缺陷：首先，层密度不均匀，因为该层只有部分区域有雨痕，使用统一的稀疏编码建模的效果是不理想的；其次，解决信号分离问题，没有区分有雨区域和无雨区域，这会导致处理后的背景过度平滑，导致形变或者模糊。&lt;/p&gt;
&lt;p&gt;       基于以上的缺陷，对上述模型进行改进。使得层既包含雨痕的位置信息也要包含特定像素点位置的雨痕对像素值的贡献构成。由此得出一个广义的雨水模型，如下所示：&lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180622232536544-1470366995.png&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;20&quot;/&gt;，这里包含了一个基于区域的变量&lt;strong&gt;R&lt;/strong&gt;，指明了单独可见的雨痕位置，该变量其实是一个二值图，值为“1”表示对应像素位置有雨痕，值为“0”表示对应像素位置没有雨痕。之所以将&lt;strong&gt;S&lt;/strong&gt;、R分别描述并分别用于网络预测，是为了避免只回归S影响了图中不含雨滴的部分。对&lt;strong&gt;R&lt;/strong&gt;独立建模有以下两点好处：首先,为网络提供更多的信息学习雨痕区域；其次，可以检测到雨水区域和非雨水区域，对两者做不同的处理，可以最大化得到背景层的信息。&lt;/p&gt;
&lt;p&gt;        在现实场景中，基于雨痕带具有不同的形状和不同的方向且雨痕之间会相互重叠，以及暴雨情况下的雨水积聚产生的雾气效果导致远处场景的能见度降低这两个主要的问题，该方法提出了一个更细致的雨水模型，该模型包含多个雨痕层（每个雨痕层中的雨痕方向是一致的），也包含了全局大气光的作用效果（用来模拟雨水产生的雾气效果），模型公式表示如下：&lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180622232655932-1675499687.png&quot; alt=&quot;&quot; width=&quot;118&quot; height=&quot;33&quot;/&gt;，这里&lt;strong&gt;S&lt;/strong&gt;表示一个雨痕层，该层中的雨痕方向都是一致的；&lt;em&gt;t&lt;/em&gt;是雨痕层的索引；&lt;strong&gt;A&lt;/strong&gt;是全局大气光，其实质是对雨水产生的雾气效果进行建模；是全局大气光传输系数。这个模型，同时实现了雨水效果和雾气效果的一种综合状态，更逼近真实的降雨效果，基于这个模型得到的目标图像更接近自然图像。&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;&lt;strong&gt;1.2&lt;/strong&gt; &lt;strong&gt;联合雨水检测和去除的深度卷积神经网络&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      基于以上模型，提出了一个循环雨水检测和去除的深度网络架构，具体结构如图1所示。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180622233349196-1004238240.jpg&quot; alt=&quot;&quot; width=&quot;726&quot; height=&quot;312&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1 循环雨水检测和去除网络架构。每次循环使用一个多任务网络进行雨水检测和去除（蓝色的点框）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;strong&gt;       情境化的上下文扩张网络&lt;/strong&gt;：该深度架构包含一个新颖的网络结构，即基于情境信息的上下文扩张网络（Contextualized dilated network），此结构用于提取雨水图像的可识别特征，为后续的检测和去除做基础。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;  扩张卷积技术&lt;/strong&gt;&lt;strong&gt;(Dilated Convolutions)&lt;/strong&gt;：上下文信息对于图像雨痕区域的检测和识别是非常有用的，使用情境化的上下文扩张网络可以聚合多尺度的上下文信息来学习雨水图像的特征信息。扩张卷积与普通的卷积相比，除了卷积核的大小以外，还有一个扩张因子(Dilated factors)参数，主要用来表示扩张的大小。扩张卷积与普通卷积的相同点在于，卷积核的大小是一样的，在神经网络中即参数数量不变，区别在于扩张卷积具有更大的感受野(Receptive field)。在图1中可以看到该网络包含三条卷积路径，每条卷积路径均使用3*3的卷积核,第一个卷积路径使用普通的卷积核，其余两条路径则使用扩张卷积技术，所以具有不同的扩张因子[DF = 1, 2, 3]，使得提取到特征具有不同的接受视野[5*5, 9*9, 13*13]。基于这种思想，可以提取更丰富的图像上下文信息，使得特征具有更强的鲁棒性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       循环子网络&lt;/strong&gt;：图1中的蓝色的点框是该子网络的结构，每次循环的结果会相应的生成一个残差图像T（*），该结果会作为下一次循环子网络的输入，每次的预测残差值随着网络的循环而累积。并且每次循环所需要的雨水掩模层和雨痕层，并不相同，而是通过损失和每次进行正则化后的结果。&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;&lt;strong&gt;1.3&lt;/strong&gt; &lt;strong&gt;实验结果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      定性评估&lt;/strong&gt;：以下给出本方法和其他方法，基于相同的真实雨水图像的测试数据集下的采样结果，其中主要了比较了DSC（鉴别稀疏编码）和LP（层先验），对比结果如下图2所示：&lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180622233605503-1783894410.jpg&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图2 基于真实图像，不同方法的测试结果。从左到右依次对应：输入测试图像，DSC,LP和本文方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        定量评估&lt;/strong&gt;：主要使用峰值信噪比(PSNR)和结构相似性(SSIM)两个度量来对不同的去雨方法进行数据比较，并且对应度量的数值越大表明效果越好。表1是基于数据集Rain12和Rain100L得出的对比结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180622233810899-1197185381.jpg&quot; alt=&quot;&quot; width=&quot;387&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;表1 基于数据集Rain12和Rain100L，不同去雨方法在PSNR和SSIM度量得出的结果&lt;/p&gt;

&lt;p&gt;       本方法解决了一个更具挑战性的问题，去除落在玻璃或者镜头上的雨滴。首先，被雨水遮挡的原图像信息是不可知的；其次，被遮挡的背景信息不可避免会丢失很多；如果输入图像的雨滴较大并且分布密集时，情况会变得更加棘手。这给问题的解决带来了极大的难度。&lt;/p&gt;
&lt;p&gt;       为了解决这个问题，该团队论文提出了使用注意力生成对抗网络(Attentive GAN)。主要思想是模拟人的视觉注意力(Visual attention),将注意力进行量化，然后同时应用于生成网络(Generative network)和判别网络(Discriminative network)进行训练。在训练过程中，量化的视觉注意力可以学习到更多的雨水区域及其周围的信息。因此，将视觉注意力应用于生成网络和判别网络，可以使得生成网络能更好的聚焦于雨水区域及其周围的结构信息，也可以使得判别网络获得图像恢复区域的局部一致性信息。&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt; 2.1&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;雨水图像模型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoBodyText&quot;&gt;&lt;span&gt;本方法将被雨滴降质的图像视为是图像背景信息和雨滴效果共同作用产生的结果，并为降质图像进行构建了物理模型，表达式如下所示：&lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180622235110680-110371180.png&quot; alt=&quot;&quot; width=&quot;145&quot; height=&quot;24&quot;/&gt;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里的&lt;strong&gt;I&lt;/strong&gt;表示输入图像；&lt;strong&gt;M&lt;/strong&gt;是基于整张图像的每个像素二进制掩模（Binary-Mask,对于像素x，如果被雨滴覆盖,则&lt;strong&gt;M&lt;/strong&gt;(x) = 1，否为&lt;strong&gt;M&lt;/strong&gt;(x) = 0）;&lt;strong&gt;B&lt;/strong&gt;是图像的背景（即想要得到的目标图像）；&lt;strong&gt;R&lt;/strong&gt;是雨滴带来的影响综合效应（图像背景信息、环境反射光和附着在挡风玻璃或者镜头的雨滴的折射光的一种复杂混合，因为雨水是透明的，由于雨滴形状和折射率的问题，图像雨水区域内的一个像素会受到周边像素的影响，是一个综合的效应表现）；操作符表示逐像素乘法。&lt;/p&gt;
&lt;p class=&quot;MsoBodyText&quot;&gt;&lt;span&gt;基于这个模型，目标是从输入降质图像&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;I&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;获取目标图像&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;B&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。使用&lt;/span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;M&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;作引导生成注意力映射图&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(Attention map),&lt;/span&gt;&lt;span&gt;并应用到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;GAN&lt;/span&gt;&lt;span&gt;来实现目标图像的生成。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.2 Attentive GAN&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;网络结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoBodyText&quot;&gt;&lt;span&gt;图&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;显示了本方法的整个网络的架构，可知网络主要包括两个部分：生成网络和判别网络。给定一张被雨水降质的图像，生成网络尝试生成尽可能真实的无雨图像，判别网络则用来验证生成的图像是否足够真实。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoBodyText&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180622235517973-640743539.jpg&quot; alt=&quot;&quot; width=&quot;839&quot; height=&quot;245&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3 Attentive GAN架构图示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        生成网络&lt;/strong&gt;：如图3所示的结构，该生成网络包含两个子网络：注意力循环子网络(Attentive-Recurrent Network)和上下文自编码器子网络(Contextual Autoencoder)。注意力循环子网络的目的是找到输入图像需要被注意的区域，主要是需要上下文自编码器子网络需要聚焦的雨水及其周围的区域。这样可以生成更好的局部恢复图像，以便判别网络更好的聚焦和评估。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       注意力循环子网络&lt;/strong&gt;：视觉注意力模型应可以帮助定位一张图像的目标区域，并获取该区域的特征。该模型对于生成无雨图像也同样重要，因为它可以让网络聚焦于图像修复区域。图3中显示，该方法使用循环网络生成量化后的图像的视觉注意力，对于每个时间步，其输入是原始输入图像和上一时间步的注意力映射图，它包含五个ResNet残差块层用于提取特征，和一个卷积LSTM单元以及一个卷积层用于生成一张2D的注意力图。&lt;/p&gt;
&lt;p&gt;       从每个时间步学习得到的注意力映射图，是一个二维的矩阵，每个元素的取值范围为0 ~ 1，且元素的值越大，表示该元素对应图像区域获到了更大的关注值。因此从整体来看，随着时间步的推移，每个步骤获取的注意力图的元素值是逐渐增加的。注意：第一个时间步的输入是原始图像和一个初始化的注意力映射图。&lt;/p&gt;
&lt;p&gt;       增加注意力机制是有意义的，注意力增加可以扩大关注的区域，使得雨水区域的周围信息也得到关注；不同的雨滴具有不同的透明度，背景信息不能完全被遮挡，扩大注意力可以透过雨滴捕捉到一些背景信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      上下文自编码器子网络&lt;/strong&gt;：该子网络的将原始输入图像和注意力循环子网络最后一个时间步生成的注意力映射图作为输入，以获取一张无雨图像为目标的。该深度自编码器包含16个conv-relu块和跳跃连接(Skip Connection)来防止目标图像模糊。具体结构如图4所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180622235647830-334710821.jpg&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;203&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4 上下文自编码器的结构。多尺度损失和感知损失被用于训练该子网络&lt;/p&gt;
&lt;p&gt;        由图4可以看出，该子网络使用了多尺度损失(Multi-scale loss)和感知损失(Perceptual loss)。基于像素操作的多尺度损失，从不同的解码层(Decoder layers)提取特征来形成不同尺寸的输出，这可以获取更多的上下文信息。感知损失，用来衡量由自编码网络输出图像的特征和原视输入图像特征的整体差异，而这里提到的特征提取，是基于训练好的CNN(基于ImageNet预训练好的VGG16)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       判别网络&lt;/strong&gt;：为了区分生成图像的真实性，一些一些基于GAN的方法，在判别网络部分常采用图像内容全局和局部一致性为标准。全局判别器用来检测整体图片的不一致性，局部判别器检测一块很小的特定区域。&lt;/p&gt;
&lt;p&gt;       该判别网络的特点是使用一个注意力判别器(Attentive discriminator)，即注意力循环网络生成的注意力映射图应用到判别网络。使用注意力映射图来引导判别器聚焦相应的区域，更好的来判断图像的真实性。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.3&lt;/strong&gt; &lt;strong&gt;实验结果&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定性评估&lt;/strong&gt;：图5给出了本方法与其他论文提出的一些方法（主要是Eigen和Pix2Pix）的结果对比；图6给出了整个网络（AA+AD）与该网络体系其他可能的配置的结构（A，A+D，A+AD）的结果对比。A（无注意力映射图的自编码器），A + D（无注意力映射图自编码器加无注意力映射图判别器），A + AD（无注意力映射图自编码器加上有注意力映射图鉴别器），AA + AD（有注意力映射图自编码器和有注意力映射图判别器）表示本方法的网络整体架构。&lt;/p&gt;
&lt;p&gt;无论雨滴颜色、形状和透明度具有多样性，本文方法都几乎都可以完全去除。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180622235857055-1758372299.jpg&quot; alt=&quot;&quot; width=&quot;415&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5 不同方法的结果比较。从左到右：原始输入图像，Eigen，Pix2Pix，本文方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180622235943148-2061887779.jpg&quot; alt=&quot;&quot; width=&quot;664&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图6 网络体系及其可能的配置结构之间的结果对比&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     定量评估&lt;/strong&gt;：表2给出了本文方法和已有方法在峰值信噪比(PSNR)和结构相似性(SSIM)两个度量上比较的结果，对应度量的数值越大表明效果越好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/636854/201806/636854-20180623000031637-1881770249.jpg&quot; alt=&quot;&quot; width=&quot;286&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;表2 定量评估结果&lt;/p&gt;

&lt;p&gt;        方法一团队提出了一种区域相关的雨水图像模型，用于进一步检测雨水，并进一步更好的模拟雨水积聚和暴雨的情况，并基于此模型提出一种联合雨水检测和去除的网络结构，对于去除雨痕积聚的情况很有效果；方法二团队提出了一种基于单幅图像的雨滴去除方法，该方法利用生成对抗网络，其中生成网络通过特殊的循环机制产生注意力映射图，并将该图与输入图像一起通过上下文自动编码器生成无雨滴图像，对于去除明显可见且密集的雨滴效果明显。&lt;/p&gt;
&lt;p&gt;        为了更好的泛化，获得更普适的去雨机制，可以尝试探索将两种方法结合起来的一种方法，此方法的展望需要进一步的实验探究和验证。经过不断的研究，图像去雨已经取得了较大的成就，但将卷积神经网络技术应用于图像去雨仍然需要继续探索。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 参 考 文 献&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[1] Qian R, Tan R T, Yang W, et al. &quot;Attentive Generative Adversarial Network for Raindrop Removal from a Single Image. &quot; The IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2018       &lt;/p&gt;
&lt;p&gt;[2] Yang, Wenhan, et al. &quot;Deep joint rain detection and removal from a single image.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2017.&lt;/p&gt;
&lt;p&gt;[3] Fu, Xueyang, et al. &quot;Removing rain from single images via a deep detail network.&quot; The IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2017.&lt;/p&gt;
&lt;p&gt;[4] Cai, Bolun, et al. &quot;Dehazenet: An end-to-end system for single image haze removal.&quot;IEEE Transactions on Image Processing25.11 (2016): 5187-5198.&lt;/p&gt;
&lt;p&gt;[5] Yu F, Koltun V. Multi-scale context aggregation by dilated convolutions[J]. arXiv preprint arXiv:1511.07122, 2015.&lt;/p&gt;
&lt;p&gt;[6] 徐波, 朱青松, 熊艳海. &quot;视频图像去雨技术研究前沿.&quot; 中国科技论文 10.8 (2015): 916-927.&lt;/p&gt;
&lt;p&gt;[7] 郭潘, et al. &quot;图像去雾技术研究综述与展望.&quot; 计算机应用 30.9 (2010).&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jun 2018 16:06:00 +0000</pubDate>
<dc:creator>LittleYou123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhang716921/p/9216042.html</dc:identifier>
</item>
<item>
<title>Google Play内购测试 - AmyZYX</title>
<link>http://www.cnblogs.com/amyzhu/p/9216039.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amyzhu/p/9216039.html</guid>
<description>&lt;p&gt;最近项目做海外版本，接入Google wallet支付后，测试验证比较繁琐，故记录一下。&lt;br/&gt;Google wallet支付方式接入完成后，需要按照如下步骤设置，才可以进行支付测试：&lt;/p&gt;
&lt;h2 id=&quot;一配置并发布应用内商品&quot;&gt;一、配置并发布应用内商品&lt;/h2&gt;
&lt;p&gt;进入Google Play Console - 所有应用 ，选择具体应用，进行商品设置：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1301014/201806/1301014-20180622235859635-842123950.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置完应用内商品一定要发布，使之生效；&lt;/li&gt;
&lt;li&gt;一定要保证网络环境所对应的国家在发布范围内；&lt;/li&gt;
&lt;li&gt;游戏服务不支持商品配置，应用才支持商品信息设置；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二上传apk并发布应用&quot;&gt;二、上传APK并发布应用&lt;/h2&gt;
&lt;p&gt;Google Play Developer Console一个应用的发布渠道包括：正式渠道、Beta渠道、Alpha渠道，测试用的APK只要上传到Beta版或者Alpha版频道。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用必须发布后，才可以测试支付功能。&lt;/li&gt;
&lt;li&gt;应用发布后不会立即生效。&lt;/li&gt;
&lt;li&gt;上传的APK包必须要有签名，而且不能用debug签名。&lt;/li&gt;
&lt;li&gt;上传的APK包体积不能超过50M，否则需要做分包。&lt;/li&gt;
&lt;li&gt;apk包发布到Beta或者Alpha渠道即可，不需要发布到正式渠道。&lt;/li&gt;
&lt;li&gt;如果应该状态变为【已发布】说明发布成功。&lt;/li&gt;
&lt;li&gt;Beta、Alpha也会进行严格审核，一些隐私问题或者政策问题会导致应用无法通过审核甚至下架。&lt;/li&gt;
&lt;li&gt;安装到设备上用于测试的apk包可以和上传到Google Play的不同，但要保证这两个APK包使用相同的包名、签名、versionCode。&lt;/li&gt;
&lt;li&gt;测试时使用的网络环境所属的国家和地区一定要在应用发布的国家或者地区范围内。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三设置测试账号&quot;&gt;三、设置测试账号&lt;/h2&gt;
&lt;p&gt;（1）进入应用版本-具体发布渠道（如Alpha版）-管理测试人员，可以修改、添加测试人员账号；&lt;br/&gt;（2）将【加入测试的网址】分享给测试人员访问，二次确认后才可以真正加入测试；&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1301014/201806/1301014-20180622235923930-2066709133.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四android设备上安装应用&quot;&gt;四、Android设备上安装应用&lt;/h2&gt;
&lt;p&gt;方法一：设备上GooglePlay直接搜索应用并安装；&lt;br/&gt;方法二：通过PC的GooglePlay安装到指定手机；&lt;br/&gt;方法三：若不使用GooglePlay应用，则传统apk安装即可，注意：与GooglePlay上的包保持相同的包名、签名、versionCode。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;安装到真机上的测试APP签名、包名和上传到Google Play的APK一致，就可以测试。  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五google-wallet支付&quot;&gt;五、Google Wallet支付&lt;/h2&gt;
&lt;p&gt;安装完成后，支付环节选择开发者后台配置的商品、Google Wallet支付方式即可，注意GooglePlay账号需要绑定支持国际支付的借记卡/信用卡，才可以支付成功。&lt;/p&gt;
&lt;h2 id=&quot;六沙盒测试&quot;&gt;六、沙盒测试&lt;/h2&gt;
&lt;p&gt;沙盒测试：测试期间，经过授权的用户帐户可通过 Google Play 购买您的应用内商品，不过这些用户帐户不用实际支付费用。&lt;/p&gt;
&lt;p&gt;设置沙盒账号：在 Developer Console 中，转到 Settings &amp;gt; Account details，然后在 License Testing 部分将相应地址添加到 Gmail accounts with testing access 字段并保存。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1301014/201806/1301014-20180622235940803-2012662898.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;划重点：&lt;/strong&gt;&lt;br/&gt;1、沙盒测试的账号，也需要按照 一～五 的流程配置完成，才可以进行商品购买。&lt;br/&gt;2、沙盒测试账号只是额外增加了许可测试（license test）的设置，支付时候不需要真正付款。&lt;/p&gt;
&lt;p&gt;PS：Google开发者后台中文翻译迷之难理解，英文过关的建议直接查看英文版。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jun 2018 16:03:00 +0000</pubDate>
<dc:creator>AmyZYX</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/amyzhu/p/9216039.html</dc:identifier>
</item>
<item>
<title>【大数据实战】Logstash采集-&gt;Kafka-&gt;ElasticSearch检索 - Supernova-x</title>
<link>http://www.cnblogs.com/snova/p/9203425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snova/p/9203425.html</guid>
<description>&lt;p&gt; 　&lt;span&gt;Logstash的官网地址为：&lt;a title=&quot;https://www.elastic.co/cn/products/logstash&quot; href=&quot;https://www.elastic.co/cn/products/logstash&quot; target=&quot;_blank&quot;&gt;https://www.elastic.co/cn/products/logstash&lt;/a&gt;，以下是官方对Logstash的描述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180620194100925-1301768085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;Logstash是与Flume类似，也是一种数据采集工具，区别在于组件和特性两大方面&lt;/strong&gt;。常用的数据采集工具有Sqoop、Flume、Logstash，计划将单独写一篇博文论述它们之间的区别，所以这里就不赘述，感兴趣可关注后期的博文。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 　&lt;span&gt;Kafka的官网是：&lt;a title=&quot;http://kafka.apache.org/&quot; href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot;&gt;http://kafka.apache.org/&lt;/a&gt;，官方的介绍如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180621201952741-986157758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;总结来说，&lt;/strong&gt;Kafka是一个分布式消息队列，具有生产者和消费者的功能，它依赖Zookeeper集群来保存meta数据，根据Topic来归类存储的消息，Kafka集群由多个实例组成，每个实例称为broker。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　ElasticSearch是一个分布式的搜索和数据分析引擎&lt;/strong&gt;&lt;span&gt;。它的官网是：&lt;/span&gt;&lt;a title=&quot;https://www.elastic.co/cn/products/elasticsearch&quot; href=&quot;https://www.elastic.co/cn/products/elasticsearch&quot; target=&quot;_blank&quot;&gt;https://www.elastic.co/cn/products/elasticsearch&lt;/a&gt;&lt;span&gt;，官方对ElasticSearch的描述如下，通过官方的描述能够对ElasticSearch有一个整体的了解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180620123325999-2000082661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 3.1 小项目介绍&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　在VM的linux本地logserver目录下存有模拟数据data.log，启动一个logstash监视Linux的logserver目录的data.log日志文件，当日志文件发生了修改，将日志文件采集到Kafka消息队列的名为logs的Topic中，另启动一个logstash将Kafka的消息采集到ElashticSearch，使用ElasticSearch检索数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180621230057959-24485728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 3.2 开发环境&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　系统环境： VM中存在三台Linux机器（bigdata12，bigdata14，bigdata15）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　软件环境：kafka_2.11-0.9.0.1、z&lt;/span&gt;&lt;span&gt;ookeeper-3.4.10、&lt;/span&gt;&lt;span&gt;elasticsearch-2.4.4、&lt;/span&gt;&lt;span&gt;logstash-2.3.1&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 3.3 环境准备&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　1. 首先在三台机器开启zookeeper&lt;/strong&gt;，各机器运行zkServer.sh start，Linux下查看是否有然后使用zkServer.sh status查看zookeeper的状态，如果看到leader和follower角色的出现就代表运行正常。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;2. 三台启动&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Kafka，&lt;/strong&gt;到kafka目录下，运行 nohup bin/kafka-server-start.sh conf/serverproperties.conf。使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;3. 使用&lt;span&gt;非root用户&lt;/span&gt;启动elasticsearch&lt;/strong&gt;，使用非root用户进入elasticsearch目录执行： bin/elasticsearch -d&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;&lt;strong&gt;【&lt;/strong&gt;注意&lt;/span&gt;】&lt;/span&gt;，必须是非root用户，否则会报错。如果没有，就创建一个用户。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    例如创建一个用户为zhou的话，执行：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (1) 添加用户：useradd bigdata，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (2) 为用户添加密码 ：echo 123456 | passwd --stdin zhou，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (3) 将zhou添加到sudoers： echo &quot;bigdata ALL = (root) NOPASSWD:ALL&quot; | tee /etc/sudoers.d/zhou&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (4) 修改权限： chmod 0440 /etc/sudoers.d/zhou&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (5) 从root切换成zhou： su - zhou &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (6) 然后再执行启动elasticsearch命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;&lt;strong&gt;4. 检查进程运行情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 在Linux环境下执行jps命令查看进程是否正常启动，每台机器查看是否有以下进程&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622131442540-1308421967.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　在elasticsearch安装了head的前提下，在windows环境开启浏览器，在地址栏输入http://ip地址:9200/_plugin/head ，例如，根据我的配置，输入了http://192.168.243.11:9200/_plugin/head。出现以下界面，表示Elasticsearch启动正常&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622131625079-1412265303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;在以上环节确认后，就代表环境启动运行正常，可以进行正常开发程序。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 3.4 开发&lt;/h2&gt;
&lt;h3&gt; 3.4.1 编写logstash配置&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　在&lt;strong&gt;bigdata12&lt;/strong&gt;机器中进入logstash的conf目录：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　vi dataTokafka.conf&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;input {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  file {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         codec =&amp;gt;&lt;span&gt; plain {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         charset =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     path =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/root/logserver/supernova.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     discover_interval =&amp;gt; 5
&lt;span&gt; 8&lt;/span&gt;     start_position =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beginning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;output {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    kafka {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;           topic_id =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;           codec =&amp;gt;&lt;span&gt; plain {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;           format =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;           charset =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;           bootstrap_servers =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bigdata12:9092,bigdata14:9092,bigdata15:9092&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　在&lt;strong&gt;bigdata14&lt;/strong&gt;机器中进入logstash的conf目录：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 vi dataToElastic.conf&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;input {
  kafka {
    type &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    auto_offset_reset &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smallest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    codec &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    group_id &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;elas2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    topic_id &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    zk_connect &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bigdata12:2181,bigdata14:2181,bigdata15:2181&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}
filter {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [type] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
    mutate {
      split &lt;/span&gt;=&amp;gt; { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
      add_field &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{message[0]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{message[1]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{message[2]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{message[3]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
     }
     remove_field &lt;/span&gt;=&amp;gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
   }
  }
}
output {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [type] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
    elasticsearch {
      index &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      codec &lt;/span&gt;=&amp;gt;&lt;span&gt; plain {
        charset &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-16BE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
      hosts &lt;/span&gt;=&amp;gt; [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bigdata12:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bigdata14:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bigdata15:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　3.4.2 运行&lt;/h3&gt;
&lt;p&gt;　&lt;span&gt;(1) 在bigdata12机器中，使用3.4.1中的dataTokakfa.conf启动logstash。执行：bin/logstash -f conf/dataTokakfa.conf，监听supernova.log文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　(2) 在bigdata14机器中，使用3.4.1中的dataToElastic.conf启动logstach。执行：bin/logstash -f conf/dataToElastic.conf，将Kafka数据采集到Elasticsearch。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　(3) 为了便于观察，在bigdata15机器中，启动kafka消费者，查看Topic中的数据。执行：bin/kafka-console-consumer.sh --zookeeper bigdata11:2181 --from-beginning --topic logs，用于消费Kafka中Topic名为logs的消息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　(4) 编辑修改Logstash监听的supernova.log文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　启动】：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622133049180-880159036.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 【修改】在bigdata15中修改了数据（右下角窗口）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622133301282-643947044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【监视过程】：bigdata15中（右上），kafka的consumer消费到了supernova.log文件中的数据，在bigdata14中，可以看到将数据传至ElasticSearch的数据（左下）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622133348629-1723201415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【ElasticSeach结果】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　可以看到Elastic集群中，产生了一个supernova的type（类似关系数据库中的table）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622133538587-721097567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 【查看ElasticSearch数据】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622211019392-1670534924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;　3.4.2 ElasticSearch检索&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;    使用Junit单元测试的方法来编写测试方法，代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　EalsticSearch.java&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; novaself;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.action.search.SearchResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.client.Client;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.client.transport.TransportClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.common.settings.Settings;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.common.transport.InetSocketTransportAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.index.query.QueryBuilders;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.search.SearchHit;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.search.SearchHits;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Supernova
 * @date 2018/06/22
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ElasticSearch  {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Client client;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取客户端
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Before
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getClient() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ElasticSearch服务默认端口9300&lt;/span&gt;
        Settings settings =&lt;span&gt; Settings.settingsBuilder()
                .put(&lt;/span&gt;&quot;cluster.name&quot;, &quot;bigdata&quot;&lt;span&gt;).build();
        client &lt;/span&gt;=&lt;span&gt; TransportClient.builder().settings(settings).build()
                .addTransportAddress(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketTransportAddress(
                        InetAddress.getByName(&lt;/span&gt;&quot;bigdata12&quot;), 9300&lt;span&gt;))
                .addTransportAddress(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketTransportAddress(
                        InetAddress.getByName(&lt;/span&gt;&quot;bigdata14&quot;), 9300&lt;span&gt;))
                .addTransportAddress(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketTransportAddress(
                        InetAddress.getByName(&lt;/span&gt;&quot;bigdata15&quot;), 9300&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 词条查询: 用户名中有&quot;新&quot;字的数据
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testTermQuery(){
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * termQuery词条查询: 只匹配指定字段中含有该词条的文档
         * 查询user字段为超新星的记录
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        SearchResponse response &lt;/span&gt;= client.prepareSearch(&quot;supernova&quot;&lt;span&gt;)
                .setTypes(&lt;/span&gt;&quot;supernova&quot;&lt;span&gt;)
                .setQuery(QueryBuilders.termQuery(&lt;/span&gt;&quot;user&quot;,&quot;新&quot;&lt;span&gt;))
                .get();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取结果集对象、命中数&lt;/span&gt;
        SearchHits hits =&lt;span&gt; response.getHits();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用迭代器遍历数据&lt;/span&gt;
        Iterator&amp;lt;SearchHit&amp;gt; iter =&lt;span&gt; hits.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(iter.hasNext()){
            SearchHit hit &lt;/span&gt;=&lt;span&gt; iter.next();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以Json格式输出&lt;/span&gt;
            String result =&lt;span&gt; hit.getSourceAsString();
            System.out.println(result);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭客户端&lt;/span&gt;
&lt;span&gt;        client.close();
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 模糊查询: 星期四的数据
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testWildcardQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * wildcardQuery模糊查询,time字段中包含&quot;四&quot;的数据
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        SearchResponse response &lt;/span&gt;= client.prepareSearch(&quot;supernova&quot;&lt;span&gt;)
                .setTypes(&lt;/span&gt;&quot;supernova&quot;&lt;span&gt;)
                .setQuery(QueryBuilders.wildcardQuery(&lt;/span&gt;&quot;time&quot;,&quot;四&quot;&lt;span&gt;))
                .get();


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取结果集对象、命中数&lt;/span&gt;
        SearchHits hits =&lt;span&gt; response.getHits();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用迭代器遍历数据&lt;/span&gt;
        Iterator&amp;lt;SearchHit&amp;gt; iter =&lt;span&gt; hits.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(iter.hasNext()){
            SearchHit hit &lt;/span&gt;=&lt;span&gt; iter.next();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以Json格式输出&lt;/span&gt;
            String result =&lt;span&gt; hit.getSourceAsString();
            System.out.println(result);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭客户端&lt;/span&gt;
&lt;span&gt;        client.close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【检索结果】：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  词条查询：testTermQuery( )方法的运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622223520972-2129699292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;模糊查询：testWildcardQuery ( )方法的运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622223640656-1909214688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 22 Jun 2018 14:45:00 +0000</pubDate>
<dc:creator>Supernova-x</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snova/p/9203425.html</dc:identifier>
</item>
<item>
<title>Web自动化测试环境搭建1（基于firefox火狐浏览器） - 韬哥（NickJiang）</title>
<link>http://www.cnblogs.com/nickjiang/p/9215587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nickjiang/p/9215587.html</guid>
<description>&lt;p&gt;　　自动化测试是时代趋势，因此很多测试人员开始研究自动化测试，web自动化测试化测试并不难，但是很多人都是被挡在了环境搭建这一步，后面学习激情全无，这里，韬哥手把手教大家搭建火狐浏览器下的自动化测试环境（基于java）。&lt;/p&gt;
&lt;p&gt;　　为什么搭建自动化测试环境难呢，因为环境要求高，selenium版本，驱动文件版本，浏览器版本这中间有适配问题，如果没注意这些版本信息，就可能导致web自动化程序就跑不起来。&lt;/p&gt;
&lt;p&gt;　　下面将为大家演示selenium 3.x下的火狐自动化自动化环境搭建：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1.准备selenium 3.5.1，maven下的依赖信息如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.seleniumhq.selenium&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;selenium-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.5.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;2.准备火狐驱动文件geckodriver.exe&lt;/span&gt;（从selenium 3.0开始火狐浏览器的自动化就需要驱动文件来驱动了），这里准备的驱动文件版本为0.19.0，大家可以自己去selenium官网下载，或者直接使用老师给大家分享的网盘地址去下载【链接：https://pan.baidu.com/s/1oN8tg66cobM7yX-T6GKuFw 密码：9rb7】&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416840/201806/1416840-20180622212109028-174916272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　另外大家记得把火狐浏览器的版本更换为56（并且&lt;span&gt;禁止浏览器更新功能&lt;/span&gt;，防止浏览器后台自动更新版本，至于怎么禁止，很简单的事情，pls自行百度），因为根据geckodriver的change log建议，0.19.0版本的驱动最好是适配：Firefox 55.0 （或更高）+ Selenium 3.5（或更高），这就是为什么上面为什么用selenium3.5.1。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416840/201806/1416840-20180622213517757-525073017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以下为大家整理火狐的各版本下载链接：【http://ftp.mozilla.org/pub/firefox/releases/】，或者大家可以直接去我的网盘下载：【链接：https://pan.baidu.com/s/1xMBkf_ViIV_RyFGN2V-Qaw 密码：eyo6】&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416840/201806/1416840-20180622214137069-743808051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;3.验证代码&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; web.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.firefox.FirefoxDriver;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.testng.annotations.AfterClass;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.testng.annotations.BeforeClass;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.testng.annotations.Test;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;火狐的自动化测试环境搭建
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; NickJiang
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FirefoxAuto {
    WebDriver driver;
    @BeforeClass
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
        System.setProperty(&lt;/span&gt;&quot;webdriver.gecko.driver&quot;, &quot;src/test/resources/geckodriver.exe&quot;&lt;span&gt;);
        driver &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FirefoxDriver();
    }
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test(){
        driver.get(&lt;/span&gt;&quot;http://www.baidu.com&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;打开网站等待3秒后再关闭&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    }
    
    @AfterClass
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; teardown(){
        driver.quit();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;驱动文件存放目录：src/test/resources/geckodriver.exe，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416840/201806/1416840-20180622213104498-1686966173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;4.效果如下，意味着环境搞定：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416840/201806/1416840-20180622213147997-1849763189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 至此，基于java+selenium 3.x的火狐自动化测试环境就准备好了。java+selenium 2.x 后面会择时为大家补充。下一篇将为大家带来chrome下自动化环境搭建。&lt;/p&gt;

</description>
<pubDate>Fri, 22 Jun 2018 13:46:00 +0000</pubDate>
<dc:creator>韬哥（NickJiang）</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nickjiang/p/9215587.html</dc:identifier>
</item>
<item>
<title>机器学习基本概念 - 大雄的学习人生</title>
<link>http://www.cnblogs.com/codernie/p/9215365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codernie/p/9215365.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;Machine Learning：&lt;/strong&gt;A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一什么是机器学习what&quot;&gt;一、什么是机器学习？（What）&lt;/h3&gt;
&lt;p&gt;上面的概念那面有些抽象，要理解什么是机器学习，其实可以类比于人类的学习。假设一个场景：父母教三岁大的孩子认识什么是西瓜。首先父母要给孩子看西瓜，然后告诉孩子这个是西瓜。这个过程抽象成下面这张流程图：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12275140-0193df47d07fda6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;what is machine learning.png&quot;/&gt;&lt;br/&gt;孩子的学习过程是通过一些观察，然后加上自我总结，就逐渐拥有了识别什么是西瓜的技能。&lt;br/&gt;与之相类似，机器学习就是通过对数据的“学习”，从而拥有某些特定技能的过程。（那技能是什么呢？技能是某种表现的增进，例如我通过天天练习投篮，逐渐命中率达到一定水准，我就拥有了投篮技能。）&lt;/p&gt;
&lt;h3 id=&quot;二为什么要使用机器学习why&quot;&gt;二、为什么要使用机器学习？（Why）&lt;/h3&gt;
&lt;p&gt;对于不同的问题，我们选择机器学习的原因不同，这些问题按照对于人类的难易来说，可以分为两类：&lt;br/&gt;&lt;strong&gt;1.很简单的问题：&lt;/strong&gt;&lt;br/&gt;例如：识别手写的数字是几，这对于人类来说是一个极易的问题，那为什么我们还要使用机器学习呢？因为通过机器学习的方式，&lt;strong&gt;我们可以让机器来帮我们做这些“单调乏味”的工作&lt;/strong&gt;，让机器掌握识别手写数字的技能之后，我们就能让他们帮我们来分拣信件。如果把这项技能再进一步，让机器掌握识别并理解地址信息，我们甚至可以用机器来分拣快递。&lt;br/&gt;&lt;strong&gt;2.很复杂的问题：&lt;/strong&gt;&lt;br/&gt;例如：根据用户信息，给不同的用户推荐不同的广告。对于人类来说，这几乎是不可能的问题，因为不同的用户有不同的特征，怎么从这些海量的特征中判断每一个用户的喜好是什么呢？并且用户的喜好可能还在发生变化，举个通俗一点的例子，比如某些用户去年还喜欢吃西瓜，今年就讨厌西瓜了。因此，&lt;strong&gt;从海量的数据中去人为的总结规律有很大的局限性，而使用机器学习的方式使得这类问题变得简单。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;三什么时候可以使用机器学习when&quot;&gt;三、什么时候可以使用机器学习？（When）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.存在某些隐含的模式（underlying pattern）可以被学习到。&lt;/strong&gt;&lt;br/&gt;举一个反例：预测某个婴儿下一次哭是奇数分钟哭，还是偶数分钟哭。这几乎是一个随机事件，所以不存在任何隐含的模式，因此也就不能使用机器学习的方式来解答。&lt;br/&gt;&lt;strong&gt;2.不是很容易总结规律的问题。&lt;/strong&gt;&lt;br/&gt;如果规律很容易总结，那当然就不用使用机器学习了，直接代码实现即可。&lt;br/&gt;&lt;strong&gt;3.有相关的数据。&lt;/strong&gt;&lt;br/&gt;举一个反例：预测世界末日什么时候到来。显然，因为我们没有世界末日发生的相关数据，所以这个问题也无法用机器学习的方式来解答。&lt;/p&gt;
&lt;h3 id=&quot;四机器学习的组成&quot;&gt;四、机器学习的组成&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12275140-94b1082fb08d8e73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;machine learning combination.png&quot;/&gt;&lt;br/&gt;上图可以看作是整个机器学习过程的组成。&lt;br/&gt;首先从我们的数据出发，它们的具体形式是x到y的映射，比如我们的问题是预测某套房子的房价。那么我的X包括房子面积、房子楼层、是否是电梯房等等特征，Y就是房子的价格。正因为存在某种规律，才使得我们获得的数据按照训练集的每一个x对应唯一一个y。我们用 f 来表示这个X到Y的映射关系(即隐含规律)。&lt;br/&gt;那么如何去求得这个 f 呢？一般地，我们首先会把范围扩大到一个假设集合（称作 H ），比如我们假设房子价格与它的所有特征都是呈线性关系，那么这个假设集合就是一个线性假设集，那如何在这个无限大的假设集 H 中找到我们想要得到的 f 呢，那就需要通过机器学习演算法来实现，我们用 A 表示这个算法。&lt;br/&gt;那这样我们就能求得 f 了吗？答案是否定的，因为很多时候由于数据噪声等原因，我们无法获得一个精确的 f ,而只能获得某一个映射关系 g ，使得 g 最接近这个 f，我们把这个 g 称为最终预测。&lt;br/&gt;&lt;strong&gt;一般地，机器学习为了求得隐含的规律，在假设集合上通过演算法对训练集进行“训练”，使求得的预测规律最接近隐含规律。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;五机器学习数据挖掘人工智能统计学的关系&quot;&gt;五、机器学习、数据挖掘、人工智能、统计学的关系&lt;/h3&gt;
&lt;h5 id=&quot;机器学习&quot;&gt;机器学习：&lt;/h5&gt;
&lt;p&gt;利用数据计算出一个近似隐含规律的预测规律。&lt;/p&gt;
&lt;h5 id=&quot;数据挖掘&quot;&gt;数据挖掘：&lt;/h5&gt;
&lt;p&gt;利用海量的数据去寻找一些有意思的数据特征、规律。&lt;br/&gt;&lt;strong&gt;机器学习与数据挖掘的关系：&lt;/strong&gt;&lt;br/&gt;如果数据挖掘的目标是去寻找数据间的隐含规律，那么数据挖掘和机器学习做的事情是一样的。但是传统的数据挖掘总是着眼于大数据的高效计算。（比如分布式计算框架）&lt;/p&gt;
&lt;h5 id=&quot;人工智能&quot;&gt;人工智能：&lt;/h5&gt;
&lt;p&gt;让计算机做(模拟)一些像人一样的智能行为。&lt;br/&gt;&lt;strong&gt;机器学习与人工智能的关系：&lt;/strong&gt;&lt;br/&gt;机器学习是实现人工智能的一种途径，除此之外，还有一些其他的方式可以实现人工智能。&lt;/p&gt;
&lt;h5 id=&quot;统计学&quot;&gt;统计学：&lt;/h5&gt;
&lt;p&gt;利用数据对一些未知的过程做预测。&lt;br/&gt;&lt;strong&gt;机器学习与统计学的关系：&lt;/strong&gt;&lt;br/&gt;统计学的很多知识都可以被借鉴到机器学习中，但是机器学习中也有很多算法不是基于统计学的规律的。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;br/&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=nQvpFSMPhr0&amp;amp;list=PLXVfgk9fNX2I7tB6oIINGBmW50rrmFTqf&amp;amp;index=1&quot;&gt;《机器学习基石》【林轩田】(来源于Youtube)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jun 2018 12:37:00 +0000</pubDate>
<dc:creator>大雄的学习人生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codernie/p/9215365.html</dc:identifier>
</item>
<item>
<title>我是如何用redis做实时订阅推送的 - 我是林林</title>
<link>http://www.cnblogs.com/linlinismine/p/9214299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linlinismine/p/9214299.html</guid>
<description>&lt;p&gt;      &lt;strong&gt;前阵子开发了公司领劵中心的项目，这个项目是以redis作为关键技术落地的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      先说一下领劵中心的项目吧，这个项目就类似京东app的领劵中心，当然图是截取京东的，公司的就不截了。。。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622150051254-473108734.png&quot; alt=&quot;&quot; width=&quot;266&quot; height=&quot;472&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;  其中有一个功能叫做领劵的订阅推送。什么是领劵的订阅推送？就是用户订阅了该劵的推送，在可领取前的一分钟就要把提醒信息推送到用户的app中。本来这个订阅功能应该是消息中心那边做的，但他们说这个短时间内做不了。所以让我这个负责优惠劵的做了-.-!。具体方案就是到具体的推送时间点了，coupon系统调用消息中心的推送接口，把信息推送出去。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;     下们我们分析一下这个功能的业务情景。公司目前注册用户6000W+，是哪家就不要打听了。。。比如有一张无门槛的优惠劵下单立减20元，那么抢这张劵的人就会比较多，我们保守估计10W+，百万级别不好说。我们初定为20W万人，那么这20W条推送信息要在一分钟推送完成！并且一个用户是可以订阅多张劵的。所以我们知道了这个订阅功能的有两个突出的难点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt; 1、推送的实效性：推送慢了，用户会抱怨没有及时通知他们错过了开抢时机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;     2、推送的体量大：爆款的神劵，人人都想抢！&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      然而推送体量又会影响到推送的实效性。这真是一个让人头疼的问题！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;     那就让我们把问题一个个解决掉吧！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     推送的实效性的问题：当用户在领劵中心订阅了某个劵的领取提醒后，在后台就会生成一条用户的订阅提醒记录，里面记录了在哪个时间点给用户发送推送信息。所以问题就变成了系统如何快速实时选出哪些要推送的记录！&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;    方案1：MQ的延迟投递。MQ虽然支持消息的延迟投递但尺度太大1s 5s 10s 30s 1m，用来做精确时间点投递不行！并且用户执行订阅之后又取消订阅的话，要把发出去的MQ消息delete掉这个操作有点头大，短时间内难以落地！并且用户可以取消之后再订阅，这又涉及到去重的问题。所以MQ的方案否掉。&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;   方案2：传统定时任务。这个相对来说就简单一点，用定时任务是去db里面load用户的订阅提醒记录，从中选出当前可以推送的记录。但有句话说得好任何脱离实际业务的设计都是耍流氓~。下面我们就分析一下传统的定时任务到底适不适合我们的这个业务!&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;能否支持多机同时跑&lt;/td&gt;
&lt;td&gt;一般不能，同一时刻只能单机跑。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;存储数据源&lt;/td&gt;
&lt;td&gt;一般是mysql或者其它传统数据库，并且是单表存储&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;频率&lt;/td&gt;
&lt;td&gt;支持秒、分、时、天，一般不能太快&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;        &lt;strong&gt;总上所述我们就知道了一般传统的定时任务存在以下缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       1、性能瓶颈。只有一台机在处理，在大体量数据面前力不从心！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       2、实效性差。定时任务的频率不能太高，太高会业务数据库造成很大的压力！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       3、单点故障。万一跑的那台机挂了，那整个业务不可用了-。- 这是一个很可怕的事情！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        所以传统定时任务也不太适合这个业务。。。 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;   那我们是不是就束手无策了呢？其实不是的! 我们只要对传统的定时任务做一个简单的改造！就可以把它变成可以同时多机跑,并且实效性可以精确到秒级，并且拒绝单点故障的定时任务集群！这其中就要借助我们的强大的redis了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案3：定时任务集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     首先我们要定义定时任务集群要解决的三个问题！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     1、&lt;/strong&gt;&lt;strong&gt;实效性要高&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     2、吞吐量要大&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     3、服务要稳定，不能有单点故障 &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     下面是整个定时任务集群的架构图。&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622165043391-1952143442.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;400&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt; 架构很简单：我们把用户的订阅推送记录存储到redis集群的sortedSet队列里面,并且以提醒用户提醒时间戳作为score值，然后在我们个每业务server里面起一个定时器频率是秒级，我的设定就是1s，然后经过负载均衡之后从某个队列里面获取要推送的用户记录进行推送。下面我们分析以下这个架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    1、性能：除去带宽等其它因素，基本与机器数成线性相关。机器数量越多吞吐量越大，机器数量少时相对的吞吐量就减少。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    2、实效性：提高到了秒级，效果还可以接受。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    3、单点故障？不存在的！除非redis集群或者所有server全挂了。。。。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    这里解析一下为什么用redis？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    第一redis 可以作为一个高性能的存储db，性能要比MySQL好很多，并且支持持久化，稳定性好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    第二redis &lt;/strong&gt;&lt;strong&gt;SortedSet队列天然支持以时间作为条件排序，完美满足我们选出要推送的记录。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    ok~既然方案已经有了那如何在一天时间内把这个方案落地呢？是的我设计出这个方案到基本编码完成，时间就是一天。。。 因为时间太赶鸟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     首先我们以user_id作为key，然后mod队列数hash到redis SortedSet队列里面。为什么要这样呢，因为如果用户同时订阅了两张劵并且推送时间很近，这样的两条推送就可以合并成一条~，并且这样hash也相对均匀&lt;/strong&gt;。下面是部分代码的截图：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622193616161-1305837647.png&quot; alt=&quot;&quot; width=&quot;563&quot; height=&quot;36&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;  然后要决定队列的数量，一般正常来说我们有多少台处理的服务器就定义多少条队列。因为队列太少，会造成队列竞争，太多可能会导致记录得不到及时处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    然而最佳实践是队列数量应该是可动态配置化的，因为线上的集群机器数是会经常变的。大促的时候我们会加机器是不是，并且业务量增长了，机器数也是会增加是不是~。所以我是借用了淘宝的diamond进行队列数的动态配置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622195406550-1920335557.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;71&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    我们每次从队列里面取多少条记录也是可以动态配置的 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622195640651-1006475124.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;   这样就可以随时根据实际的生产情况调整整个集群的吞吐量~。  所以我们的定时任务集群还是具有一个特性就是支持动态调整~。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;   最后一个关键组件就是负载均衡了。这个是非常重要的！因为这个做得不好就会可能导致多台机竞争同时处理一个队列，影响整个集群的效率！在时间很紧的情况下我就用了一个简单实用的利用redis一个自增key 然后 mod 队列数量算法。这样就很大程度上就保证不会有两台机器同时去竞争一条队列~.&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622200223808-1322979237.png&quot; alt=&quot;&quot; width=&quot;853&quot; height=&quot;50&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;最后我们算一下整个集群的吞吐量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     10（机器数） * 2000（一次拉取数） = 20000。然后以MQ的形式把消息推送到消息中心，发MQ是异步的，算上其它处理0.5s。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     其实发送20W的推送也就是10几s的事情。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;ok~ 到这里我们整个定时任务集群就差不多基本落地好了。如果你问我后面还有什么可以完善的话那就是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    1、加监控， 集群怎么可以木有监控呢，万一出问题有任务堆积怎么办~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    2、加上可视化界面。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    3、最好有智能调度，增加任务优先级。优先级高的任务先运行嘛。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    4、资源调度，万一机器数量不够，力不从心，优先保证重要任务执行。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;     目前项目已上前线，运行平稳~。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Fri, 22 Jun 2018 12:35:00 +0000</pubDate>
<dc:creator>我是林林</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linlinismine/p/9214299.html</dc:identifier>
</item>
</channel>
</rss>