<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【朝花夕拾】Android性能优化篇之（五）Android虚拟机简介 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/9747525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/9747525.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       Android虚拟机的使用，使得android应用和Linux内核分离，这样做使得android系统更稳定可靠，比如程序中即使包含恶意代码，也不会直接影响系统文件；也提高了跨平台兼容性。在Android4.4以前的系统中，Android系统均采用Dalvik作为运行andorid程序的虚拟机，在android发展中具有举足轻重的地位，而Android 5.0及以后的系统使用ART虚拟机取代Dalvik，在性能上做了很大的优化。本文将对这两款虚拟机做一些介绍，主要内容如下：&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201810/472002-20181006154428093-1119127698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、什么是Dalvik？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       Dalvik是Google公司自己设计用于Android平台的虚拟机，是Android移动设备平台的核心组成部分之一。虚拟机的概念在前面文章中讲到过是，就是一个设备上开辟的一个虚拟空间，一个虚拟出来的设备。Dalvik就是这样，在android设备上虚拟出来的一个用于运行Android程序的空间。由于Android程序的开发语言是java，所以Dalvik的本质仍然是JVM，是一个特殊设计的JVM，没有遵循Java虚拟机规范。另外，值得一提的是，Dalvik的命名来源于其祖先生活在冰岛的一个叫做Dalvik的小渔村。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、Dalvik在Android架构中所处的位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180928083233620-244161295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       想必读者们对如上截图已经相当熟悉了——android系统架构图。从上图可以看到，Dalvik虚拟机在Android Runtime中，在Linux Kernel之上。我们都知道，Android其实就是一个操作系统，其底层基于Linxu Kernel，这一层有许多的驱动程序，主要完成操作系统所具备的功能。Android Runtime，即android的运行环境，我们可以类比于java的jre，即java平台运行期环境。Java程序的开发、编译和运行需要java的核心包（jdk/lib/和jre/lib）支持，然后通过JVM来运行java程序，同样android程序的运行也是如此，Libraries就相当于java的jdk/lib，是开发/编译android程序所需要的库，Android Runtime里面的Core Libraries里就相当于java的jre/lib，是运行android程序所需要的核心库，自然而然，Dalvik虚拟机也就类比于java中的JVM，用于运行android程序。（这一节可以先阅读我前面的文章：&lt;a href=&quot;https://www.cnblogs.com/andy-songwei/p/9291186.html&quot; target=&quot;_blank&quot;&gt;【朝花夕拾】Anroid性能优化篇之（一）Java内存分配&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、Dalvik的作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       简单来说就是：Dalvik虚拟机在Android操作系统上虚拟出一个设备，用来运行android 应用程序。Dalvik是apk运行的温床，其作为面向Linux、为嵌入式操作系统特别设计的虚拟机， 主要负责完成对象的生命周期管理、堆栈管理、线程管理、安全及异常管理、垃圾回收等。Dalvik充分利用Linux进程管理的特性，对其进项了面向对象的设计，使得可以同时运行多个程序，而传统的Java程序通常只能运行一个进程，这也是为什么Android不采用JVM的原因之一。在Android中，每一个app进程对应一个Dalvik，多个app进程在运行，就对应多个虚拟机的存在，这样设计的好处就是，当一个应用crash后，只会影响自己所在的dalvik，而不会影响到整个系统，不同的进程之间（即不同的Dalvik之间）通过进程间通信来实现交互。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、Dalvik和JVM的区别与联系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        Android程序也是用Java语言开发的，所以Dalvik本质上讲也是java虚拟机，那么Dalvik和JVM又有哪些区别和联系呢？主要有如下几点：  &lt;/p&gt;
&lt;p&gt;      （1）本质上Dalvik也是JVM，是特殊设计的JVM，没有遵循java虚拟机设计规范。&lt;/p&gt;
&lt;p&gt;      （2）JVM是基于栈的虚拟机，而Dalvik是基于寄存器的虚拟机，对于基于栈和基于寄存器的虚拟机的区别和优缺点，推荐阅读：&lt;a href=&quot;https://blog.csdn.net/u012481172/article/details/50904574&quot; target=&quot;_blank&quot;&gt;基于栈虚拟机和基于寄存器虚拟机的比较&lt;/a&gt;，讲的简洁且易懂，咱们这里不深入展开。&lt;/p&gt;
&lt;p&gt;      （3）JVM运行的是Java字节码文件，即.class文件，而Dalvik运行的是.dex（即Dalvik Executable）文件。.dex是在.class文件的基础上，经过DEX工具压缩和优化后形成的。如下图所示： &lt;/p&gt;
&lt;p&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180928190026182-1389853822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        当javac将java程序编译成class后，dex工具将所有的class文件整合到一个.dex文件中，这样做使得各个类能够共享数据，在一定程度上降低了冗余，同时也使文结构更加紧凑。.dex格式也是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。实验表明，dex文件时传统jar文件的50%左右。下图为java .jar包中.class文件和android .apk中.dex文件对比图：&lt;/p&gt;
&lt;p&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927110637327-361980182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      （4）补充两个Davik的特征：&lt;/p&gt;
&lt;p&gt;        1）Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，每一个应用对应一个虚拟机实例，对应了一个进程，对应一个独立的Linux进程。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。&lt;/p&gt;
&lt;p&gt;        2）Dalvik第一次加载后，会生成Cache文件，以提供下次快速加载，所以第一次会很慢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、Davik的孵化器——Zygote进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在Android系统中有个一特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，完成虚拟机的初始化、库的加载、预制类库和初始化操作。如果系统需要一个新的虚拟机实例，他会迅速复制自身，以最快的速度提供给系统。对于一些只读的系统库，所有的虚拟机实例都和Zygote共享一块区域。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、Dalvik的致命缺点：拖慢Android系统速度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       Dalvik有个致命的弱点，就是Dalvik虚拟机一直被用户指责为拖慢Android系统运行速度而不如IOS的根源。主要原因如下：&lt;/p&gt;
&lt;p&gt;  1、开发者因素&lt;/p&gt;
&lt;p&gt;       Android起步比IOS晚，平台不成熟，初期开发者水平有限，对性能方面关注比较少，主要关注点在提供各种丰富多彩的应用上。&lt;/p&gt;
&lt;p&gt;  2、运营商因素&lt;/p&gt;
&lt;p&gt;       Android是开源的，不同的手机厂商往往对android系统进行定制，而各厂商的技术参差不齐，修改后的特性或新增的功能，对原生系统的性能也造成一定的影响。同时，Android比较开放，有些开发者不顾用户体验，为一些目的在后台做了一些小动作，比如收集用户信息等，拖慢整体速度。&lt;/p&gt;
&lt;p&gt;  3、Dalvik运行时机制因素&lt;/p&gt;
&lt;p&gt;       在编译Android程序的时候，首先java代码被编译成class文件，然后被java打包工具dx打包成.dex文件，然后.dex文件和资源文件一起被压缩成apk文件。Apk文件其实也是zip格式，只是后缀被修改为apk，读者可以自己解压一个apk试试看。Android应用的安装过程：复制apk安装包到data/app目录（见截图6.3.2，截图6.3.3）下，解压并扫描安装包，把dex文件保存到dalvik-cache目录（见截图6.3.4）下，并在data/data（见截图6.3.5）目录下创建对应的应用数据目录。这样每次用户点击图标运行android程序时，dalvik虚拟机就会用JIT（Android2.2及以后版本）的方法把dex文件翻译为机器码，然后再执行机器码。虽然Dalvik虚拟机已经被做过很多优化（.dex文件基础上被优化为.odex文件，o表示optimization，“优化”的意思），但因为此种机制的存在，先翻译再执行，所以Android在电量消耗和程序运行流畅程度上一直不太理想。    &lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201810/472002-20181006101732338-1723285372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                           　　　　　　　　　　　　截图6.3.1  Android中 /data目录&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201810/472002-20181006102804911-439488285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                            截图6.3.2 /data/app目录&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201810/472002-20181006102956145-1580971657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                         截图6.3.3   /data/app目录下应用的信息&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201810/472002-20181006101318658-1772581397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                        截图6.3.4   /data/dalvik-cache目录下的内容&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201810/472002-20181006101634110-1720380480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                       截图6.3.5   /data/data目录下应用数据目录，存储对应应用运行中产生的一些数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;七、ART虚拟机取代Dalvik虚拟机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在第六点中，我们讲到了，由于Dalvik虚拟机机制的问题，拖慢了android应用的速度。由此，ART（即Android RunTime）虚拟机应运而生，在Android4.4中可以在设置中切换选择Dalvik或ART作为虚拟机，在Android L(5.0)中就直接删除了Dalvik，而全面使用ART。ART在机制上做了优化，可以在第一次安装应用时，字节码就会预编译（即AOT编译：ahead of time）成机器码，使其成为真正的本地应用。在点击桌面的应用图标运行时，无需再翻译字节码，而是直接运行机器码，从而提升了启动速度。另外，ART在英语单词中是“艺术”的意思，可见，ART虚拟机的设计是匠心独运，同时也是被其设计中所高度赞誉的。&lt;/p&gt;
&lt;p&gt;       下图展示了Dalvik和ART对.dex文件的处理的对比情况：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201810/472002-20181006105931539-1493651434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;八、ART的优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  1、优点&lt;/p&gt;
&lt;p&gt;       ART的AOT方式相比于Dalvik的JIT方式，主要由如下的有优势：&lt;/p&gt;
&lt;p&gt;    （1）ART抛弃了Dalvik的JIT方式，而采用AOT预编译方式，在安装apk的过程中，将.odex文件（.dex优化后的文件）预编译为二进制机器码，存储在设备中，以后每次启动应用的时候，直接运行机器码，而无需再翻译.odex，这样极大地提高了应用的启动速度。&lt;/p&gt;
&lt;p&gt;    （2）每次运行时所做的工作也少了，这样占用了更少的CPU资源，也消耗了更少的电池资源。&lt;/p&gt;
&lt;p&gt;    （3）ART也在开发者工具和垃圾回收器上做了改善。&lt;/p&gt;
&lt;p&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201810/472002-20181006123756312-1846527465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                     　　　　　　　　Dalvik和ART在性能上的对比&lt;/p&gt;
&lt;p&gt;  2、缺点&lt;/p&gt;
&lt;p&gt;       硬币有正反面，ART的预编译，也带来了一定的劣势&lt;/p&gt;
&lt;p&gt;    （1）增加了安装时间。在安装的时候需要预编译，无疑增大了安装的工作量，从而增大了安装时间，对于一些大的应用，可能需要几分钟的时间才能安装完。&lt;/p&gt;
&lt;p&gt;    （2）需要更多的空间存储预编译后的机器码，无疑占用了更多的存储空间。当然，现在硬件设备更新换代很快，性能也非常好，相比于ART带来的优点，该缺点几乎没什么影响。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;九、Android N对ART的优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在上一节中我们提到是，ART的机制使得apk在安装的时候比较耗时，为了改变这种状态，在Android N（Android7.0）中对此做了优化。Android N实现了一个使用AOT、解释、JIT混合模式的运行环境，这里使用的JIT是改进后的JIT，ART也提供了一种新的、更快的解释器。这种方式在apk安装的过程中不再进行预编译，第一次运行该应用相关程序后，在手机处于idle状态和充电的时候再将运行过的程序编译为机器码并存储在设备中。JIT提供了一套追踪机制来决定哪一部分代码需要在手机idle和充电的时候来编译（即热区域hot method的确定），这个追踪技术被称为Profile Guided Compilation，其工作原理如下：&lt;/p&gt;
&lt;p&gt;      （1）应用程序第一次启动的时候，只会通过解释器执行，同时JIT会介入并针对hot methods执行优化工作。代码在执行期间会被分析，分析结果被保存起来，同步输出一种被称为profile information的信息保存到文件中。该文件中记录了需要离线优化的hot methods，影响程序启动速度的Classes，它们主要用于进一步优化程序的启动速度。&lt;/p&gt;
&lt;p&gt;      （2）当设备处于idle状态并且在充电，就会进入Profile Guided Compilation服务，使用第一步中的profile information，生成二进制机器码，用于替代原始应用程序的相应部分。&lt;/p&gt;
&lt;p&gt;      （3）应用程序在后续启动时，就可以根据实际情况在AOT/JIT/Interpreter中选择最合适的执行方式了。&lt;/p&gt;
&lt;p&gt;        通过以上的步骤可以得知，因为有了Profile Guided Compilation，同一app会因为不同的用户行为产生不同的编译结果。&lt;/p&gt;
&lt;p&gt;       我们可以概括性地做一个总结：第一次运行到某些模块的程序的时候（此次JIT信息不会持久化），产生一个文件来记录这些被执行的程序信息，从而实现了将以往在安装过程中预编译生成机器码的过程，延迟到手机处于idle和充电的时候来完成，最终实现既能避免漫长的安装等待，又不影响程序启动速度，还节约了空间（因为有些功能程序一直不被使用，就不需要编译为机器码占用空间），cpu资源，电池资源等的目的。 &lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;        https://www.jianshu.com/p/28cdc90b456f&lt;/p&gt;
&lt;p&gt;        https://www.jianshu.com/p/28cdc90b456f&lt;/p&gt;
&lt;p&gt;        https://blog.csdn.net/aroundme/article/details/55002563&lt;/p&gt;
&lt;p&gt;        https://www.2cto.com/kf/201802/723530.html&lt;/p&gt;
</description>
<pubDate>Sat, 06 Oct 2018 07:49:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>Android虚拟机的使用，使得android应用和Linux内核分离，这样做使得android系统更稳定可靠，比如程序中即使包含恶意代码，也不会直接影响系统文件；也提高了跨平台兼容性。在Androi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/9747525.html</dc:identifier>
</item>
<item>
<title>数据结构与算法学习笔记之 复杂度分析 - Dawnzhang</title>
<link>http://www.cnblogs.com/clwydjgs/p/9718754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clwydjgs/p/9718754.html</guid>
<description>
&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　 &lt;span&gt;大家都知道数据结构和英语，就如同程序员的两条腿一样；只有不断的积累，学习，拥有了健壮的“双腿”才能越走越远；在数据结构和算法的领域，不得不承认自己就是一只菜鸟；需要不断的学习；在学习过程中，经常会有一些自己的看法，和别人独特的见解；我都会一一做好笔记，以便进步；&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;正文：复杂度分析&lt;/h2&gt;
&lt;h3&gt; 一、什么是复杂度分析？&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”，而时间、空间复杂度做为数据结构和算法的精髓，很直观说明了代码”多快“”多省“。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.我们可以从执行时间和占用空间来评估数据结构和算法的性能，也就空间复杂度、时间复杂度，统称为复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;二、为什么要进行复杂度分析？&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.测试环境的不稳定因素（如同样的代码，i7比i3快得多），测试规模对测试结果影响很大（有些算法更适用于大规模数据），复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;三、如何进行复杂度分析？&lt;/h3&gt;
&lt;h4&gt;1.大O表示法&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1）所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　　T(n) = O(f（n）)&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大 O 时间复杂度并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，也叫作渐进时间复杂度，简称时间复杂度，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;2.复杂度分析法则&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1）单段代码看高频：比如循环。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）嵌套代码求乘积：比如递归、多重循环等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;四、常用的复杂度级别？&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括， O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括， O(2^n)（指数阶）、O(n!)（阶乘阶）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;五、如何掌握好复杂度分析方法？&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;复杂度分析关键在于多练，所谓孰能生巧。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;六、&lt;/span&gt;最好、最坏、平均、均摊时间复杂度&lt;/h3&gt;
&lt;h4&gt;一、概念：&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1.最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;二、为什么要引入这4个概念？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。&lt;br/&gt;2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;三、如何分析平均、均摊时间复杂度？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1.平均时间复杂度&lt;br/&gt;代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。&lt;br/&gt;2.均摊时间复杂度&lt;br/&gt;两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？&lt;/h2&gt;
&lt;h2&gt;每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我不认为是多此一举，渐进时间，空间复杂度分析为我们提供了一个很好的理论分析的方向，并且它是宿主平台无关的，能够让我们对我们的程序或算法有一个大致的认识，让我们知道，比如在最坏的情况下程序的执行效率如何，同时也为我们交流提供了一个不错的桥梁，我们可以说，算法1的时间复杂度是O(n)，算法2的时间复杂度是O(logN)，这样我们立刻就对不同的算法有了一个“效率”上的感性认识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，渐进式时间，空间复杂度分析只是一个理论模型，只能提供给粗略的估计分析，我们不能直接断定就觉得O(logN)的算法一定优于O(n), 针对不同的宿主环境，不同的数据集，不同的数据量的大小，在实际应用上面可能真正的性能会不同，个人觉得，针对不同的实际情况，进而进行一定的性能基准测试是很有必要的，比如在统一一批手机上(同样的硬件，系统等等)进行横向基准测试，进而选择适合特定应用场景下的最有算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上所述，渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的，但是一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，所以在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的，同时，因为渐进式时间，空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Oct 2018 07:27:00 +0000</pubDate>
<dc:creator>Dawnzhang</dc:creator>
<og:description>前言： 大家都知道数据结构和英语，就如同程序员的两条腿一样；只有不断的积累，学习，拥有了健壮的“双腿”才能越走越远；在数据结构和算法的领域，不得不承认自己就是一只菜鸟；需要不断的学习；在学习过程中，经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clwydjgs/p/9718754.html</dc:identifier>
</item>
<item>
<title>TOF--TOF相机技术原理深入解析与分享 - pans0ul</title>
<link>http://www.cnblogs.com/pans0ul/p/9747441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pans0ul/p/9747441.html</guid>
<description>&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF&lt;/span&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439035/201810/1439035-20181006151812565-1870851773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF,&lt;/span&gt; &lt;span&gt;即&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;time of flight ,&lt;/span&gt;&lt;span&gt;直译过来就是飞行时间。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF&lt;/span&gt;&lt;span&gt;的原理与他的名称对应，即，测量光在空间中飞行的时间，通过换算成距离，就可以测得摄像头与物体的距离。通常，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF&lt;/span&gt;&lt;span&gt;摄像头组成有一个发射模块，一个接收模块。发射模块可以是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;LED&lt;/span&gt;&lt;span&gt;、激光等发射元件，它将发射例如&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;850nm&lt;/span&gt;&lt;span&gt;的调制红外光，物体经过反射后，由接收模块接收到反射的红外光。由于发射和接收的都是调制波，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF&lt;/span&gt;&lt;span&gt;摄像头可以计算发射和接收的相位差，通过换算得到深度值，即摄像头与物体的深度距离。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF-&lt;/span&gt;&lt;span&gt;单点测距原理&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一个简易的单点&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF&lt;/span&gt;&lt;span&gt;系统组成如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439035/201810/1439035-20181006151820557-68482974.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;它由一个发射二极管、接收二极管、调制模块，解调模块、处理器几部分组成。调制模块负责调制发射的红外调制波，通过发射二极管将信号发射出去；解调模块负责对接受二极管接收到的反射红外波解调；处理器中包含&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;ADC&lt;/span&gt;&lt;span&gt;和数据处理，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;ADC&lt;/span&gt;&lt;span&gt;是为了将模拟信号转化为数字信号，具体是什么模拟信号下文将会详细讲述；数据处理为了将测得的相位差换算成深度信息。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF-&lt;/span&gt;&lt;span&gt;多点测距原理&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;目前，一个完整的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF&lt;/span&gt;&lt;span&gt;系统组成如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439035/201810/1439035-20181006151827689-1643561604.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;它和传统&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;RGB&lt;/span&gt;&lt;span&gt;摄像头的组成结构基本相似。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;它与点单的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF&lt;/span&gt;&lt;span&gt;系统比较区别在于，测量范围不是一个点，它是一个面，因此，接收模块变成了点阵的光敏传感器，通常使用的是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CMOS&lt;/span&gt;&lt;span&gt;传感器；在传感器前面、和发射二极管前面多了光学镜片，一个是为了红外波的辐射范围、一个是为了滤除&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;850nm&lt;/span&gt;&lt;span&gt;以外的光线，就是说，要保证进入传感器的光线只是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;850nm&lt;/span&gt;&lt;span&gt;的，这样才能保证测量的准确度。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;因为相位差即代表物体的与摄像头的距离，即深度，由于每个点的相位差不同，所以才能组成有关物体整幅深度图像。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF&lt;/span&gt;&lt;span&gt;传感器工作原理&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;目前，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;TOF&lt;/span&gt;&lt;span&gt;传感器工作原理中主要有两种，基于脉冲波（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;paulse base&lt;/span&gt;&lt;span&gt;）的技术原理、基于连&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;续调制波（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CW&lt;/span&gt;&lt;span&gt;）的技术原理。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在这之前，需要知道解调模块是如何工作的，如何读取感光传感器上面的电荷量。以单点像素的读取测量为例：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439035/201810/1439035-20181006151835753-187670005.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;整个读取测量过程主要分为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;&lt;span&gt;个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439035/201810/1439035-20181006151843141-1146621346.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;分别是，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Reset;Integration;Readout;Deadtime&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Reset：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在上图中看到，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Rst&lt;/span&gt;&lt;span&gt;开关，在测量电荷量之前，需要将&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Rst&lt;/span&gt;&lt;span&gt;开关闭合，让电容&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CB&lt;/span&gt;&lt;span&gt;充电，充好点之后断开。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Integration&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Integration period ,DMIX0&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMIX1&lt;/span&gt;&lt;span&gt;是由解调模块控制的开关，什么时候开关，与调制和解调的频率有关。当光子被感光元件&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;&lt;span&gt;蓝色圆圈箭头&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;span&gt;接收时，并且当&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMIX0&lt;/span&gt;&lt;span&gt;闭合时，这时候，充好电的电容&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;&lt;span&gt;就会和感光元件释放出来的电子中和，电容&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;&lt;span&gt;放电，直到中和完毕，最后得到的电容电平代表着接受光子数量和时间的电平。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Readout&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;中和完毕之后，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Address Decode&lt;/span&gt; &lt;span&gt;开关打开，读取电容上的电平。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Deadtime&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;死区时间&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;从以上四个环节来看，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Integration Time&lt;/span&gt; &lt;span&gt;是最重要的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;关于，为什么还会有&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMIX1&lt;/span&gt;&lt;span&gt;，下面将会解释到。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;基于脉冲波（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;paulse base&lt;/span&gt;&lt;span&gt;）的技术原理&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;发射模块发射矩形脉冲波，物体发射后具有相位差的脉冲波，测量相位差的方法如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439035/201810/1439035-20181006151850481-747829473.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;发射脉冲可以设定一个频率&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f&lt;/span&gt;&lt;span&gt;，并且开启两个反向的窗口，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMIX0&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMIX1&lt;/span&gt;&lt;span&gt;用来接收光子的数量，&lt;/span&gt; &lt;span&gt;一个窗口的频率和相位是与发射脉冲是一致的，另外一个是与&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMIX1&lt;/span&gt;&lt;span&gt;反向，并且相位差为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;180&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;在两个窗口打开的时候，也就是高电平的时候，并且这时候存在物体反射过来的脉冲波，这时候两个不同窗口在各自的时间内收集电荷。在图上已经用红色上色表示。假设&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMIX0&lt;/span&gt;&lt;span&gt;收集到的电荷量为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Q0&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMIX1&lt;/span&gt;&lt;span&gt;收集到的电荷量为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Q1&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Q0&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Q1&lt;/span&gt;&lt;span&gt;相加的这部分就是有反射脉冲时间内收集的电荷量。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;td&lt;/span&gt;&lt;span&gt;表示相位差存在的时间，为了计算&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;td&lt;/span&gt;&lt;span&gt;，可以通过计算&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Q1&lt;/span&gt;&lt;span&gt;在反射脉冲所占的时间，为了计算&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Q1&lt;/span&gt;&lt;span&gt;这部分的时间，我们可以读取&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMIX0&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;DMIX1&lt;/span&gt;&lt;span&gt;窗口上的电平，也就是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Q0&lt;/span&gt;&lt;span&gt;加&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Q1&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Q1&lt;/span&gt;&lt;span&gt;的比值，再乘上发射电平高电平的时间。因此，可以通过式子计算相位差&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;d&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439035/201810/1439035-20181006151856026-1903555581.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;注：以上的整个过程称为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;IntegrationTime&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;基于连续调制波（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CW&lt;/span&gt;&lt;span&gt;）的技术原理&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;连续调制波在脉冲波的基础上而来，连续调制波通常是连续正弦波调制，与脉冲不同的是，连续调制波开启了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;&lt;span&gt;个窗口分别是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;C1-C4.&lt;/span&gt;&lt;span&gt;如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439035/201810/1439035-20181006151900669-187022954.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;由于连续调制波通常是连续正弦波调制，可以将调制波看成是正弦波如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439035/201810/1439035-20181006151904827-1529400807.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;连续正弦波调制测量方法，推导过程如下。序号&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1-9&lt;/span&gt;&lt;span&gt;对应下图的公式&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1-8&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;span&gt;       &lt;/span&gt;&lt;/span&gt; &lt;span&gt;假设发射的正弦信号&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;s(t)&lt;/span&gt;&lt;span&gt;振幅是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;a&lt;/span&gt;&lt;span&gt;，调制频率是&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;f&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.&lt;span&gt;       &lt;/span&gt;&lt;/span&gt; &lt;span&gt;经过时延&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;△&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;t&lt;/span&gt;&lt;span&gt;后接收到的信号为接收&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;r(t)&lt;/span&gt;&lt;span&gt;，衰减后的振幅为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;，强度偏移（由环境光引起）为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;B&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.&lt;span&gt;       &lt;/span&gt;&lt;/span&gt; &lt;span&gt;四个采样时间间隔相等，均为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;T/4&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;4.&lt;span&gt;       &lt;/span&gt;&lt;/span&gt; &lt;span&gt;根据上述采样时间可以列出四个方程组&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;5.&lt;span&gt;       &lt;/span&gt;&lt;/span&gt; &lt;span&gt;从而可以计算出发射和接收的正弦信号的相位偏移&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;△&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;φ&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;6.&lt;span&gt;       &lt;/span&gt;&lt;/span&gt; &lt;span&gt;据此可以根据（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;6&lt;/span&gt;&lt;span&gt;）中公式计算物体和深度相机的距离&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;d&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;7.&lt;span&gt;       &lt;/span&gt;&lt;/span&gt; &lt;span&gt;接收信号的衰减后的振幅&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;的计算结果&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;8.&lt;span&gt;       &lt;/span&gt;&lt;/span&gt; &lt;span&gt;接收信号强度偏移&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;B&lt;/span&gt;&lt;span&gt;的计算结果，反映了环境光&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439035/201810/1439035-20181006151910201-653306705.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;更加详细的推导过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439035/201810/1439035-20181006151916646-1202949070.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;其实两种基于不同原理的计算相位的方法差不多，连续调制波相对复杂。关于如何推到，更多的是数学的部分，最后计算&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;d&lt;/span&gt;&lt;span&gt;公式中，其实表示的含义是一样的，只是符号不同罢了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;两种基于不同测量方法的优缺点分析&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;基于脉冲波（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;paulse base&lt;/span&gt;&lt;span&gt;）的技术原理&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;span&gt;        &lt;/span&gt;&lt;/span&gt; &lt;span&gt;因为不用计算振幅和环境光，测量方法简单，响应较快，可以提高相机的帧率&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;span&gt;        &lt;/span&gt;&lt;/span&gt; &lt;span&gt;由于没有抵消环境光对测量的影响，所以将会受到环境光的影响&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.&lt;span&gt;        &lt;/span&gt;&lt;/span&gt; &lt;span&gt;相对于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CW&lt;/span&gt;&lt;span&gt;的方案，测量精度较低，但也不会低到离谱&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;基于连续调制波（&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;CW&lt;/span&gt;&lt;span&gt;）的技术原理&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;span&gt;        &lt;/span&gt;&lt;/span&gt; &lt;span&gt;相位偏移（公式&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;5&lt;/span&gt;&lt;span&gt;）中的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(r2-r0)&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(r1-r3)&lt;/span&gt;&lt;span&gt;相对于脉冲调试法消除了由于测量器件或者环境光引起的固定偏差。连续调制波使用多个测量窗口，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(Q 3 -Q 4 )&lt;/span&gt;&lt;span&gt;及&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(Q 1 -Q 2 )&lt;/span&gt;&lt;span&gt;可以减掉测量中的共同成分（复位电压，环境光，电容增益等）及其中的偏差。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.&lt;span&gt;        &lt;/span&gt;&lt;/span&gt; &lt;span&gt;可以根据接收信号的振幅&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;A&lt;/span&gt;&lt;span&gt;和强度偏移&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;B&lt;/span&gt;&lt;span&gt;来间接的估算深度测量结果的精确程度（方差）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.&lt;span&gt;        &lt;/span&gt;&lt;/span&gt; &lt;span&gt;不要求光源必须是短时高强度脉冲，可以采用不同类型的光源，运用不同的调制方法&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;span&gt;        &lt;/span&gt;&lt;/span&gt; &lt;span&gt;需要多次采样，测量时间较长，限制了相机的帧率&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.&lt;span&gt;        &lt;/span&gt;&lt;/span&gt; &lt;span&gt;因为采集和计算量大，导致在相同成本的产品中，深度分辨率降低&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;MsoNormal&quot;&gt;&lt;span&gt;参考文献：&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1. https://blog.csdn.net/electech6/article/details/78349107&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2. TI documents&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Oct 2018 07:24:00 +0000</pubDate>
<dc:creator>pans0ul</dc:creator>
<og:description>TOF-深度相机-TOF技术原理-飞行时间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pans0ul/p/9747441.html</dc:identifier>
</item>
<item>
<title>.Net Core中的Api版本控制 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9747180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9747180.html</guid>
<description>&lt;blockquote readability=&quot;2.0161290322581&quot;&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://neelbhatt.com/2018/04/21/api-versioning-in-net-core&quot;&gt;API Versioning in .Net Core&lt;/a&gt;&lt;br/&gt;作者：&lt;a href=&quot;https://neelbhatt.com/contact-me/&quot;&gt;Neel Bhatt&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Api的版本控制是Api开发中经常遇到的问题, 在大部分中大型项目都需要使用到Api的版本控制&lt;/p&gt;
&lt;p&gt;在本篇博客中，我们将说明一下如何在.Net Core Api项目中使用Api版本控制。&lt;/p&gt;
&lt;p&gt;本篇博客中测试项目的开发环境：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Visual Studio 2017&lt;/li&gt;
&lt;li&gt;.Net Core 2.1 SDK&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;创建一个api项目&quot;&gt;创建一个Api项目&lt;/h2&gt;
&lt;p&gt;首先我们创建一个.NET Core Api项目&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181006144515753-1152787892.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用nuget安装api版本控制库&quot;&gt;使用Nuget安装Api版本控制库&lt;/h2&gt;
&lt;p&gt;.NET Core Mvc中，微软官方提供了一个可用的Api版本控制库&lt;em&gt;Microsoft.AspNetCore.Mvc.Versioning&lt;/em&gt;。 这里我们可以使用Nuget安装这个包。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PM&amp;gt; Install-Package Microsoft.AspNetCore.Mvc.Versioning&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;修改startup类&quot;&gt;修改Startup类&lt;/h2&gt;
&lt;p&gt;Microsoft.AspNetCore.Mvc.Versioning库安装完成之后，下一步我们来添加Api版本控制服务。&lt;/p&gt;
&lt;p&gt;这里我们需要在Startup类的ConfigureService方法中添加以下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    services.AddApiVersioning(o =&amp;gt; {
        o.ReportApiVersions = true;
        o.AssumeDefaultVersionWhenUnspecified = true;
        o.DefaultApiVersion = new ApiVersion(1, 0);
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码解释&quot;&gt;代码解释&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;ReportApiVersion&lt;/code&gt; 属性是一个布尔类型，如果设置为true, 在Api请求的响应头部，会追加当前Api支持的版本, 例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Response Header
api-supported-versions: 1.0
content-type: application/json; charset=utf-8
date: Sat, 06 Oct 2018 05:24:21 GMT
server: Kestrel
status: 200
x-powered-by: ASP.NET&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;AssumeDefaultVersionWhenUnspecified&lt;/code&gt;属性是为了标记当客户端没有指定版本号的时候，是否使用默认版本号&lt;br/&gt;&lt;code&gt;DefaultApiVersion&lt;/code&gt;属性即默认版本号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;创建多版本api&quot;&gt;创建多版本Api&lt;/h2&gt;
&lt;p&gt;这里为了测试.Net Core Mvc的Api版本控制库，我们创建如下2个Controller。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    [ApiVersion(&quot;1.0&quot;)]
    [Route(&quot;api/values&quot;)]
    [ApiController]
    public class ValuesV1Controller : ControllerBase
    {
        [HttpGet]
        public IEnumerable&amp;lt;string&amp;gt; Get()
        {
            return new string[] { &quot;Value1 from Version 1&quot;, &quot;value2 from Version 1&quot; };
        }
    }   

    [ApiVersion(&quot;2.0&quot;)]
    [Route(&quot;api/values&quot;)]
    [ApiController]
    public class ValuesV2Controller : ControllerBase
    {
        [HttpGet]
        public IEnumerable&amp;lt;string&amp;gt; Get()
        {
            return new string[] { &quot;value1 from Version 2&quot;, &quot;value2 from Version 2&quot; };
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码解释-1&quot;&gt;代码解释&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Value1Controller&lt;/code&gt;和&lt;code&gt;Value2Controller&lt;/code&gt;使用了一样的路由&quot;/api/values&quot;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Value1Controller&lt;/code&gt;类头部使用&lt;code&gt;ApiVersion&lt;/code&gt;特性标记了当前Controller的Api版本号是1.0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Value2Controller&lt;/code&gt;类头部使用&lt;code&gt;ApiVersion&lt;/code&gt;特性标记了当前Controller的Api版本号是2.0&lt;br/&gt;-&lt;code&gt;Value1Controller&lt;/code&gt;和&lt;code&gt;Value2Controller&lt;/code&gt;都持有相同方法签名的&lt;code&gt;Get&lt;/code&gt;方法, 只是2个&lt;code&gt;Get&lt;/code&gt;中返回了不同的字符串&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在我们启动项目，得到的结果如下，说明当没有指定Api版本号时，项目自动使用1.0版本的Api, 即&lt;code&gt;ValuesV1Controller&lt;/code&gt;中的Get方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181006144524128-85502879.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何在查询字符串query-string中使用版本控制&quot;&gt;如何在查询字符串(Query String)中使用版本控制&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Microsoft.AspNetCore.Mvc.Versioning&lt;/em&gt;支持以QueryString的形式指定请求Api的版本号。开发人员可以在Url中指定api-version参数来选择调用的Api版本号。&lt;/p&gt;
&lt;p&gt;以当前项目为例&lt;br/&gt;当请求https://localhost:44319/api/values?api-version=2.0时, 返回结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&quot;value1 from Version 2&quot;,&quot;value2 from Version 2&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当请求https://localhost:44319/api/values?api-version=1.0时, 返回结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&quot;Value1 from Version 1&quot;,&quot;value2 from Version 1&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何使用路由约束中指定请求api的版本&quot;&gt;如何使用路由约束中指定请求Api的版本&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Microsoft.AspNetCore.Mvc.Versioning&lt;/em&gt;还支持使用路由约束指定请求Api的版本号。&lt;/p&gt;
&lt;p&gt;例： [Route(“api/{v:apiVersion}/Values”)]&lt;/p&gt;
&lt;p&gt;我们对之前2个Controller的代码作如下修改。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [ApiVersion(&quot;1.0&quot;)]
    [Route(&quot;api/{v:apiVersion}/values&quot;)]
    [ApiController]
    public class ValuesV1Controller : ControllerBase
    {
        [HttpGet]
        public IEnumerable&amp;lt;string&amp;gt; Get()
        {
            return new string[] { &quot;Value1 from Version 1&quot;, &quot;value2 from Version 1&quot; };
        }
    }   

    [ApiVersion(&quot;2.0&quot;)]
    [Route(&quot;api/{v:apiVersion}/values&quot;)]
    [ApiController]
    public class ValuesV2Controller : ControllerBase
    {
        [HttpGet]
        public IEnumerable&amp;lt;string&amp;gt; Get()
        {
            return new string[] { &quot;value1 from Version 2&quot;, &quot;value2 from Version 2&quot; };
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们通过以下2个Url请求Api, 返回的结果如下 :&lt;br/&gt;&lt;strong&gt;/api/2.0/values&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&quot;value1 from Version 2&quot;,&quot;value2 from Version 2&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;/api/1.0/values&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&quot;Value1 from Version 1&quot;,&quot;value2 from Version 1&quot;]&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;以上的2种方式需要修改请求的Url, 如果你不喜欢这2种方式，&lt;em&gt;Microsoft.AspNetCore.Mvc.Versioning&lt;/em&gt;还提供了第三种指定Api版本号的方式，即在HTTP请求头中添加版本号参数。&lt;/p&gt;
&lt;p&gt;为了启用这种方式，我们首先需要在Startup.cs中修改&lt;em&gt;Microsoft.AspNetCore.Mvc.Versioning&lt;/em&gt;的配置, 代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    services.AddApiVersioning(o =&amp;gt;
    {
        o.ReportApiVersions = true;
        o.AssumeDefaultVersionWhenUnspecified = true;
        o.DefaultApiVersion = new ApiVersion(1, 0);
        o.ApiVersionReader = new HeaderApiVersionReader(&quot;x-api-version&quot;);
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里通过&lt;code&gt;ApiVersionReader&lt;/code&gt;属性指定了Api版本号是从请求头部的&lt;code&gt;x-api-version&lt;/code&gt;属性来的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Tips: 一旦你使用&lt;code&gt;o.ApiVersionReader = new HeaderApiVersionReader(&quot;x-api-version&quot;);&lt;/code&gt;, 在查询字符串中指定版本号的方式将不再可用，如果你希望同时支持2种方式，请改用&lt;code&gt;o.ApiVersionReader = new QueryStringOrHeaderApiVersionReader(&quot;x-api-version&quot;);&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们通过Postman来请求2.0的Api, 结果正确返回了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201810/65831-20181006144533642-1164460973.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;弃用apideprecated特性&quot;&gt;弃用Api(Deprecated)特性&lt;/h2&gt;
&lt;p&gt;有些时候，我们需要标记一些过时的Api为弃用状态，但是我们又不希望完全移除这个版本的Api, 我们可以使用&lt;code&gt;Deprecated&lt;/code&gt;特性。&lt;/p&gt;
&lt;p&gt;例：我们当前希望弃用&lt;code&gt;ValuesV1Controller&lt;/code&gt;, 我们可以指定Deprecated特性的值为true&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [ApiVersion(&quot;1.0&quot;, Deprecated = true)]
    [Route(&quot;api/values&quot;)]
    [ApiController]
    public class ValuesV1Controller : ControllerBase
    {
        [HttpGet]
        public IEnumerable&amp;lt;string&amp;gt; Get()
        {
            return new string[] { &quot;Value1 from Version 1&quot;, &quot;value2 from Version 1&quot; };
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们请求在此请求这个api的时候, 在响应头中会出现&lt;code&gt;api-deprecated-versions&lt;/code&gt;和&lt;code&gt;api-supported-versions&lt;/code&gt;2个属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Response Header
api-deprecated-versions: 1.0
api-supported-versions: 2.0
content-type: application/json; charset=utf-8
date: Sat, 06 Oct 2018 06:32:18 GMT
server: Kestrel
status: 200
x-powered-by: ASP.NET
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段响应的意思就是1.0版本的Api已经过期了，2.0版本中有相同的Api, 可以换用2.0版本的Api。&lt;/p&gt;
&lt;h2 id=&quot;使用apiversionneutral指定不需要版本控制的api&quot;&gt;使用&lt;code&gt;ApiVersionNeutral&lt;/code&gt;指定不需要版本控制的Api&lt;/h2&gt;
&lt;p&gt;在编写Api的时候，对于一些非常简单的Api， 我们可能不需要指定Api版本号, 例如健康检查Api。我们可以使用&lt;code&gt;ApiVersionNeutral&lt;/code&gt;特性，将它从Api版本控制中排除掉。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [ApiVersionNeutral]
    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class HealthCheckController : ControllerBase
    {
        public string Get()
        {
            return &quot;Good&quot;;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/lwqlun/ApiVersioningSample.zip&quot;&gt;本篇源代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Oct 2018 06:55:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文链接：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9747180.html</dc:identifier>
</item>
<item>
<title>一套代码小程序&amp;Web&amp;Native运行的探索05——snabbdom - 叶小钗</title>
<link>http://www.cnblogs.com/yexiaochai/p/9742383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yexiaochai/p/9742383.html</guid>
<description>&lt;p&gt;接上文：&lt;a href=&quot;https://www.cnblogs.com/yexiaochai/p/9713519.html&quot;&gt;一套代码小程序&amp;amp;Web&amp;amp;Native运行的探索04——数据更新&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应Git代码地址请见：&lt;a href=&quot;https://github.com/yexiaochai/wxdemo/tree/master/mvvm&quot; target=&quot;_blank&quot;&gt;https://github.com/yexiaochai/wxdemo/tree/master/mvvm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/yexiaochai/p/9713519.html&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;https://github.com/fastCreator/MVVM（极度参考，十分感谢该作者，直接看Vue会比较吃力的，但是看完这个作者的代码便会轻易很多，可惜这个作者没有对应博客说明，不然就爽了）&lt;/p&gt;
&lt;p&gt;https://www.tangshuang.net/3756.html&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/kidney/p/8018226.html&lt;/p&gt;
&lt;p&gt;http://www.cnblogs.com/kidney/p/6052935.html&lt;/p&gt;
&lt;p&gt;https://github.com/livoras/blog/issues/13&lt;/p&gt;
&lt;p&gt;根据最近的学习，离我们最终的目标还有一段距离，但是对于Vue实现原理却慢慢有了体系化的认识，相信本系列结束后，如果能完成我们跨端代码，哪怕是demo的实现，都会对后续了解Vue或者React这里源码提供深远的帮助，平时工作较忙，这次刚好碰到假期，虽然会耽搁一些时间，我们试试这段时间运气可好，能不能在这个阶段取得不错的进展，好了我们继续完成今天的学习吧&lt;/p&gt;
&lt;p&gt;到目前的地步，其中一些代码比较散乱，没有办法粘贴出来做讲解了，我这边尽量写注释，这里文章记录的主要目的还是帮助自己记录思路&lt;/p&gt;
&lt;p&gt;昨天，我们完成了最简单的模板到DOM的实现，以及执行setData时候页面重新渲染工作，只不过比较粗暴还没有引入snabbdom进行了重新渲染，今天我们来完成其中的事件绑定部分代码&lt;/p&gt;
&lt;p&gt;这里我们先不去管循环标签这些的解析，先完成事件绑定部分代码，这里如果只是想实现click绑定便直接在此处绑定事件即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class Element {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  constructor(tagName, props, children, vm) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.tagName =&lt;span&gt; tagName;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.props =&lt;span&gt; props;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.children = children ||&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.vm =&lt;span&gt; vm.vm;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  render() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿着根节点往下面撸&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     let el = document.createElement(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tagName);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     let props = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.props;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     let scope = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     let events = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.on;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(let name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; props) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;      el.setAttribute(name, props[name]);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; events) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       let type = Object.keys(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.on);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       type = type[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       el.addEventListener(type, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         scope.vm.$options.methods[scope.props.on[type]] &amp;amp;&amp;amp;&lt;span&gt; scope.vm.$options.methods[scope.props.on[type]].call(scope.vm, e);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;      })
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     let children = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.children;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(let i = 0, l = children.length; i &amp;lt; l; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;       let child =&lt;span&gt; children[i];
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;      let childEl;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;(child &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Element) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归调用&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         childEl =&lt;span&gt; child.render();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         childEl =&lt;span&gt; document.createTextNode(child);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;      el.append(childEl);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; el;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，这个不是我们要的最终代码，事实上，事件如何绑定dom如何比较差异渲染，我们这块不需要太多关系，我们只需要引入snabbdom即可，这里便来一起了解之&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;snabbdom&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面我们对snabbdom做了初步介绍，暂时看来MVVM框架就我这边学习的感觉有以下几个难点：&lt;/p&gt;
&lt;p&gt;① 第一步的模板解析，这块很容易出错，但如果有志气jQuery源码的功底就会比较轻易&lt;/p&gt;
&lt;p&gt;② 虚拟DOM这块，要对比两次dom树的差异再选择如何做&lt;/p&gt;
&lt;p&gt;只要突破这两点，其他的就会相对简单一些，而这两块最难也最容易出错的工作，我们全部引用了第三方库HTMLParser和snabbdom，所以我们都碰上了好时代啊......&lt;/p&gt;
&lt;p&gt;我们很容易将一个dom结构用js对象来抽象，比如我们之前做的班次列表中的列表排序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/294743/201810/294743-20181004152724909-1815050834.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里出发的因子就有出发时间、耗时、价格，这里表示下就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; let trainData =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   sortKet: 'time', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;耗时,价格,发车时间等等方式排序&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   sortType: 1, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1升序,2倒叙&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;   oData: [], &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器给过来的原生数据&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;   data: [], &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前筛选条件下的数据&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个对象有点缺陷就是不能与页面映射起来，我们之前的做法就算映射起来了，也只会跟一个跟节点做绑定关系，一旦数据发生变化便全部重新渲染，这个还是小问题，比较复杂的问题是半年后筛选条件增加，这个页面的代码可能会变得相当难维护，其中最难的点可能就是页面中的dom关系维护，和事件维护&lt;/p&gt;
&lt;p&gt;而我们想要的就是数据改变了，DOM自己就发生变化，并且以高效的方式发生变化，这个就是我们snabbdom做的工作了，而之前我们用一段代码说明过这个问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; element =&lt;span&gt; {
  tagName: &lt;/span&gt;'ul', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点标签名&lt;/span&gt;
  props: { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DOM的属性，用一个对象存储键值对&lt;/span&gt;
    id: 'list'&lt;span&gt;
  },
  children: [ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该节点的子节点&lt;/span&gt;
    {tagName: 'li', props: {class: 'item'}, children: [&quot;Item 1&quot;&lt;span&gt;]},
    {tagName: &lt;/span&gt;'li', props: {class: 'item'}, children: [&quot;Item 2&quot;&lt;span&gt;]},
    {tagName: &lt;/span&gt;'li', props: {class: 'item'}, children: [&quot;Item 3&quot;&lt;span&gt;]},
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='list'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
2   &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='item'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Item 1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
3   &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='item'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Item 2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
4   &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='item'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Item 3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
5 &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;真实的虚拟DOM会翻译为这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Element {
  constructor(tagName, props, children) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tagName =&lt;span&gt; tagName;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.props =&lt;span&gt; props;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.children =&lt;span&gt; children;
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; el(tagName, props, children)  {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Element(tagName, props, children)
}

el(&lt;/span&gt;'ul', {id: 'list'&lt;span&gt;}, [
  el(&lt;/span&gt;'li', {class: 'item'}, ['Item 1'&lt;span&gt;]),
  el(&lt;/span&gt;'li', {class: 'item'}, ['Item 2'&lt;span&gt;]),
  el(&lt;/span&gt;'li', {class: 'item'}, ['Item 3'&lt;span&gt;])
])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里很快就能封装一个可运行的代码出来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;起步&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;***虚拟dom部分代码,后续会换成snabdom&lt;/span&gt;
&lt;span&gt;  class Element {
    constructor(tagName, props, children) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tagName &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; tagName;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; props;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.children &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; children;
    }
    render() {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿着根节点往下面撸&lt;/span&gt;
&lt;span&gt;      let root &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.createElement(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tagName);
      let props &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props;

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let name &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; props) {
        root.setAttribute(name, props[name]);
      }

      let children &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.children;

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, l &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; children.length; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; l; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
        let child &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; children[i];
        let childEl;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(child &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Element) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归调用&lt;/span&gt;
&lt;span&gt;          childEl &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; child.render();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          childEl &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.createTextNode(child);
        }
        root.append(childEl);
      }

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.rootNode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; root;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    }
  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; el(tagName, props, children)  {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Element(tagName, props, children)
  }

  let vnode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; el(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {id: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}, [
    el(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {class: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}, [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Item 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]),
    el(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {class: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}, [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Item 2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]),
    el(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {class: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}, [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Item 3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
  ])

  let root &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; vnode.render();

  document.body.appendChild(root);

&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们今天要做的事情，便是把这段代码写的更加完善一点，就要进入第二步，比较两颗虚拟树的差异了，而这块也是snabbdom的核心，当然也比较有难度啦&lt;/p&gt;
&lt;p&gt;PS：这里借鉴：&lt;span&gt;&lt;strong&gt;https://github.com/livoras/blog/issues/13&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实际代码中，会对两棵树进行深度优先遍历，这样会给每个节点一个唯一的标志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/294743/201810/294743-20181004155442062-630336311.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在深度优先遍历的时候，每到一个节点便与新的树进行对比，如果有差异就记录到一个对象中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历子树,用来做递归的&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; diffChildren(oldNodeChildren, newNodeChildren, index, patches) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;   let leftNode = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   let curNodeIndex =&lt;span&gt; index;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt;(let i = 0, l = oldNodeChildren.length; i &amp;lt; l; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     let child =&lt;span&gt; oldNodeChildren[i];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     let newChild =&lt;span&gt; newNodeChildren[i];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算节点的标识&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     curNodeIndex = (leftNode &amp;amp;&amp;amp; leftNode.count) ? curNodeIndex + leftNode.count + 1 : curNodeIndex + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    dfsWalk(child, newChild)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     leftNode =&lt;span&gt; child;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对两棵树进行深度优先遍历,找出差异&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; dfsWalk(oldNode, newNode, index, patches) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将两棵树的不同记录之&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;   patches[index] =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;  diffChildren(oldNode.children, newNode.children, index, patches);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对比两棵树的差异&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; diff(oldTree, newTree) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前节点标志&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;   let index = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录每个节点的差异&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;   let patches =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;深度优先遍历&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; patches;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
patches[0] = [{difference}, {difference}, ...] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用数组存储新旧节点的不同&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里已经做好了工具流程遍历节点得出差异，而我们的差异有：&lt;/p&gt;
&lt;p&gt;① 替换原来的节点，例如把div换成section&lt;/p&gt;
&lt;p&gt;② 移动、删除、新增子节点，例如把p与ul顺序替换&lt;/p&gt;
&lt;p&gt;③ 这个比较简单，修改节点属性&lt;/p&gt;
&lt;p&gt;④ 这个也比较简单，修改文本内容&lt;/p&gt;
&lt;p&gt;这里给这几种类型的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let REPLACE = 0&lt;span&gt;
let REORDER &lt;/span&gt;= 1&lt;span&gt;
let PROPS &lt;/span&gt;= 2&lt;span&gt;
let TEXT &lt;/span&gt;= 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;节点替换首先判断tagname是否一致即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
patches[0] =&lt;span&gt; [{
  type: REPALCE,
  node: newNode &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; el('section', props, children)&lt;/span&gt;
}]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果给div新增属性，便记录之：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
patches[0] =&lt;span&gt; [{
  type: REPALCE,
  node: newNode &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; el('section', props, children)&lt;/span&gt;
&lt;span&gt;}, {
  type: PROPS,
  props: {
    id: &lt;/span&gt;&quot;container&quot;&lt;span&gt;
  }
}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是文本节点便记录之：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
patches[2] =&lt;span&gt; [{
  type: TEXT,
  content: &lt;/span&gt;&quot;Virtual DOM2&quot;&lt;span&gt;
}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上都比较常规，不会做太大改变，情况比较多的是REODER（Reorder重新排列），比如将这里div的子节点顺序变成了div-p-ul，这个该如何对比，其实这个情况可能会直接被替换掉，这样DOM开销太大，这里牵扯到了列表对比算法，有点小复杂：&lt;/p&gt;
&lt;p&gt;假如现在对英文字母进行排序，久的顺序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
a b c d e f g h i
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后对节点进行了一系列的操作，新增j节点，删除e节点，移动h节点，于是有了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
a b c h d f g i j
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;知道了新旧顺序，现在需要我们写一个算法计算最小插入、删除操作（移动是删除+插入），这块具体我们不深入，有兴趣移步至，这里&lt;a href=&quot;https://github.com/livoras/list-diff/blob/master/lib/diff.js&quot;&gt;代码&lt;/a&gt;，我们最终形成的结果是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
patches[0] =&lt;span&gt; [{
  type: REORDER,
  moves: [{remove or insert}, {remove or insert}, ...]
}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是我们将这段寻找差异的代码放入前面的遍历代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; patch (node, patches) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; walker = {index: 0&lt;span&gt;}
  dfsWalk(node, walker, patches)
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; dfsWalk (node, walker, patches) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentPatches = patches[walker.index] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从patches拿出当前节点的差异&lt;/span&gt;

  &lt;span&gt;var&lt;/span&gt; len =&lt;span&gt; node.childNodes
    &lt;/span&gt;?&lt;span&gt; node.childNodes.length
    : &lt;/span&gt;0
  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; len; i++) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 深度遍历子节点&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; child =&lt;span&gt; node.childNodes[i]
    walker.index&lt;/span&gt;++&lt;span&gt;
    dfsWalk(child, walker, patches)
  }

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (currentPatches) {
    applyPatches(node, currentPatches) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对当前节点进行DOM操作&lt;/span&gt;
&lt;span&gt;  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; applyPatches (node, currentPatches) {
  currentPatches.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (currentPatch) {
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (currentPatch.type) {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; REPLACE:
        node.parentNode.replaceChild(currentPatch.node.render(), node)
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
      &lt;span&gt;case&lt;/span&gt;&lt;span&gt; REORDER:
        reorderChildren(node, currentPatch.moves)
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
      &lt;span&gt;case&lt;/span&gt;&lt;span&gt; PROPS:
        setProps(node, currentPatch.props)
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
      &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TEXT:
        node.textContent &lt;/span&gt;=&lt;span&gt; currentPatch.content
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
      &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('Unknown patch type ' +&lt;span&gt; currentPatch.type)
    }
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个就是我们snabbdom中重要的patch.js的实现，而Virtual DOM算法主要就是：&lt;br/&gt;① 虚拟DOM element的定义&lt;/p&gt;
&lt;p&gt;② 差异的定义与实现&lt;/p&gt;
&lt;p&gt;③ 将差异部分代码补足形成新树的&lt;a href=&quot;https://github.com/livoras/simple-virtual-dom/blob/master/lib/patch.js&quot;&gt;patch&lt;/a&gt;部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 构建虚拟DOM&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; tree = el('div', {'id': 'container'&lt;span&gt;}, [
    el(&lt;/span&gt;'h1', {style: 'color: blue'}, ['simple virtal dom'&lt;span&gt;]),
    el(&lt;/span&gt;'p', ['Hello, virtual-dom'&lt;span&gt;]),
    el(&lt;/span&gt;'ul', [el('li'&lt;span&gt;)])
])

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 通过虚拟DOM构建真正的DOM&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; root =&lt;span&gt; tree.render()
document.body.appendChild(root)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. 生成新的虚拟DOM&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; newTree = el('div', {'id': 'container'&lt;span&gt;}, [
    el(&lt;/span&gt;'h1', {style: 'color: red'}, ['simple virtal dom'&lt;span&gt;]),
    el(&lt;/span&gt;'p', ['Hello, virtual-dom'&lt;span&gt;]),
    el(&lt;/span&gt;'ul', [el('li'), el('li'&lt;span&gt;)])
])

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4. 比较两棵虚拟DOM树的不同&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; patches =&lt;span&gt; diff(tree, newTree)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5. 在真正的DOM元素上应用变更&lt;/span&gt;
patch(root, patches)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了以上知识，我们现在来开始使用snabbdom，相比会得心应手&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用snabbdom&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; snabbdom = require(&quot;snabbdom&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; patch = snabbdom.init([ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化补丁功能与选定的模块&lt;/span&gt;
  require(&quot;snabbdom/modules/class&quot;).&lt;span&gt;default&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使切换class变得容易&lt;/span&gt;
  require(&quot;snabbdom/modules/props&quot;).&lt;span&gt;default&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于设置DOM元素的属性(注意区分props，attrs具体看snabbdom文档)&lt;/span&gt;
  require(&quot;snabbdom/modules/style&quot;).&lt;span&gt;default&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理元素的style，支持动画&lt;/span&gt;
  require(&quot;snabbdom/modules/eventlisteners&quot;).&lt;span&gt;default&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件监听器&lt;/span&gt;
&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;h是一个生成vnode的包装函数,factory模式？对生成vnode更精细的包装就是使用jsx&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;在工程里,我们通常使用webpack或者browserify对jsx编译&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; h = require(&quot;snabbdom/h&quot;).&lt;span&gt;default&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于创建vnode,VUE中render(createElement)的原形&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; container = document.getElementById(&quot;container&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vnode = h(&quot;div#container.two.classes&quot;&lt;span&gt;, {on: {click: someFn}}, [
  h(&lt;/span&gt;&quot;span&quot;, {style: {fontWeight: &quot;bold&quot;}}, &quot;This is bold&quot;&lt;span&gt;),
  &lt;/span&gt;&quot; and this is just normal text&quot;&lt;span&gt;,
  h(&lt;/span&gt;&quot;a&quot;, {props: {href: &quot;/foo&quot;}}, &quot;I\&quot;ll take you places!&quot;&lt;span&gt;)
]);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一次打补丁，用于渲染到页面，内部会建立关联关系，减少了创建oldvnode过程&lt;/span&gt;
&lt;span&gt;patch(container, vnode);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建新节点&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; newVnode = h(&quot;div#container.two.classes&quot;&lt;span&gt;, {on: {click: anotherEventHandler}}, [
  h(&lt;/span&gt;&quot;span&quot;, {style: {fontWeight: &quot;normal&quot;, fontStyle: &quot;italic&quot;}}, &quot;This is now italic type&quot;&lt;span&gt;),
  &lt;/span&gt;&quot; and this is still just normal text&quot;&lt;span&gt;,
  h(&lt;/span&gt;&quot;a&quot;, {props: {href: &quot;/bar&quot;}}, &quot;I\&quot;ll take you places!&quot;&lt;span&gt;)
]);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二次比较，上一次vnode比较，打补丁到页面&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;VUE的patch在nextTick中，开启异步队列，删除了不必要的patch&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;nextTick异步队列解析，下面文章中会详解&lt;/span&gt;
patch(vnode, newVnode); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Snabbdom efficiently updates the old view to the new state&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里可以看到，我们传入h的要求是什么样的格式，依次有什么属性，这里还是来做一个demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;module&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;use strict&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  import { patch, h, VNode } from &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./libs/vnode.js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt;&lt;span&gt; container &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; someFn(){ console.log(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; anotherEventHandler(){ console.log(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt;&lt;span&gt; oldVnode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; h(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {on: {click: someFn}}, [
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    h(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {style: {fontWeight: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}}, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; and this is just normal text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    h(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {props: {href: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}}, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I\&quot;ll take you places!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  ]);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一次打补丁，用于渲染到页面，内部会建立关联关系，减少了创建oldvnode过程&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  let diff &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; patch(container, oldVnode);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建新节点&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt;&lt;span&gt; newVnode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; h(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {on: {click: anotherEventHandler}}, [
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    h(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {style: {fontWeight: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;normal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, fontStyle: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;italic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}}, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is now italic type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; and this is still just normal text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    h(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {props: {href: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}}, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I\&quot;ll take you places!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  ]);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二次比较，上一次vnode比较，打补丁到页面&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;VUE的patch在nextTick中，开启异步队列，删除了不必要的patch&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;nextTick异步队列解析，下面文章中会详解&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;  patch(oldVnode, newVnode); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Snabbdom efficiently updates the old view to the new state&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;      oldVnode,newVnode,container,diff
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以我们现在工作变得相对简单起来就是根据HTML模板封装虚拟DOM结构即可，如果不是我们其中存在指令系统甚至可以不用HTMLParser，所以我们改下之前的代码，将我们自己实现的丑陋vnode变成snabbdom，这里详情还是看github：&lt;a href=&quot;https://github.com/yexiaochai/wxdemo/tree/master/mvvm&quot; target=&quot;_blank&quot;&gt;https://github.com/yexiaochai/wxdemo/tree/master/mvvm&lt;/a&gt;。接下来，我们来解决其中的指令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里所谓的指令用的最多的也就是：&lt;/p&gt;
&lt;p&gt;① if&lt;/p&gt;
&lt;p&gt;② for&lt;/p&gt;
&lt;p&gt;对应到小程序中就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;block &lt;/span&gt;&lt;span&gt;wx:for&lt;/span&gt;&lt;span&gt;=&quot;{{[1, 2, 3]}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; {{index}}: &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; {{item}} &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;block &lt;/span&gt;&lt;span&gt;wx:if&lt;/span&gt;&lt;span&gt;=&quot;{{true}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; view1 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; view2 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Vue中的语法是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example-1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;item in items&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {{ item.message }}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1 &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;ok&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Yes&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1 &lt;/span&gt;&lt;span&gt;v-else&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;No&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大同小异，我们来看看如何处理这种代码，这里也开始进入数组对象的处理，这里便引入了指令系统，我们这里单独说下这块代码&lt;/p&gt;
&lt;p&gt;框架里面的for或者if这种指令代码因为要要保证框架性，首先写的很分散，其次用起来也很绕，就很不好理解，所以这里需要单独拎出来说下&lt;/p&gt;
&lt;p&gt;之前我们使用的模板一般就是js代码，直接被翻译为了js函数，比如这段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;%&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;let&lt;/span&gt;&lt;span&gt; key in arr) { &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; } &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会被大概翻译为这个样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; __t,__p='',__j=Array.prototype.join,print=&lt;span&gt;function&lt;/span&gt;(){__p+=__j.call(arguments,''&lt;span&gt;);};
&lt;/span&gt;&lt;span&gt;with&lt;/span&gt;(obj||&lt;span&gt;{}){
__p&lt;/span&gt;+='&amp;lt;ul&amp;gt;\n  '&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; arr) { 
__p&lt;/span&gt;+='\n    &amp;lt;li&amp;gt;...&amp;lt;/li&amp;gt;\n  '&lt;span&gt;;
 } 
__p&lt;/span&gt;+='\n&amp;lt;/ul&amp;gt;'&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; __p;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而MVVM类框架执行的是相同的逻辑，只不过代码实现上面因为要考虑映射关系就复杂的多了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;m-for&lt;/span&gt;&lt;span&gt;=&quot;(val, key, index) in arr&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;索引 {{key + 1}} ：{{val}}    
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;翻译后基本就是这个代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;with&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
  &lt;/span&gt;&lt;span&gt;debugger&lt;/span&gt; ;&lt;span&gt;return&lt;/span&gt; _h('ul', {}, [_l((arr), &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val, key, index) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _h('li'&lt;span&gt;, {
      attrs: {
        &lt;/span&gt;&quot;m-for&quot;: '(val, key, index) in arr'&lt;span&gt;
      }
    }, [&lt;/span&gt;&quot;索引 &quot; + _s(key + 1) + &quot; ：&quot; +&lt;span&gt; _s(val)])
  })])
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有的这一切都是为了形成虚拟树结构，最终要的是这样的东西&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/294743/201810/294743-20181005172806054-610169994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以指令是其中的工具，一个过程，帮助我们达到目的，为了帮助理解，我们这边单独抽一段代码出来说明这个问题，这里再强调一下指令系统在整体流程中的意义是：&lt;/p&gt;
&lt;p&gt;我们最终目标是将模板转换为snabbdom中的vnode，这样他便能自己渲染，而这里的过程是&lt;/p&gt;
&lt;p&gt;模板 =&amp;gt; HTMLParser解析模板 =&amp;gt; 框架element对象 =&amp;gt; 解析框架element对象中的属性，这里包括指令 =&amp;gt; 将属性包含的指令相关信息同步到element对象上（因为每个标签都会有element对象）=&amp;gt; 生成用于render的函数（其实就是将element转换为snabbdom可识别的对象） =&amp;gt; 生成snabbdom树后，调用pacth即可完成渲染&lt;/p&gt;
&lt;p&gt;所以指令系统在其中的意义便是：解析element中的指令对应的代码，方便后续生成render匿名函数罢了，这就是为什么指令系统的实现包含了两个方法：&lt;/p&gt;
&lt;p&gt;① template2Vnode，这个事实上是将模板中与指令相关的信息放到element对象上方便后续vnode2render时候使用&lt;/p&gt;
&lt;p&gt;② vnode2render，便是将之前存到element中与生成最终函数有关的字段拿出来拼接成函数字符串，调用的时候是在mvvm实例对象下，所以可以取到传入的data以及method&lt;/p&gt;
&lt;p&gt;之所以设计的比较复杂是为了让大家方便新增自定义指令，这里仍然先上一段简单的说明性代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;131&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;指令系统演示&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;module&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要处理的模板,我们需要将他转换为虚拟dom vnode&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;  let html &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; `
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li m&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(val, key, index) in arr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;索引 {{key &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;}} ：{{val}}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;li&amp;gt;&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;ul&amp;gt;&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;  `
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里我们为了降低学习成本将这段模板再做一次简化,变成这样&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;  html &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div m-for=&quot;(val, key, index) in arr&quot;&amp;gt;索引 {{key + 1}} ：{{val}}&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理element元素生成render函数&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; genElement(el) {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里如果有自定义指令也会被拿出来&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;el.processed) {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有这个指令会递归调用&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;      el.processed &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;      let hooks &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; el.vm.hooks;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let hkey &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; hooks) {
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (el[hkey] &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; hooks[hkey].vnode2render) {
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;           &lt;span&gt;return&lt;/span&gt;&lt;span&gt; hooks[hkey].vnode2render(el, genElement);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不带hook的情况,这个就是普通的标签&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nodir(el)
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; nodir(el) {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;    let code
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换子节点&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    const children &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; genChildren(el, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    code &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; `_h(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;${el.tag}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;${
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;      }${
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;          children &lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt; `,${children}` : &lt;/span&gt;&lt;span&gt;''&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; children&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;    })`
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; code
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; genChildren(el, checkSkip) {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    const children &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; el.children
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (children.length) {
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;        const el &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; children[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是v-for&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (children.length &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; el.&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;           &lt;span&gt;return&lt;/span&gt;&lt;span&gt; genElement(el)
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        const normalizationType &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; `[${children.map(genNode).join(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)}]${
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;              checkSkip
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                   &lt;span&gt;?&lt;/span&gt;&lt;span&gt; normalizationType &lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt; `,${normalizationType}` : &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;      : &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;      }`
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将element转换为render函数&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; compileToFunctions(el) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;    let vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; el.vm;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;    let render &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; genElement(el);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;    render &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; `&lt;/span&gt;&lt;span&gt;with&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){ &lt;/span&gt;&lt;span&gt;debugger&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ${render}}`;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Function(render);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; genNode(node) {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node.type &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; genElement(node)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; genText(node)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; genText(text) {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; text.type &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt; text.expression : JSON.stringify(text.text)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们依旧定义个MVVM的类&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;  class MVVM {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;    constructor(options) {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$data &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; options.data;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.template &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; options.template;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将data中的数据装填到实例上,以便后续函数组装使用&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let name &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$data) {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;[name] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$data[name];
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.compile();
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析模板生成虚拟dom,这里是重要的一步将模板变成方法&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    compile() {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;      let element &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.html2Elment();
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.element &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; element;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.initHooks();
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setElDrictive(element);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为设置属性已经被我们手动做了这里便不需要处理了&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt; &lt;span&gt;      let hooks &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.hooks;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里,我们需要将有的钩子执行,主要是为了处理指令&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let hkey &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; hooks) {
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果对象上面已经装载了这个指令,并且具有模板到node的函数定义则执行&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里之所以需要模板上具有,因为对象数据需要在这里取&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(element[hkey] &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; hooks[hkey].template2Vnode) {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用这个钩子,事实上这个钩子要往对象实例上面加东西&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个会将循环相关的指令,比如要循环的对象放到for字段,将值放到alias,将迭代器属性关键词放到iterator&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt; &lt;span&gt;          hooks[hkey].template2Vnode(element, element[hkey], &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上面做了指令系统第一步,将模板中的属性存到element对应对象上,这里开始调用之&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$render &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; compileToFunctions(element)
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行渲染&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;      let vnode &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$render();
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; 
&lt;span&gt;134&lt;/span&gt; &lt;span&gt;      console.log(html, element, vnode)
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;       &lt;span&gt;debugger&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt; 
&lt;span&gt;140&lt;/span&gt; &lt;span&gt;    initHooks() {
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要处理的指令钩子,本来该放到prototype上&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.hooks &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;          template2Vnode: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (el, dir) {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(val, key, index) in arr&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt; &lt;span&gt;            let exp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; dir.expression
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for in 或者 for of 这种循环&lt;/span&gt;
&lt;span&gt;149&lt;/span&gt; &lt;span&gt;            const forAliasRE &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;(.*?)\s+(?:in|of)\s+(.*)&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;150&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出迭代器关键词&lt;/span&gt;
&lt;span&gt;151&lt;/span&gt; &lt;span&gt;            const forIteratorRE &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt; 
&lt;span&gt;153&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数组&lt;/span&gt;
&lt;span&gt;154&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(key ,index) in arr&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0] (key ,index) in arr,[1] (key ,index),[2] arr&lt;/span&gt;
&lt;span&gt;156&lt;/span&gt; &lt;span&gt;            const inMatch &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; exp.match(forAliasRE)
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;inMatch) {
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;              warn(`Invalid v&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; expression: ${exp}`)
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;               &lt;span&gt;return&lt;/span&gt;
&lt;span&gt;160&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; 
&lt;span&gt;162&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上面的正则其实是为了取出迭代器中的字符串,后面好组装函数&lt;/span&gt;
&lt;span&gt;163&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里开始重新组装对象上的for指令,这里把循环的对象指向了数组关键词&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt; &lt;span&gt;            el.&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; inMatch[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;].trim()
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(val, key, index)&lt;/span&gt;
&lt;span&gt;166&lt;/span&gt; &lt;span&gt;            let alias &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; inMatch[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].trim()
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; 
&lt;span&gt;168&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键词拿出来&lt;/span&gt;
&lt;span&gt;169&lt;/span&gt; &lt;span&gt;            const iteratorMatch &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; alias.match(forIteratorRE)
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (iteratorMatch) {
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;              el.alias &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; iteratorMatch[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].trim();
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;              el.iterator1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; iteratorMatch[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;].trim()
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (iteratorMatch[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]) {
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;                el.iterator2 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; iteratorMatch[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;].trim()
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;              el.alias &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; alias
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; 
&lt;span&gt;180&lt;/span&gt; &lt;span&gt;          },
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将node对象转换为函数&lt;/span&gt;
&lt;span&gt;182&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为之前已经用上面的函数&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将循环相关的指令,比如要循环的对象放到for字段,将值放到alias,将迭代器属性关键词放到iterator&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所以这里直接取出关键词使用即可&lt;/span&gt;
&lt;span&gt;185&lt;/span&gt; &lt;span&gt;          vnode2render: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (el, genElement) {
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个状态机&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(el.forProcessed) &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; 
&lt;span&gt;189&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出相关属性&lt;/span&gt;
&lt;span&gt;190&lt;/span&gt; &lt;span&gt;            let exp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; el.&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;            let alias &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; el.alias;
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; 
&lt;span&gt;193&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这个字符串里面的代码会执行,最新js语法&lt;/span&gt;
&lt;span&gt;194&lt;/span&gt; &lt;span&gt;            let iterator1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; el.iterator1 &lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt; `,${el.iterator1}` : &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;            let iterator2 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; el.iterator2 &lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt; `,${el.iterator2}` : &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; 
&lt;span&gt;197&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;198&lt;/span&gt; &lt;span&gt;            输出
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;             _l((arr), function(val,key,index) {
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;                console.log(arguments);
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;             })
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;203&lt;/span&gt; &lt;span&gt;            let _render &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; ` _l((${exp}), &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(${alias}${iterator1}${iterator2}) {
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;                console.log(arguments);
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ${genElement(el)}
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;              })
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;            `
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; &lt;span&gt;            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;render&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, _render);
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; 
&lt;span&gt;210&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _render
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; 
&lt;span&gt;212&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt;      };
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; 
&lt;span&gt;217&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;渲染for时,返回多个render&lt;/span&gt;
&lt;span&gt;218&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为_l调用的时候是处在mvvm实例作用域,所以这里传入的时候是一个数组&lt;/span&gt;
&lt;span&gt;219&lt;/span&gt; &lt;span&gt;    _l(val, render) {
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; &lt;span&gt;      let ret, i, l, keys, key
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Array.isArray(val) &lt;/span&gt;&lt;span&gt;||&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; val &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt; &lt;span&gt;        ret &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array(val.length)
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, l &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; val.length; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; l; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;          ret[i] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; render(val[i], i)
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; &lt;span&gt;      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; val &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;        ret &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array(val)
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; val; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;          ret[i] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; render(i &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, i)
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isObject(val)) {
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; &lt;span&gt;        keys &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Object.keys(val)
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt; &lt;span&gt;        ret &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array(keys.length)
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, l &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; keys.length; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; l; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;          key &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; keys[i]
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; &lt;span&gt;          ret[i] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; render(val[key], key, i)
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; 
&lt;span&gt;242&lt;/span&gt; &lt;span&gt;    _s(val) {
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; val &lt;/span&gt;&lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;
&lt;span&gt;244&lt;/span&gt;               &lt;span&gt;?&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;245&lt;/span&gt; &lt;span&gt;              : &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; val &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;246&lt;/span&gt;               &lt;span&gt;?&lt;/span&gt;&lt;span&gt; JSON.stringify(val, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; &lt;span&gt;              : String(val)
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt; 
&lt;span&gt;250&lt;/span&gt; &lt;span&gt;    _h(sel, data, children) {
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; 
&lt;span&gt;252&lt;/span&gt;       &lt;span&gt;debugger&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt; 
&lt;span&gt;254&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;
&lt;span&gt;255&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; 
&lt;span&gt;257&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析指令&lt;/span&gt;
&lt;span&gt;258&lt;/span&gt; &lt;span&gt;    setElDrictive(el) {
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析指令,这里主要是解析for与if&lt;/span&gt;
&lt;span&gt;260&lt;/span&gt; &lt;span&gt;      let attrs &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; el.attrs;
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt; 
&lt;span&gt;262&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断m-xxx这种类型的正则&lt;/span&gt;
&lt;span&gt;263&lt;/span&gt; &lt;span&gt;      const drictiveRE &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;^m\-(\w+)(\:[^\.]+)?\.?([^\:]+)?&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;264&lt;/span&gt; 
&lt;span&gt;265&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let name &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; attrs) {
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt; &lt;span&gt;        let darr &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; name.match(drictiveRE);
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(darr){
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt; 
&lt;span&gt;269&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有什么其他目的,就是将属性中的指令挪到对象上&lt;/span&gt;
&lt;span&gt;270&lt;/span&gt; &lt;span&gt;          el[darr[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt; &lt;span&gt;            name: darr[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt; &lt;span&gt;            expression: attrs[name],
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt; &lt;span&gt;            arg: darr[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; darr[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;].slice(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; 
&lt;span&gt;276&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt; 
&lt;span&gt;279&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt; 
&lt;span&gt;281&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将模板转换为js对象,这里要调用HTMLParser&lt;/span&gt;
&lt;span&gt;282&lt;/span&gt; &lt;span&gt;    html2Elment() {
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们这里简化代码,直接返回解析后的结果即可&lt;/span&gt;
&lt;span&gt;284&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...一大段调用htmlParser,包括递归调用生成js对象的过程,略&lt;/span&gt;
&lt;span&gt;285&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt; &lt;span&gt;        vm: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt; &lt;span&gt;        tag: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt; &lt;span&gt;        attrs: {
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt;           &lt;span&gt;'&lt;/span&gt;&lt;span&gt;m-for&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(val, key, index) in arr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;290&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt; &lt;span&gt;        children: [
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt; &lt;span&gt;          {
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt; &lt;span&gt;            type: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;294&lt;/span&gt; &lt;span&gt;            text: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;索引 {{key + 1}} ：{{val}}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt; &lt;span&gt;            expression: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;索引 &quot;+_s(key + 1)+&quot; ：&quot;+_s(val)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;296&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt; &lt;span&gt;        ]
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt; 
&lt;span&gt;300&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt; 
&lt;span&gt;302&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt; 
&lt;span&gt;304&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后我们在这里实例化即可&lt;/span&gt;
&lt;span&gt;305&lt;/span&gt;   &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MVVM({
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt; &lt;span&gt;    template: html,
&lt;/span&gt;&lt;span&gt;307&lt;/span&gt; &lt;span&gt;    data: {
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt; &lt;span&gt;      arr: [
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;叶小钗&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;素还真&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;一页书&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;310&lt;/span&gt; &lt;span&gt;      ]
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt; &lt;span&gt;  })
&lt;/span&gt;&lt;span&gt;313&lt;/span&gt; 
&lt;span&gt;314&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;315&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;316&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一大坨代码，是可运行的代码，其中打了很多断点写了很多注释，剔除了很多无用的代码，想要了解指令系统的朋友可以看看，这里如何自定义指令，大家也可以思考下是怎么实现的，今天的学习暂时到这里，我们明天来看看组件一块的实现&lt;/p&gt;
</description>
<pubDate>Sat, 06 Oct 2018 06:54:00 +0000</pubDate>
<dc:creator>叶小钗</dc:creator>
<og:description>接上文：一套代码小程序&amp;Web&amp;Native运行的探索04——数据更新 对应Git代码地址请见：https://github.com/yexiaochai/wxdemo/tree/ma</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yexiaochai/p/9742383.html</dc:identifier>
</item>
<item>
<title>《番茄工作法图解》一种优秀的时间管理方法 - yuanrw</title>
<link>http://www.cnblogs.com/yuanrw/p/9747251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanrw/p/9747251.html</guid>
<description>&lt;p&gt;    刚开始工作的时候，常常感觉效率低下，如果同时有好几件事情要做，就会忙不过来。因此，找了几本不错的书籍学习了一下时间管理。工作了之后才发现时间管理非常重要，提高工作的效率，可以为自己省出更多的时间做自己的事。比如每天学习一点知识，哪怕只有半个小时，久而久之也会有非常显著的效果。这篇随笔是读《番茄工作法图解：简单易行的时间管理方法》一书的笔记。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;番茄工作法&lt;/strong&gt;，简单地说，就是首先列出你当天要做的事，根据优先级排好队，设置25分钟闹钟，从第一件事开始做。此外还要有每日回顾、做每日承诺、控制中断、预估要花的功夫等。详细的说，有以下五个阶段：&lt;/p&gt;
&lt;h2&gt;计划&lt;/h2&gt;
&lt;p&gt;    在一天的开始，从积压的工作（活动清单）中提取最重要的活动，填写到“今日待办”表格中。这就是当天的自我承诺。什么是活动清单？它是你要做的所有事情的清单，每次来了一件新的事情，就立刻把它加到活动清单里面。每天早上，你需要从活动清单里挑出优先级最高、想要今天完成的事情，排好序，写到“今日待办”里面。要预估好工作量，能够在一天内完成，一般1~3件事就足够了。&lt;/p&gt;
&lt;h2&gt;跟踪&lt;/h2&gt;
&lt;p&gt;    确定当天活动之后，开始25分钟的番茄钟，从第一项开始进行，切记：一个番茄钟内只能专注做一件事情。番茄钟的时间因人而异，如果你是新手，也可以缩短为15分钟，如果你有自信长时间专注，那也可以适当延长。时间越长，被打断的几率就越大，因此不宜太长。&lt;/p&gt;
&lt;p&gt;    在每个番茄钟内，你要收集一些过程指标，比如计算遇到的中断次数。如果在家里，可以用厨房里的那种小扭蛋或者闹钟，但是声音比较大，在办公室可以用番茄钟软件，这类软件有很多的，我用的是be focused。用这类软件，你可以设定25分钟专注，3分钟休息，软件会自动一直连续下去。分别设置好开始工作和开始休息的音乐，久而久之就形成了条件反射，一听到开始工作的铃声人就立刻专注起来，听到休息的铃声就会进入放松状态。&lt;/p&gt;
&lt;h4&gt;中断&lt;/h4&gt;
&lt;p&gt;    电脑不要登录微信qq，把邮件和社交软件的通知关掉。避免中断。如果突然有新的临时任务，就把它写到活动清单中，最好不要打断当前的工作，等到这个番茄钟结束后，再按照优先级重新对列表里的工作排序，然后下一个番茄钟就从列表的第一件事情开始做。&lt;/p&gt;
&lt;h4&gt;休息&lt;/h4&gt;
&lt;p&gt;    休息的时候就应该彻底休息，可以离开座位，倒杯水、倒杯咖啡，活动一下肩膀，查看一下邮件和社交软件是否有新消息。但尽量不要回复邮件，回复邮件通常时间比较久，也应该也列入今日待办里面，专门为它安排时间，避免打乱本来的计划。总之在休息的这3~5分钟里，不能再想任何工作的事情。这样才是高质量的放松，能够充分提高下一个番茄钟的效率。一般在4~5个番茄钟结束后，可以安排一个长的休息（例如10~15分钟）。&lt;/p&gt;

&lt;p&gt;今日待办&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500605/201810/1500605-20181006141937938-230514229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;番茄钟&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1500605/201810/1500605-20181006142001373-1254857483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;记录和处理&lt;/h2&gt;
&lt;p&gt;    在一天结束时，将当天收集的数据归档，写入“记录”表格。可以记录每天完成了几个番茄钟，平均每个工作花费了多少番茄钟，如果数字很大，就尝试着拆分工作。检查今天给自己安排了几项工作，是否都完成了？如果没有完成，那原因是什么？是给自己安排的太多了，还是其他原因。明天早上安排工作的时候，就可以进行适当调整。每天对自己一天的工作进行分析和观察，从记录的数据中提取有用信息并总结，以便改进。&lt;/p&gt;
&lt;p&gt;    做完的工作就把它勾掉，一天下来，看到今天完成的工作，可能不多，但会很有成就感。过去我的时间管理比较糟糕，常常一天做了n件事情，但没有一件是彻底完成的。&lt;/p&gt;
&lt;h2&gt;可视化&lt;/h2&gt;
&lt;p&gt;    最终你要将信息以某种方式组织起来，可以做成可视化的图表，可以一周做一次。从中找出改进流程的思路。根据自己的工作习惯每天做自我调整。有经验了之后，每次给自己安排工作的时候，就可以预估每一项工作大概会用多少番茄钟来完成。久而久之就可以越来越熟练和精准地安排时间和工作。&lt;/p&gt;

&lt;p&gt;    最后，推荐几本时间管理的书籍，都是挺有名的、口碑不错的，我自己读下来也觉得非常有收获的：《番茄工作法图解：简单易行的时间管理方法》、《小强升职记》、拖延症晚期的同学可以读《拖延心理学》、《晨间日记的奇迹》可以帮助克服熬夜，养成早睡早起的好习惯。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Oct 2018 06:10:00 +0000</pubDate>
<dc:creator>yuanrw</dc:creator>
<og:description>刚开始工作的时候，常常感觉效率低下，如果同时有好几件事情要做，就会忙不过来。因此，找了几本不错的书籍学习了一下时间管理。工作了之后才发现时间管理非常重要，提高工作的效率，可以为自己省出更多的时间做自己</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanrw/p/9747251.html</dc:identifier>
</item>
<item>
<title>30分钟了解Springboot整合Shiro - 冷豪</title>
<link>http://www.cnblogs.com/learnhow/p/9747134.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnhow/p/9747134.html</guid>
<description>&lt;p&gt;前言：06年7月的某日，不才创作了一篇题为《&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/learnhow/p/5694876.html&quot; target=&quot;_blank&quot;&gt;30分钟学会如何使用Shiro&lt;/a&gt;》的文章。不在意之间居然斩获了22万的阅读量，许多人因此加了我的联系方式咨询源码工程，只可惜当时并没有专门保留。2年后的今天在机缘巧合之下，我又重拾此话题。希望能带给小伙伴们在Springboot下如何使用Shiro，当然若各位感兴趣我还希望之后能创作一些与它有关的更加深入的知识。作为一个知识分享型博主，我希望能够帮助大家尽快上手。因此我尽可能去除了与整合无关的干扰因素，方便大家只要按照文章的思路就一定能有所收获。&lt;/p&gt;
&lt;p&gt;项目结构截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/871676/201810/871676-20181006114038025-873281744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目在结构上没有任何特殊之处，基本就是MVC的传统结构重点需要关注的是3个Entity类、2个Controller类和1个Config类。&lt;/p&gt;
&lt;p&gt;首先，提供pom的完整文档结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.learnhow.springboot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0.4.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-jpa&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.shiro&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;shiro-spring&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.4.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-devtools&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;optional&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;optional&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其次，创建数据库和表结构。由于我们采用jpa作为数据库持久层框架，因此我们将建表的任务交给框架自动完成，我们只需要在entity中写清楚对应关系即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
CREATE DATABASE enceladus;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; enceladus是数据库的名称&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;application.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
   port: 8088
spring:
   application:
      name: shiro
   datasource:
      url: jdbc:mysql://192.168.31.37:3306/enceladus
      username: root
      password: 12345678
      driver-class-name: com.mysql.jdbc.Driver
   jpa:
      database: mysql
      showSql: true
      hibernate:
         ddlAuto: update
      properties:
         hibernate:
            dialect: org.hibernate.dialect.MySQL5Dialect
            format_sql: true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最基础的Shiro配置至少需要三张主表分别代表用户（user）、角色（role）、权限（permission），用户和角色，角色与权限之间都是ManyToMany的对应关系，不熟悉实体对应关系的小伙伴可以先去熟悉一下Hibernate。&lt;/p&gt;
&lt;p&gt;User.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_aad6fc5a-b7b4-414a-afd3-274e866a499e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_aad6fc5a-b7b4-414a-afd3-274e866a499e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aad6fc5a-b7b4-414a-afd3-274e866a499e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.FetchType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinColumn;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinTable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.ManyToMany;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

@Entity
@Table(name &lt;/span&gt;= &quot;user_t&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = -3320971805590503443L&lt;span&gt;;
    @Id
    @GeneratedValue
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String salt;
    @ManyToMany(fetch &lt;/span&gt;=&lt;span&gt; FetchType.EAGER)
    @JoinTable(name &lt;/span&gt;= &quot;user_role_t&quot;, joinColumns = { @JoinColumn(name = &quot;uid&quot;) }, inverseJoinColumns =&lt;span&gt; {
            @JoinColumn(name &lt;/span&gt;= &quot;rid&quot;&lt;span&gt;) })
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;SysRole&amp;gt;&lt;span&gt; roles;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; password;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSalt() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; salt;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSalt(String salt) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.salt =&lt;span&gt; salt;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;SysRole&amp;gt;&lt;span&gt; getRoles() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roles;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setRoles(List&amp;lt;SysRole&amp;gt;&lt;span&gt; roles) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roles =&lt;span&gt; roles;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCredentialsSalt() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; username + salt +&lt;span&gt; salt;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;]&quot;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;user&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;SysRole.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_99b3a66d-e1e5-46dd-ac15-979b204b1460&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_99b3a66d-e1e5-46dd-ac15-979b204b1460&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_99b3a66d-e1e5-46dd-ac15-979b204b1460&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.FetchType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinColumn;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinTable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.ManyToMany;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

@Entity
@Table(name &lt;/span&gt;= &quot;role_t&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SysRole &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = -8687790154329829056L&lt;span&gt;;
    @Id
    @GeneratedValue
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String role;
    @ManyToMany(fetch &lt;/span&gt;=&lt;span&gt; FetchType.EAGER)
    @JoinTable(name &lt;/span&gt;= &quot;role_permission_t&quot;, joinColumns = { @JoinColumn(name = &quot;rid&quot;) }, inverseJoinColumns =&lt;span&gt; {
            @JoinColumn(name &lt;/span&gt;= &quot;pid&quot;&lt;span&gt;) })
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;SysPermission&amp;gt;&lt;span&gt; permissions;
    @ManyToMany
    @JoinTable(name &lt;/span&gt;= &quot;user_role_t&quot;, joinColumns = { @JoinColumn(name = &quot;rid&quot;) }, inverseJoinColumns =&lt;span&gt; {
            @JoinColumn(name &lt;/span&gt;= &quot;uid&quot;&lt;span&gt;) })
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; users;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRole() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; role;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRole(String role) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.role =&lt;span&gt; role;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;SysPermission&amp;gt;&lt;span&gt; getPermissions() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; permissions;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPermissions(List&amp;lt;SysPermission&amp;gt;&lt;span&gt; permissions) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.permissions =&lt;span&gt; permissions;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; getUsers() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; users;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUsers(List&amp;lt;User&amp;gt;&lt;span&gt; users) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.users =&lt;span&gt; users;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;role&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;SysPermission.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_568352e9-d2e9-4b63-bdb8-54afc68a9893&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_568352e9-d2e9-4b63-bdb8-54afc68a9893&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_568352e9-d2e9-4b63-bdb8-54afc68a9893&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Entity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.GeneratedValue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Id;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinColumn;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.JoinTable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.ManyToMany;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.persistence.Table;

@Entity
@Table(name &lt;/span&gt;= &quot;permission_t&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SysPermission &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 353629772108330570L&lt;span&gt;;
    @Id
    @GeneratedValue
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    @ManyToMany
    @JoinTable(name &lt;/span&gt;= &quot;role_permission_t&quot;, joinColumns = { @JoinColumn(name = &quot;pid&quot;) }, inverseJoinColumns =&lt;span&gt; {
            @JoinColumn(name &lt;/span&gt;= &quot;rid&quot;&lt;span&gt;) })
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;SysRole&amp;gt;&lt;span&gt; roles;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;SysRole&amp;gt;&lt;span&gt; getRoles() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; roles;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setRoles(List&amp;lt;SysRole&amp;gt;&lt;span&gt; roles) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.roles =&lt;span&gt; roles;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;perm&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在注明对应关系以后，jpa会帮助我们创建3张实体表和2张中间表：&lt;/p&gt;
&lt;p&gt;最后我们还需要初始化一些基础数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
INSERT INTO `permission_t` VALUES (1, 'Retrieve'&lt;span&gt;);
INSERT INTO `permission_t` VALUES (&lt;/span&gt;2, 'Create'&lt;span&gt;);
INSERT INTO `permission_t` VALUES (&lt;/span&gt;3, 'Update'&lt;span&gt;);
INSERT INTO `permission_t` VALUES (&lt;/span&gt;4, 'Delete'&lt;span&gt;);
INSERT INTO `role_t` VALUES (&lt;/span&gt;1, 'guest'&lt;span&gt;);
INSERT INTO `role_t` VALUES (&lt;/span&gt;2, 'user'&lt;span&gt;);
INSERT INTO `role_t` VALUES (&lt;/span&gt;3, 'admin'&lt;span&gt;);
INSERT INTO `role_permission_t` VALUES (&lt;/span&gt;1, 1&lt;span&gt;);
INSERT INTO `role_permission_t` VALUES (&lt;/span&gt;1, 2&lt;span&gt;);
INSERT INTO `role_permission_t` VALUES (&lt;/span&gt;2, 2&lt;span&gt;);
INSERT INTO `role_permission_t` VALUES (&lt;/span&gt;3, 2&lt;span&gt;);
INSERT INTO `role_permission_t` VALUES (&lt;/span&gt;1, 3&lt;span&gt;);
INSERT INTO `role_permission_t` VALUES (&lt;/span&gt;2, 3&lt;span&gt;);
INSERT INTO `role_permission_t` VALUES (&lt;/span&gt;3, 3&lt;span&gt;);
INSERT INTO `role_permission_t` VALUES (&lt;/span&gt;4, 3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，前期的准备工作已经完成。下面为了让Shiro能够在项目中生效我们需要通过代码的方式提供配置信息。Shiro的安全管理提供了两个层面的控制：（1）用户认证：需要用户通过登陆证明你是你自己。（2）权限控制：在证明了你是你自己的基础上系统为当前用户赋予权限。后者我们已经在数据库中完成了大部分配置。&lt;/p&gt;
&lt;p&gt;用户认证的常规手段就是登陆认证，在目前的情况下我们认为只有用户自己知道登陆密码。不过Shiro为我们做的更多，它还提供了一套能够很方便我们使用的密码散列算法。因为普通的散列技巧可以很容易的通过暴力手段破解，我们可以在散列的过程中加入一定的算法复杂度（增加散列次数与Salt）从而解决这样的问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.crypto.RandomNumberGenerator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.crypto.SecureRandomNumberGenerator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.crypto.hash.SimpleHash;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.util.ByteSource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learnhow.springboot.web.entity.User;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PasswordHelper {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; RandomNumberGenerator randomNumberGenerator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SecureRandomNumberGenerator();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ALGORITHM_NAME = &quot;md5&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基础散列算法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HASH_ITERATIONS = 2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义散列次数&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; encryptPassword(User user) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机字符串作为salt因子，实际参与运算的salt我们还引入其它干扰因子&lt;/span&gt;
&lt;span&gt;        user.setSalt(randomNumberGenerator.nextBytes().toHex());
        String newPassword &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleHash(ALGORITHM_NAME, user.getPassword(),
                ByteSource.Util.bytes(user.getCredentialsSalt()), HASH_ITERATIONS).toHex();
        user.setPassword(newPassword);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个类帮助我们解决用户注册的密码散列问题，当然我们还需要使用同样的算法来保证在登陆的时候密码能够被散列成相同的字符串。如果两次散列的结果不同系统就无法完成密码比对，因此在计算散列因子的时候我们不能引入变量，例如我们可以将username作为salt因子加入散列算法，但是不能选择password或datetime，具体原因各位请手动测试。&lt;/p&gt;
&lt;p&gt;另外为了帮助Shiro能够正确为当前登陆用户做认证和赋权，我们需要实现自定义的Realm。具体来说就是实现doGetAuthenticationInfo和doGetAuthorizationInfo，这两个方法前者负责登陆认证后者负责提供一个权限信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.authc.AuthenticationException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.authc.AuthenticationInfo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.authc.AuthenticationToken;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.authc.SimpleAuthenticationInfo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.authz.AuthorizationInfo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.authz.SimpleAuthorizationInfo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.realm.AuthorizingRealm;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.subject.PrincipalCollection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.util.ByteSource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learnhow.springboot.web.entity.SysPermission;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learnhow.springboot.web.entity.SysRole;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learnhow.springboot.web.entity.User;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learnhow.springboot.web.service.UserService;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EnceladusShiroRealm &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AuthorizingRealm {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService userService;

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        SimpleAuthorizationInfo authorizationInfo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleAuthorizationInfo();
        String username &lt;/span&gt;=&lt;span&gt; (String) principals.getPrimaryPrincipal();
        
        User user &lt;/span&gt;=&lt;span&gt; userService.findUserByName(username);
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (SysRole role : user.getRoles()) {
            authorizationInfo.addRole(role.getRole());
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (SysPermission permission : role.getPermissions()) {
                authorizationInfo.addStringPermission(permission.getName());
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; authorizationInfo;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; AuthenticationException {
        String username &lt;/span&gt;=&lt;span&gt; (String) token.getPrincipal();
        User user &lt;/span&gt;=&lt;span&gt; userService.findUserByName(username);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        SimpleAuthenticationInfo authenticationInfo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleAuthenticationInfo(user.getUsername(), user.getPassword(),
                ByteSource.Util.bytes(user.getCredentialsSalt()), getName());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; authenticationInfo;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还记得前面我们说过，认证的时候我们需要提供相同的散列算法吗？可是在上面的代码里，我们并未提供。那么Shiro是怎么做的呢？AuthorizingRealm是一个抽象类，我们会在另外的配置文件里向它提供基础算法与散列次数这两个变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.authc.credential.HashedCredentialsMatcher;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.mgt.SecurityManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.spring.web.ShiroFilterFactoryBean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.web.mgt.DefaultWebSecurityManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;

@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShiroConfig {
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);

        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; filterChainDefinitionMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
        shiroFilterFactoryBean.setLoginUrl(&lt;/span&gt;&quot;/login&quot;&lt;span&gt;);
        shiroFilterFactoryBean.setUnauthorizedUrl(&lt;/span&gt;&quot;/unauthc&quot;&lt;span&gt;);
        shiroFilterFactoryBean.setSuccessUrl(&lt;/span&gt;&quot;/home/index&quot;&lt;span&gt;);
        
        filterChainDefinitionMap.put(&lt;/span&gt;&quot;/*&quot;, &quot;anon&quot;&lt;span&gt;);
        filterChainDefinitionMap.put(&lt;/span&gt;&quot;/authc/index&quot;, &quot;authc&quot;&lt;span&gt;);
        filterChainDefinitionMap.put(&lt;/span&gt;&quot;/authc/admin&quot;, &quot;roles[admin]&quot;&lt;span&gt;);
        filterChainDefinitionMap.put(&lt;/span&gt;&quot;/authc/renewable&quot;, &quot;perms[Create,Update]&quot;&lt;span&gt;);
        filterChainDefinitionMap.put(&lt;/span&gt;&quot;/authc/removable&quot;, &quot;perms[Delete]&quot;&lt;span&gt;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; shiroFilterFactoryBean;
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HashedCredentialsMatcher hashedCredentialsMatcher() {
        HashedCredentialsMatcher hashedCredentialsMatcher &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashedCredentialsMatcher();
        hashedCredentialsMatcher.setHashAlgorithmName(PasswordHelper.ALGORITHM_NAME); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 散列算法&lt;/span&gt;
        hashedCredentialsMatcher.setHashIterations(PasswordHelper.HASH_ITERATIONS); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 散列次数&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashedCredentialsMatcher;
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EnceladusShiroRealm shiroRealm() {
        EnceladusShiroRealm shiroRealm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EnceladusShiroRealm();
        shiroRealm.setCredentialsMatcher(hashedCredentialsMatcher()); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原来在这里&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; shiroRealm;
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SecurityManager securityManager() {
        DefaultWebSecurityManager securityManager &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultWebSecurityManager();
        securityManager.setRealm(shiroRealm());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; securityManager;
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PasswordHelper passwordHelper() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PasswordHelper();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，我们将目光集中到上文的shirFilter方法中。Shiro通过一系列filter来控制访问权限，并在它的内部为我们预先定义了多个过滤器，我们可以直接通过字符串配置这些过滤器。&lt;/p&gt;
&lt;p&gt;常用的过滤器如下：&lt;/p&gt;
&lt;p&gt;authc：所有已登陆用户可访问&lt;/p&gt;
&lt;p&gt;roles：有指定角色的用户可访问，通过[ ]指定具体角色，这里的角色名称与数据库中配置一致&lt;/p&gt;
&lt;p&gt;perms：有指定权限的用户可访问，通过[ ]指定具体权限，这里的权限名称与数据库中配置一致&lt;/p&gt;
&lt;p&gt;anon：所有用户可访问，通常作为指定页面的静态资源时使用&lt;/p&gt;
&lt;p&gt;为了测试方便我们不引入页面配置直接通过rest方式访问&lt;/p&gt;
&lt;p&gt;不受权限控制访问的地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.SecurityUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.authc.IncorrectCredentialsException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.authc.UnknownAccountException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.authc.UsernamePasswordToken;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.subject.Subject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestParam;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learnhow.springboot.web.PasswordHelper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learnhow.springboot.web.entity.User;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learnhow.springboot.web.service.UserService;

@RestController
@RequestMapping
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService userService;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PasswordHelper passwordHelper;

    @GetMapping(&lt;/span&gt;&quot;login&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object login() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Here is Login page&quot;&lt;span&gt;;
    }

    @GetMapping(&lt;/span&gt;&quot;unauthc&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object unauthc() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Here is Unauthc page&quot;&lt;span&gt;;
    }

    @GetMapping(&lt;/span&gt;&quot;doLogin&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object doLogin(@RequestParam String username, @RequestParam String password) {
        UsernamePasswordToken token &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UsernamePasswordToken(username, password);
        Subject subject &lt;/span&gt;=&lt;span&gt; SecurityUtils.getSubject();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            subject.login(token);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IncorrectCredentialsException ice) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;password error!&quot;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnknownAccountException uae) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;username error!&quot;&lt;span&gt;;
        }

        User user &lt;/span&gt;=&lt;span&gt; userService.findUserByName(username);
        subject.getSession().setAttribute(&lt;/span&gt;&quot;user&quot;&lt;span&gt;, user);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;SUCCESS&quot;&lt;span&gt;;
    }

    @GetMapping(&lt;/span&gt;&quot;register&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object register(@RequestParam String username, @RequestParam String password) {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setUsername(username);
        user.setPassword(password);
        passwordHelper.encryptPassword(user);

        userService.saveUser(user);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;SUCCESS&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要指定权限可以访问的地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.SecurityUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.shiro.subject.Subject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learnhow.springboot.web.entity.User;

@RestController
@RequestMapping(&lt;/span&gt;&quot;authc&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthcController {

    @GetMapping(&lt;/span&gt;&quot;index&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object index() {
        Subject subject &lt;/span&gt;=&lt;span&gt; SecurityUtils.getSubject();
        User user &lt;/span&gt;= (User) subject.getSession().getAttribute(&quot;user&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user.toString();
    }

    @GetMapping(&lt;/span&gt;&quot;admin&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object admin() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Welcome Admin&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; delete&lt;/span&gt;
    @GetMapping(&quot;removable&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object removable() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;removable&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; insert &amp;amp; update&lt;/span&gt;
    @GetMapping(&quot;renewable&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object renewable() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;renewable&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样，我们对在Springboot下如何使用Shiro的介绍就告一段落，有希望看到后续更加深入文章的小伙伴欢迎踊跃马克。另外，大部分代码我已经在文章中提供如果需要源码的小伙伴也可以@我。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Oct 2018 05:06:00 +0000</pubDate>
<dc:creator>冷豪</dc:creator>
<og:description>前言：06年7月的某日，不才创作了一篇题为《30分钟学会如何使用Shiro》的文章。不在意之间居然斩获了22万的阅读量，许多人因此加了我的联系方式咨询源码工程，只可惜当时并没有专门保留。2年后的今天在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learnhow/p/9747134.html</dc:identifier>
</item>
<item>
<title>Flutter 布局（二）- Padding、Align、Center详解 - Q吹个大气球Q</title>
<link>http://www.cnblogs.com/holy-loki/p/9735045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/holy-loki/p/9735045.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文主要介绍Flutter布局中的Padding、Align以及Center控件，详细介绍了其布局行为以及使用场景，并对源码进行了分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;padding&quot;&gt;1. Padding&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;A widget that insets its child by the given padding.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简介&quot;&gt;1.1 简介&lt;/h3&gt;
&lt;p&gt;Padding在Flutter中用的也挺多的，作为一个基础的控件，功能非常单一，给子节点设置padding属性。写过其他端的都了解这个属性，就是设置内边距属性，内边距的空白区域，也是widget的一部分。&lt;/p&gt;
&lt;p&gt;Flutter中并没有单独的Margin控件，在Container中有margin属性，看源码关于margin的实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (margin != null)
  current = new Padding(padding: margin, child: current);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难看出，Flutter中淡化了margin以及padding的区别，margin实质上也是由Padding实现的。&lt;/p&gt;
&lt;h3 id=&quot;布局行为&quot;&gt;1.2 布局行为&lt;/h3&gt;
&lt;p&gt;Padding的布局分为两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当child为空的时候，会产生一个宽为left+right，高为top+bottom的区域；&lt;/li&gt;
&lt;li&gt;当child不为空的时候，Padding会将布局约束传递给child，根据设置的padding属性，缩小child的布局尺寸。然后Padding将自己调整到child设置了padding属性的尺寸，在child周围创建空白区域。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;继承关系&quot;&gt;1.3 继承关系&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Object &amp;gt; Diagnosticable &amp;gt; DiagnosticableTree &amp;gt; Widget &amp;gt; RenderObjectWidget &amp;gt; SingleChildRenderObjectWidget &amp;gt; Padding&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从继承关系可以看出，Padding控件是一个基础控件，不像Container这种组合控件。Container中的margin以及padding属性都是利用Padding控件去实现的。&lt;/p&gt;
&lt;h4 id=&quot;关于singlechildrenderobjectwidget&quot;&gt;1.3.1 关于SingleChildRenderObjectWidget&lt;/h4&gt;
&lt;p&gt;SingleChildRenderObjectWidget是RenderObjectWidgets的一个子类，用于限制只能有一个子节点。它只提供child的存储，而不提供实际的更新逻辑。&lt;/p&gt;
&lt;h4 id=&quot;关于renderobjectwidgets&quot;&gt;1.3.2 关于RenderObjectWidgets&lt;/h4&gt;
&lt;p&gt;RenderObjectWidgets为RenderObjectElement提供配置，而RenderObjectElement包含着（wrap）RenderObject，RenderObject则是在应用中提供实际的绘制（rendering）的元素。&lt;/p&gt;
&lt;h3 id=&quot;示例代码&quot;&gt;1.4 示例代码&lt;/h3&gt;
&lt;p&gt;实例代码直接上官方的例子，非常的简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new Padding(
  padding: new EdgeInsets.all(8.0),
  child: const Card(child: const Text('Hello World!')),
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子中对Card设置了一个宽度为8的内边距。&lt;/p&gt;
&lt;h3 id=&quot;源码解析&quot;&gt;1.5 源码解析&lt;/h3&gt;
&lt;p&gt;构造函数如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const Padding({
    Key key,
    @required this.padding,
    Widget child,
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;包含一个padding属性，相当的简单。&lt;/p&gt;
&lt;h4 id=&quot;属性解析&quot;&gt;1.5.1 属性解析&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;padding&lt;/strong&gt;：padding的类型为&lt;code&gt;EdgeInsetsGeometry&lt;/code&gt;，EdgeInsetsGeometry是EdgeInsets以及EdgeInsetsDirectional的基类。在实际使用中不涉及到国际化，例如适配阿拉伯地区等，一般都是使用EdgeInsets。EdgeInsetsDirectional光看命名就知道跟方向相关，因此它的四个边距不限定上下左右，而是根据方向来定的。&lt;/p&gt;
&lt;h4 id=&quot;源码&quot;&gt;1.5.2 源码&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@override
  RenderPadding createRenderObject(BuildContext context) {
    return new RenderPadding(
      padding: padding,
      textDirection: Directionality.of(context),
   );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Padding的创建函数，实际上是由&lt;code&gt;RenderPadding&lt;/code&gt;来进行的。&lt;/p&gt;
&lt;p&gt;关于RenderPadding的实际布局表现，当child为null的时候：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (child == null) {
  size = constraints.constrain(new Size(
    _resolvedPadding.left + _resolvedPadding.right,
    _resolvedPadding.top + _resolvedPadding.bottom
  ));
  return;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回一个宽为_resolvedPadding.left+_resolvedPadding.right，高为_resolvedPadding.top+_resolvedPadding.bottom的区域。&lt;/p&gt;
&lt;p&gt;当child不为null的时候，经历了三个过程，即调整child尺寸、调整child位置以及调整Padding尺寸，最终达到实际的布局效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 调整child尺寸
final BoxConstraints innerConstraints = constraints.deflate(_resolvedPadding);
child.layout(innerConstraints, parentUsesSize: true);

// 调整child位置
final BoxParentData childParentData = child.parentData;
childParentData.offset = new Offset(_resolvedPadding.left, _resolvedPadding.top);

// 调整Padding尺寸
size = constraints.constrain(new Size(
  _resolvedPadding.left + child.size.width + _resolvedPadding.right,
  _resolvedPadding.top + child.size.height + _resolvedPadding.bottom
));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此处，上面介绍的padding布局行为就解释的通了。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;1.6 使用场景&lt;/h3&gt;
&lt;p&gt;Padding本身还是挺简单的，基本上需要间距的地方，它都能够使用。如果在单一的间距场景，使用Padding比Container的成本要小一些，毕竟Container里面包含了多个widget。Padding能够实现的，Container都能够实现，只不过，Container更加的复杂。&lt;/p&gt;
&lt;h2 id=&quot;align&quot;&gt;2. Align&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;A widget that aligns its child within itself and optionally sizes itself based on the child's size.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简介-1&quot;&gt;2.1 简介&lt;/h3&gt;
&lt;p&gt;在其他端的开发，Align一般都是当做一个控件的属性，并没有拿出来当做一个单独的控件。Align本身实现的功能并不复杂，设置child的对齐方式，例如居中、居左居右等，并根据child尺寸调节自身尺寸。&lt;/p&gt;
&lt;h3 id=&quot;布局行为-1&quot;&gt;2.2 布局行为&lt;/h3&gt;
&lt;p&gt;Align的布局行为分为两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当widthFactor和heightFactor为null的时候，当其有限制条件的时候，Align会根据限制条件尽量的扩展自己的尺寸，当没有限制条件的时候，会调整到child的尺寸；&lt;/li&gt;
&lt;li&gt;当widthFactor或者heightFactor不为null的时候，Aligin会根据factor属性，扩展自己的尺寸，例如设置widthFactor为2.0的时候，那么，Align的宽度将会是child的两倍。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Align为什么会有这样的布局行为呢？原因很简单，设置对齐方式的话，如果外层元素尺寸不确定的话，内部的对齐就无法确定。因此，会有宽高因子、根据外层限制扩大到最大尺寸、外层不确定时调整到child尺寸这些行为。&lt;/p&gt;
&lt;h3 id=&quot;继承关系-1&quot;&gt;2.3 继承关系&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Object &amp;gt; Diagnosticable &amp;gt; DiagnosticableTree &amp;gt; Widget &amp;gt; RenderObjectWidget &amp;gt; SingleChildRenderObjectWidget &amp;gt; Align&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，Align跟Padding一样，也是一个非常基础的组件，Container中的align属性，也是使用Align去实现的。&lt;/p&gt;
&lt;h3 id=&quot;示例代码-1&quot;&gt;2.4 示例代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;new Align(
  alignment: Alignment.center,
  widthFactor: 2.0,
  heightFactor: 2.0,
  child: new Text(&quot;Align&quot;),
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子依旧很简单，设置一个宽高为child两倍区域的Align，其child处在正中间。&lt;/p&gt;
&lt;h3 id=&quot;源码解析-1&quot;&gt;2.5 源码解析&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;const Align({
    Key key,
    this.alignment: Alignment.center,
    this.widthFactor,
    this.heightFactor,
    Widget child
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Align的构造函数基本上就是宽高因子、对齐方式属性。日常使用中，宽高因子属性基本上用的不多。如果是复杂的布局，Container内部的align属性也可以实现相同的效果。&lt;/p&gt;
&lt;h4 id=&quot;属性解析-1&quot;&gt;2.5.1 属性解析&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;alignment&lt;/em&gt;&lt;/strong&gt;：对齐方式，一般会使用系统默认提供的9种方式，但是并不是说只有这9种，例如如下的定义。系统提供的9种方式只是预先定义好的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// The top left corner.
static const Alignment topLeft = const Alignment(-1.0, -1.0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Alignment实际上是包含了两个属性的，其中第一个参数，-1.0是左边对齐，1.0是右边对齐，第二个参数，-1.0是顶部对齐，1.0是底部对齐。根据这个规则，我们也可以自定义我们需要的对齐方式，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// 居右高于底部1/4处.
static const Alignment rightHalfBottom = alignment: const Alignment(1.0, 0.5),&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;widthFactor&lt;/em&gt;&lt;/strong&gt;：宽度因子，如果设置的话，Align的宽度就是child的宽度乘以这个值，不能为负数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;heightFactor&lt;/em&gt;&lt;/strong&gt;：高度因子，如果设置的话，Align的高度就是child的高度乘以这个值，不能为负数。&lt;/p&gt;
&lt;h4 id=&quot;源码-1&quot;&gt;2.5.2 源码&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@override
  RenderPositionedBox createRenderObject(BuildContext context) {
    return new RenderPositionedBox(
      alignment: alignment,
      widthFactor: widthFactor,
      heightFactor: heightFactor,
      textDirection: Directionality.of(context),
    );
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Align的实际构造调用的是&lt;code&gt;RenderPositionedBox&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;RenderPositionedBox的布局表现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 根据_widthFactor、_heightFactor以及限制因素来确定宽高
final bool shrinkWrapWidth = _widthFactor != null || constraints.maxWidth == double.infinity;
final bool shrinkWrapHeight = _heightFactor != null || constraints.maxHeight == double.infinity;

if (child != null) {
  //  如果child不为null，则根据规则设置Align的宽高，如果需要缩放，则根据_widthFactor是否为null来进行缩放，如果不需要，则尽量扩展。
  child.layout(constraints.loosen(), parentUsesSize: true);
  size = constraints.constrain(new Size(shrinkWrapWidth ? child.size.width * (_widthFactor ?? 1.0) : double.infinity,
                                        shrinkWrapHeight ? child.size.height * (_heightFactor ?? 1.0) : double.infinity));
  alignChild();
} else {
  // 如果child为null，如果需要缩放，则变为0，否则就尽量扩展
  size = constraints.constrain(new Size(shrinkWrapWidth ? 0.0 : double.infinity,
                                        shrinkWrapHeight ? 0.0 : double.infinity));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用场景-1&quot;&gt;2.6 使用场景&lt;/h3&gt;
&lt;p&gt;一般在对齐场景下使用，例如需要右对齐或者底部对齐之类的。它能够实现的功能，Container都能实现。&lt;/p&gt;
&lt;h2 id=&quot;center&quot;&gt;3. Center&lt;/h2&gt;
&lt;p&gt;Center继承自Align，只不过是将alignment设置为Alignment.center，其他属性例如widthFactor、heightFactor，布局行为，都与Align完全一样，在这里就不再单独做介绍了。Center源码如下，没有设置alignment属性，是因为Align默认的对齐方式就是居中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Center extends Align {
  /// Creates a widget that centers its child.
  const Center({ Key key, double widthFactor, double heightFactor, Widget child })
    : super(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;后话&quot;&gt;4. 后话&lt;/h2&gt;
&lt;p&gt;笔者建了一个flutter学习相关的项目，&lt;a href=&quot;https://github.com/yang7229693/flutter-study&quot;&gt;github地址&lt;/a&gt;，里面包含了笔者写的关于flutter学习相关的一些文章，会定期更新，也会上传一些学习demo，欢迎大家关注。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;5. 参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://docs.flutter.io/flutter/widgets/Padding-class.html&quot;&gt;Padding class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.flutter.io/flutter/painting/EdgeInsetsGeometry-class.html&quot;&gt;EdgeInsetsGeometry class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.flutter.io/flutter/painting/EdgeInsets-class.html&quot;&gt;EdgeInsets class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.flutter.io/flutter/painting/EdgeInsetsDirectional-class.html&quot;&gt;EdgeInsetsDirectional class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.flutter.io/flutter/rendering/RenderPadding-class.html&quot;&gt;RenderPadding class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.flutter.io/flutter/widgets/Align-class.html&quot;&gt;Align class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.flutter.io/flutter/widgets/Center-class.html&quot;&gt;Center class&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 06 Oct 2018 05:00:00 +0000</pubDate>
<dc:creator>Q吹个大气球Q</dc:creator>
<og:description>本文主要介绍Flutter布局中的Padding、Align以及Center控件，详细介绍了其布局行为以及使用场景，并对源码进行了分析。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/holy-loki/p/9735045.html</dc:identifier>
</item>
<item>
<title>django框架--视图系统 - zzzzou</title>
<link>http://www.cnblogs.com/zzzlw/p/9747058.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzzlw/p/9747058.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;一视图函数的理解&quot;&gt;一、视图函数的理解&lt;/h2&gt;
&lt;p&gt;视图函数的作用是，对指定的&lt;code&gt;url&lt;/code&gt;执行业务逻辑，视图函数将会作为&lt;code&gt;model&lt;/code&gt;层和&lt;code&gt;template&lt;/code&gt;层的桥梁，最主要的逻辑是操作数据库以及完成模板渲染前的上下文准备。&lt;br/&gt;视图系统的模块：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;请求对象&lt;/li&gt;
&lt;li&gt;业务逻辑&lt;br/&gt;2.1 连接&lt;code&gt;model&lt;/code&gt;层&lt;br/&gt;2.2 连接&lt;code&gt;template&lt;/code&gt;层&lt;/li&gt;
&lt;li&gt;响应对象&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二视图函数的定位&quot;&gt;二、视图函数的定位&lt;/h2&gt;
&lt;p&gt;所有实现&lt;code&gt;wsgi&lt;/code&gt;协议的&lt;code&gt;web&lt;/code&gt;框架都必须实现如下接口形式的&lt;code&gt;application&lt;/code&gt;函数，完成对&lt;code&gt;http&lt;/code&gt;请求的&lt;code&gt;http&lt;/code&gt;响应，&lt;code&gt;web&lt;/code&gt;应用程序和&lt;code&gt;web&lt;/code&gt;服务器的分界即从此函数开始。&lt;br/&gt;&lt;code&gt;application&lt;/code&gt;函数在&lt;code&gt;web&lt;/code&gt;应用程序中被定义，而在&lt;code&gt;wsgi&lt;/code&gt;服务器(&lt;code&gt;web&lt;/code&gt;服务器)上被无限循环调用，在&lt;code&gt;django&lt;/code&gt;中，&lt;code&gt;application&lt;/code&gt;函数中会通过路由系统根据&lt;code&gt;url&lt;/code&gt;来寻找对应的&lt;code&gt;view&lt;/code&gt;，然后执行&lt;code&gt;view&lt;/code&gt;视图函数处理业务逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 伪代码

def application(environ, start_response):
    # 此函数在web应用程序上被定义，在web服务器上被无限循环调用
    view = route(environ.url)  # 路由系统
    response = view(environ, *args, **kw)  # 视图系统

    return response&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;django视图功能定位图示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181006121606605-1315950066.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视图函数的本质作用就是：接收一个&lt;code&gt;reqeust&lt;/code&gt;请求，正确处理，然后返回一个&lt;code&gt;reponse&lt;/code&gt;响应。&lt;br/&gt;为了方便在视图函数中处理请求与响应，&lt;code&gt;reqeust&lt;/code&gt;请求报文在&lt;code&gt;web&lt;/code&gt;框架中被封装成&lt;code&gt;HttpRequest&lt;/code&gt;请求对象，而&lt;code&gt;reponse&lt;/code&gt;响应报文也被封装成&lt;code&gt;HttpResponse&lt;/code&gt;响应对象。&lt;br/&gt;所以视图函数中，除了处理逻辑之外，还有两个重要的对象，就是请求对象和响应对象。&lt;/p&gt;
&lt;h2 id=&quot;三请求对象httprequest&quot;&gt;三、请求对象&lt;strong&gt;HttpRequest&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;请求对象就是对&lt;code&gt;http&lt;/code&gt;请求报文的封装，&lt;code&gt;django&lt;/code&gt;自动执行封装并传入视图函数第一参数，我们需要在视图函数中调用。&lt;br/&gt;请求对象中有很多需要被进一步处理的数据，常用的接口如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;常用接口：
HttpRequest.method  请求方法
HttpRequest.GET   对应GET请求类型的数据字典
HttpRequest.POST    对应POST请求类型的数据字典
HttpRequest.path   请求的路径
HttpRequest.get_full_path()  请求的路径+get数据
HttpRequest.is_ajax()  判断是否为ajax形式的请求&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四响应对象httpresponse&quot;&gt;四、响应对象&lt;strong&gt;HttpResponse&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;响应对象就是对&lt;code&gt;http&lt;/code&gt;响应报文的封装，响应对象需要我们在视图函数中创建，并在视图函数最后&lt;code&gt;return&lt;/code&gt;给上层函数即底层控制循环。响应对象意味着&lt;code&gt;web&lt;/code&gt;服务程序通过业务逻辑处理后返回的响应信息。&lt;br/&gt;在视图函数中返回响应对象主要有两种形式的方法：&lt;/p&gt;
&lt;p&gt;方式1: 以字符串字面量为接口：&lt;code&gt;return HttpResponse('xxx')&lt;/code&gt;，直接返回的字符串会作为&lt;code&gt;html&lt;/code&gt;页面的内容，会被浏览器所执行，&lt;strong&gt;即，可以返回一个&lt;code&gt;&amp;lt;h1&amp;gt;xxx&amp;lt;/h1&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方式2: 以&lt;code&gt;html&lt;/code&gt;文件或模板文件为接口：&lt;code&gt;return render(request, 'index.html', {xxx})&lt;/code&gt;，可以直接返回最终形态的&lt;code&gt;html&lt;/code&gt;字符串。通过&lt;code&gt;render&lt;/code&gt;函数调用渲染引擎对模板文件执行渲染操作，&lt;br/&gt;模板文件中包含模板语法，这些模板语法被认为是&lt;code&gt;html&lt;/code&gt;文件中的占位符，用于后续填充动态数据，&lt;code&gt;render&lt;/code&gt;函数内部最后会执行&lt;code&gt;return HttpResponse&lt;/code&gt;操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：为了提高安全性，&lt;code&gt;render&lt;/code&gt;函数在处理&lt;code&gt;{xxx}&lt;/code&gt;渲染上下文时，如果包含有可执行的&lt;code&gt;html&lt;/code&gt;数据的时候会&lt;/strong&gt;自动转义成特殊字符&lt;strong&gt;，这主要是为了防止插入类似&lt;code&gt;link&lt;/code&gt;或者&lt;code&gt;script&lt;/code&gt;等这些浏览器会执行的&lt;code&gt;html&lt;/code&gt;代码给客户端带来的安全性问题。&lt;code&gt;render&lt;/code&gt;函数流程是进行渲染得到&lt;code&gt;http&lt;/code&gt;响应报文中的响应体字符串，然后再返回一个&lt;code&gt;HttpResponse&lt;/code&gt;对象，这相对于方式1，就是多了渲染的流程。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Oct 2018 04:32:00 +0000</pubDate>
<dc:creator>zzzzou</dc:creator>
<og:description>[TOC] 一、视图函数的理解 视图函数的作用是，对指定的 执行业务逻辑，视图函数将会作为 层和 层的桥梁，最主要的逻辑是操作数据库以及完成模板渲染前的上下文准备。 视图系统的模块： 1. 请求对象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzzlw/p/9747058.html</dc:identifier>
</item>
<item>
<title>负载，性能测试工具-Gatling - 三升水</title>
<link>http://www.cnblogs.com/sanshengshui/p/9747069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanshengshui/p/9747069.html</guid>
<description>&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/Gatling-dark-logo.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Gatling&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Gatling是一款功能强大的负载测试工具，它为易于使用，高可维护性和高性能而设计。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;开箱即用，Gatling由于对HTTP协议的出色支持，使其成为负载测试任何HTTP服务器的首选工具。由于核心引擎实际上是协议不可知的，因此完全可以实现对其他协议的支持。例如，Gatling目前还提供JMS支持。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;代码自定义&lt;/strong&gt;&lt;span&gt;并且&lt;span&gt;&lt;strong&gt;场景资源有效&lt;/strong&gt;&lt;span&gt;是Gatling的两个基础。并且拥有富有表现力的&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;&lt;span&gt;DSL&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，自我解释的场景,易于维护，可以保存在版本控制系统中的优点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;只要底层协议（如HTTP）可以以非阻塞方式实现，Gatling的体系结构就是异步的。这种架构允许我们将虚拟用户实现为消息而不是专用线程，这使得硬件要求不需要很苛刻。因此，运行数千个并发虚拟用户不是问题。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;使用理由&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;避免崩溃&lt;/strong&gt;&lt;span&gt;：Gatling可以帮助您预测缓慢的响应时间和奔溃。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;缩短产品上市时间&lt;/strong&gt;&lt;span&gt;：Gatling 在开发周期的早期检测到性能问题和错误&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;增强用户体验&lt;/strong&gt;&lt;span&gt;：Gatling可以准确描述您最慢的用户体验&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;提升您的业务&lt;/strong&gt;&lt;span&gt;：加特林可以防止您的业务成为自身成功的牺牲品&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;性能测试&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;性能测试是什么意思?&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;Web应用程序&lt;/strong&gt;&lt;span&gt;的性能测试包括:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;模拟大量&lt;/strong&gt;&lt;span&gt;具有&lt;span&gt;&lt;strong&gt;复杂行为的用户&lt;/strong&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;收集&lt;/strong&gt;&lt;span&gt;和汇总&lt;span&gt;&lt;strong&gt;所有请求的响应时间&lt;/strong&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;创建报告&lt;/strong&gt;&lt;span&gt;和&lt;span&gt;&lt;strong&gt;分析数据&lt;/strong&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/Capture-d%C3%A9cran-2017-01-05-16.26.07.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181006121136641-591518911.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;编写测试场景，自动化测试&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Gatling的&lt;span&gt;&lt;strong&gt;类似代码的脚本&lt;/strong&gt;&lt;span&gt;使您可以&lt;span&gt;&lt;strong&gt;轻松维护测试场景&lt;/strong&gt;&lt;span&gt;，并在持续交付管道中轻松实现自动化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们开发了自己的&lt;span&gt;&lt;strong&gt;领域特定语言（DSL）&lt;/strong&gt;&lt;span&gt;，以便让&lt;span&gt;&lt;strong&gt;每个人都能轻松阅读&lt;/strong&gt;&lt;span&gt;您的场景。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/codelike.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181006121209388-85363094.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;分析并调查您的应用程序的瓶颈&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Gatling是一个&lt;span&gt;&lt;strong&gt;功能强大的工具&lt;/strong&gt;&lt;span&gt;：只需几台计算机，您就可以 在Web应用程序上模拟&lt;span&gt;&lt;strong&gt;每秒数十万个请求，&lt;/strong&gt;&lt;span&gt;并获得&lt;span&gt;&lt;strong&gt;高精度指标&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在测试结束时，Gatling会自动生成&lt;span&gt;&lt;strong&gt;详尽，动态&lt;/strong&gt;&lt;span&gt;且&lt;span&gt;&lt;strong&gt;丰富多彩的报告&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;平均值和平均数据是&lt;span&gt;&lt;strong&gt;不够的&lt;/strong&gt;&lt;span&gt;：使用Gatling，您可以得到&lt;span&gt;&lt;strong&gt;适当&lt;/strong&gt;&lt;span&gt;的&lt;span&gt;&lt;strong&gt;响应时间&lt;/strong&gt;&lt;span&gt;百分位数&lt;span&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;span&gt;不要让最慢的用户落后！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/rapport.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181006122006913-56425964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;准备工作&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Java版本&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Gatling主要针对Oracle提供的JDK8软件包进行测试。Gatling需要&lt;span&gt;&lt;strong&gt;JDK8&lt;/strong&gt;&lt;span&gt;（因此不支持JDK9 atm）。Gatling应该适用于任何JDK8更新，但我们建议您使用最新版本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;IPv4 vs IPv6&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;发现IPv6（默认情况下在Java上启用）有时会导致一些性能问题，因此启动脚本会使用以下选项禁用它：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  -Djava.net.preferIPv4Stack=&lt;span&gt;true&lt;/span&gt;
  -Djava.net.preferIPv6Addresses=&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果您确实需要优先选择IPv6，请编辑启动脚本。&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;操作系统调整&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;4.3018867924528&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;以下说明摘自伟大的Riak文档。 有关更多详细信息或OS X的说明，请参阅“ &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/basho/basho_docs/blob/master/content/riak/kv/2.2.3/using/performance/open-files-limit.md/&quot;&gt;&lt;span&gt;打开文件限制”&lt;/span&gt;&lt;/a&gt; &lt;span&gt;和“ &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/basho/basho_docs/blob/master/content/riak/kv/2.2.3/using/performance.md#kernel-and-network-tuning&quot;&gt;&lt;span&gt;内核和网络调整”&lt;/span&gt;&lt;/a&gt;&lt;span&gt;部分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在正常操作期间，Gatling会消耗大量的打开文件句柄。通常，操作系统会限制此数量，因此您可能必须在所选操作系统中调整一些选项，以便可以打开&lt;span&gt;&lt;em&gt;许多&lt;/em&gt;&lt;span&gt;新套接字并实现高负载。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;打开文件限制&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;大多数操作系统都可以使用该命令更改打开文件限制。例：&lt;span&gt;&lt;code&gt;ulimit -n&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
  $ ulimit -n 65536
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但是，这只会更改当前shell会话的限制。在系统范围内，永久性地更改限制因系统而异。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;要&lt;span&gt;&lt;em&gt;为系统的所有用户&lt;/em&gt;&lt;span&gt;永久设置软值和硬值&lt;span&gt;&lt;em&gt;，&lt;/em&gt;&lt;span&gt;以允许最多65536个打开文件; 编辑&lt;span&gt;&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;&lt;span&gt;并附加以下两行：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  *       soft    nofile  65535
  *       hard    nofile  65535
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;保存文件。启动新会话以使限制生效。您现在可以验证是否正确设置了限制。&lt;span&gt;&lt;code&gt;ulimit -a&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;对于Debian和Ubuntu，您应该启用PAM用户限制。为此，请添加：&lt;span&gt;&lt;code&gt;session required pam_limits.so&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;/etc/pam.d/common-session&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;/etc/pam.d/common-session-noninteractive&lt;/code&gt; &lt;span&gt;如果文件存在&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;/etc/pam.d/sshd&lt;/code&gt; &lt;span&gt;如果您通过SSH访问该计算机&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;另外，如果访问通过SSH的机器，一定要具有在&lt;span&gt;&lt;code&gt;UseLogin yes``/etc/ssh/sshd_config&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;要进行更多调整，您可能需要执行以下操作：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  # more ports &lt;span&gt;for&lt;/span&gt;&lt;span&gt; testing
  sudo sysctl &lt;/span&gt;-w net.ipv4.ip_local_port_range=&quot;1025 65535&quot;&lt;span&gt;
  ​
  # increase the maximum number of possible open file descriptors:
  echo &lt;/span&gt;300000 | sudo tee /proc/sys/fs/&lt;span&gt;nr_open
  echo &lt;/span&gt;300000 | sudo tee /proc/sys/fs/file-max
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;内核和网络调优&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;考虑调整内核和网络，并在/etc/sysctl.conf中添加以下这些设置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 net.ipv4.tcp_max_syn_backlog = 40000&lt;span&gt;
  net.core.somaxconn &lt;/span&gt;= 40000&lt;span&gt;
  net.core.wmem_default &lt;/span&gt;= 8388608&lt;span&gt;
  net.core.rmem_default &lt;/span&gt;= 8388608&lt;span&gt;
  net.ipv4.tcp_sack &lt;/span&gt;= 1&lt;span&gt;
  net.ipv4.tcp_window_scaling &lt;/span&gt;= 1&lt;span&gt;
  net.ipv4.tcp_fin_timeout &lt;/span&gt;= 15&lt;span&gt;
  net.ipv4.tcp_keepalive_intvl &lt;/span&gt;= 30&lt;span&gt;
  net.ipv4.tcp_tw_reuse &lt;/span&gt;= 1&lt;span&gt;
  net.ipv4.tcp_moderate_rcvbuf &lt;/span&gt;= 1&lt;span&gt;
  net.core.rmem_max &lt;/span&gt;= 134217728&lt;span&gt;
  net.core.wmem_max &lt;/span&gt;= 134217728&lt;span&gt;
  net.ipv4.tcp_mem  &lt;/span&gt;= 134217728 134217728 134217728&lt;span&gt;
  net.ipv4.tcp_rmem &lt;/span&gt;= 4096 277750 134217728&lt;span&gt;
  net.ipv4.tcp_wmem &lt;/span&gt;= 4096 277750 134217728&lt;span&gt;
  net.core.netdev_max_backlog &lt;/span&gt;= 300000
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;离线下载&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;您可以离线下载Gatling。然后，您只需要一个文本编辑器（Scala语法高亮）来编辑模拟，您就可以从命令行启动Gatling。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;查看我们的&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://gatling.io/#/resources/download&quot;&gt;&lt;span&gt;下载页面&lt;/span&gt;&lt;/a&gt;&lt;span&gt;以获取下载链接。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;将下载的包解压缩到您选择的文件夹中。使用&lt;span&gt;&lt;code&gt;bin&lt;/code&gt;&lt;span&gt;目录中的脚本启动Gatling和Recorder。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Windows用户：我们建议您不要将Gatling放在“ Programs”文件夹中，因为可能存在权限和路径问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;要运行Gatling，您需要安装JDK。加特林至少需要&lt;span&gt;&lt;strong&gt;JDK8&lt;/strong&gt;&lt;span&gt;。然后，我们建议您使用最新版本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;4&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Gatling启动脚本和Gatling maven插件会在&lt;span&gt;&lt;code&gt;JAVA_HOME&lt;/code&gt;&lt;span&gt;env var中设置它。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;与OSX一样，操作系统有自己的棘手方法来发现要运行的Java版本，因此最终可能会运行与您告诉您的版本不同的版本。如果您遇到奇怪的错误，并且您希望运行JDK8，则可能需要明确设置&lt;span&gt;&lt;code&gt;JAVA_HOME&lt;/code&gt;&lt;span&gt;。&lt;span&gt;&lt;code&gt;java -version``Unsupported major.minor version 51.0&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;使用构建工具&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Maven&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Gatling提供了一个名为gatling-maven-plugin的官方maven 插件。这个插件允许您编译Scala代码并启动Gatling模拟。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;有了这个插件，Gatling可以在构建项目时启动，例如使用您最喜欢的CI解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Versions&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;查看&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://search.maven.org/search?q=g:io.gatling%20AND%20a:gatling-maven-plugin&amp;amp;core=gav&quot;&gt;&lt;span&gt;Maven Central&lt;/span&gt;&lt;/a&gt;&lt;span&gt;上的可用版本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;请注意，OSS用户未记录里程碑（M版本），仅针对专业版客户发布。&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Setup&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在你的&lt;span&gt;&lt;code&gt;pom.xml&lt;/code&gt;&lt;span&gt;，添加：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;io.gatling.highcharts&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;gatling-charts-highcharts&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;MANUALLY_REPLACE_WITH_LATEST_VERSION&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;&lt;span&gt;
  ​
  &lt;/span&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;io.gatling&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;gatling-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;MANUALLY_REPLACE_WITH_LATEST_VERSION&amp;lt;/version&amp;gt;
  &amp;lt;/plugin&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;演示样本&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;您可以在Gatling的Github组织中找到&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/gatling/gatling-sbt-plugin-demo&quot;&gt;&lt;span&gt;gatling-sbt-plugin-demo&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/gatling/gatling-sbt-plugin-demo&quot;&gt;&lt;span&gt;示例项目&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;您还可以使用&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://gatling.io/docs/current/extensions/maven_archetype#maven-archetype&quot;&gt;&lt;span&gt;gatling-highcharts-maven-archetype&lt;/span&gt;&lt;/a&gt;&lt;span&gt;来引导项目。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Usage&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;您可以直接启动gatling-maven-plugin，其&lt;span&gt;&lt;code&gt;test&lt;/code&gt;&lt;span&gt;目标是：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
  mvn gatling:test
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;它默认绑定到&lt;span&gt;&lt;code&gt;integration-test&lt;/code&gt;&lt;span&gt;阶段。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Configuration&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;下面的例子显示了默认值（所以不要指定你没有覆盖的选项!!!）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;simulationClass&amp;gt;foo.Bar&amp;lt;/simulationClass&amp;gt;                               &amp;lt;!-- the name of the single Simulation &lt;span&gt;class&lt;/span&gt; to run --&amp;gt;
    &amp;lt;runMultipleSimulations&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/runMultipleSimulations&amp;gt;                   &amp;lt;!-- &lt;span&gt;if&lt;/span&gt; the plugin should run multiple simulations sequentially --&amp;gt;
    &amp;lt;includes&amp;gt;                                                               &amp;lt;!-- include filters, see dedicated section below --&amp;gt;
      &amp;lt;include&amp;gt;&amp;lt;/include&amp;gt;
    &amp;lt;/includes&amp;gt;
    &amp;lt;excludes&amp;gt;                                                               &amp;lt;!-- exclude filters, see dedicated section below --&amp;gt;
      &amp;lt;exclude&amp;gt;&amp;lt;/exclude&amp;gt;
    &amp;lt;/excludes&amp;gt;
    &amp;lt;noReports&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/noReports&amp;gt;                                             &amp;lt;!-- to disable generating HTML reports --&amp;gt;
    &amp;lt;reportsOnly&amp;gt;&amp;lt;/reportsOnly&amp;gt;                                              &amp;lt;!-- to only trigger generating HTML reports from the log file contained in folder parameter --&amp;gt;
    &amp;lt;runDescription&amp;gt;This-is-the-run-description&amp;lt;/runDescription&amp;gt;             &amp;lt;!-- &lt;span&gt;short&lt;/span&gt; text that will be displayed in the HTML reports --&amp;gt;
    &amp;lt;skip&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/skip&amp;gt;                                                       &amp;lt;!-- skip executing &lt;span&gt;this&lt;/span&gt; plugin --&amp;gt;
    &amp;lt;failOnError&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/failOnError&amp;gt;                                          &amp;lt;!-- report failure in &lt;span&gt;case&lt;/span&gt; of assertion failure, typically to fail CI pipeline --&amp;gt;
    &amp;lt;continueOnAssertionFailure&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/continueOnAssertionFailure&amp;gt;           &amp;lt;!-- keep on executing multiple simulations even &lt;span&gt;if&lt;/span&gt; one fails --&amp;gt;
    &amp;lt;useOldJenkinsJUnitSupport&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/useOldJenkinsJUnitSupport&amp;gt;             &amp;lt;!-- report results to Jenkins JUnit support (workaround until we manage to get Gatling support into Jenkins) --&amp;gt;
    &amp;lt;jvmArgs&amp;gt;
      &amp;lt;jvmArg&amp;gt;-DmyExtraParam=foo&amp;lt;/jvmArg&amp;gt;                                    &amp;lt;!-- pass extra parameters to the Gatling JVM --&amp;gt;
    &amp;lt;/jvmArgs&amp;gt;
    &amp;lt;overrideJvmArgs&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/overrideJvmArgs&amp;gt;                                 &amp;lt;!-- &lt;span&gt;if&lt;/span&gt; above option should override the defaults instead of replacing them --&amp;gt;
    &amp;lt;propagateSystemProperties&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/propagateSystemProperties&amp;gt;              &amp;lt;!-- &lt;span&gt;if&lt;/span&gt; System properties from the maven JVM should be propagated to the Gatling forked one --&amp;gt;
    &amp;lt;compilerJvmArgs&amp;gt;
      &amp;lt;compilerJvmArg&amp;gt;-DmyExtraParam=foo&amp;lt;/compilerJvmArg&amp;gt;                    &amp;lt;!-- pass extra parameters to the Compiler JVM --&amp;gt;
    &amp;lt;/compilerJvmArgs&amp;gt;
    &amp;lt;overrideCompilerJvmArgs&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/overrideCompilerJvmArgs&amp;gt;                 &amp;lt;!-- &lt;span&gt;if&lt;/span&gt; above option should override the defaults instead of replacing them --&amp;gt;
    &amp;lt;extraScalacOptions&amp;gt;                                                     &amp;lt;!-- extra options to be passed to scalac --&amp;gt;
      &amp;lt;extraScalacOption&amp;gt;&amp;lt;/extraScalacOption&amp;gt;
    &amp;lt;/extraScalacOptions&amp;gt;
    &amp;lt;disableCompiler&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/disableCompiler&amp;gt;                                 &amp;lt;!-- &lt;span&gt;if&lt;/span&gt; compiler should be disabled, typically because another plugin has already compiled sources --&amp;gt;
    &amp;lt;simulationsFolder&amp;gt;${project.basedir}/src/test/scala&amp;lt;/simulationsFolder&amp;gt; &amp;lt;!-- where the simulations to be compiled are located --&amp;gt;
    &amp;lt;resourcesFolder&amp;gt;${project.basedir}/src/test/resources&amp;lt;/resourcesFolder&amp;gt; &amp;lt;!-- where the test resources are located --&amp;gt;
    &amp;lt;resultsFolder&amp;gt;${project.basedir}/target/gatling&amp;lt;/resultsFolder&amp;gt;         &amp;lt;!-- where the simulation log and the HTML reports will be generated --&amp;gt;
  &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;包含/排除过滤器&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;运行多个模拟时，您可以使用&lt;span&gt;&lt;code&gt;includes&lt;/code&gt;&lt;span&gt;和&lt;span&gt;&lt;code&gt;excludes&lt;/code&gt;&lt;span&gt;过滤器控制哪些模拟将被触发。那些使用ant模式语法并与类名匹配。另请注意，这些过滤器仅适用于从设置插件的项目中的源编译的类。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!--   ...  --&amp;gt;
    &amp;lt;runMultipleSimulations&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/runMultipleSimulations&amp;gt;
    &amp;lt;includes&amp;gt;
      &amp;lt;include&amp;gt;my.&lt;span&gt;package&lt;/span&gt;.*&amp;lt;/include&amp;gt;
    &amp;lt;/includes&amp;gt;
    &amp;lt;excludes&amp;gt;
      &amp;lt;exclude&amp;gt;my.&lt;span&gt;package&lt;/span&gt;.IgnoredSimulation&amp;lt;/exclude&amp;gt;
    &amp;lt;/excludes&amp;gt;
  &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;注意:过滤器的顺序对执行顺序没有影响，模拟将按字母顺序按类名排序。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;禁用编译器&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;默认情况下，gatling-maven-plugin负责编译Scala代码，因此您可以直接运行。&lt;span&gt;&lt;code&gt;mvn gatling:execute&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;然后，由于某种原因，你可能想要另一个插件，如&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/davidB/scala-maven-plugin&quot;&gt;&lt;span&gt;scala-maven-plugin&lt;/span&gt;&lt;/a&gt; &lt;span&gt;或&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/random-maven/scalor-maven-plugin&quot;&gt;&lt;span&gt;scalor-maven-plugin&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，负责编译。然后，您可以禁用Gatling编译器，这样就不会编译两次：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &amp;lt;configuration&amp;gt;
    &amp;lt;disableCompiler&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/disableCompiler&amp;gt;
  &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;覆盖logback.xml文件&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;您可以&lt;span&gt;&lt;code&gt;logback-test.xml&lt;/code&gt;&lt;span&gt;拥有优先于嵌入&lt;span&gt;&lt;code&gt;logback.xml&lt;/code&gt;&lt;span&gt;文件的优先级，也可以添加JVM选项&lt;span&gt;&lt;code&gt;-Dlogback.configurationFile=myFilePath&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;使用IDE&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;您可以使用任何Scala语法高亮的文本编辑器编辑Simulation类。但如果您是开发人员，您很可能希望将自己喜欢的IDE与Gatling一起使用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Gatling正式支持IntelliJ IDEA和eclipse。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;IntelliJ IDEA&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;您需要安装社区版中提供的Scala插件。然后，您就可以使用Scala源直接导入常规maven或sbt项目。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Eclipse&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;您必须安装&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;http://scala-ide.org/index.html&quot;&gt;&lt;span&gt;ScalaIDE&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，最好是最新版本，甚至是里程碑。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;遗憾的是，截至今天，ScalaIDE仅适用于Eclipse 4.7（Oxygen），并且与更现代的版本不兼容。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;请注意，Eclipse 4.7不支持Java 9+，因此如果您的计算机上安装了多个Java，则可能必须强制使用JVM &lt;span&gt;&lt;code&gt;eclipse.ini&lt;/code&gt;&lt;span&gt;，例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  -&lt;span&gt;vm
  &lt;/span&gt;/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/bin/java
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;SBT&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果你正在使用sbt，你可以使用&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/sbt/sbteclipse&quot;&gt;&lt;span&gt;sbteclipse&lt;/span&gt;&lt;/a&gt;&lt;span&gt;来生成eclipse项目配置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Maven&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果您正在使用maven，则可以将&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/davidB/scala-maven-plugin&quot;&gt;&lt;span&gt;scala-maven-plugin&lt;/span&gt;&lt;/a&gt;&lt;span&gt;与&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/sonatype/m2eclipse-scala&quot;&gt;&lt;span&gt;m2eclipse-scala&lt;/span&gt;&lt;/a&gt;&lt;span&gt;结合使用。前者将编译Scala代码，后者将执行ScalaIDE和m2e（maven的eclipse插件）之间的集成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;您必须在pom.xml中添加以下部分：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &amp;lt;build&amp;gt;
          &amp;lt;sourceDirectory&amp;gt;src/main/scala&amp;lt;/sourceDirectory&amp;gt;
          &amp;lt;testSourceDirectory&amp;gt;src/test/scala&amp;lt;/testSourceDirectory&amp;gt;
          &amp;lt;plugins&amp;gt;
                  &amp;lt;plugin&amp;gt;
                          &amp;lt;groupId&amp;gt;net.alchim31.maven&amp;lt;/groupId&amp;gt;
                          &amp;lt;artifactId&amp;gt;scala-maven-plugin&amp;lt;/artifactId&amp;gt;
                          &amp;lt;version&amp;gt;MANUALLY_REPLACE_WITH_LATEST_VERSION&amp;lt;/version&amp;gt;
  &amp;lt;configuration&amp;gt;
    &amp;lt;args&amp;gt;
      &amp;lt;arg&amp;gt;-target:jvm-1.8&amp;lt;/arg&amp;gt;
      &amp;lt;arg&amp;gt;-deprecation&amp;lt;/arg&amp;gt;
      &amp;lt;arg&amp;gt;-feature&amp;lt;/arg&amp;gt;
      &amp;lt;arg&amp;gt;-unchecked&amp;lt;/arg&amp;gt;
      &amp;lt;arg&amp;gt;-language:implicitConversions&amp;lt;/arg&amp;gt;
      &amp;lt;arg&amp;gt;-language:postfixOps&amp;lt;/arg&amp;gt;
    &amp;lt;/args&amp;gt;
  &amp;lt;/configuration&amp;gt;
                          &amp;lt;executions&amp;gt;
                                  &amp;lt;execution&amp;gt;
                                          &amp;lt;goals&amp;gt;
                                                  &amp;lt;goal&amp;gt;compile&amp;lt;/goal&amp;gt;
                                                  &amp;lt;goal&amp;gt;testCompile&amp;lt;/goal&amp;gt;
                                          &amp;lt;/goals&amp;gt;
                                  &amp;lt;/execution&amp;gt;
                          &amp;lt;/executions&amp;gt;
                  &amp;lt;/plugin&amp;gt;
          &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;您也可以使用&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/random-maven/scalor-maven-plugin&quot;&gt;&lt;span&gt;scalor-maven-plugin&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;您必须在pom.xml中添加以下部分：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.8.0&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
          &amp;lt;skip&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/skip&amp;gt;
          &amp;lt;skipMain&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/skipMain&amp;gt;
        &amp;lt;/configuration&amp;gt;
      &amp;lt;/plugin&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;com.carrotgarden.maven&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;scalor-maven-plugin_2.12&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;MANUALLY_REPLACE_WITH_LATEST_VERSION&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
                                        &amp;lt;zincOptionsScala&amp;gt;
                                                -target:jvm-1.8
                                                -&lt;span&gt;deprecation
                                                &lt;/span&gt;-&lt;span&gt;feature
                                                &lt;/span&gt;-&lt;span&gt;unchecked
                                                &lt;/span&gt;-&lt;span&gt;language:implicitConversions
                                                &lt;/span&gt;-&lt;span&gt;language:postfixOps
                                        &lt;/span&gt;&amp;lt;/zincOptionsScala&amp;gt;
                                &amp;lt;/configuration&amp;gt;
        &amp;lt;executions&amp;gt;
          &amp;lt;execution&amp;gt;
            &amp;lt;goals&amp;gt;
              &amp;lt;goal&amp;gt;eclipse-config&amp;lt;/goal&amp;gt;
              &amp;lt;goal&amp;gt;eclipse-format&amp;lt;/goal&amp;gt;
              &amp;lt;goal&amp;gt;eclipse-restart&amp;lt;/goal&amp;gt;
              &amp;lt;goal&amp;gt;eclipse-prescomp&amp;lt;/goal&amp;gt;
              &amp;lt;!-- &amp;lt;goal&amp;gt;register-main&amp;lt;/goal&amp;gt; --&amp;gt; &amp;lt;!-- uncomment &lt;span&gt;if&lt;/span&gt; you have some Scala code to compile in src/main/scala --&amp;gt;
              &amp;lt;goal&amp;gt;register-test&amp;lt;/goal&amp;gt;
              &amp;lt;!-- &amp;lt;goal&amp;gt;compile-main&amp;lt;/goal&amp;gt; --&amp;gt;  &amp;lt;!-- uncomment &lt;span&gt;if&lt;/span&gt; you have some Scala code to compile in src/main/scala --&amp;gt;
              &amp;lt;goal&amp;gt;compile-test&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
          &amp;lt;/execution&amp;gt;
        &amp;lt;/executions&amp;gt;
      &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
 
&lt;/pre&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;从IDE启动加特林&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://gatling.io/docs/current/extensions/maven_archetype#maven-archetype&quot;&gt;&lt;span&gt;gatling-highcharts-maven-archetype&lt;/span&gt;&lt;/a&gt;&lt;span&gt;生成，您可以使用从您的IDE手动启动加特林和记录一些辅助类。可以完美复制&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://github.com/gatling/gatling-highcharts-maven-archetype/tree/master/src/main/scala&quot;&gt;&lt;span&gt;这3个类&lt;/span&gt;&lt;/a&gt;&lt;span&gt;（&lt;span&gt;&lt;code&gt;Engine&lt;/code&gt;&lt;span&gt;，&lt;span&gt;&lt;code&gt;Recorder&lt;/code&gt;&lt;span&gt;并&lt;span&gt;&lt;code&gt;IDEPathHelper&lt;/code&gt;&lt;span&gt;在自己的项目）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;以上参考官网介绍:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://gatling.io/&quot;&gt;https://gatling.io/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;初次接触Gatling&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;文件目录介绍&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  Gatling_Home
    ├── bin 执行程序
      ├── gatling.bat &lt;/span&gt;--&lt;span&gt; 启动入口(windows)
      ├── gatling.sh &lt;/span&gt;--&lt;span&gt; 启动入口(linux)
      ├── recorder.bat &lt;/span&gt;--&lt;span&gt; UI记录入口(windows)
      ├── recorder.sh &lt;/span&gt;--&lt;span&gt; UI记录入口(linux)
    ├── conf 配置信息
      ├── gatling.conf &lt;/span&gt;--&lt;span&gt; 加特林配置文件
      ├── gatling&lt;/span&gt;-akka.conf --&lt;span&gt; 加特林akka配置文件
      ├── logback.xml &lt;/span&gt;--&lt;span&gt; 日志配置文件
      ├── recorder.conf &lt;/span&gt;--&lt;span&gt; recorder配置文件
    ├── lib 加特林依赖jar包
    ├── results 测试报告
    ├── target 编译类 
    ├── user&lt;/span&gt;-&lt;span&gt;files 用户文件
    ├── LICENSE 许可证&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;How to run it&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;进入bin目录可以看到下面两个文件（.bat属于windows下面的可执行脚本）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;gatling.sh&lt;/strong&gt; &lt;span&gt;启动入口 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;依次输入以下三个参数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;执行的脚本序号&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;本次测试Id,用作测试报告命名前缀,不能包含空格，特殊字符，中文等&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;本次测试描述（非必须），会显示在报告头部&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;record.sh&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;UI操作，它主要用于将浏览器配置代理后记录用户操作然后生成测试脚本，更多的用于用户行为模拟测试。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;测试运行&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;首先肯定是要下载它&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;http://gatling.io/#/download&quot;&gt;http://gatling.io/#/download&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;解压并进入到bin目录下运行sh gatling.sh（linux环境下）&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/2199008197-57298d6dd0e09_articlex.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181006121401155-1547644547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;上面列出的就是官方自带的测试脚本样例，我们试着跑下。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;输入0.就能看到窗口开始跳动字节了！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181006121445424-1849460695.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;显示上面的信息表示测试程序已经运行完成，最后一行显示的是本次的测试报告，可以打开瞅瞅，风骚的报告自己体会吧，首次介绍就先到这里了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;部分报告截图如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181006121502417-53702425.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;其他&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;关于负载，性能测试工具-Gatling详解到这里就结束了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;版权声明:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;作者：穆书伟&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;博客园出处：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/sanshengshui&quot;&gt;https://www.cnblogs.com/sanshengshui&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;github出处：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://github.com/sanshengshui&quot;&gt;https://github.com/sanshengshui&lt;/a&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;个人博客出处：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://sanshengshui.github.io/&quot;&gt;https://sanshengshui.github.io/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/%E9%80%89%E5%8C%BA_005.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Oct 2018 04:23:00 +0000</pubDate>
<dc:creator>三升水</dc:creator>
<og:description>前言 Gatling Gatling是一款功能强大的负载测试工具，它为易于使用，高可维护性和高性能而设计。 开箱即用，Gatling由于对HTTP协议的出色支持，使其成为负载测试任何HTTP服务器的首</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanshengshui/p/9747069.html</dc:identifier>
</item>
</channel>
</rss>