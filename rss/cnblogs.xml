<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>day14_DBUtils学习笔记 - 黑泽明军</title>
<link>http://www.cnblogs.com/chenmingjun/p/9063639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/9063639.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-29415&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;34.5&quot;&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Apache公司开发的框架。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;code&gt;什么是dbutils？它的作用？&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;  DBUtils是java编程中的数据库操作实用工具，小巧简单实用。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;  DBUtils封装了对JDBC的操作，简化了JDBC操作。可以少写代码。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，&lt;code&gt;它是对JDBC的简单封装&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; ，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。因此&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;dbutils&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 成为很多不喜欢&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;hibernate&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 的公司的首选框架。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;对于数据表的&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;读操作&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; ，dbutils可以把结果转换成List、Array、Set等java集合，便于程序员操作。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对于数据表的&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;写操作&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; ，也变得很简单(只需写sql语句就行)。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;可以使用数据源、使用JNDI、数据库连接池等技术来优化性能(即重用已经构建好的数据库连接对象)。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-29416&quot; class=&quot;wmd-preview-section preview-content&quot;&gt;

&lt;ul&gt;&lt;li&gt;QueryRunner类&lt;/li&gt;
&lt;li&gt;ResultSetHandler接口&lt;/li&gt;
&lt;li&gt;DBUtils类&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;QueryRunner类&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;QueryRunner中提供对sql语句操作的API。&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;它主要有三个方法&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;query() 用于执行select语句&lt;/li&gt;
&lt;li&gt;update() 用于执行insert、update、delete语句&lt;/li&gt;
&lt;li&gt;batch() 批处理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ResultSetHandler接口&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;用于定义select操作后，怎样封装结果集。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;DbUtils类&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;它就是一个工具类，定义了关闭资源与事务处理的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-29417&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;31&quot;&gt;

&lt;ol&gt;&lt;li&gt;导入jar包&lt;/li&gt;
&lt;li&gt;创建QueryRunner对象&lt;/li&gt;
&lt;li&gt;使用query方法执行select语句&lt;/li&gt;
&lt;li&gt;使用ResultSetHandler封装结果集&lt;/li&gt;
&lt;li&gt;使用DbUtils类释放资源&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Dbutils快速入门实现步骤：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;　　创建数据库及表，如下:&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-29418&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;se-section-delimiter&quot; readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;DATABASE&lt;/span&gt;&lt;span&gt; day14;
&lt;/span&gt;&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; day14;

&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; users (
    id &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
    username &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt; (&lt;span&gt;40&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    PASSWORD &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt; (&lt;span&gt;40&lt;/span&gt;&lt;span&gt;),
    email &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt; (&lt;span&gt;60&lt;/span&gt;&lt;span&gt;),
    birthday DATE
) &lt;/span&gt;&lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt;&lt;span&gt; utf8 COLLATE utf8_general_ci;
 
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; users(username, PASSWORD, email, birthday) &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tom@163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1980-12-04&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;导入jar包&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;　　注意: c3p0与mysql驱动jar包也要导入。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;code&gt;示例代码如下：&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-29419&quot; class=&quot;wmd-preview-section preview-content&quot;&gt;
&lt;div class=&quot;se-section-delimiter&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.itheima.util;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.QueryRunner;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.ResultSetHandler;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.handlers.BeanListHandler;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.itheima.entity.User;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSelect {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testSelect() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个QueryRunner对象&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         List&amp;lt;User&amp;gt; list = qr.query(&quot;select * from users&quot;, &lt;span&gt;new&lt;/span&gt; ResultSetHandler&amp;lt;List&amp;lt;User&amp;gt;&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当query方法执行select语句后，将结果集以参数的形式传递过来&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; handle(ResultSet rs) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 List&amp;lt;User&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;User&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (rs.next()) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     User u = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     u.setId(rs.getInt(1&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     u.setUsername(rs.getString(2&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     u.setPassword(rs.getString(3&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     u.setEmail(rs.getString(4&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     u.setBirthday(rs.getDate(5&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    list.add(u);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (User user : list) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            System.out.println(user);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testSelect2() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个QueryRunner对象&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行查询语句，并返回结果&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         List&amp;lt;User&amp;gt; list = qr.query(&quot;select * from users&quot;, &lt;span&gt;new&lt;/span&gt; BeanListHandler&amp;lt;User&amp;gt;(User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (User user : list) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            System.out.println(user);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-29420&quot; class=&quot;wmd-preview-section preview-content&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;1.1 构造函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;new QueryRunner(); // 它的事务可以手动控制。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;此对象调用的方法（如：query、update、batrch）参数中要有Connection对象。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;new QueryRunner(DataSource ds); // 它的事务是自动控制的。一个sql一个事务。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;此对象调用的方法（如：query、update、batrch）参数中无需Connection对象。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;1.2 方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-29421&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;49&quot;&gt;
&lt;div class=&quot;se-section-delimiter&quot; readability=&quot;13.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&amp;lt;T&amp;gt; T query(String sql, ResultSetHandler&amp;lt;T&amp;gt;&lt;span&gt; rsh) 
&lt;/span&gt;&amp;lt;T&amp;gt; T query(Connection conn, String sql, ResultSetHandler&amp;lt;T&amp;gt;&lt;span&gt; rsh)
&lt;/span&gt;&amp;lt;T&amp;gt; T query(Connection conn, String sql, ResultSetHandler&amp;lt;T&amp;gt;&lt;span&gt; rsh, Object... params)

&lt;/span&gt;&lt;span&gt;int &lt;/span&gt;&lt;span&gt;update(String sql, Object... params)
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; update(Connection conn, String sql, Object... params)

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; batch(String sql, Object[][] params) 
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] batch(Connection conn, String sql, Object[][] params)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;　　示例如下：&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201805/841693-20180520154232728-244996664.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img title=&quot;&quot; alt=&quot;&quot;/&gt;　　进行基本的CRUD操作：练习一下，&lt;code&gt;示例代码如下：&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.itheima.util;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.Connection;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.PreparedStatement;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.QueryRunner;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestCRUD {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有使用框架之前&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testInsert0() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         Connection conn = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         PreparedStatement ps = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             conn =&lt;span&gt; C3P0Util.getConnection();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             ps = conn.prepareStatement(&quot;insert into users(name, money) values('ggg', 2000)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            ps.executeUpdate();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             C3P0Util.release(conn, ps, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用框架之后&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testInsert() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个QueryRunner对象&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行sql语句&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         qr.update(&quot;insert into users(username, password, email, birthday) values(?, ?, ?, ?)&quot;, &quot;菜10&quot;, &quot;123&quot;, &quot;c10@163.com&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testUpdate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个QueryRunner对象&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         qr.update(&quot;update users set username=?, password=? where id=?&quot;, &quot;周杰杰&quot;, &quot;333&quot;, 15&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testDelete() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个QueryRunner对象&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         qr.update(&quot;delete from users where id=?&quot;, 15&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 批处理，只能执行相同的sql语句&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    @Test 
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testBatch() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个QueryRunner对象&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;         Object[][] params = &lt;span&gt;new&lt;/span&gt; Object[10][]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 高维代表执行多少次sql语句&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; params.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             params[i] = &lt;span&gt;new&lt;/span&gt; Object[] { &quot;菜10&quot; + i, &quot;123&quot;, &quot;c10@163.com&quot;, &lt;span&gt;new&lt;/span&gt; Date() }; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给每次执行的sql语句中的?赋值&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         qr.batch(&quot;insert into users(username, password, email, birthday) values(?, ?, ?, ?)&quot;&lt;span&gt;, params);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-29423&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;31&quot;&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ResultSetHandler接口下的所有结果处理器实现类(&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;共9个实现类&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; )：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;ArrayHandler实现类&lt;/code&gt;：适合取1条记录(1行数据)。把该条记录的每列值封装到一个Object[]数组中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ArrayListHandler实现类&lt;/code&gt;：适合取多条记录(多行数据)。把每条记录的每列值封装到一个Object[]数组中，把数组封装到一个List集合中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ColumnListHandler实现类&lt;/code&gt;：适合取某一列的数据。把取到的数据封装到List集合中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyedHandler实现类&lt;/code&gt;：取多条记录(多行数据)，每一条记录封装到一个Map集合中，再把这个Map集合封装到另外一个Map集合中，key为指定的字段值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MapHandler实现类&lt;/code&gt;：适合取1条记录(1行数据)。把当前记录的列名和列值放到一个Map集合中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MapListHandler实现类&lt;/code&gt;：适合取多条记录(多行数据)。把每条记录封装到一个Map集合中，再把Map集合封装到List集合中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ScalarHandler实现类&lt;/code&gt;：适合取单行单列数据(一个单元格的数据)。&lt;/li&gt;
&lt;li&gt;BeanHandler实现类：适合取单行数据。&lt;/li&gt;
&lt;li&gt;BeanListHandler实现类：适合取单行数据。&lt;p&gt;&lt;code&gt;示例代码如下&lt;/code&gt;：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-29424&quot; class=&quot;wmd-preview-section preview-content&quot;&gt;
&lt;div class=&quot;se-section-delimiter&quot; readability=&quot;18.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.itheima.util;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.QueryRunner;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.handlers.ArrayHandler;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.handlers.ArrayListHandler;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.handlers.BeanHandler;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.handlers.BeanListHandler;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.handlers.ColumnListHandler;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.handlers.KeyedHandler;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.handlers.MapHandler;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.handlers.MapListHandler;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbutils.handlers.ScalarHandler;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.itheima.entity.User;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestResultSetHandler {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     @Test &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ArrayHandler实现类：适合取1条记录(1行数据)。把该条记录的每列值封装到一个Object[]数组中。&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tese1() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         Object[] arr = qr.query(&quot;select * from users&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayHandler());
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object o : arr) {
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;            System.out.println(o);
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;     @Test &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ArrayListHandler实现类：适合取多条记录(多行数据)。把每条记录的每列值封装到一个Object[]数组中，把数组封装到一个List集合中。&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tese2() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         List&amp;lt;Object[]&amp;gt; query = qr.query(&quot;select * from users&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayListHandler());
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object[] os : query) {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object o : os) {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;                System.out.println(o);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             System.out.println(&quot;--------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;     @Test &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ColumnListHandler实现类：适合取某一列的数据。把取到的数据封装到List集合中。&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tese3() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         List&amp;lt;Object&amp;gt; list = qr.query(&quot;select * from users&quot;, &lt;span&gt;new&lt;/span&gt; ColumnListHandler(3&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object o : list) {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;            System.out.println(o);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;     @Test &lt;span&gt;//&lt;/span&gt;&lt;span&gt; KeyedHandler实现类：适合取多条记录(多行数据)。每一条记录封装到一个Map集合中，再把这个Map集合封装到另外一个Map集合中，key为指定的字段值。&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tese4() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 大Map集合的key是表中的第一列数据，小Map集合中的key是表的列名，所以大Map集合的key是Object类型，小Map集合的key是String类型。&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;         Map&amp;lt;Object, Map&amp;lt;String, Object&amp;gt;&amp;gt; map = qr.query(&quot;select * from users&quot;, &lt;span&gt;new&lt;/span&gt; KeyedHandler(1&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;Object, Map&amp;lt;String, Object&amp;gt;&amp;gt;&lt;span&gt; m : map.entrySet()) {
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             System.out.println(m.getKey()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认大Map集合中key值就是id列的值&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, Object&amp;gt;&lt;span&gt; mm : m.getValue().entrySet()) {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 System.out.println(mm.getKey() + &quot;\t&quot; + mm.getValue()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出小Map集合中的列名和列值&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             System.out.println(&quot;--------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;     @Test &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MapHandler实现类：适合取1条记录(1行数据)。把当前记录的列名和列值放到一个Map集合中。&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tese5() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         Map&amp;lt;String, Object&amp;gt; map = qr.query(&quot;select * from users where id=?&quot;, &lt;span&gt;new&lt;/span&gt; MapHandler(), 10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, Object&amp;gt;&lt;span&gt; m : map.entrySet()) {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             System.out.println(m.getKey() + &quot;\t&quot; +&lt;span&gt; m.getValue());
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;     @Test &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MapListHandler实现类：适合取多条记录(多行数据)。把每条记录封装到一个Map集合中，再把Map封装到List集合中。&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tese6() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; list = qr.query(&quot;select * from users&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MapListHandler());
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Map&amp;lt;String, Object&amp;gt;&lt;span&gt; map : list) {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, Object&amp;gt;&lt;span&gt; m : map.entrySet()) {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                 System.out.println(m.getKey() + &quot;\t&quot; +&lt;span&gt; m.getValue());
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             System.out.println(&quot;--------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;     @Test &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ScalarHandler实现类：适合取单行单列数据(一个单元格的数据)。&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tese7() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         Object o = qr.query(&quot;select count(*) from users&quot;, &lt;span&gt;new&lt;/span&gt; ScalarHandler(1)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 统计有多少行数据&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;         System.out.println(o.getClass().getName()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意：行数是long类型，因为表格已经突破了千万行了。&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt;     @Test &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BeanHandler实现类：适合取单行数据。&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tese8() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;         User user = qr.query(&quot;select * from users where id=?&quot;, &lt;span&gt;new&lt;/span&gt; BeanHandler&amp;lt;User&amp;gt;(User.&lt;span&gt;class&lt;/span&gt;), 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        System.out.println(user);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;     @Test &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BeanListHandler实现类：适合取单行数据。&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tese9() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;         QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3P0Util.getDataSource());
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         List&amp;lt;User&amp;gt; list = qr.query(&quot;select * from users where id=?&quot;, &lt;span&gt;new&lt;/span&gt; BeanListHandler&amp;lt;User&amp;gt;(User.&lt;span&gt;class&lt;/span&gt;), 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;        System.out.println(list);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-29425&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;39&quot;&gt;

&lt;p&gt;　　1.版本一：转账的具体操作在数据访问层（dao）中实现。不好，因为转账操作属于业务层（service）的东西。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201805/841693-20180520154943666-1290433076.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201805/841693-20180520154955874-1542406196.png&quot; alt=&quot;&quot;/&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;　　2.&lt;img title=&quot;&quot; alt=&quot;&quot;/&gt;版本二：转账的具体操作在业务层（service）中实现。可以，但是，业务层里面出现了数据访问层（dao）的东西。&lt;code&gt;Connection conn = C3P0Util.getConnection();&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201805/841693-20180520155008219-2015627054.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　3.版本三：使用线程局部变量ThreadLocal&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201805/841693-20180520155023691-448670299.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-29426&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;31&quot;&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;模拟ThreadLocal类的设计，让大家明白它的作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadLocal {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;Runnable, Object&amp;gt; container = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Runnable, Object&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; set(Object value) {
        container.put(Thread.currentThread(), value); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用当前线程作为key&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object get() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; container.get(Thread.currentThread());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
        container.remove(Thread.currentThread());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;　　　　总结&lt;/code&gt;：调用该类的get方法，永远返回当前线程放入的数据，保证线程安全。所以ThreadLocal叫做线程局部变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;八、完成案例&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;项目开发的准备工作&lt;/li&gt;
&lt;li&gt;创建项目&lt;br/&gt;　　添加jar包&lt;/li&gt;
&lt;li&gt;添加dao、service、servlet分层代码&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　创建数据库及表&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;database&lt;/span&gt;&lt;span&gt; day14;
&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; day14;

&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; books (
    id &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;) &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt;,
    name &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    price &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt;,
    pnum &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,
    category &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;),
    description &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;&lt;span&gt;)
)

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; books;

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; books &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;java编程思想&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;98&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;计算机&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;好书&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; books &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1002&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;解忧杂货铺&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;文学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;好书&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; books &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1003&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创京东&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;科技&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;好书&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;显示列表数据&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 的思路图：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201805/841693-20180520155426237-1450514378.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;添加/修改列表数据&lt;/code&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 的思路图：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201805/841693-20180520155436697-1557893589.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 May 2018 07:57:00 +0000</pubDate>
<dc:creator>黑泽明军</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/9063639.html</dc:identifier>
</item>
<item>
<title>数据分析师岗位的一点理解 - 向薇佳</title>
<link>http://www.cnblogs.com/caexiang/p/9063570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caexiang/p/9063570.html</guid>
<description>&lt;p&gt;    最近跟公司的数据分析师打交道比较多，其中一个分析师认为：行业对数据分析师这个岗位的理解有严重偏差。&lt;/p&gt;
&lt;p&gt;    由此产生了一个好奇，行业理解数据分析师是什么？偏差是什么？严重偏差的严重在哪里？&lt;/p&gt;
&lt;p&gt;    讲真啊，这么大的问题，我一个都答不上来。我就根据自己在工作中，亲身遇到数据分析师接的任务来说一下我理解的这个岗位吧。&lt;/p&gt;
&lt;p&gt;    领导会要求运营人员要多看数，多分析数据，理解数据背后的意义。&lt;/p&gt;
&lt;p&gt;    然后每天都会接到运营提出的类似这种样子的任务：XX，最近PC的数据下降的厉害，帮忙分析下是什么原因吧。XX，昨天App的数据降的多，看看是怎么回事。XX，上周移动端上发生什么了？导致我们的新用户大幅减少。&lt;/p&gt;
&lt;p&gt;    好吧。这些就是我日常中的一小部分（日常的东西太多了^-^）。其实我部门的数据分析师干的就是这些活：为数据异动找到一个合理的解释。必须强调：这是我部门的数据分析师。行业的数据分析师是干嘛的，据我所知，每个公司还真不一样。&lt;/p&gt;
&lt;p&gt;    要给出一个合理的解释，其实是挺难的。最难的是提需求方是否能接受分析师给的结论。我部门的好处是：哪怕结论是非常悲观的，只要合情合理，也能接受。这一点难能可贵。&lt;/p&gt;
&lt;p&gt;    一些人是不太能接受悲观解释的，比如某公司CEO就不太能接受数据分析师给出这种结论：行业用户规模已经见顶，我们发掘新用户的成本将大幅上升，且增长将减慢。于是CEO甚至会不看分析过程，直接把结论怼回去：你分析的不对，重新来过。因为他不能接受这种结论。&lt;/p&gt;
&lt;p&gt;    如果需求方大老板是这种个性，那么数据分析师的任务就变成了：不要分析我提出的观点对不对，请你负责证明我是对的。哪怕是错的，也要变着方证明我是对的。&lt;/p&gt;
&lt;p&gt;    所以数据分析师这个岗位分两种：&lt;/p&gt;
&lt;p&gt;    1、分析事情的原因，并给出解释。&lt;/p&gt;
&lt;p&gt;    2、证明领导的话是对的。&lt;/p&gt;
&lt;p&gt;    不管是1还是2，其实做事的方法是一样的，就是以下步骤循环使用，直到问题被解释/证明出来。&lt;/p&gt;
&lt;p&gt;    1、抓重点。&lt;/p&gt;
&lt;p&gt;    2、往下拆。&lt;/p&gt;
&lt;p&gt;    我工作中，重点是这么理解的：用最少的动因组合解释80%以上的异动情况。&lt;/p&gt;
&lt;p&gt;    往下拆是这么理解的：如果解释还不能满足需求，就需要把动因再找个维度，往下拆解一层。然后对拆解的内容继续抓重点，往下拆。&lt;/p&gt;
&lt;p&gt;    所以面试中我都会问一个问题：针对XXX情况，请你至少找2个维度来分析这件事。&lt;/p&gt;
&lt;p&gt;    至于需要掌握的技能嘛，身为互联网大数据行业，SQL必须要会。大部分传统行业来面试的，因为SQL不过关被我毙掉了。因为没耐心教怎么写SQL，还是要找个来了就直接能写的才行。工具方面excel肯定要会，matlab、spss等，会1、2个就行，没有什么特殊要求。计算机语言也得会一个，最好是Python，如果不会Java、C/C++也可以。相比起来，Python更简单，更好学。计算机语言是作为胶水使用的。把数据库导出的数据预处理一下，输入到分析软件中。数据库和分析软件之间的胶水。所以不需要掌握的很好，毕竟不是做工程，只是在分析师的工作电脑上做一个数据格式转换和基础的清洗而已。代码写的有内存泄露、复用性差，这些都不是问题。&lt;/p&gt;
&lt;p&gt;    这次成功的把一个前端开发培养成了一个数据分析师，也是很欣慰的。堪称0基础手把手教会的经典案例。&lt;/p&gt;
</description>
<pubDate>Sun, 20 May 2018 07:35:00 +0000</pubDate>
<dc:creator>向薇佳</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caexiang/p/9063570.html</dc:identifier>
</item>
<item>
<title>salesforce lightning零基础学习(四)  事件（component events）简单介绍 - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/8977093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/8977093.html</guid>
<description>&lt;p&gt;lightning component基于事件驱动模型来处理用户界面的交互。这种事件驱动模型和js的事件驱动模型也很相似，可以简单的理解成四部分：&lt;/p&gt;
&lt;p&gt;1.事件源：产生事件的地方，可以是页面中的输入框，按钮等等；&lt;/p&gt;
&lt;p&gt;2.事件： 点击，失去焦点，初始化等等；&lt;/p&gt;
&lt;p&gt;3.事件对象：当在事件源触发某个事件的时候，一般会产生一个事件对象，记录着事件的事件源相关信息以及相关的事件信息；&lt;/p&gt;
&lt;p&gt;4.事件处理程序（Event Handler）：对当前的事件进行程序的处理或者函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201805/910966-20180520112627765-600065373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来回到lightning中。在lightning component使用 handler方式作为事件处理程序绑定事件，用来当某些事件发生后，可以反馈到绑定到事件处理程序上。事件通过javascript controller层的action来触发执行。在事件触发以前，我们可以设置attribute值用来作为参数传递。&lt;/p&gt;
&lt;p&gt;事件Events 通过aura:event来声明，声明后所在的位置为aura目录下，后缀名为.evt 如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201805/910966-20180506143536314-1941783270.png&quot; alt=&quot;&quot;/&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201805/910966-20180506143628329-335834550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事件类型分成两类： component events 以及application events.官方推荐可以情况下尽量使用component events,后面的内容也是以component event进行说明，关于application events，感兴趣的可以自行查看文档。 event使用可以分成以下几步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一. 创建自定义Event&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自定义事件头部由aura:event作为开始， type可以为COMPONENT以及APPLICATION，type定义了当前的这个事件属于component event还是application event。&lt;/p&gt;
&lt;p&gt;事件还可以添加多个aura:attribute，执行此事件前可以先对这些attribute赋值来传递参数数据。在js后台部分可以使用event.setParam('attributeName',attributeValue)方式对预装载的参数赋值。&lt;/p&gt;
&lt;p&gt;我们简单声明一个component event，名称为 messageEvt,有一个attribute，名字是message,类型为String。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:event &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;COMPONENT&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:event&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下的二、三步均需要写在lightning component中，这里创建了一个lighnting component:MessageEventComponent.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二. 注册事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建完事件后需要在lightning component中进行注册以后才可以进行接下来的使用。使用aura:registerEvent标签进行注册事件。&lt;/p&gt;
&lt;p&gt; aura:registerEvent有两个属性，一个是name，一个是type。name是任意起的，这个name需要和后面提到的aura:handler中的name一致。 type为你的namespace + ':' + 事件名称，这里为c:messageEvt。整体如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:registerEvent &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;componentEvent&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;c:messageEvt&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三. 设置事件的处理程序(handler)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们注册完事件以后，我们需要考虑当事件被触发以后，要做什么。所以这里我们需要配置一下事件的handler部分，当事件触发以后，我们让他去执行controller的某个方法去进行业务逻辑的操作。配置handler需要使用aura:handler标签，主要有几个属性：&lt;/p&gt;
&lt;p&gt;name ： 此属性用来定义handler句柄名称，此值需要和aura:registerEvent的name的值相同，这里是componentEvent；&lt;/p&gt;
&lt;p&gt;event ： 此属性用来绑定对应的component event，此值和aura:registerEvent的type的值相同，这里是c:messageEvt；&lt;/p&gt;
&lt;p&gt;action ： 此属性用来绑定当事件执行后需要调用的controller js的方法；&lt;/p&gt;
&lt;p&gt;phase ： 自定义事件可以分成两种phase，分别为Bubble和Capture，默认为Bubble。以后会对这两种区别进行说明；&lt;/p&gt;
&lt;p&gt;value ：  此属性用来定义监控的值，通常在自定义的事件中不会设置，此属性更多的会应用在 aura:handler name 为 'init' 以及'change'的情况。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;messageAttribute&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:registerEvent &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;componentEvent&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;c:messageEvt&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:handler &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;init&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{!this}&quot;&lt;/span&gt;&lt;span&gt; action&lt;/span&gt;&lt;span&gt;=&quot;{!c.handlerInit}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:handler &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;change&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{!v.messageAttribute}&quot;&lt;/span&gt;&lt;span&gt; action&lt;/span&gt;&lt;span&gt;=&quot;{!c.handlerMessageChange}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:handler &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;componentEvent&quot;&lt;/span&gt;&lt;span&gt; event&lt;/span&gt;&lt;span&gt;=&quot;c:messageEvt&quot;&lt;/span&gt;&lt;span&gt; action&lt;/span&gt;&lt;span&gt;=&quot;{!c.handlerMessageEvt}&quot;&lt;/span&gt;&lt;span&gt; phase&lt;/span&gt;&lt;span&gt;=&quot;bubble&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四. 触发事件（Fire Event）：触发事件需要写在controller.js中，这里是MessageEventComponentController.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当controller/helper js  可以使用component.getEvent(eventName) 来获取事件的实例化变量（这里的eventName取得是registerEvent中的name值），通过setParam方法设置自定义事件中设置的aura:attribute，通过fire()方法触发事件，事件触发后，事件驱动模型会执行绑定的处理程序的handlerMessageEvt方法。&lt;/p&gt;
&lt;p&gt;此处的demo为lightning component初始化会调用event handler 方法执行handlerMessageEvt函数，通过messageAttribute的变化从而执行change事件的句柄handlerMessageChange函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    handlerInit : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        console.log(&lt;/span&gt;'execute init'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; messageEvent = component.getEvent('componentEvent'&lt;span&gt;);
        messageEvent.setParam(&lt;/span&gt;'message','testAfterUpdate'&lt;span&gt;);
        messageEvent.fire();
    },
    handlerMessageChange : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component,event,helper) {
        console.log(&lt;/span&gt;'execute change'&lt;span&gt;);
        console.log(&lt;/span&gt;'old value : ' + event.getParam('oldValue'&lt;span&gt;));
        console.log(&lt;/span&gt;'current value : ' + event.getParam('value'&lt;span&gt;));
    },
    handlerMessageEvt : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component,event,helper) {
        console.log(event.getParam(&lt;/span&gt;'message'&lt;span&gt;));
        component.set(&lt;/span&gt;'v.messageAttribute',event.getParam('message'&lt;span&gt;));
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 结果展示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个MessageEventApplication包含messageEventComponent用于结果展示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:messageEventComponent&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：通过运行结果可以看出来，初始化时会执行自定义事件，自定义事件对messageAttribute的改变会触发change标准事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201805/910966-20180520142418045-109423018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 总结：&lt;/strong&gt;此篇只是简单的介绍lightning中自定义Component Event的实现步骤，至于自定义Event的两种phase以及生命周期等知识后期会深入介绍。篇中如果有错误的地方欢迎指正，有问题欢迎留言。&lt;/p&gt;
</description>
<pubDate>Sun, 20 May 2018 06:49:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/8977093.html</dc:identifier>
</item>
<item>
<title>JavaWeb学习(一) ---- HTTP以及Tomcat的安装及使用 - 阿来丶</title>
<link>http://www.cnblogs.com/JiangLai/p/9062697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JiangLai/p/9062697.html</guid>
<description>&lt;h3&gt;一、协议&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　双方在交互、通讯的时候，遵循的一种规范，一种规则。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 二、HTTP协议&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　HTTP的全名是：Hypertext Transfer Protocol（超文本传输协议），针对网络上的客户端与服务器端在执行http协议的时候，遵循的一种规范。其实就是规定了客户端在访问服务器的时候，需要传送什么东西，服务器响应客户端的时候需要返回什么东西。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;blogTitle2&quot;&gt;三、HTTP1.0和HTTP1.1的区别&lt;/h3&gt;
&lt;p&gt;　　在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。&lt;/p&gt;
&lt;p&gt;　　在HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上可以获取多个web资源。&lt;/p&gt;
&lt;h3&gt;四、HTTP请求&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;　　请求的数据里面包含三个部分内容 ： 请求行 、 请求头 、请求体。&lt;br/&gt;　　&lt;strong&gt;请求行&lt;/strong&gt;：请求方式有：POST、GET、HEAD、OPTIONS、DELETE、TRACE、PUT，常用的有： GET、 POST&lt;br/&gt;　　GET和POST的区别：　　　&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520092747808-1308689923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　请求头&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*
        Referer: http://localhost:8080/examples/servlets/servlet/RequestParamExample
        Accept-Language: zh-CN
        User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)
        Content-Type: application/x-www-form-urlencoded
        Accept-Encoding: gzip, deflate
        Host: localhost:8080
        Content-Length: 31
        Connection: Keep-Alive
        Cache-Control: no-cache
-----------------------------------------------------------------------------
        Accept: 客户端向服务器端表示，我能支持什么类型的数据。 
        Referer ： 真正请求的地址路径，全路径
        Accept-Language: 支持语言格式
        User-Agent: 用户代理 向服务器表明，当前来访的客户端信息。 
        Content-Type： 提交的数据类型。经过urlencoding编码的form表单的数据
        Accept-Encoding： gzip, deflate ： 压缩算法 。 
        Host ： 主机地址
        Content-Length： 数据长度
        Connection : Keep-Alive 保持连接
        Cache-Control ： 对缓存的操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　请求体&lt;/strong&gt;：HTML代码&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;五、HTTP响应&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;　　请求的数据里面包含三个部分内容 ： 响应行 、 响应头 、响应体。&lt;br/&gt;　　&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;* 响应行
    
        HTTP/1.1 200 OK

        协议版本  

        状态码 (JS中详细解释了，这里只列出一些常见的)
        
            200 : 成功，正常处理，得到数据。
            403  : for bidden  拒绝
            404 ： Not Found
            500 ： 服务器异常

* 响应头

        Server:  服务器是哪一种类型。  Tomcat
    
        Content-Type ： 服务器返回给客户端你的内容类型

        Content-Length ： 返回的数据长度

        Date ： 通讯的日期，响应的时间    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;1.下载Tomcat&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;官网地址：&lt;a href=&quot;http://tomcat.apache.org/whichversion.html&quot;&gt;http://tomcat.apache.org/whichversion.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520141050590-1607491551.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;2.安装Tomcat&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　1. 直接解压 ，然后找到bin/startup.bat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. 可以安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　启动之后，如果能够正常看到黑窗口，表明已经成功安装。 为了确保万无一失， 最好在浏览器的地址栏上输入 ： http://localhost:8080 , 如果有看到内容 就表明成功了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. 如果双击了startup.bat,  看到一闪而过的情形，一般都是 JDK的环境变量没有配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520142324993-740956627.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;3.Tomcat目录&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520141515400-774701624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　bin&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&amp;gt; 包含了一些jar ,  bat文件 。  startup.bat&lt;br/&gt;　　conf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　tomcat的配置     server.xml  web.xml&lt;br/&gt;　　lib&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　tomcat运行所需的jar文件&lt;br/&gt;　　logs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　运行的日志文件&lt;br/&gt;　　temp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　临时文件&lt;br/&gt;　　webapps&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　发布到tomcat服务器上的项目，就存放在这个目录。    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　work(目前不用管)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　jsp翻译成class文件存放地&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.使用Tomcat发布WEB项目&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;需求： 如何能让其他的电脑访问我这台电脑上的资源 。 aa.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    浏览器地址栏写法：localhost : 本机地址/项目名/文件夹名/文件名&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　拷贝这个文件到webapps/ROOT底下， 在浏览器里面访问：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        http://localhost:8080/stu.xml&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        使用IP地址访问：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;/span&gt;&lt;br/&gt;&lt;span&gt;        http://192.168.5.437:8080/aa.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520142208827-743690210.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 5.WEB应用的目录结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520142353811-1510302688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　步骤一、获得服务器运行环境配置，Window/Preferences/Server/Runtime Environmen（每个版本的位置不同，自己寻找）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520142517250-772029453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　步骤二、点击add选择自己下载的Tomcat版本，点击下一步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520142618019-1087058342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　步骤三、选在自己的Tomcat主目录文件夹点击finish&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520142723381-1626513678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　步骤四、查看server中是否出现自己的Tomcat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520142834110-1256521270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 步骤五、测试自己的Tomcat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520142930607-1410085459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　步骤六、将自己的JSP项目配置到Tomcat中（具体怎么建立WEB项目以后会介绍）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520143153577-384302659.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350478/201805/1350478-20180520143234616-1573736740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 20 May 2018 06:34:00 +0000</pubDate>
<dc:creator>阿来丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JiangLai/p/9062697.html</dc:identifier>
</item>
<item>
<title>微信开发相关，了解一下 - 子慕大诗人</title>
<link>http://www.cnblogs.com/1wen/p/9024873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1wen/p/9024873.html</guid>
<description>&lt;h2&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　从微信公众号到现在的小程序，涉及微信开发方面的内容越来越多，工作大多时候是需要我们更了解微信开发的，比如老大说要做个什么东西，涉及到微信的，我们能立马想到方案或者提出可行性的分析吗？  因为微信开发有它自己的一套规则，有它自己的一套框架，有一定它带来的便利，也就有它带来的限制。  这篇文章，不写入门，不写开发流程，主要聊聊最近的一些调研和细节。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;主要平台：&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;开放平台            （文档：微信开放平台文）&lt;/li&gt;
&lt;li&gt;公众平台&amp;amp;小程序 （文档：微信公众平台文档&amp;amp;微信小程序文档）&lt;/li&gt;
&lt;li&gt;商户平台            （文档：微信支付文档）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　&lt;span&gt;1）&lt;/span&gt;开放平台包含了：移动应用，网站应用，公众号和小程序，第三方平台。    &lt;/p&gt;
&lt;ol&gt;&lt;li&gt;移动应用：在开放平台创建移动应用和app关联，为app提供微信支付、分享到微信等等功能&lt;/li&gt;
&lt;li&gt;网站应用：使网站支持使用微信帐号来登录&lt;/li&gt;
&lt;li&gt;公众号和小程序：在开放平台里，可以绑定公众号和小程序，绑定后会触发unionId机制，帮助不同公众号或者小程序打通用户体系。&lt;/li&gt;
&lt;li&gt;第三方平台：代小程序和公众号调用接口，提供运营服务和行业解决方案&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　&lt;span&gt;2）&lt;/span&gt;公众平台包含：订阅号、服务号、小程序&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;3）&lt;/span&gt;商户平台：主要支持微信支付，包括线上线下的支付应用场景&lt;/p&gt;

&lt;p&gt;　　三者关系如下图，所有应用都属于开放平台，开放平台可以绑定小程序和公众号使它们关联起来，商户平台为所有应用提供支付功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201805/623144-20180520124233503-1914404936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　如何更好的理解他们呢？  当然是走一遍所有的流程，所谓流程也包括了注册，微信文档在大多数时候并没有特别详细，文档告诉了我们几步流程，但每个流程里面含有什么内容我们不知道，我好几次在文档怎么也找不到我想要的一些细节点。  最后还是自己走一遍流程才理解，所以你想要更清楚细节，最好都能自己去注册一遍。  微信开发相关的内容很多，研发要关注的不只是怎么调用接口，而还需要关注平台相互之间的关系，运营规范，设计规范等等。  &lt;/p&gt;

&lt;h2&gt;&lt;span&gt;列举一些比较常遇到的问题&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;微信授权OAuth2.0&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　微信授权几乎是所有微信开发下应用入口接口，用户授权后，通过请求微信后端，我们才能拿到用户信息，授权流程大致如下：&lt;/p&gt;
&lt;p&gt;　　1. 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；&lt;br/&gt;　　2. 通过code参数加上AppID和AppSecret等，通过API换取access_token；&lt;br/&gt;　　3. 通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作&lt;/p&gt;
&lt;p&gt;　　官方文档：Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）。&lt;/p&gt;
&lt;p&gt;　　说起这个问题，当时也出现一个事故，在微信公众平台后台appsecret没有修改的功能，只能重置。微信后台也有统计功能，当时运营同事就要求给他们账户，他们方便实时查看。  第二天我们就发现业务功能出问题了，无法用了，前端查问题，后端查问题，怎么看业务逻辑都没有动过，不会是代码改出的问题，后端查日志就是微信那块报的错。  结果是一个运营同事皮，公众后台里面的所有功能都去点过一次，把appsecret给重置了。  结论是后台权限还是别给非研发同事吧，如果要给，也要提前提醒一下这些注意事项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201805/623144-20180515115337195-1051608714.png&quot; alt=&quot;&quot; width=&quot;1408&quot; height=&quot;114&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;消息分发相关&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　产品是需要提醒用户的，消息通知在平时的开发中显得尤为重要，也常因为消息的规则可能会影响最初的产品需求。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公众号可以以一定频次群发消息（订阅号为每天1次，服务号为每月4次）&lt;/li&gt;
&lt;li&gt;公众号模板消息可以用特定内容模板，主动向用户发送消息，可以带上链接，可以说没有次数限制&lt;/li&gt;
&lt;li&gt;小程序的模版消息需要用户有交互通过form组件拿到formId才能向用户发送模板&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;span&gt;微信分享&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　在开放平台注册移动应用后申请的App通过审核后，即可获得微信分享及收藏权限。&lt;/p&gt;
&lt;p&gt;　　如果在网页中需要如下步骤：&lt;/p&gt;
&lt;p&gt;　　  1.微信公众平台里填写“JS接口安全域名”&lt;/p&gt;
&lt;p&gt;　　  2.在需要调用JS接口的页面引入如下JS文件，（支持https）：&lt;a href=&quot;http://res.wx.qq.com/open/js/jweixin-1.2.0.js&quot;&gt;http://res.wx.qq.com/open/js/jweixin-1.2.0.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　  3.通过config接口注入权限验证配置（配置的签名需要后端获取）&lt;/p&gt;
&lt;p&gt;　　目前一个公众号可以填写三个js接口安全域名地址。  大部分公司的前端页面都部署到某一个域名下的，后端可以只提供一个公众号的签名接口作为公共服务，其他公众号的业务在同一个域名下都能调用这个接口，以完成jssdk签名配置。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;微信支付&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;1）&lt;/span&gt;要使用微信支付，我们的商户号的公司主体必须和公众号小程序等注册主体一样，否则无法绑定商户号。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;2）&lt;/span&gt;如何实现测试公众号支付：&lt;/p&gt;
&lt;p&gt;　　生成一个字典，存储测试用户的测试公众号和正式公众号的openId，当测试用户在测试公众号唤起支付的时候，后端把测试公众号的openId替换为正式公众号，并使用同主体商户号，便可以正常支付。  其实就是走正式的支付，调用测试的回调。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;3）&lt;/span&gt;商户号绑定公众号：&lt;/p&gt;
&lt;p&gt;　　微信的开发者文档有时候某些文档不是很好找，入口比较深，比如最初我想找到商户号如何和多个公众号绑定，找半天没有相关文档，几个开发文档里搜索也没有。  而在微信公众平台后台的“微信支付”里，也找不到相关的文档和入口。  还好因为公司有商户号，我登录进去看了看才找到，如果是新手，在做技术调研的时候，可能会找不到文档。  最开始我还以为商户号和公众号后台都能相互申请绑定，但是确实只有商户号里面才有此功能。  商户平台新增了授权申请单以后，对应的公众平台后台便在【微信支付 ~ M-A授权】下能看到。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 商户号绑定申请页面：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201805/623144-20180515200946897-1017869359.png&quot; alt=&quot;&quot; width=&quot;901&quot; height=&quot;546&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公众平台后台申请授权页面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201805/623144-20180515204717769-1632658661.png&quot; alt=&quot;&quot; width=&quot;631&quot; height=&quot;293&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
如何授权文档链接 &lt;a href=&quot;https://pay.weixin.qq.com/static/pay_setting/appid_protocol.shtml&quot; target=&quot;_blank&quot;&gt;https://pay.weixin.qq.com/static/pay_setting/appid_protocol.shtml&lt;/a&gt;，文档入口如下图（难找）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201805/623144-20180520135910715-357352628.png&quot; alt=&quot;&quot; width=&quot;857&quot; height=&quot;291&quot;/&gt;&lt;/p&gt;


&lt;p&gt;关于支付，企业后端应该对每种支付实现后提供一个公共服务，每当有新的公众号需要支付的时候，只需要配置好相应的参数，调用公共服务下单即可。  如果有需要，前端也可以做一个钱包页面兼容多场景下的支付。  如果账户体系打通了，钱包里会有充值的余额，用户还可以直接选择扣除余额，如果是在非微信浏览器中，钱包理应也有支付宝等支付方式。  但是钱包页面的存在会多一次跳转，如果在微信里用钱包页面，用户体验没有直接唤起支付好。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;通过开放平台打通账户体系&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;一个企业下面大部分的应用都希望拥有一个账户体系，相互之间的数据要能打通，而每一个公众号或者应用下面对应一个用户都有不同的openId也就无法在不同应用之间标识同一个用户，这个时候就需要用到微信开放平台。微信公众号、移动应用、小程序等都是通过openId来标识用户的唯一性，开放平台能够绑定这些应用，绑定之后同一个用户会生成unionid来体现用户的唯一性。详情&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140839&quot; target=&quot;_blank&quot;&gt;UnionID机制&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;目前一个开放平台下面可以绑定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;50个移动应用(native)&lt;/li&gt;
&lt;li&gt;10个网站应用&lt;/li&gt;
&lt;li&gt;50个同主体公司公众号，5个不同主体公司公众号&lt;/li&gt;
&lt;li&gt;50个同主体公司小程序，5个不同主体公司小程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;span&gt;主体注册限制 &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　我之前一直在找一个公司能注册多少公众号，在公众平台开发者文档就一直没找到有说明。  结果这块的内容在qq客服那个网站上&lt;a href=&quot;http://kf.qq.com/faq/120911VrYVrA140428naUJVv.html&quot; target=&quot;_blank&quot;&gt;http://kf.qq.com/faq/120911VrYVrA140428naUJVv.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201805/623144-20180516192416145-1160595843.png&quot; alt=&quot;&quot; width=&quot;936&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;账号迁移&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　公众号主体一旦审核完成就不能更换。如果需要更换，只能新注册一个公众号做迁移，迁移只能迁移部分数据，一个用户在不同公众号openId不一样的原则，如果A公众号迁移到B公众号，需要进行一次openId转换，官方有接口，详情看：&lt;a href=&quot;http://kf.qq.com/faq/170221aUnmmU170221eUZJNf.html&quot; target=&quot;_blank&quot;&gt;http://kf.qq.com/faq/170221aUnmmU170221eUZJNf.html&lt;/a&gt;。  目前小程序无法迁移。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　微信开发容易出现很多坑，不止于技术带来的，而其体量也越来越大，前后端都应该了解整个开发流程、开发配置、运营规则等等，否则容易出了问题不知道是谁的问题，解决问题的效率会非常低，甚至相互甩锅。  微信生态功能在不停的迭代，开发者技术文档、各种政策也时而变更，这些都是我们需要时刻关注的。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 May 2018 06:28:00 +0000</pubDate>
<dc:creator>子慕大诗人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1wen/p/9024873.html</dc:identifier>
</item>
<item>
<title>第3课 - 异常类构建 - 原野追逐</title>
<link>http://www.cnblogs.com/songhe364826110/p/9054031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songhe364826110/p/9054031.html</guid>
<description>&lt;h3&gt;本篇开始正式进入数据结构的相关内容，目标是基于C++语言，设计一个可复用的数据结构类库DTLib。&lt;/h3&gt;

&lt;h3&gt;1. C++异常类简介&lt;/h3&gt;
&lt;p&gt; - C++异常的类型可以是&lt;span data-mce-=&quot;&quot;&gt;自定义类类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; - catch语句对于类类型异常的匹配，依旧是&lt;span data-mce-=&quot;&quot;&gt;自上而下严格匹配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; - &lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt;赋值兼容性原则&lt;/span&gt;（在出现父类对象的地方，可以用一个子类对象来代替）在异常类型匹配中依然适用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; - &lt;span data-mce-=&quot;&quot;&gt;匹配子类异常的catch放在上面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; - &lt;span data-mce-=&quot;&quot;&gt;匹配父类异常的catch放在下面&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2. 异常类设计&lt;/h3&gt;
&lt;p&gt;现代C++库必然包含&lt;span&gt;充要的&lt;/span&gt;异常类族，异常类是数据结构类所依赖的&lt;span&gt;“基础设施”&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;【异常类组成】&lt;/p&gt;
&lt;p&gt;DTLib中的异常类由1个顶层父类和5个异常子类组成，其UML类图如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1053346/201805/1053346-20180520123956662-1685275022.jpg&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;184&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 【异常类功能定义】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1053346/201805/1053346-20180520124116552-1780585425.jpg&quot; alt=&quot;&quot; width=&quot;395&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3. 顶层父类Exception设计&lt;/h3&gt;
&lt;p&gt;【接口设计】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *m_message;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛异常时的提示消息&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *m_location;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛异常的位置，格式为“file:line”
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有辅助函数，用于简化三个构造函数实现&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; init(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     Exception(&lt;span&gt;const&lt;/span&gt; Exception &amp;amp;&lt;span&gt;e);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     Exception &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; Exception &amp;amp;&lt;span&gt;e);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;在处理异常时，用来获取异常消息和异常发生位置&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message() &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *location() &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; ~Exception() = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【构造函数实现】&lt;/p&gt;
&lt;p&gt;1. 先来实现init()，之所以设计这个私有函数，是因为重载的三个构造函数内部逻辑是差不多的，所以先在init()中完成该逻辑，然后分别在三个构造函数中调用，可以减小冗余代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Exception::init(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     m_message = (message ? strdup(message) : NULL);&lt;span&gt; &lt;br/&gt;4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (file !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; sline[&lt;span&gt;16&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         itoa(line, sline, &lt;span&gt;10&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将行号转换为字符串&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;动态申请内存，拷贝文件名，并拼接上行号，最终组成m_loction&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         m_location = static_cast&amp;lt;&lt;span&gt;char&lt;/span&gt; *&amp;gt;(&lt;span&gt;malloc&lt;/span&gt;(strlen(file) + strlen(sline) + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         m_location =&lt;span&gt; strcpy(m_location, file);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         m_location = strcat(m_location, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         m_location =&lt;span&gt; strcat(m_location, sline);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         m_location =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：参数message指向的字符串可能位于堆、栈或其他地方，如果代码第3行直接用m_message = message，会导致DTLib库无法控制字符串的生命周期，这是不安全的，因此使用strdup在库内部单独拷贝保存一份。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 2. 接下来实现三个构造函数接口，可以看到有了init()之后，这三个函数的实现都变得非常简单了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Exception::Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     init(message, NULL, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; Exception::Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    init(NULL, file, line);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; Exception::Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    init(message, file, line);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 【拷贝构造和赋值操作符重载实现】&lt;/p&gt;
&lt;p&gt;从init()可以看出，构造异常类对象时在堆空间动态申请了内存，说明拷贝构造和赋值操作内部必须实现为深拷贝，而默认情况下它们都是浅拷贝，需要自行实现拷贝构造函数和重载赋值操作符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Exception::Exception(&lt;span&gt;const&lt;/span&gt; Exception &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     m_message =&lt;span&gt; strdup(e.m_message);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     m_location =&lt;span&gt; strdup(e.m_location);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; Exception &amp;amp;Exception::&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; Exception &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; != &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(m_message);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(m_location);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         m_message =&lt;span&gt; strdup(e.m_message);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         m_location =&lt;span&gt; strdup(e.m_location);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【异常消息和异常位置获取函数实现】&lt;/p&gt;
&lt;p&gt;这两个函数的实现非常简单，直接将m_message和m_location返回就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *Exception::message() &lt;span&gt;const&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_message;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *Exception::location() &lt;span&gt;const&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_location;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【析构函数实现】&lt;/p&gt;
&lt;p&gt;看到这里大家可能会有疑问，既然析构函数被设计为纯虚函数，而纯虚函数的实现应该在子类中完成，为什么还要在这里提供纯虚函数的函数体呢？&lt;/p&gt;
&lt;p&gt;其实，这里是一个例外，&lt;span&gt;&lt;strong&gt;C++规定：只要自定义了析构函数，不管析构函数是不是纯虚函数，都必须提供实现&lt;/strong&gt;&lt;/span&gt;。否则其子类对象析构时，会因为找不到父类析构函数的实现而导致析构失败。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Exception::~&lt;span&gt;Exception()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(m_message);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(m_location);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. 异常子类实现&lt;/h3&gt;
&lt;p&gt;5个异常子类均继承自Exception，主要实现几个构造函数、拷贝构造函数和赋值操作符重载函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArithmeticException : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     ArithmeticException() : Exception(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     ArithmeticException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message) : Exception(message) { }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     ArithmeticException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(file, line) { }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     ArithmeticException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(message, file, line) { }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     ArithmeticException(&lt;span&gt;const&lt;/span&gt; ArithmeticException&amp;amp;&lt;span&gt; e) : Exception(e) { }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     ArithmeticException &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; ArithmeticException &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         Exception::&lt;span&gt;operator&lt;/span&gt; =&lt;span&gt;(e);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NullPointerException : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     NullPointerException() : Exception(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     NullPointerException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message) : Exception(message) { }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     NullPointerException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(file, line) { }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     NullPointerException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(message, file, line) { }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     NullPointerException(&lt;span&gt;const&lt;/span&gt; NullPointerException&amp;amp;&lt;span&gt; e) : Exception(e) { }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     NullPointerException &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; NullPointerException &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Exception::&lt;span&gt;operator&lt;/span&gt; =&lt;span&gt;(e);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IndexOutOfBoundsException : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     IndexOutOfBoundsException() : Exception(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     IndexOutOfBoundsException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message) : Exception(message) { }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     IndexOutOfBoundsException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(file, line) { }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     IndexOutOfBoundsException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(message, file, line) { }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     IndexOutOfBoundsException(&lt;span&gt;const&lt;/span&gt; IndexOutOfBoundsException&amp;amp;&lt;span&gt; e) : Exception(e) { }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     IndexOutOfBoundsException &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; IndexOutOfBoundsException &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         Exception::&lt;span&gt;operator&lt;/span&gt; =&lt;span&gt;(e);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NoEnoughMemoryException : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     NoEnoughMemoryException() : Exception(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     NoEnoughMemoryException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message) : Exception(message) { }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     NoEnoughMemoryException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(file, line) { }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     NoEnoughMemoryException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(message, file, line) { }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;     NoEnoughMemoryException(&lt;span&gt;const&lt;/span&gt; NoEnoughMemoryException&amp;amp;&lt;span&gt; e) : Exception(e) { }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     NoEnoughMemoryException &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; NoEnoughMemoryException &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         Exception::&lt;span&gt;operator&lt;/span&gt; =&lt;span&gt;(e);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InvalidParameterException : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     InvalidParameterException() : Exception(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     InvalidParameterException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message) : Exception(message) { }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     InvalidParameterException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(file, line) { }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;     InvalidParameterException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(message, file, line) { }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;     InvalidParameterException(&lt;span&gt;const&lt;/span&gt; InvalidParameterException&amp;amp;&lt;span&gt; e) : Exception(e) { }
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     InvalidParameterException &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; InvalidParameterException &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         Exception::&lt;span&gt;operator&lt;/span&gt; =&lt;span&gt;(e);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5. 抛异常操作简化设计&lt;/h3&gt;
&lt;p&gt;至此，DTLib异常类构建基本全部完成，按照我们的设计，在抛异常时的代码是这么写的： &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;throw Exception&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, __FILE__, __LINE__);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果在每一个需要抛异常的地方都这么写，会比较繁琐，而且代码有冗余，看起来也不太美观，因此设计下面这个宏来简化抛异常的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛异常，e为异常类类型，m为提示消息字符串&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; THROW_EXCEPTION(e, m) (throw e(m, __FILE__, __LINE__))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一来，上面的抛异常操作就简化为 &lt;span class=&quot;cnblogs_code&quot;&gt;THROW_EXCEPTION(Exception, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;6. 异常类完整源代码&lt;/h3&gt;
&lt;p&gt;最后，给出DTLib异常类的完整源代码。&lt;/p&gt;
&lt;p&gt;【Exception.h】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#ifndef EXCEPTION_H
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; EXCEPTION_H
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DTLib
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛异常，e为异常类类型，m为提示消息字符串&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; THROW_EXCEPTION(e, m) (throw e(m, __FILE__, __LINE__))
&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *m_message;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛异常时的提示消息&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *m_location;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛异常的位置，格式为“file:line”
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有辅助函数，用于简化三个构造函数实现&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; init(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line);
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;     Exception(&lt;span&gt;const&lt;/span&gt; Exception &amp;amp;&lt;span&gt;e);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     Exception &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; Exception &amp;amp;&lt;span&gt;e);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;在处理异常时，用来获取异常消息和异常发生位置&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message() &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *location() &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; ~Exception() = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArithmeticException : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     ArithmeticException() : Exception(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { }
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     ArithmeticException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message) : Exception(message) { }
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     ArithmeticException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(file, line) { }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     ArithmeticException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(message, file, line) { }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;     ArithmeticException(&lt;span&gt;const&lt;/span&gt; ArithmeticException&amp;amp;&lt;span&gt; e) : Exception(e) { }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     ArithmeticException &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; ArithmeticException &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         Exception::&lt;span&gt;operator&lt;/span&gt; =&lt;span&gt;(e);
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NullPointerException : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     NullPointerException() : Exception(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     NullPointerException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message) : Exception(message) { }
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     NullPointerException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(file, line) { }
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     NullPointerException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(message, file, line) { }
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;     NullPointerException(&lt;span&gt;const&lt;/span&gt; NullPointerException&amp;amp;&lt;span&gt; e) : Exception(e) { }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     NullPointerException &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; NullPointerException &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         Exception::&lt;span&gt;operator&lt;/span&gt; =&lt;span&gt;(e);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IndexOutOfBoundsException : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     IndexOutOfBoundsException() : Exception(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;     IndexOutOfBoundsException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message) : Exception(message) { }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     IndexOutOfBoundsException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(file, line) { }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     IndexOutOfBoundsException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(message, file, line) { }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;     IndexOutOfBoundsException(&lt;span&gt;const&lt;/span&gt; IndexOutOfBoundsException&amp;amp;&lt;span&gt; e) : Exception(e) { }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     IndexOutOfBoundsException &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; IndexOutOfBoundsException &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         Exception::&lt;span&gt;operator&lt;/span&gt; =&lt;span&gt;(e);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NoEnoughMemoryException : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     NoEnoughMemoryException() : Exception(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     NoEnoughMemoryException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message) : Exception(message) { }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     NoEnoughMemoryException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(file, line) { }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     NoEnoughMemoryException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(message, file, line) { }
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt;     NoEnoughMemoryException(&lt;span&gt;const&lt;/span&gt; NoEnoughMemoryException&amp;amp;&lt;span&gt; e) : Exception(e) { }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     NoEnoughMemoryException &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; NoEnoughMemoryException &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         Exception::&lt;span&gt;operator&lt;/span&gt; =&lt;span&gt;(e);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InvalidParameterException : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     InvalidParameterException() : Exception(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     InvalidParameterException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message) : Exception(message) { }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;     InvalidParameterException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(file, line) { }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     InvalidParameterException(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line) : Exception(message, file, line) { }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;     InvalidParameterException(&lt;span&gt;const&lt;/span&gt; InvalidParameterException&amp;amp;&lt;span&gt; e) : Exception(e) { }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;     InvalidParameterException &amp;amp;&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; InvalidParameterException &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         Exception::&lt;span&gt;operator&lt;/span&gt; =&lt;span&gt;(e);
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; EXCEPTION_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【Exception.cpp】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;cstring&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;cstdlib&amp;gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DTLib
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Exception::init(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * message指向的字符串可能位于堆、栈或其他地方，如果直接用m_message = message，
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * 会导致DTLib库无法控制字符串的生命周期，这是不安全的，因此使用strdup在库内部
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 单独拷贝保存一份。
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     m_message = (message ? strdup(message) : NULL);&lt;br/&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (file !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; sline[&lt;span&gt;16&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         itoa(line, sline, &lt;span&gt;10&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将行号转换为字符串&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;动态申请内存，拷贝文件名，并拼接上行号，最终组成m_loction&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         m_location = static_cast&amp;lt;&lt;span&gt;char&lt;/span&gt; *&amp;gt;(&lt;span&gt;malloc&lt;/span&gt;(strlen(file) + strlen(sline) + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         m_location =&lt;span&gt; strcpy(m_location, file);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         m_location = strcat(m_location, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         m_location =&lt;span&gt; strcat(m_location, sline);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         m_location =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; Exception::Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;message)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     init(message, NULL, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; Exception::Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    init(NULL, file, line);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; Exception::Exception(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *message, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *file, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    init(message, file, line);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从init()的实现可以看出，拷贝构造和赋值操作必须为深拷贝&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; Exception::Exception(&lt;span&gt;const&lt;/span&gt; Exception &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     m_message =&lt;span&gt; strdup(e.m_message);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     m_location =&lt;span&gt; strdup(e.m_location);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; Exception &amp;amp;Exception::&lt;span&gt;operator&lt;/span&gt; = (&lt;span&gt;const&lt;/span&gt; Exception &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; != &amp;amp;&lt;span&gt;e)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(m_message);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(m_location);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;         m_message =&lt;span&gt; strdup(e.m_message);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         m_location =&lt;span&gt; strdup(e.m_location);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *Exception::message() &lt;span&gt;const&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_message;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *Exception::location() &lt;span&gt;const&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_location;
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt; &lt;span&gt; * C++规定，只要自定义了析构函数，不管是不是纯虚函数，都必须提供实现，
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt; * 否则其子类对象析构时，会因为找不到父类析构函数的实现而导致析构失败。
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;85&lt;/span&gt; Exception::~&lt;span&gt;Exception()
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(m_message);
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(m_location);
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; 
&lt;span&gt;91&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;注：本文整理于狄泰《数据结构开发实战教程》课程内容&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 May 2018 06:10:00 +0000</pubDate>
<dc:creator>原野追逐</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songhe364826110/p/9054031.html</dc:identifier>
</item>
<item>
<title>JDK源码分析-String、StringBuilder、StringBuffer - 仍是少年</title>
<link>http://www.cnblogs.com/ashleyboy/p/9063153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashleyboy/p/9063153.html</guid>
<description>&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;String类的申明&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; String
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt; java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {…}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;String类用了final修饰符，表示它不可以被继承，同时还实现了三个接口, 实现Serializable接口表示String类可被序列化；实现Comparable&amp;lt;T&amp;gt; 接口主要是提供一个compareTo 方法用于比较String字符串；还实现了CharSequence 接口，这个接口代表的是char值得一个可读序列（&lt;a title=&quot;java.nio 中的类&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/nio/CharBuffer.html&quot;&gt;CharBuffer&lt;/a&gt;, &lt;a title=&quot;javax.swing.text 中的类&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/javax/swing/text/Segment.html&quot;&gt;Segment&lt;/a&gt;, &lt;a title=&quot;java.lang 中的类&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html&quot;&gt;String&lt;/a&gt;, &lt;a title=&quot;java.lang 中的类&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;, &lt;a title=&quot;java.lang 中的类&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/StringBuilder.html&quot;&gt;StringBuilder&lt;/a&gt;也都实现了CharSequence接口）&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;String主要字段、属性说明&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;字符数组value，存储String中实际字符 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt; value[];
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;字符串的哈希值 默认值0&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;字符串的哈希值 默认值0&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;一个比较器，用来排序String对象,  compareToIgnoreCase方法中有使用 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Comparator&amp;lt;String&amp;gt;&lt;span&gt; CASE_INSENSITIVE_ORDER
                                         &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CaseInsensitiveComparator();
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;String 部分方法分析&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;String类提供了系列的构造函数，其中有几个都已经不推荐使用了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180520124522913-210691980.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;474&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;p&gt;以下是两个常用的构造函数的实现：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String str = new String(“123”)&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String(String original) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; original.value;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hash =&lt;span&gt; original.hash;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String str3 = new String(new char[] {'1','2','3'});&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; String(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; value[]) {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将字符数组值copy至value&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; Arrays.copyOf(value, value.length); 
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;boolean &lt;span lang=&quot;EN-US&quot;&gt;equals(Object anObject)&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; String 类重写了 equals 方法,将此字符串与指定的对象比较。当且仅当该参数不为 &lt;code&gt;null&lt;/code&gt;，并且是与此对象表示相同字符序列的 &lt;code&gt;String&lt;/code&gt; 对象时，结果才为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object anObject) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接将对象引用相比较，相同返回true&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; anObject) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较当前对象与anObject的字符序列value&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (anObject &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String) {
            String anotherString &lt;/span&gt;=&lt;span&gt; (String)anObject;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; value.length;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n ==&lt;span&gt; anotherString.value.length) {
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; v1[] =&lt;span&gt; value;
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; v2[] =&lt;span&gt; anotherString.value;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (n-- != 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (v1[i] !=&lt;span&gt; v2[i])
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    i&lt;/span&gt;++&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;int compareTo(String anotherString)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 逐位比较两个字符串的字符序列，如果某一位字符不相同，则返回该位的两个字符的Unicode 值的差，所有位都相同，则计算两个字符串长度之差，两个字符串相同则返回0&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(String anotherString) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len1 =&lt;span&gt; value.length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len2 =&lt;span&gt; anotherString.value.length;
&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;取长度较小的字符串的长度&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lim =&lt;span&gt; Math.min(len1, len2);
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; v1[] =&lt;span&gt; value;
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; v2[] =&lt;span&gt; anotherString.value;

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (k &amp;lt;&lt;span&gt; lim) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将两个字符串的字符序列value逐个比较，如果不等，则返回该位置两个字符的Unicode 之差&lt;/span&gt;
            &lt;span&gt;char&lt;/span&gt; c1 =&lt;span&gt; v1[k];
            &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c2 =&lt;span&gt; v2[k];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c1 !=&lt;span&gt; c2) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; c1 - c2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回Unicode 之差&lt;/span&gt;
&lt;span&gt;
            }
            k&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;长度较小的字符串所有位都比较完，则返回两个字符串长度之差
&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;如果两个字符串相同，那么长度之差为0，即相同字符串返回0&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; len1 -&lt;span&gt; len2;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;compareToIgnoreCase&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;(String str)方法实现于此类似，比较时忽略字符的大小写，实现方式如下：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(String s1, String s2) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n1 =&lt;span&gt; s1.length();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n2 =&lt;span&gt; s2.length();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; min =&lt;span&gt; Math.min(n1, n2);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; min; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c1 =&lt;span&gt; s1.charAt(i);
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c2 =&lt;span&gt; s2.charAt(i);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c1 !=&lt;span&gt; c2) {
                    c1 &lt;/span&gt;=&lt;span&gt; Character.toUpperCase(c1);
                    c2 &lt;/span&gt;=&lt;span&gt; Character.toUpperCase(c2);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c1 !=&lt;span&gt; c2) {
                        c1 &lt;/span&gt;=&lt;span&gt; Character.toLowerCase(c1);
                        c2 &lt;/span&gt;=&lt;span&gt; Character.toLowerCase(c2);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c1 !=&lt;span&gt; c2) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; No overflow because of numeric promotion&lt;/span&gt;
                            &lt;span&gt;return&lt;/span&gt; c1 -&lt;span&gt; c2;
                        }
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n1 -&lt;span&gt; n2;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;native String intern()&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;当调用 intern 方法时，如果池已经包含一个等于此 &lt;code&gt;String&lt;/code&gt; 对象的字符串（用 &lt;code&gt;equals(Object)&lt;/code&gt; 方法确定），则返回池中的字符串。否则，将此 &lt;code&gt;String&lt;/code&gt; 对象添加到池中，并返回此 &lt;code&gt;String&lt;/code&gt; 对象的引用。&lt;/p&gt;
&lt;p&gt;所有字面值字符串和字符串赋值常量表达式都使用 intern 方法进行操作，例如：String str1 = &quot;123&quot;;&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;String内存位置：常量池&lt;span lang=&quot;EN-US&quot;&gt;OR堆&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;String对象可以直接通过字面量创建，也可以通过构造函数创建，有什么区别呢？&lt;/p&gt;
&lt;p&gt; 1．通过字面量或者字面量字符串通过”+”拼接的方式创建的String对象存储在常量池中，实际创建时如果常量池中存在，则直接返回引用，如果不存在则创建该字符串对象&lt;/p&gt;
&lt;p&gt; 2．使用构造函数创建字符串对象，则直接在堆中创建一个String对象&lt;/p&gt;
&lt;p&gt; 3．调用intern方法，返回则会将该对象放入常量池（不存在则放入常量池，存在则返回引用）&lt;/p&gt;
&lt;p&gt;下面举例说明String对象内存分配情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        String str1 = &lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;&lt;span&gt;);
        String str2 &lt;/span&gt;= &quot;123&quot;&lt;span&gt;;
        String str3 &lt;/span&gt;= &quot;123&quot;&lt;span&gt;;
        String str4 &lt;/span&gt;=&lt;span&gt; str1.intern();
        System.out.println(str1&lt;/span&gt;==str2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false str1在堆中创建对象，str2在常量池中创建对象&lt;/span&gt;
        System.out.println(str2==str3); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true  str2在常量池中创建对象,str3直接返回的str2创建的对象的引用 所以str2和str3指向常量池中同一个对象&lt;/span&gt;
        System.out.println(str4==str3); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true  str4返回常量池中值为&quot;123&quot;的对象，因此str4和str2、str3都相等&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180520125008699-868945997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于字符串拼接示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String X = &quot;ABC&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 常量X&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test() {

        String str5 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;ABC&quot;&lt;span&gt;);
        String str6 &lt;/span&gt;= str5+&quot;DEF&quot;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;堆中创建&lt;/span&gt;
        String str7 = &quot;ABC&quot;+&quot;DEF&quot;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;常量池&lt;/span&gt;
        String str8 = X+&quot;DEF&quot;;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;X为常量,值是固定的,因此X+&quot;DEF&quot;值已经定下来为ABCDEF，实际上编译后得代码相当于String str8 = &quot;ABCDEF&quot;&lt;/span&gt;
        String str9 = &quot;ABC&quot;&lt;span&gt;;       
        String str10 &lt;/span&gt;= str9+&quot;DEF&quot;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;堆中&lt;/span&gt;
&lt;span&gt;        
        System.out.println(str6&lt;/span&gt;==str7); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
        System.out.println(str8==str7); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
        System.out.println(str10==str7); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;反编译后的代码看一下便一目了然:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180520125047236-1453093745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内存分配如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180520125100864-1816880560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;String、&lt;span lang=&quot;EN-US&quot;&gt;StringBuffer、&lt;span lang=&quot;EN-US&quot;&gt;StringBuilder&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 由于String类型内部维护的用于存储字符串的属性value[]字符数组是用final来修饰的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The value is used for character storage. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; value[];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表明在赋值后可以再修改，因此我们认为String对象一经创建后不可变，在开发过程中如果碰到频繁的拼接字符串操作，如果使用String提供的contact或者直接使用”+”拼接字符串会频繁的生成新的字符串，这样使用显得低效。Java提供了另外两个类：StringBuffer和StringBuilder，用于解决这个问题：&lt;/p&gt;
&lt;p&gt;看一下下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
         String str1=&quot;123&quot;&lt;span&gt;;
         String str2&lt;/span&gt;=&quot;456&quot;&lt;span&gt;;
         String str3&lt;/span&gt;=&quot;789&quot;&lt;span&gt;;
         
         String str4 &lt;/span&gt;= &quot;123&quot; + &quot;456&quot; + &quot;789&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;常量相加，编译器自动识别 String str4=“123456789”&lt;/span&gt;
&lt;span&gt;         
         String str5 &lt;/span&gt;= str1 + str2 + str3;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串变量拼接，推荐使用StringBuilder&lt;/span&gt;
&lt;span&gt;         
         StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();  
            sb.append(str1);
            sb.append(str2);
            sb.append(str3);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是StringBuilder类的实现，只截取了分析的部分代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringBuilder
    &lt;/span&gt;&lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractStringBuilder
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; java.io.Serializable, CharSequence
{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼接字符串&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringBuilder append(String str) {&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;   //调用父类AbstractStringBuilder.append&lt;/span&gt;&lt;br/&gt;super&lt;span&gt;.append(str); &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;; &lt;br/&gt;} &lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractStringBuilder &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Appendable, CharSequence {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 存储字符串的字符数组，非final类型，区别于String类
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt;&lt;span&gt;[] value;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The count is the number of characters used.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;

&lt;/span&gt;&lt;span&gt;    public&lt;/span&gt;&lt;span&gt; AbstractStringBuilder append(String str) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; appendNull();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; str.length();
&lt;/span&gt;&lt;span&gt;         //&lt;/span&gt;&lt;span&gt;检查是否需要扩容&lt;/span&gt;
        ensureCapacityInternal(count +&lt;span&gt; len);
&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;字符串str拷贝至value        &lt;/span&gt;
        str.getChars(0&lt;span&gt;, len, value, count);
        count &lt;/span&gt;+=&lt;span&gt; len;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
}


&lt;/span&gt;&lt;span&gt;    private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ensureCapacityInternal(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minimumCapacity) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow-conscious code
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; minimumCapacity=count+str.length
&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;拼接上str后的容量 如果 大于value容量，则扩容&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (minimumCapacity - value.length &amp;gt; 0&lt;span&gt;) {
                
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扩容，并将当前value值拷贝至扩容后的字符数组，返回新数组引用&lt;/span&gt;
            value =&lt;span&gt; Arrays.copyOf(value,
                    newCapacity(minimumCapacity));
        }
    }

&lt;/span&gt;&lt;span&gt;    //&lt;/span&gt;&lt;span&gt;StringBuilder扩容&lt;/span&gt;
&lt;span&gt;    private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; newCapacity(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow-conscious code
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算扩容容量
&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt; 默认扩容后的数组长度是按原数（value[]）组长度的2倍再加上2的规则来扩展,为什么加2？&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; newCapacity = (value.length &amp;lt;&amp;lt; 1) + 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; 0&lt;span&gt;) {
            newCapacity &lt;/span&gt;=&lt;span&gt; minCapacity;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (newCapacity &amp;lt;= 0 || MAX_ARRAY_SIZE - newCapacity &amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;?&lt;span&gt; hugeCapacity(minCapacity)
            : newCapacity;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;StringBuffer和StringBuilder用一样，内部维护的value[]字符数组都是可变的，区别只是StringBuffer是线程安全的，它对所有方法都做了同步，StringBuilder是线程非安全的，因此在多线程操作共享字符串变量的情况下字符串拼接处理首选用StringBuffer, 否则可以使用StringBuilder，毕竟线程同步也会带来一定的消耗。&lt;/p&gt;

</description>
<pubDate>Sun, 20 May 2018 04:56:00 +0000</pubDate>
<dc:creator>仍是少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashleyboy/p/9063153.html</dc:identifier>
</item>
<item>
<title>集成学习之Boosting —— AdaBoost原理 - massquantity</title>
<link>http://www.cnblogs.com/massquantity/p/9063033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/massquantity/p/9063033.html</guid>
<description>&lt;h3 id=&quot;集成学习之boosting-adaboost原理&quot;&gt;集成学习之Boosting —— AdaBoost原理&lt;/h3&gt;
&lt;h3 id=&quot;集成学习之boosting-adaboost实现&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/massquantity/p/9061447.html&quot;&gt;集成学习之Boosting —— AdaBoost实现&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;集成学习大致可分为两大类：Bagging和Boosting。Bagging一般使用强学习器，其个体学习器之间不存在强依赖关系，容易并行。Boosting则使用弱分类器，其个体学习器之间存在强依赖关系，是一种序列化方法。Bagging主要关注降低方差，而Boosting主要关注降低偏差。Boosting是一族算法，其主要目标为将弱学习器“提升”为强学习器，大部分Boosting算法都是根据前一个学习器的训练效果对样本分布进行调整，再根据新的样本分布训练下一个学习器，如此迭代M次，最后将一系列弱学习器组合成一个强学习器。而这些Boosting算法的不同点则主要体现在每轮样本分布的调整方式上。本系列文章先讨论Boosting的两大经典算法 —— AdaBoost和Gradient Boosting，再探讨近年来在各大数据科学比赛中大放异彩的XGBoost和LightGBM。&lt;/p&gt;

&lt;h2 id=&quot;adaboost原理概述&quot;&gt;AdaBoost原理概述&lt;/h2&gt;
&lt;p&gt;AdaBoost是一个具有里程碑意义的算法，因为其是第一个具有适应性的算法，即能适应弱学习器各自的训练误差率，这也是其名称的由来（Ada为Adaptive的简写）。&lt;/p&gt;
&lt;p&gt;AdaBoost的具体流程为先对每个样本赋予相同的初始权重，每一轮学习器训练过后都会根据其表现对每个样本的权重进行调整，增加分错样本的权重，这样先前做错的样本在后续就能得到更多关注，按这样的过程重复训练出M个学习器，最后进行加权组合，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/massquantity/ML-algorithms-implemetation/master/AdaBoost/images/AdaBoost.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图显示通过将简单学习器加权组合就能生成具有复杂边界的强学习器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/massquantity/ML-algorithms-implemetation/master/AdaBoost/images/AdaBoost1.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里有两个关键问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每轮训练过后如何调整样本权重&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;？&lt;/li&gt;
&lt;li&gt;如何确定最后各学习器的权重 &lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt; ？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这两个问题可由加法模型和指数损失函数推导出来。&lt;/p&gt;

&lt;h2 id=&quot;加法模型-additive-model-和指数损失函数-exponential-loss&quot;&gt;加法模型 (Additive Model) 和指数损失函数 (Exponential Loss)&lt;/h2&gt;
&lt;p&gt;由上图可以看出，AdaBoost最后得到的强学习器是由一系列的弱学习器的线性组合，此即加法模型：&lt;br/&gt;​ &lt;span class=&quot;math display&quot;&gt;\[ f(x) = \sum_{m=1}^{M}\alpha_{m}G_{m}(x)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(G_{m}(x)\)&lt;/span&gt;为基学习器，&lt;span class=&quot;math inline&quot;&gt;\(\alpha_{m}\)&lt;/span&gt;为系数。&lt;/p&gt;
&lt;p&gt;在第m步，我们的目标是最小化一个指定的损失函数&lt;span class=&quot;math inline&quot;&gt;\(L(y,f(x))\)&lt;/span&gt;，即 :&lt;br/&gt;​ &lt;span class=&quot;math display&quot;&gt;\[\min\limits_{(\alpha_{m}\,,\,G_{m})}\sum\limits_{i=1}^{N}L(y_{i}, \,\sum\limits_{m=1}^{M}\alpha_{m}G_{m}(x_{i})) \qquad (1.1)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\((x_{1},y_{1}),(x_{2},y_{2}),\cdots(x_{N},y_{N})\)&lt;/span&gt;为训练数据集。&lt;/p&gt;
&lt;p&gt;这是个复杂的全局优化问题，通常我们使用其简化版，即假设在第m次迭代中，前m-1次的系数&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;和基学习器&lt;span class=&quot;math inline&quot;&gt;\(G(x)\)&lt;/span&gt;都是固定的，则&lt;span class=&quot;math inline&quot;&gt;\(f_{m}(x) = f_{m-1}(x) + \alpha_{m}G_{m}(x)\)&lt;/span&gt;，这样在第m步我们只需就当前的&lt;span class=&quot;math inline&quot;&gt;\(\alpha_{m}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(G_{m}(x)\)&lt;/span&gt;最小化损失函数。&lt;/p&gt;

&lt;p&gt;AdaBoost采用的损失函数为指数损失，形式如下：&lt;br/&gt;​ &lt;span class=&quot;math display&quot;&gt;\[L(y,\,f(x)) = e^{-yf(x)} \qquad (1.2)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;结合上文，我们现在的目标是在指数函数最小的情况下求得&lt;span class=&quot;math inline&quot;&gt;\(\alpha_{m}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(G_{m}(x)\)&lt;/span&gt;。&lt;br/&gt;​ &lt;span class=&quot;math display&quot;&gt;\[(\alpha_{m},G_{m}(x)) = \mathop{\arg\min}\limits_{(\alpha,G)}\sum\limits_{i=1}^{N}e^{-y_{i}f_{m}(x_{i})} = \mathop{\arg\min}\limits_{(\alpha,G)}\sum\limits_{i=1}^{N}e^{-y_{i}(f_{m-1}(x_{i}) + \alpha G(x_{i}))} \qquad (1.3)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(w_{i}^{(m)} = e^{-y_{i}f_{m-1}(x_{i})}\)&lt;/span&gt;，由于&lt;span class=&quot;math inline&quot;&gt;\(w_i^{(m)}\)&lt;/span&gt;不依赖于&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(G(x)\)&lt;/span&gt;，所以可认为其是第m步训练之前赋予每个样本的权重。然而&lt;span class=&quot;math inline&quot;&gt;\(w_i^{(m)}\)&lt;/span&gt;依赖于&lt;span class=&quot;math inline&quot;&gt;\(f_{m-1}(x_i)\)&lt;/span&gt;，所以每一轮迭代会改变。&lt;/p&gt;&lt;p&gt;于是式 (1.3) 变为：&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math display&quot;&gt;\[\sum\limits_{i=1}^{N}w_{i}^{(m)}e^{-y_i\alpha G(x_i)} = e^{-\alpha}\sum\limits_{y_{i}=G(x_{i})}w_{i}^{(m)} + e^{\alpha}\sum\limits_{y_i \neq G(x_i)}w_i^{(m)} \qquad\qquad (1.4)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​&lt;span class=&quot;math display&quot;&gt;\[= (e^{\alpha} - e^{-\alpha})\sum\limits_{i=1}^Nw_i^{(m)}\mathbb{I}(y_i \neq G(x_i)) + e^{-\alpha}\sum\limits_{i=1}^Nw_i^{(m)} \qquad\qquad\quad (1.5)\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;由上面几个式子可以得到AdaBoost算法的几个关键点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) 基学习器&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt; :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;求令式 (1.5) 最小的&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;等价于令 &lt;span class=&quot;math inline&quot;&gt;\(\sum\limits_{i=1}^Nw_i^{(m)}\mathbb{I}(y_i \neq G(x_i))\)&lt;/span&gt; 最小化的&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;，因此可认为每一轮基学习器都是通过最小化带权重误差得到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2) 下一轮样本权值&lt;span class=&quot;math inline&quot;&gt;\(w_i^{(m+1)}\)&lt;/span&gt; ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由 &lt;span class=&quot;math inline&quot;&gt;\(w_{i}^{(m+1)} = e^{-y_{i}f_{m}(x_{i})} = e^{-y_{i}(f_{m-1}(x_{i}) + \alpha G(x_{i}))} = e^{-y_if_{m-1}(x_i)}e^{-y_i\alpha_mG_m(x_i)} = w_i^{(m)}e^{-y_i\alpha_mG_m(x_i)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看到对于&lt;span class=&quot;math inline&quot;&gt;\(\alpha_m&amp;gt;0\)&lt;/span&gt;，若&lt;span class=&quot;math inline&quot;&gt;\(y_i = G_m(x_i)\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\(w_i^{(m+1)} = w_i^{(m)}e^{-\alpha_m}\)&lt;/span&gt;，表明前一轮被正确分类样本的权值会减小； 若&lt;span class=&quot;math inline&quot;&gt;\(y_i \neq G_m(x_i)\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\(w_i^{(m+1)} = w_i^{(m)}e^{\alpha_m}\)&lt;/span&gt;，表明前一轮误分类样本的权值会增大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(3) 各基学习器的系数 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_m\)&lt;/span&gt; ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;在训练集上的带权误差率为 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_m = \frac{\sum\limits_{i=1}^Nw_i^{(m)}\mathbb{I}(y_i \neq G_m(x_i))}{\sum\limits_{i=1}^Nw_i^{(m)}}\)&lt;/span&gt; ，&lt;/p&gt;
&lt;p&gt;式 (1.4) 对&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt; 求导并使导数为0： $-e^{-\alpha}\sum\limits_{y_{i}=G(x_{i})}w_{i}^{(m)} + e^{\alpha}\sum\limits_{y_i \neq G(x_i)}w_i^{(m)} = 0 $ ，&lt;/p&gt;
&lt;p&gt;两边同乘以&lt;span class=&quot;math inline&quot;&gt;\(e^\alpha\)&lt;/span&gt;，得 &lt;span class=&quot;math inline&quot;&gt;\(e^{2\alpha} = \frac{\sum\limits_{y_{i}=G(x_{i})}w_{i}^{(m)}}{\sum\limits_{y_{i} \neq G(x_{i})}w_{i}^{(m)}} = \frac{1-\epsilon_m}{\epsilon_m}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\quad {\color{Red}{\Longrightarrow}} \quad\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\alpha_m = \frac{1}{2}ln\frac{1-\epsilon_m}{\epsilon_m}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看出，&lt;span class=&quot;math inline&quot;&gt;\(\epsilon_m​\)&lt;/span&gt;越小，最后得到的&lt;span class=&quot;math inline&quot;&gt;\(\alpha_m​\)&lt;/span&gt;就越大，表明在最后的线性组合中，准确率越高的基学习器会被赋予较大的系数。&lt;/p&gt;

&lt;h2 id=&quot;adaboost算法&quot;&gt;AdaBoost算法&lt;/h2&gt;
&lt;p&gt;在了解了&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(w_i^{(m+1)}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\alpha_m\)&lt;/span&gt;的由来后，AdaBoost算法的整体流程也就呼之欲出了：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;输入： 训练数据集 &lt;span class=&quot;math inline&quot;&gt;\(T = \left \{(x_1,y_1), (x_2,y_2), \cdots (x_N,y_N)\right \}\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(y\in\left\{-1,+1 \right\}\)&lt;/span&gt;，基学习器&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;，训练轮数M&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;初始化权值分布： &lt;span class=&quot;math inline&quot;&gt;\(w_i^{(1)} = \frac{1}{N}\:, \;\;\;\; i=1,2,3, \cdots N\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;for m=1 to M:&lt;/p&gt;
(a) 使用带有权值分布的训练集学习得到基学习器&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;:&lt;br/&gt;​ &lt;span class=&quot;math display&quot;&gt;\[G_m(x) = \mathop{\arg\min}\limits_{G(x)}\sum\limits_{i=1}^Nw_i^{(m)}\mathbb{I}(y_i \neq G(x_i))\]&lt;/span&gt; (b) 计算&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;在训练集上的误差率：&lt;br/&gt;​ &lt;span class=&quot;math display&quot;&gt;\[\epsilon_m = \frac{\sum\limits_{i=1}^Nw_i^{(m)}\mathbb{I}(y_i \neq G_m(x_i))}{\sum\limits_{i=1}^Nw_i^{(m)}}\]&lt;/span&gt; (c) 计算&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;的系数： &lt;span class=&quot;math inline&quot;&gt;\(\alpha_m = \frac{1}{2}ln\frac{1-\epsilon_m}{\epsilon_m}\)&lt;/span&gt; (d) 更新样本权重分布： &lt;span class=&quot;math inline&quot;&gt;\(w_{i}^{(m+1)} = \frac{w_i^{(m)}e^{-y_i\alpha_mG_m(x_i)}}{Z^{(m)}}\; ,\qquad i=1,2,3\cdots N\)&lt;/span&gt;&lt;br/&gt;　　其中&lt;span class=&quot;math inline&quot;&gt;\(Z^{(m)}\)&lt;/span&gt;是规范化因子，&lt;span class=&quot;math inline&quot;&gt;\(Z^{(m)} = \sum\limits_{i=1}^Nw^{(m)}_ie^{-y_i\alpha_mG_m(x_i)}\)&lt;/span&gt;，以确保所有的&lt;span class=&quot;math inline&quot;&gt;\(w_i^{(m+1)}\)&lt;/span&gt;构成一个分布。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;输出最终模型： &lt;span class=&quot;math inline&quot;&gt;\(G(x) = sign\left[\sum\limits_{m=1}^M\alpha_mG_m(x) \right]\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;adaboost采用指数损失的原因&quot;&gt;AdaBoost采用指数损失的原因&lt;/h2&gt;
&lt;p&gt;若将指数损失表示为期望值的形式：&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math display&quot;&gt;\[E(e^{-yf(x)}|x) = P(y=1|x)e^{-f(x)} + P(y=-1|x)e^{f(x)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于是最小化指数损失，则将上式求导并令其为0：&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial E(e^{-yf(x)}|x)}{\partial f(x)} = -P(y=1|x) e^{-f(x)} + P(y=-1|x)e^{f(x)} = 0\quad ，\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[f(x) = \frac12 log\frac{P(y=1|x)}{P(y=-1|x)}，或写为 P(y=1|x) = \frac{1}{1+e^{-2f(x)}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;仔细看，这不就是logistic regression吗？二者只差系数&lt;span class=&quot;math inline&quot;&gt;\(\frac12\)&lt;/span&gt;，因此每一轮最小化指数损失其实就是在训练一个logistic regression模型，以逼近对数几率 (log odds)。&lt;/p&gt;

&lt;p&gt;于是，&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \begin{aligned} sign(f(x)) &amp;amp;= sign(\frac12 log\frac{P(y=1|x)}{P(y=-1|x)}) \\ &amp;amp; =\left\{\begin{matrix} 1 &amp;amp; \;\; P(y=1|x) &amp;gt; p(y=-1|x)\\ -1 &amp;amp; \;\; P(y=1|x) &amp;lt; P(y=-1|x) \end{matrix}\right. \\&amp;amp;=\mathop{\arg\max} \limits_{y \in\{-1,1\}}P(y|x) \end{aligned} \end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这意味着&lt;span class=&quot;math inline&quot;&gt;\(sign(f(x))\)&lt;/span&gt;达到了贝叶斯最优错误率，即对于每个样本&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;都选择后验概率最大的类别。若指数损失最小化，则分类错误率也将最小化。这说明指数损失函数是分类任务原本0-1损失函数的一致性替代函数。由于这个替代函数是单调连续可微函数，因此用它代替0-1损失函数作为优化目标。&lt;/p&gt;

&lt;h2 id=&quot;real-adaboost&quot;&gt;Real AdaBoost&lt;/h2&gt;
&lt;p&gt;上文推导出的AdaBoost算法被称为&quot;&lt;strong&gt;Discrete AdaBoost&lt;/strong&gt;&quot;，因为其各个基学习器&lt;span class=&quot;math inline&quot;&gt;\(G_m(x)\)&lt;/span&gt;的输出为{-1,1} 。如果将基学习器的输出改为一个类别概率，则产生了Real AdaBoost。Real AdaBoost通常在更少的轮数达到更高的精度，像scikit-learn中的&lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html&quot;&gt;AdaBoostClassifier&lt;/a&gt;就是默认优先使用Real AdaBoost (SAMME.R)，不过Real AdaBoost中的基学习器必须支持概率估计。&lt;/p&gt;
&lt;p&gt;推导与Discrete AdaBoost类似，仍最小化指数损失：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \begin{aligned} E(e^{-yf_m(x)}|x) &amp;amp;= E(e^{-y(f_{m-1}(x) + G(x))}|x) \\ &amp;amp;=E(w \cdot e^{-yG(x)}|x) \\&amp;amp;=e^{-G(x)}P_w(y=1|x) + e^{G(x)}P_w(y=-1|x)\end{aligned} \end{equation}\]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对&lt;span class=&quot;math inline&quot;&gt;\(G(x)\)&lt;/span&gt;求导： &lt;span class=&quot;math inline&quot;&gt;\(G(x) = \frac12log\frac{P_w(y=1|x)}{P_w(y=-1|x)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(P_w(y=1|x)\)&lt;/span&gt;是权重为&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;下y=1的概率，注意这里的&lt;span class=&quot;math inline&quot;&gt;\(G(x)\)&lt;/span&gt;不是基学习器，而是基学习器的类别概率的一个对数转换。由此Real AdaBoost的算法流程如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;初始化权重分布：&lt;span class=&quot;math inline&quot;&gt;\(w_i^{(1)} = \frac1N, \qquad i = 1,2 \cdots N\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;for m=1 to M:&lt;br/&gt;　　(a) 使用带权重分布的训练集训练基学习器，得到类别概率&lt;span class=&quot;math inline&quot;&gt;\(P_m(x) = P_w(y=1|x) \;\in [0,1]\)&lt;/span&gt;&lt;br/&gt;　　(b) &lt;span class=&quot;math inline&quot;&gt;\(G_m(x) = \frac12 log\frac{P_m(x)}{1-P_m(x)} \;\in R\)&lt;/span&gt;&lt;br/&gt;　　(c) 更新权重分布： &lt;span class=&quot;math inline&quot;&gt;\(w_i^{(m+1)} = \frac{w_i^{(m)}e^{-y_iG_m(x_i)}}{Z^{(m)}}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;输出最终模型：&lt;span class=&quot;math inline&quot;&gt;\(G(x) = sign\left[\sum\limits_{m=1}^MG_m(x)\right]\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;正则化-regularization-和其他&quot;&gt;正则化 (Regularization) 和其他&lt;/h2&gt;

&lt;h3 id=&quot;shrinkage&quot;&gt;1、Shrinkage&lt;/h3&gt;
&lt;p&gt;对每个基学习器乘以一个系数&lt;span class=&quot;math inline&quot;&gt;\(\nu\)&lt;/span&gt; (0 &amp;lt; &lt;span class=&quot;math inline&quot;&gt;\(\nu\)&lt;/span&gt; &amp;lt;1)，使其对最终模型的贡献减小，从而防止学的太快产生过拟合。&lt;span class=&quot;math inline&quot;&gt;\(\nu\)&lt;/span&gt;又称学习率，即scikit-learn中的 &lt;strong&gt;learning rate&lt;/strong&gt;。于是上文的加法模型就从：&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math display&quot;&gt;\[f_m(x) = f_{m-1}(x) + \alpha_m G_m(x)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;变为：&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math display&quot;&gt;\[f_m(x) = f_{m-1}(x) + \nu \cdot \alpha_m G_m(x)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一般&lt;span class=&quot;math inline&quot;&gt;\(\nu\)&lt;/span&gt;要和迭代次数M结合起来使用，较小的&lt;span class=&quot;math inline&quot;&gt;\(\nu\)&lt;/span&gt;意味着需要较大的M。ESL中提到的策略是先将&lt;span class=&quot;math inline&quot;&gt;\(\nu\)&lt;/span&gt;设得很小 (&lt;span class=&quot;math inline&quot;&gt;\(\nu\)&lt;/span&gt; &amp;lt; 0.1)，再通过early stopping选择M，不过现实中也常用cross-validation进行选择。&lt;/p&gt;

&lt;h3 id=&quot;early-stopping&quot;&gt;2、Early stopping&lt;/h3&gt;
&lt;p&gt;将数据集划分为训练集和测试集，在训练过程中不断检查在测试集上的表现，如果测试集上的准确率下降到一定阈值之下，则停止训练，选用当前的迭代次数M，这同样是防止过拟合的手段。&lt;/p&gt;

&lt;h3 id=&quot;weight-trimming&quot;&gt;3、Weight Trimming&lt;/h3&gt;
&lt;p&gt;weight trimming不是正则化的方法，其主要目的是提高训练速度。在AdaBoost的每一轮基学习器训练过程中，只有小部分样本的权重较大，因而能产生较大的影响，而其他大部分权重小的样本则对训练影响甚微。Weight trimming的思想是每一轮迭代中删除那些低权重的样本，只用高权重样本进行训练。具体是设定一个阈值 (比如90%或99%)，再将所有样本按权重排序，计算权重的累积和，累积和大于阈值的权重 (样本) 被舍弃，不会用于训练。注意每一轮训练完成后所有样本的权重依然会被重新计算，这意味着之前被舍弃的样本在之后的迭代中如果权重增加，可能会重新用于训练。&lt;/p&gt;
&lt;p&gt;根据 [Friedman et al., 2000] 中的描述，weighting trimming可以提高计算效率，且不会牺牲准确率，下一篇中将通过实现来验证。&lt;/p&gt;

&lt;h2 id=&quot;终末&quot;&gt;终末&lt;/h2&gt;
&lt;p&gt;AdaBoost的原始论文 &lt;a href=&quot;http://www.face-rec.org/algorithms/Boosting-Ensemble/decision-theoretic_generalization.pdf&quot;&gt;[&lt;span&gt;Freund &amp;amp; Schapire, 1997&lt;/span&gt;]&lt;/a&gt; 并非使用了上文中的推导方法，而是基于PAC学习框架下进行解释的。上文的将AdaBoost视为 “加法模型 + 指数损失” 的观点，由斯坦福的几位统计系大牛 [Friedman et al., 2000] 提出，因而这一派也被称为“统计视角”。沿着这个路子，若将指数损失替换为其他损失函数并依此不断训练新学习器，则诞生了Gradient Boosting算法，是为下一篇的主题。&lt;/p&gt;

&lt;hr/&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference :&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Friedman, J., Hastie, T. and Tibshirani, R. &lt;a href=&quot;http://statweb.stanford.edu/~jhf/ftp/boost.pdf&quot;&gt;&lt;em&gt;&lt;span&gt;Additive logistic regression: a statistical view of boosting&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Friedman, J., Hastie, T. and Tibshirani, R. &lt;em&gt;The Elements of Staistical Learning&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;周志华. 《机器学习》&lt;/li&gt;
&lt;li&gt;李航. 《统计学习方法》&lt;/li&gt;
&lt;li&gt;Schapire R. E. &lt;a href=&quot;http://rob.schapire.net/papers/explaining-adaboost.pdf&quot;&gt;&lt;em&gt;&lt;span&gt;Expalining AdaBoost&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;/&lt;/p&gt;
</description>
<pubDate>Sun, 20 May 2018 04:36:00 +0000</pubDate>
<dc:creator>massquantity</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/massquantity/p/9063033.html</dc:identifier>
</item>
<item>
<title>[创业] 03：建立财务模型 - 一步之遥&gt;&gt;</title>
<link>http://www.cnblogs.com/somebody2005/p/9063117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/somebody2005/p/9063117.html</guid>
<description>&lt;div readability=&quot;11.448559670782&quot;&gt;孙子曰：“夫未战而庙算胜者，得算多也，未战而庙算不胜者，得算少也”。&lt;br/&gt;如果已经选择好了创业方向(&lt;a href=&quot;http://www.cnblogs.com/somebody2005/p/9059635.html&quot; target=&quot;_blank&quot;&gt;02：如何选择创业方向&lt;/a&gt;),那么在正式开始营业之前，可以先建立一个财务模型。&lt;/div&gt;

&lt;p&gt;建立这个财务模型的目的是要得到：&lt;br/&gt;1：&lt;strong&gt;毛利率&lt;/strong&gt;&lt;br/&gt;2：通过现金流表得到&lt;br/&gt;   2.1：&lt;strong&gt;总资金投入&lt;/strong&gt;（最低点）&lt;br/&gt;   2.2：&lt;strong&gt;收支平衡点&lt;/strong&gt;&lt;br/&gt;3：&lt;strong&gt;盈利空间&lt;/strong&gt;&lt;br/&gt;4：所需&lt;strong&gt;人力/资源的时间表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;毛利在30左右就是一个比较危险的数字了(具体到不同行业/国家地区可能不一样)，这个数字指导自己值不值得做。&lt;br/&gt;盈利空间是投资人很关心地话题。&lt;br/&gt;人力资源可以指导如何建立核心团队和中层管理。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;这些数据在经营过程中很可能会调整，但是依然是可以作为经营过程中的指导数据的。&lt;br/&gt;这些数据也可以作为融资的基础数据，用来估值、计算融资金额等。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;做出这样一个模型，只需要一个简单的excel就行。&lt;br/&gt;但是要得到这些数据，有几个基础数据要先得到&lt;br/&gt;1：&lt;strong&gt;目标客户的数量&lt;/strong&gt;&lt;br/&gt;   搜集数据即可。通过网站查询、政府调查报告等可以大致得到，也可以自己做市场调查。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;2：&lt;strong&gt;目标客户可以得到的占有率&lt;/strong&gt;&lt;br/&gt;   市场调查。了解行业现有玩家，各个玩家的市场份额，分析他们各自的特点。&lt;br/&gt;   这个调查问卷要好好设计，也可以请专人来设计。&lt;br/&gt;   通过电话、网络，还是专门的公司进行调查都可以。&lt;br/&gt;   藉此也可以得到自己的竞争优势，建立差异化。这个部分在如何做市场的时候单独说。&lt;/p&gt;

&lt;p&gt;3：&lt;strong&gt;制定售价&lt;/strong&gt;&lt;br/&gt;   售价原则。如果市场上有玩家了，可以参考他们的价格。这个价格之所以在市场上一直存在，说明这个价格是经过n多人n长时间博弈出来的价格，有极大的合理性。&lt;br/&gt;   再参照自己的差异化和竞争策略，进行微调。&lt;br/&gt; &lt;br/&gt;4：&lt;strong&gt;单位获客成本&lt;/strong&gt;&lt;br/&gt;   获得一个客户的成本。很多风头非常关心这个数据。&lt;br/&gt;   这个数据决定了成本分析的很多计算。可以通过同行数据或者其他方式估算。&lt;/p&gt;

&lt;p&gt;5：&lt;strong&gt;成本分析&lt;/strong&gt;&lt;br/&gt;   分析条目：人力(公积金)/租金/原材料/物流/设备(折旧)/市场费用/税费&lt;br/&gt;   直接成本/管理成本：那些可以归入直接成本(和生产成线性比例的投入)，那些算是管理成本。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;产品差异化 / 核心竞争力&lt;/strong&gt;&lt;br/&gt;这个话题有点大。做到产品差异化比建立财务模型还艰巨，可以在如何做市场的时候一起说说这个部分。&lt;br/&gt;找出差异化，是定价的一个指导原则之一。如果毫无差异，价格就得跟着市场来。&lt;br/&gt;关于差异化有个朋友说的很好：如果你不是领域的第一，也要制造出一个领域让自己第一。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在收集和分析这些数据的时候，其实也可以顺便建立自己的&lt;strong&gt;财务制度&lt;/strong&gt;了(有计划的话可以单独写出一篇来)，有懂财务的朋好友帮忙是最好的。&lt;br/&gt;其他小问题，比如那些可以资本化，都可以将来再思考，毕竟这个模型只是理论模型，在运营过程中可能出现各种意外。&lt;br/&gt; &lt;br/&gt; &lt;/p&gt;

</description>
<pubDate>Sun, 20 May 2018 04:35:00 +0000</pubDate>
<dc:creator>一步之遥&amp;gt;&amp;gt;</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/somebody2005/p/9063117.html</dc:identifier>
</item>
<item>
<title>[OPEN CV] 常用视频操作方法 - newzol</title>
<link>http://www.cnblogs.com/newzol/p/9063019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/newzol/p/9063019.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、视频的定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;视频（Video）泛指将一系列静态影像以电信号的方式加以捕捉、纪录、处理、储存、传送与重现的各种技术。连续的图像变化每秒超过24帧（frame）画面以上时，根据视觉暂留原理，人眼无法辨别单幅的静态画面；看上去是平滑连续的视觉效果，这样连续的画面叫做视频。视频技术最早是为了电视系统而发展，但现在已经发展为各种不同的格式以利消费者将视频记录下来。网络技术的发达也促使视频的纪录片段以串流媒体的形式存在于因特网之上并可被电脑接收与播放。视频与电影属于不同的技术，后者是利用照相术将动态的影像捕捉为一系列的静态照片。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、OPEN CV视频处理流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/364188/201805/364188-20180520115225855-195171844.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、OPEN CV支持的s&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、非压缩格式的AVI文件（或是MPEG1格式的），这个不需要装任何插件就可以播放了。&lt;/p&gt;&lt;p&gt;2、DIVX格式的AVI，这也是MPEG4的一种，安装最新的DIVX 5.21（目前最新版），就可以播放了，不过缺点是在播放之初会有一个DIVX的标记显示几秒。&lt;/p&gt;&lt;p&gt;下载地址： http://gupin.fangdown.com/soft/138.htm&lt;/p&gt;&lt;p&gt;3、XVID格式的AVI，这也是MPEG4的一种，可以说是从DIVX变种而来的，据说是XVID原作者不满意DIVX商业化收费的行为，而开发的一个全Free的MPEG4编码核心，安装最新的XVID（1.02版）就可以播放。&lt;/p&gt;&lt;p&gt;下载地址: http://gupin.fangdown.com/soft/45.htm&lt;/p&gt;&lt;p&gt;4、ffdshow MPEG-4格式的AVI，现在越来越多的AVI都采用ffdshow MPEG-4来，集成了DIVX与XVID的一种东西（好象还支持WMV与AC3音频），因此如果你装了ffdshow MPEG-4，就可以不用装XVID与DIVX等编码核心了。另外ffdshow MPEG-4也提供丰富的滤镜功能比如增亮，增加锐度等，最新的ffdshow MPEG-4 Video Decoder 20041012。&lt;/p&gt;&lt;p&gt;下载地址：http://gupin.fangdown.com/soft/383.htm&lt;/p&gt;&lt;p&gt;5、WMV9格式的AVI，微软自己推出的MPEG4编码标准，使用Windows Media 9.0就可以播放，如果没有的话，也可以下载一个Windows Media Encoder 9.0，使你的系统支持WMV 9.0的格式。&lt;/p&gt;&lt;p&gt;下载地址：http://www.ogg.cn/Software/view-software-62.html&lt;/p&gt;&lt;p&gt;6、VP6格式的AVI，也是一种MPEG4的编码格式，On2 Technologies开发的编码器，VP6号称在同等码率下，视频质量超过了Windows Media 9、Real 9和H.264。VP6视频编码器目前被中国的EVD所采用。说真的，现在用这个不多。最新版本是VP6 vfw Codec 6.2.6.0。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、OPEN CV处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入您要运行的功能:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1:批量读取目录下的图片并展示：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2:将视频中的帧保存为图片&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3:将图片合成为视频&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入您的选择：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; iopt;
    cin &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; iopt;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (iopt) 
    {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;批量读取文件目录图片并展示&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; filename[&lt;span&gt;50&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; winname[&lt;span&gt;50&lt;/span&gt;] = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;winimg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;};
        Mat winimg;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;2&lt;/span&gt;; i++&lt;span&gt;)
        {
            snprintf(filename, &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\dev\\res\\IMG_%d.JPG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;strcpy_s(winname, filename);&lt;/span&gt;
            winimg=&lt;span&gt;imread(filename);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (winimg.empty()) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            imshow(winname, winimg);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (waitKey(&lt;span&gt;3000&lt;/span&gt;) &amp;gt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        destroyAllWindows();
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将视频拆分成图片保存&lt;/span&gt;
        &lt;span&gt;char&lt;/span&gt; outfile[&lt;span&gt;50&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
        VideoCapture cap;
        cap.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\dev\\res\\test.mp4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cap.isOpened())
        {
            cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;视频打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        Mat frame;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; totalframe = cap.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(CV_CAP_PROP_FRAME_COUNT);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;totalframe;i++&lt;span&gt;)
        {
            cap &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; frame;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (frame.empty()) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            snprintf(outfile, &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\dev\\res\\IMG_%d.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i);
            imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, frame);
            imwrite(outfile, frame);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (waitKey(&lt;span&gt;20&lt;/span&gt;) &amp;gt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        destroyAllWindows();
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图像合成视频&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; filename[&lt;span&gt;50&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
        Size size0 &lt;/span&gt;= Size(&lt;span&gt;960&lt;/span&gt;, &lt;span&gt;540&lt;/span&gt;&lt;span&gt;);
        VideoWriter writer(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c:\\dev\\res\\merge.avi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,CV_FOURCC(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;20&lt;/span&gt;,size0,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        Mat frame;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;215&lt;/span&gt;; i++&lt;span&gt;)
        {
            snprintf(filename, &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\dev\\res\\IMG_%d.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i);
            frame &lt;/span&gt;=&lt;span&gt; imread(filename);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (frame.empty()) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;winname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, frame);
            writer &lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt; frame;
        }
        destroyAllWindows();
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 20 May 2018 03:56:00 +0000</pubDate>
<dc:creator>newzol</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/newzol/p/9063019.html</dc:identifier>
</item>
</channel>
</rss>