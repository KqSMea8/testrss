<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《Spark Python API 官方文档中文版》 之 pyspark.sql  (二) - 牛仔裤的夏天</title>
<link>http://www.cnblogs.com/wonglu/p/7784825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wonglu/p/7784825.html</guid>
<description>&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;在Spark开发中，由于需要用Python实现，发现API与Scala的略有不同，而Python API的中文资料相对很少。每次去查英文版API的说明相对比较慢，还是中文版比较容易get到所需，所以利用闲暇之余将官方文档翻译为中文版，并亲测Demo的代码。在此记录一下，希望对那些对Spark感兴趣和从事大数据开发的人员提供有价值的中文资料，对PySpark开发人员的工作和学习有所帮助。&lt;/p&gt;
&lt;p&gt;官网地址：http://spark.apache.org/docs/1.6.2/api/python/pyspark.sql.html            &lt;/p&gt;

&lt;h2&gt;&lt;span&gt;Module Context&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Spark SQL和DataFrames重要的类有：&lt;br/&gt;pyspark.sql.SQLContext DataFrame和SQL方法的主入口&lt;br/&gt;pyspark.sql.DataFrame 将分布式数据集分组到指定列名的数据框中&lt;br/&gt;pyspark.sql.Column DataFrame中的列&lt;br/&gt;pyspark.sql.Row DataFrame数据的行&lt;br/&gt;pyspark.sql.HiveContext 访问Hive数据的主入口&lt;br/&gt;pyspark.sql.GroupedData 由DataFrame.groupBy()创建的聚合方法集&lt;br/&gt;pyspark.sql.DataFrameNaFunctions 处理丢失数据(空数据)的方法&lt;br/&gt;pyspark.sql.DataFrameStatFunctions 统计功能的方法&lt;br/&gt;pyspark.sql.functions DataFrame可用的内置函数&lt;br/&gt;pyspark.sql.types 可用的数据类型列表&lt;br/&gt;pyspark.sql.Window 用于处理窗口函数&lt;/p&gt;
&lt;h3&gt;3.class pyspark.sql.DataFrame(jdf, sql_ctx)&lt;/h3&gt;
&lt;p&gt;分布式的收集数据分组到命名列中。&lt;br/&gt;一个DataFrame相当于在Spark SQL中一个相关的表,可在SQLContext使用各种方法创建,如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
people = sqlContext.read.parquet(&quot;...&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦创建， 可以使用在DataFrame、Column中定义的不同的DSL方法操作。&lt;br/&gt;从data frame中返回一列使用对应的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ageCol = people.age
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个更具体的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# To create DataFrame using SQLContext
people = sqlContext.read.parquet(&quot;...&quot;&lt;span&gt;)
department = sqlContext.read.parquet(&quot;...&quot;&lt;span&gt;)
people.filter(people.age &amp;gt; 30).join(department, people.deptId == department.id)).groupBy(department.name, &quot;gender&quot;).agg({&quot;salary&quot;: &quot;avg&quot;, &quot;age&quot;: &quot;max&quot;})&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.1 agg(*exprs)&lt;/h4&gt;
&lt;p&gt;没有组的情况下聚集整个DataFrame (df.groupBy.agg()的简写)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; l=[('jack',5),('john',4),('tom',2&lt;span&gt;)]
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sqlContext.createDataFrame(l,['name','age'&lt;span&gt;])
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.agg({&quot;age&quot;: &quot;max&quot;&lt;span&gt;}).collect()
[Row(max(age)=5&lt;span&gt;)]
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; from pyspark.sql import&lt;span&gt; functions as F
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.agg(F.min(df.age)).collect()
[Row(min(age)=2)]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.2 alias(alias)&lt;/h4&gt;
&lt;p&gt;返回一个设置别名的新的DataFrame。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l=[('Alice',2),('Bob',5&lt;span&gt;)]
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; df = sqlContext.createDataFrame(l,['name','age'&lt;span&gt;])
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; from pyspark.sql.functions import *
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; df_as1 = df.alias(&quot;df_as1&quot;&lt;span&gt;)
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; df_as2 = df.alias(&quot;df_as2&quot;&lt;span&gt;)
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; joined_df = df_as1.join(df_as2, col(&quot;df_as1.name&quot;) == col(&quot;df_as2.name&quot;), 'inner'&lt;span&gt;)
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; joined_df.select(col(&quot;df_as1.name&quot;), col(&quot;df_as2.name&quot;), col(&quot;df_as2.age&quot;&lt;span&gt;)).collect()
[Row(name=u'Alice', name=u'Alice', age=2), Row(name=u'Bob', name=u'Bob', age=5)]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.3 cache()&lt;/h4&gt;
&lt;p&gt;用默认的存储级别缓存数据(MEMORY_ONLY_SER).&lt;/p&gt;
&lt;h4&gt;3.4 coalesce(numPartitions)&lt;/h4&gt;
&lt;p&gt;返回一个有确切的分区数的分区的新的DataFrame。&lt;br/&gt;与在一个RDD上定义的合并类似, 这个操作产生一个窄依赖。 如果从1000个分区到100个分区,不会有shuffle过程, 而是每100个新分区会需要当前分区的10个。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; df.coalesce(1&lt;span&gt;).rdd.getNumPartitions()
1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.5 collect()&lt;/h4&gt;
&lt;p&gt;返回所有的记录数为行的列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; df.collect()
[Row(age=2, name=u'Alice'), Row(age=5, name=u'Bob')]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.6 columns&lt;/h4&gt;
&lt;p&gt;返回所有列名的列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; df.columns
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.7 corr(col1, col2, method=None)&lt;/h4&gt;
&lt;p&gt;计算一个DataFrame相关的两列为double值。通常只支持皮尔森相关系数。DataFrame.corr()和DataFrameStatFunctions.corr()类似。&lt;br/&gt;&lt;strong&gt;参数：●  col1&lt;/strong&gt; – 第一列的名称  &lt;br/&gt;　　    &lt;strong&gt;●  col2&lt;/strong&gt; – 第二列的名称&lt;br/&gt;&lt;strong&gt;           ●  method&lt;/strong&gt; – 相关方法.当前只支持皮尔森相关系数&lt;/p&gt;
&lt;h4&gt;3.8 count()&lt;/h4&gt;
&lt;p&gt;返回DataFrame的行数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.count()
&lt;/span&gt;2
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.9 cov(col1, col2)&lt;/h4&gt;
&lt;p&gt;计算由列名指定列的样本协方差为double值。DataFrame.cov()和DataFrameStatFunctions.cov()类似。&lt;br/&gt;&lt;strong&gt;参数：●  col1&lt;/strong&gt; – 第一列的名称&lt;br/&gt;　　    &lt;strong&gt;●  col2&lt;/strong&gt; – 第二列的名称&lt;/p&gt;
&lt;h4&gt;3.10 crosstab(col1, col2)&lt;/h4&gt;
&lt;p&gt;计算给定列的分组频数表,也称为相关表。每一列的去重值的个数应该小于1e4.最多返回1e6个非零对.每一行的第一列会是col1的去重值，列名称是col2的去重值。第一列的名称是$col1_$col2. 没有出现的配对将以零作为计数。DataFrame.crosstab() and DataFrameStatFunctions.crosstab()类似。&lt;br/&gt;&lt;strong&gt;参数：●  col1&lt;/strong&gt; – 第一列的名称. 去重项作为每行的第一项。&lt;br/&gt;　　    &lt;strong&gt;●  col2&lt;/strong&gt; – 第二列的名称. 去重项作为DataFrame的列名称。&lt;/p&gt;
&lt;h4&gt;3.11 cube(*cols)&lt;/h4&gt;
&lt;p&gt;创建使用指定列的当前DataFrame的多维立方体，这样可以聚合这些数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; l=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,5&lt;span&gt;)]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; df.cube(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, df.age).count().show()
&lt;/span&gt;+-----+----+-----+
| name| age|count|
+-----+----+-----+
| null|   2|    1|
|Alice|null|    1|
|  Bob|   5|    1|
|  Bob|null|    1|
| null|   5|    1|
| null|null|    2|
|Alice|   2|    1|
+-----+----+-----+
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.12 describe(*cols)&lt;/h4&gt;
&lt;p&gt;计算数值列的统计信息。&lt;br/&gt;包括计数，平均，标准差，最小和最大。如果没有指定任何列，这个函数计算统计所有数值列。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; df.describe().show()
&lt;/span&gt;+-------+------------------+
|summary|               age|
+-------+------------------+
|  count|                 2|
|   mean|               3.5|
| stddev|2.1213203435596424|
|    min|                 2|
|    max|                 5|
+-------+------------------+
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.describe([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]).show()
&lt;/span&gt;+-------+------------------+-----+
|summary|               age| name|
+-------+------------------+-----+
|  count|                 2|    2|
|   mean|               3.5| null|
| stddev|2.1213203435596424| null|
|    min|                 2|Alice|
|    max|                 5|  Bob|
+-------+------------------+-----+
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.13 distinct()&lt;/h4&gt;
&lt;p&gt;返回行去重的新的DataFrame。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,5&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; df.distinct().count()
&lt;/span&gt;2
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.14 drop(col)&lt;/h4&gt;
&lt;p&gt;返回删除指定列的新的DataFrame。&lt;br/&gt;&lt;strong&gt;参数：●  col&lt;/strong&gt; – 要删除列的字符串类型名称,或者要删除的列。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; df.drop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)] 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt; df.drop(df.age).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l1=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,5&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l2=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,85&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df2 = sqlContext.createDataFrame(l2,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.join(df2, df.name == df2.name, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).drop(df.name).collect()
[Row(age&lt;/span&gt;=5, height=85, name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.join(df2, df.name == df2.name, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).drop(df2.name).collect()
[Row(age&lt;/span&gt;=5, name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, height=85)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.15 dropDuplicates(subset=None)&lt;/h4&gt;
&lt;p&gt;返回去掉重复行的一个新的DataFrame,通常只考虑某几列。&lt;br/&gt;drop_duplicates()和dropDuplicates()类似。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;from&lt;/span&gt; pyspark.sql &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Row
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sc.parallelize([Row(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=5, height=80),Row(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=5, height=80),Row(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=10, height=80&lt;span&gt;)]).toDF()
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.dropDuplicates().show()
&lt;/span&gt;+---+------+-----+
|age|height| name|
+---+------+-----+
|  5|    80|Alice|
| 10|    80|Alice|
+---+------+-----+
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; df.dropDuplicates([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]).show()
&lt;/span&gt;+---+------+-----+
|age|height| name|
+---+------+-----+
|  5|    80|Alice|
+---+------+-----+
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.16 drop_duplicates(subset=None)&lt;/h4&gt;
&lt;p&gt;与以上相同。&lt;/p&gt;
&lt;h4&gt;3.17 dropna(how='any', thresh=None, subset=None)&lt;/h4&gt;
&lt;p&gt;返回一个删除null值行的新的DataFrame。dropna()和dataframenafunctions.drop()类似。&lt;br/&gt;&lt;strong&gt;参数：●  how&lt;/strong&gt; – 'any'或者'all'。如果'any',删除包含任何空值的行。如果'all',删除所有值为null的行。&lt;br/&gt;　　　&lt;strong&gt;●&lt;/strong&gt;  &lt;strong&gt;thresh&lt;/strong&gt; – int,默认为None,如果指定这个值，删除小于阈值的非空值的行。这个会重写'how'参数。&lt;br/&gt;　　　&lt;strong&gt;●  subset&lt;/strong&gt; – 选择的列名称列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,5&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; dfnew = df.cube(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, df.age).count()
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; dfnew.show()
&lt;/span&gt;+-----+----+-----+
| name| age|count|
+-----+----+-----+
| null|   2|    1|
|Alice|null|    1|
|  Bob|   5|    1|
|  Bob|null|    1|
| null|   5|    1|
| null|null|    2|
|Alice|   2|    1|
+-----+----+-----+
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; dfnew.na.drop().show()
&lt;/span&gt;+-----+---+-----+
| name|age|count|
+-----+---+-----+
|  Bob|  5|    1|
|Alice|  2|    1|
+-----+---+-----+
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.18 dtypes&lt;/h4&gt;
&lt;p&gt;返回所有列名及类型的列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.dtypes
[(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.19 explain(extended=False)&lt;/h4&gt;
&lt;p&gt;将（逻辑和物理）计划打印到控制台以进行调试。&lt;br/&gt;&lt;strong&gt;参数：●  extended&lt;/strong&gt; – boolean类型，默认为False。如果为False,只打印物理计划。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; df.explain()
&lt;/span&gt;== Physical Plan ==&lt;span&gt;
Scan ExistingRDD[age&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;0,name#1]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.explain(True)
&lt;/span&gt;== Parsed Logical Plan ==&lt;span&gt;
...
&lt;/span&gt;== Analyzed Logical Plan ==&lt;span&gt;
...
&lt;/span&gt;== Optimized Logical Plan ==&lt;span&gt;
...
&lt;/span&gt;== Physical Plan ==&lt;span&gt;
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.20 fillna(value, subset=None)&lt;/h4&gt;
&lt;p&gt;替换空值,和na.fill()类似，DataFrame.fillna()和dataframenafunctions.fill()类似。&lt;br/&gt;&lt;strong&gt;参数：●  value&lt;/strong&gt; - 要代替空值的值有int,long,float,string或dict.如果值是字典,subset参数将被忽略。值必须是要替换的列的映射,替换值必须是int,long,float或者string.&lt;br/&gt;&lt;strong&gt;    　　●  subset&lt;/strong&gt; - 要替换的列名列表。在subset指定的列,没有对应数据类型的会被忽略。例如,如果值是字符串,subset包含一个非字符串的列,这个非字符串的值会被忽略。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,5&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; dfnew = df.cube(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, df.age).count()
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; dfnew.show()
&lt;/span&gt;+-----+----+-----+
| name| age|count|
+-----+----+-----+
| null|   2|    1|
|Alice|null|    1|
|  Bob|   5|    1|
|  Bob|null|    1|
| null|   5|    1|
| null|null|    2|
|Alice|   2|    1|
+-----+----+-----+
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; dfnew.na.fill(50&lt;span&gt;).show()
&lt;/span&gt;+-----+---+-----+
| name|age|count|
+-----+---+-----+
| null|  2|    1|
|Alice| 50|    1|
|  Bob|  5|    1|
|  Bob| 50|    1|
| null|  5|    1|
| null| 50|    2|
|Alice|  2|    1|
+-----+---+-----+
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; dfnew.na.fill({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 50, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;unknown&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}).show()
&lt;/span&gt;+-------+---+-----+
|   name|age|count|
+-------+---+-----+
|unknown|  2|    1|
|  Alice| 50|    1|
|    Bob|  5|    1|
|    Bob| 50|    1|
|unknown|  5|    1|
|unknown| 50|    2|
|  Alice|  2|    1|
+-------+---+-----+
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.21 filter(condition)&lt;/h4&gt;
&lt;p&gt;用给定的条件过滤行。&lt;br/&gt;where()和filter()类似。&lt;br/&gt;&lt;strong&gt;参数：●  条件&lt;/strong&gt; - 一个列的bool类型或字符串的SQL表达式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,5&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.filter(df.age &amp;gt; 3&lt;span&gt;).collect()
[Row(age&lt;/span&gt;=5, name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.where(df.age == 2&lt;span&gt;).collect()
[Row(age&lt;/span&gt;=2, name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.filter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age &amp;gt; 3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).collect()
[Row(age&lt;/span&gt;=5, name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.where(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age = 2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).collect()
[Row(age&lt;/span&gt;=2, name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.22 first()&lt;/h4&gt;
&lt;p&gt;返回第一行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; df.first()
Row(age&lt;/span&gt;=2, name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.23 flatMap(f)&lt;/h4&gt;
&lt;p&gt;返回在每行应用F函数后的新的RDD,然后将结果压扁。&lt;br/&gt;是df.rdd.flatMap()的简写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.flatMap(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; p: p.name).collect()
[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.24 foreach(f)&lt;/h4&gt;
&lt;p&gt;应用f函数到DataFrame的所有行。&lt;br/&gt;是df.rdd.foreach()的简写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(person):
...     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(person.name)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.foreach(f)
Alice
Bob&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.25 foreachPartition(f)&lt;/h4&gt;
&lt;p&gt;应用f函数到DataFrame的每一个分区。&lt;br/&gt;是 df.rdd.foreachPartition()的缩写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(people):
...     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; person &lt;span&gt;in&lt;/span&gt;&lt;span&gt; people:
...         &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(person.name)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.foreachPartition(f)
Alice
Bob&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.26 freqItems(cols, support=None)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;参数：●  cols&lt;/strong&gt; – 要计算重复项的列名，为字符串类型的列表或者元祖。&lt;br/&gt;　　    &lt;strong&gt;●  support&lt;/strong&gt; – 要计算频率项的频率值。默认是1%。参数必须大于1e-4.&lt;/p&gt;
&lt;h4&gt;3.27 groupBy(*cols)&lt;/h4&gt;
&lt;p&gt;使用指定的列分组DataFrame,这样可以聚合计算。可以从GroupedData查看所有可用的聚合方法。&lt;br/&gt;groupby()和groupBy()类似。&lt;br/&gt;&lt;strong&gt;参数：●  cols &lt;/strong&gt;– 分组依据的列。每一项应该是一个字符串的列名或者列的表达式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; df.groupBy().avg().collect()
[Row(avg(age)&lt;/span&gt;=3.5&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.groupBy(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).agg({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mean&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, avg(age)=2.0), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, avg(age)=5.0&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.groupBy(df.name).avg().collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, avg(age)=2.0), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, avg(age)=5.0&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.groupBy([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, df.age]).count().collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=5, count=1), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=2, count=1)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.28 groupby(*cols)&lt;/h4&gt;
&lt;p&gt;和以上一致&lt;/p&gt;
&lt;h4&gt;3.29 head(n=None)&lt;/h4&gt;
&lt;p&gt;返回前n行&lt;br/&gt;&lt;strong&gt;参数：●  n&lt;/strong&gt; – int类型，默认为1，要返回的行数。&lt;br/&gt;&lt;strong&gt;返回值&lt;/strong&gt;: 如果n大于1,返回行列表，如果n为1，返回单独的一行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.head()
Row(age&lt;/span&gt;=2, name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.head(1&lt;span&gt;)
[Row(age&lt;/span&gt;=2, name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.30 insertInto(tableName, overwrite=False)&lt;/h4&gt;
&lt;p&gt;插入DataFrame内容到指定表。&lt;br/&gt;注：在1.4中已过时,使用DataFrameWriter.insertInto()代替。&lt;/p&gt;
&lt;h4&gt;3.31 intersect(other)&lt;/h4&gt;
&lt;p&gt;返回新的DataFrame,包含仅同时在当前框和另一个框的行。&lt;br/&gt;相当于SQL中的交集。&lt;/p&gt;
&lt;h4&gt;3.32 intersect(other)&lt;/h4&gt;
&lt;p&gt;如果collect()和take()方法可以运行在本地(不需要Spark executors)那么返回True&lt;/p&gt;
&lt;h4&gt;3.33 join(other, on=None, how=None)&lt;/h4&gt;
&lt;p&gt;使用给定的关联表达式，关联另一个DataFrame。&lt;br/&gt;以下执行df1和df2之间完整的外连接。&lt;br/&gt;&lt;strong&gt;参数：● other&lt;/strong&gt; – 连接的右侧&lt;br/&gt;　　　&lt;strong&gt;● on&lt;/strong&gt; – 一个连接的列名称字符串, 列名称列表,一个连接表达式(列)或者列的列表。如果on参数是一个字符串或者字符串列表,表示连接列的名称,这些名称必须同时存在join的两个表中, 这样执行的是一个等价连接。&lt;br/&gt;　　　&lt;strong&gt;● how&lt;/strong&gt; – 字符串,默认'inner'。inner,outer,left_outer,right_outer,leftsemi之一。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,5&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l2=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,80),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,85&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df2 = sqlContext.createDataFrame(l2,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; df.join(df2, df.name == df2.name, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;outer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).select(df.name, df2.height).collect()
[Row(name&lt;/span&gt;=None, height=80), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, height=None), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, height=85)]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; df.join(df2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;outer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, height=80), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, height=None), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, height=85)]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; l3=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2,60),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,5,80&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df3 = sqlContext.createDataFrame(l3,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; cond = [df.name == df3.name, df.age ==&lt;span&gt; df3.age]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.join(df3, cond, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;outer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).select(df.name, df3.age).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=5), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=2)]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.join(df2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).select(df.name, df2.height).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, height=85)]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l4=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,5&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df4 = sqlContext.createDataFrame(l4,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.join(df4, [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]).select(df.name, df.age).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=5)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.34 limit(num)&lt;/h4&gt;
&lt;p&gt;将结果计数限制为指定的数字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.limit(1&lt;span&gt;).collect()
[Row(age&lt;/span&gt;=2, name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.limit(0).collect()
[]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.35 map(f)&lt;/h4&gt;
&lt;p&gt;通过每行应用f函数返回新的RDD。&lt;br/&gt;是 df.rdd.map()的缩写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; df.map(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; p: p.name).collect()
[u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.36 mapPartitions(f, preservesPartitioning=False)&lt;/h4&gt;
&lt;p&gt;通过每个分区应用f函数返回新的RDD&lt;br/&gt;是df.rdd.mapPartitions()的缩写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; rdd = sc.parallelize([1, 2, 3, 4], 4&lt;span&gt;)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;def&lt;/span&gt; f(iterator): &lt;span&gt;yield&lt;/span&gt; 1&lt;span&gt;
...
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; rdd.mapPartitions(f).sum()
&lt;/span&gt;4
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.37 na&lt;/h4&gt;
&lt;p&gt;返回DataFrameNaFunctions用于处理缺失值。&lt;/p&gt;
&lt;h4&gt;3.38 orderBy(*cols, **kwargs)&lt;/h4&gt;
&lt;p&gt;返回按照指定列排序的新的DataFrame。&lt;br/&gt;&lt;strong&gt;参数：● cols&lt;/strong&gt; – 用来排序的列或列名称的列表。&lt;br/&gt;　　    &lt;strong&gt;● ascending&lt;/strong&gt; – 布尔值或布尔值列表(默认 True). 升序排序与降序排序。指定多个排序顺序的列表。如果指定列表, 列表的长度必须等于列的长度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,5&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.sort(df.age.desc()).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=5), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=2&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.sort(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ascending=&lt;span&gt;False).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=5), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=2&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.orderBy(df.age.desc()).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=5), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=2&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;from&lt;/span&gt; pyspark.sql.functions &lt;span&gt;import&lt;/span&gt; *
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.sort(asc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=2), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=5&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.orderBy(desc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=5), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=2&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df.orderBy([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], ascending=[0, 1&lt;span&gt;]).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=5), Row(name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=2)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.39 persist(storageLevel=StorageLevel(False, True, False, False, 1))&lt;/h4&gt;
&lt;p&gt;设置存储级别以在第一次操作运行完成后保存其值。这只能用来分配新的存储级别，如果RDD没有设置存储级别的话。如果没有指定存储级别，默认为(memory_only_ser)。&lt;/p&gt;
&lt;h4&gt;3.40 printSchema()&lt;/h4&gt;
&lt;p&gt;打印schema以树的格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.printSchema()
root
 &lt;/span&gt;|-- name: string (nullable =&lt;span&gt; true)
 &lt;/span&gt;|-- age: long (nullable =&lt;span&gt; true)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
</description>
<pubDate>Sat, 04 Nov 2017 14:13:00 +0000</pubDate>
<dc:creator>牛仔裤的夏天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wonglu/p/7784825.html</dc:identifier>
</item>
<item>
<title>Matplotlib常用绘图示例入门 - faramita2016</title>
<link>http://www.cnblogs.com/faramita2016/p/7784699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/faramita2016/p/7784699.html</guid>
<description>&lt;h3&gt;一.Matplotlib介绍&lt;/h3&gt;
&lt;p&gt;Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。通过 Matplotlib，开发者可以仅需要几行代码，便可以生成绘图，直方图，功率谱，条形图，错误图，散点图等。Matplotlib使用NumPy进行数组运算，并调用一系列其他的Python库来实现硬件交互。&lt;/p&gt;

&lt;h3&gt;二.常用示例&lt;/h3&gt;
&lt;p&gt;环境：Jupyter(1.0.0) &lt;a href=&quot;http://www.cnblogs.com/faramita2016/p/7512471.html&quot; target=&quot;_blank&quot;&gt;Ubuntu安装Jupyter Notebook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.折线图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
%&lt;span&gt;matplotlib inline

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

x &lt;/span&gt;= np.arange(9&lt;span&gt;)
y &lt;/span&gt;=&lt;span&gt; np.sin(x)
z &lt;/span&gt;=&lt;span&gt; np.cos(x)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; marker数据点样式，linewidth线宽，linestyle线型样式，color颜色&lt;/span&gt;
plt.plot(x, y, marker=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, linewidth=3, linestyle=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot(x, z)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置X轴刻度，rotation旋转&lt;/span&gt;
plt.xticks(x, [str(i) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; x], rotation=45&lt;span&gt;)
plt.title(u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;matplotlib&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置图例&lt;/span&gt;
plt.legend([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], loc=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;upper right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.grid(True)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1164036/201711/1164036-20171104212303888-1540305076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.散点图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
x = np.random.rand(10&lt;span&gt;)
y &lt;/span&gt;= np.random.rand(10&lt;span&gt;)
plt.scatter(x,y)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1164036/201711/1164036-20171104212508420-510607736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.柱状图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
x = np.arange(10&lt;span&gt;)
y &lt;/span&gt;= np.random.randint(0,30,10&lt;span&gt;)
plt.bar(x, y)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1164036/201711/1164036-20171104212731638-1465043138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.饼图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
x = np.random.rand(3&lt;span&gt;)
plt.pie(x)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1164036/201711/1164036-20171104213140420-1395047548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.直方图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mean, sigma = 0, 1&lt;span&gt;
x &lt;/span&gt;= mean + sigma * np.random.randn(10000&lt;span&gt;)
plt.hist(x,&lt;/span&gt;50&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1164036/201711/1164036-20171104213227638-1545083312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.子图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; figsize绘图对象的宽度和高度，单位为英寸，dpi绘图对象的分辨率，即每英寸多少个像素，缺省值为80&lt;/span&gt;
plt.figure(figsize=(8,6),dpi=100&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一个Figure对象可以包含多个子图Axes，subplot将整个绘图区域等分为numRows行*numCols列个子区域，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 按照从左到右，从上到下的顺序对每个子区域进行编号&lt;/span&gt;
A = plt.subplot(2,2,1&lt;span&gt;)
plt.plot([0,&lt;/span&gt;1],[0,1], color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

plt.subplot(&lt;/span&gt;2,2,2&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot([0,&lt;/span&gt;1],[0,1], color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

plt.subplot(&lt;/span&gt;2,1,2&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot(np.arange(&lt;/span&gt;10), np.random.rand(10), color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择子图A&lt;/span&gt;
&lt;span&gt;plt.sca(A)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1164036/201711/1164036-20171104213450513-118781463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Nov 2017 13:47:00 +0000</pubDate>
<dc:creator>faramita2016</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/faramita2016/p/7784699.html</dc:identifier>
</item>
<item>
<title>移动端二三事【三】：transform的矩阵（matrix）操作及注意事项 - 牙疼哥哥</title>
<link>http://www.cnblogs.com/pomelott/p/7784684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pomelott/p/7784684.html</guid>
<description>&lt;p&gt;&lt;strong&gt;*每当在DOM浏览器中增加动态效果时，使用强大的transform和transition，总是很酸爽。抛开css，使用js操作transform还真的有点复杂，涉及到线性代数中的矩阵，但是js操作又不可避免的会用到。俗话说，山水有相逢，早日学会，早日总结，方便以后用到。今天就与大家分享一下，transform的注意事项以及transform矩阵操作的一些技巧。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*首先说一些小的注意事项，硬菜在后面！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.js操作transition时需使用驼峰命名增加前缀：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
div.style.WebkitTransform = div.style.transform = &quot;rotate(90deg)&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.多个transition操作的执行顺序：先写的后后执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下以两个div为例，点击后执行不同的过渡效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    div[0].addEventListener('touchend', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.style.WebkitTransform = &lt;span&gt;this&lt;/span&gt;.style.transform = &quot;scale(.5) translateX(100px)&quot;&lt;span&gt;;
    });
    div[&lt;/span&gt;1].addEventListener('touchend', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.style.WebkitTransform = &lt;span&gt;this&lt;/span&gt;.style.transform = &quot;translateX(100px) scale(.5)&quot;&lt;span&gt;;
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始 效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/849191/201711/849191-20171104212130998-1033555664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/849191/201711/849191-20171104212149201-120807543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面代码如下，可自己拎下来运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no&quot; /&amp;gt;
&amp;lt;title&amp;gt;执行顺序&amp;lt;/title&amp;gt;
&amp;lt;style type=&quot;text/css&quot;&amp;gt;&lt;span&gt;
#box {
    width: 100px;
    border: 1px solid #&lt;/span&gt;000&lt;span&gt;;
    padding: 100px;
}
.div {
    width: 100px;
    height: 100px;
    margin: 10px &lt;/span&gt;0&lt;span&gt;;
    background: red;
    transition: 3s;
    &lt;/span&gt;-webkit-transform-origin: 0 0&lt;span&gt;;
    transform&lt;/span&gt;-origin: 0 0&lt;span&gt;;
}
&lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;
document.addEventListener(&lt;/span&gt;'touchstart', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    e.preventDefault();
});
window.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; div = document.querySelectorAll('.div'&lt;span&gt;);
    div[&lt;/span&gt;0].addEventListener('touchend', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.style.WebkitTransform = &lt;span&gt;this&lt;/span&gt;.style.transform = &quot;scale(.5) translateX(100px)&quot;&lt;span&gt;;
    });
    div[&lt;/span&gt;1].addEventListener('touchend', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.style.WebkitTransform = &lt;span&gt;this&lt;/span&gt;.style.transform = &quot;translateX(100px) scale(.5)&quot;&lt;span&gt;;
    });
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;div class=&quot;div&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;div&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;    
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.移动端在操作结点位置时，尽量使用translate，而操作left或margin等都会引起页面回流（reflow），我们要做的就是尽可能地避免回流，尽可能的减少重绘。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个栗子使用translate模拟垂直滚动条：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&amp;lt;title&amp;gt;垂直滚动&amp;lt;/title&amp;gt;
&amp;lt;meta name=&quot;viewport&quot; content = &quot;width=device-width,user-scalable=no&quot;&amp;gt;
&amp;lt;style type=&quot;text/css&quot;&amp;gt;&lt;span&gt;
body {
    margin: &lt;/span&gt;0&lt;span&gt;;
}
html,
body {
    overflow: hidden;
    height: &lt;/span&gt;100%&lt;span&gt;;
    position: relative;
}
header{
    height: 40px;
    background: #&lt;/span&gt;000&lt;span&gt;;
    color: #fff;
    text&lt;/span&gt;-&lt;span&gt;align: center;
    font&lt;/span&gt;-&lt;span&gt;size: 20px;
    line&lt;/span&gt;-&lt;span&gt;height: 40px;
}
#wrap {
    position: absolute;
    left: &lt;/span&gt;0&lt;span&gt;;
    right: &lt;/span&gt;0&lt;span&gt;;
    top: 40px;
    bottom: 0px;    
    overflow: hidden;    
}
#list {
    margin: &lt;/span&gt;0&lt;span&gt;;
    padding: &lt;/span&gt;0&lt;span&gt;;
    list&lt;/span&gt;-&lt;span&gt;style: none;
}
#list li {
    height: 30px;
    border&lt;/span&gt;-bottom: 1px solid #000&lt;span&gt;;
    line&lt;/span&gt;-&lt;span&gt;height: 30px;
    text&lt;/span&gt;-&lt;span&gt;indent: 20px;
}
&lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;
document.addEventListener(&lt;/span&gt;&quot;touchstart&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
        e.preventDefault();
});
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setListInner(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list = document.querySelector('#list'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; inner = &quot;&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;){
        inner &lt;/span&gt;+= &quot;&amp;lt;li&amp;gt;这是第&quot;+i+&quot;个li&amp;lt;/li&amp;gt;&quot;&lt;span&gt;
    }    
    list.innerHTML &lt;/span&gt;=&lt;span&gt; inner;
}
window.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    setListInner();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; wrap = document.querySelector('#wrap'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list = document.querySelector('#list'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; startPoint = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; startEl = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; elTranslateY = 0&lt;span&gt;;
    list.addEventListener(&lt;/span&gt;'touchstart', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
        startPoint &lt;/span&gt;= e.changedTouches[0&lt;span&gt;].pageY;
        startEl &lt;/span&gt;=&lt;span&gt; elTranslateY;
    });
    list.addEventListener(&lt;/span&gt;'touchmove', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nowPoint = e.changedTouches[0&lt;span&gt;].pageY; 
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dis =  nowPoint -&lt;span&gt; startPoint;
        elTranslateY &lt;/span&gt;= startEl +&lt;span&gt; dis;
        list.style.WebkitTransform &lt;/span&gt;= list.style.transform = &quot;translateY(&quot;+elTranslateY+&quot;px)&quot;&lt;span&gt;;
    });
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;header&amp;gt;垂直滚动&amp;lt;/header&amp;gt;
&amp;lt;div id=&quot;wrap&quot;&amp;gt;
    &amp;lt;ul id=&quot;list&quot;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4.矩阵操作&lt;/p&gt;
&lt;p&gt;大家都知道当使用js获取transform时获取的是一个矩阵：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    div[0].style.WebkitTransform = div[0].style.transform = &quot;scale(.5) translateX(100px)&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终样式才能获取到transform的矩阵参数字符串&lt;/span&gt;
    console.log(getComputedStyle(div[0])[&quot;transform&quot;]);                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  matrix(0.5, 0, 0, 0.5, 50, 0)&lt;/span&gt;
    console.log( &lt;span&gt;typeof&lt;/span&gt; (getComputedStyle(div[0])[&quot;transform&quot;]));       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  string&lt;/span&gt;
    console.log(div[0].style.transform);                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   scale(0.5) translateX(100px)&lt;/span&gt;
    console.log(&lt;span&gt;typeof&lt;/span&gt; (div[0].style.transform));   &lt;span&gt;                  //&lt;/span&gt;&lt;span&gt;  string&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; *矩阵参数对应的变量：&lt;br/&gt;   matrix( a, b, c, d, e, f )，基础值为：&lt;/p&gt;
&lt;p&gt;   matrix( 1, 0, 0, 1, 0, 0 )&lt;/p&gt;
&lt;p&gt;基础效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/849191/201711/849191-20171104221930216-733551431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.改变位移：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;位移:&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;x为轴位移量，y为y轴位移量，可使用负数&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;x轴位移 = e + x;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;y轴位移 = f + y;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;如下为左移100像素，下移50像素&lt;/span&gt;
div[0].style.transform = &quot;matrix(1, 0, 0, 1, -100, 50)&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改变位移效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/849191/201711/849191-20171104222032623-517622675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.缩放：&lt;/p&gt;
&lt;p&gt;（1） x轴缩放：操作变量a,c,e&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x轴:&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;a = a*x;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;c = c*x;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;e = e*x;&lt;br/&gt;//x为缩放倍数&lt;br/&gt;&lt;/span&gt;
div[0].style.transform = &quot;matrix(.5, 0, 0, 1, 0, 0)&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;x轴缩放0.5效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/849191/201711/849191-20171104222935466-277076415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）y轴缩放：操作变量b,d,f&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y轴:&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;b = b*x;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;d = d*x;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;f = f*x;&lt;/span&gt;
div[0].style.transform = &quot;matrix(1, 0, 0, .5, 0, 0)&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;y轴缩放后效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/849191/201711/849191-20171104222844795-1258943257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此就可以解释，在使用css命令时的执行顺序问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先执行matrix(.5, 0, 0, 1, 0, 0)&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;后执行matrix(.5, 0, 0, 1, 100, 0)&lt;/span&gt;
div[0].style.transform = &quot;scaleX(.5) translateX(100px)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先执行matrix(1, 0, 0, 1, 100, 0)&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;后执行matrix(.5, 0, 0, 1, 50, 0)&lt;/span&gt;
div[0].style.transform = &quot;translateX(100px) scaleX(.5)&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.斜切：&lt;/p&gt;
&lt;p&gt;（1）x轴斜切：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x轴斜切30度：单位(deg)&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;操作参数c，修改参数时需要转化为弧度&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;弧度 = Math.tan(角度/180*Math.PI);&lt;/span&gt;
div[0].style.transform = &quot;matrix(1, 0, &quot;+Math.tan(30/180*Math.PI)+&quot;, 1, 0, 0)&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/849191/201711/849191-20171104225022232-1833403828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）y轴斜切：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y轴斜切30度：单位(deg)&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;操作参数b，修改参数时需要转化为弧度&lt;/span&gt;
div[0].style.transform = &quot;matrix(1,&quot;+Math.tan(30/180*Math.PI)+&quot;,0, 1, 0, 0)&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/849191/201711/849191-20171104225250982-672169129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.旋转rotate：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;旋转：&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;修改a，b，c，d四个参数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = Math.cos(45/180*Math.PI);
&lt;span&gt;var&lt;/span&gt; b = Math.sin(45/180*Math.PI);
&lt;span&gt;var&lt;/span&gt; c = -Math.sin(45/180*Math.PI);
&lt;span&gt;var&lt;/span&gt; d = Math.cos(45/180*Math.PI);
div[0].style.transform = &quot;matrix(&quot;+ a +&quot;,&quot;+ b +&quot;,&quot;+ c +&quot;,&quot;+ d +&quot;,0,0)&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/849191/201711/849191-20171104230019013-2119082817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 04 Nov 2017 13:33:00 +0000</pubDate>
<dc:creator>牙疼哥哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pomelott/p/7784684.html</dc:identifier>
</item>
<item>
<title>原生JS实现Ajax及Ajax的跨域请求 - 换个影子</title>
<link>http://www.cnblogs.com/2502778498spw/p/7784390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/2502778498spw/p/7784390.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  前  言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;        &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　如今，从事前端方面的程序猿们，如果，不懂一些前后台的数据交互方面的知识的话，估计都不太好意思说自己是程序猿。当然，如今有着许多的框架，都有相对应的前后台数据交互的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而，其中，用得最多的应该苏算是JQuery的Ajax了。但是，今天，影子向大家介绍的是原生js的Ajax，及跨域请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、 JQuery的Ajax&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;首先，先回忆下JQuery的Ajax写法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$.ajax({
    url: ,
    type: '',
    dataType: '',
    data: {
          
    },
    success: function(){
         
    },
    error: function(){
          
    }
 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、原生JS实现Ajax&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// 第一步： 获得XMLHttpRequest对象
            var ajax = new XMLHttpRequest();
            // 第二步： 设置状态监听函数
            ajax.onreadystatechange = function(){
                console.log(ajax.readyState);
                console.log(ajax.status);
                // 第五步：在监听函数中，判断readyState=4 &amp;amp;&amp;amp; status=200表示请求成功
                if(ajax.readyState==4 &amp;amp;&amp;amp; ajax.status==200){
                    // 第六步： 使用responseText、responseXML接受响应数据，并使用原生JS操作DOM进行显示
                    console.log(ajax.responseText);
                    console.log(ajax.responseXML);// 返回不是XML，显示null
                    console.log(JSON.parse(ajax.responseText));
                    console.log(eval(&quot;(&quot;+ajax.responseText+&quot;)&quot;));
                }
            }
            // 第三步： open一个链接
            ajax.open(&quot;GET&quot;,&quot;h51701.json&quot;,false);//true异步请求，false同步
            
            // 第四步： send一个请求。 可以发送对象和字符串，不需要传递数据发送null
            ajax.send(null);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;注释：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. open(method, url, async) 方法需要三个参数:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 method：发送请求所使用的方法（GET或POST）；与POST相比，GET更简单也更快，并且在大部分情况下都能用；然而，在以下情况中，请使用POST请求：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;无法使用缓存文件（更新服务器上的文件或数据库）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;向服务器发送大量数据（POST 没有数据量限制）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　url：规定服务器端脚本的 URL(该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php （在传回响应之前，能够在服务器上执行任务）)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　async：规定应当对请求进行异步（true）或同步（false）处理；true是在等待服务器响应时执行其他脚本，当响应就绪后对响应进行处理；false是等待服务器响应再执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. send() 方法可将请求送往服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. onreadystatechange：存有处理服务器响应的函数，每当 readyState 改变时，onreadystatechange 函数就会被执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. readyState：存有服务器响应的状态信息。&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;listintable&quot;&gt;&lt;li&gt;&lt;span&gt;0: 请求未初始化&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;1: 服务器连接已建立&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2: 请求已接收&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3: 请求处理中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4: 请求已完成，且响应已就绪&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;5. responseText：获得字符串形式的响应数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt; &lt;/span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;eval() 和JSON.parse() &lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;另外，给大家介绍两种解析字符串的方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;eval() :&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt; eval函数用于将字符串中的JS代码解析出来并执行！！     &lt;br/&gt;   　  当使用eval函数解析JSON字符串时，需 要在函数内部将JSON字符串用()拼接&lt;br/&gt;   　　   例如：  eval(&quot;(&quot;+json1+&quot;)&quot;)&lt;br/&gt;  　　　　  表示eval函数中的字符串不是用于执行，而是要进行字符串解析&lt;br/&gt;  　　   即：&lt;br/&gt;   　　　　 eval(&quot;(&quot;+json1+&quot;)&quot;) = JSON.parse(json1；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;JOSN.parse() :&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　纯粹的将JSON字符串解析为数组或对象；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、 Ajax的跨域请求&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; &lt;br/&gt;首先，我们得知道 为什么会有跨域请求这回事，以及什么情况下会有跨域请求？&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1 &lt;/span&gt; &lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;同源策略&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它的定义是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一段脚本向后台请求数据，只能读取属于同一协议名、同一主机名、同一端口号下的数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以，请求不同协议名、不同端口号、不同主机名下面的文件时，&lt;br/&gt;       将会违背同源策略，无法请求成功，需要进行跨越处理!!&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;解决跨域请求的方法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;方法一：&lt;strong&gt;&lt;span&gt;后台PHP进行设置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;前台无需任何设置，在后台被请求的&lt;/span&gt;PHP&lt;span&gt;文件中，写入一条&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   header(&quot;Access-Control-Allow-Origin:*&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   --- &lt;span&gt;表示允许哪些域名请求这个&lt;/span&gt;&lt;span&gt;PHP&lt;/span&gt;&lt;span&gt;文件，&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;表示所有域名都允许&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;JS代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104202603029-1699177757.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注释：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　其中，url为PHP文件的路径;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;PHP代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104205632779-1059622645.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104203310529-263998610.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;方法二 ：&lt;strong&gt;&lt;span&gt;使用SRC属性 + jsonp实现跨域&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;实现步骤：　　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　1、原有src属性的标签子带跨域功能；所以可以使用script标签的src属性请求后台数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 　　　　　　 &amp;lt;script src=&quot;http://127.0.0.1/json.php&quot;&amp;gt;&amp;lt; /script&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  　　　 2、用于src在加载数据成功后，会直接将加载的内容放到script标签中；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　   所以，后台直接返回JSON字符串将不能在script标签中解析。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  　　　　　　 因此，后台应该返回给前台一个回调函数名，并将JSON字符串作为参数传入。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  　　　　　　　　后台PHP文件中返回： echo &quot;callback({$json})&quot;;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  　　   3、前台接收到返回的回调函数，将直接在script标签中调用。因此，需要声明这样一个回调函数，作为请求成功的回调&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&lt;span&gt;  function callback(data){

  alert(&quot;请求成功!!&quot;);

  console.log(data);

  }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;JS代码：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104204359670-1159434907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;PHP文件：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104204620545-357175626.png&quot; alt=&quot;&quot;/&gt;　　　　　　&lt;/p&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104203747138-8801060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;方法三 ：JQuery的Ajax实现jsonp&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1、在ajax请求时，设置dataType为&quot;jsonp&quot;；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       2、后台返回时，依然需要返回回调函数名，但是，ajax在发送请求时，会默认使用get请求将回调函数名发给后台，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  　　　　 后台$_GET['callback'] 取出函数名：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   　　　　　　---   echo &quot;{$_GET['callback']}({$str})&quot;;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       3、后台返回以后，前台就可以使用ajax的success函数作为成功的回调&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 　　　　　　  ---    success : function(data){}&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; js代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104203628591-1068515119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;PHP文件：　　&lt;/strong&gt;&lt;/span&gt;　　　　　　　&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104203724795-578907116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104205045310-1140197937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当然，后台也可以随便返回一个函数名，前台只要请求成功，就会自动调用这个函数。类似第二条的&lt;/span&gt;②、③步，而不需要本方法的第③步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; PHP&lt;span&gt;返回：&lt;/span&gt; &lt;span&gt;echo &quot;callback({$str})&quot;;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  JS&lt;span&gt;代码：  &lt;/span&gt;&lt;span&gt;function callback(data){&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　console.log(data);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;js代码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104205327701-867851017.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PHP文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104205407420-1920299817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206202/201711/1206202-20171104205441685-177870530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然，影子是一名web前端工程师，但是，影子中的觉得关于数据交互这一块，对我们这一群人来说，要用的地方还是，比较多的；况且，就算是用不到，多一技傍身也是，不错的；&lt;/p&gt;
&lt;p&gt;好了，今天，影子的分享，就到这里结束了，感谢大家的支持!!!!&lt;/p&gt;
</description>
<pubDate>Sat, 04 Nov 2017 13:01:00 +0000</pubDate>
<dc:creator>换个影子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/2502778498spw/p/7784390.html</dc:identifier>
</item>
<item>
<title>《Spark Python API 官方文档中文版》 之 pyspark.sql  (一) - 牛仔裤的夏天</title>
<link>http://www.cnblogs.com/wonglu/p/7784556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wonglu/p/7784556.html</guid>
<description>&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;在Spark开发中，由于需要用Python实现，发现API与Scala的略有不同，而Python API的中文资料相对很少。每次去查英文版API的说明相对比较慢，还是中文版比较容易get到所需，所以利用闲暇之余将官方文档翻译为中文版，并亲测Demo的代码。在此记录一下，希望对那些对Spark感兴趣和从事大数据开发的人员提供有价值的中文资料，对PySpark开发人员的工作和学习有所帮助。&lt;/p&gt;
&lt;p&gt;官网地址：http://spark.apache.org/docs/1.6.2/api/python/pyspark.sql.html            &lt;/p&gt;

&lt;h2&gt;&lt;span&gt;Module Context&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Spark SQL和DataFrames重要的类有：&lt;br/&gt;pyspark.sql.SQLContext DataFrame和SQL方法的主入口&lt;br/&gt;pyspark.sql.DataFrame 将分布式数据集分组到指定列名的数据框中&lt;br/&gt;pyspark.sql.Column DataFrame中的列&lt;br/&gt;pyspark.sql.Row DataFrame数据的行&lt;br/&gt;pyspark.sql.HiveContext 访问Hive数据的主入口&lt;br/&gt;pyspark.sql.GroupedData 由DataFrame.groupBy()创建的聚合方法集&lt;br/&gt;pyspark.sql.DataFrameNaFunctions 处理丢失数据(空数据)的方法&lt;br/&gt;pyspark.sql.DataFrameStatFunctions 统计功能的方法&lt;br/&gt;pyspark.sql.functions DataFrame可用的内置函数&lt;br/&gt;pyspark.sql.types 可用的数据类型列表&lt;br/&gt;pyspark.sql.Window 用于处理窗口函数&lt;/p&gt;
&lt;h3&gt;1.class pyspark.sql.SQLContext(sparkContext, sqlContext=None)&lt;/h3&gt;
&lt;p&gt;SQLContext可以用来创建DataFrame、注册DataFrame为表、在表上执行SQL、缓存表、读取parquet文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;：●  &lt;strong&gt;sparkContext&lt;/strong&gt; - 支持sqlcontext的sparkcontext&lt;br/&gt;&lt;strong&gt;           &lt;/strong&gt;●  &lt;strong&gt;sqlContext&lt;/strong&gt; - 一个可选的JVM Scala sqlcontext，若设置，我们不需要在JVM实例化一个新的sqlcontext，而是都调用这个对象。&lt;/p&gt;
&lt;h4&gt;1.1 applySchema(rdd, schema)&lt;/h4&gt;
&lt;p&gt;注：在1.3中已过时,使用createDataFrame()代替。&lt;/p&gt;
&lt;h4&gt;1.2 cacheTable(tableName)&lt;/h4&gt;
&lt;p&gt;缓存表到内存中&lt;/p&gt;
&lt;h4&gt;1.3 clearCache()&lt;/h4&gt;
&lt;p&gt;从内存缓存删除所有缓存表。&lt;/p&gt;
&lt;h4&gt;1.4 createDataFrame(data, schema=None, samplingRatio=None)&lt;/h4&gt;
&lt;p&gt;从元组/列表RDD或列表或pandas.DataFrame创建DataFrame&lt;br/&gt;当模式是列名的列表时，每个列的类型会从数据中推断出来。&lt;br/&gt;当模式没有时，将尝试从数据中推断模式（列名和类型）,数据应该是行或命名元组或字典的RDD。&lt;br/&gt;如果模式推理是必要的，samplingRatio用来确定用于模式推理的行比率。如果没有samplingratio，将使用第一行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;：●  &lt;strong&gt;data&lt;/strong&gt; - 行或元组或列表或字典的RDD、list、pandas.DataFrame.&lt;br/&gt;　　    ● &lt;strong&gt;schema&lt;/strong&gt; – 一个结构化类型或者列名列表，默认是空。&lt;/p&gt;
&lt;p&gt;samplingRatio – 用于推断的行的样本比率。&lt;br/&gt;&lt;strong&gt;返回&lt;/strong&gt;： DataFrame&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; l=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; sqlContext.createDataFrame(l).collect()
[Row(_1&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, _2=1&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]).collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=1)]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; d=[{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1&lt;span&gt;}]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; sqlContext.createDataFrame(d).collect()
[Row(age&lt;/span&gt;=1, name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; rdd=&lt;span&gt;sc.parallelize(l)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; sqlContext.createDataFrame(rdd).collect()
[Row(_1&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, _2=1&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df=sqlContext.createDataFrame(rdd,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df.collect()
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=1)]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; sqlContext.createDataFrame(df.toPandas()).collect()  
[Row(name&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, age=1&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.createDataFrame(pandas.DataFrame([[1, 2&lt;span&gt;]])).collect()  
[Row(0&lt;/span&gt;=1, 1=2)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.5 createExternalTable(tableName, path=None, source=None, schema=None, **options)&lt;/h4&gt;
&lt;p&gt;创建基于数据源中的数据的外部表.&lt;br/&gt;返回与外部表关联的DataFrame&lt;br/&gt;数据源由源和一组选项指定。如果未指定源，那么将使用由spark.sql.sources.default 配置的默认的数据源配置。&lt;br/&gt;通常，一个模式可以被提供作为返回的DataFrame的模式，然后创建外部表。&lt;br/&gt;&lt;strong&gt;返回：&lt;/strong&gt; DataFrame&lt;/p&gt;
&lt;h4&gt;1.6 dropTempTable(tableName)&lt;/h4&gt;
&lt;p&gt;从目录中删除临时表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; sqlContext.registerDataFrameAsTable(df, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.dropTempTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.7 getConf(key, defaultValue)&lt;/h4&gt;
&lt;p&gt;返回指定键的Spark SQL配置属性值。&lt;br/&gt;如果键没有指定返回默认值。&lt;/p&gt;
&lt;h4&gt;1.8 inferSchema(rdd, samplingRatio=None)&lt;/h4&gt;
&lt;p&gt;注：在1.3中已过时,使用createDataFrame()代替。&lt;/p&gt;
&lt;h4&gt;1.9 jsonFile(path, schema=None, samplingRatio=1.0)&lt;/h4&gt;
&lt;p&gt;从一个文本文件中加载数据，这个文件的每一行均为JSON字符串。&lt;br/&gt;注：在1.4中已过时,使用DataFrameReader.json()代替。&lt;/p&gt;
&lt;h4&gt;1.10 jsonRDD(rdd, schema=None, samplingRatio=1.0)&lt;/h4&gt;
&lt;p&gt;从一个已经存在的RDD中加载数据，这个RDD中的每一个元素均为一个JSON字符串。&lt;br/&gt;如果提供了模式，将给定的模式应用到这个JSON数据集。否则，它根据数据集的采样比例来确定模式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; json=sc.parallelize([&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;{&quot;name&quot;:&quot;jack&quot;,&quot;addr&quot;:{&quot;city&quot;:&quot;beijing&quot;,&quot;mail&quot;:&quot;10001&quot;}}&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;{&quot;name&quot;:&quot;john&quot;,&quot;addr&quot;:{&quot;city&quot;:&quot;shanghai&quot;,&quot;mail&quot;:&quot;10002&quot;}}&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df1 =&lt;span&gt; sqlContext.jsonRDD(json)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df1.collect()
[Row(addr&lt;/span&gt;=Row(city=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beijing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, mail=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), Row(addr=Row(city=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shanghai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, mail=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10002&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;john&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; df2 =&lt;span&gt; sqlContext.jsonRDD(json,df1.schema)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df2.collect()
[Row(addr&lt;/span&gt;=Row(city=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beijing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, mail=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), Row(addr=Row(city=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shanghai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, mail=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10002&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), name=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;john&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.11 load(path=None, source=None, schema=None, **options)&lt;/h4&gt;
&lt;p&gt;返回数据源中的数据集为DataFrame.&lt;br/&gt;注：在1.4中已过时,使用DataFrameReader.load()代替。&lt;/p&gt;
&lt;h4&gt;1.12 newSession()&lt;/h4&gt;
&lt;p&gt;返回一个新的SQLContext做为一个新的会话,这个会话有单独的SQLConf,注册临时表和UDFs，但共享sparkcontext和缓存表。&lt;/p&gt;
&lt;h4&gt;1.13 parquetFile(*paths)&lt;/h4&gt;
&lt;p&gt;加载Parquet文件，返回结果为DataFrame&lt;br/&gt;注：在1.4中已过时,使用DataFrameReader.parquet()代替。&lt;/p&gt;
&lt;h4&gt;1.14 range(start, end=None, step=1, numPartitions=None)&lt;/h4&gt;
&lt;p&gt;创建只有一个名为id的长类型的列的DataFrame,包含从开始到结束的按照一定步长的独立元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;：●  &lt;strong&gt;start &lt;/strong&gt;- 开始值&lt;br/&gt;　　    ●  &lt;strong&gt;end&lt;/strong&gt; -  结束值&lt;br/&gt;           ●  &lt;strong&gt;step&lt;/strong&gt; - 增量值(默认：1)            &lt;br/&gt;　　　●  &lt;strong&gt;numPartitions&lt;/strong&gt; – DataFrame分区数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回&lt;/strong&gt;: DataFrame&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.range(1, 7, 2&lt;span&gt;).collect()
[Row(id&lt;/span&gt;=1), Row(id=3), Row(id=5)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果仅有一个参数，那么这个参数被作为结束值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.range(3&lt;span&gt;).collect()
[Row(id&lt;/span&gt;=0), Row(id=1), Row(id=2)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.15 read&lt;/h4&gt;
&lt;p&gt;返回一个DataFrameReader，可用于读取数据为DataFrame。&lt;/p&gt;
&lt;h4&gt;1.16 registerDataFrameAsTable(df, tableName)&lt;/h4&gt;
&lt;p&gt;注册给定的DataFrame作为目录中的临时表。&lt;br/&gt;临时表只在当前SQLContext实例有效期间存在。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.registerDataFrameAsTable(df, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.17 registerFunction(name, f, returnType=StringType)&lt;/h4&gt;
&lt;p&gt;注册python方法(包括lambda方法)，作为UDF,这样可以在 SQL statements中使用。&lt;br/&gt;除了名称和函数本身之外，还可以选择性地指定返回类型。当返回类型没有指定时，默认自动转换为字符串。对于任何其他返回类型，所生成的对象必须与指定的类型匹配。&lt;br/&gt;&lt;strong&gt;参数&lt;/strong&gt;：●  &lt;strong&gt;name &lt;/strong&gt;- UDF名称&lt;br/&gt;　　    ● &lt;strong&gt; f&lt;/strong&gt; – python方法&lt;br/&gt;　　    ●  &lt;strong&gt;返回类型&lt;/strong&gt; 数据类型对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.registerFunction(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stringLengthString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x: len(x))
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.sql(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT stringLengthString('test')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).collect()
[Row(_c0&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;from&lt;/span&gt; pyspark.sql.types &lt;span&gt;import&lt;/span&gt;&lt;span&gt; IntegerType
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.registerFunction(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stringLengthInt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x: len(x), IntegerType())
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.sql(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT stringLengthInt('test')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).collect()
[Row(_c0&lt;/span&gt;=4)]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;from&lt;/span&gt; pyspark.sql.types &lt;span&gt;import&lt;/span&gt;&lt;span&gt; IntegerType
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.udf.register(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stringLengthInt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x: len(x), IntegerType())
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.sql(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT stringLengthInt('test')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).collect()
[Row(_c0&lt;/span&gt;=4)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.18 setConf(key, value)&lt;/h4&gt;
&lt;p&gt;设置给定的Spark SQL配置属性&lt;/p&gt;
&lt;h4&gt;1.19 sql(sqlQuery)&lt;/h4&gt;
&lt;p&gt;返回DataFrame代表给定查询的结果&lt;br/&gt;&lt;strong&gt;参数：● sqlQuery&lt;/strong&gt; - sql语句  &lt;br/&gt;&lt;strong&gt;返回&lt;/strong&gt;: DataFrame&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l=[(1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(3,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;field1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;field2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.registerDataFrameAsTable(df, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df2 = sqlContext.sql(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT field1 AS f1, field2 as f2 from table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; df2.collect()
[Row(f1&lt;/span&gt;=1, f2=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), Row(f1=2, f2=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), Row(f1=3, f2=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.20 table(tableName)&lt;/h4&gt;
&lt;p&gt;返回指定的表为DataFrame&lt;br/&gt;&lt;strong&gt;返回&lt;/strong&gt;: DataFrame&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; l=[(1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(3,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;field1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;field2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; sqlContext.registerDataFrameAsTable(df, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; df2 = sqlContext.table(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; sorted(df.collect()) ==&lt;span&gt; sorted(df2.collect())
True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.21 tableNames(dbName=None)  &lt;/h4&gt;
&lt;p&gt;返回数据库的表名称列表&lt;br/&gt;&lt;strong&gt;参数&lt;/strong&gt;：&lt;strong&gt;dbName&lt;/strong&gt; – 字符串类型的数据库名称.默认为当前的数据库。&lt;br/&gt;&lt;strong&gt;返回&lt;/strong&gt;: 字符串类型的表名称列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; l=[(1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(3,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;field1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;field2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.registerDataFrameAsTable(df, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sqlContext.tableNames()
True
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; sqlContext.tableNames(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.22 tables(dbName=None)&lt;/h4&gt;
&lt;p&gt;返回一个包含表名称的DataFrame从给定的数据库。&lt;br/&gt;如果数据库名没有指定，将使用当前的数据库。&lt;br/&gt;返回的DataFrame包含两列: 表名称和是否临时表 (一个Bool类型的列，标识表是否为临时表)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;：● dbName – 字符串类型的使用的数据库名&lt;br/&gt;&lt;strong&gt;返回&lt;/strong&gt;: DataFrame&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt; l=[(1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(3,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df = sqlContext.createDataFrame(l,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;field1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;field2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; sqlContext.registerDataFrameAsTable(df, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df2 =&lt;span&gt; sqlContext.tables()
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt; df2.filter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tableName = 'table1'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).first()
Row(tableName&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, isTemporary=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.23 udf&lt;/h4&gt;
&lt;p&gt;返回一个注册的UDF为UDFRegistration。&lt;br/&gt;返回: UDFRegistration&lt;/p&gt;
&lt;h4&gt;1.24 uncacheTable(tableName)&lt;/h4&gt;
&lt;p&gt;从内存的缓存表中移除指定的表。&lt;/p&gt;
&lt;h3&gt;2.class pyspark.sql.HiveContext(sparkContext, hiveContext=None)&lt;/h3&gt;
&lt;p&gt;Hive此处暂略&lt;/p&gt;
</description>
<pubDate>Sat, 04 Nov 2017 12:59:00 +0000</pubDate>
<dc:creator>牛仔裤的夏天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wonglu/p/7784556.html</dc:identifier>
</item>
<item>
<title>基于矩阵分解的推荐系统 - 学会思考の小R</title>
<link>http://www.cnblogs.com/hello-world-n/p/7784542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hello-world-n/p/7784542.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;推荐系统产生推荐列表的方式通常有两种：协同过滤以及基于内容推荐，或者基于个性化推荐。协同过滤方法根据用户历史行为（例如其购买的、选择的、评价过的物品等）结合其他用户的相似决策建立模型。这种模型可用于预测用户对哪些物品可能感兴趣（或用户对物品的感兴趣程度）。基于内容推荐利用一些列有关物品的离散特征，推荐出具有类似性质的相似物品。而本文使用协同过滤的方法来构建整个推荐系统。&lt;/code&gt;
&lt;/pre&gt;

&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;根据流行程度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;:能够给使用者推荐一些东西，了解到最新流行动向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：没有代表性，因为这仅仅是该平台的数据集合。推荐的并不符合个性化的需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;根据个人特征&lt;/p&gt;
&lt;p&gt;通过用户信息和商品特征给出推荐。但这往往也有很多问题：用户信息不完善，商品信息不全，给分类的方式带来很大不确定性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171104205921904-1700702289.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;根据协同过滤&lt;/p&gt;
&lt;p&gt;这也是今天的主角。首先说说什么是协同过滤：&lt;strong&gt;通过其他人的个人特征，商品的特征，用户和商品的一般化关联关系给用户推荐相应的产品。&lt;/strong&gt;举个例子：比如你买了一个手机，那么该平台看看和你相似买了手机的用户都会买哪些东西，然后给你进行推荐。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;step-1&quot;&gt;step 1:&lt;/h2&gt;
&lt;p&gt;需要根据用户购买的东西和商品对应建一个矩阵：（列为商品，横为用户）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171104205957341-191738965.gif&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：一个人可能会购买多件商品这样会产生计算误差。&lt;/p&gt;
&lt;p&gt;这时需要对矩阵进行规范化处理（将数据按比例缩放，使之落入一个小的特定区间），引入Jaccard相似性系数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171104210039623-1830676207.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;step-2&quot;&gt;step 2:&lt;/h2&gt;
&lt;p&gt;将购物历史加入其中，进行权重的计算。假如一名用户买了牛奶和尿布，那么他买湿巾的可能：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171104210057420-1423903620.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后将加权平均分排序后，即可按排序进行推荐。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;step-3&quot;&gt;step 3：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;现象：&lt;/strong&gt;对一些产品来说，用户可能喜欢，但是他用购买记录没办法得到推荐。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案:&lt;/strong&gt; 首先拿已经评价过的商品和用户对应构成如下矩阵（列为商品，横为用户），黑块是已经进行评价的，而白块是评价过的，那么将白块变成黑块便是我们下面要做的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171104210117888-796735547.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了计算白块，我们为商品和用户建立向量。而向量里有一系列关于商品和用户特征取值。如一用户喜欢计算机那么他的计算机属性值就较高。而每个商品也具有计算机的属性值并赋值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Lu = [ 0.3 0.6 1.6 ... ] --用户取值
Ru = [ 0.6 0.8 4.2 ... ] --商品取值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再对Lu和Ru取点乘，便能取得用户和商品的相关性。以这样的思路我们便能建立起&lt;strong&gt;矩阵因子分解模型&lt;/strong&gt;（L为用户集合，R为商品的集合，集合的每项便为特征取值）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171104210137060-1524749907.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过得到模型与商品评价矩阵Rating进行残差平方和来判断模型的好坏。这种预测也仅仅是数据层面上的，下面介绍具体判断模型好坏的参数：召回率和精准度。&lt;/p&gt;
&lt;h3 id=&quot;用户喜欢的商品并且被展示出来的商品-喜欢的商品&quot;&gt;用户喜欢的商品并且被展示出来的商品 / 喜欢的商品&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171104210156716-1427600173.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;用户喜欢的商品并且被展示出来的商品-被展示出来的商品&quot;&gt;用户喜欢的商品并且被展示出来的商品 / 被展示出来的商品&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171104210208654-147126367.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;不同模型得到的不同函数&quot;&gt;不同模型得到的不同函数&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171104210220107-76972281.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Nov 2017 12:54:00 +0000</pubDate>
<dc:creator>学会思考の小R</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hello-world-n/p/7784542.html</dc:identifier>
</item>
<item>
<title>python生成式 - 小破孩92</title>
<link>http://www.cnblogs.com/miqi1992/p/7784449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miqi1992/p/7784449.html</guid>
<description>&lt;blockquote readability=&quot;3.7647058823529&quot;&gt;
&lt;p&gt;本篇将介绍Python的列表生成式，更多内容请参考:&lt;a href=&quot;http://www.cnblogs.com/miqi1992/p/7784449.html&quot;&gt;Python列表生成式&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;列表生成式即List Comprehensions,是Python内置的非常简单却强大的可以用来创建list的生成式。&lt;br/&gt;举个例子，要生成list&lt;code&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/code&gt;可以用&lt;code&gt;list(range(1, 11))&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;])
[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;,]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是要生成&lt;code&gt;[1×1, 2×2, 3×3, 4×4,..., 10×10]&lt;/code&gt;怎么做？方法一是循环:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;L &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;):
    L.append(x &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; x)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;L
[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; ,&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt; ,&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;, ..., &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;[x&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;x &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;)]
[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;49&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;81&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写列表生成式时，把要生成的元素&lt;code&gt;x * x&lt;/code&gt;放在前面，后面跟&lt;code&gt;for&lt;/code&gt;循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。&lt;br/&gt;for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;[x&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;x &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可以使用两层循环，还可以生成全排列：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;[m&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;n &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; m &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'ABC'&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; n &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'XYZ'&lt;/span&gt;]
[&lt;span class=&quot;st&quot;&gt;'AX'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'AY'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'AZ'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'BX'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'BY'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'BZ'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'CX'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'CY'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'CZ'&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三层和三层以上的循环就很少使用了。&lt;/p&gt;
&lt;p&gt;运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; os &lt;span class=&quot;co&quot;&gt;#导入os模块&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;[d &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; d &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; os.listdir(&lt;span class=&quot;st&quot;&gt;'.'&lt;/span&gt;)] &lt;span class=&quot;co&quot;&gt;#os.listdir可以列出文件和目录&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;for&lt;/code&gt;循环其实可以同时使用两个甚至多个变量，比如&lt;code&gt;dict&lt;/code&gt;的&lt;code&gt;items()&lt;/code&gt;可以同时迭代key和value：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;d &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {&lt;span class=&quot;st&quot;&gt;'X'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'A'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'y'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'B'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'z'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'C'&lt;/span&gt;}
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; d.items():
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(k, &lt;span class=&quot;st&quot;&gt;'='&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'v'&lt;/span&gt;)
y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; B
x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; A
z &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; C&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此，列表生成式也可以使用两个变量来生成list:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;d &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {&lt;span class=&quot;st&quot;&gt;'x'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'A'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'y'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'B'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'z'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'C'&lt;/span&gt;}
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;[k&lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;' ='&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;v &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; d.items()]
[&lt;span class=&quot;st&quot;&gt;'y=B'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'x=A'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'z=C'&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后把一个list中所有的字符串变成小写：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;L &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'Hello'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'World'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'IBM'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'Apple'&lt;/span&gt;]
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;[s.lower() &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; s &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; L]
[&lt;span class=&quot;st&quot;&gt;'hello'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'world'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'ibm'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'apple'&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;复杂表达式&quot;&gt;复杂表达式&lt;/h3&gt;
&lt;p&gt;1、使用for循环的迭代不仅可以迭代普通的list,还可以迭代dict。&lt;br/&gt;假设有如下的dict:&lt;br/&gt;d = {'Adam':95, 'Lisa':85, 'Bart':59}&lt;br/&gt;完全可以通过一个复杂的列表生成式把它变成一个HTML表格：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;tds &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;%&lt;/span&gt;(name, score) &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; name, score &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; d.items()]
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&amp;lt;table&amp;gt;'&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Score&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;'&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;.join(tds)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&amp;lt;/table&amp;gt;'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：字符串可以通过%进行格式化，用指定的参数替代%s。字符串的join()方法可以把一个list拼接成一个字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、在生成的表格中，对于没有及格的同学，请把分数标记为红色。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;d &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {&lt;span class=&quot;st&quot;&gt;'Adam'&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;95&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Lisa&quot;&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;85&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Bart&quot;&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;59&lt;/span&gt;}
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; generate_tr(name, score):
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; score &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;:
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;lt;/td&amp;gt;&amp;lt;td style=&quot;color:red&quot;&amp;gt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt;s(name, score)
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Name&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;Score&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;%&lt;/span&gt;(name, score)

tds &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [generate_tr(name, score) &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; name, score &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; d.items()]
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&amp;lt;table border = &quot;1&quot;&amp;gt;'&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;.join(tds))
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&amp;lt;/table&amp;gt;'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、条件过滤&lt;br/&gt;列表生成式的for循环后面还可以加上if判断，例如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;[x &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; x &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;)]
[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;49&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;81&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们只想要偶数的平方，不改动range()的情况下，可以加上if来筛选：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;[x&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;x &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了if条件，只有if判断为True的时候，才把循环的当前元素添加到列表中。&lt;/p&gt;
&lt;p&gt;编写一个函数，它接收一个list，然后把list中的所有字符串变成大写后返回，非字符串元素将被忽略。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;[x.upper() &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; L &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;isinstance&lt;/span&gt;(x, &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;)]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/630a6c35fbc4&quot;&gt;列表生成式--学习笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431779637539089fd627094a43a8a7c77e6102e3a811000&quot;&gt;廖雪峰-生成式&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 04 Nov 2017 12:19:00 +0000</pubDate>
<dc:creator>小破孩92</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/miqi1992/p/7784449.html</dc:identifier>
</item>
<item>
<title>负载均衡集群企业级应用实战—LVS - 阿龙along</title>
<link>http://www.cnblogs.com/along21/p/7784394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/along21/p/7784394.html</guid>
<description>&lt;h2&gt;一、负载均衡集群介绍&lt;/h2&gt;
&lt;p&gt;1、集群&lt;/p&gt;
&lt;p&gt;① 集群（cluster）技术是一种较新的技术，通过集群技术，可以在付出较低成本的情况下获得在性能、可靠性、灵活性方面的相对较高的收益，其&lt;strong&gt;任务调度&lt;/strong&gt;则是集群系统中的核心技术。&lt;/p&gt;
&lt;p&gt;② 集群是一组&lt;strong&gt;相互独立的、通过高速网络互联&lt;/strong&gt;的计算机，它们构成了一个组，并以单一系统的模式加以管理。一个客户与集群相互作用时，集群像是一个独立的服务器。&lt;/p&gt;
&lt;p&gt;③ 集群组成后，可以利用多个计算机和组合进行海量请求处理（&lt;strong&gt;负载均衡&lt;/strong&gt;），从而获得很高的处理效率，也可以用多个计算机做备份（高可用），使得任何一个机器坏了整个系统还是能正常运行。集群在目前互联网公司是必备的技术，极大提高互联网业务的可用性和可缩放性。&lt;/p&gt;

&lt;p&gt;2、负载均衡集群技术&lt;/p&gt;
&lt;p&gt;① 负载均衡（Load Balance）：负载均衡集群为企业需求提供了可解决容量问题的有效方案。负载均衡集群使负载可以在&lt;strong&gt;计算机集群中尽可能平均地分摊处理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;② 负载通常包括&lt;strong&gt;应用程序处理负载和网络流量负载&lt;/strong&gt;。这样的系统非常适合向使用同一组应用程序的大量用户提供服务。每个节点都可以承担一定的处理负载，并且可以实现处理负载在节点之间的动态分配，以实现负载均衡。对于网络流量负载,当网络服务程序接受了高入网流量，以致无法迅速处理，这时，网络流量就会发送给在其它节点上运行的网络服务程序。也可根据服务器的承载能力，进行服务请求的分发，从而使用户的请求得到更快速的处理。&lt;/p&gt;

&lt;p&gt;3、负载均衡集群技术的实现&lt;/p&gt;
&lt;p&gt;负载均衡（Load Balance）&lt;/p&gt;
&lt;p&gt;负载均衡技术类型：基于&lt;strong&gt;4层负载均衡技术&lt;/strong&gt;和基于7层负载均衡技术&lt;/p&gt;
&lt;p&gt;负载均衡实现方式：硬件负载均衡设备或者软件负载均衡&lt;/p&gt;
&lt;p&gt;硬件负载均衡产品：&lt;strong&gt;F5&lt;/strong&gt; BIG-IP 、Citrix Netscaler  、深信服 、Array 、Radware&lt;/p&gt;
&lt;p&gt;软件负载均衡产品： &lt;strong&gt;LVS&lt;/strong&gt;（Linux Virtual Server）、 Haproxy、Nginx、Ats（apache traffic server）&lt;/p&gt;

&lt;p&gt;4、图示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195646201-164801771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;二、lvs 的介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1、lvs&lt;/p&gt;
&lt;p&gt;（1）LVS是&lt;strong&gt;Linux Virtual Server&lt;/strong&gt;的简称，也就是Linux虚拟服务器, 是一个由章文嵩博士发起的自由软件项目，它的官方站点是&lt;strong&gt;www.linuxvirtualserver.org。&lt;/strong&gt;现在LVS已经是 Linux标准内核的一部分，在Linux2.4内核以前，使用LVS时必须要重新编译内核以支持LVS功能模块，但是从Linux2.4内核以后，已经完全内置了LVS的各个功能模块，无需给内核打任何补丁，可以直接使用LVS提供的各种功能。&lt;/p&gt;
&lt;p&gt;（2）LVS自从1998年开始，发展到现在已经是一个比较成熟的技术项目了。可以利用LVS技术实现高可伸缩的、高可用的网络服务，例如WWW服务、Cache服务、DNS服务、FTP服务、MAIL服务、视频/音频点播服务等等，有许多比较著名网站和组织都在使用LVS架设的集群系统，例如：Linux的门户网站（www.linux.com）、向RealPlayer提供音频视频服务而闻名的Real公司（www.real.com）、全球最大的开源网站（sourceforge.net）等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）LVS软件作用：通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器群集，它具有良好可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2、优缺点：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;高并发连接&lt;/strong&gt;&lt;/span&gt;：LVS基于内核网络层面工作，有超强的承载能力和并发处理能力。单台LVS负载均衡器，可支持上万并发连接。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;稳定性强：&lt;/strong&gt;&lt;/span&gt;是工作在网络4层之上仅作分发之用，这个特点也决定了它在负载均衡软件里的性能最强，稳定性最好，对内存和cpu资源消耗极低。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;成本低廉：&lt;/strong&gt;&lt;/span&gt;硬件负载均衡器少则十几万，多则几十万上百万，LVS只需一台服务器和就能免费部署使用，性价比极高。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;配置简单：&lt;/strong&gt;&lt;/span&gt;LVS配置非常简单，仅需几行命令即可完成配置，也可写成脚本进行管理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;支持多种算法：&lt;/strong&gt;&lt;/span&gt;支持多种论调算法，可根据业务场景灵活调配进行使用&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;支持多种工作模型：&lt;/strong&gt;&lt;/span&gt;可根据业务场景，使用不同的工作模式来解决生产环境请求处理问题。&lt;/p&gt;
&lt;p&gt;应用范围广：因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、DNS、ftp服务等等&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;工作在4层，不支持7层规则修改，机制过于庞大，不适合小规模应用。&lt;/p&gt;

&lt;p&gt;3、LVS 核心组件和专业术语&lt;/p&gt;
&lt;p&gt;（1）核心组件&lt;/p&gt;
&lt;p&gt;LVS的管理工具和内核模块ipvsadm/ipvs&lt;/p&gt;
&lt;p&gt;ipvsadm：用户空间的命令行工具，用于管理集群服务及集群服务上的RS等；&lt;/p&gt;
&lt;p&gt;ipvs：工作于内核上的netfilter INPUT钩子之上的程序，可根据用户定义的集群实现请求转发；&lt;/p&gt;
&lt;p&gt;（2）专业术语&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;VS&lt;/strong&gt;&lt;/span&gt;：Virtual Server   #虚拟服务&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Director, Balancer&lt;/strong&gt;&lt;/span&gt;    #负载均衡器、分发器&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RS&lt;/strong&gt;&lt;/span&gt;：Real Server   #后端请求处理服务器 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CIP&lt;/strong&gt;&lt;/span&gt;: Client IP    #用户端IP&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP&lt;/strong&gt;&lt;/span&gt;：Director Virtual IP   #负载均衡器虚拟IP&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;DIP&lt;/strong&gt;&lt;/span&gt;：Director IP   #负载均衡器IP&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RIP&lt;/strong&gt;&lt;/span&gt;：Real Server IP #后端请求处理服务器IP&lt;/p&gt;

&lt;p&gt;（3）图解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195646779-1808181772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、LVS工作内核模型及工作模式&lt;/p&gt;
&lt;p&gt;① 当客户端的请求到达负载均衡器的内核空间时，首先会到达PREROUTING链。&lt;/p&gt;
&lt;p&gt;② 当内核发现请求数据包的目的地址是本机时，将数据包送往INPUT链。&lt;/p&gt;
&lt;p&gt;③ LVS由用户空间的ipvsadm和内核空间的IPVS组成，ipvsadm用来定义规则，IPVS利用ipvsadm定义的规则工作，IPVS工作在INPUT链上,当数据包到达INPUT链时，首先会被IPVS检查，如果数据包里面的目的地址及端口没有在规则里面，那么这条数据包将被放行至用户空间。&lt;/p&gt;
&lt;p&gt;④ 如果数据包里面的目的地址及端口在规则里面，那么这条数据报文将被修改目的地址为事先定义好的后端服务器，并送往POSTROUTING链。&lt;/p&gt;
&lt;p&gt;⑤ 最后经由POSTROUTING链发往后端服务器。&lt;/p&gt;
&lt;p&gt;图解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195647154-844173473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、LVS负载均衡四种工作模式&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1、NAT工作模式&lt;/h3&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;Virtual Server via NAT(VS-NAT):用&lt;strong&gt;地址翻译&lt;/strong&gt;实现虚拟服务器｡地址转换器有能被外界访问到的合法IP地址,它修改来自专有网络的流出包的地址｡外界看起来包是来自地址转换器本身,当外界包送到转换器时,它能判断出应该将包送到内部网的哪个节点｡优点是节省IP 地址,能对内部进行伪装;缺点是效率低,因为返回给请求方的流量经过转换器｡&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）工作流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(a). 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的&lt;strong&gt;PREROUTING链&lt;/strong&gt;。 此时报文的&lt;strong&gt;源IP为CIP，目标IP为VIP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(b). PREROUTING检查发现数据包的目标IP是本机，&lt;strong&gt;将数据包送至INPUT链&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(c). IPVS比对数据包请求的服务&lt;strong&gt;是否为集群服务&lt;/strong&gt;，若是，&lt;strong&gt;修改数据包的目标IP地址为后端服务器IP，然后将数据包发至POSTROUTING链&lt;/strong&gt;。 此时报文的&lt;strong&gt;源IP为CIP，目标IP为RIP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(d). POSTROUTING链通过选路，将数据包&lt;strong&gt;发送给Real Server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(e). Real Server比对发现目标为自己的IP，开始&lt;strong&gt;构建响应报文&lt;/strong&gt;发回给Director Server。 此时报文的&lt;strong&gt;源IP为RIP，目标IP为CIP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(f). Director Server 把RS来到响应包，&lt;strong&gt;通过FORWORD&lt;/strong&gt; 转发给client 在响应客户端前，此时会将源IP地址修改为自己的VIP地址，然后响应给客户端。 此时报文的&lt;strong&gt;源IP为VIP，目标IP为CIP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（3）图解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195647435-6995388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195647763-946588891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、DR工作模式&lt;/h3&gt;
&lt;p&gt;（1）介绍&lt;/p&gt;
&lt;p&gt;Virtual Server via Direct Routing(VS-DR):用直接路由技术实现虚拟服务器｡当参与集群的计算机和作为控制管理的计算机在&lt;strong&gt;同一个网段时&lt;/strong&gt;可以用此方法,控制管理的计算机接收到请求包时直接送到参与集群的节点｡直接路由模式比较特别，很难说和什么方面相似，前种模式基本上都是工作在网络层上（三层），而直接路由模式则应该是工作在数据链路层上（二层）。&lt;/p&gt;

&lt;p&gt;（2）工作原理 ：&lt;/p&gt;
&lt;p&gt;DR和REAL SERVER都使用同一个IP对外服务。但只有DR对ARP请求进行响应，所有REAL SERVER对本身这个IP的ARP请求保持静默。也就是说，网关会把对这个服务IP的请求全部定向给DR，而DR收到数据包后根据调度算法，找出对应的 REAL SERVER，&lt;strong&gt;把目的MAC地址&lt;/strong&gt;改为REAL SERVER的MAC并发给这台REAL SERVER。这时REAL SERVER收到这个数据包，则等于直接从客户端收到这个数据包无异，处理后直接返回给客户端。由于DR要对二层包头进行改换，所以DR和REAL SERVER之间必须在一个广播域，也可以简单的理解为在同一台交换机上&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）工作流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(a) 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的&lt;strong&gt;PREROUTING链&lt;/strong&gt;。 此时报文的&lt;strong&gt;源IP为CIP，目标IP为VIP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(b) PREROUTING检查发现数据包的目标IP是本机，将&lt;strong&gt;数据包送至INPUT链&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(c) IPVS比对数据包请求的服务&lt;strong&gt;是否为集群服务&lt;/strong&gt;，若是，将请求报文中的&lt;strong&gt;源MAC地址修改为DIP的MAC地址，将目标MAC地址修改RIP的MAC地址&lt;/strong&gt;，然后将数据包&lt;strong&gt;发至POSTROUTING链&lt;/strong&gt;。 此时的源&lt;strong&gt;IP和目的IP均未修改，仅修改了源MAC地址&lt;/strong&gt;为DIP的MAC地址，&lt;strong&gt;目标MAC地址&lt;/strong&gt;为RIP的MAC地址&lt;/p&gt;
&lt;p&gt;(d) 由于DS和RS&lt;strong&gt;在同一个网络中&lt;/strong&gt;，所以是&lt;strong&gt;通过二层，数据链路层&lt;/strong&gt;来传输。POSTROUTING链检查目标MAC地址为RIP的MAC地址，那么此时数据包将会发至Real Server。&lt;/p&gt;
&lt;p&gt;(e) &lt;strong&gt;RS&lt;/strong&gt;发现请求报文的MAC地址是&lt;strong&gt;自己的MAC地址&lt;/strong&gt;，就接收此报文。处理完成之后，将响应报文通过&lt;strong&gt;lo接口&lt;/strong&gt;传送给eth0网卡然后向外发出。 此时的&lt;strong&gt;源IP地址为VIP，目标IP为CIP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(f) 响应报文最终送达至客户端&lt;/p&gt;

&lt;p&gt;（4）特点&lt;/p&gt;
&lt;p&gt;① 保证前端路由将目标地址为VIP报文统统发给Director Server，而不是RS&lt;/p&gt;
&lt;p&gt;② RS可以使用私有地址；也可以是公网地址，如果使用公网地址，此时可以通过互联网对RIP进行直接访问&lt;/p&gt;
&lt;p&gt;③ &lt;strong&gt;RS跟Director Server必须在同一个物理网络中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;④ 所有的请求报文经由Director Server，但&lt;strong&gt;响应报文必须不能进过Director Server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;⑤ 不支持地址转换，也不支持端口映射&lt;/p&gt;
&lt;p&gt;⑥ RS可以是大多数常见的操作系统&lt;/p&gt;
&lt;p&gt;⑦ &lt;strong&gt;RS的网关绝不允许指向DIP&lt;/strong&gt;(因为我们不允许他经过director)&lt;/p&gt;
&lt;p&gt;⑧ RS上的lo接口配置VIP的IP地址&lt;/p&gt;

&lt;p&gt;（5）工作流程图解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195648091-1186638337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195648529-1556710994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195648935-525866155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3、TUN工作模式&lt;/h3&gt;
&lt;p&gt;1、定义&lt;/p&gt;
&lt;p&gt;用&lt;strong&gt;IP隧道技术&lt;/strong&gt;实现虚拟服务器｡这种方式是在集群的节点不在&lt;strong&gt;同一个网段&lt;/strong&gt;时可用的转发机制,是将IP包封装在其他网络流量中的方法｡为了安全的考虑,应该使用隧道技术中的VPN,也可使用租用专线｡ 集群所能提供的服务是基于TCP/IP的Web服务､Mail服务､News服务､DNS服务､Proxy服务器等等.&lt;/p&gt;
&lt;p&gt;TUN模式:采用NAT技术时，由于请求和响应报文都必须经过调度器地址重写，当客户请求越来越多时，调度器的处理能力将成为瓶颈。为了解决这个问题，调度器把请求报文通过IP隧道转发至真实服务器，而真实服务器将响应直接返回给客户，所以调度器只处理请求报文。由于一般网络服务应答比请求报文大许多，采用 VS/TUN技术后，集群系统的最大吞吐量可以提高10倍&lt;/p&gt;

&lt;p&gt;2、工作流程&lt;/p&gt;
&lt;p&gt;(a) 客户端将请求发往前端的负载均衡器，请求报文&lt;strong&gt;源地址是CIP，目标地址为VIP。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(b) 负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将在客户端请求报文的&lt;strong&gt;首部再封装一层IP报文&lt;/strong&gt;,将&lt;strong&gt;源地址改为DIP，目标地址改为RIP,&lt;/strong&gt;并将此包发送给RS。&lt;/p&gt;
&lt;p&gt;(c) RS收到请求报文后，会首先拆开第一层封装,然后发现里面还有一层IP首部的目标地址是自己lo接口上的VIP，所以会处理次请求报文，并将响应报文&lt;strong&gt;通过lo接口送给eth0网卡直接发送给客户端&lt;/strong&gt;。注意：需要设置lo接口的VIP不能在共网上出现&lt;/p&gt;

&lt;p&gt;3、图解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195649248-1705324201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195649607-540503453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4、full-nat 工作模式&lt;/h3&gt;
&lt;p&gt;vlvs-fullnat（双向转换）&lt;/p&gt;
&lt;p&gt;通过请求报文的&lt;strong&gt;源地址为DIP，目标为RIP&lt;/strong&gt;来实现转发：对于响应报文而言，修改&lt;strong&gt;源地址为VIP，目标地址为CIP&lt;/strong&gt;来实现转发：&lt;/p&gt;
&lt;p&gt;          CIP --&amp;gt; DIP           VIP --&amp;gt; RIP&lt;/p&gt;
&lt;p&gt;架构特点：这是一种对nat模型的改进，是一个扩展，使得RS与Director可以处于不同网络。&lt;/p&gt;
&lt;p&gt;（1）RIP，DIP可以使用私有地址；&lt;/p&gt;
&lt;p&gt;（2）RIP和DIP可以不再同一个网络中，且RIP的网关未必需要指向DIP；&lt;/p&gt;
&lt;p&gt;（3）支持端口映射；&lt;/p&gt;
&lt;p&gt;（4）RS的OS可以使用任意类型；&lt;/p&gt;
&lt;p&gt;（5）请求报文经由Director，响应报文也经由Director&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195649951-2027809396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;5、四者的区别&lt;/span&gt;&lt;/h2&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;216&quot;/&gt;&lt;col width=&quot;310&quot;/&gt;&lt;col width=&quot;118&quot;/&gt;&lt;col width=&quot;220&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td class=&quot;oa1&quot; width=&quot;216&quot; height=&quot;38&quot;&gt;
&lt;p&gt;机器名称&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa1&quot; width=&quot;310&quot;&gt;
&lt;p&gt;IP配置&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa1&quot; width=&quot;118&quot;&gt;
&lt;p&gt;服务角色&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa1&quot; width=&quot;220&quot;&gt;
&lt;p&gt;备注&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;oa2&quot; width=&quot;216&quot; height=&quot;54&quot;&gt;
&lt;p&gt;lvs-server&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa2&quot; width=&quot;310&quot;&gt;
&lt;p&gt;VIP：172.16.100.1&lt;/p&gt;
&lt;p&gt;DIP：192.168.100.1&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa2&quot; width=&quot;118&quot;&gt;
&lt;p&gt;负载均衡器&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa2&quot; width=&quot;220&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;开启路由功能&lt;/p&gt;
&lt;p&gt;（VIP桥接、DIP仅主机）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;oa3&quot; width=&quot;216&quot; height=&quot;54&quot;&gt;
&lt;p&gt;rs01&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa3&quot; width=&quot;310&quot;&gt;
&lt;p&gt;RIP：192.168.100.2&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa3&quot; width=&quot;118&quot;&gt;
&lt;p&gt;后端服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa3&quot; width=&quot;220&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;网关指向DIP（仅主机）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;oa4&quot; width=&quot;216&quot; height=&quot;40&quot;&gt;
&lt;p&gt;rs02&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa4&quot; width=&quot;310&quot;&gt;
&lt;p&gt;RIP：192.168.100.3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa4&quot; width=&quot;118&quot;&gt;
&lt;p&gt;后端服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa4&quot; width=&quot;220&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;网关指向DIP（仅主机）&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;oa3&quot; width=&quot;216&quot; height=&quot;77&quot;&gt;
&lt;p&gt;rs03&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa3&quot; width=&quot;310&quot;&gt;
&lt;p&gt;RIP：192.168.100.4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa3&quot; width=&quot;118&quot;&gt;
&lt;p&gt;后端服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;oa3&quot; width=&quot;220&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;网关指向DIP（仅主机）&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br/&gt;lvs-nat与lvs-fullnat：请求和响应报文都经由Director&lt;/p&gt;
&lt;p&gt;   　　lvs-nat：RIP的网关要指向DIP&lt;/p&gt;
&lt;p&gt;  　　 lvs-fullnat：RIP和DIP未必在同一IP网络，但要能通信&lt;/p&gt;
&lt;p&gt;lvs-dr与lvs-tun：请求报文要经由Director，但响应报文由RS直接发往Client&lt;/p&gt;
&lt;p&gt;  　　 lvs-dr：通过封装新的MAC首部实现，通过MAC网络转发&lt;/p&gt;
&lt;p&gt;  　　 lvs-tun：通过在原IP报文外封装新IP头实现转发，支持远距离通信&lt;/p&gt;

&lt;h2&gt;四、LVS ipvsadm 命令的使用&lt;/h2&gt;
&lt;p&gt;1、yum install &lt;strong&gt;ipvsadm&lt;/strong&gt; -y #在LVS-server安装lvs管理软件&lt;/p&gt;
&lt;p&gt;程序包：ipvsadm（LVS管理工具）&lt;/p&gt;
&lt;p&gt;　　Unit File: ipvsadm.service&lt;/p&gt;
&lt;p&gt;　　主程序：/usr/sbin/ipvsadm&lt;/p&gt;
&lt;p&gt;　　规则保存工具：/usr/sbin/ipvsadm-save&lt;/p&gt;
&lt;p&gt;　　规则重载工具：/usr/sbin/ipvsadm-restore&lt;/p&gt;
&lt;p&gt;　　配置文件：/etc/sysconfig/ipvsadm-config&lt;/p&gt;

&lt;p&gt;2、选项&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① -A --add-service&lt;/span&gt; 在服务器列表中新添加一条新的虚拟服务器记录&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-t&lt;/span&gt; 表示为tcp服务&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-u&lt;/span&gt; 表示为udp服务&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-s --scheduler&lt;/span&gt; 使用的调度算法， rr | wrr | lc | wlc | lblb | lblcr | dh | sh | sed | nq 默认调度算法是 wlc&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：ipvsadm -A -t 192.168.1.2:80 -s wrr&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;② -a --add-server&lt;/span&gt; 在服务器表中添加一条新的真实主机记录&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-t --tcp-service&lt;/span&gt; 说明虚拟服务器提供tcp服务&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-u --udp-service&lt;/span&gt; 说明虚拟服务器提供udp服务&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-r --real-server&lt;/span&gt; 真实服务器地址&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-m --masquerading&lt;/span&gt; 指定LVS工作模式为NAT模式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-w --weight&lt;/span&gt; 真实服务器的权值&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-g --gatewaying&lt;/span&gt; 指定LVS工作模式为直接路由器模式（也是LVS默认的模式）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-i --ip&lt;/span&gt; 指定LVS的工作模式为隧道模式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-p&lt;/span&gt; 会话保持时间，定义流量呗转到同一个realserver的会话存留时间&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：ipvsadm -a -t 192.168.1.2:80 -r 192.168.2.10:80 -m -w 1&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;③ -E -edit-service 编辑内核虚拟服务器表中的一条虚拟服务器记录。&lt;/p&gt;
&lt;p&gt;-D -delete-service 删除内核虚拟服务器表中的一条虚拟服务器记录。&lt;/p&gt;
&lt;p&gt;-C -clear 清除内核虚拟服务器表中的所有记录。&lt;/p&gt;
&lt;p&gt;-R -restore 恢复虚拟服务器规则&lt;/p&gt;
&lt;p&gt;-S -save 保存虚拟服务器规则，输出为-R 选项可读的格式&lt;/p&gt;
&lt;p&gt;-e -edit-server 编辑一条虚拟服务器记录中的某条真实服务器记录&lt;/p&gt;
&lt;p&gt;-d -delete-server 删除一条虚拟服务器记录中的某条真实服务器记录&lt;/p&gt;
&lt;p&gt;-L|-l –list 显示内核虚拟服务器表&lt;/p&gt;
&lt;p&gt;  --numeric, -n：以数字形式输出地址和端口号&lt;/p&gt;
&lt;p&gt;--exact：扩展信息，精确值 &lt;/p&gt;
&lt;p&gt;--connection，-c：当前IPVS连接输出&lt;/p&gt;
&lt;p&gt;--stats：统计信息&lt;/p&gt;
&lt;p&gt;--rate ：输出速率信息&lt;/p&gt;
&lt;p&gt;参数也可以从/proc/net/ip_vs*映射文件中查看&lt;/p&gt;
&lt;p&gt;-Z –zero 虚拟服务表计数器清零（清空当前的连接数量等）&lt;/p&gt;

&lt;h2&gt;五、实现LVS持久连接&lt;/h2&gt;
&lt;p&gt;1、定义&lt;/p&gt;
&lt;p&gt;由于HTTP是一种无状态协议，每次请求完毕之后就立即断开了，当用户浏览购物网站挑选商品的时候，看到一件商品加入购物车，此过程被重定向到了REALSERVER1上面来，当把第二件商品加入购物车又被重定向到了REALSERVER2上面，最后结账的时候在REALSERVER2上面，只有一件商品，这显然是用户无法接受的，此时就需要一种持久连接机制，来把同一用户的HTTP请求在超时时间内都重定向到同一台REALSERVER，超时时间可以自己定义，比如说2个小时，在超时时间内服务器会不断追踪用户的访问请求，把某一用户的所有请求都转发到同一台REALSERVER上面&lt;/p&gt;
&lt;p&gt;对于电子商务网站来说，用户在挑选商品的时候使用的是80端口来浏览的，当付款的时候则是通过443的ssl加密的方式，当然当用户挑选完商品付款的时候我们当然不希望https的443跳转到另外一台REALSERVER，很显然应该是同一REALSERVER才对，这时候就要用到基于防火墙标记的持久连接，通过定义端口的姻亲关系来实现&lt;/p&gt;

&lt;p&gt;2、功能：&lt;/p&gt;
&lt;p&gt;无论ipvs使用何种scheduler，其都能够实现在指定时间范围内始终将来自同一个ip地址的请求发往同一个RS；此功能是通过lvs持久连接模板实现，其与调度方法无关；&lt;/p&gt;
&lt;p&gt;iptables -t mangle -A PREROUTING -d 172.16.100.100 -p tcp --dport 80 -j MARK --set-mark 99&lt;/p&gt;
&lt;p&gt;#在iptables 打上标记，把80端口标记为99&lt;/p&gt;
&lt;p&gt; iptables -t mangle -A PREROUTING -d 172.16.100.100-p tcp --dport 443 -j MARK --set-mark 99&lt;/p&gt;
&lt;p&gt;#在iptables打上标记，把443端口标记为99&lt;/p&gt;
&lt;p&gt;ipvsadm -A -f 99 -s rr -p&lt;/p&gt;
&lt;p&gt;#在lvs上建立基于99号标记的虚拟服务&lt;/p&gt;
&lt;p&gt;ipvsadm -a -f 99 -r 172.16.100.2 -g&lt;/p&gt;
&lt;p&gt;#设置后端服务地址&lt;/p&gt;
&lt;p&gt;pvsadm -a -f 99 -r 172.16.100.3 -g&lt;/p&gt;



&lt;h2&gt;&lt;span&gt;实现基于LVS负载均衡集群的电商网站架构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195650404-1333076927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前景：随着业务的发展，网站的访问量越来越大，网站访问量已经从原来的1000QPS，变为3000QPS，网站已经不堪重负，响应缓慢，面对此场景，单纯靠单台LNMP的架构已经无法承载更多的用户访问，此时需要用负载均衡技术，对网站容量进行扩充，来解决承载的问题。scale out? scale up?&lt;/p&gt;

&lt;p&gt;实验前准备：&lt;/p&gt;
&lt;p&gt;1、ipvsadm&lt;/p&gt;
&lt;p&gt;yum install ipvsadm -y #在LVS-server安装lvs管理软件&lt;/p&gt;
&lt;p&gt;2、grep -i -C 10 &quot;ipvs&quot; /boot/config-VERSION-RELEASE.x86_64 查看内核是否支持IPVS&lt;/p&gt;
&lt;p&gt;3、iptables -F &amp;amp;&amp;amp; setenforing 清空防火墙策略，关闭selinux&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;实战一：LVS的NAT模式实现负载均衡&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;实战架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195650732-1575596881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、环境准备：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;机器名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;IP配置&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;服务角色&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;备注&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;lvs-server&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;VIP：172.17.1.6&lt;/p&gt;
&lt;p&gt;DIP：192.168.30.106&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;负载均衡器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;开启路由功能&lt;/p&gt;
&lt;p&gt;（VIP桥接、DIP仅主机）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;rs01&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;RIP：192.168.30.107&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;后端服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;网关指向DIP（仅主机）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;rs02&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;RIP：192.168.30.7&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;后端服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;网关指向DIP（仅主机）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注意：确保rs 在一个网段，且只有一个网段&lt;/p&gt;

&lt;p&gt;2、在directory 负载均衡器上&lt;/p&gt;
&lt;p&gt;yum -y install ipvsadm&lt;/p&gt;
&lt;p&gt;① 开启一个基于80端口的虚拟服务vip，调度方式为wrr&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ipvsadm -A -t&lt;/strong&gt; 172.17.1.6&lt;strong&gt;:80 -s wrr&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;② 配置web服务后端real server  为nat工作方式  权重为1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ipvsadm -a -t&lt;/strong&gt; 172.17.1.6&lt;strong&gt;:80 -r&lt;/strong&gt; 192.168.30.107&lt;strong&gt;:80 -m -w 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ipvsadm -a -t 172.17.1.6:80 -r 192.168.30.7:80 -m -w 1&lt;/p&gt;
&lt;p&gt;③ 修改内核配置，开启路由转发&lt;/p&gt;
&lt;p&gt;vim /etc/sysctl.conf 该一行&lt;/p&gt;
&lt;p&gt;net.ipv4.ip_forward = 1&lt;/p&gt;

&lt;p&gt;sysctl -p 读一些，使其生效&lt;/p&gt;

&lt;p&gt;3、在两台real server 上设置&lt;/p&gt;
&lt;p&gt;① 开启实现准备好的web网页服务&lt;/p&gt;
&lt;p&gt;systemctl start nginx&lt;/p&gt;
&lt;p&gt;systemctl start php-mysql&lt;/p&gt;
&lt;p&gt;systemctl start mariadb&lt;/p&gt;

&lt;p&gt;② 把网关指向directory&lt;/p&gt;
&lt;p&gt;route add default gw 192.168.30.106&lt;/p&gt;

&lt;p&gt;4、自己的windows 做客户端，通过vip 172.17.1.6访问web服务，调度成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195651232-34348303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;实战二：LVS的DR 模式实现负载均衡&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;实战架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195651576-774641715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、环境准备&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;机器名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;IP配置&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;服务角色&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;备注&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;lvs-server&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;VIP：172.17.100.100&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;负载均衡器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;开启路由功能&lt;/p&gt;
&lt;p&gt;（VIP桥接）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;rs01&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;RIP：172.17.1.7&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;后端服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;网关指向DIP（桥接）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;rs02&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;RIP：172.17.22.22&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;后端服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;网关指向DIP（桥接）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注意：lvs-server 和rs 要在一个网段，rs只有一个网段&lt;/p&gt;

&lt;p&gt;2、在lvs-server 上设置&lt;/p&gt;
&lt;p&gt;① 配置VIP到本地网卡别名，广播只自己响应&lt;/p&gt;
&lt;p&gt;ifconfig eth0:0 172.17.100.100 broadcast 172.17.100.100 netmask 255.255.255.255 up&lt;/p&gt;
&lt;p&gt;route add -host 172.17.100.100 dev eth0:0 给网卡别名指向网关&lt;/p&gt;

&lt;p&gt;② ipvsadm 策略配置&lt;/p&gt;
&lt;p&gt;开启一个基于80端口的虚拟服务，调度方式为wrr&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ipvsadm -A -t&lt;/strong&gt; 172.17.100.100:80 -s wrr&lt;/p&gt;
&lt;p&gt;配置web服务后端real server  为DR工作方式  权重为1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ipvsadm -a -t&lt;/strong&gt; 172.17.100.100:80 -r 172.17.22.22:80 &lt;strong&gt;-g -w 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ipvsadm -a -t 172.17.100.100:80 -r 172.17.1.6:80 -g -w 1&lt;/p&gt;

&lt;p&gt;3、real server 上配置&lt;/p&gt;
&lt;p&gt;① &lt;strong&gt;配置VIP到本地回环网卡lo&lt;/strong&gt;上，并只广播自己&lt;/p&gt;
&lt;p&gt;ifconfig lo:0 172.17.100.100 broadcast 172.17.100.100 netmask 255.255.255.255 up&lt;/p&gt;
&lt;p&gt;配置本地回环网卡路由&lt;/p&gt;
&lt;p&gt;route add -host 172.17.100.100 lo:0&lt;/p&gt;

&lt;p&gt;② 使RS &quot;闭嘴&quot;&lt;/p&gt;
&lt;p&gt;echo &quot;1&quot; &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_ignore&lt;/p&gt;
&lt;p&gt;echo &quot;2&quot; &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_announce&lt;/p&gt;
&lt;p&gt;忽略ARP广播&lt;/p&gt;
&lt;p&gt;echo &quot;1&quot; &amp;gt; /proc/sys/net/ipv4/conf/all/arp_ignore&lt;/p&gt;
&lt;p&gt;echo &quot;2&quot; &amp;gt; /proc/sys/net/ipv4/conf/all/arp_announce&lt;/p&gt;
&lt;p&gt;注意：关闭arp应答&lt;/p&gt;
&lt;p&gt;1：仅在请求的目标IP配置在本地主机的接收到请求报文的接口上时，才给予响应&lt;/p&gt;
&lt;p&gt;2：必须避免将接口信息向非本网络进行通告&lt;/p&gt;

&lt;p&gt;③ 想永久生效，可以写到配置文件中&lt;/p&gt;
&lt;p&gt;vim /etc/sysctl.conf&lt;/p&gt;
&lt;p&gt;net.ipv4.conf.lo.arp_ignore = 1&lt;/p&gt;
&lt;p&gt;net.ipv4.conf.lo.arp_announce = 2&lt;/p&gt;
&lt;p&gt;net.ipv4.conf.all.arp_ignore = 1&lt;/p&gt;
&lt;p&gt;net.ipv4.conf.all.arp_announce = 2&lt;/p&gt;

&lt;p&gt;sysctl -p 读一下，使其生效&lt;/p&gt;

&lt;p&gt;4、开启实现准备好的web网页服务&lt;/p&gt;
&lt;p&gt;systemctl start nginx&lt;/p&gt;
&lt;p&gt;systemctl start php-mysql&lt;/p&gt;
&lt;p&gt;systemctl start mariadb&lt;/p&gt;

&lt;p&gt;5、效果验证&lt;/p&gt;
&lt;p&gt;① 可分别在rs1和rs2建立2个不同内容，统一路径的test.html测试文件，测试负载均衡功能&lt;/p&gt;
&lt;p&gt;在RS01 上vim ../test.html&lt;/p&gt;
&lt;p&gt;real server 1&lt;/p&gt;
&lt;p&gt;在RS01 上vim ../test.html&lt;/p&gt;
&lt;p&gt;real server 1&lt;/p&gt;
&lt;p&gt;② 打开http://172.17.1.6/ ，并在director上用ipvsadm -L -n观察访问连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195651951-1844167073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ 用另外一台测试机，用ab压力测试工具，测试经过负载均衡后的服务器容量&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;实战三：实现80、443端口都可访问服务，且LVS实现持久连接&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1、环境准备&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;机器名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;IP配置&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;服务角色&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;备注&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;lvs-server&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;VIP：172.17.100.100&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;负载均衡器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;开启路由功能&lt;/p&gt;
&lt;p&gt;（VIP桥接）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;rs01&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;RIP：172.17.1.7&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;后端服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;网关指向DIP（桥接）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;rs02&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;RIP：172.17.22.22&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;后端服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;网关指向DIP（桥接）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;2、在vs 上设置：&lt;/p&gt;
&lt;p&gt;① 在iptables 打上标记，把80端口标记为99&lt;/p&gt;
&lt;p&gt;iptables -t mangle -A PREROUTING -d 172.17.100.100 -p tcp &lt;strong&gt;--dport 80 -j MARK --set-mark 99&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在iptables打上标记，把443端口标记为99&lt;/p&gt;
&lt;p&gt;iptables -t mangle -A PREROUTING -d 172.17.100.100-p tcp &lt;strong&gt;--dport 443&lt;/strong&gt; &lt;strong&gt;-j MARK --set-mark 99&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;② 在lvs上建立基于99号标记的虚拟服务&lt;/p&gt;
&lt;p&gt;ipvsadm -A &lt;strong&gt;-f 99&lt;/strong&gt; -s rr &lt;strong&gt;-p&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置后端服务地址，用DR模式&lt;/p&gt;
&lt;p&gt;ipvsadm -a &lt;strong&gt;-f 99&lt;/strong&gt; -r 172.17.1.7 &lt;strong&gt;-g&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ipvsadm -a &lt;strong&gt;-f 99&lt;/strong&gt; -r 172.17.22.22 &lt;strong&gt;-g&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解析：-p 就是持久连接&lt;/p&gt;

&lt;p&gt;3、在rs 准备好了的web服务，开启80、443端口&lt;/p&gt;
&lt;p&gt;关于ssl 443 加密的设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195652295-194047886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、测试，自己windows 做客户端，访问 http://172.17.1.6/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195652716-1047020441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问 http://172.17.1.6/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1216496/201711/1216496-20171104195653216-360122043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 04 Nov 2017 12:16:00 +0000</pubDate>
<dc:creator>阿龙along</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/along21/p/7784394.html</dc:identifier>
</item>
<item>
<title>Java反射机制能够获取的信息，与应用 - AudreyHepburn</title>
<link>http://www.cnblogs.com/zyypro/p/7784032.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyypro/p/7784032.html</guid>
<description>&lt;p&gt;【1】反射机制是在运行状态中，对于任何一个类，都能够知道这个类的所有属性和方法；&lt;/p&gt;
&lt;p&gt;【2】对于任意一个对象，都能够调用它的任意一个属性和方法；&lt;/p&gt;
&lt;p&gt;  像这种动态获取类的信息以及动态调用对象的方法的骚操作称为java语言的反射机制。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;二、Java反射机制能够获取及操作哪些信息？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【1】获取类的包名 + 类名&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 package com.zyy.test.reflect;
 2 
 3 public class TestReflect {
 4 
 5     public static void main(String[] args) throws ClassNotFoundException {
 6         Class&amp;lt;?&amp;gt; class1 = TestReflect.class;
 7         Class&amp;lt;?&amp;gt; class2 = new TestReflect().getClass();
 8         Class&amp;lt;?&amp;gt; class3 = Class.forName(&quot;com.zyy.test.reflect.TestReflect&quot;);
 9         
10         System.out.println(&quot;包名+类名：&quot; + class1.getName());
11         System.out.println(&quot;类名&quot; + class1.getSimpleName());
12         System.out.println(&quot;包名+类名：&quot; + class2.getName());
13         System.out.println(&quot;类名&quot; + class2.getSimpleName());
14         System.out.println(&quot;包名+类名：&quot; + class3.getName());
15         System.out.println(&quot;类名&quot; + class3.getSimpleName());
16         
17         /*
18          打印结果如下：
19             包名+类名：com.zyy.test.reflect.TestReflect
20             类名TestReflect
21             包名+类名：com.zyy.test.reflect.TestReflect
22             类名TestReflect
23             包名+类名：com.zyy.test.reflect.TestReflect
24             类名TestReflect
25         */
26     }
27 
28 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;【2】获取某个类的父类与实现的接口信息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 package com.zyy.test.reflect;
 2 
 3 import java.io.Serializable;
 4 
 5 public class TestReflect implements Serializable{
 6 
 7     private static final long serialVersionUID = -8047590384784013451L;
 8 
 9     public static void main(String[] args) throws ClassNotFoundException {
10         Class&amp;lt;?&amp;gt; clazz = Class.forName(&quot;com.zyy.test.reflect.TestReflect&quot;);
11         //获取父类信息
12         System.out.println(&quot;父类：&quot; + clazz.getSuperclass().getName());
13         //获取实现的所有接口信息
14         Class&amp;lt;?&amp;gt;[] interfaces = clazz.getInterfaces();
15         for (int i = 0; i &amp;lt; interfaces.length; i++) {
16             System.out.println(&quot;接口：&quot; + interfaces[i].getName());
17         }
18         
19         /*打印结果如下：
20             父类：java.lang.Object
21             接口：java.io.Serializable
22          */
23     }
24 
25 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;【3】获取某个类的构造信息以及使用构造进行赋值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 package com.zyy.test.reflect;
 2 
 3 import java.lang.reflect.Constructor;
 4 import java.lang.reflect.InvocationTargetException;
 5 import java.math.BigDecimal;
 7 
 8 public class TestReflect {
 9     
10     public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, 
11         IllegalArgumentException, InvocationTargetException {
12         
13         Class&amp;lt;?&amp;gt; clazz = Class.forName(&quot;com.zyy.test.reflect.BookFacaed&quot;);
14         Constructor&amp;lt;?&amp;gt;[] constructors = clazz.getConstructors();
15         
16         for (int i = 0; i &amp;lt; constructors.length; i++) {
17             System.out.println(&quot;构造&quot; + i + constructors[i].getName() + &quot;的参数为：&quot;);
18             //获取构造的参数信息
19             Class&amp;lt;?&amp;gt;[] types = constructors[i].getParameterTypes();
20             for (int j = 0; j &amp;lt; types.length; j++) {
21                 System.out.println(types[j].getName() + &quot; &quot;);
22             }
23         }
24         
25         /*打印结果：
26              构造0com.zyy.test.reflect.BookFacaed的参数为：
27             java.lang.String 
28             java.math.BigDecimal 
29             构造1com.zyy.test.reflect.BookFacaed的参数为：
30             java.lang.String 
31             构造2com.zyy.test.reflect.BookFacaed的参数为：
32          */
33         
34         //实例化拥有2个参数的构造方法
35         BookFacaed bookFacaed = (BookFacaed)constructors[0].newInstance(&quot;《数据结构》&quot;, new BigDecimal(100));
36         System.out.println(bookFacaed);    //调用实体的toString方法打印
37         
38         //通过反射机制直接实例化对象
39         BookFacaed bookFacaed2 = (BookFacaed)clazz.newInstance();
40         bookFacaed2.setName(&quot;《数据结构》&quot;);
41         bookFacaed2.setPrice(new BigDecimal(100));
42         System.out.println(bookFacaed2);
43     }
44     
45 }
46 
47 class BookFacaed {
48     private String name;
49     
50     private BigDecimal price;
51     
52     public BookFacaed () {}
53     
54     public BookFacaed (String name) {
55         this.name = name;
56     }
57 
58     public BookFacaed (String name, BigDecimal price) {
59         this.name = name;
60         this.price = price;
61     }
62     
63     public String getName() {
64         return name;
65     }
66 
67     public void setName(String name) {
68         this.name = name;
69     }
70 
71     public BigDecimal getPrice() {
72         return price;
73     }
74 
75     public void setPrice(BigDecimal price) {
76         this.price = price;
77     }
78     
79     @Override
80     public String toString() {
81         return name + &quot;的价格为：&quot; + price;
82     }
83 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;【4】获取某个类的所有属性信息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 package com.zyy.test.reflect;
 2 
 3 import java.lang.reflect.Field;
 4 import java.lang.reflect.Modifier;public class TestReflect {
 5     
 6     public static void main(String[] args) throws ClassNotFoundException {
 7         Class&amp;lt;?&amp;gt; clazz = Class.forName(&quot;com.zyy.test.reflect.BookFacaed&quot;);
 8         Field[] fields = clazz.getDeclaredFields();
 9         for (int i = 0; i &amp;lt; fields.length; i++) {
10             //获得类属性的修饰符
11             String pri = Modifier.toString(fields[i].getModifiers());
12             //获得类属性的类型
13             Class&amp;lt;?&amp;gt; type = fields[i].getType();
14             
15             System.out.println(pri + &quot; &quot; + type.getSimpleName() + &quot; &quot; + fields[i].getName());
16             /*打印结果：
17                 private String name
18                 private BigDecimal price
19              */
20         }
21         
22         /*如果要获取类的接口或者父类的属性使用下面的方法获取*/
23         Field[] fields2 = clazz.getFields();
24     }
25     
26 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;【5】获取某个类的所有方法及其属性信息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 package com.zyy.test.reflect;
 2 
 3 import java.lang.reflect.Method;
 4 import java.lang.reflect.Modifier;
 5 import java.math.BigDecimal;
 6 
 7 
 8 public class TestReflect {
 9     
10     public static void main(String[] args) throws ClassNotFoundException {
11         Class&amp;lt;?&amp;gt; clazz = Class.forName(&quot;com.zyy.test.reflect.BookFacaed&quot;);
12         
13         Method[] methods = clazz.getMethods();
14         for (int i = 0; i &amp;lt; methods.length; i++) {
15             System.out.println(&quot;方法&quot; + (i + 1));
16             //获取方法的修饰符
17             String pri = Modifier.toString(methods[i].getModifiers());
18             //获取方法的返回类型
19             Class&amp;lt;?&amp;gt; type = methods[i].getReturnType();
20             //获取方法的持有参数
21             Class&amp;lt;?&amp;gt;[] params = methods[i].getParameterTypes();
22             for (int j = 0; j &amp;lt; params.length; j++) {
23                 System.out.println(params[j].getName());
24             }
25             //获取方法的抛出异常
26             Class&amp;lt;?&amp;gt;[] excTypes = methods[i].getExceptionTypes();
27             for (int j = 0; j &amp;lt; excTypes.length; j++) {
28                 System.out.println(excTypes[j].getName());
29             }
30         }
31     }
32     
33 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;【6】反射机制调用某个类的某个方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 package com.zyy.test.reflect;
 2 
 3 import java.lang.reflect.InvocationTargetException;
 4 import java.lang.reflect.Method;
 5 import java.math.BigDecimal;
 6 
 7 public class TestReflect {
 8     
 9     public static void main(String[] args) throws NoSuchMethodException, SecurityException, ClassNotFoundException, 
10         IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException {
11         
12         Class&amp;lt;?&amp;gt; clazz = Class.forName(&quot;com.zyy.test.reflect.BookFacaed&quot;);
13         //调用BookFacaed的addBook()方法
14         Method method = clazz.getMethod(&quot;addBook&quot;, String.class);
15         method.invoke(clazz.newInstance(), &quot;《数据结构》&quot;);
16     }
17     
18 }
19 
20 class BookFacaed {
21     private String name;
22     
23     private BigDecimal price;
24     
25     public BookFacaed () {}
26     
27     public BookFacaed (String name) {
28         this.name = name;
29     }
30 
31     public BookFacaed (String name, BigDecimal price) {
32         this.name = name;
33         this.price = price;
34     }
35     
36     public void addBook(String name) {
37         System.out.println(&quot;添加书：&quot; + name);
38     }
39     
40     public String getName() {
41         return name;
42     }
43 
44     public void setName(String name) {
45         this.name = name;
46     }
47 
48     public BigDecimal getPrice() {
49         return price;
50     }
51 
52     public void setPrice(BigDecimal price) {
53         this.price = price;
54     }
55     
56     @Override
57     public String toString() {
58         return name + &quot;的价格为：&quot; + price;
59     }
60 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;【7】通过反射机制操作某个类的属性&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 package com.zyy.test.reflect;
 2 
 3 import java.lang.reflect.Field;
 4 import java.math.BigDecimal;
 5 
 6 public class TestReflect {
 7     
 8     public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, 
 9         SecurityException, IllegalArgumentException, IllegalAccessException, InstantiationException {
10         
11         Class&amp;lt;?&amp;gt; clazz = Class.forName(&quot;com.zyy.test.reflect.BookFacaed&quot;);
12         Object obj = clazz.newInstance();
13         //调用BookFacaed的name属性，并赋值
14         Field field = clazz.getDeclaredField(&quot;name&quot;);
15         field.setAccessible(true); //操作属性修饰符为private则必须用此申明
16         field.set(obj, &quot;《数据结构》&quot;);
17         
18         System.out.println(field.get(obj));
19     }
20     
21 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;三、Java反射机制能够帮助我们做什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【1】打破泛型的约束&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 package com.zyy.test.reflect;
 2 
 3 import java.lang.reflect.InvocationTargetException;
 4 import java.lang.reflect.Method;
 5 import java.math.BigDecimal;
 6 import java.util.ArrayList;
 7 import java.util.List;
 8 
 9 public class TestReflect {
10     
11     public static void main(String[] args) throws NoSuchMethodException, SecurityException, 
12         IllegalAccessException, IllegalArgumentException, InvocationTargetException {
13         
14         List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
15         //设定了以上泛型之后，list集合中是无法插入String或者其他类型的数据的
16         //通过泛型我们便可打破这个约束，代码如下
17         Method method = list.getClass().getMethod(&quot;add&quot;, Object.class);
18         method.invoke(list, &quot;看插入了一个String数据&quot;);
19         
20         System.out.println(list.get(0));
21     }
22     
23 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;【2】反射机制实现动态代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Spring的一个核心设计思想便是AOP(面向切面编程)，那么AOP是通过动态代理实现的，而动态代理则用到了反射机制；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　用了反射机制的好处在于，一个代理就能处理所有的委托，而不用一个委托类就创建一个代理；&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 package com.zyy.test.reflect;
 2 
 3 import java.lang.reflect.InvocationHandler;
 4 import java.lang.reflect.Method;
 5 import java.lang.reflect.Proxy;
 6 
 7 
 8 public class TestReflect {
 9     
10     public static void main(String[] args) {
11         //创建代理类并绑定委托类
12         FruitProxy proxy = new FruitProxy();
13         Fruit fruit = (Fruit) proxy.bind(new Apple());
14         fruit.eatFruit();
15     }
16     
17 }
18 
19 interface Fruit {
20     public void eatFruit();
21 }
22 
23 //委托类
24 class Apple implements Fruit {
25     public void eatFruit() {
26         System.out.println(&quot;eat Apple&quot;);
27     }
28 }
29 
30 //代理类
31 class FruitProxy implements InvocationHandler{
32     private Object obj;
33     
34     //绑定对象
35     public Object bind(Object obj) {
36         this.obj = obj;
37         return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this);
38     }
39     
40     @Override
41     public Object invoke(Object proxy, Method method, Object[] args)
42             throws Throwable {
43         System.out.println(&quot;这里添加执行内容,&amp;lt;aop:before/&amp;gt;标签熟悉吧，作用一样&quot;);
44         Method result = (Method) method.invoke(obj, args);
45         System.out.println(&quot;这里添加执行内容,&amp;lt;aop:after/&amp;gt;标签熟悉吧，作用一样&quot;);
46         
47         return result;
48     }
49     
50 }
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;【3】反射机制应用于工厂模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于普通的工厂，新增一个子类的时候，工厂就需要进行调整，而加入反射机制后，工厂则不需要关心你有多少个子类；&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
 1 package com.zyy.test.reflect;
 2 
 3 public class TestReflect {
 4     
 5     public static void main(String[] args) throws InstantiationException, 
 6         IllegalAccessException, ClassNotFoundException {
 7         
 8         Fruit fruit = (Fruit) Factory.getInstance(&quot;com.zyy.test.reflect.Orange&quot;);
 9         fruit.eatFruit();
10     }
11     
12 }
13 
14 interface Fruit {
15     public void eatFruit();
16 }
17 
18 class Apple implements Fruit {
19     public void eatFruit() {
20         System.out.println(&quot;eat Apple&quot;);
21     }
22 }
23 
24 class Orange implements Fruit {
25     public void eatFruit() {
26         System.out.println(&quot;eat Orange&quot;);
27     }
28 }
29 
30 class Factory {
31     public static Object getInstance (String className) throws InstantiationException, 
32         IllegalAccessException, ClassNotFoundException {
33         
34         Object obj = Class.forName(className).newInstance();
35         return obj;
36     }
37     
38 }
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 04 Nov 2017 09:59:00 +0000</pubDate>
<dc:creator>AudreyHepburn</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zyypro/p/7784032.html</dc:identifier>
</item>
<item>
<title>阿里JAVA开发手册零度的思考理解(二) - 匠心零度</title>
<link>http://www.cnblogs.com/lirenzuo/p/7783998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lirenzuo/p/7783998.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;转载请注明原创出处，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;说在前面&quot;&gt;说在前面&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;人生的大道上默默地走，就必须要有一盏灯亮着为你引导方向！而这盏灯抑或只是一句话，一句鼓励，一个赞美，一次承认，一次认可，一次相识一次交流……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&amp;amp;mid=2247483742&amp;amp;idx=1&amp;amp;sn=45385073d1b4375363f09f7fe6385917&amp;amp;chksm=fcaedb42cbd95254328a7014eb9a1608e4efe7c3df9680431aba6b783e2652cafed2df8663e4#rd&quot;&gt;阿里JAVA开发手册零度的思考理解(一)&lt;/a&gt;得到作者&lt;strong&gt;孤尽&lt;/strong&gt;的肯定支持，那是一个小激动啊，我会继续努力，继续阅读和思考阿里JAVA开发手册，毕竟每一条都是前人踩过的坑，通过血的教训总结出来的。&lt;/p&gt;
&lt;h3 id=&quot;上篇题目回顾&quot;&gt;上篇题目回顾&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-6e6ffb470ba18275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;阿里JAVA开发手册&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看完这条，个人觉得主要是&lt;strong&gt;集合相关操作&lt;/strong&gt;，在JAVA基础中&lt;strong&gt;集合&lt;/strong&gt;这块的重要性也的确非常重要（毕竟是用到最多的），本期只会结合上题进行一些简单扩展，并不会涵盖所有集合操作，也不涉及集合是否线程安全这块，后期我会在我的系列&lt;strong&gt;高并发、锁系列&lt;/strong&gt;里扩展深入。&lt;/p&gt;
&lt;h3 id=&quot;集合的重要性&quot;&gt;集合的重要性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;已经有数组了为什么会出现集合呢？&lt;/strong&gt;依然清晰的记得数据结构里面顺序结构、链式结构的特点。在这里数组就属于顺序结构（但是集合里面根据顺序结构或者链式结构实现的都有，所以在选择用那个的时候最起码需要有那么一点点思考而不是拿什么用什么）。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;数组一旦定义，长度将不能再变化。并且数组仅仅是一个一连串的变量而已，对于很多重复的操作（并没有进行统一的抽象）而且有些顺序结构并不太适合，需要链式结构实现适合或者是需要顺序结构与链式结构结合实现才比较合适。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;对于很多重复的操作，比如如果需要扩容，需要自己实现，根据编码水平不同实现的效率不一样（而且这个可能大量存在，每个人都需要实现，不符合工程学的思想），再比如需要排序，增删，遍历等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上面的一些问题就引入了集合并且解决了这些问题，所以集合非常重要，并且项目中集合到处可见，需要把db，nosql里面的数据接收下来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面看看集合具备的几个特性 ：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这种框架是高性能的，对于基本集合（动态数组、链表、树和散列表）的实现是高效的，并且是经过高度测试（不管是性能，安全等都是很可靠的）。&lt;/li&gt;
&lt;li&gt;集合允许不同类型的集合以相同的方式继续操作。&lt;/li&gt;
&lt;li&gt;集合是容易扩展和修改的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;集合的遍历思考&quot;&gt;集合的遍历思考&lt;/h3&gt;
&lt;p&gt;集合遍历，从工程学我们需要提供一种方法顺序访问一个集合对象中的各各元素，&lt;strong&gt;而又不需要暴露该对象的内部表示&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如何才能做到呢？？？ 迭代器模式就可以做到，下面带大家一起去了解下。&lt;/p&gt;
&lt;h3 id=&quot;迭代器模式&quot;&gt;迭代器模式&lt;/h3&gt;
&lt;p&gt;迭代器模式的功能主要在于提供对聚合对象的迭代访问。主要就是这个&lt;strong&gt;访问&lt;/strong&gt;进行做文章的。那么为什么使用迭代器模式呢？有什么好处呢？&lt;/p&gt;
&lt;p&gt;一般情况下面，使用的都是外部迭代器（由客户端来控制迭代器的下一个元素的步骤，就是在代码里面我们需要手动调用next来迭代下一个元素，这样做就是要灵活点）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;JDK5之后引入的新特性foreach（ 增强版for）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;通过使用javap查看反编译代码，在数组里面，是固有的foreach实现，直接循环数组，而在容器的迭代foreach是通过迭代器来实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-c09ddb3971cb0d40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;数组foreach&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-7ce777ba9ffb1b53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;容器的迭代foreach&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在稍微多做点铺垫&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;解题&quot;&gt;解题&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-6e6ffb470ba18275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;阿里JAVA开发手册&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面说了那么多，我觉得现在可以开始解题了，各位看官久等了。并发系列又是另外一个重要的话题，先不考虑并发进行分析，如果并发操作，需要对Iterator对象加锁，这个应该好理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;This field is used by the iterator and list iterator implementation returned by the iterator and listIterator methods. If the value of this field changes unexpectedly, the iterator (or list iterator) &lt;strong&gt;will throw a ConcurrentModificationException in response to the next, remove, previous, set or add operations.&lt;/strong&gt; This provides fail-fast behavior, rather than non-deterministic behavior in the face of concurrent modification during iteration.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;Use of this field by subclasses is optional. If a subclass wishes to provide fail-fast iterators (and list iterators), then it merely has to increment this field in its &lt;strong&gt;add(int, E) and remove(int)&lt;/strong&gt; methods (and any other methods that it overrides that result in structural modifications to the list). A single call to add(int, E) or remove(int) must add no more than one to this field, or the iterators (and list iterators) will throw bogus ConcurrentModificationExceptions. If an implementation does not wish to provide fail-fast iterators, this field may be ignored.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;所以应该注意，并不仅仅包括remove，add元素也请使用Iterator方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这一条标准是加了强制的，说明了重要性，按照上面的优秀实践去做就对了。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        List&amp;lt;String&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();
        
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2&quot;&lt;/span&gt;);
        
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(String item:list){
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(item)){  &lt;span class=&quot;co&quot;&gt;//(1    换成  if(&quot;2&quot;.equals(item)){ &lt;/span&gt;
                list.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(item);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当（1 换成 if(&quot;2&quot;.equals(item)){ 之后，运行结果报异常，结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-9393c0c2d753fce1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这种给出了错误，并且有代码行数的情况其实发现查找问题都挺方便的，&lt;strong&gt;其实该问题的重点就变成了都是基于Iterator的输出，但是在进行删除元素的时候应该用那种方式才正确。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有必要纠结为什么1不错，而2错，稍微看下源码就知道了，其实我们也可以让2不错，只是jdk里面就是这样实现的，它的解释和考虑如下原因。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;原因&quot;&gt;原因&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;ArrayList此类的 iterator 和 listIterator 方法返回的迭代器是快速失败的：在创建迭代器之后，除非通过迭代器自身的 remove 或 add 方法从结构上对列表进行修改，否则在任何时间以任何方式对列表进行修改，迭代器都会抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-8de8bad5d4836abf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;快速失败&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以最佳实践就按照阿里java开发手册里面那样就好了，add元素也请使用Iterator方式。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;实际工作中迭代器用法&quot;&gt;实际工作中迭代器用法&lt;/h3&gt;
&lt;p&gt;可能说完，大家感觉迭代器就仅仅在集合遍历里面用，而且都已经有了，其实实际中的确有一些用法，反正都是围绕控制访问的，比如分页，非常常见的情况，如果每次都基于数据库分页那么怕性能不好，如果完全在内存（内存太贵，数据太多，不现实），一般的做法就是比如一页20条数据，我们一般可以每次查询数据库的时候取5页到内存（具体每次取多少可以根据用户行为分析，得到一个比较合理的，而且越到后面访问的机会越少，取到内存的就越少了，可以先比如每次都是取n页数据，在多少页之后每次取m页 之后在每次取一页一页了。n&amp;gt;m&amp;gt;1）。那么比如取出来的100条数据在内存中，需要进行根据分页访问，而原来的jdk里面的好像不满足，那么自己实现一个类似的是不是特别灵活呢？后续有空，我会在我的微信公众号，系列文章的&lt;strong&gt;技术思考&lt;/strong&gt;里面把类似这块分析下的。&lt;/p&gt;
&lt;h3 id=&quot;思考&quot;&gt;思考&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-97e6bf4bf7371a64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;阿里JAVA开发手册&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是阿里JAVA开发手册其中一条明细，&lt;strong&gt;期待你的留言和分析！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果读完觉得有收获的话，欢迎点赞加关注。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;查阅更多历史，欢迎关注个人公众号！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-5f48f1430e958383.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;匠心零度公众号.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Nov 2017 09:46:00 +0000</pubDate>
<dc:creator>匠心零度</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lirenzuo/p/7783998.html</dc:identifier>
</item>
</channel>
</rss>