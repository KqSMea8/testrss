<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>spark的sparkUI如何解读？ - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/7764687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/7764687.html</guid>
<description>&lt;p&gt;spark的sparkUI如何解读？&lt;/p&gt;
&lt;p&gt;以spark2.1.4来做例子&lt;/p&gt;

&lt;p&gt;进入之后默认是进入spark job 页面&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/136188/201711/136188-20171101074231451-242406055.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个说明有很详细的解释，spark有两种操作算子：转换算子（transformation）和执行算子（Action）。当执行到行为算子的时候，就出发了一个Job作业，比如count()和saveAsTextFile()。&lt;/p&gt;
&lt;p&gt;sparkJob页面头部有几个，最重要的是Schedule mode，表示的是Job的调度模型。如果多个线程调用多个并行的job，这些job就会被分配调用，这里就有个调度模型，一般是FIFO模型，先进先出模型。但是在spark0.8之后，就支持了一种FAIR模型，FAIR模型是一种公平模型，相当于每个任务轮换使用资源等，这样能使的小job能很快执行，而不用等大job完成才执行了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/136188/201711/136188-20171101074242779-1062993761.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就是用来表示调度job何时启动，何时结束，并且excutor何时加入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/136188/201711/136188-20171101074258623-773179491.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以很方便看到哪些job已经运行完成，使用了多少excutor，哪些正在运行。&lt;/p&gt;
&lt;p&gt;点击进入每个job，我们就可以看到每个job的detail&lt;/p&gt;

&lt;p&gt;在这个页面我们能看到job的详情。一个job会被分为一个或者多个stage&lt;/p&gt;
&lt;p&gt;这里也有event timeline，告诉我们这个job中每个stage执行时间。&lt;/p&gt;
&lt;p&gt;这里多了一个DAG可视化的图&lt;/p&gt;
&lt;h2 id=&quot;dag&quot;&gt;DAG&lt;/h2&gt;
&lt;p&gt;DAG图是有向无环图的意思。spark中使用有向无环图来显示流程。&lt;/p&gt;
&lt;p&gt;DAG也是一种调度模型，在spark的作业调度中，有很多作业存在依赖关系，所以有的作业可以并行执行，有的作业不能并行执行。把这些作业的内部转向关系描绘清楚，就是一个DAG图。使用DAG图，就能很清晰看到我们的作业（RDD）哪些先执行，哪些后执行，哪些是并行执行的。&lt;/p&gt;
&lt;p&gt;当调用了一个行为算子的时候，前面的所有转换算子也会一并提交给DAG调度器，DAG调度器把这些算子操作分为不同的stage，这个就是stage的由来。而DAG在画stage的时候也会产生出一个DAG图，就是这里的图了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/136188/201711/136188-20171101074313232-2068273247.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击每个stage，我们就能看到这个stage执行的任务（Task）了。&lt;/p&gt;

&lt;h2 id=&quot;标题&quot;&gt;标题&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/136188/201711/136188-20171101074325420-1255955837.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;标题代表这是第几号stage，第几次尝试。&lt;/p&gt;
&lt;h2 id=&quot;show-additional-metrics&quot;&gt;Show Additional Metrics&lt;/h2&gt;
&lt;h3 id=&quot;scheduler-delay&quot;&gt;Scheduler Delay&lt;/h3&gt;
&lt;p&gt;调度延迟时间，包含把任务从调度器输送给excutor，并且把任务的结果从excutor返回给调度器。如果调度时间比较久，则考虑降低任务的数量，并且降低任务结果大小&lt;/p&gt;
&lt;h3 id=&quot;task-deserialization-time&quot;&gt;Task Deserialization Time&lt;/h3&gt;
&lt;p&gt;反序列化excutor的任务，也包含读取广播任务的时间&lt;/p&gt;
&lt;h3 id=&quot;shuffle-read-blocked-time&quot;&gt;Shuffle Read Blocked Time&lt;/h3&gt;
&lt;p&gt;任务shuffle时间，从远端机器读取shuffle数据的时间&lt;/p&gt;
&lt;h3 id=&quot;shuffle-remote-reads&quot;&gt;Shuffle Remote Reads&lt;/h3&gt;
&lt;p&gt;从远端机器读取shuffle数据的时间&lt;/p&gt;
&lt;h3 id=&quot;getting-result-time&quot;&gt;Getting Result Time&lt;/h3&gt;
&lt;p&gt;从worker中获取结果的时间&lt;/p&gt;
&lt;p&gt;// 这里应该还有一些其它的各种指标，等以后看代码的时候再补充。&lt;/p&gt;
&lt;p&gt;在用图形表示完之后还有一个summary的时间统计，告诉你每个阶段的时间，所有任务的分布图。&lt;/p&gt;

&lt;p&gt;这个矩阵告诉我们每个excutor的执行情况。&lt;/p&gt;

&lt;p&gt;告知每个任务的执行情况。&lt;/p&gt;

&lt;p&gt;显示所有的环境变量&lt;/p&gt;

&lt;p&gt;显示每个excutor的统计情况&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.csdn.net/article/2015-07-08/2825162&quot; class=&quot;uri&quot;&gt;http://www.csdn.net/article/2015-07-08/2825162&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://jaceklaskowski.gitbooks.io/mastering-apache-spark/content/spark-webui-StagePage.html&quot; class=&quot;uri&quot;&gt;https://jaceklaskowski.gitbooks.io/mastering-apache-spark/content/spark-webui-StagePage.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 23:44:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjf512/p/7764687.html</dc:identifier>
</item>
<item>
<title>Docker 如何支持多种日志方案？- 每天5分钟玩转 Docker 容器技术（88） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/7762369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/7762369.html</guid>
<description>&lt;p&gt;&lt;span&gt;将容器日志发送到 STDOUT 和 STDERR 是 Docker 的默认日志行为。实际上，Docker 提供了多种日志机制帮助用户从运行的容器中提取日志信息。这些机制被称作 logging driver。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;Docker 的默认 logging driver 是&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;json-file&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;# docker info |grep 'Logging Driver'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Logging Driver: json-file&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;如果容器在启动时没有特别指明，就会使用这个默认的 logging driver。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;json-file&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;会将容器的日志保存在 json 文件中，Docker 负责格式化其内容并输出到 STDOUT 和 STDERR。&lt;/p&gt;
&lt;p&gt;我们可以在 Host 的容器目录中找到这个文件，器路径为&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;/var/lib/docker/containers/&amp;lt;contariner ID&amp;gt;/&amp;lt;contariner ID&amp;gt;-json.log&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;比如我们可以查看前面 httpd 容器 json 格式的日志文件。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171031-1509439261125030420.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171031-1509439261125030420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 5 条日志记录。&lt;/p&gt;
&lt;p&gt;除了&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;json-file&lt;/span&gt;&lt;/code&gt;，Docker 还支持多种 logging driver。完整列表可访问官方文档&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;a href=&quot;https://docs.docker.com/engine/admin/logging/overview/#supported-logging-drivers&quot;&gt;https://docs.docker.com/engine/admin/logging/overview/#supported-logging-drivers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171031-1509439261232024465.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171031-1509439261232024465.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;none&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;是 disable 容器日志功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;syslog&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;和&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;journald&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;是 Linux 上的两种日志管理服务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;awslogs&lt;/span&gt;&lt;/code&gt;、&lt;code&gt;&lt;span&gt;splunk&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;和&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;gcplogs&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;是第三方日志托管服务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;gelf&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;和&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;fluentd&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;是两种开源的日志管理方案，我们会在后面分别讨论。&lt;/p&gt;
&lt;p&gt;容器启动时可以通过&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;--log-driver&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;指定使用的 logging driver。如果要设置 Docker 默认的 logging driver，需要修改 Docker daemon 的启动脚本，指定&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;--log-driver&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;参数，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;ExecStart=/usr/bin/dockerd -H fd:// --log-driver=syslog --log-opt ......&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;每种 logging driver 都有自己的&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;--log-opt&lt;/span&gt;&lt;/code&gt;，使用时请参考官方文档。&lt;/p&gt;
&lt;p&gt;下一节我们开始学习 ELK。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627732322012171.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171010-1507627732322012171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 23:30:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/7762369.html</dc:identifier>
</item>
<item>
<title>javascript 之作用域链-07 - 风吹De麦浪</title>
<link>http://www.cnblogs.com/CandyManPing/p/7764664.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CandyManPing/p/7764664.html</guid>
<description>&lt;p&gt;上一节我们说到作用域：是指变量可以访问的范围，他规定了如何查找变量，以及确定当前执行代码对变量的访问权限；也说到静态作用域即词法作用域，是在编译阶段决定变量的引用（由程序定义的位置决定，和代码执行顺序无关，用嵌套的方式解析）。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; x=10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; name='Joel'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         console.log(x+name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10Joel  这里做了隐适转换 当有+时有一个为string 那么会当做字符拼接来处理&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     run();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，在执行run函数时，在run作用域中有name变量，但是并没有变量x，那么为什么不会报错，变量x又是怎么访问的呢？可能有些人理解是去父级函数作用域中寻找变量，其实这样理解作用域存在歧义（如果理解为是在调用函数的父级函数，那么肯定是错的  如下代码），上一节我们说过javascript的作用域是静态作用域，即&lt;span&gt;&lt;strong&gt;应该关心代码定义的位置而不是调用的位置&lt;/strong&gt;&lt;/span&gt; （词法作用域）；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; x=10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        console.log(x);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(f){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; x=20&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            f()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     show(fn);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10 并不是20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过分析作用域的变量解析来理解作用域链&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; a=10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; name='Joel'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; say(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; content='hello'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             console.log(content+name+','+&lt;span&gt;a);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        say();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     run();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;helloJoel,10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/825196/201711/825196-20171101000818091-2095888431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上一篇我们知道js作用域有全局作用域，函数作用域，所以上面代码作用域如下：&lt;/p&gt;
&lt;p&gt;全局作用域：存在变量a、run函数引用，当然还存在其他函数、属性（内置的就不讨论了）；&lt;/p&gt;
&lt;p&gt;run函数作用域：存在变量 name 、say函数引用；&lt;/p&gt;
&lt;p&gt;say函数作用域：存在变量content；&lt;/p&gt;
&lt;p&gt;当代码执行到 console.log(content+name+','+a); 首先在say函数作用域中寻找变量content、name、a，如果找到则停止，没有找到就到上一个作用域中寻找，以此类推一直到window 全局作用域，如变量a 在当前say 作用域中没有，就到run作用域中寻找，还没找到就到全局作用域中寻找，如果还找不到就报错 is not defined，因为全局作用域是最外层作用域 ；&lt;/p&gt;
&lt;p&gt;继续看下面代码，我们在say函数中定义了变量name 之后，name值不在是run作用域中的值，因为在say作用域中找到了变量name 就不会继续寻找了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; a=10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; name='Joel'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; say(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; content='hello',name=' Word'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;             console.log(content+name+','+&lt;span&gt;a);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        say();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     run();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hello Word,10&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这样一步一步的寻找变量的过程我们叫做标识符解析或者你可以理解为变量解析，那么提供这个线路或者这样寻找变量的机制我们叫做作用域链；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们来总结一下这个过程：&lt;/p&gt;
&lt;p&gt;第一步，在当前作用域查找变量，如果有则获取并停止。如果没有则继续向上一个作用域寻找；&lt;/p&gt;
&lt;p&gt;第二步，如果当前作用域是全局作用域，则说明变量未定义，结束；否则继续；&lt;/p&gt;
&lt;p&gt;第三步，（不是全局作用域，那就是函数作用域）继续第一步；&lt;/p&gt;
&lt;p&gt;那么作用域链到底是什么呢？&lt;/p&gt;
&lt;p&gt;其实作用域链本质是一个指向变量对象的指针链表，它只引用但不实际包含变量对象的值；&lt;/p&gt;
&lt;p&gt;如上代码作用域链结构类似这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/825196/201711/825196-20171101012109107-1708437867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这篇只是引出作用域链，下一篇正式开始说执行环境，会涉及到变量对象、活动对象、作用域链等内容从而深入作用域链的创建过程。&lt;/p&gt;
&lt;p&gt;之所以要先写执行环境，是因为完整的作用域链是在执行环境中构建的。&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 18:54:00 +0000</pubDate>
<dc:creator>风吹De麦浪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CandyManPing/p/7764664.html</dc:identifier>
</item>
<item>
<title>Spring AOP中级——应用场景 - 余林丰</title>
<link>http://www.cnblogs.com/yulinfeng/p/7764600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/7764600.html</guid>
<description>&lt;p&gt;　　在&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/7719128.html&quot; target=&quot;_blank&quot;&gt;《Spring AOP初级——入门及简单应用》&lt;/a&gt;中对AOP作了简要的介绍，以及一些专业术语的解释，同时写了一个简单的Spring AOPdemo。本文将继续探讨Spring AOP在实际场景中的应用。&lt;/p&gt;
&lt;p&gt;　　对用户操作日志的记录是很常见的一个应用场景，本文选取“用户管理”作为本文Spring AOP的示例。当然，该示例只是对真实场景的模拟，实际的环境一定比该示例更复杂。&lt;/p&gt;
&lt;p&gt;　　该示例的完整代码路径在&lt;a href=&quot;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/Spring%20AOP%E4%B8%AD%E7%BA%A7%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF&quot; target=&quot;_blank&quot;&gt;https://github.com/yu-linfeng/BlogRepositories/tree/master/repositories/Spring%20AOP%E4%B8%AD%E7%BA%A7%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF&lt;/a&gt;。本文仅对Spring AOP相关的代码进行讲解。&lt;/p&gt;
&lt;p&gt;　　在这个示例中首次采用RESTful架构风格，对于以下RESTful API的设计可能并不完美，如果有熟悉、精通RESTful架构风格的朋友希望能够指出我的错误。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201711/630246-20171101004300576-124864376.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;398&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用RESTful的前后端分离架构风格后，我感受到了前所未有的畅快，所以此次示例并没有前端页面的展示，完全使用JUnit进行单元测试包括对HTTP请求的Mock模拟，这部分代码不会进行详细讲解，之后会继续深入JUnit单元测试的一些学习研究。&lt;/p&gt;
&lt;p&gt;　　数据库只有一张表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201711/630246-20171101003110888-407031171.png&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　回到正题，我们回顾下切面由哪两个部分组成： 通知 切点 首先明确我们需要在何时记录日志：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　通知&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　切点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先明确我们需要在何时记录日志：&lt;/p&gt;
&lt;p&gt;　　1. 查询所有用户时，并没有参数（此示例没有作分页），只有在返回时才会有数据的返回，所以对查询所有用户的方法采用返回通知（AfterReturning）。&lt;/p&gt;
&lt;p&gt;　　2. 新增用户时，会带有新增的参数，此时可采用前置通知（Before）。&lt;/p&gt;
&lt;p&gt;　　3. 修改用户时，也会带有新增的参数，此时同样采用前置通知（Before）。&lt;/p&gt;
&lt;p&gt;　　4. 删除用户时，通常会带有唯一标识符ID，此时采用前置通知（Before）记录待删除的用户ID。&lt;/p&gt;
&lt;p&gt;　　在明确了通知类型后，此时我们需要明确切点，也就是在哪个地方记录日志。当然上面实际已经明确了日志记录的位置，但主要是切面表达式的书写。 在有了&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/7719128.html&quot; target=&quot;_blank&quot;&gt;《Spring AOP初级——入门及简单应用》&lt;/a&gt;的基础，相信对日志切面类已经比较熟悉了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.manager.aspect;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.log4j.Logger;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.JoinPoint;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; org.aspectj.lang.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * 日志切面
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/10/29.
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;@Aspect
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogAspect {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * 操作日志文件名
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String OPERATION_LOG_NAME = &quot;operationLog&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String LOG_FORMATTER = &quot;%s.%s - %s&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     Logger log =&lt;span&gt; Logger.getLogger(OPERATION_LOG_NAME);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * 对查询方法记录日志的切点
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     @Pointcut(&quot;execution(* com.manager..*.*Controller.query*(..))&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; query(){}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * 对新增方法记录日志的切点
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     @Pointcut(&quot;execution(* com.manager..*.*Controller.add*(..))&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(){}
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * 对修改方法记录日志的切点
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     @Pointcut(&quot;execution(* com.manager..*.*Controller.update*(..))&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(){}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;     * 对删除方法记录日志的切点
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     @Pointcut(&quot;execution(* com.manager..*.*Controller.delete*(..))&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete(){}
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     @AfterReturning(value = &quot;query()&quot;, returning = &quot;rvt&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; queryLog(JoinPoint joinPoint, Object rvt) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         String className =&lt;span&gt; joinPoint.getTarget().getClass().getName();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         String methodName =&lt;span&gt; joinPoint.getSignature().getName();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         String returnResult =&lt;span&gt; rvt.toString();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        log.info(String.format(LOG_FORMATTER, className, methodName, returnResult));
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;     @Before(&quot;add()&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addLog(JoinPoint joinPoint) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         String className =&lt;span&gt; joinPoint.getTarget().getClass().getName();
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         String methodName =&lt;span&gt; joinPoint.getSignature().getName();
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         Object[] params =&lt;span&gt; joinPoint.getArgs();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        log.info(String.format(LOG_FORMATTER, className, methodName, Arrays.toString(params)));
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;     @Before(&quot;update()&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateLog(JoinPoint joinPoint) {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         String className =&lt;span&gt; joinPoint.getTarget().getClass().getName();
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         String methodName =&lt;span&gt; joinPoint.getSignature().getName();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         Object[] params =&lt;span&gt; joinPoint.getArgs();
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;        log.info(String.format(LOG_FORMATTER, className, methodName, Arrays.toString(params)));
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;     @Before(&quot;delete()&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteLog(JoinPoint joinPoint) {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         String className =&lt;span&gt; joinPoint.getTarget().getClass().getName();
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         String methodName =&lt;span&gt; joinPoint.getSignature().getName();
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         Object[] params =&lt;span&gt; joinPoint.getArgs();
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        log.info(String.format(LOG_FORMATTER, className, methodName, Arrays.toString(params)));
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的日志切面类中出现了JointPoint类作为参数的情况，这个参数能够传递被通知方法的相信，例如被通知方法所处的类以及方法名等。在第47行中的Object rvt参数就是获取被通知方法的返回值。 上面的切面并没有关注被通知方法的参数，如果要使得切面和被通知方法参数参数关联可以使用以下的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@Pointcut(&quot;execution(* com.xxx.demo.Demo.method(&lt;span&gt;int&lt;/span&gt;)) &amp;amp;&amp;amp;&lt;span&gt; args(arg)&quot;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; aspectMethod(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg){}

@Before(“aspectMedhot(arg)”)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; method(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时arg参数就是被通知方法的参数&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　本例中最主要的切面部分就完成了。注意在结合Spring时需要在applicationContext.xml中加入以下语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;启用AspectJ自动代理，其中proxy-target-class为true表示使用CGLib的代理方式，false表示JDK的代理方式，默认false&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:aspectj-autoproxy &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例中关于log4j、pom.xml依赖、JUnit如何结合Spring进行单元测试等等均可可以参考完整代码。特别是JUnit是很值得学习研究的一部分，这部分在将来慢慢我也会不断学习推出新的博客，在这里就只贴出JUnit的代码，感兴趣的可以浏览一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.manager.user.controller;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.fasterxml.jackson.databind.ObjectMapper;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.manager.user.pojo.User;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.MediaType;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.web.WebAppConfiguration;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.MockMvc;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.result.MockMvcResultMatchers;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.web.servlet.setup.MockMvcBuilders;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.WebApplicationContext;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.junit.Assert.assertNotNull;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt; * UserController单元测试
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/10/26.
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; @ContextConfiguration({&quot;classpath*:applicationContext.xml&quot;, &quot;classpath*:spring-servlet.xml&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;@WebAppConfiguration
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserControllerTest {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; WebApplicationContext wac;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; MockMvc mvc;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    @Before
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initMockHttp() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.mvc =&lt;span&gt; MockMvcBuilders.webAppContextSetup(wac).build();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testQueryUsers() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         mvc.perform(MockMvcRequestBuilders.get(&quot;/users&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                .andExpect(MockMvcResultMatchers.status().isOk());
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testAddUser() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         user.setName(&quot;kevin&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         user.setAge(23&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         mvc.perform(MockMvcRequestBuilders.post(&quot;/users&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                .contentType(MediaType.APPLICATION_JSON_UTF8)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 .content(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectMapper().writeValueAsString(user)))
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                .andExpect(MockMvcResultMatchers.status().isOk())
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.name&quot;).value(&quot;kevin&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.age&quot;).value(23&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testQueryUserById() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         user.setId(8&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         mvc.perform(MockMvcRequestBuilders.get(&quot;/users/&quot; +&lt;span&gt; user.getId()))
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                .andExpect(MockMvcResultMatchers.status().isOk())
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.name&quot;).value(&quot;kevin&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                 .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.age&quot;).value(23&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testUpdateUserById() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         user.setId(9&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         user.setName(&quot;tony&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         user.setAge(99&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         mvc.perform(MockMvcRequestBuilders.put(&quot;/users/&quot; +&lt;span&gt; user.getId())
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;                .contentType(MediaType.APPLICATION_JSON_UTF8)
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;                 .content(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectMapper().writeValueAsString(user)))
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;                .andExpect(MockMvcResultMatchers.status().isOk());
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testDeleteUserById() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; id = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;         mvc.perform(MockMvcRequestBuilders.delete(&quot;/users/&quot; +&lt;span&gt; id))
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;                .andExpect(MockMvcResultMatchers.status().isOk());
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有了初级和中级，接下来必然就是Spring AOP高级——源码实现。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 16:44:00 +0000</pubDate>
<dc:creator>余林丰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/7764600.html</dc:identifier>
</item>
<item>
<title>由移动端级联选择器所引发的对于数据结构的思考 - nzbin</title>
<link>http://www.cnblogs.com/nzbin/p/7754447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nzbin/p/7754447.html</guid>
<description>&lt;blockquote readability=&quot;1.0917431192661&quot;&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/nzbin/Framework7-CityPicker&quot; target=&quot;_blank&quot;&gt;https://github.com/nzbin/Framework7-CityPicker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Demo：&lt;a href=&quot;https://nzbin.github.io/Framework7-CityPicker/&quot; target=&quot;_blank&quot;&gt;https://nzbin.github.io/Framework7-CityPicker/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/999445/201710/999445-20171031212033279-415490372.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在做移动端项目的时候遇到了省市区选择的功能。以往做项目时都是省市区分开的下拉框样式。这次希望实现效果图要求的级联选择器。我是 Framework7 框架的忠实粉丝，庆幸的是 Framework7 已经有模拟 iOS 选择框效果的 Picker 组件。在开发之前我先搜索了现有的一些选择器插件，整体而言都能满足需求但都不完美，比如滑动不流畅、显示有 Bug 等等。&lt;/p&gt;
&lt;h2&gt;Picker 级联选择器&lt;/h2&gt;
&lt;p&gt;基于 Framework7 制作级联选择器比较简单，关键是生成省市区数组以及省市区之间的联动。&lt;/p&gt;
&lt;p&gt;以下是 CityPicker 的基本参数设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; pickerLocation =&lt;span&gt; myApp.picker({
    input: &lt;/span&gt;'#location',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择器&lt;/span&gt;
    rotateEffect: &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//设置&lt;/span&gt;&lt;span&gt;旋转效果&lt;/span&gt;
    toolbarTemplate: '',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义按钮&lt;/span&gt;
&lt;span&gt;    cols: [{
            cssClass: &lt;/span&gt;'f-s-14',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加自定义类&lt;/span&gt;
            width: 100,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;列宽&lt;/span&gt;
            textAlign: 'left',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对齐方式&lt;/span&gt;
            values: province,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省数组&lt;/span&gt;
            onChange: &lt;span&gt;function&lt;/span&gt;(picker, province) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;联动方法&lt;/span&gt;
&lt;span&gt;
            }
        },
        {
            cssClass: &lt;/span&gt;'f-s-14',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加自定义类&lt;/span&gt;
            width: 100,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;列宽&lt;/span&gt;
            textAlign: 'center',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对齐方式&lt;/span&gt;
            values: city,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;市数组&lt;/span&gt;
            onChange: &lt;span&gt;function&lt;/span&gt;(picker, city) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;联动方法&lt;/span&gt;
&lt;span&gt;
            }
        },
        {
            cssClass: &lt;/span&gt;'f-s-14',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加自定义类&lt;/span&gt;
            width: 100,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;列宽&lt;/span&gt;
            textAlign: 'right',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对齐方式&lt;/span&gt;
            values: area,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;区数组&lt;/span&gt;
&lt;span&gt;        }
    ]
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中省市区的格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
province = ['北京','天津','河北','山东'&lt;span&gt;,...]
city &lt;/span&gt;= ['济南','青岛','淄博','滨州'&lt;span&gt;,...]
area &lt;/span&gt;= ['滨城区','惠民县','阳信县','博兴县',...]
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;省市区数据结构&lt;/h2&gt;
&lt;p&gt;没有想到一个简单的问题，最后竟然扯到了数据结构。经过尝试和思考，最终出现了三种数据结构，而这些东西应该都不是新鲜事。鉴于学识有限，我只能浅尝辄止的对比三者的异同，以及给出自己循环数据的方法。&lt;/p&gt;
&lt;h3&gt;1.无子父级关系的数组&lt;/h3&gt;
&lt;p&gt;去年做项目时省市区数据并没有从接口读取，而是保存到一个 JS 文件中。以下是后台从数据库导出的原始省市区数据片段（2016 年的数据，应该比较全，我删除了香港、澳门及台湾）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('63e92cac-0e40-473c-9c96-6cd041f2bea2')&quot; readability=&quot;59.5&quot;&gt;&lt;img id=&quot;code_img_closed_63e92cac-0e40-473c-9c96-6cd041f2bea2&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_63e92cac-0e40-473c-9c96-6cd041f2bea2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('63e92cac-0e40-473c-9c96-6cd041f2bea2',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_63e92cac-0e40-473c-9c96-6cd041f2bea2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;114&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
    {
      &lt;/span&gt;&quot;region_id&quot;: 11&lt;span&gt;,
      &lt;/span&gt;&quot;region_name&quot;: &quot;北京市&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;region_sort&quot;: 1&lt;span&gt;,
      &lt;/span&gt;&quot;region_remark&quot;: &quot;直辖市&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;pinyin&quot;: &quot;beijingshi&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;py&quot;: &quot;bjs&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;area_code&quot;: &quot;110000&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;parent_id&quot;: 1&lt;span&gt;,
      &lt;/span&gt;&quot;level&quot;: 1&lt;span&gt;
    },
    {
      &lt;/span&gt;&quot;region_id&quot;: 12&lt;span&gt;,
      &lt;/span&gt;&quot;region_name&quot;: &quot;天津市&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;region_sort&quot;: 2&lt;span&gt;,
      &lt;/span&gt;&quot;region_remark&quot;: &quot;直辖市&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;pinyin&quot;: &quot;tianjinshi&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;py&quot;: &quot;tjs&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;area_code&quot;: &quot;120000&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;parent_id&quot;: 1&lt;span&gt;,
      &lt;/span&gt;&quot;level&quot;: 1&lt;span&gt;
    },
    {
      &lt;/span&gt;&quot;region_id&quot;: 13&lt;span&gt;,
      &lt;/span&gt;&quot;region_name&quot;: &quot;河北省&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;region_sort&quot;: 3&lt;span&gt;,
      &lt;/span&gt;&quot;region_remark&quot;: &quot;省份&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;pinyin&quot;: &quot;hebeisheng&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;py&quot;: &quot;hbs&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;area_code&quot;: &quot;130000&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;parent_id&quot;: 1&lt;span&gt;,
      &lt;/span&gt;&quot;level&quot;: 1&lt;span&gt;
    },
    ...
    {
      &lt;/span&gt;&quot;region_id&quot;: 101&lt;span&gt;,
      &lt;/span&gt;&quot;region_name&quot;: &quot;北京市&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;region_sort&quot;: 1&lt;span&gt;,
      &lt;/span&gt;&quot;region_remark&quot;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;pinyin&quot;: &quot;beijingshi&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;py&quot;: &quot;bjs&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;area_code&quot;: &quot;110100&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;parent_id&quot;: 11&lt;span&gt;,
      &lt;/span&gt;&quot;level&quot;: 2&lt;span&gt;
    },
    {
      &lt;/span&gt;&quot;region_id&quot;: 102&lt;span&gt;,
      &lt;/span&gt;&quot;region_name&quot;: &quot;天津市&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;region_sort&quot;: 2&lt;span&gt;,
      &lt;/span&gt;&quot;region_remark&quot;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;pinyin&quot;: &quot;tianjinshi&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;py&quot;: &quot;tjs&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;area_code&quot;: &quot;120100&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;parent_id&quot;: 12&lt;span&gt;,
      &lt;/span&gt;&quot;level&quot;: 2&lt;span&gt;
    },
    {
      &lt;/span&gt;&quot;region_id&quot;: 105&lt;span&gt;,
      &lt;/span&gt;&quot;region_name&quot;: &quot;邯郸市&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;region_sort&quot;: 5&lt;span&gt;,
      &lt;/span&gt;&quot;region_remark&quot;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;pinyin&quot;: &quot;handanshi&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;py&quot;: &quot;hds&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;area_code&quot;: &quot;130400&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;parent_id&quot;: 13&lt;span&gt;,
      &lt;/span&gt;&quot;level&quot;: 2&lt;span&gt;
    },
    ...
  }
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 这个数据并没有明确的子父级关系，只能通过 parent_id 查找对应的省市。循环方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * [getProvince 获取省]
 * @param  {[Object]} regions [省市区数据]
 * @return {[Array]}          [省数组]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getProvince(regions) {

    $.each(regions, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.level === 1&lt;span&gt;) {
            province.push(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.region_name);
        }
    });

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; province;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * [getCity 获取市]
 * @param  {[Object]} regions      [省市区数据]
 * @param  {[String]} provinceName [省名]
 * @return {[Array]}               [市数组]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getCity(regions, provinceName) {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; province_id = 0&lt;span&gt;,
        cityArr &lt;/span&gt;=&lt;span&gt; [];

    $.each(regions, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.level === 1 &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.region_name ===&lt;span&gt; provinceName) {
            province_id &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.region_id;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    });
    $.each(regions, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.level === 2 &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.parent_id ===&lt;span&gt; province_id) {
            cityArr.push(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.region_name)
        }
    });

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cityArr;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * [getArea 获取区]
 * @param  {[Object]} regions      [省市区数据]
 * @param  {[String]} provinceName [省名]
 * @param  {[String]} cityName     [市名]
 * @return {[Array]}               [区数组]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getArea(regions, provinceName, cityName) {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; province_id = 0&lt;span&gt;,
        city_id &lt;/span&gt;= 0&lt;span&gt;,
        areaArr &lt;/span&gt;=&lt;span&gt; [];

    $.each(regions, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.level === 1 &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.region_name ===&lt;span&gt; provinceName) {
            province_id &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.region_id;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.level === 2 &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.region_name === cityName &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.parent_id ===&lt;span&gt; province_id) {
            city_id &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.region_id;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    });
    $.each(regions, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.level === 3 &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.parent_id ===&lt;span&gt; city_id) {
            areaArr.push(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.region_name)
        }
    });

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; areaArr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为数据量不大，我使用了 jQuery 原生的 $.each 循环，而在平时的工作中，我更倾向于使用 JS 原生的 for 循环。&lt;/p&gt;
&lt;h3&gt;2.有子父级关系的数组&lt;/h3&gt;
&lt;p&gt;在之前做项目的时候，非常希望能够将第一种省市区结构转化成比较常用的具有子父级关系的结构数组。但那时不会用 Nodejs，也没有其它比较好的生成文件的方法，所以就一直使用第一种循环思路。&lt;/p&gt;
&lt;p&gt;最终经过一阵折腾，成功用 Nodejs 实现了对原有数据结构的重新映射。&lt;/p&gt;
&lt;p&gt;现在我使用 Nodejs 读写文件的方式对省市区结构做了如下调整，因为本文的讨论重点是级联选择器以及数据结构，所以就不去讨论如何使用 Nodejs 生成文件了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4115d5eb-73af-40e9-82f6-7d544e264009')&quot; readability=&quot;52&quot;&gt;&lt;img id=&quot;code_img_closed_4115d5eb-73af-40e9-82f6-7d544e264009&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4115d5eb-73af-40e9-82f6-7d544e264009&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4115d5eb-73af-40e9-82f6-7d544e264009',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4115d5eb-73af-40e9-82f6-7d544e264009&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;99&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
  {
    &lt;/span&gt;&quot;provinceName&quot;: &quot;北京市&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;provinceId&quot;: 11&lt;span&gt;,
    &lt;/span&gt;&quot;cities&quot;&lt;span&gt;: [
      {
        &lt;/span&gt;&quot;cityName&quot;: &quot;北京市&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;cityId&quot;: 101&lt;span&gt;,
        &lt;/span&gt;&quot;areas&quot;&lt;span&gt;: [
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;东城区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1001&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;西城区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1002&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;崇文区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1003&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;宣武区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1004&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;朝阳区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1005&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;丰台区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1006&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;石景山区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1007&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;海淀区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1008&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;门头沟区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1009&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;房山区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1010&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;通州区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1011&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;顺义区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1012&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;昌平区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1013&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;大兴区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1014&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;怀柔区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1015&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;平谷区&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1016&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;密云县&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1017&lt;span&gt;
          },
          {
            &lt;/span&gt;&quot;areaName&quot;: &quot;延庆县&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;areaId&quot;: 1018&lt;span&gt;
          }
        ]
      }
    ]
  }
  ...
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 循环方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * [getProvince 获取省]
 * @param  {[Object]} regions [省市区数据]
 * @return {[Array]}          [省数组]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getProvince(&lt;span&gt;regions&lt;/span&gt;) {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provinceArr =&lt;span&gt; [];

    $.each(regions, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        provinceArr.push(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.provinceName);
    });

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; provinceArr;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * [getCity 获取市]
 * @param  {[Object]} regions      [省市区数据]
 * @param  {[String]} provinceName [省名]
 * @return {[Array]}               [市数组]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getCity(&lt;span&gt;regions&lt;/span&gt;, provinceName) {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cityArr =&lt;span&gt; [];

    $.each(regions, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i, province) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (province.provinceName ===&lt;span&gt; provinceName) {
            $.each(province.cities, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(j, city) {
                cityArr.push(city.cityName);
            });
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    });

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cityArr;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * [getArea 获取区]
 * @param  {[Object]} regions      [省市区数据]
 * @param  {[String]} provinceName [省名]
 * @param  {[String]} cityName     [市名]
 * @return {[Array]}               [区数组]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getArea(&lt;span&gt;regions&lt;/span&gt;, provinceName, cityName) {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; areaArr =&lt;span&gt; [];

    $.each(regions, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i, province) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (province.provinceName ===&lt;span&gt; provinceName) {
            $.each(province.cities, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(j, city) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (city.cityName ===&lt;span&gt; cityName) {
                    $.each(city.areas, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(k, area) {
                        areaArr.push(area.areaName);
                    });
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
            });
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    });

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; areaArr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过简单测试，这种数据结构确实优于第一种，但是两者循环时间的差距也仅在毫秒之间，所以实际感受并不深刻。&lt;/p&gt;
&lt;h3&gt;3.有子父级关系的对象&lt;/h3&gt;
&lt;p&gt;第二种数据结构是省市区数据常用的数据类型，但是选择省市对应的 ID 不是很方便，需要再循环一次。&lt;/p&gt;
&lt;p&gt;最后尝试将省市区名称作为键值的对象类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('aa1f5907-ddfd-42c6-8859-2430a7ff4f20')&quot; readability=&quot;42&quot;&gt;&lt;img id=&quot;code_img_closed_aa1f5907-ddfd-42c6-8859-2430a7ff4f20&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_aa1f5907-ddfd-42c6-8859-2430a7ff4f20&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('aa1f5907-ddfd-42c6-8859-2430a7ff4f20',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aa1f5907-ddfd-42c6-8859-2430a7ff4f20&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;北京市&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;id&quot;: 11&lt;span&gt;,
    &lt;/span&gt;&quot;cities&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;北京市&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;id&quot;: 101&lt;span&gt;,
        &lt;/span&gt;&quot;areas&quot;&lt;span&gt;: {
          &lt;/span&gt;&quot;东城区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1001&lt;span&gt;
          },
          &lt;/span&gt;&quot;西城区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1002&lt;span&gt;
          },
          &lt;/span&gt;&quot;崇文区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1003&lt;span&gt;
          },
          &lt;/span&gt;&quot;宣武区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1004&lt;span&gt;
          },
          &lt;/span&gt;&quot;朝阳区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1005&lt;span&gt;
          },
          &lt;/span&gt;&quot;丰台区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1006&lt;span&gt;
          },
          &lt;/span&gt;&quot;石景山区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1007&lt;span&gt;
          },
          &lt;/span&gt;&quot;海淀区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1008&lt;span&gt;
          },
          &lt;/span&gt;&quot;门头沟区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1009&lt;span&gt;
          },
          &lt;/span&gt;&quot;房山区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1010&lt;span&gt;
          },
          &lt;/span&gt;&quot;通州区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1011&lt;span&gt;
          },
          &lt;/span&gt;&quot;顺义区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1012&lt;span&gt;
          },
          &lt;/span&gt;&quot;昌平区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1013&lt;span&gt;
          },
          &lt;/span&gt;&quot;大兴区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1014&lt;span&gt;
          },
          &lt;/span&gt;&quot;怀柔区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1015&lt;span&gt;
          },
          &lt;/span&gt;&quot;平谷区&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1016&lt;span&gt;
          },
          &lt;/span&gt;&quot;密云县&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1017&lt;span&gt;
          },
          &lt;/span&gt;&quot;延庆县&quot;&lt;span&gt;: {
            &lt;/span&gt;&quot;id&quot;: 1018&lt;span&gt;
          }
        }
      }
    }
  }
  ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 这样的变化使循环变得简单了，只用一层循环就可以：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * [getProvince 获取省]
 * @param  {[Object]} regions [省市区数据]
 * @return {[Array]}          [省数组]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getProvince(regions) {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provinceArr =&lt;span&gt; [];

    $.each(regions, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(province) {
        provinceArr.push(province);
    });

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; provinceArr;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * [getCity 获取市]
 * @param  {[Object]} regions      [省市区数据]
 * @param  {[String]} provinceName [省名]
 * @return {[Array]}               [市数组]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getCity(regions, provinceName) {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cityArr =&lt;span&gt; [];

    $.each(regions[provinceName][&lt;/span&gt;'cities'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(city) {
        cityArr.push(city);
    });

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cityArr;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * [getArea 获取区]
 * @param  {[Object]} regions      [省市区数据]
 * @param  {[String]} provinceName [省名]
 * @param  {[String]} cityName     [市名]
 * @return {[Array]}               [区数组]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getArea(regions, provinceName, cityName) {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; areaArr =&lt;span&gt; [];

    $.each(regions[provinceName][&lt;/span&gt;'cities'][cityName]['areas'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(area) {
        areaArr.push(area);
    });

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; areaArr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种数据结构和第二种差不多，但是循环对象只能用 for in 形式，而 for in 是最不稳定的循环方式，所以这种数据结构会不会存在潜在的危险？虽然目前的数据量并不需要担心，但作为程序员，还是应该时刻把效率和性能放在第一位。&lt;/p&gt;
&lt;p&gt;下图显示了三种文件的大小，都是未压缩的 JSON 格式。很显然，第三种数据结构最轻量，而第一种数据因为有多余的键值，所以尺寸非常庞大。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/999445/201710/999445-20171031183242996-1723717952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;结论与思考&lt;/h2&gt;
&lt;p&gt;第二种数据结构和第三种数据结构差别不大，但是第三种数据结构可以更简单的获取省市 ID 。也许其中还有很多我所不知道的细枝末节，但我能力有限，无法深入展开讨论，只能从表面探索其中的异同。&lt;/p&gt;
&lt;p&gt;整体而言，三种数据结构都有循环，所以第一级联动时或多或少会有性能的损耗。我突然在想有没有第四种数据结构，在对应的 key 值上有现成的数组，这样就不必再去循环了，答案也许是肯定的。&lt;/p&gt;
&lt;p&gt;以下是省市区选择器的完整配置，联动效果需要使用上面提到的循环方法。所有的演示文件以及省市区 JSON 文件都上传到了 &lt;a href=&quot;https://github.com/nzbin/Framework7-CityPicker&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt; 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7bdeaa70-a725-4b59-aea8-c5210c621ddc')&quot; readability=&quot;47&quot;&gt;&lt;img id=&quot;code_img_closed_7bdeaa70-a725-4b59-aea8-c5210c621ddc&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7bdeaa70-a725-4b59-aea8-c5210c621ddc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7bdeaa70-a725-4b59-aea8-c5210c621ddc',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7bdeaa70-a725-4b59-aea8-c5210c621ddc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;89&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化 Framework7&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; myApp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Framework7();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化省市区&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; province =&lt;span&gt; getProvince(regions),
    city &lt;/span&gt;= getCity(regions, '北京市'&lt;span&gt;),
    area &lt;/span&gt;= getArea(regions, '北京市', '北京市'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存 picker 选择的省&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; provinceSelect = ''&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省市区联动 / Framework7 picker&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pickerLocation =&lt;span&gt; myApp.picker({
    input: &lt;/span&gt;'#location'&lt;span&gt;,
    rotateEffect: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    toolbarTemplate: &lt;/span&gt;'&lt;span&gt;&amp;lt;div class=&quot;toolbar&quot;&amp;gt;\
                        &amp;lt;div class=&quot;toolbar-inner&quot;&amp;gt;\
                            &amp;lt;div class=&quot;left&quot;&amp;gt;\
                                &amp;lt;a href=&quot;#&quot; class=&quot;link close-picker&quot;&amp;gt;取消&amp;lt;/a&amp;gt;\
                            &amp;lt;/div&amp;gt;\
                            &amp;lt;div class=&quot;right&quot;&amp;gt;\
                                &amp;lt;a href=&quot;#&quot; class=&quot;link close-picker&quot;&amp;gt;完成&amp;lt;/a&amp;gt;\
                            &amp;lt;/div&amp;gt;\
                        &amp;lt;/div&amp;gt;\
                    &amp;lt;/div&amp;gt;&lt;/span&gt;'&lt;span&gt;,
    cols: [{
            cssClass: &lt;/span&gt;'f-s-14'&lt;span&gt;,
            width: &lt;/span&gt;'33.33%'&lt;span&gt;,
            textAlign: &lt;/span&gt;'left'&lt;span&gt;,
            values: province,
            onChange: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(picker, province) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (picker.cols[1&lt;span&gt;].replaceValues) {
                    provinceSelect &lt;/span&gt;=&lt;span&gt; province;
                    city &lt;/span&gt;=&lt;span&gt; getCity(regions, province);
                    area &lt;/span&gt;= getArea(regions, province, city[0&lt;span&gt;]);
                    picker.cols[&lt;/span&gt;1&lt;span&gt;].replaceValues(city);
                    picker.cols[&lt;/span&gt;2&lt;span&gt;].replaceValues(area);
                }
            }
        },
        {
            cssClass: &lt;/span&gt;'f-s-14'&lt;span&gt;,
            width: &lt;/span&gt;'33.33%'&lt;span&gt;,
            textAlign: &lt;/span&gt;'center'&lt;span&gt;,
            values: city,
            onChange: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(picker, city) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (picker.cols[2&lt;span&gt;].replaceValues) {
                    area &lt;/span&gt;=&lt;span&gt; getArea(regions, provinceSelect, city);
                    picker.cols[&lt;/span&gt;2&lt;span&gt;].replaceValues(area);
                }
            }
        },
        {
            cssClass: &lt;/span&gt;'f-s-14'&lt;span&gt;,
            width: &lt;/span&gt;'33.33%'&lt;span&gt;,
            textAlign: &lt;/span&gt;'right'&lt;span&gt;,
            values: area,
        }
    ]
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;很遗憾，CityPicker 并不是一个插件，只是对 Framework7 Picker 组件的具体应用。如果有需要的话，我也会考虑把它封装成一个插件。&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 15:59:00 +0000</pubDate>
<dc:creator>nzbin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nzbin/p/7754447.html</dc:identifier>
</item>
<item>
<title>绝对路径和相对路径 - lonelyshy</title>
<link>http://www.cnblogs.com/lonelyshy/p/7764527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lonelyshy/p/7764527.html</guid>
<description>&lt;p&gt;&lt;strong&gt;比如有3个路径 D:\www\h0\ha.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;D:\www\h0\hb.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;D:\www\h1\hc.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在D盘的www目录下的h0子目录下的有一个ha.html和hb.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;h1子目录下有一个hc.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果ha.html想要链接到hb怎么办呢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以用相对路径 因为ha.html和hb.html是在一个子目录下所以ha.html可以这样调用简单一些&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;a href=&quot;hb.html&quot; &amp;gt;&amp;lt;/a&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就可以直接调用hb.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是如果不是在一个路径的hc.html 想要调用hb.html怎么办呢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这时 我们就要使用绝对路径了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;绝对路径有两种方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种是从文档根目录开始的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;a href=&quot;D:\www\h0\hb.html&quot; &amp;gt;&amp;lt;/a&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有一种方法是&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;a href=&quot;../h0/hb.html&quot;&amp;gt;&amp;lt;/a&amp;gt; &quot;../&quot;代表的是上一级目录 比如hc.html所在子目录为h1文件夹 在上一级就是WWW目录了 所以../代表的就是www目录，&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;上传服务器时 服务器的域名就是文档的根目录&lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 31 Oct 2017 15:59:00 +0000</pubDate>
<dc:creator>lonelyshy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lonelyshy/p/7764527.html</dc:identifier>
</item>
<item>
<title>使用sklearn进行数据挖掘-房价预测(4)—数据预处理 - Wanna_Go</title>
<link>http://www.cnblogs.com/wxshi/p/7764518.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxshi/p/7764518.html</guid>
<description>&lt;p&gt;在使用机器算法之前，我们先把数据做下预处理，先把特征和标签拆分出来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;housing = strat_train_set.drop(&quot;median_house_value&quot;,axis=1) #原始数据集并未发生改变
housing_labels=strat_train_set[&quot;median_house_value&quot;].copy()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据清洗&quot;&gt;数据清洗&lt;/h3&gt;
&lt;p&gt;大多数机器学习算法是不能在有缺失值的数据集上面运行的，而本数据集特征&lt;code&gt;total_bedrooms&lt;/code&gt;是存在数据缺失现象的，所以就需要想办法处理，有以下几个思路：&lt;/p&gt;
&lt;ul readability=&quot;75.5&quot;&gt;&lt;li&gt;1.将存在缺失数据的样本去除掉&lt;/li&gt;
&lt;li&gt;2.将存在缺失数据的特征去除掉&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;3.将缺失值用统一的值替换，如：均值、中值等&lt;br/&gt;上面对应的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;housing.dropna(subset=[&quot;total_bedrooms&quot;]) # 1.删除样本
housing.drop(&quot;total_bedrooms&quot;, axis=1) # 2.删除特征，注意参数的用法和1不一样
median = housing[&quot;total_bedrooms&quot;].median()
housing[&quot;total_bedrooms&quot;].fillna(median) # 3. 中值填充&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;去过采用的是方法3那么就需要将替换的值保存起来，在后续的工作中需要将它应用到测试集，以及可能添加的新数据。上面这个操作是使用pandas，sklearn提供了&lt;code&gt;Imputer&lt;/code&gt;,同样能够很好解决缺失值问题，下面其用法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.preprocessing import Imputer
imputer = Imputer(strategy=&quot;median&quot;)
housing_num = housing.drop(&quot;ocean_proximity&quot;, axis=1) #去除非数值类特征
imputer.fit(housing_num)&lt;/code&gt;
&lt;/pre&gt;
imputer提供了以下几种填充策略&lt;/li&gt;
&lt;li&gt;If &quot;mean&quot;, then replace missing values using the mean along the axis.&lt;/li&gt;
&lt;li&gt;If &quot;median&quot;, then replace missing values using the median along the axis.&lt;/li&gt;
&lt;li readability=&quot;138&quot;&gt;
&lt;p&gt;If &quot;most_frequent&quot;, then replace missing using the most frequent value along the axis.&lt;br/&gt;通过&lt;code&gt;statistics_&lt;/code&gt; 查看填充的数值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;imputer.statistics_
array([-118.51      ,   34.26      ,   29.        , ...,    5.23228423,
      0.20303137,    2.8176527 ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看一看pandas计算出来的中值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;housing_num.median().values
array([-118.51      ,   34.26      ,   29.        , ...,    5.23228423,
      0.20303137,    2.8176527 ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就需要将计算得到的数值应用到数据集中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;X = imputer.transform(housing_num) 
&amp;gt;&amp;gt;type(X)
numpy.ndarray&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终得到的是结果是array类型，如果想转为pandas类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;housing_tr = pd.DataFrame(X, columns=housing_num.columns)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们把&lt;code&gt;ocean_proximity&lt;/code&gt;这一特征去掉，所以这些操作是处理数值类型的特征，那么非数值类型的该如何处理呢？&lt;/p&gt;
&lt;h3 id=&quot;处理文本和类别特征&quot;&gt;处理文本和类别特征&lt;/h3&gt;
&lt;p&gt;决策树、贝叶斯等分类器能够处理标签类特征，但很多算法是不能处理这类特征，需要转换为数值类型，sklearn提供了&lt;code&gt;LabelEncoder&lt;/code&gt;特征转换方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.preprocessing import LabelEncoder
encoder = LabelEncoder()
housing_cat = housing[&quot;ocean_proximity&quot;]
housing_cat_encoded = encoder.fit_transform(housing_cat)
&amp;gt;&amp;gt;housing_cat_encoded 
 array([0, 0, 4, ..., 1, 0, 3], dtype=int64)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是输出编码的结果，那么对应的0、1...是指的什么呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;encoder.clases_
array(['&amp;lt;1H OCEAN', 'INLAND', 'ISLAND', 'NEAR BAY', 'NEAR OCEAN'], dtype=object)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过类别号可以表示类别，还有一种方法能够表示类别---&lt;code&gt;one hot&lt;/code&gt;,该特征取的值位置为1，其余为0；当然sklearn也提供了实现方法&lt;code&gt;OneHotEncoder&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.preprocessing import OneHotEncoder
encoder = OneHotEncoder()
housing_cat_1hot = encoder.fit_transform(housing_cat_encoded.reshape(-1,1))#返回的为稀疏矩阵
&amp;gt;&amp;gt;housing_cat_1hot.toarray()
array([[ 1.,  0.,  0.,  0.,  0.],
   [ 1.,  0.,  0.,  0.,  0.],
   [ 0.,  0.,  0.,  0.,  1.],
   ..., 
   [ 0.,  1.,  0.,  0.,  0.],
   [ 1.,  0.,  0.,  0.,  0.],
   [ 0.,  0.,  0.,  1.,  0.]])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt;&lt;code&gt;housing_cat_encoded&lt;/code&gt;返回的为1D 数组，fit_transform需要传入的为一个2D数组，需要先转为列向量。&lt;br/&gt;可以将上面&lt;code&gt;encoder&lt;/code&gt;和&lt;code&gt;one hot&lt;/code&gt;过程合并为一个&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.preprocessing import LabelBinarizer
encoder = LabelBinarizer()
housing_cat_1hot=encoder.fit_transform(housing_cat)
&amp;gt;&amp;gt;housing_cat_1hot #numpy array
array([[1, 0, 0, 0, 0],
   [1, 0, 0, 0, 0],
   [0, 0, 0, 0, 1],
   ..., 
   [0, 1, 0, 0, 0],
   [1, 0, 0, 0, 0],
   [0, 0, 0, 1, 0]])&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义处理方法&quot;&gt;自定义处理方法&lt;/h3&gt;
&lt;p&gt;尽管sklearn提供了强大的数据处理功能，有些时候我们需要根据自己的需求自定义一些数据预处理方法，并且让我们这些操作有着sklearnAPI相似的用法，我们所需要做的就是继承&lt;code&gt;BaseEstimator&lt;/code&gt;类，并覆写三个方法&lt;code&gt;fit&lt;/code&gt;，&lt;code&gt;transform&lt;/code&gt;和&lt;code&gt;fit_transform&lt;/code&gt;，第三个方法是前两个的整合，如果不想覆写&lt;code&gt;fit_transform&lt;/code&gt;,可以继承&lt;code&gt;TransformerMixin&lt;/code&gt;(从类名称就可以看出其作用)这个类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;from sklearn.base import BaseEstimator, TransformerMixin
rooms_ix, bedrooms_ix, population_ix, household_ix = 3, 4, 5, 6
class CombinedAttributesAdder(BaseEstimator, TransformerMixin):
    def __init__(self, add_bedrooms_per_room = True): # no *args or **kargs
                self.add_bedrooms_per_room = add_bedrooms_per_room
    def fit(self, X, y=None):
        return self # nothing else to do
    def transform(self, X, y=None):
        rooms_per_household = X[:, rooms_ix] / X[:, household_ix]
        population_per_household = X[:, population_ix] / X[:, household_ix]
        if self.add_bedrooms_per_room:
            bedrooms_per_room = X[:, bedrooms_ix] / X[:, rooms_ix]
            return np.c_[X, rooms_per_household, population_per_household,bedrooms_per_room]
        else:
            return np.c_[X, rooms_per_household, population_per_household]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;attr_adder = CombinedAttributesAdder(add_bedrooms_per_room=False)
housing_extra_attribs = attr_adder.transform(housing.values) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面定义的类的功能是为原数据集添加新的特征，&lt;code&gt;X[:,3]&lt;/code&gt;表示的是第4列所有数据，&lt;code&gt;np.c_&lt;/code&gt;表示的是拼接数组。&lt;br/&gt;&lt;strong&gt;另外&lt;/strong&gt;sklearn是不能直接处理&lt;code&gt;DataFrames&lt;/code&gt;的，那么我们需要自定义一个处理的方法将之转化为numpy类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class DataFrameSelector(BaseEstimator,TransformerMixin):
    def __init__(self,attribute_names): #可以为列表
        self.attribute_names = attribute_names
    def fit(self,X,y=None):
        return self
    def transform(self,X):
        return X[self.attribute_names].values #返回的为numpy array&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;特征缩放&quot;&gt;特征缩放&lt;/h3&gt;
&lt;p&gt;机器学习算法在缩放尺度不一样的数据效果比较差，比就如房价数据集&lt;code&gt;total_bedrooms&lt;/code&gt;的取值范围为1~6445，而&lt;code&gt;median_income&lt;/code&gt;的范围是0.5~15，所以需要对特征进行缩放。&lt;br/&gt;&lt;strong&gt;note:&lt;/strong&gt;通常情况下Target特征不需缩放&lt;br/&gt;有两种缩放数据的方法&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;min-max方式,对应的方法为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MinMaxScaler(self, feature_range=(0, 1), copy=True)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;standardization 标准化数据,对应的方法为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;StandardScaler(self, copy=True, with_mean=True, with_std=True)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;特征处理流程&quot;&gt;特征处理流程&lt;/h3&gt;
&lt;p&gt;目前在数据预处理阶段，我们需要对缺失值进行处理、特征组合和特征缩放。每一步的执行都有着先后顺序，sklearn提供了&lt;code&gt;Pipeline&lt;/code&gt;帮助顺序完成转换。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;num_attribs = list(housing_num)#返回的为列名[col1,col2,....]
cat_attribs = [&quot;ocean_proximity&quot;]

num_pipeline = Pipeline([ #数值类型
        ('selector', DataFrameSelector(num_attribs)),
        ('imputer', Imputer(strategy=&quot;median&quot;)),
        ('attribs_adder', CombinedAttributesAdder()),
        ('std_scaler', StandardScaler()),
    ])

cat_pipeline = Pipeline([ #标签类型
        ('selector', DataFrameSelector(cat_attribs)),
        ('cat_encoder', CategoricalEncoder(encoding=&quot;onehot-dense&quot;)),
    ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面定义的为分别处理数值类型和标签类型的转换流程，&lt;code&gt;housing_num&lt;/code&gt;为&lt;code&gt;DataFrame&lt;/code&gt;类型，&lt;code&gt;list(DataFrame)&lt;/code&gt;的结果会是什么？返回的为列名字，不管你们信不信，反正我是信了。pandas真是太强大了。上面着两个流程还可以再整合一起&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.pipeline import FeatureUnion
full_pipeline = FeatureUnion(transformer_list=[
        (&quot;num_pipeline&quot;, num_pipeline),
        (&quot;cat_pipeline&quot;, cat_pipeline),
    ])
housing_prepared = full_pipeline.fit_transform(housing)#最终的结果&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;今天就到这里把，工作了一天好困、眼疼，先发出去，明天再看看有没有什么错误。&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 15:55:00 +0000</pubDate>
<dc:creator>Wanna_Go</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wxshi/p/7764518.html</dc:identifier>
</item>
<item>
<title>Web性能测试工具之ab入门篇 - lovesoo</title>
<link>http://www.cnblogs.com/lovesoo/p/7762796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovesoo/p/7762796.html</guid>
<description>&lt;p&gt;ab全称Apache Bench，是apache附带的一个小工具，它可以同时模拟多个并发请求，测试apache等Web服务器的最大负载压力。&lt;/p&gt;
&lt;p&gt;本文通过一个简单的示例，介绍了使用ab进行web页面性能测试、查看结果方法及运行参数详解。&lt;/p&gt;
&lt;p&gt;运行环境为Windows 10系统。&lt;/p&gt;


&lt;h2&gt;2.1 Windows系统&lt;/h2&gt;

&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201710/445074-20171031232944185-233482869.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;h2&gt;2.2 linux系统&lt;/h2&gt;
&lt;p&gt;使用如下命令安装Apache&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; httpd
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;使用cmd/shell进入到Apache24\bin目录下，运行ab即可&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/yws/public/resource/6198d73bf23289361757538ca7f02a97/xmlnote/121C298EE35744C8AF79B53360FB5018/11331&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;http://note.youdao.com/yws/public/resource/6198d73bf23289361757538ca7f02a97/xmlnote/121C298EE35744C8AF79B53360FB5018/11331&quot;/&gt;&lt;/div&gt;



&lt;p&gt;最常用两种运行命令如下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ab -n &lt;span&gt;10&lt;/span&gt; -c &lt;span&gt;10&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com&lt;/span&gt;
# -n 总共10次请求，-&lt;span&gt;c 模拟10个并发用户，即10个并发请求博客园首页，共请求10次
 
ab &lt;/span&gt;-t &lt;span&gt;10&lt;/span&gt; -c &lt;span&gt;10&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com&lt;/span&gt;
# -t 是测试执行时间，-c 模拟10个并发用户，即10个并发请求博客园首页，持续10秒
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/445074/201711/445074-20171101000852279-64223399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Server Software:
Server Hostname:        www.cnblogs.com
Server Port:            &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;

Document Path:          &lt;/span&gt;/&lt;span&gt;
Document Length:        &lt;/span&gt;&lt;span&gt;147&lt;/span&gt;&lt;span&gt; bytes    #HTTP响应数据的正文长度

Concurrency Level:      &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;    #并发数
Time taken &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; tests:   &lt;span&gt;10.183&lt;/span&gt;&lt;span&gt; seconds    #测试执行时间
Complete requests:      &lt;/span&gt;&lt;span&gt;169&lt;/span&gt;&lt;span&gt;    #完成请求数
Failed requests:        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;    #失败请求数
Non&lt;/span&gt;-2xx responses:      &lt;span&gt;169&lt;/span&gt;&lt;span&gt;
Total transferred:      &lt;/span&gt;&lt;span&gt;65403&lt;/span&gt;&lt;span&gt; bytes    #网络总传输量
HTML transferred:       &lt;/span&gt;&lt;span&gt;24843&lt;/span&gt;&lt;span&gt; bytes    #HTML内容传输量
Requests per second:    &lt;/span&gt;&lt;span&gt;16.60&lt;/span&gt; [#/&lt;span&gt;sec] (mean)    #每秒请求数
Time per request:       &lt;/span&gt;&lt;span&gt;602.545&lt;/span&gt; [ms] (mean)    #用户平均请求等待时间，计算公式：测试执行总时间/（总请求数/&lt;span&gt;并发用户数）
Time per request:       &lt;/span&gt;&lt;span&gt;60.254&lt;/span&gt; [ms] (mean, across all concurrent requests)    #服务器平均请求等待时间，计算公式：测试执行总时间/&lt;span&gt;总请求数
Transfer rate:          &lt;/span&gt;&lt;span&gt;6.27&lt;/span&gt; [Kbytes/&lt;span&gt;sec] received    #平均传输速率

Connection Times (ms)    #响应时间小、中、大值
              min  mean[&lt;/span&gt;+/-&lt;span&gt;sd] median   max
Connect:        &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;40&lt;/span&gt; &lt;span&gt;325.5&lt;/span&gt;      &lt;span&gt;3&lt;/span&gt;    &lt;span&gt;3006&lt;/span&gt;&lt;span&gt;
Processing:    &lt;/span&gt;&lt;span&gt;41&lt;/span&gt;  &lt;span&gt;382&lt;/span&gt; &lt;span&gt;928.1&lt;/span&gt;     &lt;span&gt;63&lt;/span&gt;    &lt;span&gt;3072&lt;/span&gt;&lt;span&gt;
Waiting:       &lt;/span&gt;&lt;span&gt;41&lt;/span&gt;  &lt;span&gt;376&lt;/span&gt; &lt;span&gt;922.1&lt;/span&gt;     &lt;span&gt;58&lt;/span&gt;    &lt;span&gt;3063&lt;/span&gt;&lt;span&gt;
Total:         &lt;/span&gt;&lt;span&gt;43&lt;/span&gt;  &lt;span&gt;422&lt;/span&gt; &lt;span&gt;971.5&lt;/span&gt;     &lt;span&gt;68&lt;/span&gt;    &lt;span&gt;3075&lt;/span&gt;&lt;span&gt;

Percentage of the requests served within a certain &lt;/span&gt;&lt;span&gt;time&lt;/span&gt; (ms)    #一定时间内请求完成的百分比，如50%用户完成的响应时间在68ms内, &lt;span&gt;66&lt;/span&gt;%用户完成的响应时间在73ms内，&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;用户在3075ms内完成
  &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;%     &lt;span&gt;68&lt;/span&gt;
  &lt;span&gt;66&lt;/span&gt;%     &lt;span&gt;73&lt;/span&gt;
  &lt;span&gt;75&lt;/span&gt;%     &lt;span&gt;81&lt;/span&gt;
  &lt;span&gt;80&lt;/span&gt;%     &lt;span&gt;85&lt;/span&gt;
  &lt;span&gt;90&lt;/span&gt;%   &lt;span&gt;3060&lt;/span&gt;
  &lt;span&gt;95&lt;/span&gt;%   &lt;span&gt;3066&lt;/span&gt;
  &lt;span&gt;98&lt;/span&gt;%   &lt;span&gt;3069&lt;/span&gt;
  &lt;span&gt;99&lt;/span&gt;%   &lt;span&gt;3075&lt;/span&gt;
 &lt;span&gt;100&lt;/span&gt;%   &lt;span&gt;3075&lt;/span&gt; (longest request)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;官方帮助文档如下：&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Usage: ab [options] [http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;]hostname[:port]/path&lt;/span&gt;
&lt;span&gt;Options are:
&lt;/span&gt;-&lt;span&gt;n requests Number of requests to perform
&lt;/span&gt;-c concurrency Number of multiple requests to &lt;span&gt;make&lt;/span&gt; at a &lt;span&gt;time&lt;/span&gt;
-&lt;span&gt;t timelimit Seconds to max. to spend on benchmarking
This implies &lt;/span&gt;-n &lt;span&gt;50000&lt;/span&gt;
-s timeout Seconds to max. &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; each response
Default is &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt; seconds
&lt;/span&gt;-b windowsize Size of TCP send/receive buffer, &lt;span&gt;in&lt;/span&gt;&lt;span&gt; bytes
&lt;/span&gt;-&lt;span&gt;B address Address to bind to when making outgoing connections
&lt;/span&gt;-p postfile File containing data to POST. Remember also to set -&lt;span&gt;T
&lt;/span&gt;-u putfile File containing data to PUT. Remember also to set -&lt;span&gt;T
&lt;/span&gt;-T content-type Content-type header to use &lt;span&gt;for&lt;/span&gt; POST/&lt;span&gt;PUT data, eg.
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Default is &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/plain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
-v verbosity How much troubleshooting &lt;span&gt;info&lt;/span&gt;&lt;span&gt; to print
&lt;/span&gt;-&lt;span&gt;w&lt;/span&gt; Print out results &lt;span&gt;in&lt;/span&gt;&lt;span&gt; HTML tables
&lt;/span&gt;-&lt;span&gt;i Use HEAD instead of GET
&lt;/span&gt;-&lt;span&gt;x attributes String to insert as table attributes
&lt;/span&gt;-y attributes String to insert as &lt;span&gt;tr&lt;/span&gt;&lt;span&gt; attributes
&lt;/span&gt;-&lt;span&gt;z attributes String to insert as td or th attributes
&lt;/span&gt;-C attribute Add cookie, eg. &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Apache=1234&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;. (repeatable)
&lt;/span&gt;-H attribute Add Arbitrary header line, eg. &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accept-Encoding: gzip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Inserted after all normal header lines. (repeatable)
&lt;/span&gt;-&lt;span&gt;A attribute Add Basic WWW Authentication, the attributes
are a colon separated username and password.
&lt;/span&gt;-&lt;span&gt;P attribute Add Basic Proxy Authentication, the attributes
are a colon separated username and password.
&lt;/span&gt;-&lt;span&gt;X proxy:port Proxyserver and port number to use
&lt;/span&gt;-&lt;span&gt;V Print version number and exit
&lt;/span&gt;-&lt;span&gt;k Use HTTP KeepAlive feature
&lt;/span&gt;-&lt;span&gt;d Do not show percentiles served table.
&lt;/span&gt;-&lt;span&gt;S Do not show confidence estimators and warnings.
&lt;/span&gt;-q Do not show progress when doing &lt;span&gt;more&lt;/span&gt; than &lt;span&gt;150&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;-l Accept variable document length (use this &lt;span&gt;for&lt;/span&gt;&lt;span&gt; dynamic pages)
&lt;/span&gt;-g filename Output collected data to gnuplot format &lt;span&gt;file&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;-e filename Output CSV &lt;span&gt;file&lt;/span&gt;&lt;span&gt; with percentages served
&lt;/span&gt;-r Don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t exit on socket receive errors.&lt;/span&gt;
-&lt;span&gt;m method Method name
&lt;/span&gt;-h Display usage information (this message)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;中文翻译如下：&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
-n 即requests，用于指定压力测试/&lt;span&gt;总请求数。
&lt;/span&gt;-&lt;span&gt;c 即concurrency，用于指定压力测试的并发数。
&lt;/span&gt;-&lt;span&gt;t 即timelimit，测试执行最大秒数，它可以让测试限制在一个固定的总时间以内，默认值为50000。
&lt;/span&gt;-&lt;span&gt;s 即timeout，请求最大等待时长，默认30s
&lt;/span&gt;-b 即windowsize，TCP发送/&lt;span&gt;接收的缓冲大小(单位：字节)。
&lt;/span&gt;-p 即postfile，发送POST请求时需要上传的文件，文件格式如&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1=1&amp;amp;p2=2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;。使用方法是 -p &lt;span&gt;123&lt;/span&gt;.txt 。 （配合-&lt;span&gt;T）
&lt;/span&gt;-u 即putfile，发送PUT请求时需要上传的文件。（配合-&lt;span&gt;T）
&lt;/span&gt;-T 即content-type，用于设置Content-Type请求头信息，如 -T &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded”，默认值为text/plain。（配合-p）&lt;/span&gt;
-v 即verbosity，设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(&lt;span&gt;404&lt;/span&gt;&lt;span&gt;, 200等), 2或更大值可以显示警告和其他信息。
&lt;/span&gt;-&lt;span&gt;w&lt;/span&gt;&lt;span&gt; 以HTML表格形式打印结果。
&lt;/span&gt;-&lt;span&gt;i 使用HEAD请求代替GET请求。
&lt;/span&gt;-&lt;span&gt;x 插入字符串作为table标签的属性。
&lt;/span&gt;-&lt;span&gt;y 插入字符串作为tr标签的属性。
&lt;/span&gt;-&lt;span&gt;z 插入字符串作为td标签的属性。
&lt;/span&gt;-C 添加cookie信息，例如：&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Apache=1234&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;。此参数可以重复，用逗号分割。提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如&lt;/span&gt;-C &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;。
&lt;/span&gt;-H 添加任意的请求头，例如：&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Accept-Encoding: gzip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，请求头将会添加在现有的多个请求头之后(可以重复该参数选项以添加多个)。
&lt;/span&gt;-&lt;span&gt;A 添加一个基本的网络认证信息，用户名和密码之间用英文冒号隔开。
&lt;/span&gt;-P 添加一个基本的代理认证信息，用户名和密码之间用英文冒号隔开。如-P proxy-auth-&lt;span&gt;username:password
&lt;/span&gt;-X 指定使用的代理服务器和端口号，例如:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;126.10.10.3:88&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;。
&lt;/span&gt;-&lt;span&gt;V 显示版本号并退出。
&lt;/span&gt;-&lt;span&gt;k 使用HTTP的KeepAlive特性。
&lt;/span&gt;-&lt;span&gt;d 不显示百分比。
&lt;/span&gt;-&lt;span&gt;S 不显示预估和警告信息。
&lt;/span&gt;-&lt;span&gt;q 超过150个请求后不显示进度
&lt;/span&gt;-&lt;span&gt;l 接受可变文档长度（用于动态页面）
&lt;/span&gt;-&lt;span&gt;g filename 输出结果信息到gnuplot格式的文件中。
&lt;/span&gt;-&lt;span&gt;e filename 输出结果信息到CSV格式的文件中。
&lt;/span&gt;-&lt;span&gt;r 指定接收到错误信息时不退出程序。
&lt;/span&gt;-&lt;span&gt;m method 方法名
&lt;/span&gt;-h 帮助
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 31 Oct 2017 15:43:00 +0000</pubDate>
<dc:creator>lovesoo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovesoo/p/7762796.html</dc:identifier>
</item>
<item>
<title>脱壳第三讲,UPX压缩壳,以及补充壳知识 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7764483.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7764483.html</guid>
<description>&lt;h2&gt;一丶什么是压缩壳.以及壳的原理&lt;/h2&gt;
&lt;p&gt;在理解什么是压缩壳的时候,我们先了解一下什么是壳&lt;/p&gt;
&lt;h3&gt;1.什么是壳&lt;/h3&gt;
&lt;p&gt;　　壳可以简单理解为就是在自己的PE文件中包含了代码.而有不影响我们的PE文件的执行.&lt;/p&gt;
&lt;h3&gt;2.什么是压缩壳&lt;/h3&gt;
&lt;p&gt;　　压缩壳指的是让我们的PE文件变小.&lt;/p&gt;
&lt;h3&gt;3.压缩壳原理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031225316591-1696939120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先可以看到,我们的PE文件&lt;/p&gt;
&lt;p&gt;一个PE头,两个节数据,其中节和节之间还有对齐值.而上图是我们的一个正常壳映射到内存中的示意图.&lt;/p&gt;
&lt;h3&gt;4.压缩壳的思路&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031225626748-1437822251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出, 我们的PE文件,压缩一下变成了一个新的PE文件,其中我们的PE文件,压缩的数据是节里面的数据&lt;/p&gt;
&lt;p&gt;也就是说,压缩壳的原理就是压缩PE文件中节的数据.然后产生新的PE,这个新的PE我们成为带壳的PE&lt;/p&gt;
&lt;p&gt; 而我们运行带壳PE的时候,这时候壳中的解压缩代码开始执行,从而把我们以前压缩数据的节重新映射到内存.&lt;/p&gt;
&lt;h3&gt;5.压缩壳方法1(PE的生成)&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031225948591-1255335936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时观察方法1我们会发现,我们新的PE, 解压缩的代码在压缩数据(节)的上面,那么这个时候则会面临一个问题&lt;/p&gt;
&lt;p&gt;如果我们解压缩的时候,那么压缩数据的地址应该在我们解压缩代码的哪里,那么此时我们一边解压缩,一边压缩数据会覆盖解压缩代码,此时我们不知道是先解压完成,还是先覆盖完成&lt;/p&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;p&gt;　　首先我们知道原PE的节的个数以及大小,那么此时我们生成的新的带壳PE,则会获得大小.然后在其带壳PE的下面申请怎么大小的节用来占位置即可.&lt;/p&gt;
&lt;p&gt;那么此时我们解压的数据,则会写到我们占位置的地方.&lt;/p&gt;

&lt;p&gt;如果不懂可以看下图理解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031230426185-739480095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 此时Shell(中文翻译为壳)代表的就是解压缩的代码&lt;/p&gt;
&lt;p&gt;这个图是映射到内存中的带壳PE分布图.&lt;/p&gt;
&lt;p&gt;很简单,解压缩代码执行,然后解压的代码正好在我们占地方的位置.&lt;/p&gt;
&lt;h3&gt;二丶脱壳步骤,以及手脱UPX壳&lt;/h3&gt;
&lt;p&gt;首先我们知道压缩壳了,压缩壳就是缩小PE文件&lt;/p&gt;
&lt;p&gt;那么在壳的世界 还有加密壳.  原理是一样的,只不过 &lt;/p&gt;
&lt;p&gt;压缩壳:　用来压缩数据，减小ＰＥ体积&lt;/p&gt;
&lt;p&gt;加密壳：用来防住你们我们他们等等逆向人员的　＾＿＾&lt;/p&gt;
&lt;h3&gt;1.脱壳步骤：&lt;/h3&gt;
&lt;p&gt;１．查找OEP(入口点 )&lt;/p&gt;
&lt;p&gt;　　 方法: 经验,这个主要看经验&lt;/p&gt;
&lt;p&gt;　　 不过这个经验也好分辨.&lt;/p&gt;
&lt;p&gt; 2.脱壳手法&lt;/p&gt;
&lt;p&gt;  　2.1 ESP 定律&lt;/p&gt;
&lt;p&gt;      2.2 API&lt;/p&gt;
&lt;p&gt;      2.3 单步跟踪(步过循环,只向下跳转)&lt;/p&gt;
&lt;p&gt;3. 经过上面步骤开始脱壳&lt;/p&gt;
&lt;p&gt;　　手工DMP内存(把内存拷贝下来)&lt;/p&gt;
&lt;p&gt;       然后修复PE (一般加密壳汇编PE中的导入表给抹掉)&lt;/p&gt;
&lt;p&gt;首先ESP定律,在壳的第一讲已经讲解过了&lt;/p&gt;
&lt;p&gt;这里我们说下怎么查看入口点,以及脱壳手法的API 跟踪,和单步跟踪.&lt;/p&gt;
&lt;h3&gt;2.识别入口点&lt;/h3&gt;
&lt;p&gt;如果要识别入口点,这里只简单说下,因为比如 VC++6.0  VSXXX  VB...等等入口点都是不一样的&lt;/p&gt;
&lt;p&gt;这里直说一下VC和VS入口点的识别方法.&lt;/p&gt;
&lt;p&gt;首先随便打开一个没有加壳的程序(VC++6.0的)OD打开查看.&lt;/p&gt;
&lt;p&gt;1.VC6.0的识别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031231530279-196779325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;往下拖动一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031231551685-119112498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,VC6.0的入口点会固定的调用这三个API&lt;/p&gt;
&lt;p&gt;只需要记住即可.看下VS的识别方法&lt;/p&gt;
&lt;h3&gt;&lt;sup&gt;2.VS系列识别方法&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031232418357-1564861789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不知道还是电脑原因还是编译器原因,编译的程序不能在XP下使用OD打开,所以只能用IDA说下了&lt;/p&gt;
&lt;p&gt;如果OD能打开,那么则是一个Call 然后下方紧接着跟着一个JMP跳转&lt;/p&gt;
&lt;p&gt;那么它的入口点特征则是调用以上的API&lt;/p&gt;
&lt;h3&gt;3.使用API定位脱壳&lt;/h3&gt;
&lt;p&gt;因为ESP定律已经说过了,这里使用API进行脱壳.&lt;/p&gt;
&lt;p&gt;思路:&lt;/p&gt;
&lt;p&gt;　　因为我们知道入口点的特征,比如VC6.0的,它会调用API,那么我们API下段点即可.肯定会过去的.&lt;/p&gt;
&lt;p&gt;首先我们脱一个VC6.0的upx压缩壳.&lt;/p&gt;
&lt;p&gt;首先我们知道入口点会调用的API&lt;/p&gt;
&lt;p&gt;那么我们下断点即可.&lt;/p&gt;
&lt;p&gt;(注意,这里使用UPX随便压缩了一个VC的程序,UPX可以官网下载,VC程序也可以自己编写一个)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031232922248-1281315030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;F9以下,看看能不能断下来.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031233231810-637147263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;断下来了,只不过是断在里面了,然后我们执行到返回  CTRL + F9 即可看到我们的熟悉的特征&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031233325216-1994969802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确实使我们的入口点位置&lt;/p&gt;
&lt;p&gt;那么此时移动汇编代码到入口点,也就是一开始的地方,(因为此时程序已经执行的API可能数据已经破坏了,所以我们在入口点位置下段点,重新运行则可以断在入口点)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031233610357-1589795334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时重新运行程序,当我们的EIP 位置是4014EC的地方我们则可以DMP内存了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171031234248435-1962653786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存一份即可.&lt;/p&gt;
&lt;h3&gt;3.使用单步方法定位入口点.&lt;/h3&gt;
&lt;p&gt;这个就比较简单了,我们遇到循环,不看直接往下单步走,直到走到一个远跳即可.&lt;/p&gt;
&lt;p&gt;比如我模拟一下OD&lt;/p&gt;
&lt;p&gt;地址:     汇编代码&lt;/p&gt;
&lt;p&gt;1　　　add eax,eax&lt;/p&gt;
&lt;p&gt;2          mov eax,eax&lt;/p&gt;
&lt;p&gt;3          jnz   1 　　 　　　　EIP = 3&lt;/p&gt;
&lt;p&gt;4　　  mov edx,edx&lt;/p&gt;
&lt;p&gt;5         jmp  00401000&lt;/p&gt;
&lt;p&gt; 此时EIP = 3,那么会跳转到1,那么这个时候我们在4地址下段点即可,不看它的循环,一直到5地址,有个远跳,即可.&lt;/p&gt;
&lt;p&gt;关于DMP内存和上面一样,不说了.&lt;/p&gt;

</description>
<pubDate>Tue, 31 Oct 2017 15:43:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7764483.html</dc:identifier>
</item>
<item>
<title>服务端事件EventSource揭秘 - royalrover</title>
<link>http://www.cnblogs.com/accordion/p/7764460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/accordion/p/7764460.html</guid>
<description>&lt;h2 id=&quot;服务端推&quot;&gt;服务端推&lt;/h2&gt;
&lt;p&gt;服务端推，指的是由服务器主动的向客户端发送消息（响应）。在应用层的HTTP协议实现中，“请求-响应”是一个round trip，它的起点来自客户端，因此在应用层之上无法实现简易的服务端推功能。当前解决服务端推送的方案有这几个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端长轮询&lt;/li&gt;
&lt;li&gt;websocket双向连接&lt;/li&gt;
&lt;li&gt;iframe永久帧&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;长轮训虽然可以避免短轮训造成的服务端过载，但在服务端返回数据后仍需要客户端主动发起下一个长轮训请求，等待服务端响应，这样仍需要底层的连接建立而且服务端处理逻辑需要相应处理，不符合逻辑上的流程简单的服务端推送；&lt;/p&gt;
&lt;p&gt;websocket连接相对而言功能最强大，但是它对服务器的版本有要求，在可以使用websocket协议的服务器上尽量采用此种方式；&lt;/p&gt;
&lt;p&gt;iframe永久帧则是在在页面嵌入一个专用来接受数据的iframe页面，该页面由服务器输出相关信息，如&lt;strong/&gt;，服务器不停的向iframe中写入类似的script标签和数据，实现另一种形式的服务端推送。不过永久帧的技术会导致主页面的加载条始终处于“loading”状态，体验很差。&lt;/p&gt;
&lt;p&gt;HTML5规范中提供了服务端事件EventSource，浏览器在实现了该规范的前提下创建一个EventSource连接后，便可收到服务端的发送的消息，这些消息需要遵循一定的格式，对于前端开发人员而言，只需在浏览器中侦听对应的事件皆可。&lt;/p&gt;
&lt;p&gt;相比较上文中提到的3中实现方式，EventSource流的实现方式对客户端开发人员而言非常简单，兼容性上出了IE系的浏览器（IE、Edge）外其他都良好；对于服务端，它可以兼容老的浏览器，无需upgrade为其他协议，在简单的服务端推送的场景下可以满足需求。在浏览器与服务端需要强交互的场景下，websocket仍是不二的选择。&lt;/p&gt;
&lt;h2 id=&quot;eventsource规范简析&quot;&gt;EventSource规范简析&lt;/h2&gt;
&lt;h3 id=&quot;浏览器端&quot;&gt;浏览器端&lt;/h3&gt;
&lt;p&gt;浏览器端，需要创建一个EventSource对象，并且传入一个服务端的接口URI作为参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var evtSource = new EventSource('http://localhost:9111/es');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，'&lt;a href=&quot;http://localhost:9111/es'%E4%B8%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%90%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%82%E7%9B%AE%E5%89%8D%EF%BC%8CEventSource%E5%9C%A8%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E4%B8%8D%E6%94%AF%E6%8C%81&quot; class=&quot;uri&quot;&gt;http://localhost:9111/es'为服务端吐出数据的接口。目前，EventSource在大多数浏览器端不支持&lt;/a&gt;&lt;br/&gt;跨域，因此它不是一种跨域的解决方案。&lt;/p&gt;
&lt;p&gt;默认EventSource对象通过侦听“message”事件获取服务端传来的消息，“open”事件则在http连接建立后触发，”error“事件会在通信错误（连接中断、服务端返回数据失败）的情况下触发。同时，EventSource规范允许服务端指定自定义事件，客户端侦听该事件即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;evtSource.addEventListener('message',function(e){
    console.log(e.data);
});
evtSource.addEventListener('error',function(e){
    console.log(e);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;服务端&quot;&gt;服务端&lt;/h3&gt;
&lt;p&gt;事件流的对应MIME格式为&lt;strong&gt;text/event-stream&lt;/strong&gt;，而且其基于HTTP长连接。针对HTTP1.1规范默认采用长连接，针对HTTP1.0的服务器需要特殊设置。&lt;/p&gt;
&lt;p&gt;服务端返回数据需要特殊的格式，它分为四种消息类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;event, data, id, retry&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，event指定自定义消息的名称，如&lt;strong&gt;event: customMessage\n&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;data指定具体的消息体，可以是对象或者字符串，如&lt;strong&gt;data: &lt;code&gt;JSON.stringify(jsonObj)\n\n&lt;/code&gt;&lt;/strong&gt;,在消息体后面有两个换行符\n，代表当前消息体发送完毕，一个换行符标识当前消息并未结束，浏览器需要等待后面数据的到来后再触发事件；&lt;/p&gt;
&lt;p&gt;id为当前消息的标识符，可以不设置。一旦设置则在浏览器端的eventSource对象中就会有体现(假设服务端返回&lt;strong&gt;id: 369\n&lt;/strong&gt;)，&lt;code&gt;eventSource.lastEventId == 369&lt;/code&gt;。该字段使用场景不大;&lt;/p&gt;
&lt;p&gt;retry设置当前http连接失败后，重新连接的间隔。EventSource规范规定，客户端在http连接失败后默认进行重新连接，重连间隔为3s，通过设置retry字段可指定重连间隔;&lt;/p&gt;
&lt;p&gt;每个字段都有名称，紧接着有个”:“。当出现一个没有名称的字段而只有”:“时，这就会被服务端理解为”注释“，并不会被发送至浏览器端，如&lt;em&gt;: commision&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;由于EventSource是基于HTTP连接之上的，因此在一段没有数据的时期会出现超时问题。&lt;strong&gt;服务器默认HTTP超时时间为2分钟，在node端可以通过response.connection.setTimeou(0)设置为默认的2min超时&lt;/strong&gt;， 因此需要服务端做心跳保活，否则客户端在连接超时的情况下出现&lt;strong&gt;net::ERR_INCOMPLETE_CHUNKED_ENCODING&lt;/strong&gt;错误。通过阅读相关规范，发现注释行可以用来防止连接超时,服务器可以定期发送一条消息注释行,以保持连接不断。&lt;/p&gt;
&lt;p&gt;下面提供koa的服务端代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var fs = require('fs');
var path = require('path');
var PassThrough = require('stream').PassThrough;
var Readable = require('stream').Readable;
var koa = require('koa');
var Router = require('koa-router');
var app = new koa();
var router = new Router();

function RR(){
    Readable.call(this,arguments);
}
RR.prototype = new Readable();
RR.prototype._read = function(data){
}

router.get('/',function(ctx,next){
    ctx.set('content-type','text/html');
    ctx.body = fs.readFileSync(path.join(process.cwd(),'eventServer.html'));
});

const sse = (stream,event, data) =&amp;gt; {
    return stream.push(`event:${ event }\ndata: ${ JSON.stringify(data) }\n\n`)
//    return stream.write(`event:${ event }\ndata: ${ JSON.stringify(data) }\n\n`);
}
router.get('/es',function(ctx,next){
    var stream = new RR()//PassThrough();
    ctx.set({
        'Content-Type':'text/event-stream',
        'Cache-Control':'no-cache',
        Connection: 'keep-alive'
    });
    sse(stream,'test',{a: &quot;yango&quot;,b: &quot;tango&quot;});
    ctx.body = stream;
    setInterval(()=&amp;gt;{
        sse(stream,'test',{a: &quot;yango&quot;,b: Date.now()});
    },3000); 
});

app.use(router.routes());
app.listen(9111,function(){
    console.log('listening port 9111');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处需要注意的是koa-router的返回值必须是一个Stream（Readable），这是由于koa的特殊性造成的。如果context.body不是Stream是一个字符串或者Buffer实例，会直接在node原生中调用res.end(buffer),结束了HTTP响应：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;koa lib/application.js

// responses
if (Buffer.isBuffer(body)) return res.end(body);
if ('string' == typeof body) return res.end(body);
if (body instanceof Stream) return body.pipe(res);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此造成了服务端事件流无法正确响应。而返回Stream类型的方式有几种，如通过扩展stream模块的Readable可读流返回或者直接采用PassThrough流返回，亦可通过through2模块或者Transform对象实现，归根到底保证可以从该stream对象中pipe出数据至http.ServerResponse对象中。&lt;/p&gt;
&lt;p&gt;附页面代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        hello world
    &amp;lt;/div&amp;gt;
    &amp;lt;p id=&quot;info&quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;script&amp;gt;
        var infoShow = document.querySelector('#info');
        var se = new EventSource('http://localhost:9111/es');
        se.addEventListener('test',function(e){
            infoShow.textContent += e.data+'\n';
        });
        se.addEventListener('error',function(e){
            console.log(e);
        })
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events&quot;&gt;使用服务器发送事件&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8761025/why-is-eventsource-connection-closed-every-30-60-sec-when-no-data-transported-w&quot;&gt;EventSource超时&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 15:36:00 +0000</pubDate>
<dc:creator>royalrover</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/accordion/p/7764460.html</dc:identifier>
</item>
</channel>
</rss>