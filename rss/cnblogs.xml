<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>学习java的优势 - 茆安国</title>
<link>http://www.cnblogs.com/maoanguo/p/7897146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maoanguo/p/7897146.html</guid>
<description>&lt;p&gt;              学习java之后，到企业的岗位&lt;/p&gt;
&lt;p&gt;&lt;span&gt;技术：java软件开发工程师（中初级）：技术一般；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;高级工程师：技术高等；&lt;/p&gt;
&lt;p&gt;技术架构师；技术顶级；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;管理：项目经理；产品经理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;质询：质询顾问；销售经理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学会之后可以根据个人的爱好去从事相关的职位，但是不管是做哪一个都是需要技术的底子。希望能帮到你们。在这里我也提醒大家，去做管理和质询的话是需要一定口才的，当然不管做什么你都需要一个好口才，只有把自己推销出去让别人认可你， 你才能拿到高薪。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 15:50:00 +0000</pubDate>
<dc:creator>茆安国</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maoanguo/p/7897146.html</dc:identifier>
</item>
<item>
<title>Redis 快速入门 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/7897131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/7897131.html</guid>
<description>&lt;p&gt;谈到Redis，大家应该都不陌生。它是用c语言开发的一个高性能键值数据库，主要用于缓存领域。本章通过Redis的安装，Redis的五大数据类型，Redis的Java客户端，Redis与Spring 的整合 。来让读者对它有一个初步的了解。下一章再通过介绍配置文件来搭建Redis的主从模式和集群模式（配置大于编程，先从简单的编程入手）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果图&lt;/strong&gt;：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/806956/201711/806956-20171125214014703-1073380070.png&quot; alt=&quot;Redis 缓存项目效果图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：对商品类目进行Redis缓存处理&lt;br/&gt;&lt;strong&gt;技术&lt;/strong&gt;：Redis，Spring，SpringMVC，Mybatis，EasyUI&lt;br/&gt;&lt;strong&gt;说明&lt;/strong&gt;：EasyUI的树菜单上一章节有介绍，这里是为了方便展示效果。项目结构图中箭头所指的文件是需要重点学习的。若对EasyUI 树菜单感兴趣的可以访问：（该章节源码中提供商品类名的sql文件）&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/qq_19558705/article/details/78583888&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq_19558705/article/details/78583888&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;源码&lt;/strong&gt;：见文章底部&lt;br/&gt;&lt;strong&gt;项目结构&lt;/strong&gt;：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/806956/201711/806956-20171125215651906-382867536.png&quot; alt=&quot;项目结构图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis-安装&quot;&gt;Redis 安装&lt;/h2&gt;
&lt;p&gt;安装文档:&lt;br/&gt;&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/blob/master/Redis/Redis%E5%AE%89%E8%A3%85.md&quot;&gt;https://github.com/ITDragonBlog/daydayup/blob/master/Redis/Redis%E5%AE%89%E8%A3%85.md&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis-五大数据类型&quot;&gt;Redis 五大数据类型&lt;/h2&gt;
&lt;p&gt;Redis 五大数据类型有String 类型，Hash 类型，List 类型，Set 类型，Zset（Sortedset）类型。其中常用的是前三个。&lt;br/&gt;官方提供的操作手册：&lt;a href=&quot;http://redisdoc.com/&quot; class=&quot;uri&quot;&gt;http://redisdoc.com/&lt;/a&gt;&lt;br/&gt;在redis 自带的客户端中输入命令时，可以使用tab自动补齐，新手建议不要偷懒。&lt;/p&gt;
&lt;h3 id=&quot;string-类型&quot;&gt;String 类型&lt;/h3&gt;
&lt;p&gt;String 是 redis 最基本的类型，一个key对应一个value。&lt;br/&gt;赋值：set key value&lt;br/&gt;取值：get key&lt;br/&gt;批量赋值：mset key value ... keyN valueN&lt;br/&gt;批量取值：mget key ... keyN&lt;br/&gt;取值并赋值：getset key value&lt;br/&gt;删除key：del key ... keyN&lt;br/&gt;数值加一：incr key&lt;br/&gt;数值加N：incrby key n&lt;br/&gt;数值减一：decr key&lt;br/&gt;数值减N：decrby key n&lt;br/&gt;字符串追加：append key value&lt;br/&gt;字符串长度：strlen key&lt;br/&gt;*注 形如&quot;key ... keyN&quot; 表示可以批量操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set key value
OK
127.0.0.1:6379&amp;gt; get key
&quot;value&quot;
127.0.0.1:6379&amp;gt; mset key1 1 key2 2 key3 3
OK
127.0.0.1:6379&amp;gt; mget key1 key3
1) &quot;1&quot;
2) &quot;3&quot;
127.0.0.1:6379&amp;gt; del key
(integer) 1
127.0.0.1:6379&amp;gt; incr count
(integer) 1
127.0.0.1:6379&amp;gt; incrby count 10
(integer) 11
127.0.0.1:6379&amp;gt; decr count
(integer) 10
127.0.0.1:6379&amp;gt; decrby count 5
(integer) 5
127.0.0.1:6379&amp;gt; set str itdragon
OK
127.0.0.1:6379&amp;gt; append str &quot; blog!&quot;
(integer) 14
127.0.0.1:6379&amp;gt; get str
&quot;itdragon blog!&quot;
127.0.0.1:6379&amp;gt; strlen str
(integer) 14&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hash-散列类型&quot;&gt;Hash 散列类型&lt;/h3&gt;
&lt;p&gt;Redis hash 是一个键值对集合，和Java 的HashMap 类似。&lt;br/&gt;Redis hash 是一个String 类型的 field 和 value 的映射表，hash特别适合用于存储对象（key 可以是对象+id，field 是对象属性，value则是属性值）。&lt;br/&gt;给一个字段赋值：hset key field value&lt;br/&gt;给多个字段赋值：hmset key field value ... fieldN valueN&lt;br/&gt;取一个字段的值：hget key field&lt;br/&gt;取多个字段的值：gmset key field ... fieldN&lt;br/&gt;取所有的字段名和值：hgetall key&lt;br/&gt;删除字段名和值：hdel key field ... fieldN&lt;br/&gt;判断字段是否存在：hexists key field&lt;br/&gt;获取key的所有field：hkeys key&lt;br/&gt;获取key的所有value：hvals key&lt;br/&gt;获取field个数：hlen key&lt;br/&gt;*注：这里的field 就是 字段名，value 就是字段值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hset user name itdragon
(integer) 1
127.0.0.1:6379&amp;gt; hget user name
&quot;itdragon&quot;
127.0.0.1:6379&amp;gt; hmset user position java study redis
OK
127.0.0.1:6379&amp;gt; hmget user position study
1) &quot;java&quot;
2) &quot;redis&quot;
127.0.0.1:6379&amp;gt; hgetall user
1) &quot;name&quot;
2) &quot;itdragon&quot;
3) &quot;position&quot;
4) &quot;java&quot;
5) &quot;study&quot;
6) &quot;redis&quot;
127.0.0.1:6379&amp;gt; hdel user name 
(integer) 1
127.0.0.1:6379&amp;gt; hdel user position study
(integer) 2
127.0.0.1:6379&amp;gt; hexists user name
(integer) 1
127.0.0.1:6379&amp;gt; hexists user age
(integer) 0
127.0.0.1:6379&amp;gt; hkeys user
1) &quot;name&quot;
2) &quot;position&quot;
3) &quot;study&quot;
127.0.0.1:6379&amp;gt; hvals user
1) &quot;itdragon&quot;
2) &quot;java&quot;
3) &quot;redis&quot;
127.0.0.1:6379&amp;gt; hlen user
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;list-类型&quot;&gt;List 类型&lt;/h3&gt;
&lt;p&gt;Redis 列表是采用来链表来存储的简单字符串列表，按照插入顺序排序。添加元素一般从链表两端开始。&lt;br/&gt;向列表左侧加元素：lpush key value ... valueN&lt;br/&gt;向列表右侧加元素：rpush key value ... valueN&lt;br/&gt;遍历列表：lrange key startIndex endIndex&lt;br/&gt;获取List长度：llen key&lt;br/&gt;通过下标获取值：lindex key index&lt;br/&gt;通过下标设置值：lset key index value&lt;br/&gt;列表左侧移除第一个元素：lpop key&lt;br/&gt;列表右侧移除第一个元素：rpop key&lt;br/&gt;截取保留剩下的列表：ltrim key startIndex endIndex&lt;br/&gt;在制定元素插入值：linsert key after/before index value&lt;br/&gt;把集合第一个元素移到其他集合中：rpoplpush key otherListKey&lt;/p&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;注：若endIndex=-1 表示最后一位；otherListKey 表示其他集合&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; lpush list 1 2
(integer) 2
127.0.0.1:6379&amp;gt; rpush list 3 4 
(integer) 4
127.0.0.1:6379&amp;gt; lrange list 0 -1
1) &quot;2&quot;
2) &quot;1&quot;
3) &quot;3&quot;
4) &quot;4&quot;
127.0.0.1:6379&amp;gt; lpop list
&quot;2&quot;
127.0.0.1:6379&amp;gt; rpop list
&quot;4&quot;
127.0.0.1:6379&amp;gt; llen list
(integer) 2
127.0.0.1:6379&amp;gt; lindex list 1
&quot;3&quot;
127.0.0.1:6379&amp;gt; linsert list after 1 2
(integer) 3
127.0.0.1:6379&amp;gt; linsert list before 3 4
(integer) 4
127.0.0.1:6379&amp;gt; ltrim list 0 1
OK
127.0.0.1:6379&amp;gt; rpoplpush list newlist
&quot;1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;set-类型&quot;&gt;Set 类型&lt;/h3&gt;
&lt;p&gt;Redis 的 Set 是String类型的无序集合。它是通过HashTable实现实现的，用法和 List 类型很相似。&lt;br/&gt;新增集合元素：sadd key value ... valueN&lt;br/&gt;删除集合元素：srem key value ... valueN&lt;br/&gt;获取集合所有元素：smembers key&lt;br/&gt;判断集合元素是否存在：sismember key value&lt;br/&gt;集合差集：sdiff key1 key2&lt;br/&gt;集合交集：sinter key1 key2&lt;br/&gt;集合并集：sunion key1 key2&lt;br/&gt;获取集合长度：scard key1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; sadd set a b c d
(integer) 4
127.0.0.1:6379&amp;gt; srem set a b c
(integer) 3
127.0.0.1:6379&amp;gt; smembers set
1) &quot;d&quot;
127.0.0.1:6379&amp;gt; sismember set a
(integer) 0
127.0.0.1:6379&amp;gt; sismember set d
(integer) 1
127.0.0.1:6379&amp;gt; sadd setA 1 2 3 
(integer) 3
127.0.0.1:6379&amp;gt; sadd setB 2 3 4
(integer) 3
127.0.0.1:6379&amp;gt; sdiff setA setB
1) &quot;1&quot;
127.0.0.1:6379&amp;gt; sdiff setB setA
1) &quot;4&quot;
127.0.0.1:6379&amp;gt; sinter setA setB
1) &quot;2&quot;
2) &quot;3&quot;
127.0.0.1:6379&amp;gt; sunion setA setB
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
127.0.0.1:6379&amp;gt; scard setA
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;zset-类型&quot;&gt;Zset 类型&lt;/h3&gt;
Redis 的 zset（sorted set）和 set 一样也是string类型元素的集合,且不允许有重复的成员。不同的是 zset 的每个元素都会关联一个double类型的分数。zset正是通过分数来为集合中的成员进行排序。zset的成员是唯一的,但分数(score)却可以重复。&lt;br/&gt;新增集合元素：zadd key score value ... scoreN valueN&lt;br/&gt;获取元素分数：zscore key value&lt;br/&gt;按照分数从小到大排序：zrange key startIndex endIndex&lt;br/&gt;按照分数从大到小排序：zrevrange key startIndex endIndex&lt;br/&gt;遍历时显示分数：withscores&lt;br/&gt;统计分数比value少的个数：zrank key value&lt;br/&gt;统计分数比value高的个数：zrevrank key value&lt;br/&gt;输出分数在制定值内的元素：zrangebyscore key score1 score2&lt;br/&gt;给元素加分：zincrby key score value&lt;br/&gt;获取元素个数：zcard()&lt;br/&gt;统计分数内的个数：zcount key score1 score2&lt;br/&gt;删除制定排名内的元素：zremrangebyrank key no1 no2&lt;br/&gt;删除指定分数内的元素：zremrangebyscore key score1 score2&lt;br/&gt;删除指定元素：zrem key value&lt;/li&gt;
&lt;li readability=&quot;13.5&quot;&gt;
&lt;p&gt;注： zcount 统计分数内的个数，score1 &amp;lt;= keyScore =&amp;lt; score2；zremrangebyrank 的 no1 和 no2 表示排名的第几位。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zadd zset 65 A 67 C 66 B
(integer) 3
127.0.0.1:6379&amp;gt; zscore zset C
&quot;67&quot;
127.0.0.1:6379&amp;gt; zrange zset 0 -1
1) &quot;A&quot;
2) &quot;B&quot;
3) &quot;C&quot;
127.0.0.1:6379&amp;gt; zrevrange zset 0 -1
1) &quot;C&quot;
2) &quot;B&quot;
3) &quot;A&quot;
127.0.0.1:6379&amp;gt; zrevrange zset 0 -1 withscores
1) &quot;C&quot;
2) &quot;67&quot;
3) &quot;B&quot;
4) &quot;66&quot;
5) &quot;A&quot;
6) &quot;65&quot;
127.0.0.1:6379&amp;gt; zrank zset C
(integer) 2
127.0.0.1:6379&amp;gt; zrevrank zset C
(integer) 0
127.0.0.1:6379&amp;gt; zrangebyscore zset 65 66
1) &quot;A&quot;
2) &quot;B&quot;
127.0.0.1:6379&amp;gt; zrangebyscore zset 65 66 limit 1 2
1) &quot;B&quot;
127.0.0.1:6379&amp;gt; zincrby zset 10 A
&quot;75&quot;
127.0.0.1:6379&amp;gt; zcard zset
(integer) 3
127.0.0.1:6379&amp;gt; zcount zset 65 66
(integer) 1
127.0.0.1:6379&amp;gt; zremrangebyrank zset 0 1
(integer) 2
127.0.0.1:6379&amp;gt; zremrangebyscore zset 100 200
(integer) 0
127.0.0.1:6379&amp;gt; zrem zset A
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jedis客户端&quot;&gt;Jedis客户端&lt;/h2&gt;
&lt;p&gt;Jedis 是比较主流的 Redis Java 客户端。&lt;br/&gt;第一步：导入Jedis需要的jar&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- Redis客户端 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;redis.clients&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;jedis&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;jedis.version&amp;gt;&lt;/span&gt;2.7.2&lt;span class=&quot;kw&quot;&gt;&amp;lt;/jedis.version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步：单元测试类&lt;br/&gt;Jedis 的语法和 Redis 几乎一样，如果学好了Redis，Jedis也就没问题了，可谓是买一送一。建议使用连接池的方式。&lt;br/&gt;```java&lt;br/&gt;package com.itdragon.redis;&lt;br/&gt;import java.util.HashMap;&lt;br/&gt;import java.util.Map;&lt;br/&gt;import org.apache.commons.pool2.impl.GenericObjectPoolConfig;&lt;br/&gt;import org.junit.Test;&lt;br/&gt;import redis.clients.jedis.Jedis;&lt;br/&gt;import redis.clients.jedis.JedisPool;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;public class TestJedisOperate {&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private final static String HOST = &quot;112.74.83.71&quot;;
private final static int PORT = 6379;

/**
 * jedis 的语法和 redis 的语法几乎一致，比较常用的有Hash，String，List
 */
@Test
public void jedisSignle() {
    Jedis jedis = new Jedis(HOST, PORT);
    jedis.set(&quot;account&quot;, &quot;itdragon&quot;);
    System.out.println(&quot;set , get 操作 : &quot; + jedis.get(&quot;account&quot;));
    jedis.mset(&quot;account:01&quot;, &quot;itdragon01&quot;, &quot;account:02&quot;, &quot;itdragon02&quot;);
    System.out.println(&quot;mset , mget 操作 : &quot; + jedis.mget(&quot;account:01&quot;, &quot;account:02&quot;));
    jedis.hset(&quot;user&quot;, &quot;name&quot;, &quot;ITDragon&quot;);
    System.out.println(&quot;hset , hget 操作 : &quot; + jedis.hget(&quot;user&quot;, &quot;name&quot;));
    Map&amp;lt;String, String&amp;gt; userMap = new HashMap&amp;lt;&amp;gt;();
    userMap.put(&quot;password&quot;, &quot;123456&quot;);
    userMap.put(&quot;position&quot;, &quot;Java&quot;);
    jedis.hmset(&quot;user&quot;, userMap);
    System.out.println(&quot;hmset , hmget 操作 : &quot; + jedis.hmget(&quot;user&quot;, &quot;name&quot;, &quot;password&quot;, &quot;position&quot;));
    if (0 == jedis.llen(&quot;userList&quot;)) {
        jedis.lpush(&quot;userList&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;);
    }
    System.out.println(&quot;List 类型 lpush , lrange 操作 : &quot; + jedis.lrange(&quot;userList&quot;, 0, -1));
    jedis.sadd(&quot;userSet&quot;, &quot;1&quot;, &quot;2&quot;, &quot;2&quot;);
    System.out.println(&quot;Set 类型 sadd , smembers 操作 : &quot; + jedis.smembers(&quot;userSet&quot;));
    Map&amp;lt;String, Double&amp;gt; scoreMembers = new HashMap&amp;lt;&amp;gt;();
    scoreMembers.put(&quot;A&quot;, 65.0);
    scoreMembers.put(&quot;C&quot;, 67.0);
    scoreMembers.put(&quot;B&quot;, 66.0);
    jedis.zadd(&quot;userScore&quot;, scoreMembers);
    System.out.println(&quot;Set 类型 zadd , zrange 操作 : &quot; + jedis.zrange(&quot;userScore&quot;, 0, -1));
    jedis.close();
}

@Test
public void testJedisPool() {
    JedisPool pool = new JedisPool(HOST, PORT);
    Jedis jedis = pool.getResource();
    System.out.println(&quot;通过连接池获取 key 为 account 的值 : &quot; + jedis.get(&quot;account&quot;));
    jedis.close();
    pool.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;h2 id=&quot;spring-整合-redis&quot;&gt;Spring 整合 Redis&lt;/h2&gt;
&lt;p&gt;创建用于整合redis的文件 applicationContext-jedis.xml&lt;br/&gt;建议使用redis 默认配置（默认，让生活更美好）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:context=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:p=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:aop=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:tx=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 加载配置文件 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;context:property-placeholder&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; location=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;classpath:resource/*.properties&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接池配置 (可以用 redis 默认配置，效果可能会更好)--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jedisPoolConfig&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;redis.clients.jedis.JedisPoolConfig&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 最大连接数 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxTotal&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;30&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 最大空闲连接数 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxIdle&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 每次释放连接的最大数目 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;numTestsPerEvictionRun&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1024&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 释放连接的扫描间隔（毫秒） --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;timeBetweenEvictionRunsMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;30000&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接最小空闲时间 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;minEvictableIdleTimeMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1800000&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接空闲多久后释放, 当空闲时间&amp;gt;该值 且 空闲连接&amp;gt;最大空闲连接数 时直接释放 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;softMinEvictableIdleTimeMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10000&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxWaitMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1500&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 在获取连接的时候检查有效性, 默认false --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;testOnBorrow&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 在空闲时检查有效性, 默认false --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;testWhileIdle&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;blockWhenExhausted&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- jedis客户端单机版 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;redisClient&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;redis.clients.jedis.JedisPool&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;constructor-arg&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;host&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${redis.host}&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;constructor-arg&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;port&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${redis.ip}&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- &amp;lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot; /&amp;gt; --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jedisClient&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.itdragon.common.utils.JedisClientSingle&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单封装了Jedis 常用方法 JedisClientSingle.java&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itdragon.common.utils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import redis.clients.jedis.Jedis;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import redis.clients.jedis.JedisPool;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 单例的Redis 工具类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; JedisClientSingle {
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * connect timed out 问题： &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 1. 检查redis服务是否开启&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 2. 检查是否是因为防火墙的问题&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 3. 检查网络问题(如果在同一个局域网内几乎不会出现这个问题)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Jedis jedis =new Jedis(HOST,PORT,100000);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * JedisPool pool = new JedisPool(poolConfig, HOST, PORT, 100000);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; JedisPool jedisPool; 
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        String string = jedis.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; string;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(String key, String value) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        String string = jedis.&lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(key, value);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; string;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;hget&lt;/span&gt;(String hkey, String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        String string = jedis.&lt;span class=&quot;fu&quot;&gt;hget&lt;/span&gt;(hkey, key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; string;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hset&lt;/span&gt;(String hkey, String key, String value) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        Long result = jedis.&lt;span class=&quot;fu&quot;&gt;hset&lt;/span&gt;(hkey, key, value);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;del&lt;/span&gt;(String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        Long result = jedis.&lt;span class=&quot;fu&quot;&gt;del&lt;/span&gt;(key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hdel&lt;/span&gt;(String hkey, String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        Long result = jedis.&lt;span class=&quot;fu&quot;&gt;hdel&lt;/span&gt;(hkey, key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取商品类名接口实现类 ProductCategoryServiceImpl.java&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itdragon.service.impl;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Date;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.commons.lang3.StringUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Value;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.util.CollectionUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Service;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.transaction.annotation.Transactional;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.pojo.EUTreeNode;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.pojo.ResponseResult;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.utils.JedisClientSingle;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.utils.JsonUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.mapper.ProductCategoryMapper;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.pojo.ProductCategory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.pojo.ProductCategoryExample;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.pojo.ProductCategoryExample.Criteria;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.service.ProductCategoryService;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Service&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProductCategoryServiceImpl &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; ProductCategoryService {
    
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ProductCategoryMapper categoryMapper;
    
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; JedisClientSingle jedisClientSingle;
    
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${CATEGROY_ID_CACHE_REDIS_KEY}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String CATEGROY_ID_CACHE_REDIS_KEY;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;EUTreeNode&amp;gt; &lt;span class=&quot;fu&quot;&gt;getCategoryList&lt;/span&gt;(Long parentId) {
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; startTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
        List&amp;lt;EUTreeNode&amp;gt; resultList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
        &lt;span class=&quot;co&quot;&gt;// 从redis缓存中取内容&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            String cacheDatas = jedisClientSingle.&lt;span class=&quot;fu&quot;&gt;hget&lt;/span&gt;(CATEGROY_ID_CACHE_REDIS_KEY, parentId.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;());
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;isNotBlank&lt;/span&gt;(cacheDatas)) {
                List&amp;lt;ProductCategory&amp;gt; categories = JsonUtils.&lt;span class=&quot;fu&quot;&gt;jsonToList&lt;/span&gt;(cacheDatas, ProductCategory.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (ProductCategory category : categories) {
                    EUTreeNode node = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;EUTreeNode&lt;/span&gt;();
                    node.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;());
                    node.&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
                    node.&lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getIsParent&lt;/span&gt;()?&lt;span class=&quot;st&quot;&gt;&quot;closed&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;open&quot;&lt;/span&gt;);
                    resultList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(node);
                }
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;redis cache Time : &quot;&lt;/span&gt; + (System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - startTime));
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; resultList;
            }
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        ProductCategoryExample example = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProductCategoryExample&lt;/span&gt;();
        Criteria criteria = example.&lt;span class=&quot;fu&quot;&gt;createCriteria&lt;/span&gt;();
        criteria.&lt;span class=&quot;fu&quot;&gt;andStatusEqualTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        criteria.&lt;span class=&quot;fu&quot;&gt;andParentIdEqualTo&lt;/span&gt;(parentId); &lt;span class=&quot;co&quot;&gt;// 查询父节点下的所有子节点&lt;/span&gt;
        List&amp;lt;ProductCategory&amp;gt; productCategories = categoryMapper.&lt;span class=&quot;fu&quot;&gt;selectByExample&lt;/span&gt;(example);
        
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (ProductCategory category : productCategories) {
            EUTreeNode node = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;EUTreeNode&lt;/span&gt;();
            node.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;());
            node.&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
            node.&lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getIsParent&lt;/span&gt;()?&lt;span class=&quot;st&quot;&gt;&quot;closed&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;open&quot;&lt;/span&gt;);
            resultList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(node);
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;No redis cache Time : &quot;&lt;/span&gt; + (System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - startTime));
        &lt;span class=&quot;co&quot;&gt;// 向redis缓存中添加内容&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            jedisClientSingle.&lt;span class=&quot;fu&quot;&gt;hset&lt;/span&gt;(CATEGROY_ID_CACHE_REDIS_KEY, parentId.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;(), JsonUtils.&lt;span class=&quot;fu&quot;&gt;objectToJson&lt;/span&gt;(productCategories));
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; resultList;
    }

    &lt;span class=&quot;co&quot;&gt;// 后面的内容看源码...&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/tree/master/Redis&quot; class=&quot;uri&quot;&gt;https://github.com/ITDragonBlog/daydayup/tree/master/Redis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里，Redis 的快速入门就结束了。下一章节介绍Redis 的主从和集群。&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 15:42:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/7897131.html</dc:identifier>
</item>
<item>
<title>来手撸一个小小小小小&quot;3D引擎&quot; - assassinx</title>
<link>http://www.cnblogs.com/assassinx/p/7896478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/assassinx/p/7896478.html</guid>
<description>&lt;p&gt;开始的唠叨&lt;/p&gt;
&lt;p&gt;说是3D引擎确实有点过于博眼球了，其实就是实现了一个透视投影，当然也不是那么简单的。 此篇文章是纯粹给小白看的 高手请勿喷 。也称之为小向带你图形学入门基础 。 哇哈哈哈哈 一说到做一个3D画面的东东 一说总是到DirectX  OpenGL 这些玩意儿 我们这些菜鸟总是 想到哇擦擦 哇C++的   哇 计算机图形学好难。这玩意儿难度好大。其实就那么回事儿 ，DirectX OpenGL 只是工具 而已， 只要把原理搞懂了 你看我用low逼的GDI照样给你绘制一个3D物体 可以这样说即使不用GDI 其他任何能划线 画点的东西 ，我在安卓平台上照样给你实现这个效果。不要局限于工具 谁说做3D就只能用DirectX OpenGL了 ，谁说做3D只能用C++了  。&lt;/p&gt;

&lt;p&gt;顶点数据展现&lt;/p&gt;
&lt;p&gt;首先是3D编程中通用的数据展现 那就是顶点组成的网格数据 称之为mesh， 3个点为一组  组成的三角面片数据。三个点顺时针的方向那么 箭头方向为外表面 另一面为内表面 ，在绘制的时候 内表面不可见。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125215040562-1569414831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;好那么我们也以此方式来定义数据 ，我们定义的东西是一个 中心位置在( 0,0，-130)处的立方体。我们的观察点在(0, 0, 0)处 正对着立方体观察。 由于我们想让立方体一个面的颜色相同，所以是两个为一组定义的 ，当然三角形也是以同样的 两个为一组 组成一个正方形面。由此对物体表面空间点的描述数据就做好了。&lt;br/&gt;好 ，定义数据的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;93&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Marsh
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; List&amp;lt;Point3dF&amp;gt;&lt;span&gt; points;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Marsh()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 points = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Point3dF&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                 Point3dF pointA = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 Point3dF pointB = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 Point3dF pointC = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 Point3dF pointD = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 Point3dF pointE = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 Point3dF pointF = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 Point3dF pointG = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 Point3dF pointH = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                points.Add(pointA);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                points.Add(pointB);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                points.Add(pointC);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                points.Add(pointD);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                points.Add(pointE);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                points.Add(pointF);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                points.Add(pointG);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                points.Add(pointH);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;                 
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;                 path1 = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;() { 
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     &lt;span&gt;5&lt;/span&gt; ,&lt;span&gt;2&lt;/span&gt; ,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     &lt;span&gt;1&lt;/span&gt; ,&lt;span&gt;3&lt;/span&gt; ,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                     &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;7&lt;/span&gt; ,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                    ,
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                     &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; ,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                };
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;                 faceColors = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Brush&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 Random rdm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;6&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     Brush b= &lt;span&gt;new&lt;/span&gt; SolidBrush(Color.FromArgb(rdm.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;), rdm.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;), rdm.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Brush b = new SolidBrush(Color.FromArgb(266 / 6 * i, 266 / 6 * i, 266 / 6 * i));&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                    faceColors.Add(b);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                    faceColors.Add(b);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; List&amp;lt;Brush&amp;gt;&lt;span&gt; faceColors;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; path1;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于透视投影 和顶点绘制&lt;/p&gt;
&lt;p&gt;我数学底子差 在写这个例子之前参考了很多前辈的 图形学理论基础。最主要是透视投影 和3D旋转矩阵绕任意轴旋转 。甚至没完全搞懂 于是我就抄起代码开搞了。 不得不说这玩意儿真的很有意思。&lt;br/&gt;首先是透视投影：http://blog.csdn.net/popy007/article/details/1797121&lt;br/&gt;作者讲的很详细 其实我只看到一半 ，后面矩阵推导那些太难了 没有继续往下啃 。视线是一个发散的方式从一个点出去 （其实最后发现不用管什么视椎体不视椎体的）。 假设视点前面有一张半透明的纸张 视线上的点是怎么打到纸张上的？关于这个问题  你要粗暴点确实很简单 就是三角形 初中的知识。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125215710437-782610699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就如开始所述 视点在(0,0,0) 处看向 位于(0,0,-130) 的立方体  ，假设有一架摄像机  ，那么上图就是他的从空中看下去的俯视图。设p为(x,z)　　p'为(x' ,z') 。则x'=-N(x/z)  y'=-N(y/z)。为了方便 我们的数据定义也是跟示意图上差不多的。于是我们依葫芦画瓢 把所有的点绘制出来 包装成一个paint函数。&lt;br/&gt;需要注意的是平面坐标系 跟屏幕坐标之间的转换 ，其实不难 你其他计算应用数学公式 数学函数 还是一样该咋算咋算。  完成后我们平面坐标系的0,0  对应屏幕坐标的0,0   。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125220959171-520820594.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125221017593-296350008.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;看到没 x轴0左边也是负数 不用管  就只是y的符号不一样 变成-y就可以了。然后要让他显示在窗口中间  还要进行偏移 就是x加偏移， y加偏移  就这样就完成啦 。  哈哈哈哈哈。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; paint()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             Graphics gph = Graphics.FromHwnd(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Handle);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            gph.Clear(Color.Lavender);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行到屏幕坐标的映射(x y z)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p~ =(-n x/z       -n y/z      -n)&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             PointF screenLastPoint=&lt;span&gt; PointF.Empty;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; msh.path1.Count / &lt;span&gt;3&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (i &amp;gt;= 4)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 PointF screenPointA = &lt;span&gt;new&lt;/span&gt; PointF((&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]].x / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]].z)) , (&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]].y / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]].z))  );
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 PointF screenPointB = &lt;span&gt;new&lt;/span&gt; PointF((&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;]].x / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;]].z)) , (&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;]].y / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]].z))  );
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 PointF screenPointC = &lt;span&gt;new&lt;/span&gt; PointF((&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;]].x / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;]].z))  , (&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;]].y / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]].z))  );
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;                 screenPointA.Y = -&lt;span&gt;screenPointA.Y;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 screenPointB.Y = -&lt;span&gt;screenPointB.Y;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 screenPointC.Y = -&lt;span&gt;screenPointC.Y;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;                 screenPointA.Y=screenPointA.Y+&lt;span&gt;offsety;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 screenPointB.Y= screenPointB.Y+&lt;span&gt;offsety;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 screenPointC.Y = screenPointC.Y +&lt;span&gt; offsety;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;                 screenPointA.X = screenPointA.X +&lt;span&gt; offsetx;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 screenPointB.X = screenPointB.X +&lt;span&gt; offsetx;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 screenPointC.X = screenPointC.X +&lt;span&gt; offsetx;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;                 System.Drawing.Drawing2D.GraphicsPath ph = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Drawing.Drawing2D.GraphicsPath(
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PointF[] { screenPointA, screenPointB, screenPointC },
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                    System.Drawing.Drawing2D.FillMode.Winding);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---求法向量及夹角 如果为true 则渲染面&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算当前管线三角面片的法向量 是否朝着镜头 ，最终决定是否可见&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (angelCalc(msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]], msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;]], msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;]]) == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                    gph.FillPath(msh.faceColors[i], ph);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制边框&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             gph.DrawLine(Pens.Red, &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             gph.DrawLine(Pens.Red,  &lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;),&lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety + &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             gph.DrawLine(Pens.Red, &lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety +&lt;span&gt;36&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety + &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             gph.DrawLine(Pens.Red, &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety + &lt;span&gt;36&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/绘制网格线&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;screenLastPoint = PointF.Empty;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for (int i = 0; i &amp;lt; msh.path1.Count / 3; i++)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (i &amp;gt;= 4)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PointF screenPointA = new PointF((float)((-nearPlan) * (msh.points[msh.path1[i * 3]].x / msh.points[msh.path1[i * 3]].z)), (float)((-nearPlan) * (msh.points[msh.path1[i * 3]].y / msh.points[msh.path1[i * 3]].z)));
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PointF screenPointB = new PointF((float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 1]].x / msh.points[msh.path1[i * 3 + 1]].z)), (float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 1]].y / msh.points[msh.path1[i * 3 + 1]].z)));
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PointF screenPointC = new PointF((float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 2]].x / msh.points[msh.path1[i * 3 + 2]].z)), (float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 2]].y / msh.points[msh.path1[i * 3 + 2]].z)));
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointA.Y = -screenPointA.Y;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointB.Y = -screenPointB.Y;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointC.Y = -screenPointC.Y;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointA.Y = screenPointA.Y + offsety;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointB.Y = screenPointB.Y + offsety;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointC.Y = screenPointC.Y + offsety;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointA.X = screenPointA.X + offsetx;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointB.X = screenPointB.X + offsetx;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointC.X = screenPointC.X + offsetx;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    gph.DrawLine(Pens.Red, screenPointA, screenPointB);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    gph.DrawLine(Pens.Red, screenPointB, screenPointC);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    gph.DrawLine(Pens.Red, screenPointC, screenPointA);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;绕着坐标轴进行旋转  &lt;/p&gt;
&lt;p&gt;最开始我没有绘制面只是绘制的顶点线框而已 。然后我想做的是旋转  让他转起来，总共八个点连成线就是立方体了，哪怕是low逼的线条 只要转起来是不是就有立方体的样子了。  哇哈哈哈哈。最开始我想的很简单啊 立体的旋转也没啥不得了的啊 ，比如饶y轴旋转 我把他当成平面的不就得了么 y不变x和z变。 绕x轴旋转 同理。 我原来也写过平面的点进行旋转的计算。 为了符合图形学上的标准方式 最后我还是使用二维矩阵旋转的方式： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RotationTest2()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维空间旋转矩阵为 ： x是角度
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cos(x)  -sin(x)   (1-cos(x))tx+ty*sin(x))  x
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Sin(x) cos(x)     (1-cos(x))ty-tx*sin(x)) y
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2pi 等于360度
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绕y轴旋转
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;double xita = ((Math.PI * 2d) / 360d) * 2d;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; xita = ((Math.PI * 2d) / 360d) *&lt;span&gt; anglex;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cosx =&lt;span&gt; Math.Cos(xita);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; sinx =&lt;span&gt; Math.Sin(xita);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; xitay = ((Math.PI * 2d) / &lt;span&gt;360&lt;/span&gt;) *&lt;span&gt; angley;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cosy =&lt;span&gt; Math.Cos(xitay);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; siny =&lt;span&gt; Math.Sin(xitay);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; msh.points.Count; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF tmpPoint = new Point3dF(msh.points[i].x, msh.points[i].y, msh.points[i].z);&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 Point3dF tmpPoint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(mshSource.points[i].x, mshSource.points[i].y, mshSource.points[i].z);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 msh.points[i].x =
&lt;span&gt;24&lt;/span&gt;                     tmpPoint.x * cosx + ((-sinx) * tmpPoint.z) +
&lt;span&gt;25&lt;/span&gt;                 (((1d - cosx) * 0d) + ((-130d) *&lt;span&gt; sinx));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;                 msh.points[i].z =
&lt;span&gt;28&lt;/span&gt;                     tmpPoint.x * sinx + (cosx * tmpPoint.z) +
&lt;span&gt;29&lt;/span&gt;                     (((1d - cosx) * (-130d)) - ((0d) *&lt;span&gt; sinx));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;                 msh.points[i].y =&lt;span&gt; tmpPoint.y;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------------&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                 tmpPoint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(msh.points[i].x, msh.points[i].y, msh.points[i].z);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;                 msh.points[i].y = tmpPoint.y * cosy + ((-siny) * tmpPoint.z) +
&lt;span&gt;37&lt;/span&gt;                 (((1d - cosy) * 0d) + ((-130d) *&lt;span&gt; siny));
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;                 msh.points[i].z = tmpPoint.y * siny + (cosy * tmpPoint.z) +
&lt;span&gt;40&lt;/span&gt;                     (((1d - cosy) * (-130d)) - ((0d) *&lt;span&gt; siny));
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意了 绕着任意轴进行旋转&lt;/p&gt;
&lt;p&gt;现在我想做的是做一个跟踪球效果 。鼠标按下拖动的时候让物体 像烤肉串样绕着一根轴旋转。 网上跟踪球都是旋转相机 我们这里直接旋转物体坐标。绕着任意轴旋转啊绕着任意轴旋转的矩阵 说实话 3D旋转矩阵这个我搞不懂 ，我看不懂推导过程 但是我会看公式 哇哈哈哈哈。&lt;br/&gt;https://www.cnblogs.com/graphics/archive/2012/08/10/2627458.html&lt;br/&gt;其他的博文里贴出来的旋转矩阵也是这样 直接把他的代码抄下来之  ，c++的 我抄成c#的 没啥难的 我已经超过好些c++代码了。总之我们要做的就是 得出一个二维数组作为矩阵回传 让所有坐标根据此矩阵进行运算。注意有两个基本概念：  两个点相减 a-b  得出的是 b到a 的向量 (0,0) -(1,1)  =(-1,-1)  ，然后是向量归一化： 什么叫归一化， 就是 把向量的方向不变 长度变到单位长度 ，也就是1。问向量归一化怎么搞  。好 ，比如一个二维向量，计算原理就是通过距离计算公式&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125223044390-971885070.png&quot; alt=&quot;&quot;/&gt;得出距离。这个距离与1的比值等于 现x与归一化后x的比值：&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125223658468-749414512.png&quot; alt=&quot;&quot;/&gt;求归一化后y的值同理。当然这些都是基础的没什么特别说的。&lt;br/&gt;求旋转矩阵的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到旋转矩阵&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;double&lt;/span&gt;[,] RotateArbitraryLine(Point3dF v1, Point3dF v2, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; theta)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; a =&lt;span&gt; v1.x;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; b =&lt;span&gt; v1.y;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; c =&lt;span&gt; v1.z;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             Point3dF p = &lt;span&gt;new&lt;/span&gt; Point3dF(v2.x - v1.x, v2.y - v1.y, v2.z -&lt;span&gt; v1.z);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;v2归一化&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; x_p2 = p.x / Math.Sqrt(Math.Pow(p.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(p.y, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; y_p2 = p.y / Math.Sqrt(Math.Pow(p.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(p.y, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;.IsNaN(x_p2))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 x_p2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;.IsNaN(y_p2))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 y_p2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; u =&lt;span&gt; x_p2;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; v =&lt;span&gt; y_p2;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; w = 0d;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -130d;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0d;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; uu = u *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; uv = u *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; uw = u *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; vv = v *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; vw = v *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; ww = w *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; au = a *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; av = a *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; aw = a *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; bu = b *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; bv = b *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; bw = b *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cu = c *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cv = c *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cw = c *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; costheta =&lt;span&gt; Math.Cos(theta);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; sintheta =&lt;span&gt; Math.Sin(theta) ;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt;[,] pOut = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = uu + (vv + ww) *&lt;span&gt; costheta;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = uv * (&lt;span&gt;1&lt;/span&gt; - costheta) + w *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = uw * (&lt;span&gt;1&lt;/span&gt; - costheta) - v *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                   
&lt;span&gt;46&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = uv * (&lt;span&gt;1&lt;/span&gt; - costheta) - w *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = vv + (uu + ww) *&lt;span&gt; costheta;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = vw * (&lt;span&gt;1&lt;/span&gt; - costheta) + u *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                   
&lt;span&gt;51&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = uw * (&lt;span&gt;1&lt;/span&gt; - costheta) + v *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = vw * (&lt;span&gt;1&lt;/span&gt; - costheta) - u *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = ww + (uu + vv) *&lt;span&gt; costheta;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                   
&lt;span&gt;56&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = (a * (vv + ww) - u * (bv + cw)) * (&lt;span&gt;1&lt;/span&gt; - costheta) + (bw - cv) *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = (b * (uu + ww) - v * (au + cw)) * (&lt;span&gt;1&lt;/span&gt; - costheta) + (cu - aw) *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = (c * (uu + vv) - w * (au + bv)) * (&lt;span&gt;1&lt;/span&gt; - costheta) + (av - bu) *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pOut;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;函数写好了 矩阵也能得出了，还有个问题：函数的那几个参数 ，旋转的度数也好搞 按下的时候记录一个点 拖动的时候计算跟他的距离 距离作为度数 拖动50像素 旋转50度。 旋转的那根儿轴你怎么得出来，开始点容易 立方体的中心是0 0 -130  。按下的时候记录了按下开始点 鼠标的移动就已经是一个向量了 所以我们只需要对这个向量 绕z轴进行90度旋转 ，z也设成-130 就跟中心点平齐了 就是需要的烤肉串儿的旋转轴了。 好 原理讲完了 ，代码走起：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Form1_MouseMove(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, MouseEventArgs e)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须要得出旋转的轴才行&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pressed)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中心点 0,0,-130
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过拖动远近决定旋转角度，垂直向量 得到旋转轴
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得出鼠标拖动向量 &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;                 Point3dF dragJuli = &lt;span&gt;new&lt;/span&gt; Point3dF((e.Location.X - startPoint.X),( e.Location.Y - startPoint.Y),-&lt;span&gt;130d);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还要旋转90度才是真正的旋转轴
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cos(x)  -sin(x)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Sin(x) cos(x)  &lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;double&lt;/span&gt; cos90=&lt;span&gt;0d;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;double&lt;/span&gt; sin90=&lt;span&gt;1d;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; x = dragJuli.x * 0d + dragJuli.y *&lt;span&gt; 1d;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; y = dragJuli.x * 1d + dragJuli.y *&lt;span&gt; 0d;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;                 Point3dF dragJuli2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(x, y, dragJuli.z);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF dragJuli90=
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;x1 x2+y1 y2=0
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;double x2=(-dragJuli.y)/(dragJuli.x);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;垂直的旋转轴向量
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF roll = new Point3dF(x2, 1, -130);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拖动距离 拖动距离等于角度&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                 angelourua= Math.Sqrt(Math.Pow((e.Location.X - startPoint.X), &lt;span&gt;2&lt;/span&gt;) + Math.Pow((e.Location.Y - startPoint.Y), &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 angelourua = angelourua % &lt;span&gt;360&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 angelourua = ((Math.PI * 2d) / 360d) *&lt;span&gt; angelourua;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;double&lt;/span&gt;[,] roatMatarix= RotateArbitraryLine(&lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, -&lt;span&gt;130d), dragJuli2,angelourua);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                RotationTest(roatMatarix);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                paint();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好就这样 先进行3d空间的点旋转， 再进行平面坐标映射绘制 用线连起来。是不是就有点3D立体的样子了。哇哈哈哈哈&lt;/p&gt;
&lt;p&gt; 注意了 面绘制&lt;/p&gt;
&lt;p&gt;前面的都是有些挖的别人的，这个功能绝对是自己捣鼓出来的。开始那些不论是两两之间的线条绘制啥的都只能算是 点绘制  ，我们现在要进行面绘制。首先你要清楚的是我的顶点三角面片数据已经给出了， 3d坐标点打在半透明纸张上 的x，y 也已经得出了。 调用gdi的fillpath按ABC 的顺序连起来 就能绘制一个三角面片 是不是很简单。但是先别慌 还有两个问题需要处理，一个就是可见面判别。 就是两个三角面片 的位置 决定了 在透视投影的时候哪个在前哪个在后， 还有面相交的情况呢 ？ 是不是很复杂？其实根本不用管，即使要管 只要你使用z缓冲算法 也不是很复杂 zbuffer 。就是在求出屏幕x y过后把同xy的点z越靠近视点的放在前面 这样就达到目的了。这里我们先 不管这个zbuffer算法  下次有空闲了我们再来写。这里我们使用另外一种方式 通过判别正向面与后向面来达到目的。前面我们不是说了吗 ：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125215040562-1569414831.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们通过计算每个三角面片的法向量， 然后我们有一个视点到三角面片的向量 ，通过计算两向量的点积  &lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125225730328-262725811.png&quot; alt=&quot;&quot;/&gt;然后通过反余弦函数就可以得出两向量的夹角 。 如果夹角大于90度代表三角面片正向面朝着视点， 如果小于90度代表正向面背对了视点， 则不对这个三角面片进行渲染。如此一来 你仔细想想 我们的立方体至始至终不会存在一个面把另一个面遮挡的情况。&lt;br/&gt;好了原理讲至此 好下面 根据原理撸代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;平面是否面向摄像机的判别&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; angelCalc( Point3dF A,Point3dF B,Point3dF C)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;https://zhidao.baidu.com/question/810216091258785532.html&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AB、AC所在平面的法向量即AB×AC=(a,b,c),其中：
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a=(y2-y1)(z3-z1)-(z2-z1)(y3-y1)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b=(z2-z1)(x3-x1)-(z3-z1)(x2-x1)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;c=(x2-x1)(y3-y1)-(x3-x1)(y2-y1)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先得出点 对应的向量
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF AB = new Point3dF(B.x - A.x, B.y - A.y, B.z - A.z);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先求出法向量&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; a = ((B.y - A.y)*(C.z - A.z) - (B.z - A.z)*(C.y -&lt;span&gt; A.y));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; b = (B.z - A.z) * (C.x - A.x) - (C.z - A.z) * (B.x -&lt;span&gt; A.x);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; c = (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y -&lt;span&gt; A.y);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             Point3dF bb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(a, b, c);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;套公式 第二册 下b 39  通过两向量的cos函数 继而通过反余弦得出角度&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; angelPlan =&lt;span&gt;Math.Acos(
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 (A.x * bb.x + A.y * bb.y + A.z * bb.z) /&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                Math.Sqrt(Math.Pow(A.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(A.y, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(A.z, &lt;span&gt;2&lt;/span&gt;)) *
&lt;span&gt;22&lt;/span&gt;                Math.Sqrt(Math.Pow(bb.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(bb.y, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(bb.z, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;               )
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;               );
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (angelPlan &amp;gt; (Math.PI / &lt;span&gt;2&lt;/span&gt;))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;法向量与镜头的夹角大于90度 代表三角面片面向摄像机 则可见&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则不可见&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于光照&lt;/p&gt;
&lt;p&gt;光照这玩意儿还是 用到三角面片的法向量 ，三角面片正对着光 则表面亮度最高 ，垂直则变成黑暗。参照面绘制的原理就可以搞出来 我这里就每个面各用些五颜六色的颜色算了吧 懒得整了。&lt;/p&gt;
&lt;p&gt;其他的&lt;/p&gt;
&lt;p&gt;还有我的摄像机镜头是固定的 ，其实还有很多工作需要做  。 希望各位大大继续完善。看下效果 是不是有模有样：上个gif图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125232626546-2022770934.gif&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;你可以把平面面向摄像机判别函数返回的值反向一下看看什么效果，是不是看到内壁的那一面了 是不是很神奇哇哈哈哈哈&lt;br/&gt;是的你没看错就这么几百行核心部分就实现了  差不多都是数学知识 ，其他的都是添砖加瓦的事，原理都在这了。 好了 以后再看DirectX 啊OpenGL啊 图形学 变换矩阵啊那些的 别被唬住了 没那么难的。&lt;br/&gt;按说的话这些知识总体来说蛮难的 但是毕竟还是学过高中的向量  两向量垂直时点积等于零 这些之类的  ， 靠着摸着石头过河 把这些半懂不懂的知识 拼凑起来 加上各种度娘 和查资料 来实现 没想到竟然成功了。 意外意外  ，当然学习是要靠自己的  你想直接度娘给你出来个你要的效果 那是不可能的。&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 15:38:00 +0000</pubDate>
<dc:creator>assassinx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/assassinx/p/7896478.html</dc:identifier>
</item>
<item>
<title>Entity Framework——常见报错总结 - 甜橙很酸</title>
<link>http://www.cnblogs.com/hdwgxz/p/7897031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hdwgxz/p/7897031.html</guid>
<description>&lt;p&gt;1 &lt;strong&gt;&lt;span&gt;实体属性配置为&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;IsRequired()&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;对更新的影响&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;抛出异常类型&lt;/span&gt;DbEntityValidationException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;表结构：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125225446000-1348712507.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;实体：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 账号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Account { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮箱
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 昵称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Nickname { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 头像
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AvatarId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 记录插入时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime InsertTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 记录修改时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime UpdateTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;实体配置：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　　　　　　modelBuilder.Entity&amp;lt;User&amp;gt;().Property(u =&amp;gt;&lt;span&gt; u.Account)
                .IsRequired()
                .IsUnicode(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                .HasMaxLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
            modelBuilder.Entity&lt;/span&gt;&amp;lt;User&amp;gt;().Property(u =&amp;gt;&lt;span&gt; u.Email)
                .IsRequired()
                .IsUnicode(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                .HasMaxLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            modelBuilder.Entity&lt;/span&gt;&amp;lt;User&amp;gt;().Property(u =&amp;gt;&lt;span&gt; u.Nickname)
                .IsUnicode(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                .HasMaxLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
            modelBuilder.Entity&lt;/span&gt;&amp;lt;User&amp;gt;().Property(u =&amp;gt;&lt;span&gt; u.AvatarId)
                .IsOptional()
                .HasMaxLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;CustomDbContext&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;继承自&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;DbContext&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[DbConfigurationType(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MySqlEFConfiguration))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomDbContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CustomDbContext()
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name=Master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Configuration.LazyLoadingEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DropCreateDatabaseIfModelChanges
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new DropCreateDatabaseAlways&amp;lt;CustomDbContext&amp;gt;()&lt;/span&gt;
            Database.SetInitializer&amp;lt;CustomDbContext&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;User&amp;gt; Users { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(DbModelBuilder modelBuilder)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(modelBuilder);
            EntityConfiguration.Set(modelBuilder);
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;更新操作：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
{
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User 
                    {
                        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@1622.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行操作，报错信息如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125225655281-86711460.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看&lt;/span&gt;EntityValidationErrors&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只能看到&lt;/span&gt;{System.Data.Entity.Validation.DbEntityValidationResult}&lt;span&gt;，没有更详细的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果将上述代码用&lt;/span&gt;try..catch&lt;span&gt;包起来，如下写法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行代码&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (DbEntityValidationException ex)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; e =&lt;span&gt; ex.EntityValidationErrors;
}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;一层一层地打开，看到真正导致异常的原因，看到下面的截图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125225840750-867443493.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析实体配置发现，&lt;/span&gt;Account&lt;span&gt;属性被设置为&lt;/span&gt;IsRequired&lt;span&gt;，那么在更新实体的时候，即使不更新这个字段，也要给这个字段赋值，那么赋值后观察：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更新操作代码变为&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
                {
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User 
                    {
                        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@1622.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Account &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
                }        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;经过上述调整后，更新成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么换一个思路，将&lt;/span&gt;Account&lt;span&gt;属性被设置为&lt;/span&gt;IsOptional()&lt;span&gt;是不是也可以呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;实体配置，将&lt;/span&gt;Account&lt;span&gt;属性设置按如下修改，并注掉上面的&lt;/span&gt;Account = &quot;a&quot;&lt;/p&gt;
&lt;p&gt;modelBuilder.Entity&amp;lt;User&amp;gt;().Property(u =&amp;gt; u.Account)&lt;/p&gt;
&lt;p&gt;                .IsOptional()&lt;/p&gt;
&lt;p&gt;                .IsUnicode(false)&lt;/p&gt;
&lt;p&gt;                .HasMaxLength(50);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行测试，更改成功。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;得出结论：在实体配置时，指定了为必选的字段，那么更新操作时，构造实例一定要对必选（&lt;/span&gt;IsRequired()&lt;span&gt;）字段赋值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上述测试中还有一个值得考虑的细节，构造&lt;/span&gt;User实例的时候，只对Id,Email进行了赋值，而没有对其他属性进行赋值，那么为什么会成功呢？那么必定是未进行任何设置的实体属性默认是IsOptional()&lt;span&gt;。这跟表结构中的字段类型设置为&lt;/span&gt;Not Null有无关联呢，从测试结果看就本类应用无必然联系。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;a.实体配置中指定了实体属性为IsRequired()&lt;span&gt;，更新操作构造类的实例时必对此属性赋值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;b.不进行配置的实体属性默认为IsOptional()&lt;/p&gt;
&lt;p&gt;c.&lt;span&gt;表结构中字段是否为&lt;/span&gt;Not Null对上述规则无影响。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 更新报错：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;An object with the same key already exists in the ObjectStateManager. The ObjectStateManager cannot track multiple objects with the same key.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;异常类型：&lt;/span&gt;System.Data.Entity.Infrastructure.DbUpdateConcurrencyException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实体属性配置如上例所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作代码：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
                {
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User 
                    {
                        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@132.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    User user1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User
                    {
                        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@132.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry1 = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user1);
                    entry1.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry1.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
                }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;执行操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125230022828-936003490.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;涉及到两次修改操作，两次操作构造了两个实例，但是实例的属性&lt;/span&gt;Id&lt;span&gt;有相同的值。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果两次操作的是同一个实例，而不是不同的实例，那么不会抛出异常，代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
                {
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User 
                    {
                        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@132.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry1 = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry1.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry1.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3 &lt;strong&gt;&lt;span&gt;未给主键赋值或赋给主键一个不存在的值，抛出异常&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;System.Data.Entity.Infrastructure.DbUpdateConcurrencyException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作代码如下，其中&lt;/span&gt;Id=1这条语句被注掉，Id是主键：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
                {
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User 
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Id = 1,&lt;/span&gt;
                        Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@132.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
                }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行上述代码，抛出异常信息如下，注意异常类型居然是&lt;/span&gt;System.Data.Entity.Infrastructure.DbUpdateConcurrencyException，看上去像是并发问题，但实际却不是！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Message:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Store update, insert, or delete statement affected an unexpected number of rows (0). Entities may have been modified or deleted since entities were loaded. Refresh ObjectStateManager entries.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125230131265-1225355712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;赋给主键一个不存在的值，令&lt;/span&gt;Id=4(在数据库表中不存在Id为4的一条记录)抛出的异常与上面的相同。&lt;/p&gt;

&lt;p&gt;4 &lt;strong&gt;&lt;span&gt;字段超长抛出异常：&lt;/span&gt;System.Data.Entity.Validation.DbEntityValidationException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表中&lt;/span&gt;Nickname &lt;span&gt;字段定义为&lt;/span&gt;50个字符，现在赋值超过50。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作代码如下&lt;/span&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
                {
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User
                    {
                        Id &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@132.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Nickname &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateError&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行程序报错：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125230228984-503881830.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一层一层点开，查看具体原因：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125230353593-1287100658.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; -----------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;global-zeroclipboard-html-bridge&quot; class=&quot;global-zeroclipboard-container&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;转载与引用请注明出处。&lt;/p&gt;
&lt;p&gt;时间仓促，水平有限，如有不当之处，欢迎指正。&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Sat, 25 Nov 2017 15:06:00 +0000</pubDate>
<dc:creator>甜橙很酸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hdwgxz/p/7897031.html</dc:identifier>
</item>
<item>
<title>匿名内部类之白话文版 - 程序猿伊桑</title>
<link>http://www.cnblogs.com/ethan0603/p/7896994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ethan0603/p/7896994.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　匿名内部类对于很多刚入门的新手来说，都是一个很难跨越的坎，不是说这东西有多难，主要是这东西太饶，那么我们如何才能征服这小妖精呢？其实最重要的是搞懂三个明确：&lt;/span&gt;1.&lt;span&gt;匿名内部类是存在在外部内的成员方法内的，换句话说匿名内部类它首先得是一个局部内部类；&lt;/span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;匿名内部类必须实现一个接口或继承一个类&lt;/span&gt; &lt;span&gt;3.&lt;/span&gt;&lt;span&gt;第三个明确是在第二个明确基础上的，就是匿名内部类它实质也就是它继承的类或者实现接口的匿名子类对象，注意注意，它本质是一个子类对象！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实看代码会觉得匿名内部类的格式很复杂，各种花括号小括号分号缠绕在一块，如果用文字表达，看上去就清晰很多了：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　new 父类(或接口){ 子类内容 }。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　根据上面的解释，好像对于匿名内部类有一点点了解了，那么我们就去试一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　要有匿名内部类，我们首先得创建一个接口或类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbsClass{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method(){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(&quot;我是抽象类的method&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　然后我们创建一个外部类，在外部类的成员方法内定义匿名内部类（就是之前提到的三个明确之一，匿名内部类首先得是一个局部内部类）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Outer{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method(){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         System.out.println(&quot;我是外部类的method&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; AbsClass() {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new出来的这整个代码块，其实就代表匿名内部类，实际上也就是父类或接口的子类对象。所以，我们可以当然可以在new代码块之后用.方法名来调用本类方法&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 System.out.println(&quot;我是内部类的show&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }.show();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当然我们也可以创建一个父类或接口引用指向这个匿名内部类(也就是匿名子类对象),然后用变量名来调用方法，这是比较常用的&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         AbsClass abs1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AbsClass() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 System.out.println(&quot;我是通过变量名调用的内部类的show&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        abs1.show();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;创建测试类对其进行测试：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; 匿名内部类Test01 {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Outer().method();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;　　其实现在要理解起来就会轻松很多，我要使用匿名内部类，其实就是创建某个类或者接口的子类对象而已，只不过这个子类对象稍微特殊一点，它匿名罢了。那么匿名内部类到底会在哪些地方被应用到呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当方法参数是接口或抽象类类型时，可以使用匿名内部类作为实际参数作为传递&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;这也是动态代理的主要操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面用代码来进行分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先定义一个类或接口&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Inter{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show1();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show2();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　然后创建外部类，在外部类的成员方法内创建匿名内部类：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; 匿名内部类Test02 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show(Inter in){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当一个方法定义时的形参是一个引用类型，那么它实际上是需要这个类或&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;者其子类或实现的对象，这个我们应该很清楚&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        in.show1();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        in.show2();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;          &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 当我们以前看到这个show()方法参数是一个引用类型数据时，都是会去创建他的对象作为实际参数传递
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;         * 如果是接口或者抽象类，我们就创建其子类对象作为实参进行传递，
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;         * 但现在我们知道了匿名内部类的实质，也就是父类或接口的匿名子类对象，我们就可以将匿名内部类作为参数传递了，因为他实际上也是对象啊
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;         * 我们只是需要在传递过程中完成对其父类抽象方法的重写即可
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         show(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inter() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show2() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 System.out.println(&quot;我是匿名内部类的show1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show1() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 System.out.println(&quot;我是匿名内部类的show2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　我们现在都知道匿名内部类有两种调用自己内部方法的形式了，一种是用匿名对象调用，也就是在&lt;/span&gt;new&lt;span&gt;代码块后面直接&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;方法名；另一种则是通过父类引用来调用方法，那么他们到底有什么区别呢？&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; 匿名对象类Demo03 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Outer03().method();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Inter03{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show1();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show2();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Outer03{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method(){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inter03() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show2() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 System.out.println(&quot;show1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show1() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 System.out.println(&quot;show2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show3(){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 System.out.println(&quot;我不是重写父类方法，我是自己的方法show3&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         }.show3();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样子我是能调用我自己的方法show()3的,此时我又想调用里面的多个方法，所以我就想到了通过父类引用来给这个子类对象赋变量名，于是...&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         Inter03 inter03=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inter03() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show2() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 System.out.println(&quot;show1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show1() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 System.out.println(&quot;show2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show3(){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 System.out.println(&quot;我不是重写父类方法，我是自己的方法show3&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;inter03.show3();于是，我们很明显看到这里报错了，为什么呢？
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为我们这里用父类引用指向子类对象，也就形成了多态，而多态中成员方法是完全按照父类中的执行的，不能执行子类特有方法，所以就报错了
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么为什么上面通过匿名内部类直接调用自己特有方法就可以呢？因为他本质是一个对象，当没有父类引用指向它时，它当然可以调用自己本身的方法&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　其实看过上面的代码，就能明白他们的区别了。用父类引用进行调用的时候，只能调用父类中本来定义过的方法，因为父类引用指向子类对象就是多态！多态！！这里是很多人会跳入陷阱的地方了，对于成员方法而言，不管是编译还是运行，都是从父类中找的，那么如果你通过这个引用调用匿名内部类中特有的方法，自然是不可能实现的啦！！然后我们通过匿名对象&lt;/span&gt;.&lt;span&gt;方法名的方法为什么就可以呢？因为它就是子类对象啊，它就死它自己啊，它并没有向上转型啊，自己当然可以调用自己的方法啊！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说的最简单的，匿名对象类一个前提，两个明确：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前提：必须定义接口或父类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　明确：&lt;/span&gt;1.&lt;span&gt;定义在成员方法内，是局部内部类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　2.&lt;span&gt;匿名内部类的本质是继承的父类或实现的接口的匿名子类对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果能想通这三个东西，对于理解使用匿名内部类也就没什么难度了。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 14:57:00 +0000</pubDate>
<dc:creator>程序猿伊桑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ethan0603/p/7896994.html</dc:identifier>
</item>
<item>
<title>IIFE（立即执行函数表达式） - liuyongjia</title>
<link>http://www.cnblogs.com/liuyongjia/p/7896923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyongjia/p/7896923.html</guid>
<description>&lt;p&gt;我们经常会看到这样的写法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;fuction&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// do something&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是一个简单的IIFE（立即执行函数表达式，immediately-invoked function expression）了。&lt;/p&gt;
&lt;p&gt;这样的写法有什么好处呢？来简单分析一下。&lt;/p&gt;
&lt;h2 id=&quot;开头的分号&quot;&gt;1. 开头的分号&lt;/h2&gt;
&lt;p&gt;我们都知道，js是可以加分号或者不加分号的，在某些情况下，不加分号会让解析器解析出错，举个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; 
    a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; b &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
(b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a)
&lt;span class=&quot;co&quot;&gt;// Uncaught TypeError: 3 is not a function&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解析代码的时候，a = b + 3和(b = a)这两条语句之间没有明确的分界，回车和空格会自动被忽略。解析器会认为这是一句。所以，此时会认为3是一个函数，b=a是他的参数。&lt;br/&gt;在知乎的&lt;a href=&quot;https://www.zhihu.com/question/20298345&quot;&gt;这个问题&lt;/a&gt;下，尤大做了解释。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;真正会导致上下行解析出问题的 token 有 5 个：括号，方括号，正则开头的斜杠，加号，减号。我还从没见过实际代码中用正则、加号、减号作为行首的情况，所以总结下来就是一句话：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。其实即使是这两种情况，在实际代码中也颇为少见。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ok，回到我们的例子，我们的例子就是以括号开头的，如果上一个语句没有加分号，很可能会出现这样问题，这个分号就是为了防止这样的情况发生，称之为防御性分号。&lt;/p&gt;
&lt;h2 id=&quot;function&quot;&gt;2. function(){}&lt;/h2&gt;
&lt;p&gt;函数有两种声明方式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; foo &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种声明方式的不同之处在于，使用var声明的函数不会自动提升到顶部。也就是说，不能在var声明函数的语句之前调用函数，否则会抛出undefined的错误。&lt;br/&gt;function () {}这种形式被称为匿名函数。匿名函数没有名字，也就是没有指针，是无法在其他地方调用的。&lt;br/&gt;将匿名函数赋值给foo，则可以通过foo来调用。&lt;br/&gt;当然还有办法调用它，就是例子中的两对括号。第一对括号将匿名函数包装成了一个表达式，而第二对括号意思就是立即执行它。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 报错 Uncaught SyntaxError: Unexpected token (&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// 返回函数定义 ƒ () {console.log('a')}，没有log&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)() &lt;span class=&quot;co&quot;&gt;// a&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;// 报错 Uncaught SyntaxError: Unexpected token )&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行，因为不是合法的声明方式，希望找到函数名的地方是‘(’，所以抛出了该异常。&lt;br/&gt;第二行，（）中的语句被当成了表达式，解析器会认为是var声明的方式。&lt;br/&gt;第三行，自执行。&lt;br/&gt;第四行，function foo() {console.log('a')}是正确的函数声明方式，被正确解析。接下来的一对括号依次解析，括号里需要有表达式，但是没有，所以会抛出这样的异常。&lt;/p&gt;
&lt;h2 id=&quot;好处&quot;&gt;3. 好处&lt;/h2&gt;
&lt;p&gt;IIFE的好处就是不会污染全局变量，就在当前的函数体的作用域下进行操作，保证了父作用域的干净，如果return出一些函数，那这些函数就形成了闭包。&lt;br/&gt;我们常用IIFE来写module。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; counter &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;( val )&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; val&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F&quot;&gt;维基百科：立即调用函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/20298345&quot;&gt;知乎：JavaScript 语句后应该加分号么？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 25 Nov 2017 14:36:00 +0000</pubDate>
<dc:creator>liuyongjia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyongjia/p/7896923.html</dc:identifier>
</item>
<item>
<title>Android音视频通话过程中最小化成悬浮框的实现（类似Android8.0画中画效果） - CKTim</title>
<link>http://www.cnblogs.com/cxk1995/p/7824375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxk1995/p/7824375.html</guid>
<description>&lt;p&gt;&lt;span&gt;关于音视频通话过程中最小化成悬浮框这个功能的实现，网络上类似的文章很多，但是好像还没看到解释的较为清晰的，这里因为项目需要实现了这样的一个功能，今天我把它记录下来，一方面为了以后用到便于自己查阅，一方面也给有需要的人提供一个思路，让大家少走弯路。这里我也是参考了些有关Android悬浮框的文章，再结合自己的理解所实现出来的，可能实现的方法不是最好，但是这或许也是一个可行的方案。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、实现效果（gif效果可能录制的不是特别好）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;http://images2017.cnblogs.com/blog/913913/201711/913913-20171112214644700-761711102.gif&quot; alt=&quot;&quot;/&gt;              &lt;img src=&quot;http://images2017.cnblogs.com/blog/913913/201711/913913-20171112215257216-13134648.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、实现思路&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于这个功能的实现其实不难，这里我把实现思路拆分为了两步：1、视频通话Activity的最小化。 2、视频通话悬浮框的开启&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;具体思路是这样的：&lt;span&gt;当&lt;/span&gt;&lt;span&gt;用户点击最小化按钮的时候，最小化我们的视频通话Activity（这时Activity处于后台状态），移除原先在Activity的视频画布（因为我用的是网易云信，这里他们只能允许一个视频画布存在，这里看情况要不要移除），于此同时，延时个几百毫秒，开启悬浮框，新建一个新的视频画布然后动态添加到悬浮框里面去，监听悬浮框的触摸事件，让悬浮框可以拖拽移动；监听悬浮框的点击事件，如果用户点击了悬浮框，则移除悬浮框里面新建的那个视频画布，然后重新调起我们在后台的视频通话Activity，紧接着新建一个新的视频画布重新动态的添加到Activity里面去。关于视频画布的添加移除方法，这里要看一下所接入的第三方SDK，如用的若是网易云信的SDK，他们的方法如下（下面摘自他们的SDK说明文档），也就是说移除画布我只需要传入null就行了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/913913/201711/913913-20171112224008950-761319050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.Activity是如何实现最小化的？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Activity最小化可能你没有听过，但是只要姿势对的话，其实实现起来非常简单，因为Activity本身就自带了一个moveTaskToBack(boolean nonRoot)，如果我们要实现最小化，只需要调用moveTaskToBack(true)传入一个true值就可以了，但是这里有一个前提，就是需要设置Activity的启动模式为singleInstance模式，两步搞定。（&lt;span&gt;注：这里先记住一个小知识点，就是activity最小化后重新从后台回到前台会回调onRestart()方法&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    public boolean moveTaskToBack(boolean nonRoot) {
        return super.moveTaskToBack(nonRoot);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.悬浮框是如何开启的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我把悬浮框的实现方法写在一个服务Service里面，将悬浮框的开启关闭与服务Service的绑定解绑所关联起来，开启服务即相当于开启我们的悬浮框，解绑服务则相当于关闭关闭的悬浮框，以此来达到更好的控制效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a. 首先我们声明一个服务类，取名为FloatVideoWindowService：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class FloatVideoWindowService extends Service {

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return new MyBinder();
    }

    public class MyBinder extends Binder {
        public FloatVideoWindowService getService() {
            return FloatVideoWindowService.this;
        }
    }

    @Override
    public void onCreate() {
        super.onCreate();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;b. 为悬浮框建立一个布局文件alert_float_video_layout，这里根据需求去写，如果只是像我上面gif那样，只需要悬浮框显示对方的视频画布，那么布局文件可以如下所示：（其中悬浮框大小我这里固定为长80dp，高110dp，id为small_size_preview的Linearlayout主要是一个容器，可以动态的添加view到里面去，也就是我们的视频画布）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;&amp;gt;

    &amp;lt;FrameLayout
        android:layout_width=&quot;80dp&quot;
        android:layout_height=&quot;110dp&quot;
        android:background=&quot;@color/black_1f2d3d&quot;&amp;gt;

        &amp;lt;LinearLayout
            android:id=&quot;@+id/small_size_preview&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            android:background=&quot;@color/transparent&quot;
            android:orientation=&quot;vertical&quot; /&amp;gt;
    &amp;lt;/FrameLayout&amp;gt;
&amp;lt;/LinearLayout&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;c. 布局定义好后，接下来就要对悬浮框做一些初始化操作了，初始化操作这里我们放在服务的onCreate()生命周期里面执行，因为只需要执行一次就行了。&lt;/span&gt;&lt;span&gt;这里的初始化主要包括对：&lt;span&gt;悬浮框的基本参数（位置，宽高等），悬浮框的点击事件以及悬浮框的触摸事件（即可拖动范围）等的设置&lt;/span&gt;，代码注释已经很清楚，直接看代码，如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class FloatVideoWindowService extends&lt;/span&gt;&lt;span&gt;&lt;span&gt; Service {
    private&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager mWindowManager;
    private&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams wmParams;
    private&lt;/span&gt;&lt;span&gt;&lt;span&gt; LayoutInflater inflater;

    //constant
    private boolean&lt;/span&gt;&lt;span&gt;&lt;span&gt; clickflag;

    //view
    private View mFloatingLayout;    //浮动布局
    private&lt;/span&gt;&lt;span&gt;&lt;span&gt; LinearLayout smallSizePreviewLayout; //容器父布局

    @Nullable
    @Override
    public&lt;/span&gt;&lt;span&gt;&lt;span&gt; IBinder onBind(Intent intent) {
        return new&lt;/span&gt;&lt;span&gt;&lt;span&gt; MyBinder();
    }

    public class MyBinder extends&lt;/span&gt;&lt;span&gt;&lt;span&gt; Binder {
        public&lt;/span&gt;&lt;span&gt;&lt;span&gt; FloatVideoWindowService getService() {
            return FloatVideoWindowService.this&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
        }
    }

    @Override
    public void&lt;/span&gt;&lt;span&gt;&lt;span&gt; onCreate() {
        super&lt;/span&gt;&lt;span&gt;&lt;span&gt;.onCreate();
        initWindow();//设置悬浮窗基本参数（位置、宽高等）
        initFloating();//悬浮框点击事件的处理
&lt;/span&gt;&lt;span&gt;&lt;span&gt;    }

    @Override
    public int onStartCommand(Intent intent, int flags, int&lt;/span&gt;&lt;span&gt;&lt;span&gt; startId) {
        return super&lt;/span&gt;&lt;span&gt;&lt;span&gt;.onStartCommand(intent, flags, startId);
    }

  
    @Override
    public void&lt;/span&gt;&lt;span&gt;&lt;span&gt; onDestroy() {
        super&lt;/span&gt;&lt;span&gt;&lt;span&gt;.onDestroy();
    }

    /**
     * 设置悬浮框基本参数（位置、宽高等）
     */
    private void&lt;/span&gt;&lt;span&gt;&lt;span&gt; initWindow() {
        mWindowManager =&lt;/span&gt;&lt;span&gt;&lt;span&gt; (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
        wmParams = getParams();//设置好悬浮窗的参数
        // 悬浮窗默认显示以左上角为起始坐标
        wmParams.gravity = Gravity.LEFT |&lt;/span&gt;&lt;span&gt;&lt;span&gt; Gravity.TOP;
        //悬浮窗的开始位置，因为设置的是从左上角开始，所以屏幕左上角是x=0;y=0
        wmParams.x = 70&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
        wmParams.y = 210&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
        //得到容器，通过这个inflater来获得悬浮窗控件
        inflater =&lt;/span&gt;&lt;span&gt;&lt;span&gt; LayoutInflater.from(getApplicationContext());
        // 获取浮动窗口视图所在布局
        mFloatingLayout = inflater.inflate(R.layout.alert_float_video_layout, null&lt;/span&gt;&lt;span&gt;&lt;span&gt;);
        // 添加悬浮窗的视图
&lt;/span&gt;&lt;span&gt;&lt;span&gt;        mWindowManager.addView(mFloatingLayout, wmParams);
    }

  
    private&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams getParams() {
        wmParams = new&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams();
        //设置window type 下面变量2002是在屏幕区域显示，2003则可以显示在状态栏之上
        wmParams.type =&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams.TYPE_TOAST;
        //设置可以显示在状态栏上
        wmParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL |&lt;/span&gt;&lt;span&gt;&lt;span&gt;
                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR |&lt;/span&gt;&lt;span&gt;&lt;span&gt;
                WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;

        //设置悬浮窗口长宽数据
        wmParams.width =&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams.WRAP_CONTENT;
        wmParams.height =&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams.WRAP_CONTENT;
        return&lt;/span&gt;&lt;span&gt;&lt;span&gt; wmParams;
    }
&lt;br/&gt;　　
    private void&lt;/span&gt;&lt;span&gt;&lt;span&gt; initFloating() {
        smallSizePreviewLayout =&lt;/span&gt;&lt;span&gt;&lt;span&gt; mFloatingLayout.findViewById(R.id.small_size_preview);

        //悬浮框点击事件
        smallSizePreviewLayout.setOnClickListener(new&lt;/span&gt;&lt;span&gt;&lt;span&gt; View.OnClickListener() {
            @Override
            public void&lt;/span&gt;&lt;span&gt;&lt;span&gt; onClick(View v) {
              　//在这里实现点击重新回到Activity
            }
        });

        //悬浮框触摸事件，设置悬浮框可拖动
        smallSizePreviewLayout.setOnTouchListener(new&lt;/span&gt;&lt;span&gt;&lt;span&gt; FloatingListener());
    }

    //开始触控的坐标，移动时的坐标（相对于屏幕左上角的坐标）
    private int&lt;/span&gt;&lt;span&gt;&lt;span&gt; mTouchStartX, mTouchStartY, mTouchCurrentX, mTouchCurrentY;
    //开始时的坐标和结束时的坐标（相对于自身控件的坐标）
    private int&lt;/span&gt;&lt;span&gt;&lt;span&gt; mStartX, mStartY, mStopX, mStopY;&lt;br/&gt;　　 //判断悬浮窗口是否移动，这里做个标记，防止移动后松手触发了点击事件
    private boolean isMove;

    private class FloatingListener implements&lt;/span&gt;&lt;span&gt;&lt;span&gt; View.OnTouchListener {

        @Override
        public boolean&lt;/span&gt;&lt;span&gt;&lt;span&gt; onTouch(View v, MotionEvent event) {
            int action =&lt;/span&gt;&lt;span&gt;&lt;span&gt; event.getAction();
            switch&lt;/span&gt;&lt;span&gt;&lt;span&gt; (action) {
                case&lt;/span&gt;&lt;span&gt;&lt;span&gt; MotionEvent.ACTION_DOWN:
                    isMove = false&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
                    mTouchStartX = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getRawX();
                    mTouchStartY = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getRawY();
                    mStartX = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getX();
                    mStartY = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getY();
                    break&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
                case&lt;/span&gt;&lt;span&gt;&lt;span&gt; MotionEvent.ACTION_MOVE:
                    mTouchCurrentX = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getRawX();
                    mTouchCurrentY = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getRawY();
                    wmParams.x += mTouchCurrentX -&lt;/span&gt;&lt;span&gt;&lt;span&gt; mTouchStartX;
                    wmParams.y += mTouchCurrentY -&lt;/span&gt;&lt;span&gt;&lt;span&gt; mTouchStartY;
                    mWindowManager.updateViewLayout(mFloatingLayout, wmParams);

                    mTouchStartX =&lt;/span&gt;&lt;span&gt;&lt;span&gt; mTouchCurrentX;
                    mTouchStartY =&lt;/span&gt;&lt;span&gt;&lt;span&gt; mTouchCurrentY;
                    break&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
                case&lt;/span&gt;&lt;span&gt;&lt;span&gt; MotionEvent.ACTION_UP:
                    mStopX = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getX();
                    mStopY = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getY();
                    if (Math.abs(mStartX - mStopX) &amp;gt;= 1 || Math.abs(mStartY - mStopY) &amp;gt;= 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;) {
                        isMove = true&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
                    }
                    break&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
            }

            //如果是移动事件不触发OnClick事件，防止移动的时候一放手形成点击事件
            return&lt;/span&gt;&lt;span&gt;&lt;span&gt; isMove;
        }
    }
}       &lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;d. 在悬浮框成功被初始化以及相关参数被设置后，接下来就需要将对方的视频画布添加到悬浮框里面去了，这样我们才能看到对方的视频画面嘛，同样我们是在&lt;span&gt;Service的oncreate这个生命周期&lt;/span&gt;完成这个操作的，&lt;span&gt;这里视频画布的添加方式使用的网易云信的SDK，具体的添加方式视不同的SDK而定&lt;/span&gt;，代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    /**
     * 初始化预览窗口
     */
    private void initSurface() {
        if (smallRender == null) {
            smallRender = new AVChatSurfaceViewRenderer(getApplicationContext());
        }

        addIntoSmallSizePreviewLayout(smallRender);
    }

    /**
     * 添加surfaceview到smallSizePreviewLayout
     */
    private void addIntoSmallSizePreviewLayout(SurfaceView surfaceView) {
        if (surfaceView.getParent() != null) {
            ((ViewGroup) surfaceView.getParent()).removeView(surfaceView);
        }

        smallSizePreviewLayout.addView(surfaceView);
        surfaceView.setZOrderMediaOverlay(true);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;e. 我们上面说到要将服务service的绑定与解绑与悬浮框的开启和关闭相结合，所以既然我们在服务的oncreate()方法中开启了悬浮框，那么就应该在其ondestroy()方法中对悬浮框进行关闭，&lt;span&gt;关闭悬浮框的本质是将相关view给移除掉&lt;/span&gt;，接着清除我们的视频画布，在服务的ondestroy()方法中执行如下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  @Override
    public void&lt;span&gt; onDestroy() {
        super&lt;span&gt;.onDestroy();
        if (mFloatingLayout != null&lt;span&gt;) {
            // 移除悬浮窗口
&lt;span&gt;            mWindowManager.removeView(mFloatingLayout);
        }

        //清除视频画布
        AVChatManager.getInstance().setupRemoteVideoRender(account, null, false, 0&lt;span&gt;);
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;f. 服务的绑定方式有bindService和startService两种，使用不同的绑定方式其生命周期也会不一样，已知我们需要让悬浮框在视频通话activity finish掉的时候也顺便关掉，那么理所当然我们就应该采用bind方式来启动服务，让他的生命周期跟随他的开启者，也即是跟随开启它的activity生命周期。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;intent = new Intent(this, FloatVideoWindowService.class);//开启服务显示悬浮框
bindService(intent, mVideoServiceConnection, Context.BIND_AUTO_CREATE);

ServiceConnection mVideoServiceConnection = new ServiceConnection() {

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            // 获取服务的操作对象
            FloatVideoWindowService.MyBinder binder = (FloatVideoWindowService.MyBinder) service;
            binder.getService();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、完整的流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们将上面所说的给串联起来，思路会更加清晰一点，&lt;span&gt;假设现在我正在进行视频通话，点击视频最小化按钮，我们应该按顺序执行如下步骤：（如果你姿势对的话，现在应该是会出现个悬浮框了）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   public void startVideoService() {
         moveTaskToBack(true);//最小化Activity
         intent = new Intent(this, FloatVideoWindowService.class);//开启服务显示悬浮框
         bindService(intent, mVideoServiceConnection, Context.BIND_AUTO_CREATE);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当我们点击悬浮框的时候，可以使用startActivity(intent)来再次打开我们的activity，这时候视频通话activity会回调onRestart()方法，我们在onRestart()生命周期里面unbind解绑掉悬浮框服务，并且重新设置新的视频画布到activity上&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;  @Override
    protected void&lt;/span&gt;&lt;span&gt;&lt;span&gt; onRestart() {
        super&lt;/span&gt;&lt;span&gt;&lt;span&gt;.onRestart();
        unbindService(mVideoServiceConnection);//不显示悬浮框

        //从悬浮窗进来后重新设置画布(判断是不是接通了)
        if&lt;/span&gt;&lt;span&gt;&lt;span&gt; (isCallEstablished) {
            //如果接通，先清除所有画布
&lt;/span&gt;&lt;span&gt;&lt;span&gt;            avChatUI.clearAllSurfaceView(avChatUI.getAccount());
           //延迟重新加载远端和本地的视频画布
            mHandler.postDelayed(new&lt;/span&gt;&lt;span&gt;&lt;span&gt; Runnable() {
                @Override
                public void&lt;/span&gt;&lt;span&gt;&lt;span&gt; run() {
                    avChatUI.initAllSurfaceView(avChatUI.getAccount());
                   
                }
            }, 800&lt;/span&gt;&lt;span&gt;&lt;span&gt;);
        } else&lt;/span&gt;&lt;span&gt;&lt;span&gt; {
            //如果没接通，直接初始化所有画布
&lt;/span&gt;&lt;span&gt;&lt;span&gt;            avChatUI.initLargeSurfaceView(IMCache.getAccount());
        }
    }   &lt;/span&gt;                     &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;已经很久没有写过博客了，写着写着可能有点乱(￣_￣|||)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;如果有什么疑问或者有更好的实现思路的，欢迎给我留言~&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;联系方式：471497226@qq.com&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 14:36:00 +0000</pubDate>
<dc:creator>CKTim</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cxk1995/p/7824375.html</dc:identifier>
</item>
<item>
<title>smartClient 1--框架介绍 - HelenJ</title>
<link>http://www.cnblogs.com/hihao/p/7896919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hihao/p/7896919.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、是什么（以下简称SC）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    smartClient 是一个基于web技术的开发框架，主要包括：&lt;/p&gt;
&lt;div&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;一个无需安装的 Ajax/HTML5 客户端引擎&lt;/li&gt;
&lt;li&gt;UI组件和服务（采用富客户端RIA）--- 提供大量强大而美观的 UI 控件&lt;/li&gt;
&lt;li&gt;客户端/服务器数据绑定系统&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、有什么用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    快速构建 大型企业应用开发（无需过多关注UI），适合基于云技术的应用，主要关注业务的发展和营销，加快开发进程&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    1、不适合传统企业网站、内容网站（从SEO角度看，该框架适合web应用，而非web网站）&lt;/p&gt;
&lt;p&gt;    2、其本质是js编写的单页面程序，对搜索引擎不友好（不利于SEO）&lt;/p&gt;
&lt;p&gt;    3、IE6兼容性差&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、运行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、首页入口文件和js文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    1、SC是采用单页面的形式构建 web应用。因此，每个应用都有一个首页入口文件index.html（或者default.html）&lt;/p&gt;
&lt;p&gt;        a.  首页文件主要作用是调用SC的类库，从而能在自己的js文件中调用这些类库，生成期望的客户端UI和业务逻辑&lt;/p&gt;
&lt;p&gt;        b.  首页主要内容：至少八个js引入（包括load_skin.js，里面有十几种不同风格的皮肤，通过脚本可以改变；   frameworkMessages_zh_CN.properties文件是中文包，如果使用IIS作为web服务器，则调试会出错，解决方案是将其改为frameworkMessages_zh_CN.properties.js&amp;lt;注意在引入的时候也要改&amp;gt;）&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;        c.  添加 loading 动画：在 ISC_Fundation.js 后面（第二后引入脚本之后）（此兼容浏览器）（注意后面需要添加消失loading代码）
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;
    isc.Label.create({
        ID: &lt;/span&gt;&quot;imgLoading&quot;&lt;span&gt;,
        padding: &lt;/span&gt;10&lt;span&gt;,
        width: &lt;/span&gt;&quot;100%&quot;&lt;span&gt;,
        height: &lt;/span&gt;&quot;100%&quot;&lt;span&gt;,
        align: &lt;/span&gt;&quot;center&quot;&lt;span&gt;,
        valign: &lt;/span&gt;&quot;center&quot;&lt;span&gt;,
        wrap: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        icon: &lt;/span&gt;&quot;/images/loading.gif&quot;&lt;span&gt;,
        contents: &lt;/span&gt;&quot;Loading...&quot;&lt;span&gt;
        });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;    2、新建js文件夹，所有的js文件都将在此。&lt;/p&gt;
&lt;div readability=&quot;14.5&quot;&gt;        a.  如下，创建 loading.js（放上面loading动画） 和 default.js（作为整个项目的入口代码）
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;(){ &lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：由于js没有命名空间，因此为避免命名冲突（如var isc = ''; 和SC内置对象命名冲突，此时下面的创建SC标签代码报错），实行闭包的写法(function() {......})();&lt;/span&gt;
&lt;span&gt;    isc.Label.create({ 
        ID: &lt;/span&gt;&quot;imgLoading&quot;&lt;span&gt;, 
        padding: &lt;/span&gt;10&lt;span&gt;, 
        width: &lt;/span&gt;&quot;100%&quot;&lt;span&gt;, 
        height: &lt;/span&gt;&quot;100%&quot;&lt;span&gt;, 
        align: &lt;/span&gt;&quot;center&quot;&lt;span&gt;, 
        valign: &lt;/span&gt;&quot;center&quot;&lt;span&gt;, 
        wrap: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, 
        icon: &lt;/span&gt;&quot;/images/loading.gif&quot;&lt;span&gt;, 
        contents: &lt;/span&gt;&quot;Loading...&quot;&lt;span&gt; 
    });
})();
(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    imgLoading.destroy();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;loading标签销毁，类库加载完毕，就会运行&lt;/span&gt;
    isc.say(&quot;hello world!&quot;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹出消息的形式显示 hello world!&lt;/span&gt;
})();
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、更多主题（可以更换系统自带主题，还可以自定义主题）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    1、系统主题（web服务根目录下的isomorphic文件夹的skins下）（awd见web/awd/thirdParty/isomorphic/skins）&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;        a. 更换主题，只需要引入不同主题文件即可
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;/isomorphic/skins/Graphite/load_skin.js&quot;&amp;gt;&amp;lt;/script&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;七、多语言支持&lt;/span&gt;&lt;/strong&gt;（同更换系统皮肤，只需要引入不同的语言包即可）（iosmorphic/locales下）（awd见web/awd/thirdParty/isomorphic/locales）&lt;/p&gt;
&lt;p&gt;    1、中文字体问题（由于CSS文件定义是以英文字体、字号为标准《11px》（中文必须在12px下才能清晰显示），因此中文显示效果不理想，字体太小）&lt;/p&gt;
&lt;p&gt;        解决方案：&lt;/p&gt;
&lt;p&gt;            a. 进入对应的skin文件夹下，先备份skin_style.css.bak，然后打开skin_style.css，将font-size: 11px; font-family: xxx; 改为 font-size: 12px; font-family: Microsoft YaHei,SimSun,Arial,Verdana,sans-serif; 即可&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;    a. 为了支持多语言，需要在入口文件中指定编码方式为 UTF-8&lt;/p&gt;
&lt;p&gt;    b. 语言包的扩展名为.properties，当以js形式加载时（用script标签引入），某些服务器会拒绝（如IIS6），因此需要手动修改扩展名（添加 .js ）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;八、目录结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    1、web服务器根目录下（不一定是直接根目录，放在其他文件夹如 thirdparty 亦可），和传统网页开发类似而不同如下：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        web
            isomorphic
                skins             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;系统皮肤文件夹&lt;/span&gt;
&lt;span&gt;                system
                    modules
                        xxx.js    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SC类库&lt;/span&gt;
&lt;span&gt;            images
            js            
                xxx.js            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;各个业务逻辑代码&lt;/span&gt;
&lt;span&gt;                ......
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;.js        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;入口文件，是js的入口文件，注意在html入口文件中引用时，需要放在其他js引入的最后，保证程序正常运行&lt;/span&gt;
&lt;span&gt;            css
            index.html            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首页入口文件（单页面开发，通篇只需要一个HTML文件，即此入口文件）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;







</description>
<pubDate>Sat, 25 Nov 2017 14:34:00 +0000</pubDate>
<dc:creator>HelenJ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hihao/p/7896919.html</dc:identifier>
</item>
<item>
<title>一步一步带你实现virtual dom（二) -- Props和事件 - Mr 布鲁斯</title>
<link>http://www.cnblogs.com/sunshine-anycall/p/7896520.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-anycall/p/7896520.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/sunshine-anycall/p/7897140.html&quot;&gt;一步一步带你实现virtual dom（一）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/sunshine-anycall/p/7896520.html&quot;&gt;一步一步带你实现virtual dom（二)--Props和事件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很高兴我们可以继续分享编写虚拟DOM的知识。这次我们要讲解的是产品级的内容，其中包括：设置和DOM一致性、以及事件的处理。&lt;/p&gt;
&lt;h2 id=&quot;使用babel&quot;&gt;使用Babel&lt;/h2&gt;
&lt;p&gt;在继续之前，我们需要弥补前一篇文章中没有详细讲解的内容。假设有一个没有任何属性（props）的节点：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Babel，在处理这个节点的时候会把节点的&lt;strong&gt;props&lt;/strong&gt;属性设置为“null”，因为它没有任何的属性。因此我们会得到这样的结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;h&lt;/span&gt;(type&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; props&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...&lt;span class=&quot;at&quot;&gt;children&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;type&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; props &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{},&lt;/span&gt; children&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;设置props&quot;&gt;设置props&lt;/h2&gt;
&lt;p&gt;设置props非常简单，记得DOM显示吗？我们把props作为简单的js对象来存储，所以这样的标签：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;ul className&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;list&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; style&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;list-style: none;&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/ul&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内存里就会有这样的对象：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'ul'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'list'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'list-style:none;'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此每一个props的字段就是一个&lt;strong&gt;属性名&lt;/strong&gt;，这个字段的值就是属性值。所以，我们只要把这些值给真正的DOM节点设置了就可以了。我们写一个方法包装一个&lt;strong&gt;setAttribute()&lt;/strong&gt;方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;setProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;$target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么现在我们知道如何设置属性了（prop）--我们之后可以全部都设置上，只要遍历prop对象的属性就可以：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;setProps&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; props) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;keys&lt;/span&gt;(props).&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(name &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;setProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; props[name])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还记得&lt;strong&gt;createElement()&lt;/strong&gt;方法么？我们只需要在真正的DOM节点创建之后调用&lt;strong&gt;setProp&lt;/strong&gt;方法给它设置即可：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(node) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; node &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'string) {&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createTextNode&lt;/span&gt;(node)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; $el &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;setProps&lt;/span&gt;($el&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;children&lt;/span&gt;
        .&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(createElement)
        .&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;$el&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;appendChild&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bind&lt;/span&gt;($el))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; $el&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，这还没有完。我们忘记了一些小细节。首先，‘class’是js的保留字。所以不能把它用作属性名称。我们会使用‘className’：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;nav className&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;navbar light&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;ul&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/ul&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;/nav&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是在真正的DOM里并没有‘className’，所以我们应该在&lt;strong&gt;setProp&lt;/strong&gt;方法里处理这个问题。&lt;/p&gt;
&lt;p&gt;另外一个事情是，设置布尔型的属性的时候最好使用布尔值：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;checkbox&quot;&lt;/span&gt; checked&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个例子里，我并不希望这个'checked'属性值设置在真正的DOM节点上。但是事实上这个值足够设置DOM节点了，当然这同时还需要给对应的虚拟DOM节点也设置这个值：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;setBooleanProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;$target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;$target&lt;/span&gt;.[name] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        $target[name] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们就来看看如何自定义属性。这次完全是我们自己的实现，因此后面我们会有不同作用的属性，并且不是全都要在DOM节点上显示的。所以要写一个方法来检查这个属性是不是自定义的。现在它是空的，所以我们还没有任何的自定义属性：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;isCustomProp&lt;/span&gt;(name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面就是我们完整的&lt;code&gt;setProp()&lt;/code&gt;方法，把所有的问题都处理了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;setProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;isCustomProp&lt;/span&gt;(name)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(name &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'className'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;$target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'class'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; value &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'boolean'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;setBooleanProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;$target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在在&lt;a href=&quot;https://jsfiddle.net/deathmood/st5cyz16/?utm_source=website&amp;amp;utm_medium=embed&amp;amp;utm_campaign=st5cyz16&quot;&gt;JSFiddle&lt;/a&gt;里面试试吧.&lt;/p&gt;
&lt;h2 id=&quot;属性区分diff-props&quot;&gt;属性区分（Diff Props）&lt;/h2&gt;
&lt;p&gt;现在我们已经可以使用prop来创建元素了，现在要处理的就是如何区分元素的props了。最终要么是&lt;strong&gt;设置&lt;/strong&gt;属性，要么是&lt;strong&gt;删除&lt;/strong&gt;它。我们已经有方法可以设置属性了，现在来写一个方法来删除它们吧。事实上这非常简单：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;removeBooleanProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;$target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;removeAttribute&lt;/span&gt;(name)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    $target[name] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;removeProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;isCustomProp&lt;/span&gt;(name)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(name &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'className'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;$target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;removeAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'class'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'boolean'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;removeBooleanProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;$target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;removeAttribute&lt;/span&gt;(name)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再来写一个&lt;code&gt;updateProp()&lt;/code&gt;方法来比较两个属性--就的和新的，并根据比较的结果来更新DOM元素的属性：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在DOM里没有这个属性的话，就删除掉&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;                                     old 
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;nav&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/nav&amp;gt;     &amp;lt;nav className='navbar'&amp;gt;&amp;lt;/nav&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在新的节点里包含了某个属性，那么就需要在DOM上设置这个属性&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;                                                                         old
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;nav style&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'background: blue'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/nav&amp;gt;   &amp;lt;nav&amp;gt;&amp;lt;/nav&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;某个属性在新的和旧的节点里都存在，那么我们就需要比较他们的值。如果他们不相等我们就需要根据结果给新的节点设置属性值了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;                                                                                 old 
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;nav className&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'navbar default'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/nav&amp;gt;   &amp;lt;nav className='navbar'&amp;gt;&amp;lt;/nav&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在其他情况下，属性并没有改变我们什么都不需要做。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面这个方法就是专门处理prop的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;updateProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; naem&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; newVal&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; oldVal) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;newVal) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;removeProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; oldVal)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;oldVal &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; newVal &lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt; oldVal) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;setProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; newVal)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是很简单？但是一个节点会有不止一个属性--所以我们要写一个方法可以遍历全部的属性，然后调用&lt;code&gt;updateProp()&lt;/code&gt;方法来一对一对的处理：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;updateProps&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; newProps&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; oldProps &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; props &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;assign&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{},&lt;/span&gt; newProps&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; oldProps)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;leys&lt;/span&gt;(props).&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(name &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;updateProp&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; newProps[name]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; oldProps[name])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意我们创建的组合对象。它包含了新、旧节点的属性。因此，在遍历的时候我们会遇到&lt;code&gt;undefined&lt;/code&gt;，不过这没有关系，我们的方法可以处理这个问题。&lt;/p&gt;
&lt;p&gt;最后一件事就是把这个方法放到我们的&lt;code&gt;updateElement()&lt;/code&gt;方法里。我们应该放在哪里呢？如果节点本身没有改变，那么它的子节点呢？这个问题我们也需要处理。所以我们把那个方法放在最后一个&lt;code&gt;if&lt;/code&gt;语句块里。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;updateElement&lt;/span&gt;($parent&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; newNode&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; oldNode&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; index&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        ...
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;   &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;newNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;updateProps&lt;/span&gt;(
            &lt;span class=&quot;va&quot;&gt;$parent&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;childNodes&lt;/span&gt;[index]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;newNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;oldNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        )&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

        ...
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着在&lt;a href=&quot;https://jsfiddle.net/deathmood/urhpk7os/?utm_source=website&amp;amp;utm_medium=embed&amp;amp;utm_campaign=urhpk7os&quot;&gt;这里测试&lt;/a&gt;一下吧。&lt;/p&gt;
&lt;h2 id=&quot;事件&quot;&gt;事件&lt;/h2&gt;
&lt;p&gt;当然一个动态的应用是免不了会有事件的。我们可以使用&lt;code&gt;querySelector()&lt;/code&gt;来处理节点，然后用&lt;code&gt;addEventListener()&lt;/code&gt;来给节点添加事件的listener。但是，这样没啥意思。我们要像React一样来处理事件。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'hi'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/button&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样看起来就像那么回事儿了。你看到了，我们是用了&lt;code&gt;props&lt;/code&gt;来声明一个事件监听器的。我们的属性名都是&lt;code&gt;on&lt;/code&gt;开头的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;isEventProp&lt;/span&gt;(name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;on/&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;test&lt;/span&gt;(name)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来写一个方法，从属性里获取事件名称。记住事件的名称都是以&lt;code&gt;on&lt;/code&gt;为前缀的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;extractEventName&lt;/span&gt;(name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;name&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;toLowerCase&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来，如果我们在属性里声明了事件，那么我们就需要在&lt;code&gt;setProps()&lt;/code&gt;或者&lt;code&gt;updateProps()&lt;/code&gt;方法里处理。但是如何处理方法的不同呢？&lt;/p&gt;
&lt;p&gt;你不能用相等操作符来比较两个方法。当然你可以用&lt;code&gt;toString()&lt;/code&gt;方法，然后比较两个方法。但是有个问题，方法里可能会包含&lt;strong&gt;native code&lt;/strong&gt;，这就给比较带来了问题。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;st&quot;&gt;&quot;function () { [native code] }&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然我们可以使用时间冒泡的方式来处理。我们可以写我们自己的事件处理管理器，这个管理器会附加到&lt;code&gt;body&lt;/code&gt;或者绘制我们节点的容器节点上。因此，我们可以在每次更新的时候添加一次事件处理器，这样也不会造成多大的资源浪费。&lt;/p&gt;
&lt;p&gt;但是，我们不会这么做。因为这样会增加很多的问题，而且事实上我们的时间处理器不会频繁的改变。所以，我们只要在创建我们的节点的时候添加一次事件监听器就可以。那么不会在&lt;code&gt;setProps&lt;/code&gt;方法里设置事件属性。我们自己处理添加事件的问题。怎么实现呢？记得我们的方法可以检测自定义的属性吗？现在它不会是空的了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;isCustomProp&lt;/span&gt;(name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;isEventProp&lt;/span&gt;(name)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们知道了一个真的DOM节点的时候添加事件监听器，这时属性对象也非常清晰的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;addEventListeners&lt;/span&gt;($target&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; props) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;keys&lt;/span&gt;(props).&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(name &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;isEventProp&lt;/span&gt;(name))&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;$target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addEventListener&lt;/span&gt;(
                &lt;span class=&quot;at&quot;&gt;exteactEventName&lt;/span&gt;(name)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                props[name]
            )&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把上面的代码加入到&lt;code&gt;createElement&lt;/code&gt;方法里：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(node) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; node &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'string'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createTextNode&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'node'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; $el &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;setProps&lt;/span&gt;($el&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;addEventListeners&lt;/span&gt;($el&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;children&lt;/span&gt;
        .&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(createElement)
        .&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;$el&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;appendChild&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bind&lt;/span&gt;($el))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; $el&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;再次添加事件&quot;&gt;再次添加事件&lt;/h2&gt;
&lt;p&gt;如果你必须要再次添加事件监听器呢？我们来简单理解处理一下这个问题。只是这样的话性能会受到印象。我们会引入一个自定义属性：&lt;code&gt;forceUpdate&lt;/code&gt;。记住，我们怎么检查节点的更改的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;changed&lt;/span&gt;(node1&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; node2) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; node1 &lt;span class=&quot;op&quot;&gt;~==&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; node2 &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt;
                 &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; node1 &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'string'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; node1 &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; node2 &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt;
                 &lt;span class=&quot;va&quot;&gt;node1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;node2&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt;
                 &lt;span class=&quot;va&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;forceUpdate&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果&lt;code&gt;forceUpdate&lt;/code&gt;为true的话，节点就会整个的重新创建并且新的事件监听器也会被添加进去。整个属性也不是不应该加到实际的DOM节点的，所以需要处理一下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;isCustomProp&lt;/span&gt;(name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;isEventProp&lt;/span&gt;(name) &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; name &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'forceUpdate'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这基本就是全部了。是的，整个解决的方法会影响性能，但是很简单。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;这就基本是全部了。希望你觉得有趣。如果你知道更简单的解决方法处理事件处理器的不同的方法的话，能分享到评论里就太感谢了。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://medium.com/@deathmood/write-your-virtual-dom-2-props-events-a957608f5c76&quot; class=&quot;uri&quot;&gt;https://medium.com/@deathmood/write-your-virtual-dom-2-props-events-a957608f5c76&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 13:40:00 +0000</pubDate>
<dc:creator>Mr 布鲁斯</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-anycall/p/7896520.html</dc:identifier>
</item>
<item>
<title>照虎画猫写自己的Spring——依赖注入 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/Fairy2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/Fairy2.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;上篇《照虎画猫写自己的Spring》从无到有讲述并实现了下面几点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;声明配置文件，用于声明需要加载使用的类&lt;/li&gt;
&lt;li&gt;加载配置文件，读取配置文件&lt;/li&gt;
&lt;li&gt;解析配置文件，需要将配置文件中声明的标签转换为Fairy能够识别的类&lt;/li&gt;
&lt;li&gt;初始化类，提供配置文件中声明的类的实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一句话概括：&lt;/strong&gt;不借助Spring容器，实现了Bean的加载和实例化&lt;/p&gt;
&lt;p&gt;要想契合Fairy取名时的初衷（&lt;code&gt;东西不大，但是能量无穷&lt;/code&gt;），只有一套加载Bean的机制是远远不够的，所以还是需要照虎画猫，完善这个小精灵。&lt;/p&gt;
&lt;p&gt;Spring之所以在Java企业级开发的众多框架中崭露头角光芒万丈，与他的&lt;strong&gt;依赖注入（又名控制反转IOC）&lt;/strong&gt;和&lt;strong&gt;面向切面（AOP）&lt;/strong&gt;两大杀手锏是密不可分的。在Fairy实现了加载实例化Bean的功能后，我们再往前走一步，看看依赖注入是如何实现的。&lt;/p&gt;
&lt;h3 id=&quot;依赖注入&quot;&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;举个例子，大概介绍下依赖注入。&lt;br/&gt;没有依赖注入之前，我们买白菜的时候，需要挎着篮子去菜市场挑选并购买；&lt;br/&gt;有了依赖注入之后，我们需要白菜的时候，菜装在篮子里，已经放在你家门口。&lt;br/&gt;这就是依赖注入。&lt;/p&gt;
&lt;p&gt;对于Fairy，如果要实现依赖注入的功能，需要在上一版的代码上做一些小小的改动。&lt;br/&gt;将原来的FairyBean接口和实现类FairyBeanImpl改为FairyDao接口和实现类FairyDaoImpl，除此以外，我们需要新加一个接口FairyService和实现类FairyServiceImpl。&lt;br/&gt;这么声明，相信你一定明白这是为了使用依赖注入功能。&lt;/p&gt;
&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;我们依旧采用读取配置文件的方式来初始化容器。新建一个配置文件application-context-inject.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;beans&amp;gt;
    &amp;lt;bean id=&quot;fairyService&quot; class=&quot;com.jackie.fairy.bean.impl.FairyServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;fairyDao&quot; ref=&quot;fairyDao&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;lightColor&quot; value=&quot;blue&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;fairyDao&quot; class=&quot;com.jackie.fairy.bean.impl.FairyDaoImpl&quot;&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时我们需要FairyService和FairyServiceImpl&lt;br/&gt;FairyService&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.jackie.fairy.bean;

/**
 * Created by jackie on 17/11/25.
 */
public interface FairyService {
    void greet();

    void fly();

    void lighting();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FairyServiceImpl&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.jackie.fairy.bean.impl;

import com.jackie.fairy.bean.FairyDao;
import com.jackie.fairy.bean.FairyService;

/**
 * Created by jackie on 17/11/25.
 */
public class FairyServiceImpl implements FairyService {
    private FairyDao fairyDao;
    private String lightColor;

    public FairyDao getFairyDao() {
        System.out.println(&quot;===getFairyDao===: &quot; + fairyDao.toString());
        return fairyDao;
    }

    public void setFairyDao(FairyDao fairyDao) {
        System.out.println(&quot;===setFairyDao===: &quot; + fairyDao.toString());
        this.fairyDao = fairyDao;
    }

    public String getLightColor() {
        return lightColor;
    }

    public void setLightColor(String lightColor) {
        this.lightColor = lightColor;
    }

    @Override
    public void greet() {
        fairyDao.greet();
    }

    @Override
    public void fly() {
        fairyDao.fly();
    }

    @Override
    public void lighting() {
        System.out.println(&quot;----------Hi, I am light fairy. Exactly, &quot; + lightColor + &quot; color light fairy----------&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;mailto:没有使用@Autowired注入FairyDao&quot;&gt;没有使用@Autowired注入FairyDao&lt;/a&gt;，这是Spring的那一套&lt;/li&gt;
&lt;li&gt;将FairyDao作为成员变量，添加setter和getter方法（后续做注入使用）&lt;/li&gt;
&lt;li&gt;添加FairyService自己的实现方法lighting，这是一个会发光的小精灵的feature，小精灵的发光属性取决于lightColor，这个属性需要注入，所以也有相应的setter和getter方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;升级解析器类&quot;&gt;升级解析器类&lt;/h3&gt;
&lt;p&gt;上篇的XmlReaderUtil解析器只能解析这样的配置结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;parent&amp;gt;
    &amp;lt;child&amp;gt;
    &amp;lt;/child&amp;gt;
    ...
    &amp;lt;child&amp;gt;
    &amp;lt;/child&amp;gt;
&amp;lt;parent&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是我们现在需要支持的配置文件如上面的配置文件所示，所以需要升级解析器类，支持读取子标签的属性标签。&lt;br/&gt;在此之前，需要新建模型PropertyDefinition，用于存储属性值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.jackie.fairy.model;

/**
 * Created by jackie on 17/11/25.
 */
public class PropertyDefinition {
    private String name;
    private String ref;
    private String value;

    public PropertyDefinition(String name, String ref, String value) {
        this.name = name;
        this.ref = ref;
        this.value = value;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getRef() {
        return ref;
    }

    public void setRef(String ref) {
        this.ref = ref;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return &quot;PropertyDefinition{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, ref='&quot; + ref + '\'' +
                &quot;, value='&quot; + value + '\'' +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，需要在BeanDefinition模型中加入List，因为属性值是依附在BeanDefinition下面的。&lt;/p&gt;
&lt;p&gt;XmlReaderUtil将核心代码改为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (Iterator iterator = rootElement.elementIterator(); iterator.hasNext(); ) {
    Element element = (Element)iterator.next();
    String id = element.attributeValue(Constants.BEAN_ID_NAME);
    String clazz = element.attributeValue(Constants.BEAN_CLASS_NAME);
    BeanDefinition beanDefinition = new BeanDefinition(id, clazz);
    
    // 遍历属性标签
    for (Iterator propertyIterator = element.elementIterator(); propertyIterator.hasNext();) {
        Element propertyElement = (Element) propertyIterator.next();
        String name = propertyElement.attributeValue(Constants.PROPERTY_NAME_NAME);
        String ref = propertyElement.attributeValue(Constants.PROPERTY_REF_NAME);
        String value = propertyElement.attributeValue(Constants.PROPERTY_VALUE_NAME);
        propertyDefinitions.add(new PropertyDefinition(name, ref, value));
    }

    beanDefinition.setPropertyDefinitions(propertyDefinitions);
    beanDefinitions.add(beanDefinition);
    // 清空propertyDefinitions集合，因为有些bean没有property标签
    propertyDefinitions = Lists.newArrayList(); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即添加了对于属性标签的解析和存储，详细代码可进入GitHub项目查看。&lt;/p&gt;
&lt;h3 id=&quot;实现依赖注入函数&quot;&gt;实现依赖注入函数&lt;/h3&gt;
&lt;p&gt;在FairyApplicationContext中添加实现依赖注入功能的函数，主要思路就是对某个需要依赖注入的主体（这里的FairyService），找到要依赖注入的类（这里的FairyDao），借助反射机制，通过setter方法将FairyDao注入到FairyService中。&lt;/p&gt;
&lt;p&gt;injectObject()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void injectObject() {
    for (BeanDefinition beanDefinition : beanDefinitions) {
        Object bean = instanceBeans.get(beanDefinition.getId());
        if (bean != null) {
            try {
                BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass());
                /**
                 * 通过BeanInfo来获取属性的描述器(PropertyDescriptor)
                 * 通过这个属性描述器就可以获取某个属性对应的getter/setter方法
                 * 然后我们就可以通过反射机制来调用这些方法。
                 */
                PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();

                for (PropertyDefinition propertyDefinition : beanDefinition.getPropertyDefinitions()) {
                    for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {
                        // 用户定义的bean属性与java内省后的bean属性名称相同时
                        if (StringUtils.equals(propertyDescriptor.getName(), propertyDefinition.getName())) {
                            // 获取setter方法
                            Method setter = propertyDescriptor.getWriteMethod();
                            if (setter != null) {
                                Object value = null;
                                if (StringUtils.isNotEmpty(propertyDefinition.getRef())) {
                                    // 根据bean的名称在instanceBeans中获取指定的对象值
                                    value = instanceBeans.get(propertyDefinition.getRef());
                                } else {
                                    value = ConvertUtils.convert(propertyDefinition.getValue(), propertyDescriptor.getPropertyType());
                                }

                                // //保证setter方法可以访问私有
                                setter.setAccessible(true);
                                try {
                                    // 把引用对象注入到属性
                                    setter.invoke(bean, value);
                                } catch (Exception e) {
                                    LOG.error(&quot;invoke setter.invoke failed&quot;, e);
                                }
                            }
                            break;
                        }
                    }
                }
            } catch (Exception e) {
                LOG.error(&quot;invoke getBean failed&quot;, e);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;用到了Java内省获取Bean各个属性的setter和getter方法&lt;/li&gt;
&lt;li&gt;使用了反射调用setter方法，将其注入FairyService类中&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;编写测试代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * bean依赖注入
 */
FairyApplicationContext autowiredApplicationContext =
        new FairyApplicationContext(&quot;application-context-inject.xml&quot;);
FairyService fairyService = (FairyService) autowiredApplicationContext.getBean(&quot;fairyService&quot;);
fairyService.greet();
fairyService.lighting();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;===setFairyDao===: com.jackie.fairy.bean.impl.FairyDaoImpl@6615435c
Hi, I am fairy
----------Hi, I am light fairy. Exactly, blue color light fairy----------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中第一行打印结果是在通过反射执行&lt;code&gt;setter.invoke(bean, value);&lt;/code&gt;时触发打印的。&lt;/p&gt;
&lt;p&gt;至此，我们为Fairy实现了依赖注入的功能，项目地址&lt;br/&gt;&lt;a href=&quot;https://github.com/DMinerJackie/fairy&quot; class=&quot;uri&quot;&gt;https://github.com/DMinerJackie/fairy&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;项目结构&quot;&gt;项目结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201711/619240-20171125213220531-1901285888.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;fairy项目改动盘点&quot;&gt;Fairy项目改动盘点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;添加&lt;code&gt;FairyApplicationContext(String configLocation)&lt;/code&gt;构造函数，默认加载的配置文件是xml格式&lt;/li&gt;
&lt;li&gt;添加Json配置文件解析器，可以解析Json格式的配置文件并加载bean&lt;/li&gt;
&lt;li&gt;重构测试Bean，将接口FairyBean改为FairyDao，并新增FairyService接口及实现类，方便本文的用例测试&lt;/li&gt;
&lt;li&gt;升级XmlReaderUtil，支持Bean的自标签Property的解析&lt;/li&gt;
&lt;li&gt;添加依赖注入函数，用户实现依赖注入功能&lt;/li&gt;
&lt;li&gt;添加PropertyDefinition模型，用于存储property属性值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 13:39:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/Fairy2.html</dc:identifier>
</item>
</channel>
</rss>