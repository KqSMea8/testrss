<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>spring注解工具类AnnotatedElementUtils和AnnotationUtils - 小眼儿</title>
<link>http://www.cnblogs.com/hujunzheng/p/9790588.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/9790588.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;　　spring为开发人员提供了两个搜索注解的工具类，分别是AnnotatedElementUtils和AnnotationUtils。在使用的时候，总是傻傻分不清，什么情况下使用哪一个。于是我做了如下的整理和总结。&lt;/p&gt;
&lt;h2&gt;二、AnnotationUtils官方解释&lt;/h2&gt;
&lt;h3&gt;　　功能&lt;/h3&gt;
&lt;p&gt;　　用于处理注解，处理元注解，桥接方法（编译器为通用声明生成）以及超级方法（用于可选注解继承）的常规实用程序方法。请注意，JDK的内省工具本身并不提供此类的大多数功能。作为运行时保留注解的一般规则（例如，用于事务控制，授权或服务公开），始终在此类上使用查找方法（例如，findAnnotation（Method，Class），getAnnotation（Method，Class）和getAnnotations（方法））而不是JDK中的普通注解查找方法。您仍然可以在给定类级别的get查找（getAnnotation（Method，Class））和给定方法的整个继承层次结构中的查找查找（findAnnotation（Method，Class））之间明确选择。&lt;/p&gt;
&lt;h3&gt;　　术语&lt;/h3&gt;
&lt;p&gt;　　直接呈现，间接呈现和呈现的术语与AnnotatedElement的类级别javadoc中定义的含义相同（在Java 8中）。如果注解被声明为元素上存在的其他注解上的元注解，则注解在元素上是元存在的。如果A在另一个注解上直接存在或元存在，则注解A在另一个注解上存在元。&lt;/p&gt;
&lt;h3&gt;　　元注解支持&lt;/h3&gt;
&lt;p&gt;　　大多数find *（）方法和此类中的一些get *（）方法都支持查找用作元注解的注解。有关详细信息，请参阅此类中每个方法的javadoc。对于在组合注解中使用属性覆盖的元注解的细粒度支持，请考虑使用AnnotatedElementUtils的更具体的方法。&lt;/p&gt;
&lt;h3&gt;　　属性别名&lt;/h3&gt;
&lt;p&gt;　　此类中返回注解，注解数组或AnnotationAttributes的所有公共方法都透明地支持通过@AliasFor配置的属性别名。有关详细信息，请参阅各种synthesizeAnnotation *（..）方法。&lt;/p&gt;
&lt;h3&gt;　　搜索范围&lt;/h3&gt;
&lt;p&gt;　　一旦找到指定类型的第一个注解，此类中的方法使用的搜索算法将停止搜索注解。因此，将默默忽略指定类型的其他注解。&lt;/p&gt;
&lt;h2&gt;三、AnnotatedElementUtils官方解释&lt;/h2&gt;
&lt;h3&gt;　　功能&lt;/h3&gt;
&lt;p&gt; 　　用于在AnnotatedElements上查找注解，元注解和可重复注解的常规实用程序方法。AnnotatedElementUtils为Spring的元注解编程模型定义了公共API，并支持注解属性覆盖。如果您不需要支持注解属性覆盖，请考虑使用AnnotationUtils。请注意，JDK的内省工具本身不提供此类的功能。&lt;/p&gt;
&lt;h3&gt;　　注解属性覆盖&lt;/h3&gt;
&lt;p&gt;　　getMergedAnnotationAttributes（），getMergedAnnotation（），getAllMergedAnnotations（），getMergedRepeatableAnnotations（），findMergedAnnotationAttributes（），findMergedAnnotation（），findAllMergedAnnotations（）和findMergedRepeatableAnnotations（）的所有变体都支持组合注解中带有属性覆盖的元注解的方法。&lt;/p&gt;
&lt;h3&gt;　　查找与获取语义&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;获取语​​义（Get semantics）&lt;/strong&gt;仅限于搜索AnnotatedElement上存在的注解（即本地声明或继承）或在AnnotatedElement上方的注解层次结构中声明的注解。&lt;br/&gt;　　&lt;strong&gt;查找语义（&lt;/strong&gt;Find semantics）更加详尽，提供了语义加上对以下内容的支持：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果带注解的元素是类，则在接口上搜索&lt;/li&gt;
&lt;li&gt;如果带注解的元素是类，则在超类上搜索&lt;/li&gt;
&lt;li&gt;解析桥接方法，如果带注解的元素是方法&lt;/li&gt;
&lt;li&gt;如果带注解的元素是方法，则在接口中搜索方法&lt;/li&gt;
&lt;li&gt;如果带注解的元素是方法，则在超类中搜索方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　支持@Inherited&lt;/h3&gt;
&lt;p&gt;　　get语义之后的方法将遵循Java的@Inherited批注的约定，除了本地声明的注解（包括自定义组合注解）将优于继承注解。相反，查找语义之后的方法将完全忽略@Inherited的存在，因为查找搜索算法手动遍历类型和方法层次结构，从而隐式支持注解继承而不需要@Inherited。&lt;/p&gt;
&lt;h2&gt;四、准备两个测试的注解&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RequestMapping {

    String name() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    @AliasFor(&lt;/span&gt;&quot;path&quot;&lt;span&gt;)
    String[] value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};


    @AliasFor(&lt;/span&gt;&quot;value&quot;&lt;span&gt;)
    String[] path() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
}


@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
&lt;span&gt;@RequestMapping&lt;/span&gt;
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; PostMapping {

    @AliasFor(annotation &lt;/span&gt;= RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String name() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    @AliasFor(annotation &lt;/span&gt;= RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String[] value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    @AliasFor(annotation &lt;/span&gt;= RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String[] path() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、测试例子&lt;/h2&gt;
&lt;h3&gt;　　父类拥有注解@RequestMapping，子类没有注解&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnnotationTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;ParentController getAnnotation @RequestMapping: &quot; + AnnotationUtils.getAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController getAnnotation @RequestMapping: &quot; +AnnotationUtils.getAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println();

        System.out.println(&lt;/span&gt;&quot;ParentController findAnnotation @RequestMapping: &quot; + AnnotationUtils.findAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController findAnnotation @RequestMapping: &quot; + AnnotationUtils.findAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println();

        System.out.println(&lt;/span&gt;&quot;ParentController isAnnotated @RequestMapping: &quot; + AnnotatedElementUtils.isAnnotated(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController getMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.getMergedAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController isAnnotated @RequestMapping: &quot; + AnnotatedElementUtils.isAnnotated(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController getMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.getMergedAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println();

        System.out.println(&lt;/span&gt;&quot;ParentController hasAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.hasAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController findMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.findMergedAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController hasAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.hasAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController findMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.findMergedAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    }
}

@RequestMapping(value &lt;/span&gt;= &quot;parent/controller&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParentController {
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ChildController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ParentController {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
ParentController getAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ChildController getAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;

ParentController findAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ChildController findAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])

ParentController isAnnotated @RequestMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ParentController getMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ChildController isAnnotated @RequestMapping: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
ChildController getMergedAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;

ParentController hasAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ParentController findMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ChildController hasAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ChildController findMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/controller])
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　父类没有注解，子类拥有注解@RequestMapping&lt;/h3&gt;
&lt;p&gt;　　输出结果如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
ParentController getAnnotation @RequestMapping: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ChildController getAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])

ParentController findAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ChildController findAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])

ParentController isAnnotated @RequestMapping: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
ParentController getMergedAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ChildController isAnnotated @RequestMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ChildController getMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])

ParentController hasAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
ParentController findMergedAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ChildController hasAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ChildController findMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/controller])
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　父类拥有注解@PostMapping，子类没有注解&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnnotationTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;ParentController getAnnotation @RequestMapping: &quot; + AnnotationUtils.getAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController getAnnotation @RequestMapping: &quot; +AnnotationUtils.getAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController getAnnotation @PostMapping: &quot; + AnnotationUtils.getAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController getAnnotation @PostMapping: &quot; +AnnotationUtils.getAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println();

        System.out.println(&lt;/span&gt;&quot;ParentController findAnnotation @RequestMapping: &quot; + AnnotationUtils.findAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController findAnnotation @RequestMapping: &quot; + AnnotationUtils.findAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController findAnnotation @PostMapping: &quot; + AnnotationUtils.findAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController findAnnotation @PostMapping: &quot; + AnnotationUtils.findAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println();

        System.out.println(&lt;/span&gt;&quot;ParentController isAnnotated @RequestMapping: &quot; + AnnotatedElementUtils.isAnnotated(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController getMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.getMergedAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController isAnnotated @PostMapping: &quot; + AnnotatedElementUtils.isAnnotated(ParentController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController getMergedAnnotation @PostMapping: &quot; + AnnotatedElementUtils.getMergedAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController isAnnotated @RequestMapping: &quot; + AnnotatedElementUtils.isAnnotated(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController getMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.getMergedAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController isAnnotated @PostMapping: &quot; + AnnotatedElementUtils.isAnnotated(ChildController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController getMergedAnnotation @PostMapping: &quot; + AnnotatedElementUtils.getMergedAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println();

        System.out.println(&lt;/span&gt;&quot;ParentController hasAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.hasAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController findMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.findMergedAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController hasAnnotation @PostMapping: &quot; + AnnotatedElementUtils.hasAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController findMergedAnnotation @PostMapping: &quot; + AnnotatedElementUtils.findMergedAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController hasAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.hasAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController findMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.findMergedAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController hasAnnotation @PostMapping: &quot; + AnnotatedElementUtils.hasAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController findMergedAnnotation @PostMapping: &quot; + AnnotatedElementUtils.findMergedAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, PostMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    }
}

@PostMapping(value &lt;/span&gt;= &quot;parent/controller&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParentController {
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ChildController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ParentController {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
ParentController getAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name=, value=[], path=&lt;span&gt;[])
ChildController getAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ParentController getAnnotation @PostMapping: @com.hjzgg.apigateway.test.service.main.PostMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ChildController getAnnotation @PostMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;

ParentController findAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[], path=&lt;span&gt;[])
ChildController findAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[], path=&lt;span&gt;[])
ParentController findAnnotation @PostMapping: @com.hjzgg.apigateway.test.service.main.PostMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ChildController findAnnotation @PostMapping: @com.hjzgg.apigateway.test.service.main.PostMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])

ParentController isAnnotated @RequestMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ParentController getMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ParentController isAnnotated @PostMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ParentController getMergedAnnotation @PostMapping: @com.hjzgg.apigateway.test.service.main.PostMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ChildController isAnnotated @RequestMapping: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
ChildController getMergedAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ChildController isAnnotated @PostMapping: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
ChildController getMergedAnnotation @PostMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;

ParentController hasAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ParentController findMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ParentController hasAnnotation @PostMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ParentController findMergedAnnotation @PostMapping: @com.hjzgg.apigateway.test.service.main.PostMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ChildController hasAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ChildController findMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ChildController hasAnnotation @PostMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ChildController findMergedAnnotation @PostMapping: @com.hjzgg.apigateway.test.service.main.PostMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/controller])　　
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　父类没有注解，子类拥有注解@PostMapping&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
ParentController getAnnotation @RequestMapping: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ChildController getAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[], path=&lt;span&gt;[])
ParentController getAnnotation @PostMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ChildController getAnnotation @PostMapping: @com.hjzgg.apigateway.test.service.main.PostMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])

ParentController findAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ChildController findAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[], path=&lt;span&gt;[])
ParentController findAnnotation @PostMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ChildController findAnnotation @PostMapping: @com.hjzgg.apigateway.test.service.main.PostMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])

ParentController isAnnotated @RequestMapping: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
ParentController getMergedAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ParentController isAnnotated @PostMapping: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
ParentController getMergedAnnotation @PostMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ChildController isAnnotated @RequestMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ChildController getMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ChildController isAnnotated @PostMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ChildController getMergedAnnotation @PostMapping: @com.hjzgg.apigateway.test.service.main.PostMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])

ParentController hasAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
ParentController findMergedAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ParentController hasAnnotation @PostMapping: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
ParentController findMergedAnnotation @PostMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ChildController hasAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ChildController findMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/&lt;span&gt;controller])
ChildController hasAnnotation @PostMapping: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ChildController findMergedAnnotation @PostMapping: @com.hjzgg.apigateway.test.service.main.PostMapping(name&lt;/span&gt;=, value=[parent/controller], path=[parent/controller])
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　@PostMapping 注有 @RequestMapping，AnnotationUtils和AnnotatedElementUtils区别&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnnotationTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;ParentController getAnnotation @RequestMapping: &quot; + AnnotationUtils.getAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController getAnnotation @RequestMapping: &quot; + AnnotationUtils.getAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController findAnnotation @RequestMapping: &quot; + AnnotationUtils.findAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController findAnnotation @RequestMapping: &quot; + AnnotationUtils.findAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println();

        System.out.println(&lt;/span&gt;&quot;ParentController getMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.getMergedAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController getMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.getMergedAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController findMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.findMergedAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController findMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.findMergedAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    }
}

@RequestMapping(name &lt;/span&gt;= &quot;parent&quot;, path=&quot;parent/controller&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParentController {
}

@PostMapping(name&lt;/span&gt;=&quot;child&quot;, value = &quot;child/controller&quot;, consume = &quot;application/json&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ChildController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ParentController {
}


@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RequestMapping {

    String name() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    @AliasFor(&lt;/span&gt;&quot;path&quot;&lt;span&gt;)
    String[] value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};


    @AliasFor(&lt;/span&gt;&quot;value&quot;&lt;span&gt;)
    String[] path() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    String[] consume() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
}


@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
&lt;span&gt;@RequestMapping&lt;/span&gt;
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; PostMapping {

    @AliasFor(annotation &lt;/span&gt;= RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String name() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    @AliasFor(annotation &lt;/span&gt;= RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String[] value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    @AliasFor(annotation &lt;/span&gt;= RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String[] path() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    @AliasFor(annotation &lt;/span&gt;= RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String[] consume() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
ParentController getAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name=parent, value=[parent/controller], path=[parent/controller], consume=&lt;span&gt;[])
ChildController getAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[], path=[], consume=&lt;span&gt;[])
ParentController findAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=parent, value=[parent/controller], path=[parent/controller], consume=&lt;span&gt;[])
ChildController findAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=, value=[], path=[], consume=&lt;span&gt;[])

ParentController getMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=parent, value=[parent/controller], path=[parent/controller], consume=&lt;span&gt;[])
ChildController getMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=child, value=[child/controller], path=[child/controller], consume=[application/&lt;span&gt;json])
ParentController findMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=parent, value=[parent/controller], path=[parent/controller], consume=&lt;span&gt;[])
ChildController findMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=child, value=[child/controller], path=[child/controller], consume=[application/json])
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　@PostMapping 和 @RequestMapping各自独立，AnnotationUtils和AnnotatedElementUtils区别&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnnotationTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;ParentController getAnnotation @RequestMapping: &quot; + AnnotationUtils.getAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController getAnnotation @RequestMapping: &quot; + AnnotationUtils.getAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController findAnnotation @RequestMapping: &quot; + AnnotationUtils.findAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController findAnnotation @RequestMapping: &quot; + AnnotationUtils.findAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println();

        System.out.println(&lt;/span&gt;&quot;ParentController getMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.getMergedAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController getMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.getMergedAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ParentController findMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.findMergedAnnotation(ParentController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;ChildController findMergedAnnotation @RequestMapping: &quot; + AnnotatedElementUtils.findMergedAnnotation(ChildController.&lt;span&gt;class&lt;/span&gt;, RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    }
}

@RequestMapping(name &lt;/span&gt;= &quot;parent&quot;, path=&quot;parent/controller&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParentController {
}

@PostMapping(name&lt;/span&gt;=&quot;child&quot;, value = &quot;child/controller&quot;, consume = &quot;application/json&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ChildController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ParentController {
}


@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RequestMapping {

    String name() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    @AliasFor(&lt;/span&gt;&quot;path&quot;&lt;span&gt;)
    String[] value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};


    @AliasFor(&lt;/span&gt;&quot;value&quot;&lt;span&gt;)
    String[] path() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    String[] consume() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
}


@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; PostMapping {

    @AliasFor(annotation &lt;/span&gt;= RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String name() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    @AliasFor(annotation &lt;/span&gt;= RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String[] value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    @AliasFor(annotation &lt;/span&gt;= RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String[] path() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    @AliasFor(annotation &lt;/span&gt;= RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    String[] consume() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
ParentController getAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name=parent, value=[parent/controller], path=[parent/controller], consume=&lt;span&gt;[])
ChildController getAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ParentController findAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=parent, value=[parent/controller], path=[parent/controller], consume=&lt;span&gt;[])
ChildController findAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=parent, value=[parent/controller], path=[parent/controller], consume=&lt;span&gt;[])

ParentController getMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=parent, value=[parent/controller], path=[parent/controller], consume=&lt;span&gt;[])
ChildController getMergedAnnotation @RequestMapping: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
ParentController findMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=parent, value=[parent/controller], path=[parent/controller], consume=&lt;span&gt;[])
ChildController findMergedAnnotation @RequestMapping: @com.hjzgg.apigateway.test.service.main.RequestMapping(name&lt;/span&gt;=parent, value=[parent/controller], path=[parent/controller], consume=[])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时@PostMapping没注有@RequestMapping，所以AnnotationUtis.getAnnotation()和AnnotatedElementUtils.getMergeAnnotation()方法获取@RequestMapping信息为空，对应的find*()方法获取到的都是父类@RequestMapping信息。&lt;/p&gt;
&lt;h2&gt;六、相关方法解释&lt;/h2&gt;
&lt;h3&gt;　　AnnotationUtils.getAnnotation&lt;/h3&gt;
&lt;p&gt;　　从提供的AnnotatedElement获取annotationType的单个Annotation，其中注解在AnnotatedElement上存在或元存在。请注意，此方法仅支持单级元注解。要支持任意级别的元注解，请使用findAnnotation（AnnotatedElement，Class）。　　&lt;/p&gt;
&lt;h3&gt;　　AnnotationUtils.findAnnotation&lt;/h3&gt;
&lt;p&gt;　　在提供的AnnotatedElement上查找annotationType的单个Annotation。如果注解不直接出现在提供的元素上，则将搜索元注解。&lt;/p&gt;
&lt;h3&gt;　　AnnotatedElementUtils.isAnnotated&lt;/h3&gt;
&lt;p&gt;　　确定在提供的AnnotatedElement上或指定元素上方的注解层次结构中是否存在指定annotationType的注解。如果此方法返回true，则getMergedAnnotationAttributes方法将返回非null值。&lt;/p&gt;
&lt;h3&gt;　　AnnotatedElementUtils.hasAnnotation&lt;/h3&gt;
&lt;p&gt;　　确定指定的annotationType的注解是否在提供的AnnotatedElement上或在指定元素上方的注解层次结构中可用。如果此方法返回true，则findMergedAnnotationAttributes方法将返回非null值。&lt;/p&gt;
&lt;h3&gt;　　AnnotatedElementUtils.getMergedAnnotation&lt;/h3&gt;
&lt;p&gt;　　在提供的元素上方的注解层次结构中获取指定注解类型的第一个注解，将注解的属性与注解层次结构的较低级别中的注解的匹配属性合并，并将结果合成回指定注解类型的注解。完全支持@AliasFor语义，包括单个注解和注解层次结构。此方法委托给getMergedAnnotationAttributes（AnnotatedElement，Class）和AnnotationUtils.synthesizeAnnotation（Map，Class，AnnotatedElement）。&lt;/p&gt;
&lt;h3&gt;　　AnnotatedElementUtils.findMergedAnnotation&lt;/h3&gt;
&lt;p&gt;　　在提供的元素上方的注解层次结构中查找指定注解类型的第一个注解，将注解的属性与注解层次结构的较低级别中的注解的匹配属性合并，并将结果合成回指定注解类型的注解。完全支持@AliasFor语义，包括单个注解和注解层次结构。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 07:54:00 +0000</pubDate>
<dc:creator>小眼儿</dc:creator>
<og:description>一、前言 spring为开发人员提供了两个搜索注解的工具类，分别是AnnotatedElementUtils和AnnotationUtils。在使用的时候，总是傻傻分不清，什么情况下使用哪一个。于是我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/9790588.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——49. 检查参数有效性 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/9791434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/9791434.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;br/&gt;书中的源代码地址：https://github.com/jbloch/effective-java-3e-source-code&lt;br/&gt;注意，书中的有些代码里方法是基于Java 9 API中的，所以JDK 最好下载 JDK 9以上的版本。但是Java 9 只是一个过渡版本，所以建议安装JDK 10。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4366140-8966e457a14bc8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本章（第8章）讨论了方法设计的几个方面：如何处理参数和返回值，如何设计方法签名以及如何记载方法文档。 本章中的大部分内容适用于构造方法和其他普通方法。 与第4章一样，本章重点关注可用性，健壮性和灵活性上。&lt;/p&gt;
&lt;p&gt;大多数方法和构造方法对可以将哪些值传递到其对应参数中有一些限制。 例如，索引值必须是非负数，对象引用必须为非null。 你应该清楚地在文档中记载所有这些限制，并在方法主体的开头用检查来强制执行。 应该尝试在错误发生后尽快检测到错误，这是一般原则的特殊情况。 如果不这样做，则不太可能检测到错误，并且一旦检测到错误就更难确定错误的来源。&lt;/p&gt;
&lt;p&gt;如果将无效参数值传递给方法，并且该方法在执行之前检查其参数，则它抛出适当的异常然后快速且清楚地以失败结束。 如果该方法无法检查其参数，可能会发生一些事情。 在处理过程中，该方法可能会出现令人困惑的异常。 更糟糕的是，该方法可以正常返回，但默默地计算错误的结果。 最糟糕的是，该方法可以正常返回但是将某个对象置于受损状态，在将来某个未确定的时间在代码中的某些不相关点处导致错误。 换句话说，验证参数失败可能导致违反故障原子性（failure atomicity ）（条目 76）。&lt;/p&gt;
&lt;p&gt;对于公共方法和受保护方法，请使用Java文档&lt;code&gt;@throws&lt;/code&gt;注解来记在在违反参数值限制时将引发的异常（条目 74）。 通常，生成的异常是&lt;code&gt;IllegalArgumentException&lt;/code&gt;，&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;或&lt;code&gt;NullPointerException&lt;/code&gt;（条目 72）。 一旦记录了对方法参数的限制，并且记录了违反这些限制时将引发的异常，那么强制执行这些限制就很简单了。 这是一个典型的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**

 * Returns a BigInteger whose value is (this mod m). This method

 * differs from the remainder method in that it always returns a

 * non-negative BigInteger.

 *

 * @param m the modulus, which must be positive

 * @return this mod m

 * @throws ArithmeticException if m is less than or equal to 0

 */

public BigInteger mod(BigInteger m) {

    if (m.signum() &amp;lt;= 0)

        throw new ArithmeticException(&quot;Modulus &amp;lt;= 0: &quot; + m);

    ... // Do the computation

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，文档注释没有说“如果m为null，mod抛出NullPointerException”，尽管该方法正是这样做的，这是调用&lt;code&gt;m.sgn()&lt;/code&gt;的副产品。这个异常记载在类级别文档注释中，用于包含的&lt;code&gt;BigInteger&lt;/code&gt;类。类级别的注释应用于类的所有公共方法中的所有参数。这是避免在每个方法上分别记录每个&lt;code&gt;NullPointerException&lt;/code&gt;的好方法。它可以与&lt;code&gt;@Nullable&lt;/code&gt;或类似的注释结合使用，以表明某个特定参数可能为空，但这种做法不是标准的，为此使用了多个注解。&lt;/p&gt;
&lt;p&gt;在Java 7中添加的&lt;code&gt;Objects.requireNonNull方&lt;/code&gt;法灵活方便，因此没有理由再手动执行空值检查。 如果愿意，可以指定自定义异常详细消息。 该方法返回其输入的值，因此可以在使用值的同时执行空检查：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Inline use of Java's null-checking facility

this.strategy = Objects.requireNonNull(strategy, &quot;strategy&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以忽略返回值，并使用&lt;code&gt;Objects.requireNonNull&lt;/code&gt;作为满足需求的独立空值检查。&lt;/p&gt;
&lt;p&gt;在Java 9中，java.util.Objects类中添加了范围检查工具。 此工具包含三个方法：&lt;code&gt;checkFromIndexSize&lt;/code&gt;，&lt;code&gt;checkFromToIndex&lt;/code&gt;和&lt;code&gt;checkIndex&lt;/code&gt;。 此工具不如空检查方法灵活。 它不允许指定自己的异常详细消息，它仅用于列表和数组索引。 它不处理闭合范围（包含两个端点）。 但如果它能满足你的需要，那就很方便了。&lt;/p&gt;
&lt;p&gt;对于未导出的方法，作为包的作者，控制调用方法的环境，这样就可以并且应该确保只传入有效的参数值。因此，非公共方法可以使用断言检查其参数，如下所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Private helper function for a recursive sort

private static void sort(long a[], int offset, int length) {

    assert a != null;

    assert offset &amp;gt;= 0 &amp;amp;&amp;amp; offset &amp;lt;= a.length;

    assert length &amp;gt;= 0 &amp;amp;&amp;amp; length &amp;lt;= a.length - offset;

    ... // Do the computation

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本质上，这些断言声称断言条件将成立，无论其客户端如何使用封闭包。与普通的有效性检查不同，断言如果失败会抛出&lt;code&gt;AssertionError&lt;/code&gt;。与普通的有效性检查不同的是，除非使用&lt;code&gt;-ea&lt;/code&gt;(或者-enableassertions）标记传递给java命令来启用它们，否则它们不会产生任何效果，本质上也不会产生任何成本。有关断言的更多信息，请参阅教程&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html&quot;&gt;assert&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;检查方法中未使用但存储以供以后使用的参数的有效性尤为重要。例如，考虑第101页上的静态工厂方法，它接受一个int数组并返回数组的List视图。如果客户端传入null，该方法将抛出NullPointerException，因为该方法具有显式检查(调用Objects.requireNonNull方法)。如果省略了该检查，则该方法将返回对新创建的List实例的引用，该实例将在客户端尝试使用它时立即抛出NullPointerException。 到那时，List实例的来源可能很难确定，这可能会使调试任务大大复杂化。&lt;/p&gt;
&lt;p&gt;构造方法是这个原则的一个特例，你应该检查要存储起来供以后使用的参数的有效性。检查构造方法参数的有效性对于防止构造对象违反类不变性（class invariants）非常重要。&lt;/p&gt;
&lt;p&gt;你应该在执行计算之前显式检查方法的参数，但这一规则也有例外。 一个重要的例外是有效性检查昂贵或不切实际的情况，并且在进行计算的过程中隐式执行检查。 例如，考虑一种对对象列表进行排序的方法，例如&lt;code&gt;Collections.sort(List)&lt;/code&gt;。 列表中的所有对象必须是可相互比较的。 在对列表进行排序的过程中，列表中的每个对象都将与其他对象进行比较。 如果对象不可相互比较，则某些比较操作抛出ClassCastException异常，这正是&lt;code&gt;sort&lt;/code&gt;方法应该执行的操作。 因此，提前检查列表中的元素是否具有可比性是没有意义的。 但请注意，不加选择地依赖隐式有效性检查会导致失败原子性（ failure atomicity）的丢失（条目 76）。&lt;/p&gt;
&lt;p&gt;有时，计算会隐式执行必需的有效性检查，但如果检查失败则会抛出错误的异常。 换句话说，计算由于无效参数值而自然抛出的异常与文档记录方法抛出的异常不匹配。 在这些情况下，你应该使用条目 73中描述的异常翻译（ exception translation）习惯用法将自然异常转换为正确的异常。&lt;/p&gt;
&lt;p&gt;不要从本条目中推断出对参数的任意限制都是一件好事。 相反，你应该设计一些方法，使其尽可能通用。 假设方法可以对它接受的所有参数值做一些合理的操作，那么对参数的限制越少越好。 但是，通常情况下，某些限制是正在实现的抽象所固有的。&lt;/p&gt;
&lt;p&gt;总而言之，每次编写方法或构造方法时，都应该考虑对其参数存在哪些限制。 应该记在这些限制，并在方法体的开头使用显式检查来强制执行这些限制。 养成这样做的习惯很重要。 在第一次有效性检查失败时，它所需要的少量工作将会得到对应的回报。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 07:52:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<og:description>Tips 《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/9791434.html</dc:identifier>
</item>
<item>
<title>lua绑定C++对象系列二——基础模型 - liao0001</title>
<link>http://www.cnblogs.com/liao0001/p/9791290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liao0001/p/9791290.html</guid>
<description>&lt;p&gt;&lt;span&gt;本篇在介绍lua绑定C++的一个最基本的模型，能够很方便的理解lua绑定C++对象后具体使用方式，主要是充分利用的元表的__index特性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码文件r_oo.cpp:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;  1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt;  2&lt;/span&gt; #include &amp;lt;cstring&amp;gt;
&lt;span&gt;  3&lt;/span&gt; #include &amp;lt;stdlib.h&amp;gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; #include &amp;lt;lua.h&amp;gt;
&lt;span&gt;  6&lt;/span&gt; #include &amp;lt;lualib.h&amp;gt;
&lt;span&gt;  7&lt;/span&gt; #include &amp;lt;lauxlib.h&amp;gt;
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;comm.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;luna.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lunar.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;         Student(&lt;span&gt;int&lt;/span&gt; iAge, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; iScore):m_age(iAge), m_score(iScore){};
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;         ~Student(){cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete Student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;}
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;  getAge(){&lt;span&gt;return&lt;/span&gt;&lt;span&gt; m_age;}
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt; iAge){m_age =&lt;span&gt; iAge;}
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; autoGc(lua_State *&lt;span&gt;L){
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             Student** p = (Student**)lua_touserdata(L, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;auto gc. age: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (*p)-&amp;gt;m_age &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; score: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (*p)-&amp;gt;m_score &amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;        }   
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m_age;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m_score;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; create_stdent(lua_State *&lt;span&gt;L)
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     Student** p = (Student**)lua_newuserdata(L, &lt;span&gt;sizeof&lt;/span&gt;(Student*&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     *p = &lt;span&gt;new&lt;/span&gt; Student(&lt;span&gt;15&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;     luaL_getmetatable(L, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MetaStu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     lua_setmetatable(L, -&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get_age(lua_State *&lt;span&gt;L)
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     Student** p = (Student**)lua_touserdata(L, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; iAge = (*p)-&amp;gt;&lt;span&gt;getAge();
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;    lua_pushinteger(L, iAge);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; set_age(lua_State *&lt;span&gt;L)
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     Student** p = (Student**)lua_touserdata(L, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; iAge = lua_tointeger(L, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     (*p)-&amp;gt;&lt;span&gt;setAge(iAge);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; auto_gc (lua_State *&lt;span&gt;L)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     Student** p = (Student**)lua_touserdata(L, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     (*p)-&amp;gt;&lt;span&gt; autoGc(L);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lua_openStudent(lua_State *&lt;span&gt;L)
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; luaL_Reg list[] = {{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, create_stdent}, {NULL, NULL}};
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     luaL_register(L, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, list);
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (luaL_newmetatable(L, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MetaStu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         lua_pushcfunction(L, &amp;amp;&lt;span&gt;get_age);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         lua_setfield(L, -&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getAge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         lua_pushcfunction(L, &amp;amp;&lt;span&gt;set_age);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         lua_setfield(L, -&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;setAge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         lua_pushcfunction(L, &amp;amp;&lt;span&gt;auto_gc);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         lua_setfield(L, -&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__gc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         lua_pushvalue(L, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         lua_setfield(L, -&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     lua_State *L =&lt;span&gt; luaL_newstate();
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;    luaL_openlibs(L);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;     luaL_dofile(L, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tree.lua&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bind to object use metatable&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    lua_openStudent(L);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;    print_stack(L);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;     luaL_dofile(L, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r_oo.lua&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;    print_stack(L);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     lua_settop(L, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    lua_close(L);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上，主要思路有2步：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、  lua_openStudent。只执行一次。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; 注册一个create_student的函数，方便在lua中调用student.create_student()创建student对象。注意，这时create_student创建的是一个userdata结构，存放C++ student的对象指针。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; 针对Student类生成一个全局的元表结构MetaStu, 注册一些元表函数类似setAge, getAge, setScore, getScore等，并且把__index指向元表本身。这样后期通过userdata调用方法时，可以自动在元表中进行查找，看起来更符合OO的使用特点。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1507476/201810/1507476-20181015152827378-1253497235.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、  create_student。按需调用，多次调用创建不同的student对象实例。并且设置userdata的元表为MetaStu。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对应执行的r_oo.lua:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;do&lt;/span&gt;
&lt;span&gt;local&lt;/span&gt; stu =&lt;span&gt; student.create();
print_tree(stu);
print_metatable(stu);
&lt;/span&gt;&lt;span&gt;local&lt;/span&gt; age =&lt;span&gt; stu:getAge();
stu:setAge(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;local&lt;/span&gt; age2 =&lt;span&gt; stu:getAge();
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;old: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; .. age .. &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; new: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; .. age2);

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
stu.setAge(stu,&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;old: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; .. age .. &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; new: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; .. stu:getAge(stu));
&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;
&lt;span&gt;collectgarbage&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;collect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上所示：这里使用了stu:setAge(18)和std. setAge (stu,19)，实际是因为在使用:符号时，系统默认把对象本身作为第一个参数传入，不用再显示，两者语法效果其实是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码执行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;==========Total:2==========
idx:-1 type:5(table) 0x23ca830
idx:-2 type:5(table) 0x23ca8c0
===========================
MetaStu: 0x23c9e38
not a table
&lt;span&gt;table: 0x23ca830
getScore function: 0x402b16
setAge  function: 0x4027be
setScore function: 0x402b5a
__index table: 0x23ca830+
__gc    function: 0x402ba8
getAge  function: 0x40276f
__name  MetaStu&lt;/span&gt;
old: 15 new: 18

old: 15 new: 19
auto gc. age: 19 score: 100
==========Total:2==========
idx:-1 type:5(table) 0x23ca830
idx:-2 type:5(table) 0x23ca8c0
===========================&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上所示：红色标记的就是print_metatable(stu)打印userdata元表的情况。gc垃圾收集会调用注册的__gc元方法，Student::autoGc被成功调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结一下：这是让lua绑定C++对象的最基本模型。使用新创建userdata存放C++对象实例指针，并针对userdata设置元表，元表中注册各种C++的方法，并让__index指向元表自身，这样当使用诸如stu.setAge时，会通过__index指向的table进行索引，当__index指向自身就直接索引自身即可。这样在lua中创建userdata后，create_student接口也会自动创建C++对象关联在一起，并且在使用userdata过程中可以像C++引用成员方法一样去使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 07:50:00 +0000</pubDate>
<dc:creator>liao0001</dc:creator>
<og:description>lua绑定C++对象的最基本模型。使用新创建userdata存放C++对象实例指针，并针对userdata设置元表，元表中注册各种C++的方法，并让__index指向元表自身，这样当使用诸如stu.s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liao0001/p/9791290.html</dc:identifier>
</item>
<item>
<title>如何通过本地化事件正确实现微服务内部强一致性，事件总线跨微服务间最终一致性 - Ahoo-Wang</title>
<link>http://www.cnblogs.com/Ahoo-Wang/p/micoservice-eventbus.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ahoo-Wang/p/micoservice-eventbus.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;设计重点&lt;/li&gt;
&lt;li&gt;流程图&lt;/li&gt;
&lt;li&gt;伪代码&lt;br/&gt;2.1. PublishEvent&lt;br/&gt;2.2. SubscribeEvent&lt;br/&gt;2.3. Publisher&lt;br/&gt;2.4. Subscriber&lt;/li&gt;
&lt;li&gt;微服务 强一致性&lt;br/&gt;3.1 Publisher&lt;br/&gt;3.2 Subscriber&lt;/li&gt;
&lt;li&gt;事件总线 - 跨服务 最终一致性&lt;br/&gt;4.1 Publisher &amp;amp; Subscriber 都开启了本地事务，保证了强一致性&lt;br/&gt;4.2 问题场景一：当 ③ 发布失败怎么办？&lt;br/&gt;4.3 问题场景二：当 ③ 发布成功，但 ④ 更新事件状态失败怎么办？&lt;br/&gt;4.4 问题场景三：Publisher 端Ok,Subscriber 消费出错&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;设计重点&quot;&gt;0. 设计重点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Publisher&lt;/strong&gt; 本地化 &lt;strong&gt;PublishEvent&lt;/strong&gt; 保证事件发布可靠性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subscriber&lt;/strong&gt; 本地化 &lt;strong&gt;SubscribeEvent&lt;/strong&gt; 保证事件订阅可靠性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SubscribeEvent&lt;/strong&gt; 通过 EventId &amp;amp; HandlerType 组合约束 保证不重复消费事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件中央控制台&lt;/strong&gt; 处理 &lt;strong&gt;Publisher&lt;/strong&gt; &amp;amp; &lt;strong&gt;Subscriber&lt;/strong&gt; 事件重试&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h2 id=&quot;执行流程图&quot;&gt;1. 执行流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/457833/201708/457833-20170805115929506-1478785311.png&quot; alt=&quot;执行流程图&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;伪代码&quot;&gt;2. 伪代码&lt;/h2&gt;
&lt;h3 id=&quot;publishevent&quot;&gt;2.1 PublishEvent&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    public abstract class Event
    {
        public Event()
        {
            Id = Guid.NewGuid();
            CreationTime = DateTime.UtcNow;
        }

        public Guid Id { get; set; }
        public DateTime CreationTime { get; set; }
    }

    public class PublishEvent : Event
    {
        public PublishEvent(Event @event)
        {
            Id = @event.Id;
            CreationTime = @event.CreationTime;
            Type = @event.GetType().FullName;
            Data = JsonConvert.SerializeObject(@event);
            Status = PublishEventStatus.NotPublished;
        }

        public String Type { get; set; }
        public String Data { get; set; }
        public PublishEventStatus Status { get; set; }
    }

    public enum PublishEventStatus
    {
        NotPublished = 0,
        Published = 1,
        PublishedFailed = 2
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;subscribeevent&quot;&gt;2.2 SubscribeEvent&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    public class SubscribeEvent
    {
        public SubscribeEvent(Event @event, IEventHandler handler)
        {
            EventId = @event.Id;
            EventCreationTime = @event.CreationTime;
            EventType = @event.GetType().FullName;
            EventData = JsonConvert.SerializeObject(@event);
            HandlerType = handler.GetType().FullName;
            HandlingStatus = HandlingStatus.HandleSucceeded;
            HandlingTime = DateTime.Now;
        }
        public Guid EventId { get; set; }
        public String EventType { get; set; }
        public String EventData { get; set; }
        public DateTime EventCreationTime { get; set; }
        public String HandlerType { get; set; }
        public DateTime HandlingTime { get; set; }
        public HandlingStatus HandlingStatus { get; set; }
    }
    public enum HandlingStatus
    {
        HandleSucceeded = 0,
        HandleFailed = 1
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;publisher&quot;&gt;2.3 Publisher&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    try
    {
        BeginTransaction(); // ①
        //Biz Flow
        EventRepository.PubilshEvent(@event);// ②
        CommitTransaction();
    }
    catch(Exception ex){
        RollbackTransaction();
        throw ex;
    }
    EventBus.Publish(@event); // ③
    EventResitory.EventPublished(@event.ToString()); // ④&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;subscriber&quot;&gt;2.4 Subscriber&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    try
    {
        BeginTransaction();
        //Biz Flow
        EventRepository.SubscribeEvent(@event , eventHandler); // ⑤
        CommitTransaction();
    }
    catch(Exception ex){
        RollbackTransaction();
        throw ex;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;微服务-强一致性&quot;&gt;3. 微服务 强一致性&lt;/h2&gt;
&lt;h3 id=&quot;publisher-1&quot;&gt;3.1 Publisher&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;开启本地事务达到强一致性&lt;/li&gt;
&lt;li&gt;执行本地业务代码&lt;/li&gt;
&lt;li&gt;本地事务内部保存事件 &lt;strong&gt;预发布&lt;/strong&gt; 状态 &lt;strong&gt;②&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;发布事件到事件总线 &lt;strong&gt;③&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;修改事件发布状态为&lt;strong&gt;已发布&lt;/strong&gt; &lt;strong&gt;④&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;subscriber-1&quot;&gt;3.2 Subscriber&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;开启本地事务达到强一致性&lt;/li&gt;
&lt;li&gt;执行本地业务代码&lt;/li&gt;
&lt;li&gt;保存订阅事件到本地仓库&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h2 id=&quot;事件总线---跨服务-最终一致性&quot;&gt;4 事件总线 - 跨服务 最终一致性&lt;/h2&gt;
&lt;h3 id=&quot;publisher-subscriber-都开启了本地事务保证了强一致性&quot;&gt;4.1 Publisher &amp;amp; Subscriber 都开启了本地事务，保证了强一致性&lt;/h3&gt;
&lt;hr/&gt;&lt;h3 id=&quot;问题场景一当-发布失败怎么办&quot;&gt;4.2 问题场景一：当 ③ 发布失败怎么办？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;③&lt;/strong&gt; 发布失败，意味着抛出异常，则 &lt;strong&gt;④&lt;/strong&gt; 不执行，那么事件状态依然保持 &lt;strong&gt;预发布&lt;/strong&gt;状态&lt;/li&gt;
&lt;li&gt;后续 &lt;strong&gt;事件重试&lt;/strong&gt; 重新发布该事件，并更新事件状态为 &lt;strong&gt;已发布&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3 id=&quot;问题场景二当-发布成功但-更新事件状态失败怎么办&quot;&gt;4.3 问题场景二：当 ③ 发布成功，但 ④ 更新事件状态失败怎么办？&lt;/h3&gt;
&lt;h4 id=&quot;场景二一-subscriber-订阅成功&quot;&gt;4.3.1 场景二·一 Subscriber 订阅成功&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;③&lt;/strong&gt; 发布成功，但 &lt;strong&gt;④&lt;/strong&gt; 更新事件状态失败，事件状态依然是 &lt;strong&gt;预发布状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subscriber&lt;/strong&gt; 订阅到该事件后成功执行完业务代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subscriber&lt;/strong&gt; 将订阅事件保存到本地订阅事件仓库 &lt;strong&gt;⑤&lt;/strong&gt;&lt;br/&gt;该场景存在的问题： &lt;strong&gt;Publisher&lt;/strong&gt; 会通过 &lt;strong&gt;事件重试&lt;/strong&gt; 再次发布 &lt;strong&gt;预发布&lt;/strong&gt; 状态的事件，那么此时&lt;strong&gt;Subscriber&lt;/strong&gt; 将重复消费该事件&lt;br/&gt;方案：该问题我们可以通过将 &lt;strong&gt;SubscribeEvent&lt;/strong&gt; EventId &amp;amp; HandlerType 组合唯一约束，来避免重复消费&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;场景二二-subscriber-订阅失败&quot;&gt;4.3.2 场景二·二 Subscriber 订阅失败&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;③&lt;/strong&gt; 发布成功，但 &lt;strong&gt;④&lt;/strong&gt; 更新事件状态失败，事件状态依然是 &lt;strong&gt;预发布状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subscriber&lt;/strong&gt; 执行消费失败&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subscriber&lt;/strong&gt; 回滚本地事务&lt;br/&gt;该场景不存在任何问题，因为 &lt;strong&gt;Publisher&lt;/strong&gt; 会通过 &lt;strong&gt;事件重试&lt;/strong&gt; 再次发布 &lt;strong&gt;预发布&lt;/strong&gt; 状态的事件 。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3 id=&quot;问题场景三publisher-端oksubscriber-消费出错&quot;&gt;4.4 问题场景三：Publisher 端Ok,Subscriber 消费出错&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Publisher&lt;/strong&gt; 端处理顺利&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subscriber&lt;/strong&gt; 消费失败，回滚本地事务，此时 &lt;strong&gt;SubscribeEvent&lt;/strong&gt; 未存储到本地仓库&lt;br/&gt;该场景存在的问题：&lt;br/&gt;&lt;strong&gt;Publisher&lt;/strong&gt; 发送成功，并且本地 &lt;strong&gt;PublishEvent&lt;/strong&gt; 事件为&lt;strong&gt;已发布&lt;/strong&gt;，那么意味着从&lt;strong&gt;Publisher&lt;/strong&gt;端是无法知道&lt;strong&gt;Subscriber&lt;/strong&gt;消费失败需要&lt;strong&gt;重新消费&lt;/strong&gt;&lt;br/&gt;解决方案：&lt;/li&gt;
&lt;li&gt;通过检测 &lt;strong&gt;PublishEvent&lt;/strong&gt; &amp;amp; &lt;strong&gt;SubscribeEvent&lt;/strong&gt; 获得需要 &lt;strong&gt;事件重试&lt;/strong&gt; 的 &lt;strong&gt;PublishEvent&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;strong&gt;PublishEvent&lt;/strong&gt; &lt;strong&gt;重新发布&lt;/strong&gt; 到 &lt;strong&gt;Subscriber&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h2 id=&quot;通过nuget安装组件支持以上编程模型&quot;&gt;5. 通过Nuget安装组件支持以上编程模型&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Install-Package SmartEventBus.RabbitMQImpl
Install-Package SmartEventBus.Repository&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ormsmartsql-广而告之&quot;&gt;6. ORM:SmartSql 广而告之&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Ahoo-Wang/SmartSql&quot;&gt;SmartSql = Dapper + MyBatis + Cache(Memory | Redis) + ZooKeeper + R/W Splitting + ......&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 07:23:00 +0000</pubDate>
<dc:creator>Ahoo-Wang</dc:creator>
<og:description>目录 0. 设计重点 1. 流程图 2. 伪代码 2.1. PublishEvent 2.2. SubscribeEvent 2.3. Publisher 2.4. Subscriber 3. 微服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ahoo-Wang/p/micoservice-eventbus.html</dc:identifier>
</item>
<item>
<title>深入理解Java中停止线程 - 真正的小明被占用了</title>
<link>http://www.cnblogs.com/SAM-CJM/p/9787929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SAM-CJM/p/9787929.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一.停止线程会带来什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于单线程中，停止单线程就是直接使用关键字return或者break，但是在停止多线程时是让线程在完成任务前去开启另外一条线程，必须放弃当前任务，而这个过程是不可预测，所以必须去做好防备。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二.认识停止线程的几个方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 2.1三个被弃用的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; stop（）、suspend（）、resume（）。&lt;/p&gt;
&lt;p&gt; stop（）方法被弃用的原因：无论线程执行到了什么位置，一旦被stop就会被马上强制中断，并且释放线程所有持有锁对象，根本就没有安全性。&lt;/p&gt;
&lt;p&gt; suspend（）和resume（）这一对烂兄烂弟，因为只有其他线程调用resume这个方法时他才会释放suspend这个方法的锁，这样就极易造成死锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 2.2三个名字差不多的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  interrupt（）中断线程、interrupted（）判断当前线程是否停止、isInterrupted（）判断线程是否停止。&lt;/p&gt;
&lt;p&gt; 首先来介绍一下其中两个名字最相近的：interrupted（）、isInterrupted（）方法，这两个方法是用来测试线程是否被中断的。&lt;/p&gt;
&lt;p&gt; 来看一下原码：&lt;/p&gt;
&lt;p&gt;isInterrupted（）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isInterrupted() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; isInterrupted(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; interrupted（）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; interrupted() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; currentThread().isInterrupted(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以明显看出interrupted（）方法是静态的，而isInterrupted（）是非静态的，但都是返回线程是否被中断。　　&lt;/p&gt;
&lt;p&gt;下面我们来做一个测试，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Is_Interrupt &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;1000;i++&lt;span&gt;){
                System.out.println(&lt;/span&gt;&quot;当前i的值为:&quot;+&lt;span&gt;i);
            }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
            Is_Interrupt is_interrupt&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Is_Interrupt();
            is_interrupt.start();
            is_interrupt.interrupt();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断线程&lt;/span&gt;
            System.out.println(&quot;线程是否已经暂停？&quot;+&lt;span&gt;is_interrupt.interrupted());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 输出结果为：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181014204408732-72168405.png&quot; alt=&quot;&quot; width=&quot;166&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现线程没有停止。&lt;/p&gt;
&lt;p&gt;但是这里面还有一个线程就是main线程，而&lt;span&gt;interrupted()&lt;/span&gt;返回的就是当前线程的中断状态，那么执行这个方法的就是main线程，而main线程此时当然没有中断。&lt;/p&gt;
&lt;p&gt;我们将&lt;span&gt;interrupted()&lt;/span&gt;方法改为isInterrupted()试试效果,代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Is_Interrupt &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;1000;i++&lt;span&gt;){
                System.out.println(&lt;/span&gt;&quot;当前i的值为:&quot;+&lt;span&gt;i);
            }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
            Is_Interrupt is_interrupt&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Is_Interrupt();
            is_interrupt.start();
            is_interrupt.interrupt();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断线程&lt;/span&gt;
            System.out.println(&quot;线程是否已经暂停？&quot;+&lt;span&gt;is_interrupt.isInterrupted());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181014205805308-813047002.png&quot; alt=&quot;&quot; width=&quot;179&quot; height=&quot;177&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明线程是已经停止了的，只不过我们使用错了一个方法而已判断成了main线程的状态。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;span&gt;isInterrupted&lt;/span&gt;方法是返回调用对象的中断状态，而静态方法&lt;span&gt;interrupted&lt;/span&gt;是返回当前线程的中断状态。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;既然了解了这个误区以后我们再来看看下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterruptText &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;main线程启动!&quot;&lt;span&gt;);
        System.out.println( Thread.interrupted());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前线程是否中断&lt;/span&gt;
        System.out.println(currentThread().isInterrupted());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过currentThread().isInterrupted()同样也可以达到相同的目的，在单线程中&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181015085904870-542256606.png&quot; alt=&quot;&quot;/&gt;这个是没有问题的。&lt;/p&gt;
&lt;p&gt;那么我们多次调用这个interrupted方法呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterruptText &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;main线程启动!&quot;&lt;span&gt;);
        currentThread().interrupt();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断main线程&lt;/span&gt;
        System.out.println( Thread.interrupted());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前main线程是否中断&lt;/span&gt;
        System.out.println( Thread.interrupted());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再一次判断当main前线程是否中断&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181015090438731-123835103.png&quot; alt=&quot;&quot;/&gt;按照常理应该两次返回ture，但是为什么变成了第二次变成了false了呢？&lt;/p&gt;
&lt;p&gt;其实interrupted就是在清除状态，你两次调用当然会将true变成flase但是他还是中断状态，但是isInterrupted是不清除的。&lt;/p&gt;
&lt;p&gt;interrupt（）方法：中断线程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三.停止线程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1通过异常来暂停线程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 首先来看一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterruptText &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000; i++&lt;span&gt;) {

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (currentThread().isInterrupted()) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果线程中断&lt;/span&gt;
                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InterruptedException();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛出异常&lt;/span&gt;
                } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    System.out.println(i);
                }

            }
            System.out.println(&lt;/span&gt;&quot;线程没有终止&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e){
            e.printStackTrace();
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        InterruptText interruptText&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptText();
        interruptText.start();
        Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
        interruptText.interrupt();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181015144608523-320173216.png&quot; alt=&quot;&quot; width=&quot;424&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;
&lt;p&gt;异常停止方法的策略就是：在遇到中断时，抛出异常，扑捉异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.2在睡眠中中断线程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterruptText2 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;10000);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程睡眠&lt;/span&gt;
        } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        InterruptText2 interruptText2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptText2();
        interruptText2.start();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启线程，但是线程处于睡眠状态&lt;/span&gt;
        interruptText2.interrupt();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在睡眠状态中断线程&lt;/span&gt;
&lt;span&gt;        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果为：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181015145907872-1900004814.png&quot; alt=&quot;&quot; width=&quot;406&quot; height=&quot;145&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.3线程让步&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 方法：yield（），当前线程放弃所有的资源，去执行其他的任务。但是放弃资源的时间不可以预判的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.4守护线程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 守护线程的定义：守护线程是一种特殊的线程，区别于非守护线程，当程序中不存在非守护线程时，守护线程退出，程序退出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置守护线程：&lt;span&gt;setDaemon(),参数为ture则该线程为守护线程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 15 Oct 2018 07:13:00 +0000</pubDate>
<dc:creator>真正的小明被占用了</dc:creator>
<og:description>一.停止线程会带来什么？ 对于单线程中，停止单线程就是直接使用关键字return或者break，但是在停止多线程时是让线程在完成任务前去开启另外一条线程，必须放弃当前任务，而这个过程是不可预测，所以必</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SAM-CJM/p/9787929.html</dc:identifier>
</item>
<item>
<title>Mybait缓存机制（四） - Miya。</title>
<link>http://www.cnblogs.com/SimpleWu/p/9783191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/9783191.html</guid>
<description>&lt;p&gt;MyBatis同大多数ORM框架一样，提供了一级缓存和二级缓存的支持。&lt;/p&gt;
&lt;p&gt;一级缓存：其作用域为session范围内，当session执行flush或close方法后，一级缓存会被清空。&lt;/p&gt;
&lt;p&gt;二级缓存：二级缓存和一级缓存机制相同，但是可以自定义其作用范围，如Ehcache。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一级缓存&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在默认情况下mybatis中的一级缓存是开启的，一级缓存只在同一个SqlSession中有效不可以跨SqlSession。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testcache(){
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 测试一级缓存
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        SqlSession session1 &lt;/span&gt;=&lt;span&gt; sqlSessionFactory.openSession();
        EmployeeMapper employeeMapper &lt;/span&gt;= session1.getMapper(EmployeeMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        List&lt;/span&gt;&amp;lt;Employee&amp;gt;  list1 = employeeMapper.findAll(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        System.out.println(list1);
        List&lt;/span&gt;&amp;lt;Employee&amp;gt;  list2 = employeeMapper.findAll(&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不发送语句&lt;/span&gt;
&lt;span&gt;        System.out.println(list2);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SqlSession调用clearCache（）清除缓存，或者在执行增删改操作后，SqlSession调用close（），commit（）都会清理缓存。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二级缓存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;MyBatis中使用二级缓存也非常简单，首先开启全局二级缓存配置信息，通过开启cacheEnabled，然后在对应的mapper映射文件中使用&amp;lt;cache /&amp;gt;标签开启二级缓存即可。&lt;/p&gt;
&lt;p&gt;1.select 语句获取出来的对象都会被缓存。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.二级缓存所有实体类必须实现Serializable接口。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.所有执行 insert,update 和 delete 语句后，缓存都会被刷新。&lt;br/&gt;&lt;span&gt;&lt;strong&gt;4.必须关闭session后才会写入二级缓存中。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5.二级缓存的作用域是全局的，作用范围是映射文件级别的。只在同一类型mapper映射对象中有效。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.查询数据时，会先查询二级缓存，再查询一级缓存，然后再查询数据库。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们需要使用二级缓存必须在mybatis主配置文件中设置cacheEnabled设置为true，并且在实体类Mapper中启用缓存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 开启驼峰式命名规则 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;setting &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mapUnderscoreToCamelCase&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 开启二级缓存 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;setting &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;cacheEnabled&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;EmployeeMapper.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用mybatis默认二级缓存 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;cache&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以开启我们的二级缓存了，但是这使用至少mybatis默认的二级缓存，mybatis缓存做的并怎么的好，所有我们需要整合第三方缓存机制。&lt;/p&gt;
&lt;p&gt;EhCache 是一个纯Java的进程内缓存框架，是一种广泛使用的开源Java分布式缓存，具有快速、精干等特点，是Hibernate中默认的二级缓存。所以我们来整合Ehcache&lt;/p&gt;
&lt;p&gt;导入：mybatis-ehcache-1.0.3.jar ，ehcache-core-2.6.8.jar，slf4j-api-1.7.25.jar ，slf4j-log4j12-1.7.25.jar&lt;/p&gt;
&lt;p&gt;这个时候我们只需要在实体类指定只用EhCache缓存即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用第三方缓存 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;cache &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以创建ehcache.xml配置文件也可以直接配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;cache &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;timeToIdleSeconds&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;3600&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;1 hour&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;timeToLiveSeconds&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;3600&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;1 hour&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;maxEntriesLocalHeap&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;1000&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;maxEntriesLocalDisk&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;10000000&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;memoryStoreEvictionPolicy&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;LRU&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;cache&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二级缓存属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;cache &lt;/span&gt;&lt;span&gt;eviction&lt;/span&gt;&lt;span&gt;=&quot;FIFO&quot;&lt;/span&gt;&lt;span&gt; flushInterval&lt;/span&gt;&lt;span&gt;=&quot;60000&quot;&lt;/span&gt;&lt;span&gt; size&lt;/span&gt;&lt;span&gt;=&quot;512&quot;&lt;/span&gt;&lt;span&gt; readOnly&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181013155814867-1131876020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;和缓存相关的设置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.核心配置文件中的cacheEnabled=true|false，开启或关闭缓存(默认为true)，只对二级缓存有效，对一级缓存无效。&lt;br/&gt;2.在select标签中有一个属性useCache=true|false，开启当前查询标签的缓存(默认为true)，也是只对二级缓存有效，对一级缓存无效。&lt;br/&gt;3.在每个增删改标签中都有一个flushCache=true|false属性，设置是否清除缓存(默认为true)。一级和二级缓存都会被清空。&lt;br/&gt;4.在查询中也有flushCache=true|false 属性(默认为false)，如果设置为true，则每次查询之后都会清除缓存。&lt;br/&gt;5.sqlsession.clearCache()方法，清除缓存。只能清除一级缓存，对二级缓存无效。&lt;br/&gt;6.全局配置文件中的localCacheScope属性，表示本地缓存作用域（一级缓存）。取值为session|statement。默认为session。如果设置为statement，一级缓存会被禁用掉。&lt;/p&gt;

</description>
<pubDate>Mon, 15 Oct 2018 07:01:00 +0000</pubDate>
<dc:creator>Miya。</dc:creator>
<og:description>MyBatis同大多数ORM框架一样，提供了一级缓存和二级缓存的支持。 一级缓存：其作用域为session范围内，当session执行flush或close方法后，一级缓存会被清空。 二级缓存：二级缓</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/9783191.html</dc:identifier>
</item>
<item>
<title>【4opencv】识别复杂的答题卡1（主要算法） - jsxyhelu</title>
<link>http://www.cnblogs.com/jsxyhelu/p/9790992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jsxyhelu/p/9790992.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、问题提出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    由于GPY进行了纠偏，所以在采集的时候，就已经获得了质量较高的答题卡图片&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145610871-1577011364.jpg&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/div&gt;
&lt;p&gt;下一步就是需要从这张图片中，识别出人眼识别出来的那些信息，并且将这个过程尽可能地鲁棒化，提高识别的准确率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、思路探索&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在从图片到数字的转变过程中，既是一个“量化”的过程，也是一个“降维”的过程，需要特定的角度非常重要。这就像很多人站在一起拍集体照，选择不同的角度能够得到这群人不同的像，高明的摄像师能够很快地找到角度，将所有的人都拍摄其中；我们图像处理程序也是同样的道理，有经验的工程师能够善于模式思考，快速找到解决方法的途径。&lt;/p&gt;
&lt;p&gt;    对于我们这里的这张答题卡图片，和之前的较为简单的答题卡想比较，有很多不同，比较两者的二值图片，就可以发现：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145611148-2006800117.png&quot; alt=&quot;&quot; name=&quot;&quot; width=&quot;273&quot; height=&quot;305&quot;/&gt;  V  S&lt;img class=&quot;size-full wp-image-4570&quot; src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145611653-1393381482.png&quot; alt=&quot;Figure 5: Using Otsu's thresholding allows us to segment the foreground from the background of the image.&quot; name=&quot;&quot; width=&quot;266&quot; height=&quot;329&quot;/&gt;&lt;/div&gt;
&lt;p&gt;最大的不同在于没有可以供标定的&lt;span&gt;基础点。因此我们必须采用其它的方法来进行定位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此外，答题区域为矩形密集分布，因此我想到的是直接“网格化”进行处理。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;三、算法过程和主要代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1:灰度-二值-形态学&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145611860-613410530.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145612026-211063316.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145612205-1601936841.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;step2:轮廓分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对识别出来的二值图像通过轮廓进一步地进行处理，得到下图的&lt;span&gt;识别结果，就为下一步定量打下基础&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145612357-2012785.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145612602-414899165.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;step3:模板匹配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想得到识别的结果，首先就是需要对现有的图片进行分割出来。&lt;span&gt;在没有定位点的前提下，如何准确切割？&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145612887-1645933277.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;根据以前的经验，基本的思路是这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;a、根据模板识别，准确的获得可定位地址（比如我选择使用“选择题答题卡”几个字作为模板，得到下图定位结果，注意图中白点）；&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145613085-1367882173.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;b、而后采用经典的“纵横”方法进行识别。（这里我对各个距离进行了测量和标注）&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145613594-930868941.jpg&quot; alt=&quot;&quot; name=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;细节：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145614834-565620359.jpg&quot; alt=&quot;&quot; name=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;编写以下代码：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145615064-1217036554.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;得到以下结果：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145615244-2093015795.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;step4:分块面积识别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接识别划分区域的面积，得到定量结果&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145615451-1041645661.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145615632-974681101.png&quot; alt=&quot;&quot; name=&quot;&quot; width=&quot;119&quot; height=&quot;146&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145615825-1892437764.png&quot; alt=&quot;&quot; name=&quot;&quot; width=&quot;121&quot; height=&quot;145&quot;/&gt;&lt;/div&gt;
&lt;p&gt;全图：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145616070-1619492351.jpg&quot; alt=&quot;&quot; name=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;细节：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145616341-281448089.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;step5:转化得到识别结果&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;编写相关识别的结果为：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145616512-1639575994.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508489/201810/508489-20181015145616717-883261705.jpg&quot; alt=&quot;&quot; name=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;四、需要注意的地方：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、模板识别对于不同尺度采集的图片，是否具有通用性。故我需要在不同的图片、不同的采集模式下进行探索；&lt;/p&gt;
&lt;p&gt;2、目前识别出来的结果缺乏对答题结果“重复”“遗漏”情况分析；&lt;/p&gt;
&lt;p&gt;3、&lt;span&gt;我们看见的是彩色或者灰度图像，实际上，需要识别出来的是bin区域。在实验的过程中，我们会用到“&lt;/span&gt;&lt;span&gt;彩色或者灰度”作为背景。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;至此，复杂答题卡的算法部分基本完成。感谢阅读至此，希望有所帮助。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 15 Oct 2018 06:53:00 +0000</pubDate>
<dc:creator>jsxyhelu</dc:creator>
<og:description>一、问题提出 由于GPY进行了纠偏，所以在采集的时候，就已经获得了质量较高的答题卡图片 下一步就是需要从这张图片中，识别出人眼识别出来的那些信息，并且将这个过程尽可能地鲁棒化，提高识别的准确率。 二、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jsxyhelu/p/9790992.html</dc:identifier>
</item>
<item>
<title>XAML属性赋值转换之谜（WPF XAML语法解密） - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/xaml_property_setting.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/xaml_property_setting.html</guid>
<description>&lt;p&gt;&lt;span&gt;XAML与XML类似，就是XML延伸过来的。为了更好的表达一些功能，WPF对XML做了扩展，有些功能是WPF在后台悄悄的替你做了。有时候，虽然实现了某个功能，但是对实现原理还是很茫然。今天就讲讲XAML中赋值操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1 通过类型转换赋值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;赋值是最简单最常见的操作，举例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &amp;lt;Button  Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
 &amp;lt;/Button&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里把Width值赋值为200；用代码实现赋值，则为Button.With = 200; 这种赋值操作很直接，大家都能理解。但是仔细想想，感觉有点不对劲。XAML表达式Width=&quot;200&quot;,这里200是字符串，Width类型是double。字符串200怎么就转换成double了！你会说，200很明显可以转换为double类型，有什么大惊小怪的！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有时，程序实现的逻辑操作很傻瓜，人很容易理解的事，程序并不一定能理解。需要你告诉XAML编译器，怎么把字符串型转换成double型。确实有 一个转换类悄悄的把字符串型转换成了double型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过元文件，可以查到Width属性定义。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     获取或设置元素的宽度。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     元素的宽度，单位是与设备无关的单位（每个单位 1/96 英寸）。默认值为 System.Double.NaN。此值必须大于等于 0.0。有关上限信息，请参见“备注”。&lt;/span&gt;
        [Localizability(LocalizationCategory.None, Readability =&lt;span&gt; Readability.Unreadable)]
        [TypeConverter(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(LengthConverter))]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Width { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;Width属性定义[TypeConverter(typeof(LengthConverter))]。这句话就表明width转换类型是LengthConverter。当XAML编译器看到Width赋值操作，就会调用LengthConverter。输入是字符串，返回就是double。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;你可能感觉到，对这个属性讲解有点啰嗦。我这里是想告诉你：几乎所有的赋值操作，都需要这种转换。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;引申：&lt;/strong&gt; 更深一步讲，如果我们定义了一个属性，这个属性是一个复杂的类型。在XAML如何赋值？ 比如自己定义了类型如下：&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyPointItem
 {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Latitude { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Longitude { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
 }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 有一个类包含此属性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass
 {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyPointItem Item { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
 }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在XAML语法中如何对Item赋值，XAML语法只认识字符串型。这时需要参考上文Width处理方式。需要自己定义些转换类。定义一个类型继承TypeConverter，实现里面的函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如这样赋值MyClass.Item = &quot;123,456&quot;;你需要告诉编译器，如何将&quot;123,456&quot;转化成类型MyPointItem。这里字符串用逗号分隔，你可以用别的符号分隔；比如“#”，只要你的转换函数能处理就行。完整的处理函数如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义转换类型&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyPointItemConverter : TypeConverter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanConvertFrom( ITypeDescriptorContext context, Type sourceType)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sourceType &lt;span&gt;is&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CanConvertFrom(context, sourceType);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanConvertTo(ITypeDescriptorContext context, Type destinationType)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (destinationType &lt;span&gt;is&lt;/span&gt;&lt;span&gt; MyPointItem)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CanConvertTo(context, destinationType);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; ConvertFrom(ITypeDescriptorContext context,
                    CultureInfo culture, &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyPointItem.Parse(value &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot convert '{0}' ({1}) because {2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, value, value.GetType(), ex.Message), ex);
                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.ConvertFrom(context, culture, value);
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; ConvertTo(ITypeDescriptorContext context,
            CultureInfo culture, &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; value, Type destinationType)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (destinationType == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;destinationType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            MyPointItem gpoint &lt;/span&gt;= value &lt;span&gt;as&lt;/span&gt;&lt;span&gt; MyPointItem;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gpoint != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CanConvertTo(context, destinationType))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; gpoint.ToString();

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.ConvertTo(context, culture, value, destinationType);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义类型&lt;/span&gt;
    [TypeConverter(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MyPointItemConverter))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyPointItem
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Latitude { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Longitude { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MyPointItem Parse(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; data)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(data))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyPointItem();

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] items = data.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用逗号分隔，和XAML赋值中字符串分隔符保持一致&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (items.Count() != &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FormatException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;should have both latitude and longitude&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; lat, lon;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                lat &lt;/span&gt;= Convert.ToDouble(items[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FormatException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Latitude value cannot be converted&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ex);
            }

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                lon &lt;/span&gt;= Convert.ToDouble(items[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FormatException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Longitude value cannot be converted&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ex);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyPointItem() { Latitude=lat, Longitude=&lt;span&gt;lon };
        }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;转换类型不是万能的&lt;/strong&gt;： 只有类型转换，也会遇到难以处理的情况。比如&lt;/span&gt;MyClass.Item = &quot;null&quot;。我的意思是将Item赋值为null。但是编译不会这么处理，仍然会调用转换类型MyPointItemConverter，结果就会抛出异常！WPF为此又引入了扩展标识符的概念。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2 扩展标识符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
扩展标识符有特殊的语法，如果属性赋值为null，语法如下:&lt;br/&gt;MyClass.Item =&quot;{x:Null}&quot;; 这里的Null其实是一个类型，继承自MarkupExtension；
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     实现 XAML 标记以返回 null 对象，可使用该对象在 XAML 中将值显式设置为 null。&lt;/span&gt;
    [MarkupExtensionReturnType(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;))]
    [TypeForwardedFrom(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NullExtension : MarkupExtension
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     初始化 System.Windows.Markup.NullExtension 类的新实例。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; NullExtension();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     提供要用作值的 null 作为此标记扩展的输出。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   serviceProvider:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     可为标记扩展实现提供服务的对象。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     空引用。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; ProvideValue(IServiceProvider serviceProvider);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;MyClass.Item =&quot;{x:Null}&quot;这句话的意思就是：编译器生成类型NullExtension，调用函数ProvideValue，将此返回值赋值给MyClass.Item；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;再举个例子：&lt;br/&gt;Height=&quot;{x:Static SystemParameters.IconHeight}”； &lt;/strong&gt;编译器处理逻辑是：生成类型StaticExtension，将字符串“SystemParameters.IconHeight”传给构造函数，调用函数ProvideValue，返回double类型。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其实StaticExtension会将字符串“SystemParameters.IconHeight”认为一个静态变量。XAML眼里只有字符串！&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;br/&gt;绑定 -- 一种很常用的扩展标识符类型&lt;br/&gt;&lt;/strong&gt;&lt;span&gt;看如下语法：&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &amp;lt;Button  Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                 Content&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding Height,RelativeSource={RelativeSource Self}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;/Button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对content的赋值，是不是感到一头雾水！ binding其实也是扩展标识，最终继承自MarkupExtension；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Binding : BindingBase --&amp;gt; BindingBase : MarkupExtension;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以binding的作用也是将字符串转换成我们需要的类型。不过binding的参数比较多，有时候需要转好几个弯，才能找到真的源头！&lt;/p&gt;
&lt;p&gt;对于上面的赋值，咱做个分析,来看看编译器处理的步骤：&lt;/p&gt;
&lt;p&gt;  1）生成Binding类型，构造函数传入“Height”，&lt;/p&gt;
&lt;p&gt;   2）Binding有一个属性为RelativeSource，参见元文件&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     通过指定绑定源相对于绑定目标的位置，获取或设置绑定源。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     一个 System.Windows.Data.RelativeSource 对象，该对象指定要使用的绑定源的相对位置。默认值为 null。&lt;/span&gt;
        [DefaultValue(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelativeSource RelativeSource { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;仔细看看代码，属性类型和变量名称都是RelativeSource，这是c#语法允许的。&lt;strong&gt;当然，这样做会使人困惑！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;&lt;strong&gt;RelativeSource={RelativeSource Self}&lt;/strong&gt;，第一个RelativeSource其实是Binding的属性名称，第二个是类型名。Self是一个枚举值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这句话的意思就是，生成一个类型RelativeSource，构造函数是枚举值Self；将这个变量赋值给属性RelativeSource。&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span readability=&quot;4&quot;&gt;3） 当Content需要值时，就会调用Binding的ProvideValue。这个函数就会把Button的属性Height返回！&lt;p&gt;当然这里绕了很大一圈，只实现了一个简单的操作：将Button的高度显示出来！感觉好费劲！&lt;br/&gt;&lt;strong&gt;但是：绑定有一个特点，可以感知“源”变量的变化！举例如下&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;StackPanel&amp;gt;
            &amp;lt;Button x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btnTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                 Content&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding Height,RelativeSource={RelativeSource Self}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;/Button&amp;gt;
            &amp;lt;Button Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Click=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Button_Click&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;增加高度&amp;lt;/Button&amp;gt;
        &amp;lt;/StackPanel&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
Button_Click函数：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Button_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            btnTest.Height &lt;/span&gt;+= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当执行Button_Click时，btnTest的高度增加10，显示内容也随之变化。是不是很神奇！为什么会变化？这里需要了解WPF特殊的属性“依赖属性”。这里就不深入讲解了！&lt;/p&gt;
&lt;p&gt;当然绑定的优点不仅仅是这些，WPF会用到大量绑定，如果这些绑定都用代码来实现，太繁琐，也不易理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：微软为了让XAML好用，费了很多心思。为了XAML能做更多的工作，编译器会替你做很多事情！简单的一个赋值操作，背后门道很多！初学者如果不了解这些门道，就感到一片茫然！本文初步揭示了赋值操作背后的一些内幕，希望你读后，有豁然开朗的感觉！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 15 Oct 2018 06:47:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>XAML与XML类似，就是XML延伸过来的。为了更好的表达一些功能，WPF对XML做了扩展，有些功能是WPF在后台悄悄的替你做了。有时候，虽然实现了某个功能，但是对实现原理还是很茫然。今天就讲讲XAM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/xaml_property_setting.html</dc:identifier>
</item>
<item>
<title>为我们的SSR程序添加热更新功能 - 不懂代码的攻城师</title>
<link>http://www.cnblogs.com/lentoo/p/9790852.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lentoo/p/9790852.html</guid>
<description>&lt;h2 id=&quot;前沿&quot;&gt;前沿&lt;/h2&gt;
&lt;p&gt;通过上一篇文章 &lt;a href=&quot;https://www.cnblogs.com/lentoo/p/9637845.html&quot;&gt;通过vue-cli3构建一个SSR应用程序&lt;/a&gt; 我们知道了什么是SSR，以及如何通过vue-cli3构建一个SSR应用程序。但是最后遗留了一些问题没有处理，就是没有添加开发时的热更新功能，难道要每次更新代码都要重新编译打包吗？显然不是很合理。那接下来我们将为该SSR程序添加热更新的功能。&lt;/p&gt;
&lt;h2 id=&quot;解决思路&quot;&gt;1、解决思路&lt;/h2&gt;
&lt;p&gt;我们知道SSR程序每次打包编译完成后，都会生成这两个文件 &lt;strong&gt;vue-ssr-client-manifest.json&lt;/strong&gt; 和 &lt;strong&gt;vue-ssr-server-bundle.json&lt;/strong&gt;，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;vue-ssr-client-manifest.json&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要记录了静态资源文件的配置信息&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;vue-ssr-server-bundle.json&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要记录了js文件的内容&lt;/p&gt;
&lt;p&gt;那现在就是要解决如何在保存代码后，获取到最新的&lt;strong&gt;vue-ssr-client-manifest.json&lt;/strong&gt; 和 &lt;strong&gt;vue-ssr-server-bundle.json&lt;/strong&gt;这两个文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1155933/201810/1155933-20181015143618691-217113395.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过该图，我们知道，既然要热更新，那 webpack dev server 肯定跑不了。&lt;/p&gt;
&lt;p&gt;所以解决的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;起一个webpack dev server 服务，暴露8080端口&lt;/li&gt;
&lt;li&gt;起一个webpack compiler 编译webpack配置文件，监听文件修改，实时编译获取最新的 vue-ssr-server-bundle.json&lt;/li&gt;
&lt;li&gt;通过webpack dev server 获取最新的 vue-ssr-client-manifest.json&lt;/li&gt;
&lt;li&gt;结合 vue-ssr-server-bundle.json 和 vue-ssr-client-manifest.json 渲染html页面返回给浏览器&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;编码实现&quot;&gt;2、编码实现&lt;/h2&gt;
&lt;p&gt;有了思路后，剩下的就是要思考如何通过代码实现了。&lt;/p&gt;
&lt;h3 id=&quot;起一个webpack-dev-server-服务&quot;&gt;2.1、 起一个webpack dev server 服务&lt;/h3&gt;
&lt;p&gt;通过 npm run serve 我们能很快的起一个webpack dev server 服务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm run serve &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取webpack配置文件并编译&quot;&gt;2.2、获取webpack配置文件，并编译&lt;/h3&gt;
&lt;p&gt;通过阅读&lt;a href=&quot;https://cli.vuejs.org/zh/guide/webpack.html#%E5%AE%A1%E6%9F%A5%E9%A1%B9%E7%9B%AE%E7%9A%84-webpack-%E9%85%8D%E7%BD%AE&quot;&gt;官方文档&lt;/a&gt;我们知道webpack的配置文件在 /node_modules/@vue/cli-service/webpack.config.js 中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 1、webpack配置文件
const webpackConfig = require('@vue/cli-service/webpack.config')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编译webpack配置文件并监听文件修改&quot;&gt;2.3、编译webpack配置文件，并监听文件修改&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;
// 2、编译webpack配置文件
const serverCompiler = webpack(webpackConfig)
const mfs = new MemoryFS()
// 指定输出到的内存流中
serverCompiler.outputFileSystem = mfs

// 3、监听文件修改，实时编译获取最新的 vue-ssr-server-bundle.json
let bundle
serverCompiler.watch({}, (err, stats) =&amp;gt;{
  if (err) {
    throw err
  }
  stats = stats.toJson()
  stats.errors.forEach(error =&amp;gt; console.error(error) )
  stats.warnings.forEach( warn =&amp;gt; console.warn(warn) )
  const bundlePath = path.join(
    webpackConfig.output.path,
    'vue-ssr-server-bundle.json'
  )
  bundle = JSON.parse(mfs.readFileSync(bundlePath,'utf-8'))
  console.log('new bundle generated')
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取最新的-vue-ssr-client-manifest.json&quot;&gt;2.4、获取最新的 vue-ssr-client-manifest.json&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 4、获取最新的 vue-ssr-client-manifest.json
// 这边的 8080 是 dev server 的端口号
const clientManifestResp = await axios.get('http://localhost:8080/vue-ssr-client-manifest.json')
const clientManifest = clientManifestResp.data&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结合各个步骤的核心后的最后代码&quot;&gt;2.5、结合各个步骤的核心后的最后代码&lt;/h3&gt;
&lt;p&gt;安装所需要的库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install webpack memory-fs concurrently -D
npm install koa-router axios -S&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在项目根目录下 新建一个 server/dev.ssr.js，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// server/dev.ssr.js
const webpack = require('webpack')
const axios = require('axios')
const MemoryFS = require('memory-fs')
const fs = require('fs')
const path = require('path')
const Router = require('koa-router')
// 1、webpack配置文件
const webpackConfig = require('@vue/cli-service/webpack.config')
const { createBundleRenderer } = require(&quot;vue-server-renderer&quot;);

// 2、编译webpack配置文件
const serverCompiler = webpack(webpackConfig)
const mfs = new MemoryFS()
// 指定输出文件到的内存流中
serverCompiler.outputFileSystem = mfs

// 3、监听文件修改，实时编译获取最新的 vue-ssr-server-bundle.json
let bundle
serverCompiler.watch({}, (err, stats) =&amp;gt;{
  if (err) {
    throw err
  }
  stats = stats.toJson()
  stats.errors.forEach(error =&amp;gt; console.error(error) )
  stats.warnings.forEach( warn =&amp;gt; console.warn(warn) )
  const bundlePath = path.join(
    webpackConfig.output.path,
    'vue-ssr-server-bundle.json'
  )
  bundle = JSON.parse(mfs.readFileSync(bundlePath,'utf-8'))
  console.log('new bundle generated')
})
// 处理请求
const handleRequest = async ctx =&amp;gt; {
  console.log('path', ctx.path)
  if (!bundle) {
    ctx.body = '等待webpack打包完成后在访问在访问'
    return
  }
  // 4、获取最新的 vue-ssr-client-manifest.json
  const clientManifestResp = await axios.get('http://localhost:8080/vue-ssr-client-manifest.json')
  const clientManifest = clientManifestResp.data

  const renderer = createBundleRenderer(bundle, {
    runInNewContext: false,
    template: fs.readFileSync(path.resolve(__dirname, &quot;../src/index.temp.html&quot;), &quot;utf-8&quot;),
    clientManifest: clientManifest
  });
  const html = await renderToString(ctx,renderer)
  ctx.body = html;
}
function renderToString(context,renderer) {
  return new Promise((resolve, reject) =&amp;gt; {
    renderer.renderToString(context, (err, html) =&amp;gt; {
      err ? reject(err) : resolve(html);
    });
  });
}

const router = new Router()

router.get(&quot;*&quot;, handleRequest);

module.exports = router&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建一个 server/ssr.js，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// server/ssr.js
const Koa = require('koa')
const koaStatic = require(&quot;koa-static&quot;);
const path = require('path')

const resolve = file =&amp;gt; path.resolve(__dirname, file);
const app = new Koa()

const isDev = process.env.NODE_ENV !== 'production'
const router = isDev ? require('./dev.ssr') : require('./server')

app.use(router.routes()).use(router.allowedMethods())
// 开放目录
app.use(koaStatic(resolve(&quot;../dist&quot;)));

const port = process.env.PORT || 3000;

app.listen(port, () =&amp;gt; {
  console.log(`server started at localhost:${port}`);
});

module.exports = app&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改package.json 添加几个执行脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// package.json scripts字段
&quot;dev:serve&quot;: &quot;cross-env WEBPACK_TARGET=node node ./server/ssr.js&quot;,
&quot;dev&quot;: &quot;concurrently \&quot;npm run serve\&quot; \&quot;npm run dev:serve\&quot; &quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行 npm run dev 命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm run dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问 &lt;a class=&quot;uri&quot;&gt;localhost:3000&lt;/a&gt; 你会发现，还是有问题。&lt;/p&gt;
&lt;p&gt;静态资源的文件引用的是 node.js server 的服务的，即引用到了3000端口上去了，但是3000端口的服务并没有这些静态资源文件，&lt;br/&gt;这些静态资源文件在webpack dev server中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1155933/201810/1155933-20181015143657195-558636590.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那如何解决呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;node server将这些静态资源的请求代理到 webpack dev server中&lt;/li&gt;
&lt;li&gt;改变webpack的baseUrl，直接引用到webpack dev server中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;很显然，第二种方式实现起来比较简单，那我们就修改webpack的baseUrl配置&lt;/p&gt;
&lt;p&gt;修改 vue.config.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// vue.config.js
// 添加一个字段，如果是开发环境，就指定到webpack dev server中
baseUrl: isDev ? 'http://127.0.0.1:8080' : '',&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新 &lt;strong&gt;npm run dev&lt;/strong&gt; ,然后访问 &lt;a class=&quot;uri&quot;&gt;localhost:3000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1155933/201810/1155933-20181015143704881-1303750529.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;已经能正常访问了，那我们试试 热更新的更新能不能实现，修改一段代码，&lt;/p&gt;
&lt;p&gt;会发现 node server 会重新编译webpack配置文件，然后在看看浏览器有没有更新&lt;/p&gt;
&lt;p&gt;你会发现浏览器还是没能热更新内容，打开 F12，你会发现这个错误，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1155933/201810/1155933-20181015143804905-1709375675.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我们常见的不允许跨域的错误提示。&lt;/p&gt;
&lt;p&gt;解决方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置 webpack dev server 允许跨域&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// vue.config.js 
// 添加一个 devServer的字段
devServer: {
    headers: {'Access-Control-Allow-Origin': '*'}
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新 &lt;strong&gt;npm run dev&lt;/strong&gt; ,然后访问 &lt;a class=&quot;uri&quot;&gt;localhost:3000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1155933/201810/1155933-20181015143756818-1680573320.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是已经能实现热更新的了。&lt;/p&gt;
&lt;h2 id=&quot;优化&quot;&gt;3、优化&lt;/h2&gt;
&lt;p&gt;1、favicon的问题&lt;br/&gt;打开f12还是能看到有问题，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1155933/201810/1155933-20181015143818413-258422981.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体实现可以参考我的github代码&lt;/p&gt;
&lt;p&gt;2、修改 server 端代码自动重启代码&lt;/p&gt;
&lt;p&gt;可以使用nodemon，或者pm2实现&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4、总结&lt;/h2&gt;
&lt;p&gt;通过上一篇 &lt;a href=&quot;https://www.cnblogs.com/lentoo/p/9637845.html&quot;&gt;通过vue-cli3构建一个SSR应用程序&lt;/a&gt; 和这篇文章，我们一步一步搭建起了基于vue-cli3的一个ssr应用程序，并添加了热更新的功能，在这期间也踩了很多坑。但是最终实现了之后，你会觉得这些付出都是值得的，因为这些都是自己的成长奠定基础。&lt;/p&gt;
&lt;p&gt;如果有更好的实现方法，欢迎交流交流！&lt;/p&gt;
&lt;p&gt;如果有不对的地方，欢迎指出！&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;5、源码&lt;/h2&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/lentoo/vue-cli-ssr-example&quot;&gt;vue-cli-ssr-example&lt;/a&gt; 欢迎 star&lt;/p&gt;
&lt;h2 id=&quot;赞赏&quot;&gt;赞赏&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1155933/201810/1155933-20181015143829291-765673887.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 06:39:00 +0000</pubDate>
<dc:creator>不懂代码的攻城师</dc:creator>
<og:description>前沿 通过上一篇文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lentoo/p/9790852.html</dc:identifier>
</item>
<item>
<title>算法工程师的危机 - FerventDesert</title>
<link>http://www.cnblogs.com/buptzym/p/9790828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buptzym/p/9790828.html</guid>
<description>&lt;p&gt;9月20号讯飞AI同传语音造假的新闻刷爆科技圈，科大讯飞股价应声下跌3.89%（不是65.3%，标题党文章害死人）。 吃瓜群众纷纷感慨，有多少人工，就有多少智能。&lt;/p&gt;
&lt;p&gt;AI概念在2015年起就红得发紫，不论是送外卖，搞团购，卖车，或是推荐莆田医院的，是个公司都会标榜自己是搞人工智能的。在21世纪的第二个十年，计算机专业相关的学生不说自己是搞AI算法的，同学聚会都抬不起头，相亲机会都变少了。随便从一摞简历里抽出一份，一定会有AI，调参，CNN，LSTM这些关键词。未来最赚钱的职业，一定不是天桥贴膜，而是天桥调参，50块钱一次，一调就灵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9608527-c6d554e1007b08a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;天桥调参&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NIPS会议，人满为患，改改网络结构，弄个激活函数就想水一篇paper; 到处都是AI算法的培训广告，三个月，让你年薪45万！在西二旗或望京的地铁车厢里打个喷嚏，就能让10个算法工程师第二天因为感冒请假。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9608527-214bbcaedb72f5cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;某程序网站的页面广告&quot;/&gt;&lt;/p&gt;
&lt;p&gt;谁也不知道这波热潮还能持续多久，但笔者作为一线算法工程师，已经能明显感受到危机的味道： 以大红大紫的图像为例，图像方向简历堆满了HR的办公台，连小学生都在搞单片机和计算机视觉。在笔者所在的公司，人工智能部门正在从早前研究院性质的组织架构分别向前台和后台迁移：前者进入业务部门，背上繁重的KPI，与外部竞争者贴身肉搏；后者则完全融入基础架构，像数据库一样普通和平凡。之前安逸的偏研究生活被打破， AI早已走下神坛。&lt;/p&gt;
&lt;p&gt;以笔者愚见，对于一般的算法工程师，这种危机包含两部分：&lt;strong&gt;一方面是来自人的竞争，大量便宜的毕业生和培训生涌入这个行业，人才缺口被迅速填满甚至饱和，未来的竞争会更激烈；另一方面则是来自机器的竞争，大量算法工程师会很快被他们每天研究的算法所代替&lt;/strong&gt;。 这两者互相恶化，AI人才市场终会变成一片红海。&lt;/p&gt;
&lt;h2 id=&quot;连小学生都会写模型&quot;&gt;连小学生都会写模型&lt;/h2&gt;
&lt;p&gt;工具和框架本身的发展，让设计模型所需的代码写得越来越简洁。10年前从头用C++和矩阵库实现梯度下降还是有不小的门槛的，动辄上千行。而当今几十行Keras甚至图形化的模型构建工具，让小学生都能设计出可用的二分类模型。强大的类库吞噬了知识，掩盖了内部的复杂性，但也给从业者带来了不小的惰性。从业者的技术水平，和使用模型的复杂程度关系不大，越是大牛，用的技术更底层更make sense。&lt;/p&gt;
&lt;p&gt;不仅如此，深度学习本身的性质，造成了明显的数学鸿沟。与SVM, 决策树不同，由于模型存在大量的非线性和复杂的层次关系，且输入信号（例如图像，文本）也很复杂，因此严格的数学论证是需要极高的抽象技巧的。该方法为什么好，在什么类型的数据上好，有时连作者都在拍脑袋，很多state of arts的方法，成了口口相传的经验和trick，而非严谨的theory。 连batch normlization（批规范化，只包含四个初中数学级别的简单公式）为何有效，都被争论了好几年。只有凤毛棱角的专家，能深入到模型最深处，用数值分析和理论证明给出严谨的答案。 大部分人在入门后便进入漫长的平台期，美其名曰参数调优，实际就像太上老君炼丹一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9608527-0c6180de07d93e54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们把这种现象绘制成下面的AI学习曲线，左侧是稍显陡峭的入门期，需要学习基本的矩阵论，微积分和编程，之后便是漫长的平台期。 随着复杂性越来越高，其学习曲线也越来越陡峭，大部分人也就止步于此。 越来越易用的工具，让曲线左侧变得平坦，入门期变短，却并不能改变右侧的陡峭程度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9608527-ad77387e002c5901.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AI学习曲线&quot;/&gt;&lt;/p&gt;
&lt;p&gt;入门容易深入难，这条曲线同时也能描述AI人才的收入水平。而真正处于危机的，莫过于夹在中间的芸芸众人：&lt;strong&gt;对理论一知半解，对工具非常依赖。可替代性很强，一旦AI浪潮过去，就知道谁是在裸泳&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;市场和业务变化越来越快，能有哪些核心业务，是能让工程师静心调个一年半载的呢？当一个从培训学校里出来的人都能做模型时，有多少业务能让公司多花两三倍的人力成本，而仅带来1%的性能提升呢？&lt;/p&gt;
&lt;h2 id=&quot;机器都能调参要你干吗&quot;&gt;机器都能调参，要你干吗？&lt;/h2&gt;
&lt;p&gt;面向大众AI科普节目，最常讨论的便是“AI时代如何不被机器所取代”。很不幸，最容易且最快被取代的反而是算法工程师。&lt;/p&gt;
&lt;p&gt;算法岗比工程岗更容易被取代。 在现有技术下，由于业务需求的复杂性， 自动生成一套软件App或服务几乎不可能的（否则就已经进入强人工智能时代了），但模型太容易被形式化地定义了。根据数据性质，自动生成各个领域的端到端(end2end)的模型也逐渐在工业上可用了：图像语音和广告推荐的飞速发展，，直接套用即可。理论和经验越来越完善，人变得越来越可替代。&lt;/p&gt;
&lt;p&gt;以前需要大力气搭建的数据回流和预测的链路，已经成了公司的基础组件，数据工程师没事干了； 特征可以自动生成和优选，特征工程师失业了； 深度网络采用经典结构即能满足一般业务需求，参数搜索在AutoML下变得越来越方便，调参工程师的饭碗也丢了 。 此处引用老板经常说的一句话：机器都能干了，要你干吗？&lt;/p&gt;
&lt;p&gt;从目前AI热门论文的情况看，广告推荐领域已经逐渐成熟，很多技巧沉淀为一整套方法论，已进入平台期；下一个即将被攻陷的领域应该是图像；而文本由于其内在的抽象性和模糊性，应该是算法工程师最后的一块净土，但这个门槛，五年内就会有爆发式的突破（本文发布两周后，谷歌BERT横扫11项NLP任务记录，麻蛋）。&lt;/p&gt;
&lt;h2 id=&quot;如何最优化职业发展&quot;&gt;如何最优化职业发展？&lt;/h2&gt;
&lt;p&gt;人工智能已经火了至少五年，它在未来五年是否火爆我们不能确定，但一定会更加两极化：偏基础的功能一般程序员就能搞定，像白开水一样普通。而针对更复杂模型甚至强人工智能的研究会成为少数人的专利。&lt;/p&gt;
&lt;p&gt;在一般的技术公司，传统意义的软件开发和产品设计，远比AI算法的需求来的多。算法永远是锦上添花，而非雪中送炭，再好的算法也拯救不了落后的业务和商业模式。一旦经济下行，企业首要干掉的就是锦上添花且人力成本较高的部分。&lt;/p&gt;
&lt;p&gt;如果你是顶级的算法专家，这样的问题根本不需担心。但是，对大部分人来说，如何找到自己的梯度上升方向，实现最优的人生优化器呢？&lt;/p&gt;
&lt;p&gt;//此处该插播广告，报价最少1万吧&lt;br/&gt;//但沙漠之鹰就是有节操，不插，不插，就是不插。&lt;/p&gt;
&lt;p&gt;笔者给出一些不成熟的小建议，供读者抛砖引玉：&lt;/p&gt;
&lt;p&gt;首先是深入原理和底层，类似TensorFlow的核心代码至少要读一遍吧？就算没有严格的理论基础，最起码也不能瞎搞啊。 切莫不能被工具带来的易用性迷惑双眼。要熟悉工具箱里每种函数的品性，对流动在模型里的数据有足够的嗅觉，在调参初期就能对不靠谱的参数快速剪枝。&lt;/p&gt;
&lt;p&gt;其次，工程能力不能丢，笔者见过太多做算法眼高手低的例子了(比如自己)：一个文件写所有，毫无架构和封装；遍地是临时方案和trick，前人挖坑后人栽；稳定性考虑不足，导致线上服务经常挂掉。 没有工程和架构的积累，在团队作战时可能还不是太大问题，单兵打天下则处处碰壁。&lt;/p&gt;
&lt;p&gt;按个人理解，做算法带来的最大收获是科学精神和实验思维，这是做工程很难培养出来的。以前看论文看了introduction和模型设计，草草地读一下实验结果就完事儿了。殊不知AB实验设计很可能才是论文的核心：实验样本是否无偏，实验设计是否严谨，核心效果是否合理，是否能证明论文结论。也许一行代码和一个参数的修改，背后是艰辛的思考和实验，做算法太需要严谨和缜密的思维了。即使未来不做算法，这些经验都会是非常宝贵的财富。&lt;/p&gt;
&lt;p&gt;再者是尽早面向领域，面向人和业务。AI本身只是工具，它的抽象性并不能让其成为各个领域的灵丹妙药。 如果不能和AI专家在深度上竞争，就在业务领域专精深挖，拥有比业务人员更好的数据敏感度，成为跨界专家。现在已经有大量AI+金融， AI+医疗，AI+体育的成功案例。 人能熟悉领域背后的数据，背后的人性，这是机器短时间内无法代替的，跨界带来的组合爆炸，也许暗含着危机中的机会吧。&lt;/p&gt;
&lt;p&gt;笔者同样处在迷茫期，有想法和见解的朋友欢迎留言。最后感慨一下，同样是80后，年龄相差无几，有人已是副总裁，有人带了几个人的小团队，有人还在基层苦苦挣扎，轨迹在毕业时分叉，几年后早已沧海桑田。&lt;/p&gt;
&lt;p&gt;（欢迎关注笔者微信公众号：沙漠之鹰）&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 06:37:00 +0000</pubDate>
<dc:creator>FerventDesert</dc:creator>
<og:description>9月20号讯飞AI同传语音造假的新闻刷爆科技圈，科大讯飞股价应声下跌3.89%（不是65.3%，标题党文章害死人）。 吃瓜群众纷纷感慨，有多少人工，就有多少智能。 AI概念在2015年起就红得发紫，不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/buptzym/p/9790828.html</dc:identifier>
</item>
</channel>
</rss>