<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>c#  弹性和瞬态故障处理库Polly 学习 - alone_alone</title>
<link>http://www.cnblogs.com/xxue/p/9902669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxue/p/9902669.html</guid>
<description>&lt;p&gt;&lt;span&gt;                                                                    &lt;img src=&quot;https://img2018.cnblogs.com/blog/943408/201811/943408-20181103224731745-507595531.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;span&gt;  Polly是一个基于.NET的弹性及瞬态故障处理库,允许开发人员以顺畅及线程安全的方式执行重试(Retry)、断路(Circuit Breaker)、超时(Timeout)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;     隔离(Bulkhead Isolation)和回退策略(Fallback ).&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Polly适用于 .NET 4.0, .NET 4.5 和.NET Standard 1.1。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;     以上是官方文档对polly库的介绍。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;     polly的介绍中有个很关键的词是瞬态故障，这个词也很好的诠释了Polly使用的一个背景.瞬态故障,就是指我们的程序在运行当中可能会发生故障,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;     这些故障包含程序运行中的异常、返回结果不符等。弹性是指Polly在应对这些故障时具有灵活性，且其提供的策略也可以很灵活的组合在一起使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;span&gt;方式1：在Nuget中下载Polly安装包，安装成功即可使用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;code&gt;Install-Package Polly&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     方式2：在github中下载Polly源码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                 &lt;a href=&quot;https://github.com/App-vNext/Polly&quot; target=&quot;_blank&quot;&gt;https://github.com/App-vNext/Polly&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;   &lt;span&gt;一、重试（Retry）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;       异常重试是最常使用的一个策略,其功能是当我们执行的方法体发生异常时,可以按照我们指定的次数进行重试&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
          Policy
          .Handle&amp;lt;NullReferenceException&amp;gt;()   //指定需要重试的异常类型 
          .Retry(2,(ex,count,context)=&amp;gt; {     //指定发生异常重试的次数
              Console.WriteLine($&quot;重试次数{count},异常{ex.Message}&quot;);
          })                                          
          .Execute(() =&amp;gt; Console.Write(&quot;execute method!&quot;));    //要执行的方法
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　  &lt;span&gt; Polly的所有策略使用都支持链式调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      Polly重试策略的使用分为三个步骤&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;   1、指定需要处理的异常&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;         可以指定捕获执行的任务的异常类型,若执行任务的异常类型满足指定异常,那么重试机制将会生效&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt; 2、指定重试次数和监控重试&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;        指定整个执行过程中需要重试多少次,且可以监控每次的重试信息,比如重试次数  异常以及重试的上下文信息&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;   3、指定执行的任务&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;        指定执行的任务是整个异常重试的核心和监控对象,Execute支持多种重载.。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;          重试策略支持异步任务      &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_a88bcef7-d81f-4b3a-bfda-f60fce6d19b2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a88bcef7-d81f-4b3a-bfda-f60fce6d19b2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a88bcef7-d81f-4b3a-bfda-f60fce6d19b2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task PollyStudy()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; num = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Policy
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 .Handle&amp;lt;Exception&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 .RetryAsync(&lt;span&gt;2&lt;/span&gt;, (ex, count, context) =&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;重试次数{count},异常{ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                })
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 .ExecuteAsync&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(() =&amp;gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetNum();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; GetNum()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;  二、超时（Timeout）&lt;/span&gt; &lt;/h2&gt;
&lt;p&gt;       &lt;span&gt;超时策略主要用于对任务执行的执行时长监控,若任务执行超出指定执行时长,那么我们就认为这次任务执行是失败的,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      不会再去等待结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;超时策略最基本的设置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;             Policy
            .Timeout(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, (context, timeSpan, task) =&amp;gt;&lt;span&gt;
           {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;   &lt;span&gt;三、熔断（&lt;/span&gt;Circuit-breaker&lt;span&gt;）&lt;/span&gt;    &lt;/h2&gt;
&lt;p&gt;     &lt;span&gt;熔断在这里的含义在执行某个任务时,多次重试依然出现超时或则异常,且重试的次数已经超过了系统设定上限.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     那么就中断当前的执行,快速响应失败信息给用户,等待一段时间再进行恢复,继续执行.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var breakerPlocy = Policy.Handle&amp;lt;Exception&amp;gt;()     //指定异常
                         .CircuitBreaker(5, TimeSpan.FromSeconds(30),               //设置5次阀值,中断30秒
                         onBreak: (ex, timeSpan) =&amp;gt; { Console.WriteLine(&quot;onBreak&quot;); }, //中断回调
                         onReset: () =&amp;gt; { Console.WriteLine(&quot;onReset&quot;); });            //重置回调
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;熔断的基本策略设置如上代码所示,上面的代码可以解析为当某个任务超过5次异常时,我们进行中断处理,等待30秒后再次继续.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    我们设置了&lt;/span&gt;&lt;span&gt;中断回调和重启回调函数,可以记录当中的执行信息.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; &lt;/span&gt; &lt;span&gt;&lt;span&gt;四、&lt;/span&gt;&lt;/span&gt;&lt;span&gt;回退（Fallback）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;   &lt;span&gt;回退策略的前置条件是当我们的操作注定会失败时,我们就需要有一个合理的返回信息来替代失败信息,也就是提供一个备用方案,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   从而能对我们的失败操作进行挽救.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Policy
        .Handle&amp;lt;Exception&amp;gt;()                 
        .Fallback(fallbackAction: () =&amp;gt; { }, onFallback: (ex) =&amp;gt; { });   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;回退策略的基本设置如上所示,我们可以定义备用的返回信息,同时可以定义回调&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;   &lt;span&gt;五、隔板隔离策略&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;    &lt;span&gt;隔板隔离的前置条件是当进程出现故障时，多个失败一直在主机中对资源一直占用。下游系统故障也可能导致上游系统的故障,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   这些风险都可能导致系统产生严重的后果.而隔板隔离策略可以隔离有相互影响的操作,将受管制的草需哦限制在一个固定的&lt;/span&gt;&lt;span&gt;资源池中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            Policy.Bulkhead(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, (context) =&amp;gt; { });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;指定最大的线程数,和正在排队的队列数,若执行被拒绝,则执行回调.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; 六、缓存策略&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  &lt;span&gt;缓存策略的前置条件是我们的数据更新周期较长且使用频繁,我们可以首次加载这些数据时将这些数据缓存起来,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  如果数据已经存在那么我们直接从缓存中读取.&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
ISyncCacheProvider cacheProvider = new StubCacheProvider();
            Func&amp;lt;Context, string&amp;gt; cacheKeyStrategy = null;
            Action action = () =&amp;gt; Policy.Cache(cacheProvider, TimeSpan.MaxValue, cacheKeyStrategy);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;缓存策略在某些情况下简化我们的缓存实现是很有帮助的.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;七、策略包装策略&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  &lt;span&gt;策略包装策略的前置条件是不同的异常需要不同的策略,也就是需要我们弹性的使用策略来应对不同的异常信息.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 NoOpPolicy policy0 = Policy.NoOp();
            NoOpPolicy policy1 = Policy.NoOp();
            NoOpPolicy policy2 = Policy.NoOp();
            PolicyWrap policyWrap = Policy.Wrap(policy0, policy1, policy2);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;  &lt;span&gt;上面简单介绍了polly七大策略和其基本配置,Polly实际功能很强大,是一个很值得仔细学习的库.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  后面会详细介绍Polly的几大策略以及在实际项目中的一个应用&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 03 Nov 2018 15:40:00 +0000</pubDate>
<dc:creator>alone_alone</dc:creator>
<og:description>关于Polly Polly是一个基于.NET的弹性及瞬态故障处理库,允许开发人员以顺畅及线程安全的方式执行重试(Retry)、断路(Circuit Breaker)、超时(Timeout)、 隔离(B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xxue/p/9902669.html</dc:identifier>
</item>
<item>
<title>如何合并两个Git仓库 - Aloys寒风</title>
<link>http://www.cnblogs.com/jiangxinnju/p/9902654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangxinnju/p/9902654.html</guid>
<description>&lt;p&gt;欢迎和大家交流技术相关问题：&lt;br/&gt;邮箱: jiangxinnju@163.com&lt;br/&gt;博客园地址: &lt;a href=&quot;http://www.cnblogs.com/jiangxinnju&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/jiangxinnju&lt;/a&gt;&lt;br/&gt;GitHub地址: &lt;a href=&quot;https://github.com/jiangxincode&quot; class=&quot;uri&quot;&gt;https://github.com/jiangxincode&lt;/a&gt;&lt;br/&gt;知乎地址: &lt;a href=&quot;https://www.zhihu.com/people/jiangxinnju&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/people/jiangxinnju&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设有两个Git仓库：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/jiangxincode/thesis.git&quot; class=&quot;uri&quot;&gt;https://github.com/jiangxincode/thesis.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jiangxincode@bitbucket.org/jiangxincode/thesis.git&quot; class=&quot;uri&quot;&gt;https://jiangxincode@bitbucket.org/jiangxincode/thesis.git&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在需要进行合并，保留双方的历史提交记录，并将1的内容删除，合并之后的内容推送到2中。&lt;/p&gt;
&lt;p&gt;从Github上clone仓库到github目录：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ git clone https://github.com/jiangxincode/thesis.git github
Cloning into 'github'...
remote: Enumerating objects: 29, done.
remote: Total 29 (delta 0), reused 0 (delta 0), pack-reused 29
Unpacking objects: 100% (29/29), done.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从Bitbucket上clone仓库到bitbucket目录：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ git clone https://jiangxincode@bitbucket.org/jiangxincode/thesis.git bitbucket
Cloning into 'bitbucket'...
remote: Counting objects: 153, done.
remote: Compressing objects: 100% (150/150), done.
remote: Total 153 (delta 63), reused 0 (delta 0)
Receiving objects: 100% (153/153), 26.68 MiB | 2.64 MiB/s, done.
Resolving deltas: 100% (63/63), done.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在合并前根据实际情况分别处理两个目录的内容，并提交上传到远程仓库。&lt;/p&gt;
&lt;p&gt;在仓库bitbucket中添加远程仓库github，命名为github&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cd bitbucket/
$ git remote add github ../github/
$ git remote
github
origin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检出历史信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ git fetch github
warning: no common commits
remote: Enumerating objects: 32, done.
remote: Counting objects: 100% (32/32), done.
remote: Compressing objects: 100% (29/29), done.
remote: Total 32 (delta 8), reused 0 (delta 0)
Unpacking objects: 100% (32/32), done.
From ../github
 * [new branch]      master     -&amp;gt; github/master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于github的master分支创建并检出新的分支，名字为github_master&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ git checkout -b github_master github/master
Switched to a new branch 'github_master'
Branch 'github_master' set up to track remote branch 'master' from 'github'.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切到仓库2的主线分支&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ git checkout master
Switched to branch 'master'
Your branch is up to date with 'origin/master'.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;合并基于github创建的分支github_master到仓库bitbucket的master分支上&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ git merge github_master  --allow-unrelated-histories
Auto-merging .gitignore
CONFLICT (add/add): Merge conflict in .gitignore
Automatic merge failed; fix conflicts and then commit the result.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处可以看出出现了冲突，需要先解决冲突&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ git status
On branch master
Your branch is up to date with 'origin/master'.

You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)
  (use &quot;git merge --abort&quot; to abort the merge)

Changes to be committed:

        new file:   tex-source/LICENSE
        new file:   tex-source/Makefile
        new file:   tex-source/abstract.tex
        new file:   tex-source/dtx-style.sty
        new file:   tex-source/englishabstract.tex
        new file:   tex-source/gbt7714-2005.bst
        new file:   tex-source/get_texmf_dir.sh
        new file:   tex-source/jiangxin.bib
        new file:   tex-source/jiangxin.tex
        new file:   tex-source/njulogo.eps
        new file:   tex-source/njuname.eps
        new file:   tex-source/njuthesis.cfg
        new file:   tex-source/njuthesis.cls
        new file:   tex-source/njuthesis.dtx
        new file:   tex-source/njuthesis.ins
        new file:   tex-source/preface.tex

Unmerged paths:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to mark resolution)

        both added:      .gitignore

$ git add .gitignore

$ git commit
[master 3d6cb22] Merge branch 'github_master'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后push本地所有分支到bitbucket&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ git push origin master
Enumerating objects: 37, done.
Counting objects: 100% (37/37), done.
Delta compression using up to 4 threads.
Compressing objects: 100% (32/32), done.
Writing objects: 100% (35/35), 320.42 KiB | 3.56 MiB/s, done.
Total 35 (delta 9), reused 0 (delta 0)
To https://bitbucket.org/jiangxincode/thesis.git
   f92ef9e..3d6cb22  master -&amp;gt; master

$ git push origin github_master:github_master
Total 0 (delta 0), reused 0 (delta 0)
remote:
remote: Create pull request for github_master:
remote:   https://bitbucket.org/jiangxincode/thesis/pull-requests/new?source=github_master&amp;amp;t=1
remote:
To https://bitbucket.org/jiangxincode/thesis.git
* [new branch]      github_master -&amp;gt; github_master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时查看本地和远程的所有分支&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ git branch -a
  github_master
* master
  remotes/github/master
  remotes/origin/HEAD -&amp;gt; origin/master
  remotes/origin/github_master
  remotes/origin/master
  origin/master&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 03 Nov 2018 15:35:00 +0000</pubDate>
<dc:creator>Aloys寒风</dc:creator>
<og:description>欢迎和大家交流技术相关问题： 邮箱: jiangxinnju@163.com 博客园地址: GitHub地址: 知乎地址: 假设有两个Git仓库： 1. 2. 现在需要进行合并，保留双方的历史提交记录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiangxinnju/p/9902654.html</dc:identifier>
</item>
<item>
<title>Java实例 Part5：面向对象入门 - 落落free</title>
<link>http://www.cnblogs.com/hynazwaa/p/9902642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hynazwaa/p/9902642.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;@&lt;br/&gt;***&lt;/p&gt;
&lt;h2 id=&quot;example01成员变量的初始化值&quot;&gt;Example01：成员变量的初始化值&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;运行结果：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181103230252325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk0MjY0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Example01 {
    //声明变量
    private byte b;
    private int i;
    private short s;
    private long l;
    private char ch;
    private float f;
    private double d;
    private boolean bool;
    private String str;

    public static void main(String[] args) {
        Example01 example = new Example01();
        System.out.println(&quot;byte类型的初始值：&quot;+example.b);
        System.out.println(&quot;int类型的初始值：&quot;+example.i);
        System.out.println(&quot;short类型的初始值：&quot;+example.s);
        System.out.println(&quot;long类型的初始值：&quot;+example.l);
        System.out.println(&quot;char类型的初始值：&quot;+example.ch);
        System.out.println(&quot;float类型的初始值：&quot;+example.f);
        System.out.println(&quot;double类型的初始值：&quot;+example.d);
        System.out.println(&quot;boolean类型的初始值：&quot;+example.bool);
        System.out.println(&quot;String类型的初始值：&quot;+example.str);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;要点：对于引用类型的变量，在使用之前需要进行初始化，否则会抛出NullPointerException。&lt;br/&gt;***&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;example02单例模式的应用&quot;&gt;Example02：单例模式的应用&lt;/h2&gt;
&lt;h3 id=&quot;懒汉式&quot;&gt;-----懒汉式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;运行结果：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181103230609417.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;实现代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Single {
    private static Single s = null;
    private Single(){}
    public static Single getInstance(){
        if (s == null){
            s = new Single();
            System.out.println(&quot;---我是懒汉！&quot;);
        }
        return s;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;懒汉式在方法中创建这个类的对象，调用效率不高，但能延时加载。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;饿汉式&quot;&gt;-----饿汉式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;运行结果：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181103230709388.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Single {
    private static Single s = new Single();
    private Single(){}
    public static Single getInstance(){
            System.out.println(&quot;---我是饿汉！&quot;);
            return s;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;饿汉式在全局变量范围内创建这个类的对象，调用效率高，但不能延时加载。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;== 测试代码：==&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Example02 {
    public static void main(String[] args) {
        System.out.println(&quot;---你又是谁？&quot;);
        Single.getInstance();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;要点：单例模式的特点在于仅能获得一个对象。为了防止其他用户创建对象，需要将构造函数设置成private的，然后提供一个静态方法，该方法返回这个类的对象。&lt;/strong&gt;&lt;br/&gt;***&lt;/p&gt;
&lt;h2 id=&quot;example03汉诺塔问题的求解&quot;&gt;Example03：汉诺塔问题的求解&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;汉诺塔问题描述：有A、B、C 3根柱子，在A上从下往上按照从小到大的顺序放着3个圆盘，以B为中介，把盘子全部移动到C上。移动过程中，要求任意盘子的下面要么没有盘子，要么只能有比它大的盘子。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;运行结果：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181103230850730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk0MjY0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Example3 {
    public static void main(String[] args) {
        int nDisks = 3; //设置汉诺塔为3阶
        moveDish(nDisks,'A','B','C');
    }
    public static void moveDish(int level,char from,char inner,char to){
        if (level == 1){    //如果只有一个盘子
            System.out.println(&quot;从&quot;+from+&quot;移动盘子1号到&quot;+to);
        }else {      //如果有大于一个盘子就迭代
            moveDish(level-1,from,to,inner);
            System.out.println(&quot;从&quot;+from+&quot;移动盘子&quot;+level+&quot;号到&quot;+to);
            moveDish(level-1,inner,from,to);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;要点：为了将N个盘子从A移动到C，需要先将N个盘子上面的N-1个盘子移动的B上，这样才能将第N个盘子移动到C上，同理，为了将第N-1个盘子从B移动到C上，通过递归可以实现汉诺塔问题。（上面的程序是3阶汉诺塔问题，有需要可以改写成自己需要计算的输入程序的n阶汉诺塔问题）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;example04两只完全相同的宠物并得出对象的哈希码&quot;&gt;Example04：两只完全相同的宠物并得出对象的哈希码&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;要求：重写equals()和toString()以及hashCode()方法来比较两个对象是否相同。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;运行结果：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181103231016687.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.awt.*;
import java.util.Objects;

public class Cat {
    private String name;
    private int age;
    private double weight;
    private Color color;

    public Cat(String name, int age, double weight, Color color) {
        this.name = name;
        this.age = age;
        this.weight = weight;
        this.color = color;
    }

    @Override
    public boolean equals(Object o) {     //利用属性来判断猫咪是否相同
        if (this == o) {        //如果两个猫咪是同一个对象则相同
            return true;
        }
        if (o == null ) {   //如果两个猫咪有一个为null则不同
            return false;
        }
        if (getClass() != o.getClass()) {     //如果两个猫咪的类型不同则不同
            return false;
        }
        Cat cat = (Cat) o;
        //比较猫咪的属性
        return age == cat.age &amp;amp;&amp;amp; Double.compare(cat.weight, weight) == 0 &amp;amp;&amp;amp; Objects.equals(name, cat.name) &amp;amp;&amp;amp; Objects.equals(color, cat.color);
    }

    @Override
    public String toString() {         //重写toString()方法
        return &quot;Cat{&quot; +
                &quot;名字='&quot; + name + '\'' +
                &quot;, 年龄=&quot; + age +
                &quot;, 重量=&quot; + weight +
                &quot;, 颜色=&quot; + color +
                '}';
    }

    @Override
    public int hashCode() {

        return Objects.hash(name, age, weight, color);
    }

    public static void main(String[] args) {
        Cat c1 = new Cat(&quot;hyn&quot;,3,10,Color.PINK);
        Cat c2 = new Cat(&quot;azw&quot;,4,15,Color.YELLOW);
        Cat c3 = new Cat(&quot;hyn&quot;,3,10,Color.PINK);
        System.out.println(&quot;猫咪1号：&quot;+c1);
        System.out.println(&quot;猫咪2号：&quot;+c2);
        System.out.println(&quot;猫咪3号：&quot;+c3);
        System.out.println(&quot;猫咪1号的哈希码：&quot;+c1.hashCode());
        System.out.println(&quot;猫咪2号的哈希码：&quot;+c2.hashCode());
        System.out.println(&quot;猫咪3号的哈希码：&quot;+c3.hashCode());
        System.out.println(&quot;猫咪1号是否与2号相同：&quot;+c1.equals(c2));
        System.out.println(&quot;猫咪1号是否与3号相同：&quot;+c1.equals(c3));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;运行结果：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181103231214136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzk0MjY0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;@Override
public String toString() {         //重写toString()方法
    StringBuilder sb = new StringBuilder();
    sb.append(&quot;名字：&quot;+name+&quot;\n&quot;);
    sb.append(&quot;年龄：&quot;+age+&quot;\n&quot;);
    sb.append(&quot;重量：&quot;+weight+&quot;\n&quot;);
    sb.append(&quot;颜色：&quot;+color+&quot;\n&quot;);
    return sb.toString();
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 03 Nov 2018 15:32:00 +0000</pubDate>
<dc:creator>落落free</dc:creator>
<og:description>Part5：面向对象入门 @[toc] Example01：成员变量的初始化值 运行结果： 代码实现： public class Example01 { //声明变量 private byte b;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hynazwaa/p/9902642.html</dc:identifier>
</item>
<item>
<title>解开Future的神秘面纱之任务执行 - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/9902340.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/9902340.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　此文承接之前的博文 &lt;a href=&quot;https://www.cnblogs.com/longfurcat/p/9582413.html&quot; target=&quot;_blank&quot;&gt;解开Future的神秘面纱之取消任务&lt;/a&gt; 补充一些任务执行的一些细节，并从全局介绍程序的运行情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务提交到执行的流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103202022692-1357693454.png&quot; alt=&quot;&quot; width=&quot;562&quot; height=&quot;353&quot;/&gt;&lt;/p&gt;


&lt;p&gt;前文我们已经了解到一些Future的实现细节，这里我们来梳理一下运行流程。这里只说sumbit（提交）&lt;/p&gt;
&lt;p&gt;（1）客户端创建一个Callable或Runnable对象。&lt;/p&gt;
&lt;p&gt;（2）客户端调用ExecutorService的submit方法，将任务提交给执行器。&lt;/p&gt;
&lt;p&gt;（3）ExecutorService将调用其实现类AbstractExecutorService的submit方法。&lt;/p&gt;
&lt;p&gt;（4）submit方法将获取到的Runnable/Callable任务交由其内部方法newTaskFor进行包装。&lt;/p&gt;
&lt;p&gt;（5）newTaskFor方法将Runnable/Callable包装成FutureTask对象。&lt;/p&gt;
&lt;p&gt;（6）submit把包装好的FutureTask对象交由execute方法执行，此方法有ThreadPoolExecutor提供。&lt;/p&gt;
&lt;p&gt;（7）submit方法返回FutreTask对象给客户端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务提交为何能接收两种类型的接口？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上很有意思的是，&lt;span&gt;FutureTask只使用Callable对象（因为使用Future的初衷就是想要获取任务处理结果），而Executor的execute只接收Runnable对象（执行器只管执行任务）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;FutureTask接收到Runnable对象后，会利用&lt;strong&gt;适配器&lt;/strong&gt;，将其适配为Callable对象进行使用。注意，Runnable适配后，返回值基本没什么意义，都是写死的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103213157275-814083375.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;177&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而FutureTask实际上相当于Runnable对象的装饰器，FutureTask的继承结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103200349931-239369232.png&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;268&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道Runnable定义了任务该做什么，Future定义了任务的控制操作，而RunnableFuture接口兼具这两个功能。&lt;/p&gt;
&lt;p&gt;Future就是实现这组操作的实现类，它也是&lt;strong&gt;Runnable的装饰器类&lt;/strong&gt;，Runnable任务在经过其包装后，仍然还是Runnable，不影响其交给execute方法执行。而且他实现了Future接口，也就可以根据它对任务进行控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FutureTask有哪些字段，用来做什么的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103215845347-1394758480.png&quot; alt=&quot;&quot; width=&quot;430&quot; height=&quot;203&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）state =&amp;gt; 状态，用于基于状态的控制操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NEW  =&amp;gt; 新建任务&lt;/li&gt;
&lt;li&gt;COMPLETING =&amp;gt; 正在完成，即任务已经被线程启动&lt;/li&gt;
&lt;li&gt;NORMAL =&amp;gt; 正常完成任务&lt;/li&gt;
&lt;li&gt;EXCEPTIONAL =&amp;gt; 任务因为异常而终止&lt;/li&gt;
&lt;li&gt;CANCELLED =&amp;gt; 任务已被取消，注意这里并不表示任务实际状态，即任务可能还在运行。&lt;/li&gt;
&lt;li&gt;INTERRUPTING =&amp;gt; 中断任务中&lt;/li&gt;
&lt;li&gt;INTERRUPTD =&amp;gt; 任务已被中断&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（2）callable =&amp;gt; callable任务，实际被执行的任务&lt;/p&gt;
&lt;p&gt;（3）outcome =&amp;gt; 执行结果&lt;/p&gt;
&lt;p&gt;（4）runner =&amp;gt; 执行线程的引用，用来控制任务的执行。&lt;/p&gt;
&lt;p&gt;（5）waiters =&amp;gt; 等待线程队列，当任务还未完成时，用于保存因为获取结果的而被阻塞的线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FutureTask的状态变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）NEW -&amp;gt; COMPLETING -&amp;gt; NORMAL（任务正常执行到结束）&lt;/p&gt;
&lt;p&gt;（2）NEW -&amp;gt; COMPLETING -&amp;gt; EXCEPTIONAL（任务执行过程中出现异常）&lt;/p&gt;
&lt;p&gt;（3）NEW -&amp;gt; CANCELLED （任务被取消）&lt;/p&gt;
&lt;p&gt;（4）NEW -&amp;gt; INTERRUPTING -&amp;gt; INTERRUPTED (任务已经开始，尚未完成就被取消)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FutureTask如何确定其执行线程的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　任务的控制最主要的两个功能就是取消和获取结果。取消的操作，上一篇博文已经讲到了，获取结果将于下篇讲述。这里补充前篇的一些内容，也就是取消操作相关的细节，当时已经获知，要取消任务，实际上是通过中断任务的执行线程实现的，如图：&lt;/p&gt;
&lt;p&gt;FutureTask的cancel方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103204213732-2031889765.png&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;273&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，这个runner是何时被赋值的，我当时并不清楚，查阅源码也没发现什么setRunner之类的代码。后来突然想到，只有在任务被执行的时候才能知道，它到底被哪个线程执行。于是才注意到了这段CAS的代码，（当时不太懂，所以就算看到了这段代码，也不明白）。意思就是说，如果当前对象的runner字段值为null，就将其设置为当前的执行线程。到这里，我们就有了此线程的引用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103204948926-1611957040.png&quot; alt=&quot;&quot; width=&quot;417&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103204840514-245903804.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;423&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FutureTask到达ThreadPoolExecutor的execute之后，是什么情形？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这里简要说一下，任务到达ThreadPoolExecutor之后，线程池会根据当前线程数量的情况进行处理，可能创建一个新线程来执行，或者加入到任务队列等待执行，再或者就是被线程池抛弃等等。&lt;/p&gt;
&lt;p&gt;　　相关细节可查看，我关于ThreadPoolExecutor的相关博文。&lt;/p&gt;

</description>
<pubDate>Sat, 03 Nov 2018 14:16:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言 此文承接之前的博文 解开Future的神秘面纱之取消任务 补充一些任务执行的一些细节，并从全局介绍程序的运行情况。 任务提交到执行的流程 前文我们已经了解到一些Future的实现细节，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/9902340.html</dc:identifier>
</item>
<item>
<title>码农深耕 - 35岁的程序员何去何从？ - 高云鹏</title>
<link>http://www.cnblogs.com/gaoyunpeng/p/9902073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gaoyunpeng/p/9902073.html</guid>
<description>&lt;p&gt;曾经在知乎回答过类似问题，那也是我在知乎获赞最高的回答。但是发现这个问题简直成了知乎的日常问题，可见广大同行的焦虑。那么索性从新审视这个命题，谈谈我对这件事情的看法。&lt;/p&gt;
&lt;h2 id=&quot;程序员的职业生命到底有多长&quot;&gt;程序员的职业生命到底有多长？&lt;/h2&gt;
&lt;p&gt;程序员是可以做一辈子的，但单纯只会敲代码的程序员，职业生命十年左右。&lt;br/&gt;从业初期，肯定是从小工到大工的成长过程，业务逐渐熟练，技巧逐渐丰富，理解逐渐深刻，这时你成为了“技术大拿”，你成为团队的“百晓生”、“顶梁柱”；之后，势必会承担起更多的责任，这时工作内容会逐渐体现出一些管理性质，你开始带团队，培养新人，做一些设计，参与制定一些规范，进行代码审查，这时公司开始信任你，依赖你；再后来，开始直接接触客户，收集需求，技术选型，开始考虑成本与利润，开始考虑风险与回报，这时你已经成为公司不可或缺的一部分。&lt;br/&gt;我只是写出了一个程序员成长路线的一种可能性，但是可以看出来，随着时间的流逝，公司对你的期待会越来越高，所以，程序员的职业生命是和个人能力成正比的。如同逆水行舟，不进则退，只要不断成长，让自己的能力与自己的资历匹配，职业生命就可以无限延长；否则，当你的能力无法匹配你的资历，面临的最坏结果就是出局。&lt;/p&gt;
&lt;h2 id=&quot;技术重要还是管理重要&quot;&gt;技术重要还是管理重要？&lt;/h2&gt;
&lt;p&gt;作为对技术抱有热情与幻想的程序员，我一度坚持认为技术最重要，但是现在我觉得我错了。技术当然是重要的，这也是我得到认可的原因，但是“技术”只是个工具，最终我们的产出是利用“技术”实现了的那个“需求”。我不断地磨练自己的技术，不断地学习，目的是当面对“需求”，我可以给出更多种可行的方案，我可以在实现的过程中有更多的选择，解决难题时我可以想到更多的手段。&lt;br/&gt;谈到管理，曾经觉得它和技术格格不入，但现在我觉得我又错了。“管理”可不是单纯的“管人”，项目的结构、团队的协调、进度、质量都需要管理，而这些也可以理解为广义的“技术”，当技术成长到一定程度，自然而然地会思考如何让项目进行得更流畅、效率更高、质量更稳，那么这时事实上我们已经在思考“管理”了。&lt;br/&gt;所以，对技术痴迷，也不要固执地排斥管理；对管理重视，也不要愚蠢地鄙视技术。技术缺管理是一盘散沙，白费力气；管理缺技术是缘木求鱼，攻而不克。&lt;/p&gt;
&lt;h2 id=&quot;要不要赶时髦&quot;&gt;要不要“赶时髦”？&lt;/h2&gt;
&lt;p&gt;新技术、新理念，我们要积极地去了解，但是要慎重地使用。软件行业用日新月异来形容毫不为过，这个充满活力的行业，各种新鲜事物层出不穷。作为从业人员，我们需要开阔视野，前沿知识哪怕不用，也要去了解，因为这种积累，在日后会为你提供更多的思路。但是在新技术的使用上，我偏向于求“稳”，贸然引入新技术，特别是整个团队集体转向，会引入太大的风险。现在互联网公司呈现出的激进的风潮，我是持保留态度的。&lt;/p&gt;
&lt;h2 id=&quot;程序员的核心竞争力是什么&quot;&gt;程序员的核心竞争力是什么？&lt;/h2&gt;
&lt;p&gt;是学习能力。我们这个行业实在变化太快，“一招鲜，吃遍天”这种事情是不存在的，我们总会遇到从未接触过的新挑战，怎么办？学习。就如同一个优秀的企业，它最有价值的地方在于它有无限的发展前景。那么一个优秀的程序员，最有价值的地方就在于拥有无限的潜力。要知道，公司雇佣一个人，并不是因为他现在水平深浅，而是他能不能和公司一起成长，只看眼前的公司不会长久，只看眼前的员工没有未来。&lt;/p&gt;
&lt;h2 id=&quot;程序员到底何去何从&quot;&gt;程序员到底何去何从？&lt;/h2&gt;
&lt;p&gt;其实啰嗦了那么多，归根结底就是持续提升自己，就这么简单。把焦虑、嫉妒、迷茫的时间拿来充实自己，到了35岁你会发现，这真的是职业生涯的分岔路口，只不过我们的路通向美好。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 12:57:00 +0000</pubDate>
<dc:creator>高云鹏</dc:creator>
<og:description>曾经在知乎回答过类似问题，那也是我在知乎获赞最高的回答。但是发现这个问题简直成了知乎的日常问题，可见广大同行的焦虑。那么索性从新审视这个命题，谈谈我对这件事情的看法。 程序员的职业生命到底有多长？ 程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gaoyunpeng/p/9902073.html</dc:identifier>
</item>
<item>
<title>【大数据安全】基于Kerberos的大数据安全验证方案 - mantou叔叔</title>
<link>http://www.cnblogs.com/mantoudev/p/9877433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantoudev/p/9877433.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;1.背景&lt;/h2&gt;
&lt;p&gt;互联网从来就不是一个安全的地方。很多时候我们过分依赖防火墙来解决安全的问题，不幸的是，防火墙是假设“坏人”是来自外部的，而真正具有破坏性的攻击事件都是往往都是来自于内部的。&lt;/p&gt;
&lt;p&gt;近几年，在thehackernews等网站上总会时不时看到可以看到一些因为数据安全问题被大面积攻击、勒索的事件。在Hadoop1.0.0之前，Hadoop并不提供对安全的支持，默认集群内所有角色都是可靠的。用户访问时不需要进行任何验证,导致恶意用户很容易就可以伪装进入集群进行破坏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/11/03/i4WMu9.png&quot; alt=&quot;不安全的Hadoop集群&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要保证Hadoop集群的安全，至少要做到2个A：Authentication（认证），Authorization（授权）。常见的方案有：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Authentication：&lt;br/&gt;MIT Kerberos, Azure AD, Kerby&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Authorization：&lt;br/&gt;Apache Sentry(Cloudera), Apache Ranger(Hortonworks)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/10/30/5XI5Nu.png&quot; alt=&quot;Hadoop Cluster Secure&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;hadoop集群对kerberos的支持&quot;&gt;Hadoop集群对Kerberos的支持&lt;/h5&gt;
&lt;p&gt;2012年1.0.0版本正式发布后，Hadoop增加了对Kerberos的支持。使得集群中的节点是可信任的。Kerberos可以将认证的密钥在集群部署时事先放到可靠的节点上。集群运行时，集群内的节点使用密钥得到认证，认证通过后的节点才能提供服务。企图冒充的节点由于没有事先得到的密钥信息，无法与集群内部的节点通信。这样就防止了恶意地使用或篡改Hadoop集群的问题，确保了Hadoop集群的可靠性、安全性。&lt;/p&gt;
&lt;h2 id=&quot;kerberos介绍&quot;&gt;2.Kerberos介绍&lt;/h2&gt;
&lt;p&gt;Kerberos是种网络身份验证协议,最初设计是用来保护雅典娜工程的网络服务器。Kerberos这个名字源于希腊神话，是一只三头犬的名字，它旨在通过使用密钥加密技术为Client/Server序提供强身份验证。可以用于防止窃听、防止重放攻击、保护数据完整性等场合，是一种应用对称密钥体制进行密钥管理的系统。Kerberos的扩展产品也使用公开密钥加密方法进行认证。&lt;/p&gt;
&lt;p&gt;Kerberos目前最新版本是5，1~3版本只在MIT内部发行，因为使用DES加密，早期被美国出口管制局列为军需品禁止出口，直到瑞典皇家工学院实现了Kerberos版本4，KTH-KRB。后续也是这个团队实现了版本5: Heimdal，目前常见的Kerberos5实现之一。&lt;br/&gt;本文中讨论的Kerberos5实现版本为MIT Kerberos，MIT保持的大约半年左右一次的更新速度，目前最新版本是2018-11-01发布的1.16.2版本。&lt;/p&gt;
&lt;h3 id=&quot;名词解释&quot;&gt;2.1 名词解释&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;AS（Authentication Server）：认证服务器&lt;/li&gt;
&lt;li&gt;KDC（Key Distribution Center）：密钥分发中心&lt;/li&gt;
&lt;li&gt;TGT（Ticket Granting Ticket）：票据授权票据，票据的票据&lt;/li&gt;
&lt;li&gt;TGS（Ticket Granting Server）：票据授权服务器&lt;/li&gt;
&lt;li&gt;SS（Service Server）：特定服务提供端&lt;/li&gt;
&lt;li&gt;Principal：被认证的个体&lt;/li&gt;
&lt;li&gt;Ticket：票据，客户端用来证明身份真实性。包含：用户名，IP，时间戳，有效期，会话秘钥。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用Kerberos时，一个客户端需要经过三个步骤来获取服务:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;认证&lt;/code&gt;: 客户端向认证服务器发送一条报文，获取一个包含时间戳的TGT。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;授权&lt;/code&gt;: 客户端使用TGT向TGS请求指定Service的Ticket。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;服务请求&lt;/code&gt;: 客户端向指定的Service出示服务Ticket鉴权通讯。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Kerberos协议在网络通信协定中属于显示层。其通信流程简单地说，用户先用共享密钥从某认证服务器得到一个身份证明。随后，用户使用这个身份证明与SS通信，而不使用共享密钥。&lt;/p&gt;
&lt;h3 id=&quot;具体通信流程&quot;&gt;2.2 具体通信流程&lt;/h3&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;①此流程使用了对称加密; ②此流程发生在某一个Kerberos领域中； ③小写字母c,d,e,g是客户端发出的消息，大写字母A,B,E,F,H是各个服务器发回的消息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，用户使用客户端上的程序进行登录：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入用户ID和密码到客户端（或使用keytab登录）。&lt;/li&gt;
&lt;li&gt;客户端程序运行一个单向函数（大多数为Hash）把密码转换成密钥，这个就是客户端的“用户密钥”(user's secret key)。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;客户端认证kinit&quot;&gt;2.2.1 客户端认证（Kinit）&lt;/h4&gt;
&lt;p&gt;客户端(Client)从认证服务器(AS)获取票据的票据（TGT）。&lt;br/&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/10/30/5XIYmr.png&quot; alt=&quot;客户端认证&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Client向AS发送1条明文消息，申请基于该用户所应享有的服务，例如“用户Sunny想请求服务”（Sunny是用户ID）。（注意：用户不向AS发送“用户密钥”(user's secret key)，也不发送密码）该AS能够从本地数据库中查询到该申请用户的密码，并通过相同途径转换成相同的“用户密钥”(user's secret key)。&lt;/li&gt;
&lt;li&gt;AS检查该用户ID是否在于本地数据库中，如果用户存在则返回2条消息：
&lt;ul&gt;&lt;li&gt;【消息A】：&lt;strong&gt;Client/TGS会话密钥(Client/TGS Session Key)&lt;/strong&gt;（该Session Key用在将来Client与TGS的通信（会话）上），通过 &lt;strong&gt;用户密钥(user's secret key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;li&gt;【消息B】：&lt;strong&gt;票据授权票据(TGT)&lt;/strong&gt;（TGT包括：消息A中的“Client/TGS会话密钥”(Client/TGS Session Key)，用户ID，用户网址，TGT有效期），通过&lt;strong&gt;TGS密钥(TGS's secret key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一旦Client收到消息A和消息B，Client首先尝试用自己的“用户密钥”(user's secret key)解密消息A，如果用户输入的密码与AS数据库中的密码不符，则不能成功解密消息A。输入正确的密码并通过随之生成的&quot;user's secret key&quot;才能解密消息A，从而得到“Client/TGS会话密钥”(Client/TGS Session Key)。（注意：Client不能解密消息B，因为B是用TGS密钥(TGS's secret key)加密的）。拥有了“Client/TGS会话密钥”(Client/TGS Session Key)，Client就足以通过TGS进行认证了。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;服务授权&quot;&gt;2.2.2 服务授权&lt;/h4&gt;
&lt;p&gt;Client从TGS获取票据(client-to-server ticket)。&lt;br/&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/10/30/5XIziR.png&quot; alt=&quot;服务授权&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当client需要申请特定服务时，其向TGS发送以下2条消息：
&lt;ul&gt;&lt;li&gt;【消息c】：即消息B的内容（TGS's secret key加密后的TGT），和想获取的服务的服务ID（注意：不是用户ID）&lt;/li&gt;
&lt;li&gt;【消息d】：&lt;strong&gt;认证符(Authenticator)&lt;/strong&gt;（Authenticator包括：用户ID，时间戳），通过&lt;strong&gt;Client/TGS会话密钥(Client/TGS Session Key)&lt;/strong&gt;进行加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;收到消息c和消息d后，TGS首先检查KDC数据库中是否存在所需的服务，查找到之后，TGS用自己的“TGS密钥”(TGS's secret key)解密消息c中的消息B（也就是TGT），从而得到之前生成的“Client/TGS会话密钥”(Client/TGS Session Key)。TGS再用这个Session Key解密消息d得到包含用户ID和时间戳的Authenticator，并对TGT和Authenticator进行验证，验证通过之后返回2条消息：
&lt;ul&gt;&lt;li&gt;【消息E】：&lt;strong&gt;client-server票据(client-to-server ticket)&lt;/strong&gt;（该ticket包括：Client/SS会话密钥 (Client/Server Session Key），用户ID，用户网址，有效期），通过提供该服务的&lt;strong&gt;服务器密钥(service's secret key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;li&gt;【消息F】：&lt;strong&gt;Client/SS会话密钥( Client/Server Session Key)&lt;/strong&gt; （该Session Key用在将来Client与Server Service的通信（会话）上），通过&lt;strong&gt;Client/TGS会话密钥(Client/TGS Session Key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Client收到这些消息后，用“Client/TGS会话密钥”(Client/TGS Session Key)解密消息F，得到“Client/SS会话密钥”(Client/Server Session Key)。（注意：Client不能解密消息E，因为E是用“服务器密钥”(service's secret key)加密的）。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;服务请求&quot;&gt;2.2.3 服务请求&lt;/h4&gt;
&lt;p&gt;Client从SS获取服务。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当获得“Client/SS会话密钥”(Client/Server Session Key)之后，Client就能够使用服务器提供的服务了。Client向指定服务器SS发出2条消息：
&lt;ul&gt;&lt;li&gt;【消息e】：即上一步中的消息E“client-server票据”(client-to-server ticket)，通过&lt;strong&gt;服务器密钥(service's secret key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;li&gt;【消息g】：新的&lt;strong&gt;Authenticator&lt;/strong&gt;（包括：用户ID，时间戳），通过&lt;strong&gt;Client/SS会话密钥(Client/Server Session Key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SS用自己的密钥(service's secret key)解密消息e从而得到TGS提供的Client/SS会话密钥(Client/Server Session Key)。再用这个会话密钥解密消息g得到Authenticator，（同TGS一样）对Ticket和Authenticator进行验证，验证通过则返回1条消息（确认函：确证身份真实，乐于提供服务）
&lt;ul&gt;&lt;li&gt;【消息H】：&lt;strong&gt;新时间戳&lt;/strong&gt;（新时间戳是：Client发送的时间戳加1，v5已经取消这一做法），通过&lt;strong&gt;Client/SS会话密钥(Client/Server Session Key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Client通过Client/SS会话密钥(Client/Server Session Key)解密消息H，得到新时间戳并验证其是否正确。验证通过的话则客户端可以信赖服务器，并向服务器（SS）发送服务请求。&lt;/li&gt;
&lt;li&gt;服务器（SS）向客户端提供相应的服务。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;kerberos-ha架构&quot;&gt;3.Kerberos HA架构&lt;/h2&gt;
&lt;p&gt;Kerberos支持两种服务器在域内冗余方式：&lt;code&gt;Master/Slave&lt;/code&gt;（MIT和Heimdal）和&lt;code&gt;Multimaster&lt;/code&gt;结构（Windows Active Directory）。在生产环境中部署Kerberos时，最好使用一主(Master)多从(Slave)的架构，以确保Kerberos服务的高可用性。&lt;/p&gt;
&lt;p&gt;Kerberos中每个KDC都包含数据库的副本。主KDC包含域（Realm）数据库的&lt;strong&gt;可写副本&lt;/strong&gt;，它以固定的时间间隔复制到从KDC中。所有数据库更改（例如密码更改）都在主KDC上进行，当主KDC不可用时，从KDC提供Kerberos票据给服务授权，但不提供数据库管理。KDC需要一个Admin来进行日常的管理操作。&lt;br/&gt;Kerberos的同步机制只复制主数据库的内容，但不传递配置文件，以下文件必须手动复制到每个Slave中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- krb5.conf
- kdc.conf
- kadm5.acl
- master key stash file&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ha方案&quot;&gt;3.1 HA方案&lt;/h3&gt;
&lt;p&gt;目前单机房HA方案使用的较多的是Keepalived + Rsync 。Keepalived可以将多个无状态的单点通过虚拟IP(以下称为VIP)漂移的方式搭建成一个高可用服务。&lt;/p&gt;
&lt;p&gt;首先，在Master KDC中创建数据库的dump文件(将当前的Kerberos和KADM5数据库转储为ASCII文件)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kdb5_util dump [-b7|-ov|-r13] [-verbose] [-mkey_convert] [-new_mkey_file mkey_file] [-rev] [-recurse] [filename [principals...]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用Rsync将目录同步到Slave机器的对应目录中，&lt;br/&gt;再导入KDC中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kdb5_util load [-b7|-ov|-r13] [-hash] [-verbose] [-update] filename [dbname]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Hadoop所有请求通过请求内网域名，解析到Keepalived绑定的VIP的方式来使用KDC:&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/11/03/i4TRJI.png&quot; alt=&quot;Kerberos HA&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;优化和展望&quot;&gt;4. 优化和展望&lt;/h2&gt;
&lt;h3 id=&quot;优化&quot;&gt;4.1 优化&lt;/h3&gt;
&lt;h5 id=&quot;用户principal管理&quot;&gt;（1）用户（Principal）管理&lt;/h5&gt;
&lt;p&gt;如果团队中已经有一套权限系统，要将现有的身份系统集成到Kerberos中会很困难。&lt;br/&gt;随着业务的飞速增长，服务器规模越来越大，Kerberos Principal手动操作会越来越频繁，手动的增删改查维护会非常痛苦。需要在Kerberos管理系统中规范Principal申请、维护、删除、keytab生成流程。Principal申请和权限管理自动化。&lt;/p&gt;
&lt;h5 id=&quot;数据同步优化&quot;&gt;（2）数据同步优化&lt;/h5&gt;
&lt;p&gt;Kerberos数据同步可以将生成的数据记录同步写入到MySQL中，使用MySQL双主同步方式。在跨机房环境中，KDC数据使用Rsync工具进行增量同步。以A核心机房作为主机房，Rsync Server使用了Keepalived VIP的方式，当Kerberos主机宕机后，VIP漂移到另外一台主机器上，Rsync Client会以VIP所在的KDC主机器为Rsync Server进行数据同步，以保证KDC数据同步的高可用性。&lt;/p&gt;
&lt;h5 id=&quot;运维&quot;&gt;（3）运维&lt;/h5&gt;
&lt;p&gt;使用进程管理工具对Kerberos相关进程进行存活监控，当发现有进程异常退出时，邮件/微信/钉钉报警，主动再次拉起进程。&lt;/p&gt;
&lt;h3 id=&quot;展望&quot;&gt;4.2 展望&lt;/h3&gt;
&lt;p&gt;部署过Kerberos的同学都知道，在Hadoop集群部署Kerberos实际是一项非常繁琐的工作。Kerberos本质上是一种协议或安全通道，对于大多数用户或普通用户来说，是有一定学习曲线的，是否有更好的实现能够对普通用户隐藏这些繁琐的细节。&lt;/p&gt;
&lt;p&gt;阿里和Intel合作项目Hadoop Authentication Service (HAS) 据称目前已经应用到ApsaraDB for HBase2.0中:&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/11/03/i4H9jf.png&quot; alt=&quot;HAS&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HAS方案使用Kerby替代MIT Kerberos服务，利用HAS插件式验证方式建立一套人们习惯的账户密码体系。&lt;/p&gt;
&lt;p&gt;目前HAS在Apache Kerby项目&lt;code&gt;has-project&lt;/code&gt;分支开发中，未来会作为Kerbby的新feature出现在下一次release中。&lt;/p&gt;
&lt;p&gt;Apache Kerby作为Apache Directory的一个子项目，目前关注度并不高，让我们期待它在后续的发展吧。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 12:40:00 +0000</pubDate>
<dc:creator>mantou叔叔</dc:creator>
<og:description>1.背景 互联网从来就不是一个安全的地方。很多时候我们过分依赖防火墙来解决安全的问题，不幸的是，防火墙是假设“坏人”是来自外部的，而真正具有破坏性的攻击事件都是往往都是来自于内部的。 近几年，在the</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantoudev/p/9877433.html</dc:identifier>
</item>
<item>
<title>Vuex的基本概念、项目搭建、入坑点 - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/9901906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/9901906.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181103200324893-621048402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前言：Vuex是一个专门为Vue.js应用程序开发的状态管理模式, 它采用集中式存储管理所有组件的公共状态, 并以相应的规则保证状态以一种可预测的方式发生变化.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Vuex的四大核心&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.state 驱动应用的数据源&lt;br/&gt;2.mutations 基因突变 类如C# 属性get set&lt;br/&gt;3.actions 行为&lt;br/&gt;4.getters 读取器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181103200355777-828823668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中绿色虚线包裹起来的部分就是Vuex的核心, &lt;code&gt;state&lt;/code&gt;中保存的就是公共状态, 改变&lt;code&gt;state&lt;/code&gt;的唯一方式就是通过&lt;code&gt;mutations&lt;/code&gt;进行更改. 可能你现在看这张图有点不明白, 等经过本文的解释和案例演示, 再回来看这张图, 相信你会有更好的理解.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;如何引入Vuex？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.npm install vuex&lt;/p&gt;
&lt;p&gt;2.装好了之后，在全局上去使用你的Vuex&lt;/p&gt;
&lt;p&gt;3.创建Store对象，最好在src创建一个store这样的文件夹然后创建index.js&lt;/p&gt;
&lt;p&gt;4.在main.js中注册使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
import Vuex from 'vuex'

Vue.use( Vuex );

const store = new Vuex.Store({
    //待添加
})

new Vue({
    el: '#app',
    store,
    render: h =&amp;gt; h(App)
})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 为了讲解Vuex，我们做了一个项目，这个项目需要连接apicloud，异步操作使用了axios以及样式bootstrap，其中包括了登录注册以及其中的父组件向子节点传值等，我们给项目安装相关的modules&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm install bootstrap
npm install axios&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181103200940259-1111092346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;router.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: '/',
      name: 'index',
     component:()=&amp;gt;import('../views/index.vue')
    },
    {
      path:'/detail/:id',
      name:'detail',
      component:()=&amp;gt;import ('../views/detail.vue')
    },
    {
      path:'/login',
      name:'login',
      component:()=&amp;gt;import ('../views/login.vue')
    },
    {
      path:'/register',
      name:'register',
      component:()=&amp;gt;import ('../views/register.vue')
    }
  ]
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;store.js&lt;/p&gt;

&lt;p&gt; 我们来上述代码中来讲解其中vuex的奥秘，State就是所有组件提出来的data，用于所有组件公共数据，而其中mutations就像C#中get\set，属性赋值器，其中方法的两个参数除了state只能带一个参数。&lt;/p&gt;
&lt;p&gt;actions是操作数据的方法，说过说你的actions中需要改变state中的数据，那么必须要通过commit关键字去提交给mutations，还有一点就是actions中很多操作都是关于异步处理的，最关键就是它是操作state数据的，那getters是什么呢？它是组件访问vuex的入口，里面写好了方法去操作，它也是过滤器，就像程序中的三层架构BLL.&lt;/p&gt;
&lt;p&gt; main.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// The Vue build version to load with the `import` command
// (runtime-only or standalone) has been set in webpack.base.conf with an alias.
import Vue from 'vue'
import App from './App'
import router from './router'
import boostrap from 'bootstrap/dist/css/bootstrap.css'
import store from './store/index.js'

Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  store,//在全局对象上加载仓库
  components: { App },
  template: '&amp;lt;App/&amp;gt;'
})　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
import Vue from 'vue'
import Vuex from 'vuex'
import API from '../utils/api.js'

var api = new API('goods')
var userApi = new API('userinfo');

Vue.use(Vuex);

const state = {
    user: null,
    products: []
}
const mutations = {
    //加载产品数据
    INIT_PRODUCTS(state, data) {
        state.products = data;
    },
    SET_LOGIN_USER(state, u) {
        state.user = u;
    }
}
const actions = {
    LOAD_PRODUCTS({ commit }) {
        api.Select().then(res =&amp;gt; {
            commit('INIT_PRODUCTS', res.data);
        })
    },
    LOGIN({ commit }, user) {
        return userApi.Select().then(res =&amp;gt; {
            let users = res.data;//所有的用户
            for (let u of users) {
                if (u.name == user.name &amp;amp;&amp;amp; u.password == user.password) {
                    commit('SET_LOGIN_USER', u);
                    return u;
                }
            }
        })
    },
    REGISTER({ commit }, user) {
        return userApi.Insert(user).then(res =&amp;gt; {
            console.log(res.data);
            return 'OK';
        }).catch(err =&amp;gt; {
            return err;
        })
    }

}
const getters = {
    ALL_PRODUCTS(state) {
        return state.products;
    },
    GET_PRODUCT_BYID: (state) =&amp;gt; function (id) {
        //遍历 is == id
        for (let p of state.products) {
            if (p.id == id) {
                return p;
            }
        }
        return null;
    }
}

//仓库
const store = new Vuex.Store({
    state: state,
    mutations: mutations,
    actions: actions,
    getters: getters
})
export default store;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;navbar.vue&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
     &amp;lt;nav class=&quot;navbar navbar-expand-lg  navbar-dark bg-dark&quot;&amp;gt;
        &amp;lt;div class=&quot;container&quot;&amp;gt;
            &amp;lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&amp;gt;购物车&amp;lt;/a&amp;gt;
            &amp;lt;ul class=&quot;navbar-nav ml-auto&quot;&amp;gt;
                &amp;lt;li class=&quot;nav-item active dropdown&quot; v-if=&quot;user!==null&quot;&amp;gt;
                    &amp;lt;a class=&quot;nav-link dropdown-toggle&quot;  data-toggle=&quot;dropdown&quot; @click=&quot;showDropdown=!showDropdown&quot;&amp;gt;欢迎你:{{user.name}} &amp;lt;/a&amp;gt;
                    &amp;lt;div class=&quot;dropdown-menu show&quot;&amp;gt;
                        &amp;lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&amp;gt;我的订单&amp;lt;/a&amp;gt;
                        &amp;lt;div class=&quot;dropdown-divider&quot;&amp;gt;&amp;lt;/div&amp;gt;
                        &amp;lt;a class=&quot;dropdown-item&quot; &amp;gt;注销&amp;lt;/a&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li class=&quot;nav-item active&quot; style=&quot;margin-right:5px&quot; v-if=&quot;user===null&quot;&amp;gt;
                    &amp;lt;router-link  class=&quot;nav-link btn btn-warning btn-sm&quot; style=&quot;color:#fff&quot; to=&quot;/login&quot;&amp;gt;登录&amp;lt;/router-link&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li class=&quot;nav-item active&quot; v-if=&quot;user===null&quot;&amp;gt;
                    &amp;lt;router-link  class=&quot;nav-link btn btn-danger btn-sm&quot; style=&quot;color:#fff&quot; to=&quot;/register&quot;&amp;gt;注册&amp;lt;/router-link&amp;gt;
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/nav&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    data(){
        return{
            showDropdown:false
        }
    },
    computed:{
        user(){
            return this.$store.state.user;
        }
        
    }
}
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;product.vue 该组件用于显示商品的详细信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;card&quot;&amp;gt;
        &amp;lt;img class=&quot;card-img-top&quot; src=&quot;../../assets/logo.png&quot; alt=&quot;Card image cap&quot;&amp;gt;
        &amp;lt;div class=&quot;card-body&quot;&amp;gt;
            &amp;lt;h5 class=&quot;card-title&quot;&amp;gt;{{product.name}}&amp;lt;/h5&amp;gt;
            &amp;lt;p class=&quot;card-text&quot;&amp;gt;{{product.description===null?&quot;暂无描述&quot;:product.description}}&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;价格: {{product.price}}&amp;lt;/p&amp;gt;
            &amp;lt;a href=&quot;#&quot; class=&quot;btn btn-warning float-left&quot; @click=&quot;goDetail&quot;&amp;gt;查看详情&amp;lt;/a&amp;gt;
            &amp;lt;a href=&quot;#&quot; class=&quot;btn btn-primary float-right&quot;&amp;gt;加入购物车&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    props:['product'],
    methods:{
        goDetail(){
            console.log(this.product.id);
            this.$router.push(`/detail/${this.product.id}`);
        }
    }
}
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;程序入口APP.vue&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;nav-bar&amp;gt;&amp;lt;/nav-bar&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import NavBar from './views/components/navbar'
export default {
    name: 'App',
    components:{NavBar}
}
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注册：通过&lt;span&gt;this.$store.dispatch去调用actions中的方法，其中有趣的是commit的参数竟然被方法名给..这个以后在思考。。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;
            &amp;lt;div class=&quot;card&quot; style=&quot;margin:50px auto;width:400px&quot;&amp;gt;
                &amp;lt;div class=&quot;card-body&quot;&amp;gt;
                    &amp;lt;h5 class=&quot;card-title&quot;&amp;gt;注册&amp;lt;/h5&amp;gt;
                    &amp;lt;hr&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;label for=&quot;&quot;&amp;gt;用户名&amp;lt;/label&amp;gt;
                        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user.name&quot;&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;label for=&quot;&quot;&amp;gt;真实姓名&amp;lt;/label&amp;gt;
                        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user.realname&quot;&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;label for=&quot;&quot;&amp;gt;密码&amp;lt;/label&amp;gt;
                        &amp;lt;input type=&quot;password&quot; class=&quot;form-control&quot; v-model=&quot;user.password&quot;&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;button class=&quot;btn btn-primary btn-block&quot; @click=&quot;register&quot;&amp;gt;注册&amp;lt;/button&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
    data(){
        return{
            user:{
                name:'',
                realname:'',
                password:''
            }
        }
    },methods:{
        register(){
            this.$store.dispatch('REGISTER',this.user).then(res=&amp;gt;{
                if(res==&quot;OK&quot;)
                    this.$router.push('/index');
            })
        }
    }
}
&amp;lt;/script&amp;gt;　
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;　登录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;
            &amp;lt;div class=&quot;card&quot; style=&quot;margin:50px auto;width:400px&quot;&amp;gt;
                &amp;lt;div class=&quot;card-body&quot;&amp;gt;
                    &amp;lt;h5 class=&quot;card-title&quot;&amp;gt;登录&amp;lt;/h5&amp;gt;
                    &amp;lt;hr&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;label for=&quot;&quot;&amp;gt;用户名&amp;lt;/label&amp;gt;
                        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user.name&quot;&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;label for=&quot;&quot;&amp;gt;密码&amp;lt;/label&amp;gt;
                        &amp;lt;input type=&quot;password&quot; class=&quot;form-control&quot; v-model=&quot;user.password&quot;&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;button class=&quot;btn btn-primary btn-block&quot; @click=&quot;login&quot;&amp;gt;登录&amp;lt;/button&amp;gt;
                    &amp;lt;/div&amp;gt; 
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    data(){
        return {
            user:{
                name:'',
                password:''
            }
        }
    },
    methods:{
        login(){
            this.$store.dispatch('LOGIN',this.user).then(res=&amp;gt;{
                console.log(res);
                if (res){
                    this.$router.push('/')
                }
            })
        }
    }
}
&amp;lt;/script&amp;gt;
　主页面

&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;h1&amp;gt;商品列表&amp;lt;/h1&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;
              &amp;lt;div class=&quot;col-md-4&quot; v-for=&quot;p in products&quot; :key=&quot;p.id&quot;&amp;gt;
                &amp;lt;!-- 传递商品信息到子组件 --&amp;gt;
                &amp;lt;product-card  :product=&quot;p&quot;&amp;gt;&amp;lt;/product-card&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import ProductCard from './components/product.vue'
export default {
    components:{ProductCard},
    computed:{
        products(){
           return this.$store.getters.ALL_PRODUCTS;
        }
    },
    created(){
        this.$store.dispatch('LOAD_PRODUCTS');
    }
}
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本文结语知识总结：&lt;/p&gt;
&lt;p&gt;获取url中的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
let id = this.$route.params.id;
this.details = this.$store.getters.GET_PRODUCT_BYID(id);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有的小伙伴在复制我的代码运行报错，说什么未初始化；一定要在index.vue添加这个代码，LOAD_PRODUCTS给数据初始化&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
    created(){
        this.$store.dispatch('LOAD_PRODUCTS');
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;跳转路由&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
this.$router.push('/')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ApiClound万能帮助类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
import crypto from 'crypto'     // 加密
import axios from 'axios'
class API {
    constructor(classname){
        this.api = `https://d.apicloud.com/mcm/api/${classname}`;
        let ID = '';
        let KEY = '';
        let now = Date.now(); //当前时间
        let sha1 = crypto.createHash('sha1');
        sha1.update(ID + &quot;UZ&quot; + KEY + &quot;UZ&quot; + now);  
        axios.defaults.headers[&quot;X-APICloud-AppId&quot;] = ID;
        axios.defaults.headers[&quot;X-APICloud-AppKey&quot;] = sha1.digest('hex') + &quot;.&quot; + now;
    }
    
    Select(){
        return axios.get(this.api);
    }
    Insert(obj){
        return axios.post(this.api,obj);
    }
    Update(id,obj){
        // RESTFUL API 
        return axios.put(this.api+`/${id}`,obj);
    }
    Delete(id){
        return axios.delete(this.api + `/${id}`);
    }
}

export default API;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　还有同学问我父组件和子组件如何传值？&lt;/p&gt;
&lt;p&gt;在父页面引用的地方以&quot;:&quot;表示的值都可以在子页面的props获取到&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;h3&amp;gt;图书管理&amp;lt;/h3&amp;gt;&amp;lt;hr&amp;gt;
    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;div class=&quot;col-md-4 col-sm-4&quot; v-for=&quot;b in books&quot; :key=&quot;b.id&quot;&amp;gt;
            &amp;lt;book-detail @abc=&quot;xyz&quot; :Book=&quot;b&quot; :MSG=&quot;abc&quot;&amp;gt;&amp;lt;/book-detail&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
    import BookDetail from './components/BookDetails.vue'
    export default{
        components:{BookDetail},
        data(){
            return {
                abc:'heheda',
                books:[{
                    id:1,
                    name:'7天 JAVA 从入门到放弃',
                    text:'到底是人性的扭曲，还是道德的沦丧. 青年男子为何突然脱发，中年男人为何删库跑路。',
                    price:20,
                    img:'img2.jpg',
                    showHehe:true
                },{
                    id:2,
                    name:'7天 C# 从入门到自杀',
                    text:'到底是人性的扭曲啊，还是道德的沦丧啊. 祖国的花朵为何自杀。',
                    price:20,
                    img:'../../static/img2.jpg',
                    showHehe:false
                }]
            }
        },
        methods:{
            xyz(bid){
                alert(bid);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在子页面中可以这么搞&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;script&amp;gt;
export default{
    props:[&quot;Book&quot;,&quot;MSG&quot;],
    created(){
        console.log(this.Book.name);
    },
    methods:{
        select(id){
            this.$emit('abc',id);
        },
        detail(bid){
            this.$router.push(`/admin/Details/${bid}`);
        }
    }
}
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　而其中的$emit是可以调用父页面的方法的。&lt;/p&gt;
&lt;p&gt;谢谢大家收看！！！&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 12:07:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>前言：Vuex是一个专门为Vue.js应用程序开发的状态管理模式, 它采用集中式存储管理所有组件的公共状态, 并以相应的规则保证状态以一种可预测的方式发生变化. Vuex的四大核心 1.state 驱</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/9901906.html</dc:identifier>
</item>
<item>
<title>分类-MNIST - EndlessCoding</title>
<link>http://www.cnblogs.com/endlesscoding/p/9901539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endlesscoding/p/9901539.html</guid>
<description>&lt;blockquote readability=&quot;6.9878345498783&quot;&gt;
&lt;p&gt;这是学习《Hands-On Machine Learning with Scikit-Learn and TensorFlow》的笔记，如果此笔记对该书有侵权内容，请联系我，将其删除。&lt;br/&gt;博客出自：&lt;a href=&quot;https://www.cnblogs.com/endlesscoding/p/9901539.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/endlesscoding/p/9901539.html&lt;/a&gt;，未经博主同意，请忽转载。&lt;br/&gt;这里面的内容目前条理还不是特别清析，后面有时间会更新整理一下。&lt;br/&gt;下面的代码运行环境为jupyter + python3.6&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# from sklearn.datasets import fetch_mldata
# from sklearn import datasets

# mnist = fetch_mldata('MNIST   original') 
# mnist&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好像下载不到它的数据，直接从网上找到它的数据，放到当面目录下的&lt;code&gt;dataset&lt;/code&gt;目录下。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.datasets import fetch_mldata
from sklearn import datasets
import numpy as np

mnist = fetch_mldata('mnist-original', data_home = './datasets/') 
mnist
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;{'DESCR': 'mldata.org dataset: mnist-original',
 'COL_NAMES': ['label', 'data'],
 'target': array([0., 0., 0., ..., 9., 9., 9.]),
 'data': array([[0, 0, 0, ..., 0, 0, 0],
        [0, 0, 0, ..., 0, 0, 0],
        [0, 0, 0, ..., 0, 0, 0],
        ...,
        [0, 0, 0, ..., 0, 0, 0],
        [0, 0, 0, ..., 0, 0, 0],
        [0, 0, 0, ..., 0, 0, 0]], dtype=uint8)}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;网上很多的说法是错误的，只有我这个才是正解。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X, y = mnist['data'], mnist['target']
print(X.shape)
print(y.shape)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(70000, 784)
(70000,)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面看出来，X是一个&lt;span class=&quot;math inline&quot;&gt;\(7000\times784\)&lt;/span&gt;的一个矩阵，一般来说，7000行表示有7000个样本，784列，表示样本有784这么多个属性。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;%matplotlib inline
import matplotlib
import matplotlib.pyplot as plt

some_digit = X[36000]
some_digit_image = some_digit.reshape(28,28)

plt.imshow(some_digit_image, cmap=matplotlib.cm.binary, interpolation=&quot;nearest&quot;)
plt.axis('off')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd8658472a2.png&quot; alt=&quot;output_6_0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说个数看起来像是5，我觉得更像是6，我们可查看一下它的标签。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y[36000]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;5.0&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# EXTRA
def plot_digits(instances, images_per_row=10, **options):
    size = 28
    images_per_row = min(len(instances), images_per_row)
    images = [instance.reshape(size,size) for instance in instances]
    n_rows = (len(instances) - 1) // images_per_row + 1
    row_images = []
    n_empty = n_rows * images_per_row - len(instances)
    images.append(np.zeros((size, size * n_empty)))
    for row in range(n_rows):
        rimages = images[row * images_per_row : (row + 1) * images_per_row]
        row_images.append(np.concatenate(rimages, axis=1))
    image = np.concatenate(row_images, axis=0)
    plt.imshow(image, cmap = matplotlib.cm.binary, **options)
    plt.axis(&quot;off&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;plt.figure(figsize=(9,9))
example_images = np.r_[X[:12000:600], X[13000:30600:600], X[30600:60000:590]]
plot_digits(example_images, images_per_row=10)
# save_fig(&quot;more_digits_plot&quot;)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd86e72c0a4.png&quot; alt=&quot;output_10_0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能这个标签写错了都不一定，我们得新写一下这个标签，说不定可以提高模型的准确率呢。这只是我个人在这里开玩笑说的，不用当真哈。&lt;/p&gt;
&lt;p&gt;在做数据的训练前，应该找出测试集，这里MNIST已经帮我们把测试集做好了。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X_train, X_test, y_train, y_test = X[:60000],X[60000:],y[:60000],y[60000:]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MNIST的数据是按数字大小顺序排列的，所我们先要打乱它的顺序，这样可以保证我们的交叉验证是每一次都是相似的。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np

shuffle_index = np.random.permutation(60000)
shuffle_index&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([52603, 56601, 42625, ..., 17778, 24267, 29358])&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;np.random.permutation 是随机排列一个序列。上面的例子就是从0~60000的随机序列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X_train, y_train = X_train[shuffle_index],y_train[shuffle_index]&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;先不做一个多类器，我们先不去识别里面的手写数字是0~10中的某一个数。目前做一个最简单的，判断它是否是5，即将数据分成两个类别：“5”和“非5”&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 这是一个逻辑数组，5：True, 非5：False
y_train_5 = (y_train == 5)
y_test_5 = (y_test == 5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在开始用一个分类器去训练它。用随机梯度下降分类器SGD。用Scikit-Learn的SGDClassifier类。这个分类器有一个好处是能够高效地处理非常大的数据集。部分原因是它每次只处理一条数据。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.linear_model import SGDClassifier

sgd_clf = SGDClassifier(random_state = 32)
sgd_clf.fit(X_train, y_train_5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;SGDClassifier(alpha=0.0001, average=False, class_weight=None,
       early_stopping=False, epsilon=0.1, eta0=0.0, fit_intercept=True,
       l1_ratio=0.15, learning_rate='optimal', loss='hinge', max_iter=None,
       n_iter=None, n_iter_no_change=5, n_jobs=None, penalty='l2',
       power_t=0.5, random_state=32, shuffle=True, tol=None,
       validation_fraction=0.1, verbose=0, warm_start=False)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sgd_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([ True])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个模型的准确度好像受随机种子的影响比较大，如果我将模型的随机种改为42，我们再来看一下它预测的结果是不是正确的&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sgd_clf = SGDClassifier(random_state = 42)
sgd_clf.fit(X_train, y_train_5)
sgd_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([ True])&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;可以到这个时候它又预测错了。下面来整体评估一下这个分类的性能。&lt;/p&gt;
&lt;h2 id=&quot;使用交叉验证测量准确性&quot;&gt;使用交叉验证测量准确性&lt;/h2&gt;
&lt;p&gt;在交叉验证过程中，有时候我们会需要更多的控制权，相较于函数cross_val_score()或者其他相似函数所提供的功能。下面代码做了和cross_val_score()相同的事情&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.model_selection import StratifiedKFold
from sklearn.base import clone

skfolds = StratifiedKFold(n_splits = 3, random_state = 42)
clone_clf = clone(sgd_clf)
for train_index, test_index in skfolds.split(X_train, y_train_5):
    X_train_folds = X_train[train_index]
    y_train_folds = (y_train_5[train_index])
    X_test_fold = X_train[test_index]
    y_test_fold = (y_train_5[test_index])
    clone_clf.fit(X_train_folds, y_train_folds)
    y_pred = clone_clf.predict(X_test_fold)
    n_correct = sum(y_pred == y_test_fold)
    print(n_correct / len(y_pred))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.9612

0.9531

0.9688&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;StratfiedKFold 类实现了分层采样，生成的折包含了各类相应比例的样例。在每一次迭代，上述代码生成分类器的一个克隆，在克隆的模型上训练，在测试折上进行预测&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面直接使用sklearn中的库进行交叉评估。使用&lt;code&gt;cross_val_score&lt;/code&gt;函数来评估SGDClassifier模型。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.model_selection import cross_val_score

cross_val_score(sgd_clf, X_train, y_train_5, cv = 3, scoring = &quot;accuracy&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0.9612, 0.9531, 0.9688])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这精度看起来还不错，有大于95%的精度，有点让人兴奋，感觉做个分类还是挺容易的，不难。&lt;br/&gt;我们再来看下一个非常简单的分类器去分类，看看它在“非5”这个类上的表现。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.base import BaseEstimator
# 这个模型的预测的策略就是将所有的数据都认为是'非5'
class Never5Classifier(BaseEstimator):
    def fit(self,X,y=None):
        pass
    def predict(self,X):
        return np.zeros((len(X),1), dtype=bool)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;np.zeros((2,1), dtype=bool)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[False],
       [False]])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;never_5_clf = Never5Classifier()
cross_val_score(never_5_clf, X_train, y_train_5, cv = 3, scoring = &quot;accuracy&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0.90815, 0.9124 , 0.9084 ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这么一个简单的分类器也有90%的精度，这是因为只有10%的样本是5，其它都是非5，所以只我们一直猜这个图像不是5，当然有90%的精度，这叫数据不平衡。就像我们如果在日本，站到大街上，见到人就猜他是一个日本人，我们几乎肯定是正确的。&lt;/p&gt;
&lt;p&gt;所以精度并不是一个好的性能度量指标，特别是在我们数据不平衡的时候。&lt;/p&gt;
&lt;h2 id=&quot;混淆矩阵&quot;&gt;混淆矩阵&lt;/h2&gt;
&lt;p&gt;对一般分类器来说，一人好得多的性能评估指标是混淆矩阵。大体思路是：输出类别A被分成类别B的次数。&lt;/p&gt;
&lt;p&gt;为了计算混淆矩阵，首先你需要有一系列的预测值，这样才能将预测值与真实值做比较。你或许想在测试集上做预测。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.model_selection import cross_val_predict

y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv = 3)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import confusion_matrix

confusion_matrix(y_train_5, y_train_pred)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[54306,   273],
       [ 2065,  3356]], dtype=int64)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;混淆矩阵中的每一行表示一个实际的类，而每一列表一个预测的类。该矩阵的第一行认为&quot;非5&quot;中的53993张被正确地归类为非5（这被称为真反例，true negatives）,而其余586被错误归类为5（这被称为假正例，false positive），其余3905正确分类为&quot;5&quot;类（真正例，true positive）。一个完美的分类器将只有真反例和真正例，所混淆矩阵的非零值仅在其主对角线（左上至右下）。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# confusion_matrix(y_train_5, y_train_perfect_predictions)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;混淆矩阵可以提供很多信息。有时候你会想要更加简明的指标。一个有趣的指标是正例预测的精度，也叫做分类器的准确率(precision)&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ precision = \frac{TP}{TP + FP} \tag{3-1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(TP\)&lt;/span&gt;是&lt;code&gt;真正例&lt;/code&gt;的数目，&lt;span class=&quot;math inline&quot;&gt;\(FP\)&lt;/span&gt;是&lt;code&gt;假正例&lt;/code&gt;的数目。&lt;/p&gt;
&lt;p&gt;以准确率一般会伴随另一个指标一起使用，这个指标叫做召回率（recall），也叫做敏感度（sensitivity）或者真正例率（true positive rate, TPR）。这是正例被分类器正确探测出的比率。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ recall = \frac{TP}{TP+FN} \tag{3-2} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(FN\)&lt;/span&gt;是假反例的数目。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import precision_score, recall_score

print(precision_score(y_train_5, y_train_pred))
print(recall_score(y_train_5, y_train_pred))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.924772664645908
0.6190739715919572&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样看起，这个分类器的准确率并不高，只有56.8%左右，而且只是分成两类的一个分类器，这跟我们猜差不多。&lt;/p&gt;
&lt;p&gt;通常结合准确率和召回率会更加方便，这个指标叫做&lt;code&gt;F1&lt;/code&gt;值，特别是当你需要一个简单的方法去比较两个分类器的优劣的时时候。F1值是准确率和召回率的&lt;code&gt;调和平均&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ F1 = \frac{2}{\frac{1}{precision}+\frac{1}{recall}} = 2 \times \frac{precision \times recall}{precision + recall} = \frac{TP}{TP + \frac{FN+FP}{2}} \tag{3-3} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;计算F1值，简单调用&lt;code&gt;f1_score()&lt;/code&gt;即可。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import f1_score

f1_score(y_train_5, y_train_pred)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.7416574585635358&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;F1支持那些有着相近准确率和召回率的分类（意思是只有当准确率和召回率一样大的时个，F1值才会大）。但并不是所的时候，我们都关心F1值，有时候我们只关心准确率（precision），或者有时候我们只关心召回率（recall）。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;这里，我们再次理解一下准确率的含义：如果一个分类器的每次几乎都能把我们所要分的类别准确地分类出来，那么无疑，这个分类器的准确率是高的；什么时候准备率低呢，就是它把我们所要分的类，预测错了。比如我们这里的例子，我们要预测这张手写图片的数字是否是5，如果那张图真的是5，而我们的分类器预测它是5，那么它预测对了，当然预测对了，不是我们区分准确率与召回率的情况。如果将一张不是5的图片预测成5，那么我们会说它个分类器不是很准，它有低准确率。&lt;/p&gt;
&lt;p&gt;什么是召回率？当我们将一张是5的图片预测成不是5，说明这个分类器还是比较严格的，那和它有较低的如回率。&lt;/p&gt;
&lt;p&gt;总的来说，准确率低的原因就产将那些看起来像5（只是像，实际并不是5）的预测成了5；而召回率低的原因是把那些看起来不像5（实际上是5，只是可能那个5写得比较丑）预测成不是5。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里，我以自己的理解，举两个例子，比如公司想找个人当总经理，有一群人来应聘它。我们这时候的目标是，找到的这个人肯定是能够当总经理的，就算有的人看起来像是能当总经理，但是为了确保万无一失，我们要找一个看起来非常非常像能够当总经理的人。这个时候我们当然有着很高的准确率，因为我们找的人几乎肯定是能够当总经理的，但是此时，我们会犯另一个错误，就是有些人确实有能力当总经理，只是我们没有看出来（人不可貌像），所以我们拒绝他，因此我们有低的召回率，这在统计学上被称为犯了&lt;code&gt;第一类错误&lt;/code&gt;，即&lt;code&gt;弃真&lt;/code&gt;。这样做是合理的，因为即使&lt;code&gt;弃真&lt;/code&gt;，但我们&lt;code&gt;保真&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;另一种情况是，比如警察在一群人中想找出几个犯罪的人，这个时候我们就不能要超高的准确率了，因为有可能把真正的犯人放走。找犯人的原则一般是，只要他看起来像个犯人，都应该审查一下，即使最后真像大白后，他真的不是一个犯人。我们平时听到的&lt;code&gt;宁可错杀一千，不可放走一个&lt;/code&gt;说的就是这个道理，因此这有着比较低的准确率，但是有高的召回率，这在统计学上被称为犯了&lt;code&gt;第二类错误&lt;/code&gt;，即&lt;code&gt;取伪&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;准备率召回率之间的折中&quot;&gt;准备率/召回率之间的折中&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_scores = sgd_clf.decision_function([some_digit])
y_scores&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([15905.22111141])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;threshold = 0
y_some_digit_pred = (y_scores &amp;gt; threshold)
y_some_digit_pred&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([ True])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_scores = cross_val_predict(sgd_clf, X_train,y_train_5,cv=3,
                             method = &quot;decision_function&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import precision_recall_curve
precisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def plot_precision_recall_vs_threshold(precisions, recalls, thresholds):
    plt.plot(thresholds, precisions[:-1], &quot;b--&quot;, label = &quot;Precision&quot;)
    plt.plot(thresholds, recalls[:-1], &quot;g-&quot;, label = &quot;Recall&quot;)
    plt.xlabel(&quot;Threshold&quot;)
    plt.legend(loc=&quot;upper left&quot;)
    plt.ylim([0,1.1])
    
plot_precision_recall_vs_threshold(precisions,recalls,thresholds)
plt.grid()
plt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd86e785655.png&quot; alt=&quot;output_51_1.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;roc曲线&quot;&gt;ROC曲线&lt;/h3&gt;
&lt;p&gt;受试者工作特征(ROC)曲线是另一个二分类器常用的工具。它非常类似与准确率/召回率曲线，但不是画出准确率对召回率的曲线，，ROC曲线是真正例率（true positive rate，另一个名字叫做召回率）对假正例率（false positive rate, FPR）的曲线。FPR是反例被错误分成正例的比率。它等于1减去真反例率（true negative rate，TNR）。TNR是反例被正确分类的比率。TNR也叫做特异性。&lt;/p&gt;
&lt;p&gt;为了画出ROC曲线，你首先需要计算各种不同阈值下的TPR、FPR，使用roc_curve()函数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import roc_curve
fpr, tpr, thresholds = roc_curve(y_train_5, y_scores)

def plot_roc_curve(fpr, tpr, label = None):
    plt.plot(fpr,tpr, linewidth = 2, label = label)
    plt.plot([0,1],[0,1],'k--')
    plt.axis([0,1,0,1])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')

plot_roc_curve(fpr,tpr)
plt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd86e7dbb35.png&quot; alt=&quot;output_53_1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个比较分类器之间优劣的方法是：测量ROC曲线下的面积（AUC）。一个完美的分类器的 ROC AUC 等于1，而一个纯随机分类器的ROC AUC等于0.5。Scikit-Learn提供了一个函数来计算ROC AUC：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import roc_auc_score
roc_auc_score(y_train_5,y_scores)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.9623990527630832&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.ensemble import RandomForestClassifier

forest_clf = RandomForestClassifier(random_state = 42)
y_probas_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv=3, method = &quot;predict_proba&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_scores_forest = y_probas_forest[:,1]
fpr_forest, tpr_forest, thresholds_forest=roc_curve(y_train_5,y_scores_forest)
plt.plot(fpr,tpr,&quot;b:&quot;,label=&quot;SGD&quot;) 
plot_roc_curve(fpr_forest,tpr_forest,&quot;Random Forest&quot;) 
plt.legend(loc=&quot;bottom  right&quot;) 
plt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd86e83e34e.png&quot; alt=&quot;output_57_2.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 将概率大于0.5的，置为true, 否则为false
print(precision_score(y_train_5, y_scores_forest &amp;gt; 0.5))
print(recall_score(y_train_5, y_scores_forest &amp;gt; 0.5))
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.9844298245614035
0.8280760007378712&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出来，它的准确率还可，挺高的。&lt;/p&gt;
&lt;p&gt;下面我们将分类出更多的数字，而不仅仅是5。&lt;/p&gt;

&lt;p&gt;二分类器只能分出两个类，而多分类器能分出多于两个类别的类。&lt;/p&gt;
&lt;p&gt;一些算法（比如随机森林分类器或者朴素贝叶斯分类器）可以直接处理多类分类问题。其他一些算法（比如SVM分类器或者线性分类器）则是严格的二分类器，然后有许多策略可以让你用二分类器去执行多类分类。&lt;/p&gt;
&lt;p&gt;Scikit-Learn可以探测出你想使用一个二分类器去完成多分类的任务，它会自动地执行OvA（除了SVM分类器，它使用OvO）。让我们试一下&lt;code&gt;SGDClassifier&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sgd_clf.fit(X_train, y_train)
sgd_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([5.])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以调用decision_function()方法。不是返回每个样例的一个数值，而是返回10个数值，一个数值对应于一个类。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;some_digit_scores = sgd_clf.decision_function([some_digit])
some_digit_scores&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[-253639.46707377, -425198.63904333, -354213.80127786,
        -229676.13263264, -376404.48500382,   15905.22111141,
        -564592.12430579, -194289.65607053, -748913.30208666,
        -597652.52038338]])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最高的数值对应类别5&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;np.argmax(some_digit_scores)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;5&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sgd_clf.classes_&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你想强制Scikit-Learn使用OvO策略或者OvA策略，你可以使用OneVsOneClassifier类或者OneVsRestClassifier类。创建一个样例，传递一个二分类器给它的构造函数。举例子，下面的代码会创建一个多类分类器，使用OvO策略，基于&lt;code&gt;SGDClassifier&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.multiclass import OneVsOneClassifier

ovo_clf = OneVsOneClassifier(SGDClassifier(random_state=42))
ovo_clf.fit(X_train, y_train)
ovo_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([5.])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;训练一个RandomForestClassifier同样简单：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;forest_clf.fit(X_train,y_train)
forest_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([5.])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次Scikit-Learn没有必要去运行OvO或者OvA, 因为随机森林分类器能够直接将一个样例分到多个类别。你可调用&lt;code&gt;predict_proba()&lt;/code&gt;，得到样例对应的类别的概率值的列表：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;forest_clf.predict_proba([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[0. , 0. , 0. , 0. , 0. , 0.9, 0. , 0. , 0.1, 0. ]])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们当然想评估一下这些分类器。像以前一样，想便用交叉验证。让我们用&lt;code&gt;cross_val_score&lt;/code&gt;来评估&lt;code&gt;SGDClassifier&lt;/code&gt;的精度。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;cross_val_score(sgd_clf, X_train, y_train,cv = 3, scoring = &quot;accuracy&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0.86002799, 0.8760438 , 0.88093214])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到这个分类器有86.3%的精度，这个精度还不错，比我们随便乱猜的精度要高出不少（如果我们随机猜，那么精度只有10%）。看起来也并不差，这里可以使输入正则化，得到更高的精度，可以将其精度提高到90%以上。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train.astype(np.float64))
cross_val_score(sgd_clf, X_train_scaled, y_train, cv = 3, scoring=&quot;accuracy&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0.9080184 , 0.91049552, 0.91043657])&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;分析模型产生的误差，首先，我们可以检查混淆矩阵。需要使用&lt;code&gt;cross_val_predict()&lt;/code&gt;做出预测，然后调用confusion_matrix()函数，像以前做的那样&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_train_pred = cross_val_predict(sgd_clf, X_train_scaled, y_train, cv = 3)
conf_mx = confusion_matrix(y_train, y_train_pred)
conf_mx&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[5739,    3,   22,    8,    9,   50,   43,    7,   38,    4],
       [   2, 6451,   50,   23,    6,   46,    5,   14,  133,   12],
       [  58,   38, 5348,   87,   76,   26,   83,   56,  169,   17],
       [  50,   40,  134, 5300,    2,  267,   37,   64,  140,   97],
       [  25,   26,   36,    7, 5356,    9,   54,   32,   83,  214],
       [  68,   37,   34,  179,   74, 4617,  106,   30,  171,  105],
       [  35,   21,   42,    2,   39,   98, 5630,    6,   44,    1],
       [  27,   18,   66,   27,   52,   10,    7, 5793,   17,  248],
       [  58,  150,   68,  140,   16,  156,   51,   29, 5050,  133],
       [  43,   29,   24,   84,  158,   36,    3,  194,   83, 5295]],
      dtype=int64)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是一堆数字，使用Matplotlib的&lt;code&gt;matshow()&lt;/code&gt;函数，将混淆矩阵以图像的方式呈现，将会更加方便。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;plt.matshow(conf_mx, cmap = plt.cm.gray)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd878de76ae.png&quot; alt=&quot;output_80_0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，几乎所有的图片都在对角线上，这意味着分类几乎全部正确。现我们只看看其误差的图像&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;row_sums = conf_mx.sum(axis=1, keepdims=True)
norm_conf_mx = conf_mx / row_sums

np.fill_diagonal(norm_conf_mx, 0)
plt.matshow(norm_conf_mx, cmap = plt.cm.gray)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd878de8eb8.png&quot; alt=&quot;output_82_0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在可以清楚看出分类器的各类误差，其中行代表实际类别，列代表预测的类别。第8、9列很亮，这说明很多图片被误分成数字8或者数字9。&lt;/p&gt;
&lt;p&gt;分析混淆矩阵通常可以提供深刻的见解去改善分类器。回顾这幅图，看样子应该努力改善分类器在数字8和数字9上的表现，和纠正3/5的混淆。举例子，你可以尝试去收集更多的数据，或者你可以构造新的、有助于分类器的特征（新的分类器的特征，我们可以在数据里面加一个新的列———这相当添加了一个新的属性，比如字数8有两个环，数字6有一个，5没有）。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;cl_a, cl_b = 3, 5
X_aa = X_train[(y_train == cl_a) &amp;amp; (y_train_pred == cl_a)]
X_ab = X_train[(y_train == cl_a) &amp;amp; (y_train_pred == cl_b)]
X_ba = X_train[(y_train == cl_b) &amp;amp; (y_train_pred == cl_a)]
X_bb = X_train[(y_train == cl_b) &amp;amp; (y_train_pred == cl_b)]

plt.figure(figsize=(8,8))
plt.subplot(221); plot_digits(X_aa[:25], images_per_row=5)
plt.subplot(222); plot_digits(X_ab[:25], images_per_row=5)
plt.subplot(223); plot_digits(X_ba[:25], images_per_row=5)
plt.subplot(224); plot_digits(X_bb[:25], images_per_row=5)
# save_fig(&quot;error_analysis_digits_plot&quot;)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd878dea522.png&quot; alt=&quot;output_84_0.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到目前为止，所有的样例都总是被分配到仅一个类（比如我们前面训练的分类，要么输出是1，要么是2，3，...，9，一次只能输出一个类别）。有些情况下，你也许想让你的分类器给一个样例输出多个类别。比如有时候我们想识别某个人脸，想判断它的性别，还有是否为中国人，这就有两个类别了([gender, isChinese])。。这种输出多个二值标签的分类系统被叫做多标签分类系统。&lt;/p&gt;
&lt;p&gt;目前不打算深入脸部识别。我们可以先看一个简单点的例子。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.neighbors import KNeighborsClassifier
y_train_large = (y_train &amp;gt;=7)
y_train_odd = (y_train % 2 == 1)
y_multilabel = np.c_[y_train_large, y_train_odd]

knn_clf = KNeighborsClassifier()
knn_clf.fit(X_train, y_multilabel)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
           metric_params=None, n_jobs=None, n_neighbors=5, p=2,
           weights='uniform')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码创造了一个y_multilabel数组，里面包含两个目标标签。第一个标签指出这个数字是否为大数（即是否为7，8，9），第二个标签指示这个数字是否为奇数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;knn_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[False,  True]])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个预测器预测对，我们输入的数据代表5，5不是一个大数，但是是一个奇数。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# y_train_knn_pred = cross_val_predict(knn_clf, X_train, y_train, cv = 3)
# f1_score(y_train, y_train_knn_pred, average=&quot;macro&quot;)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我们即将讨论最后一种分类任务，被叫做&quot;多输出-多分类&quot;（或者简称多输出分类）。在这里每一个标签可以是多类别的（比如我们前面所举的例子）&lt;/p&gt;
&lt;p&gt;为了说明这点，我们建立一个系统，它可以去除图片当中的噪音。它将一张混有噪音的图片作为输入，期待它输出一张干净的数字图片，用一个像素强度的数组表示，就像 MNIST图片那样。注意到这个分类器的输出是多标签的（一个像素一个标签）和每个标签可以有多个值 （像素强度取值范围从0到255）。所以它是一个多输出分类系统的例子。&lt;/p&gt;
&lt;p&gt;我们从MNIST的图版创建训练集和测试集开始，然后给图片的像素强度添加噪声，这里是用NumPy的&lt;code&gt;randint()&lt;/code&gt;函数。目标图像是原始图像。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;noise = np.random.randint(0, 100, (len(X_train), 784))
X_train_mod = X_train + noise
noise = np.random.randint(0, 100, (len(X_test), 784))
X_test_mod = X_test + noise
y_train_mod = X_train
y_test_mod = X_test&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def plot_digit(data):
    image = data.reshape(28, 28)
    plt.imshow(image, cmap = matplotlib.cm.binary,
               interpolation=&quot;nearest&quot;)
    plt.axis(&quot;off&quot;)
    
some_index = 5500

plt.subplot(121); plot_digit(X_test_mod[some_index])
plt.subplot(122); plot_digit(y_test_mod[some_index])
# save_fig(&quot;noisy_digit_example_plot&quot;)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd878dec0d4.png&quot; alt=&quot;output_94_0.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;knn_clf.fit(X_train_mod, y_train_mod)
clean_digit = knn_clf.predict([X_test_mod[some_index]])
plot_digit(clean_digit)
# save_fig(&quot;cleaned_digit_example_plot&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd878df2cbe.png&quot; alt=&quot;output_95_0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的图片看起来还行，比较接近原图片，去噪的效果还可以。&lt;/p&gt;
&lt;p&gt;到这里，分类的知识学得差不多了。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 11:52:00 +0000</pubDate>
<dc:creator>EndlessCoding</dc:creator>
<og:description>这是学习《Hands On Machine Learning with Scikit Learn and TensorFlow》的笔记，如果此笔记对该书有侵权内容，请联系我，将其删除。 博客出自：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/endlesscoding/p/9901539.html</dc:identifier>
</item>
<item>
<title>不懂算法的程序员不是好工程师--选择排序 - 大菜</title>
<link>http://www.cnblogs.com/zhanlang/p/9901764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanlang/p/9901764.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;“大菜”：时刻提醒自己，技术之路修远兮，予以自勉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1541235424990&amp;amp;di=391c9d3291d6da88d0fcbd3105cef7e5&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fi3.hexun.com%2F2017-09-20%2F190942492.jpg&quot; width=&quot;100%&quot; hegiht=&quot;20%&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法主要衡量标准&quot;&gt;算法主要衡量标准&lt;/h2&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;h5 id=&quot;时间复杂度运行时间&quot;&gt;时间复杂度（运行时间）&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;在算法时间复杂度维度，我们主要对比较和交换的次数做对比，其他不交换元素的算法，主要会以访问数组的次数的维度做对比。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实有很多同学对于算法的时间复杂度有点模糊，分不清什么所谓的 O(n),O(nlogn),O(logn)...等，也许下图对一些人有一些更直观的认识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/i/608996/201408/141025088894028.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;h5 id=&quot;空间复杂度额外的内存使用&quot;&gt;空间复杂度（额外的内存使用）&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;排序算法的额外内存开销和运行时间同等重要。 就算一个算法时间复杂度比较优秀，空间复杂度非常差，使用的额外内存非常大，菜菜认为它也算不上一个优秀的算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;h5 id=&quot;结果的正确性&quot;&gt;结果的正确性&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这个指标是菜菜自己加上的，我始终认为一个优秀的算法最终得到的结果必须是正确的。就算一个算法拥有非常优秀的时间和空间复杂度，但是结果不正确，又有什么意义呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;在起始位置右侧（或左侧）找出最小的那个元素，然后和起始位置的元素交换&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;选择排序是一个不稳定的排序算法&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;具体步骤如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;在一个数据列表中找到最小的那个元素，将它和列表的第一个元素交换位置。&lt;/li&gt;
&lt;li&gt;在第二个元素位置开始再次寻找最小的那个元素，然后和列表的第二个位置的元素交换。&lt;/li&gt;
&lt;li&gt;在第三个元素位置开始再次寻找最小的那个元素，然后和列表的第三个位置的元素交换&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如此反复，直到开始查找起始位置到达列表末尾。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果查找过程中最小的元素就是起止位置的元素，那么它就和它自己交换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;++&lt;strong&gt;&lt;em&gt;因为这种算法总是在不断的选择剩余元素中最小者，因此得名选择排序&lt;/em&gt;&lt;/strong&gt;++&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1541086017129&amp;amp;di=184f40ef04b1860987dbc48165eca243&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2FJackyTecblog%2F201209%2F201209051514258004.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;复杂度&quot;&gt;复杂度&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;时间复杂度&quot;&gt;时间复杂度&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;比较次数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对于长度为N的列表，选择排序需要大约n² /2次比较.即：O（n²）平方级别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;交换次数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对于长度为N的列表，选择排序需要大约N次交换.即：O(N) 线性级别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;性能和特点&quot;&gt;性能和特点&lt;/h2&gt;
&lt;p&gt;总体来说，选择排序是一种比较简单的排序算法，很容易理解也很好用代码实现，当然他的特点也很明显：&lt;/p&gt;
&lt;h5 id=&quot;运行时间和数据初始状态无关&quot;&gt;运行时间和数据初始状态无关&lt;/h5&gt;
&lt;p&gt;为什么这么说呢？算法进行中为了查找最小的元素而遍历列表并不能为下次遍历带来任何信息，这个特性在大部分情况下是缺点。如果一个数据列表初始状态是有序的或者部分有序的，选择排序仍然需要全部扫描一次和交换。因此和一个完全无序的列表排序所花的时间相差不大。&lt;/p&gt;
&lt;h5 id=&quot;数据移动次数是最少的&quot;&gt;数据移动次数是最少的&lt;/h5&gt;
&lt;p&gt;每次交换只会改变两个列表元素，因此长度为N的列表只会发生N次交换，交换次数和列表的长度是线性关系，其他算法都不具备这个特性。&lt;/p&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;适用场景&lt;/h2&gt;
&lt;p&gt;由于选择排序的对比次数在平方级别，但是移动次数在线性级别，所以当N比较小的时候比较适用。&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;根据以上定义很容易可以得出这样的结论：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们举出一个实例，序列5 8 5 2 9， 这个在执行选择排序的时候，第一遍，肯定会将array[0]=5，交换到2所在的位置，也就是 2 8 5 5 9，那么很显然，之后的排序我们就会发现，array[2]中的5会出现在原先的array[0]之前，所以选择排序不是一个稳定的排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现案例&lt;/p&gt;
&lt;h5 id=&quot;c&quot;&gt;（c#）&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;        static void Main(string[] args)
        {
            List&amp;lt;int&amp;gt; data = new List&amp;lt;int&amp;gt;() ;
            for (int i = 0; i &amp;lt; 10; i++)
            {
                
                data.Add(new Random(Guid.NewGuid().GetHashCode()).Next(1, 100));
            }
            //打印原始数组值
            Console.WriteLine($&quot;原始数据： {string.Join(&quot;,&quot;, data)}&quot;);
            int n = data.Count;
            for (int i = 0; i &amp;lt; n; i++)
            {
                int minIndex = i;
                //查找最小的元素的索引
                for (int j = i+1; j &amp;lt; n; j++)
                {
                    if (data[j] &amp;lt; data[minIndex])
                    {
                        minIndex = j;
                    }
                }
                //交换最小的元素和当前位置的元素，当然这里可以加入一个最小元素是否是当前位置元素的判断来较少交换次数
                int tempItem = data[i];
                data[i] = data[minIndex];
                data[minIndex] = tempItem;

            }
            //打印排序后的数组
            Console.WriteLine($&quot;排序数据： {string.Join(&quot;,&quot;, data)}&quot;);
            Console.Read();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;原始数据：97,85,61,22,62,12,67,22,68,42&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;排序数据：12,22,22,42,61,62,67,68,85,97&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;go&quot;&gt;Go&lt;/h5&gt;
&lt;p&gt;家里没环境，还得FQ，以后再补上吧，望见谅。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;独乐不如众乐&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;老妈刚要收拾收拾卫生...老公就笑着说道：“妈，您大老远过来，哪能让你打扫家务...”然后老公就让我带我妈出去逛逛街，家务他全包了...就这样，我被老妈拉了出去，我生气的对老妈说道：“明明我都看到地毯底下的钱了，为什么不让我拿出来！”老妈淡定的说道：“要嘛，你现在回去把那钱拿出来翻脸！要嘛，现在就跟我逛街去！以后家务也不用做了！你选吧...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1541237550829&amp;amp;di=63c822203bb61954893ef516e504c21d&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fku.90sjimg.com%2Felement_origin_min_pic%2F18%2F01%2F24%2Fb59eca536c68e65a3d3f9008df348da9.jpg&quot; width=&quot;250px&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载请标明出处 ^ ~ ^ 。部分图片来源于网络，如有侵权请及时联系。让我们一起进步吧&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个不止于IT圈内容的微信公众号，欢迎关注，交流更多的IT知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/zhanlang/1295643/o_qrcode_for_gh_4c89835a6125_344.jpg&quot; width=&quot;250px&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 11:25:00 +0000</pubDate>
<dc:creator>大菜</dc:creator>
<og:description>“大菜”：时刻提醒自己，技术之路修远兮，予以自勉。 算法主要衡量标准 时间复杂度（运行时间） 在算法时间复杂度维度，我们主要对比较和交换的次数做对比，其他不交换元素的算法，主要会以访问数组的次数的维度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanlang/p/9901764.html</dc:identifier>
</item>
<item>
<title>Docker深入浅出系列教程——容器管理 - 张飞洪</title>
<link>http://www.cnblogs.com/jackyfee/p/8688791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackyfee/p/8688791.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我是架构师张飞洪，钻进浩瀚代码，十年有余，人不堪其累，吾不改其乐。如果你和我的看法不一样，请关注我的头条号,我们一起奇闻共赏，疑义相析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来来讲解Docker三大组件之一的容器，如果说镜像是静态的只读文件，那么容器就是带有运行时需要的可写文件层。也可以这样理解，镜像是对象的模板——类，容器是类生成的对象，镜像只有一个，对象可以有很多个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1522592947763bf20fa5a2c&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;docker create -it ubuntu:lastest&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该命令创建的容器处于停止状态，可以使用docker start启动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.启动容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker start 容器id&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.创建并启动容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;等价于docker create，再执行docker run&lt;/p&gt;
&lt;p&gt;下面的指令，输出一个hello world后，自动终止。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;docker run ubuntu /bin/echo 'hello'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该指令背后一系列别隐藏操作，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查本地是否存在指定的镜像，不存在就从公有仓库下载；&lt;/li&gt;
&lt;li&gt;利用镜像创建一个容器，并启启动该容器；&lt;/li&gt;
&lt;li&gt;分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层；&lt;/li&gt;
&lt;li&gt;从宿主主机配置的的网桥接口中，桥接一个虚拟接口口到容器中；&lt;/li&gt;
&lt;li&gt;从网桥的地址池配置一个IP地址给容器， 口执行用户指定的应用程序；&lt;/li&gt;
&lt;li&gt;执行完后，容器被自动终止。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面的命令启动一个bash终端，允许用户进行交互：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;docker run-it ubuntu:14.04 /bin/bash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中，-t 选项让docker分配一个伪终端并绑定到容器的标准输入上，-i 则让容器的标准输入保持打开。 更多的命令选项可以通过 man docker - run命令来查看。&lt;/p&gt;
&lt;p&gt;在容器内用ps命令查看进程，可以看到只运行了bash应用，并没有运行其的进程。&lt;/p&gt;
&lt;p&gt;用户可以按ctrl+d或输入exit命令来退出容器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.守护态运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多的时候，需要让docker容器在后台以守护态形式运行。此时通过添加 -d 参数来实现。&lt;/p&gt;
&lt;p&gt;下面的命令会在后台运行容器:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;docker ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1;done&quot;&lt;/p&gt;
&lt;p&gt;ce554267d7a4c34eefc92c5517051dc37b918b588736d0823e4c846596b04d83&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;容器启动后会返回一个唯一的id。&lt;/p&gt;
&lt;p&gt;此时，要获取容器的输出信息，可以用docker logs ce5&lt;/p&gt;

&lt;hr/&gt;
&lt;blockquote&gt;
&lt;p&gt;docker stop ce5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;终止的容器通过 docker start重新启动&lt;/p&gt;
&lt;p&gt;docker restart 会将运行容器先终止，然后重新启动&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;在使用-d参数时，容器启动后会进人后台，用户无法看到容器中的信息，也无法进行操作。&lt;/p&gt;
&lt;p&gt;这个时候如果需要进入容器进行操作,有多种方法,包括使用官方的 attach或exec命令，以及第三方的 nsenter工具等。&lt;/p&gt;
&lt;p&gt;1.attach&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker run -it ubuntu&lt;/p&gt;
&lt;p&gt;docker ps&lt;/p&gt;
&lt;p&gt;docker attach 容器id&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.exec[推荐]&lt;/p&gt;
&lt;p&gt;例如，进人到刚创建的容器中，并启动bash&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;docker exec -it 453698741 /bin/bash&lt;/p&gt;
&lt;p&gt;root @453698741: /#&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，一个 bash终端打开了，在不影响容器内其他应用的前提下，用户户可以很容易与容器进行交互。&lt;/p&gt;
&lt;p&gt;过指定 -it 参数来保持标准输入打开，并且分配一个伪终端。&lt;/p&gt;
&lt;p&gt;该操作是最为推荐的方式！&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;可以使用docker rm命令来删除处于终止或退出状态的容器，但不能删除处于运行状态的容器，&lt;/p&gt;
&lt;p&gt;如果要直接删除一个运行中的容器，可以添加 -f，终止运用后，强行删除。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;某些时候,需要将容器从一个系统迁移到另外一个系统，此日时可以使用docker的导入和导出功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.导出容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export命令，该命令的格式为docker export [-o | output [=&quot;&quot;]] 容器id。其中，可以通过-o选项来指定导出的tar文件名,也可以通过重定向来实现。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;docker export -o demo.tar e12&lt;/p&gt;
&lt;p&gt;docker export r78 &amp;gt; demo2.tar&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2.导入容器&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;docker import demo.tar - test/ubuntu:v1.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该命令和docker load导入镜像十分相似，这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息(即仅保存容器当时的快照状态)而镜像存储文件将保存完整记录，体积也更大。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;容器是直接提供应用服务的组件，也是docker实现快速启停和高效服务性能的基础。在生产环境中，因为容器自身的轻量级特性，笔者推荐使用容器时，在一组容器前引高可靠性机制。&lt;/p&gt;
&lt;p&gt;例如使用Haproxy工具来代理容器访问，这样在容器出现故障时，可以快速切换到功能正常的容器。此外，建议通过指定合适的容器重启策略，来自动重启退出的容器。&lt;/p&gt;

&lt;blockquote readability=&quot;6.695652173913&quot;&gt;
&lt;p&gt;如果对Docker有更深的洞察，欢迎补充和讨论，感谢您的捧场。我是张飞洪，我为博客园的读者写故事。我会给你呈现程序员眼中的世界，请关注我的&lt;a title=&quot;头条号&quot; href=&quot;https://www.toutiao.com/i6539373508986667523/&quot; target=&quot;_blank&quot;&gt;头条号&lt;/a&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/127185/201804/127185-20180401223554446-1090086808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 03 Nov 2018 10:48:00 +0000</pubDate>
<dc:creator>张飞洪</dc:creator>
<og:description>我是架构师张飞洪，钻进浩瀚代码，十年有余，人不堪其累，吾不改其乐。如果你和我的看法不一样，请关注我的头条号,我们一起奇闻共赏，疑义相析。 接下来来讲解Docker三大组件之一的容器，如果说镜像是静态的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackyfee/p/8688791.html</dc:identifier>
</item>
</channel>
</rss>