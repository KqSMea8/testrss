<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JavaScript中的构造函数和工厂函数 - 逆旅1997</title>
<link>http://www.cnblogs.com/liyangfei/p/9763850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liyangfei/p/9763850.html</guid>
<description>&lt;p&gt;JavaScript中的工厂函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; crateHero (name,blood,weapoon) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; o = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             o.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             o.blood =&lt;span&gt; blood;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             o.weapoon =&lt;span&gt; weapoon;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             o.attch = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             console.log(&lt;span&gt;this&lt;/span&gt;.name+&quot;用&quot;+&lt;span&gt;this&lt;/span&gt;.weapoon+&quot;进行了攻击&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; hero = &lt;span&gt;new&lt;/span&gt; crateHero(&quot;Tom&quot;,&quot;10&quot;,&quot;foot&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         hero.attch();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JavaScript中的构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Hero(name,blood,weapon) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.blood =&lt;span&gt; blood;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.weapon =&lt;span&gt; weapon;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.attack = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 console.log(&lt;span&gt;this&lt;/span&gt;.name+&quot;用&quot;+&lt;span&gt;this&lt;/span&gt;.weapon+&quot;进行攻击&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; HeroOne = &lt;span&gt;new&lt;/span&gt; Hero(&quot;刘备&quot;,100,&quot;雌雄双股剑&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; HeroOne.attack();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上两个代码片段其实都是实现相同的功能，表面上看两个的区别只是第一个工厂函数要复杂一些，第二个要简单一些。&lt;span&gt;其实最最重要的一点是工厂函数它没有办法解决对象的识别问题（即怎么知道一个对象的类型），而构造函数就很好的解决了这个问题每一个实例都指向了创建该实例的构造函数.&lt;span&gt;,就像下面的列子：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; console.log(HeroOne &lt;span&gt;instanceof&lt;/span&gt; Hero); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印值为true,而工厂函数只能是object&lt;/p&gt;
&lt;p&gt;&lt;span&gt;☆&lt;/span&gt;其实构造函数可以理解为简化的工厂函数，下面是构造函数的运行分析，不难可出其原理和工厂函数几乎一致：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在内存中创建一个空对象（没有体现出来）&lt;/li&gt;
&lt;li&gt;设置构造函数的this，让this指向刚刚创建的对象&lt;/li&gt;
&lt;li&gt;执行构造函数的代码&lt;/li&gt;
&lt;li&gt;返回对象（没有体现出来）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Ps：个人理解若有错误欢迎指正。&lt;/p&gt;

</description>
<pubDate>Tue, 09 Oct 2018 15:33:00 +0000</pubDate>
<dc:creator>逆旅1997</dc:creator>
<og:description>JavaScript中工厂函数与构造函数的理解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liyangfei/p/9763850.html</dc:identifier>
</item>
<item>
<title>二、Kafka基础实战：消费者和生产者实例 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/9757878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/9757878.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; kafka.consumer.partition;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; kafka.api.FetchRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; kafka.api.FetchRequestBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; kafka.api.PartitionOffsetRequestInfo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; kafka.common.ErrorMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; kafka.common.TopicAndPartition;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; kafka.javaapi.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; kafka.javaapi.consumer.SimpleConsumer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; kafka.message.MessageAndOffset;
 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.ByteBuffer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PartitionConsumerTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
        PartitionConsumerTest example &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PartitionConsumerTest();
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; maxReads =&lt;span&gt; Long.MAX_VALUE;
        String topic &lt;/span&gt;= &quot;jiketest&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(args.length &amp;lt; 1&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;Please assign partition number.&quot;&lt;span&gt;);
        }
        
        List&lt;/span&gt;&amp;lt;String&amp;gt; seeds = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        String hosts&lt;/span&gt;=&quot;10.206.216.13,10.206.212.14,10.206.209.25&quot;&lt;span&gt;;
        String[] hostArr &lt;/span&gt;= hosts.split(&quot;,&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; index = 0;index &amp;lt; hostArr.length;index++&lt;span&gt;){
            seeds.add(hostArr[index].trim());
        }
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; port = 19092&lt;span&gt;;
         
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; partLen = Integer.parseInt(args[0&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; index=0;index &amp;lt; partLen;index++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                example.run(maxReads, topic, index&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;partition&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;, seeds, port);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                System.out.println(&lt;/span&gt;&quot;Oops:&quot; +&lt;span&gt; e);
                 e.printStackTrace();
            }
        }
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; m_replicaBrokers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
     
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PartitionConsumerTest() {
            m_replicaBrokers &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        }
     
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; run(&lt;span&gt;long&lt;/span&gt; a_maxReads, String a_topic, &lt;span&gt;int&lt;/span&gt; a_partition, List&amp;lt;String&amp;gt; a_seedBrokers, &lt;span&gt;int&lt;/span&gt; a_port) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; find the meta data about the topic and partition we are interested in
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            PartitionMetadata metadata =&lt;span&gt; findLeader(a_seedBrokers, a_port, a_topic, a_partition);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (metadata == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                System.out.println(&lt;/span&gt;&quot;Can't find metadata for Topic and Partition. Exiting&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (metadata.leader() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                System.out.println(&lt;/span&gt;&quot;Can't find Leader for Topic and Partition. Exiting&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            String leadBroker &lt;/span&gt;=&lt;span&gt; metadata.leader().host();
            String clientName &lt;/span&gt;= &quot;Client_&quot; + a_topic + &quot;_&quot; +&lt;span&gt; a_partition;
     
            SimpleConsumer consumer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleConsumer(leadBroker, a_port, 100000, 64 * 1024&lt;span&gt;, clientName);
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; readOffset =&lt;span&gt; getLastOffset(consumer,a_topic, a_partition, kafka.api.OffsetRequest.EarliestTime(), clientName);
     
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; numErrors = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (a_maxReads &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (consumer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    consumer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleConsumer(leadBroker, a_port, 100000, 64 * 1024&lt;span&gt;, clientName);
                }
                FetchRequest req &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FetchRequestBuilder()
                        .clientId(clientName)
                        .addFetch(a_topic, a_partition, readOffset, &lt;/span&gt;100000) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Note: this fetchSize of 100000 might need to be increased if large batches are written to Kafka&lt;/span&gt;
&lt;span&gt;                        .build();
                FetchResponse fetchResponse &lt;/span&gt;=&lt;span&gt; consumer.fetch(req);
     
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (fetchResponse.hasError()) {
                    numErrors&lt;/span&gt;++&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Something went wrong!&lt;/span&gt;
                    &lt;span&gt;short&lt;/span&gt; code =&lt;span&gt; fetchResponse.errorCode(a_topic, a_partition);
                    System.out.println(&lt;/span&gt;&quot;Error fetching data from the Broker:&quot; + leadBroker + &quot; Reason: &quot; +&lt;span&gt; code);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numErrors &amp;gt; 5) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (code ==&lt;span&gt; ErrorMapping.OffsetOutOfRangeCode())  {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We asked for an invalid offset. For simple case ask for the last element to reset&lt;/span&gt;
                        readOffset =&lt;span&gt; getLastOffset(consumer,a_topic, a_partition, kafka.api.OffsetRequest.LatestTime(), clientName);
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    consumer.close();
                    consumer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    leadBroker &lt;/span&gt;=&lt;span&gt; findNewLeader(leadBroker, a_topic, a_partition, a_port);
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                numErrors &lt;/span&gt;= 0&lt;span&gt;;
     
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; numRead = 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (MessageAndOffset messageAndOffset : fetchResponse.messageSet(a_topic, a_partition)) {
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; currentOffset =&lt;span&gt; messageAndOffset.offset();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (currentOffset &amp;lt;&lt;span&gt; readOffset) {
                        System.out.println(&lt;/span&gt;&quot;Found an old offset: &quot; + currentOffset + &quot; Expecting: &quot; +&lt;span&gt; readOffset);
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    readOffset &lt;/span&gt;=&lt;span&gt; messageAndOffset.nextOffset();
                    ByteBuffer payload &lt;/span&gt;=&lt;span&gt; messageAndOffset.message().payload();
     
                    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[payload.limit()];
                    payload.get(bytes);
                    System.out.println(String.valueOf(messageAndOffset.offset()) &lt;/span&gt;+ &quot;: &quot; + &lt;span&gt;new&lt;/span&gt; String(bytes, &quot;UTF-8&quot;&lt;span&gt;));
                    numRead&lt;/span&gt;++&lt;span&gt;;
                    a_maxReads&lt;/span&gt;--&lt;span&gt;;
                }
     
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numRead == 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ie) {
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (consumer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) consumer.close();
        }
     
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; getLastOffset(SimpleConsumer consumer, String topic, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; partition,
                                         &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; whichTime, String clientName) {
            TopicAndPartition topicAndPartition &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TopicAndPartition(topic, partition);
            Map&lt;/span&gt;&amp;lt;TopicAndPartition, PartitionOffsetRequestInfo&amp;gt; requestInfo = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;TopicAndPartition, PartitionOffsetRequestInfo&amp;gt;&lt;span&gt;();
            requestInfo.put(topicAndPartition, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PartitionOffsetRequestInfo(whichTime, 1&lt;span&gt;));
            kafka.javaapi.OffsetRequest request &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; kafka.javaapi.OffsetRequest(
                    requestInfo, kafka.api.OffsetRequest.CurrentVersion(), clientName);
            OffsetResponse response &lt;/span&gt;=&lt;span&gt; consumer.getOffsetsBefore(request);
     
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (response.hasError()) {
                System.out.println(&lt;/span&gt;&quot;Error fetching data Offset Data the Broker. Reason: &quot; +&lt;span&gt; response.errorCode(topic, partition) );
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;[] offsets =&lt;span&gt; response.offsets(topic, partition);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; offsets[0&lt;span&gt;];
        }
     
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String findNewLeader(String a_oldLeader, String a_topic, &lt;span&gt;int&lt;/span&gt; a_partition, &lt;span&gt;int&lt;/span&gt; a_port) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; goToSleep = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                PartitionMetadata metadata &lt;/span&gt;=&lt;span&gt; findLeader(m_replicaBrokers, a_port, a_topic, a_partition);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (metadata == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    goToSleep &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (metadata.leader() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    goToSleep &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (a_oldLeader.equalsIgnoreCase(metadata.leader().host()) &amp;amp;&amp;amp; i == 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; first time through if the leader hasn't changed give ZooKeeper a second to recover
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; second time, assume the broker did recover before failover, or it was a non-Broker issue
                    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;                    goToSleep = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; metadata.leader().host();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (goToSleep) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ie) {
                    }
                }
            }
            System.out.println(&lt;/span&gt;&quot;Unable to find new leader after Broker failure. Exiting&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;Unable to find new leader after Broker failure. Exiting&quot;&lt;span&gt;);
        }
     
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; PartitionMetadata findLeader(List&amp;lt;String&amp;gt; a_seedBrokers, &lt;span&gt;int&lt;/span&gt; a_port, String a_topic, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a_partition) {
            PartitionMetadata returnMetaData &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            loop:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String seed : a_seedBrokers) {
                SimpleConsumer consumer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    consumer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleConsumer(seed, a_port, 100000, 64 * 1024, &quot;leaderLookup&quot;&lt;span&gt;);
                    List&lt;/span&gt;&amp;lt;String&amp;gt; topics =&lt;span&gt; Collections.singletonList(a_topic);
                    TopicMetadataRequest req &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TopicMetadataRequest(topics);
                    kafka.javaapi.TopicMetadataResponse resp &lt;/span&gt;=&lt;span&gt; consumer.send(req);
     
                    List&lt;/span&gt;&amp;lt;TopicMetadata&amp;gt; metaData =&lt;span&gt; resp.topicsMetadata();
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TopicMetadata item : metaData) {
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (PartitionMetadata part : item.partitionsMetadata()) {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (part.partitionId() ==&lt;span&gt; a_partition) {
                                returnMetaData &lt;/span&gt;=&lt;span&gt; part;
                                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt; loop;
                            }
                        }
                    }
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    System.out.println(&lt;/span&gt;&quot;Error communicating with Broker [&quot; + seed + &quot;] to find Leader for [&quot; +&lt;span&gt; a_topic
                            &lt;/span&gt;+ &quot;, &quot; + a_partition + &quot;] Reason: &quot; +&lt;span&gt; e);
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (consumer != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) consumer.close();
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (returnMetaData != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                m_replicaBrokers.clear();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (kafka.cluster.Broker replica : returnMetaData.replicas()) {
                    m_replicaBrokers.add(replica.host());
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnMetaData;
        }
}&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 09 Oct 2018 15:17:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<og:description>一、Kafka消费者编程模型 1.分区消费模型 分区消费伪代码描述 main() 获取分区的size for index =0 to size create thread(or process) co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/9757878.html</dc:identifier>
</item>
<item>
<title>java序列化与反序列化总结 - 王屋山下的传说</title>
<link>http://www.cnblogs.com/v-lcc/p/9763759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/v-lcc/p/9763759.html</guid>
<description>&lt;p&gt;很多商业项目用到数据库、内存映射文件和普通文件来完成项目中的序列化处理的需求，但是这些方法很少会依靠于Java序列化。本文也不是用来解释序列化的，而是一起来看看面试中有关序列化的问题，这些问题你很有可能不了解。“Java序列化指的是将对象转换程字节格式并将对象状态保存在文件中，通常是.ser扩展名的文件。然后可以通过.ser文件重新创建Java对象，这个过程为返序列化”&lt;/p&gt;
&lt;p&gt;Java序列化的API中提供了开发人员进行序列化对象的机制，通过Serializable和Externalizable接口。&lt;/p&gt;
&lt;p&gt;一起看看这些问题：&lt;br/&gt;&lt;strong&gt;1）Java中的Serializable接口和Externalizable接口有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个是面试中关于Java序列化问的最多的问题。我的回答是，Externalizable接口提供了两个方法writeExternal()和readExternal()。这两个方法给我们提供了灵活处理Java序列化的方法，通过实现这个接口中的两个方法进行对象序列化可以替代Java中默认的序列化方法。正确的实现Externalizable接口可以大幅度的提高应用程序的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）Serializable接口中有借个方法？如果没有方法的话，那么这么设计Serializable接口的目的是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Serializable接口在java.lang包中，是Java序列化机制的核心组成部分。它里面没有包含任何方法，我们称这样的接口为标识接口。如果你的类实现了Serializable接口，这意味着你的类被打上了“可以进行序列化”的标签，并且也给了编译器指示，可以使用序列化机制对这个对象进行序列化处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）什么是serialVersionUID？如果你没有定义serialVersionUID意味着什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SerialVersionUID应该是你的类中的一个public static final类型的常量，如果你的类中没有定义的话，那么编译器将抛出警告。如果你的类中没有制定&lt;strong&gt;serialVersionUID，&lt;/strong&gt;那么Java编译器会根据类的成员变量和一定的算法生成用来表达对象的&lt;strong&gt;serialVersionUID&lt;/strong&gt; ，通常是用来表示类的哈希值（hash code）。结论是，如果你的类没有实现SerialVersionUID，那么如果你的类中如果加入或者改变成员变量，那么已经序列化的对象将无法反序列化。这是以为，类的成员变量的改变意味这编译器生成的SerialVersionUID的值不同。Java序列化过程是通过正确SerialVersionUID来对已经序列化的对象进行状态恢复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）当对象进行序列化的时候，如果你不希望你的成员变量进行序列化，你怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个问题也会这么问，如何使用暂态类型的成员变量？暂态和静态成员变量是否会被序列化等等。如果你不希望你的对象中的成员变量的状态得以保存，你可以根据需求选择transient或者static类型的变量，这样的变量不参与Java序列化处理的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5）如果一个类中的成员变量是其它符合类型的Java类，而这个类没有实现Serializable接口，那么当对象序列化的时候会怎样？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的一个对象进行序列化，而这个对象中包含另外一个引用类型的成员编程，而这个引用的类没有实现Serializable接口，那么当对象进行序列化的时候会抛出“NotSerializableException“的运行时异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6）如果一个类是可序列化的，而他的超类没有，那么当进行反序列化的时候，那些从超类继承的实例变量的值是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java&lt;/strong&gt;中的序列化处理实例变量只会在所有实现了Serializable接口的继承支路上展开。所以当一个类进行反序列化处理的时候，超类没有实现Serializable接口，那么从超类继承的实例变量会通过为实现序列化接口的超类的构造函数进行初始化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7) Can you Customize Serialization process or can you override default Serialization process in Java?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7）你能够自定义序列化处理的代码吗或者你能重载Java中默认的序列化方法吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案是肯定的，可以。我们都知道可以通过ObjectOutputStream中的writeObject()方法写入序列化对象，通过ObjectInputStream中的readObject()读入反序列化的对象。这些都是Java虚拟机提供给你的两个方法。如果你在你的类中定义了这两个方法，那么JVM就会用你的方法代替原有默认的序列化机制的方法。你可以通过这样的方式类自定义序列化和反序列化的行为。需要注意的一点是，最好将这两个方法定义为private，以防止他们被继承、重写和重载。也只有JVM可以访问到你的类中所有的私有方法，你不用担心方法私有不会被调用到，Java序列化过程会正常工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8）假设一个新的类的超类实现了Serializable接口，那么如何让这个新的子类不被序列化？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个超类已经序列化了，那么无法通过是否实现什么接口的方式再避免序列化的过程了，但是也还有一种方式可以使用。那就是需要你在你的类中重新实现writeObject()和readObject()方法，并在方法实现中通过抛出NotSerializableException。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9）在Java进行序列化和反序列化处理的时候，哪些方法被使用了？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个是面试中常见的问题，主要用来考察你是否对readObject()、writeObject()、readExternal()和writeExternal()方法的使用熟悉。Java序列化是通过java.io.ObjectOutputStream这个类来完成的。这个类是一个过滤器流，这个类完成对底层字节流的包装来进行序列化处理。我们通过ObjectOutputStream.writeObject(obj)进行序列化，通过ObjectInputStream.readObject()进行反序列化。对writeObject()方法的调用会触发Java中的序列化机制。readObject()方法用来将已经持久化的字节数据反向创建Java对象，该方法返回Object类型，需要强制转换成你需要的正确类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10) Suppose you have a class which you serialized it and stored in persistence and later modified that class to add a new field. What will happen if you deserialize the object already serialized?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10）假设你有一个类并且已经将这个类的某一个对象序列化存储了，那么如果你在这个类中加入了新的成员变量，那么在反序列化刚才那个已经存在的对象的时候会怎么样？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个取决于这个类是否有&lt;strong&gt;serialVersionUID&lt;/strong&gt;成员。通过上面的，我们已经知道如果你的类没有提供serialVersionUID，那么编译器会自动生成，而这个serialVersionUID就是对象的hash code值。那么如果加入新的成员变量，重新生成的serialVersionUID将和之前的不同，那么在进行反序列化的时候就会产生java.io.InvalidClassException的异常。这就是为什么要建议为你的代码加入serialVersionUID的原因所在了。&lt;/p&gt;


</description>
<pubDate>Tue, 09 Oct 2018 15:07:00 +0000</pubDate>
<dc:creator>王屋山下的传说</dc:creator>
<og:description>很多商业项目用到数据库、内存映射文件和普通文件来完成项目中的序列化处理的需求，但是这些方法很少会依靠于Java序列化。本文也不是用来解释序列化的，而是一起来看看面试中有关序列化的问题，这些问题你很有可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/v-lcc/p/9763759.html</dc:identifier>
</item>
<item>
<title>OAuth2.0 原理简介 - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9763121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9763121.html</guid>
<description>&lt;h2&gt;写在前面：&lt;/h2&gt;
&lt;p&gt;    在正式介绍OAuth2.0之前我们先来看一个场景：&lt;strong&gt;小李&lt;/strong&gt;是一个文艺小青年， 经常喜欢出去旅游并且把自己旅行中的美景照片分享到各大社交网站上，比如朋友圈，&lt;strong&gt;新浪微博&lt;/strong&gt;。小李马上要向女朋友求婚了，他想把这三年来和自己女朋友出去旅游的照片打印出来做成照片墙，好在求婚的时候讲女友感动的一塌糊涂，然后你懂得...，那么问题来了，按照小李带女朋友一个月出去玩一次，每次分享30张照片，三年就是30 * 12 * 3 = 1080 张，小李现在想把这1080张照片全部打印出来他首先得找个提供打印照片服务的公司（&lt;strong&gt;美图快印&lt;/strong&gt;），然后把需要打印的照片给到服务公司然后才能打印。怎么把这些照片给到美图快印呢，一般来说有下面两种方式：&lt;/p&gt;
&lt;p&gt;1.小李到自己的微博相册中吭哧吭哧下载他需要打印的所有照片，然后装到U盘里或者转储到网盘里，再给到美图快印（那可是1080张照片啊，纯手工操作，好累啊）&lt;/p&gt;
&lt;p&gt;2.小李到美图快印告诉工作人员自己的账户名和密码，并告诉他那些需要打印，那些不需要打印，然后小李还会担心：自己和女友的亲密照被工作人员看到了怎么办（更可怕的是某一天自己会不会出现在某论坛上成为网红）？万一他记住了我的密码然后悄悄的登陆上去把我的密码改了怎么办？。。。。&lt;/p&gt;
&lt;p&gt;小李觉得有点头疼了，有没有什么方法客户既不告诉工作人员自己的账号和密码又能够方便快捷的把照片给到美图快印呢？&lt;/p&gt;
&lt;p&gt;这就要说到我们今天的正题了，用OAuth就可以轻松的解决此类特定范围的授权问题。&lt;/p&gt;
&lt;h2&gt;OAuth2.0简介：　　&lt;/h2&gt;
&lt;p&gt;    &lt;strong&gt;OAuth2.0 是一个开放的工业标准的授权协议，它允许用户授权让第三方应用直接访问用户在某一个服务中的特定资源，但是不提供给第三方账号及密码信息。完整定义请移步官网：&lt;a href=&quot;https://oauth.net/2/&quot; target=&quot;_blank&quot;&gt;https://oauth.net/2/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;OAuth2.0的基本概念&lt;/h2&gt;
&lt;p&gt;    在了解OAuth2.0之前我们有必要先介绍一下下面几个基本的概念：&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot; data-v-4c8ee738=&quot;&quot;&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-0&quot;&gt;1. 资源所有者（Resource Owner）：一个能够访问受保护资源的实体。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-1&quot;&gt;当资源所有者是一个人时，它被称为终端用户。（小李）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot; data-v-4c8ee738=&quot;&quot;&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;1-0&quot;&gt;2. 资源服务器（Resource Server）：托管受保护资源的服务器，能够使用访问令牌接受和响应受保护的资源请求。（新浪微博）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot; data-v-4c8ee738=&quot;&quot;&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;2-0&quot;&gt;3. 客户端（Client）：代表资源所有者和其授权的应用程序来保护资源请求。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;2-1&quot;&gt;术语客户端并不意味着任何特定的实现特征（例如，应用程序是否在服务器、桌面或其他设备上执行）（美图快印）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot; data-v-4c8ee738=&quot;&quot;&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;3-0&quot;&gt;4. 授权服务器（Authorization Server）：在成功验证资源所有者并获得授权之后，服务器向客户端发出访问令牌。（授权服务器是用来管理Resource Owner，Resource Server，Client的中间人）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Authorization Server和Resource Server可以使独立的服务提供商，也可以是在一起的，比如上面例子中新浪微博既作授权服务器也用来存储用户的图片资源，OAuth2解决的问题是：通过Authorization Server可以提供一个访问的凭据（token）给client（美图快印的工作人员），使得client可以在不知道Resource Owner以及Resource Server的用户名和密码的情况下访问到Resource Owner受保护的资源，它是一个完美的中间人。　　&lt;/p&gt;
&lt;h2&gt; OAuth2.0详解&lt;/h2&gt;
&lt;p&gt;通常 Resource server本身就提供Authorization server服务，它主要提供两类接口：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;授权服务接口：接受Client的授权请求，并引导用户到Resource server完成登陆授权的过程。&lt;/li&gt;
&lt;li&gt;获取访问令牌的接口：使用授权接口提供的许可凭据来颁发Resource owner的访问令牌给Client，或由Client更新过期的访问令牌。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;除此之外还需要提供一个第三方应用程序注册管理的服务。通常情况下会为注册完成的第三方应用程序分配两个成对出现的重要参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;client_id：第三方应用程序的一个标识id，这个信息通常是公开的信息，用来区分哪一个第三方应用程序。&lt;/li&gt;
&lt;li&gt;client_secret：第三方应用程序的私钥信息，这个信息是私密的信息，不允许在OAuth2流程中传递的，用于安全方面的检测和加密。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Client在取得client_id和client_secret之后再向Authorization Server发起授权请求，并获取AccessToken，然后携带Token来访问和消费受保护的资源。美图快印要想直接获取小李新浪微博相册中的照片资源就需要先引导小李到新浪的登陆界面，然后完成授权登陆，然后再向授权服务器发起授权请求，然后获取到新浪微博办法给他的token，再携带者token才能访问到微博的相册。&lt;/p&gt;
&lt;p&gt;下面我们来看一下OAuth2.0的详细授权过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201810/1413706-20181009223131701-1576956298.jpg&quot; alt=&quot;&quot; width=&quot;892&quot; height=&quot;678&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到在上述的授权过程中最关键的部分是获取token的那一步，这也是OAuth2.0的核心。有了这个token我们就可以访问到resource server上的资源，ABCD这几步都是为了获取这个token。&lt;/p&gt;
&lt;p&gt;那么这个token到底包含了哪些信息呢？我们来从头分析一下，我们需要实现的是：让美图快印能够在&lt;strong&gt;不用小李用户名和密码&lt;/strong&gt;的前提下&lt;strong&gt;访问到&lt;/strong&gt;小李&lt;strong&gt;新浪微博账户&lt;/strong&gt;相册中的&lt;strong&gt;特定图片。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意上面加粗的部分，要实现这样的需求我们需要从token中解析出来下面3类信息：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端标识，表明是谁在请求访问资源（美图快印）；&lt;/li&gt;
&lt;li&gt;用户标识，得到了谁的许可（小李）；&lt;/li&gt;
&lt;li&gt;客户端能访问资源所有者的哪些资源以及其相应的权限。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;有了上面的这些信息，那么资源服务器（Resouce Server）就可以区分出来是哪个第三方应用（Client）要访问哪个用户（Resource Owner）的哪些资源（以及有没有权限）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上面的流程中出现了授权许可（Authorization Grant）这个概念，那到底它是什么意思呢？&lt;/p&gt;
&lt;p&gt;书面解释是：&lt;strong&gt;&lt;span&gt;授权许可是一个代表资源所有者授权（访问受保护资源）的凭据，客户端用它来获取访问令牌。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这个解释比较抽象，那么我们来翻译一下就是：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;授权许可是小李授予美图快印获得新浪微博相册的访问令牌的一个凭据。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么我们该如何获得这个凭据呐，OAuth2定义了四种许可类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Authorization Code：授权码；&lt;/li&gt;
&lt;li&gt;Implicit：隐式许可；&lt;/li&gt;
&lt;li&gt;Resource Owner Password Credentials：资源所有者密码凭据；&lt;/li&gt;
&lt;li&gt;Client Credentials ：客户端凭据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体每一种许可类型到底怎么实现我们将放到后面详细讨论，本文不做详细解释。&lt;/p&gt;
&lt;h2&gt;写到最后：&lt;/h2&gt;
&lt;p&gt;   总结：OAuth2.0是一套工业级的标准授权协议，可以很方便的解决第三方服务的授权而不需要资源所有者直接提供身份信息，它大大降低了我们在实现认证和授权时的复杂度。目前基于OAuth2.0实现的框架有很多，基于.NET Core实现最好的是&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4&quot; target=&quot;_blank&quot;&gt;IdentityServer4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 在后续文章中我们将一起探讨IdentityServer4在.NET Core中的使用，欢迎持续关注。&lt;/p&gt;
&lt;p&gt; 如果你觉得本文写得不错，麻烦给个赞呗~~~&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://oauth.net/2/&quot; target=&quot;_blank&quot;&gt;https://oauth.net/2/&lt;/a&gt;     &lt;/p&gt;

</description>
<pubDate>Tue, 09 Oct 2018 14:57:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<og:description>写在前面： 在正式介绍OAuth2.0之前我们先来看一个场景：小李是一个文艺小青年， 经常喜欢出去旅游并且把自己旅行中的美景照片分享到各大社交网站上，比如朋友圈，新浪微博。小李马上要向女朋友求婚了，他</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9763121.html</dc:identifier>
</item>
<item>
<title>好代码是管出来的——使用Jenkins搭建CI服务器 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/9763268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/9763268.html</guid>
<description>&lt;p&gt;　　Jenkins是一个开源的跨平台的CI工具，它可以部署在Windows、Linux等平台上，并且Jenkins提供了非常丰富的插件来帮助完成编译、测试、部署等工作。&lt;br/&gt;　　本文将介绍在Windows平台上使用Jenkins完成.Net Core应用的持续集成环境搭建，其主要内容有：&lt;/p&gt;
&lt;h2&gt;Jenkins下载与安装&lt;/h2&gt;
&lt;p&gt;　　本例使用Jenkins2.136版本进行演示，Jenkins下载地址：&lt;a href=&quot;https://jenkins.io/download/&quot; target=&quot;_blank&quot;&gt;https://jenkins.io/download/&lt;/a&gt;&lt;br/&gt;　　1. 下载Jenkins的Windows安装器：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009215544136-2120701412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 通过安装向导完成Jenkins安装：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009215722595-602119540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Jenkins的默认端口是8080，当安装完成后可以通过该端口访问Jenkins：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009220211608-711650717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 根据Jenkins的配置向导完成相应配置，并进入Jenkins：&lt;br/&gt;　　选择常用插件，这些插件包含了Git、SVN等常用插件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009220245728-436976589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建用户：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009220306667-2080493106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　进入Jenkins：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009220338136-344151466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;创建一个.Net Core编译任务&lt;/h2&gt;
&lt;p&gt;　　1. 创建一个新任务：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009221329201-803423783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　填写任务名称选择自由风格项目：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009221748600-1736194713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2. 修改任务配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009221820284-416113606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　代码库：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009221840984-763958874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 添加构建步骤，此处执行dotnet的编译命令：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009221900368-619428940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4. 执行任务，结果输出如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222209777-238784099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;实现自动测试&lt;/h2&gt;
&lt;p&gt;　　1. 添加测试运行步骤：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222239475-2107855291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　dotnet测试命令参考：&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-test?tabs=netcore21&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-test?tabs=netcore21&lt;/a&gt;&lt;br/&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222317608-1843089798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 收集代码覆盖率：&lt;br/&gt;　　之前介绍了使用OpenCover来分析.net core的单元测试代码覆盖率，然后再通过ReportGenerator来生成Html格式的报告，所以首先需要添加代码覆盖率分析以及报告生成的构建步骤：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222610287-1450365014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　OpenCover.Console.exe -target:&quot;dotnet.exe&quot; -targetargs:&quot;test XUnitTestProject/XUnitTestProject.csproj&quot; -output:coverage.xml -filter:&quot;+[*]* -[*Moq]* -[xunit*]*&quot; -oldstyle&lt;br/&gt;　　ReportGenerator.exe &quot;-reports:coverage.xml&quot; &quot;-targetdir:report&quot;&lt;br/&gt;　　&lt;span&gt;注：在持续集成工具中使用OpenCover可能会无法生成代码覆盖信息，所以需要对OpenCover.Profiler.dll文件进行注册，注册代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222647391-812667253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　OpenCover.Profiler.dll文件位于OpenCover的安装目录下，更多详情查考OpenCover安装目录下的Usage.rtf文档。&lt;/p&gt;
&lt;p&gt;　　如果要将生成的Html在Jenkins上显示，那么必须添加一个HTML Publisher的插件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222718871-478016919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后在构建后操作中添加HTML发布操作：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222735867-1348736940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　需要填写HTML的目录和报告起始页面。&lt;br/&gt;　　完成后保存配置，并执行构建：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222808187-787199496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222821857-1922593200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222848948-628482637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后在工程面板中即可查看代码覆盖报告：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222934100-588097978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　报告：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009222953246-1167054802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;实现自动部署&lt;/h2&gt;
&lt;p&gt;　　当完成编译工作后，需要把编译的结果发布出来，对于一个Windows的控制台应用程序来说，实际上把编辑的执行程序以及相关程序集发布出来即可，而这个程序文件实际上是在项目的bin目录下。&lt;br/&gt;在Jenkins中可以通过Artifact Deployer Plug-in这个插件来完成文件发布功能：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009223122746-1041153733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　插件安装完成后，在项目的构建后操作中添加部署操作，将生成的文件复制到D:\test目录下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009223149461-342459249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　执行构建后将自动把构建结果发布至D:\test目录下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640251/201810/640251-20181009223221422-296949541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本文简单的介绍了如何使用Jenkins及相关插件完成.Net Core程序的自动编译、测试和发布功能。无论是前面文章提到的使用各种托管工具还是自己搭建Jenkins其核心步骤都是通过相应工具以执行命令的方式完成的(编译命令、测试命令、代码覆盖率命令、报表生成命令等)。&lt;/p&gt;
&lt;p&gt;　　虽然都是通过相同的工具以及相同的命令，但是不同的CI工具使用上还是存在一些区别，并且还存在大量的手动配置，有没有一种方法来简化并且重用CI/CD流程呢？敬请期待后续内容(*^_^*)&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 好代码是管出来的——使用Jenkins搭建CI服务器&quot; href=&quot;https://www.cnblogs.com/selimsong/p/9763268.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/selimsong/p/9763268.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a id=&quot;post_title_link_8675028&quot; href=&quot;https://www.cnblogs.com/selimsong/p/8675028.html&quot;&gt;好代码是管出来的——浅谈.Net Core的代码管理方法与落地（更新中...）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Oct 2018 14:42:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<og:description>Jenkins是一个开源的跨平台的CI工具，它可以部署在Windows、Linux等平台上，并且Jenkins提供了非常丰富的插件来帮助完成编译、测试、部署等工作。 本文将介绍在Windows平台上使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/9763268.html</dc:identifier>
</item>
<item>
<title>深入学习卷积神经网络（CNN）的原理知识 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/9754072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/9754072.html</guid>
<description>&lt;p&gt;　　网上关于卷积神经网络的相关知识以及数不胜数，所以本文在学习了前人的博客和知乎，在别人博客的基础上整理的知识点，便于自己理解，以后复习也可以常看看，但是如果侵犯到哪位大神的权利，请联系小编，谢谢。好了下面言归正传：&lt;/p&gt;
&lt;p&gt;　　在深度学习领域中，已经经过验证的成熟算法，目前主要有深度卷积网络（DNN）和递归网络（RNN），在图像识别，视频识别，语音识别领域取得了巨大的成功，正是由于这些成功，能促成了当前深度学习的大热。与此相对应的，在深度学习研究领域，最热门的是AutoEncoder、RBM、DBN等产生式网络架构，但是这些研究领域，虽然论文比较多，但是重量级应用还没有出现，是否能取得成功还具有不确定性。但是有一些比较初步的迹象表明，这些研究领域还是非常值得期待的。比如AutoEncoder在图像、视频搜索领域的应用，RBM对非结构化数据的处理方面，DBN网络在结合人工智能领域两大流派连接主义和符号主义，都具有巨大的前景，有理由期待产生重量级成果。我们在后续会对这些网络逐一进行介绍和实现，除了给出重构后的Theano实现代码外，还会逐步补充这些算法在实际应用的中的实例，我们会主要将这些算法应用在创业公司数据中，从几万家创业公司及投融资数据中，希望能挖掘出哪些公司更可能获得投资，特定公司更有可能获得哪家投资机构的投资。&lt;/p&gt;
&lt;p&gt;　　卷积神经网络（CNN），这是深度学习算法应用最成功的领域之一，卷积神经网络包括一维卷积神经网络，二维卷积神经网络以及三维卷积神经网络。一维卷积神经网络主要用于序列类的数据处理，二维卷积神经网络常应用于图像类文本的识别，三维卷积神经网络主要应用于医学图像以及视频类数据识别。&lt;/p&gt;
&lt;p&gt;　　下面我的学习分为四部分，首先利用一个形象的例子说明电脑是如何识别图像的，然后在说明什么是神经网络，什么是卷积神经网络，最后介绍常见的几种卷积神经网络。大体的结构就是这样的。&lt;/p&gt;
&lt;h2&gt;一：如何帮助神经网络识别图像？&lt;/h2&gt;
&lt;p&gt;　　人类大脑是一非常强大的机器，每秒内能看（捕捉）多张图，并在意识不到的情况下就完成了对这些图的处理。但机器并非如此。机器处理图像的第一步是理解，理解如何表达一张图像，进而读取图片。&lt;/p&gt;
&lt;p&gt; 　　简单来说，每个图像都是一系列特定排序的图点（像素）。如果你改变像素的顺序或颜色，图像也随之改变。举个例子，存储并读取一张上面写着数字 4 的图像。&lt;/p&gt;
&lt;p&gt; 　　基本上，机器会把图像打碎成像素矩阵，存储每个表示位置像素的颜色码。在下图的表示中，数值 1 是白色，256 是最深的绿色（为了简化，我们示例限制到了一种颜色）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009193804305-1415099295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一旦你以这种格式存储完图片信息，下一步就是让神经网络理解这种排序与模式。（表征像素的数值是以特定的方式排序的）&lt;/p&gt;
&lt;p&gt;　　那么如何帮助神经网络识别图像？&lt;/p&gt;
&lt;p&gt;　　假设我们尝试使用全连接网络识别图像，应该如何做？&lt;/p&gt;
&lt;p&gt;　　全连接网络可以通过平化它，把图像当作一个数组，并把像素值当作预测图像中数值的特征。明确地说，让网络理解理解下面图中发生了什么，非常的艰难。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009194226547-926965819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　即使人类也很难理解上图中表达的含义是数字 4。我们完全丢失了像素的空间排列。&lt;/p&gt;
&lt;p&gt;我们能做什么呢？可以尝试从原图中提取特征，从而保留空间排序。&lt;/p&gt;
&lt;h4&gt;案例一&lt;/h4&gt;
&lt;p&gt;　　这里我们使用一个权重乘以初始像素值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009194412794-370880997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在裸眼识别出这是「4」就变得更简单了。但把它交给全连接网络之前，还需要平整化（flatten) 它，要让我们能够保留图像的空间排列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009194458050-287250904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;案例二&lt;/h4&gt;
&lt;p&gt;　　现在我们可以看到，把图像平整化完全破坏了它的排列。我们需要想出一种方式在没有平整化的情况下把图片馈送给网络，并且还要保留空间排列特征，也就是需要馈送像素值的 2D/3D 排列。&lt;/p&gt;
&lt;p&gt;        我们可以尝试一次采用图像的两个像素值，而非一个。这能给网络很好的洞见，观察邻近像素的特征。既然一次采用两个像素，那也就需要一次采用两个权重值了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009194628837-1816653303.gif&quot; alt=&quot;&quot; width=&quot;661&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　希望你能注意到图像从之前的 4 列数值变成了 3 列。因为我们现在一次移用两个像素（在每次移动中像素被共享），图像变的更小了。虽然图像变小了，我们仍能在很大程度上理解这是「4」。而且，要意识到的一个重点是，我们采用的是两个连贯的水平像素，因此只会考虑水平的排列。&lt;/p&gt;
&lt;p&gt;　　这是我们从图像中提取特征的一种方式。我们可以看到左边和中间部分，但右边部分看起来不那么清楚。主要是因为两个问题：&lt;/p&gt;
&lt;p&gt;　　1. 图片角落左边和右边是权重相乘一次得到的。&lt;/p&gt;
&lt;p&gt;　　2. 左边仍旧保留，因为权重值高；右边因为略低的权重，有些丢失。&lt;/p&gt;

&lt;p&gt;现在我们有两个问题，需要两个解决方案。&lt;/p&gt;
&lt;h4&gt;案例三&lt;/h4&gt;
&lt;p&gt;　　遇到这样的问题是图像左右两角只被权重通过一次，我们需要做的是让网络像考虑其他像素一样考虑角落。我们有一个简单的方法解决这一问题：把零放在权重运动的两边。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009194945634-1642748434.gif&quot; alt=&quot;&quot; width=&quot;635&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　你可以看到通过添加零，来自角落的信息被再训练。图像也变得更大。这可被用于我们不想要缩小图像的情况下。&lt;/p&gt;
&lt;h4&gt;案例四&lt;/h4&gt;
&lt;p&gt;　　这里我们试图解决的问题是右侧角落更小的权重值正在降低像素值，因此使其难以被我们识别。我们所能做的是采取多个权重值并将其结合起来。&lt;/p&gt;
&lt;p&gt;　　(1,0.3) 的权重值给了我们一个输出表格&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009195137325-199762655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　同时表格 (0.1,5) 的权重值也将给我们一个输出表格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009195204087-2074633267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　两张图像的结合版本将会给我们一个清晰的图片。因此，我们所做的是简单地使用多个权重而不是一个，从而再训练图像的更多信息。最终结果将是上述两张图像的一个结合版本。&lt;/p&gt;
&lt;h4&gt;案例五&lt;/h4&gt;
&lt;p&gt;　　我们到现在通过使用权重，试图把水平像素（horizontal pixel）结合起来。但是大多数情况下我们需要在水平和垂直方向上保持空间布局。我们采取 2D 矩阵权重，把像素在水平和垂直方向上结合起来。同样，记住已经有了水平和垂直方向的权重运动，输出会在水平和垂直方向上低一个像素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009195306742-242550034.gif&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;238&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;所以我们做了什么？&lt;/h4&gt;
&lt;p&gt;　　上面我们所做的事是试图通过使用图像的空间的安排从图像中提取特征。为了理解图像，理解像素如何安排对于一个网络极其重要。上面我们所做的也恰恰是一个卷积网络所做的。我们可以采用输入图像，定义权重矩阵，并且输入被卷积以从图像中提取特殊特征而无需损失其有关空间安排的信息。&lt;/p&gt;
&lt;p&gt; 　　这个方法的另一个重大好处是它可以减少图像的参数数量。正如所见，卷积图像相比于原始图像有更少的像素。&lt;/p&gt;
&lt;h2&gt;2 ：什么是神经网络？&lt;/h2&gt;
&lt;p&gt;　　这里的神经网络，也指人工神经网络（Artificial Neural Networks，简称ANNs），是一种模仿生物神经网络行为特征的算法数学模型，由神经元、节点与节点之间的连接（突触）所构成，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009201543865-152729152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　每个神经网络单元抽象出来的数学模型如下，也叫感知器，它接收多个输入（x1，x2，x3...），产生一个输出，这就好比是神经末梢感受各种外部环境的变化（外部刺激），然后产生电信号，以便于转导到神经细胞（又叫神经元）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009201559612-2042841014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　单个的感知器就构成了一个简单的模型，但在现实世界中，实际的决策模型则要复杂得多，往往是由多个感知器组成的多层网络，如下图所示，这也是经典的神经网络模型，由输入层、隐含层、输出层构成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009201617454-953193246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　人工神经网络可以映射任意复杂的非线性关系，具有很强的鲁棒性、记忆能力、自学习等能力，在分类、预测、模式识别等方面有着广泛的应用。&lt;/p&gt;
&lt;h2&gt;3 ：什么是卷积神经网络？&lt;/h2&gt;
&lt;p&gt;　　卷积神经网络是近年发展起来的，并引起广泛重视的一种高效识别方法，20世纪60年代，Hubel和Wiesel在研究猫脑皮层中用于局部敏感和方向选择的神经元时发现其独特的网络结构可以有效地降低反馈神经网络的复杂性，继而提出了卷积神经网络（Convolutional Neural Networks-简称CNN）。现在，CNN已经成为众多科学领域的研究热点之一，特别是在模式分类领域，由于该网络避免了对图像的复杂前期预处理，可以直接输入原始图像，因而得到了更为广泛的应用。 K.Fukushima在1980年提出的新识别机是卷积神经网络的第一个实现网络。随后，更多的科研工作者对该网络进行了改进。其中，具有代表性的研究成果是Alexander和Taylor提出的“改进认知机”，该方法综合了各种改进方法的优点并避免了耗时的误差反向传播。&lt;/p&gt;
&lt;p&gt;　　这听起来像是一个奇怪的生物学和数学的结合，但是这些网络已经成为计算机视觉领域最具影响力的创新之一。2012年是神经网络成长的第一年，Alex Krizhevsky用它们赢得了当年的ImageNet竞赛（基本上是计算机视觉年度奥运会），把分类错误记录从26％降到了15％，这个惊人的提高从那以后，许多公司一直在以服务为核心进行深度学习。Facebook使用自动标记算法的神经网络，谷歌的照片搜索，亚马逊的产品推荐，Pinterest的家庭饲料个性化和Instagram的搜索基础设施。&lt;/p&gt;
&lt;p&gt;　　一般的，CNN的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数。卷积神经网络中的每一个卷积层都紧跟着一个用来求局部平均与二次提取的计算层，这种特有的两次特征提取结构减小了特征分辨率。&lt;/p&gt;
&lt;p&gt; 　　CNN主要用来识别位移、缩放及其他形式扭曲不变性的二维图形，该部分功能主要由池化层实现。由于CNN的特征检测层通过训练数据进行学习，所以在使用CNN时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度。&lt;/p&gt;
&lt;p&gt; 　　说了这么多，接下来将以图像识别为例子，来介绍卷积神经网络的原理。&lt;/p&gt;
&lt;h3&gt;3.1 案例&lt;/h3&gt;
&lt;p&gt;　　假设给定一张图（可能是字母X或者字母O），通过CNN即可识别出是X还是O，如下图所示，那怎么做到的呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202515631-1056461501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2 图像输入&lt;/h3&gt;
&lt;p&gt;　　如果采用经典的神经网络模型，则需要读取整幅图像作为神经网络模型的输入（即全连接的方式），当图像的尺寸越大时，其连接的参数将变得很多，从而导致计算量非常大。&lt;br/&gt;　　而我们人类对外界的认知一般是从局部到全局，先对局部有感知的认识，再逐步对全体有认知，这是人类的认识模式。在图像中的空间联系也是类似，局部范围内的像素之间联系较为紧密，而距离较远的像素则相关性较弱。因而，每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。这种模式就是卷积神经网络中降低参数数目的重要神器：局部感受野。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202559906-1527391226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.3 提取特征&lt;/h3&gt;
&lt;p&gt;　　如果字母X、字母O是固定不变的，那么最简单的方式就是图像之间的像素一一比对就行，但在现实生活中，字体都有着各个形态上的变化（例如手写文字识别），例如平移、缩放、旋转、微变形等等，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202627271-1361985686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们的目标是对于各种形态变化的X和O，都能通过CNN准确地识别出来，这就涉及到应该如何有效地提取特征，作为识别的关键因子。&lt;br/&gt;　　回想前面讲到的“局部感受野”模式，对于CNN来说，它是一小块一小块地来进行比对，在两幅图像中大致相同的位置找到一些粗糙的特征（小块图像）进行匹配，相比起传统的整幅图逐一比对的方式，CNN的这种小块匹配方式能够更好的比较两幅图像之间的相似性。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202646989-200335159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以字母X为例，可以提取出三个重要特征（两个交叉线、一个对角线），如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202702561-93616180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　假如以像素值&quot;1&quot;代表白色，像素值&quot;-1&quot;代表黑色，则字母X的三个重要特征如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202719374-1192154873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么这些特征又是怎么进行匹配计算呢？&lt;/p&gt;
&lt;h3&gt;3.4 卷积（convolution）&lt;/h3&gt;
&lt;p&gt;　　这时就要请出今天的重要嘉宾：卷积。那什么是卷积呢，不急，下面慢慢道来。&lt;br/&gt;当给定一张新图时，CNN并不能准确地知道这些特征到底要匹配原图的哪些部分，所以它会在原图中把每一个可能的位置都进行尝试，相当于把这个feature（特征）变成了一个过滤器。这个用来匹配的过程就被称为卷积操作，这也是卷积神经网络名字的由来。&lt;br/&gt;　　卷积的操作如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202815705-1130979104.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　是不是很像把毛巾沿着对角卷起来，下图形象地说明了为什么叫「卷」积&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202835673-1097098037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在本案例中，要计算一个feature（特征）和其在原图上对应的某一小块的结果，只需将两个小块内对应位置的像素值进行乘法运算，然后将整个小块内乘法运算的结果累加起来，最后再除以小块内像素点总个数即可（注：也可不除以总个数的）。&lt;br/&gt;　　如果两个像素点都是白色（值均为1），那么1*1 = 1，如果均为黑色，那么(-1)*(-1) = 1，也就是说，每一对能够匹配上的像素，其相乘结果为1。类似地，任何不匹配的像素相乘结果为-1。具体过程如下（第一个、第二个……、最后一个像素的匹配结果）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202855998-59013486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202908559-627574450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202915949-1736606974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　根据卷积的计算方式，第一块特征匹配后的卷积计算如下，结果为1&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003238_pAHg_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;285&quot;/&gt; &lt;br/&gt;　　对于其它位置的匹配，也是类似（例如中间部分的匹配）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009202942591-1247559272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　计算之后的卷积如下&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003251_DxUs_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;276&quot;/&gt; &lt;br/&gt;　　以此类推，对三个特征图像不断地重复着上述过程，通过每一个feature（特征）的卷积操作，会得到一个新的二维数组，称之为feature map。其中的值，越接近1表示对应位置和feature的匹配越完整，越是接近-1，表示对应位置和feature的反面匹配越完整，而值接近0的表示对应位置没有任何匹配或者说没有什么关联。如下图所示：&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003257_dZEn_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;415&quot;/&gt; &lt;br/&gt;　　可以看出，当图像尺寸增大时，其内部的加法、乘法和除法操作的次数会增加得很快，每一个filter的大小和filter的数目呈线性增长。由于有这么多因素的影响，很容易使得计算量变得相当庞大。&lt;/p&gt;
&lt;h3&gt;3.5 池化（Pooling）&lt;/h3&gt;
&lt;p&gt;　　为了有效地减少计算量，CNN使用的另一个有效的工具被称为“池化(Pooling)”。池化就是将输入图像进行缩小，减少像素信息，只保留重要信息。&lt;br/&gt;　　池化的操作也很简单，通常情况下，池化区域是2*2大小，然后按一定规则转换成相应的值，例如取这个池化区域内的最大值（max-pooling）、平均值（mean-pooling）等，以这个值作为结果的像素值。&lt;br/&gt;　　下图显示了左上角2*2池化区域的max-pooling结果，取该区域的最大值max(0.77,-0.11,-0.11,1.00)，作为池化后的结果，如下图：&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003312_A4YP_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;269&quot;/&gt; &lt;br/&gt;　　池化区域往左，第二小块取大值max(0.11,0.33,-0.11,0.33)，作为池化后的结果，如下图：&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003318_39Ru_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;269&quot;/&gt; &lt;br/&gt;　　其它区域也是类似，取区域内的最大值作为池化后的结果，最后经过池化后，结果如下：&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003323_Jy2u_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;230&quot;/&gt; &lt;br/&gt;　　对所有的feature map执行同样的操作，结果如下：&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003329_XCiq_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;423&quot;/&gt; &lt;br/&gt;　　最大池化（max-pooling）保留了每一小块内的最大值，也就是相当于保留了这一块最佳的匹配结果（因为值越接近1表示匹配越好）。也就是说，它不会具体关注窗口内到底是哪一个地方匹配了，而只关注是不是有某个地方匹配上了。&lt;br/&gt;　　通过加入池化层，图像缩小了，能很大程度上减少计算量，降低机器负载。&lt;/p&gt;
&lt;h3&gt;3.6 激活函数RelU&lt;strong&gt; (Rectified Linear Units)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　常用的激活函数有sigmoid、tanh、relu等等，前两者sigmoid/tanh比较常见于全连接层，后者ReLU常见于卷积层。&lt;br/&gt;　　回顾一下前面讲的感知机，感知机在接收到各个输入，然后进行求和，再经过激活函数后输出。激活函数的作用是用来加入非线性因素，把卷积层输出结果做非线性映射。&lt;strong&gt;&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003341_H0bQ_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;322&quot;/&gt; &lt;br/&gt;&lt;/strong&gt;　　在卷积神经网络中，激活函数一般使用ReLU(The Rectified Linear Unit，修正线性单元)，它的特点是收敛快，求梯度简单。计算公式也很简单，max(0,T)，即对于输入的负值，输出全为0，对于正值，则原样输出。&lt;br/&gt;　　下面看一下本案例的ReLU激活函数操作过程：&lt;br/&gt;　　第一个值，取max(0,0.77)，结果为0.77，如下图&lt;strong&gt;&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003349_hKBL_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;297&quot;/&gt; &lt;br/&gt;　　&lt;/strong&gt;第二个值，取max(0,-0.11)，结果为0，如下图&lt;strong&gt;&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003354_5cd6_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;297&quot;/&gt; &lt;br/&gt;　&lt;/strong&gt;　以此类推，经过ReLU激活函数后，结果如下：&lt;strong&gt;&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003400_MYqn_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;236&quot;/&gt; &lt;br/&gt;&lt;/strong&gt;　　对所有的feature map执行ReLU激活函数操作，结果如下：&lt;strong&gt;&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003405_TmMY_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;454&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;3.7 深度神经网络&lt;/h3&gt;
&lt;p&gt;　　通过将上面所提到的卷积、激活函数、池化组合在一起，就变成下图：&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003417_g8lB_876354.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;242&quot;/&gt; &lt;br/&gt;　　通过加大网络的深度，增加更多的层，就得到了深度神经网络，如下图：&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003423_SvCC_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;163&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.8 &lt;strong&gt;全连接层(Fully connected layers)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;全连接层在整个卷积神经网络中起到“分类器”的作用，即通过卷积、激活函数、池化等深度网络后，再经过全连接层对结果进行识别分类。&lt;br/&gt;　　首先将经过卷积、激活函数、池化的深度网络后的结果串起来，如下图所示：&lt;strong&gt;&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003434_MygV_876354.png&quot; alt=&quot;&quot; width=&quot;424&quot; height=&quot;416&quot;/&gt; &lt;br/&gt;&lt;/strong&gt;　　由于神经网络是属于监督学习，在模型训练时，根据训练样本对模型进行训练，从而得到全连接层的权重（如预测字母X的所有连接的权重）&lt;strong&gt;&lt;br/&gt; &lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003440_MLD0_876354.png&quot; alt=&quot;&quot; width=&quot;422&quot; height=&quot;261&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;　　在利用该模型进行结果识别时，根据刚才提到的模型训练得出来的权重，以及经过前面的卷积、激活函数、池化等深度网络计算出来的结果，进行加权求和，得到各个结果的预测值，然后取值最大的作为识别的结果（如下图，最后计算出来字母X的识别值为0.92，字母O的识别值为0.51，则结果判定为X）&lt;strong&gt;&lt;br/&gt; &lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003445_oQwf_876354.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;341&quot;/&gt;&lt;br/&gt;　　&lt;/strong&gt;上述这个过程定义的操作为”全连接层“(Fully connected layers)，全连接层也可以有多个，如下图：&lt;strong&gt;&lt;br/&gt; &lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003451_GX0E_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;294&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;3.9 &lt;strong&gt;卷积神经网络（Convolutional Neural Networks）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　将以上所有结果串起来后，就形成了一个“卷积神经网络”（CNN）结构，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003504_HAIT_876354.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后，再回顾总结一下，卷积神经网络主要由两部分组成，一部分是特征提取（卷积、激活函数、池化），另一部分是分类识别（全连接层），下图便是著名的手写文字识别卷积神经网络结构图：&lt;br/&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2018/0210/003512_hpv5_876354.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四：常见的几种卷积神经网络介绍&lt;/h2&gt;
&lt;p&gt;　　目前图像分类中的ResNet, 目标检测领域占统治地位的Faster R-CNN，分割中最牛的Mask-RCNN, UNet和经典的FCN都是以下面几种常见网络为基础。&lt;/p&gt;
&lt;h3&gt; 一：LeNet&lt;/h3&gt;
&lt;h4&gt;1.1  网络背景&lt;/h4&gt;
&lt;p&gt;　　LeNet诞生于1994年，由深度学习三巨头之一的Yan LeCun提出，他也被称为卷积神经网络之父。LeNet主要用来进行手写字符的识别与分类，准确率达到了98%，并在美国的银行中投入了使用，被用于读取北美约10%的支票。LeNet奠定了现代卷积神经网络的基础。&lt;/p&gt;
&lt;h4&gt;1.2  网络结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009200722728-1243890538.png&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图为LeNet结构图，是一个6层网络结构：三个卷积层，两个下采样层和一个全连接层（图中C代表卷积层，S代表下采样层，F代表全连接层）。其中，C5层也可以看成是一个全连接层，因为C5层的卷积核大小和输入图像的大小一致，都是5*5（可参考&lt;a href=&quot;http://noahsnail.com/2017/03/02/2017-3-2-LeNet%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;LeNet详细介绍&lt;/a&gt;）。&lt;/p&gt;
&lt;h4&gt;1.3 网络特点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;每个卷积层包括三部分：卷积、池化和非线性激活函数（sigmoid激活函数）&lt;/li&gt;
&lt;li&gt;使用卷积提取空间特征&lt;/li&gt;
&lt;li&gt;降采样层采用平均池化&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;二：AlexNet&lt;/h3&gt;
&lt;h4&gt;2.1 网络背景&lt;/h4&gt;
&lt;p&gt;　　AlexNet由Hinton的学生Alex Krizhevsky于2012年提出，并在当年取得了Imagenet比赛冠军。AlexNet可以算是LeNet的一种更深更宽的版本，证明了卷积神经网络在复杂模型下的有效性，算是神经网络在低谷期的第一次发声，确立了深度学习，或者说卷积神经网络在计算机视觉中的统治地位。&lt;/p&gt;
&lt;h4&gt;2.2 网络结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009200921424-1587522639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　AlexNet的结构及参数如上图所示，是8层网络结构（忽略激活，池化，LRN，和dropout层）,有5个卷积层和3个全连接层，第一卷积层使用大的卷积核，大小为11*11，步长为4，第二卷积层使用5*5的卷积核大小，步长为1，剩余卷积层都是3*3的大小，步长为1。激活函数使用ReLu（虽然不是他发明，但是他将其发扬光大），池化层使用重叠的最大池化，大小为3*3，步长为2。在全连接层增加了dropout，第一次将其实用化。（参考：&lt;a href=&quot;https://www.jianshu.com/p/58168fec534d&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;AlexNet详细解释&lt;/a&gt;）&lt;/p&gt;
&lt;h4&gt;2.3 网络特点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;使用两块GPU并行加速训练，大大降低了训练时间&lt;/li&gt;
&lt;li&gt;成功使用ReLu作为激活函数，解决了网络较深时的梯度弥散问题&lt;/li&gt;
&lt;li&gt;使用数据增强、dropout和LRN层来防止网络过拟合，增强模型的泛化能力&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;三：VGGNet&lt;/h3&gt;
&lt;h4&gt;3.1 网络背景&lt;/h4&gt;
&lt;p&gt;　　VGGNet是牛津大学计算机视觉组和Google DeepMind公司一起研发的深度卷积神经网络，并取得了2014年Imagenet比赛定位项目第一名和分类项目第二名。该网络主要是泛化性能很好，容易迁移到其他的图像识别项目上，可以下载VGGNet训练好的参数进行很好的初始化权重操作，很多卷积神经网络都是以该网络为基础，比如FCN，UNet，SegNet等。vgg版本很多，常用的是VGG16，VGG19网络。&lt;/p&gt;
&lt;h4&gt;3.2 网络结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009201051038-616079975.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图为VGG16的网络结构，共16层（不包括池化和softmax层），所有的卷积核都使用3*3的大小，池化都使用大小为2*2，步长为2的最大池化，卷积层深度依次为64 -&amp;gt; 128 -&amp;gt; 256 -&amp;gt; 512 -&amp;gt;512。&lt;/p&gt;
&lt;h4&gt;3.3 网络特点&lt;/h4&gt;
&lt;p&gt;网络结构和AlexNet有点儿像，不同的地方在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主要的区别，一个字：深，两个字：更深。把网络层数加到了16-19层（不包括池化和softmax层），而AlexNet是8层结构。&lt;/li&gt;
&lt;li&gt;将卷积层提升到卷积块的概念。卷积块有2~3个卷积层构成，使网络有更大感受野的同时能降低网络参数，同时多次使用ReLu激活函数有更多的线性变换，学习能力更强（详细介绍参考：TensorFlow实战P110页）。&lt;/li&gt;
&lt;li&gt;在训练时和预测时使用Multi-Scale做数据增强。训练时将同一张图片缩放到不同的尺寸，在随机剪裁到224*224的大小，能够增加数据量。预测时将同一张图片缩放到不同尺寸做预测，最后取平均值。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;四：ResNet&lt;/h3&gt;
&lt;h4&gt;4.1 网络背景&lt;/h4&gt;
&lt;p&gt;　　ResNet（残差神经网络）由微软研究院的何凯明等4名华人于2015年提出，成功训练了152层超级深的卷积神经网络，效果非常突出，而且容易结合到其他网络结构中。在五个主要任务轨迹中都获得了第一名的成绩：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ImageNet分类任务：错误率3.57%&lt;/li&gt;
&lt;li&gt;ImageNet检测任务：超过第二名16%&lt;/li&gt;
&lt;li&gt;ImageNet定位任务：超过第二名27%&lt;/li&gt;
&lt;li&gt;COCO检测任务：超过第二名11%&lt;/li&gt;
&lt;li&gt;COCO分割任务：超过第二名12%&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　作为大神级人物，何凯明凭借Mask R-CNN论文获得ICCV2017最佳论文，也是他第三次斩获顶会最佳论文，另外，他参与的另一篇论文：Focal Loss for Dense Object Detection，也被大会评为最佳学生论文。&lt;/p&gt;
&lt;h4&gt;4.2 网络结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009201245842-411894298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图为残差神经网络的基本模块（专业术语叫残差学习单元），输入为x，输出为F(x)+x，F(x)代表网络中数据的一系列乘、加操作，假设神经网络最优的拟合结果输出为H(x)=F(x)+x，那么神经网络最优的F(x)即为H(x)与x的残差，通过拟合残差来提升网络效果。为什么转变为拟合残差就比传统卷积网络要好呢？因为训练的时候至少可以保证残差为0，保证增加残差学习单元不会降低网络性能，假设一个浅层网络达到了饱和的准确率，后面再加上这个残差学习单元，起码误差不会增加。（参考：&lt;a href=&quot;https://www.leiphone.com/news/201608/vhqwt5eWmUsLBcnv.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ResNet详细解释&lt;/a&gt;）&lt;br/&gt;通过不断堆叠这个基本模块，就可以得到最终的ResNet模型，理论上可以无限堆叠而不改变网络的性能。下图为一个34层的ResNet网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201810/1226410-20181009201309180-970405753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;4.3 网络特点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;使得训练超级深的神经网络成为可能，避免了不断加深神经网络，准确率达到饱和的现象（后来将层数增加到1000层）&lt;/li&gt;
&lt;li&gt;输入可以直接连接到输出，使得整个网络只需要学习残差，简化学习目标和难度。&lt;/li&gt;
&lt;li&gt;ResNet是一个推广性非常好的网络结构，容易和其他网络结合&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; 五：几张常见的卷积神经网络论文地址：&lt;/h3&gt;
&lt;p&gt;1. &lt;a href=&quot;http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;LeNet论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;AlexNet论文&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;3. &lt;a href=&quot;https://arxiv.org/abs/1409.1556&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;VGGNet论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;4. &lt;a href=&quot;https://arxiv.org/abs/1512.03385&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ResNet论文&lt;/a&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参考文献：https://www.sumaarts.com/share/620.html&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_34759239/article/details/79034849&lt;/p&gt;
&lt;p&gt;https://my.oschina.net/u/876354/blog/1620906&lt;/p&gt;
&lt;p&gt;https://baike.baidu.com/item/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/17541100?fr=aladdin&lt;/p&gt;

</description>
<pubDate>Tue, 09 Oct 2018 14:32:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<og:description>网上关于卷积神经网络的相关知识以及数不胜数，所以本文在学习了前人的博客和知乎，在别人博客的基础上整理的知识点，便于自己理解，以后复习也可以常看看，但是如果侵犯到哪位大神的权利，请联系小编，谢谢。好了下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/9754072.html</dc:identifier>
</item>
<item>
<title>美化你的博客 | 来看这篇指导教程 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/9763281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/9763281.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220354427-426246674.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好的博客主题不仅美观大方，而且能促进主人书写的愿望，博主也是个喜欢折腾的人，前前后后对自己现在的博客整容过很多次，动过很多次刀，很多人看我博客都说“博主，你的主题666”。其实我很抱歉啊，因为这主题并不是我原创的。我当时也是逛博客园突然发现了该款主题，然后自己就套用了下，研究了下js，最后再进行重新编辑定制了些功能，添加了一些博主自己喜欢的内容，如代码高亮等等。&lt;/p&gt;
&lt;p&gt;博主是名Java开发工程师，也工作了5年左右了，刚刚开始工作的时候，那时候还不是很流行现在的微服务以及前后端分离的项目架构。博主记得第一年面试的时候还被面试官问到Jquery的选择器，Ajax，以及CSS的盒子模型等相关的前端技术。而且第一份工作也是前后端都写，因为java的jsp技术也有写页面的能力，所以公司里面没有前端，只有一个美工(不知道美工属不属于前端，因为之前有人和我争论过，说美工不属于前端)，美工给我们制作下静态页面就可以了，我们再填充静态页面。&lt;br/&gt;说了这么多，其实，我只是想解释下我的JS和CSS只是菜鸟级别的，我只是博客主题的搬运工，我的这篇随笔不是想教各位大神如何定制主题，而是给大家推荐一些好的现存的Code和案例。&lt;/p&gt;

&lt;p&gt;虽然CSDN-自称全球最大的中文IT社区，而且也确实做的比博客园大，因为CSDN的商业化做的更好，但也是因为这样，CSND的博客页面广告覆盖率特别大，不说我们平时写技术的人看着难受，每次阅读起来也很难受，而且主题样式我个人认为及其丑陋。博客园也有广告，但是我们可以定制代码，书写自己的主题。前端技术能力强的Coder完全可以做到博客主题大变身，看起来像是个人博客一样，一点博客园的影子都没有。广告之类的我们也可以自己通过样式代码去掉，可以使得博客界面简介大方，虽然这样可能不好，但是博客园也没有强制拒绝你这样做。&lt;/p&gt;
&lt;p&gt;如何定制？我们可以通过【设置】中定制自己的CSS代码，当然是先要申请，并通过审核的。&lt;br/&gt;我们原始的主题一般都选择的是SimpleMemory主题，因为这款主题纯白简洁。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009222257226-1976855147.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后勾选上【禁用模板默认CSS】，填上自己整理的CSS代码，如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220430318-1348917024.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就是【博客侧边栏公告】，这里面可以定制自己的主页面HTML和一些JS功能，如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220440955-1154218760.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页首Html代码，支持js，可以添加赞赏，返回文章顶部等功能。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220452445-1808631461.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页脚Html代码，支持js，可添加音乐播放器等功能。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220501280-1930168131.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以参考：&lt;a href=&quot;https://www.cnblogs.com/study-everyday/p/6688974.html&quot;&gt;明志健致远&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;程序员写博客，我推荐用Markdown，因为用Markdown写文章就像写代码的感觉一样。博客园大概是2014年将markdown语法引进来的。参考：&lt;a href=&quot;https://www.cnblogs.com/cmt/p/markdown.html&quot;&gt;新功能发布！Markdown写博客！&lt;/a&gt;。Markdown的语法，不同的平台大致一样。博客园稍微有点区别，例如图片的应用，其他编辑器通过@会将描述显示在图片下方，而博客园不支持。博客园的Markdown语法详情可以参考&lt;a href=&quot;https://www.cnblogs.com/zichi/p/4788229.html&quot;&gt;markdown在博客园的使用&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;编辑器的话就不要用博客园自己的了，你写的时候会急死，不多说你亲身体会下就知道了。可以先在其他编辑器上写好，再Copy过去就可以了。前提是你先要设置它的默认编辑器为Markdown，可在【设置】-【选项】中修改，如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220513104-352537436.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里推荐几款Markdown编辑器，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;马克飞象&lt;br/&gt;印象笔记的产品，本人目前在用，有网页版和客户端版，可免费可付费，影响的只是是否你需要同步到云上印象笔记，我喜欢它的原因是因为它的高亮代码是在太漂亮了，而且可以免费导出到本地，类型可以是Markdown，HTML，PDF等格式，关键是并保留高亮的样式。截个图你体验下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220523787-918473243.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;唯一的缺点是我公司禁用这些笔记类工具。大公司都有这样的安全规定。想哭。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Sublime Text3&lt;br/&gt;Sublime Text3不多说了，程序员最熟悉的小伙伴了，轻量、简洁、高效、跨平台的编辑器，只不过用它写markdown之前需要一翻折腾，具体怎么折腾法我就不详细说了，网上的教程很多，也很详细。&lt;/li&gt;
&lt;li&gt;Cmd Markdown&lt;br/&gt;我为什么推荐它？因为它是我们公司的漏网之鱼，嘘，请不要声张，哈哈。博主在公司项目不忙的时候就偷偷的在上面写写文章，联网自动同步，也是可免费可收费的，但是免费的不支持图片。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然还有其他很多各种各样的编辑器，如有道笔记等等，在这里就不一一介绍了，根据个人的使用习惯和爱好选择吧。&lt;/p&gt;

&lt;p&gt;这里推荐两款高亮的CSS，当然这是针对Markdown类文章的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一款Css代码&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.cnblogs-markdown pre {
    white-space: pre!important
}

.cnblogs-markdown .hljs {
    display: block!important;
    overflow-x: auto!important;
    padding: 1em!important;
    background: #282c34!important;
    border: 1px solid #fff!important;
    border-radius: 5px!important;
    font-family: Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace!important;
    font-size: 15px!important
}

.hljs,.hljs-subst,.hljs-tag {
    color: #f8f8f2!important
}

.hljs-emphasis,.hljs-strong {
    color: #a8a8a2!important
}

.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote {
    color: #ae81ff!important
}

.hljs-meta,.hljs-regexp {
    color: #fd971f!important
}

.hljs-built_in,.hljs-builtin-name,.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title {
    color: #a6e22e!important
}

.hljs-strong {
    font-weight: 700
}

.hljs-emphasis {
    font-style: italic!important
}

.hljs-attr,.hljs-name,.hljs-selector-tag,.hljs-symbol {
    color: #f74449!important
}

.hljs-attribute,.hljs-keyword {
    color: #66d9ef!important
}

.hljs-class .hljs-title,.hljs-params {
    color: #f8f8f2!important
}

.hljs-addition,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable {
    color: #e6db74!important
}

.hljs-comment,.hljs-deletion {
    color: #999!important
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：就是博主现在在用的&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220539647-1867673080.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二款Css代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;pre {
    white-space: pre;
    word-wrap: normal
}

.cnblogs-markdown .hljs {
    display: block;
    overflow-x: auto;
    padding: .5em;
    background: #23241f!important;
    color: #FFF;
    white-space: pre;
    word-break: normal
}

.hljs,.hljs-subst,.hljs-tag {
    color: #f8f8f2
}

.hljs-emphasis,.hljs-strong {
    color: #a8a8a2
}

.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp {
    color: #ae81ff
}

.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title {
    color: #a6e22e
}

.hljs-strong {
    font-weight: 700
}

.hljs-emphasis {
    font-style: italic
}

.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag {
    color: #f92672
}

.hljs-attribute,.hljs-symbol {
    color: #66d9ef
}

.hljs-class .hljs-title,.hljs-params {
    color: #f8f8f2
}

.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable {
    color: #e6db74
}

.hljs-comment,.hljs-deletion,.hljs-meta {
    color: #75715e
}

.cnblogs-markdown code,.cnblogs-post-body code {
    display: inline-block;
    padding: 2px 4px;
    font-size: 90%!important;
    color: #c7254e;
    background-color: #f9f2f4!important;
    border-radius: 4px;
    border: none!important
}

.cnblogs-markdown .hljs,.cnblogs-post-body .hljs {
    font-family: &quot;Courier New&quot;,sans-serif!important;
    font-size: 13px!important;
    line-height: 1.5!important;
    padding: 5px!important
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220551296-1912996495.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;随笔如果书写的内容很多，这时候有个文章目录的话，是很方便读者阅读的，而且也能快速了解文章的总体内容。我看到过很多种类型的目录，有的是直接内嵌在文章里面的，这种肯定不好，因为太占空间了，如果标题过多，那么读者开始文章简介还没看到，先阅读了一串又臭又长的目录，瞬间心情就不好了。最好的目录还是悬浮在页面上的，能隐藏能展开。&lt;/p&gt;
&lt;p&gt;这里推荐一款，&lt;a href=&quot;http://www.cnblogs.com/asxinyu/p/Bolg_Category_AddArticleCategory_6.html&quot;&gt;悬浮目录&lt;/a&gt;，大家平时逛百度百科的时候，不知道你们有没有注意到它的目录，和这款很类似。随笔起始的时候默认隐藏，当向下阅读到一定长度之后，目录自动显示出来，也可以点击图标按钮进行收缩，很智能人性化。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181009220604012-1935296251.png&quot;/&gt;&lt;/p&gt;


&lt;p&gt;暂时先添加这么多，后期博主看到了更多的有趣的再在此基础上添加。如果喜欢请&lt;strong&gt;推荐支持&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Tue, 09 Oct 2018 14:06:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>前言 好的博客主题不仅美观大方，而且能促进主人书写的愿望，博主也是个喜欢折腾的人，前前后后对自己现在的博客整容过很多次，动过很多次刀，很多人看我博客都说“博主，你的主题666”。其实我很抱歉啊，因为这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/9763281.html</dc:identifier>
</item>
<item>
<title>改善javascript代码结构 - 清许</title>
<link>http://www.cnblogs.com/qingxuit/p/9763198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingxuit/p/9763198.html</guid>
<description>&lt;p&gt;首先看下常规开发中javascript非结构化组织代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; appInit () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序初始化操作&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; appModule1 () {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块1   &lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; appModule2 () {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块2   &lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; appModule3 () {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块3   &lt;/span&gt;
&lt;span&gt;}

$( document ).ready(appInit )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从技术角度看，这种代码方式并没有任何错误，但是通过下图可以发现这些函数都是建立在全局名称空间下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451247/201810/1451247-20181009201545513-1192641943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若在全局名称空间中创建很多变量很快会导致严重的问题、比如在全局名称空间中定义了名为i、_或$的变量。&lt;/p&gt;
&lt;p&gt;如何改善呢？&lt;/p&gt;
&lt;p&gt;1、使用一个单例创建一个应用程序名称空间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; myApp =&lt;span&gt; {
    init : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序初始化操作&lt;/span&gt;
&lt;span&gt;    },
    appModule1 : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块1&lt;/span&gt;
&lt;span&gt;    },
    appModule2 : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块2&lt;/span&gt;
&lt;span&gt;    },
    appModule3 : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序功能模块3&lt;/span&gt;
&lt;span&gt;    }
}
$( document ).ready(myApp.init)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于上面的新结构，打开chrome查看window下的属性时仅看到单个变量myApp，这中方式极大的降低了变量名冲突的可能性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451247/201810/1451247-20181009213352921-1105912729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一模式允许多个开发人员跨越多个文件，在单个应用程序名称空间之下进行协同开发。从代码结构角度来说，可以将网站的每一部分拆成独立文件。比如本例中的common.js、&lt;/p&gt;
&lt;p&gt;&lt;span&gt;appModule1.js、&lt;span&gt;appModule2.js和&lt;/span&gt;&lt;span&gt;appModule3.js。每个开发人员都有一个自己负责的网站部分和相应的javascript文件，开发人员只需要关注自己的文件，不需要担心会发生冲突。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;common.js

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; myApp =&lt;span&gt; {
    common : {
           init : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化应用程序通用代码&lt;/span&gt;
&lt;span&gt;           }
    }
}

appModule1.js

myApp.appModule1 &lt;/span&gt;=&lt;span&gt; {
     init : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化代码&lt;/span&gt;
&lt;span&gt;     },
     update : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新模块1的代码&lt;/span&gt;
&lt;span&gt;     }，
     render : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;呈现模块1的代码&lt;/span&gt;
&lt;span&gt;     }
}

appModule2.js

myApp.appModule2 &lt;/span&gt;=&lt;span&gt; {
     init : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化代码&lt;/span&gt;
&lt;span&gt;     },
     update : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新模块2的代码&lt;/span&gt;
&lt;span&gt;     }，
     render : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;呈现模块2的代码&lt;/span&gt;
&lt;span&gt;     }
}

appModule3.js

myApp.appModule3 &lt;/span&gt;=&lt;span&gt; {
     init : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化代码&lt;/span&gt;
&lt;span&gt;     },
     update : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新模块3的代码&lt;/span&gt;
&lt;span&gt;     }，
     render : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;呈现模块3的代码&lt;/span&gt;
&lt;span&gt;     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、Module模式&lt;/p&gt;
&lt;p&gt;      模块模式是单例的一种变种，增强了单例模式提供的封装性，并增加了创建私有方法和私有属性的功能&lt;/p&gt;
&lt;p&gt;      模块模式包含三个主要组件：一个与前面例子类似的命名空间、一个立即执行函数和函数返回对象，该返回对象包含公有方法和公有属性，js代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;app的名称空间。传入jquery对象以缩短查找过程&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; myApp = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( $ ){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有变量和方法&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; message = &quot; i am a module &quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; multiplier (x,y) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x *&lt;span&gt; y;
    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回对象包含公有属性和方法&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        init:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化app&lt;/span&gt;
&lt;span&gt;        },
        prop : &lt;/span&gt;'42'&lt;span&gt;,
        getProduct : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问私有方法&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; multiplier(2,3&lt;span&gt;);
        },
        shareMessage : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (arg){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对私有属性进行限制访问&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(arg == &quot;admin&quot;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; message;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;No access&quot;&lt;span&gt;);
            }
        }
        
    }
}(jQuery)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台中测试如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451247/201810/1451247-20181009213813979-23962878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     扩展该模式以增加更多的模块也非常简单。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
myApp.module1 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;($){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有变量和方法&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; config =&lt;span&gt; {
        &lt;/span&gt;&quot;color&quot;:&quot;red&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;title&quot;:&quot;module1&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;width&quot;:&quot;20px&quot;&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        init:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化module1&lt;/span&gt;
&lt;span&gt;        },
        updateConfig : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj){
            config.color &lt;/span&gt;= obj.color ||&lt;span&gt; config.color;
            config.title &lt;/span&gt;= obj.title ||&lt;span&gt; config.title;
            config.width &lt;/span&gt;= obj.width ||&lt;span&gt; config.width;
        },
        render:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; $module1 = $(&quot;#id&quot;&lt;span&gt;);
            $module1.text(config.title)
                    .css({&lt;/span&gt;&quot;width&quot;:config.width,&quot;color&quot;&lt;span&gt;:config.color})
            
        }
    }
    
}(jQuery)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该代码描述了一个module1模块，它包含一个私有配置对象和一个公共方法，该公有方法允许根据一组预定义条件获得对module1配置的访问，类似于java中private和public关键字的使用。在js开发中，并非所以时候都需要使用这种保护访问，但当我们需要实现这样功能时，使用模块模式是非常重要的。&lt;/p&gt;

</description>
<pubDate>Tue, 09 Oct 2018 13:55:00 +0000</pubDate>
<dc:creator>清许</dc:creator>
<og:description>首先看下常规开发中javascript非结构化组织代码 从技术角度看，这种代码方式并没有任何错误，但是通过下图可以发现这些函数都是建立在全局名称空间下 若在全局名称空间中创建很多变量很快会导致严重的问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingxuit/p/9763198.html</dc:identifier>
</item>
<item>
<title>RIP及距离向量算法 - zhxxxx</title>
<link>http://www.cnblogs.com/zhanghx/p/9761882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanghx/p/9761882.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;预备知识&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;网络层提供两种服务：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;虚电路服务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据报服务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;caption&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;虚电路服务与数据报服务的对比&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/caption&gt;
&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;对比的方面&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;虚电路服务&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;数据报服务&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可靠通信由网络保证&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可靠通信由终系统保证&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;连接的建立&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;必须有&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不需要&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;终点地址&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;仅在连接建立阶段使用，每个分组使用短的虚电路号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每个分组都有终点的完整地址&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分组的转发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;属于同一条虚电路的分组均按照同一路由进行转发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每个分组独立选择路由进行转发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当结点出故障&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所有通过出故障的结点的虚电路均不能工作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;出故障的结点可能会丢失分组，一些路由可能发生变化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分组的顺序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;按发送顺序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不按发送顺序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;端到端的差错处理和流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可由网络负责，也可由终系统负责&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;由终系统负责&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;因数据报服务在分组转发时，每个分组独立选择路由进行转发，从而引出&lt;span&gt;路由选择协议&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;路由选择协议的核心是&lt;span&gt;路由算法&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;理想路由算法特点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法必须是&lt;span&gt;正确的和完整的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法在计算上应&lt;span&gt;简单&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法应能适应通信量和网络拓扑结的变化，要有&lt;span&gt;自适应性&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法应具有&lt;span&gt;稳定性&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法应是&lt;span&gt;公平的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法应是&lt;span&gt;最佳的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;路由算法依据自适应性来划分为:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;静态路由选择策略（非自适应路由选择）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;动态路由选择策略（自适应路由选择）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;由于互联网的规模非常大，以及各单位的保密需求，互联网采用&lt;span&gt;分层次的路由选择协议&lt;/span&gt;。为此，将互联网分为许多较小的&lt;span&gt;自治系统（AS）&lt;/span&gt;，AS是在单一技术管理下的一组路由器。一个AS对其他AS表现出的是&lt;span&gt;一个单一的和一致的路由选择策略&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;路由选择协议分类：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一）内部网关协议IGP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　RIP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　OSPF&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自治系统内部的路由选择叫做&lt;span&gt;域内路由选择&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二）外部网关协议EGP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　BGP-4（BGP）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自治系统之间的路由选择叫做&lt;span&gt;域间路由选择&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;中文名：&lt;span&gt;路由信息协议&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;RIP是一种&lt;span&gt;分布式&lt;/span&gt;的&lt;span&gt;基于距离向量的路由选择协议&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;距离的定义：也称“跳数（hop count）”,&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;从一路由器到直接连接的网络的距离定义为 1。从一路由器到非直接连接的路由器的距离定义为所经过的路由器数加 1。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;RIP允许一条路径最多包含 15 个路由器，即“距离”等于 16 时不可达。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;RIP选择一条具有最少路由器的路由（最短路由），哪怕还存在另一条高速但路由器较多的路由。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;特点：每一个路由器都要不断地和其他路由器交换路由信息。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;仅和&lt;span&gt;相邻路由器&lt;/span&gt;交换信息&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;路由器交换的信息是&lt;span&gt;当前本路由器所知道的所有信息，即当前的路由表&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;按固定时间间隔&lt;/span&gt;交换路由信息&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;路由器刚开始工作时，路由表是空的，但经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。以上过程，叫 “&lt;span&gt;收敛&lt;/span&gt;”，收敛是在AS中所有结点都得到正确的路由选择信息的过程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;路由表中最主要的信息：到某个网络的距离（&lt;span&gt;最短距离&lt;/span&gt;），经过的下一跳地址。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为了找出最短距离，由此引出 距离向量算法——&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;距离向量算法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;此算法的基础是&lt;span&gt;Bellman-Ford算法&lt;/span&gt;，这种算法的要点是：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　设 X 是结点 A 到 B 的最短路径上的一个结点。若把路径 A到B 拆成两段路径 A到X 和 X到B，则每段路径 A到X 和 X到B 也都分别是结点 A到X 和结点 X到B 的最短路径。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;对每一个相邻路由器发送过来的RIP报文，进行以下步骤：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）对地址为 X 的相邻路由器发来的RIP报文，先修改此报文的所有项目：把“下一跳”字段中的地址都改为 X ，并把所有的“距离”字段值加 1 　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;假设从位于 X 的相邻路由器发来RIP报文的某一项目是：“Net2，3，Y”，意思是“我经过路由器Y到网络Net2的距离是3”，那么本路由器可推断出“我经过路由器X到网络Net2的距离是3+1=4”，于是将收到的RIP报文的这一项目修改为：“Net2，4，X”，作为下一步和路由表中原有项目进行比较时使用（比较后确定是否更新）&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;每一个项目都有三个关键数据，即：到目的的网络 N ，距离 d ，下一跳路由器 X 。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）对修改后的RIP报文中的每个项目，执行以下步骤：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;if （原来的路由表中没有目的网络N）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　把该项目添加到路由表中　　&lt;span&gt;#&lt;/span&gt;&lt;span data-mce-=&quot;&quot;&gt;本路由表中没有到目的网络Net2的路由，那么路由表中就要加入新的项目“Net2，4，X”  &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在路由表中有目的网络N，查看下一跳路由器地址：elif（下一跳路由器地址是 X）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　把收到的项目替换原路由表中的项目　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;不管原来路由表中项目时“Net2，3，X”还是“Net2，5，X”，都要更新为“Net2，4，X”&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在路由表中有目的网络N，但下一跳路由器不是X，比较距离d与路由表中的距离：elif（收到的项目中的距离 d 小于路由表中的距离）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　更新　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;若路由表中已有项目“Net2，5，P”，就更新为“Net2，4，X”&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;else：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　无动作　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;若距离更大了，显然不应更新；若距离不变，也不更新&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）若三分钟还没收到相邻路由器的更新路由表，则把此相邻路由器记为不可到达的路由器，即“距离”为 16。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）return&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;【例】：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;已知路由器R6有表a所示的路由表。现收到相邻路由器R4发来的路由更新信息，如表b所示。试更新路由器R6的路由表。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;caption&gt;&lt;span&gt;&lt;strong&gt;表 a&lt;/strong&gt;&lt;/span&gt;&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;目的网络&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;距离&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;下一跳路由器&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R5&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table border=&quot;1&quot;&gt;&lt;caption&gt;&lt;span&gt;&lt;strong&gt;表 b&lt;/strong&gt;&lt;/span&gt;&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;目的网络&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;距离&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;下一跳路由器&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net1&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R1&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;直接交付&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;解：先将收到的RIP报文改为表c：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;caption&gt;&lt;span&gt;&lt;strong&gt;表 c&lt;/strong&gt;&lt;/span&gt;&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;目的网络&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;距离&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;下一跳路由&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net1&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;3+1=4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;4+1=5&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;1+1=2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;将表c与表a比较：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;row1：没有Net1，添加到表a中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;row2：有Net2，且下一跳路由器相同，更新&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;row3：有Net3，但下一跳路由器是不同，比较距离得到，新的距离小于路由表中距离，更新&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;综上所述：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更新后R6的路由表如表d 所示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;caption&gt;&lt;span&gt;&lt;strong&gt;表 d&lt;/strong&gt;&lt;/span&gt;&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;目的网络&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;距离&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;下一跳&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net1&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Net3&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;R4&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;RIP协议让AS中所有路由器都和自己相邻路由器定期交换路由信息，并不断更新路由表，使得&lt;span&gt;每个路由器到每个目的网络的路由都是最短的&lt;/span&gt;（跳数最少）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Oct 2018 13:39:00 +0000</pubDate>
<dc:creator>zhxxxx</dc:creator>
<og:description>&gt;&gt;&gt;预备知识 网络层提供两种服务： 虚电路服务 数据报服务 因数据报服务在分组转发时，每个分组独立选择路由进行转发，从而引出路由选择协议。 路由选择协议的核心是路由算法。 理想路由</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanghx/p/9761882.html</dc:identifier>
</item>
<item>
<title>systemd服务详解-技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9762823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9762823.html</guid>
<description>&lt;h2&gt;1.简介&lt;/h2&gt;
&lt;p&gt;在centos5中生成和管理用户空间中的进程以及完成系统的初始化使用的是init,并且是依次启动。在centos6中则是使用的upstart,在一定程度上实现了并行启动，但是仍然存在依赖关系，到了centos7中开始使用systemd，真正的实现并行启动、延时按需启动。&lt;/p&gt;
&lt;h2&gt;2.&lt;strong&gt;systemd&lt;span&gt;的特性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1 &lt;span&gt;启动系统的过程中实现了并行启动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2 &lt;span&gt;由&lt;/span&gt;&lt;span&gt;systemd&lt;/span&gt;&lt;span&gt;所管理的服务可以实现按需激活&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3 &lt;span&gt;支持系统服务状态快照&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4 &lt;span&gt;可以定义程序之间依赖关系&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.unit介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;unit&lt;span&gt;的配置文件是&lt;/span&gt;&lt;span&gt;uit&lt;/span&gt;&lt;span&gt;的核心，在配置文件中主要包含一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;需要管理服务或者程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;服务或者程序需要监听的套接字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;保存的系统快照（就是制作快照的时候，系统中各个服务的状态）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;其他和&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;相关的配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;unit&lt;span&gt;配置文件的位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;/lib/systemd/system         &lt;span&gt;本地配置的系统单元&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;/run/systemd/system         &lt;span&gt;运行时配置的系统单元&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;/usr/lib/systemd/system      第三方软件的系统单元(sshd,nginx..)&lt;/p&gt;
&lt;p&gt;注意：unit(&lt;span&gt;单元&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;中的服务脚本类似，但是不相同&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.&lt;/span&gt;&lt;strong&gt;unit&lt;span&gt;的多种类别&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;类型1：service unit，这是服务类型的unit，该类unit后缀是  .service，比如nginx.service，通过这个nuit可以实现启动、关闭、查看状态等
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     该类unit位于 /usr/lib/systemd/&lt;span&gt;system
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    注意：unit本质上来说并不是脚本，而仅仅是systemd一个配置文件，因此这个unit文件不具有执行权限，而且也无法执行
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    启动服务的方式：通过让systemd去读取配置文件中的内容，完成nginx进程的启动
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;类型2：device unit，这是设备unit，该类unit的后缀是.device，这类unit的作用是用来识别设备文件
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;类型3：mount unit，后缀 .mount，用来实现挂载文件系统到指定的挂载点
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;类型4：socket unit，后缀.socket，用来表示进程间通信的socket文件
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;类型5：snapshot nuit：快照unit，后缀.snapshot, 用来管理快照
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;类型6：target unit：目标unit，后缀是 .target，模拟centos5、6上的运行级别（主要是为了向后兼容）
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;类型7：swap unit
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 类型8：path unit
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.&lt;strong&gt;systemd&lt;span&gt;的特性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;特性1. 基于socket的激活机制
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    在启动系统的时候，systemd会将所有要启动的服务都标记已经启动，标记的方式就是将所有要启动的服务的套接字都监听起来，但是是由systemd自己来监听，而不是让具体的服务自己来监听，这样就解决了进程之间的依赖关系。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    当某个套接第一次被用户的访问的时候，systemd会立刻启动这个套接字所对应的进程，然后将这个套接字和这个启动的服务做绑定
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;特性2：基于bus机制激活
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;特性3：基于device机制激活
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;特性4：基于path机制激活
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    可以让systemd监控某个某个目录，当目录中的文件发生更改的时候，立刻激活某个服务
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;特性5：支持快照机制
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; 特性6：支持域兼容sysV风格的服务管理脚本
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6systemctl&lt;span&gt;使用举例&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.&lt;/span&gt;查看激活的服务&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     查看当前系统中全部已经被激活的unit：systemctl list-units --&lt;span&gt;type service
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     查看当前系统中全部的unit(包括未激活的)：systemctl list-units --type service --all
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 2.&lt;span&gt;开机自启动关闭&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;设置某个服务开机自启动：systemctl enable nginx.service
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    禁止某个服务开机自启动：systemctl disable nginx.service
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     【设置开机自启动，其实就是在/etc/systemd/system/multi-user.target.wants/下创建执行/usr/lib/systemd/system/&lt;span&gt;下的配置文件的软连接】
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     查看当前系统中的全部unit的自动启动情况：systemctl list-unit-&lt;span&gt;files
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    state
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        disabled：禁止开机自动启动
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        enabled：开机自动启动
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt;：该unit不能独立运行，是其他unit所依赖的
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 3.&lt;span&gt;查看是否自启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;查看指定的服务是否开机自动启动
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         systemctl list-unit-files |&lt;span&gt; grep nginx.service
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         systemctl list-unit-&lt;span&gt;files nginx.service
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         systemctl &lt;span&gt;is&lt;/span&gt;-&lt;span&gt;enabled nginx.service
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     查看一个unit的依赖关系：systemctl list-&lt;span&gt;dependencies nginx.service
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     优先用reload，如果无法让修改生效，才执行restart：systemctl reload-or-restart nginx.service
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt; 4.&lt;span&gt;禁止使用&lt;/span&gt;&lt;span&gt;enable&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;禁止用enable让某服务开机自启动：systemctl mask nginx.service
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    解除禁止mask功能：systemctl unmask nginx.service
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     注意：所有的.service可以省略
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 5.&lt;span&gt;切换级别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     systemctl使用举例-&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    切换级别：systemctl isolate name.target
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     切换到的救援模式（级别）：systemctl rescure.tartet   &amp;lt;&amp;lt;&amp;lt; 切换到救援模式不需要用isolate
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 6.&lt;/strong&gt;&lt;strong&gt;查看默认级别&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1    &lt;/span&gt; 查看系统默认的运行级别：systemctl &lt;span&gt;get&lt;/span&gt;-&lt;span&gt;default&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     查看当前系统可用的target：systemctl list-units --&lt;span&gt;type target
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     修改系统默认运行级别：systemctl &lt;span&gt;set&lt;/span&gt;-&lt;span&gt;default&lt;/span&gt; name.target
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;7.unit&lt;span&gt;的文件的基本构成&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一部分：&lt;/span&gt;unit&lt;span&gt;，用于记录该&lt;/span&gt;&lt;span&gt;unit&lt;/span&gt;&lt;span&gt;文件的一些通用信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二部分：&lt;/span&gt;service&lt;span&gt;，记录&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;具体信息（如何启动、配置文件位置&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三部分：&lt;/span&gt;install&lt;span&gt;，记录安装信息（运行级别）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;第一部分：Unit部分
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt;&lt;span&gt;）Description：对该服务的一个简要说明
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt;）Before：定义启动顺序，例子：Before=&lt;span&gt;nginx.service，表示该服务需要在nginx启动之前启动
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt;&lt;span&gt;）After：定义启动顺序，同上
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;4&lt;/span&gt;&lt;span&gt;）Documentation：帮助文档
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt;）Wants：建议同时启动某服务，比如：Wants=&lt;span&gt;nginx.service 表示系统中最好启动nginx服务，但是即使不启动nginx，当前这个服务也没啥影响
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt;）Require：当前服务是需要哪个特定的服务的，比如：Require=&lt;span&gt;nginx.service，这就表示当前服务是需要nginx服务，那么在启动当前这个服务的时候，会自动将nginx也启动起来；而且一旦发现nginx服务停止了，那么当前这个服务也就会自动停止
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    【require无法指定启动次序，需要结合Before After来用，否则经常出现各种问题】
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;7&lt;/span&gt;&lt;span&gt;）Conflicis：当一个服务启动的时候，会立刻停止与之相冲突的服务
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;第二部分：Service部分
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt;&lt;span&gt;）Type：指定service的类型
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        类型1：oneshot：程序执行完成就自动结束了，没有后台进程，比如执行一个shell
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        类型2：forking：需要一个后台守护进程一直在运行，比如运行nginx、apache、sshd
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt;&lt;span&gt;）ExecStart：指定如何启动服务（指定启动服务要执行的命令）
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        如果服务类型是oneshot类型，那么可以直接写上他要执行命令即可，通常不能添加参数和选项
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        如果服务类型不是oneshot类型，那么在写要执行的命令的时候，可以添加一些参数，比如指定选项、配置文件、用户
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        【如果要执行多个命令，那么多个命令之间用;分割，如果需要换行可以用 \ 来续行】
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt;&lt;span&gt;）ExecStartPre, ExecStartPost：指定在执行启动服务之前、之后要执行什么命令
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;4&lt;/span&gt;&lt;span&gt;）ExecStop：停止服务
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt;&lt;span&gt;）Restart：
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt;&lt;span&gt;）PIDFile：指定pid文件的路径
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;第三部分：install部分
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     WantedBy：指定运行级别，WantedBy=multi-user.target
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;8.案例：&lt;span&gt;编写&lt;/span&gt;unit&lt;span&gt;文件，并注册到&lt;/span&gt;&lt;span&gt;systemd&lt;/span&gt;&lt;span&gt;服务中&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;第一步：准备一个shell脚本
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         # vim /root/&lt;span&gt;name.sh
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             #!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             echo `hostname`&amp;gt;/tmp/&lt;span&gt;name.log
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    第二步：创建unit文件
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        # vim my.service
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            [Unit]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             Description=&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; my first unit file
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            [Service]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             Type=&lt;span&gt;oneshot
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             ExecStart=/bin/bash /root/&lt;span&gt;name.sh
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            [Install]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             WantedBy=multi-&lt;span&gt;user.target
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         # mv my.service /usr/lib/systemd/&lt;span&gt;system
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    第三步：将我的unit文件注册到systemd中
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        # systemctl enable my.service
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    第四步：查看该服务的状态
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         # systemctl status my.service
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;9.扩展&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.grub2&lt;span&gt;的配置文件-&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;/etc/default/grub &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;# 指定用户选择菜单超时时间
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     GRUB_TIMEOUT=&lt;span&gt;5&lt;/span&gt;      
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    # 指定菜单中的描述名称    
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     GRUB_DISTRIBUTOR=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$(sed 's, release .*$,,g' /etc/system-release)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    # GRUB指定哪个是默认的title
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    # save表示会保存当前的配置，需要结合一个内置变量来使用
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     GRUB_DEFAULT=&lt;span&gt;saved
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    # 禁用子菜单
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     GRUB_DISABLE_SUBMENU=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    # 指定将启动过程中的信息输出到终端
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     GRUB_TERMINAL_OUTPUT=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;console&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    # 在启动系统的时候，以命令行的方式向内核传递参数
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     GRUB_CMDLINE_LINUX=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;crashkernel=auto rhgb &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    # 指定是否显示启动过程信息
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     GRUB_DISABLE_RECOVERY=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.&lt;span&gt;定制&lt;/span&gt;grub2&lt;span&gt;的配置文件&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1    &lt;/span&gt; &lt;span&gt;第一步：备份原有的grub.cfg
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         # cp /boot/grub2/&lt;span&gt;grub.cfg{,.bak}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     第二步：修改/etc/&lt;span&gt;default&lt;/span&gt;/&lt;span&gt;grub 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    第三步：重新生成grub.cfg
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         # grub2-mkconfig&amp;gt;/boot/grub2/grub.cfg
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.&lt;strong&gt;CentOS7&lt;span&gt;忘记密码解决方法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;进入紧急救援模式
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         进入方式：在启动系统的时候，编辑内核选项，添加 rd.&lt;span&gt;break&lt;/span&gt;，然后按ctrl+&lt;span&gt;x
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        进入救援模式后：
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 根在 sysroot 下
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;2&lt;/span&gt;&lt;span&gt;. 当前是只读权限
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        操作：
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             # mount -o remount,rw /&lt;span&gt;sysroot
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             # chroot /&lt;span&gt;sysroot
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            # passwd 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                xxx
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                xxx
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            # exit
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             # reboot
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 10.进入救援模式方法&lt;/h2&gt;
&lt;h3&gt;1 概述&lt;/h3&gt;
&lt;p&gt;要使得linux进入救援模式，原则其实就是一个，通过光盘启动模式进入，所以，就要想办法让机器能从光盘启动。&lt;/p&gt;
&lt;p&gt;本文主要模拟了Vmware下的操作。如果是真实机器，操作前将光盘插入机器里即可&lt;/p&gt;
&lt;h3&gt;2 CentOS6&lt;/h3&gt;
&lt;p&gt;首先在重新开机时当出现下面这个接界面时按esc进入到Boot Menu。（ps：如果是虚拟机，要提前按一下鼠标，按鼠标模式是在虚拟机内操作，不是本地机器的操作，然后，手速要快，在进度条满之前按，只能按一下，按多了也进不去）&lt;/p&gt;
&lt;p&gt;备注：这里如果按F2进入BIOS然后在设置光盘启动项为第一项也是可以，但是不推荐，因为还要改回来，要不然每次都是光盘第一启动，很麻烦&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-92bca46318ae5e3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上下键选择第三项CD-ROM Drive，光盘启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-a16aa18deeb648cb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再选择第三项救援模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-cffe328a9ceae9c1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择语言，默认English就行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-58e607641916b56c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-1acd94f0ca27a2a7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择No跳过网口检测&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-bcd8d36baca9af55?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击继续&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-69c36ba3faaa1a2c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里提示我们，救援模式下的根目录不是我们以前的根目录，而/mnt.sysimage这个目录才是我没以前的根目录，如果想要变回以前的根目录需要执行chroot /mnt/sysimage命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-1eea760167a47e87?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再一次提示我们根目录的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-e2256eb045c1a3c4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候选择开启shell进程，这样我们就可以使用命令了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-cd7555575d39078a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-b0c877b36966a287?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3 CentOS7&lt;/h3&gt;
&lt;p&gt;centOS7进入图一 troubleshooting有两个方法&lt;/p&gt;
&lt;p&gt;方法一&lt;/p&gt;
&lt;p&gt;首先在重新开机时当出现下面这个接界面时按esc进入到Boot Menu。（ps：如果是虚拟机，要提前按一下鼠标，按鼠标模式是在虚拟机内操作，不是本地机器的操作，然后，手速要快，在进度条满之前按，只能按一下，按多了也进不去）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-92bca46318ae5e3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上下键选择第三项CD-ROM Drive，光盘启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-a16aa18deeb648cb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法二&lt;/p&gt;
&lt;p&gt;虚拟机开机按F12--》c--&amp;gt;输入exit --》&lt;/p&gt;
&lt;p&gt;以上两个方法都可以进入troubleshooting页面，接下来步骤一样&lt;/p&gt;
&lt;p&gt; 图一 选择troubleshooting --&amp;gt; 图二 选择Rescue，等待加载--》选择 选项1，等待一会儿，按enter，就可以进入救援模式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-a9e4f88cbd1dcd22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图一 选择troubleshooting&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-b2a626c9b1ceea0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图二 选择Rescue&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6943703-fbe74d1204d815e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Oct 2018 13:14:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>1.简介 在centos5中生成和管理用户空间中的进程以及完成系统的初始化使用的是init,并且是依次启动。在centos6中则是使用的upstart,在一定程度上实现了并行启动，但是仍然存在依赖关系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9762823.html</dc:identifier>
</item>
</channel>
</rss>