<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Canvas-图片旋转 - Mr.苏</title>
<link>http://www.cnblogs.com/suyuanli/p/8279244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suyuanli/p/8279244.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;众所周知canvas是位图，你可以在里面渲染你要的东西，不过你只能操作canvas的属性来进行编辑。就是说你并不能操作画进canvas的东西，例如我在canvas里添加一幅画，我现在想将那幅画移动10px，我们并不能直接操作那幅画，因为我们根本获取不到那幅画的任何信息。我们永远只能获取到的是canvas对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;那问题来了我要怎么旋转图片&quot;&gt;那问题来了，我要怎么旋转图片&lt;/h5&gt;
其实canvas是提供了各种各样的接口去控制画布的，旋转有&lt;span&gt;rotate()&lt;/span&gt;方法。&lt;br/&gt;其实这里的旋转并不是真的把这个画布旋转了，例如我ctx.rotate(Math.PI/2)旋转90°了。并不是说我们在页面上就会看到canvas旋转了90°。我们可以理解为其实canvas是有两个部分组成的，一个是肉眼看得到的画布，一个是用于操作的虚拟画布，我们所有在虚拟画布上的动作都会映射到真实画布中去。&lt;br/&gt;这样说可能很难理解，下面用图来解释一波。首先介绍一下&lt;span&gt;rotate()&lt;/span&gt;方法先，它可以旋转画布，旋转点画布的原点，而画布的原点默认是左上角。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1515823062000-965.png&quot; title=&quot;cancas旋转图解1&quot; alt=&quot;cancas旋转图解1&quot;/&gt;&lt;br/&gt;下面在给大家看一下旋转45°所呈现的效果：&lt;br/&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1515825290000-863.png&quot; title=&quot;canvas旋转图解2&quot; alt=&quot;canvas旋转图解2&quot;/&gt;&lt;br/&gt;在这里我们可以看到我刚刚所说的虚拟的画布旋转45°后再向虚拟的画布内插入图片，然后真实画布所呈现的就是虚拟画布和真实画布相交的部分了。这里可能不太好理解，大家仔细想想。&lt;br/&gt;两张图的代码是这样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 未旋转&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; img &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'img'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; canvas &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'canvas'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ctx &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;canvas&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getContext&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2d&quot;&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;drawImage&lt;/span&gt;(img&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;// 逆时针旋转45°&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; img &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'img'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; canvas &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'canvas'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ctx &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;canvas&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getContext&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2d&quot;&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;rotate&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;PI&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;drawImage&lt;/span&gt;(img&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到这里我想大家基本知道&lt;span&gt;rotate()&lt;/span&gt;的使用方法了。&lt;/p&gt;
&lt;h5 id=&quot;下面就来说说怎么实现再图片中心旋转&quot;&gt;下面就来说说怎么实现再图片中心旋转&lt;/h5&gt;
&lt;p&gt;再说之前向给大家了解一下canvas的另外两个方法的用法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;ctx.translate(x, y): 这个方法是可以移动画布原点的方法，参数分别是x，y；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;ctx.drawImage(img, x, y)：这个方法上面用过了，不过里面是有三个参数的，第一个是要插入的图片dom，后面两个x，y分别为插入图片时对img的位置进行修改。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从图可以看出，要想实现围绕图片中心旋转45°，就得把canvas的原点移动到这张图的中心，再旋转canvas，再就是插入图片时将图片往左上角平移图片自身的一半。&lt;br/&gt;这里分别有三个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;移动canvas原点&lt;/li&gt;
&lt;li&gt;旋转canvas&lt;/li&gt;
&lt;li&gt;插入图片并移动&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1515826329000-087.png&quot; title=&quot;canvas旋转图解3&quot; alt=&quot;canvas旋转图解3&quot;/&gt;&lt;br/&gt;下面把这三个步骤分开看看（图片的宽高为400和300）&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;移动canvas原点&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; img &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'img'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; canvas &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'canvas'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ctx &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;canvas&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getContext&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2d&quot;&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;translate&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;150&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;drawImage&lt;/span&gt;(img&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1515827444000-158.png&quot; title=&quot;canvas旋转图解4&quot; alt=&quot;canvas旋转图解4&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;旋转canvas&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; img &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'img'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; canvas &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'canvas'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ctx &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;canvas&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getContext&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2d&quot;&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;translate&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;150&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;rotate&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;PI&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;drawImage&lt;/span&gt;(img&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1515827609000-132.png&quot; title=&quot;canvas旋转图解5&quot; alt=&quot;canvas旋转图解5&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;插入图片并移动&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; img &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'img'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; canvas &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'canvas'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ctx &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;canvas&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getContext&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2d&quot;&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;translate&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;150&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;rotate&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;PI&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;drawImage&lt;/span&gt;(img&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;150&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1515827762000-917.png&quot; title=&quot;canvas旋转图解6&quot; alt=&quot;canvas旋转图解6&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样就大功告成了&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3 id=&quot;ps大家再做完一系列动作后一定要将canvas的原点旋转复原不然再经过一系列操作后canvas的设置会乱掉每操作一次完成后都把设置恢复回原样就好了&quot;&gt;ps:大家再做完一系列动作后一定要将canvas的原点，旋转复原。不然再经过一系列操作后，canvas的设置会乱掉。每操作一次完成后都把设置恢复回原样就好了。&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; img &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'img'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; canvas &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'canvas'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ctx &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;canvas&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getContext&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2d&quot;&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;translate&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;150&lt;/span&gt;)         &lt;span class=&quot;co&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;rotate&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;PI&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)        &lt;span class=&quot;co&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;drawImage&lt;/span&gt;(img&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;150&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;// 恢复设置（恢复的步骤要跟你修改的步骤向反）&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;rotate&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;PI&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)         &lt;span class=&quot;co&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;translate&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;150&lt;/span&gt;)       &lt;span class=&quot;co&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 之后canvas的原点又回到左上角，旋转角度为0&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 其它操作...&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一点要注意的，我刚刚示范的是图片相对canvas x轴y轴为0所示范的例子，如果不为0的情况下，只需在移动原点的时候ctx.translate(200+x, 150+y)。这里的200和150是该图片的宽高的一半，x，y就是图片相对canvas的x，y&lt;/p&gt;
&lt;h5 id=&quot;这篇文章讲的只是在图片中心旋转之后我会写旋转搭配图片的缩放有写的不好或错误的地方望指出&quot;&gt;这篇文章讲的只是在图片中心旋转，之后我会写旋转搭配图片的缩放。有写的不好或错误的地方，望指出&lt;/h5&gt;
</description>
<pubDate>Sat, 13 Jan 2018 07:38:00 +0000</pubDate>
<dc:creator>Mr.苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suyuanli/p/8279244.html</dc:identifier>
</item>
<item>
<title>DirectSound---输出设备基本操作（枚举、查询等） - lgxZJ</title>
<link>http://www.cnblogs.com/lgxZJ/p/8279193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lgxZJ/p/8279193.html</guid>
<description>&lt;p&gt;DirectSound是DirectX组件之一，提供了对音频设备的捕获和播放能力，同时它也是唯一几个支持Xp系统的音频技术之一。 DirectSound主要有以下特点：&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;播放音频&lt;strong&gt;低延迟&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件资源控制&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同时&lt;/strong&gt;播放&lt;strong&gt;多个&lt;/strong&gt;声音。&lt;/li&gt;
&lt;li&gt;控制硬件缓冲区的使用&lt;strong&gt;优先级&lt;/strong&gt;（DirectSound使用缓冲区来播放音频）。&lt;/li&gt;
&lt;li&gt;模拟&lt;strong&gt;3D&lt;/strong&gt;音频环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态&lt;/strong&gt;更改音效（回声、和声等）。&lt;/li&gt;
&lt;li&gt;捕获音频输入设备声音位wav（多为PCM数据，未经压缩）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只能播放wav音频文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我们说说设备操作这一块儿。&lt;/p&gt;
&lt;h2 id=&quot;输出设备操作&quot;&gt;1. 输出设备操作&lt;/h2&gt;
&lt;p&gt;在DirectSound中，一个设备对象就代表一个音频设备，播放设备对象对应播放设备，输入设备对象对应输入设备。因为DirectSound使用COM协议，因此每个设备对象都用接口来表示。这里&lt;strong&gt;IDirectSound8&lt;/strong&gt;这个接口就代表了一个输出设备对象，应用程序可以对&lt;strong&gt;同一个&lt;/strong&gt;音频设备&lt;strong&gt;创建多个&lt;/strong&gt;设备对象来进行音频输出操作。旧版本的DirectSound使用的是&lt;strong&gt;IDirectSound&lt;/strong&gt;接口，相比前者少了一些功能。&lt;/p&gt;
&lt;h3 id=&quot;枚举&quot;&gt;1.1 枚举&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;HRESULT WINAPI DirectSoundEnumerateW(&lt;em&gt;In&lt;/em&gt; LPDSENUMCALLBACKW pDSEnumCallback, &lt;em&gt;In_opt&lt;/em&gt; LPVOID pContext);&lt;br/&gt;typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们通过DirectSoundEnumerateW这个函数来枚举，该函数需要传入一个回调函数（原型见上），当枚举到一个设备时该回调会被调用。&lt;strong&gt;如果我们想继续枚举，需要在这个回调用中返回TRUE来告诉系统，否则返回FALSE&lt;/strong&gt;。另一个参数&lt;code&gt;pContext&lt;/code&gt;允许用户传入额外的参数，传入回调函数的最后一个实参就是这个&lt;code&gt;pContext&lt;/code&gt;。枚举时，DirectSound会将默认也认作一个单独的设备来对待，因此默认设备会被重复枚举一次。当设备被作为默认设备枚举时，它的&lt;strong&gt;GUID和设备描述字符串都为空&lt;/strong&gt;，需要小心处理，这里我直接跳过了该次枚举：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (DirectSoundEnumerateW(enumerateCallback, nullptr) != DS_OK) {
    ...
}

BOOL CALLBACK DirectSoundBasic::enumerateCallback(LPGUID guid,
                                              LPCWSTR deviceDescription,
                                              LPCWSTR deviceDriverModule,
                                              LPVOID context)
{
    Q_UNUSED(context);

    //  if primary device, skip it
    if (guid == nullptr)        return TRUE;

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建设备对象&quot;&gt;1.2 创建设备对象&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;HRESULT WINAPI DirectSoundCreate8(&lt;em&gt;In_opt&lt;/em&gt; LPCGUID pcGuidDevice, &lt;em&gt;Outptr&lt;/em&gt; LPDIRECTSOUND8 *ppDS8, &lt;em&gt;Pre_null&lt;/em&gt; LPUNKNOWN pUnkOuter);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调用DirectSoundCreate8函数，我们可以创建一个设备对象，通过传入一个枚举设备时获得的&lt;strong&gt;GUID&lt;/strong&gt;，函数会返给我们一个&lt;strong&gt;IDirectSound8&lt;/strong&gt;接口代表设备对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;IDirectSound8* directSound8;
if (DirectSoundCreate8(guid, &amp;amp;directSound8, NULL) != DS_OK) {
    std::wcout &amp;lt;&amp;lt; L&quot;[error] DirectSoundCreate8 call error!&quot;;
    return TRUE;    //  if error, skip this device
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置设备对象优先级&quot;&gt;1.3 设置设备对象优先级&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HRESULT IDirectSound8::SetCooperativeLevel(HWND hwnd, DWORD dwLevel)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在使用设备对象创建缓冲区（用来捕获、播放音频）之前，我们需要设置设备对象的&lt;strong&gt;协作级别&lt;/strong&gt;。这个协作级别相当于用户对设备进行操作的优先级，分为：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;DSSCL_EXCLUSIVE&lt;/strong&gt;: 互斥级别。对于DirectX8.0以前版本，仅播放当前应用的音频数据，其他应用的声音不会被播放；对于DirectX8.0级以后版本，同DSSCL_PRIORITY版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSSCL_NORMAL&lt;/strong&gt;： 普通级别，这种级别下的应用程序具有&lt;strong&gt;最平滑的多任务和资源共享表现&lt;/strong&gt;，但是这种应用&lt;strong&gt;不能更改&lt;/strong&gt;主缓冲区音频数据格式，输出音频格式被&lt;strong&gt;限制为8位&lt;/strong&gt;数据。&lt;em&gt;在DirectSound中，次缓冲区用来填充应用程序需要播放的声音，主缓冲区会对多个次缓冲区（可能是本应用的，也可能是其他应用的）进行混音，然后用声卡输出播放。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSSCL_PRIORITY&lt;/strong&gt;： 优先级别，&lt;strong&gt;可以&lt;/strong&gt;更改主缓冲区数据格式。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;DSSCL_WRITEPRIMARY&lt;/strong&gt;：写主缓冲区级别，应用可以直接&lt;strong&gt;写入主缓冲区&lt;/strong&gt;，此时所有次缓冲区不会被播放（如果设备的驱动是DirectSound模拟出来的，则不能设置该级别）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意该函数需要传入一个窗口句柄，因为我们今天只介绍DirectSound的基本操作，我直接传入桌面窗口的句柄并设定位DSSCL_NORMAL优先级：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (directSound8-&amp;gt;SetCooperativeLevel(GetDesktopWindow(), DSSCL_NORMAL) != DS_OK) {
    std::wcout &amp;lt;&amp;lt; L&quot;[error] SetCooperativeLevel call error!&quot;;
    return TRUE;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设备能力&quot;&gt;1.4 设备能力&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;HRESULT IDirectSound8::GetCaps(LPDSCAPS pDSCaps)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不同的音频播放设备具有不同的能力，DirectSound允许我们查询设备的能力：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是否经过Microsoft认证。&lt;/li&gt;
&lt;li&gt;知否支持最小最大采样率之间的所有采样率。&lt;/li&gt;
&lt;li&gt;当没有DirectSound驱动时模拟驱动。&lt;/li&gt;
&lt;li&gt;主次缓冲区格式（16位、8位）。&lt;/li&gt;
&lt;li&gt;主次缓冲区声道支持（单声道、立体声即多声道）。&lt;/li&gt;
&lt;li&gt;不精准的数据（某些声卡不支持）：
&lt;ul&gt;&lt;li&gt;缓冲区（静态缓冲区、流缓冲区、3D缓冲区）最大数、空闲数。&lt;/li&gt;
&lt;li&gt;声卡上的总内存数量、空闲内存数量、最大空闲块大小，&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们传给GetCaps一个DSCAPS结构体地址，然后系统就帮我们填充相应的数据，调用GetCaps前需要将DSCAPS结构体的dwSize设置为DSCAPS的大小：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DSCAPS deviceCapability = { sizeof(deviceCapability) };
if (directSound8-&amp;gt;GetCaps(&amp;amp;deviceCapability) != DS_OK) {
    std::wcout &amp;lt;&amp;lt; L&quot;[error] GetCaps call error!&quot;;
    return TRUE;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;播放器配置&quot;&gt;1.5 播放器配置&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HRESULT IDirectSound8::GetSpeakerConfig(LPDWORD pdwSpeakerConfig)&lt;br/&gt;HRESULT IDirectSound8::SetSpeakerConfig(LPDWORD pdwSpeakerConfig)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;播放器配置只能是以下之一：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DSSPEAKER_5POINT1_SURROUND&lt;/strong&gt;、&lt;strong&gt;DSSPEAKER_5POINT1_BACK&lt;/strong&gt;: 家庭影院配置，5个环绕扬声器，1个低音炮。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSSPEAKER_DIRECTOUT&lt;/strong&gt;：直接播放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSSPEAKER_HEADPHONE&lt;/strong&gt;：头戴式耳机。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSSPEAKER_MONO&lt;/strong&gt;：单声道扬声器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSSPEAKER_QUAD&lt;/strong&gt;：4声道播放器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSSPEAKER_STEREO&lt;/strong&gt;：立体声播放器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSSPEAKER_SURROUND&lt;/strong&gt;：环绕播放器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSSPEAKER_7POINT1_WIDE&lt;/strong&gt;、&lt;strong&gt;DSSPEAKER_7POINT1_SURROUND&lt;/strong&gt;：家庭影院配置，7个环绕扬声器，1个低音炮。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然MSDN文档没有写清楚，但是通过查以上宏定义我们发现它们是按大小顺序定义的，因此不可能通过OR&lt;code&gt;|&lt;/code&gt;来包含多种可能，例子中如果调用出错直接返回TRUE表示我们继续枚举设备并继续查询那些设备能力：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DWORD deviceSpeakerConfiguration;
if (directSound8-&amp;gt;GetSpeakerConfig(&amp;amp;deviceSpeakerConfiguration) != DS_OK) {
    std::wcout &amp;lt;&amp;lt; L&quot;[error] GetSpeakerConfig call error!&quot;;
    return TRUE;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运行结果&quot;&gt;2. 运行结果&lt;/h2&gt;
&lt;p&gt;这次我们用GUI界面来显示实例运行的结果（出于方便考虑，以后我会用控制台来显示示例），为防止用户误操作更改显示的数据我将大部分控件都disable了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/01/13/5a59b149bc632.png&quot; alt=&quot;result-img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整代码见&lt;a href=&quot;https://github.com/lgxZJ/Miscellaneous/tree/master/Audio/DirectSoundBasic&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jan 2018 07:24:00 +0000</pubDate>
<dc:creator>lgxZJ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lgxZJ/p/8279193.html</dc:identifier>
</item>
<item>
<title>[认证授权] 6.Permission Based Access Control - blackheart</title>
<link>http://www.cnblogs.com/linianhui/p/permission-based-access-control.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linianhui/p/permission-based-access-control.html</guid>
<description>&lt;p&gt;在前面5篇博客中介绍了OAuth2和OIDC（OpenId Connect），其作用是授权和认证。那么当我们得到OAuth2的Access Token或者OIDC的Id Token之后，我们的资源服务如何来验证这些token是否有权限来执行对资源的某一项操作呢？比如我有一个API，/books，它具有如下5个操作：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;POST /books&lt;/td&gt;
&lt;td&gt;添加一本书&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GET /books/{id}&lt;/td&gt;
&lt;td&gt;获取一本书&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PUT /books/{id}&lt;/td&gt;
&lt;td&gt;更新一本书&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DELETE /books/{id}&lt;/td&gt;
&lt;td&gt;删除一本书&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GET /books　　&lt;/td&gt;
&lt;td&gt;获取书的列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;books&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BooksController : Controller
{
    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book[] Get() { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }

    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book Get(&lt;span&gt;int&lt;/span&gt; bookId) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }

    [HttpPost(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book Post(Book book) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }

    [HttpPut(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book Put(&lt;span&gt;int&lt;/span&gt; bookId, Book book) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }

    [HttpDelete(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book Delete(&lt;span&gt;int&lt;/span&gt; bookId) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么我们先看看基于OAuth2的Access Token，OIDC的Id Token和传统的基于角色的权限控制是如何处理控制这些资源的操作。&lt;/p&gt;

&lt;p&gt;我们都知道OAuth2的最终产物是提供给我们一个Access Token，而这个Access Token中包含了一个&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/oauth2-authorization.html#auto_id_9&quot; target=&quot;_blank&quot;&gt;Scope&lt;/a&gt;的字段，这个字段代表的是&lt;strong&gt;授权服务器&lt;/strong&gt;或者&lt;strong&gt;资源拥有者&lt;/strong&gt;授予第三方客户端允许操作&lt;strong&gt;资源服务器&lt;/strong&gt;的哪些资源的范围。这里有一点需要注意的是，这个授权过程可以有资源拥有着的参与（&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/oauth2-authorization.html#auto_id_8&quot; target=&quot;_blank&quot;&gt;Authorization Code&lt;/a&gt;,&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/oauth2-authorization.html#auto_id_13&quot; target=&quot;_blank&quot;&gt;Implicit&lt;/a&gt;,&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/oauth2-authorization.html#auto_id_16&quot; target=&quot;_blank&quot;&gt;Resource Owner Password Credentials Grant&lt;/a&gt;)，也可以没有他的参与（&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/oauth2-authorization.html#auto_id_17&quot; target=&quot;_blank&quot;&gt;Client Credentials Grant&lt;/a&gt;）。那么基于上述的books的资源，我们可以定义一个 &lt;span class=&quot;cnblogs_code&quot;&gt;user_manager&lt;/span&gt; 的Scope，来控制对books的五个操作的权限控制。那么Books的基于Scope的权限控制看起来就像是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;books&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BooksController : Controller
{
    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;span&gt;[Scope(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;book_manager&quot;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book[] Get() { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }

    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;span&gt;[Scope(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;book_manager&quot;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book Get(&lt;span&gt;int&lt;/span&gt; bookId) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }

    [HttpPost(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;span&gt;[Scope(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;book_manager&quot;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book Post(Book book) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }

    [HttpPut(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;span&gt;[Scope(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;book_manager&quot;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book Put(&lt;span&gt;int&lt;/span&gt; bookId, Book book) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }

    [HttpDelete(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;span&gt;[Scope(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;book_manager&quot;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Book Delete(&lt;span&gt;int&lt;/span&gt; bookId) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意看红色的部分，为每一个操作都添加了一个Scope的描述。如果Access Token拥有&lt;span class=&quot;cnblogs_code&quot;&gt;user_manager&lt;/span&gt;这个Scope（不管他是OAuth2的哪一个授权方式颁发的，我们的最终代码部分只认Scope），那么对这些API的调用就是被允许的，否则视为无权操作。&lt;/p&gt;

&lt;p&gt;关于Id Token的用途以及其包含哪些信息请参考&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto_id_5&quot; target=&quot;_blank&quot;&gt;Id Token&lt;/a&gt;。Id Token和Access Token的不同之处在于它一定是包含某一个用户的标识 &lt;span class=&quot;cnblogs_code&quot;&gt;sub&lt;/span&gt; ，但是没有Scope，这是因为Id Token的用途是认证当前用户是谁，所以用户是必须存在的；由于仅仅是认证，则不会包含被认证用户可以做哪些操作之类的授权相关的事情。那么针对Id Token，我们的API应该如何进行权限管控呢？通常的做法是使用传统的基于校色的权限控制(Role Based Access Control)。其实现细节就不解释了，它的模型大致是：一个实体（用户或者组织）拥有一组角色，每一个角色代表着一组权限集合。感觉是不是和Scope很像呢，其实差不多。我们定义一个这样的角色 &lt;span class=&quot;cnblogs_code&quot;&gt;图书管理员&lt;/span&gt; 吧。这里是故意和Scope的命名区分开的，因为其来源不同，那么我们最终实现的时候也会是独立开来的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;books&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BooksController : Controller
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     [HttpGet(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     [Scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book_manager&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;[Role(&quot;图书管理员&quot;)]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Book[] Get() { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     [Scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book_manager&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;[Role(&quot;图书管理员&quot;)]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Book Get(&lt;span&gt;int&lt;/span&gt; bookId) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     [HttpPost(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     [Scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book_manager&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;[Role(&quot;图书管理员&quot;)]
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Book Post(Book book) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     [HttpPut(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     [Scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book_manager&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;[Role(&quot;图书管理员&quot;)]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Book Put(&lt;span&gt;int&lt;/span&gt; bookId, Book book) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     [HttpDelete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     [Scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book_manager&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;[Role(&quot;图书管理员&quot;)]
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Book Delete(&lt;span&gt;int&lt;/span&gt; bookId) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果 &lt;span class=&quot;cnblogs_code&quot;&gt;sub&lt;/span&gt; 代表的用户自身拥有或者其所属的组织机构拥有（不管其是怎么组织管理的吧，最终我们可以知道这个用户是否具有某一个角色） &lt;span class=&quot;cnblogs_code&quot;&gt;图书管理员&lt;/span&gt; 这个角色。则允许其访问books的这些操作。&lt;/p&gt;

&lt;p&gt;其实不止以上两种，比如在Asp.Net Core中有内置的这些授权控制组件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/168328/201801/168328-20180113132335379-1395438878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [Authorize(Policy = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AtLeast21&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AlcoholPurchaseController : Controller
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; IActionResult Login() =&amp;gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; IActionResult Logout() =&amp;gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上这些本质上和上面的基于Scope和基于Role的属于同一种类型。我们这样做当然可以工作，但是问题来了，&lt;span&gt;它们直观吗，灵活吗？繁琐吗？好用吗?能满足我们变化的需求吗？总有着一种把简单的事情搞复杂的感觉&lt;/span&gt;。比如现在我增需要增加一个角色，超级管理员，那么上述的代码是不是需要我们做出改变呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [HttpGet(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; [Scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book_manager&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; [Role(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;图书管理员&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;超级管理员&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Book[] Get() { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再比如，现在需要增加一个Scope &lt;span class=&quot;cnblogs_code&quot;&gt;book_reader&lt;/span&gt; ，它只能执行读取的操作，又要做出改变了吧。况且即使我们把Scope和Role合二为一了，还是混乱不堪。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;那么造成这些问题的根本原因是什么？答：不管是Scope还是Role它们体现的都是一个隐式的描述信息，而不是某一个具体的操作行为的描述信息。&lt;span&gt;既然我们知道了其症结所在，那么怎么解决这个问题呢？原理很简单，使用权限作为我们的最小单元，把Scope和Role等等还有其他的一些管理组织权限的概念都作为一个中间层，禁止它们出现在接口权限验证的地方，而是仅作为管理组织&lt;span&gt;&lt;span&gt;&lt;span&gt;Permission&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的手段存在。然后改造上面的代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;books&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BooksController : Controller
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     [HttpGet(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;[Permission(&quot;books.read&quot;)]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Book[] Get() { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;[Permission(&quot;book.read&quot;)]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Book Get(&lt;span&gt;int&lt;/span&gt; bookId) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     [HttpPost(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;[Permission(&quot;book.add&quot;)]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Book Post(Book book) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     [HttpPut(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;[Permission(&quot;book.edit&quot;)]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Book Put(&lt;span&gt;int&lt;/span&gt; bookId, Book book) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     [HttpDelete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{bookId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;[Permission(&quot;book.delete&quot;)]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Book Delete(&lt;span&gt;int&lt;/span&gt; bookId) { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们把每一个操作都定义一个权限&lt;span&gt;Permission&lt;/span&gt;，不管你是Access Token的Scope，还是Role，都不会在这里出现&lt;span&gt;。比如在检查&lt;span&gt;超级管理员&lt;/span&gt;是不是能操作的时候，我们可以直接放行（把这些检查和我们对接口的操作权限的描述分开）。如果是名为&lt;span class=&quot;cnblogs_code&quot;&gt;book_reader&lt;/span&gt;的Scope的时候，我们让&lt;span class=&quot;cnblogs_code&quot;&gt;book_reader&lt;/span&gt;只关联&lt;span&gt;books.read&lt;/span&gt;和&lt;span&gt;book.read&lt;/span&gt;这两个&lt;span&gt;Permission&lt;/span&gt;，而这种关联关系的管理，我们是可以通过数据存储来维持的，也很方便的提供管理页面来灵活的配置。而最终的代码上关心的只是&lt;span&gt;Permission&lt;/span&gt;。&lt;span&gt;这种方式可以称为&lt;strong&gt;Resource Based Access Control&lt;/strong&gt;或者&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Permission Based Access Control&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以上是我自己的一些理解和思路，然后我发现了Apache Shiro这个项目，感觉就像是找到了组织，&lt;span&gt;Apache Shiro&lt;/span&gt;走的更远，而且为&lt;span&gt;&lt;span&gt;Permission定义了一套规则&lt;/span&gt;&lt;/span&gt;。强烈建议读一读&lt;a href=&quot;https://shiro.apache.org/permissions.html&quot; target=&quot;_blank&quot;&gt;https://shiro.apache.org/permissions.html&lt;/a&gt;这篇文档。而.Net这边就没有这么好的福气了，，，Asp.Net Core中的默认授权过滤器还是传统的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/168328/201801/168328-20180113133507488-844554015.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;不过基于Asp.Net Core的Filter：IAuthorizationFilter，我们可以把这一整套授权控制方式给替换掉：使用代码：&lt;a href=&quot;https://github.com/linianhui/oidc.example/tree/master/src/web.oauth2.resources&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/oidc.example/tree/master/src/web.oauth2.resources&lt;/a&gt;；Filters代码：&lt;a href=&quot;https://github.com/linianhui/oidc.example/tree/master/src/aspnetcore.filters.permissions&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/oidc.example/tree/master/src/aspnetcore.filters.permissions&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/168328/201801/168328-20180113153033801-876908426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从此和讨厌的 &lt;span class=&quot;cnblogs_code&quot;&gt;[Authorize(Roles =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;图书管理员&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Policy =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XXX&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]&lt;/span&gt; 说再见。&lt;/p&gt;
&lt;p&gt;以上只是个人的一些理解，如有错误，欢迎指正。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://shiro.apache.org/&quot; target=&quot;_blank&quot;&gt;https://shiro.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;强烈推荐：&lt;/span&gt;&lt;a href=&quot;https://shiro.apache.org/permissions.html&quot; target=&quot;_blank&quot;&gt;https://shiro.apache.org/permissions.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/security/authorization/&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/security/authorization/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jan 2018 07:23:00 +0000</pubDate>
<dc:creator>blackheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linianhui/p/permission-based-access-control.html</dc:identifier>
</item>
<item>
<title>python 3.x 与2.x的区别 - 王延领</title>
<link>http://www.cnblogs.com/kmonkeywyl/p/8279128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kmonkeywyl/p/8279128.html</guid>
<description>&lt;p&gt;　　保持学习的态度，学一门动态语言其实是很早以前的就准备要做的事情，当时还在纠结python与ruby。现在不单单是要学python，还在考虑用它做点什么，这些等后续再说吧，因为看的是python2.x的书籍。用的是python 3.7.所以先把两者的区别记录一下，仅限于基础。&lt;/p&gt;

&lt;h2&gt;1.print&lt;/h2&gt;
&lt;p&gt;print语句没有了，取而代之的是print()函数。&lt;/p&gt;
&lt;p&gt;py 2.x:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;wyl&lt;/span&gt;&lt;span&gt;&quot; #语句&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;wyl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;py 3.x:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
wyl
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wyl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
SyntaxError: Missing parentheses &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; call to &lt;span&gt;'&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;. Did you mean &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wyl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)?
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.Unicode&lt;/h2&gt;
&lt;p&gt;Python 2 有 ASCII str() 类型，unicode() 是单独的，不是 byte 类型。&lt;/p&gt;
&lt;p&gt;现在， 在 Python 3，我们最终有了 Unicode (utf-8) 字符串，以及一个字节类：byte 和 bytearrays。&lt;/p&gt;
&lt;p&gt;由于 Python3.X 源码文件默认使用utf-8编码，这就使得以下代码是合法的：&lt;/p&gt;
&lt;p&gt;py 2.x&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; str=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王延领那小子真帅&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; str
&lt;/span&gt;&lt;span&gt;'&lt;span class=&quot;str&quot;&gt;xe6\x88\x91\xe7\x88\xb1\xe5\x8c\x97\xe4\xba\xac\xe5\xa4\xa9\xe5\xae\x89\xe9\x97\xa8&lt;/span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;py 3.x&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; str=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王延领那小子真帅&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; str
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王延领那小子真帅&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 3.除法运算 &lt;/h2&gt;
&lt;p&gt;Python中的除法有两个运算符，/和//&lt;/p&gt;
&lt;p&gt;首先来说/除法:&lt;/p&gt;
&lt;p&gt;在python 2.x中/除法就跟我们熟悉的大多数语言，比如Java啊C#啊差不多，取整，把小数部分完全忽略掉。&lt;/p&gt;
&lt;p&gt;在python 3.x中/除法不再这么做了，对于整数之间的相除，结果也会是浮点数。&lt;/p&gt;
&lt;p&gt;py 2.x&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; 1/2
0
&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;py 3.x&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; 1/2&lt;br/&gt;0.5&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;第二种//除法：&lt;/p&gt;
&lt;p&gt;这种除法叫做floor除法，py2.x与py3.x相同&lt;/p&gt;
&lt;p&gt; py2.x py3.x&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; 1//2&lt;span&gt;
0
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.异常&lt;/h2&gt;
&lt;p&gt;在 py3.x 中我们现在使用 as 作为关键词,而非‘，’&lt;/p&gt;
&lt;p&gt;所以异常都从 BaseException继承，并删除了StardardError &lt;/p&gt;
&lt;p&gt;去除了异常类的序列行为和.message属性 &lt;/p&gt;
&lt;p&gt;用 raise Exception(args)代替 raise Exception, args语法 &lt;/p&gt;
&lt;p&gt;捕获异常的语法改变，引入了as关键字来标识异常实例&lt;/p&gt;
&lt;p&gt;py3.0:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
  &lt;/span&gt;1/&lt;span&gt;0
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception , err:
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; err
  
SyntaxError: invalid syntax
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;正确的写法&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
  &lt;/span&gt;1/&lt;span&gt;0
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as err:
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(err)

  
division by zero
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.xrange&lt;/h2&gt;
&lt;p&gt;xrange() 改名为range()，要想使用range()获得一个list，必须显式调用： &lt;/p&gt;
&lt;p&gt;py 2.x&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; range(1,10&lt;span&gt;)
[0, &lt;/span&gt;1, 2, 3, 4, 5, 6, 7, 8, 9]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;py3.x&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; range(10&lt;span&gt;)
range(0, &lt;/span&gt;10&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;py3.x 如果想使用range(),可以结合list&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; list(range(10&lt;span&gt;))
[0, &lt;/span&gt;1, 2, 3, 4, 5, 6, 7, 8, 9&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 6.八进制&lt;/h2&gt;
&lt;p&gt;python 八进制不能0开头而是以0o开头&lt;/p&gt;
&lt;p&gt;py 3.x&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; 0101&lt;span&gt;
SyntaxError: invalid token
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; 0o101
&lt;/span&gt;65
&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7.不等运算符&lt;/h2&gt;
&lt;p&gt;不等运算py3.x只有“！=”，“&amp;lt;&amp;gt;”已被移除&lt;/p&gt;
&lt;p&gt;py3.x&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; 1!=3&lt;span&gt;
True
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; 1&amp;lt;&amp;gt;3&lt;span&gt;
SyntaxError: invalid syntax
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;8.去掉了repr表达式``&lt;/h2&gt;
&lt;p&gt;py3.x&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; s=&lt;span&gt;`wyl`
SyntaxError: invalid syntax
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; s=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wyl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; repr(s)
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'wyl'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;9.多个模块被改名（根据PEP8）&lt;/h2&gt;
&lt;table class=&quot;reference&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;旧的名字&lt;/th&gt;
&lt;th&gt;新的名字&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;_winreg&lt;/td&gt;
&lt;td&gt;winreg&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ConfigParser&lt;/td&gt;
&lt;td&gt;configparser&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;copy_reg&lt;/td&gt;
&lt;td&gt;copyreg&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Queue&lt;/td&gt;
&lt;td&gt;queue&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SocketServer&lt;/td&gt;
&lt;td&gt;socketserver&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;repr&lt;/td&gt;
&lt;td&gt;reprlib&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;






&lt;p&gt;StringIO模块现在被合并到新的io模组内。 new, md5, gopherlib等模块被删除。&lt;/p&gt;
&lt;p&gt;Python 2.6已经支援新的io模组。&lt;/p&gt;
&lt;p&gt;httplib, BaseHTTPServer, CGIHTTPServer, SimpleHTTPServer, Cookie, cookielib被合并到http包内。&lt;/p&gt;
&lt;p&gt;取消了exec语句，只剩下exec()函数。 Python 2.6已经支援exec()函数。&lt;/p&gt;
&lt;h2&gt;10.数据类型&lt;/h2&gt;
&lt;p&gt;py 3.x&lt;/p&gt;
&lt;p&gt;1&amp;gt;去掉了long&lt;/p&gt;
&lt;p&gt;2&amp;gt;新增了bytes类型，对应于2.X版本的八位串&lt;/p&gt;
&lt;p&gt;3&amp;gt;dict的.keys()、.items 和.values()方法返回迭代器，而之前的iterkeys()等函数都被废弃。同时去掉的还有 dict.has_key()，用 in替代它吧 。&lt;/p&gt;
&lt;h2&gt;11.面向对象&lt;/h2&gt;
&lt;p&gt;1&amp;gt;引入抽象基类（Abstraact Base Classes，ABCs）&lt;/p&gt;
&lt;p&gt;2&amp;gt;容器类和迭代器类被ABCs化，所以cellections模块里的类型比Py2.x多了很多&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ee5eaa03-aedb-4278-b077-af4af31c0664')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ee5eaa03-aedb-4278-b077-af4af31c0664&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ee5eaa03-aedb-4278-b077-af4af31c0664&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ee5eaa03-aedb-4278-b077-af4af31c0664',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ee5eaa03-aedb-4278-b077-af4af31c0664&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; collections
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(dir(collections)))
AsyncGenerator
AsyncIterable
AsyncIterator
Awaitable
ByteString
Callable
ChainMap
Collection
Container
Coroutine
Counter
Generator
Hashable
ItemsView
Iterable
Iterator
KeysView
Mapping
MappingView
MutableMapping
MutableSequence
MutableSet
OrderedDict
Reversible
Sequence
Set
Sized
UserDict
UserList
UserString
ValuesView
_Link
_OrderedDictItemsView
_OrderedDictKeysView
_OrderedDictValuesView
&lt;/span&gt;&lt;span&gt;__all__&lt;/span&gt;
&lt;span&gt;__builtins__&lt;/span&gt;
&lt;span&gt;__cached__&lt;/span&gt;
&lt;span&gt;__doc__&lt;/span&gt;
&lt;span&gt;__file__&lt;/span&gt;
&lt;span&gt;__loader__&lt;/span&gt;
&lt;span&gt;__name__&lt;/span&gt;
&lt;span&gt;__package__&lt;/span&gt;
&lt;span&gt;__path__&lt;/span&gt;
&lt;span&gt;__spec__&lt;/span&gt;&lt;span&gt;
_chain
_collections_abc
_count_elements
_eq
_heapq
_iskeyword
_itemgetter
_nt_itemgetters
_proxy
_recursive_repr
_repeat
_starmap
_sys
abc
defaultdict
deque
namedtuple
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3&amp;gt;迭代器的next()方法改名为__next__()，并增加内置函数next()，用以调用迭代器的__next__()方法 &lt;/p&gt;
&lt;p&gt;4&amp;gt;增加了@abstractmethod和 @abstractproperty两个 decorator，编写抽象方法（属性）更加方便。&lt;/p&gt;
&lt;h2&gt;12.模块&lt;/h2&gt;
&lt;p&gt;1&amp;gt;移除了cPickle模块，可以使用pickle模块代替。最终我们将会有一个透明高效的模块。 &lt;/p&gt;
&lt;p&gt;2&amp;gt;移除了imageop模块 &lt;/p&gt;
&lt;p&gt;3&amp;gt;移除了 audiodev, Bastion, bsddb185, exceptions, linuxaudiodev, md5, MimeWriter, mimify, popen2,  rexec, sets, sha, stringold, strop, sunaudiodev, timing和xmllib模块 &lt;/p&gt;
&lt;p&gt;4&amp;gt;移除了bsddb模块(单独发布，可以从http://www.jcea.es/programacion/pybsddb.htm获取&lt;/p&gt;
&lt;p&gt;5&amp;gt;移除了new模块 &lt;/p&gt;
&lt;p&gt;6&amp;gt;os.tmpnam()和os.tmpfile()函数被移动到tmpfile模块下 &lt;/p&gt;
&lt;p&gt;7&amp;gt;tokenize模块现在使用bytes工作。主要的入口点不再是generate_tokens，而是 tokenize.tokenize() &lt;/p&gt;

</description>
<pubDate>Sat, 13 Jan 2018 06:52:00 +0000</pubDate>
<dc:creator>王延领</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kmonkeywyl/p/8279128.html</dc:identifier>
</item>
<item>
<title>大话python模块与包 - 古墓派掌门</title>
<link>http://www.cnblogs.com/qflyue/p/8277591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qflyue/p/8277591.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　眼看着老掌门年纪越来越大，掌门之位的传承也成了门派中的一件大事。这天，老掌门把小掌门叫到跟前，语重心长地说道：孩子啊，以后你就要继任掌门之位了，我就传授此生所学的绝世功法与你，以后可要悉心学习，潜心修炼。藏经洞便是功法所在之处，今日你去取了便是。小掌门听完这内心可犯了嘀咕，藏经洞他可是去过，里面的书籍千千万还乱成一团。在这些书堆中找出一两本功法无异于大海捞针啊。“这次对于藏经洞整改也是交给你的任务，门派历史悠久，教派文化源远流长，自从上次“万教论道“后，藏经洞内的摆放也是乱作一窝粥，这次书籍的整理问题就交给你了” 老掌门对小掌门微微一笑，转身回屋了。&lt;/p&gt;
&lt;h2&gt;模块与包&lt;/h2&gt;
&lt;p&gt;　　这下小掌门可犯了难，漫漫书洞浩如烟海，整理起来又岂非易事，于是小掌门去找门派扫地僧去寻求帮助。“老朽且教你一招，此招名为白夜飞花，精于此功可夜行如白昼，落叶飞花信手拈来。不过此功也有冒险之处，你可知那缥缈峰的傻姑，其名原为傻秋，早些年因此功走火入魔，这个稍后再细说，下面就说说精要。”扫地僧收起扫帚灿灿笑道。&lt;/p&gt;
&lt;h3&gt;什么是模块&lt;/h3&gt;
&lt;p&gt;　　&quot;老掌门分给你的任务是整理书籍,首先你就得对这些书籍进行分类汇总。在藏经洞中你可以用书架或者木盒，把每一类的书籍给装起来，这个书架或者木盒就好比于那些苦逼的程序员所用的模块，一般他们所说的模块包括为四类：”&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 使用python编写的代码（.py文件）

　　&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 已被编译为共享库或DLL的C或C++&lt;span&gt;扩展

　　&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; 包好一组模块的包

　　&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 使用C编写并链接到python解释器的内置模块
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而你的木盒或者书架，就可以分为内功心法，功法，炼丹要术，医药典籍等等。对于模块来说，其目的就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
随着程序的发展，功能越来越多，为了方便管理，我们通常将程序分成一个个的文件，这样做程序的结构更清晰，方便管理。这时我们不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现了功能的重复利用，
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这木盒或书架的作用就是方便管理了，扫地僧煞有介事地说道。&lt;/p&gt;
&lt;h3&gt;模块的使用&lt;/h3&gt;
&lt;p&gt;　　“对于书架或者木盒如何操作，那些苦逼程序员的做法也很值得我们借鉴。对于模块使用他们可有一套流程。这你得给老朽沏壶好茶与你慢慢细说”扫地僧捋起长须笑道。&lt;/p&gt;
&lt;h4&gt;　　import&lt;/h4&gt;
&lt;p&gt;　　我就给先你说说&lt;span&gt;import &lt;span&gt; 一般程序中导入包可这样引用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　示例文件目录（&lt;span&gt;&lt;strong&gt;tips：情景描述，实际开发时文件夹or文件名尽量不要用中文&lt;/strong&gt;&lt;/span&gt;）：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180112182508176-119802737.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('88e7b500-1f5a-401a-8ba9-b510c6e73bc6')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_88e7b500-1f5a-401a-8ba9-b510c6e73bc6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_88e7b500-1f5a-401a-8ba9-b510c6e73bc6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('88e7b500-1f5a-401a-8ba9-b510c6e73bc6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_88e7b500-1f5a-401a-8ba9-b510c6e73bc6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def func():
    print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;欲练此功，必先...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;python之禅.py文件内容&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;模块的引入：import xxx    or   from  xxx  import   xxx&lt;/p&gt;
&lt;p&gt;如我们在&lt;span&gt;修炼.py&lt;/span&gt;中导入“python之禅”模块，&quot;修炼.py&quot;内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import python之禅
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; python之禅.func()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行，如下效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180112183558191-1505365283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同时，我们还可以对导入模块进行重命名，如下&lt;/p&gt;
&lt;h4&gt;import   as&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import python之禅 &lt;span&gt;as&lt;/span&gt; gumupai #import xxx &lt;span&gt;as&lt;/span&gt;&lt;span&gt; 重命名

gumupai.func()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如上&lt;/p&gt;
&lt;p&gt;也可以导入多个文件，import 模块1，模块2，模块3...&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import python之禅,玉笛清心咒,炼火诀

gumupai.func()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;from ... import ...&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
对比import python之禅，会将源文件的名称空间&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python之禅&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;带到当前名称空间中，使用时必须是&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python之禅.名字&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;的方式

而from 语句相当于import，也会创建新的名称空间，但是将&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python之禅&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;中的名字直接导入到当前的名称空间中，在当前名称空间中，直接使用名字就可以了
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; python之禅 import func
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; func()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;from ... import *&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　from python之禅 import * 把python之禅中所有的不是以下划线(_)开头的名字都导入到当前位置，大部分情况下我们的python程序不应该使用这种导入方式，因为*你不知道你导入什么名字，很有可能会覆盖掉你之前已经定义的名字。而且可读性极其的差，在交互式环境中导入时没有问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 我们先修改 'python之禅.py' 内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0d65e255-6072-49c7-8495-24ab6344e84a')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_0d65e255-6072-49c7-8495-24ab6344e84a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0d65e255-6072-49c7-8495-24ab6344e84a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0d65e255-6072-49c7-8495-24ab6344e84a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0d65e255-6072-49c7-8495-24ab6344e84a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; surprise=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;恭喜获得python传承&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;def my_fun():
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;大道至简&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;def func():
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;欲练此功，必先...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;python之禅内容&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;'修炼.py' 内容如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; python之禅 import *
&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;func()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; print(surprise)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180112190736926-1672154102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在python之禅中新增一行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
__all__=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;my_fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]#这样在另外一个文件中用from python.之禅 import *就这能导入列表中规定的两个名字
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180112191245207-531483480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果在   'python之禅.py'   中的变量或者函数名加上_,则 from python之禅  import * 时不能被导入&lt;/p&gt;

&lt;h4&gt;把模块当作脚本执行&lt;/h4&gt;
&lt;p&gt;我们可以通过模块的全局变量__name__来查看模块名：&lt;br/&gt;当做脚本运行：&lt;br/&gt;__name__ 等于'__main__'&lt;/p&gt;
&lt;p&gt;当做模块导入：&lt;br/&gt;__name__= 模块名&lt;/p&gt;
&lt;p&gt;作用：用来控制.py文件在不同的应用场景下执行不同的逻辑&lt;br/&gt;if __name__ == '__main__':&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; python之禅 import *

&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    func()
    my_fun()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;模块搜索路径&lt;/h4&gt;
&lt;p&gt;python解释器在启动时会自动加载一些模块，可以使用sys.modules查看&lt;/p&gt;
&lt;p&gt;在第一次导入某个模块时（比如my_module），会先检查该模块是否已经被加载到内存中（当前执行文件的名称空间对应的内存），如果有则直接引用&lt;/p&gt;
&lt;p&gt;如果没有，解释器则会查找同名的内建模块，如果还没有找到就从sys.path给出的目录列表中依次寻找my_module.py文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以总结模块的查找顺序是：内存中已经加载的模块-&amp;gt;内置模块-&amp;gt;sys.path路径中包含的模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sys.path的初始化的值来自于：&lt;/p&gt;
&lt;p&gt;The directory containing the input script (or the current directory when no file is specified).&lt;br/&gt;PYTHONPATH (a list of directory names, with the same syntax as the shell variable PATH).&lt;br/&gt;The installation-dependent default.&lt;/p&gt;
&lt;p&gt;需要特别注意的是：我们自定义的模块名不应该与系统内置模块重名。虽然每次都说，但是仍然会有人不停的犯错。 &lt;/p&gt;
&lt;p&gt;在初始化后，python程序可以修改sys.path,路径放到前面的优先于标准库被加载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; import sys
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; sys.path.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/a/b/c/d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; sys.path.insert(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/x/y/z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) #排在前的目录，优先被搜索
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：搜索时按照sys.path中从左到右的顺序查找，位于前的优先被查找，sys.path中还可能包含.zip归档文件和.egg文件，python会把.zip归档文件当成一个目录去处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#首先制作归档文件：zip module.zip foo.py bar.py

import sys
sys.path.append(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;module.zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
import foo,bar

#也可以使用zip中目录结构的具体位置
sys.path.append(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;module.zip/lib/python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

#windows下的路径不加r开头，会语法错误
sys.path.insert(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\PycharmProjects\a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于.egg文件是由setuptools创建的包，这是按照第三方python库和扩展时使用的一种常见格式，.egg文件实际上只是添加了额外元数据(如版本号，依赖项等)的.zip文件。&lt;/p&gt;
&lt;p&gt;需要强调的一点是：只能从.zip文件中导入.py，.pyc等文件。使用C编写的共享库和扩展块无法直接从.zip文件中加载（此时setuptools等打包系统有时能提供一种规避方法），且从.zip中加载文件不会创建.pyc或者.pyo文件，因此一定要事先创建他们，来避免加载模块是性能下降。&lt;/p&gt;

&lt;p&gt;以下是官网解释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;当一个命名为my_module的模块被导入时
    解释器首先会从内建模块中寻找该名字
    找不到，则去sys.path中找该名字

sys.path从以下位置初始化
执行文件所在的当前目录
PTYHONPATH（包含一系列目录名，与shell变量PATH语法一样）
依赖安装时默认指定的

注意：在支持软连接的文件系统中，执行脚本所在的目录是在软连接之后被计算的，换句话说，包含软连接的目录不会被添加到模块的搜索路径中

在初始化后，我们也可以在python程序中修改sys.path,执行文件所在的路径默认是sys.path的第一个目录，在所有标准库路径的前面。这意味着，当前目录是优先于标准库目录的，需要强调的是：我们自定义的模块名不要跟python标准库的模块名重复，除非你是故意的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 关于包&lt;/h3&gt;
&lt;p&gt;“咦，前辈，你不是教我招式给我出主意的吗，怎么给我聊起凡间那些程序员了”，小掌门嘀咕着。“别急别急，等我讲完包，你的问题也就解决了”扫地僧闻了闻茶笑着道&lt;/p&gt;
&lt;p&gt;“你的书架或者包是相当于模块，而包就相当于模块或者包所在的区域，老朽就接着以包来给你讲”&lt;/p&gt;
&lt;p&gt;&lt;span&gt;包是一种通过使用‘.模块名’来组织python模块名称空间的方式。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 一、无论是import形式还是from...import形式，凡是在导入语句中（而不是在使用时）遇到带点的，都要第一时间提高警觉：这是关于包才有的导入语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 二、包是目录级的（文件夹级），文件夹是用来组成py文件（包的本质就是一个包含__init__.py文件的目录）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 三、mport导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的__init__.py，导入包本质就是在导入该文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强调：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. 在python3中，即使包下没有__init__.py文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import 包报错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. 创建包的目的不是为了运行，而是被导入使用，记住，包只是模块的一种形式而已，包即模块&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不管是哪种方式，只要是第一次导入包或者是包的任何其他部分，都会依次执行包下的__init__.py文件(我们可以在每个包的文件内都打印一行内容来验证一下)，这个文件可以为空，但是也可以存放一些初始化包的代码。&lt;/p&gt;
&lt;p&gt;现在我们修改下文件结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180113140514926-1221831637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c1002ff6-6433-418b-9269-03462464d432')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_c1002ff6-6433-418b-9269-03462464d432&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c1002ff6-6433-418b-9269-03462464d432&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c1002ff6-6433-418b-9269-03462464d432',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c1002ff6-6433-418b-9269-03462464d432&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; 内功心法 import  python之禅
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    python之禅.func()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     python之禅.my_fun()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;练习.py内容&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f03d5f5b-0da9-4819-84f3-a7f4f0112513')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_f03d5f5b-0da9-4819-84f3-a7f4f0112513&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f03d5f5b-0da9-4819-84f3-a7f4f0112513&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f03d5f5b-0da9-4819-84f3-a7f4f0112513',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f03d5f5b-0da9-4819-84f3-a7f4f0112513&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; . import  内功心法
print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;武学精要的init&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;武学精要/__init__.py&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cbd65539-a361-4f5e-a34f-f52b4238ecd1')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_cbd65539-a361-4f5e-a34f-f52b4238ecd1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cbd65539-a361-4f5e-a34f-f52b4238ecd1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cbd65539-a361-4f5e-a34f-f52b4238ecd1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cbd65539-a361-4f5e-a34f-f52b4238ecd1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; . import python之禅
print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内功心法的init&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;内功心法/__init__.py&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;运行&quot;练习.py&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180113141025097-884776841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上方__init__.py中，用到了from . import xxx  ，下面接着说相对导入与绝对导入&lt;/p&gt;
&lt;h4&gt;相对导入与绝对导入&lt;/h4&gt;

&lt;p&gt;绝对导入：以工作目录（武学精要）作为起始&lt;/p&gt;
&lt;p&gt;相对导入：用.或者..的方式最为起始（只能在一个包中使用，不能用于不同目录内）&lt;/p&gt;
&lt;p&gt;我们用到的from . import 内功心法  其实就是相对导入&lt;/p&gt;
&lt;p&gt;再说绝对导入，我们修改下__init__.py文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4281d78f-3a1e-4de6-9ccd-28005cfe1330')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_4281d78f-3a1e-4de6-9ccd-28005cfe1330&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4281d78f-3a1e-4de6-9ccd-28005cfe1330&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4281d78f-3a1e-4de6-9ccd-28005cfe1330',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4281d78f-3a1e-4de6-9ccd-28005cfe1330&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; 武学精要 import  内功心法
print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;武学精要的init&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;武学精要/__init__.py&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f0071464-bac1-46a2-b780-90b796fe1c8e')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_f0071464-bac1-46a2-b780-90b796fe1c8e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f0071464-bac1-46a2-b780-90b796fe1c8e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f0071464-bac1-46a2-b780-90b796fe1c8e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f0071464-bac1-46a2-b780-90b796fe1c8e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; 武学精要.内功心法 import python之禅
print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内功心法的init&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;内功心法/__init__.py&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;运行“练习.py”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180113141811988-240285750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 注意：在使用pycharm时，有的情况会为你多做一些事情，这是软件相关的东西，会影响你对模块导入的理解，因而在测试时，一定要回到命令行去执行，模拟我们生产环境，你总不能拿着pycharm去上线代码吧！！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;特别需要注意的是：可以用import导入内置或者第三方模块（已经在sys.path中），但是要绝对避免使用import来导入自定义包的子模块(没有在sys.path中)，应该使用from... import ...的绝对或者相对导入,且包的相对导入只能用from的形式。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;软件开发流程规范&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;“行了，模块与包老朽也算给你简单地讲完了，你的书应该知道怎么处理了吧。”扫地僧面带醉意地伸了个懒腰。“先附上一般门派套路，夜晚到我房间来教你白夜飞花”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180113143514363-1980131920.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; “老朽刚用通天境看了看你的下次轮回，应该是个苦逼的码农，自求多福吧”老朽要去扫院子了&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jan 2018 06:39:00 +0000</pubDate>
<dc:creator>古墓派掌门</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qflyue/p/8277591.html</dc:identifier>
</item>
<item>
<title>Android查缺补漏（View篇）--自定义View利器Canvas和Paint详解 - codingblock</title>
<link>http://www.cnblogs.com/codingblock/p/8227598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingblock/p/8227598.html</guid>
<description>&lt;p&gt;上篇文章介绍了自定义View的创建流程，从宏观上给出了一个自定义View的创建步骤，本篇是上一篇文章的延续，介绍了自定义View中两个必不可少的工具Canvas和Paint，从细节上更进一步的讲解自定义View的详细绘制方法。如果把自定义View比作盖一座房子，那么上篇文章就相当于教会了我们怎么一步步的搭建房子的骨架，而本篇文章将要教会我们的是为房子的骨架添砖加瓦直至成型，甚至是怎么装修。&lt;/p&gt;
&lt;h2 id=&quot;canvas&quot;&gt;Canvas&lt;/h2&gt;
&lt;p&gt;为了后文更为方便的讲解Canvas的常用方法的使用，我们先来做一些准备工作，创建一个自定义View框架，先初始化一下Paint画笔，并设置相关方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StudyView extends View {

    private Paint mPaint;
    private Context mContext;

    public StudyView(Context context) {
        super(context);
        init(context);
    }

    public StudyView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    private void init(Context context) {
        mContext = context;
        mPaint = new Paint();
        mPaint.setAntiAlias(true); // 消除锯齿
        mPaint.setStrokeWidth(5); // 设置笔尖宽度
        mPaint.setStyle(Paint.Style.STROKE); // 不填充
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;绘制圆弧和扇形&quot;&gt;绘制圆弧和扇形&lt;/h3&gt;
&lt;p&gt;Canvas提供drawArc()方法，通过传递不同的参数可用来绘制圆弧和扇形，此方法有两个重载方法，详细参数如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;left：扇形或圆弧所占区域的左边界线x坐标&lt;/li&gt;
&lt;li&gt;top：扇形或圆弧所占区域的上边界线y坐标&lt;/li&gt;
&lt;li&gt;right：右边界线x坐标&lt;/li&gt;
&lt;li&gt;bottom：下边界线y坐标&lt;/li&gt;
&lt;li&gt;startAngle：扇形或圆弧的起始角度&lt;/li&gt;
&lt;li&gt;sweepAngle：扫过的角度&lt;/li&gt;
&lt;li&gt;userCenter：此参数可以理解为true就是画扇形，false就是画圆弧&lt;/li&gt;
&lt;li&gt;paint：画笔&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此方法第一个参数是一个RectF类，也是边界，就是把一个方法的left，top，right，bottom封装到了RectF类中，剩余参数与上一个方法一致。&lt;/p&gt;
&lt;p&gt;接下来用着两个重载方法分别绘制两个90°的扇形和两个90°的圆弧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    // 绘制扇形
    canvas.drawArc(0, 0, 200, 200, 0, 90, true, mPaint);
    RectF rectF = new RectF(0, 0, 200, 200);
    canvas.drawArc(rectF, 180, 90, true, mPaint);

    // 绘制圆弧
    canvas.drawArc(300, 0, 500, 200, 0, 90, false, mPaint);
    RectF rectF1 = new RectF(300, 0, 500, 200);
    canvas.drawArc(rectF1, 180, 90, false, mPaint);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;绘制效果如下图所示，另外需要说明的一点是，drawArc的第五个参数startAngle中的角度，0°是指坐标系中第四象限中与x重合的角度，顺时针方向代表角度增大的方向，如下图中红色线条所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107111902831-580150495.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;绘制bitmap&quot;&gt;绘制Bitmap&lt;/h3&gt;
&lt;p&gt;在Canvas中提供了drawBitmap方法，此方法可以让我们直接获取一张图片绘制到画布上，有了它可以让我们的自定义View锦上添花，同时也让我们实现一些复杂效果有了一个更加方便的途径。下面是drawBitmap的几个比较常用的重载方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;drawBitmap(Bitmap bitmap, float left, float top, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;bitmap：Bitmap资源文件&lt;/li&gt;
&lt;li&gt;left和top：代表了图片左上角落入的位置坐标。&lt;/li&gt;
&lt;li&gt;top：看2&lt;/li&gt;
&lt;li&gt;paint：画笔&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;src：在Bitmap图片上截取一部分作为绘制源，可null&lt;/li&gt;
&lt;li&gt;det：将绘制目标拉伸平铺到det指定的矩形中&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;drawBitmap(Bitmap bitmap, Rect src, RectF dst, Paint paint)&lt;br/&gt;同第二个重载方法，几乎一毛一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;matrix：Matrix的参数传入是的drawBitmap功能变得异常强大，让此方法有意思了许多，通过matrix可以实现图片的平移(postTranslate())、缩放(postScale())、旋转(postRotate())、错切(postSkew())等等花式炫酷效果，由于Matrix的用法稍微多一些，篇幅限制，这里就先一带而过了，感兴趣的朋友可以自行探索。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在onDraw方法中drawBitmap的以上重载方法，注意在使用完Bitmap之后记得用Bitmap.recycle()来回收掉资源，以防止oom。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/** drawBitmap */
Bitmap bitmap = BitmapFactory.decodeResource(mContext.getResources(), android.R.mipmap.sym_def_app_icon);
// 绘制图片
canvas.drawBitmap(bitmap, 0, 300, null);
// 将图片拉伸平铺在RectF矩形内
canvas.drawBitmap(bitmap, null, new RectF(200, 300, 500, 500), null);
// 截取图片的四分之一拉伸平铺在RectF矩形内
canvas.drawBitmap(bitmap, new Rect(0, 0, bitmap.getWidth()/2, bitmap.getHeight()/2), new RectF(500, 300, 800, 500), null);

Matrix matrix = new Matrix();
matrix.postTranslate(800, 300); // 将bitmap平移到此位置
canvas.drawBitmap(bitmap, matrix, mPaint);

// 为防止oom，及时回收bitmap
bitmap.recycle();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下图（红框内）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107111926956-851207336.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;绘制圆形&quot;&gt;绘制圆形&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;drawCircle(float cx, float cy, float radius, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;cx：圆心x坐标&lt;/li&gt;
&lt;li&gt;cy：圆心y坐标&lt;/li&gt;
&lt;li&gt;radius：半径&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;canvas.drawCircle(100, 700, 100, mPaint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107111941378-1054281930.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;绘制点&quot;&gt;绘制点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;drawPoint(float x, float y, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;x：点的x坐标&lt;/li&gt;
&lt;li&gt;y：点的y坐标&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;drawPoints(float[] pts, Paint paint) 绘制一组点&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;pts：float数组，两位为一组，两两结合代表x、y坐标，例如：pts[0]、pts[1]代表第一个点的x、y坐标，pts[2]、pts[3]代表第二个点的x、y坐标，依次类推。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;drawPoints(float[] pts, int offset, int count, Paint paint) 绘制一组点&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;pts：float数组，两位为一组，两两结合代表x、y坐标，例如：pts[0]、pts[1]代表第一个点的x、y坐标，pts[2]、pts[3]代表第二个点的x、y坐标，依次类推。&lt;/li&gt;
&lt;li&gt;offset：代表数组开始跳过几个只开始绘制点，注意这里不是指数组的下标，而是代表跳过几个值。&lt;/li&gt;
&lt;li&gt;count：在跳过offset个值后，处理几个值，注意这里的count不是代表点的个数，而是代表数组中值的个数。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;canvas.drawPoint(100, 700, mPaint); // 绘制一个点

float[] points = new float[] {
    130, 700,
    160, 700,
    190, 700,
    210, 700,
    240, 700
};

canvas.drawPoints(points, 2, 4, mPaint); // 绘制一组点（代表跳过前两个值，处理4个值，也就是实际绘制2个点）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107111956112-1764327689.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;绘制椭圆&quot;&gt;绘制椭圆&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;drawOval(float left, float top, float right, float bottom, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;left&lt;/li&gt;
&lt;li&gt;top&lt;/li&gt;
&lt;li&gt;right&lt;/li&gt;
&lt;li&gt;bottom&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在left、top、right、bottom围成的区域内绘制一个椭圆。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;drawOval(RectF oval, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;将第一个重载方法的left、top、right、bottom封装到RectF类中，与扇形的重载方法异曲同工。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;RectF rectF2 = new RectF(300, 600, 700, 800); // 创建一个RectF
canvas.drawOval(rectF2, mPaint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107112010674-1577315955.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;绘制矩形&quot;&gt;绘制矩形&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;drawRect(float left, float top, float right, float bottom, Paint paint)&lt;/li&gt;
&lt;li&gt;drawRect(Rect r, Paint paint)&lt;/li&gt;
&lt;li&gt;drawRect(RectF rect, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;drawRect的参数非常好理解，这里就不啰嗦了，直接上代码看效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;canvas.drawRect(rectF2, mPaint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：这里的rectF2即上文绘制椭圆时创建的RectF对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107112024268-293048520.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;绘制圆角矩形&quot;&gt;绘制圆角矩形&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)&lt;/li&gt;
&lt;li&gt;drawRoundRect(RectF rect, float rx, float ry, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;drawRoundRect是绘制圆角矩形，用法和drawRect类似，唯一不同的是多了两个参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;rx：x轴方向的圆角弧度&lt;/li&gt;
&lt;li&gt;ry：y轴方向的圆角弧度&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上代码，看效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;canvas.drawRoundRect(rectF2, 60, 30, mPaint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里为了突出两个方向的圆角弧度，特地将rx和ry设置差距比较大，效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107112043284-856130574.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;绘制直线&quot;&gt;绘制直线&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;drawLine(float startX, float startY, float stopX, float stopY, Paint paint)&lt;/li&gt;
&lt;li&gt;drawLines(float[] pts, int offset, int count, Paint paint)&lt;/li&gt;
&lt;li&gt;drawLines(float[] pts, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;drawLine和drawLines一个是绘制一个点，一个是绘制一组点，其中drawLines中的float数组中四个值为一组点，其用法可以参照drawPoints。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;canvas.drawLine(100, 820, 800, 820, mPaint);

float[] lines = new float[]{
        100f, 850f, 800f, 850f,
        100f, 900f, 800f, 900f,
        100f, 950f, 800f, 950f
};
canvas.drawLines(lines, mPaint); // 按floats数组中，四个数为1组，绘制多条线&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107112106049-1751643241.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;drawpath-绘制不规则图形&quot;&gt;drawPath() 绘制不规则图形&lt;/h3&gt;
&lt;p&gt;上面的这些Canvas方法固然已经很强大了，但是我们如果想要绘制一些不规则的图形怎么办，这时候就要用到强大的drawPath()方法了，通过对Path进行设置不同的坐标、添加不同图形，最后传入drawPath方法中可以绘制出复杂的且不规则的形状。以下是drawPath的方法及参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;drawPath(Path path, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里的关键参数就是Path，Path类的方法较多，大部分用法类似，这里挑几个说一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;addArc(RectF oval, float startAngle, float sweepAngle) 往path里面添加一个圆弧&lt;/li&gt;
&lt;li&gt;addCircle(float x, float y, float radius, Path.Direction dir) 添加一个圆形&lt;/li&gt;
&lt;li&gt;addOval(RectF oval, Path.Direction dir) 添加一个椭圆&lt;/li&gt;
&lt;li&gt;addRect(RectF rect, Path.Direction dir) 添加一个矩形&lt;/li&gt;
&lt;li&gt;lineTo(float x, float y) 连线到坐标（x，y）&lt;/li&gt;
&lt;li&gt;moveTo(float x, float y) 将path绘制点移动到坐标（x，y）&lt;/li&gt;
&lt;li&gt;close() 用直线闭合图形，调用此方法后，path会将最后一处点与起始用直线连接起来，path起始点为moveTo()方法的坐标上，如果没有调用moveTo()起始点将默认为（0，0）坐标。&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来使用drawPath绘制一个楼梯：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 使用 Path 绘制一个楼梯
Path path = new Path();
path.lineTo(0, 1000);
path.lineTo(100, 1000);
path.lineTo(100, 1100);
path.lineTo(200, 1100);
path.lineTo(200, 1200);
path.lineTo(300, 1200);
path.lineTo(300, 1300);
path.lineTo(400, 1300);
path.lineTo(400, 1400);
path.lineTo(0, 1400);
path.lineTo(0, 1000);
path.close();
canvas.drawPath(path, mPaint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107112120815-1573771669.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再用drawPath方法绘制一个Android小机器人：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/ 使用 Path 绘制一个Android机器人
// 绘制两个触角
path.reset();
path.moveTo(625, 1050);
path.lineTo(650, 1120);
path.moveTo(775, 1050);
path.lineTo(750, 1120);

path.addArc(new RectF(600, 1100, 800, 1300), 180, 180); // 绘制头部
path.addCircle(666.66f, 1150, 10, Path.Direction.CW); // 绘制眼睛，CW：顺时针绘制， CCW：逆时针绘制
path.addCircle(733.33f, 1150, 10, Path.Direction.CW);
path.addRect(new RectF(600, 1200, 800, 1300), Path.Direction.CW);  // 身体
canvas.drawPath(path, mPaint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107112134049-911945217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，上文中Canvas示例的全部代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StudyView extends View {

    private Paint mPaint;
    private Context mContext;

    public StudyView(Context context) {
        super(context);
        init(context);
    }

    public StudyView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    private void init(Context context) {
        mContext = context;
        mPaint = new Paint();
        mPaint.setAntiAlias(true); // 消除锯齿
        mPaint.setStrokeWidth(5); // 设置笔尖宽度
        mPaint.setStyle(Paint.Style.STROKE); // 不填充
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        /** 1、drawArc */

        // 绘制扇形
        canvas.drawArc(0, 0, 200, 200, 0, 90, true, mPaint);
        RectF rectF = new RectF(0, 0, 200, 200);
        canvas.drawArc(rectF, 180, 90, true, mPaint);

        // 绘制圆弧
        canvas.drawArc(300, 0, 500, 200, 0, 90, false, mPaint);
        RectF rectF1 = new RectF(300, 0, 500, 200);
        canvas.drawArc(rectF1, 180, 90, false, mPaint);

        /** 2、drawBitmap */
        Bitmap bitmap = BitmapFactory.decodeResource(mContext.getResources(), android.R.mipmap.sym_def_app_icon);
        // 绘制图片
        canvas.drawBitmap(bitmap, 0, 300, null);
        // 将图片拉伸平铺在RectF矩形内
        canvas.drawBitmap(bitmap, null, new RectF(200, 300, 500, 500), null);
        // 截取图片的四分之一拉伸平铺在RectF矩形内
        canvas.drawBitmap(bitmap, new Rect(0, 0, bitmap.getWidth()/2, bitmap.getHeight()/2), new RectF(500, 300, 800, 500), null);

        Matrix matrix = new Matrix();
        matrix.postTranslate(800, 300); // 将bitmap平移到此位置
        canvas.drawBitmap(bitmap, matrix, mPaint);

        // 为防止oom，及时回收bitmap
        bitmap.recycle();

        /** 3、drawCircle */
        canvas.drawCircle(100, 700, 100, mPaint);

        /** 4、绘制一个点 */
        canvas.drawPoint(100, 700, mPaint); // 绘制一个点

        float[] points = new float[] {
            130, 700,
            160, 700,
            190, 700,
            210, 700,
            240, 700
        };

        canvas.drawPoints(points, 2, 4, mPaint); // 绘制一组点（代表跳过前两个值，处理4个值，也就是实际绘制2个点）


        RectF rectF2 = new RectF(300, 600, 700, 800); // 创建一个RectF

        /** 5、drawOval 绘制椭圆 */
        canvas.drawOval(rectF2, mPaint);

        /** 6、drawRect 绘制矩形*/
        canvas.drawRect(rectF2, mPaint);
        canvas.drawRoundRect(rectF2, 60, 30, mPaint);

        /** 7、drawLine */
        canvas.drawLine(100, 820, 800, 820, mPaint);

        float[] lines = new float[]{
                100f, 850f, 800f, 850f,
                100f, 900f, 800f, 900f,
                100f, 950f, 800f, 950f
        };
        canvas.drawLines(lines, mPaint); // 按floats数组中，四个数为1组，绘制多条线


        /** 8、drawPath */

        // 使用 Path 绘制一个楼梯
        Path path = new Path();
        path.moveTo(0, 1000);
        path.lineTo(100, 1000);
        path.lineTo(100, 1100);
        path.lineTo(200, 1100);
        path.lineTo(200, 1200);
        path.lineTo(300, 1200);
        path.lineTo(300, 1300);
        path.lineTo(400, 1300);
        path.lineTo(400, 1400);
        path.close();
        canvas.drawPath(path, mPaint);

        // 使用 Path 绘制一个Android机器人

        // 绘制两个触角
        path.reset();
        path.moveTo(625, 1050);
        path.lineTo(650, 1120);
        path.moveTo(775, 1050);
        path.lineTo(750, 1120);

        path.addArc(new RectF(600, 1100, 800, 1300), 180, 180); // 绘制头部
        path.addCircle(666.66f, 1150, 10, Path.Direction.CW); // 绘制眼睛，CW：顺时针绘制， CCW：逆时针绘制
        path.addCircle(733.33f, 1150, 10, Path.Direction.CW);
        path.addRect(new RectF(600, 1200, 800, 1300), Path.Direction.CW);  // 身体
        canvas.drawPath(path, mPaint);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107112155737-1370141604.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实Canvas除了可以绘制图形之外，还可以绘制文字，Canvas的绘制文字的方法有drawText()、drawTextOnPath()、drawTextRun()等方法，在绘制文字是和Paint的结合更为紧密，所以讲绘制文字的方法放在下文和Paint一起讲可能效果会更好一些，好了，废话不多说了，接下来咱们就开始Paint的篇章。&lt;/p&gt;
&lt;h2 id=&quot;paint&quot;&gt;Paint&lt;/h2&gt;
&lt;p&gt;为了更为清晰的讲解Paint的用法，先来新建一个自定义类，暂叫PaintStudyView，接下来创建一个它的大体骨架，在此类中定义了一些变量，变量的意义请见注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PaintStudyView extends View {

    private Paint mTextPaint;  // 绘制文字的Paint
    private Paint mPointPaint; // 绘制参考点的Paint
    private Context mContext;

    private final static float Y_SPACE = 100; // y轴方向的间距

    public PaintStudyView(Context context) {
        super(context);
        init(context);
    }

    public PaintStudyView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    private void init(Context context) {
        mContext = context;
        mTextPaint = new Paint();
        mTextPaint.setAntiAlias(true); // 消除锯齿
        mTextPaint.setStrokeWidth(1); // 设置笔尖宽度
        mTextPaint.setStyle(Paint.Style.FILL); // 填充
        mTextPaint.setTextSize(30);

        mPointPaint = new Paint();
        mPointPaint.setAntiAlias(true);
        mPointPaint.setStrokeWidth(5);
        mPointPaint.setColor(Color.RED); // 将参考点的Paint设置为红色
        mPointPaint.setStyle(Paint.Style.STROKE);// 不填充
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;canvas的绘制文字的相关方法&quot;&gt;Canvas的绘制文字的相关方法：&lt;/h3&gt;
&lt;h4 id=&quot;drawtext的重载方法&quot;&gt;drawText()的重载方法&lt;/h4&gt;
&lt;p&gt;drawText() 是Canvas的绘制文字中的最长用的方法，它只能按照从左至右的普通方式来绘制文字。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;drawText(String text, float x, float y, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;text：待绘制的文字内容&lt;/li&gt;
&lt;li&gt;x：文字绘制位置的x坐标&lt;/li&gt;
&lt;li&gt;y：文字绘制位置的y坐标&lt;/li&gt;
&lt;li&gt;paint：Paint画笔，可以通过Paint.setTextAlign()来决定文字的方位，有：Paint.Align.LEFT（居左），Paint.Align.RIGHT（居右），Paint.Align.CENTER（居中）三个位置。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;drawText(String text, int start, int end, float x, float y, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;start：代表从text中的第几个字符开始截取绘制，包含第start个字符。&lt;/li&gt;
&lt;li&gt;end：代表截取到text的第几个字符，不包含第end个字符。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如：我是一个自定义View的控件，start=1，end=6，截取后为：是一个自定&lt;/p&gt;
&lt;p&gt;下面两个重载方法可以参考第二个很容易就能理解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;drawText(CharSequence text, int start, int end, float x, float y, Paint paint)&lt;/li&gt;
&lt;li&gt;drawText(char[] text, int index, int count, float x, float y, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下示例说明了文字的不同位置，同时也说明了第二个和第四个重载方法对字符串截取时的用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String str = &quot;我是一个自定义View的控件&quot;;// 待绘制文字

float x = getWidth() / 2;
float y = 100;
canvas.drawPoint(x, y, mPointPaint); // 绘制参考点，便于观察文字处于x，y坐标的位置，从而来学习setTextAlign()方法

mTextPaint.setTextAlign(Paint.Align.LEFT);
canvas.drawText(str, x, y, mTextPaint);

y += Y_SPACE;
canvas.drawPoint(x, y, mPointPaint);
mTextPaint.setTextAlign(Paint.Align.RIGHT);
canvas.drawText(str, 0, 6, x, y, mTextPaint);

y += Y_SPACE;
canvas.drawPoint(x, y, mPointPaint);
mTextPaint.setTextAlign(Paint.Align.CENTER);
canvas.drawText(str.toCharArray(), 1, 6, x, y, mTextPaint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107112234003-610724951.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的红点为额外添加的参考坐标，目的是为了突出setTextAlign中参数的位置。&lt;/p&gt;
&lt;h4 id=&quot;drawtextonpath的重载方法&quot;&gt;drawTextOnPath()的重载方法&lt;/h4&gt;
&lt;p&gt;drawTextOnPath() 由方法名字我们就可以看出来他可以按照Path的走向来绘制文字，例如我们在path中传入一个圆弧，那么绘制出来的文字走向就是圆弧状的，是不是很酷，来看一下它的重载方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;drawTextOnPath(String text, Path path, float hOffset, float vOffset, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;text：同drawText的第一个参数。&lt;/li&gt;
&lt;li&gt;path：Path参数，用法在前文已经说过了。&lt;/li&gt;
&lt;li&gt;hOffset：水平方向的偏移量。&lt;/li&gt;
&lt;li&gt;vOffset：垂直方向的偏移量。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关键点：有一点一定要提的就是，这里的hOffset是相对于path路径的水平偏移量，而vOffset也是相对于path路径的垂直偏移量，这么说可能还有点不清楚，结合下面的示例来说明，请仔细体会这里的意思：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 1、下开口圆弧方向绘制文字
mTextPaint.setTextAlign(Paint.Align.LEFT);
y += Y_SPACE;
Path path = new Path();
path.addArc(new RectF(x - 150, y, x + 150, y + 300), 180,180);
canvas.drawPath(path, mPointPaint); // 参考弧度线
canvas.drawTextOnPath(str, path, 0, 0, mTextPaint); // 按照path路径绘制文字，不偏移
canvas.drawTextOnPath(str, path, 30, 30, mTextPaint);// 向水平、垂直方向各偏移30
canvas.drawTextOnPath(str, path, 60, 60, mTextPaint);// 向水平、垂直方向各偏移60

// 2、上开口圆弧方向绘制文字
path.reset();
y += Y_SPACE;
path.addArc(new RectF(x - 150, y, x + 150, y + 300), 0, 180);
canvas.drawPath(path, mPointPaint); // 参考弧度线
canvas.drawTextOnPath(str, path, 0, 0, mTextPaint);
canvas.drawTextOnPath(str, path, 30, 30, mTextPaint);
canvas.drawTextOnPath(str, path, 60, 60, mTextPaint);
path.close();

// 3、竖直方向绘制文字
path.reset();
path.moveTo(200, y);
path.lineTo(200, y + 4 * Y_SPACE);
canvas.drawPath(path, mPointPaint); // 参考弧度线
canvas.drawTextOnPath(str, path, 0, 0, mTextPaint);
canvas.drawTextOnPath(str, path, 30, 60, mTextPaint);


y += Y_SPACE;
y += Y_SPACE;
y += Y_SPACE;
y += Y_SPACE;

// 4、水平方向绘制文字
path.reset();
path.moveTo(x, y);
path.lineTo(x + 4 * Y_SPACE, y);
canvas.drawPath(path, mPointPaint); // 参考弧度线
canvas.drawTextOnPath(str, path, 0, 0, mTextPaint);
canvas.drawTextOnPath(str, path, 30, 60, mTextPaint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下是效果图，注意看图片中的红色部分，红色的线是用代码绘制出来的path参考线，红色的箭头是path的水平和垂直方向的走向，结合下图可以更好的理解drawTextOnPath的hOffset和vOffset参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107112249924-1669813015.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;drawTextOnPath(char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个方法的套路想必不用解释了。&lt;/p&gt;
&lt;h4 id=&quot;drawtextrun的重载方法&quot;&gt;drawTextRun()的重载方法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;drawTextRun(char[] text, int index, int count, int contextIndex, int contextCount, float x, float y, boolean isRtl, Paint paint)&lt;/li&gt;
&lt;li&gt;drawTextRun(CharSequence text, int start, int end, int contextStart, int contextEnd, float x, float y, boolean isRtl, Paint paint)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;drawTextRun()可以文字的是从左到右还是从右到左的顺序来绘制，其中倒数第二个参数isRtl就是用来控制方向的，true就是倒序绘制，false就是正序绘制，其他的参数就没啥好说的了，这个方法用法比较简单，这里就不贴代码了。另外这个方法是在API 23才开始添加的，使用时要注意。&lt;/p&gt;
&lt;p&gt;到目前为止，Canvas的常用用法基本介绍完了，接下来就可以着重来看Paint的使用了，Paint和Canvas两者是不可分离的，两者协作，相辅相成。所以在下面的用法示例中不免要用到Canvas的相关方法。&lt;/p&gt;
&lt;h3 id=&quot;使用paint测量文字的尺寸定位文字&quot;&gt;使用Paint测量文字的尺寸，定位文字&lt;/h3&gt;
&lt;p&gt;我们在开发自定义控件时，免不了要精确定位文字的文字，例如必须把文字放在某个区域的正中间，或者必须让一行文字的几何中心精确的处于某个点上，这时我们如果不懂这里的窍门可能就要盲目的试位置了，这样一点一点试出来的位置很不可靠，可能换个屏幕尺寸位置就不对了，接下来怎么来看看怎么样用最优雅的姿势来精确的定位文字。&lt;/p&gt;
&lt;p&gt;其实在水平方向的定位还比较好说，直接使用Paint.setTextAlign()就能搞定大多需求，主要是在水平方向上稍稍复杂一点，想要定位位置，首先需要先获取文字的高度，要用到Paint的以下两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;float ascent()：根据文字大小获取文字顶端到文字基线的距离（返回的是负值）&lt;/li&gt;
&lt;li&gt;float descent()：根据文字大小获取文字底部到文字基线的距离（返回的事正值）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了这两个方法那就非常好办了，首先用代码结合效果图说明一下基线、ascent、descent和文字的关系：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;y += Y_SPACE;
canvas.drawPoint(x, y, mPointPaint);
canvas.drawLine(x - 300, y, x+300, y, mPointPaint);
mTextPaint.setTextAlign(Paint.Align.CENTER);// 水平方向上让文字居中
float ascent = mTextPaint.ascent(); // 根据文字大小获取文字顶端到文字基线的距离（返回的是负值）
float descent = mTextPaint.descent(); // 根据文字大小获取文字底部到文字基线的距离（返回的事正值）
canvas.drawLine(x - 300, y + ascent, x+300, y + ascent, mPointPaint);
canvas.drawLine(x - 300, y + descent, x+300, y + descent, mPointPaint);
canvas.drawText(str, x, y, mTextPaint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图如下，它们之间的关系注意看图片里面的说明。（注：在这里感谢园友在截图中指出的一处错误，现已修正）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180113150459051-867666708.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就让文字的中心落在参考点上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 将文字的中心定位在参考点上
y += Y_SPACE;
canvas.drawPoint(x, y, mPointPaint);
canvas.drawText(str, x, y - ascent / 2 - descent / 2, mTextPaint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图如下，仔细看参考点（红点）和文字的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107112324081-288733932.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;利用paint.setshader着色器绘制渐变色&quot;&gt;利用Paint.setShader()（着色器）绘制渐变色&lt;/h3&gt;
&lt;p&gt;使用 setShader() 方法可以添加渐变颜色也可以使用图片作为背景，其参数是一个Shader类，传入不同的Shader子类可以实现不同的渐变效果或者添加背景图片，其子类有一下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LinearGradient：线性渐变&lt;/li&gt;
&lt;li&gt;RadialGradient：放射状渐变&lt;/li&gt;
&lt;li&gt;SweepGradient：扫描渐变&lt;/li&gt;
&lt;li&gt;BitmapShader：添加背景图片&lt;/li&gt;
&lt;li&gt;ComposeShader：多种Shader组合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面接个Shader的子类在使用方式上都差不多，这里只用LinearGradient为例说明一下，并注意对LinearGradient构造器的最后一个参数传入不同的参数对应的效果图：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* Shader 渐变 */
y = 100;
Shader shader = new LinearGradient(x - 50, y - 80, x + 50, y + 80,
        Color.parseColor(&quot;#FFCCBB&quot;), Color.parseColor(&quot;#FF0000&quot;), Shader.TileMode.CLAMP);
mTextPaint.setShader(shader);
canvas.drawRect(x - 500, y - 80, x + 500, y + 80, mTextPaint);

y += 3 * Y_SPACE;
Shader shader1 = new LinearGradient(x - 50, y - 80, x + 50, y + 80,
        Color.parseColor(&quot;#FFCCBB&quot;), Color.parseColor(&quot;#FF0000&quot;), Shader.TileMode.REPEAT);
mTextPaint.setShader(shader1);
canvas.drawRect(x - 500, y - 80, x + 500, y + 80, mTextPaint);

y += 3 * Y_SPACE;
Shader shader2 = new LinearGradient(x - 50, y - 80, x + 50, y + 80,
        Color.parseColor(&quot;#FFCCBB&quot;), Color.parseColor(&quot;#FF0000&quot;), Shader.TileMode.MIRROR);
mTextPaint.setShader(shader2);
canvas.drawRect(x - 500, y - 80, x + 500, y + 80, mTextPaint);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201801/776965-20180107112337753-550382048.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了以上这些，Paint的用法还有很多很多，一时半会也列不完，博主在这也只能抛砖引玉，感兴趣的朋友可查看官方API自行探索。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;最后想说的是，本系列文章为博主对Android知识进行再次梳理，查缺补漏的学习过程，一方面是对自己遗忘的东西加以复习重新掌握，另一方面相信在重新学习的过程中定会有巨大的新收获，如果你也有跟我同样的想法，不妨关注我一起学习，互相探讨，共同进步！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参考文献：&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jan 2018 06:08:00 +0000</pubDate>
<dc:creator>codingblock</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingblock/p/8227598.html</dc:identifier>
</item>
<item>
<title>AI时代：推荐引擎正在塑造人类 - CaiYongji</title>
<link>http://www.cnblogs.com/takeurhand/p/8278936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takeurhand/p/8278936.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;We shape our tools and afterwards our tools shape us. ------Marshall McLuhan&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;麦克卢汉说：“我们塑造了工具，反过来工具也在塑造我们。”&lt;/p&gt;
&lt;p&gt;我本人不反感AI，也相信人工智能会开创一个伟大的时代，但是我们要思考一些东西，至少知道那是什么。本人旨在让你了解当前人工智能应用最普遍的&lt;strong&gt;智能推荐引擎&lt;/strong&gt;（Intelligent Recommendation Engine），其背后的设计理念，以及一些更深度的思考。关于理念，它不像技术要求太多的基础，我尽量不使用专业术语，所以本文同样适合程序员以外群体。&lt;/p&gt;

&lt;p&gt;以大家熟悉的分类信息网为例，像58同城、赶集网。网站把现实生活中的商品、服务进行分类进行展示，比如房产、二手车、家政服务等。这些内容即是现实世界对应的抽象，我们可以很容易的找到对应关系。&lt;/p&gt;
&lt;p&gt;我们再以求职网站为例，像智联招聘、BOSS直聘。网站按照职业把 人分类，比如程序员、厨师、设计师、数学家、物理学家等。&lt;/p&gt;
&lt;p&gt;那么现在问题出现了，众所周知，人工智能的完美入门人才是&lt;strong&gt;具有数学和计算机双学位的硕士以上学历人才&lt;/strong&gt;。那么，我们如何把这样的人分类呢？我们无法单一的将其归入到程序员或者数学家，我们无法为每一个这样的复合型人（slash）进行单独分类。&lt;/p&gt;
&lt;p&gt;分类产生矛盾。&lt;/p&gt;
&lt;p&gt;我们区分南方人、北方人，所以有地域歧视。我们区分亚洲人、欧洲人，所以有种族歧视。“分类”只是人类简化问题逻辑的手段，薛定谔的猫和罗素的理发师已经证明了“分类”并不正确。所以在大计算时代，我们引入“贴标签”的概念。&lt;/p&gt;

&lt;p&gt;AI时代是计算能力爆炸增长所带来的。在强大的计算能力面前，我们真的可以针对每个人进行“分类”，它的表现形式就是---&lt;strong&gt;贴标签&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;30岁以下、程序员、屌丝、奶爸、熬夜、不爱运动、公众号叫caiyongji、格子衬衫、机械键盘、牛仔裤……这些可以是一个程序员的标签。换个角度，“类别”反转过来服务于单独的某个人，这是在计算能力短缺的时代所无法想象的。&lt;/p&gt;
&lt;p&gt;传统的智能推荐引擎对用户进行多维度的数据采集、数据过滤、数据分析，然后建模，而人工智能时代的推荐引擎在建立模型步骤中加入Training the models（训练、测试、验证）。&lt;/p&gt;
&lt;p&gt;最后，推荐引擎就可以根据用户标签的权重（可以理解为对标签的打分，表示侧重点），对用户进行精准推送了。&lt;/p&gt;

&lt;p&gt;俗话是这么说的“旱的旱死，涝的涝死”，“饱汉子不知饿汉子饥”，不知道这些俗语我用的恰当不恰当。我的意思是在智能引擎的推荐下，会加强属性两极分化。&lt;/p&gt;
&lt;p&gt;我们以程序员为例，选取编程技巧、打游戏、体育运动、熬夜、看书五个维度。经过推荐引擎的“塑造”后如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/678094/201801/678094-20180113132618816-749262879.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前，推荐引擎的算法会将权重比较大的标签进行优先推广，这就导致原本权重大的标签得到更多的曝光次数，最终使得权重大的标签权重越来越大，而权重小的标签在长时间的被忽略状态下逐渐趋近于零。&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;波兹曼认为，媒体能够以一种隐蔽却强大的暗示力量来“定义现实世界”。其中媒体的形式极为重要，因为特定的形式会偏好某种特殊的内容，最终会塑造整个文化的特征。这就是所谓“媒体即隐喻”的主要涵义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于“推荐”机制的属性分化，那些高技术含量的、专业的、科学的、真正对人又帮助的信息被更少的人接触，而那些简单的、轻松的、娱乐的、裸露的、粗俗的信息被越来越多的人接触。&lt;/p&gt;
&lt;p&gt;我们看一下具有影响力的百度、今日头条和微博在今天(2018年1月13日10:04:xx)所推荐的内容。我删除了cookie，使用匿名session，移除我的“标签”。也就是说，下图所推荐内容对大部分人适用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/678094/201801/678094-20180113132629191-1551297369.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要你好奇点击，你的&lt;strong&gt;tittytainment&lt;/strong&gt;（我翻译成“愚乐”，那个三俗的译法不要再传了）属性权重就会越来越大。娱乐新闻点击过百万，科普文章点击不过百，这种现象正是推荐引擎的行为引导导致的。&lt;/p&gt;
&lt;p&gt;不客气的说，百度、今日头条、微博对国民素质的影响是有责任的。&lt;/p&gt;

&lt;p&gt;对于你从来都没思考过的事物，你可能永远都接触不到，因为你不知道求索的路径，所以有的人每个月都读与自己专业无关的书，来扩展自己的知识面。我们举个例子：&lt;/p&gt;
&lt;p&gt;你可能会在网上搜索&lt;code&gt;如何与女朋友和谐相处&lt;/code&gt;但你未必会搜索&lt;code&gt;如何让女朋友们和谐相处&lt;/code&gt;，有人笑谈“贫穷限制了我的想象力”，其实不然，是你接收不到&lt;strong&gt;无关&lt;/strong&gt;的推荐，你才被限制在特定的知识圈子里。&lt;/p&gt;
&lt;p&gt;所以我提出无关推荐这个概念。&lt;/p&gt;
&lt;p&gt;对程序员进行画像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/678094/201801/678094-20180113132635535-509477912.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，当某个标签没有到达“程序员”的路径时，他可能永远无法触及那个标签。这时，我们推荐“无关”信息给用户，强制产生路径。&lt;/p&gt;
&lt;p&gt;你可能会质疑，这是随机强制推荐垃圾信息吗？&lt;/p&gt;
&lt;p&gt;其实不然，通过深度学习，我们可以进行大量的数据收集、数据分析和模型训练，我们是可以找到对某个&lt;strong&gt;个体无关&lt;/strong&gt;，但会让其感兴趣信息的&lt;strong&gt;兴趣点&lt;/strong&gt;。这种信息就是无关推荐的&lt;strong&gt;解&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;你每天接收到的“推荐”背后是各个团队经过心理学研究、行为学研究、大量计算设计的，人们正在失去深度思考、自主判断的能力。对于进步青年、斜杠青年请保持思考。谨以此文献给希望进步的你，希望你有所收获和思考。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文欢迎注明出处的转载，但微信转载请联系公众号: caiyongji进行授权转载。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jan 2018 05:27:00 +0000</pubDate>
<dc:creator>CaiYongji</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takeurhand/p/8278936.html</dc:identifier>
</item>
<item>
<title>【推荐】拆解分析测试流程 - 资深Tester_王豆豆</title>
<link>http://www.cnblogs.com/evangline/p/8278869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evangline/p/8278869.html</guid>
<description>
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;与一些刚入行的测试人员接触时，发现他们对测试的认识不够，总是认为测试只是一个点、点的过程，认为测试也总是在界面上点，点的过程，我只想说“测试看似简单，但实则深不可测”，接下来就讲讲测试过程主要是做什么？&lt;/p&gt;
&lt;p&gt; 
&lt;hr/&gt;
    &lt;/p&gt;
&lt;p&gt;测试主要做什么？这完全都体现在测试流程中，同时测试流程是面试问题中出现频率最高的，这不仅是因为测试流程很重要，而是在面试过程中这短短的半小时到一个小时的时间，通过测试流程就可以判断出应聘者是否做过软件测试，以及能了解到应聘者在流程中承担的职责，故在测试流程中包含了测试工作的核心内容 ，例如需求分析，测试用例的设计，测试执行，缺陷等重要的过程。下面就以迭代测试为例，给大家画下测试流程图：&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/128111/201801/128111-20180113124411551-802339119.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;1.需求分析&lt;/h3&gt;
&lt;p&gt;一般在上一个迭代测试即将完成之时，下一个迭代的需求文档就已经发出来，放到配置管理平台，便于测试和开发自取，那这个时候一般测试人员就会自动去取需求文档，开始做需求分析，需求分析主要是分析接下来的需求，从功能交互，测试要点等方面入手分析。&lt;/p&gt;
&lt;p&gt;需求分析完成之后，就会开始需求评审。&lt;/p&gt;

&lt;h3&gt;2.编写测试用例&lt;/h3&gt;
&lt;p&gt;需求评审完成之后，对测试而言，应该还需要编写测试计划和测试方案，一般测试计划是由测试主管编写，测试方案是高级测试工程师编写，故有些测试人员并不会要求编写，但是测试用例却是每个测试人员都需求编写的，一般测试用例我们主要用到的都是黑盒用例设计方法，如等价类分析法，边界值分析法，因果图，判定表，场景法，状态迁移，错误推测法等等，根据自己熟悉的方法和需求文档来设计测试用例。&lt;/p&gt;
&lt;p&gt;测试用例编写完成后，测试人员就要开始用例评审，用例评审与需求评审的评审流程相同，只是发起人和评审内容，评审重点不同。&lt;/p&gt;
&lt;h3&gt;3.测试执行&lt;/h3&gt;
&lt;p&gt;一般用例评审完成之后，就要开始等待开发转测。&lt;/p&gt;
&lt;p&gt;转测成功后，测试这边就要开始搭建测试环境，然后进行冒烟测试，冒烟测试通过后才开始进入正式测试执行阶段。&lt;/p&gt;
&lt;p&gt;1.冒烟测试的重点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原来版本的主要功能&lt;/li&gt;
&lt;li&gt;新需求的主要功能主要流程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.提交缺陷&lt;/p&gt;
&lt;p&gt;     在正式测试阶段，测试人员是根据已经编写好的测试用例执行程序，当执行程序的实际结果与测试用例的预期结果不符时，就需要在缺陷管理工具上提交bug单，bug单会根据bug处理流程进行处理。&lt;/p&gt;
&lt;p&gt;3.回归测试&lt;/p&gt;
&lt;p&gt;   当开发人员修改了大部分bug时，开发人员会再次合版，联调，转测，这时测试人员就会进入到回归测试阶段。&lt;/p&gt;
&lt;p&gt;回归测试的重点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查bug单上的缺陷是否被修复OK&lt;/li&gt;
&lt;li&gt;检查在修改bug的时候是否引入新的bug&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;6.部署上线/交付&lt;/h3&gt;
&lt;p&gt;当测试执行阶段根据测试标准中的出口准则，结束测试活动，如果测试结果是OK的，这时运维人员就可以开始部署上线，或者进行版本交付。&lt;/p&gt;

&lt;p&gt;上面的测试流程是基于有需求文档的一个完整测试流程，如果公司没有需求文档，则测试流程就会在上面的基础上有所删减。&lt;/p&gt;

&lt;p&gt;欢迎关注王豆豆的微信公众号：资深Tester，了解更多好文，和王豆豆一起成长。。。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jan 2018 04:57:00 +0000</pubDate>
<dc:creator>资深Tester_王豆豆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evangline/p/8278869.html</dc:identifier>
</item>
<item>
<title>跟我一起读postgresql源码(九)——Executor(查询执行模块之——Scan节点(上)) - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/8137720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/8137720.html</guid>
<description>&lt;p&gt;从前面介绍的可优化语句处理相关的背景知识、实现思想和执行流程，不难发现可优化语句执行的核心内容是对于各种计划节点的处理，由于使用了节点表示、递归调用、统一接口等设计，计划节点的功能相对独立、代码总体流程相似，下面介绍执行器中各种计划节点的相关执行过程。&lt;/p&gt;
&lt;p&gt;在PostgreSQL中，计划节点分为四类，分别是控制节点（Control Node)、扫描节点（ScanNode),物化节点（Materialization Node)、连接节点（Join Node) 。&lt;/p&gt;
&lt;ul readability=&quot;4.3623529411765&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;控制节点：是一类用于处理特殊情况的节点，用于实现特殊的执行流程。例如，Result节点可用来表示INSERT语句中VALUES子句指定的将要插人的元组。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;扫描节点：顾名思义，此类节点用于扫描表等对象以从中获取元组。例如，SeqScan节点用于顺序扫描一个表.毎次扫描一个元组。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.8792569659443&quot;&gt;
&lt;p&gt;物化节点：这类节点种类比较复杂，但它们有一个共同特点，即能够缓存执行结果到辅助存储中。物化节点会在第一次被执行时生成其中的所有结果元组，然后将这些结果元组缓存起来，等待其上层节点取用；而非物化节点则是每次被执行时生成一个结果元组并返回给上层节点。例如，Sort节点能够获取下层节点返回的所有元组并根据指定的属性进行排序，并将排序结果全部缓存起来，每次上层节点从Sort节点取元组时就从缓存中按顺序返回下一个元组(见&lt;a href=&quot;http://www.cnblogs.com/flying-tiger/p/8120046.html&quot;&gt;Postgres中的物化节点之sort节点&lt;/a&gt;)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;连接节点：此类节点对应于关系代数中的连接操作，可以实现多种连接方式（条件连接、左连接、右连接、全连接、自然连接等），每种节点实现一种连接算法。例如，HashJoin实现了基于Hash的连接箅法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扫描节点的作用是扫描表，每次获取一条元组作为上层节点的输入。扫描节点普遍存在于查询计划树的叶子节点，它不仅可以扫描表，还可以扫描函数的结果集、链表结构、子查询结果集等。&lt;/p&gt;
&lt;p&gt;所有扫描节点都使用Scan作为公共父类，Scan不仅继承了Plan的所有属性，还扩展定义了scanrelid用于记录被扫描的表在范围表中的序号。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct Scan
{
    Plan        plan;
    Index       scanrelid;      /* relid is index into the range table */
} Scan;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扫描节点的执行状态节点都以ScanState作为公共父类，ScanState除了继承PlanState的所有属性之外，还扩展定义了ss_currentScanDesc(记录扫描的位置、关系等信息），currentRelation(记录被扫描的关系)和ss_ScanTupleSlot(记录扫描到的结果）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct ScanState
{
    PlanState   ps;             /* its first field is NodeTag */
    Relation    ss_currentRelation;
    HeapScanDesc ss_currentScanDesc;
    TupleTableSlot *ss_ScanTupleSlot;
} ScanState;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是来自源码中的所有的Scan类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    T_SeqScanState,
    T_SampleScanState,
    T_IndexScanState,
    T_IndexOnlyScanState,
    T_BitmapIndexScanState,
    T_BitmapHeapScanState,
    T_TidScanState,
    T_SubqueryScanState,
    T_FunctionScanState,
    T_ValuesScanState,
    T_CteScanState,
    T_WorkTableScanState,
    T_ForeignScanState,
    T_CustomScanState,&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面将对其一一说明。&lt;/p&gt;
&lt;p&gt;扫描节点有各自的执行函数，但是这些执行函数都由公共的执行函数ExecScan来实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TupleTableSlot *
ExecScan(ScanState *node,
         ExecScanAccessMtd accessMtd,   /* function returning a tuple */
         ExecScanRecheckMtd recheckMtd)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ExecScan需要三个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态节点ScanState，&lt;/li&gt;
&lt;li&gt;获取扫描元组的函数指针(accessMtd,由于每一种扫描节点扫描的对象不同，因此函数都不同)，&lt;/li&gt;
&lt;li&gt;判断元组是否满足符合过滤条件的函数指针(recheckMtd)。这个要说一下：&lt;strong&gt;这个函数用于并发控制，如果当前元组被其他事物修改并已提交，需要检测该元组是否仍然满足选择条件。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ExecScan迭代地扫描对象，每次执行返回一条结果(内部返回元组是通过ExecScanFetch实现的)。ExecScan会使用accessMtd获取元组，然后recheckMtd进行过滤条件判断，最终返回元组。&lt;/p&gt;
&lt;p&gt;看例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;EXPLAIN SELECT * FROM tenk1 WHERE unique1 &amp;lt; 100;  
  
                                  QUERY PLAN  
------------------------------------------------------------------------------  
 Bitmap Heap Scan on tenk1  (cost=5.07..229.20 rows=101 width=244)  
   Recheck Cond: (unique1 &amp;lt; 100)                  &amp;lt;---recheckMtd 的作用
   -&amp;gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0)  
         Index Cond: (unique1 &amp;lt; 100&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;seqscan-节点&quot;&gt;1.SeqScan 节点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;SeqScan是最基本的扫描节点，它用于扫描物理表，完成没有索引辅助的顺序扫描过程。其计划节点SeqScan实际是Scan节点的一个别名，并未定义扩展属性。其执行状态节点SeqScanState也直接使用ScanState。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SeqScan节点的初始化由函数ExecInitSeqScan完成。该函数首先创建一个SeqScanState结构，将SeqScan节点链接在SeqScanState结构的&lt;strong&gt;ps&lt;/strong&gt;字段中。然后调用ExecInitExpr对计划节点的目标属性和査询条件进行初始化，并将它们链接到SeqScanState相应的字段中。接下来还将为计划节点分配用于存储结果元组和扫描元组的数据结构。最后通过计划节点中&lt;strong&gt;scanrelid&lt;/strong&gt;字段的信息获取被扫描对象的RelationData结构，并链接在&lt;strong&gt;ss_currentRelation&lt;/strong&gt;字段中，同时利用该信息调用heap_beginscan初始化扫描描述符&lt;strong&gt;ss_currentScanDesc&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;SeqScan节点的执行函数是ExecSeqScan，在该函数中:&lt;/p&gt;
&lt;p&gt;调用ExecScan函数，并将SeqNext函数的指针作为ExecScan函数accessMtd参数的值。并将SeqRecheck函数指针作为ExecScan函数recheckMtd参数的值。SeqNext函数将通过存储模块提供的函数heap_getnext获取下一条元组并返回;&lt;br/&gt;ExecScan在利用SeqNext获得一个元组之后，还将根据计划节点中的査询条件和投影要求对得到的元组进行条件检査和投影操作，最后将满足要求的结果元组返回。这里SeqRecheck其实没做任何处理和判断，因为这个函数不使用heap_beginscan返回的keys(也就是自己去表上找，不受并发的影响。这个后面说)。&lt;/p&gt;
&lt;p&gt;其他扫描节点的执行函数都采用类似的方式管理，即统一调用ExecScan,但根据节点的类型给ExecScan的参数AccessMtd和recheckMtd賦予不同的函数指针。&lt;/p&gt;
&lt;p&gt;SeqScan节点的淸理过程由函数ExecEndSeqScan完成，在该函数中需要额外调用函数heap_endscan来清理ss_currentScanDesc内的信息。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;samplescan节点&quot;&gt;2.SampleScan节点&lt;/h2&gt;
&lt;p&gt;这个是9.5 版本新增的数据取样功能，支持查询返回取样数据。当前只在常规表和物化视图上接受TABLESAMPLE子句。&lt;/p&gt;
&lt;p&gt;语法大概是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT select_list FROM table_name TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE ( seed ) ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用法的话看这里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.postgres.cn/docs/9.5/sql-select.html&quot; class=&quot;uri&quot;&gt;http://www.postgres.cn/docs/9.5/sql-select.html&lt;/a&gt;(使用Sample)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.postgres.cn/docs/9.5/tablesample-method.html&quot; class=&quot;uri&quot;&gt;http://www.postgres.cn/docs/9.5/tablesample-method.html&lt;/a&gt;(自定义Sample函数)&lt;/p&gt;
&lt;p&gt;用白话说就是我对表中符合条件的数据可以进行采样。帮你省了一个抽奖系统，棒棒棒！！(微笑脸)。&lt;/p&gt;
&lt;p&gt;我们看一下节点结构:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct SampleScan
{
    Scan        scan;
    /* use struct pointer to avoid including parsenodes.h here */
    struct TableSampleClause *tablesample;
} SampleScan;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在Scan的基础上加上了TableSample相关的结构，它的数据结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct TableSampleClause
{
    NodeTag     type;
    Oid         tsmhandler;     /* OID of the tablesample handler function */
    List       *args;           /* tablesample argument expression(s) */
    Expr       *repeatable;     /* REPEATABLE expression, or NULL if none */
} TableSampleClause;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;描述SampleScan查询状态的数据结构SampleScanState如下，简单而言，它在ScanState的基础上增加了Sample采样策略，随机种子，采样函数这些和Sample相关的数据。而这些数据就来自于SampleScan节点的TableSampleClause结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct SampleScanState
{
    ScanState   ss;
    List       *args;           /* expr states for TABLESAMPLE params */
    ExprState  *repeatable;     /* expr state for REPEATABLE expr */
    /* use struct pointer to avoid including tsmapi.h here */
    struct TsmRoutine *tsmroutine;      /* descriptor for tablesample method */
    void       *tsm_state;      /* tablesample method can keep state here */
    bool        use_bulkread;   /* use bulkread buffer access strategy? */
    bool        use_pagemode;   /* use page-at-a-time visibility checking? */
    bool        begun;          /* false means need to call BeginSampleScan */
    uint32      seed;           /* random seed */
} SampleScanState;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他的话，诸君请看代码吧~&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;indexscan-节点&quot;&gt;3.IndexScan 节点&lt;/h2&gt;
&lt;p&gt;如果选择条件涉及的属性上建立了索引，则生成的査询计划中涉及表的扫描时会使用IndexScan节点。该节点能够利用索引进行表的扫描以获取满足选择条件的元组。&lt;/p&gt;
&lt;p&gt;IndexScan节点的定义如下面所示。除了继承Scan节点定义的属性外，IndexScan扩展定义了indexid属性（用于存储索引的OID)、indexqual属性（用于存储索引扫描的条件）、indexqualorig属性（用于存储没有处理的原始扫描条件链表以及indexonierdir属性（用于存储扫描的方向）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct IndexScan
{
    Scan        scan;
    Oid         indexid;        /* OID of index to scan */
    List       *indexqual;      /* list of index quals (usually OpExprs) */
    List       *indexqualorig;  /* the same in original form */
    List       *indexorderby;   /* list of index ORDER BY exprs */
    List       *indexorderbyorig;       /* the same in original form */
    List       *indexorderbyops;    /* OIDs of sort ops for ORDER BY exprs */
    ScanDirection indexorderdir;    /* forward or backward or don't care */
} IndexScan;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IndexScan节点的初始化过程由函数ExecInitlndexScan完成。该函数将构造IndexScanState节点，并使用indexid获取索引的RelationData结构存放于iss_RelationDesc字段中。同时，通过调用ExeclndexBuildScanKeys将indexqual中的索引扫描条件转换为扫描关键字（ScanKey，存储扫描满足的条件）以及运行时关键字计算结构（IndexRuntimeKeylnfo，执行时才能得到结果的表达式信息）分别存储在 iss_ScanKeys 和 iss_RuntimeKeys 这两个数组中。iss_NumScanKeys 和 iss_NumRuntimeKeys 则用于指示前面两个数组的长度，同时还要设罝iss_NumRumimeKeys为false。最后将调用索引模块提供的index_beginscan初始化扫描描述符iss_ScanDesc。而索引扫描未经特殊处理的原始约束条件链表则用于构造indexqualorig字段。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct IndexOnlyScanState
{
    ScanState   ss;             /* its first field is NodeTag */
    List       *indexqual;                  execution state for indexqual expressions
    ScanKey     ioss_ScanKeys;              Skey structures for index quals
    int         ioss_NumScanKeys;           number of ScanKeys
    ScanKey     ioss_OrderByKeys;           Skey structures for index ordering operators
    int         ioss_NumOrderByKeys;        number of OrderByKeys
    IndexRuntimeKeyInfo *ioss_RuntimeKeys;  info about Skeys that must be evaluated at runtime
    int         ioss_NumRuntimeKeys;        number of RuntimeKeys
    bool        ioss_RuntimeKeysReady;      true if runtime Skeys have been computed
    ExprContext *ioss_RuntimeContext;       expr context for evaling runtime Skeys
    Relation    ioss_RelationDesc;          index relation descriptor
    IndexScanDesc ioss_ScanDesc;            index scan descriptor
    Buffer      ioss_VMBuffer;              buffer in use for visibility map testing, if any
    long        ioss_HeapFetches;           number of tuples we were forced to fetch from heap
} IndexOnlyScanState;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IndexScan节点的执行过程由ExecIndexScan函数完成，其执行过程同样由ExecScan统一管理，但对IndexScan节点将使用IndexNext函数来获取元组。ExecIndexScan首先判断是否有RuntimeKeys且需要计算（iss_RuntimeKeyReady为false),如果存在则调用ExecIndexReScan函数计算所有的iss_RuntimeKeys表达式，并将其存储到关联的iss_ScanKeys中。接着调用ExecScan通过IndexNext获取元组，在IndexNext中将调用索引模块提供的index_getnext函数利用索引取得元组。&lt;/p&gt;
&lt;p&gt;IndexScan的淸理过程由EndlndexScan函数完成，其中需要回收索引关系描述结构iss_RelationDesc (调用 index_close)和索引扫描描述符 iss_ScanDesc (调用 index_endacan)。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;indexonlyscan节点&quot;&gt;4.IndexOnlyScan节点&lt;/h2&gt;
&lt;p&gt;所谓index only scan ,就是因为建立index时，所包含的字段集合，囊括了我们查询语句中的字段，这样，提取出相应的index ，就不必再次提取数据块了。&lt;/p&gt;
&lt;p&gt;举个例子：对于表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table test(id int, name text, age int);
insert into test select generate_series(1,100000),'test'::text,generate_series(1,100000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们对id和age建立复合索引：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create index test_id_age on test(id ,age);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，执行查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;explain select id, age from test  where id &amp;lt; 20 and age &amp;gt;0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# explain select id ,age from test where id &amp;lt; 20 and age &amp;gt;0;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Index Only Scan using test_id_age on test  (cost=0.29..41.94 rows=20 width=8)
   Index Cond: ((id &amp;lt; 20) AND (age &amp;gt; 0))
(2 rows)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个查询里查询的id和age就在索引test_id_age上，在我们取出索引的时候，我们已经获取了(id，age)值的序列，因此就不必再去表中获取记录了，在Index上我们就获得了我们需要的数据，因此称为Index Only Scan。&lt;/p&gt;
&lt;p&gt;对这个IndexOnlyScan我们可能有疑问，万一我的索引没有及时更新，岂不是会查询出来旧的过时的数据？&lt;br/&gt;对这点不必担心，我们可以看看IndexOnlyScan的执行函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void
ExecReScanIndexOnlyScan(IndexOnlyScanState *node)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它不是单纯地根据节点的类型给ExecScan的参数AccessMtd和recheckMtd賦予不同的函数指针，而是还要：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; *      Recalculates the values of any scan keys whose value depends on
 *      information known at runtime, then rescans the indexed relation.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，我们会先重新扫描获取scan key，然后再拿着这个key去scan。调用路径如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ExecIndexOnlyScan
    --&amp;gt;ExecReScan  * 这里是rescan，更新scan keys
        --&amp;gt;ExecReScanIndexOnlyScan
    
    --&amp;gt;ExecScan ## 用新的scan keys进行Scan&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，IndexOnlyScan不允许Recheck。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static bool
IndexOnlyRecheck(IndexOnlyScanState *node, TupleTableSlot *slot)
{
    elog(ERROR, &quot;EvalPlanQual recheck is not supported in index-only scans&quot;);
    return false;               /* keep compiler quiet */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;bitmapindexscan-节点&quot;&gt;5.BitmapIndexScan 节点&lt;/h2&gt;
&lt;p&gt;BitmapIndexScan节点也是利用属性上的索引进行扫描操作，但是BitmapIndexScan得到的结果不是实际的元组，而是一个位图，该位图标记了满足条件的元组在页面中的偏移量。BitmapIndexScan节点在第一次被执行时就将获取所有满足条件的元组并在位图中标记它们，而其上层节点中都会有特殊的扫描节点（例如下面将介绍的BitmapHeapScan)使用该位图来获取实际的元组。&lt;strong&gt;因此，该扫描方式下不产生实际的元组，也就是说，该节点不出现在ExecProcNode函数的调用中，不是一个独立的执行节点，只被特殊的上层节点调用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;BitmapIndexScan与IndexScan节点定义几乎相同，由于一次返回关于所有的元组的位图，所以不需要记录扫描方向的indexorderdir和indexorderby字段。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct BitmapIndexScan
{
    Scan        scan;
    Oid         indexid;        /* OID of index to scan */
    List       *indexqual;      /* list of index quals (OpExprs) */
    List       *indexqualorig;  /* the same in original form */
} BitmapIndexScan;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其执行状态节点BitmapIndexScanState与IndexScanState也很相似，但多出了表示索引关键字属性数组及其长度的字段。BitmapIndexScan和IndexScan的执行过程也类似，只是在BitmapIndexScan处理过程中，初始化函数ExecInitBitmapIndexScan使用index_beginscan_bitmap函数初始化扫描状态，MultiExecBitmapIndexScan函数将调用index_getbitmap生成位图，并将其存放在执行状态记录节点的&lt;strong&gt;biss_result&lt;/strong&gt;字段中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct BitmapIndexScanState
{
    ScanState   ss;             /* its first field is NodeTag */
    TIDBitmap  *biss_result;                bitmap to return output into, or NULL
    ScanKey     biss_ScanKeys;              Skey structures for index quals
    int         biss_NumScanKeys;           number of ScanKeys
    IndexRuntimeKeyInfo *biss_RuntimeKeys;  info about Skeys that must be evaluated at runtime
    int         biss_NumRuntimeKeys;        number of RuntimeKeys
    IndexArrayKeyInfo *biss_ArrayKeys;      info about Skeys that come from ScalarArrayOpExprs
    int         biss_NumArrayKeys;          number of ArrayKeys
    bool        biss_RuntimeKeysReady;      true if runtime Skeys have been computed
    ExprContext *biss_RuntimeContext;       expr context for evaling runtime Skeys
    Relation    biss_RelationDesc;          index relation descriptor
    IndexScanDesc biss_ScanDesc;            index scan descriptor
} BitmapIndexScanState;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;bitmapheapscan&quot;&gt;6.BitmapHeapScan&lt;/h2&gt;
&lt;p&gt;上面介绍的BitmapIndexScan节点将输出位图而不是元组，为了根据位图获取实际的元组，PostgreSQL提供了BitmapHeapScan节点从BitmapIndexScan输出的位图中获取元组。&lt;/p&gt;
&lt;p&gt;BitmapHeapScan节点定义如下所示，该节点在Scan的基础上仅扩展了约束条件检査字段(bitmapqualorig)，该字段与IndexScan节点的indexqualorig功能相同。当并发事务修改并提交了当前处理的元组时，需要重新扫描更新后的元组是否满足约束条件，而不是重新获取位图，因此将直接使用该表达式进行条件计算。BitmapHeapScan有且仅有一个子节点（左子节点），显然这个左子节点必须是提供位图输出的计划节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct BitmapHeapScan
{
    Scan        scan;
    List       *bitmapqualorig; /* index quals, in standard expr form */
} BitmapHeapScan;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化函数ExecInitBitmapHeapScan会根据节点中的scanrelid初始化扫描描述符ss_currentScanDesc。其他的初始化设置在执行过程中进行。&lt;/p&gt;
&lt;p&gt;执行函数 ExecBitmapHeapScan 会将 BitmapHeapNext 函数指针传递给 ExecScan, ExecScan 使用BitmapHeapNext 获取元组。BitmapHeapNext 首先判断 BitmapHeapScanState 的 tbm (位图)是否为空，如果为空则调用MultiExecProcNode从左子节点获取位图，并调用tbm_begin_iterate初始化tbmiterator。如果需要预取还要调用 tbm_begin_iterate 初始化 prefetch_iterator,并将 prefetch_pages 置 0, prefetch_target设置为-1。然后执行过程会利用tbmiterator遍历位图获取物理元组的偏移量，然后从对应的缓冲区中按照偏移量取出元组并返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct BitmapHeapScanState
{
    ScanState   ss;             /* its first field is NodeTag */
    List       *bitmapqualorig;     execution state for bitmapqualorig expressions
    TIDBitmap  *tbm;                bitmap obtained from child index scan(s)
    TBMIterator *tbmiterator;       iterator for scanning current pages
    TBMIterateResult *tbmres;       current-page data
    long        exact_pages;        total number of exact pages retrieved
    long        lossy_pages;        total number of lossy pages retrieved
    TBMIterator *prefetch_iterator; iterator for prefetching ahead of current page
    int         prefetch_pages;     # pages prefetch iterator is ahead of current
    int         prefetch_target;    target prefetch distance
} BitmapHeapScanState;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清理过程ExecEndBitmapHeapScan需要调用左子节点的清理函数，然后清理tbmiterator、prefetch_iterator以及tbm位图，最后清理扫描描述符并关闭打开的表。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;tidscan-节点&quot;&gt;7.TidScan 节点&lt;/h2&gt;
&lt;p&gt;PostgreSQL系统专用于标识元组物理位置的数据类型被称作TID (Tuple Identifier),一个TID由块号和块内偏移量组成，系统属性ctid被定义为此种类型。&lt;/p&gt;
&lt;p&gt;PostgreSQL 自带的表是堆表，数据按行存储在HEAP PAGE中，在btree索引中，除了存储字段的value，还会存储对应的ctid(即行号)，检索记录也是通过行号进行检索。 因此通过行号是可以快速检索到记录的。&lt;/p&gt;
&lt;p&gt;行号的写法是(page_number, item_number)，数据块从0开始编号，行号从1开始编号。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# select ctid ,* from zxc;
 ctid  | id |   name
-------+----+----------
 (0,4) |  1 | asdftest
 (0,5) |  3 | asdftest
 (0,6) |  9 | asdftest
(3 行)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们可以用ctid来访问数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# select *  from zxc where ctid = '(0,5)'::tid;
 id |   name
----+----------
  3 | asdftest
(1 行)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，在定义游标后，可以使用“UPDATE/DELETE…WHERE CURRENT OF…”语句对当前游标位置的元组进行修改/删除。可以参考这里：[]&lt;a href=&quot;http://www.postgres.cn/docs/9.5/sql-update.html(http://www.postgres.cn/docs/9.5/sql-update.html)&quot; class=&quot;uri&quot;&gt;http://www.postgres.cn/docs/9.5/sql-update.html(http://www.postgres.cn/docs/9.5/sql-update.html)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个时候生成的査询计划树仅包含一个TidScan节点，其扫描的对象是TidScan节点中保存的一个表达式链表，其中存储的表达式可以得到ctid的值，TidScan节点将根据ctid值取得对应的元组。TidScan节点只在Scan节点的基础上扩展了一个字段tidquals用于保存可以得到ctid的表达式链表。&lt;/p&gt;
&lt;p&gt;TidScan 节点的初始化函数 ExecInitTidScan 会根据 tidquals 初始化 TidScanState 中的 tss_tidquals字段，然后调用ExecInitExpr初始化tidquals中的表达式，并根据节点中的scanrelid初始化扫描描述符 ss_currentScanDesc。&lt;/p&gt;
&lt;p&gt;TidScan节点的执行函数（ExecTidScan)也同样调用函数ExecScan来完成执行工作，其中传递给ExecScan函数的指针是TidNext。函数TidNext首先需要通过计算TidScanState节点的tss_tidquals链表中的表达式来构造tss_TidList数组，该数组中存放的是一系列的ctid, tss_NumTidS用于记录数组的长度，tss_TidPtr用于记录当前处理的ctid在tss_TidList数组中的偏移量，初始值设为-1。然后从tss_TidList中获取下一个ctid值，接着调用存储模块提供的heap_fetch根据该ctid获取元组并返回。出于并发的需要，当TidScan节点用于“CURRENTOF&quot;.(游标名）”语句时，获取的ctid可能已经被其他事务修改，需要获取此ctid对应元组的最新版本(利用HOT链)，然后再调用heap_fetch进行获取。&lt;/p&gt;
&lt;p&gt;清理过程ExecEndTidScan不需要特殊的操作，直接释放相关内存上下文和初始化时分配的空间。&lt;/p&gt;
&lt;p&gt;大约还剩下7个Scan方法，下篇再说~&lt;/p&gt;
</description>
<pubDate>Sat, 13 Jan 2018 03:40:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/8137720.html</dc:identifier>
</item>
<item>
<title>OLEDB数据源 - GunLun</title>
<link>http://www.cnblogs.com/lanuage/p/8278087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lanuage/p/8278087.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: OLEDB数据源&lt;br/&gt;date: 2018-01-12 21:42:37&lt;br/&gt;tags: [OLEDB, 数据库编程, VC++, 数据库]&lt;br/&gt;categories: windows 数据库编程&lt;br/&gt;keywords: OLEDB, 数据库编程, VC++, 数据库&lt;br/&gt;---&lt;br/&gt;数据源在oledb中指数据提供者，这里可以简单的理解为数据库程序。数据源对象代表数据库的一个连接，是需要创建的第一个对象。而数据源对象主要用于配置数据库连接的相关属性如连接数据库的用户名密码等等&lt;/p&gt;&lt;p&gt;数据源主要完成的功能如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进行数据库身份认证&lt;/li&gt;
&lt;li&gt;为每个连接准备对应的资源，如对应的数据缓冲，网络连接资源&lt;/li&gt;
&lt;li&gt;设置连接属性，给访问者何种权限，设置连接的超时值等等，对象会根据对应的属性打开对应的接口。它的这些设置都是通过属性进行的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OLEDB虽然是基于COM的一组接口，但是它与标准的COM接口有点不同，它的一大特色在于它自身的属性设置，有的接口虽然对象中存在但是调用QueryInterface是查询不出来的，只有设置相应的接口才会打开，有的接口可以根据属性值表现不同的行为。比如设置了对应的只读属性则不允许使用更新接口。&lt;br/&gt;每个属性都有值、类型、说明和读写属性，对于行集对象，还有一个用于指示是否可以逐列应用它的指示器。&lt;br/&gt;属性由一个GUID和一个整数ID进行唯一标识。&lt;br/&gt;属性集是所有具有相同 组GUID 的一组属性。在逻辑上它们都用于同一种功能，比如有的属性集用于设置数据源连接属性，有的用于设置行集属性等等。它们是应用在同一个特定对象上的一组属性。在每个这样的属性组中都有属性每个属性属于一个或者多个属性组。&lt;br/&gt;属性定义如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; tagDBPROP {
   DBPROPID        dwPropertyID; &lt;span class=&quot;co&quot;&gt;//属性GUID&lt;/span&gt;
   DBPROPOPTIONS   dwOptions; &lt;span class=&quot;co&quot;&gt;//属性的操作方式&lt;/span&gt;
   DBPROPSTATUS    dwStatus; &lt;span class=&quot;co&quot;&gt;//属性设置状态&lt;/span&gt;
   DBID            colid; &lt;span class=&quot;co&quot;&gt;//属性ID，一般给DB_NULLID&lt;/span&gt;
   VARIANT         vValue; &lt;span class=&quot;co&quot;&gt;//属性值&lt;/span&gt;
} DBPROP;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dwOptions:属性的操作方式有3种，但是一般只使用其中的两种：DBPROPOPTIONS_REQUIRED表示必须设置成功，如果设置失败，则设置属性的操作失败，DBPROPOPTIONS_OPTIONAL，表示可选，即即使该属性设置失败，设置属性的操作也返回成功。DBPROPOPTIONS_SETIFCHEAP表示如果在设置属性操作时在在dwStatus参数中返回该属性设置的状态，是否成功，失败的原因等等。&lt;br/&gt;属性集的定义如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; tagDBPROPSET {
   DBPROP *   rgProperties; &lt;span class=&quot;co&quot;&gt;//属性数组的指针&lt;/span&gt;
   ULONG      cProperties; &lt;span class=&quot;co&quot;&gt;//属性数组中元素个数&lt;/span&gt;
   GUID       guidPropertySet; &lt;span class=&quot;co&quot;&gt;//属性集的GUID&lt;/span&gt;
} DBPROPSET;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目前属性组包括初始化属性组、数据源属性组、会话属性组、行集属性组、表属性组和列属性组等等。&lt;br/&gt;设置属性一般包含如下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分配一个属性类型DBPRO的数组，一般倾向于多分配一个，最后一个数组元素全0，作为结尾&lt;/li&gt;
&lt;li&gt;确定每个属性的属性GUID，即明确我们需要设置的是对象的哪个属性&lt;/li&gt;
&lt;li&gt;填充对应的属性值，属性操作方式&lt;/li&gt;
&lt;li&gt;填充对应的属性集DBPROPSET结构。设置该属性集的GUID&lt;/li&gt;
&lt;li&gt;调用对应的接口设置属性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据源对象的接口定义如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;CoType TDataSource {
   [mandatory]   interface IDBCreateSession; &lt;span class=&quot;co&quot;&gt;//创建回话对象&lt;/span&gt;
   [mandatory]   interface IDBInitialize; &lt;span class=&quot;co&quot;&gt;//创建数据源连接对象&lt;/span&gt;
   [mandatory]   interface IDBProperties; &lt;span class=&quot;co&quot;&gt;///&lt;/span&gt;创建数据源的属性操作对象
   [mandatory]   interface IPersist;
   [optional]    interface IConnectionPointContainer;
   [optional]    interface IDBAsynchStatus;
   [optional]    interface IDBDataSourceAdmin;
   [optional]    interface IDBInfo;
   [optional]    interface IObjectAccessControl;
   [optional]    interface IPersistFile;
   [optional]    interface ISecurityInfo;
   [optional]    interface ISupportErrorInfo;
   [optional]    interface ITrusteeAdmin;
   [optional]    interface ITrusteeGroupAdmin;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面代码中，mandatory表示是数据源必须提供的接口，optional表示的是可选性提供的接口，在创建对应的接口时尽量使用必须实现的接口，如果需要使用可选择的接口，一定要判断数据源是否支持。在数据源对象中最主要的还是前三个必须提供的接口&lt;/p&gt;

&lt;p&gt;连接到数据源一般使用IDBInitialize接口的Initialize方法，但是生成IDBInitialize接口有几种不同的方式，下面一一列举出来&lt;/p&gt;
&lt;h2 id=&quot;直接创建idbinitialize接口&quot;&gt;直接创建IDBInitialize接口&lt;/h2&gt;
&lt;p&gt;这种方式一般调用CoCreateInstance函数创建，下面是具体的代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;tchar.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;windows.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;strsafe.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define COM_NO_WINDOWS_H    &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//如果已经包含了Windows.h或不使用其他Windows库函数时&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define OLEDBVER 0x0260     &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//MSDAC2.6版&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;oledb.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;oledberr.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define GRS_ALLOC(sz)       HeapAlloc(GetProcessHeap(),0,sz)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_CALLOC(sz)      HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sz)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_SAFEFREE(p)     if(NULL != p){HeapFree(GetProcessHeap(),0,p);p=NULL;}&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define GRS_USEPRINTF() TCHAR pBuf[1024] = {}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//定义输出宏&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_PRINTF(...) &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    GRS_USEPRINTF();&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    StringCchPrintf(pBuf,1024,__VA_ARGS__);&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),pBuf,lstrlen(pBuf),NULL,NULL);&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//安全释放，为了养成良好的编码习惯，特作此宏定义&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_SAFERELEASE(I)&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    if(NULL != (I))&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    {&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        (I)-&amp;gt;Release();&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        (I)=NULL;&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//检测上一步的操作是否成功&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_COM_CHECK(hr,...)&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    if(FAILED(hr))&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    {&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        GRS_PRINTF(__VA_ARGS__);&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        goto CLEAR_UP;&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    }&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; _tmain(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, TCHAR* argv[])
{
    CoInitialize(NULL);
    &lt;span class=&quot;co&quot;&gt;//创建OLEDB init接口&lt;/span&gt;
    IDBInitialize *pDBInit = NULL;
    IDBProperties *pIDBProperties = NULL;
    &lt;span class=&quot;co&quot;&gt;//设置链接属性&lt;/span&gt;
    DBPROPSET dbPropset[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};
    DBPROP dbProps[&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;] = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};
    CLSID clsid_MSDASQL = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;}; &lt;span class=&quot;co&quot;&gt;//sql server 的数据源对象&lt;/span&gt;
    
    HRESULT hRes = CLSIDFromProgID(_T(&lt;span class=&quot;st&quot;&gt;&quot;SQLOLEDB&quot;&lt;/span&gt;), &amp;amp;clsid_MSDASQL);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;获取SQLOLEDB的CLSID失败，错误码：0x&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = CoCreateInstance(clsid_MSDASQL, NULL, CLSCTX_INPROC_SERVER, IID_IDBInitialize,(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pDBInit);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;无法创建IDBInitialize接口，错误码：0x&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    &lt;span class=&quot;co&quot;&gt;//指定数据库实例名，这里使用了别名local，指定本地默认实例&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].dwPropertyID = DBPROP_INIT_DATASOURCE;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].dwOptions = DBPROPOPTIONS_REQUIRED;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;LIU-PC&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;SQLEXPRESS&quot;&lt;/span&gt;));
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].colid = DB_NULLID;

    &lt;span class=&quot;co&quot;&gt;//指定数据库库名&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].dwPropertyID = DBPROP_INIT_CATALOG;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].dwOptions = DBPROPOPTIONS_REQUIRED;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;Study&quot;&lt;/span&gt;));
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].colid = DB_NULLID;

    &lt;span class=&quot;co&quot;&gt;//指定链接数据库的用户名&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;].dwPropertyID = DBPROP_AUTH_USERID;
    dbProps[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;sa&quot;&lt;/span&gt;));
    
    &lt;span class=&quot;co&quot;&gt;//指定链接数据库的用户密码&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;].dwPropertyID = DBPROP_AUTH_PASSWORD;
    dbProps[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;));
    
    
    &lt;span class=&quot;co&quot;&gt;//设置属性&lt;/span&gt;
    hRes = pDBInit-&amp;gt;QueryInterface(IID_IDBProperties, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDBProperties);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;查询IDBProperties接口失败, 错误码:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    dbPropset-&amp;gt;guidPropertySet = DBPROPSET_DBINIT;
    dbPropset[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].cProperties = &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;;
    dbPropset[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].rgProperties = dbProps;
    hRes = pIDBProperties-&amp;gt;SetProperties(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, dbPropset);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;设置属性失败, 错误码:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    &lt;span class=&quot;co&quot;&gt;//链接数据库&lt;/span&gt;
    hRes = pDBInit-&amp;gt;Initialize();
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;链接数据库失败：错误码:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    &lt;span class=&quot;co&quot;&gt;//do something&lt;/span&gt;
    pDBInit-&amp;gt;Uninitialize();

    GRS_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;数据库操作成功!!!!!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;));
CLEAR_UP:
    GRS_SAFEFREE(pDBInit);
    GRS_SAFEFREE(pIDBProperties);
    CoUninitialize();
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一份完整的可执行代码，后续的部分对于重复的代码将不再给出。&lt;br/&gt;在上述代码中我们首先根据字符串SQLOLEDB查找到SQL Server对应的数据源对象，然后根据数据源对象查询出IDBProperties对象，接着分配一些空间来设置属性和属性集，调用IDBProperties接口的SetProperties函数来设置对应的数据源对象的接口。最后调用IDBInitialize接口的Initialize链接数据源，调用Uninitialize函数来断开连接。&lt;br/&gt;一般数据源对象的属性集合的GUID为DBPROPSET_DBINIT，下面包含的属性最主要的有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DBPROP_INIT_DATASOURCE:数据连接实例（具体的DBMS实例名）&lt;/li&gt;
&lt;li&gt;DBPROP_INIT_CATALOG：目录名（在SQL Server中对应的是具体的数据库名称，对于ORACLE来说没有意义）&lt;/li&gt;
&lt;li&gt;DBPROP_AUTH_USERID: 用户名&lt;/li&gt;
&lt;li&gt;DBPROP_AUTH_PASSWORD: 密码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们也注意到上面调用SysAllocString的BSTR类型的字符串并没有调用对应的函数进行释放，会不会发生内存泄露？其实不用担心OLEDB在断开连接的时候已经帮助我们释放了这部分空间。&lt;/p&gt;
&lt;h2 id=&quot;使用idbpromptinitialize接口来创建数据源对象&quot;&gt;使用IDBPromptInitialize接口来创建数据源对象&lt;/h2&gt;
&lt;p&gt;上述方法是依托于标准的COM，虽然也成功创建的数据源连接，但是无法在标准的com之上进行更多的初始化操作，导致了有些特定的高级功能无法使用，所以在实践中常用的还是利用IDBPromptInitialize和IDataInitialize的方式比较多。&lt;br/&gt;IDBPromptInitialize创建时会弹出一个数据源选择的对话框，供用户选择相关配置信息（数据源/用户名/密码等）然后根据这些配置自动生成连接对象。&lt;br/&gt;下面看一个弹出数据源对话框的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;27&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConnectSQLServerByDialog() &lt;span class=&quot;co&quot;&gt;//通过弹出对话框来链接SQL SERVER数据库&lt;/span&gt;
{
    DECLARE_BUFFER();
    DECLARE_OLEDB_INTERFACE(IDBPromptInitialize);
    DECLARE_OLEDB_INTERFACE(IDBInitialize);

    HWND hDesktop = GetDesktopWindow();
    HRESULT hRes = CoCreateInstance(CLSID_DataLinks, NULL, CLSCTX_INPROC_SERVER, IID_IDBPromptInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDBPromptInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDBPromptInitialize接口失败: &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    &lt;span class=&quot;co&quot;&gt;//调用该函数弹出数据源对话框&lt;/span&gt;
    hRes = pIDBPromptInitialize-&amp;gt;PromptDataSource(NULL, hDesktop, DBPROMPTOPTIONS_PROPERTYSHEET, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, NULL, NULL, IID_IDBInitialize, (IUnknown**)&amp;amp;pIDBInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;弹出数据源对话框失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    hRes = pIDBInitialize-&amp;gt;Initialize();
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;链接数据库失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    COM_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;链接数据库成功&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;));

    hRes = pIDBInitialize-&amp;gt;Uninitialize();
__CLEAN_UP:
    SAFE_RELEASE(pIDBPromptInitialize);
    SAFE_RELEASE(pIDBInitialize);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了这种方式，他还可以直接创建出IDBInitialize接口，利用之前设置属性的方式来连接到数据库，下面是一个演示的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;    HRESULT hRes = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER, IID_IDataInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDataInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建接口IDBInitialize失败：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = CLSIDFromProgID(_T(&lt;span class=&quot;st&quot;&gt;&quot;SQLOLEDB&quot;&lt;/span&gt;), &amp;amp;clsid);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;查询SQLOLEDB CLSID 失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = pIDataInitialize-&amp;gt;CreateDBInstance(clsid, NULL,
        CLSCTX_INPROC_SERVER, NULL, IID_IDBInitialize,
        (IUnknown**)&amp;amp;pIDBInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDBInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    &lt;span class=&quot;co&quot;&gt;//后续的代码就是我们之前写的那段定义属性，设置属性，连接数据库的代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;使用idatainitialize接口来创建数据源对象&quot;&gt;使用IDataInitialize接口来创建数据源对象&lt;/h2&gt;
&lt;p&gt;使用IDataInitialize接口可以直接使用连接字串连接到数据库，下面是使用连接字串的例子:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConnectSQLServerByConnstr() &lt;span class=&quot;co&quot;&gt;//通过连接字符串连接数据库&lt;/span&gt;
{
    DECLARE_OLEDB_INTERFACE(IDataInitialize);
    DECLARE_OLEDB_INTERFACE(IDBInitialize);
    DECLARE_BUFFER();
    HRESULT hRes = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER, IID_IDataInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDataInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDataInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    hRes = pIDataInitialize-&amp;gt;GetDataSource(NULL, CLSCTX_INPROC_SERVER, 
        OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;Provider=SQLOLEDB.1;Persist Security Info=False;User ID=sa;Password = 123456;Initial Catalog=Study;Data Source=LIU-PC&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;SQLEXPRESS;&quot;&lt;/span&gt;), 
        IID_IDBInitialize, (IUnknown**)&amp;amp;pIDBInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;获取IDBInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = pIDBInitialize-&amp;gt;Initialize();
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;连接数据库失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    COM_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;连接数据库成功&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;));
    pIDBInitialize-&amp;gt;Uninitialize();
__CLEAN_UP:
    SAFE_RELEASE(pIDataInitialize);
    SAFE_RELEASE(pIDBInitialize);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其实除了上面这种直接创建IDataInitialize接口的方法外，还可以使用IDBPromptInitialize接口Query出一个IDataInitialize接口，然后再设置连接字串连接到数据库。&lt;br/&gt;其实在OLEDB中，可以认为连接字串最终被翻译为对应的属性，也就是说OLEDDB保存着对应连接的属性，我们可以通过不同的方式来获取不同类型的属性，比如使用IDBProperties接口来获取对应的链接属性，或者使用IDataInitialize的GetInitializationString函数来获取连接的链接字串。&lt;br/&gt;既然它保存着每个连接的对应属性，那么是不是可以将用户在数据源对话框上的操作最终保存为数据连接字串呢，答案是肯定的。实现的思路如下：&lt;/p&gt;
&lt;ol readability=&quot;0.48894062863795&quot;&gt;&lt;li&gt;调用IDBPromptInitialize接口的PromptDataSourc方法弹出数据源对话框，让用户操作&lt;/li&gt;
&lt;li&gt;根据IDBPromptInitialize接口Query出IDataInitialize接口&lt;/li&gt;
&lt;li readability=&quot;17.561257216164&quot;&gt;
&lt;p&gt;调用IDataInitialize接口的GetInitializationString来获取连接字串&lt;br/&gt;下面是具体实现的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; GetConnectString()
{
DECLARE_OLEDB_INTERFACE(IDBPromptInitialize);
DECLARE_OLEDB_INTERFACE(IDataInitialize);
DECLARE_OLEDB_INTERFACE(IDBInitialize);
DECLARE_BUFFER();

LPOLESTR pConnStr = NULL;
HWND hDeskTop = GetDesktopWindow();
HRESULT hRes = CoCreateInstance(CLSID_DataLinks, NULL, CLSCTX_INPROC_SERVER, IID_IDBPromptInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDBPromptInitialize);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDBPromptInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
hRes = pIDBPromptInitialize-&amp;gt;PromptDataSource(NULL, hDeskTop, DBPROMPTOPTIONS_PROPERTYSHEET, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, NULL, NULL, IID_IDBInitialize, (IUnknown**)&amp;amp;pIDBInitialize);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;弹出数据源对话框失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);


hRes= pIDBPromptInitialize-&amp;gt;QueryInterface(IID_IDataInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDataInitialize);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDataInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

hRes = pIDataInitialize-&amp;gt;GetInitializationString(pIDBInitialize, TRUE, &amp;amp;pConnStr);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;获取连接字串失败失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

COM_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;连接字符串:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), pConnStr);
SysAllocString(pConnStr);
__CLEAN_UP:
SAFE_RELEASE(pIDataInitialize);
SAFE_RELEASE(pIDBInitialize);
SAFE_RELEASE(pIDBPromptInitialize);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;为了节约篇幅，这些笔记内容只会列举部分关键的代码，至完整的代码我会随着博客内容的进度慢慢上传到GitHub项目中，并在博文的最末尾给出对应文件的地址&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/aMonst/OLEDB_Demo/blob/master/ConnectDB.cpp&quot;&gt;本次代码地址1&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/aMonst/OLEDB_Demo/blob/master/DataSource.cpp&quot;&gt;本次代码地址2&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 12 Jan 2018 15:41:00 +0000</pubDate>
<dc:creator>GunLun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lanuage/p/8278087.html</dc:identifier>
</item>
</channel>
</rss>