<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>玩转小程序云开发 - gxlself</title>
<link>http://www.cnblogs.com/gxlself/p/9721623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gxlself/p/9721623.html</guid>
<description>
&lt;h2&gt;前言&lt;/h2&gt;
&lt;h3&gt;　　好久没写小程序的文章了，最近小程序变动也比较大。最主要的是我之前也曾写过个人如果开发小程序，可以使用Bmob免费的服务去开发自己的一套小程序，Bmob提供了免费的云函数以及数据库（20G空间）。But！！！微信小程序推出了自己的云开发服务，虽然数据库只有5G的空间，但是对于个人开发基本上足够使用，20支云函数接口以及云存储（相当于OSS服务器一样存放图片json文件等），以及用户管理。&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt;　　1. 先来玩玩云函数&lt;/h3&gt;
&lt;p&gt;　　云函数是什么呢？估计很多玩过阿里云以及腾讯云的人已经对这个名词早已很熟悉。一种无需服务器的执行环境，平台会给出它支持的语言以及核心的代码，即可以在服务商提供的设施上弹性、安全的运行。这个很大程度上省却了很多开发部署工作，用过的都说好（假的）。&lt;/p&gt;
&lt;p&gt;　　小程序内部提供了专门用于云函数调用的API，而我们只需要在云函数内将每次获取到的appId以及openId不再需要后台经过一系列鉴定加密就可以获取到可信任的用户登录状态！！！这个是最主要的，再之前利用Bmob也好，自己开发也好，这个是必备的，具体前往微信登录流程查看。现在利用小程序本身的云函数，省去了大量工作，真的是个人开发者的福音。&lt;/p&gt;
&lt;p&gt;　　废话这么多，赶紧开始第一个云函数的添加以及调用吧 ----&amp;gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;配置云开发：&lt;/p&gt;
&lt;p&gt;　　第一步： &lt;span&gt;project.config.json &lt;/span&gt;中进行添加字段 &lt;span&gt;&quot;cloudfunctionRoot&quot;: &quot;cloudfunctions/&quot; &lt;span&gt; &lt;span&gt;这个字段主要是为了指定存放云函数的文件夹&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&quot;cloudfunctions/&quot;&lt;/span&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1333487/201809/1333487-20180928230955704-2137579601.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第二步： &lt;span&gt;app.json&lt;/span&gt; 中添加 &lt;span&gt;&quot;cloud&quot;: true &lt;span&gt;指定是云开发模式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333487/201809/1333487-20180928231055418-1515965309.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;　&lt;span&gt;第三步： 添加云函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333487/201809/1333487-20180928231720757-99408599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第四步：添加对应的函数后，会下载依赖，这一步玩过node及npm的都知道，就是下载依赖，现在下载的是微信小程序官方的sdk。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333487/201809/1333487-20180928231832055-537545509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　等下载完成后，点开云开发控制台的云函数一栏就会发现函数名称已经有了test这个云函数了。。。具体看下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333487/201809/1333487-20180928232139716-184428564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这个test云函数就是我们刚刚添加的云函数，此时在开发者工具中打开test目录下的index.js文件，就可以进行返回我们需要返回的内容。。。如下：测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333487/201809/1333487-20180928234723609-58583197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这里如果是利用了获取授权的按钮之后就会在return中返回用户登录后的openId和appId，所以我们就return默认的&lt;span&gt;event&lt;/span&gt;对象以及&lt;span&gt;context&lt;/span&gt;（上下文）对象。主要是为了看看小程序默认提供的对象包含了什么，我们可以用什么？？？&lt;/p&gt;
&lt;p&gt;　　　　保存完了，还不够因为这个云函数我们都说了是小程序提供的服务平台来运行我们做的类似于接口的函数，所以我们必须得上传，具体看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333487/201809/1333487-20180928235159043-1148236456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　等待上传完毕，在&lt;span&gt;pages&lt;span&gt;下&lt;/span&gt;index.wxml&lt;/span&gt;中需要做的是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfgo&quot;&amp;gt;授权登录&amp;lt;/button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　由于获取授权需要配合点击后js的操作，所以在index.js中添加对应的&lt;span&gt;getUserInfo&lt;/span&gt;的方法，并且注意这里的&lt;span&gt;wx.cloud.callFunction&lt;/span&gt;方法，因为这是调用云函数的方法。不可忽视~~~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
getUserInfo: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
    wx.cloud.callFunction({
      name: &lt;/span&gt;&quot;test&quot;&lt;span&gt;,//这里填写云函数的名字
      data: {
        userInfo: e // 这里是把参数e直接传给test函数处理
      },
      success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.log(res) // 返回的文本如下图所示：
      },
      fail: err &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.log(err)
      }
    })
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333487/201809/1333487-20180929000523853-1689141554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　可以看到输出的信息中会返回用户的openId以及appId还有对应云函数认证的信息。。。具体的实际可以自行测试查看，这里不做进一步探测...&lt;/p&gt;
&lt;p&gt;　　　　这里云函数已经相信大家会玩了。。。就不再做其他的一一测试以及讲解。&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt;　　2. 数据库&lt;/h3&gt;
&lt;p&gt;　　对于数据库我相信大家都早已用的不能再熟悉，mySql， SQLServer， Oracle， MongoDb， indexDb等等。。。。接下来带着大家玩玩这个微信云开发提供的数据库。。。&lt;/p&gt;
&lt;p&gt;　　云开发提供的应该是类似于NoSql类型的数据库，存储的是JSON对象。一个数据库也是多个集合（相似于MongoDb）&lt;/p&gt;
&lt;p&gt;　　接下来让我们开始快乐的使用这个数据库吧~~~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先  要实例一个数据库对象&lt;/span&gt;
&lt;span&gt;
let db &lt;/span&gt;=&lt;span&gt; wx.cloud.database();
db.collection(&lt;/span&gt;'counters'&lt;span&gt;).add({
      data: {
        count: &lt;/span&gt;1&lt;span&gt;
      },
      success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在返回结果中会包含新创建的记录的 _id&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
          counterId: res._id,
          count: &lt;/span&gt;1&lt;span&gt;
        })
        wx.showToast({
          title: &lt;/span&gt;'新增记录成功'&lt;span&gt;,
        })
        console.log(&lt;/span&gt;'[数据库] [新增记录] 成功，记录 _id: '&lt;span&gt;, res._id)
      },
      fail: err &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        wx.showToast({
          icon: &lt;/span&gt;'none'&lt;span&gt;,
          title: &lt;/span&gt;'新增记录失败'&lt;span&gt;
        })
        console.error(&lt;/span&gt;'[数据库] [新增记录] 失败：'&lt;span&gt;, err)
      }
    })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333487/201809/1333487-20180929001355949-56119998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这是利用添加数据的方法进行添加的数据，此时可以在云开发控制台看到对应得数据：下图---》&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333487/201809/1333487-20180929001505382-1227396593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　此时可以看到插入进去的数据。。。接下来可以看看增删改查的其余操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询数据：&lt;/span&gt;
const db =&lt;span&gt; wx.cloud.database()
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询当前用户所有的 counters&lt;/span&gt;
    db.collection('counters'&lt;span&gt;).where({
      _openid: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.openid
    }).get({
      success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
          queryResult: JSON.stringify(res.data, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, 2&lt;span&gt;)
        })
        console.log(&lt;/span&gt;'[数据库] [查询记录] 成功: '&lt;span&gt;, res)
      },
      fail: err &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        wx.showToast({
          icon: &lt;/span&gt;'none'&lt;span&gt;,
          title: &lt;/span&gt;'查询记录失败'&lt;span&gt;
        })
        console.error(&lt;/span&gt;'[数据库] [查询记录] 失败：'&lt;span&gt;, err)
      }
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改数据&lt;/span&gt;
const db =&lt;span&gt; wx.cloud.database()
    const newCount &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.data.count + 1&lt;span&gt;
    db.collection(&lt;/span&gt;'counters').doc(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.counterId).update({
      data: {
        count: newCount
      },
      success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
          count: newCount
        })
      },
      fail: err &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        icon: &lt;/span&gt;'none'&lt;span&gt;,
        console.error(&lt;/span&gt;'[数据库] [更新记录] 失败：'&lt;span&gt;, err)
      }
 })    

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  删除数据&lt;/span&gt;
const db =&lt;span&gt; wx.cloud.database()
      db.collection(&lt;/span&gt;'counters').doc(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.counterId).remove({
        success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
          wx.showToast({
            title: &lt;/span&gt;'删除成功'&lt;span&gt;,
          })
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
            counterId: &lt;/span&gt;''&lt;span&gt;,
            count: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
          })
        },
        fail: err &lt;/span&gt;=&amp;gt;&lt;span&gt; {
          wx.showToast({
            icon: &lt;/span&gt;'none'&lt;span&gt;,
            title: &lt;/span&gt;'删除失败'&lt;span&gt;,
          })
          console.error(&lt;/span&gt;'[数据库] [删除记录] 失败：'&lt;span&gt;, err)
        }
 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　当然，在数据库操作之前需要利用云函数login获取对应的openId， 获取方法请细看上方云函数test部分。。。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;　　3. 存储部分&lt;/h3&gt;
&lt;p&gt;　　小程序只有2M的空间，个人开发要么将图片放在这小小的2M内，要么自己配置https证书的域名，再要么利用github将自己的域名免费转为https，不会玩的可以私信我，我可以再单独写一篇将自己的域名利用github穿https证书的方法，哈哈（略过）。将图片放github不用自己的域名也行，但是利用github就要忍受它的网速慢以及随时被墙的可能性。。。&lt;/p&gt;
&lt;p&gt;　　现在我们来用云开发提供的存储：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wx.chooseImage({
      count: &lt;/span&gt;1&lt;span&gt;,
      sizeType: [&lt;/span&gt;'compressed'&lt;span&gt;],
      sourceType: [&lt;/span&gt;'album', 'camera'&lt;span&gt;],
      success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {

        wx.showLoading({
          title: &lt;/span&gt;'上传中'&lt;span&gt;,
        })

        const filePath &lt;/span&gt;= res.tempFilePaths[0&lt;span&gt;]
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上传图片&lt;/span&gt;
        const cloudPath = 'my-image' + filePath.match(/\.[^.]+?$/)[0&lt;span&gt;]
        wx.cloud.uploadFile({
          cloudPath,
          filePath,
          success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'[上传文件] 成功：'&lt;span&gt;, res)

            let fileId &lt;/span&gt;=&lt;span&gt; res.fileID
            let cloudPath &lt;/span&gt;=&lt;span&gt; cloudPath
            let imagePath &lt;/span&gt;=&lt;span&gt; filePath
            
            console.log( fileId )
            console.log( cloudPath )
           console.log( imagePath )
          },
          fail: e &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.error(&lt;/span&gt;'[上传文件] 失败：'&lt;span&gt;, e)
            wx.showToast({
              icon: &lt;/span&gt;'none'&lt;span&gt;,
              title: &lt;/span&gt;'上传失败'&lt;span&gt;,
            })
          },
          complete: () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            wx.hideLoading()
          }
        })

      },
      fail: e &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.error(e)
      }
    })                &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　代码已经奉上，上传成功后再跑去云开发控制台查看一番~~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333487/201809/1333487-20180929002842866-1740264164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　好了，云开发已经基本上完成，当然云存储也可以存储json文件，然后请求静态数据~~~看自己的需要了。&lt;/p&gt;
&lt;p&gt;　　　　云开发是将前端开发者摆到了更重要的地位，不再很依赖于服务端。这真的是一个福利~~~~&lt;/p&gt;
&lt;p&gt;　　　　OVER~~SLEEP!!!&lt;/p&gt;
</description>
<pubDate>Fri, 28 Sep 2018 16:32:00 +0000</pubDate>
<dc:creator>gxlself</dc:creator>
<og:description>前言 好久没写小程序的文章了，最近小程序变动也比较大。最主要的是我之前也曾写过个人如果开发小程序，可以使用Bmob免费的服务去开发自己的一套小程序，Bmob提供了免费的云函数以及数据库（20G空间）。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gxlself/p/9721623.html</dc:identifier>
</item>
<item>
<title>Java设计模式学习记录-状态模式 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/9715937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/9715937.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;状态模式是一种行为模式，用于解决系统中复杂的对象状态转换以及各个状态下的封装等问题。状态模式是将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象的状态可以灵活多变。这样在客户端使用时无需关心对象的状态，可以实现自身的一致性处理。最近工作有些忙，更新博客慢了。还是要严格要求自己的，抽时间也要坚持学习。 &lt;/p&gt;
&lt;h2&gt;状态模式&lt;/h2&gt;
&lt;h3&gt;概念介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;状态模式允许一个对象在其状态改变时，改变它的行为，对象看起来似乎修改了它的类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想要在改变自身状态时改变对象行为，最直接的方法就是在代码中将所有可能发生的情况都考虑到了，然后使用if-else语句来进行相应的选择。但是这种方法对于复杂的状态判断会显得杂乱无章，容易产生错误；而且增加一个新的状态将会带来大量的修改。&lt;/p&gt;
&lt;p&gt;流程结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180928002443758-135444701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时“能够修改自身”的状态模式的引入也许是个不错的主意，将不同条件下的行为封装在一个类里，再给这些类一个统一的父类来约束它们。&lt;/p&gt;
&lt;p&gt;就会变成如下图流程结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180928002502338-1073380051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;举例&lt;/h3&gt;
&lt;p&gt;还是来举个具体的实例来说明一下吧。同事小王要请假，根据公司规定，请假要先在OA上提请假申请单，然后审批通过后就可以正常休假了。这个请假申请单大致经历这么几个状态，未审核（待提交）、审核中、审核通过、审核未通过，这里只是粗略的分为这几个状态。下面我们使用状态模式来模拟实现一下这个请假申请单的状态流转过程。&lt;/p&gt;
&lt;p&gt;先创建一个休假申请单类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 休假申请
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LeaveApply {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 休假申请单初始状态是待提交状态
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; ApplyState applyState = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnAudited();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置状态
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; state
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setState(ApplyState state){
        applyState &lt;/span&gt;=&lt;span&gt; state;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 状态变化后，更新对象自身的行为
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(){
        applyState.changeHandle();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;审批单状态接口，声明统一处理的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 审批单状态接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ApplyState {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 状态变化处理操作
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeHandle();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;待提交状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 未审核状态（待提交审核）
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UnAudited &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ApplyState {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 状态变化处理操作
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeHandle() {
        System.out.println(&lt;/span&gt;&quot;申请单处于未审核状态，当用户查看申请单详情时直接跳转到编辑页。&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;审核中状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 审核中状态
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Audit &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ApplyState {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 状态变化处理操作
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeHandle() {
        System.out.println(&lt;/span&gt;&quot;申请单处于审核中状态，当用户查看申请单详情时跳转到详情页可以看到提交记录。&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;审核通过状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *
 * 审核通过状态
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Pass &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ApplyState {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 状态变化处理操作
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeHandle() {
        System.out.println(&lt;/span&gt;&quot;申请单已经审批通过，当前用户可以正常休假了。&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;审核未通过状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 审核未通过状态
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NotPass &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ApplyState {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 状态变化处理操作
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeHandle() {
        System.out.println(&lt;/span&gt;&quot;申请单未通过审核，当前用户不可以休假&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestOA {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个请假申请单&lt;/span&gt;
        LeaveApply leaveApply = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LeaveApply();

        leaveApply.setState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnAudited());
        leaveApply.update();

        leaveApply.setState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Audit());
        leaveApply.update();

        leaveApply.setState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Pass());
        leaveApply.update();

        leaveApply.setState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotPass());
        leaveApply.update();


    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;申请单处于未审核状态，当用户查看申请单详情时直接跳转到编辑页。
申请单处于审核中状态，当用户查看申请单详情时跳转到详情页可以看到提交记录。
申请单已经审批通过，当前用户可以正常休假了。
申请单未通过审核，当前用户不可以休假&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子如果是不使用状态模式的思想，而是使用条件语句来实现就会出现很多的if-else来进行判断什么状态，应该执行什么样的方法。现在把各个状态的处理逻辑分离，结构清晰了并且耦合也不那么紧密了。&lt;/p&gt;
&lt;h3&gt;结构分析&lt;/h3&gt;
&lt;p&gt;在状态模式中引入了抽象状态类和具体状态类，它们是状态模式的核心。状态模式的结构组成如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180928233305191-147271154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在状态模式中，主要涉及了如下几个角色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境角色（Context）&lt;/strong&gt;：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象状态角色（State）&lt;/strong&gt;：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体状态角色（Contract）&lt;/strong&gt;：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;状态模式在功能上和策略模式很类似，但是在实现思想上状态模式是将各个状态分离解耦的，并且可以将对象的具体行为委托给当前的状态对象，而策略模式中，策略的选择是根据Context类中的行为来确定的，也不存在各个状态的切换。在实际开发中，状态模式具有较高的使用频率，在工作流和游戏开发中状态模式都得到了广泛的应用，例如公文状态的转换、游戏中角色的升级等。&lt;/p&gt;
&lt;h3&gt;主要优点&lt;/h3&gt;
&lt;p&gt;1、封装了状态的转换规则，在状态模式中可以将状态转换的工作封装在环境类或具体的状态类中，可以对状态转换码进行集中管理，而不是分散在一个个的业务中。&lt;/p&gt;
&lt;p&gt;2、将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。&lt;/p&gt;
&lt;p&gt;3、允许状态转换逻辑与状态对象合为一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。&lt;/p&gt;
&lt;h3&gt;主要缺点&lt;/h3&gt;
&lt;p&gt;1、状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。&lt;/p&gt;
&lt;p&gt;2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。&lt;/p&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;p&gt;1、对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化。&lt;/p&gt;
&lt;p&gt;2、在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。&lt;/p&gt;



&lt;p&gt;想了解更多的设计模式请查看&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jimoer/p/9163426.html&quot;&gt;Java设计模式学习记录-GoF设计模式概述&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180915224244625-861430438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个是我的个人公众号，文章以后也会同步到公众号上去，欢迎关注。&lt;/p&gt;

</description>
<pubDate>Fri, 28 Sep 2018 16:31:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 状态模式是一种行为模式，用于解决系统中复杂的对象状态转换以及各个状态下的封装等问题。状态模式是将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象的状态可以灵活多变。这样在客户端使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimoer/p/9715937.html</dc:identifier>
</item>
<item>
<title>工厂设计模式究竟怎么写更优雅？！ - xfma</title>
<link>http://www.cnblogs.com/blog411032/p/9721599.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blog411032/p/9721599.html</guid>
<description>&lt;p&gt;闲来无事看了菜鸟教程的设计模式。看到了一个很有趣的讨论，该讨论是关于工厂设计模式的书写形式。下面先看一下给出的基础写法，然后再看一下各位网友的优化。&lt;/p&gt;
&lt;p&gt;工厂设计模式初衷：我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。即只需要告诉接口想要获取对象的类型，然后接口就会创建好该类型对应的对象，并返回。&lt;/p&gt;
&lt;p&gt;类图如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/921991/201809/921991-20180928234507381-1961632024.png&quot; alt=&quot;&quot; width=&quot;684&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据上面的类图，可以给出如下实现：&lt;/p&gt;
&lt;p&gt;1.首先创建shape.java接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public interface Shape {
   void draw();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2.创建接口的三个实现类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);
   }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&quot;Inside Square::draw() method.&quot;);
   }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println(&quot;Inside Circle::draw() method.&quot;);
   }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3.创建工厂：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class ShapeFactory {
    
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){
         return new Square();
      }
      return null;
   }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4.使用该工厂，根据传过来的类型信息获取实体类的对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class FactoryPatternDemo {
 
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
 
      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
 
      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);
 
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 5.输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 工厂模式的优缺点：&lt;/p&gt;
&lt;p&gt;优点：一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。&lt;/p&gt;
&lt;p&gt;缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;网友优化：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网友A给出的优化方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　使用反射机制可以解决每次增加一个产品时，都需要增加一个对象实现工厂的缺点。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class ShapeFactory {
    public static Object getClass(Class&amp;lt;?extends Shape&amp;gt; clazz) {
        Object obj = null;

        try {
            obj = Class.forName(clazz.getName()).newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }

        return obj;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 生产对象的时候使用强制转换&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Rectangle rect = (Rectangle) ShapeFactory.getClass(Rectangle.class);
rect.draw();
Square square = (Square) ShapeFactory.getClass(Square.class);
square.draw();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这样只需要一个对象实现工厂，不需要每次增加类型时都需要重新写一个工厂的实现。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网友B对A又进行了进一步优化：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class ShapeFactory {
    public static &amp;lt;T&amp;gt; T getClass(Class&amp;lt;? extends T&amp;gt; clazz) {
        T obj = null;

        try {
            obj = (T) Class.forName(clazz.getName()).newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }

        return obj;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 使用泛型，去掉了每次获取对象时的强制转换&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Rectangle rect = ShapeFactory.getClass(Rectangle.class);
rect.draw();

Shape square = ShapeFactory.getClass(Square.class);
square.draw();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 网友C又在B的基础上进一步优化：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;针对多个接口实现一个公共的工厂类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class ObjectFactory {
    public &amp;lt;T&amp;gt; Object getObject(Class&amp;lt;T&amp;gt; clazz) {
       if (clazz == null ) {
           return null;
    }    
        Object obj  = null;
        try {
            obj = Class.forName(clazz.getName()).newInstance();
        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return obj;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 网友D又在C的基础上进行了一次优化：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class ShapeFactory {
    
   //使用 getShape 方法获取形状类型的对象
  public Shape getShape(Class&amp;lt;?&amp;gt; clazz){
        try {
            return (IShape) clazz.getConstructor().newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (SecurityException e) {
            e.printStackTrace();
        }
        return null;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 接下来有位E网友对以上ABCD网友的写法给出了自己的见解：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　其实使用反射是一种不错的办法，但反射也是从类名反射而不能从类反射！&lt;/p&gt;
&lt;p&gt;　　先看一下工厂模式是用来干什么的——属于创建模式，解决子类创建问题的。换句话来说，调用者并不知道运行时真正的类名，只知道从“Circle&quot;可以创建出一个shape接口的类，至于类的名称是否叫'Circle&quot;，调用者并不知情。所以真正的对工厂进行扩展的方式（防止程序员调用出错）可以考虑使用一个枚举类（防止传入参数时，把circle拼写错误）。&lt;/p&gt;
&lt;p&gt; 　　如果调用者参肯定类型是Circle的话，那么其工厂没有存在的意义了！&lt;/p&gt;
&lt;p&gt;　　比如 IShape shape = new Circle();这样不是更好？也就是说调用者有了Circle这个知识是可以直接调用的，根据DP（迪米特法则）其实调用者并不知道有一个Circle类的存在，他只需要知道这个IShape接口可以计算圆面积，而不需要知道；圆这个类到底是什么类名——他只知道给定一个”circle&quot;字符串的参数,IShape接口可以自动计算圆的面积就可以了！&lt;/p&gt;
&lt;p&gt; 　　其实在.net类库中存在这个模式的的一个典型的。但他引入的另一个概念“可插入编程协议”。&lt;/p&gt;
&lt;p&gt;那个就是WebRequest req = WebRequest.Create(&quot;&lt;a href=&quot;http://ccc....../&quot; rel=&quot;nofollow&quot;&gt;http://ccc......&lt;/a&gt;&quot;);可以自动创建一个HttpWebRequest的对象，当然，如果你给定的是一个ftp地址，他会自动创建一个FtpWebRequest对象。工厂模式中着重介绍的是这种通过某个特定的参数，让你一个接口去干对应不同的事而已！而不是调用者知道了类！&lt;/p&gt;
&lt;p&gt;　　比如如果圆的那个类名叫&quot;CircleShape“呢？不管是反射还是泛型都干扰了你们具体类的生成！其实这个要说明的问题就是这个，调用者（clinet)只知道IShape的存在，在创建时给IShape一个参数&quot;Circle&quot;,它可以计算圆的面积之类的工作，但是为什么会执行这些工作，根据迪米特法则，client是不用知道的。&lt;/p&gt;
&lt;p&gt; 　　我想问一下那些写笔记的哥们，如果你们知道了泛型，那么为什么不直接使用呢？干吗还需要经过工厂这个类呢？不觉得多余了吗？&lt;/p&gt;
&lt;p&gt; 　　如果，我只是说如果，如果所有从IShape继承的类都是Internal类型的呢？而client肯定不会与IShape一个空间！这时，你会了现你根本无法拿到这个类名！&lt;/p&gt;
&lt;p&gt;　　Create时使用注册机制是一种简单的办法，比如使用一个枚举类，把功能总结到一处。而反射也是一种最简单的办法，调用者输入的名称恰是类名称或某种规则时使用，比如调用者输入的是Circle，而类恰是CircleShape，那么可以通过输入+”Shape&quot;字符串形成新的类名，然后从字符串将运行类反射出来！&lt;/p&gt;
&lt;p&gt; 　　工厂的创建行为，就这些作用，还被你们用反射或泛型转嫁给了调用者（clinet)，那么，这种情况下，要工厂类何用？！&lt;/p&gt;

&lt;p&gt;自认为E的见解是从工厂设计模式的根本出发的，大致可以总结出如下实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public enum Factory {
    CIRCLE(new Circle(),&quot;CIRCLE&quot;),
    RECTANGLE(new Rectangle(),&quot;RECTANGLE&quot;),
    SQUARE(new Square(),&quot;SQUARE&quot;);
    
    // 成员变量  
    private Shape shape;  
    private String name;  
    
    // 普通方法  
    public static Shape getShape(String name) {  
        for (Factory c : Factory.values()) {  
            if (c.name == name) {  
                return c.shape;  
            }  
        }  
        return null;  
    } 
    // 构造方法  
    private Factory(Shape shape, String name) {  
        this.shape = shape;  
        this.name = name;  
    } 
    public String getName() {
        return name;
    }
    public Shape getShape() {
        return shape;
    }


    public void setShape(Shape shape) {
        this.shape = shape;
    }


    public void setName(String name) {
        this.name = name;
    } 
    
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可使用枚举根据类型来创建想要的对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Factory.getShape(&quot;CIRCLE&quot;).draw();
Factory.getShape(&quot;RECTANGLE&quot;).draw();
Factory.getShape(&quot;SQUARE&quot;).draw();
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 28 Sep 2018 16:18:00 +0000</pubDate>
<dc:creator>xfma</dc:creator>
<og:description>闲来无事看了菜鸟教程的设计模式。看到了一个很有趣的讨论，该讨论是关于工厂设计模式的书写形式。下面先看一下给出的基础写法，然后再看一下各位网友的优化。 工厂设计模式初衷：我们在创建对象时不会对客户端暴露</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blog411032/p/9721599.html</dc:identifier>
</item>
<item>
<title>前端XSS相关整理 - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/9721563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/9721563.html</guid>
<description>&lt;p&gt;前端安全方面，主要需要关注 XSS（跨站脚本攻击 Cross-site scripting） 和 CSRF（跨站请求伪造 Cross-site request forgery）&lt;/p&gt;
&lt;p&gt;当然了，也不是说要忽略&lt;a class=&quot;external-link&quot; href=&quot;http://imweb.io/topic/56f895bf14ea0f7263803d5b&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;其他&lt;/a&gt;安全问题：后端范畴、DNS劫持、HTTP劫持、加密解密、钓鱼等&lt;/p&gt;
&lt;p&gt;CSRF主要是借用已登录用户之手发起“正常”的请求，防范措施主要就是对需要设置为Post的请求，判断Referer以及&lt;a href=&quot;https://www.cnblogs.com/imwtr/p/4763457.html&quot; rel=&quot;nofollow&quot;&gt;token&lt;/a&gt;的一致性，本文不展开&lt;/p&gt;
&lt;p&gt;相对来说，XSS的内容就非常庞大了，下面就来整理一下一些XSS的知识点。比较匆忙，可能有点乱哈~&lt;/p&gt;


&lt;p&gt;恶意攻击者向页面中注入可执行的JS代码来实现XSS的攻击。&lt;/p&gt;
&lt;p&gt;如常见的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Payload：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;[输出]&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个 Payload 可以从编辑区域而来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;[输入]&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，输入和输出的位置还可以出现在其他地方，根据输入输位置的不同，可以形成不同类型的XSS，相应的防范措施也不同。&lt;/p&gt;

&lt;h2 id=&quot;id-前端XSS相关整理-1.1XSS的分类&quot;&gt;&lt;span&gt;1.1 XSS的分类&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;一般来说，可以将XSS分为三类：反射型XSS、存储型XSS、DOM-base 型XSS&lt;/p&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.1.1反射型XSS&quot;&gt;&lt;span&gt;1.1.1 反射型XSS&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;大多通过URL进行传播，发请求时，XSS代码出现在URL中，提交给服务端。服务端未进行处理或处理不当，返回的内容中也带上了这段XSS代码，最后浏览器执行XSS代码&lt;/p&gt;
&lt;p&gt;比如在 php的smarty模板中直接获取url的参数值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Payload: &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
http://local.abc.com/main/?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;param&lt;/span&gt;=&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;{$smarty&lt;/span&gt;&lt;span&gt;.get.param}&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-X-XSS-Protection&quot;&gt;&lt;span&gt;X-XSS-Protection&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;新版Chrome和Safari中，已自动屏蔽了这种XSS，形如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180928233926158-2125156584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个屏蔽是由 XSS Auditor操作的，它由HTTP返回头部进行控制，有四个可选值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;X-XSS-Protection : 0    关闭浏览器的XSS防护机制
X-XSS-Protection : 1    删除检测到的恶意代码(如果不指定，IE将默认使用这个)
X-XSS-Protection : 1; mode=block   如果检测到恶意代码，将不渲染页面 (如果不指定，Chrome将默认使用这个)
X-XSS-Protection : 1; report=&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;reporting-uri&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 删除检测到的恶意代码，并通过report-uri发出一个警告。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前三个在IE和Chrome中有效，最后一个只在Chrome中有效&lt;/p&gt;
&lt;p&gt;可以手动在设置请求头看看变化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;header&lt;/span&gt;('X-XSS-Protection: 1; mode=block');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建议配置为后两个的结合，禁止页面渲染并进行上报&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;header&lt;/span&gt;('X-XSS-Protection: 1; mode=block; report=www.xss.report');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不建议仅仅配置为1，因为它删除恶意代码的功能有时比较鸡肋，可能会弄巧成拙。&lt;/p&gt;
&lt;p&gt;另外，这个配置只能充当辅助作用，不能完全依赖，其也可能会产生&lt;a class=&quot;external-link&quot; href=&quot;https://blog.innerht.ml/the-misunderstood-x-xss-protection/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;一些问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不过在Firefox中并未屏蔽&lt;/p&gt;
&lt;p&gt;在IE中的XSS Filter也默认也开启了屏蔽，也可手动关闭试试，或者通过HTTP头部进行控制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180928234049892-380279664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180928234108052-1626554972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;id-前端XSS相关整理-1.1.2存储型XSS&quot;&gt;&lt;span&gt;1.1.2 存储型XSS&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;提交的XSS代码会存储在服务器端，服务端未进行处理或处理不当，每个人访问相应页面的时候，将会执行XSS代码&lt;/p&gt;
&lt;p&gt;如本文开始的第一个例子&lt;/p&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.1.3DOM-base型XSS&quot;&gt;&lt;span&gt;1.1.3 DOM-base 型XSS&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这个类型和反射型的有点类似，区别是它不需要服务端参与&lt;/p&gt;
&lt;p&gt;比如在JS中直接获取URL中的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Payload: alert('xss')
http://local.abc.com/main/?r=abc/index#alert('xss')
 
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; hash &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; eval(location.hash.slice(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外，有些攻击方式的类型是单一的，有些是混合的。防范攻击，不应仅根据类型来防范，而应根据输入输出的不同来应对。&lt;/p&gt;
&lt;p&gt;在反射型和DOM-base型中，一般会通过设置一些有诱导性质的链接，用户点击链接后则触发链接中的XSS&lt;/p&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-ContentSecurityPolicy（CSP）内容安全策略&quot;&gt;&lt;span&gt;Content Security Policy（CSP）内容安全策略&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;为了防范XSS，&lt;a class=&quot;external-link&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;CSP&lt;/a&gt;出现了。&lt;/p&gt;
&lt;p&gt;CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，提供了这种白名单之后，实现和执行则由浏览器完成&lt;/p&gt;
&lt;p&gt;通过一系列的&lt;a class=&quot;external-link&quot; href=&quot;http://www.ruanyifeng.com/blog/2016/09/csp.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;自定义配置&lt;/a&gt;，可以在很大程度上防止恶意脚本的攻击，建议进行配置。&lt;/p&gt;
&lt;p&gt;不过策略比较新，在各浏览器也有一些兼容性的问题。另外，似乎还是可以通过&lt;a class=&quot;external-link&quot; href=&quot;https://mp.weixin.qq.com/s/z_XmhrTUg_yUfkyAFFfaKQ&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;一些手段&lt;/a&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://buer.haus/2017/03/08/airbnb-when-bypassing-json-encoding-xss-filter-waf-csp-and-auditor-turns-into-eight-vulnerabilities/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;绕过&lt;/a&gt;的，这里就不展开了&lt;/p&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-Cookie配置&quot;&gt;&lt;span&gt;Cookie 配置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;大多使用cookie来实现对用户的认证。如果攻击者拿到了这个认证cookie，就可以登录了用户的账号了&lt;/p&gt;
&lt;p&gt;XSS的主要目的是为了得到cookie，当然也不仅是为了获取cookie&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://wps2015.org/drops/drops/%E6%88%91%E7%9A%84%E9%80%9A%E8%A1%8C%E4%BD%A0%E7%9A%84%E8%AF%81.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;cookie安全注意点&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Httponly：防止cookie被xss偷&lt;/p&gt;
&lt;p&gt;https：防止cookie在网络中被偷&lt;/p&gt;
&lt;p&gt;Secure：阻止cookie在非https下传输，很多全站https时会漏掉&lt;/p&gt;
&lt;p&gt;Path :区分cookie的标识，安全上作用不大，和浏览器同源冲突&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过设置 cookie的几个属性，可以在一定程度上保障网站的安全&lt;/p&gt;
&lt;p&gt;不过并没有十全十美的东西，虽然攻击门槛提高了，但HttpOnly在某些特定情况下还是能绕过的，道高一尺魔高一点一尺呀&lt;/p&gt;

&lt;h2 id=&quot;id-前端XSS相关整理-1.2执行JS代码&quot;&gt;&lt;span&gt;1.2 执行JS代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;XSS的目的一般是盗取cookie，一般需要通过JS 的 document.cookie来获取这个值。&lt;/p&gt;
&lt;p&gt;所以要先思考的是：&lt;strong&gt;在什么地方可以执行JS相关的代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后要思考的是：&lt;strong&gt;攻击者能不能在这些地方构造出能够执行的脚本&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.2.1&amp;lt;script&amp;gt;标签中&quot;&gt;&lt;span&gt;1.2.1  &amp;lt;script&amp;gt;标签中&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.2.2HTML中的某些事件&quot;&gt;&lt;span&gt;1.2.2 HTML中的某些事件&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; onerror&lt;/span&gt;&lt;span&gt;=&quot;alert(1)&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; onfocus&lt;/span&gt;&lt;span&gt;=&quot;alert(1)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;onmouseover&lt;/span&gt;&lt;span&gt;=&quot;alert(1)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.2.3javascript:伪协议&quot;&gt;&lt;span&gt;1.2.3  javascript: 伪协议&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:alert(1)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iframe &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;javascript:alert(1)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
 
location.href = 'javascript:alert(1)'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于事件的执行触发，是有机会防御的，围观 &lt;a href=&quot;http://www.cnblogs.com/coco1s/p/5777260.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.2.4base64编码的data:伪协议&quot;&gt;&lt;span&gt;1.2.4  base64编码的  data: 伪协议&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Payload: &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;XSS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; ，它的base64编码为PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.2.5css中的expression表达式&quot;&gt;&lt;span&gt;1.2.5  css中的expression表达式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;仅在IE8以下才支持expression，可以忽略这个了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color:1;zoom:expression(alert(1));&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.2.6css中的src&quot;&gt;&lt;span&gt;1.2.6 css中的src&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;很多文章都说到这个payload，然鹅并没有生效，不知真假&lt;/p&gt;
&lt;p&gt;根据&lt;a class=&quot;external-link&quot; href=&quot;https://stackoverflow.com/questions/3607894/cross-site-scripting-in-css-stylesheets&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;一些讨论&lt;/a&gt;，在css中是很难实现xss的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.abc &lt;/span&gt;{&lt;span&gt;
    background&lt;/span&gt;:&lt;span&gt; url(...)
&lt;/span&gt;} 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.2.7使用eval、newFunction、setTimeout执行字符串时&quot;&gt;&lt;span&gt;1.2.7 使用 eval、new Function、setTimeout 执行字符串时&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
setTimeout('alert(1)'&lt;span&gt;);
 
eval(&lt;/span&gt;'alert(2)'&lt;span&gt;);
 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; f = &lt;span&gt;new&lt;/span&gt; Function('alert(3)'&lt;span&gt;);
f();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&quot;id-前端XSS相关整理-1.3编码与解码&quot;&gt;&lt;span&gt;1.3 编码与解码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;防范XSS，比较通用的做法是：提交保存前对特殊字符进行过滤转义，进行HTML实体的编码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; escape =&lt;span&gt; {
    &lt;/span&gt;'&amp;amp;': '&amp;amp;amp;'&lt;span&gt;,
    &lt;/span&gt;'&amp;lt;': '&amp;amp;lt;'&lt;span&gt;,
    &lt;/span&gt;'&amp;gt;': '&amp;amp;gt;'&lt;span&gt;,
    &lt;/span&gt;'&quot;': '&amp;amp;quot;'&lt;span&gt;,
    &lt;/span&gt;&quot;'&quot;: '&amp;amp;#x27;'&lt;span&gt;,
    &lt;/span&gt;'`': '&amp;amp;#x60;'&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;事实上，仅仅这样做还是不够的&lt;/p&gt;
&lt;p&gt;那为什么要进行HTML实体的编码呢？&lt;/p&gt;
&lt;p&gt;这涉及到浏览器的解析过程。&lt;/p&gt;
&lt;p&gt;浏览器在解析HTML文档期间，根据文档中的内容，会经过 HTML解析、JS解析和URL解析几个过程&lt;/p&gt;

&lt;p&gt;首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这完成HTML解码工作并创建DOM树。&lt;/p&gt;
&lt;p&gt;如果HTML文档中存在JS的上下文环境，JavaScript解析器会介入对内联脚本进行解析，完成JS的解码工作。&lt;/p&gt;
&lt;p&gt;如果浏览器遇到需要URL的上下文环境，URL解析器也会介入完成URL的解码工作。&lt;/p&gt;
&lt;p&gt; URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析&lt;/p&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.3.1HTML实体编码&quot;&gt;&lt;span&gt;1.3.1 HTML实体编码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;浏览器会对一些字符进行特殊识别处理，比如将 &amp;lt; &amp;gt; 识别为标签的开始结束。&lt;/p&gt;
&lt;p&gt;要想在HTML页面中呈现出特殊字符，就需要用到对应的字符实体。比如在HTML解析过程中，如果要求输出值为 &amp;lt; &amp;gt; ，那么输入值应该为其对应的实体 &amp;amp;lt; &amp;amp;gt;&lt;/p&gt;

&lt;p&gt;字符实体以&amp;amp;开头 + 预先定义的实体名称，以分号结束，如“&amp;lt;”的实体名称为&amp;amp;lt; &lt;/p&gt;
&lt;p&gt;或以&amp;amp;开头 + #符号 以及字符的十进制数字，如”&amp;lt;”的实体编号为&amp;amp;#60;&lt;/p&gt;
&lt;p&gt;或以&amp;amp;开头 + #x符号 以及字符的十六进制数字，如”&amp;lt;”的实体编号为&amp;amp;#x3c;&lt;/p&gt;
&lt;p&gt;字符都是有实体编号的但有些字符没有实体名称。&lt;/p&gt;

&lt;p&gt;&lt;a class=&quot;external-link&quot; href=&quot;http://www.goodxyx.com/tool/transcode.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;普通编码与实体编码的在线转换&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.3.2Javascript编码&quot;&gt;&lt;span&gt;1.3.2 Javascript编码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Unicode 是字符集，而 utf-8,utf-16,utf-32 是编码规则&lt;/p&gt;
&lt;p&gt;最常用的如“\uXXXX”这种写法为Unicode转义序列，表示一个字符，其中xxxx表示一个16进制数字&lt;/p&gt;
&lt;p&gt;如”&amp;lt;” Unicode编码为“\u003c”，不区分大小写&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;external-link&quot; href=&quot;http://www.goodxyx.com/tool/transcode.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;普通编码与Unicode转义序列的在线转换&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;external-link&quot; href=&quot;https://unicode-table.com/en/#control-character&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Unicode字符集大全&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.3.3URL编码&quot;&gt;&lt;span&gt;1.3.3 URL编码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;%&lt;/strong&gt;加字符的ASCII编码对于的2位16进制数字，如”/”对应的URL编码为%2f&lt;/p&gt;
&lt;p&gt;转换可以使用 JS 自带的 encodeURIComponent 和 decodeURLComponent 方法来对特殊字符进行转义，也可以对照ASCII表为每个字符进行转换&lt;/p&gt;
&lt;h3 id=&quot;id-前端XSS相关整理-1.3.4编码解码分析&quot;&gt;&lt;span&gt;1.3.4 编码解码分析&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;a&amp;lt;b&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
等价于
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;a&amp;amp;lt;b&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码中&lt;/p&gt;
&lt;p&gt;编码顺序：HTML编码&lt;/p&gt;
&lt;p&gt;解码顺序：HTML解码&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;//www.baidu.com?a=1&amp;amp;b=2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
等价于
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;//www.baidu.com?a=1%26b=2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
等价于
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;//www.baidu.com?a=1&amp;amp;#37;&amp;amp;#50;&amp;amp;#54;b=2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码中&lt;/p&gt;
&lt;p&gt;编码顺序：URL编码 -&amp;gt; HTML编码&lt;/p&gt;
&lt;p&gt;解码顺序：HTML解码 -&amp;gt; URL解码&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;alert(1)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
等价于
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;\u0061\u006c\u0065\u0072\u0074(1)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
等价于
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#92;&amp;amp;#117;&amp;amp;#48;&amp;amp;#48;&amp;amp;#54;&amp;amp;#49;&amp;amp;#92;&amp;amp;#117;&amp;amp;#48;&amp;amp;#48;&amp;amp;#54;&amp;amp;#99;&amp;amp;#92;&amp;amp;#117;&amp;amp;#48;&amp;amp;#48;&amp;amp;#54;&amp;amp;#53;&amp;amp;#92;&amp;amp;#117;&amp;amp;#48;&amp;amp;#48;&amp;amp;#55;&amp;amp;#50;&amp;amp;#92;&amp;amp;#117;&amp;amp;#48;&amp;amp;#48;&amp;amp;#55;&amp;amp;#52;&amp;amp;#40;&amp;amp;#49;&amp;amp;#41;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码中&lt;/p&gt;
&lt;p&gt;编码顺序：Javascript编码 -&amp;gt; HTML编码&lt;/p&gt;
&lt;p&gt;解码顺序：HTML解码 -&amp;gt; Javascript解码&lt;/p&gt;
&lt;p&gt;需要注意的是，在JS的解码中，相关的标识符才能被正确解析（如这里的 alert 标识符），&lt;/p&gt;
&lt;p&gt;像圆括号、双引号、单引号等等这些控制字符，在进行JavaScript解析的时候仅会被解码为对应的字符串文本（比如这里并未对 (1) 进行编码，如果对括号及括号里面内容做JS编码，将无法执行alert函数 ）&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:alert(1&amp;lt;2)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
等价于
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:\u0061\u006c\u0065\u0072\u0074(1&amp;lt;2)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
等价于（使用JS的方法进行的URL编码）
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:alert(1%3C2)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
等价于（使用转换成对应ASCII编码对应2位16进制数字的URL编码）
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34%28%31%3C%32%29&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
等价于
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#106;&amp;amp;#97;&amp;amp;#118;&amp;amp;#97;&amp;amp;#115;&amp;amp;#99;&amp;amp;#114;&amp;amp;#105;&amp;amp;#112;&amp;amp;#116;&amp;amp;#58;&amp;amp;#97;&amp;amp;#108;&amp;amp;#101;&amp;amp;#114;&amp;amp;#116;&amp;amp;#40;&amp;amp;#49;&amp;amp;#37;&amp;amp;#51;&amp;amp;#67;&amp;amp;#50;&amp;amp;#41;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码中&lt;/p&gt;
&lt;p&gt;编码顺序：Javascript编码 -&amp;gt; URL编码 -&amp;gt; HTML编码&lt;/p&gt;
&lt;p&gt;解码顺序：HTML解码 -&amp;gt; URL解码 -&amp;gt; Javascript解码&lt;/p&gt;
&lt;p&gt;这里还需要注意的是，在URL的编码中，不能对协议类型（这里的 javascript: ）进行编码，否则URL解析器会认为它无类型，导致无法正确识别&lt;/p&gt;

&lt;p&gt;应用这个解析顺序，看以下这个例子&lt;/p&gt;
&lt;p&gt;输入源 abc为URL中的值，如果后端仅进行了HTML的编码，还是有问题的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Payload-0: http://local.abc.com/main/?r=abc/index&lt;span&gt;&amp;amp;abc&lt;/span&gt;&lt;span&gt;=');alert('11
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;test('&amp;lt;{$abc}&amp;gt;')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;test('&amp;amp;#x27;);alert(&amp;amp;#x27;11')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解码顺序先是进行HTML解码，此时会将 &amp;amp;#x27解析成 ' 号，接着进行Javascript的解码，识别到 ' 即可闭合test函数，调用成功&lt;/p&gt;
&lt;p&gt;所以，这种情况下，后端需要先进行Javascript编码再进行HTML的编码&lt;/p&gt;

&lt;p&gt;当然，还有其他顺序的混合。也需要考虑编码工作能不能正确地进行过滤&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:window.open('[输入源]')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解码顺序：&lt;/p&gt;
&lt;p&gt;HTML解码 -&amp;gt; URL解码 -&amp;gt; Javascript解码 -&amp;gt; URL解码&lt;/p&gt;

&lt;p&gt;引申出去，还有一些&lt;a class=&quot;external-link&quot; href=&quot;http://blog.rakeshmane.com/2017/08/xssing-web-part-2.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;字符集&lt;/a&gt;的知识点，脑壳疼，就不在这整理了&lt;/p&gt;

&lt;h3 id=&quot;id-前端XSS相关整理-1.4常见XSS攻击方式&quot;&gt;&lt;span&gt;1.4 常见XSS攻击方式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;XSS的攻击脚本多种多样，在使用了模板（前端模板和后端模板）之后，需要格外注意数据的输入输出&lt;/p&gt;
&lt;p&gt;下面列举几个常见的&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4.1 PHP使用Yii框架中的Smarty模板&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有时候会使用 $smarty.get.abc 获取URL中的参数，未经转义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Payload-1: http://local.abc.com/main/?r=abc/index&lt;span&gt;&amp;amp;abc&lt;/span&gt;=&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;{$smarty&lt;/span&gt;&lt;span&gt;.get.abc}&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
 
Payload-2: http://local.abc.com/main/?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;abc&lt;/span&gt;=&quot;&amp;gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/main/?param=&amp;lt;{$smarty.get.abc}&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/main/?param=&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&quot;&amp;gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
 
Payload-3: http://local.abc.com/main/?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;abc&lt;/span&gt;&lt;span&gt;=&quot; onmouseover=alert(1)
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/main/?param=&amp;lt;{$smarty.get.abc}&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/main/?param=&quot;&lt;/span&gt;&lt;span&gt; onmouseover&lt;/span&gt;&lt;span&gt;=&quot;alert(1)&quot;&lt;/span&gt;&lt;span&gt; &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;abc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
 
Payload-4: http://local.abc.com/main/?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;urlTo&lt;/span&gt;&lt;span&gt;=javascript:alert(1)
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;&amp;lt;{$smarty.get.urlTo}&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;urlTo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:alert(1)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;urlTo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
 
Payload-5: http://local.abc.com/main/?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;urlTo&lt;/span&gt;&lt;span&gt;=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pgo=
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;&amp;lt;{$smarty.get.urlTo}&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;urlTo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 对 &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; 进行 base64编码 为 PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pgo= &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pgo=&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;urlTo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
 
Payload-6: http://local.abc.com/main/?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;abc&lt;/span&gt;=&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; abc &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;{$smarty.get.abc}&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个 script标签被闭合，虽然会报错，但不会影响第二个script标签，注意需要闭合后面的引号或注释，防止报错&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; abc &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;';&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
 
Payload-7: http://local.abc.com/main/?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;abc&lt;/span&gt;&lt;span&gt;=alert(1)
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;{$smarty.get.abc}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
        console.log(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处因为没有用引号，所以可以直接执行 alert(1)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;==&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
        console.log(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
 
Payload-8: http://local.abc.com/main/?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;abc&lt;/span&gt;&lt;span&gt;='){}if(alert(1)){//
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;{$smarty.get.abc}&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
        console.log(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用了引号之后，闭合难度增加，不过还是可以闭合起来的&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;){}&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)){&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;' == 'abc') {&lt;/span&gt;
&lt;span&gt;        console.log(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
 
Payload-9: http://local.abc.com/main/?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;abc&lt;/span&gt;&lt;span&gt;=');alert('1
Payload-10: http://local.abc.com/main/?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;abc&lt;/span&gt;&lt;span&gt;=%26%2339%3B);alert(%26%2339%3B1    对参数进行了HTML的实体编码
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;test('&amp;lt;{$smarty.get.abc}&amp;gt;')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;test('');alert('1')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
 
Payload-11: http://local.abc.com/main/?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;abc&lt;/span&gt;&lt;span&gt;=&quot; onfocus=&quot;alert(1)&quot; autofocus=&quot;autofocus&quot;
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&amp;lt;{$smarty.get.abc}&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; onfocus&lt;/span&gt;&lt;span&gt;=&quot;alert(1)&quot;&lt;/span&gt;&lt;span&gt; autofocus&lt;/span&gt;&lt;span&gt;=&quot;autofocus&quot;&lt;/span&gt;&lt;span&gt; &quot;&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a class=&quot;external-link&quot; href=&quot;http://tool.oschina.net/encrypt?type=3&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;在线 base64编码解码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方式为：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不使用 $smarty.get 相关获取参数，改用后端过滤数据后再返回参数；&lt;/p&gt;
&lt;p&gt;Yii框架中相应位置配置：'escape_html' =&amp;gt; true&lt;/p&gt;
&lt;p&gt;在页面标签内嵌的脚本中直接使用后端返回的数据并不安全，后端可能过滤不完善（见Payload-7和Payload-0）避免直接使用&lt;/p&gt;
&lt;p&gt;可以改用将数据存储在属性中，再通过脚本获取属性的方式&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4.2 JS操作DOM的时候是否会有XSS隐患？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用 jQuery的append相关方法时（比如 html方法）可能会&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行&lt;/span&gt;
$($0).html('&amp;lt;script&amp;gt;alert(1);&amp;lt;/script&amp;gt;'&lt;span&gt;);
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行&lt;/span&gt;
$($0).html('\u003cscript\u003ealert(1);\u003c/script\u003e'&lt;span&gt;);
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行&lt;/span&gt;
$($0).append('&amp;lt;script&amp;gt;alert(1);&amp;lt;/script&amp;gt;'&lt;span&gt;);
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不执行&lt;/span&gt;
$0.innerHTML = '&amp;lt;script&amp;gt;alert(1);&amp;lt;/script&amp;gt;';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原因是在jQuery中使用了eval方法执行相应的脚本，需要注意的是，Unicode编码的字符在运算中会被解析出来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180928234832865-191998875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180928234842536-625465781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，要注意的是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用jQuery设置DOM内容时，记得先对内容进行转义&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于设置输入框的值，是安全的&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;12&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;textarea&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不执行&lt;/span&gt;
&lt;span&gt;    document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).value &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&amp;lt;script&amp;gt;alert(1);&amp;lt;\/script&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).value &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&amp;lt;script&amp;gt;alert(1);&amp;lt;\/script&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
     
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不执行&lt;/span&gt;
&lt;span&gt;    $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot; onmouseover=&quot;alert(1)&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#textarea&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot; onmouseover=&quot;alert(1)&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;对于设置属性的值，是安全的&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;12&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;textarea&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不执行&lt;/span&gt;
&lt;span&gt;    document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).setAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&amp;lt;script&amp;gt;alert(1);&amp;lt;\/script&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).setAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&amp;lt;script&amp;gt;alert(1);&amp;lt;\/script&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不执行&lt;/span&gt;
&lt;span&gt;    $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).attr(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot; onmouseover=&quot;alert(1)&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#textarea&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).attr(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot; onmouseover=&quot;alert(1)&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180928234936400-780841163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4.3 前端Handlebars模板中的安全问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;后端有Smarty模板，前端也可以有Handlebars模板，使用模板有利于开发维护代码。不过和后端一样，使用模板也要考虑到XSS的问题&lt;/p&gt;
&lt;p&gt;Handlebars模板中可选择是否开启转义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 转义，如果name的值已经被后端转义为实体符&amp;amp;gt; 那么Handlebars将会转换成 &amp;amp;amp;gt; 在浏览器中将会显示 &amp;amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 所以此时需要先将 &amp;amp;gt; 转回 &amp;gt; 再传入Handlebars模板，才能看到正确的 &amp;gt; 符号 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 不转义 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{{name}}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以要注意的第一点是：&lt;/p&gt;
&lt;p&gt;如果使用了转义占位符，就需要先进行还原；如果不使用转义，就不要还原，否则将造成XSS&lt;/p&gt;
&lt;p&gt;另外，Handlebars模板可以自定义helper，helper有两种使用方式，直接返回数据或返回子层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 模板 [A] &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/template&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;test-tpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span abc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{#abc attrData}}{{/abc}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;{{#abc data}}{{&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;abc}}&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{#abc attrData}}{{/abc}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;span&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 模板 [B] &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;script type=&quot;text/template&quot; id=&quot;test-tpl&quot;&amp;gt;
    &amp;lt;span abc=&quot;{{#abc attrData}}{{attrData}}{{/abc}}&quot;&amp;gt;111{{#abc data}}{{data}}{{/abc}}&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;
        &amp;lt;input type=&quot;text&quot; value=&quot;{{#abc attrData}}{{attrData}}{{/abc}}&quot;&amp;gt;
    &amp;lt;/span&amp;gt;
&amp;lt;/script&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
 
 
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 容器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;........./handlebars/handlebars-v4.0.5.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义helper&lt;/span&gt;
&lt;span&gt;    Handlebars.registerHelper(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (text, options) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对输入数据进行过滤 [1]&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; text = Handlebars.Utils.escapeExpression(text)&lt;/span&gt;
 
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; helper直接返回数据 [2]&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; text;
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; helper返回子层 [3]&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; return options.fn(this);&lt;/span&gt;
&lt;span&gt;    });
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Handlebars获取数据&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getHtml(html, data) {
        let source &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Handlebars.compile(html);
        let content &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; source(data);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; content;
    }
 
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; data &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;script&amp;gt;alert(1);&amp;lt;\/script&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; attrData &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot; onmouseover=&quot;alert(2)&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 渲染&lt;/span&gt;
&lt;span&gt;    $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).html(getHtml($(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#test-tpl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).html(), {
        data: data,
        attrData: attrData
    }));
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入页面后，将会执行 alert(1) ,然后鼠标滑过span或input元素，将会执行 alert(2)&lt;/p&gt;
&lt;p&gt;这是因为Handlebars在处理helper时，如果是返回数据，将不进行转义过滤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案为：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果使用了自定义的helper直接返回数据，先转义一遍，即取消注释[1] 处 代码&lt;/p&gt;
&lt;p&gt;或者不直接返回数据，即注释模板[A]，[1] 和[2]处，取消注释模板[B]，[3]处 代码&lt;/p&gt;

&lt;p&gt;另外，前端模板会频繁和JS进行交互，在前端直接使用JS获取URL参数并放到模板中时，要格外注意防止产生DOM-base型XSS，如下面这段代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Payload: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;local.abc.com/main/?r=abc/index&amp;amp;param=%22%20onmouseover=%22alert(2)%22&lt;/span&gt;
 
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getUrlParam(name) {
    let value &lt;/span&gt;= window.location.search.match(&lt;span&gt;new&lt;/span&gt; RegExp('[?&amp;amp;]' + name + '=([^&amp;amp;]*)(&amp;amp;?)', 'i'&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value ? decodeURIComponent(value[1]) : ''&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; attrData = getUrlParam('param');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4.4  React JSX模板中的 dangerouslySetInnerHTML&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;dangerouslySetInnerHTML&lt;/span&gt;&lt;span&gt;={{__html: &lt;/span&gt;&lt;span&gt;'&amp;lt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;alert(1);&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;'}}&amp;gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码会执行么&lt;/p&gt;
&lt;p&gt;事实上，并不会。与模板不同，它使用的是 innerHTML来更新DOM元素的内容，所以不会执行恶意代码&lt;/p&gt;
&lt;p&gt;不过，这个内容不会显示在页面中，如果这时正常的一段内容，就应该转义之后再放入 __html的值中&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4.5 在React的服务端渲染中，也要注意安全问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;服务端渲染需要一个初始的state，并与客户端做对应&lt;/p&gt;
&lt;p&gt;可能会长这样子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 客户端 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;|- &lt;/span&gt;&lt;span&gt;appHtml |&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;preload-state&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; PRELOAD_STATE &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&amp;lt;|-&lt;/span&gt;&lt;span&gt; preloadState &lt;/span&gt;&lt;span&gt;|&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
 
// 服务端
res.render('xxx.html', {
    appHtml: appHtml,
    preloadState: JSON.stringify(preloadState).replace(/&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;g, '\\u003c')
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似模板，服务端将数据传给客户端时，在模板组装数据的时候要防止构造出闭合 &amp;lt;script&amp;gt;标签的情景&lt;/p&gt;
&lt;p&gt;这里可以将 &amp;lt; 替换成对应的Unicode字符串，在JS中获取该字符串时，可以直接识别为 &amp;lt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4.6 百度编辑器的编辑源码，可能会有安全问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180928235143246-854639172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在编辑器内直接输入这串内容，不会执行。点击查看源码，可以看到已经经过转义&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180928235155990-1685731555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以直接在这里修改源码&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180928235207710-101690919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再切换回去，一个XSS漏洞就产生了，如果稍加不注意就会被利用。&lt;/p&gt;
&lt;p&gt;所以，在前端范畴必须将此入口去除，后端也应加强一些特殊字符的转义&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180928235221438-1296088834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4.7 谨防 javascript: 伪协议&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;链接中带有 javascript: 伪协议可执行对应的脚本，常见于 a 的 href 标签和 iframe的 src 中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:alert(1)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 冒号: 的HTML实体符 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript&amp;amp;#58;alert(1)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iframe &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;javascript:alert(1)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入源多为一个完整的URL路径，输出地方多为模板与JS的操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;&amp;lt;{$urlTo}&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;{{{urlTo}}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
location.href = getUrlParam('urlTo');&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;普通的HTML实体符并不能过滤这个伪协议&lt;/p&gt;
&lt;p&gt;需要知道的是，javascript: 能够正常工作的前提为：开始URL解析时没有经过编码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 前端后端都要先对 '&quot;&amp;gt;&amp;lt;&amp;amp; 这些特殊字符进行过滤转义，特别是在与模板共用时，它们很有可能会闭合以产生攻击，或者利用浏览器解码的顺序来绕过不严格的过滤&lt;/p&gt;
&lt;p&gt;2.严格要求输入的URL以 https:// 或 http:// 协议开头&lt;/p&gt;
&lt;p&gt;3.严格限制白名单协议虽然可取，但有时会造成限制过头的问题。还可以单独限制伪协议，直接对 javascript: 进行过滤&lt;/p&gt;
&lt;p&gt;过滤时需要兼容多层级的嵌套： javajavajavascript:script:script:alert(1) &lt;/p&gt;
&lt;p&gt;同时显示的时候，将多余的冒号 : 转义成URL编码，注意避免把正常的协议头也转义了，要兼容正常的URL&lt;/p&gt;
&lt;p&gt;转义冒号要使用 encodeURIComponent , encodeURI转义不了，另外escape也不建议使用，关于&lt;a class=&quot;external-link&quot; href=&quot;https://stackoverflow.com/questions/75980/when-are-you-supposed-to-use-escape-instead-of-encodeuri-encodeuricomponent&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;三者的区别&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; replaceJavascriptScheme(str) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;str) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ''&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; str.replace(/:/g, encodeURIComponent(':'&lt;span&gt;));
}
 
Handlebars.registerHelper(&lt;/span&gt;'generateURL', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (url) {
    url &lt;/span&gt;=&lt;span&gt; Handlebars.Utils.escapeExpression(url);
 
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;url) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ''&lt;span&gt;;
    }
 
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; schemes = ['//', 'http://', 'https://'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; schemeMatch = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
 
    schemes.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(scheme) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (url.slice(0, scheme.length) ===&lt;span&gt; scheme) {
            url &lt;/span&gt;= scheme +&lt;span&gt; replaceJavascriptScheme(url.slice(scheme.length));
            schemeMatch &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    });
 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; schemeMatch ? url : '//' +&lt;span&gt; replaceJavascriptScheme(url);;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4.8  注意符号的闭合  '&quot;&amp;gt;&amp;lt;  和其他特殊符号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;闭合标签，闭合属性是很常见的一种攻击方式，要重点关注哪里可能被恶意代码闭合。&lt;/p&gt;
&lt;p&gt;本文使用了模板Smarty，在使用模板的时候，一般都将模板变量放在了引号中，需要带符号来闭合来实现攻击&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;=&quot;&amp;lt;{$abc}&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
&quot; onclick=alert(1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在设置了特殊符号转义的情况下，这种攻击方式将失效&lt;/p&gt;
&lt;p&gt;然鹅当输出的数据不在引号当中时，防范难度将加大。因为分离属性可以使用很多符号，黑名单过滤可能列举不全&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;abc/index?abc=1 onclick=alert(1)
 
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;test1&quot;&lt;/span&gt;&lt;span&gt; abc&lt;/span&gt;&lt;span&gt;=&amp;lt;{$abc}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&amp;gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，尽量用引号包裹起变量&lt;/p&gt;
&lt;p&gt;另外，也要避免在 &amp;lt;script&amp;gt;标签中直接使用模板中的变量，可以改用将模板变量缓存在HTML属性中，JS再进行取值&lt;/p&gt;
&lt;p&gt;防止该 &amp;lt;script&amp;gt;标签被恶意代码闭合，然后执行恶意代码，例子可见上文的 Payload-6&lt;/p&gt;
&lt;p&gt;还要注意JS的语法，在某些时候，特殊符号 反斜杠\ 没有过滤的话，也有安全问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; aaaa &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?a=&amp;lt;{$a}&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;b=&amp;lt;{$b}&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
 
?r=abc/index&lt;/span&gt;&lt;span&gt;&amp;amp;a&lt;/span&gt;=\&lt;span&gt;&amp;amp;b&lt;/span&gt;&lt;span&gt;==alert(1);function b(){}//
 
 
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造处可执行的代码，如果空格也被转义了，还可以用注释占位 function/**/b(){}&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; aaaa &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?a=\' + &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;alert(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; b(){}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;';&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设只对 ' &quot; &amp;gt; &amp;lt; &amp;amp; 进行了转义，可以试试从URL拿数据，这里需要利用到JS代码中关键的 &amp;amp; 符号与 \ 转义符&lt;/p&gt;
&lt;p&gt;\ 将第一个分号转义为字符串&lt;/p&gt;
&lt;p&gt;&amp;amp; 与运算将前后分离&lt;/p&gt;
&lt;p&gt;b的参数加上 = 号构造处bool运算&lt;/p&gt;
&lt;p&gt;为了防止b未定义，在后面用函数提升特性来定义&lt;/p&gt;
&lt;p&gt;最后注释符防止报错&lt;/p&gt;
&lt;p&gt;为了攻击也是蛮拼的....所以最好还是要对JS操作的字符用反斜杠进行转义一下，比如 \  -&amp;gt; \\&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4.9 图片 exif 信息含有恶意代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;另一种XSS攻击的方式是在图片的exif信息中注入脚本，在读取图片信息时要注意过滤&lt;/p&gt;
&lt;p&gt;在早期的很多插件中都没有进行处理，如之前爆出的 &lt;a class=&quot;external-link&quot; href=&quot;https://www.hackersb.cn/hacker/140.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Chrome Exif Viewer&lt;/a&gt; 插件问题，可能还有相关插件没有这些意识，平时也要注意&lt;/p&gt;
&lt;p&gt;另外，站点自身在读取文件信息时也要注意，攻击者在上传文件前，可能会对文件的信息进行修改，过滤不当很可能就造成严重的存储型漏洞&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201809/688270-20180928235422188-666778837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 28 Sep 2018 16:00:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<og:description>前端安全方面，主要需要关注 XSS（跨站脚本攻击 Cross-site scripting） 和 CSRF（跨站请求伪造 Cross-site request forgery） 当然了，也不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/9721563.html</dc:identifier>
</item>
<item>
<title>CentOS&amp;.NET Core初试-4-安装守护服务(Supervisor) - ZeroDai</title>
<link>http://www.cnblogs.com/zerodai/p/9721524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zerodai/p/9721524.html</guid>
<description>&lt;h2 id=&quot;系列目录&quot;&gt;系列目录&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zerodai/p/9704300.html&quot; target=&quot;_blank&quot;&gt;CentOS的安装和网卡的配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zerodai/p/9704213.html&quot; target=&quot;_blank&quot;&gt;安装.NET Core SDK和发布网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zerodai/p/9710556.html&quot; target=&quot;_blank&quot;&gt;Nginx的安装和配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zerodai/p/9721524.html&quot; target=&quot;_blank&quot;&gt;安装守护服务(Supervisor)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;supervisor是什么&quot;&gt;Supervisor是什么？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://supervisord.org&quot;&gt;Supervisor&lt;/a&gt; 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。&lt;/p&gt;
&lt;h2 id=&quot;supervisor能干什么&quot;&gt;Supervisor能干什么？&lt;/h2&gt;
&lt;p&gt;Supervisor帮助我们解决在开发过程中遇到的以下问题：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ASP.NET Core应用程序运行在shell之中，如果关闭shell则会发现ASP.NET Core应用被关闭，从而导致应用无法访问，这种情况当然是我们不想遇到的，而且生产环境对这种情况是零容忍的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果ASP.NET Core进程意外终止那么需要人为连进shell进行再次启动，往往这种操作都不够及时。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果服务器宕机或需要重启我们则还是需要连入shell进行启动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装supervisor&quot;&gt;安装Supervisor&lt;/h2&gt;
&lt;p&gt;首先安装Python包管理工具（Supervisor使用Python开发的），然后再安装supervisor。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;yum install python-setuptools
easy_install supervisor&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;supervisor安装完成后会生成三个执行程序：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;supervisortd&lt;/strong&gt; :supervisor的守护进程服务（用于接收进程管理命令）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;supervisorctl&lt;/strong&gt; :客户端（用于和守护进程通信，发送管理进程的指令）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;echo_supervisord_conf&lt;/strong&gt; :生成初始配置文件程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;配置supervisor&quot;&gt;配置Supervisor&lt;/h2&gt;
&lt;p&gt;添加supervisor文件夹以及conf.d配置文件夹&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mkdir /etc/supervisor
echo_supervisord_conf &amp;gt; /etc/supervisor/supervisord.conf
mkdir /etc/supervisor/conf.d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改supervisord.conf文件,在文件尾部：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[include]
files=/etc/supervisor/conf.d/*.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动supervisor服务&quot;&gt;启动Supervisor服务&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;supervisord -c /etc/supervisor/supervisord.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;program的配置&quot;&gt;program的配置&lt;/h2&gt;
&lt;p&gt;在supervisor的conf.d文件夹下新建一个程序配置文件，hellocore.conf：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#配置程序名称
[program:hellocore]
#运行程序的命令
command=dotnet hellocore.dll 
#命令执行的目录
directory=/home/hellocore/ 
#错误日志文件
stderr_logfile=/var/log/hellocore.err.log
#输出日志文件
stdout_logfile=/var/log/hellocore.out.log 
#进程环境变量
environment=ASPNETCORE_ENVIRONMENT=Production 
#进程执行的用户身份
user=root
#程序是否自启动
autostart=true
#程序意外退出是否自动重启
autorestart=true
#启动时间间隔（秒）
startsecs=5
stopsignal=INT&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;重载supervisor的配置文件&quot;&gt;重载Supervisor的配置文件&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;supervisorctl reload #重新加载配置文件&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端相关命令：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;supervisorctl status #查看程序配置的状态
supervisorctl stop programname    #停止某一个程序配置
supervisorctl start programname   #加载某一个程序配置
supervisorctl restart programname #重新加载某一个程序配置
supervisorctl reload #重新加载配置
supervisorctl update&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看配置程序是否启动：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ps -ef | grep hellocore #programdllname&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图，则Supervisor配置成功：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/625771/201809/625771-20180928232903373-1592066006.png&quot; alt=&quot;Supervisor配置成功&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;设置supervisor开机启动&quot;&gt;设置Supervisor开机启动&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;文件夹下新建&lt;code&gt;supervisor.service&lt;/code&gt;配置文件，内容如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[Unit]
Description=supervisor
[Service]
Type=forking
ExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.conf
ExecStop=/usr/bin/supervisorctl shutdown
ExecReload=/usr/bin/supervisorctl reload
KillMode=process
Restart=on-failure
RestartSec=42s
[Install]
WantedBy=multi-user.target&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将服务设置为开机启动：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;systemctl enable supervisor.service
systemctl start supervisor.service&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;supervisor开机启动服务配置成功&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/625771/201809/625771-20180928232950434-1265262153.png&quot; alt=&quot;supervisor开机启动&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置supervisor图形化管理&quot;&gt;配置Supervisor图形化管理&lt;/h2&gt;
&lt;p&gt;打开supervisor的配置文件&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vi /etc/supervisor/supervisord.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到配置：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;;[inet_http_server]         ; inet (TCP) server disabled by default
;port=127.0.0.1:9001        ; (ip_address:port specifier, *:port for all iface)
;username=user              ; (default is no username (open server))ls
;password=123               ; (default is no password (open server))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改成：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[inet_http_server] ; inet (TCP) 服务，默认是关闭的
port=*:9001      ;ip:端口,*代表所有IP
username=root               ;登陆账号，可以不设
password=root123              ;登陆账户，可以不设&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存好修改后，重启supervisor。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;supervisorctl reload&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;防火墙查看9001端口是否开启&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;firewall-cmd --list-ports #查看已开放的端口&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开启端口：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;firewall-cmd --zone=public  --add-port=9001/tcp --permanent
firewall-cmd --reload #重启防火墙&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;命令含义：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;--zone #作用域
--add-port=9001/tcp  #添加端口，格式为：端口/通讯协议
--permanent  #永久生效，没有此参数重启后失效&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功访问：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/625771/201809/625771-20180928232959487-1713438483.png&quot; alt=&quot;supervisor图形界面&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Sep 2018 15:51:00 +0000</pubDate>
<dc:creator>ZeroDai</dc:creator>
<og:description>系列目录 1. CentOS的安装和网卡的配置 2. 安装.NET Core SDK和发布网站 3. Nginx的安装和配置 4. 安装守护服务(Supervisor) Supervisor是什么？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zerodai/p/9721524.html</dc:identifier>
</item>
<item>
<title>MyBatis(2)-全局配置文件 - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/9721330.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/9721330.html</guid>
<description>&lt;p&gt;本文的代码是在&lt;a href=&quot;https://www.cnblogs.com/Mrchengs/p/9721184.html&quot;&gt;MyBatis(1)-简单入门&lt;/a&gt;基础之上进行学习的，如有不懂请先看此博文&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/Mrchengs/p/9721184.html&quot;&gt;&lt;span&gt;MyBatis(1)-简单入门&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）配置文件的安装&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;---&amp;gt;未联网：去mybatis的jar包-&amp;gt;org.apache.ibatis.builder.xml-&amp;gt;文件夹下的两个.dtd文件解压&lt;/p&gt;
&lt;p&gt;                    点击选中我们的dtd地址选中-&amp;gt;preferences-&amp;gt;XML-&amp;gt;XML Catalog-&amp;gt;ADD-&amp;gt;Location是文件的地址，Key type必须选中URI，Key就是我们的dtd地址-&amp;gt;选择合适的地址&lt;/p&gt;
&lt;p&gt;                引入成功之后，我们输入在myeclipse中键盘Alt+/会有提示，需要关闭重启&lt;/p&gt;
&lt;p&gt;        目录如下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;                            &lt;img alt=&quot;&quot;/&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 2）属性讲解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1）&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;20.954326241135&quot;&gt;
&lt;p&gt;　　  properties:可以使用properties来引入外部的properties配置文件内容&lt;/p&gt;
&lt;p&gt;         属性：&lt;/p&gt;
&lt;p&gt;         resource：引用类路径下的资源&lt;/p&gt;
&lt;p&gt;         url：引入网络或者磁盘路径下的资源&lt;/p&gt;
&lt;p&gt;         db.properties在同一目录下，所以可以直接写处文件的名字&lt;/p&gt;
&lt;p&gt;         假设db.properties在com.MrChengs.db目录下&lt;/p&gt;
&lt;p&gt;         此时resource=&quot;com.MrChengs/db/db.properties&quot;&lt;/p&gt;
&lt;p&gt;　　  在于spring整合的时候就会相对比较少的使用这个属性！&lt;/p&gt;
&lt;div readability=&quot;19.455390889198&quot;&gt;2.1.1）首先建立db.properties文件，其目录如下图所示
&lt;p&gt;　　     注意：配置文件的位置，在resource里面的路径问题&lt;/p&gt;
&lt;div&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201809/1488757-20180928221131802-1769176879.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;db.properties&lt;/p&gt;
&lt;div readability=&quot;39.408055864791&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
jdbc.driver=&lt;span&gt;com.mysql.jdbc.Driver
jdbc.url&lt;/span&gt;=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3306/mybatis&lt;/span&gt;
jdbc.username=&lt;span&gt;root
jdbc.password&lt;/span&gt;=9876
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.1.2）在mybatis-config.xml文件中加入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;properties resource=&quot;db.properties&quot; &amp;gt;&amp;lt;/properties&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2.3）得到我们的数据信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
             &amp;lt;environment id=&quot;development&quot;&amp;gt;
                &amp;lt;transactionManager type=&quot;JDBC&quot; /&amp;gt;
                &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                     &amp;lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&amp;gt;
                &amp;lt;/dataSource&amp;gt;
           &amp;lt;/environment&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们再次运行之前的测试代码，一样可以查询出结果&lt;/p&gt;

&lt;p&gt; /------------------------------------------------------------分割线------------------------------------------------------------/&lt;/p&gt;

&lt;p&gt;2.2）&lt;span&gt;settings&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这是MyBatis中极为重要的调整设置，他会改变MyBatis的运行行为&lt;/p&gt;
&lt;p&gt;       用来设置每一个设置项的&lt;/p&gt;
&lt;p&gt;       有很多的属性标签&lt;/p&gt;
&lt;p&gt;       name:设置项的名字&lt;/p&gt;
&lt;p&gt;       value：设置项的取值&lt;/p&gt;

&lt;p&gt;　　 实例：mybatis-config.xml加入&lt;/p&gt;
&lt;div readability=&quot;78.793287827076&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
      &amp;lt;settings&amp;gt;
          &amp;lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&amp;gt;
      &amp;lt;/settings&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;假设我们数据库的字段和类的字段不一样：数据库----last_name   类----lastName   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时使用这个驼峰命名发，即可匹配到两者之间的关系，否杂而在查询的时候可能会显示为null&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此处不在做详细的测试，可以参考相关的文档。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; /------------------------------------------------------------分割线------------------------------------------------------------/&lt;/p&gt;

&lt;div readability=&quot;11&quot;&gt;&lt;span&gt;&lt;span&gt;2.3）&lt;/span&gt;&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;(别名处理器）
&lt;p&gt;&lt;span&gt;　　  把java类型起一个简单的名字，可以减少工作量&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.3.1）单个类起别名：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.3.1.1在mybatis-config.xml文件中： 此时使用默认的系统命名法&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &amp;lt;typeAliases&amp;gt;
           &amp;lt;!--&lt;span&gt; 为某个java类型起别名
                 type：指定起别名的全类名，默认就是类名小写
                    可以用alias为起指定新的别名
                    我们此时给Employee起别名
           &lt;/span&gt;--&amp;gt;
           &amp;lt;typeAlias type=&quot;com.MrChengs.bean.Employee&quot;/&amp;gt;
     &amp;lt;/typeAliases&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 2.3.1.2)在EmployeeMapper.xml文件中&lt;/p&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
     &amp;lt;!-- 接口式编程 --&amp;gt;
     &amp;lt;select id=&quot;getEmployee&quot; resultType=&quot;employee&quot;&amp;gt;&lt;span&gt;
           select id,name,gender,email from test where id &lt;/span&gt;=&lt;span&gt; #{id}
     &lt;/span&gt;&amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们继续使用上次的查询方法进行修改，在&lt;span&gt;默认&lt;/span&gt;不命名的情况下，是类的&lt;span&gt;小写&lt;/span&gt;！&lt;/p&gt;
&lt;p&gt;此时可以查询成功！&lt;/p&gt;

&lt;p&gt;2.3.2）使用alias&lt;/p&gt;
&lt;p&gt;2.3.2.1）在mybatis-config.xml文件中，是在2.3.1中的实例中加入alias&lt;/p&gt;
&lt;p&gt;此时把其类命名为emp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;typeAlias type=&quot;com.MrChengs.bean.Employee&quot; alias=&quot;emp&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.3.2.2）在EmployeeMapper.xml文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &amp;lt;select id=&quot;getEmployee&quot; resultType=&quot;emp&quot;&amp;gt;&lt;span&gt;
           select id,name,gender,email from test where id &lt;/span&gt;=&lt;span&gt; #{id}
  &lt;/span&gt;&amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; 此时可以查询成功！&lt;/p&gt;


&lt;p&gt;2.3.3）多个类一起起别名时&lt;/p&gt;
&lt;div readability=&quot;41.5&quot;&gt;2.3.3.1）在mybatis-config.xml
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;typeAliases&amp;gt;
   &amp;lt;!-- &lt;span&gt;package&lt;/span&gt;&lt;span&gt;:为某个包下的 所有类批量起别名
        name:指定包名（为当前包以及下面所有的后代包的每一个类都起一个别名（默认类名小写）
    &lt;/span&gt;--&amp;gt;
   &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;com.MrChengs.bean&quot;/&amp;gt;
 &amp;lt;/typeAliases&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.3.3.2）EmployeeMapper.xml文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;select id=&quot;getEmployee&quot; resultType=&quot;Employee&quot;&amp;gt;&lt;span&gt;
           select id,name,gender,email from test where id &lt;/span&gt;=&lt;span&gt; #{id}
&lt;/span&gt;&amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时查询是可以成功的！&lt;/p&gt;

&lt;p&gt;2.3.4）在多各类一起起别名时&lt;/p&gt;
&lt;p&gt;容易产生一个问题，假设此时子包里和父包了都有一个同名类&lt;/p&gt;
&lt;p&gt;此时MyBatis会很难进行区分，所有有以下的方法：&lt;/p&gt;
&lt;p&gt;2.3.4.1）在Employee.java中&lt;/p&gt;
&lt;p&gt;并且使用&lt;span&gt;@Alias进行重命名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201809/1488757-20180928224820862-228754157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.3.4.2）EmployeeMapper.xml文件中引用我们所创建的新的别名&quot;empl&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;select id=&quot;getEmployee&quot; resultType=&quot;empl&quot;&amp;gt;&lt;span&gt;
           select id,name,gender,email from test where id &lt;/span&gt;=&lt;span&gt; #{id}
&lt;/span&gt;&amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时会编译得到我们想要的答案！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：在起别名的时候，不区分大小写！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; /------------------------------------------------------------分割线------------------------------------------------------------/&lt;/p&gt;

&lt;p&gt;2.4）&lt;span&gt;typeHandlers&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;架起java类型和数据库类型的映射&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201809/1488757-20180928225316574-369771384.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;使用方法：&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201809/1488757-20180928225348114-1627062579.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt; /------------------------------------------------------------分割线------------------------------------------------------------/&lt;/p&gt;

&lt;p&gt;2.5）&lt;span&gt;plugins&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　待补充。。。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;46.5&quot;&gt;
&lt;p&gt; /------------------------------------------------------------分割线------------------------------------------------------------/&lt;/p&gt;

&lt;p&gt;2.6）&lt;span&gt;environments 环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　可以配置多种环境&lt;/p&gt;
&lt;p&gt;    &amp;lt;environments default=&quot;development&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;        　　default：可以指定使用那种环境，可以进行快速的切换&lt;/p&gt;
&lt;p&gt;    environment：配置一个具体的环境，可以配置多个具体环境，且必须配置              &lt;/p&gt;
&lt;p&gt;       　　 id：代表当前环境的唯一标识&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    transactionManager：事物管理器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        　　 type：事物管理器的类型，有两个取值    JDBC（使用mysql）/MANAGED（使用j2ee自带的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    dataSource：数据源&lt;/p&gt;
&lt;p&gt;      　　  type：数据源类型   POOLED（使用连接池）/JNDI/UNPOOLEN（不使用连接池）&lt;/p&gt;
&lt;p&gt;    property：数据源的相关信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
             &amp;lt;environment id=&quot;development&quot;&amp;gt;
                &amp;lt;transactionManager type=&quot;JDBC&quot; /&amp;gt;
                &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                     &amp;lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&amp;gt;
                &amp;lt;/dataSource&amp;gt;
           &amp;lt;/environment&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的讲解如上！&lt;/p&gt;

&lt;p&gt; /------------------------------------------------------------分割线------------------------------------------------------------/&lt;/p&gt;

&lt;p&gt;2.7）&lt;span&gt;databaseIdProvider&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　代码在environments标签下面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可移植性的重要性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　支持多数据库的厂商的&lt;/p&gt;
&lt;p&gt;2.7.1）在mybatis-config.xml&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;37.292118582791&quot;&gt;
&lt;pre&gt;
 type=&quot;DB_VENDOR&quot;&lt;span&gt;固定值，作用是得到数据库厂商的标识来执行不同的SQL语句&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&amp;gt;
           &amp;lt;!-- 为不同数据库起别名 --&amp;gt;
           &amp;lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&amp;gt;
           &amp;lt;property name=&quot;SqlSever value=&quot;sqlSever&quot;/&amp;gt;
        &amp;lt;/databaseIdProvider&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.7.2）引用方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201809/1488757-20180928230218499-2090677678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设此时databaseId=sqlSever，则执行的是SqlSever数据库！&lt;/p&gt;

&lt;p&gt; /------------------------------------------------------------分割线------------------------------------------------------------/&lt;/p&gt;

&lt;p&gt;2.8）&lt;span&gt;mappers&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　将sql映射注册到全局配置中&lt;/p&gt;
&lt;p&gt;　　mapper注册一个sql映射&lt;/p&gt;
&lt;p&gt;       resource：引用类路径下的sql映射文件&lt;/p&gt;
&lt;p&gt;       uri：引用网络或这磁盘路径下的sql映射文件&lt;/p&gt;
&lt;p&gt;       class:引用注册（接口）&lt;/p&gt;
&lt;p&gt;           有sql映射文件名必须和接口同名，并放在同意目录下&lt;/p&gt;
&lt;p&gt;   一般的mapper都放在mapper包里面&lt;/p&gt;
&lt;p&gt;    假设在mybatis.mapper包里面&lt;/p&gt;
&lt;p&gt;    则resource=&quot;mybatis/mapper/xxxx.xml&lt;/p&gt;

&lt;p&gt;在mybatis-config.xml文件的最底部&lt;/p&gt;
&lt;div readability=&quot;17.863276089828&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &amp;lt;mappers&amp;gt;
           &amp;lt;mapper resource=&quot;EmployeeMapper.xml&quot; /&amp;gt;
     &amp;lt;/mappers&amp;gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;此时此刻配置文件差不多讲到这里要结束了&lt;/p&gt;
&lt;p&gt;此时此刻，把本次博文是修改到的代码奉上，结合&lt;a href=&quot;https://www.cnblogs.com/Mrchengs/p/9721184.html&quot;&gt;MyBatis(1)-简单入门&lt;/a&gt;！&lt;/p&gt;

&lt;p&gt;3.1）mybatis-config.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!&lt;span&gt;DOCTYPE configuration
 PUBLIC &lt;/span&gt;&quot;-//mybatis.org//DTD Config 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;

        &amp;lt;!-- 
        1&lt;span&gt;.properties:可以使用properties来引入外部的properties配置文件内容
        属性：
        resource：引用类路径下的资源
        url：引入网络或者磁盘路径下的资源
        db.properties在同一目录下，所以可以直接写处文件的名字
        假设db.properties在com.MrChengs.db目录下
        此时resource&lt;/span&gt;=&quot;com.MrChengs/db/db.properties&quot;
         --&amp;gt;
    &amp;lt;properties resource=&quot;db.properties&quot; &amp;gt;&amp;lt;/properties&amp;gt;
    
    &amp;lt;!-- 
        2&lt;span&gt;.settings设置
        这是MyBatis中极为重要的调整设置，他会改变MyBatis的运行行为
        用来设置每一个设置项的
        name:设置项的名字
        value：设置项的取值
     &lt;/span&gt;--&amp;gt;
     &amp;lt;settings&amp;gt;
         &amp;lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&amp;gt;
     &amp;lt;/settings&amp;gt;
    
    &amp;lt;!-- 
        3&lt;span&gt;.typeAliases:别名处理器
     &lt;/span&gt;--&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;!--&lt;span&gt; 为某个java类型起别名
             type：指定起别名的全类名，默认就是类名小写
                可以用alias为起指定新的别名
                我们此时给Employee起别名 
        &lt;/span&gt;--&amp;gt;
        &amp;lt;typeAlias type=&quot;com.MrChengs.bean.Employee&quot; alias=&quot;emp&quot;/&amp;gt;
        &amp;lt;!--
             &lt;span&gt;package&lt;/span&gt;&lt;span&gt;:为某个包下的 所有类批量起别名
             name:指定包名（为当前包以及下面所有的后代包的每一个类都起一个别名（默认类名小写）
        &lt;/span&gt;--&amp;gt;
        &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;com.MrChengs.bean&quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;
    
    
    &amp;lt;environments &lt;span&gt;default&lt;/span&gt;=&quot;development&quot;&amp;gt;
        &amp;lt;environment id=&quot;development&quot;&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot; /&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;

    &amp;lt;!-- 
        5&lt;span&gt;.databaseIdProvider
        支持多数据库的厂商的
            type&lt;/span&gt;=&quot;DB_VENDOR&quot;&lt;span&gt;固定值，作用是得到数据库厂商的标识来执行不同的SQL语句
     &lt;/span&gt;--&amp;gt;
    &amp;lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&amp;gt;
        &amp;lt;!-- 为不同数据库起别名 --&amp;gt;
        &amp;lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&amp;gt;
    &amp;lt;/databaseIdProvider&amp;gt;

    &amp;lt;!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&quot;EmployeeMapper.xml&quot; /&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.2)EmployeeMapper.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!&lt;span&gt;DOCTYPE mapper
 PUBLIC &lt;/span&gt;&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.MrChengs.dao.EmployeeMapper&quot;&amp;gt;

     &amp;lt;!-- 原生 --&amp;gt;
    &amp;lt;select id=&quot;getId&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
        select id,name,gender,email from test where id &lt;/span&gt;=&lt;span&gt; #{id}
    &lt;/span&gt;&amp;lt;/select&amp;gt;
    
    &amp;lt;!-- 接口式编程 --&amp;gt;
    &amp;lt;select id=&quot;getEmployee&quot; resultType=&quot;empl&quot; databaseId=&quot;mysql&quot;&amp;gt;&lt;span&gt;
        select id,name,gender,email from test where id &lt;/span&gt;=&lt;span&gt; #{id}
    &lt;/span&gt;&amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;本次博文到此结束，谢谢您的浏览，如果问题，请提出，博主及时修改。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 28 Sep 2018 15:11:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>本文的代码是在MyBatis(1)-简单入门基础之上进行学习的，如有不懂请先看此博文MyBatis(1)-简单入门！ 1）配置文件的安装 &gt;在联网的情况下，点击去下载http://mybatis</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/9721330.html</dc:identifier>
</item>
<item>
<title>浅尝Spring Cloud Sleuth - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9716282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9716282.html</guid>
<description>&lt;p&gt;Spring Cloud Sleuth提供了分布式追踪(distributed tracing)的一个解决方案。其基本思路是在服务调用的请求和响应中加入ID，标明上下游请求的关系。利用这些信息，可以方便地分析服务调用链路和服务间的依赖关系。&lt;/p&gt;

&lt;p&gt;在Spring Tool Suite的文件菜单中，点击新建Spring Starter Project。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201809/991496-20180927225943168-538008881.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在请求处理方法内加上一行日志代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@SpringBootApplication
public class SpringcloudSleuthApplication {

    private static Logger log = LoggerFactory.getLogger(SpringcloudSleuthApplication.class);
    @RequestMapping(&quot;/&quot;)
    public String home() {
        log.info(&quot;Handling home&quot;);
        return &quot;Hello World&quot;;
    }

    public static void main(String[] args) {
        SpringApplication.run(SpringcloudSleuthApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设定应用程序端口及名称。&lt;/p&gt;
&lt;pre class=&quot;config&quot;&gt;
&lt;code&gt;server.port=10001

spring.application.name=sleuth-demo-without-zipkin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动程序并浏览页面后，可以看到日志信息里多了点东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201809/991496-20180927232211517-1662648561.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[sleuth-demo-without-zipkin,6c00dba1679ee164,6c00dba1679ee164,false]&lt;/p&gt;
&lt;p&gt;这一串数据里包含四个部分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;appname - 应用程序名称&lt;/li&gt;
&lt;li&gt;traceId - 追踪系统中的唯一标识&lt;/li&gt;
&lt;li&gt;spanId - 具体操作的唯一标识&lt;/li&gt;
&lt;li&gt;exportable - 是否日志要导出到Zipkin&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;zipkin-server&quot;&gt;Zipkin Server&lt;/h2&gt;
&lt;p&gt;要想把追踪数据发送到Zipkin上，首先需要建立一个Zipkin Server应用程序，在pom.xml里加上如下依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
  &amp;lt;/dependency&amp;gt;

  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
  &amp;lt;/dependency&amp;gt;

  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.zipkin.java&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;zipkin-server&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.11.5&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
  
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.zipkin.java&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;zipkin-autoconfigure-ui&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.11.5&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在启动类加上@EnableZipkinServer标记。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import zipkin2.server.internal.EnableZipkinServer;

@EnableZipkinServer
@SpringBootApplication
public class SpringcloudZipkinServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringcloudZipkinServerApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;application.properties文件中可修改默认端口，&lt;code&gt;server.port=10000&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;打开相关页面，如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201809/991496-20180928223628450-1948101120.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;zipkin-client&quot;&gt;Zipkin Client&lt;/h2&gt;
&lt;p&gt;再新建一个应用程序。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201809/991496-20180928223814593-1975039861.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动程序代码基本一样。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@SpringBootApplication
public class SpringcloudZipkinApplication {

    private static Logger log = LoggerFactory.getLogger(SpringcloudZipkinApplication.class);
    @RequestMapping(&quot;/&quot;)
    public String home() {
        log.info(&quot;Handling home&quot;);
        return &quot;Hello World&quot;;
    }
    
    public static void main(String[] args) {
        SpringApplication.run(SpringcloudZipkinApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;application.properties文件里加上Zipkin Server的地址，同时为了每次都将数据传入Zipkin，需要把spring.sleuth.sampler.probability的值改为1.0。&lt;/p&gt;
&lt;pre class=&quot;config&quot;&gt;
&lt;code&gt;server.port=10002

spring.application.name=sleuth-demo-with-zipkin
spring.zipkin.base-url=http://localhost:10000
spring.sleuth.sampler.probability=1.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动Zipkin Client后，可以看到Zipkin Server页面上多了一条追踪数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201809/991496-20180928224251897-1243760557.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次刷新Zipkin Client页面，又会有条新的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201809/991496-20180928224347916-1223112052.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在看控制台的日志记录，exportable项变成了true，说明数据已传入Zipkin。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201809/991496-20180928224548579-1952856657.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Sep 2018 14:57:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>Spring Cloud Sleuth提供了分布式追踪(distributed tracing)的一个解决方案。其基本思路是在服务调用的请求和响应中加入ID，标明上下游请求的关系。利用这些信息，可以方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9716282.html</dc:identifier>
</item>
<item>
<title>VSCode的Python扩展下程序运行的几种方式与环境变量管理 - Inpool</title>
<link>http://www.cnblogs.com/inpool/p/setup-environ-variable-4-vscode.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/inpool/p/setup-environ-variable-4-vscode.html</guid>
<description>&lt;p&gt;在VSCode中编写Python程序时，由于有些地方要使用环境变量，但是发现设置的环境变量有时不起作用，花了点时间研究了一下，过程不表，直接说结论。&lt;/p&gt;
&lt;p&gt;首先，环境变量的设置，Python扩展中有三种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接设置系统环境变量，或在使用命令行启动VSCode时临时先设置环境变量。&lt;br/&gt;这种方式设置的环境变量在所有的&lt;span&gt;运行方式下起效，但由于多个工程所用的环境变量不同，每次设置太麻烦，使用bash脚本或批处理我也觉得不爽，所以没有采用。&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;通过 &lt;span&gt;&lt;span&gt;&lt;span&gt;terminal.integrated.env.windows / &lt;span&gt;terminal.integrated.env.linux / &lt;span&gt;terminal.integrated.env.osx &lt;span&gt;选项配置。&lt;br/&gt;选项的格式是字典，键和值都必须是字符串，具体格式：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;terminal.integrated.env.windows&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;ENVIRON_VARIABLE&quot;: &quot;The Variable value&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;VAR2&quot;: &quot;111&quot;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面没加引号的是错的，不会生效&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;VAR3&quot;: 111, &lt;/span&gt;
&lt;span&gt;    },
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;通过配置 python.envFile 选项。&lt;/span&gt;&lt;br/&gt;python.envFile 是一个绝对路径，指向一个文件，默认为工程目录下的.env文件，用于定义需要的环境变量，基本格式如下：&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 注释
PYTHONPATH &lt;/span&gt;=&lt;span&gt; D:\workspace\safe110\webapps
PYTEST &lt;/span&gt;= 111
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其次，VSCode的Python扩展有四种程序运行方式，针对不同的运行方式，起作用的环境变量分别如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Debug&lt;br/&gt;以上三种方式设置的环境变量都会生效，VSCode会按照上面列出的顺序依次读取环境变量（即重名变量后面的生效）。&lt;/li&gt;
&lt;li&gt;pylint 等后台任务 （包括运行测试和调试测试）&lt;br/&gt;只有第1种和第3种方式设置的环境变量生效，读取顺序同上。&lt;/li&gt;
&lt;li&gt;右键文件--&amp;gt;在终端运行 或 选中代码，右键--&amp;gt;在Python终端运行&lt;br/&gt;只有第1种和第2种方式设置的环境变量生效，读取顺序同上。&lt;/li&gt;
&lt;li&gt;运行测试和调试测试（只分析了pytest）&lt;br/&gt;同2。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 28 Sep 2018 14:54:00 +0000</pubDate>
<dc:creator>Inpool</dc:creator>
<og:description>在VSCode中编写Python程序时，由于有些地方要使用环境变量，但是发现设置的环境变量有时不起作用，花了点时间研究了一下，过程不表，直接说结论。 首先，环境变量的设置，Python扩展中有三种方式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/inpool/p/setup-environ-variable-4-vscode.html</dc:identifier>
</item>
<item>
<title>【朝花夕拾】Android性能优化篇之（四）Apk打包 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/9721337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/9721337.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        APK，即Android Package，是将android程序和资源整合在一起，形成的一个.apk文件。相信所有的Android程序员是在IDE的帮助下，完成打包轻而易举，但对打包流程真正清楚的可能并不多。本章的内容比较简单，也是非常基础的内容，但是对理解android应用的结构却有很大的帮助。笔者写这篇文章的目的，一方面是为了弥补这方面的盲点，回顾和梳理apk打包方面的理论知识点；第二方面，是为了给后续写Android虚拟机知识做铺垫，进而去研究android的性能优化，这也是把这篇文章放到Android性能优化系列文章当中的原因；第三方面，也是为了方便读者理解Android虚拟机的相关内容。&lt;/p&gt;
&lt;p&gt;       对于在IDE，如Android Studio上操作打包的过程，本文不做演示，对于更深入的源码分析，也不在本文讨论之列，出于前面说到的原因，本文只简单阐述其打包流程，本文主要内容如下：&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180928222601604-950431632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、apk构建流程图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     以下截图为Google官方提供的详细的apk构建过程图，其中包含了各个环节所用到的工具和中间相关的文件。&lt;/p&gt;
&lt;p&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180926163655859-228268054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                         apk构建过程（绿色部分为对应环节工具，蓝色部分为相关文件）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、构建过程中所用工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        如下截图展示了apk构建过程中所使用的部分工具，这些工具大部分都在sdk/build-tools/文件夹下：&lt;/p&gt;
&lt;p&gt;                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927082344379-1840798044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927145341237-1345837808.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;                    代码混淆所用工具&lt;/p&gt;
&lt;p&gt;                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927113341056-1968929319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                   打包所用工具所在的jar包&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、apk打包流程详解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       依据如上的流程图和工具图，下面咱们按照流程顺序对其进行讲解。&lt;/p&gt;
&lt;p&gt;  1、aapt打包资源&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具：aapt（Android Asset Package Tool Android资源打包工具）&lt;/li&gt;
&lt;li&gt;工具路径：sdkpath/build-tools/版本号/aapt.exe和aapt2.exe&lt;/li&gt;
&lt;li&gt;输入：Android资源文件、AndroidManifest.xml&lt;/li&gt;
&lt;li&gt;输出： R.java类、二进制的resource.arsc，res文件夹（包括二进制的xml、没被改变的图片和res/raw文件）、二进制的AndroidManifest.xml文件、没有改变的assets文件夹。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        Android的资源文件包含了两类：1）assets类资源。该类资源放在工程目录的assets根目录下，存放一些原始文件，这些文件不会被编译为二进制文件，而是被原封不动地打包在apk文件中，同样也不能通过资源ID来查找，不保存在R文件中。2）res类资源，10种目录。这类资源保存在工程目录中的res目录下，包含了animator（属性动画资源）、anim（补间动画资源）、color（对象颜色状态选择资源）、drawable（xml或Bitmap文件的图像资源）、layout（布局文件资源）、menu（程序菜单资源）、mipmap（图标资源，推荐阅读：&lt;a href=&quot;https://blog.csdn.net/wk_beicai/article/details/78471187&quot; target=&quot;_blank&quot;&gt;drawable与mipmap的区别&lt;/a&gt;）、raw（不被编译成二进制文件的资源，注意和assets资源的区别，推荐阅读：&lt;a href=&quot;https://www.jianshu.com/p/dacef104e548&quot; target=&quot;_blank&quot;&gt;assets和raw的区别&lt;/a&gt;）、values（6种不同的值：数组arrays.xml、颜色值colors.xml、尺寸dimens.xml、字符串strings.xml和样式值styles.xml）、xml（描述应用程序配置信息的资源）。&lt;/p&gt;
&lt;p&gt;       如下截图展示了R.java的内容，其中包含了各种静态内部类，分别对应了某种资源的类型。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927151402249-1110991325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                            R.java结构图&lt;/p&gt;
&lt;p&gt;      以R.string类为例，其中展示了字符串名称对应的id值，就是对应在res/values文件夹下，string字符串资源。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927152043121-1003707521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                    R.string结构图&lt;/p&gt;
&lt;p&gt;        推荐阅读：&lt;a href=&quot;https://segmentfault.com/a/1190000004916563&quot; target=&quot;_blank&quot;&gt;apk打包安装过程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  2、aidl生成跨进程通信的java文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具：aidl（Android Interface Definition Language安卓接口定义语言）&lt;/li&gt;
&lt;li&gt;工具路径：sdkpath/build-tools/版本号/aidl.exe&lt;/li&gt;
&lt;li&gt;输入：aidl后缀的文件，位于工程项目src/main/aidl目录下&lt;/li&gt;
&lt;li&gt;输出：可用于进程间通信的C/S端java代码，位于build/generated/source/aidl&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927084817603-1732745002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                       工程项目中的aidl原始文件&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927084927001-550083857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                       aidl工具处理后生成的java文件&lt;/p&gt;
&lt;p&gt;  3、Java编译源码&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具：javac.exe&lt;/li&gt;
&lt;li&gt;工具路径：jdk/bin/javac.exe&lt;/li&gt;
&lt;li&gt;输入：java source文件夹、aapt中生成的R.java文件、aidl生成的java文件、BuildConfig.java文件&lt;/li&gt;
&lt;li&gt;输出：对于gradle编译，生成的class文件保存在build/intermediates/classes里&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927091141733-1186665294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                               BuildConfig.java和R.java文件&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927091055729-1638521547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                              输出的class文件&lt;/p&gt;
&lt;p&gt;  4、proguard代码混淆&lt;/p&gt;
&lt;p&gt;        完成javac编译之后，一般还会对其进行代码的混淆，其实就是类似于加密的功能，作用就是增加反编译的难度，同时也将一些代码的命名进行了缩短，减少代码占用的空间。推荐阅读：&lt;a href=&quot;https://www.jianshu.com/p/86ee6ef970ef&quot; target=&quot;_blank&quot;&gt;Android代码混淆零基础入门&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具：ProGuard&lt;/li&gt;
&lt;li&gt;工具路径：sdk/tools/proguard/bin/proguard.bat&lt;/li&gt;
&lt;li&gt;输入：被编译过的class文件、混淆配置文件proguard-rules.pro&lt;/li&gt;
&lt;li&gt;输出：被混淆过的.class文件、混淆前后映射文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927104017950-142541900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  5、将所有.class文件转化为classes.dex文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具：dx.bat&lt;/li&gt;
&lt;li&gt;工具路径：sdkpath/build-tools/版本号/dx.bat&lt;/li&gt;
&lt;li&gt;输入：编译后生成的所有.class文件、第三方库和.class文件&lt;/li&gt;
&lt;li&gt;输出：可以在Android虚拟机上使用的.dex文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       调用dx.bat将所有的class文件转化为classes.dex文件，将二进制码转化为Android虚拟机（Android4.4以前虚拟机是Dalvik，4.4上是Dalvik和ART可以切换、Android5.0及以后是ART）上的字节码、生成常量池、消除冗余数据等。由于Android虚拟机是一种针对嵌入式设备而特殊设计的java虚拟机，所有dex文件与标准的class文件在结构设计上有着很大的区别，当javac将java程序编译成class后，dx工具将所有的class文件整合到一个dex文件中，这样做使得各个类能够共享数据，在一定程度上降低了容易，同时也使文结构更加紧凑，实验表明，dex文件时传统jar文件的50%左右。class文件结构和dex文件结构比对如下（该部分还会在后文讲Android虚拟机时提到）：&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927110637327-361980182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                     .class文件和.dex文件结构对比图&lt;/p&gt;
&lt;p&gt;  6、apkbuilder打包生成apk&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具：ApkBuilder类&lt;/li&gt;
&lt;li&gt;工具路径：sdkpath/tools/lib/sdklib_xxx.jar&lt;/li&gt;
&lt;li&gt;输入：上一步生成的classes.dex文件，aapt时生成的resources.arsc、被编译后的res文件夹、AndroidManifest.xml，Other Resouces（assets文件夹）&lt;/li&gt;
&lt;li&gt;输出：.apk文件(Android Package)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  7、对apk进行签名&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具：apksigner.bat&lt;/li&gt;
&lt;li&gt;工具路径：sdkpath/build-tools/版本号/apksigner.bat&lt;/li&gt;
&lt;li&gt;输入：上一步中生成的.apk文件、签名文件（Debug or Release Keystore）&lt;/li&gt;
&lt;li&gt;输出：签名后的.apk文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      签名是一个apk身份的证明，Android系统在安装apk的时候，首先会检验apk的签名，如果发现签名文件不存在或者校验签名失败，就会拒绝安装。对一个apk文件签名后，apk文件根目录下回增加META-INF目录，该目录下有三个文件：&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927134251573-1485605126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;               META-IINF文件夹结构&lt;/p&gt;
&lt;p&gt;      Android系统就是根据这三个文件的内容对apk文件进行签名验证的：&lt;/p&gt;
&lt;p&gt;      MANIFEST.MF中包含对apk中除了/META-INF文件夹外所有文件的签名值。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927140029084-2000909632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                 MANIFEST.MF内容截图&lt;/p&gt;
&lt;p&gt;      CERT.SF是对MANIFEST.MF文件整体签名以及其中各个条目的签名。一般地，如果是使用工具签名，还多包括一项，就是对MANIFEST.MF头部信息签名。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927140719496-1476867942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                               CERT.SF内容截图&lt;/p&gt;
&lt;p&gt;      CERT.RSA包含用私钥对CERT.SF的签名以及包含公钥信息的数字证书。用一般的文本打开后，会显示乱码。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927141333320-99750118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　                CETR.RSA内容截图&lt;/p&gt;
&lt;p&gt;      推荐阅读：&lt;a href=&quot;https://blog.csdn.net/lb_fighting/article/details/52687691&quot; target=&quot;_blank&quot;&gt;Android签名有什么用？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                     &lt;a href=&quot;https://blog.csdn.net/jiangwei0910410003/article/details/50402000&quot; target=&quot;_blank&quot;&gt; Android签名过程详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  8、zipalign优化&lt;/p&gt;
&lt;p&gt;      如果是在release mode下，还会对apk进行align，即对签名后的apk进行对齐处理，这种方式是对apk进行整理和优化。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具：zipalign&lt;/li&gt;
&lt;li&gt;工具路径：sdkpath/build-tools/版本号/zipalign.exe&lt;/li&gt;
&lt;li&gt;输入：上一步中签名后的apk文件&lt;/li&gt;
&lt;li&gt;输出：优化后的apk文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;四、APK文件结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      一个apk解压后，其典型的结构如下所示，分别在apk打包流程中appt资源打包、javac编译、签名阶段所产生：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201809/472002-20180927143444451-132441667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Sep 2018 14:38:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>APK，即Android Package，apk打包是将android程序和资源整合在一起，形成的一个.apk文件。相信所有的Android程序员是在IDE的帮助下，完成打包轻而易举，但对打包流程真正</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/9721337.html</dc:identifier>
</item>
<item>
<title>可验证随机函数 - warm3snow</title>
<link>http://www.cnblogs.com/informatics/p/9721295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/informatics/p/9721295.html</guid>
<description>&lt;p&gt;最近区块链领域流行了一种“怪病”，许多区块链项目或者设计方案都加入了一个叫做&lt;strong&gt;VRFs&lt;/strong&gt;的算法。&lt;br/&gt;（1） 那什么是VRFs？&lt;br/&gt;（2） 使用VRFs又是为了什么？&lt;br/&gt;本文旨在介绍VRFs的原理以及在区块链中的用途，不涉及复杂的VRFs的详细设计实现以及安全性证明。&lt;/p&gt;
&lt;h2 id=&quot;一什么是vrfs&quot;&gt;（一）什么是VRFs？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;VRFs&lt;/strong&gt;全称Verifiable Random Functions，也就是可验证随机函数。从名字上可以看出VRFs有三个重要的特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;可验证&lt;/li&gt;
&lt;li&gt;随机性&lt;/li&gt;
&lt;li&gt;函数组&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;实际上，VRFs是hash函数构造的公钥密码方案，因此VRFs又包含了hash函数和公钥密码算法（hash函数和公钥密码参考wiki，这里不在赘述），功能上简单来讲，hash函数一般用来保证信息完整性，公钥密码用来进行数据鉴权。&lt;br/&gt;VRFs介绍内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;关键术语介绍&lt;/li&gt;
&lt;li&gt;VRFs之函数组&lt;/li&gt;
&lt;li&gt;VRFs之随机性&lt;/li&gt;
&lt;li&gt;VRFs之可验证&lt;/li&gt;
&lt;li&gt;VRFs之确定性&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;关键术语&quot;&gt;关键术语&lt;/h3&gt;
&lt;p&gt;VRFs涉及的一些关键术语：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;SK, PK: VRF中使用的公私钥对，SK为私钥，PK为公钥。PK默认为公开参数（比如说已经记录在区块链上）&lt;/li&gt;
&lt;li&gt;M: 输入数据&lt;/li&gt;
&lt;li&gt;R：VRF哈希输出&lt;/li&gt;
&lt;li&gt;P：VRF证明&lt;/li&gt;
&lt;li&gt;Prover：证明者，拥有VRF公私钥PK和SK的一方&lt;/li&gt;
&lt;li&gt;Verifier：验证着，拥有VRF中的公钥PK&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;vrfs之函数组&quot;&gt;VRFs之函数组&lt;/h3&gt;
&lt;p&gt;VRFs中涉及到四个重要的函数&lt;br/&gt;uploading-image-30552.png&lt;/p&gt;
&lt;p&gt;这四个函数可以分为两类，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生成函数：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;R=VRF_Hash(SK,M)
P=VRF_Proof(SK,M)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;验证函数：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;R=VRF_P2H(P)
VRF_Verify(PK,M,P)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用上，（1）首先生成一对公私钥；（2）然后使用&lt;strong&gt;生成函数&lt;/strong&gt;分别生成哈希值&lt;em&gt;R&lt;/em&gt;和哈希值的证明&lt;em&gt;P&lt;/em&gt;；（3）使用验证函数分别验证&lt;strong&gt;R&lt;/strong&gt;和&lt;strong&gt;P&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;vrfs之随机性&quot;&gt;VRFs之随机性&lt;/h3&gt;
&lt;p&gt;像每个密码算法一样，首先VRF需要一个密钥生成算法，用来生成公私钥对&lt;code&gt;(SK,PK)&lt;/code&gt;。这里的SK的产生需要复杂的随机数产生函数（高端一点的需要特制的硬件随机数发生源）来保证密钥的随机性。&lt;br/&gt;当然，VRFs之随机性实际上并不是指的上述随机性，VRFs的随机性指的是，在不给定证明&lt;strong&gt;P&lt;/strong&gt;的情况下，&lt;code&gt;VRF_Hash&lt;/code&gt;的输出&lt;strong&gt;R&lt;/strong&gt;与随机数两者之间是敌手不可区分的，这是比较正式或者说学术上的说法，可以认为VRF_Hash输出的&lt;strong&gt;R&lt;/strong&gt;就是个随机数。&lt;/p&gt;
&lt;h3 id=&quot;vrfs之可验证&quot;&gt;VRFs之可验证&lt;/h3&gt;
&lt;p&gt;VRF的可验证性，有两层意思：&lt;br/&gt;一是&lt;strong&gt;P&lt;/strong&gt;对&lt;strong&gt;R&lt;/strong&gt;的验证；&lt;br/&gt;二是&lt;strong&gt;PK&lt;/strong&gt;对&lt;strong&gt;P&lt;/strong&gt;的验证。&lt;br/&gt;前者是VRF证明对VRF哈希的验证，后者是公钥对VRF证明的验证。有点类似验证链：拥有公钥&lt;strong&gt;PK&lt;/strong&gt;可以通过&lt;code&gt;VRF_Verify(PK,M,P)&lt;/code&gt;验证证明&lt;strong&gt;P&lt;/strong&gt;的合法性；拥有&lt;strong&gt;P&lt;/strong&gt;可以通过&lt;code&gt;R=VRF_P2H(P)&lt;/code&gt;来验证&lt;strong&gt;R&lt;/strong&gt;的合法性。&lt;/p&gt;
&lt;h3 id=&quot;vrfs之确定性&quot;&gt;VRFs之确定性&lt;/h3&gt;
&lt;p&gt;VRFs的确定性比较简单，就是对相同的&lt;strong&gt;SK&lt;/strong&gt;和&lt;strong&gt;M&lt;/strong&gt;，多次计算&lt;code&gt;R=VRF_Hash(SK,M)&lt;/code&gt;,得到的&lt;strong&gt;R&lt;/strong&gt;是相同的。&lt;/p&gt;
&lt;h2 id=&quot;二vrfs在区块链中的作用&quot;&gt;（二）VRFs在区块链中的作用&lt;/h2&gt;
&lt;p&gt;区块链技术包含了密码学、P2P协议以及共识算法等，是多种技术的巧妙组合，同时加入了经济激励机制。其中，共识算法可谓是区块链技术的灵魂。区块链技术从2009年至今发展了接近十年的时间，共识算法也一直围绕着安全性、去中心化以及高效低能者三个要求不断探索，从中本聪共识（POW类），到POS和DPOS共识，再到各种BFT共识等。&lt;/p&gt;
&lt;p&gt;在区块链世界中，矿工的工作是区块链安全运行的基础，而他们的工作就是挖矿⚒️，矿工挖到矿（区块）会获得一笔奖励金和一部分交易手续费。同一时间会有许多矿工进行挖矿，但最终只会有一个区块进入到主链上。&lt;/p&gt;
&lt;p&gt;POW挖矿算法：&lt;code&gt;Hash(Hash(block, nonce)) &amp;lt; D&lt;/code&gt;&lt;br/&gt;矿工挖矿的过程就是为了找到一个以上条件的nonce，谁先算出来谁就是本轮的获胜者。根据Hash算法的特点，其他矿工可以很容易验证上面不等式的有效性。众所周知这类算法：实现简单，易于理解，但低效高能。&lt;br/&gt;为了解决POW共识低效高能的缺点，出现了POS类共识，而这类共识首先要解决的问题就是 &lt;strong&gt;&lt;em&gt;谁来出块&lt;/em&gt;&lt;/strong&gt; 的问题，VRFs最初被引入区块链就是为了解决这个问题。&lt;/p&gt;
&lt;h3 id=&quot;vrfs如何决定出块者&quot;&gt;VRFs如何决定出块者&lt;/h3&gt;
&lt;p&gt;像选美大赛一样，评委和观众会有一个评选标准，比如说身材、相貌或者多才多艺。用VRF选择出块者也需要一个标准，跟POW挖矿算法中的难度&lt;strong&gt;D&lt;/strong&gt;一样，VRFs也需要类似的&lt;strong&gt;D&lt;/strong&gt;。&lt;br/&gt;VRFs挖矿算法：&lt;code&gt;R = VRF_Hash(SK,block) &amp;lt; D&lt;/code&gt;&lt;br/&gt;为了统一暂且也叫做挖矿算法。给定自己的私钥SK和block信息，可以很快的验证自己是否成为下一轮的出块者，不需要进行大量的Hash计算。&lt;/p&gt;
&lt;p&gt;这类算法特点：离线验证，高效低能，但实现复杂&lt;/p&gt;
&lt;h2 id=&quot;十万个为什么qa&quot;&gt;#### 十万个为什么Q&amp;amp;A&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;不过聪明的人可能一下就能看出其中的问题：&lt;strong&gt;SK&lt;/strong&gt;是矿工私钥不会公开，其他矿工如何证明&lt;strong&gt;R&lt;/strong&gt;不是随便选取的小于&lt;strong&gt;D&lt;/strong&gt;的数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此需要有个对于&lt;strong&gt;R&lt;/strong&gt;有效性的证明，也就是上文中的&lt;strong&gt;P&lt;/strong&gt;：&lt;code&gt;P=VRF_Proof(SK,M)&lt;/code&gt;，然后通过&lt;code&gt;R'=VRF_P2H(P)&lt;/code&gt;，从&lt;strong&gt;P&lt;/strong&gt;中恢复出一个&lt;strong&gt;R'&lt;/strong&gt;,只要 &lt;code&gt;R == R'&lt;/code&gt;,就可以证明&lt;strong&gt;R&lt;/strong&gt;的有效性。然后用公钥&lt;strong&gt;PK&lt;/strong&gt;通过&lt;code&gt;VRF_Verify(PK,M,P)&lt;/code&gt;来对&lt;strong&gt;P&lt;/strong&gt;进行公开验证。&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;当然聪明的你可能又问了：看了半天，我感觉直接用签名算法不就可以了，干嘛整的这么复杂，比如说矿工直接对block签名，如果&lt;code&gt;Sign(SK, block) &amp;lt; D&lt;/code&gt;，那么矿工就有出块的权利。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在密码学签名算法中，大都会引入随机性，也就是对相同信息的多次签名会得到不同的签名值，因此矿工可以不断对相同的输入&lt;strong&gt;SK&lt;/strong&gt;和&lt;strong&gt;block&lt;/strong&gt;，计算签名，以满足结果小于&lt;strong&gt;D&lt;/strong&gt;。那么理论上任何人都会成为出块者，只要计算足够多次的签名。&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;老师，还有个问题：RSA签名方案，每次得到的签名不就都是确定值么！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对。其实不管使用确定性签名还是随机性签名，都存在个安全隐患。就是一旦将自己的出块凭证公布，任何人都可以公开验证，包括攻击者。那么攻击者可以对出块节点进行攻击，使其不能出块。&lt;br/&gt;使用VRFs的方式，矿工只需要公布自己的&lt;strong&gt;R&lt;/strong&gt;表明自己的出块权，当出完块的时候再公布&lt;strong&gt;P&lt;/strong&gt;，那么攻击者就无法在出块之前知道谁具有出块权，因此也就无法实施针对性的攻击。&lt;br/&gt;当然对于&lt;strong&gt;R&lt;/strong&gt;作假，还有个比较有名的问题：&quot;&lt;strong&gt;&lt;em&gt;Nothing At Risk&lt;/em&gt;&lt;/strong&gt;&quot;，翻译过来叫无利害关系。对于这类攻击的解决方法，一般都会使用 &quot;&lt;strong&gt;&lt;em&gt;缴纳保证金&lt;/em&gt;&lt;/strong&gt;&quot; 的方式。&lt;/p&gt;
&lt;h3 id=&quot;三个人思考&quot;&gt;（三）个人思考&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;共识不是一个简单的算法问题，更像一个社会治理问题。&lt;/li&gt;
&lt;li&gt;共识算法的设计需要关注性能和安全性，以达到性能和安全性的平衡。&lt;/li&gt;
&lt;li&gt;区块链技术”&lt;strong&gt;不可能三角问题&lt;/strong&gt;“中的去中心化，个人认为应该叫做公平性，因为去中心化不是区块链的目的，优秀的区块链应该是高性能，高安全性，参与者相对平等。而去中心化只是实现上的效果。公平性不单指的是公平的出块权，未来也可能代表公平的获取信息的权利（当然可能只是借助了区块链技术的创新项目）。&lt;/li&gt;
&lt;li&gt;VRFs可以用来选出块者，也可以用来分组，通过分组，提高交易并行处理性能。&lt;/li&gt;
&lt;/ol&gt;&lt;h5&gt;个人思考，有感而发，欢迎批评指正~~&lt;/h5&gt;
</description>
<pubDate>Fri, 28 Sep 2018 14:25:00 +0000</pubDate>
<dc:creator>warm3snow</dc:creator>
<og:description>可验证随机函数（VRFs） 最近区块链领域流行了一种“怪病”，许多区块链项目或者设计方案都加入了一个叫做 VRFs 的算法。 （1） 那什么是VRFs？ （2） 使用VRFs又是为了什么？ 本文旨在介</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/informatics/p/9721295.html</dc:identifier>
</item>
</channel>
</rss>