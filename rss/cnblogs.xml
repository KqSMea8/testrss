<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>依赖注入[3]: 依赖注入模式 - Artech</title>
<link>http://www.cnblogs.com/artech/p/net-core-di-03.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/net-core-di-03.html</guid>
<description>&lt;p&gt;IoC主要体现了这样一种设计思想：通过将一组通用流程的控制权从应用转移到框架中以实现对流程的复用，并按照“&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-01.html&quot;&gt;好莱坞法则&lt;/a&gt;”实现应用程序的代码与框架之间的交互。我们可以采用若干设计模式以不同的方式实现IoC，比如我们在《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwOTM1MjgzMA==&amp;amp;mid=2247484126&amp;amp;idx=1&amp;amp;sn=d25d50f3afae0bb7fa0b13ade205aaf0&amp;amp;chksm=977463cfa003ead9444f1c6b663da3cfc036388aba44def567b505b59f8cb493eabe7c1a25e1&amp;amp;scene=21#wechat_redirect&quot;&gt;依赖注入[2]: 基于IoC的设计模式&lt;/a&gt;》介绍的模板方法、工厂方法和抽象工厂，接下来我们介绍一种更为有价值的IoC模式，即依赖注入（DI：Dependency Injection，以下简称DI）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、由容器提供服务实例&lt;br/&gt;二、构造器注入&lt;br/&gt;三、属性注入&lt;br/&gt;四、方法注入&lt;br/&gt;五、Service Locator&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;和在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-02.html&quot;&gt;基于IoC的设计模式&lt;/a&gt;》中介绍的工厂方法和抽象工厂模式一样，DI是一种“&lt;strong&gt;对象提供型&lt;/strong&gt;”的设计模式，在这里我们将提供的对象统称为“&lt;strong&gt;服务&lt;/strong&gt;”、“&lt;strong&gt;服务对象&lt;/strong&gt;”或者“&lt;strong&gt;服务实例&lt;/strong&gt;”。在一个采用DI的应用中，在定义某个服务类型的时候，我们直接将依赖的服务采用相应的方式注入进来。按照“面向接口编程”的原则，被注入的最好是依赖服务的接口而非实现。&lt;/p&gt;
&lt;p&gt;在应用启动的时候，我们会对所需的服务进行全局注册。服务一般都是针对接口进行注册的，服务注册信息的核心目的是为了在后续消费过程中能够根据接口创建或者提供对应的服务实例。按照“好莱坞法则”，应用只需要定义好所需的服务，服务实例的激活和调用则完全交给框架来完成，而框架则会采用一个独立的“容器（Container）”来提供所需的每一个服务实例。&lt;/p&gt;
&lt;p&gt;我们将这个被框架用来提供服务的容器称为“&lt;strong&gt;DI容器&lt;/strong&gt;”，也由很多人将其称为“IoC容器”，根据我们在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-01.html&quot;&gt;控制反转&lt;/a&gt;》针对IoC的介绍，我不认为后者是一个合理的称谓。DI容器之所以能够按照我们希望的方式来提供所需的服务是因为该容器是根据服务注册信息来创建的，服务注册了包含提供所需服务实例的所有信息。&lt;/p&gt;
&lt;p&gt;举个简单的例子，我们创建一个名为Cat的DI容器类，那么我们可以通过调用具有如下定义的扩展方法GetService&amp;lt;T&amp;gt;从某个Cat对象获取指定类型的服务对象。我之所以将其命名为Cat，源于我们大家都非常熟悉的一个卡通形象“机器猫（哆啦A梦）”。机器猫的那个四次元口袋就是一个理想的DI容器，大熊只需要告诉哆啦A梦相应的需求，它就能从这个口袋中得到相应的法宝。DI容器亦是如此，服务消费者只需要告诉容器所需服务的类型（一般是一个服务接口或者抽象服务类），就能得到与之匹配的服务实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CatExtensions
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T GetService&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; Cat cat);
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;对于演示的MVC框架，我们在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-02.html&quot;&gt;基于IoC的设计模式&lt;/a&gt;》中分别采用不同的设计模式对框架的核心类型MvcEngine进行了改造，现在我们采用DI的方式并利用上述的这个Cat容器按照如下的方式对其进行重新实现，我们会发现MvcEngine变得异常简洁而清晰。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcEngine
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Cat Cat { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MvcEngine(Cat cat) =&amp;gt; Cat =&lt;span&gt; cat;
        
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task StartAsync(Uri address)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; listener = Cat.GetService&amp;lt;IWebLister&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; activator = Cat.GetService&amp;lt;IControllerActivator&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; executor = Cat.GetService&amp;lt;IControllerExecutor&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; render = Cat.GetService&amp;lt;IViewRender&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ListenAsync(address);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContext = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ReceiveAsync();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controller = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.CreateControllerAsync(httpContext);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; view = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; executor.ExecuteAsync(controller, httpContext);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; render.RendAsync(view, httpContext);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.ReleaseAsync(controller);
            }
        }
    }  
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;从服务消费的角度来讲，我们借助于一个服务接口对消费的服务进行抽象，那么服务消费程序针对具体服务类型的依赖可以转移到对服务接口的依赖上，但是在运行时提供给消费者总是一个针对某个具体服务类型的对象。不仅如此，要完成定义在服务接口的操作，这个对象可能需要其他相关对象的参与，也就是说提供的这个服务对象可能具有针对其他对象的依赖。作为服务对象提供者的DI容器，在它向消费者提供服务对象之前就会根据服务实现类型和服务注册信息自动创建依赖的服务实例，并将后者注入到当前对象之中。接下来我们从编程层面介绍三种典型的注入方式。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;构造器注入就在在构造函数中借助参数将依赖的对象注入到创建的对象之中。如下面的代码片段所示，Foo针对Bar的依赖体现在只读属性Bar上，针对该属性的初始化实现在构造函数中，具体的属性值由构造函数的传入的参数提供。当DI容器通过调用构造函数创建一个Foo对象之前，需要根据当前注册的类型匹配关系以及其他相关的注入信息创建并初始化参数对象。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar{&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foo(IBar bar) =&amp;gt;Bar =&lt;span&gt; bar;
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;除此之外，构造器注入还体现在对构造函数的选择上面。如下面的代码片段所示，Foo类上面定义了两个构造函数，DI容器在创建Foo对象之前首选需要选择一个适合的构造函数。至于目标构造函数如何选择，不同的DI容器可能有不同的策略，比如可以选择参数做多或者最少的，或者可以按照如下所示的方式在目标构造函数上标注一个InjectionAttribute特性。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar{&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBaz Baz {&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;}

    [Injection]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foo(IBar bar) =&amp;gt;Bar =&lt;span&gt; bar;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foo(IBar bar, IBaz):&lt;span&gt;this&lt;/span&gt;(bar) =&amp;gt;Baz =&lt;span&gt; baz;
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;如果依赖直接体现为类的某个属性，并且该属性不是只读的，我们可以让DI容器在对象创建之后自动对其进行赋值进而达到依赖自动注入的目的。一般来说，我们在定义这种类型的时候，需要显式将这样的属性标识为需要自动注入的依赖属性以区别于该类型的其他普通的属性。如下面的代码片段所示，Foo类中定义了两个可读写的公共属性Bar和Baz，我们通过标注InjectionAttribute特性的方式将属性Baz设置为自动注入的依赖属性。对于由DI容器提供的Foo对象，它的Baz属性将会自动被初始化。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar{&lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}

    [Injection]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBaz Baz {&lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;体现依赖关系的字段或者属性可以通过方法的形式初始化。如下面的代码片段所示，Foo针对Bar的依赖体现在只读属性上，针对该属性的初始化实现在Initialize方法中，具体的属性值由构造函数的传入的参数提供。我们同样通过标注特性（InjectionAttribute）的方式将该方法标识为注入方法。DI容器在调用构造函数创建一个Foo对象之后，它会自动调用这个Initialize方法对只读属性Bar进行赋值。在调用该方法之前，DI容器会根据预先注册的类型映射和其他相关的注入信息初始化该方法的参数。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar{&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;}

    [Injection]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Initialize(IBar bar)=&amp;gt; Bar =&lt;span&gt; bar;
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;除了上述这种通过DI容器在初始化服务过程中自动调用的实现在外，我们还可以利用它实现另一个更加自由的方法注入形式，后者在ASP.NET Core应用具有广泛的应用。ASP.NET Core在启动的时候会调用我们注册的Startup对象来完成中间件的注册，当我们在定义这个Startup类型的时候不需要让它实现某个接口，所以用于注册中间件的Configure方法其实没有一个固定的声明，我们可以按照如下的方式将任意依赖的服务直接注入到这个方法中。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IFoo foo, IBar bar, IBaz baz);
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;类似的注入方式同样可以应用到中间件的定义中。与用于注册中间件的Startup类型一样，ASP.NET Core框架下的中间件类型同样不需要实现某个预定义的接口，用于处理请求的InvokeAsync或者Invoke方法上同样可以按照如下的方式注入任意的依赖服务。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next; 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarMiddleware(RequestDelegate next) =&amp;gt;_next =&lt;span&gt; next;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext httpContext, IFoo foo, IBar bar, IBaz baz);
}&lt;/span&gt;&lt;/code&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这种方式的方法注入促成了一种“&lt;strong&gt;面向约定&lt;/strong&gt;”的编程方式，由于不再需要实现某个预定义的接口或者继承某一个预定义的类型，需要实现的方法的声明也就少了对应的限制，这样就可用采用最直接的方式将依赖的服务注入到所需的方法中。&lt;/p&gt;
&lt;p&gt;对于上面介绍的这几种注入方式，&lt;strong&gt;构造器注入&lt;/strong&gt;是最为理想的形式，我个人不建议使用属性注入和方法注入（上面介绍这种基于约定的方法注入除外）。我们定义的服务类型应该是独立自治的，我们不应该对它运行的环境做过多的假设和限制，也就说同一个服务类型可以使用在框架A中，也可以实现在框架B上；在没有使用任何DI容器的应用中可以使用这个服务类型，当任何一种DI容器被使用到应用中之后，该服务类型依旧能够被正常使用。对于上面介绍的这三种注入方式，唯一构造器注入能够代码这个目的，而属性注入和方法注入都依赖于某个具体的DI框架来实现针对依赖属性的自动复制和依赖方法的自动调用。&lt;/p&gt;

&lt;p&gt;假设我们需要定义一个服务类型Foo，它依赖于另外两个服务Bar和Baz，后者对应的服务接口分别为IBar和IBaz。如果当前应用中具有一个DI容器（假设类似于我们在上面定义的Cat），那么我们可以采用如下两种方式来定义这个服务类型Foo。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : IFoo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBaz Baz { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Foo(IBar bar, IBaz baz)
    {
        Bar &lt;/span&gt;=&lt;span&gt; bar;
        Baz &lt;/span&gt;=&lt;span&gt; baz;
    }  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync()
    {
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Bar.InvokeAsync();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Baz.InvokeAsync();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : IFoo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Cat Cat { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foo(Cat cat) =&amp;gt; Cat =&lt;span&gt; cat; 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync()
    {
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Cat.GetService&amp;lt;IBar&amp;gt;&lt;span&gt;().InvokeAsync();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Cat.GetService&amp;lt;IBaz&amp;gt;&lt;span&gt;().InvokeAsync();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从表面上看，上面提供的这两种服务类型的定义方式貌似都不错，至少它们都解决针对依赖服务的耦合问题，将针对服务实现的依赖转变成针对接口的依赖。那么哪一种更好呢？我想有人会选择第二种定义方式，因为这种定义方式不仅仅代码量更少，针对服务的提供也更加直接。我们直接在构造函数中“注入”了代表“DI容器”的Cat对象，在任何使用到依赖服务的地方，我们只需要利用它来提供对应的服务实例就可以了。&lt;/p&gt;
&lt;p&gt;但事实上第二种定义方式采用的设计模式根本就不是“依赖注入”，而是一种被称为“&lt;strong&gt;Service Locator&lt;/strong&gt;”的设计模式。Service Locator模式同样具有一个通过服务注册创建的全局的容器来提供所需的服务实例，该容器被称为“Service Locator”。“DI容器”和“Service Locator”实际上是同一事物在不同设计模型中的不同称谓罢了，那么DI和Service Locator之间的差异体现在什么地方呢？&lt;/p&gt;
&lt;p&gt;我们觉得可以从&lt;strong&gt;“DI容器”和“Service Locator”被谁使用&lt;/strong&gt;的角度来区分这两种设计模式的差别。在一个采用依赖注入的应用中，我们只需要采用标准的注入形式将服务类型定义好，并在应用启动之前完成相应的服务注册就可以了，框架自身的引擎在运行过程中会利用DI容器来提供当前所需的服务实例。换句话说，DI容器的使用者应该是&lt;strong&gt;框架&lt;/strong&gt;而不是应用程序。Service Locator模式显然不是这样，很明显是应用程序在利用它来提供所需的服务实例，所以它的使用者是&lt;strong&gt;应用程序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们也可以从另外一个角度区分两者之间的差别。由于依赖服务是以“注入”的方式来提供的，所以采用依赖注入模式的应用可以看成是将服务“&lt;strong&gt;推&lt;/strong&gt;”给DI容器，Service Locator模式下的应用则是利用Service Locator去“&lt;strong&gt;拉”&lt;/strong&gt;取所需的服务，这一推一拉也准确地体现了两者之间的差异。那么既然两者之间有差别，究竟孰优孰劣呢？&lt;/p&gt;
&lt;p&gt;早在2010年，Mark Seemann就在它的&lt;a href=&quot;http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern&quot;&gt;博客&lt;/a&gt;中将Service Locator视为一种“&lt;strong&gt;反模式（Anti-Pattern）&lt;/strong&gt;”，虽然也有人对此提出不同的意见，但我个人是非常不推荐使用这种设计模式的。我反对使用Service Locator与上面提到的反对使用属性注入和方法注入具有类似的缘由。&lt;/p&gt;
&lt;p&gt;我们既然将一组相关的操作定义在一个能够复用的服务中，不但要求服务自身具有&lt;strong&gt;独立和自治&lt;/strong&gt;的特性，也要求服务之间的应该具有&lt;strong&gt;明确的边界&lt;/strong&gt;，服务之间的依赖关系应该是&lt;strong&gt;明确&lt;/strong&gt;的而不是模糊的。不论是采用属性注入或者构造器注入，还是使用Service Locator来提供当前依赖的服务，这无疑为当前的应用增添了一个新的依赖，即针对DI容器或者Service Locator的依赖。&lt;/p&gt;
&lt;p&gt;当前服务针对另一个服务的依赖与针对DI容器或者Service Locator的依赖具有本质的不同，前者是一种基于类型的依赖，不论是基于服务的接口还是实现类型，这是一种基于“契约”的依赖。这种依赖不仅是明确的，也是由保障的。但是DI容器也好，Service Locator也罢，它们本质上都是一个黑盒，它能够提供所需服务的前提已经预先添加了对应的服务注册，但是这种依赖不仅是模糊和也是可靠的。&lt;/p&gt;
&lt;p&gt;正因为如此，ASP.NET Core框架使用的DI框架&lt;strong&gt;只支持构造器注入&lt;/strong&gt;，而&lt;strong&gt;不支持属性和方法注入&lt;/strong&gt;（类似于Startup和中间件基于约定的方法注入除外）。但是我们很有可能不知不觉地会按照Service Locator模式来编写我们的代码，从某种意义上讲，当我们在程序中使用IServiceProvider（表示DI容器）来提取某个服务实例的时候，就意味着我们已经在使用Service Locator模式了，所以当我们遇到这种情况下的时候应该多想一想是否一定需要这么做。虽然我们提倡尽可能避免使用Service Locator模式，但是有的时候（有其是在编写框架或者组件的时候），我们是无法避免使用IServiceProvider来提取服务。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 22:26:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/artech/p/net-core-di-03.html</dc:identifier>
</item>
<item>
<title>ParisGabriel：Python全栈工程师（0基础到精通）教程 第二十八课（多继承、函数重写） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9375303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9375303.html</guid>
<description>&lt;div align=&quot;left&quot;&gt;
&lt;p&gt;&lt;span&gt;ParisGabriel&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;         每天坚持手写  一天一篇  决定坚持几年 为了梦想为了信仰&lt;/p&gt;

&lt;div align=&quot;left&quot;&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt; 开局一张图&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;Python人工智能从入门到精通&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;补充：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　&lt;strong&gt;对象&lt;/strong&gt; -------------------------&amp;gt; &lt;strong&gt;类&lt;/strong&gt;&lt;br/&gt;实例变量（属性） 　　　　 类变量&lt;br/&gt;实例方法 　　　　　　　　 类方法（ @classmethond）&lt;/p&gt;
&lt;p&gt;静态方法（ @staticmethond）（类内普通函数）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;继承/派生&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;　　单继承：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　一个子类只有一个父类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　一个父类可以有多个子类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; --------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用于类的函数：&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;issublclass&lt;/strong&gt;&lt;/span&gt;（cls， cls_or_tuple）&lt;br/&gt;　　&lt;strong&gt;判断&lt;/strong&gt;这个类&lt;strong&gt;是否继承自其他类&lt;/strong&gt;， 如果此cls是class&lt;br/&gt;　　或&lt;strong&gt;tuple中的一个派生子类&lt;/strong&gt;， 返回&lt;strong&gt;True&lt;/strong&gt; 否则返回&lt;strong&gt;False&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;br/&gt;　　class A:&lt;br/&gt;　　　　pass&lt;br/&gt;　　class B(A):&lt;br/&gt;　　　　pass&lt;br/&gt;　　class C(B):&lt;br/&gt;　　　　pass&lt;/p&gt;
&lt;p&gt;issublclass(C, B) # True&lt;br/&gt;issublclass(B, C) # False&lt;br/&gt;issublclass(C, (int, str)) # False&lt;br/&gt;issublclass(C, (int, B, str)) # True&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;封装 enclosure&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;封装&lt;/strong&gt;是指&lt;strong&gt;隐藏类&lt;/strong&gt;的&lt;strong&gt;实现细节&lt;/strong&gt;，&lt;strong&gt;让使用者不关心这些细节&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;封装的目的&lt;/strong&gt;是让使用者通过&lt;strong&gt;尽可能少的方法&lt;/strong&gt;（或属性）&lt;strong&gt;操作对象&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;私有属性和私有方法：&lt;/strong&gt;&lt;br/&gt;　　python类中以&lt;span&gt;双下划线（__）开头&lt;/span&gt;，&lt;br/&gt;　　&lt;span&gt;不&lt;/span&gt;以&lt;span&gt;双下划线结尾&lt;/span&gt;的标识符为&lt;strong&gt;私有成员&lt;/strong&gt;，私有成员或&lt;strong&gt;只能用&lt;/strong&gt;类的&lt;strong&gt;方法&lt;/strong&gt;进行&lt;strong&gt;访问&lt;/strong&gt;和修改&lt;br/&gt;　　以__开头的实例变量有私有属性&lt;br/&gt;　　以__开头的方法有私有方法&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__p1&lt;/span&gt; = 100  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 私有属性&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; show_A(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;self.__p1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, self.&lt;span&gt;__p1&lt;/span&gt;&lt;span&gt;)
        self.&lt;/span&gt;&lt;span&gt;__m1&lt;/span&gt;()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以调用自己的方法&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__m1&lt;/span&gt;(self):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 私有方法&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__m1(self)方法被调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


a &lt;/span&gt;=&lt;span&gt; A()
a.show_A()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 100&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(a.__p1)  # 出错　不能在类外部访问a.__p1私有属性　也不能在子类中访问&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; a.__m1()  # 出错　不能在类外部访问a.__p1私有方法　也不能在子类中访问&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;


b &lt;/span&gt;=&lt;span&gt; B()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(b.&lt;span&gt;__p1&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 出错，子类不能访问父类的私有成员&lt;/span&gt;
b.&lt;span&gt;__m1&lt;/span&gt;()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 出错&lt;/span&gt;
&lt;span&gt;
b._A__p1 &lt;/span&gt;= 200  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; python的假封装可以用此方法访问&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(b.&lt;span&gt;__p1&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 200&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多态polymorphic：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　什么是多态&lt;br/&gt;　　　　就是多种状态&lt;br/&gt;　　　　多态是指在继承/派生关系的类中，调用基类对象的方法，&lt;br/&gt;　　　　实际能够调用子类的覆盖方法的现象叫多态&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;状态：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;静态（编译时状态）执行速度快&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;动态（运行时状态）执行速度慢&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;多态调用&lt;/strong&gt;方法&lt;strong&gt;与对象相关&lt;/strong&gt;，&lt;strong&gt;不与类相关&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;Python&lt;/strong&gt;的全部对象&lt;strong&gt;只有&lt;/strong&gt;“运行时状态（&lt;strong&gt;动态&lt;/strong&gt;）”&lt;br/&gt;　　没有C++语言里的“编译时状态（静态）”&lt;br/&gt;　　由于Python是&lt;strong&gt;解释执行&lt;/strong&gt;的 是动态 没有静态&lt;br/&gt;　　是在&lt;span&gt;运行时编译&lt;/span&gt;（解释执行）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Pytgon中的运行时状态&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shape:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; draw(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Shape的　draw　方法被调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Point(Shape):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; draw(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;画车&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Circle(Shape):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; draw(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;画圈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; python无法实现静态　除非不出现任何覆盖&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; my_draw(s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 其他静态语言　def　my_draw(Circle s)　指定调用者　无法进行改变&lt;/span&gt;
    s.draw()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处显示出＂动态＂&lt;/span&gt;
&lt;span&gt;

s1 &lt;/span&gt;=&lt;span&gt; Circle()
s2 &lt;/span&gt;=&lt;span&gt; Point()
my_draw(s1)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只有在调用时才能能确定调用哪一个&lt;/span&gt;
my_draw(s2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;面向对象不是编程而是一种思想&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面向对象的语言的特征：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;　　继承&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　封装&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　多态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;多继承：multiple inheritance&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;多继承是指&lt;strong&gt;一个子类继承&lt;/strong&gt;自&lt;strong&gt;两个或&lt;/strong&gt;两个&lt;strong&gt;以上的基类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　语法：&lt;/strong&gt;&lt;br/&gt;　　　　class 类名（基类名1， 基类名2， ...）&lt;br/&gt;　　&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　　　1.一个子类同时继承自&lt;strong&gt;多个父类&lt;/strong&gt;，父类中的&lt;strong&gt;方法&lt;/strong&gt;可以&lt;strong&gt;同时被继承下来&lt;/strong&gt;&lt;br/&gt;　　　　2.&lt;strong&gt;如果&lt;/strong&gt;两个&lt;strong&gt;父类中&lt;/strong&gt;同时&lt;strong&gt;有同名方法&lt;/strong&gt;，而在&lt;strong&gt;子类中又没有覆盖&lt;/strong&gt;此方法时，&lt;br/&gt;　　　　调用&lt;strong&gt;结果难以确定&lt;/strong&gt;  （也可以确定 C3算法）&lt;br/&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self, speed):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;汽车&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, speed, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Km/h 的速度行驶&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Plane:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fly(self, height):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;飞机以海拔&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, height, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;米高度飞行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PlaneCar(Plane, Car):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;同时继承Plane,Car的方法&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;


p1 &lt;/span&gt;=&lt;span&gt; PlaneCar()
p1.fly(&lt;/span&gt;10000&lt;span&gt;)
p1.run(&lt;/span&gt;300)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多继承的问题（缺陷）：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;标识符冲突&lt;/strong&gt;的问题&lt;br/&gt;　　要&lt;strong&gt;谨慎&lt;/strong&gt;使用&lt;strong&gt;继承&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 多继承名字冲突问题&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; m(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A.m被调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; m(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B.m被调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; AB(A, B):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 优先调用先出现的父类　　有先后顺序&lt;/span&gt;
    &lt;span&gt;pass&lt;/span&gt;&lt;span&gt;


ab &lt;/span&gt;=&lt;span&gt; AB()

ab.m()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; A.m被调用&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BA(B, A):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;


ba &lt;/span&gt;=&lt;span&gt; BA()

ba.m()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; B.m被调用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多继承的MRO（Method Resolution Order）：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　类的&lt;span&gt;&lt;strong&gt;__mro__&lt;/strong&gt;&lt;/span&gt;属性&lt;br/&gt;　　　　__mro__ &lt;strong&gt;是&lt;/strong&gt;一个&lt;span&gt;元组&lt;/span&gt; 里面&lt;strong&gt;存放类&lt;/strong&gt;&lt;br/&gt;　　　　此属性用来&lt;strong&gt;记录&lt;/strong&gt;方法&lt;strong&gt;查找顺序&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; go(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; go(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; C(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; go(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; D(B, C):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; go(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        super().go()


d &lt;/span&gt;=&lt;span&gt; D()
d.go()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; B&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 多继承的super调用关系一定是mro元组内的下一个类　和子父类没关系&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果没有方法则报错　　调用算法（C3算法）&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 正常调用也是mro顺序&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;函数重写：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;在自定义类内&lt;span&gt;添加&lt;/span&gt;相应的&lt;span&gt;方法&lt;/span&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;span&gt;让&lt;/span&gt;自定义类创建的&lt;span&gt;实例&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;&lt;span&gt;能&lt;/span&gt;像内建对象一样&lt;span&gt;进行内建函数操作&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;对象转字符串函数：&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;repr（obj）&lt;/span&gt; &lt;strong&gt;返回&lt;/strong&gt;一个能代表此对象的&lt;strong&gt;表达式字符串&lt;/strong&gt;，通常&lt;strong&gt;eval（repr（obj））== obj&lt;/strong&gt;&lt;br/&gt;　　（这个字符串通常给Python解释执行器运行用的）&lt;br/&gt;　　&lt;span&gt;str（obj）&lt;/span&gt; &lt;strong&gt;返回&lt;/strong&gt;的&lt;strong&gt;字符串&lt;/strong&gt;（这个字符串通常给人阅读用的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象转字符串函数的重写方法：&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;repr（obj）&lt;/span&gt; 函数的重写方法：&lt;br/&gt;　　　　def __repr__（self）：&lt;/p&gt;
&lt;p&gt;　　　　　　pass&lt;br/&gt;　&lt;span&gt;　str（obj）&lt;/span&gt; 函数的重写方法：&lt;br/&gt;　　　　def __str__（self）：&lt;/p&gt;
&lt;p&gt;　　　　　　pass&lt;br/&gt;　　&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　　　1.str（obj）函数&lt;span&gt;先查找&lt;/span&gt;， &lt;strong&gt;obj.str（）&lt;/strong&gt;方法&lt;br/&gt;　　　　调用此方法并返回结果&lt;br/&gt;　　　　2.如果&lt;span&gt;&lt;strong&gt;没有&lt;/strong&gt;&lt;/span&gt;obj.__str__&lt;strong&gt;方法时&lt;/strong&gt;，&lt;span&gt;返回obj.__repr__（）&lt;/span&gt;&lt;br/&gt;　　　　方法的结果并返回&lt;br/&gt;　　　　3.如果&lt;strong&gt;obj.__repr__&lt;/strong&gt;方法&lt;span&gt;不存在&lt;/span&gt;，则&lt;strong&gt;调用obj类的&lt;/strong&gt;&lt;span&gt;__repr__&lt;/span&gt;&lt;br/&gt;　　　　实例方法显示：&amp;lt;__main__.XXXX object at 0x7f4b1c36fa90&amp;gt;&lt;br/&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyNumber:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, value):
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;构造函数,初始化MyNumber&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        self.data &lt;/span&gt;=&lt;span&gt; value

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;转换为人能够识别的字符串&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__str__方法被调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自定义数字类型对象：%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;转换为eval能够识别的字符串&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyNumber(%d)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.data


n1 &lt;/span&gt;= MyNumber(100&lt;span&gt;)
n2 &lt;/span&gt;= MyNumber(200&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;repr(n1):---&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, repr(n1))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strr(n2):---&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str(n2))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strr(n2):---&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, n2.&lt;span&gt;__str__&lt;/span&gt;())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;其他内建函数的重写方法：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;__abs__&lt;/span&gt; 　　　　   abs（obj） 　　　　 　   函数&lt;br/&gt;&lt;span&gt;__len__&lt;/span&gt; 　　　　   len(obj) 　　　　　　　  函数（必须返回整数）&lt;br/&gt;&lt;span&gt;__reversed__&lt;/span&gt;　　  reversed(obj) 　　 函数（必须返回可迭代对象）&lt;br/&gt;&lt;span&gt;__round__&lt;/span&gt; 　　      round(obj) 　　　　   函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 函数重写&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyNumber:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, v):
        self.data &lt;/span&gt;=&lt;span&gt; v

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyNumber(%d)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__abs__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;__abs__函数重写 求绝对值函数&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; return -self.data&lt;/span&gt;
        v =&lt;span&gt; abs(self.data)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyNumber(v)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个新的MyNumber对象&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;__len__函数重写 求长度函数&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; return len(self.data)&lt;/span&gt;
        i =&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.data:
            i &lt;/span&gt;+= 1
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i


i1 &lt;/span&gt;= MyNumber(-10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i1)
i2 &lt;/span&gt;=&lt;span&gt; abs(i1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i2)

i3 &lt;/span&gt;= MyNumber(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123d5sa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(len(i3))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据转换函数的重写：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;__complex__&lt;/span&gt; 　　  complex(obj) 　   　函数&lt;br/&gt;&lt;span&gt;__int__ 　&lt;/span&gt;　　   　 int(obj) 　　　　　  函数&lt;br/&gt;&lt;span&gt;__float__&lt;/span&gt; 　　　　 float(obj) 　　　　  函数&lt;br/&gt;&lt;span&gt;__bool__ 　&lt;/span&gt;　　　 bool(obj) 　　　　  函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;数据转换构造函数重写
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyNumber:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, v):
        self.data &lt;/span&gt;=&lt;span&gt; v

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyNumber(%d)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__int__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; return 999999  # 可以自定义返回规则&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data


n1 &lt;/span&gt;= MyNumber(100&lt;span&gt;)
x &lt;/span&gt;=&lt;span&gt; int(n1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(x))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;class 'int'&amp;gt;&lt;/span&gt;


&lt;span&gt;print&lt;/span&gt;(bool(n1))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; True&lt;/span&gt;
n2 =&lt;span&gt; MyNumber(0)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(bool(n2))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; True&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认返回  # True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;布尔测试函数重写：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;格式&lt;/strong&gt;：&lt;br/&gt;　&lt;span&gt;&lt;strong&gt;　__bool__&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;作用：&lt;/strong&gt;&lt;br/&gt;　　　　用于&lt;strong&gt;bool&lt;/strong&gt;（obj）函数&lt;strong&gt;取值&lt;/strong&gt;&lt;br/&gt;　　　　用于if语句的&lt;strong&gt;真值表达&lt;/strong&gt;式中&lt;br/&gt;　　&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　　　1.当自定义的类内&lt;span&gt;&lt;strong&gt;有__bool__(self)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　　　方法时，此方法的&lt;strong&gt;返回值为bool（obj）的返回值&lt;/strong&gt;&lt;br/&gt;　　　　2.当&lt;strong&gt;不存在__bool__(self)&lt;/strong&gt;，bool（x）&lt;br/&gt;　　　　&lt;strong&gt;返回&lt;span&gt;__len__&lt;/span&gt;（self）&lt;/strong&gt;方法的返回值&lt;span&gt;&lt;strong&gt;是否为零&lt;/strong&gt;&lt;/span&gt;来&lt;strong&gt;测试布尔值&lt;/strong&gt;&lt;br/&gt;　　　　3.当&lt;span&gt;不存在&lt;/span&gt;&lt;strong&gt;__len__&lt;/strong&gt;方法时，则&lt;strong&gt;直接返回&lt;span&gt;True&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; bool(x)函数重写&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;自定义类型的列表，用来保存数据，内部用列表来储存数据&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, iterable):
        self.data &lt;/span&gt;= [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; iterable]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; MyList(%s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;返回长度&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__bool__方法被调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; len(self.data)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; def __bool__(self):&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     print(&quot;__bool__方法被调用&quot;)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     return False  # 此处定义所有对象返回False&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__bool__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__bool__方法被调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.data:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; x:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; True  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自定义返回规则（这就是函数重写）&lt;/span&gt;
&lt;span&gt;

myl &lt;/span&gt;= MyList((1, 2, -3, 4, -5, 5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(myl)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(bool(myl))
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; myl:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myl是真值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myl是假值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;迭代器（高级）：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;什么是迭代器：&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;可以&lt;/strong&gt;通过&lt;span&gt;next（it）&lt;/span&gt;函数&lt;strong&gt;取值&lt;/strong&gt;的对象&lt;strong&gt;就是迭代器&lt;/strong&gt;&lt;br/&gt;　&lt;strong&gt;　迭代器协议：&lt;/strong&gt;&lt;br/&gt;　　　　迭代器&lt;strong&gt;是&lt;/strong&gt;指&lt;strong&gt;对象能&lt;/strong&gt;够使用&lt;strong&gt;next&lt;/strong&gt;函数获&lt;strong&gt;取下一项数据&lt;/strong&gt;，&lt;br/&gt;　　　　在&lt;strong&gt;没有下一项&lt;/strong&gt;数据时&lt;strong&gt;触发&lt;/strong&gt;一个&lt;span&gt;StopIteration&lt;/span&gt;&lt;strong&gt;异常&lt;/strong&gt;来&lt;strong&gt;终止迭代的重写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代器协议实现方法：&lt;/strong&gt;&lt;br/&gt;　　　&lt;span&gt;__next__&lt;/span&gt;（self） 方法来&lt;strong&gt;实现迭代协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法形式：&lt;/strong&gt;&lt;br/&gt;　　class MyIterator：&lt;br/&gt;　　　　def __next__(self):&lt;br/&gt;　　　　　　迭代器协议&lt;br/&gt;　　　　　　return 数据&lt;br/&gt;&lt;strong&gt;什么是可迭代对象：&lt;/strong&gt;&lt;br/&gt;　　是指&lt;strong&gt;用&lt;/strong&gt; &lt;span&gt;&lt;strong&gt;iter（obj）&lt;/strong&gt;&lt;/span&gt; &lt;strong&gt;函数返回迭代对象&lt;/strong&gt;（实例）&lt;br/&gt;　　&lt;strong&gt;可迭代对象&lt;/strong&gt;内部&lt;strong&gt;需要定义&lt;span&gt;__iter__&lt;/span&gt;&lt;/strong&gt;（self）方法&lt;strong&gt;来返回迭代器对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意让自定义的作为可迭代对象能让 for 语句迭代访问&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;创建MyList类&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, iterable=&lt;span&gt;()):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;初始化self　
        　　　iterable:可迭代对象
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用iterable生成列表&lt;/span&gt;
        self.data = [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; iterable]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;返回一个MyList字符串&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyList(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;此方法必须返回一个迭代器对象
        此方法创建一个迭代器对象并返回
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; MyListIterator(self.data)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyListIterator:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;此类用来创建迭代器,此类型的迭代器可以迭代访问
    MyList类型的对象&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, lst):
        self.data &lt;/span&gt;=&lt;span&gt; lst
        self.cur_index &lt;/span&gt;= 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化迭代器的起始位置&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;此方法用于实现迭代器协议&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self.cur_index &amp;gt;=&lt;span&gt; len(self.data):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果索引越界就发终止迭代通知&lt;/span&gt;
            &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; StopIteration
        value &lt;/span&gt;= self.data[self.cur_index]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 要返回的值&lt;/span&gt;
        self.cur_index += 1
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value


myl &lt;/span&gt;= MyList([0, -1, 2, -3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(myl)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; it = iter(myl)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(next(it))&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; myl:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 迭代访问自定义类型的可迭代对象&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(x)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;练习:&lt;br/&gt;写一个类Bicycle类 ,有 run方法.调用时显示骑行里程km&lt;br/&gt;class Bicycle:&lt;br/&gt;　　def run(self, km):&lt;br/&gt;　　　　print('自行车骑行了', km, '公里')&lt;br/&gt;再写一个类EBicycle(电动自行车类), 在Bicycle类的基础上添加了电池电量 volume 属性, 有两个方法:&lt;br/&gt;1. fill_charge(self, vol) 用来充电, vol为电量&lt;br/&gt;2. run(self, km) 方法每骑行10km消耗电量1度,同时显示当前电量,当电量耗尽时调用 父类的run方法继续骑行&lt;/p&gt;
&lt;p&gt;b = EBicycle(5) # 新买的电动有内有5度电&lt;br/&gt;b.run(10) # 电动骑行了10km还剩 4 度电&lt;br/&gt;b.run(100) #电动骑行了40km,还剩0度电,其余60用脚登骑行&lt;br/&gt;b.fill_charge(10) # 又充了10度电&lt;br/&gt;b.run(50) # 骑行了50公里剩5度电&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bycycle:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self, km):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;自行车&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自行车骑行了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, km, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;公里&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; EBycyle(Bycycle):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, volume=&lt;span&gt;0):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;初始化电动车&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        self.volume &lt;/span&gt;=&lt;span&gt; volume
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新买的电动车有&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, volume, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;度电&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fill_charge(self, vol):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;冲电&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        self.volume &lt;/span&gt;+=&lt;span&gt; vol
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;又冲了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, vol, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;度电&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self, km):
        self.volume &lt;/span&gt;-= (km / 10)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 减去使用的电量&lt;/span&gt;
        x = abs(self.volume) * 10  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算超出的公里&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self.volume &amp;lt; 0:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否超出电量&lt;/span&gt;
            self.volume =&lt;span&gt; 0
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;电动车骑行了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, km, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;千米　还剩&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                  self.volume, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;度电 其余&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;千米用脚蹬&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;电动车骑行了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, km, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;千米　还剩&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                  self.volume, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;度电&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


b &lt;/span&gt;= EBycyle(10&lt;span&gt;)
b.run(&lt;/span&gt;10&lt;span&gt;)
b.run(&lt;/span&gt;100&lt;span&gt;)
b.fill_charge(&lt;/span&gt;10&lt;span&gt;)
b.run(&lt;/span&gt;50&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 新买的电动车有 10 度电&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 电动车骑行了 10 千米　还剩 9.0 度电&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 电动车骑行了 100 千米　还剩 0 度电 其余 10.0 千米用脚蹬&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 又冲了 10 度电&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 电动车骑行了 50 千米　还剩 5.0 度电&lt;/span&gt;
&lt;span&gt;
b &lt;/span&gt;= EBycyle(50&lt;span&gt;)
b.run(&lt;/span&gt;10&lt;span&gt;)
b.run(&lt;/span&gt;100&lt;span&gt;)
b.fill_charge(&lt;/span&gt;10&lt;span&gt;)
b.run(&lt;/span&gt;50&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 新买的电动车有 50 度电&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 电动车骑行了 10 千米　还剩 49.0 度电&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 电动车骑行了 100 千米　还剩 39.0 度电&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 又冲了 10 度电&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 电动车骑行了 50 千米　还剩 44.0 度电&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;练习:&lt;br/&gt;1. 修改原有的学生信息管理系统, 将学生对象的,全部属性&lt;br/&gt;都变为私有属性,不让外部直接访问来实现封装&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;源码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;https://pan.baidu.com/s/1szQDS5cfzVHLlZrrJcCs8A&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2. 写一个列表类MyList实现存储整数列表,写类的定义如下:&lt;br/&gt;class MyList:&lt;br/&gt;　　def __init__(self, iterator):&lt;br/&gt;　　　　self.data = ...&lt;br/&gt;让此类的对象能用for语句进行迭代访问&lt;/p&gt;
&lt;p&gt;L = MyList(range(5))&lt;br/&gt;print(L)&lt;br/&gt;L2 = [x ** 2 for x in L]&lt;br/&gt;print(L2) # [0, 1, 4, 9, 16]&lt;/p&gt;

&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, iterable=&lt;span&gt;()):
        self.lst &lt;/span&gt;= [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; iterable]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.lst

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; MyIterable(self.lst)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyIterable:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, lst):
        self.lst &lt;/span&gt;=&lt;span&gt; lst
        self.myindex &lt;/span&gt;=&lt;span&gt; 0

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.myindex &amp;gt;=&lt;span&gt; len(self.lst):
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt; StopIteration
        value &lt;/span&gt;=&lt;span&gt; self.lst[self.myindex]
        self.myindex &lt;/span&gt;+= 1
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value


L &lt;/span&gt;= MyList(range(5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(L)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x)

L2 &lt;/span&gt;= [x ** 2 &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180727015902241-296595672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3. 写一个类Fibonacci 实现迭代器协议 ,此类的对象可以作为可迭代对象生成相应的斐波那契数&lt;br/&gt;1 1 2 3 5&lt;br/&gt;class Fibonacci:&lt;br/&gt;　　def __init__(self, n) # n代表数据的个数&lt;br/&gt;...&lt;br/&gt;...&lt;br/&gt;实现如下操作:&lt;br/&gt;for x in Fibonacci(10):&lt;br/&gt;　　print(x) # 1 1 3 5 8 ....&lt;br/&gt;L = [x for x in Fibonacii(50)]&lt;br/&gt;print(L)&lt;br/&gt;F = fibonicci(30)&lt;br/&gt;print(sum(F))&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;直接继承第二题的类&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Fibonicci(MyList):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, n):
        L &lt;/span&gt;= [1, 1&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(n - 2&lt;span&gt;):
            L.append(L[&lt;/span&gt;-1] + L[-2&lt;span&gt;])
        self.lst &lt;/span&gt;=&lt;span&gt; L


&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; Fibonicci(10&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(x)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1 1 3 5 8 ....&lt;/span&gt;
L = [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; Fibonicci(50&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(L)
F &lt;/span&gt;= Fibonicci(30&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(F)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sum(F))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180727015724936-1589666615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 26 Jul 2018 17:25:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9375303.html</dc:identifier>
</item>
<item>
<title>Kafka监控系统Kafka Eagle剖析 - 哥不是小萝莉</title>
<link>http://www.cnblogs.com/smartloli/p/9371904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartloli/p/9371904.html</guid>
<description>&lt;p&gt;最近有同学留言反馈了使用Kafka监控工具Kafka Eagle的一些问题，这里笔者特意整理了这些问题。并且希望通过这篇博客来解答这些同学的在使用Kafka Eagle的时候遇到的一些困惑，同时也给出一些定位分析Kafka Eagle异常的时的解决办法。&lt;/p&gt;

&lt;h2&gt;2.1 背景&lt;/h2&gt;
&lt;p&gt;在使用Kafka Eagle监控系统之前，笔者简单的介绍一下这款工具的用途。Kafka Eagle监控系统是一款用来监控Kafka集群的工具，目前更新的版本是v1.2.3，支持管理多个Kafka集群、管理Kafka主题（包含查看、删除、创建等）、消费者组合消费者实例监控、消息阻塞告警、Kafka集群健康状态查看等。目前Kafka Eagle v1.2.3整个系统所包含的功能，这里笔者给绘制成了一个图，结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201807/666745-20180726155027971-1664616298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2 安装&lt;/h2&gt;
&lt;p&gt;接下来，我们开始安装Kafka Eagle系统，安装之前，我们需要准备好Kafka Eagle安装包。这里有2种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;下载编译好的安装包&lt;/li&gt;
&lt;li&gt;下载源代码，然后自行编译安装&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面分别介绍这2种方式。&lt;/p&gt;
&lt;h3&gt;2.2.1 直接下载安装包&lt;/h3&gt;
&lt;p&gt; 可以直接访问Kafka Eagle安装包下载地址：&lt;a href=&quot;http://download.smartloli.org/&quot; target=&quot;_blank&quot;&gt;http://download.smartloli.org/&lt;/a&gt;,然后点击下载按钮，等待下载完成即可。下载界面如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201807/666745-20180726234757083-1491281273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 2.2.2 下载源代码，自行编译安装&lt;/h3&gt;
&lt;p&gt;Kafka Eagle系统的源代码托管在Github上，大家可以访问&lt;a href=&quot;https://github.com/smartloli/kafka-eagle&quot; target=&quot;_blank&quot;&gt;https://github.com/smartloli/kafka-eagle&lt;/a&gt;来获取源代码。Kafka Eagle源代码是由Maven工程来管理的，所以，在编译Kafka Eagle源代码之前，需要在本地开发环境中准备好你的Maven环境。&lt;/p&gt;
&lt;p&gt;Maven安装比较简单，这里给大家介绍安装Maven的步骤：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 步骤1：下载Maven安装包
&lt;/span&gt;&lt;span&gt;wget&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz&lt;/span&gt;
&lt;span&gt;
# 步骤2：解压Maven安装包
&lt;/span&gt;&lt;span&gt;tar&lt;/span&gt; -zxvf apache-maven-&lt;span&gt;3.5&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-bin.&lt;span&gt;tar&lt;/span&gt;&lt;span&gt;.gz

# 步骤3：重命名并移动到指定位置
&lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; apache-maven-&lt;span&gt;3.5&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt; /usr/local/&lt;span&gt;maven

# 步骤4：配置Maven环境编辑
&lt;/span&gt;&lt;span&gt;vi&lt;/span&gt; ~/&lt;span&gt;.bash_profile

export M2_HOME&lt;/span&gt;=/usr/local/&lt;span&gt;maven
export PATH&lt;/span&gt;=$PATH:$M2_HOME/&lt;span&gt;bin

# 步骤5：执行source命令让环境变量立即生效
source &lt;/span&gt;~/&lt;span&gt;.bash_profile

# 步骤6：验证Maven是否安装成功
mvn &lt;/span&gt;-&lt;span&gt;v

# 如果能打印Maven版本信息，则安装成功&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，进入到Kafka Eagle源代码根目录，在根目录中有一个build.sh的脚本，执行该脚本进行源代码编译。编译成功后，控制台会打印相关信息，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201807/666745-20180727000107937-1283479031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2.3 配置Kafka Eagle&lt;/h3&gt;
&lt;p&gt;准备好Kafka Eagle安装包后，接下来我们就可以进行安装了。其实，Kafka Eagle的安装是很简单的，当初设计这个系统就是遵循简单、易用的原则来的。但是，很多同学在安装的过程当中却遇到了很多各式各样的问题。其实，在官方使用手册的安装一节中，介绍的也很详细。官方使用手册地址：&lt;a href=&quot;http://ke.smartloli.org/&quot; target=&quot;_blank&quot;&gt;http://ke.smartloli.org/&lt;/a&gt; 文档托管在Gitbook，这里需要注意的是，可能有些同学反馈说访问不了，如果网络有波动，偶尔可能需要使用代理来访问。&lt;/p&gt;
&lt;p&gt;接下来，我们就开始配置Kafka Eagle系统，步骤如下：&lt;/p&gt;
&lt;h4&gt;1. 配置JAVA_HOME和KE_HOME&lt;/h4&gt;
&lt;p&gt;由于源代码核心实现采用的是Java语言，所以需要配置JDK环境，建议采用JDK8以上。配置内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vi&lt;/span&gt; ~/&lt;span&gt;.bash_profile
export JAVA_HOME&lt;/span&gt;=/usr/local/&lt;span&gt;jdk8
export KE_HOME&lt;/span&gt;=/data/soft/new/kafka-&lt;span&gt;eagle

export PATH&lt;/span&gt;=$PATH:$JAVA_HOME/bin:$KE_HOME/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，执行source ~/.bash_profile命令让命令立即生效。如果不配置环境变量，可能在启动Kafka Eagle脚本ke.sh时抛出如下异常，异常信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;26&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;&lt;span&gt;] Error: The KE_HOME environment variable is not defined correctly.
[&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;26&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;&lt;span&gt;] Error: This environment variable is needed to run this program.

[&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;26&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;&lt;span&gt;] Error: The JAVA_HOME environment variable is not defined correctly.
[&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;26&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;] Error: This environment variable is needed to run this program.
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2. 配置system-config.properties文件&lt;/h4&gt;
&lt;p&gt;该文件在$KE_HOME/conf/目录，配置内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;######################################
# 配置多个Kafka集群所对应的Zookeeper
######################################
kafka.eagle.zk.cluster.alias&lt;/span&gt;=&lt;span&gt;cluster1,cluster2
cluster1.zk.list&lt;/span&gt;=dn1:&lt;span&gt;2181&lt;/span&gt;,dn2:&lt;span&gt;2181&lt;/span&gt;,dn3:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;
cluster2.zk.list&lt;/span&gt;=tdn1:&lt;span&gt;2181&lt;/span&gt;,tdn2:&lt;span&gt;2181&lt;/span&gt;,tdn3:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;

######################################
# 设置Zookeeper线程数
######################################
kafka.zk.limit.size&lt;/span&gt;=&lt;span&gt;25&lt;/span&gt;&lt;span&gt;

######################################
# 设置Kafka Eagle浏览器访问端口
######################################
kafka.eagle.webui.port&lt;/span&gt;=&lt;span&gt;8048&lt;/span&gt;&lt;span&gt;

######################################
# 如果你的offsets存储在Kafka中，这里就配置
# 属性值为kafka，如果是在Zookeeper中，可以
# 注释该属性。一般情况下，Offsets的也和你消
# 费者API有关系，如果你使用的Kafka版本为0.&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.x
# 以后的版本，但是，你的消费API使用的是0.&lt;/span&gt;&lt;span&gt;8.2&lt;/span&gt;&lt;span&gt;.x
# 时的API，此时消费者依然是在Zookeeper中
######################################
kafka.eagle.offset.storage&lt;/span&gt;=&lt;span&gt;kafka

######################################
# 是否启动监控图表，默认是不启动的
######################################
kafka.eagle.metrics.charts&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;

######################################
# 在使用Kafka SQL查询主题时，如果遇到错误，
# 可以尝试开启这个属性，默认情况下，不开启
######################################
kafka.eagle.sql.fix.error&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;

######################################
# 邮件服务器设置，用来告警
######################################
kafka.eagle.mail.enable&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
kafka.eagle.mail.sa&lt;/span&gt;=&lt;span&gt;
kafka.eagle.mail.username&lt;/span&gt;=&lt;span&gt;
kafka.eagle.mail.password&lt;/span&gt;=&lt;span&gt;
kafka.eagle.mail.server.host&lt;/span&gt;=&lt;span&gt;
kafka.eagle.mail.server.port&lt;/span&gt;=&lt;span&gt;

######################################
# 设置告警用户，多个用户以英文逗号分隔
######################################
kafka.eagle.alert.users&lt;/span&gt;=&lt;span&gt;smartloli.org@gmail.com


######################################
# 超级管理员删除主题的Token
######################################
kafka.eagle.topic.token&lt;/span&gt;=&lt;span&gt;keadmin

######################################
# 如果启动Kafka SASL协议，开启该属性
######################################
kafka.eagle.sasl.enable&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
kafka.eagle.sasl.protocol&lt;/span&gt;=&lt;span&gt;SASL_PLAINTEXT
kafka.eagle.sasl.mechanism&lt;/span&gt;=&lt;span&gt;PLAIN

######################################
# Kafka Eagle默认存储在Sqlite中，如果要使用
# MySQL可以替换驱动、用户名、密码、连接地址
######################################
#kafka.eagle.driver&lt;/span&gt;=&lt;span&gt;com.mysql.jdbc.Driver
#kafka.eagle.url&lt;/span&gt;=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:3306/ke?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNull&lt;/span&gt;
#kafka.eagle.username=&lt;span&gt;root
#kafka.eagle.password&lt;/span&gt;=&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;

kafka.eagle.driver&lt;/span&gt;=&lt;span&gt;org.sqlite.JDBC
kafka.eagle.url&lt;/span&gt;=jdbc:sqlite:/Users/dengjie/workspace/kafka-egale/db/&lt;span&gt;ke.db
kafka.eagle.username&lt;/span&gt;=&lt;span&gt;root
kafka.eagle.password&lt;/span&gt;=root
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3. 启动Kafka Eagle&lt;/h4&gt;
&lt;p&gt;配置完成后，可以执行Kafka Eagle脚本ke.sh。如果首次执行，需要给该脚本赋予执行权限，命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;chmod&lt;/span&gt; +x $KE_HOME/bin/ke.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ke.sh脚本中，支持以下命令：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;命令&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ke.sh start&lt;/td&gt;
&lt;td&gt;启动Kafka Eagle系统&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ke.sh stop&lt;/td&gt;
&lt;td&gt;停止Kafka Eagle系统&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ke.sh restart&lt;/td&gt;
&lt;td&gt;重启Kafka Eagle系统&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ke.sh status&lt;/td&gt;
&lt;td&gt;查看Kafka Eagle系统运行状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ke.sh stats&lt;/td&gt;
&lt;td&gt;统计Kafka Eagle系统占用Linux资源情况&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ke.sh find [ClassName]&lt;/td&gt;
&lt;td&gt;查看Kafka Eagle系统中的类是否存在&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;在反馈出现频率最多的问题，就是Consumer模块没有数据展示、趋势监控图没有数据、Kafka SQL查询Topic没有数据。下面围绕这3个问题来给大家演示，以及解释什么情况下出现这种情况。&lt;/p&gt;
&lt;h2&gt;3.1 Consumer模块展示&lt;/h2&gt;
&lt;p&gt;启动一个消费者程序，然后进入到Consumer模块，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201807/666745-20180727003501567-792685122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201807/666745-20180727003557494-955457367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要注意的时，Kafka在0.10.x之后的版本和之前的版本底层设计有了变化，在之前的版本消费者信息是存储在Zookeeper中的，在0.10.x版本之后，默认存储到了Kafka内部主题中，只保留了元数据信息存储在Zookeeper中，例如：Kafka Broker地址、Topic名称、分区等信息。&lt;/p&gt;
&lt;p&gt;是不是我使用的是Kafka 0.10.x之后的版本（如0.10.0、1.0.x、1.x等），然后配置属性kafka.eagle.offset.storage=kafka，启动消费者，就可以看到消费者信息呢？不一定的，还有一个关键因素决定Kafka Eagle系统是否可以展示你消费者程序信息，那就是消费者API的使用。&lt;/p&gt;
&lt;p&gt;如果你使用的Kafka 0.10.x之后的版本，然后消费者API也是使用的最新的写法，那么自然你的消费者信息会被记录到Kafka内部主题中，那么此时你设置kafka.eagle.offset.storage=kafka这个属性，Kafka Eagle系统可以完美展示你的消费者使用情况。&lt;/p&gt;
&lt;p&gt;但是，如果你虽然使用的是Kafka 0.10.x之后的版本，但是你使用的消费者API还是0.8.2.x或是0.9.x时的写法，此时的消费者信息是会被记录到Zookeeper中进行存储，那么此时你需要设置kafka.eagle.offset.storage=zookeeper或者注释掉该属性，在访问Kafka Eagle系统就可以查看到你的消费者详情了。&lt;/p&gt;
&lt;h2&gt;3.2. 监控趋势图&lt;/h2&gt;
&lt;p&gt; Kafka系统默认是没有开启JMX端口的，所以Kafka Eagle的监控趋势图默认采用不启用的方式，即kafka.eagle.metrics.charts=false。如果需要查看监控趋势图，需要开启Kafka系统的JMX端口，设置该端口在$KAFKA_HOME/bin/kafka-server-start.sh脚本中，设置内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vi&lt;/span&gt; kafka-server-start.&lt;span&gt;sh&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x$KAFKA_HEAP_OPTS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;&lt;span&gt;
    export KAFKA_HEAP_OPTS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-server -Xms2G -Xmx2G -XX:PermSize=128m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=8 -XX:ConcGCThreads=5 -XX:InitiatingHeapOccupancyPercent=70&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    export JMX_PORT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    #export KAFKA_HEAP_OPTS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Xmx1G -Xms1G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的时，这里的端口不一定非要设置成9999，端口只有可用，均可。Kafka Eagle系统会自动获取这个JMX端口，采集结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201807/666745-20180727004948478-1062696178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.3 Kafka SQL查询Topic&lt;/h2&gt;
&lt;p&gt;还有一部分同学在Kafka Eagle系统的SQL查询Topic时，会出现查询不到数据的情况。这里查询不到数据可能情况有多种，首先需要排除Kafka集群因素，确保Kafka集群运行正常，Topic能够正常访问，并且Topic中是有数据的。&lt;/p&gt;
&lt;p&gt;在排除一些主观因素后，回到Kafka Eagle系统应用层面，如果出现这种问题，可以尝试开启属性kafka.eagle.sql.fix.error=true，这个属性默认是不开启的。正常情况下使用Kafka SQL查询Topic，返回结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201807/666745-20180727005710817-1885036162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201807/666745-20180727005735726-1157971488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 另外，如果在使用Kafka Eagle系统中遇到其他问题，可以查看$KE_HOME/logs/ke_console.out日志来分析具体的异常信息，一般都会提示具体的错误，大家可以根据错误提示来进行解决。&lt;/p&gt;

&lt;p&gt;这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！&lt;/p&gt;
&lt;p&gt;另外，博主出书了《Hadoop大数据挖掘从入门到进阶实战》，喜欢的朋友或同学， 可以在公告栏那里点击购买链接购买博主的书进行学习，在此感谢大家的支持。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 17:02:00 +0000</pubDate>
<dc:creator>哥不是小萝莉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smartloli/p/9371904.html</dc:identifier>
</item>
<item>
<title>group by、rollup、cube的用法以及区别 - springy</title>
<link>http://www.cnblogs.com/springy/p/9375236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/springy/p/9375236.html</guid>
<description>&lt;p&gt; 在此使用oracle，oracle 中的用法为 group by [rollup|cube]( colomn),sql server中的用法为group by colomn with [rollup|cube]&lt;/p&gt;
&lt;p&gt;  首先要弄明白rollup 和cube，就要知道group by的用法，group by 为对列进行分组，只展现分组统计的值，而rollup 为分层次展现，cube为展现列中所有层次，听我娓娓道来。&lt;/p&gt;
&lt;p&gt;1、搭建场地&lt;/p&gt;
&lt;p&gt;首先建立一个group_by 表,列值分别为购买者名称，购买物品的大类，购买物品的小类，物品以及价格，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726224511658-2047850742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户购买了一些3C以及衣物&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58.5&quot;&gt;&lt;img id=&quot;code_img_closed_be488b24-73ea-4dfe-918e-3f194cbde668&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_be488b24-73ea-4dfe-918e-3f194cbde668&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_be488b24-73ea-4dfe-918e-3f194cbde668&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;112&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; group_by (
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; o_name &lt;span&gt;varchar2&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; o_class &lt;span&gt;varchar2&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; o_item &lt;span&gt;varchar2&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; o_object &lt;span&gt;varchar2&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; o_price &lt;span&gt;int&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;springy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;phone&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;huawei&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;4000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;springy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;phone&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xiaomi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;springy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;computer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mac&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;springy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;phone&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;thinkpad&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;8000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;springy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;phone&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;huawei&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;4000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;springy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;clothes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shoes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adidas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;springy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;clothes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shoes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lining&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;400&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;springy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;clothes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pants&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jackjones&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stephenson&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;clothes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shoes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adivon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;200&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stephenson&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;clothes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shoes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nike&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stephenson&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;clothes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;skirt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nike&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;300&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; group_by &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stephenson&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;clothes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;skirt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adidas&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;400&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;commit&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726224952333-1207504917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、初识group by&lt;/p&gt;
&lt;p&gt;此时向我们缓缓走来的是group by，group by 可以对数据进行分组求值。&lt;/p&gt;
&lt;p&gt;首先对O_NAME,O_CLASS,O_ITEM进行group by 分组 ，查看购买者购买对应分类物品的价格合计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726230401882-278352382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_c208517c-6371-49ea-a9c9-38c7c02faaf6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c208517c-6371-49ea-a9c9-38c7c02faaf6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c208517c-6371-49ea-a9c9-38c7c02faaf6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; o_name, o_class, o_item, &lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(o_price)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; group_by
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; o_name, o_class, o_item
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; o_name, o_class, o_item
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到购买者没类物品消耗的价格&lt;/p&gt;
&lt;p&gt;3、rollup&lt;/p&gt;
&lt;p&gt;此时我们对统计的数据不太理想，除了想看每个小类，还想看每个大类，以及他们两人的消费和&lt;/p&gt;
&lt;p&gt;表格画出来就是这个意思&lt;/p&gt;
&lt;p&gt;　　　　表3-1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726231552349-996439753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时，我们将其与上面group by的进行对比，发现多了这些&lt;/p&gt;
&lt;p&gt;　　　　表3-2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726231727837-949900007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而这些又是怎么出来的呢？&lt;/p&gt;
&lt;p&gt;这是就回到了开始所说的，rollup为分层次展现，怎么个分层次法呢？&lt;/p&gt;
&lt;p&gt;首先，我们要确定，group by 的为O_NAME,O_CLASS,O_ITEM，此时对这些值进行分层次展现，即为下表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726232301479-1073794447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中第一行为group by出来的，接下来的三行即为分层次汇总统计，而最后的空白的一行为对购买者进行汇总统计。&lt;/p&gt;
&lt;p&gt;带入我们的例子中，可以看出来即为表3-1，而第2-4行则为多出来的部分，在此也可以看出来rollup 对group by中的值有顺序要求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_7e214fb9-6271-4e79-8cf7-37e246726256&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7e214fb9-6271-4e79-8cf7-37e246726256&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7e214fb9-6271-4e79-8cf7-37e246726256&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; o_name,o_class,o_item，&lt;span&gt;sum&lt;/span&gt;(o_price),&lt;span&gt;grouping&lt;/span&gt;(o_name ),&lt;span&gt;grouping&lt;/span&gt;(o_class),&lt;span&gt;grouping&lt;/span&gt;&lt;span&gt;(o_item)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; group_by
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; rollup (o_name,o_class,o_item) 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; o_name,o_class,o_item 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;使用rollup出来的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726233105117-790331764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，看到的结果和表格也不一样呀，其中还有这么多空格怎么处理？？别急，接下来会讲到&lt;/p&gt;
&lt;p&gt;4、初始cube &lt;/p&gt;
&lt;p&gt;说完rollup，开始说cube&lt;/p&gt;
&lt;p&gt;开始说cube为展现所有层次，这是什么意思呢？就是有这里面所有的分组汇总统计&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726233616652-1594043732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 在此，看下我们的结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_22e9809b-5cb1-40cd-8982-507f7b3a693f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_22e9809b-5cb1-40cd-8982-507f7b3a693f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_22e9809b-5cb1-40cd-8982-507f7b3a693f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; o_name,o_class,o_item，&lt;span&gt;sum&lt;/span&gt;(o_price),&lt;span&gt;grouping&lt;/span&gt;(o_name ),&lt;span&gt;grouping&lt;/span&gt;(o_class),&lt;span&gt;grouping&lt;/span&gt;&lt;span&gt;(o_item)
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; group_by
&lt;/span&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; cube (o_name,o_class,o_item) 
&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; o_name,o_class,o_item 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726234153225-1995298823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、group by、rollup、cube的用法以及区别&lt;/p&gt;
&lt;p&gt;cube的组合&lt;/p&gt;
&lt;p&gt;使用数字表达一下，看上去至少会更清晰点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726233639964-2133932905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想必这样子看上去更明白些，空值部分即该行为合计，这里面列出了所有分组。&lt;/p&gt;
&lt;p&gt;而cube与rollup的区别在于后面对2,3部分的分组&lt;/p&gt;
&lt;p&gt;rollup分组&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726233912255-1511730665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;group by分组&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726233949361-143808527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想必这样子更直观&lt;/p&gt;
&lt;p&gt; 6、处理空值&lt;/p&gt;
&lt;p&gt;此时有一个方法为grouping() 可以查看该值是否有rollup|cube产生的，若为其值则为1，否则为0，使用一个case when判断一下就好。&lt;/p&gt;
&lt;p&gt;下图为使用cube时，可以看出每个有cube产生合计，即空值处，其grouping的值都为1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_dee54f34-738f-4ded-ac35-fdad2f93ebea&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dee54f34-738f-4ded-ac35-fdad2f93ebea&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dee54f34-738f-4ded-ac35-fdad2f93ebea&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; o_name,o_class,o_item，&lt;span&gt;sum&lt;/span&gt;(o_price),&lt;span&gt;grouping&lt;/span&gt;(o_name ),&lt;span&gt;grouping&lt;/span&gt;(o_class),&lt;span&gt;grouping&lt;/span&gt;&lt;span&gt;(o_item)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; group_by
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; cube (o_name,o_class,o_item) 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; o_name,o_class,o_item 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726234627434-805779208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7 应用&lt;/p&gt;
&lt;p&gt;7.1在统计时，若只有一列，那么cube和rollup没差别&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_a0116873-abf7-4217-8ee2-eb62af5bf069&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a0116873-abf7-4217-8ee2-eb62af5bf069&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a0116873-abf7-4217-8ee2-eb62af5bf069&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;case&lt;/span&gt;
         &lt;span&gt;when&lt;/span&gt; &lt;span&gt;grouping&lt;/span&gt;(o_name) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
          &lt;span&gt;'&lt;/span&gt;&lt;span&gt;合计&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
          o_name
       &lt;/span&gt;&lt;span&gt;end&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;&lt;span&gt; customer,
       &lt;/span&gt;&lt;span&gt;sum&lt;/span&gt;(o_price) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; total,
       &lt;/span&gt;&lt;span&gt;grouping&lt;/span&gt;&lt;span&gt;(o_name) 
  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; group_by
 &lt;/span&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; rollup(o_name)
 &lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; o_name
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180726235332971-1713806197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在看到上图时，只对一列进行统计时，并且有合计值时使用cube和rollup都ok。&lt;/p&gt;
&lt;p&gt;7.2 若进行两列的统计&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_46dedf27-3724-48c8-96ab-77f72675b80c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_46dedf27-3724-48c8-96ab-77f72675b80c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_46dedf27-3724-48c8-96ab-77f72675b80c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;case&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;          &lt;span&gt;when&lt;/span&gt; &lt;span&gt;grouping&lt;/span&gt;(o_name) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;           &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;distinct&lt;/span&gt; o_name) &lt;span&gt;||&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;位&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;          &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;          o_name
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;end&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;&lt;span&gt; customer,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;case&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;          &lt;span&gt;when&lt;/span&gt; &lt;span&gt;grouping&lt;/span&gt;(o_class) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;grouping&lt;/span&gt;(o_name) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;           &lt;span&gt;'&lt;/span&gt;&lt;span&gt;合计&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;          &lt;span&gt;when&lt;/span&gt; &lt;span&gt;grouping&lt;/span&gt;(o_class) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;           &lt;span&gt;'&lt;/span&gt;&lt;span&gt;小计&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;          &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;          o_class
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        &lt;span&gt;end&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;&lt;span&gt; class,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;        &lt;span&gt;sum&lt;/span&gt;(o_price) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; total,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;        &lt;span&gt;grouping&lt;/span&gt;&lt;span&gt;(o_name),
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;        &lt;span&gt;grouping&lt;/span&gt;&lt;span&gt;(o_class)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   &lt;span&gt;from&lt;/span&gt;&lt;span&gt; group_by
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; rollup(o_name, o_class)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; o_name, o_class
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180727001938231-509944096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到类似上图时，总的合计中不出现第二列的详细情况时，只对两列进行总的合计时，使用rollup&lt;/p&gt;
&lt;p&gt;7.3 两列分各种情况全统计&lt;/p&gt;
&lt;p&gt; 此时，我除了想看到两位顾客和消费，还想看到两位在各个类上的消费是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_20b08ce8-cbac-4e67-bdce-b456c6eeb6ec&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_20b08ce8-cbac-4e67-bdce-b456c6eeb6ec&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_20b08ce8-cbac-4e67-bdce-b456c6eeb6ec&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;case&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;          &lt;span&gt;when&lt;/span&gt; &lt;span&gt;grouping&lt;/span&gt;(o_name) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;grouping&lt;/span&gt;(o_class) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;           &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;distinct&lt;/span&gt; o_name) &lt;span&gt;||&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;位消费&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;            &lt;span&gt;when&lt;/span&gt; &lt;span&gt;grouping&lt;/span&gt;(o_class) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;          &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;          o_name
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;end&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;&lt;span&gt; customer,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;        &lt;span&gt;case&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;          &lt;span&gt;when&lt;/span&gt; &lt;span&gt;grouping&lt;/span&gt;(o_class) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;grouping&lt;/span&gt;(o_name) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;           &lt;span&gt;'&lt;/span&gt;&lt;span&gt;合计&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;          &lt;span&gt;when&lt;/span&gt; &lt;span&gt;grouping&lt;/span&gt;(o_class) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;           &lt;span&gt;'&lt;/span&gt;&lt;span&gt;小计&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;          &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;          o_class
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;        &lt;span&gt;end&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;&lt;span&gt; class,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;        &lt;span&gt;sum&lt;/span&gt;(o_price) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; total,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;        &lt;span&gt;grouping&lt;/span&gt;&lt;span&gt;(o_name),
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;        &lt;span&gt;grouping&lt;/span&gt;&lt;span&gt;(o_class)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   &lt;span&gt;from&lt;/span&gt;&lt;span&gt; group_by
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; cube(o_name, o_class)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; o_name, o_class &lt;span&gt;desc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397757/201807/1397757-20180727001759061-154667126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应的图就是上面这样子。&lt;/p&gt;
&lt;p&gt;若果仍不清楚，就挨着试一下rollup和cube。&lt;/p&gt;

</description>
<pubDate>Thu, 26 Jul 2018 16:25:00 +0000</pubDate>
<dc:creator>springy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/springy/p/9375236.html</dc:identifier>
</item>
<item>
<title>一个小白的四次前端面试经历 - 一步一步向上爬</title>
<link>http://www.cnblogs.com/z937741304/p/9375226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/z937741304/p/9375226.html</guid>
<description>&lt;p&gt;　　做一个自我介绍，本人男，爱好女。曾以为自己可以改变世界，没想到被世界无情的摧残。来深圳之前那种找工作少于1W少跟我谈，变成了收到offer了4000包吃住挺好，由于现在还没有找到工作，有招前端工程师的可以和我留言和我联系一下嘿嘿，本人实际项目经验有些少，但是基础知识html，css，js这些基本知识还是挺扎实的。&lt;/p&gt;

&lt;p&gt;　　在深圳已经快两个星期了，从7月22号开始就一直在投简历，第一天投了100多份，之后每天就投几十份吧，在这其中面试了一共四家公司，其中有一家公司已经表示要我了，但是由于薪资问题还有他们公司只要我去了就只有我一个前端这样的问题，感觉不太适合的成长，就拒绝了。下面具体说一说四次面试经历，已经问到的问题，现在就做一次总结。&lt;/p&gt;
&lt;p&gt;　　本人由于现在在读大四（下半年开始读），所以去公司面试过程中难免会被问到自己的学历，比较尴尬，再加上自己的经验不足，所以小公司都会把我当成实习生来看待的感觉不是太好，因为实习生工资是有一些低的，感觉很难活下去。&lt;/p&gt;
&lt;p&gt;　　我因为租房的地方离四次面试的地方比较远，有三次都是2个小时左右的地铁上的时间，再加上走路找到公司的时间，所以每次走的都特别早，每次都差不多提前近一个小时就到了，第一次面试过程，我是提早了半个多小时到的，这是我来到这里第一次面试，比较重视，所以还专门去他公司的官网当中去看了看公司文化啥的，以为会被问到，然而四次下来没有一个公司问到我公司文化。第一次面试过程中一个应该算是全栈的技术人员来面试我的技术，每一个公司都会让你自己先做一个自我介绍的，当时脑子不好使了还是怎么了，就说了我叫XXX，来自哪里，在哪里上的学，然后就没有在说话，面试官都楞了一下。哈哈，因为我的简历上面写的东西都是真实比如自己的一些技能，自己的作品都是真实的，但是实际项目其实没有几个，这个技术人员着重问的我是我的技术能力中的东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250927/201807/1250927-20180726230208334-683661547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面的是我的能力技能的简历，因为我面试之后猜的，他可能是一个全栈工程师，所以前端的一些技能我感觉可能没有我深入，但是他的经验肯定是比我高的，他一直都是问我的问题都是一些表面的东西。重点有几个。 H5的一些新增的特性有哪些，我没有做具体的介绍，只是在坐地铁的过程中将H5的一些新增的特性说了出来，比如 新增了一些语义化标签，拖拽，本地存储，离线存储，多线程，多媒体标签音乐视频了，我当时连svg，canvas都忘记了说。我以为他会在其中打断我，让我对其中的一个东西做一个具体的介绍，没想到没有再问我。 第二个重点就是问了一下我封装jQ的时候具体实现了哪些方法，是如何封装的。我就简单的介绍了一下基本的功能，获取元素的一些方法，获得宽高，定位位置，事件，动画等一些功能，然后讲了一下简单的实现。他在中间也没有打断我说，也没有再继续问我这个问题，然后就换问题了，没有问我关于es6的问题，问到node.js的掌握程度，我说我用node.js通过express，mysql等一些模块做出了自己个人博客，有一些什么功能等等。他重点又问了我一些mysql的增删改查一些，内连接外连接知道是什么吗。其他的没有什么要说的了。我感觉他对我是比较满意的，这也是给我offer一家公司。接下来HR面试的时候，就主要问了住在哪里，就是看我们的忠心吧，会不会做东西做到一半跳槽了。我也就坚决表明了自己的决心，因为我人比较实在，只要还可以，只要能学到技术，一直待下去我也是没问题的。&lt;/p&gt;
&lt;p&gt;　　第二次面试就不是那么愉快了，因为他们公司招的人是主要做微信小程序为主的，我自己又是只是对微信小程序有一个简单的了解，并没有做出来过实际的项目，再加上这家公司要招的人说主要是想找一个来了就可以立马来上手工作的人，我也没有达到他的要求，也还可以吧，这家公司没有问太多的技术，只是对我的经历着重问了好多，如果说要问技术的话主要是问了vue，vue的原理，还有就是对微信小程序的看法是什样子的，我的回答让他不太满意吧或许，最后留下了一个等通知吧，我就已经知道没戏了，最后的一个问题都是这个你对公司还想有什么需要了解的吗。我问的他的是一个有点傻气的问题，我问公司包住吗？哈哈 接下来对我一阵教育，口头上都表示了对我的一些不满意，说现在的大学生出来之后应该是对技术保持着热情，而薪资待遇什么的都是次要的，感觉学习到了，因为我当时确实没有什么问题想问的，也不知道该问什么，我感觉什么都不说有点不好，反正就是一出门口就知道这次已经没戏了。&lt;/p&gt;
&lt;p&gt;　　第三家公司的招聘信息当中并没有提到招前端工程师，招的是软件工程师，我以为是招错了，所以多次联系确定之后去了他家的公司面试，这一家是做通讯的东西的，我感觉他们公司个个都是大牛。用c和c++去开发操作系统，然后在操作系统上的一些http、反正是一大堆通讯协议，对于我的能力技术我感觉他还是比较认可我的，因为底层的人应该是重基础的，问的我前端的问题比较少，问的我后台的知识，重点问的我的是mysql的语法，视图一些东西问的比较深入，他对前端新兴的技术不是那么了解，没有问我框架，只是问了我一些html、css原生的js的一些东西。他是看我的发展方向的，我问他我去他们公司主要去做什么事情。他说了好多我要干的工作，感觉就是除了操作系统之外的东西，我全部都需要干的那种。前端的系统的界面设计，再去用前端做出界面，还需要通过后台语言去把ajax请求存数据库，如果有需要的话我还需要出差去跟客户模拟这个功能，我还要会一些基本linux系统的指令，还需要读懂一些他们c、c++的源码。我感觉我有点难受，这样的工作或许是好多工作了三四年的前端都不曾具备的能力吧。我唯一的一次发挥就是他看到我的简历上面写的是做过一个超市管理系统，让我拿着笔去跟他画一画具体的实现的过程，我感觉我讲的不是那么好，他心中应该是对我有一点点失望的。但是我也很难受，我面试的是一个前端工程师，我要做这么多的事情，所以这一次也不算失败吧，我说我现在有点达不到他们的要求，他说可以培养我，然后一点一点的来，我也不知道怎么吧，感觉这个工作不太适合我，或许会适合三四年后的我，但是绝对不适合现在的我，面试过程还算愉快，就是有一点不适合。&lt;/p&gt;
&lt;p&gt;　　第四家公司真的就是高大上了，在腾讯的旁边，先不说面试，先说腾讯，真的就是当时内心挺害怕的。有点不好意思的说就是当时站在腾讯大楼面前腿是有些瑟瑟发抖的。我想BAT应该是90%以上的前端工程师想进去的公司吧，我想以后有能力的时候也可以去他们的公司工作，当然我要付出好多的努力。咱们来说面试，这次面试是我这几次当中最开心快乐的一次，面试官真的是大牛，就是完全的让你发挥自己，他自己在我磕绊住的时候稍微换一个小小的话题就会让我继续把我的经验，技术说下去。怎么说呢，面试的过程我内心是非常快乐的，但是可能他对我的技术能力有一点就是感到我的能力经验或许会有一些不足。就问的我一些我的简历当中具体的项目中的问题来问我是如何解决的。总结下来就是下面几个。我做自我介绍的过程当中他对我的简历的一些东西来打断我来跟我比对，不会让我一直说到无话可说，然后问了一些我平时的学习方法。我做过一个仿京东首页的静态页面，他问的我是如何适配手机端的页面的。我用的是rem布局，他让我说rem布局的原理，然后我说完之后，我就疯狂的夸rem的优点，我说他不用写那种响应式的写好多套样式，写一套就行了，非常简单，方便。他问我有什么缺点，我就说所有的单位都是rem会去计算，可能性能上有一些不好。他问我还有呢，我实在是想不出他还有哪一点不好，所以我嗯哼的半天说我不知道，我感觉他挺好的了哈哈。接着我俩就开始笑。 还有一个问题就是看到了封装jQ，然后也是问的我实现的原理，功能。我说到功能的时候，说到了动画，他让我给他讲一下实现那个的过程。我那个已经是好几个月之前的事情了，说实话让我当场讲有一些困难，我讲的也并不好，但是还是讲完了。后来就是问了我css的一个最基本的问题 定位 有哪几种定位方式，有什么不同。我说心里话，如果这个问题是半年之前问的我，我肯定回答的非常好，但是无奈是现在，大概每一个用过他的人都知道该怎么使用，使用的过程中出现的问题。我讲出来的 东西是对的，但是讲出来的不是那么完整，就是缺少一些东西。相对定位的特性当中更没有说出不影响元素本身的特性（&lt;span class=&quot;md-expand&quot;&gt;块级的还是支持margin：auto； 行内元素还是行内元素和块级元素还是块级元素&lt;/span&gt;）。他当时是问了我的，还有其他的特性吗，我确实是想不起来了，所以有点遗憾当时没有说出来。因为就从这一点当中可以看出我整体的学习的一个知识体系，就是给了他一种我什么东西都学了但是掌握的不到位的感觉。相对定位中也没有提到 &lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;行内元素支持宽高    &lt;strong&gt;&lt;span&gt;块级元素，内容撑开宽高  &lt;span class=&quot;md-expand&quot;&gt;不支持margin:auto:&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt; &lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;的这一个特性，当然在这其中我是想到了z-index层级的关系的但是我不知道出于什么想法，没有把层级这个东西说出来，所以这一个问题是我在面试当中回答的特别不满意的地方。最后一个肯定会问的问题，我问了他一个我到现在还不是太明白的区块链到底是干什么的，他对这方面了解的不是太多，说对这个不敢妄加断论，但是他给我介绍了一下他们公司的这方面的东西，说是想要建立一个部门的，他问我还有什么需要问的吗，我直接说我非常喜欢你们公司，希望可以来这里工作。我俩一直笑。后面的HR来面试我，我感觉他对我的印象可能不是那么好，后面他又去找老板或者是谁去了，那个人不在公司，所以说等通知，电话联系，总之如果可以去他们的那个公司的话，我感觉对我的成长是非常大的，我直接跟他们说了，我非常的喜欢他们公司。最后有一个举动感觉不是太礼貌，我当时因为想让他对我有一些印象，所以主动找他握手了，感觉不是太好的行为。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;　　总之了，感觉这边机会特别多，但是对于网络上的招聘信息，什么8000-15000什么的一些招聘，你也不要太相信这上面的价格，你自己的能力心里是有一点数的，一般达不到他们的要求的话，他们可能会录用你，但是工资绝对是到不了他们最低的那个的，肯定会比8000要低的感觉。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;　　反正我会一直在前端这个圈子里面一直捣鼓下去的，我希望我还可以保持现在的努力，可以保持现在的热情，明天会更好！！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;　　我来园子有九个多月了，从来没有主动要过赞，感觉写的可以给我点一个赞好吗，给我一些支持，我希望明天真的会更好！！ 对于一个外地人来这里找工作，我只想说挺难的。请给我一点鼓励和支持。谢谢了，自己祝福自己可以早日找到工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 16:19:00 +0000</pubDate>
<dc:creator>一步一步向上爬</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/z937741304/p/9375226.html</dc:identifier>
</item>
<item>
<title>gocommand:一个跨平台的golang命令行执行package - lizongshen</title>
<link>http://www.cnblogs.com/lizongshen/p/9375158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lizongshen/p/9375158.html</guid>
<description>&lt;p&gt;    最近在做一个项目的时候,需要使用golang来调用操作系统中的命令行,来执行shell命令或者直接调用第三方程序,这其中自然就用到了golang自带的exec.Command.&lt;/p&gt;
&lt;p&gt;    但是如果直接使用原生exec.Command会造成大量的重复代码,网上搜了一圈又没有找到对exec.Command相应的封装包,索性自己封装了一个,取名为&lt;a href=&quot;https://github.com/lizongshen/gocommand&quot; target=&quot;_blank&quot;&gt;gocommand&lt;/a&gt;.目前支持Linux和Windows,欢迎各位大神在github上提交代码补充其他平台的实现.&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;下面介绍一下gocommand库的实现思路:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package gocommand

// 命令行接口
type Commander interface {
        // 执行命令行并返回结果
        // args: 命令行参数
        // return: 进程的pid, 命令行结果, 错误消息
        Exec(args ...string) (int, string, error)

        // 异步执行命令行并通过channel返回结果
        // stdout: chan结果
        // args: 命令行参数
        // return: 进程的pid
        // exception: 协程内的命令行发生错误时,会panic异常
        ExecAsync(stdout chan string, args ...string) int

        // 执行命令行(忽略返回值)
        // args: 命令行参数
        // return: 错误消息
        ExecNoWait(args ...string) error
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;gocommand目前的命令行执行函数都是源于Commander接口,目前该接口定义了3个函数,分别是:执行命令行病返回结果;异步执行命令行并得到结果;执行命令行并忽略结果.&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package gocommand

import (
        &quot;runtime&quot;
)

// Command的初始化函数
func NewCommand() Commander {
        var cmd Commander

        switch runtime.GOOS {
        case &quot;linux&quot;:
                cmd = NewLinuxCommand()
        case &quot;windows&quot;:
                cmd = NewWindowsCommand()
        default:
                cmd = NewLinuxCommand()
        }

        return cmd
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    创建一个Command的实现,并根据当前的操作系统,返回对应的实现函数,目前只实现了Linux和Windows,(Mac留给各位大神(土豪)了),其中LinuxCommand的代码实现如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package gocommand

import (
        &quot;io/ioutil&quot;
        &quot;os&quot;
        &quot;os/exec&quot;
        &quot;syscall&quot;
)

// LinuxCommand结构体
type LinuxCommand struct {
}

// LinuxCommand的初始化函数
func NewLinuxCommand() *LinuxCommand {
        return &amp;amp;LinuxCommand{}
}

// 执行命令行并返回结果
// args: 命令行参数
// return: 进程的pid, 命令行结果, 错误消息
func (lc *LinuxCommand) Exec(args ...string) (int, string, error) {
        args = append([]string{&quot;-c&quot;}, args...)
        cmd := exec.Command(os.Getenv(&quot;SHELL&quot;), args...)

        cmd.SysProcAttr = &amp;amp;syscall.SysProcAttr{}

        outpip, err := cmd.StdoutPipe()
        if err != nil {
                return 0, &quot;&quot;, err
        }

        err = cmd.Start()
        if err != nil {
                return 0, &quot;&quot;, err
        }

        out, err := ioutil.ReadAll(outpip)
        if err != nil {
                return 0, &quot;&quot;, err
        }

        return cmd.Process.Pid, string(out), nil
}

// 异步执行命令行并通过channel返回结果
// stdout: chan结果
// args: 命令行参数
// return: 进程的pid
// exception: 协程内的命令行发生错误时,会panic异常
func (lc *LinuxCommand) ExecAsync(stdout chan string, args ...string) int {
        var pidChan = make(chan int, 1)

        go func() {
                args = append([]string{&quot;-c&quot;}, args...)
                cmd := exec.Command(os.Getenv(&quot;SHELL&quot;), args...)

                cmd.SysProcAttr = &amp;amp;syscall.SysProcAttr{}

                outpip, err := cmd.StdoutPipe()
                if err != nil {
                        panic(err)
                }

                err = cmd.Start()
                if err != nil {
                        panic(err)
                }

                pidChan &amp;lt;- cmd.Process.Pid

                out, err := ioutil.ReadAll(outpip)
                if err != nil {
                        panic(err)
                }

                stdout &amp;lt;- string(out)
        }()

        return &amp;lt;-pidChan
}

// 执行命令行(忽略返回值)
// args: 命令行参数
// return: 错误消息
func (lc *LinuxCommand) ExecNoWait(args ...string) error {
        args = append([]string{&quot;-c&quot;}, args...)
        cmd := exec.Command(os.Getenv(&quot;SHELL&quot;), args...)

        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.SysProcAttr = &amp;amp;syscall.SysProcAttr{}

        err := cmd.Run()

        return err
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    Exec函数会在执行命令行后阻塞,直到得到命令的执行结果;ExecAsync函数在内部使用了协程来执行命令行,并通过参数中的chan变量把结果传递出去;ExecNoWait会无阻赛地执行命令行.Windows平台上的实现类似,只是Shell命令换成了cmd.&lt;/p&gt;
&lt;p&gt;    使用示例如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import (
        &quot;log&quot;

        &quot;github.com/lizongshen/gocommand&quot;
)

func main() {
        _, out, err := gocommand.NewCommand().Exec(&quot;ls /&quot;)
        if err != nil {
                log.Panic(err)
        }

        log.Println(out)

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    代码的单元测试情况:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[lizongshen@localhost gocommand]$ go test
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr
PASS
ok      gocommand       0.007s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    github开源地址:&lt;a href=&quot;https://github.com/lizongshen/gocommand&quot; target=&quot;_blank&quot;&gt;https://github.com/lizongshen/gocommand&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 16:01:00 +0000</pubDate>
<dc:creator>lizongshen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lizongshen/p/9375158.html</dc:identifier>
</item>
<item>
<title>使用“数据驱动测试”之前应该知道的 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/9375172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/9375172.html</guid>
<description>&lt;p&gt;我曾经写过一篇博客&lt;a href=&quot;https://www.cnblogs.com/fnng/p/6111516.html&quot;&gt;《自动化测试---被玩坏的数据驱动》&lt;/a&gt;讨论过数据驱动测试，当时主要是吐槽那些教大家读取txt、csv/excel、xml文件文章。“我教大家如何做数据驱动测试，来！我们先学习如何读取excel文件。。。”，然后，网上也有大量的文章来介绍如何用excel来管理测试数据的，甚至是测试报告展示的。&lt;/p&gt;
&lt;p&gt;读各种数据文件就是驱动测试？这样真的方便做测试么？&lt;/p&gt;

&lt;h4 id=&quot;什么是数据驱动测试&quot;&gt;什么是数据驱动测试？&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从它的定义来看，就是数据的改变从而驱动自动化测试的执行，最终引起测试结果的改变。说的直白些，就是参数化的应用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;他们认为数据驱动什么样子&quot;&gt;“他们”认为数据驱动什么样子？&lt;/h4&gt;
&lt;p&gt;这里以csv文件为例，大多文章也是选用的csv/excel文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201807/311516-20180726235920541-1029019834.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数、断言、结果都有了，大概就这样子吧？&lt;/p&gt;
&lt;p&gt;接下来需要将数据读取出来。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
import csv
import codecs
from itertools import islice

# 读取本地 CSV 文件
data = csv.reader(codecs.open('user_info.csv', 'r', 'utf_8_sig'))

# 用户存放用户数据
users = []

# 循环输出每一行信息
for line in islice(data, 1, None):
    users.append(line)

# 打印
print(users)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[['', '123', '请输入帐号', ''],
['user', '', '请输入密码', ''],
['error', 'error', '帐号或密码错误',''],
['admin', 'admin123', 'admin你好', ''],
['guest', 'guest123', 'guest你好', '']]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里得到一个测试数据的二维数组。&lt;/p&gt;
&lt;p&gt;那么接下来要用这些数据做自动化测试了？被测试功能如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201807/311516-20180726235937103-1824815949.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 测试登陆功能
from selenium import webdriver
from time import sleep


driver = webdriver.Chrome()

for user in users:
    driver.get(&quot;http://127.0.0.1:8000/&quot;)
    driver.find_element_by_id(&quot;inputUsername&quot;).send_keys(user[0])
    driver.find_element_by_id(&quot;inputPassword&quot;).send_keys(user[1])
    driver.find_element_by_id(&quot;Login&quot;).click()
    sleep(2)    
    tips = driver.find_element_by_id(&quot;tips&quot;).text
    print(tips)
    print(user[2])
    try:
        assert tips == user[2]
    except AssertionError as msg:
        print(msg)
        user[3] = &quot;Faile&quot;
    else:
        user[3] = &quot;Pass&quot;

driver.quit()

# 打印结果
print(users)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后的测试结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[['', '123', '请输入帐号', 'Pass'],
['user', '', '请输入密码', 'Pass'],
['error', 'error', '帐号或密码错误','Pass'],
['admin', 'admin123', 'admin你好', 'Faile'],
['guest', 'guest123', 'guest你好', 'Faile']]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看，结果已经写到最后一列了。&lt;/p&gt;
&lt;p&gt;最后，我们还需要将测试结果写回到csv文件中。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 读取本地 CSV 文件
csv_file = csv.writer(codecs.open('user_info.csv', 'w','utf_8_sig'), 
                                  dialect=&quot;excel&quot;)

# 写入标题
csv_file.writerow(['用户名','密码','断言','结果'])

# 循环写入数据
for user in users:
    csv_file.writerow(user)

# 打印
print(users)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开CSV文件，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201807/311516-20180726235952943-1808440802.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看结果一列，是不是已经有了结果。&lt;/p&gt;

&lt;h4 id=&quot;那么下来思考几个问题&quot;&gt;那么，下来思考几个问题。&lt;/h4&gt;
&lt;p&gt;1、测试结果是否太过简单了，只有“Pass”和“Faile”，没有任何失败的日志，是否需要另起一列记录失败日志？&lt;/p&gt;
&lt;p&gt;2、如何统计出总失败的用例数和成功的用例数？&lt;/p&gt;
&lt;p&gt;3、如果想单独验证失败的两条用例应该怎么做？例如上图中的最后两条失败的用例。&lt;/p&gt;
&lt;p&gt;4、上面的测试代码中，有多少是真正用在测试操作的，至少一半都在读写csv文件，是否需要做封装，想想怎么封装更简单？&lt;/p&gt;
&lt;p&gt;5、在获取具体读取数据的时候，我们使用的是user[0]、user[1]、user[2]，你真的容易分辨这些数据么？如果又加了一列数据呢？不改代码是不是就对不上号了。&lt;/p&gt;
&lt;p&gt;6、这只是一组登录数据。我们知道不同的功能，所需要的数据是不一样的，比如搜索，只需要“搜索关键字”， 例如注册，需要“邮箱”、“密码”、“重复密码”、“昵称”等。我们一个系统有N多功能的好吧！&lt;/p&gt;
&lt;p&gt;7、如第6条，这些测试数据要怎么放，放在一个csv文件还是多个文件？怎么统计测试结果？&lt;/p&gt;
&lt;p&gt;所以，知道读取数据文件有多坑了吧！？谁说的方便维护？你一定没用这种方式写过真正的项目吧！一直处在跟着别人写demo阶段。如果你有更“高大上”的处理方式欢迎请告诉我，谢谢！&lt;/p&gt;
&lt;p&gt;下一篇，我将介绍基于单元测试框架的数据驱动。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 16:00:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/9375172.html</dc:identifier>
</item>
<item>
<title>Netty源码—五、内存分配概述 - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/9375157.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/9375157.html</guid>
<description>&lt;p&gt;Netty中的内存管理应该是借鉴了FreeBSD内存管理的思想——&lt;a href=&quot;http://jemalloc.net/&quot;&gt;jemalloc&lt;/a&gt;。Netty内存分配过程中总体遵循以下规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优先从缓存中分配&lt;/li&gt;
&lt;li&gt;如果缓存中没有的话，从内存池看看有没有剩余可用的&lt;/li&gt;
&lt;li&gt;如果已申请的没有的话，再真正申请内存&lt;/li&gt;
&lt;li&gt;分段管理，每个内存大小范围使用不同的分配策略&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们先总体上看下Netty内存分配的策略，然后再结合对应的数据结构来看看每种策略的具体实现。&lt;/p&gt;
&lt;h2 id=&quot;总体分配策略&quot;&gt;总体分配策略&lt;/h2&gt;
&lt;p&gt;netty根据需要分配内存的大小使用不同的分配策略，主要分为以下几种情况(pageSize默认是8K, chunkSize默认是16m)：&lt;/p&gt;
&lt;p&gt;tiny: allocateSize&amp;lt;512，allocateSubpage&lt;/p&gt;
&lt;p&gt;small: pageSize&amp;gt;=allocateSize &amp;gt;=512，allocateSubpage&lt;/p&gt;
&lt;p&gt;normal: chunkSize &amp;gt;= allocateSize &amp;gt; pageSize ，allocateRun&lt;/p&gt;
&lt;p&gt;huge: allocateSize &amp;gt; chunkSize&lt;/p&gt;
&lt;p&gt;内存分配的调用堆栈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/846961/201807/846961-20180726234930674-1465433303.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结合上面内存分配的调用堆栈看看内存分配的主要过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;new一个ByteBuf，如果是direct则new：PooledUnsafeDirectByteBuf&lt;/li&gt;
&lt;li&gt;从缓存中查找，没有可用的缓存进行下一步&lt;/li&gt;
&lt;li&gt;从内存池中查找可用的内存，查找的方式如上所述（tiny、small、normal）&lt;/li&gt;
&lt;li&gt;如果找不到则重新申请内存，并将申请到的内存放入内存池&lt;/li&gt;
&lt;li&gt;使用申请到的内存初始化ByteBuf&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;基本数据结构&quot;&gt;基本数据结构&lt;/h2&gt;
&lt;p&gt;PoolSubpage：一个内存页，默认是8k&lt;/p&gt;
&lt;p&gt;PoolChunk：有多个PoolSubpage组成，默认包含2048个subpage，即默认大小是16m&lt;/p&gt;
&lt;p&gt;chunk内部包含一个byte数组memoryMap，默认包含4096个元素，memoryMap实际上是一棵完全二叉树，共有12层，也就是maxOrder默认是11（从0开始），所以这棵树总共有2048个叶子结点，每个叶子节点对应一个subpage，树中非叶子节点的内存大小由左子节点的内存大小加上右子节点的内存大小，memoryMap数组中存储的值是byte类型，其实就是该树节点在树中的深度（深度从0开始）。树的基本结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/846961/201807/846961-20180726234953241-661643120.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PoolSubpage表示一个内存页大小，还可以继续划分成更小的内存块，以便能充分利用每一个page。&lt;/p&gt;
&lt;p&gt;所以在分配内存的时候，如果分配的内存小于pageSIze（默认8k）大小，则会从PoolSubpage中分配；&lt;/p&gt;
&lt;p&gt;如果需要分配的内存大于pageSize且小于chunkSize（默认16m）的内存从chunk中分配&lt;/p&gt;
&lt;p&gt;如果大于chunkSize的内存则直接分配，Netty不做进一步管理。&lt;/p&gt;
&lt;h2 id=&quot;normal内存申请&quot;&gt;normal内存申请&lt;/h2&gt;
&lt;p&gt;先看下分配内存的入口方法allocate&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 这个方法进行具体申请内存的操作
private void allocate(PoolThreadCache cache, PooledByteBuf&amp;lt;T&amp;gt; buf, final int reqCapacity) {
    final int normCapacity = normalizeCapacity(reqCapacity);
    // 小于pageSize(默认是8K)
    if (isTinyOrSmall(normCapacity)) { // capacity &amp;lt; pageSize
        int tableIdx;
        PoolSubpage&amp;lt;T&amp;gt;[] table;
        boolean tiny = isTiny(normCapacity);
        if (tiny) { // &amp;lt; 512
            // 使用缓存
            if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) {
                // was able to allocate out of the cache so move on
                return;
            }
            tableIdx = tinyIdx(normCapacity);
            table = tinySubpagePools;
        } else {
            // 512-8K
            if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) {
                // was able to allocate out of the cache so move on
                return;
            }
            tableIdx = smallIdx(normCapacity);
            table = smallSubpagePools;
        }

        final PoolSubpage&amp;lt;T&amp;gt; head = table[tableIdx];

        /**
             * Synchronize on the head. This is needed as {@link PoolChunk#allocateSubpage(int)} and
             * {@link PoolChunk#free(long)} may modify the doubly linked list as well.
             */
        synchronized (head) {
            final PoolSubpage&amp;lt;T&amp;gt; s = head.next;
            if (s != head) {
                assert s.doNotDestroy &amp;amp;&amp;amp; s.elemSize == normCapacity;
                // 这里为什么一定可以找到可用的内存块（handle&amp;gt;=0）呢？
                // 因为在io.netty.buffer.PoolSubpage#allocate的时候，如果可用内存块为0了会将该page从链表中remove，所以保证了head.next一定有可用的内存
                long handle = s.allocate();
                assert handle &amp;gt;= 0;
                s.chunk.initBufWithSubpage(buf, handle, reqCapacity);

                if (tiny) {
                    allocationsTiny.increment();
                } else {
                    allocationsSmall.increment();
                }
                return;
            }
        }
        allocateNormal(buf, reqCapacity, normCapacity);
        return;
    }
    if (normCapacity &amp;lt;= chunkSize) {
        if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) {
            // was able to allocate out of the cache so move on
            return;
        }
        allocateNormal(buf, reqCapacity, normCapacity);
    } else {
        // Huge allocations are never served via the cache so just call allocateHuge
        allocateHuge(buf, reqCapacity);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到除了huge内存之外，其他内存申请都可能会调用到allocateNormal，我们先来看下normal内存的申请。&lt;/p&gt;
&lt;p&gt;上文一直提到tiny、small、normal、huge，这里我们看下这些内存划分的标准是什么&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// normCapacity &amp;lt; 512
static boolean isTiny(int normCapacity) {
    // 小于512的是tiny
    return (normCapacity &amp;amp; 0xFFFFFE00) == 0;
}

// capacity &amp;lt; pageSize
// subpageOverflowMask = ~(pageSize - 1);
// 所以小于8k的是small或者tiny，结合tiny的范围，small的范围就是：512-8192
boolean isTinyOrSmall(int normCapacity) {
    return (normCapacity &amp;amp; subpageOverflowMask) == 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大于8k但是小于chunkSize（16m）的使用allocateNormal来申请内存，所以我们暂且把这个范围的称为normal&lt;/p&gt;
&lt;p&gt;大于chunkSize使用allocateHuge来申请内存，我们暂且把这个范围的称为huge。&lt;/p&gt;
&lt;p&gt;还需要一个铺垫，申请内存大小的规整。Netty并不是申请多少就分配多少，会根据一定的规则分配大于等于需要内存的规整过的值。上面在allocate方法刚开始就会先将reqCapacity规范化为normCapacity，使用下面的方法，规范的过程也是进行了分类，不同的内存大小类型规范化的方式不一样&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 规范化申请的内存大小为2的指数次
// io.netty.buffer.PoolArena#normalizeCapacity
int normalizeCapacity(int reqCapacity) {
    if (reqCapacity &amp;lt; 0) {
        throw new IllegalArgumentException(&quot;capacity: &quot; + reqCapacity + &quot; (expected: 0+)&quot;);
    }
    if (reqCapacity &amp;gt;= chunkSize) {
        return reqCapacity;
    }

    if (!isTiny(reqCapacity)) { // &amp;gt;= 512
        // Doubled
        // 如果申请的内存大于512则规范化为大于reqCapacity的最近的2的指数次的值
        int normalizedCapacity = reqCapacity;
        // 当normalizedCapacity本身就是2的指数次的时候，取其本身
        // 这个时候防止下面的算法再向后查找，先将normalizedCapacity-1
        normalizedCapacity --;
        normalizedCapacity |= normalizedCapacity &amp;gt;&amp;gt;&amp;gt;  1;
        normalizedCapacity |= normalizedCapacity &amp;gt;&amp;gt;&amp;gt;  2;
        normalizedCapacity |= normalizedCapacity &amp;gt;&amp;gt;&amp;gt;  4;
        normalizedCapacity |= normalizedCapacity &amp;gt;&amp;gt;&amp;gt;  8;
        normalizedCapacity |= normalizedCapacity &amp;gt;&amp;gt;&amp;gt; 16;
        normalizedCapacity ++;

        // 如果上面的计算结果溢出了(如果reqCapacity是Integer.MAX_VALUE)，则去掉最高位
        if (normalizedCapacity &amp;lt; 0) {
            normalizedCapacity &amp;gt;&amp;gt;&amp;gt;= 1;
        }

        return normalizedCapacity;
    }

    // 下面之所以是16的倍数是因为用来管理tiny内存tinySubpagePools数组的大小刚好是512&amp;gt;&amp;gt;&amp;gt;4，32个元素
    // 每个元素PoolSubpage本身会构成链表，也就是说每个元素（PoolSubpage）对应的链表内每个元素的内存块大小（elemSize）是相同的，数组内每个链表的elemSize依次是：
    // 16,32,48......480，496，512
    // Quantum-spaced
    // 刚好是16的倍数(这个时候reqCapacity&amp;lt;512)
    if ((reqCapacity &amp;amp; 15) == 0) {
        return reqCapacity;
    }
    // 找到距离reqCapacity最近的下一个16的倍数
    return (reqCapacity &amp;amp; ~15) + 16;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里解释下上面&lt;code&gt;if (!isTiny(reqCapacity))&lt;/code&gt;里面的位运算，由于要寻找的数是2的指数次，所以二进制表示除了最高位是1，后面的位都应该是0，假设寻找的是x // x-1的二进制所有位都是1，所以变成了寻找比x少一位的二进制全1的数&lt;/p&gt;
&lt;p&gt;normalizedCapacity二进制表示的第一位肯定是1，右移1位之后，第二位变为了1，两者进行逻辑或的时候，前两位一定是1同理&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继续右移2位之后，前4位肯定是1&lt;/li&gt;
&lt;li&gt;继续右移4位之后，前8位肯定是1&lt;/li&gt;
&lt;li&gt;继续右移8位之后，前16位肯定是1&lt;/li&gt;
&lt;li&gt;继续右移16位之后，前32位一定是1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样就找到了全是1的数，然后再加上1就是2的指数次。&lt;/p&gt;
&lt;p&gt;总结上面的代码逻辑，规范化的过程是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是huge，大于chunkSize直接返回reqCapacity&lt;/li&gt;
&lt;li&gt;如果是small或者normal，大于512，则规范化为大于reqCapacity的最近的2的指数次的值&lt;/li&gt;
&lt;li&gt;如果是tiny，小于512，则规范为16的倍数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面这个规范化的原因和每类内存申请的数据结构有密切的关系，我们这里先只关心normal类型的被规范化为2的指数次。&lt;/p&gt;
&lt;p&gt;下面接着看normal内存的申请&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.buffer.PoolArena#allocateNormal
private void allocateNormal(PooledByteBuf&amp;lt;T&amp;gt; buf, int reqCapacity, int normCapacity) {
    // 先从内存池中获取需要的内存
    if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||
        q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||
        q075.allocate(buf, reqCapacity, normCapacity)) {
        return;
    }

    // 如果从现有内存池中没有找到可用的内存，则重新申请一个chunk
    // Add a new chunk.
    PoolChunk&amp;lt;T&amp;gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);
    long handle = c.allocate(normCapacity);
    assert handle &amp;gt; 0;
    // 用申请的内存初始化buffer
    c.initBuf(buf, handle, reqCapacity);
    // 刚刚初始化的chunk放在init链表中
    qInit.add(c);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看下上面用到的几个数据结构&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 每个链表存放的是已经被分配过的chunk，不同使用率的chunk被存放在不同的链表中
// 初始情况链表都是空的，刚开始从init开始，依次向后寻找，找到合适范围的list，然后add
// qinit - q000 - q025 - q050 - q075 - q100 
// 注意qinit和q000之间是单向，也就是说qinit的chunk可以move到q000，但是q000的chunk不能再向前move了
// 使用率在50%-100%
private final PoolChunkList&amp;lt;T&amp;gt; q050;
// 使用率在25%-75%
private final PoolChunkList&amp;lt;T&amp;gt; q025;
// 使用率在1%-50%
private final PoolChunkList&amp;lt;T&amp;gt; q000;
// 使用率在0%-25%
private final PoolChunkList&amp;lt;T&amp;gt; qInit;
// 使用率在75%-100%
private final PoolChunkList&amp;lt;T&amp;gt; q075;
// 使用率100%
private final PoolChunkList&amp;lt;T&amp;gt; q100;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;allocateNormal一开始先从已经申请过的chunk中查找有无可用内存，上面几个链表查找的顺序是q050、q025、q000、qinit、q075，关于这个顺序问题可以参考网上的&lt;a href=&quot;https://www.jianshu.com/p/4856bd30dd56&quot;&gt;一篇文章&lt;/a&gt;。还有一个问题，既然有了q000，为什么需要qinit？前面这篇文章也有介绍，这结合我的理解再说下：&lt;/p&gt;
&lt;p&gt;首先qinit的内存使用率是0-25%，q000的内存使用率是1-50%，q000没有使用率是0的chunk；其次在构成链表的时候qinit.next = q000，但是q000.prev是null，如果是一个chunk的使用率变为0以后，调用io.netty.buffer.PoolChunkList#free方法来释放，由于当前使用率是0，而q000的最小使用率是1%，所以会执行下面代码的remove和move，将这个chunk移除出链表等待被回收。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.buffer.PoolChunkList#free
boolean free(PoolChunk&amp;lt;T&amp;gt; chunk, long handle) {
    chunk.free(handle);
    if (chunk.usage() &amp;lt; minUsage) {
        // 如果小于当前链表的最小利用率，将chunk从链表中移除
        remove(chunk);
        // Move the PoolChunk down the PoolChunkList linked-list.
        // 将chunk添加到当前链表的上一个链表，，如果是当前链表是q000，没有上一个，也就是这个chunk不能再被使用，等待被GC护回收内存
        return move0(chunk);
    }
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本数据结构说了，接下来看看具体的逻辑。allocateNormal一开始是调用的PoolChunkList#allocate&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.buffer.PoolChunkList#allocate
boolean allocate(PooledByteBuf&amp;lt;T&amp;gt; buf, int reqCapacity, int normCapacity) {
    if (head == null || normCapacity &amp;gt; maxCapacity) {
        // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can
        // be handled by the PoolChunks that are contained in this PoolChunkList.
        // 当前链表为空或者申请内存的大小大于当前链表的利用率直接返回false
        return false;
    }

    // 从链表头开始依次查找可用的内存
    for (PoolChunk&amp;lt;T&amp;gt; cur = head;;) {
        // 针对每个chunk申请内存，如果返回handle小于0表示没有符合条件的内存，继续查找下一个
        long handle = cur.allocate(normCapacity);
        if (handle &amp;lt; 0) {
            cur = cur.next;
            if (cur == null) {
                return false;
            }
        } else {
            // 如果找到可用的内存，用来初始化buffer
            cur.initBuf(buf, handle, reqCapacity);
            if (cur.usage() &amp;gt;= maxUsage) {
                // 如果当前chunk的利用率大于当前链表的最大利用率需要移动到下一个链表
                remove(cur);
                nextList.add(cur);
            }
            return true;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看看最终chunk是怎么分配内存的，下面这个方法其实就是计算出chunk中符合条件的内存的memoryMap数组中的index&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.buffer.PoolChunk#allocate
long allocate(int normCapacity) {
    if ((normCapacity &amp;amp; subpageOverflowMask) != 0) { // &amp;gt;= pageSize
        // 大于等于pageSize，8k
        return allocateRun(normCapacity);
    } else {
        // 小于pageSize
        return allocateSubpage(normCapacity);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个里面就根据申请内存的大小使用不同的分配策略，这里先看下大于pageSize的内存分配&lt;/p&gt;
&lt;h3 id=&quot;大于pagesize的内存申请&quot;&gt;大于pageSize的内存申请&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.buffer.PoolChunk#allocateRun
private long allocateRun(int normCapacity) {
    // 计算出所申请的内存位于树的哪一层
    // Integer.numberOfLeadingZeros(pageSize)表示pageSize二进制表示的时候，前面有多个0，也就是第一个1出现的位置
    // pageShift = Integer.SIZE - 1 - Integer.numberOfLeadingZeros(pageSize) = 13
    // pageShift就是pageSize的最高位相对于右边的位偏移
    int d = maxOrder - (log2(normCapacity) - pageShifts);
    // 在d层找到可用的内存并返回对应的memoryMap数组元素的index
    int id = allocateNode(d);
    if (id &amp;lt; 0) {
        // 如果小于0说明没有找到
        return id;
    }
    // 如果找到了则更新当前chunk可用内存大小
    freeBytes -= runLength(id);
    return id;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中d的含义：要申请内存位于memoryMap数的第几层（下面是第maxOrder层）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;maxOrder&lt;/code&gt;：表示memoryMap数总共有maxOrder层，从上到下依次是0,1,2,3,4,5,6,7,8,9,10,11，也即是默认12层&lt;/p&gt;
&lt;p&gt;&lt;code&gt;log2(normCapacity)&lt;/code&gt;：要申请内存大小二进制最高位相对于右边的偏移&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pageShift&lt;/code&gt;：pageSize二进制最高位相对于右边的偏移&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(log2(normCapacity) - pageShifts)&lt;/code&gt;：要申请内存的大小在树中的层数与最底层的层数（最底层的内存大小是pageSIze，8K）差，memoryMap树中，两层之间表示的内存是2倍关系，比如第10层是第11层的2倍，第11层是8k，那么第10层就是16k&lt;/p&gt;
&lt;p&gt;&lt;code&gt;maxOrder - (log2(normCapacity) - pageShifts)&lt;/code&gt;：表示要申请的内存大小位于数的哪一层&lt;/p&gt;
&lt;p&gt;举个例子，假如申请的内存是32k，log2(normalCapacity) = 15，32k距离8k中间隔了15-13=2层，所以要申请的内存位于第11-2=9层，验证一下，叶子节点内存大小是一个page8k，父节点16k，父节点的父节点是32k，所以申请的内存应该位于上一层的上一层，也就是第9层&lt;/p&gt;
&lt;p&gt;那么怎么从树中找到合适的内存呢，下面这个方法就是在指定的d层找到符合条件的内存，由于每个节点的值本来是该节点所在的深度depth，如果该节点的内存（包括子节点）已经被分配过，则会被标记为不可用，所以只要从根节点开始，依次向下查找，如果当前节点没有被分配则找左子节点，如果该节点已经被分配了则找当前节点的兄弟节点，直到找到第d层依然没有可用内存的时候，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* Algorithm to allocate an index in memoryMap when we query for a free node
* at depth d
*
* @param d depth 树的深度
* @return index in memoryMap
*/
// 在d层查找一个可用的节点，根据所在层数来查找盖层可用的内存的memoryMap的index
private int allocateNode(int d) {
    int id = 1;
    int initial = - (1 &amp;lt;&amp;lt; d); // has last d bits = 0 and rest all = 1
    byte val = value(id);
    if (val &amp;gt; d) { // unusable
        return -1;
    }
    // id &amp;lt; 2^d 的时候 id &amp;amp; initial = 0，也就是说d层所有的id&amp;amp;inital都是大于0的
    // 所以这两个条件就限定了寻找的节点在d层，并且可用free
    // 这里就是查找第d层的可用节点，为什么不直接从d层开始查找呢？
    while (val &amp;lt; d || (id &amp;amp; initial) == 0) { // id &amp;amp; initial == 1 &amp;lt;&amp;lt; d for all ids at depth d, for &amp;lt; d it is 0
        id &amp;lt;&amp;lt;= 1;
        val = value(id);
        // 如果该节点的子节点已经被分配过了，那么找兄弟节点
        if (val &amp;gt; d) {
            // id = id + 1
            id ^= 1;
            val = value(id);
        }
    }
    byte value = value(id);
    assert value == d &amp;amp;&amp;amp; (id &amp;amp; initial) == 1 &amp;lt;&amp;lt; d : String.format(&quot;val = %d, id &amp;amp; initial = %d, d = %d&quot;,
                                                                  value, id &amp;amp; initial, d);
    // 将当前内存标记为不可用，也就是将该节点的数组值更新maxOrder+1
    setValue(id, unusable); // mark as unusable
    updateParentsAlloc(id);
    return id;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面说过chunk的数据结构memoryMap，申请的内存的时候也是和这个数据结构密切相关，其实就是找到这棵树中可用内存的节点的index，然后更新memoryMap中内存的使用情况。&lt;/p&gt;
&lt;p&gt;再看一个问题：为什么不直接从d层开始查找呢，而是从根节点开始？&lt;/p&gt;
&lt;p&gt;为了更快的查找。如果直接从d层开始查找，需要的时间是最坏是2^d（要找的节点在最右侧），最好是1（要找的节点在最左侧），因为可能存在前面的节点已经被分配的情况。使用从上往下查找的时候，如果发现子节点被分配过了，就直接查找兄弟节点，时间是log&lt;sub&gt;2&lt;/sub&gt;d&lt;/p&gt;
&lt;p&gt;上面是大于等于pageSize的内存申请，接下来看看另外一种小于pageSize的内存申请&lt;/p&gt;
&lt;h3 id=&quot;小于pagesize的内存申请&quot;&gt;小于pageSize的内存申请&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.buffer.PoolChunk#allocateSubpage
private long allocateSubpage(int normCapacity) {
    // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.
    // This is need as we may add it back and so alter the linked-list structure.
    // 从tinySubpagePools或者smallSubpagePools中查找
    PoolSubpage&amp;lt;T&amp;gt; head = arena.findSubpagePoolHead(normCapacity);
    synchronized (head) {
        // 由于是小于pageSize的，所以直接在最后一层，也就是树的最底层查找，因为树的最底层的节点的内存大小事pageSize
        int d = maxOrder; // subpages are only be allocated from pages i.e., leaves
        int id = allocateNode(d);
        if (id &amp;lt; 0) {
            return id;
        }

        final PoolSubpage&amp;lt;T&amp;gt;[] subpages = this.subpages;
        final int pageSize = this.pageSize;
        // 更新当前chunk的剩余内存大小，本次申请的是一个page，所以减去pageSize
        freeBytes -= pageSize;
        // memoryIdx - 2048就是page的index
        int subpageIdx = subpageIdx(id);
        PoolSubpage&amp;lt;T&amp;gt; subpage = subpages[subpageIdx];
        if (subpage == null) {
            // 该page尚未初始化过，第一次初始化
            // 初始化的过程会将subpage放到链表头
            subpage = new PoolSubpage&amp;lt;T&amp;gt;(head, this, id, runOffset(id), pageSize, normCapacity);
            subpages[subpageIdx] = subpage;
        } else {
            // 重新init
            subpage.init(head, normCapacity);
        }
        // 返回的是申请到内存的handle，包含了bitmap和memoryMapIdx信息
        return subpage.allocate();
    }
}

/**
* Returns the bitmap index of the subpage allocation.
* 返回的是申请到的可用内存块在bitmap数组中对应bit的index
*/
long allocate() {
    if (elemSize == 0) {
        return toHandle(0);
    }

    if (numAvail == 0 || !doNotDestroy) {
        return -1;
    }

    // 获取下一个可用内存块的位置
    final int bitmapIdx = getNextAvail();
    // 右移6位，得到的是该bit对应bitmap数组中的下标
    int q = bitmapIdx &amp;gt;&amp;gt;&amp;gt; 6;
    // 逻辑与63，得到的是该bit在long型数据中的第几个bit
    int r = bitmapIdx &amp;amp; 63;
    assert (bitmap[q] &amp;gt;&amp;gt;&amp;gt; r &amp;amp; 1) == 0;
    // 将该bit置为已使用
    bitmap[q] |= 1L &amp;lt;&amp;lt; r;
    // 将可用的内存块总数减1
    if (-- numAvail == 0) {
        removeFromPool();
    }

    return toHandle(bitmapIdx);
}

private long toHandle(int bitmapIdx) {
    // 2^62，高位是bitmapIdx，低位是memoryMapIdx
    return 0x4000000000000000L | (long) bitmapIdx &amp;lt;&amp;lt; 32 | memoryMapIdx;
}

private int getNextAvail() {
    int nextAvail = this.nextAvail;
    if (nextAvail &amp;gt;= 0) {
        this.nextAvail = -1;
        return nextAvail;
    }
    return findNextAvail();
}

private int findNextAvail() {
    final long[] bitmap = this.bitmap;
    final int bitmapLength = this.bitmapLength;
    // 从实际使用到的标志位bitmapLength中查找
    for (int i = 0; i &amp;lt; bitmapLength; i ++) {
        long bits = bitmap[i];
        // bits不全为1，表示有空余
        if (~bits != 0) {
            return findNextAvail0(i, bits);
        }
    }
    return -1;
}

private int findNextAvail0(int i, long bits) {
    final int maxNumElems = this.maxNumElems;
    // i为数组的下标，表示第i个long数
    final int baseVal = i &amp;lt;&amp;lt; 6;
    // 判断long的每一位是否时可用的
    for (int j = 0; j &amp;lt; 64; j ++) {
        if ((bits &amp;amp; 1) == 0) {
            // 找到可用的后，记录可用内存块对应于bitmap中的index，j为该long数据的第j位
            int val = baseVal | j;
            if (val &amp;lt; maxNumElems) {
                return val;
            } else {
                break;
            }
        }
        // 查找下一位
        bits &amp;gt;&amp;gt;&amp;gt;= 1;
    }
    return -1;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先是从内存池中获取内存，PoolArena维护了以下两个数组，arena.findSubpagePoolHead就是从以下两个数组中查找可用的chunk的head，接下来就是从找到的chunk中查找可用内存，类似上面大于8k申请的查找方式，实际上是调用的同一个方法：io.netty.buffer.PoolChunk#allocateNode&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// small内存池，数组大小是log2(pageSize&amp;gt;&amp;gt;&amp;gt;10)，默认就是4，所以数组index的计算方式也是这样log2(reqCapacity&amp;gt;&amp;gt;&amp;gt;10)
// 每个元素保存的是一个PoolSubpage链表，一个PoolSubpage链表里面的subpage都是相同的块大小(8k分成小童的份数)
// 每个元素的elemSize依次是：1k,2k,4k,8k
private final PoolSubpage&amp;lt;T&amp;gt;[] smallSubpagePools
// tiny内存池，数组大小是512 &amp;gt;&amp;gt;&amp;gt; 4，也就是32，数组index的计算方式也就是一样：reqCapacity除以16
// 每个元素的elemSize依次是：16,32,48......480，496，512，每个PoolSubpage又是一个链表，该链表上的elemSize相同
private final PoolSubpage&amp;lt;T&amp;gt;[] tinySubpagePools;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里也可以看出之前将申请内存的大小规范化的目的了，也能理解为什么tiny规范化为16的倍数，而small规范化为2的指数次。因为&lt;/p&gt;
&lt;p&gt;small的内存范围是：8192 &amp;gt; size &amp;gt; 512，大于512并且是2的指数次，正好是1k、2k、4k、8k&lt;/p&gt;
&lt;p&gt;tiny的内存范围是：size &amp;lt;= 512，16的倍数正好是16、32、48...&lt;/p&gt;
&lt;h3 id=&quot;init-buffer&quot;&gt;init buffer&lt;/h3&gt;
&lt;p&gt;上面一系列的方法都是计算出可用内存在memoryMap数组中的index，接下来看看怎么使用这个index初始化buffer&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.buffer.PoolChunk#initBuf
// 找到chunk信息后调用这个方法初始化buf，用分配好的内存初始化buf
void initBuf(PooledByteBuf&amp;lt;T&amp;gt; buf, long handle, int reqCapacity) {
    int memoryMapIdx = memoryMapIdx(handle);
    int bitmapIdx = bitmapIdx(handle);
    // 如果分配的内存大于一个page，不需要使用bitmapIdx，这个时候bitmapIdx为0
    if (bitmapIdx == 0) {
        byte val = value(memoryMapIdx);
        assert val == unusable : String.valueOf(val);
        buf.init(this, handle, runOffset(memoryMapIdx), reqCapacity, runLength(memoryMapIdx),
                 arena.parent.threadCache());
    } else {
        initBufWithSubpage(buf, handle, bitmapIdx, reqCapacity);
    }
}

// io.netty.buffer.PoolChunk#initBufWithSubpage(io.netty.buffer.PooledByteBuf&amp;lt;T&amp;gt;, long, int, int)
// 使用PoolSubpage初始化buf
// handle构成：2^62 | long(bitmapIdx) &amp;lt;&amp;lt; 32 | memoryMapIdx
private void initBufWithSubpage(PooledByteBuf&amp;lt;T&amp;gt; buf, long handle, int bitmapIdx, int reqCapacity) {
    assert bitmapIdx != 0;
    // memoryMapIdx方法是直接将handler强转为int，也就是截去了高32位，低32位就是memoryMapIdx
    int memoryMapIdx = memoryMapIdx(handle);

    PoolSubpage&amp;lt;T&amp;gt; subpage = subpages[subpageIdx(memoryMapIdx)];
    assert subpage.doNotDestroy;
    assert reqCapacity &amp;lt;= subpage.elemSize;
    // 0x3FFFFFFF是2^31-1，此刻的bitmapIdx是2^30 | bitmapIdx
    // 所以bitmapIdx &amp;amp; 0x3FFFFFFF得到的就是原始的bitmapIdx
    buf.init(
        this, handle,
        runOffset(memoryMapIdx) + (bitmapIdx &amp;amp; 0x3FFFFFFF) * subpage.elemSize, reqCapacity, subpage.elemSize,
        arena.parent.threadCache());
}

// 根据memoryIdx获取对应的subpage的序号，memoryIdx一定是位于2048-4097之间才能使用此方法
private int subpageIdx(int memoryMapIdx) {
    // memoryIdx位于2048-4097之间，和2048即2^11进行异或运算，相当于memoryIdx-2048
    return memoryMapIdx ^ maxSubpageAllocs; // remove highest set bit, to get offset
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面根据不同的handle使用不同的初始化buffer的策略&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;大于pageSize返回的handle，是一个memoryMap数组的下标&lt;/li&gt;
&lt;li&gt;小于pageSize返回的是handle，包含了bitmap和memoryMapIdx数组元素的下标信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里再说下bitmap是什么意思，由于一个PoolSubpage的大小默认是8k，如果要分割成更小的内存块需要使用一个标记来记录这个page划分成的内存块哪些已经使用，那些是可用的，io.netty.buffer.PoolSubpage#bitmap就是这个作用，PoolSubpage中相关的字段有&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 记录subpage分割后的内存块的使用情况，一个bit对应一个内存块
private final long[] bitmap;

PoolSubpage&amp;lt;T&amp;gt; prev;
PoolSubpage&amp;lt;T&amp;gt; next;

boolean doNotDestroy;
// 内存块的大小
int elemSize;
// 划分后的内存块的大小
private int maxNumElems;
// 实际使用到的bitmap数组的长度
private int bitmapLength;
// 下一个可用的内存块的位置
private int nextAvail;
private int numAvail;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;allocateNormal终于申请到了内存，也初始化了buffer，但是这个方法不仅包含了分配normal内存的方法也包含了tiny和small内存的分配方法。&lt;/p&gt;
&lt;h2 id=&quot;tiny内存分配&quot;&gt;tiny内存分配&lt;/h2&gt;
&lt;p&gt;tiny内存分配流程：&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果申请的是tiny类型，会先从tiny缓存中尝试分配，如果缓存分配成功则返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;否则从tinySubpagePools中尝试分配&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果上面没有分配成功则使用allocateNormal进行分配&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;从缓存中分配&quot;&gt;从缓存中分配&lt;/h3&gt;
&lt;p&gt;这里以启用了缓存为例来说明，使用到的缓存类是PoolThreadCache，缓存是通过队列实现的，一个队列中存储的内存大小都是相同的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.buffer.PoolArena#allocate(io.netty.buffer.PoolThreadCache, io.netty.buffer.PooledByteBuf&amp;lt;T&amp;gt;, int)
// 这里的cache是PoolThreadCache
if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) {
    // was able to allocate out of the cache so move on
    return;
}

boolean allocateTiny(PoolArena&amp;lt;?&amp;gt; area, PooledByteBuf&amp;lt;?&amp;gt; buf, int reqCapacity, int normCapacity) {
    // 缓存维护了一个队列，这个队列中存储的内存块大小都相同
    // 找到缓存之后，从队列中取出一个内存块用来初始化buffer
    return allocate(cacheForTiny(area, normCapacity), buf, reqCapacity);
}

// 查找缓存数组中缓存的内存
private MemoryRegionCache&amp;lt;?&amp;gt; cacheForTiny(PoolArena&amp;lt;?&amp;gt; area, int normCapacity) {
    // 计算出申请内存位于缓存数组中的位置，即数组下标
    int idx = PoolArena.tinyIdx(normCapacity);
    if (area.isDirect()) {
        // 使用直接内存的缓存
        return cache(tinySubPageDirectCaches, idx);
    }
    // 使用堆内存的缓存
    return cache(tinySubPageHeapCaches, idx);
}

static int tinyIdx(int normCapacity) {
    // 由于tiny缓存数组大小是32，依次对应的内存大小是16、32...，512，所以数组的下标应该是申请内存的大小除以16
    // normCapacity = normCapacity / 16
    return normCapacity &amp;gt;&amp;gt;&amp;gt; 4;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从缓存中分配内存的过程&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;寻找缓存tinySubPageDirectCaches&lt;/li&gt;
&lt;li&gt;使用缓存中的chunk初始化buf&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于tiny缓存的数据结构&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// tiny缓存
// 是一个SubPageMemoryRegionCache数组，默认缓存数组长度：32，依次存储的内存大小是16、32、48...，512
io.netty.buffer.PoolThreadCache#tinySubPageHeapCaches

// 初始化tiny缓存数组，数组大小是32
// static final int numTinySubpagePools = 512 &amp;gt;&amp;gt;&amp;gt; 4;
tinySubPageHeapCaches = createSubPageCaches(
                    tinyCacheSize, PoolArena.numTinySubpagePools, SizeClass.Tiny);


// 初始化tiny和small缓存数组
private static &amp;lt;T&amp;gt; MemoryRegionCache&amp;lt;T&amp;gt;[] createSubPageCaches(
    int cacheSize, int numCaches, SizeClass sizeClass) {
    if (cacheSize &amp;gt; 0) {
        @SuppressWarnings(&quot;unchecked&quot;)
        MemoryRegionCache&amp;lt;T&amp;gt;[] cache = new MemoryRegionCache[numCaches];
        for (int i = 0; i &amp;lt; cache.length; i++) {
            // TODO: maybe use cacheSize / cache.length
            cache[i] = new SubPageMemoryRegionCache&amp;lt;T&amp;gt;(cacheSize, sizeClass);
        }
        return cache;
    } else {
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缓存使用队列实现，一个队列最大元素个数&lt;/p&gt;
&lt;p&gt;DEFAULT_TINY_CACHE_SIZE = SystemPropertyUtil.getInt(&quot;io.netty.allocator.tinyCacheSize&quot;, 512);&lt;/p&gt;
&lt;h3 id=&quot;从tinysubpagepools中分配&quot;&gt;从tinySubpagePools中分配&lt;/h3&gt;
&lt;p&gt;上面缓存中如果没有分配到内存的话，会向内存池tinySubpagePools申请，主要逻辑是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;计算tinySubpagePools数组的index，右移4，除以16（该数组长度是512&amp;gt;&amp;gt;&amp;gt;4）&lt;/li&gt;
&lt;li&gt;取出index出的subpage，也就是这个index处head&lt;/li&gt;
&lt;li&gt;从head.next查找合适的内存&lt;/li&gt;
&lt;li&gt;找到可用内存后使用io.netty.buffer.PoolChunk#initBufWithSubpage(io.netty.buffer.PooledByteBuf&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;前面已经介绍过tinySubpagePools，是一个数组，数组大小是32，每个元素是一个PoolSubpage，PoolSubpage本身是一个链表，所以要在这个里面查找可用内存，先要计算出数组下表，然后找到该位置的PoolSubpage，取出这个链表的头，然后分配内存。关键代码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.buffer.PoolArena#allocate(io.netty.buffer.PoolThreadCache, io.netty.buffer.PooledByteBuf&amp;lt;T&amp;gt;, int)
private void allocate(PoolThreadCache cache, PooledByteBuf&amp;lt;T&amp;gt; buf, final int reqCapacity) {
    final int normCapacity = normalizeCapacity(reqCapacity);
    if (isTinyOrSmall(normCapacity)) { // capacity &amp;lt; pageSize
        int tableIdx;
        PoolSubpage&amp;lt;T&amp;gt;[] table;
        boolean tiny = isTiny(normCapacity);
        if (tiny) { // &amp;lt; 512
            // 省略中间代码...
            tableIdx = tinyIdx(normCapacity);
            table = tinySubpagePools;
        } else {
            // 省略中间代码...
        }

        final PoolSubpage&amp;lt;T&amp;gt; head = table[tableIdx];

        /**
             * Synchronize on the head. This is needed as {@link PoolChunk#allocateSubpage(int)} and
             * {@link PoolChunk#free(long)} may modify the doubly linked list as well.
             */
        synchronized (head) {
            final PoolSubpage&amp;lt;T&amp;gt; s = head.next;
            if (s != head) {
                assert s.doNotDestroy &amp;amp;&amp;amp; s.elemSize == normCapacity;
                long handle = s.allocate();
                assert handle &amp;gt;= 0;
                s.chunk.initBufWithSubpage(buf, handle, reqCapacity);
                incTinySmallAllocation(tiny);
                return;
            }
        }
        // 省略中间代码... 
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 26 Jul 2018 15:50:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/9375157.html</dc:identifier>
</item>
<item>
<title>CUBA Platform —— 开源的、可靠的企业级应用开发利器 - CUBA-China</title>
<link>http://www.cnblogs.com/cubacn/p/cubaplatform1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cubacn/p/cubaplatform1.html</guid>
<description>&lt;p class=&quot;MsoTitle&quot; align=&quot;right&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;原文：&lt;/span&gt;&lt;a href=&quot;https://dzone.com/articles/cuba-platform-an-open-source-java-framework-for-ra&quot;&gt;CUBA Platform: An Open-Source Java Framework for Rapid Application Development&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;翻译：CUBA China                                                         &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;CUBA-Platform 官方网站 : &lt;a href=&quot;https://www.cuba-platform.com/&quot;&gt;https://www.cuba-platform.com&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;CUBA China 官方网站 : &lt;a href=&quot;http://cuba-platform.cn/&quot;&gt;&lt;span&gt;http://cuba-platform.cn&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;欢迎转载，转载请注明来源： https://www.cnblogs.com/cubacn/p/cubaplatform1.html。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;　　CUBA China是由多名具有丰富的行业软件、工具软件开发经验的开发人员组成的团队，我们出于对CUBA-Platform开发技术的共同爱好而成立， 我们的初衷是建立一个社区、与更多的行业软件开发人员一起交流关于CUBA-Platform及企业级应用的开始技术、架构经验等。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　作为企业软件开发行业的“老兵”，我们经历过众多的开发框架，包括国内的、国外的，我们每个人对于所使用过的框架都持有种种不满意，但CUBA-Platform的整体表现让我们印象深刻，她具有深厚的技术沉淀（GITHUB上自2009年起有代码提交）、源自实践的设计、丰富的文档、开放的姿态、先进的技术栈、完备的企业软件基础功能、高度可定制的系统架构、开发工具加持等等，所有这些让我们认为她是一个值得投入的框架。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　独乐乐不如众乐乐，所以我们计划&lt;/em&gt;&lt;/span&gt;&lt;em&gt;构建并维护一个中国地区CUBA-Platform的社区，为国内的企业应用开发人员提供关于CUBA-Platform及企业级应用的技术交流、讨论的平台。。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　这篇文章是我们介绍CUBA-Platform的第一篇文章，后续我们会持续推出一系列翻译或原创文章。 如果您希望进一步了解CUBA-Platform并及时获得最新的技术文章，请扫描文章右侧或下方的二维码关注我们的公众号。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　本文&lt;/span&gt;&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;CUBA&lt;/span&gt;&lt;span&gt;-Platform&lt;/span&gt;&lt;span&gt;简介&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;span&gt;一个&lt;/span&gt;&lt;/span&gt;&lt;span&gt;结合&lt;/span&gt;&lt;span&gt;&lt;span&gt;了可靠架构&lt;/span&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;span&gt;企业&lt;/span&gt;&lt;/span&gt;&lt;span&gt;级&lt;/span&gt;&lt;span&gt;&lt;span&gt;应用程序&lt;/span&gt;“&lt;span&gt;必备&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;功能和应用程序快速开发工具的开源框架。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       从进入计算机时代起，企业应用软件开发一直面临一个挑战：虽然企业应用开发的目的是解决实际业务问题，但事实上开发人员必须花费大量时间和精力在纯技术层面，比如软件架构和一些很通用的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       为了解决上述技术与业务之间的不对等精力消耗，涌现了很多开发框架，目的都是为了提高抽象级别，将开发人员从低级繁杂的工作中解放出来。随着时间的推移，这些开发工具越来越智能，使得开发效率越来越高。Borland Delphi就是21世纪初最成功的例子之一，它能使开发产出大幅提升。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       过去的十年以来， 企业级应用软件的需求越来越多、系统越来越庞大、功能越来越复杂、技术更新迭代不断，促生了对新一代高效框架和开发工具的需求。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       在这篇文章里我们要介绍&lt;a href=&quot;https://www.cuba-platform.com/&quot;&gt;CUBA-Platform &lt;/a&gt;&lt;span&gt; &lt;/span&gt;：一个结合了可靠架构、企业级应用程序必备功能和快速应用程序开发工具的开源框架，它有助于大幅提高研发团队的开发效率、提高交付质量。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       CUBA平台与其他大多数Java框架最大的区别是：它的抽象级别更高，开发人员可以只专注于解决业务问题。它把稍高但是又有些偏“底层”的技术细节（如Vaadin，Spring和EclipseLink）也封装起来，并自带丰富的应用功能和开发工具，因此开发人员可以最大限度地专注于业务实现 。同时，CUBA并不限制对底层代码的访问，这样可以保证框架可以适应具体项目的需求。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;       CUBA平台能为开发企业应用程序带来巨大价值：复杂的数据模型、数十或数百个页面、各式各样的业务流程、系统的健壮性安全性等等。&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       CUBA应用程序具有标准的三层体系架构。连接各层的纽带是元数据 – 就是我们所知的数据模型。它使所有可视组件都具有数据感知能力。比如，表格可以知道自己所展示实体的属性、标签知道自己在显示日期。类似地，元数据有助于可视组件通过ORM与数据层进行通信，ORM用来定义对象的关系图，决定是否需要加载或者更新数据。安全子系统、报表生成器和平台的其他组件也有同样的机制。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前端界面&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;(&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;V&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;a&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;adin&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       CUBA-Platform使用Vaadin作为默认的前端界面框架，并提供声明式的界面开发模型，用户可以在可视化设计器或XML中定义页面布局。CUBA框架内置70多种Vaadin可视化组件供选择，比如各类按钮、表格组件、树组件、表单字段、 地图组件、动态图表、透视表等等，涵盖企业应用界面需要的一切组件。界面定义完成后，在Java控制器中添加组件的初始化逻辑和事件处理逻辑。基于组件的数据感知功能，用户可以非常快速地创建专业的企业应用页面。业务逻辑代码和页面布局代码分离，系统更易于维护。如果各式各样可视化组件还是不能满足用户需求，CUBA也可以灵活的集成外部JavaScript库、GWT或Vaadin组件。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201807/1438872-20180720195213437-249964437.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;[WEB前端界面示例]&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;端界面&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;(&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;Polymer&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       Google Polymer是CUBA-Platform的另一个可选的前端界面技术，通过Restful API与CUBA项目服务端进行通讯。Google Polymer客户端界面一般用于功能操作较少，但界面要求更灵活、可提供移动优先的响应式WEB界面。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201807/1438872-20180720195302569-1708650987.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Polymer&lt;/span&gt;&lt;span&gt;界面示例]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;过滤器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;        CUBA用户界面的一个重要功能：过滤器 – 这个组件能够让用户自定义搜索条件，并且开发起来很简单：开发人员只需将它放到一个显示实体列表的页面就万事大吉了。用户或管理员可以根据各自的需求定义各自的搜索条件。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       过滤器得益于CUBA元数据驱动的开发理念，过滤器能感知到自己绑定的实体，通过元数据，过滤器可准确地展示出表格可过滤的字段、限制关键字的值类型、提供备选值列表等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201807/1438872-20180720195328549-1881064612.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;[添加过滤字段]&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201807/1438872-20180720195337481-701956006.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;[过滤器界面]&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;安全控制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       访问控制对于企业级应用来说至关重要，在CUBA项目中所有的用户操作均由安全子系统控制。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       CUBA支持实体级别、行级别、实体属性级别（列级别）的数据读写控制；功能界面功能也可以基于角色开放或拒绝；也可以对界面上的组件进行基于角色的权限控制。行级别的安全机制用来控制用户只能对实体的某些数据记录（行）的访问 - 例如，某部门的用户只能看到该部门用户创建的文档。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       所有权限设置都可以在运行时通过界面进行配置，所有更改都可以由系统管理员线上操作。当然，所有数据的更改历史都有记录，谁在何时更改了什么 -出现问题时溯源以及汇报都很方便！&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;内置基础的WEB安全设施&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       CUBA-Platform作为一个框架，整合了最佳安全实践，可自动对WEB应用程序中的大部分常见漏洞提供防护。比如跨站脚本（XSS）攻击、跨站请求伪造攻击（CSRF）、SQL注入攻击等。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;用户&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;管理&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       用户管理模块包含了用户管理、角色管理、访问组管理等界面，通过用户管理模块可在运行时对系统用户、角色、访问组进行增、删、改的维护；可对用户的权限进行管理。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;管理&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;员&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;工具&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       CUBA-Platform内置了多个管理员实用工具，这些有助于系统管理员了解系统的运行情况、快速查找定位系统问题、自动执行重复性的管理任务等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;       日志查看&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;功能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       通过日志查看功能，系统管理员不必登录服务器，直接登录系统来查看各种日志，比如服务器日志、实体日志、session日志等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;       实体&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;(Entity)探查&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;         CUBA-Platform可在运行时分析实体定义、动态生成实体数据浏览界面、数据编辑界面，管理员可通过实体探查功能查看、维护系统数据。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;       性能&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;统计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       通过性能统计功能，管理员可 全面了解系统运行的数据，比如系统运行时间、内存占用数据、CPU占用数据、数据库连接数据、客户端请求数据等。这些数据可为管理员优化系统配置、硬件配置、排查问题提供依据。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;       定时任务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       通过定时任务，管理员可配置任意需要周期性或定时执行的任务，比如定时清理磁盘空间、定时发送系统状态通知等。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;       数据恢复&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       CUBA-Platform支持数据软删除，实体删除执行了删除操作后并不被物理删除，只是给数据添加了删除标记。如果发生了数据误删，管理可通过数据恢复功能恢复删除的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;       Session查看&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       通过用户会话功能，管理员可查看所有在线的用户，并可对用户会话进行管理。比如发送消息给用户、注销用户登录等。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多语言和多时区支持&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       CUBA-Platform提供了标准化多语言开发规范，可以使业务系统很方便地支持多国语言，这点对于开发国际性的业务系统很有帮助。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;通用REST API&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       通过CBUA-Platform，可很容易地实现REST API。方便外部系统与CUBA开发的业务系统进行集成，外部系统可以通过REST API调用基于CUBA的业务系统的中间件服务、访问领域实体数据。交互的数据格式支持JSON和XML。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;报&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;表&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;管理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       报表模块可以帮助开发人员快速生成各种类型的统计报表，并支持以多种格式输出。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;工作流模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       CUBA Platform的BPM模块基于Activiti，提供流程设计、执行和管理业务流程的工具，支持BPMN 2.0标准。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;全文&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;检索&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       CUBA-Platform的全文搜索（FTS）功能对实体属性和上传的文件内容进行索引，提供非结构化搜索。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       在程序部署和软件运行环境方面，可选项很多。CUBA应用程序有多种部署配置方案，可以在单个服务器运行所有程序，或者采用单独中间件（后台服务程序）加Web集群的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       平台开箱支持的数据库有：PostgreSQL，Oracle，Microsoft SQL Server，MySQL和HSQL（通常用于原型设计），随着项目的发展，用户也可以轻松地切换数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       WEB应用方面， CUBA应用程序可以部署到任何Java EE Web 服务器（例如Jetty，Tomcat，Glassfish或Websphere）。当然，用户也可以把应用编成Docker镜像，也可以在流行的PaaS云中部署，比如CloudFoundry，OpenShift或Jelastic。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       使用CUBA 平台开发应用程序，你只需要懂得Java SE，XML和JPQL – 你的应用程序代码会更统一更易于维护。你的开发团队也更加灵活 – 你并不需要专门的Web开发人员或Java EE专家团队。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201807/1438872-20180720203158992-1209072776.png&quot; alt=&quot;&quot;/&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;用户可以自己选择IDE开发业务逻辑，比如IntelliJ IDEA或Eclipse。CUBA也提供了CUBA应用的集成开环境：CUBA Studio – 一个辅助开发的可视化工具，CUBA有关的任务都可以通过它自动完成：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　· &lt;/span&gt;&lt;span&gt;配置项目基础信息可视化设计&lt;/span&gt;&lt;span&gt;UI和数据模型&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　· &lt;/span&gt;&lt;span&gt;带有&lt;/span&gt;&lt;span&gt;多种布局选项&lt;/span&gt;&lt;span&gt;的增删查改脚手架页面&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　· &lt;/span&gt;&lt;span&gt;自动生成和运行&lt;/span&gt;&lt;span&gt;数据库脚本&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　· &lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;监听处理器（handlers）和接口创建&lt;/span&gt;&lt;span&gt;脚手架&lt;/span&gt;&lt;span&gt;代码&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;         Studio与IDE之间的所有改动都是同步的，用户可以完全自由地选择在哪里进行更改。为了进一步提高开发人员的效率，Studio会自动热部署除数据模型之外的所有代码。因此，Studio大大避免了例行工作和编写样板代码的工作量，而且还不限制用户对编码工具的选择。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       如果用户考虑将旧系统升级到流行的技术栈，CUBA也有解决方案。Studio自带的迁移工具可以将旧数据库转换为符合CUBA平台的数据库，并根据数据模型自动生成页面，用户只需要添加自定义页面和迁移业务逻辑代码。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       如标题所述，核心框架（CUBA Framework）是开源的，是Apache 2.0许可， 源码都在GitHub上。所以对用户在CUBA上开发的软件没有许可限制。您可以免费使用IDEA或Eclipse基于CUBA Framework进行业务系统的开发。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       如果您想加快开发过程或者团队中有一些初级开发人员，那么您可以使用CUBA Studio来帮助提升开发效率。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;       CUBA-Platform是一个基础设施可靠、通用功能完善的开发框架，一篇文章不足以概括她的方方面面。希望本文可以让您对&lt;a href=&quot;https://www.cuba-platform.com/&quot;&gt;CUBA平台&lt;/a&gt;有一个初步的了解并且决定亲自试一试。接下来您可以：&lt;a href=&quot;https://www.cuba-platform.com/download&quot;&gt;下载免费的Studio&lt;/a&gt;，根据&lt;a href=&quot;http://t.cn/Rgphjz7&quot;&gt;快速入门指南，&lt;/a&gt;在几分钟内运行您的第一个CUBA应用程序！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;您也可以访问我们的&lt;a href=&quot;http://discuss.cuba-platform.cn/&quot;&gt;论坛&lt;/a&gt;，通过讨论提交您的问题、想法&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;CUBA-Platform 官方网站 : &lt;a href=&quot;https://www.cuba-platform.com/&quot;&gt;https://www.cuba-platform.com&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; CUBA China 官方网站 : &lt;a href=&quot;http://cuba-platform.cn/&quot;&gt;http://cuba-platform.cn&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1438872/201807/1438872-20180726232149431-852240571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 26 Jul 2018 15:37:00 +0000</pubDate>
<dc:creator>CUBA-China</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cubacn/p/cubaplatform1.html</dc:identifier>
</item>
<item>
<title>【JDK源码分析】深入源码分析CountDownLatch - 还是搬砖踏实</title>
<link>http://www.cnblogs.com/d-homme/p/9375105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/d-homme/p/9375105.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-3&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;33.886925795053&quot;&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;CountDownLatch是一个闭锁实现，它可以使一个或者多个线程等待一组事件发生。它包含一个计数器，用来表示需要等待的事件数量，coutDown方法用于表示一个事件发生，计数器随之递减，而await方法等待计数器为0之前一直阻塞。它是基于AQS的共享锁来实现的，其中使用了较多的AQS的方法，所以在这之前最好阅读过AQS的源码，不嫌弃也可以查看本人之前&lt;a href=&quot;https://www.cnblogs.com/d-homme/p/9357006.html&quot; target=&quot;_blank&quot;&gt;AQS的源码分析&lt;/a&gt;，有些AQS方法没有在之前分析过的这里涉及到了会进行分析。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-4&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32&quot;&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;我们先看它的属性和构造器，&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-5&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sync为其内部类&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Sync sync;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唯一的一个构造器
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造参数count就是需要等待事件的数量&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CountDownLatch(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了保证count &amp;gt;= 0&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (count &amp;lt; 0) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;count &amp;lt; 0&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造sync&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.sync = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sync(count);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在来看内部类Sync，它继承了AQS，实现了共享锁方法，下面来看其源码，代码行数不多很好理解&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-6&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;33.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Sync &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 4982264981922014374L&lt;span&gt;;

        Sync(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; setState 为AQS更改其state变量的方法
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将AQS state变量设置成count&lt;/span&gt;
&lt;span&gt;            setState(count);
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; AQS的获取state锁状态值&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getState();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试获取共享锁&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回1表示此时锁状态值为0表示锁已释放
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1表示此时锁状态值大于0，表示出于锁定状态&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; (getState() == 0) ? 1 : -1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试释放共享锁（计数器递减releases次）&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryReleaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Decrement count; signal when transition to zero
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待锁状态值为0或者更改锁状态值成功&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将state赋值给变量c&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时锁已清除&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递减&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; nextc = c-1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比较state的状态值是否等于C,等于将state状态值改为nextc&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetState(c, nextc))
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更改成功后，如果nextc为0则返回true&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; nextc == 0&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-7&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32&quot;&gt;
&lt;h4 id=&quot;await方法&quot;&gt;await方法&lt;/h4&gt;
&lt;p&gt;await方法就是当state状态值不为0时将当前线程阻塞，然后等待唤醒&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-8&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;33.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; await() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用的AQS获取共享锁可中断方法&lt;/span&gt;
        sync.acquireSharedInterruptibly(1&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们来看看AQS的acquireSharedInterruptibly方法&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-9&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;34.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted())
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此方法调用的是CountDownLatch内部类Sync的方法
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果锁状态不为0，则执行doAcquireSharedInterruptibly方法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; 0&lt;span&gt;)
            doAcquireSharedInterruptibly(arg);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;doAcquireSharedInterruptibly方法也是由AQS实现的&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-10&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;35.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doAcquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加一个共享锁节点到队列&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Node node =&lt;span&gt; addWaiter(Node.SHARED);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直到线程被唤醒或者线程被中断时跳出循环&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; node节点的前驱节点&lt;/span&gt;
                &lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; head) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用CountDownLatch内部类Sync的方法
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果锁状态值为0，则返回值大于0&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; tryAcquireShared(arg);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r &amp;gt;= 0&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当锁状态值为0，开始将note节点设置为头节点并唤醒后继节点
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是队列不断的出列，然后唤醒后继节点，后继节点被唤醒后由于前驱节点被设置成头节点，又会调用该方法进行后继节点的唤醒&lt;/span&gt;
&lt;span&gt;                        setHeadAndPropagate(node, r);
                        p.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
                        failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }

                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 shouldParkAfterFailedAcquire用于清除已中断/或者取消的线程以及判断此次循环是否需要挂起线程
                 parkAndCheckInterrupt 挂机当前线程
                 shouldParkAfterFailedAcquire 和 parkAndCheckInterrupt 在AQS之前博文里分析过这里就不再分析了
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt;
                    parkAndCheckInterrupt())
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示当前线程中断，取消获取锁
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 之前分析过，略过源码分析&lt;/span&gt;
&lt;span&gt;                cancelAcquire(node);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;setHeadAndPropagate方法，主要作用是唤醒后继节点线程&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-11&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setHeadAndPropagate(Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; propagate) {
        Node h &lt;/span&gt;=&lt;span&gt; head; 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前节点设置为头节点，节点关联的线程设置为空&lt;/span&gt;
&lt;span&gt;        setHead(node)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (propagate &amp;gt; 0 || h == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0 ||&lt;span&gt;
            (h &lt;/span&gt;= head) == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0&lt;span&gt;) {
            Node s &lt;/span&gt;=&lt;span&gt; node.next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; s.isShared())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点等待状态为signal时，唤醒后继节点线程&lt;/span&gt;
&lt;span&gt;                doReleaseShared();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;doReleaseShared很巧妙，当当前节点等待状态为signal时，唤醒后继节点线程&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doReleaseShared() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            Node h &lt;/span&gt;=&lt;span&gt; head;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h !=&lt;span&gt; tail) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; h.waitStatus;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程等待状态为signal时表示后继节点需要唤醒&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!compareAndSetWaitStatus(h, Node.SIGNAL, 0&lt;span&gt;))
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示h节点的状态替换失败，会再次循环判断h节点的状态&lt;/span&gt;
                        &lt;span&gt;continue&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop to recheck cases
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒后继节点&lt;/span&gt;
&lt;span&gt;                    unparkSuccessor(h);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 状态为0时，将其改成PROPAGATE，更改失败会再次循环判断h节点的状态&lt;br/&gt;　　　　　　　　　 // 这种情况发生在一个线程调用await方法，节点的等待状态还是初始值0未来得及被修改，刚好state被置为0然后调用了doReleaseShared方法&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ws == 0 &amp;amp;&amp;amp;
                         !compareAndSetWaitStatus(h, 0&lt;span&gt;, Node.PROPAGATE))
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop on failed CAS&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h == head)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop if head changed&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32&quot;&gt;
&lt;h4 id=&quot;countdown方法&quot;&gt;countDown方法&lt;/h4&gt;
&lt;p&gt;countDown方法递减state值，当值为0时，依次唤醒等待的线程&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-14&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; countDown() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递减一次state值，知道state为0时唤醒等待中的线程&lt;/span&gt;
        sync.releaseShared(1&lt;span&gt;);
    }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; releaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试将state减去arg&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryReleaseShared(arg)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; state为0时唤醒线程&lt;/span&gt;
&lt;span&gt;            doReleaseShared();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-15&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot;&gt;
&lt;p&gt;到此分析完毕。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-16&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot;&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;通过源码知道CountDownLatch 不能像CyclicBarrier那样使用完毕后还可以复用；&lt;/li&gt;
&lt;li&gt;CountDownLatch 是通过共享锁来实现的，它的构造参数就是AQS state的值；&lt;/li&gt;
&lt;li&gt;由于内部类继承了AQS，所以它内部也是FIFO队列，同时也一样是前驱节点唤醒后继节点。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 26 Jul 2018 15:33:00 +0000</pubDate>
<dc:creator>还是搬砖踏实</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/d-homme/p/9375105.html</dc:identifier>
</item>
</channel>
</rss>