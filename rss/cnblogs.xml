<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>最全Python内置函数 - WrYcF</title>
<link>http://www.cnblogs.com/wuyongcong/p/9418919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyongcong/p/9418919.html</guid>
<description>&lt;h2&gt;内置函数的基本使用&lt;/h2&gt;
&lt;p&gt;abs的使用：&lt;/p&gt;
&lt;p&gt;取绝对值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; abs&lt;br/&gt;print(abs(123))&lt;br/&gt;print(abs(-123))&lt;p&gt;result：&lt;br/&gt;123&lt;br/&gt;123
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;all的使用：&lt;/p&gt;
&lt;p&gt;循环参数，如果每个元素都为真的情况下，那么all的返回值为True：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
假： 0， None， &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;， []，()， {}

ret &lt;/span&gt;=&lt;span&gt; all([True, True])

ret1 &lt;/span&gt;=&lt;span&gt; all([True, False])

result:

True

False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;any的使用：&lt;/p&gt;
&lt;p&gt;只要有一个为True，则全部为True&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ret = any(None, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;, [])

ret1 &lt;/span&gt;= any(None, &lt;span&gt;&quot;&quot;&lt;/span&gt;, 1&lt;span&gt;)

result:

False

True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ascii的使用：&lt;/p&gt;
&lt;p&gt;回去对象的类中，找到__repr__方法，找到该方法之后获取返回值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

obj &lt;/span&gt;=&lt;span&gt; Foo()

ret &lt;/span&gt;=&lt;span&gt; ascii(obj )

自动去对象(类)中找到  &lt;/span&gt;&lt;span&gt;__repr__方法获取其返回值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bin的使用：&lt;/p&gt;
&lt;p&gt;二进制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ret = bin(11&lt;span&gt;)

result:

0b1011&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;oct的使用：&lt;/p&gt;
&lt;p&gt;八进制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ret = oct(14&lt;span&gt;)

result:

0o16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;int的使用：&lt;/p&gt;
&lt;p&gt;十进制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ret = int(10&lt;span&gt;)

result:

&lt;/span&gt;10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hex的使用：&lt;/p&gt;
&lt;p&gt;十六进制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ret = hex(14&lt;span&gt;)

result:

&lt;/span&gt;0xe          0x:表示16进制   e： 表示14
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bool的使用：&lt;/p&gt;
&lt;p&gt;判断真假，  True：真  ，  False：假，   把一个对象转换成bool值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ret =&lt;span&gt; bool(None)

ret &lt;/span&gt;= bool(1&lt;span&gt;)

result:

False

True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bytearray的使用：&lt;/p&gt;
&lt;p&gt;字节列表&lt;/p&gt;
&lt;p&gt;列表元素是字节，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bytes的使用：

字节

bytes(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;callable的使用：&lt;/p&gt;
&lt;p&gt;判断对象是否可被调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Foo:            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义类&lt;/span&gt;
    &lt;span&gt;pass&lt;/span&gt;&lt;span&gt;

foo &lt;/span&gt;= Foo()          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成Foo类实例&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(callable(foo))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  调用实例&lt;/span&gt;
ret = callable(Foo)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断Foo类是否可被调用&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)

result：
False
True                            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;chr的使用：&lt;/p&gt;
&lt;p&gt;给数字找到对应的字符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ret = chr(65&lt;span&gt;)

result:

A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ord的使用：&lt;/p&gt;
&lt;p&gt;给字符找到对应的数字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ret = ord(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

result:

a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;classmethod的使用：&lt;/p&gt;
&lt;p&gt;修饰符&lt;/p&gt;
&lt;p&gt;修饰符对应的函数不需要实例化，不需要self参数，但第一个参数需要时表示自身类的cls参数，可以来调用类的属性，类的方法，实例化对象等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A(object):
    bar &lt;/span&gt;= 1
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2(cls):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;func2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(cls.bar)
        cls().func()    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用func方法&lt;/span&gt;
&lt;span&gt;
A.func2()     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不需要实例化&lt;/span&gt;
&lt;span&gt;

result：
func2
&lt;/span&gt;1&lt;span&gt;
func&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;compile的使用：&lt;/p&gt;
&lt;p&gt;函数讲一个字符串编译为字节代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;compile(source, filename, mode[, flags[, dont_inherit]])


参数：
source      字符串或者AST(Abstract Syntax Trees对象)

filename    代码文件名称，如果不是从文件读取代码则传递一些可辨认的值

mode         指定编译代码的种类，可指定： &lt;/span&gt;&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;， eval， single

flags          变量作用域，局部命名空间，如果被提供，可以是任何映射对象。

flags和dont_inherit是用来控制编译源码时的标志&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
str_for = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;for i in range(1,10): print(i)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
c &lt;/span&gt;= compile(str_for, &lt;span&gt;''&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 编译为字节代码对象&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;(c))

result：
&lt;/span&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;complex的使用：&lt;/p&gt;
&lt;p&gt;函数用于创建一个值为 real + image * j 的复数或者转化一个字符串或数为复数，如果第一个参数为字符串，则不需要指定第二个参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;语法：

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; complex([real ,[ image]])

参数说明：
real        int, long, float或字符串

image     int，long，float&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ret1 = complex(1,2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret1)

ret2 &lt;/span&gt;= complex(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret2)

ret3 &lt;/span&gt;= complex(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret3)

ret4 &lt;/span&gt;= complex(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1+2j&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret4)

result：返回一个复数
(&lt;/span&gt;1+2j&lt;span&gt;)
(&lt;/span&gt;1+&lt;span&gt;0j)
(&lt;/span&gt;1+&lt;span&gt;0j)
(&lt;/span&gt;1+2j)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;delattr的使用：&lt;/p&gt;
&lt;p&gt;用于删除属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
delattr(x, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foobar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)   相等于  &lt;span&gt;del&lt;/span&gt;&lt;span&gt; x.foobar

语法：

delattr(object, name)

参数：
object     对象

name      必须是当前对象的属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DelClass:
    x &lt;/span&gt;= 10&lt;span&gt;
    y &lt;/span&gt;= -5&lt;span&gt;
    z &lt;/span&gt;=&lt;span&gt; 0

obj &lt;/span&gt;=&lt;span&gt; DelClass
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj.x)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj.y)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj.z)

delattr(DelClass, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj.x)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj.y)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj.z)

result：

x &lt;/span&gt;10&lt;span&gt;
y &lt;/span&gt;-5&lt;span&gt;
z 0
x &lt;/span&gt;10&lt;span&gt;
y &lt;/span&gt;-5
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj.z)
AttributeError: type object &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DelClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; has no attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dict的使用：&lt;/p&gt;
&lt;p&gt;字典的使用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
new_dict =&lt;span&gt; dict()
new_dict[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(new_dict)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dir的使用：&lt;/p&gt;
&lt;p&gt;该方法将最大限制地收集参数信息， 查看当前，变量，方法， 类型的属性以及功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dir())
list_one &lt;/span&gt;=&lt;span&gt; list()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dir(list_one))
 
result：
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__builtins__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__cached__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__loader__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__package__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__spec__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
 
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__add__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__class__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__contains__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__delattr__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__delitem__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__dir__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__eq__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__format__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__ge__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__getattribute__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__gt__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__hash__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__iadd__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__imul__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__le__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__lt__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__mul__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__ne__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__reduce__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__reduce_ex__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__reversed__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__rmul__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__setattr__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__sizeof__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__subclasshook__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;clear&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;copy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;extend&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;reverse&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sort&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;divmod的使用：&lt;/p&gt;
&lt;p&gt;将除数和余数运算结果结合起来，返回一个包含商和余数的元祖。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
ret = divmod(7, 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
ret_one &lt;/span&gt;= divmod(8, 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret_one)

参数： 数字

result：
(&lt;/span&gt;3, 1&lt;span&gt;)
(&lt;/span&gt;4, 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;enumerate的使用：&lt;/p&gt;
&lt;p&gt; 用于将一个可遍历的数据对象(list， tuple，str)组合为一个索引序列，同时列出数据，和数据下标。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
test_list = [1, 2, 3, 4, 5&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; data_index, data &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(test_list):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;下标:{0},数据{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(data_index, data))

参数：
sequence        一个序列，迭代器或其他支持迭代对象
start               下标起始位置

result：
下标:0,数据1
下标:&lt;/span&gt;1&lt;span&gt;,数据2
下标:&lt;/span&gt;2&lt;span&gt;,数据3
下标:&lt;/span&gt;3&lt;span&gt;,数据4
下标:&lt;/span&gt;4,数据5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;eval的使用：&lt;/p&gt;
&lt;p&gt; 用来执行一个字符串表达式，并且返回表达式的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
x = 7&lt;span&gt;
ret &lt;/span&gt;= eval(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x + 3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)

参数：
expression             表达式

globals                   变量作用域，全局命名空间

locals                     变量作用域，局部命名空间

result：
&lt;/span&gt;10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;exec的使用：&lt;/p&gt;
&lt;p&gt; 执行存储在字符串或文件中的python语句，相比eval，exec可以执行更复杂的python代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
ret &lt;/span&gt;= &lt;span&gt;exec&lt;/span&gt;(&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;for i in range(0,5): 
                    time.sleep(1)   
                    print(i) &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意代码块中的缩进&lt;/span&gt;
&lt;span&gt;
result:

0
&lt;/span&gt;1
2
3
4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;filter的使用：&lt;/p&gt;
&lt;p&gt; 用于过滤序列，过滤掉不符合条件的元素，返回符合条件元素组成的新list&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_odd(n):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n % 2 == 1&lt;span&gt;


newlist &lt;/span&gt;= filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(newlist)

参数：
function      判断函数

iterable       可迭代对象


result：
[&lt;/span&gt;1, 3, 5, 7, 9]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;float的使用：&lt;/p&gt;
&lt;p&gt;将整形转换成小数形&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
a_int = 10&lt;span&gt;
b_float &lt;/span&gt;=&lt;span&gt; float(a_int)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a_int)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b_float)


result：
&lt;/span&gt;10
10.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;format的使用：&lt;/p&gt;
&lt;p&gt;字符串序列化，可以序列多种类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
str_format = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Helle World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

list_format &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;list hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

dict_format &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key_one&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value_one&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}

ret_format_one &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(str_format)
ret_format_two &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(list_format)
ret_format_three &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(dict_format)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret_format_one)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret_format_two)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret_format_three)

result：
Helle World
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;list hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key_one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value_one&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;frozenset的使用：&lt;/p&gt;
&lt;p&gt; 返回一个冻结集合，集合冻结之后不允许添加，删除任何元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
a = frozenset(range(10))    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成一个新的不可变集合&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)

b &lt;/span&gt;= frozenset(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wyc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建不可变集合&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)



result：
frozenset({0, &lt;/span&gt;1, 2, 3, 4, 5, 6, 7, 8, 9&lt;span&gt;})
frozenset({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;getattr的使用：&lt;/p&gt;
&lt;p&gt;用于返回一个对象的属性值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(object):
    bar &lt;/span&gt;= 1&lt;span&gt;

obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(getattr(obj, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取属性bar的默认值&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(getattr(obj, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不存在，没设置默认值，则报错&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(getattr(obj, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3))          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 属性2不存在，则设置默认值即可&lt;/span&gt;
&lt;span&gt;
result：
&lt;/span&gt;1

 &lt;span&gt;print&lt;/span&gt;(getattr(obj, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
AttributeError: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; object has no attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

3        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;globals的使用：&lt;/p&gt;
&lt;p&gt;会以字典类型返回当前位置的全部全局变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(globals())

result：
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__cached__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__builtins__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;builtins&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__package__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:/Users/Administrator/PycharmProjects/untitled/day1.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__loader__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;_frozen_importlib_external.SourceFileLoader object at 0x0000011E78626B70&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__spec__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hasattr的使用：&lt;/p&gt;
&lt;p&gt; 用于判断对象是否包含对应的属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    x &lt;/span&gt;= 10&lt;span&gt;
    y &lt;/span&gt;= 20&lt;span&gt;
    z &lt;/span&gt;=&lt;span&gt; 0

obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(hasattr(obj, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(hasattr(obj, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

result：
True
False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hash的使用：&lt;/p&gt;
&lt;p&gt; 用于获取一个对象(字符串或者数值等)的哈希值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
str_test = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
int_test &lt;/span&gt;= 5


&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(hash(str_test))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(hash(int_test))

result：
&lt;/span&gt;1305239878169122869
5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;help的使用：&lt;/p&gt;
&lt;p&gt;帮助查看类型有什么方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
str_test = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(help(str))



result：
结果有点小长，就不粘贴再此了&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;id的使用：&lt;/p&gt;
&lt;p&gt;查看当前类型的存储在计算机内存中的id地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
str_test = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(str_test))

result：
&lt;/span&gt;2376957216616 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;input的使用：&lt;/p&gt;
&lt;p&gt;接受标准数据，返回一个string类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
user_input = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(user_input)

result：
请输入：wyc
wyc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;isinstance的使用：&lt;/p&gt;
&lt;p&gt; 判断一个对象是否是一个已知的类型，类似type()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
a = 1
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(isinstance(a, int))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(isinstance(a, str))


result:
True
False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;issubclass的使用：&lt;/p&gt;
&lt;p&gt; 用于判断参数class是否是类型参数， classinfo的子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(issubclass(B, A))       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断B是否是A的子类&lt;/span&gt;
&lt;span&gt;
result：
True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;iter的使用：&lt;/p&gt;
&lt;p&gt; 用来生成迭代器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
lst = [1, 2, 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; iter(lst):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)


result：
&lt;/span&gt;1
2
3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;len的使用：&lt;/p&gt;
&lt;p&gt;查看当前类型里边有多少个元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
str_one = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
lst &lt;/span&gt;= [1, 2, 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(len(str_one))          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 空格也会算一个元素&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(len(lst))    

result：
&lt;/span&gt;11
3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;list的使用：&lt;/p&gt;
&lt;p&gt;列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
list = [1, 2, 3, 4, 5&lt;span&gt;]

方法：
索引：  index
切片： [&lt;/span&gt;1:3&lt;span&gt;]
追加： append
删除： pop
长度： len
扩展： extend
插入： insert
移除：remove
反转： reverse
排序：sort&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;locals的使用：&lt;/p&gt;
&lt;p&gt; 以字典类型返回当前位置的全部，局部变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(arg):
    z &lt;/span&gt;= 1
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; locals()

ret &lt;/span&gt;= func(4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)

result：
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;arg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 4, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;map的使用：&lt;/p&gt;
&lt;p&gt; 根据提供的函数对指定序列做映射&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(list_num):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; list_num * 2

&lt;span&gt;print&lt;/span&gt;(map(func, [1, 2, 3, 4, 5&lt;span&gt;]))

result:
[&lt;/span&gt;2, 4, 6, 8, 10]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;max的使用：&lt;/p&gt;
&lt;p&gt;返回最大数值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ret = max(1, 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)

result：
&lt;/span&gt;10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;memoryview的使用：&lt;/p&gt;
&lt;p&gt; 返回给定参数的内存查看对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
v = memoryview(bytearray(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(v[0])

restlt：
&lt;/span&gt;97
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;min的使用：&lt;/p&gt;
&lt;p&gt; 取出最小数值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(min(1, 10&lt;span&gt;))

result：
&lt;/span&gt;1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;next的使用：&lt;/p&gt;
&lt;p&gt; 返回迭代器的下一个项目&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
it = iter([1, 2, 3, 4, 5&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        x &lt;/span&gt;=&lt;span&gt; next(it)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopIteration:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遇到StopIteration就退出循环&lt;/span&gt;
        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;


result：
&lt;/span&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;open的使用：&lt;/p&gt;
&lt;p&gt; 打开一个文件，创建一个file对象，相关的方法才可以调用它的读写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
f.read()
f.close()       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 文件读写完成之后，一定要关闭&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ord的使用：&lt;/p&gt;
&lt;p&gt;函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ret = ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
ret1 &lt;/span&gt;= ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
ret2 &lt;/span&gt;= ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


result:
&lt;/span&gt;97
98
99
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pow的使用：&lt;/p&gt;
&lt;p&gt; 返回 x&lt;sup&gt;y&lt;/sup&gt;（x的y次方） 的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; math   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入 math 模块&lt;/span&gt;
 
&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;math.pow(100, 2) : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, math.pow(100, 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用内置，查看输出结果区别&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pow(100, 2) : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, pow(100, 2&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;math.pow(100, -2) : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, math.pow(100, -2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;math.pow(2, 4) : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, math.pow(2, 4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;math.pow(3, 0) : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, math.pow(3, 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;print的使用:&lt;/p&gt;
&lt;p&gt; 输出，打印&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

result:
hello world&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;property的使用：&lt;/p&gt;
&lt;p&gt; 新式类中的返回属性值，python3中是新式类，2中是旧式类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; C(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self._x &lt;/span&gt;=&lt;span&gt; None
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; getx(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._x
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setx(self, value):
        self._x &lt;/span&gt;=&lt;span&gt; value
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; delx(self):
        &lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; self._x
 
    x &lt;/span&gt;= property(getx, setx, delx, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm the 'x' property.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;range的使用：&lt;/p&gt;
&lt;p&gt;输出范围之内的数值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, 5&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)

result:
&lt;/span&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;repr的使用：&lt;/p&gt;
&lt;p&gt; 函数将对象转化为供解释器读取的形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
s = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;RUNOOB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
repr(s)
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'RUNOOB'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dict &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;runoob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;runoob.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;google.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;};
repr(dict)
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{'google': 'google.com', 'runoob': 'runoob.com'}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reversed的使用：&lt;/p&gt;
&lt;p&gt; 返回一个反转的迭代器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 字符串&lt;/span&gt;
seqString = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Runoob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list(reversed(seqString)))
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 元组&lt;/span&gt;
seqTuple = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list(reversed(seqTuple)))
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; range&lt;/span&gt;
seqRange = range(5, 9&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list(reversed(seqRange)))
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列表&lt;/span&gt;
seqList = [1, 2, 4, 3, 5&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list(reversed(seqList)))

result：
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;8, 7, 6, 5&lt;span&gt;]
[&lt;/span&gt;5, 3, 4, 2, 1]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;round的使用：&lt;/p&gt;
&lt;p&gt; 返回浮点数x的四舍五入值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;round(80.23456, 2) : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, round(80.23456, 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;round(100.000056, 3) : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, round(100.000056, 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;round(-100.000056, 3) : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, round(-100.000056, 3&lt;span&gt;)

result：
round(&lt;/span&gt;80.23456, 2) :  80.23&lt;span&gt;
round(&lt;/span&gt;100.000056, 3) :  100.0&lt;span&gt;
round(&lt;/span&gt;-100.000056, 3) :  -100.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;set的使用：&lt;/p&gt;
&lt;p&gt; 不可重复元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
a=set((1,2,3,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;setattr的使用：&lt;/p&gt;
&lt;p&gt;设置属性值，该属性必须存在&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A(object):
    bar &lt;/span&gt;= 1&lt;span&gt;

a &lt;/span&gt;=&lt;span&gt; A()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(getattr(a, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取属性 bar 值&lt;/span&gt;
1&lt;span&gt;
setattr(a, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 5)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置属性 bar 值&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(a.bar)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;slice的使用：&lt;/p&gt;
&lt;p&gt;  实现切片对象，主要用在切片操作函数里的参数传递&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
myslice = slice(5)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置截取5个元素的切片&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(myslice)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(slice(None, 5&lt;span&gt;, None))
arr &lt;/span&gt;= range(10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(arr)
[0, &lt;/span&gt;1, 2, 3, 4, 5, 6, 7, 8, 9&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(arr[myslice])        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 截取 5 个元素&lt;/span&gt;
[0, 1, 2, 3, 4]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;sorted的使用：&lt;/p&gt;
&lt;p&gt; 所有可迭代的对象进行排序操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;105&quot;&gt;
&lt;pre&gt;
a = [5,7,6,3,4,1,2&lt;span&gt;]
b &lt;/span&gt;= sorted(a)       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保留原列表&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a) 
[&lt;/span&gt;5, 7, 6, 3, 4, 1, 2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
[&lt;/span&gt;1, 2, 3, 4, 5, 6, 7&lt;span&gt;]
 
L&lt;/span&gt;=[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,3),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,4&lt;span&gt;)]
sorted(L, cmp&lt;/span&gt;=&lt;span&gt;lambda&lt;/span&gt; x,y:cmp(x[1],y[1]))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用cmp函数&lt;/span&gt;
[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 1), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 4&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sorted(L, key=&lt;span&gt;lambda&lt;/span&gt; x:x[1]))               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用key&lt;/span&gt;
[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 1), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 2), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 4&lt;span&gt;)]
 
 
students &lt;/span&gt;= [(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;john&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 15), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jane&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 12), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 10&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sorted(students, key=&lt;span&gt;lambda&lt;/span&gt; s: s[2]) )           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按年龄排序&lt;/span&gt;
[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 10), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jane&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 12), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;john&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 15&lt;span&gt;)]
 
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(sorted(students, key=&lt;span&gt;lambda&lt;/span&gt; s: s[2], reverse=True) )      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按降序&lt;/span&gt;
[(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;john&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 15), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jane&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 12), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 10)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;staticmethod的使用：&lt;/p&gt;
&lt;p&gt; 返回函数的静态方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; C(object):
    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;runoob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
 
C.f();          &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 静态方法无需实例化&lt;/span&gt;
cobj =&lt;span&gt; C()
cobj.f()        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 也可以实例化后调用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;str的使用：&lt;/p&gt;
&lt;p&gt; 字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
str = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

方法：
cpitalize      首字母变大写

count           子序列个数

decode          解码

encode          编码针对unicode

endswith        是否以xxx结束

find            寻找子序列位置，如果没有找到，返回&lt;/span&gt;-1&lt;span&gt;

format          字符串格式化

index           子序列位置，如果没有找到，报错

isalnum         是否是字母数字

isalpha         是否是字母

isdigit         是否是数字

islower         是否小写

join            拼接

lower           变小写

lstrip          移除左侧空白

replace         替换&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sum的使用：&lt;/p&gt;
&lt;p&gt;求数值整合&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(sum(1+1&lt;span&gt;))

result:
&lt;/span&gt;2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;super的使用：&lt;/p&gt;
&lt;p&gt; 用于调用父类(超类)的一个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
Python3.x 和 Python2.x 的一个区别是: Python 3&lt;span&gt; 可以使用直接使用 super().xxx 代替 super(Class, self).xxx 

python3
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self, x):
        super().add(x)

python2
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; A(object):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Python2.x 记得继承 object&lt;/span&gt;
    &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self, x):
        super(B, self).add(x)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tuple的使用：&lt;/p&gt;
&lt;p&gt;元祖，元祖是不可修改的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
tuple = (1, 2, 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;type的使用：&lt;/p&gt;
&lt;p&gt;查看当前类型是什么类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
lst =&lt;span&gt; list()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(lst))

result:
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;vars的使用：&lt;/p&gt;
&lt;p&gt; 返回对象object的属性和属性值的字典对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(vars())
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__builtins__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;module &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__builtin__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (built-&lt;span&gt;in&lt;/span&gt;)&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__package__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: None}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Runoob:
a &lt;/span&gt;= 1

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(vars(Runoob))
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__module__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: None}
runoob &lt;/span&gt;=&lt;span&gt; Runoob()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(vars(runoob))
{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zip的使用：&lt;/p&gt;
&lt;p&gt;函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。&lt;/p&gt;
&lt;p&gt;如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
a = [1,2,3&lt;span&gt;]
b &lt;/span&gt;= [4,5,6&lt;span&gt;]
c &lt;/span&gt;= [4,5,6,7,8&lt;span&gt;]
zipped &lt;/span&gt;= zip(a,b)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打包为元组的列表&lt;/span&gt;
[(1, 4), (2, 5), (3, 6&lt;span&gt;)]
zip(a,c)              &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 元素个数与最短的列表一致&lt;/span&gt;
[(1, 4), (2, 5), (3, 6&lt;span&gt;)]
zip(&lt;/span&gt;*zipped)          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式&lt;/span&gt;
[(1, 2, 3), (4, 5, 6)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;__import__的使用：&lt;/p&gt;
&lt;p&gt; 函数用于动态加载类和函数 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;  time， os
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扩展进制转换：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;二进制转换十进制

int(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0b11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, base=2&lt;span&gt;)

result:    &lt;/span&gt;3&lt;span&gt;

八进制转换十进制

int(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, base=8&lt;span&gt;)

result: &lt;/span&gt;9&lt;span&gt;

十六进制转换十进制

int(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0xe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, base=16&lt;span&gt;)

result: &lt;/span&gt;14
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上有不足之处，请大神，留下宝贵的建议，本人看到第一时间添加。&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 16:55:00 +0000</pubDate>
<dc:creator>WrYcF</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyongcong/p/9418919.html</dc:identifier>
</item>
<item>
<title>如何正确的使用Unity的Sprite Atlas - Eran</title>
<link>http://www.cnblogs.com/eran/p/9420765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eran/p/9420765.html</guid>
<description>&lt;p&gt;做了几个关于spriteatlas的实验,收获不少. 过程懒得写了.就把最后关键的两点列一下吧.&lt;/p&gt;
&lt;h2 id=&quot;显存&quot;&gt;显存&lt;/h2&gt;
&lt;p&gt;当img被放入纹理集以后,无论原img是否在&lt;code&gt;Resources&lt;/code&gt;目录.显存中均使用的是纹理集而非原始图片.&lt;/p&gt;
&lt;p&gt;比如游戏中有10个物品,背包展示时候 你通过&lt;code&gt;Resource.Load&amp;lt;Sprite&amp;gt;($imgPath)&lt;/code&gt;加载对应的图片进行展示. 但是该图片已经被打入纹理集了. 则此时显存中加载的是纹理集而非单张图片素材&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/478652/201808/478652-20180805005036390-897000131.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图,裸包19个纹理 打成纹理集后 无论如何折腾都是20个纹理.&lt;/p&gt;
&lt;h2 id=&quot;apk包体&quot;&gt;APK包体&lt;/h2&gt;
&lt;p&gt;原始图片如果放入&lt;code&gt;Resources&lt;/code&gt;目录则会被全量打入APK(即使根本用不到☹️). 但是如果放在外部,只有纹理集放入&lt;code&gt;Resources&lt;/code&gt;目录则原素材只会打入很小一部分信息.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/478652/201808/478652-20180805005039264-256439941.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/478652/201808/478652-20180805005042202-2036375512.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;恩 这个是比较尴尬的地方了.&lt;/p&gt;
&lt;p&gt;如果所有图片都是被间接引用的. 比如一个Prefab里面有一个节点挂了一个SpreiteRender然后引用了Pic1.jpg.&lt;/p&gt;
&lt;p&gt;这时候只要把Img和纹理集都丢到&lt;code&gt;Resource&lt;/code&gt;目录外面即可. 打出包来 结构也会和方案2一样的.&lt;/p&gt;
&lt;p&gt;但是 如果项目中存在 需要用路径去进行&lt;code&gt;Resource.Lord&amp;lt;Sprite&amp;gt;($imgPath)&lt;/code&gt;来访问资源时候. 原始资源如果不在&lt;code&gt;Resource&lt;/code&gt;目录就根本访问不到.&lt;/p&gt;
&lt;p&gt;此时需要首先Load到纹理集,然后通过&lt;code&gt;GetSprites&lt;/code&gt;方法访问到相应纹理. 也就是自己需要维护一份纹理集和图片的从属关系.然后封装一下Load函数才行.&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 16:52:00 +0000</pubDate>
<dc:creator>Eran</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eran/p/9420765.html</dc:identifier>
</item>
<item>
<title>OpenJudge1001Exponentiation - 守功</title>
<link>http://www.cnblogs.com/sgatbl/p/9420701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sgatbl/p/9420701.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt;  2&lt;/span&gt; #include&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt;  3&lt;/span&gt; #include&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; bign{
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; data[&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; point;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;    bign(){
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         memset(data, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(data));
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         length = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         point = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; str;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;bign Change(){
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;    bign a;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     a.point = str.length() - str.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(unsigned &lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;str.length();i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(str[str.length() - i - &lt;span&gt;1&lt;/span&gt;]!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             a.data[j] = str[str.length() - i - &lt;span&gt;1&lt;/span&gt;] - &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;             j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;     a.length =&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;bign multi(bign a, bign b){
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;    bign c;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; carry = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;b.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         c.length =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;a.length;j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; temp = a.data[j] * b.data[i] + carry + c.data[i+&lt;span&gt;j];
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             c.data[c.length++] = temp % &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             carry = temp / &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(carry != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             c.data[c.length++] = carry % &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             carry /= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     c.point = a.point +&lt;span&gt; b.point;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; c;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; bign power(bign a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(n==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;        bign d;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         d.data[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         d.length = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; d;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(n%&lt;span&gt;2&lt;/span&gt;==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;  multi(a, power(a, n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; multi(power(a, n/&lt;span&gt;2&lt;/span&gt;), power(a, n/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show(bign rs){
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ans;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; zero = &lt;span&gt;0&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录尾部0的数目&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;rs.point;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(rs.data[i]!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             zero++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(str[&lt;span&gt;0&lt;/span&gt;]!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=rs.length-&lt;span&gt;1&lt;/span&gt;;i&amp;gt;=zero;i--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(zero==&lt;span&gt;rs.point){
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                 ans.insert(ans.end(), rs.data[i] + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(i==&lt;span&gt;rs.point){
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                     ans.insert(ans.end(), rs.data[i] + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                     ans.insert(ans.end(), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                     ans.insert(ans.end(), rs.data[i] + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         ans.insert(ans.end(), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=rs.point-&lt;span&gt;1&lt;/span&gt;;i&amp;gt;=zero;i--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             ans.insert(ans.end(), rs.data[i] + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;     cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(cin&amp;gt;&amp;gt;str&amp;gt;&amp;gt;&lt;span&gt;n){
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         bign bg =&lt;span&gt; Change();
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         bign rs =&lt;span&gt; power(bg, n);
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        show(rs);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Sat, 04 Aug 2018 16:10:00 +0000</pubDate>
<dc:creator>守功</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sgatbl/p/9420701.html</dc:identifier>
</item>
<item>
<title>30分钟带你了解Docker - 冷豪</title>
<link>http://www.cnblogs.com/learnhow/p/9420404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnhow/p/9420404.html</guid>
<description>&lt;p&gt;最近一直在忙项目，不知不觉2个多月没有更新博客了。正好自学了几天docker就干脆总结一下，也顺带增加一篇《30分钟入门系列》。网上能够查到的对于docker的定义我就不再重复了，说说我自己对它的理解：Docker一个方便多次部署的虚拟化Linux容器，与当下流行的SpringBoot和微服务框架搭配更加相得益彰，从而真正的做到从开发到部署的全流程灵敏。请注意这里的三个关键词：Linux容器，SpringBoot，灵敏。首先，Docker不能别用来部署本地应用（如果你有开发过基于Qt的桌面应用你就能体会到运行环境不统一对于开发人员来说简直是噩梦）。其次，这篇博客是针对Java开发人员的，但Docker的使用场景绝不仅限于此。最后，灵敏意味着可能有一些开发方式需要调整，到底如何利用Docker应该是当你了解它之后需要认真思考的问题。&lt;/p&gt;
&lt;p&gt;一、环境准备&lt;/p&gt;
&lt;p&gt;我个人的测试环境为VirtualBox，CentOS7及最新版本的Spring Boot。首先以最小化方式安装CentOS：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201808/871676-20180804210310165-726650804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201808/871676-20180804210516208-1169630559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推荐在安装阶段就默认打开网络链接...接下来等待20分钟虚拟机安装完毕&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201808/871676-20180804210710795-426580889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于是最小化安装，完成以后推荐安装几条基础命令：&lt;/p&gt;
&lt;p&gt;1. yum update&lt;/p&gt;
&lt;p&gt;2. yum install -y net-tools vim curl wget &lt;/p&gt;
&lt;p&gt;以上测试环境就算搭建完成，以下开始安装Docker。我们进入官方网站，他们已经很贴心的为我们准备好了安装教程。目前我可以登陆Docker的官方网站，并且基于Centos的安装说明在&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/centos/&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;也可以查看。不过为了以防万一，我在博客中还是记录一下如果你发现无法访问或阅读英文有些困难直接跟着下面的流程走即可：&lt;/p&gt;
&lt;p&gt;1. 卸载系统中的早期版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 安装工具&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ sudo yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 配置Docker的安装yum原&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. 安装Docker CE&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ sudo yum install docker-ce
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5. 启动Docker&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ sudo systemctl start docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6. 运行Hello World&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ sudo docker run hello-world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201808/871676-20180804213017208-1731885035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7. 配置国内的镜像加速&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://57326c54.m.daocloud.io
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、操作指南&lt;/p&gt;
&lt;p&gt;网上有关docker的命令有很多，详细的说明各位可以去更权威的地方查阅。这里我只列举几条最重要的命令并加以说明：&lt;/p&gt;
&lt;p&gt;1. 查阅镜像列表：docker images&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201808/871676-20180804213733948-586019448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你应该不会有这么多镜像，但是至少应该存在一条hello-world。没错这就是你刚刚下载的测试镜像。&lt;/p&gt;
&lt;p&gt;2. 查阅容器列表：docker ps -a&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201808/871676-20180804214450976-908005134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你应该也只会看到一条hello-world的容器。&lt;/p&gt;
&lt;p&gt;这里我们已经接触到了有关docker的第一个重要概念：镜像和容器。不过暂时我还不打算对这两个概念加以说明，我们可以反复运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ sudo docker run hello-world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再查看容器列表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201808/871676-20180804215049117-1977977597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错，你现在发现多次运行同一个镜像只会发生一次镜像下载，但是却会出现多个容器。更准确的说，你运行了几次hello-world就会生成几个容器。&lt;/p&gt;
&lt;p&gt;3. 停止和删除容器：docker stop/rm [container_id]&lt;/p&gt;
&lt;p&gt;我们删除掉所有hello-world容器，瞬间整个世界变的美好了。&lt;/p&gt;
&lt;p&gt;4. 删除镜像：docker rmi [image_id]&lt;/p&gt;
&lt;p&gt;我们删除掉hello-world镜像，世界终于又归于寂静。&lt;/p&gt;
&lt;p&gt;有了感性认识以后，现在可以说明镜像和容器的概念：&lt;/p&gt;
&lt;p&gt;镜像就好像是iso文件，docker需要使用镜像作为源。一个镜像可以反复被使用，而每次当docker通过镜像启动起来的就是一个容器，容器之间相互隔离。如果容器被删除了，在容器中的所有改变都会丢失。&lt;/p&gt;
&lt;p&gt;用一张最经典的图来表示镜像与容器的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201808/871676-20180804221223789-244690423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错，一个完整的docker项目就应该是这样，在本地系统（boosfs）之上可能存在多个镜像（image）它们之间存在继承关系，而最上层处于运行环境的就是容器（container）。所有的修改操作都只在容器中。如果容器被关闭数据会发生丢失，除非你将容器刻录为新的镜像层。不过我们还有别的更好的手段将数据保存下来，但不在我们今天的讨论中。&lt;/p&gt;
&lt;p&gt;5. 获取镜像：docker pull [image_name]&lt;/p&gt;
&lt;p&gt;**********************************************&lt;/p&gt;
&lt;p&gt;请确认你已经配置了国内的镜像加速：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/docker/daemon.json
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
&quot;registry-mirrors&quot;: [&quot;http://57326c54.m.daocloud.io&quot;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启Docker：systermctl restart docker&lt;/p&gt;
&lt;p&gt;**********************************************&lt;/p&gt;
&lt;p&gt;先查询一下与CentOS有关的镜像&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker search centos
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个看上去很“官方”的样子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker pull centos:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载完成以后先查询一下确认镜像没有问题docker images。&lt;/p&gt;
&lt;p&gt;6. 交互的方式来启动镜像：docker run -it [image_name] [args...]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -it centos /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;咦？似乎没有任何变化。再仔细看看，命令提示符是不是有变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201808/871676-20180804224127133-978598054.png&quot; alt=&quot;&quot;/&gt;没错，你已经进入了容器，现在是在容器的CentOS操作界面。&lt;/p&gt;
&lt;p&gt;7. 安装Mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ sudo yum install -y wget
$ sudo wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm
$ sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm
$ sudo yum install mysql-community-server&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ sudo mysql_install_db --user=mysql --ldata=/var/lib/mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ sudo mysqld_safe
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8. 离开容器：Ctrl + q, Ctrl + p&lt;/p&gt;
&lt;p&gt;这个组合键是用来退出容器并让容器在后台保持运行&lt;/p&gt;
&lt;p&gt;9. 重新登陆容器：docker exec -it [container_id] [args...]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker exec -it 21f99e364fb1 bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;赋予MySQL的root用户远程连接权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# mysql -u root

mysql&amp;gt; UPDATE mysql.user SET Password = PASSWORD('12345678') WHERE User = 'root';
mysql&amp;gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '12345678' WITH GRANT OPTION;
mysql&amp;gt; flush privileges;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;10. 提交镜像：docker commit [container_id] [myimage_name:tag]&lt;/p&gt;
&lt;p&gt;要提交自己的镜像首先需要退出当前容器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exit
docker commit 21f99e364fb1 centos:mysql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;11. 端口映射：docker run -p [local_port]:[docker_port] -it [image_name] [args...]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -p 3307:3306 -it centos:mysql /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们在本地的操作系统中就可以通过访问虚拟机的3307端口访问我们在docker中部署的mysql服务了。&lt;/p&gt;
&lt;p&gt;三、构建SpringBoot项目的docker镜像&lt;/p&gt;
&lt;p&gt;到目前为止，如果你的操作一切顺利代表已经掌握了docker的基本使用方法。上面的对于mysql的安装其实只是起到一个抛砖引玉的作用，目的是让你熟悉docker的基础命令，实际在开发中我们很少会将mysql部署在docker中。更常见的一个开发场景是将SpringBoot项目生成docker镜像，下面我们就正式进入实战环节。&lt;/p&gt;
&lt;p&gt;1. 在本地先构建一个SpringBoot项目&lt;/p&gt;
&lt;p&gt;通过SpringBoot的&lt;a href=&quot;https://start.spring.io/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;为我们生成一个基础项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201808/871676-20180804231507838-961018493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着通过你喜欢的IDE导入并打开项目，在pom.xml文件中添加依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.spotify&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;docker-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;imageName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${docker.image.prefix}/${project.artifactId}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;imageName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dockerDirectory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;src/main/docker&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dockerDirectory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;targetPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;targetPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;directory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${project.build.directory}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;directory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${project.build.finalName}.jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编写一个controller文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DockerController {
    @RequestMapping(&lt;/span&gt;&quot;/&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello Docker!&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在本地运行一下，看看有没有问题。如果一切正常进入下一步。&lt;/p&gt;
&lt;p&gt;2. 接下来我们需要将项目放到docker的环境中去打包&lt;/p&gt;
&lt;p&gt;(1) 在虚拟机中安装jdk&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum -y install java-1.8.0-openjdk*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2) 配置环境变量如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vim /etc/profile

export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-0.b14.el7_4.x86_64 
export PATH=$PATH:$JAVA_HOME/bin &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3) 从&lt;a href=&quot;http://mirrors.shu.edu.cn/apache/maven/maven-3/3.5.4/binaries/&quot; target=&quot;_blank&quot;&gt;Apache官网&lt;/a&gt;下载最新版本的maven&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tar vxf apache-maven-3.5.4-bin.tar.gz
mv apache-maven-3.5.4 /usr/local/maven3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(4) 配置环境变量如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export MAVEN_HOME=/usr/local/maven3
export PATH=PATH:MAVEN_HOME/bin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(5) 使环境变量生效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
source /etc/profile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(6) 编写DockerFile文件&lt;/p&gt;
&lt;p&gt;在main目录下添加一个docker目录并创建DockerFile文件，文件内容如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;FROM openjdk:8-jdk-alpine
VOLUME /tmp
ADD helloboot-0.0.1-SNAPSHOT.jar app.jar
ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(7) 接着在项目路径下使用maven打包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mvn package docker:build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果中间发生构建失败可能的原因是你的项目名称和我的不一样，请仔细检查DockerFile文件，通常在第一次i构建中你可能会遇到各种各样的错误信息。放到网上查一下就可以了。&lt;/p&gt;
&lt;p&gt;构建完成以后我们可以通过docker images查询一下镜像列表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201808/871676-20180804234611533-1609514696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错第一个镜像就是我们的项目。下面启动这个镜像并通过服务器的80端口来映射：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -p 80:8080 -t springboot/helloboot
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后我们在本地通过浏览器直接访问虚拟机的ip，如果可以看到“Hello Docker!”&lt;/p&gt;
&lt;p&gt;说明使用 Docker 部署 Spring Boot 项目成功！&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 15:55:00 +0000</pubDate>
<dc:creator>冷豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learnhow/p/9420404.html</dc:identifier>
</item>
<item>
<title>使用 OpenSSL为WindowsServer远程桌面（RDP）创建自签名证书 (Self-signed SSL certificate) - ChasingDreams</title>
<link>http://www.cnblogs.com/chasingdreams2017/p/9420561.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chasingdreams2017/p/9420561.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;笔者查阅很多资料，才写成此文章，如有错误，请读者们及时提出。&lt;br/&gt;一般大家使用远程桌面(Remote Desktop)连接Windows Server时，总会有一个警告提示，如图1&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1303627/201808/1303627-20180804231211395-293348145.png&quot; alt=&quot;图1&quot;/&gt;&lt;br/&gt;图1&lt;br/&gt;出现此警告的原因为证书为服务器的自签名证书，我们的客户端无法识别，故笔者思考，如何使用证书安全的使用远程桌面（RDP）。&lt;/p&gt;
&lt;h4 id=&quot;解决方法&quot;&gt;解决方法：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;使用WIndowsServer自带的&quot;AD证书服务&quot;，生成整个&lt;a href=&quot;https://baike.baidu.com/item/PKI/212376&quot;&gt;PKI&lt;/a&gt;，即拥有整套证书体系，自然所有有关认证问题迎刃而解。缺点是操作非常复杂，优点是安全，商业级别！&lt;/li&gt;
&lt;li&gt;使用OpenSSL全程自己搭建证书，比方式一会节省很多步骤，使用简单，适合开发测试，缺点是安全级别不能达到用于商业的高度（其实操作者熟知PKI、X509什么的，也能做出标准的证书）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;关于openca&quot;&gt;关于OpenCA:&lt;/h4&gt;
&lt;p&gt;OpenCA是一个开源项目，用于搭建私有&lt;a href=&quot;https://baike.baidu.com/item/PKI/212376&quot;&gt;PKI&lt;/a&gt;。笔者才疏学浅，尚未对此有所研究，希望有对此比较清楚的读者告知如何应用到远程桌面服务器身份认证上。^-^&lt;/p&gt;
&lt;h4 id=&quot;难点&quot;&gt;难点:&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;客户端连接服务器远程桌面时需要检查证书吊销状态。检查证书吊销状态有两种方式： &lt;a href=&quot;http://www.cfca.com.cn/20150811/101230759.html&quot;&gt;CRL与OSCP&lt;/a&gt;&lt;br/&gt;1.1 OCSP&lt;br/&gt;默认情况，证书路径验证设置使用的是OCSP,但是由于我们是自签名证书，Windows检查时始终会提示&quot;Invalid Signer EKU&quot;/&quot;无效签名者 EKU&quot;,所以我们无法使用此方式验证证书吊销状态。&lt;br/&gt;1.2 CRL&lt;br/&gt;当OCSP不能满足我们的需求时，我们只能使用CRL来验证证书吊销状态啦，所以我们还需使用一个站点用于提供CRL&lt;/li&gt;
&lt;li&gt;在OpenSSL 中灵活使用&lt;code&gt;x509v3_config&lt;/code&gt;。目前好多文章都没有讲到如何在证书里添加&lt;code&gt;CRL分发点&lt;/code&gt;、&lt;code&gt;授权信息访问&lt;/code&gt;等扩展信息，究其原因就是没有理解X509z证书扩展的应用，当然也有好多文章里面有提及，但未明确指明，会让读者一头雾水。&lt;code&gt;强烈推荐使用OpenSSL的读者阅读&lt;/code&gt; &lt;a href=&quot;https://www.openssl.org/docs/manmaster/man5/x509v3_config.html&quot;&gt;x509v3_config - X509 V3 certificate extension configuration format&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;兵贵神速，马上实战！&lt;/p&gt;
&lt;h2 id=&quot;openssl&quot;&gt;OpenSSL&lt;/h2&gt;
&lt;p&gt;笔者使用的是Ubuntu，所以可能会出现不同操作系统OpenSSL配置文件路径不一样的情况，请读者自行根据自身情况寻找默认配置文件.&lt;br/&gt;不要使用太旧的OpenSSL，当心漏洞。&lt;/p&gt;
&lt;h3 id=&quot;准备环境&quot;&gt;准备环境&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;mkdir openssl.Test
cd openssl.Test
mkdir -p ./demoCA/{private,newcerts} 
touch demoCA/index.txt 
touch demoCA/serial
touch demoCA/crlnumber
echo 01 &amp;gt; demoCA/serial
echo 01 &amp;gt; demoCA/crlnumber
cp /etc/ssl/openssl.cnf .&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自建ca&quot;&gt;自建CA&lt;/h2&gt;
&lt;p&gt;根据提示输入信息时，请读者牢记输入内容，后文有用到。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置私钥&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;openssl genrsa -des3 -out ./demoCA/private/cakey.pem 2048&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;申请自签名证书&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;openssl req -new -x509 -days 365 -key ./demoCA/private/cakey.pem -out ./demoCA/cacert.pem&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;调整openssl.cnf&quot;&gt;调整openssl.cnf&lt;/h2&gt;
&lt;p&gt;打开我们之前复制过来的openssl.cnf&lt;/p&gt;
&lt;p&gt;[ CA_default ]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;default_crl_days= 365&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;确保req下存在以下2行（默认第一行是有的，第2行被注释了）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ req ]
distinguished_name = req_distinguished_name
req_extensions = v3_req&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;v3_req节点示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ v3_req ]

# 在证书请求中添加扩展

# 作为最终证书，不能用此证书作为中间证书 具体表现为在查看证书中&quot;基本约束&quot;为 Subject Type=End Entity
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
# 暂且理解用来扩展域名吧，DNS.1建议写服务器域名，否则在做HTTPS网站时就呵呵了（题外话）， SANs是超级有用的！
subjectAltName = @alt_names
# 指定CRL地址的 必需
crlDistributionPoints = @crl_section
# CPS 说明，具体表现在查看证书&quot;免责说明&quot;中
certificatePolicies = @polsect

[ alt_names ]

DNS.1 = test.com
DNS.2 = a.test.com
DNS.3 = b.test.com

[crl_section]
URI.0 = http://example.com/rootca.crl

[polsect]

policyIdentifier = 2.5.29.32.0
CPS.1=&quot;http://example.com/&quot;
userNotice.1=@notice

[notice]

explicitText=&quot;Prower By Low-grade Coder&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;生成服务器证书&quot;&gt;生成服务器证书&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;设置私钥&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;openssl genrsa -out userkey.pem 2048&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;创建证书申请&lt;br/&gt;&lt;code&gt;countryName&lt;/code&gt;、&lt;code&gt;stateOrProvinceName&lt;/code&gt;、&lt;code&gt;organizationName&lt;/code&gt; 默认要求与建CA时填写的要一致，如要修改规则可在&lt;code&gt;openssl.cnf&lt;/code&gt;中&lt;code&gt;[ CA_default ]&lt;/code&gt;里修改,&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;# Common Name 写域名或IP
openssl req -new -days 365 -key userkey.pem -out userreq.pem&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;签发&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;openssl ca -in userreq.pem -out usercert.pem -extensions v3_req -config openssl.cnf&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;制作pfx&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;openssl pkcs12 -export -inkey userkey.pem -in usercert.pem -out user.pfx&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;吊销证书&quot;&gt;吊销证书&lt;/h2&gt;
&lt;p&gt;好吧，我们没有需要吊销的证书，暂时忽略&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl ca -revoke usercert.pem -cert ./demoCA/cacert.pem -keyfile ./demoCA/private/cakey.pem&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;生成吊销列表&quot;&gt;生成吊销列表&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;openssl ca -gencrl -out rootca.crl -cert ./demoCA/cacert.pem -keyfile ./demoCA/private/cakey.pem --config openssl.cnf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把&lt;code&gt;rootca.crl&lt;/code&gt;部署到站点上，做到客户端使用HTTP/HTTPS协议能访问到配置文件中&lt;code&gt;[crl_section]&lt;/code&gt;的地址即可。&lt;/p&gt;
&lt;p&gt;准备工作到此完成！&lt;/p&gt;
&lt;h2 id=&quot;windowsserver&quot;&gt;WindowsServer&lt;/h2&gt;
&lt;h3 id=&quot;导入根证书&quot;&gt;导入根证书&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;把&lt;code&gt;cacert.pem&lt;/code&gt;改名为&lt;code&gt;cacert.crt&lt;/code&gt;,复制到服务器，点击安装到&lt;code&gt;本地计算机&lt;/code&gt;,至此，根证书安装完毕&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;导入服务器证书&quot;&gt;导入服务器证书&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;导入&lt;code&gt;user.pfx&lt;/code&gt;,&lt;code&gt;本地计算机&lt;/code&gt;和&lt;code&gt;当前用户&lt;/code&gt;都需要导入到&lt;code&gt;个人&lt;/code&gt;目录中。&lt;br/&gt;PS：使用&quot;根据证书类型，自动选择证书存储&quot;也可以啦，会默认选择&lt;code&gt;个人&lt;/code&gt;目录的&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;设定远程桌面证书&quot;&gt;设定远程桌面证书&lt;/h3&gt;
&lt;p&gt;使用命令 &lt;code&gt;certmgr.msc&lt;/code&gt; 打开证书管理器，展开 &lt;code&gt;个人&lt;/code&gt;-&amp;gt;&lt;code&gt;证书&lt;/code&gt;,双击我们刚刚导入的证书，选择&lt;code&gt;详细信息&lt;/code&gt;,找到&lt;code&gt;指纹&lt;/code&gt;,复制其内容到记事本(或命令行)，去除&lt;code&gt;空格&lt;/code&gt;，备用。&lt;br/&gt;PS：那一串十六进制最前面的空格超级隐蔽。&lt;/p&gt;
&lt;p&gt;使用命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wmic /namespace:\\root\cimv2\TerminalServices PATH Win32_TSGeneralSetting Set  SSLCertificateSHA1Hash=&quot;刚处理的指纹&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出现更新成功字样即可，如失败，请仔细检查细节。&lt;/p&gt;
&lt;h3 id=&quot;修改组策略&quot;&gt;修改组策略&lt;/h3&gt;
&lt;p&gt;再次强调，证书默认吊销查询使用的OCSP，可是笔者至今未调通，只能通过修改组策略的方式强制走CRL，可是这样会有一系列弊端（当然也可以避免），如果有读者能使用OCSP验证证书吊销状态，此步骤可避免！届时请联系笔者！谢谢。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;启动组策略 gpedit.msc
[计算机配置]-&amp;gt;[安全设置]-&amp;gt;[公钥策略]
打开[证书路径验证设置]
选择[吊销]选项卡
勾选[定义这些策略设置]、[始终首选证书吊销列表(CRL)而非联机证书状态协议(OCSP)响应(不推荐)(P)]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;应用&lt;/code&gt;-&amp;gt;&lt;code&gt;重启机器&lt;/code&gt;。至此，服务器端配置完毕。&lt;/p&gt;
&lt;h2 id=&quot;windows&quot;&gt;Windows&lt;/h2&gt;
&lt;h3 id=&quot;导入根证书-1&quot;&gt;导入根证书&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;把&lt;code&gt;cacert.pem&lt;/code&gt;改名为&lt;code&gt;cacert.crt&lt;/code&gt;,复制到服务器，点击安装到&lt;code&gt;本地计算机&lt;/code&gt;,至此，根证书安装完毕&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;是时候结束这个磨人的小东西了&quot;&gt;^.^ 是时候结束这个磨人的小东西了&lt;/h2&gt;
&lt;p&gt;打开远程桌面 &lt;code&gt;mstsc&lt;/code&gt;,验证结果,如图2&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1303627/201808/1303627-20180804231238267-749078923.png&quot; alt=&quot;图2&quot;/&gt;&lt;br/&gt;图2&lt;/p&gt;
&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;p&gt;肯定有读者会问，使用自签名证书连接远程桌面，需要客户端安装CA，岂不是很麻烦？&lt;br/&gt;对此问题，一般使用此方法用于开发测试学习，如不想配置WindowsServer证书服务器或OpenCA等，可以直接使用在线服务商的证书，只需把本文相关自建证书省略，即可应用。参考&lt;a href=&quot;http://blog.robiii.nl/2015/10/configure-your-windows-remote-desktop.html&quot;&gt;Configure your Windows Remote Desktop (RDP) to use TLS with a StartSSL certificate&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于ocsp笔者研究的进展&quot;&gt;关于OCSP笔者研究的进展&lt;/h2&gt;
&lt;p&gt;首先修改配置文件&lt;/p&gt;
&lt;pre class=&quot;cacert.crt```为ca证书，因为我们用的是base64形式的证书，所以直接改后缀```*.pem```-&amp;gt;```*.crt```没有任何问题。&quot;&gt;
&lt;code&gt;参考：[那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)](https://www.cnblogs.com/guogangj/p/4118605.html)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;[ v3_req ]&lt;/p&gt;
&lt;p&gt;.....&lt;/p&gt;
&lt;p&gt;authorityInfoAccess = @ocsp_section&lt;/p&gt;
&lt;p&gt;[ ocsp_section ]&lt;br/&gt;caIssuers;URI.0 = http://example.com/cacert.crt&lt;br/&gt;OCSP;URI.0 = http://example.com/&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;其次创建个OCSP服务端 (OCSP Responser)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;openssl ocsp -index ./demoCA/index.txt -CA ./demoCA/cacert.pem -rsigner usercert.pem -rkey userkey.pem -port 8000 -text&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;接着再开一个终端，验证下证书

OCSP Client&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;openssl ocsp -issuer ./demoCA/cacert.pem -url http://example.com:8000 -serial 01 -VAfile usercert.pem&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我们会观察到OCSP工作正常&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Response verify OK&lt;br/&gt;01: good&lt;br/&gt;This Update: Aug 4 09:20:46 2018 GMT&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;然后打开WindowServer，导入相关证书，使用```certutil```检查&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;certutil -url C:\Users...\cacert.crt&lt;br/&gt;&lt;code&gt;选择检索方式为OCSP，点击检索&lt;/code&gt;最终```出现&quot;Invalid Signer EKU&quot;/&quot;无效签名者 EKU&quot;的结果。&lt;br/&gt;笔者猜测毕竟我们自签名证书，服务器无法验证我们的身份吧。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://community.spiceworks.com/topic/2098362-rdp-a-revocation-check-could-not-be-performed-for-the-certificate&quot;&gt;[SOLVED] RDP - A revocation check could not be performed for the certificate - Microsoft Remote Desktop Services - Spiceworks&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://webcache.googleusercontent.com/search?q=cache:http://blog.robiii.nl/2015/10/configure-your-windows-remote-desktop.html&amp;amp;gws_rd=cr&quot;&gt;RobIII: Configure your Windows Remote Desktop (RDP) to use TLS with a StartSSL certificate&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd320345(v=ws.10)&quot;&gt;RDS: RD Gateway must be configured to use an SSL certificate signed by a trusted certification authority | Microsoft Docs&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blogs.technet.microsoft.com/askds/2009/06/24/implementing-an-ocsp-responder-part-i-introducing-ocsp/&quot;&gt;Implementing an OCSP responder: Part I – Introducing OCSP | Ask the Directory Services Team&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://serverfault.com/questions/131983/openssl-how-to-setup-an-ocsp-server-for-checking-third-party-certificates&quot;&gt;OpenSSL: how to setup an OCSP server for checking third-party certificates? - Server Fault&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.51cto.com/zlyux/1744016&quot;&gt;Windows Server 2012 R2 远程桌面安全证书警告-zlyux-51CTO博客&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/tsh185/article/details/8107248&quot;&gt;openssl ocsp - CSDN博客&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.openssl.org/docs/manmaster/man5/x509v3_config.html&quot;&gt;/docs/manmaster/man5/x509v3_config.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/howeverpf/article/details/21622545&quot;&gt;使用OpenSSL工具制作X.509证书的方法及其注意事项总结 - CSDN博客&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.sys4.de/how-create-and-administer-x509-certificate-chains-part-i-en.html&quot;&gt;How to create and administer X.509 Certificate chains, Part I&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://superuser.com/questions/738612/openssl-ca-keyusage-extension&quot;&gt;ssl - OpenSSL CA keyUsage extension - Super User&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;本文采用&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/2.5/cn/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 2.5 中国大陆许可协议&lt;/a&gt;进行许可，发表在&lt;a href=&quot;https://blog.csdn.net/hatmen2&quot;&gt;CSDN&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/chasingdreams2017/&quot;&gt;博客园&lt;/a&gt;，欢迎读者转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接！请读者/爬虫们尊重&lt;code&gt;版权&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 15:21:00 +0000</pubDate>
<dc:creator>ChasingDreams</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chasingdreams2017/p/9420561.html</dc:identifier>
</item>
<item>
<title>Python全栈 MySQL 数据库（SQL命令大全、MySQL 、Python调用） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9420563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9420563.html</guid>
<description>
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;p&gt;为了梦想与了信仰&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt; 开局一张图&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要三个方面：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Linux终端命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.MySQL语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.Python调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先删库 再跑路.....&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;                           终端命令：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;vi                                                                文本编辑器&lt;/p&gt;
&lt;p&gt;cat /etc/password | grep “用户名”         获取user表&lt;/p&gt;

&lt;p&gt;sudo -i                                                       获取root权限&lt;/p&gt;

&lt;p&gt;sudo apt-get install python3-pip             安装pip3&lt;/p&gt;

&lt;p&gt;sudo pip3 install pymysql                        安装mysql&lt;/p&gt;

&lt;p&gt;sudo apt-get install mysql-server            安装服务端&lt;/p&gt;

&lt;p&gt;sudo apt-get install mysql-client             安装客户端&lt;/p&gt;

&lt;p&gt;sudo apt-get update                               读取列表 保存到 /var/lib/apt/lists&lt;/p&gt;

&lt;p&gt;sudo apt-get upgrade                             对比下载列表并更新&lt;/p&gt;

&lt;p&gt;sudo /etc/init.d/mysql status                  查询状态&lt;/p&gt;

&lt;p&gt;sudo /etc/init.d/mysql stop                     停止服务&lt;/p&gt;

&lt;p&gt;sudo /etc/init.d/mysql restart                 重启服务&lt;/p&gt;

&lt;p&gt;sudo /etc/init.d/mysql reload                 重新加载&lt;/p&gt;

&lt;p&gt;mysql -h主机地址 -u用户名 -p密码          链接mysql&lt;/p&gt;



&lt;p&gt;                                                             &lt;strong&gt; 修改mysql默认字符集：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;sudo -i                                                                       1.获取root&lt;/p&gt;

&lt;p&gt;chmod  644 文件名                                                    2.修改文件权限&lt;/p&gt;

&lt;p&gt;cd etc/mysql/mysql.conf.d                                        3.进入配置文目录&lt;/p&gt;

&lt;p&gt;cp etc/msql.cnf/mysqld.cnf.bak                                4.备份&lt;/p&gt;

&lt;p&gt;subl mysqld.cnf                                                         5.vi打开源文件&lt;/p&gt;
&lt;p&gt;[mysqld]  目录&lt;/p&gt;
&lt;p&gt;character_set_server = utf8                                       6.添加命令&lt;/p&gt;
&lt;p&gt;/etc/init.d/mysql&lt;/p&gt;


&lt;p&gt;mysqldump -u用户 -p源库名 &amp;gt; ~/xxx.sql          &lt;strong&gt;   数据备份：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                                                       参数：&lt;/p&gt;
&lt;p&gt;          --all-databases                                                   1.备份所有库&lt;/p&gt;
&lt;p&gt;          库名                                                                     2.备份单个库&lt;/p&gt;
&lt;p&gt;          -B 库1 库2..                                                          3.备份多个库&lt;/p&gt;
&lt;p&gt;          库名 表1 表2...                                                     4.备份指定库指定表&lt;/p&gt;


&lt;p&gt;                                                                           &lt;strong&gt;  数据恢复：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;mysql -uroot -p &amp;lt; 目标库名 xxx.sql                                  1. 恢复备份库&lt;/p&gt;
&lt;p&gt;mysql -uroot -p --one-database 目标库名 &amp;lt; xxx.sql        2. 恢复备份内某一个库&lt;/p&gt;
&lt;p&gt;恢复：表不删除 表记录删除覆盖&lt;/p&gt;



&lt;p&gt;                                                                     &lt;strong&gt; MySQL远程连接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sudo -i                                                               1.管理员模式&lt;/p&gt;
&lt;p&gt;cd /etc/mysql/mysql.conf.d/                             2.cd到mysql目录&lt;/p&gt;
&lt;p&gt;vi mysqld.cnf                                                     3.打开注释掉默认IP&lt;/p&gt;
&lt;p&gt;#bind-address = 127.0.0.1                                4.保存&lt;/p&gt;
&lt;p&gt;/etc/init.d/mysql restart                                    5.重启服务&lt;/p&gt;

&lt;p&gt;                                                                                                                                        &lt;strong&gt;授权用户：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;grant 授权列表 on 库.表 to “用户名“@”%”identified by “密码” with grant option          1.命令格式&lt;/p&gt;
&lt;p&gt;示例：grant all privileges on *.* to &quot;tiger&quot;@&quot;%&quot; identified by &quot;123&quot; with grant option;          2.示例&lt;/p&gt;
&lt;p&gt;all privileges、select、insert ...                              4.库.表: *.*  所有库所有表  3.权限列表&lt;/p&gt;

&lt;p&gt;                                                 &lt;strong&gt; python3模块安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模块名 ：pymysql &lt;/p&gt;
&lt;p&gt;        在线 ：sudo pip3 install pymysql&lt;/p&gt;
&lt;p&gt;离线 ：pymysql-0.7.11.tar.gz&lt;/p&gt;
&lt;p&gt;    $ tar -zxvf pymyql-0.7.11.tar.gz&lt;/p&gt;
&lt;p&gt;    $ cd pymysql-0.7.11&lt;/p&gt;
&lt;p&gt;    $ sudo python3 setup.py install&lt;/p&gt;
&lt;p&gt;        验证：&lt;/p&gt;
&lt;p&gt;            $ python3&lt;/p&gt;
&lt;p&gt;            &amp;gt;&amp;gt;&amp;gt; import pymysql&lt;/p&gt;
&lt;p&gt;            &amp;gt;&amp;gt;&amp;gt; &lt;/p&gt;

&lt;p&gt;                                                 &lt;strong&gt; python2模块安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模块名 ：MySQLdb&lt;/p&gt;
&lt;p&gt;安装 ：sudo pip install mysql-python&lt;/p&gt;


&lt;p&gt;                                                 &lt;strong&gt; sqlalchemy 框架 安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在线 ：sudo pip3 install sqlalchemy&lt;/p&gt;
&lt;p&gt;    离线 ：&lt;/p&gt;
&lt;p&gt;      $ tar -zxvf SQLAlchemy-1.2.10.tar.gz&lt;/p&gt;
&lt;p&gt;      $ cd SQLAlchemy-1.2.10&lt;/p&gt;
&lt;p&gt;      $ sudo python3 setup.py install&lt;/p&gt;
&lt;p&gt;    验证：&lt;/p&gt;
&lt;p&gt;      $ python3&lt;/p&gt;
&lt;p&gt;      &amp;gt;&amp;gt;&amp;gt; import sqlalchemy&lt;/p&gt;
&lt;p&gt;      &amp;gt;&amp;gt;&amp;gt; &lt;/p&gt;

&lt;p&gt;                                                  &lt;strong&gt; pymysql使用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;from pymsql import *                                   导入模块&lt;/p&gt;
&lt;p&gt;(db = pymysql.connect(...))                               1、建立数据库连接&lt;/p&gt;
&lt;p&gt;c = db.cursor())                                                 2、创建游标对象&lt;/p&gt;
&lt;p&gt;c.execute(&quot;insert ....&quot;)                                        3、游标方法: &lt;/p&gt;
&lt;p&gt;db.commit()                                                      4、提交到数据库&lt;/p&gt;
&lt;p&gt;c.close()                                                            5、关闭游标对象&lt;/p&gt;
&lt;p&gt;db.close()                                                         6、断开数据库连接 ：&lt;/p&gt;

&lt;p&gt;                                                                        7.&lt;strong&gt;connect对象：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;db = pymysql.connect(参数列表)&lt;/p&gt;
&lt;p&gt;      1、host ：主机地址,本地 localhost&lt;/p&gt;
&lt;p&gt;      2、port ：端口号,默认3306&lt;/p&gt;
&lt;p&gt;      3、user ：用户名&lt;/p&gt;
&lt;p&gt;      4、password ：密码&lt;/p&gt;
&lt;p&gt;      5、database ：库&lt;/p&gt;
&lt;p&gt;      6、charset ：编码方式,推荐使用 utf8&lt;/p&gt;
&lt;p&gt;                                                                       8.&lt;strong&gt;连接对象的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库连接对象(db)的方法&lt;/p&gt;
&lt;p&gt;      1、db.close() 关闭连接&lt;/p&gt;
&lt;p&gt;      2、db.commit() 提交到数据库执行&lt;/p&gt;
&lt;p&gt;      3、db.rollback() 回滚&lt;/p&gt;
&lt;p&gt;      4、cur = db.cursor() 返回游标对象,用于执行具体SQL命令&lt;/p&gt;
&lt;p&gt;                                                                     9.&lt;strong&gt;游标对象的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;游标对象(cur)的方法&lt;/p&gt;
&lt;p&gt;      1、cur.execute(sql命令,[列表]) 执行SQL命令&lt;/p&gt;
&lt;p&gt;      2、cur.close() 关闭游标对象&lt;/p&gt;
&lt;p&gt;      3、cur.fetchone() 获取查询结果集的第一条数据&lt;/p&gt;
&lt;p&gt;                        ((记录1),)&lt;/p&gt;
&lt;p&gt;      4、cur.fetchmany(n) 获取n条&lt;/p&gt;
&lt;p&gt;                        ((记录1),(记录2))&lt;/p&gt;
&lt;p&gt;      5、cur.fetchall() 获取所有记录&lt;/p&gt;

&lt;p&gt;  &lt;strong&gt;ORM&lt;/strong&gt;：orm(Object Relation Mapping 对象关系映射) 定义：把对象模型映射到MySQL数据库中&lt;/p&gt;



&lt;p&gt;                                           &lt;strong&gt;&lt;span&gt;SQL命令：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;/var/lib/mysql                                                                          MySQL数据目录&lt;/p&gt;

&lt;p&gt;show variables like &quot;autocommit&quot;;                                          查询commit事务&lt;/p&gt;

&lt;p&gt;begin；                                                                                     开启事务&lt;/p&gt;

&lt;p&gt;commit；                                                                                  提交事务（MySQL默认自动提交）&lt;/p&gt;

&lt;p&gt;rollback；                                                                                 终止事务&lt;/p&gt;

&lt;p&gt;system sudo -i                                                                          由数据直接进入终端&lt;/p&gt;

&lt;p&gt;show databases；                                                                    查看已有库&lt;/p&gt;

&lt;p&gt;create database 库名；                                                             创建库&lt;/p&gt;

&lt;p&gt;create database 库名 charcater set utf8；                               指定字符集&lt;/p&gt;

&lt;p&gt;show create database 库名；                                                   查看库字符集&lt;/p&gt;

&lt;p&gt;select database（）；                                                              查看当前所在库&lt;/p&gt;

&lt;p&gt;use 库名；                                                                                切换库&lt;/p&gt;

&lt;p&gt;drop database 库名；                                                              删除库&lt;/p&gt;

&lt;p&gt;show tables；                                                                           查看已有表&lt;/p&gt;

&lt;p&gt;create table 表名（字段名1 数据类型，....）；                           创建表&lt;/p&gt;

&lt;p&gt;show create table 表名；                                                          查看表字符集&lt;/p&gt;

&lt;p&gt;desc 表名；                                                                               查看表结构&lt;/p&gt;

&lt;p&gt;drop table 表名；                                                                      删除表&lt;/p&gt;

&lt;p&gt;insert into 表名 values（值1），（值2）...；                             插入完整记录&lt;/p&gt;

&lt;p&gt;insert into 表名 （字段名1，...） values（值1），...；               插入字段数据&lt;/p&gt;

&lt;p&gt;select * from 表名 [where 条件]；                                             查询所有字段&lt;/p&gt;

&lt;p&gt;select 字段名1，字段名2，...from 表名[where 条件]；                查看字段&lt;/p&gt;

&lt;p&gt;alter table 表名 add 字段名 数据类型;                                        添加字段&lt;/p&gt;

&lt;p&gt;alter table 表名 add 字段名 数据类型 first；                               头插）&lt;/p&gt;

&lt;p&gt;alter table 表名 add 字段名 数据类型 after 字段名；                  指定插入）&lt;/p&gt;

&lt;p&gt;alter table 表名 drop 字段名；                                                   删除字段&lt;/p&gt;

&lt;p&gt;alter table 表名 modify 字段名 新数据类型；                             修改数据类型&lt;/p&gt;

&lt;p&gt;alter table 表名 rename 表名；                                                 表重命名&lt;/p&gt;

&lt;p&gt;delete from 表名 where 条件；                                                 删除表记录（必须加where）&lt;/p&gt;

&lt;p&gt;update 表名 set 字段1=值1，字段名2=值2，... where 条件       更改表记录（必须加where）&lt;/p&gt;

&lt;p&gt;alter table 表名 change 原名 新名 数据类型；                           字段重命名&lt;/p&gt;

&lt;p&gt; create table 表名 select .. from 表名 where 条件;                    复制表（不复制key）&lt;/p&gt;

&lt;p&gt;create table 表名 select * from 表名 where false;                    复制表结构（不复制key）&lt;/p&gt;

&lt;p&gt;sex enum（“M”,&quot;F&quot;,&quot;S&quot;） not null defaulf &quot;S&quot;                       约束&lt;/p&gt;

&lt;p&gt;show variables like 变量名；                                                    查询MySQL变量&lt;/p&gt;

&lt;p&gt;select 字段名列表 from 表名列表;                                              (笛卡尔积)&lt;/p&gt;

&lt;p&gt;select t1.name,t2.name from t1,t2 where 条件                        多表查询   &lt;/p&gt;

&lt;p&gt;create index 索引名 on 表名(字段名);                                         添加普通索引&lt;/p&gt;

&lt;p&gt;create table（....index（字段名），...）                                      创建表时创建普通索引&lt;/p&gt;

&lt;p&gt;drop index 索引名 on 表名；                                                      删除普通索引&lt;/p&gt;

&lt;p&gt;show index from 表名；                                                            查看普通索引&lt;/p&gt;

&lt;p&gt;create unique index 索引名 on表名（字段名）；                       添加唯一索引&lt;/p&gt;

&lt;p&gt;create table 表名( .... , unique key (字段名) );                             创建表时创建唯一索引&lt;/p&gt;

&lt;p&gt;drop unique index 索引名 on 表名；                                         删除唯一索引&lt;/p&gt;

&lt;p&gt;show unique index from 表名；                                                查看唯一索引&lt;/p&gt;

&lt;p&gt;alter table 表名 add primary key（字段名）；                           添加主键索引&lt;/p&gt;

&lt;p&gt;create table 表名( .... , id int， primary key (字段名) );                创建表时创主键一索引&lt;/p&gt;

&lt;p&gt;(id int primary key auto_increment,)auto_increment=10000;    设置自增长起始值&lt;/p&gt;

&lt;p&gt;alter table 表名 modify id int auto_increment;                            添加自增长&lt;/p&gt;

&lt;p&gt;alter table 表名 auto_increment=20000;                                     修改自增长起始值&lt;/p&gt;

&lt;p&gt;alter table 表名 modify id int;                                                       删除自增长&lt;/p&gt;

&lt;p&gt;alter table 表名 drop primary key;                                                删除主键索引&lt;/p&gt;

&lt;p&gt;show index from 表名\G;                                                             查看表索引&lt;/p&gt;

&lt;p&gt;desc 表名；                                                                                查看表结构（key）&lt;/p&gt;

&lt;p&gt;Non_Unique：1   ：index                                                         普通索引（查询结果）&lt;/p&gt;

&lt;p&gt;Non_Unique：0   ：unique                                                        唯一索引（查询结果）&lt;/p&gt;

&lt;p&gt;alter table 表名 drop foreign key 外键名;                                    删除外键&lt;/p&gt;

&lt;p&gt;show create table 表名;                                                                 查看外键名&lt;/p&gt;

&lt;p&gt;                                                                   &lt;strong&gt;  创建外键：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;create......t1（）；&lt;/p&gt;
&lt;p&gt;create table t2（&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;foreign key(参考字段名)&lt;/p&gt;
&lt;p&gt;references 主表(被参考字段名)&lt;/p&gt;
&lt;p&gt;on delete 级联动作&lt;/p&gt;
&lt;p&gt;on update 级联动作）； &lt;/p&gt;
&lt;p&gt;                                                                    &lt;strong&gt; 添加外键：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;alter table 表名 add &lt;/p&gt;
&lt;p&gt;foreign key(参考字段) references 主表(被参考字段)&lt;/p&gt;
&lt;p&gt;on delete ...&lt;/p&gt;
&lt;p&gt;on update ...&lt;/p&gt;
&lt;p&gt;                                                                     &lt;strong&gt;级联动作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;restrict(默认)不允许主表操作从表&lt;/p&gt;
&lt;p&gt;cascade ：跟随删除、更新&lt;/p&gt;
&lt;p&gt;set null：主表更改后从表值为NULL&lt;/p&gt;

&lt;p&gt;                                                                 &lt;strong&gt;    内链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;select 字段名 from表1 &lt;/p&gt;
&lt;p&gt;inner join 表2 on 条件&lt;/p&gt;
&lt;p&gt;inner join 表3 on 条件...；&lt;/p&gt;

&lt;p&gt;                                                                  &lt;strong&gt;   外链接.左链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以左表为主显示查询结果&lt;/p&gt;
&lt;p&gt;         select 字段名 from 表1 &lt;/p&gt;
&lt;p&gt;         left join 表2 on 条件&lt;/p&gt;
&lt;p&gt;         left join 表3 on 条件...；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;右链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        以右表为主显示查询结果&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                                                                     数据导入：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;load data  infile “文件名”&lt;/p&gt;
&lt;p&gt;into table 表名&lt;/p&gt;
&lt;p&gt;fields terminated by “分隔符”&lt;/p&gt;
&lt;p&gt;lines terminated by “\n”；&lt;/p&gt;

&lt;p&gt;                                                                 &lt;strong&gt;    数据导出：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;select ... from 表名&lt;/p&gt;
&lt;p&gt;into outfile “/var/lib/mysql-files/文件名”&lt;/p&gt;
&lt;p&gt;fields terminated by “分隔符”&lt;/p&gt;
&lt;p&gt;lines terminated by “\n”;&lt;/p&gt;

&lt;p&gt;                                                                   &lt;strong&gt;  数据恢复：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;恢复单个库&lt;/p&gt;
&lt;p&gt;     mysql -uroot -p &amp;lt; 目标库名 xxx.sql&lt;/p&gt;
&lt;p&gt;从所有库备份中恢复某一个库（-one-database）&lt;/p&gt;
&lt;p&gt;     mysql -uroot -p --one-database 目标库名 &amp;lt; xxx.sql&lt;/p&gt;
&lt;p&gt;恢复：表不删除 表记录删除覆盖&lt;/p&gt;

&lt;p&gt;                                                                    &lt;strong&gt; 数据备份：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysqldump -u用户 -p源库名 &amp;gt; ~/xxx.sql&lt;/p&gt;
&lt;p&gt;--all-databases  备份所有库&lt;/p&gt;
&lt;p&gt;库名             备份单个库&lt;/p&gt;
&lt;p&gt;-B 库1 库2..     备份多个库&lt;/p&gt;
&lt;p&gt;库名 表1 表2...  备份指定库指定表&lt;/p&gt;


&lt;p&gt;运行时间检测：&lt;/p&gt;
&lt;p&gt;   开启：set profiling=1；&lt;/p&gt;
&lt;p&gt;   关闭：set profiling=0；&lt;/p&gt;
&lt;p&gt;   查询执行记录：show profilings；&lt;/p&gt;



&lt;p&gt;                     &lt;strong&gt;&lt;span&gt; SQL查询：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3.select ... 聚合函数 from 表名&lt;/p&gt;
&lt;p&gt;1.where&lt;/p&gt;
&lt;p&gt;2.group by...&lt;/p&gt;
&lt;p&gt;4.having ...&lt;/p&gt;
&lt;p&gt;5.order by ...&lt;/p&gt;
&lt;p&gt;6.limit ...；&lt;/p&gt;

&lt;p&gt;select ... from 表名 where 条件(select ....);                         &lt;strong&gt;查询嵌套：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    2、找出每个国家攻击力最高的英雄的名字和攻击值&lt;/p&gt;
&lt;p&gt;       select name,gongji from sanguo&lt;/p&gt;
&lt;p&gt;       where &lt;/p&gt;
&lt;p&gt;       (country,gongji) in&lt;/p&gt;
&lt;p&gt;       (select country,max(gongji) from sanguo group by country);&lt;/p&gt;

&lt;p&gt;where：只能操作表中实际存在的字段&lt;/p&gt;
&lt;p&gt;group by：给查询结果进行分组&lt;/p&gt;
&lt;p&gt;having：对查询结果进一步筛选&lt;/p&gt;
&lt;p&gt;distinct：不显示字段重复值&lt;/p&gt;


&lt;p&gt;show engines;                                                                   查看所有存储引擎&lt;/p&gt;
&lt;p&gt;show create table 表名;                                                     查看表的存储引擎&lt;/p&gt;
&lt;p&gt;create table 表名(...)engine=myisam;                                创建表时指定存储引擎&lt;/p&gt;
&lt;p&gt;alter table 表名 engine=innodb;                                       添加储存引擎&lt;/p&gt;

&lt;p&gt;                                                                                         &lt;strong&gt; InnoDB：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InnoDB特点（2文件）：&lt;/p&gt;
&lt;p&gt;      行级锁、支持外键、事务操作&lt;/p&gt;
&lt;p&gt;      .frm（表结构，索引）、.ibd（表记录）&lt;/p&gt;

&lt;p&gt;MyISAM特点（3文件）：                                                  &lt;strong&gt;MyISAM：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      独享表空间、表级锁&lt;/p&gt;
&lt;p&gt;      .frm（结构）、.myd（记录）、.myi（索引）&lt;/p&gt;

&lt;p&gt;                                                                                              &lt;strong&gt;锁：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;select ：加读锁之后别人不能更改表记录,但可以进行查询&lt;/p&gt;
&lt;p&gt;insert、delete、update ：加写锁之后别人不能查、不能改&lt;/p&gt;
&lt;p&gt;锁粒度：&lt;/p&gt;
&lt;p&gt;     表级锁 ：myisam&lt;/p&gt;
&lt;p&gt;     行级锁 ：innodb&lt;/p&gt;

&lt;p&gt;                                                                                         &lt;strong&gt;   调优：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.选择合适的存储引擎&lt;/p&gt;
&lt;p&gt;2.常用字段建立索引&lt;/p&gt;
&lt;p&gt;3.where 避免使用 !=、NULL判断、or链接、&lt;/p&gt;
&lt;p&gt;   like前置%、in、not in、*代替字段、&lt;/p&gt;


&lt;p&gt;                 &lt;strong&gt;      &lt;span&gt; 数据类型:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;数据类型:&lt;/p&gt;

&lt;p&gt;int             大整型（4个字节）  2**32 - 1（4294967295）&lt;/p&gt;

&lt;p&gt;tinyint         微小整型（一个字节） &lt;/p&gt;
&lt;p&gt;                有符号（signed默认）：-128 ~ 127&lt;/p&gt;
&lt;p&gt;                无符号（unsigned）：0 ~ 255&lt;/p&gt;

&lt;p&gt;smallint        小整型（2字节）&lt;/p&gt;
&lt;p&gt;bigint          极大整型（8字节）&lt;/p&gt;
&lt;p&gt;float           浮点数（4个字节，7个有效位）&lt;/p&gt;
&lt;p&gt;       字段名 float（m，n） m：总位数 n：小数位数&lt;/p&gt;
&lt;p&gt;decimal         浮点数（28个有效位）&lt;/p&gt;
&lt;p&gt;      字段名 decimal（m，n）m：总位数 n：小数位数&lt;/p&gt;
&lt;p&gt;            将9的倍数包装成4个字节&lt;/p&gt;
&lt;p&gt;      余数   字节&lt;/p&gt;
&lt;p&gt;        0      0&lt;/p&gt;
&lt;p&gt;       1-2     1&lt;/p&gt;
&lt;p&gt;       3-4     2&lt;/p&gt;
&lt;p&gt;       5-6     3&lt;/p&gt;
&lt;p&gt;       7-9     4&lt;/p&gt;

&lt;p&gt;字段名 enum（值1，值2...）；               单选（enum）&lt;/p&gt;

&lt;p&gt;字段名 set（值1，值2...）；                多选（set）&lt;/p&gt;
&lt;p&gt;    （多项放在一个字符串内用，号隔开）&lt;/p&gt;

&lt;p&gt;date：“YYYY-MM-DD”&lt;/p&gt;
&lt;p&gt;time：“HH：MM：SS”&lt;/p&gt;
&lt;p&gt;datetime：“YYYY-MM-DD HH：MM：SS”&lt;/p&gt;
&lt;p&gt;timestamp：“YYYY-MM-DD HH：MM：SS”&lt;/p&gt;
&lt;p&gt;datetime：不给值默认返回Null&lt;/p&gt;
&lt;p&gt;timestamp：不给值默认返回系统时间&lt;/p&gt;

&lt;p&gt;时间函数&lt;/p&gt;
&lt;p&gt;now（）                                                          返回服务器当前的时间&lt;/p&gt;
&lt;p&gt;curdate（）                                                    返回当前时期&lt;/p&gt;
&lt;p&gt;curtime（）                                                    返回当前日期&lt;/p&gt;
&lt;p&gt;year（date）                                                  返回指定时间的年份&lt;/p&gt;
&lt;p&gt;date（date）                                                  返回指定时间的日期&lt;/p&gt;
&lt;p&gt;time（date）                                                  返回指定时间的时间&lt;/p&gt;

&lt;p&gt;聚合函数&lt;/p&gt;
&lt;p&gt;avg（字段名）：求该字段的平均值&lt;/p&gt;
&lt;p&gt;sum（字段名）：求和&lt;/p&gt;
&lt;p&gt;max（字段名）：最大值&lt;/p&gt;
&lt;p&gt;min（字段名）：最小值&lt;/p&gt;
&lt;p&gt;count（字段名）：统计该字段的个数&lt;/p&gt;


&lt;p&gt;运算符：+ - * / %&lt;/p&gt;

&lt;p&gt;时间运算符&lt;/p&gt;
&lt;p&gt;select * from 表名&lt;/p&gt;
&lt;p&gt;where 字段名 运算符（时间-interval 时间间隔单位）；&lt;/p&gt;
&lt;p&gt;时间间隔单位：1 day | 2hour | 1 minute | 2year | month&lt;/p&gt;

&lt;p&gt;数值比较： =  !=  &amp;gt;  &amp;gt;= &amp;lt; &amp;lt;=&lt;/p&gt;
&lt;p&gt;字符比较： =  !=&lt;/p&gt;
&lt;p&gt;逻辑比较： and   or&lt;/p&gt;
&lt;p&gt;范围内比较：&lt;/p&gt;
&lt;p&gt;      1.where 字段名 between 值1 and 值2&lt;/p&gt;
&lt;p&gt;      2.where 字段名 in（值1，值2，....）&lt;/p&gt;
&lt;p&gt;      3.where 字段名 not in （值1，值2，...）&lt;/p&gt;
&lt;p&gt;空：where name is null&lt;/p&gt;
&lt;p&gt;非空：where name is not null&lt;/p&gt;
&lt;p&gt;NILL：空值，只能用is或is not取匹配&lt;/p&gt;
&lt;p&gt;“” ： 空字符串，用 = 或  != 去匹配&lt;/p&gt;
&lt;p&gt;模糊比较：&lt;/p&gt;
&lt;p&gt;     where 字段名 like 表达式&lt;/p&gt;
&lt;p&gt;     表达式&lt;/p&gt;
&lt;p&gt;        _ : 匹配单个字符&lt;/p&gt;
&lt;p&gt;       %：匹配0到多个字符&lt;/p&gt;
&lt;p&gt;        NULL不会被统计&lt;/p&gt;

&lt;p&gt;排序：order by ASC | DESC&lt;/p&gt;
&lt;p&gt;显示： limit 开始显示位置，条数   &lt;/p&gt;
&lt;p&gt;     每页显示n条记录，显示第m页：&lt;/p&gt;
&lt;p&gt;     limit（m-1）*n，n&lt;/p&gt;


&lt;p&gt;                     &lt;strong&gt;&lt;span&gt;   MySQL 与 Python 交互&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;29&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# mysqlpython.py

# 导入mysql模块
from pymysql import *


class MysqlPython:
    def __init__(self, database,  # 库
                 host=&quot;127.0.0.1&quot;,  # ip地址
                 user=&quot;root&quot;,  # 用户名
                 password=&quot;123456&quot;,  # 密码
                 port=3306,  # 端口
                 charset=&quot;utf8&quot;):  # 字符集
        self.host = host
        self.database = database
        self.user = user
        self.password = password
        self.port = port
        self.charset = charset

    def open(self):  # 创建数据库链接函数
        self.db = connect(host=self.host,
                          database=self.database,
                          user=self.user,
                          password=self.password,
                          port=self.port,
                          charset=self.charset)
        self.cur = self.db.cursor()  # 创建游标对象

    def close(self):  # 创建断开数据库链接　关闭游标函数
        self.cur.close()
        self.db.close()

    def zhixing(self, sql, L=[]):  # 创建pymysql.execute() 方法函数
        try:
            self.open()  # 链接数据库
            self.cur.execute(sql, L)  # 参数化执行ＳＱＬ命令
            self.db.commit()  # 提交数据
            print(&quot;ok&quot;)
        except Exception as e:
            self.db.rollback()  # 出错取消提交
            print(&quot;Failed&quot;, e)
        self.close()  # 断开数据库链接　关闭游标

    def all(self, sql, L=[]):
        try:
            self.open()
            self.cur.execute(sql, L)
            result = self.cur.fetchall()
            return result
        except Exception as e:
            print(&quot;Failed&quot;, e)
        self.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;数据库用户登录&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;div readability=&quot;13&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from mysqlpython import Mysqlpython
from hashlib import sha1

uname = input(&quot;请输入用户名:&quot;)
pwd = input(&quot;请输入密码:&quot;)
# 用sha1给pwd加密

s1 = sha1()  # 创建sha1加密对象
s1.update(pwd.encode(&quot;utf8&quot;))  # 指定编码
pwd2 = s1.hexdigest()  # 返回16进制加密结果

sqlh = Mysqlpython(&quot;db4&quot;)
select = &quot;select password from user where \
          username=%s;&quot;
result = sqlh.all(select, [uname])
# print(result)
# (('7c4a8d09ca3762af61e59520943dc26494f8941b',),)

if len(result) == 0:
    print(&quot;用户名不存在&quot;)
elif result[0][0] == pwd2:
    print(&quot;登录成功&quot;)
else:
    print(&quot;密码错误&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ORM  sqlalchemy框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 创建一张表

# 连接数据库的模块
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String

engine = create_engine(&quot;mysql+pymysql://root:123456@localhost/db4&quot;, encoding=&quot;utf8&quot;)
Base = declarative_base()  # orm基类

class User(Base):  # 继承Base基类
    __tablename__ = &quot;t123&quot;
    id = Column(Integer, primary_key=True)
    name = Column(String(20))
    address = Column(String(40))

Base.metadata.create_all(engine)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 04 Aug 2018 15:15:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9420563.html</dc:identifier>
</item>
<item>
<title>在多线程中使用静态方法是否有线程安全问题 - 李志章</title>
<link>http://www.cnblogs.com/lizhizhang/p/9420403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lizhizhang/p/9420403.html</guid>
<description>&lt;p&gt;　类的成员分为两类，静态成员（static member）和实例成员(instance member)。静态成员属于类，实例成员则属于对象，即类的实例。&lt;/p&gt;
&lt;p&gt;    简单讨论一下在一个类中使用静态字段(static field)和静态方法(static method)是否会有线程安全问题。 &lt;/p&gt;
&lt;p&gt;    我们在知道, 静态字段(static field)和静态方法(static method)的调用是通过类来调用。静态方法不对特定的实例操作，只能访问静态成员。实例方法可对特定的实例操作，既能访问静态成员，也能访问实例成员。&lt;/p&gt;
&lt;p&gt;    那么,在多线程中使用静态方法是否有线程安全问题?这要看静态方法是是引起线程安全问题要看在静态方法中是否使用了静态成员。&lt;/p&gt;&lt;p&gt;    因为，在多线程中使用同一个静态方法时，每个线程使用各自的实例字段(instance field)的副本，而共享一个静态字段(static field)。所以说，如果该静态方法不去操作一个静态成员，只在方法内部使用实例字段(instance field)，不会引起安全性问题。但是，如果该静态方法操作了一个静态字段，则需要静态方法中采用互斥访问的方式进行安全处理。&lt;br/&gt;    &lt;br/&gt;    举个简单的例子，我们使用的Console.WriteLine();中WriteLine()是Console.WriteLine类的静态方法。&lt;/p&gt;&lt;p&gt;     对于ASP.NET, 多个客户端访问服务器端, 这是一个多线程的例子.只要理解了原因,我们可以在三层架构中的数据访问层中放心使用静态方法(static method)来访问数据库.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;先看一个类:&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String hello(String str)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;        String tmp = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;        tmp = tmp +&lt;span&gt; str;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hello方法会不会有多线程安全问题呢？没有！&lt;/p&gt;
&lt;p&gt;静态方法如果没有使用静态变量，则没有线程安全问题。&lt;br/&gt;为什么呢？因为静态方法内声明的变量，每个线程调用时，都会新创建一份，而不会共用一个存储单元。比如这里的tmp,每个线程都会创建自己的一份，因此不会有线程安全问题。&lt;br/&gt;注意:静态变量，由于是在类加载时占用一个存储区，每个线程都是共用这个存储区的，所以如果在静态方法里使用了静态变量，这就会有线程安全问题！&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 14:20:00 +0000</pubDate>
<dc:creator>李志章</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lizhizhang/p/9420403.html</dc:identifier>
</item>
<item>
<title>讲讲网络模块中加解密那点儿事--AES+BASE64 - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/9419877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/9419877.html</guid>
<description>&lt;p&gt;这次想来讲讲网络安全通信这一块，也就是网络层封装的那一套加密、解密，编码、解码的规则，不会很深入，但会大概将这一整块的讲一讲。&lt;/p&gt;
&lt;p&gt;之所以想写这篇，是因为，最近被抽过去帮忙做一个 C++ 项目，在 Android 中，各种编解码、加解密算法官方都已经封装好了，我们要使用非常的方便，但在 C++ 项目中很多都要自己写。&lt;/p&gt;
&lt;p&gt;然而，自己写是不可能的了，没这么牛逼也没这么多时间去研究这些算法，网上自然不缺少别人写好的现成算法。但不同项目应用场景自然不一样，一般来说，都需要对其进行修修改改才能拿到项目中来用。&lt;/p&gt;
&lt;p&gt;踩的坑实在有点儿多，所以想写一篇来总结一下。好了，废话结束，开始正文。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q1: 你的 app 与后台各接口通信时有做身份校验吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2: 你的 app 与后台各接口通信的数据有涉及敏感数据吗？你是如何处理的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q3: MD5 了解过吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q4: AES(16位密钥 + CBC + PKCS5Padding) 呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q5: BASE64 呢？或者 UTF-8?&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;身份校验----md5-算法&quot;&gt;身份校验 -- MD5 算法&lt;/h3&gt;
&lt;p&gt;第一点：&lt;strong&gt;为什么需要身份校验？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;身份校验是做什么，其实也就是校验访问接口的用户合法性。说得白一点，也就是要过滤掉那些通过脚本或其他非正常 app 发起的访问请求。&lt;/p&gt;
&lt;p&gt;试想一下，如果有人破解了服务端某个接口，然后写个脚本，模拟接口所需的各种参数，这样它就可以伪装成正常用户从这个接口拿到他想要的数据了。&lt;/p&gt;
&lt;p&gt;更严重点的是，如果他想图摸不轨，向服务端发送了一堆伪造的数据，如果这些数据会对服务端造成损失怎么办。&lt;/p&gt;
&lt;p&gt;所以，基本上服务端的接口都会有身份校验机制，来检测访问的对象是否合法。&lt;/p&gt;
&lt;p&gt;第二点：&lt;strong&gt;MD5 算法是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通俗的讲，MD5 算法能对一串输入生成一串唯一的不可逆的 128 bit 的 0 和 1 的二进制串信息。&lt;/p&gt;
&lt;p&gt;通常 app 都会在发起请求前根据自己公司所定义的规则做一次 MD5 计算，作为 token 发送给服务端进行校验。&lt;/p&gt;
&lt;p&gt;MD5 有两个特性：唯一性和不可逆性。&lt;/p&gt;
&lt;p&gt;唯一性可以达到防止输入被篡改的目的，因为一旦第三方攻击者劫持了这个请求，篡改了携带的参数，那么服务端只要再次对这些输入做一次 MD5 运算，比较计算的结果与 app 上传的 token 即可检测出输入是否有被修改。&lt;/p&gt;
&lt;p&gt;不可逆的特点，则是就算第三方攻击者劫持了这次请求，看到了携带的参数，以及 MD5 计算后的 token，那么他也无法从这串 token 反推出我们计算 MD5 的规则，自然也就无法伪造新的 token，那么也就无法通过服务端的校验了。&lt;/p&gt;
&lt;p&gt;第三点：&lt;strong&gt;理解 16 位和 32 位 MD5 值的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网上有很多在线进行 MD5 计算的工具，如 &lt;a href=&quot;http://www.cmd5.com/&quot; class=&quot;uri&quot;&gt;http://www.cmd5.com/&lt;/a&gt;，这里演示一下，尝试一下分别输入：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;I am dasu&lt;/code&gt; 和 &lt;code&gt;I'm dasu&lt;/code&gt; 看一下经过 MD5 运算后的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-66628f61bc02489e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MD5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-03059a86616e8391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MD5_.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先确认一点，不同的输入，输出就会不一样，即使只做了细微修改，两者输出仍旧毫无规律而言。&lt;/p&gt;
&lt;p&gt;另外，因为经过 MD5 计算后输出是 128 bit 的 0 和 1 二进制串，但通常都是用十六进制来表示比较友好，1个十六进制是 4 个 bit，128 / 4 = 32，所以常说的 32 位的 MD5 指的是用十六进制来表示的输出串。&lt;/p&gt;
&lt;p&gt;那么，为什么还会有 16 位的 MD5 值？其实也就是嫌 32 位的数据太长了，所以去掉开头 8 位，末尾 8 位，截取中间的 16 位来作为 MD5 的输出值。&lt;/p&gt;
&lt;p&gt;所以，MD5 算法的输出只有一种：128 bit 的二进制串，而通常结果都用十六进制表示而已，32 位与 16 位的只是精度的区别而已。&lt;/p&gt;
&lt;p&gt;第四点：&lt;strong&gt;MD5 的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用场景很多：数字签名、身份校验、完整性（一致性）校验等等。&lt;/p&gt;
&lt;p&gt;这里来讲讲 app 和服务端接口访问通过 MD5 来达到身份校验的场景。&lt;/p&gt;
&lt;p&gt;app 持有一串密钥，这串密钥服务端也持有，除此外别人都不知道，因此 app 就可以跟服务端协商，两边统一下交互的时候都有哪些数据是需要加入 MD5 计算的，以怎样的规则拼接进行 MD5 运算的，这样一旦这些数据被三方攻击者篡改了，也能检查出来。&lt;/p&gt;
&lt;p&gt;也就是说，密钥和拼接规则都是关键点，不可以泄漏出去。&lt;/p&gt;
&lt;h3 id=&quot;敏感数据加密----aes-base64&quot;&gt;敏感数据加密 -- AES + BASE64&lt;/h3&gt;
&lt;p&gt;MD5 只能达到校验的目的，而 app 与服务端交互时，数据都是在网络中传输的，这些请求如果被三方劫持了，那么如果交互的数据里有一些敏感信息，就会遭到泄漏，存在安全问题。&lt;/p&gt;
&lt;p&gt;当然，如果你的 app 与服务端的交互都是 HTTPS 协议了的话，那么自然就是安全的，别人抓不到包，也看不到信息。&lt;/p&gt;
&lt;p&gt;如果还是基于 HTTP 协议的话，那么有很多工具都可以劫持到这个 HTTP 包，app 与服务端交互的信息就这样赤裸裸的展示在别人面前。&lt;/p&gt;
&lt;p&gt;所以，通常一些敏感信息都会经过加密后再发送，接收方拿到数据后再进行解密即可。&lt;/p&gt;
&lt;p&gt;而加解密的世界很复杂，对称加密、非对称加密，每一种类型的加解密算法又有很多种，不展开了，因为实在展开不了，我门槛都没踏进去，实在没去深入学习过，目前只大概知道个流程原理，会用的程度。&lt;/p&gt;
&lt;p&gt;那么，本篇就介绍一种网上很常见的一整套加解密、编解码流程：&lt;/p&gt;
&lt;h4 id=&quot;utf-8-aes-base64&quot;&gt;UTF-8 + AES + BASE64&lt;/h4&gt;
&lt;p&gt;UTF-8 和 BASE64 都属于编解码，AES 属于对称加密算法。&lt;/p&gt;
&lt;p&gt;信息其实本质上是由二进制串组成，通过各种不同的编码格式，来将这段二进制串信息解析成具体的数据。比如 ASCII 编码定义了一套标准的英文、常见符号、数字的编码；UTF-8 则是支持中文的编码。目前大部分的 app 所使用的数据都是基于 UTF-8 格式的编码的吧。&lt;/p&gt;
&lt;p&gt;AES 属于对称加密算法，对称的意思是说，加密方和解密方用的是同一串密钥。信息经过加密后会变成一串毫无规律的二进制串，此时再选择一种编码方式来展示，通常是 BASE64 格式的编码。&lt;/p&gt;
&lt;p&gt;BASE64 编码是将所有信息都编码成只用大小写字母、0-9数字以及 + 和 / 64个字符表示，所有称作 BASE64。&lt;/p&gt;
&lt;p&gt;不同的编码所应用的场景不同，比如 UTF-8 倾向于在终端上呈现各种复杂字符包括简体、繁体中文、日文、韩文等等数据时所使用的一种编码格式。而 BASE64 编码通常用于在网络中传输较长的信息时所使用的一种编码格式。&lt;/p&gt;
&lt;p&gt;基于以上种种，目前较为常见的 app 与服务端交互的一套加解密、编解码流程就是：UTF-8 + AES + BASE64&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-e12adc004153766d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;加解密流程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图就是从 app 端发数据给服务端的一个加解密、编解码过程。&lt;/p&gt;
&lt;p&gt;需要注意的是，因为 AES 加解密时输入和输出都是二进制串的信息，因此，在发送时需先将明文通过 UTF-8 解码成二进制串，然后进行加密，再对这串二进制密文通过 BASE64 编码成密文串发送给接收方。&lt;/p&gt;
&lt;p&gt;接收方的流程就是反着来一遍就对了。&lt;/p&gt;

&lt;p&gt;理论上基本清楚了，那么接下去就是代码实现了，Android 项目中要实现很简单，因为 JDK 和 SDK 中都已经将这些算法封装好了，直接调用 api 接口就可以了。&lt;/p&gt;
&lt;h3 id=&quot;java&quot;&gt;Java&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EncryptDecryptUtils {
    private static final String ENCODE = &quot;UTF-8&quot;;
    //AES算法加解密模式有多种，这里选择 CBC + PKCS5Padding 模式，CBC 需要一个AES_IV偏移量参数，而AES_KEY 是密钥。当然，这里都是随便写的，这些信息很关键，不宜泄露
    private static final String AES = &quot;AES&quot;;
    private static final String AES_IV = &quot;aaaaaaaaaaaaaaaa&quot;;
    private static final String AES_KEY = &quot;1111111111111111&quot;;//16字节，128bit，三种密钥长度中的一种
    private static final String CIPHER_ALGORITHM = &quot;AES/CBC/PKCS5Padding&quot;;

    /**
    * AES加密后再Base64编码，输出密文。注意AES加密的输入是二进制串，所以需要先将UTF-8明文转成二进制串
    */
    public static String doEncryptEncode(String content) throws Exception {
        SecretKeySpec secretKeySpec = new SecretKeySpec(AES_KEY.getBytes(ENCODE), AES);
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, new IvParameterSpec(AES_IV.getBytes(ENCODE)));
        //1. 先获取二进制串，再进行AES（CBC+PKCS5Padding)模式加密
        byte[] result = cipher.doFinal(content.getBytes(ENCODE));
        //2. 将二进制串编码成BASE64串
        return Base64.encodeToString(result, Base64.NO_WRAP);
    }

    /**
    * Base64解码后再进行AES解密，最后对二进制明文串进行UTF-8编码输出明文串
    */
    public static String doDecodeDecrypt(String content) throws Exception {
        SecretKeySpec secretKeySpec = new SecretKeySpec(AES_KEY.getBytes(ENCODE), AES);
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, new IvParameterSpec(AES_IV.getBytes(ENCODE)));
        //1. 先将BASE64密文串解码成二进制串
        byte[] base64 = Base64.decode(content, Base64.NO_WRAP);
        //2. 再将二进制密文串进行AES(CBC+PKCS5Padding)模式解密
        byte[] result = cipher.doFinal(base64);
        //3. 最后将二进制的明文串以UTF-8格式编码成字符串后输出
        return new String(result, Charset.forName(ENCODE)); 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java 的实现代码是不是很简单，具体算法的实现都已经封装好了，就是调一调 api 的事。&lt;/p&gt;
&lt;p&gt;这里需要稍微知道下，AES 加解密模式分很多种，首先，它有三种密钥形式，分别是 128 bit，192 bit，256 bit，注意是 bit，Java 中的字符串每一位是 1B = 8 bit，所以上面例子中密钥长度是 16 位的字符串。&lt;/p&gt;
&lt;p&gt;除了密钥外，AES 还分四种模式的加解密算法：ECB，CBC，CFB，OFB，这涉及到具体算法，我也不懂，就不介绍了，清楚上面是使用了 CBC 模式就可以了。&lt;/p&gt;
&lt;p&gt;最后一点，使用 CBC 模式进行加密时，是对明文串进行分组加密的，每组的大小都一样，因此在分组时就有可能会存在最后一组的数量不够的情况，那么这时就需要进行填充，而这个填充的概念就是 PKCS5Padding 和 PKCS7Padding 两种。&lt;/p&gt;
&lt;p&gt;这两种的填充规则都一样，具体可看其他的文章，区别只在于分组时规定的每组的大小。在PKCS5Padding中，明确定义 Block 的大小是 8 位，而在 PKCS7Padding 定义中，对于块的大小是不确定的，可以在 1-255 之间。&lt;/p&gt;
&lt;p&gt;稍微了解下这些就够了，如果你不继续往下研究 C++ 的写法，这些不了解也没事，会用就行。&lt;/p&gt;
&lt;h3 id=&quot;c&quot;&gt;C++&lt;/h3&gt;
&lt;p&gt;c++ 坑爹的地方就在于，这整个流程，包括 UTF-8 编解码、AES 加解密、BASE64 编解码都得自己写。&lt;/p&gt;
&lt;p&gt;当然，不可能自己写了，网上轮子那么多了，但问题就在于，因为 AES 加解密模式太多了，网上的资料大部分都只是针对其中一种进行介绍，因此，如果不稍微了解一下相关原理的话，就无从下手进行修改了。&lt;/p&gt;
&lt;p&gt;我这篇，自然也只是介绍我所使用的模式，如果你刚好跟我一样，那也许可以帮到你，如果跟你不一样，至少我列出了资料的来源，整篇下来也稍微讲了一些基础性的原理，掌握这些，做点儿修修补补应该是可以的。&lt;/p&gt;
&lt;p&gt;贴代码前，先将我所使用的模式列出来：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTF-8 + AES(16位密钥 + CBC + PKCS5Padding) + BASE64&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实这些都类似于工具类，官方库没提供，那网上找个轮子就好了，都是一个 h 和 cpp 文件而已，复制粘贴下就可以了。重点在于准备好了这些工具类后，怎么用，怎么稍微修改。&lt;/p&gt;
&lt;p&gt;如果你不想自己网上找，那下面我已经将相关链接都贴出来了，去复制粘贴下就可以了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yinshi_blog/article/details/6731809&quot;&gt;c++ string、UTF8相互转换方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/csdn49532/article/details/50686222&quot;&gt;C++使用AES+Base64算法对文本进行加密&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我最开始就是拿的第二篇来用的，然后才发现他所采用的模式是：AES(16位密钥 + CBC + PKCS7Padding) + BASE64&lt;/p&gt;
&lt;p&gt;也就是说，他的例子中不支持中文的加解密，而且填充模式采用的是 PKCS7Padding，跟我的不一致。一开始我也不了解相关原理基础，怎么调都调不出结果，无奈只能先去学习下原理基础。&lt;/p&gt;
&lt;p&gt;还好后面慢慢的理解了，也懂得该改哪些地方，也增加了 UTF-8 编解码的处理。下面贴的代码中注释会写得很清楚，整篇看下来，我相信，就算你模式跟我的也不一样，你的密钥是24位的、32位的，没关系，稍微改一改就可以了。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//EncryptDecryptUtils.h
#pragma once
#include &amp;lt;string&amp;gt;

using namespace std;

#ifndef AES_INFO
#define AES_INFO

#define AES_KEY &quot;1111111111111111&quot;  //AES 16B的密钥
#define AES_IV &quot;aaaaaaaaaaaaaaaa&quot; //AES CBC加解密模式所需的偏移量

#endif 

class EncryptDecryptUtils {
public:
    //解码解密
    static string doDecodeDecrypt(string content);
    //加密编码
    static string doEncryptEncode(string content);
    EncryptDecryptUtils();
    ~EncryptDecryptUtils();
private:
    //去除字符串中的空格、换行符
    static string removeSpace(string content);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下才是具体实现，其中在头部 include 的 AES.h，Base64.h，UTF8.h 需要先从上面给的博客链接中将相关代码复制粘贴过来。这些文件基本都是作为工具类使用，不需要进行改动。可能需要稍微改一改的就只是 AES.h 文件，因为不同的填充模式需要改一个常量值。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//EncryptDecryptUtils.cpp
#include &quot;EncryptDecryptUtils.h&quot;
#include &quot;AES.h&quot;
#include &quot;Base64.h&quot;
#include &quot;UTF8.h&quot;

EncryptDecryptUtils::EncryptDecryptUtils()
{
}
~EncryptDecryptUtils::EncryptDecryptUtils()
{
}

/**
* 流程：服务端下发的BASE64编码的密文字符串 -&amp;gt; 去除字符串中的换行符 -&amp;gt; BASE64解码 -&amp;gt; AES::CBC模式解密 -&amp;gt; 去掉AES::PKCS5Padding 填充 -&amp;gt; UTF-8编码 -&amp;gt; 明文字符串
*/
string EncryptDecryptUtils::doDecodeDecrypt(string content)
{   
    //1.去掉字符串中的\r\n换行符
    string noWrapContent = removeSpace(string);
    //2. Base64解码
    string strData = base64_decode(noWrapContent);
    size_t length = strData.length();

    //3. new些数组，给解密用
    char *szDataIn = new char[length + 1];
    memcpy(szDataIn, strData.c_str(), length + 1);
    char *szDataOut = new char[length + 1];
    memcpy(szDataOut, strData.c_str(), length + 1);

    //4. 进行AES的CBC模式解密
    AES aes;
    //在这里传入密钥，和偏移量，以及指定密钥长度和iv长度，如果你的密钥长度不是16字节128bit，那么需要在这里传入相对应的参数。
    aes.MakeKey(string(AES_KEY).c_str(), string(AES_IV).c_str(), 16, 16);
    //这里参数有传入指定加解密的模式，AES::CBC，如果你不是这个模式，需要传入相对应的模式，源码中都有注释说明
    aes.Decrypt(szDataIn, szDataOut, length, AES::CBC);

    //5.去PKCS5Padding填充:解密后需要将字符串中填充的去掉，根据填充规则进行去除，感兴趣可去搜索相关的填充规则
    if (0x00 &amp;lt; szDataOut[length - 1] &amp;lt;= 0x16)
    {
        int tmp = szDataOut[length - 1];
        for (int i = length - 1; i &amp;gt;= length - tmp; i--)
        {
            if (szDataOut[i] != tmp)
            {
                memset(szDataOut, 0, length);
                break;
            }
            else
                szDataOut[i] = 0;
        }
    }

    //6. 将二进制的明文串转成UTF-8格式的编码方式，输出
    string srcDest = UTF8_To_string(szDataOut);
    delete[] szDataIn;
    delete[] szDataOut;
    return srcDest;
}

/**
* 流程：UTF-8格式的明文字符串 -&amp;gt; UTF-8解码成二进制串 -&amp;gt; AES::PKCS5Padding 填充 -&amp;gt; AES::CBC模式加密 -&amp;gt; BASE64编码 -&amp;gt; 密文字符串
*/
string EncryptDecryptUtils::doEncryptEncode(string content)
{
    //1. 先获取UTF-8解码后的二进制串
    string utf8Content = string_To_UTF8(content);
    size_t length = utf8Content.length();
    int block_num = length / BLOCK_SIZE + 1;
    
    //2. new 些数组供加解密使用
    char* szDataIn = new char[block_num * BLOCK_SIZE + 1];
    memset(szDataIn, 0x00, block_num * BLOCK_SIZE + 1);
    strcpy(szDataIn, utf8Content.c_str());

    //3. 进行PKCS5Padding填充：进行CBC模式加密前，需要填充明文串，确保可以分组后各组都有相同的大小。
    // BLOCK_SIZE是在AES.h中定义的常量，PKCS5Padding 和 PKCS7Padding 的区别就是这个 BLOCK_SIZE 的大小，我用的PKCS5Padding，所以定义成 8。如果你是使用 PKCS7Padding，那么就根据你服务端具体大小是在 1-255中的哪个值修改即可。
    int k = length % BLOCK_SIZE;
    int j = length / BLOCK_SIZE;
    int padding = BLOCK_SIZE - k;
    for (int i = 0; i &amp;lt; padding; i++)
    {
        szDataIn[j * BLOCK_SIZE + k + i] = padding;
    }
    szDataIn[block_num * BLOCK_SIZE] = '\0';

    char *szDataOut = new char[block_num * BLOCK_SIZE + 1];
    memset(szDataOut, 0, block_num * BLOCK_SIZE + 1);

    //4. 进行AES的CBC模式加密
    AES aes;
     //在这里传入密钥，和偏移量，以及指定密钥长度和iv长度，如果你的密钥长度不是16字节128bit，那么需要在这里传入相对应的参数。
    aes.MakeKey(string(AES_KEY).c_str(), string(AES_IV).c_str(), 16, 16);
    //这里参数有传入指定加解密的模式，AES::CBC，如果你不是这个模式，需要传入相对应的模式，源码中都有注释说明
    aes.Encrypt(szDataIn, szDataOut, block_num * BLOCK_SIZE, AES::CBC);
    
    //5. Base64编码
    string str = base64_encode((unsigned char*)szDataOut, block_num * BLOCK_SIZE);
    delete[] szDataIn;
    delete[] szDataOut;
    return str;
}

//去除字符串中的空格、换行符
string EncryptDecryptUtils::formatText(string src)
{
    int len = src.length();
    char *dst = new char[len + 1];
    int i = -1, j = 0;
    while (src[++i])
    {
        switch (src[i])
        {
        case '\n':
        case '\t':
        case '\r':
            continue;
        }
        dst[j++] = src[i];
    }
    dst[j] = '\0';
    string rel = string(dst);
    delete dst;
    return rel;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再列个在线验证 AES 加解密结果的网站，方便调试：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.seacha.com/tools/aes.html&quot; class=&quot;uri&quot;&gt;http://www.seacha.com/tools/aes.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 实现那么方便，为什么还需要用 C++ 的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想一想，密钥信息那么重要，你要放在哪？像我例子那样直接写在代码中？那只是个例子，别忘了，app 混淆的时候，字符串都是不会参与混淆的，随便反编译下你的 app，密钥就暴露给别人了。&lt;/p&gt;
&lt;p&gt;那么，有其他比较好的方式吗？我只能想到，AES 加解密相关的用 C++ 来写，生成个 so 库，提供个 jni 接口给 app 层调用，这样密钥信息就可以保存在 C++ 中了。&lt;/p&gt;
&lt;p&gt;也许你会觉得，哪有人那么闲去反编译 app，而且正在写的 app 又没有什么价值让别人反编译。&lt;/p&gt;
&lt;p&gt;emmm，说是这么说，但安全意识还是要有的，至少也要先知道有这么个防护的方法，以及该怎么做，万一哪天你写的 app 就火了呢？&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 12:50:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/9419877.html</dc:identifier>
</item>
<item>
<title>Java基础面试题总结 - AntzUhl</title>
<link>http://www.cnblogs.com/LexMoon/p/javams.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/javams.html</guid>
<description>&lt;h2 id=&quot;面向对象和面向过程的区别&quot;&gt;&lt;span&gt;面向对象和面向过程的区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;面向过程：&lt;/strong&gt;&lt;br/&gt;　　优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。&lt;br/&gt;缺点：没有面向对象易维护、易复用、易扩展&lt;br/&gt;&lt;strong&gt;面向对象：&lt;/strong&gt;&lt;br/&gt;　　优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护&lt;br/&gt;缺点：性能比面向过程低&lt;/p&gt;
&lt;h2 id=&quot;java语言有哪些特点&quot;&gt;&lt;span&gt;Java语言有哪些特点？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　1，简单易学；2，面向对象（封装，继承，多态）；3，平台无关性（Java虚拟机实现平台无关性）；4，可靠性；5，安全性；6，支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言却提供了多线程支持）；7，支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）；8，编译与解释并存；&lt;/p&gt;
&lt;h2 id=&quot;什么是字节码采用字节码的最大好处是什么什么java是虚拟机&quot;&gt;&lt;span&gt;什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;先看下java中的编译器和解释器：&lt;/strong&gt;&lt;br/&gt;　　Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。&lt;br/&gt;Java源代码----&amp;gt;编译器----&amp;gt;jvm可执行的Java字节码(即虚拟指令)----&amp;gt;jvm----&amp;gt;jvm中解释器-----&amp;gt;机器可执行的二进制机器码----&amp;gt;程序运行。&lt;br/&gt;&lt;strong&gt;采用字节码的好处：&lt;/strong&gt;&lt;br/&gt;　　Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。&lt;/p&gt;
&lt;h2 id=&quot;什么是java虚拟机&quot;&gt;&lt;span&gt;什么是Java虚拟机&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　任何一种可以运行Java字节码的软件均可看成是Java的虚拟机（JVM）&lt;/p&gt;
&lt;h2 id=&quot;什么是java程序的主类应用程序和小程序的主类有何不同&quot;&gt;&lt;span&gt;什么是Java程序的主类？应用程序和小程序的主类有何不同？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main（）方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。&lt;/p&gt;
&lt;h2 id=&quot;什么是jdk什么是jre&quot;&gt;&lt;span&gt;什么是JDK?什么是JRE？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　JDK: 顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/11/8/9cf7f48fdbe608ae70080aa6c5a2f910?w=680&amp;amp;h=278&amp;amp;f=png&amp;amp;s=-1&quot; alt=&quot;JDK&quot;/&gt;&lt;br/&gt;　　JRE:普通用户而只需要安装JRE（Java Runtime Environment）来 来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。&lt;/p&gt;
&lt;h2 id=&quot;环境变量path和classpath的作用是什么如何设置这两个环境变量&quot;&gt;&lt;span&gt;环境变量Path和ClassPath的作用是什么？如何设置这两个环境变量？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Java环境变量PATH和CLASSPATH - 简书 http://www.jianshu.com/p/d63b099cf283&lt;/p&gt;
&lt;h2 id=&quot;java应用程序与小程序之间有那些差别&quot;&gt;&lt;span&gt;Java应用程序与小程序之间有那些差别？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。&lt;/p&gt;
&lt;h2 id=&quot;字符型常量和字符串常量的区别&quot;&gt;&lt;span&gt;字符型常量和字符串常量的区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1) 形式上:&lt;br/&gt;字符常量是单引号引起的一个字符&lt;br/&gt;字符串常量是双引号引起的若干个字符&lt;br/&gt;2) 含义上:&lt;br/&gt;字符常量相当于一个整形值(ASCII值),可以参加表达式运算&lt;br/&gt;字符串常量代表一个地址值(该字符串在内存中存放位置)&lt;br/&gt;3) 占内存大小&lt;br/&gt;字符常量只占一个字节&lt;br/&gt;字符串常量占若干个字节(至少一个字符结束标志)&lt;/p&gt;
&lt;h2 id=&quot;java语言采用何种编码方案有何特点&quot;&gt;&lt;span&gt;Java语言采用何种编码方案？有何特点？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。&lt;/p&gt;
&lt;h2 id=&quot;构造器constructor是否可被override&quot;&gt;&lt;span&gt;构造器Constructor是否可被override&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override,但是可以overload,所以你可以看到一个类中有多个构造函数的情况。&lt;/p&gt;
&lt;h2 id=&quot;重载和重写的区别&quot;&gt;&lt;span&gt;重载和重写的区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。&lt;br/&gt;　　重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。&lt;/p&gt;
&lt;h2 id=&quot;java-面向对象编程三大特性------封装继承多态&quot;&gt;&lt;span&gt;java 面向对象编程三大特性------封装、继承、多态&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jianyuerensheng/article/details/51602015&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/jianyuerensheng/article/details/51602015&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;string和stringbufferstringbuilder的区别是什么string为什么是不可变的&quot;&gt;&lt;span&gt;String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可变性&lt;/strong&gt;&lt;br/&gt;　&lt;/p&gt;
&lt;p&gt;String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。&lt;br/&gt;&lt;strong&gt;对于三者使用的总结：&lt;/strong&gt;&lt;br/&gt;如果要操作少量的数据用 = String&lt;br/&gt;单线程操作字符串缓冲区 下操作大量数据 = StringBuilder&lt;br/&gt;多线程操作字符串缓冲区 下操作大量数据 = StringBuffer&lt;/p&gt;
&lt;h2 id=&quot;自动装箱与拆箱&quot;&gt;&lt;span&gt;自动装箱与拆箱&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;装箱&lt;/strong&gt;：将基本类型用它们对应的引用类型包装起来；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拆箱&lt;/strong&gt;：将包装类型转换为基本数据类型；&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。&lt;/p&gt;
&lt;h2 id=&quot;类方法成员变量和局部变量的可用修饰符--&quot;&gt;&lt;span&gt;类、方法、成员变量和局部变量的可用修饰符 -&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/yttcjj/article/details/6939239&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/yttcjj/article/details/6939239&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;在一个静态方法内调用一个非静态成员为什么是非法的&quot;&gt;&lt;span&gt;在一个静态方法内调用一个非静态成员为什么是非法的？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。&lt;/p&gt;
&lt;h2 id=&quot;在java中定义一个不做事且没有参数的构造方法的作用&quot;&gt;&lt;span&gt;在Java中定义一个不做事且没有参数的构造方法的作用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。&lt;/p&gt;
&lt;h2 id=&quot;import-java和javax有什么区别&quot;&gt;&lt;span&gt;import java和javax有什么区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/EasonJim/p/6993139.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/EasonJim/p/6993139.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;接口和抽象类的区别是什么&quot;&gt;&lt;span&gt;接口和抽象类的区别是什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1.接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法&lt;br/&gt;2.接口中的实例变量默认是final类型的，而抽象类中则不一定&lt;br/&gt;3.一个类可以实现多个接口，但最多只能实现一个抽象类&lt;br/&gt;4.一个类实现接口的话要实现接口的所有方法，而抽象类不一定&lt;br/&gt;5.接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象&lt;br/&gt;从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。&lt;/p&gt;
&lt;h2 id=&quot;成员变量与局部变量的区别有那些&quot;&gt;&lt;span&gt;成员变量与局部变量的区别有那些？&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；成员变量和局部变量都能被final所修饰；&lt;/li&gt;
&lt;li&gt;从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存&lt;/li&gt;
&lt;li&gt;从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。&lt;/li&gt;
&lt;li&gt;成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;创建一个对象用什么运算符对象实体与对象引用有何不同&quot;&gt;&lt;span&gt;创建一个对象用什么运算符？对象实体与对象引用有何不同？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）&lt;/p&gt;
&lt;h2 id=&quot;什么是方法的返回值返回值在类的方法里的作用是什么&quot;&gt;&lt;span&gt;什么是方法的返回值？返回值在类的方法里的作用是什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！&lt;/p&gt;
&lt;h2 id=&quot;一个类的构造方法的作用是什么若一个类没有声明构造方法改程序能正确执行吗为什么&quot;&gt;&lt;span&gt;一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。&lt;/p&gt;
&lt;h2 id=&quot;构造方法有哪些特性&quot;&gt;&lt;span&gt;构造方法有哪些特性？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　1，名字与类名相同；2，没有返回值，但不能用void声明构造函数；3，生成类的对象时自动执行，无需调用。&lt;/p&gt;
&lt;h2 id=&quot;静态方法和实例方法有何不同&quot;&gt;&lt;span&gt;静态方法和实例方法有何不同？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;静态方法和实例方法的区别主要体现在两个方面：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;对象的相等与指向他们的引用相等两者有什么不同&quot;&gt;&lt;span&gt;对象的相等与指向他们的引用相等，两者有什么不同？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。&lt;/p&gt;
&lt;h2 id=&quot;在调用子类构造方法之前会先调用父类没有参数的构造方法其目的是&quot;&gt;&lt;span&gt;在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　帮助子类做初始化工作。&lt;/p&gt;
&lt;h2 id=&quot;什么是多态机制java语言是如何实现多态的&quot;&gt;&lt;span&gt;什么是多态机制？Java语言是如何实现多态的？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/bornlili/article/details/55213563&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/bornlili/article/details/55213563&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;equals-和-的区别&quot;&gt;&lt;span&gt;equals 和 == 的区别？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;通俗点讲：==是看看左右是不是一个东西。equals是看看左右是不是长得一样。如何记住嘛。如果单纯是想记住，==：等于。equals：相同。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。你只要记住equals，==就不用记了。&lt;/p&gt;
&lt;p&gt;术语来讲的区别：1.==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同&lt;br/&gt;2.==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同&lt;/p&gt;
&lt;h2 id=&quot;创建线程有几种不同的方式你喜欢哪一种为什么&quot;&gt;&lt;span&gt;创建线程有几种不同的方式？你喜欢哪一种？为什么？&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;继承Thread类&lt;/li&gt;
&lt;li&gt;实现Runnable接口&lt;/li&gt;
&lt;li&gt;应用程序可以使用Executor框架来创建线程池&lt;/li&gt;
&lt;li&gt;实现Callable接口。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我更喜欢实现Runnable接口这种方法，当然这也是现在大多程序员会选用的方法。因为一个类只能继承一个父类而可以实现多个接口。同时，线程池也是非常高效的，很容易实现和使用。&lt;/p&gt;
&lt;h2 id=&quot;简述线程程序进程的基本概念以及他们之间关系是什么参考书籍java程序设计基础第五版&quot;&gt;&lt;span&gt;简述线程，程序、进程的基本概念。以及他们之间关系是什么？（参考书籍：《Java程序设计基础》第五版）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。&lt;br/&gt;线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。&lt;/p&gt;
&lt;h2 id=&quot;什么是多线程为什么程序的多线程功能是必要的&quot;&gt;&lt;span&gt;什么是多线程？为什么程序的多线程功能是必要的？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;多线程就是几乎同时执行多个线程（一个处理器在某一个时间点上永远都只能是一个线程！即使这个处理器是多核的，除非有多个处理器才能实现多个线程同时运行。）。几乎同时是因为实际上多线程程序中的多个线程实际上是一个线程执行一会然后其他的线程再执行，并不是很多书籍所谓的同时执行。这样可以带来以下的好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用线程可以把占据长时间的程序中的任务放到后台去处理&lt;/li&gt;
&lt;li&gt;用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度&lt;/li&gt;
&lt;li&gt;程序的运行速度可能加快&lt;/li&gt;
&lt;li&gt;在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。&lt;br/&gt;还有其他很多使用多线程的好处，这里就不一一说明了。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;多线程与多任务的差异是什么参考书籍java程序设计基础第五版&quot;&gt;&lt;span&gt;多线程与多任务的差异是什么？（参考书籍：《Java程序设计基础》第五版）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;多任务与多线程是两个不同的概念，&lt;br/&gt;多任务是针对操作系统而言的，表示操作系统可以同时运行多个应用程序。&lt;br/&gt;而多线程是针对一个进程而言的，表示在一个进程内部可以几乎同时执行多个线程&lt;/p&gt;
&lt;h2 id=&quot;线程有哪些基本状态这些状态是如何定义的&quot;&gt;&lt;span&gt;线程有哪些基本状态？这些状态是如何定义的?&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;新建(new)&lt;/strong&gt;：新创建了一个线程对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可运行(runnable)&lt;/strong&gt;：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行(running)&lt;/strong&gt;：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞(block)&lt;/strong&gt;：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：&lt;br/&gt;(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。&lt;br/&gt;(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。&lt;br/&gt;(三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死亡(dead)&lt;/strong&gt;：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/15/16059cc91ee8efb3?w=876&amp;amp;h=492&amp;amp;f=png&amp;amp;s=-1&quot; alt=&quot;线程的基本状态&quot;/&gt;&lt;/p&gt;
&lt;p&gt;备注：&lt;br/&gt;可以用早起坐地铁来比喻这个过程：&lt;br/&gt;还没起床：sleeping&lt;br/&gt;起床收拾好了，随时可以坐地铁出发：Runnable&lt;br/&gt;等地铁来：Waiting&lt;br/&gt;地铁来了，但要排队上地铁：I/O阻塞&lt;br/&gt;上了地铁，发现暂时没座位：synchronized阻塞&lt;br/&gt;地铁上找到座位：Running&lt;br/&gt;到达目的地：Dead&lt;/p&gt;
&lt;h2 id=&quot;什么是线程的同步程序中为什么要实现线程的同步是如何实现同步的&quot;&gt;&lt;span&gt;什么是线程的同步？程序中为什么要实现线程的同步？是如何实现同步的？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。&lt;br/&gt;在多线程应用中，考虑不同线程之间的数据同步和防止死锁。当两个或多个线程之间同时等待对方释放资源的时候就会形成线程之间的死锁。为了防止死锁的发生，需要通过同步来实现线程安全。&lt;/p&gt;
&lt;h2 id=&quot;在监视器monitor内部是如何做线程同步的程序应该做哪种级别的同步&quot;&gt;&lt;span&gt;在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在 java 虚拟机中, 每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联, 为了实现监视器的互斥功能, 每个对象都关联着一把锁.&lt;br/&gt;一旦方法或者代码块被 &lt;strong&gt;synchronized&lt;/strong&gt; 修饰, 那么这个部分就放入了监视器的监视区域, &lt;strong&gt;确保一次只能有一个线程执行该部分的代码&lt;/strong&gt;, 线程在获取锁之前不允许执行该部分的代码&lt;br/&gt;另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案&lt;/p&gt;
&lt;h2 id=&quot;什么是死锁deadlock&quot;&gt;&lt;span&gt;什么是死锁(deadlock)？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.so.com/doc/6950313-7172714.html&quot;&gt;360百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;死锁 :是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去 。&lt;br/&gt;产生原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为系统资源不足。&lt;/li&gt;
&lt;li&gt;进程运行推进顺序不合适。&lt;/li&gt;
&lt;li&gt;资源分配不当等。&lt;/li&gt;
&lt;li&gt;占用资源的程序崩溃等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。&lt;/p&gt;
&lt;p&gt;下面四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要下列条件之一不满足，就不会发生死锁。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;互斥条件：一个资源每次只能被一个进程使用。&lt;/li&gt;
&lt;li&gt;请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。&lt;/li&gt;
&lt;li&gt;不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。&lt;/li&gt;
&lt;li&gt;循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。&lt;br/&gt;死锁的解除与预防：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。&lt;/p&gt;
&lt;h2 id=&quot;如何确保n个线程可以访问n个资源同时又不导致死锁&quot;&gt;&lt;span&gt;如何确保N个线程可以访问N个资源同时又不导致死锁？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上面一题我们知道了发生死锁的四个必要条件。我们只要使其中一个不成立就行了。一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。这也就是破坏了第四个条件循环等待条件。&lt;/p&gt;
&lt;h2 id=&quot;java中垃圾回收有什么目的什么时候进行垃圾回收&quot;&gt;&lt;span&gt;Java中垃圾回收有什么目的？什么时候进行垃圾回收？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行。&lt;/p&gt;
&lt;p&gt;垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。&lt;/p&gt;
&lt;h2 id=&quot;finalize方法什么时候被调用析构函数finalization的目的是什么&quot;&gt;&lt;span&gt;finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1）垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法；&lt;br/&gt;finalize是Object类的一个方法，该方法在Object类中的声明protected void finalize() throws Throwable { }&lt;br/&gt;在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放对象占用的内存，将首先调用该对象的finalize()方法，并且下一次垃圾回收动作发生时，才真正回收对象占用的内存空间&lt;/p&gt;
&lt;p&gt;2）GC本来就是内存回收了，应用还需要在finalization做什么呢？ 答案是大部分时候，什么都不用做(也就是不需要重载)。只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可以要在finaliztion里去调用C的释放函数。&lt;/p&gt;
&lt;h2 id=&quot;如果对象的引用被置为null垃圾收集器是否会立即释放对象占用的内存&quot;&gt;&lt;span&gt;如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;不会，在下一个垃圾回收周期中，这个对象将是可被回收的。&lt;/p&gt;

&lt;h2 id=&quot;servlet总结&quot;&gt;&lt;span&gt;Servlet总结&lt;/span&gt;：&lt;/h2&gt;
&lt;p&gt;在Java Web程序中，&lt;strong&gt;Servlet&lt;/strong&gt;主要负责接收用户请求&lt;strong&gt;HttpServletRequest&lt;/strong&gt;,在&lt;strong&gt;doGet()&lt;/strong&gt;,&lt;strong&gt;doPost()&lt;/strong&gt;中做相应的处理，并将回应&lt;strong&gt;HttpServletResponse&lt;/strong&gt;反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用&lt;strong&gt;init()方法&lt;/strong&gt;，销毁时调用&lt;strong&gt;destroy()方法&lt;/strong&gt;。&lt;strong&gt;Servlet需要在web.xml中配置&lt;/strong&gt;（MyEclipse中创建Servlet会自动配置），&lt;strong&gt;一个Servlet可以设置多个URL访问&lt;/strong&gt;。&lt;strong&gt;Servlet不是线程安全&lt;/strong&gt;，因此要谨慎使用类变量。&lt;/p&gt;
&lt;h2 id=&quot;阐述servlet和cgi的区别&quot;&gt;&lt;span&gt;阐述Servlet和CGI的区别?&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CGI的不足之处：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。&lt;/p&gt;
&lt;p&gt;2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销&lt;/p&gt;
&lt;p&gt;3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Servlet的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销&lt;/p&gt;
&lt;p&gt;2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销&lt;/p&gt;
&lt;p&gt;3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。&lt;/p&gt;
&lt;p&gt;4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。&lt;/p&gt;
&lt;p&gt;补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。&lt;/p&gt;
&lt;p&gt;参考：《javaweb整合开发王者归来》P7&lt;/p&gt;
&lt;h2 id=&quot;servlet接口中有哪些方法及servlet生命周期探秘&quot;&gt;&lt;span&gt;Servlet接口中有哪些方法及Servlet生命周期探秘&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Servlet接口定义了5个方法，其中&lt;strong&gt;前三个方法与Servlet生命周期相关&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;void init(ServletConfig config) throws ServletException&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;void destory()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;java.lang.String getServletInfo()&lt;/li&gt;
&lt;li&gt;ServletConfig getServletConfig()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;生命周期：&lt;/strong&gt; &lt;strong&gt;Web容器加载Servlet并将其实例化后，Servlet生命周期开始&lt;/strong&gt;，容器运行其&lt;strong&gt;init()方法&lt;/strong&gt;进行Servlet的初始化；请求到达时调用Servlet的&lt;strong&gt;service()方法&lt;/strong&gt;，service()方法会根据需要调用与请求对应的&lt;strong&gt;doGet或doPost&lt;/strong&gt;等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的&lt;strong&gt;destroy()方法&lt;/strong&gt;。&lt;strong&gt;init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行&lt;/strong&gt;。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。&lt;/p&gt;
&lt;p&gt;参考：《javaweb整合开发王者归来》P81&lt;/p&gt;
&lt;h2 id=&quot;get和post请求的区别&quot;&gt;&lt;span&gt;get和post请求的区别？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；&lt;/p&gt;
&lt;p&gt;②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用&quot;?&quot;连接，而各个变量之间使用&quot;&amp;amp;&quot;连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；&lt;/p&gt;
&lt;p&gt;③get传输的数据要受到URL长度限制（1024字节即256个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；&lt;/p&gt;
&lt;p&gt;④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；&lt;/p&gt;
&lt;p&gt;⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是&quot;%20&quot;。&lt;/p&gt;
&lt;p&gt;补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。&lt;/p&gt;
&lt;h2 id=&quot;什么情况下调用doget和dopost&quot;&gt;&lt;span&gt;什么情况下调用doGet()和doPost()?&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。&lt;/p&gt;
&lt;h2 id=&quot;转发forward和重定向redirect的区别&quot;&gt;&lt;span&gt;转发（Forward）和重定向（Redirect）的区别？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;转发是服务器行为，重定向是客户端行为。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转发（Forword）&lt;/strong&gt;&lt;br/&gt;通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;     request.getRequestDispatcher(&quot;login_success.jsp&quot;).forward(request, response);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重定向（Redirect）&lt;/strong&gt; 是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;从地址栏显示来说&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.&lt;br/&gt;redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;从数据共享来说&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;forward:转发页面和转发到的页面可以共享request里面的数据.&lt;br/&gt;redirect:不能共享数据.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;从运用地方来说&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;forward:一般用于用户登陆的时候,根据角色转发到相应的模块.&lt;br/&gt;redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从效率来说&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;forward:高.&lt;br/&gt;redirect:低.&lt;/p&gt;
&lt;h2 id=&quot;自动刷新refresh&quot;&gt;&lt;span&gt;自动刷新（Refresh）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Response.setHeader(&quot;Refresh&quot;,&quot;1000;URL=http://localhost:8080/servlet/example.htm&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中1000为时间，单位为毫秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现没过一秒自动刷新本页面一次）&lt;/p&gt;
&lt;h2 id=&quot;servlet与线程安全&quot;&gt;&lt;span&gt;Servlet与线程安全&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。&lt;/strong&gt; 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。&lt;br/&gt;注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。&lt;/p&gt;
&lt;p&gt;参考：《javaweb整合开发王者归来》P92&lt;/p&gt;
&lt;h2 id=&quot;jsp和servlet是什么关系&quot;&gt;&lt;span&gt;JSP和Servlet是什么关系？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。&lt;/p&gt;
&lt;h2 id=&quot;jsp工作原理&quot;&gt;&lt;span&gt;JSP工作原理：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。&lt;br/&gt;工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。&lt;br/&gt;.class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/31/1627bee073079a28?w=675&amp;amp;h=292&amp;amp;f=jpeg&amp;amp;s=133553&quot; alt=&quot;JSP工作原理&quot;/&gt;&lt;br/&gt;由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。&lt;/p&gt;
&lt;p&gt;开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。&lt;/p&gt;
&lt;p&gt;参考：《javaweb整合开发王者归来》P97&lt;/p&gt;
&lt;h2 id=&quot;jsp有哪些内置对象作用分别是什么&quot;&gt;&lt;span&gt;JSP有哪些内置对象？作用分别是什么？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qq_34337272/article/details/64310849&quot;&gt;JSP内置对象 - CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JSP有9个内置对象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;request：封装客户端的请求，其中包含来自GET或POST请求的参数；&lt;/li&gt;
&lt;li&gt;response：封装服务器对客户端的响应；&lt;/li&gt;
&lt;li&gt;pageContext：通过该对象可以获取其他对象；&lt;/li&gt;
&lt;li&gt;session：封装用户会话的对象；&lt;/li&gt;
&lt;li&gt;application：封装服务器运行环境的对象；&lt;/li&gt;
&lt;li&gt;out：输出服务器响应的输出流对象；&lt;/li&gt;
&lt;li&gt;config：Web应用的配置对象；&lt;/li&gt;
&lt;li&gt;page：JSP页面本身（相当于Java程序中的this）；&lt;/li&gt;
&lt;li&gt;exception：封装页面抛出异常的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;request对象的主要方法有哪些&quot;&gt;&lt;span&gt;Request对象的主要方法有哪些？&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;setAttribute(String name,Object)：设置名字为name的request 的参数值&lt;/li&gt;
&lt;li&gt;getAttribute(String name)：返回由name指定的属性值&lt;/li&gt;
&lt;li&gt;getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例&lt;/li&gt;
&lt;li&gt;getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组&lt;/li&gt;
&lt;li&gt;getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度&lt;/li&gt;
&lt;li&gt;getHeader(String name) ：获得HTTP协议定义的文件头信息&lt;/li&gt;
&lt;li&gt;getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例&lt;/li&gt;
&lt;li&gt;getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例&lt;/li&gt;
&lt;li&gt;getInputStream() ：返回请求的输入流，用于获得请求中的数据&lt;/li&gt;
&lt;li&gt;getMethod() ：获得客户端向服务器端传送数据的方法&lt;/li&gt;
&lt;li&gt;getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值&lt;/li&gt;
&lt;li&gt;getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例&lt;/li&gt;
&lt;li&gt;getParameterValues(String name)：获得有name指定的参数的所有值&lt;/li&gt;
&lt;li&gt;getProtocol()：获取客户端向服务器端传送数据所依据的协议名称&lt;/li&gt;
&lt;li&gt;getQueryString() ：获得查询字符串&lt;/li&gt;
&lt;li&gt;getRequestURI() ：获取发出请求字符串的客户端地址&lt;/li&gt;
&lt;li&gt;getRemoteAddr()：获取客户端的 IP 地址&lt;/li&gt;
&lt;li&gt;getRemoteHost() ：获取客户端的名字&lt;/li&gt;
&lt;li&gt;getSession([Boolean create]) ：返回和请求相关 Session&lt;/li&gt;
&lt;li&gt;getServerName() ：获取服务器的名字&lt;/li&gt;
&lt;li&gt;getServletPath()：获取客户端所请求的脚本文件的路径&lt;/li&gt;
&lt;li&gt;getServerPort()：获取服务器的端口号&lt;/li&gt;
&lt;li&gt;removeAttribute(String name)：删除请求中的一个属性&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;request.getattribute和-request.getparameter有何区别&quot;&gt;&lt;span&gt;request.getAttribute()和 request.getParameter()有何区别?&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;从获取方向来看：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;getParameter()是获取 POST/GET 传递的参数值；&lt;/p&gt;
&lt;p&gt;getAttribute()是获取对象容器中的数据值；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从用途来看：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;getParameter用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。&lt;/p&gt;
&lt;p&gt;getAttribute用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了&lt;br/&gt;mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。&lt;/p&gt;
&lt;p&gt;另外，可以用 setAttribute,getAttribute 发送接收对象.而 getParameter 显然只能传字符串。&lt;br/&gt;setAttribute 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样getAttribute就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。getParameter只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;getParameter 返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）&lt;/p&gt;
&lt;p&gt;getAttribute 返回的是Object，需进行转换,可用setAttribute 设置成任意对象，使用很灵活，可随时用&lt;/p&gt;
&lt;h2 id=&quot;include指令include的行为的区别&quot;&gt;&lt;span&gt;include指令include的行为的区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;include指令：&lt;/strong&gt; JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下：&lt;br/&gt;&amp;lt;%@ include file=&quot;文件相对 url 地址&quot; %&amp;gt;&lt;/p&gt;
&lt;p&gt;i&lt;strong&gt;nclude动作：&lt;/strong&gt; 动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jsp九大内置对象七大动作三大指令-&quot;&gt;&lt;span&gt;JSP九大内置对象，七大动作，三大指令-&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qq_34337272/article/details/64310849&quot;&gt;JSP九大内置对象，七大动作，三大指令总结&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;讲解jsp中的四种作用域&quot;&gt;&lt;span&gt;讲解JSP中的四种作用域&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;JSP中的四种作用域包括page、request、session和application，具体来说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;page&lt;/strong&gt;代表与一个页面相关的对象和属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;request&lt;/strong&gt;代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;session&lt;/strong&gt;代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;application&lt;/strong&gt;代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何实现jsp或servlet的单线程模式&quot;&gt;&lt;span&gt;如何实现JSP或Servlet的单线程模式？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;对于JSP页面，可以通过page指令进行设置。&lt;br/&gt;&amp;lt;%@page isThreadSafe=”false”%&amp;gt;&lt;/p&gt;
&lt;p&gt;对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。&lt;/p&gt;
&lt;p&gt;说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。&lt;/p&gt;
&lt;h2 id=&quot;实现会话跟踪的技术有哪些&quot;&gt;&lt;span&gt;实现会话跟踪的技术有哪些？&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;使用Cookie&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;向客户端发送Cookie&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Cookie c =new Cookie(&quot;name&quot;,&quot;value&quot;); //创建Cookie 
c.setMaxAge(60*60*24); //设置最大时效，此处设置的最大时效为一天
response.addCookie(c); //把Cookie放入到HTTP响应中&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从客户端读取Cookie&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String name =&quot;name&quot;; 
Cookie[]cookies =request.getCookies(); 
if(cookies !=null){ 
   for(int i= 0;i&amp;lt;cookies.length;i++){ 
    Cookie cookie =cookies[i]; 
    if(name.equals(cookis.getName())) 
    //something is here. 
    //you can get the value 
    cookie.getValue(); 
       
   }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt; 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt; 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;URL 重写&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 在Cookie被禁用的时候依然可以使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。&lt;/p&gt;
&lt;p&gt;3.隐藏的表单域&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;input type=&quot;hidden&quot; name =&quot;session&quot; value=&quot;...&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; Cookie被禁时可以使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 所有页面必须是表单提交之后的结果。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HttpSession&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。&lt;/p&gt;
&lt;h2 id=&quot;cookie和session的的区别&quot;&gt;&lt;span&gt;Cookie和Session的的区别？&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。&lt;/li&gt;
&lt;li&gt;思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。&lt;/li&gt;
&lt;li&gt;Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;listsetmap三者的区别及总结&quot;&gt;&lt;span&gt;List，Set,Map三者的区别及总结&lt;/span&gt;&lt;/h2&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;List：对付顺序的好帮手&lt;/strong&gt;&lt;/p&gt;
List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Set:注重独一无二的性质&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不允许重复的集合。不会有多个元素引用相同的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Map:用Key来搜索的专家&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;arraylist-与-linkedlist-区别&quot;&gt;&lt;span&gt;Arraylist 与 LinkedList 区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Arraylist底层使用的是数组（存读数据效率高，插入删除特定位置效率低），LinkedList底层使用的是双向循环链表数据结构（插入，删除效率特别高）。学过数据结构这门课后我们就知道采用链表存储，插入，删除元素时间复杂度不受元素位置的影响，都是近似O（1）而数组为近似O（n），因此当数据特别多，而且经常需要插入删除元素时建议选用LinkedList.一般程序只用Arraylist就够用了，因为一般数据量都不会蛮大，Arraylist是使用最多的集合类。&lt;/p&gt;
&lt;h2 id=&quot;arraylist-与-vector-区别为什么要用arraylist取代vector呢&quot;&gt;&lt;span&gt;ArrayList 与 Vector 区别（为什么要用Arraylist取代Vector呢？）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector&lt;br/&gt;，代码要在同步操作上耗费大量的时间。Arraylist不是同步的，所以在不需要同步时建议使用Arraylist。&lt;/p&gt;
&lt;h2 id=&quot;hashmap-和-hashtable-的区别&quot;&gt;&lt;span&gt;HashMap 和 Hashtable 的区别&lt;/span&gt;&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;HashMap是非线程安全的，HashTable是线程安全的；HashTable内部的方法基本都经过synchronized修饰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;因为线程安全的问题，HashMap要比HashTable效率高一点，HashTable基本被淘汰。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;HashMap允许有null值的存在，而在HashTable中put进的键值只要有一个null，直接抛出NullPointerException。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java5或以上的话，请使用ConcurrentHashMap吧&lt;/p&gt;
&lt;h2 id=&quot;hashset-和-hashmap-区别&quot;&gt;&lt;span&gt;HashSet 和 HashMap 区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/2/161e717d734f3b23?w=896&amp;amp;h=363&amp;amp;f=jpeg&amp;amp;s=205536&quot; alt=&quot;HashSet 和 HashMap 区别&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;hashmap-和-concurrenthashmap-的区别&quot;&gt;&lt;span&gt;HashMap 和 ConcurrentHashMap 的区别&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xuefeng0707/article/details/40834595&quot;&gt;HashMap与ConcurrentHashMap的区别&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）&lt;/li&gt;
&lt;li&gt;HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;hashset如何检查重复&quot;&gt;&lt;span&gt;HashSet如何检查重复&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hashCode（）与equals（）的相关规定：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果两个对象相等，则hashcode一定也是相同的&lt;/li&gt;
&lt;li&gt;两个对象相等,对两个equals方法返回true&lt;/li&gt;
&lt;li&gt;两个对象有相同的hashcode值，它们也不一定是相等的&lt;/li&gt;
&lt;li&gt;综上，equals方法被覆盖过，则hashCode方法也必须被覆盖&lt;/li&gt;
&lt;li&gt;hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;==与equals的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同&lt;/li&gt;
&lt;li&gt;==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;comparable-和-comparator的区别&quot;&gt;&lt;span&gt;comparable 和 comparator的区别？&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序&lt;/li&gt;
&lt;li&gt;comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().&lt;/p&gt;
&lt;h3 id=&quot;comparator定制排序&quot;&gt;&lt;span&gt;Comparator定制排序&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class CollectionsSort {

    public static void main(String[] args) {

        ArrayList&amp;lt;Integer&amp;gt; arrayList = new ArrayList&amp;lt;Integer&amp;gt;();
        arrayList.add(-1);
        arrayList.add(3);
        arrayList.add(3);
        arrayList.add(-5);
        arrayList.add(7);
        arrayList.add(4);
        arrayList.add(-9);
        arrayList.add(-7);
        System.out.println(&quot;原始数组:&quot;);
        System.out.println(arrayList);
        // void reverse(List list)：反转
        Collections.reverse(arrayList);
        System.out.println(&quot;Collections.reverse(arrayList):&quot;);
        System.out.println(arrayList);
/*      
         * void rotate(List list, int distance),旋转。
         * 当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将
         * list的前distance个元素整体移到后面。
         
        Collections.rotate(arrayList, 4);
        System.out.println(&quot;Collections.rotate(arrayList, 4):&quot;);
        System.out.println(arrayList);*/
        
        // void sort(List list),按自然排序的升序排序
        Collections.sort(arrayList);
        System.out.println(&quot;Collections.sort(arrayList):&quot;);
        System.out.println(arrayList);

        // void shuffle(List list),随机排序
        Collections.shuffle(arrayList);
        System.out.println(&quot;Collections.shuffle(arrayList):&quot;);
        System.out.println(arrayList);

        // 定制排序的用法
        Collections.sort(arrayList, new Comparator&amp;lt;Integer&amp;gt;() {

            @Override
            public int compare(Integer o1, Integer o2) {
                return o2.compareTo(o1);
            }
        });
        System.out.println(&quot;定制排序后：&quot;);
        System.out.println(arrayList);
    }

}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重写compareto方法实现按年龄来排序&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;重写compareTo方法实现按年龄来排序&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;code&gt;package map;

import java.util.Set;
import java.util.TreeMap;

public class TreeMap2 {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        TreeMap&amp;lt;Person, String&amp;gt; pdata = new TreeMap&amp;lt;Person, String&amp;gt;();
        pdata.put(new Person(&quot;张三&quot;, 30), &quot;zhangsan&quot;);
        pdata.put(new Person(&quot;李四&quot;, 20), &quot;lisi&quot;);
        pdata.put(new Person(&quot;王五&quot;, 10), &quot;wangwu&quot;);
        pdata.put(new Person(&quot;小红&quot;, 5), &quot;xiaohong&quot;);
        // 得到key的值的同时得到key所对应的值
        Set&amp;lt;Person&amp;gt; keys = pdata.keySet();
        for (Person key : keys) {
            System.out.println(key.getAge() + &quot;-&quot; + key.getName());

        }
    }
}

// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列
// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他
// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了

class Person implements Comparable&amp;lt;Person&amp;gt; {
    private String name;
    private int age;

    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    /**
     * TODO重写compareTo方法实现按年龄来排序
     */
    @Override
    public int compareTo(Person o) {
        // TODO Auto-generated method stub
        if (this.age &amp;gt; o.getAge()) {
            return 1;
        } else if (this.age &amp;lt; o.getAge()) {
            return -1;
        }
        return age;
    }
}&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何对object的list排序&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如何对Object的list排序？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;对objects数组进行排序，我们可以用Arrays.sort()方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;对objects的集合进行排序，需要使用Collections.sort()方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何实现数组与list的相互转换&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如何实现数组与List的相互转换？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;List转数组：toArray(arraylist.size()方法；数组转List:Arrays的asList(a)方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;code&gt;List&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;String&amp;gt;();
        arrayList.add(&quot;s&quot;);
        arrayList.add(&quot;e&quot;);
        arrayList.add(&quot;n&quot;);
        /**
         * ArrayList转数组
         */
        int size=arrayList.size();
        String[] a = arrayList.toArray(new String[size]);
        //输出第二个元素
        System.out.println(a[1]);//结果：e
        //输出整个数组
        System.out.println(Arrays.toString(a));//结果：[s, e, n]
        /**
         * 数组转list
         */
        List&amp;lt;String&amp;gt; list=Arrays.asList(a);
        /**
         * list转Arraylist
         */
        List&amp;lt;String&amp;gt; arrayList2 = new ArrayList&amp;lt;String&amp;gt;();
        arrayList2.addAll(list);
        System.out.println(list);&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何求arraylist集合的交集-并集-差集-去重复并集&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如何求ArrayList集合的交集 并集 差集 去重复并集&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;需要用到List接口中定义的几个方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;addAll(Collection&amp;lt;? extends E&amp;gt; c) :按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾&lt;br/&gt;实例代码：&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;retainAll(Collection&amp;lt;?&amp;gt; c): 仅保留此列表中包含在指定集合中的元素。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;removeAll(Collection&amp;lt;?&amp;gt; c) :从此列表中删除指定集合中包含的所有元素。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;code&gt;package list;

import java.util.ArrayList;
import java.util.List;

public class MethodDemo {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        List&amp;lt;Integer&amp;gt; list1 = new ArrayList&amp;lt;Integer&amp;gt;();
        list1.add(1);
        list1.add(2);
        list1.add(3);
        list1.add(4);

        List&amp;lt;Integer&amp;gt; list2 = new ArrayList&amp;lt;Integer&amp;gt;();
        list2.add(2);
        list2.add(3);
        list2.add(4);
        list2.add(5);
        // 并集
        // list1.addAll(list2);
        // 交集
        //list1.retainAll(list2);
        // 差集
        // list1.removeAll(list2);
        // 无重复并集
        list2.removeAll(list1);
        list1.addAll(list2);
        for (Integer i : list1) {
            System.out.println(i);
        }
    }

}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;hashmap-的工作原理及代码实现&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;HashMap 的工作原理及代码实现&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://juejin.im/post/5ab0568b5188255580020e56&quot;&gt;集合框架源码学习之HashMap(JDK1.8)&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;concurrenthashmap-的工作原理及代码实现&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;ConcurrentHashMap 的工作原理及代码实现&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/chengxiao/p/6842045.html&quot;&gt;ConcurrentHashMap实现原理及源码分析&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;参考书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;《Head first java 》第二版 推荐阅读真心不错 （适合基础较差的）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;《Java核心技术卷1》推荐阅读真心不错 （适合基础较好的）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;《算法》第四版 （适合想对数据结构的Java实现感兴趣的）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 12:11:00 +0000</pubDate>
<dc:creator>AntzUhl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/javams.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务之基于Apollo实现统一配置中心 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/9419379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/9419379.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;Tip:&lt;/strong&gt; &lt;/em&gt;此篇已加入&lt;a title=&quot;find more ?&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index.html&quot; target=&quot;_blank&quot;&gt;.NET Core微服务基础系列文章索引&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　在微服务架构环境中，项目中配置文件比较繁杂，而且不同环境的不同配置修改相对频繁，每次发布都需要对应修改配置，如果配置出现错误，需要重新打包发布，时间成本较高，因此需要做统一的配置中心，能做到自动更新配置文件信息，解决以上问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804174604273-161191730.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Apollo（阿波罗）是携程框架部门研发的配置管理平台，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。其服务端基于Spring Boot和Spring Cloud开发，打包后可以直接运行，不需要额外安装Tomcat等应用容器。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Apollo目前在国内开发者社区比较热，在Github上有超过&lt;strong&gt;5k&lt;/strong&gt;颗星，在国内众多互联网公司&lt;strong&gt;有落地案例&lt;/strong&gt;，可以说Apollo是目前配置中心产品领域&lt;strong&gt;No.1&lt;/strong&gt;的产品，其成熟度和企业级特性要&lt;strong&gt;远远强于Spring Cloud体系中的Spring Cloud Config产品&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　目前有针对Java和.Net的两个客户端供使用：&lt;/p&gt;
&lt;p&gt;　　Java客户端不依赖任何框架，能够运行于所有Java运行时环境，同时对Spring/Spring Boot环境也有额外支持。&lt;/p&gt;
&lt;p&gt;　　.Net客户端不依赖任何框架，能够运行于所有.Net运行时环境。&lt;/p&gt;
&lt;p&gt;　　更多Apollo介绍请浏览 &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Apollo配置中心介绍&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;2.1 快速安装&lt;/h2&gt;
&lt;p&gt;　　Apollo GitHub中提供了一个让我们快速上手的Quick Start，帮助我们快速在本地环境部署，启动Apollo配置中心。这里主要集中于针对开发环境的本地部署（单击），要部署到生产环境，请参考 &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97&quot; target=&quot;_blank&quot;&gt;Apollo分布式部署指南&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　这里我使用的是Windows Server的虚拟机在本机搭的，当然你可以在你的Linux虚拟机中搭建，另外你也可以通过&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo-Quick-Start-Docker%E9%83%A8%E7%BD%B2&quot; target=&quot;_blank&quot;&gt;Docker更快捷地部署Apollo&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　Step1.准备下列软件/环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html&quot; target=&quot;_blank&quot;&gt;Java&lt;/a&gt; =&amp;gt; JDK 1.8+&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mysql.com/downloads/&quot; target=&quot;_blank&quot;&gt;MySQL&lt;/a&gt; =&amp;gt; 5.6.6+&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitforwindows.org/&quot; target=&quot;_blank&quot;&gt;Gitbash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nobodyiam/apollo-build-scripts&quot; target=&quot;_blank&quot;&gt;Apollo QuickStart&lt;/a&gt;　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Step2.陆续安装Java JDK, MySQL与Git&lt;/p&gt;
&lt;p&gt;　　Step3.导入脚本（从QuickStart目录中的sql文件夹中拷贝），导入的结果会创建两个数据库：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804180345292-758388507.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Step4.修改demo.sh中关于数据库连接的信息，主要是url、username与password&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;# apollo config db info&lt;br/&gt;apollo_config_db_url=jdbc:mysql://&lt;span&gt;&lt;strong&gt;192.168.80.70&lt;/strong&gt;&lt;/span&gt;:3306/ApolloConfigDB?characterEncoding=utf8&lt;br/&gt;apollo_config_db_username=root&lt;br/&gt;apollo_config_db_password=&lt;span&gt;213224591&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;# apollo portal db info&lt;br/&gt;apollo_portal_db_url=jdbc:mysql://&lt;span&gt;&lt;strong&gt;192.168.80.70&lt;/strong&gt;&lt;/span&gt;:3306/ApolloPortalDB?characterEncoding=utf8&lt;br/&gt;apollo_portal_db_username=root&lt;br/&gt;apollo_portal_db_password=&lt;span&gt;213224591&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Step5.通过以下命令启动（切换到quickstart的目录中），后续可以将其作为Windows服务，不过生产环境一般用Linux。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;cmd&amp;gt;cd C:\Apollo\apollo-build-scripts-master&lt;/p&gt;
&lt;p&gt;cmd&amp;gt;demo.sh start　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　启动后会最终显示以下信息：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;pre&gt;
==== starting service ====
Service logging file is ./service/apollo-service.log
Started [3099]
Waiting for config service startup.......
Config service started. You may visit http://localhost:8080 for service status now!
Waiting for admin service startup....
Admin service started
==== starting portal ====
Portal logging file is ./portal/apollo-portal.log
Started [4071]
Waiting for portal startup......
Portal started. You can visit http://localhost:8070 now!
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;　　看到上述信息显示完毕，证明我们的Apollo已经成功启动起来了，那么我们可以去这两个端口8080和8070去看看：&lt;/p&gt;
&lt;p&gt;　　[8070 =&amp;gt; Apollo 配置中心管理界面，默认账号：apollo/admin]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804180926923-1799350822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　进入之后会看到一个示例项目SampleApp，点进去可以看到其中有一个示例配置applicaiton&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804182441970-649329530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　[8080 =&amp;gt; Eureka服务注册&amp;amp;发现，和Consul类似，因为Apollo采用了Eureka作为服务注册中心，对Apollo架构感兴趣的童鞋可以阅读波波老师的《&lt;a href=&quot;https://mp.weixin.qq.com/s/-hUaQPzfsl9Lm3IqQW3VDQ&quot; target=&quot;_blank&quot;&gt;携程配置中心Apollo架构分析&lt;/a&gt;》，这里不是本文的重点]&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804181806323-2147160271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2 基本配置&lt;/h2&gt;
&lt;p&gt;　　Step1.创建一个新项目（这里部门可以自己在数据中编辑serverconfig表添加）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804183912266-1858967713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Step2.默认情况下，创建新项目后有一个默认的application的Namespace，我们删除它，然后重新创建我们要用到的配置。对于一般共用的数据库、Redis、RabbitMQ等配置，我们一般会将其放到一个Public的配置列表中，而每个项目中私有的配置信息（如Swagger文档的说明信息）我们会单独创建一个Private的配置列表给每个项目。&lt;/p&gt;
&lt;p&gt;　　下图为创建一个共享的配置列表（在Apollo中称为Namespace，详细内容可以参考：&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B9%8B%E2%80%9CNamespace%E2%80%9D&quot; target=&quot;_blank&quot;&gt;Apollo核心概念之Namespace&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804184611324-1802336019.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　Step3.向Shared和ClientService两个Namespace中添加Key/Value配置项（可以通过文本形式添加，速度更快），添加之后记得点击发布，最终结果如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804185633263-1302034738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在配置都有了，开始和我们的ASP.Net Core集成把。&lt;/p&gt;

&lt;h2&gt;3.1 准备工作&lt;/h2&gt;
&lt;p&gt;　　导入.Net Core的客户端package，看这个名字Com.Ctrip.Framework.Apollo.Configuration应该是Java程序员写的，特别的Java Style.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PM&amp;gt;Install-Package Com.Ctrip.Framework.Apollo.Configuration　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　修改appsettings.json，添加apollo节点：指明apollo的AppId和Server地址 =&amp;gt; AppId 用来标识应用身份的唯一id，Apollo客户端针对不同的环境会从不同的服务器获取配置 ，MetaServer 就是客户端获取配置的服务器配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apollo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MSAD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MetaServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.80.70:8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.2 更改Program.cs&lt;/h2&gt;
&lt;p&gt;　　这里主要会在启动时读取appsettings.json中的AppId和MetaServer来连接Apollo，并且指定要读取哪个Namespace的配置项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHost BuildWebHost(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
&lt;strong&gt;                .ConfigureAppConfiguration((hostingContext, builder) &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;=&amp;gt;&lt;span&gt;
                {
                    builder
                    .AddApollo(builder.Build().GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apollo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;))
                    .AddDefault()
                    .AddNamespace(&quot;&lt;span&gt;TEST3.Shared&lt;/span&gt;&quot;);
                    .AddNamespace(&quot;&lt;span&gt;ClientService&lt;/span&gt;&quot;);
                })&lt;/strong&gt;
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.3 更改StartUp.cs&lt;/h2&gt;
&lt;p&gt;　　对于StartUp.cs，它承担了很多初始化的注入工作，我们会在里边引入很多配置项，但是幸运的是我们不需要做太多更改，只是把配置项的Key换成Apollo中定义的即可。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; IoC - DbContext&lt;/span&gt;
    services.AddDbContextPool&amp;lt;ClientDbContext&amp;gt;&lt;span&gt;(
                options &lt;/span&gt;=&amp;gt; options.UseSqlServer(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Swagger&lt;/span&gt;
    services.AddSwaggerGen(s =&amp;gt;&lt;span&gt;
    {
        s.SwaggerDoc(Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.DocName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Info
        {
            Title &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
            Version &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.Version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
            Description &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.Description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
            Contact &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Contact
            {
                Name &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.Contact:Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
                Email &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Swagger.Contact:Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
            }
        });
        ......
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里通过查看Swagger API文档来验证一下是否读出来了配置项Value：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804194641266-695722913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更多内容，请参考Apollo的.Net core客户端分支：&lt;a href=&quot;https://github.com/ctripcorp/apollo.net/tree/dotnet-core&quot; target=&quot;_blank&quot;&gt;https://github.com/ctripcorp/apollo.net/tree/dotnet-core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　这时如果我们在Apollo中更改了ClientService的Swagger.Title配置项并发布之后，重启一下ClientService，配置已经更改为下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180804195339376-1535724574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本篇简单介绍了一下统一配置中心与Apollo的基本概念，然后介绍了Apollo的快速安装（基于QuickStart）与基本配置，最后通过与ASP.NET Core的集成演示了如何在项目中使用Apollo替代原有的配置文件（appsettings.json）。当然，本篇只是一个QuickStart，更多的内容都没有覆盖，需要我们去看官方Wiki了解。Apollo目前在国内开发者社区比较热，在Github上有超过&lt;strong&gt;5k&lt;/strong&gt;颗星，在国内众多互联网公司&lt;strong&gt;有落地案例&lt;/strong&gt;，值得我们学习和了解&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）min.jiang，《&lt;a href=&quot;https://www.cnblogs.com/ASPNET2008/p/5166922.html&quot; target=&quot;_blank&quot;&gt;统一配置中心&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（2）张乐，《&lt;a href=&quot;https://blog.csdn.net/lepdou/article/details/70880285&quot; target=&quot;_blank&quot;&gt;开源配置中心之Apollo&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（3）陈珙，《&lt;a href=&quot;https://www.cnblogs.com/skychen1218/p/9300745.html&quot; target=&quot;_blank&quot;&gt;基于Windows Server部署Apollo初次体验&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（4）Apollo Quick Start: &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Quick-Start&quot; target=&quot;_blank&quot;&gt;https://github.com/ctripcorp/apollo/wiki/Quick-Start&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（5）Apollo GitHub: &lt;a href=&quot;https://github.com/ctripcorp/apollo&quot; target=&quot;_blank&quot;&gt;https://github.com/ctripcorp/apollo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（6）杨波，《&lt;a href=&quot;https://mp.weixin.qq.com/s/-hUaQPzfsl9Lm3IqQW3VDQ&quot; target=&quot;_blank&quot;&gt;携程配置中心Apollo架构分析&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（7）focus-lei，《&lt;a href=&quot;https://www.cnblogs.com/focus-lei/p/9077467.html&quot; target=&quot;_blank&quot;&gt;.Net core使用Apollo做统一配置中心&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（8）张善友，《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/8449863.html&quot;&gt;携程Apollo（阿波罗）配置中心在.NET Core项目快速集成&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;（9）ctrip，《&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/.Net%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97&quot; target=&quot;_blank&quot;&gt;Apollo .Net客户端使用指南&lt;/a&gt;》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 04 Aug 2018 11:58:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/9419379.html</dc:identifier>
</item>
</channel>
</rss>