<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>IntentService使用以及源码分析 - 九路313</title>
<link>http://www.cnblogs.com/start1225/p/10012322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/start1225/p/10012322.html</guid>
<description>&lt;h2 id=&quot;一-概述&quot;&gt;一 概述&lt;/h2&gt;
&lt;p&gt;我们知道，在Android开发中，遇到耗时的任务操作时，都是放到子线程去做，或者放到Service中去做，在Service中开一个子线程来执行耗时操作。&lt;br/&gt;那么，在Service里面我们需要自己管理Service的生命周期，何时开启何时关闭，还是很麻烦的，还好Android给我们提供了一个这样的类，叫做&lt;code&gt;IntentService&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么IntentService是做什么用的呢？&lt;br/&gt;IntentService: 是继承于Service的一个类，用来处理异步请求。可以直接通过startService(Intent intent)来提交请求，Service的创建，关闭，开子线程等工作，IntentService内部都帮我们封装好了，我们只需要发请求处理请求就行了。&lt;br/&gt;如此简单&lt;/p&gt;
&lt;p&gt;我们先来看一下IntentService的用法&lt;/p&gt;
&lt;h2 id=&quot;二-intentservice用法&quot;&gt;二 IntentService用法&lt;/h2&gt;
&lt;p&gt;假如我们现在有一个下载文件的需求，我们需要开启一个Service并在里面开启一个子线程中去下载文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 先继承IntentService实现一个类，我们叫做 DownloadService如下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DownloadService extends IntentService {

     //重写无参的构造方法
    public DownloadService(){
        super(&quot;DownloadService&quot;);
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        String url = intent.getStringExtra(&quot;url&quot;);
        downloadFile(url);
    }

    //下载文件
    private void downloadFile(String url){
        try {
            Log.e(&quot;DownloadService&quot;,&quot;当前线程名：&quot; + Thread.currentThread().getName());
            Log.e(&quot;DownloadService&quot;,&quot;文件开始下载... url=&quot;+url);
      
            //模拟下载文件操作
            Thread.sleep(3000);

            Log.e(&quot;DownloadService&quot;,&quot;文件下载完成...&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承IntentService类，实现&lt;code&gt;onHandleIntent(Intent intent)&lt;/code&gt;方法&lt;br/&gt;&lt;em&gt;注意，不要忘了DownloadService需要在清单文件中注册&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 我们在界面上的按钮的点击事件中，来下载一个文件，如下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  findViewById(R.id.tv_hello).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Log.e(&quot;DownloadService&quot;,&quot;当前线程名：&quot;+Thread.currentThread().getName());
            
                //像平时启动service方式一样，没有任何区别
                Intent intent = new Intent(MainActivity.this,DownloadService.class);
                intent.putExtra(&quot;url&quot;,&quot;http://xx/test.apk&quot;);
                startService(intent);
            }
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击按钮，输出&lt;br/&gt;E/DownloadService: 当前线程名：main&lt;br/&gt;E/DownloadService: 当前线程名：IntentService[DownloadService]&lt;br/&gt;E/DownloadService: 文件开始下载... url=http://xx/test.apk&lt;br/&gt;E/DownloadService: 文件下载完成...&lt;/p&gt;
&lt;p&gt;通过输出日志，可以看到，开启任务是在主线程中，而执行下载文件的耗时任务，是在子线程中，使用的时候，只需要startService(Intent intent)，并通过intent把所需要的数据带过去就行了。是不是很简单。&lt;/p&gt;
&lt;p&gt;下面来分析IntentService是如何做到的？&lt;/p&gt;
&lt;p&gt;## 三 IntentService源码分析&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 看下IntentService的类定义&lt;/strong&gt;&lt;br/&gt;```&lt;br/&gt;public abstract class IntentService extends Service {&lt;br/&gt;private volatile Looper mServiceLooper;&lt;br/&gt;private volatile ServiceHandler mServiceHandler;&lt;br/&gt;private String mName;&lt;br/&gt;private boolean mRedelivery;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private final class ServiceHandler extends Handler {
    public ServiceHandler(Looper looper) {
        super(looper);
    }

    @Override
    public void handleMessage(Message msg) {
        onHandleIntent((Intent)msg.obj);
        stopSelf(msg.arg1);
    }
}


......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;```&lt;br/&gt;可以看到，IntentService有几个需要注意的地&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;IntentService是一个Service也是一个抽象类,子类只需要实现&lt;code&gt;void onHandleIntent(@Nullable Intent intent)&lt;/code&gt;并在里面添加自己的业务即可&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;IntentService类中有一个 &lt;code&gt;Looper mServiceLooper&lt;/code&gt;以及一个&lt;code&gt;ServiceHandler mServiceHandler&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;ServiceHandler&lt;/code&gt;继承&lt;code&gt;Handler&lt;/code&gt;，并在&lt;code&gt;handleMessage()&lt;/code&gt;中调用了外部类的&lt;code&gt;onHandleIntent&lt;/code&gt;方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在&lt;code&gt;ServiceHandler&lt;/code&gt;的&lt;code&gt;handleMessage()&lt;/code&gt;方法中，执行完&lt;code&gt;onHandleIntent((Intent)msg.obj)&lt;/code&gt;,调用了&lt;code&gt;stopSelf(msg.arg1)&lt;/code&gt;来关闭这个&lt;code&gt;Service&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;所以&lt;code&gt;IntentService&lt;/code&gt;不用去管怎么创建的，怎么关闭的，怎么开启线程的，我们只需要继承&lt;code&gt;IntentService&lt;/code&gt;，实现&lt;code&gt;onHandleIntent()&lt;/code&gt;方法并在里面执行我们的逻辑就行了，执行完任务之后，自动会把&lt;code&gt;Service&lt;/code&gt;关闭。这一切都是&lt;code&gt;IntentService&lt;/code&gt;帮我们封装好了的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 startService之后，会走Service的生命周期方法,onCreate()源码如下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   @Override
    public void onCreate() {
        super.onCreate();
        
        //还记得上一篇讲的HandlerThread源码分析吗
        //创建一个HandlerThread对象，并调用start()方法
        //使之成为一个looper线程
        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);
        thread.start();
            
        //拿到上面创建的looper线程对应的looper
        //并传给ServiceHandler
        mServiceLooper = thread.getLooper();
        mServiceHandler = new ServiceHandler(mServiceLooper);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，在onCreate中创建了一个线程而且是一个looper线程，又创建了一个Handler对象，并把这个线程的looper传给了这个Handler，那么这个Handler发送的任务消息都会由这个ServiceHandler处理了&lt;/p&gt;
&lt;p&gt;再看看 onStart()方法和onStartCommand()方法，如下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onStart()方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Override
    public void onStart(@Nullable Intent intent, int startId) {
        Message msg = mServiceHandler.obtainMessage();
        msg.arg1 = startId;
        msg.obj = intent;
        mServiceHandler.sendMessage(msg);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;onStartCommand()方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  @Override
    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
        onStart(intent, startId);
        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;startService方法启动的时候，第一次会调用onCreate() -&amp;gt; onStart() -&amp;gt; onStartCommand()方法&lt;br/&gt;而且之后再次调用startService方法启动的时候，不会再调用onCreate()方法了，而是会调用onStandCommand()方法&lt;/p&gt;
&lt;p&gt;而在IntentService中，onStartCommand()方法中又会调用onStart()方法，所以，我们只需要分析onStart()方法即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onStart()方法源码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   @Override
    public void onStart(@Nullable Intent intent, int startId){
        //使用mServiceHandler获取一个消息
        Message msg = mServiceHandler.obtainMessage();
        msg.arg1 = startId;
        msg.obj = intent;
        
        //发送这个消息
        mServiceHandler.sendMessage(msg);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面可知，我们调用startService方法启动service的时候，会调用onStart()方法，在这个方法里面，把intent和startId赋值给了 msg ，并发送消息。这时候会调用Handler的handleMessag()方法,ServiceHandler的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class IntentService extends Service {
    private volatile Looper mServiceLooper;
    private volatile ServiceHandler mServiceHandler;
    private String mName;
    private boolean mRedelivery;

    private final class ServiceHandler extends Handler {
        public ServiceHandler(Looper looper) {
            super(looper);
        }

        @Override
        public void handleMessage(Message msg) {
            onHandleIntent((Intent)msg.obj);
            stopSelf(msg.arg1);
        }
    }
 
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到ServiceHandler是IntentService的内部类，而且在handleMessage中会调用IntentService的 onHandleIntent()方法，并把 intent 参数也传过去。&lt;/p&gt;
&lt;p&gt;我们来看下 onHandleIntent()方法&lt;br/&gt;&lt;code&gt;protected abstract void onHandleIntent(@Nullable Intent intent);&lt;/code&gt;&lt;br/&gt;是一个抽象方法，这时候就需要子类去实现这个方法并在里面做耗时的操作即可。&lt;/p&gt;
&lt;p&gt;经过上面的分析可知，IntentService使用也非常方便，原理就是利用HandlerThread开启了一个looper线程，并在onStart中把intent通过msg发送出去，并在handleMessage中又调用了onHandleIntent方法，子类实现即可&lt;/p&gt;
</description>
<pubDate>Sat, 24 Nov 2018 07:41:00 +0000</pubDate>
<dc:creator>九路313</dc:creator>
<og:description>一 概述 我们知道，在Android开发中，遇到耗时的任务操作时，都是放到子线程去做，或者放到Service中去做，在Service中开一个子线程来执行耗时操作。 那么，在Service里面我们需要自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/start1225/p/10012322.html</dc:identifier>
</item>
<item>
<title>Java反射的简单入门 - DingYu</title>
<link>http://www.cnblogs.com/dddyyy/p/10009678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dddyyy/p/10009678.html</guid>
<description>&lt;h3&gt;　　1.Class的简单介绍&lt;/h3&gt;
&lt;p&gt;　Class类的类表示正在运行的Java应用程序中的类和接口。 枚举是一种类，一个注解是一种接口， 每个数组也属于一个反映为类对象的类，该对象由具有相同元素类型和维数的所有数组共享。 原始Java类型（ &lt;code&gt;boolean&lt;/code&gt; ， &lt;code&gt;byte&lt;/code&gt; ， &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;float&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt; ），和关键字&lt;code&gt;void&lt;/code&gt;也表示为类对象。&lt;/p&gt;
&lt;p&gt;　　摘自jdk1.8中文版，刚开始看可能不懂，现在逐句来解释一下。&lt;/p&gt;

&lt;p&gt;　　第一句话：一个类被加载以后，JVM就会在内存中给创建一个对应类的Class对象。&lt;/p&gt;
&lt;p&gt;　　第二句话：类型相同的对象，维数相同的数组（不管长度）共享的是同一个内存中的Class对象。&lt;/p&gt;
&lt;p&gt;　　第三句话：上面这些原始的类型，也会在内存中有一个与之对象的Class对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dingyu;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Class的简单使用方法
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 70241
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClassDemo {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; classTest1() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Class class1 &lt;/span&gt;= Class.forName(&quot;com.dingyu.User&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一种获取Class对象的方法&lt;/span&gt;
            User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
            Class class2 &lt;/span&gt;= user.getClass();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二种获取Class对象的方法&lt;/span&gt;
            Class class3=User.&lt;span&gt;class&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三种获取Class对象的方法&lt;/span&gt;
            System.out.println(&quot;接下来判断到底同一类的不同对象的Class对象是不是同一个:&quot;
                    + (class1.hashCode() == class2.hashCode()&amp;amp;&amp;amp;class1.hashCode() ==&lt;span&gt; class3.hashCode()));

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; classTest2() {
        String[] s1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[10&lt;span&gt;];
        String[] s2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[30&lt;span&gt;];
        String[][] s3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[3][30&lt;span&gt;];
        System.out.println(s1.getClass().hashCode()&lt;/span&gt;==&lt;span&gt;s2.getClass().hashCode());
        System.out.println(s1.getClass().hashCode()&lt;/span&gt;==&lt;span&gt;s3.getClass().hashCode());
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1248002/201811/1248002-20181123202746256-488057352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1248002/201811/1248002-20181123202803465-194277815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2.Class获取类的属性，构造器，方法和注解的简单使用 &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dingyu;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Annotation;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Constructor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Class的简单用法
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; dingyu
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClassDemo02 {

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; usingClass() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        Class userClass &lt;/span&gt;= Class.forName(&quot;com.dingyu.User&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得类名&lt;/span&gt;
        System.out.println(userClass.getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得全类名&lt;/span&gt;
        System.out.println(userClass.getSimpleName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得类名

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得属性&lt;/span&gt;
        Field[] fields = userClass.getDeclaredFields();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得所有的属性&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Field field : fields) {
            System.out.println(field.getName());
        }

        System.out.println(userClass.getDeclaredField(&lt;/span&gt;&quot;id&quot;).getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得指定的属性

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得方法&lt;/span&gt;
        Method[] methods = userClass.getDeclaredMethods();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得所有的方法&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
            System.out.println(method.getName());
        }
        Method method &lt;/span&gt;= userClass.getDeclaredMethod(&quot;setId&quot;, &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得指定的方法，前面方法名，后面方法的参数&lt;/span&gt;
&lt;span&gt;        System.out.println(method.getName());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得构造器&lt;/span&gt;
        Constructor[] constructors =&lt;span&gt; userClass.getDeclaredConstructors();
        System.out.println(constructors.length);
        Constructor constructor &lt;/span&gt;= userClass.getDeclaredConstructor(&lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;, String.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得指定的构造器，需要指定构造的参数&lt;/span&gt;
&lt;span&gt;        System.out.println(constructor.getName());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得注解&lt;/span&gt;
        Annotation[] annotations =&lt;span&gt; userClass.getAnnotations();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Annotation annotation : annotations) {
            System.out.println(annotation);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定注解名&lt;/span&gt;
        MyAnnotation annotation = (MyAnnotation)userClass.getDeclaredAnnotation(MyAnnotation.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        System.out.println(annotation);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3.Class动态的调用构造器，方法，修改属性 &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dingyu;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Constructor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 使用反射动态的调用构造器，方法，修改属性 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 70241
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClassDemo03 {
    @Test
    @SuppressWarnings(&lt;/span&gt;&quot;all&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; usingClass() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Class class1 &lt;/span&gt;= Class.forName(&quot;com.dingyu.User&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用反射去调用构造器&lt;/span&gt;
        User user1 = (User) class1.newInstance();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用的是无参的&lt;/span&gt;
&lt;span&gt;        
        Constructor constructor &lt;/span&gt;= class1.getDeclaredConstructor(&lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;,String.&lt;span&gt;class&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得有参的构造器&lt;/span&gt;
        User user2 = (User) constructor.newInstance(04,&quot;dingyu&quot;,20);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态生成对象
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用反射去调用方法&lt;/span&gt;
        Method methodSetId = class1.getDeclaredMethod(&quot;setId&quot;,&lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        methodSetId.invoke(user1, &lt;/span&gt;02);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行user1中的setId，后面是给的参数&lt;/span&gt;
&lt;span&gt;        System.out.println(user1.getId());
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用反射去修改属性的值&lt;/span&gt;
        Field field = class1.getDeclaredField(&quot;age&quot;&lt;span&gt;);
        field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为age是私有的，加上这句就表示这个属性不需要做安全检查&lt;/span&gt;
        field.set(user1, 20&lt;span&gt;);
        System.out.println(field.get(user1));
        System.out.println(user1.getAge());
        
        
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4.反射获得带泛型的参数或返回值里泛型的的类型　　&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dingyu;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.ParameterizedType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Type;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 反射获得带泛型的参数或返回值里泛型的的类型
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; dingyu
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClassDemo04 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test01(Map&amp;lt;Integer, String&amp;gt;&lt;span&gt; map, String s) {

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;Integer, String&amp;gt;&lt;span&gt; test02() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数中带泛型的&lt;/span&gt;
        Method method = ClassDemo04.&lt;span&gt;class&lt;/span&gt;.getDeclaredMethod(&quot;test01&quot;, Map.&lt;span&gt;class&lt;/span&gt;, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        Type[] types &lt;/span&gt;= method.getGenericParameterTypes();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个 Type对象的数组， Type以声明顺序表示由该对象表示的可执行文件的形式参数类型
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印这些参数的类型&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Type type : types) {
            System.out.println(type.getTypeName());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type &lt;span&gt;instanceof&lt;/span&gt; ParameterizedType) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是泛型的参数&lt;/span&gt;
                Type[] actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得泛型的的类型&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Type type2 : actualTypeArguments) {
                    System.out.println(type2.getTypeName());
                }
            }
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回值中带泛型的&lt;/span&gt;
        Method method02 = ClassDemo04.&lt;span&gt;class&lt;/span&gt;.getDeclaredMethod(&quot;test02&quot;&lt;span&gt;);
        Type type &lt;/span&gt;= method02.getGenericReturnType();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回的类型
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印这些返回的类型            &lt;/span&gt;
&lt;span&gt;        System.out.println(type.getTypeName());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type &lt;span&gt;instanceof&lt;/span&gt; ParameterizedType) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是泛型的参数&lt;/span&gt;
            Type[] actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得泛型的的类型&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Type type2 : actualTypeArguments) {
            System.out.println(type2.getTypeName());
            }
        }            
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 24 Nov 2018 07:40:00 +0000</pubDate>
<dc:creator>DingYu</dc:creator>
<og:description>1.Class的简单介绍 Class类的类表示正在运行的Java应用程序中的类和接口。 枚举是一种类，一个注解是一种接口， 每个数组也属于一个反映为类对象的类，该对象由具有相同元素类型和维数的所有数组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dddyyy/p/10009678.html</dc:identifier>
</item>
<item>
<title>Elasticsearch Query DSL 整理总结（三）—— Match Phrase Query 和 Match Phrase Prefix Query - ReyCG</title>
<link>http://www.cnblogs.com/reycg-blog/p/10012238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reycg-blog/p/10012238.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;今天再读庄子的《逍遥游》，其中鲲鹏之扶摇直上九万里之气势，蜩（tiao）与学鸠之渺小之对比，令人印象深刻，并对鲲鹏之志心生向往。而郭象在注《庄子》卷中却说，&quot;苟足于其性，则虽大鹏无以自贵于小鸟，小鸟无羡于天池，而荣愿有余矣。故小大虽殊，逍遥一也。&quot;观看自身，虽然不是什么领导，老总，但也完全不必感到为职业生涯忧虑，只要热爱程序员这个工作，享受编码的乐趣，做到 80 岁又有何妨。&lt;/p&gt;
&lt;p&gt;书归正传，今天我们聊聊 Match Phase Query。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;match_phrase&lt;/code&gt; 查询针对的是一个语句，比如 &quot;like football&quot;, 分析时也会将整个语句作为整体,而不会像上篇的 &lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/10002794.html&quot;&gt;match 查询&lt;/a&gt; 会将整个语句拆分为单个词条。&lt;/p&gt;
&lt;p&gt;举个例子，创建一个 match_phase type 并塞进去一个文档, message 是 &lt;em&gt;I like swimming and riding!&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT matchphasetest
{}

PUT matchphasetest/_mapping/match_phase
{
  &quot;properties&quot;: {
    &quot;message&quot;: {
      &quot;type&quot;: &quot;text&quot;
    }
  }
}

PUT matchphasetest/match_phase/1
{
  &quot;message&quot;: &quot;I like swimming and riding!&quot;
}

GET matchphasetest/_search
{
  &quot;query&quot;: {
    &quot;match_phrase&quot;: {
      &quot;message&quot;: &quot;I like swimming&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认使用 &lt;code&gt;match_phrase&lt;/code&gt; 时会精确匹配查询的短语，需要全部单词和顺序要完全一样，标点符号除外。&lt;/p&gt;
&lt;h2 id=&quot;slop-参数&quot;&gt;slop 参数&lt;/h2&gt;
&lt;p&gt;这种精确匹配在大部分情况下显得太严苛了，有时我们想要包含 &quot;&quot;I like swimming and riding!&quot;&quot; 的文档也能够匹配 &quot;I like riding&quot;。这时就要以用到 &quot;slop&quot; 参数来控制查询语句的灵活度。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slop&lt;/code&gt; 参数告诉 &lt;code&gt;match_phrase&lt;/code&gt; 查询词条相隔多远时仍然能将文档视为匹配 什么是相隔多远？ 意思是说为了让查询和文档匹配你需要移动词条多少次？&lt;/p&gt;
&lt;p&gt;以 &quot;I like swimming and riding!&quot; 的文档为例，想匹配 &quot;I like riding&quot;，只需要将 &quot;riding&quot; 词条向前移动两次，因此设置 &lt;code&gt;slop&lt;/code&gt; 参数值为 2， 就可以匹配到。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET matchphasetest/_search
{
  &quot;query&quot;: {
    &quot;match_phrase&quot;: {
      &quot;message&quot;: {
        &quot;query&quot;: &quot;I like riding&quot;,
        &quot;slop&quot;: 2
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;analyzer-参数&quot;&gt;analyzer 参数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;match_phrase&lt;/code&gt; 语句也可以设置 &lt;code&gt;analyzer&lt;/code&gt; 参数来定义查询语句时对其中词条执行的分析过程。&lt;/p&gt;
&lt;p&gt;默认情况下，使用的是创建 mapping 时的分析器，如果没有指定就会使用默认的查询分析器。这里举个例子（只是如何使用）&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET /_search
{
    &quot;query&quot;: {
        &quot;match_phrase&quot; : {
            &quot;message&quot; : {
                &quot;query&quot; : &quot;this is a test&quot;,
                &quot;analyzer&quot; : &quot;my_analyzer&quot;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;zero-terms-query&quot;&gt;zero terms query&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;match_phrase&lt;/code&gt; 也接受 &lt;code&gt;zero_terms_query&lt;/code&gt; 为参数，使用方式和 &lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/10002794.html#zero-terms-query&quot;&gt;&lt;code&gt;match&lt;/code&gt;查询语句&lt;/a&gt;相同&lt;/p&gt;

&lt;p&gt;&lt;code&gt;match_phrase_prefix&lt;/code&gt; 和 &lt;code&gt;match_phrase&lt;/code&gt; 用法是一样的，区别就在于它允许对最后一个词条前缀匹配。以上节的数据为例，查询 &lt;code&gt;I like sw&lt;/code&gt; 就能匹配到&lt;/p&gt;
&lt;p&gt;&lt;code&gt;I like swimming and riding&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET matchphasetest/_search
{
  &quot;query&quot;: {
    &quot;match_phrase_prefix&quot;: {
      &quot;message&quot;: &quot;I like swi&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;max_expansions&quot;&gt;max_expansions&lt;/h2&gt;
&lt;p&gt;官方文档中说 &lt;code&gt;match_phrase_prefix&lt;/code&gt; 查询中有个参数 &lt;code&gt;max_expansions&lt;/code&gt; 说的是参数 &lt;code&gt;max_expansions&lt;/code&gt; 控制着可以与前缀匹配的词的数量，默认值是 50。&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;I like swi&lt;/code&gt; 查询为例，它会先查找第一个与前缀 &lt;code&gt;swi&lt;/code&gt; 匹配的词，然后依次查找搜集与之匹配的词（按字母顺序），直到没有更多可匹配的词或当数量超过 &lt;code&gt;max_expansions&lt;/code&gt; 时结束。&lt;/p&gt;
&lt;p&gt;但是我在使用时，故意造出了数十个以 &lt;code&gt;swi&lt;/code&gt; 开头的词，而将 &lt;code&gt;max_expansions&lt;/code&gt; 的值设为 10。但是却返回了所有的结果。在 elasitc 官网也有对该问题的&lt;a href=&quot;https://discuss.elastic.co/t/how-exactly-works-max-expansions-in-match-phrase-prefix-query/10815&quot;&gt;讨论&lt;/a&gt;, 也是没有找到答案。这个问题作为一个公案权且记下，如果您知道原因，麻烦告诉我，非常感谢。&lt;/p&gt;
&lt;p&gt;这里也贴出个例子，以备后面排查&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET matchphaseprefixtest/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;message&quot;: {
        &quot;query&quot;: &quot;I like sw&quot;,
        &quot;max_expansions&quot;: 10
       }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;match_phrase_prefix&lt;/code&gt; 用起来非常方便，能够实现输入即搜索的效果，但是也会出现问题。 假如说查询 &lt;code&gt;I like s&lt;/code&gt; 并且想要匹配 &lt;code&gt;I like swimming&lt;/code&gt; ，结果是默认情况下它会搜索出前 50 个组合，如果前 50 个没有 &lt;code&gt;swimming&lt;/code&gt; ，那就不会显示出结果。只能是用户继续输入后面的字母才可能匹配出结果。&lt;/p&gt;
&lt;p&gt;要实现更好的即使搜索的特性，可以看看 &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.3/search-suggesters-completion.html&quot;&gt;completion suggester&lt;/a&gt; 和&lt;br/&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/guide/master/_index_time_search_as_you_type.html&quot;&gt;Index-Time Search-as-You-Type&lt;/a&gt; 能不能实现。&lt;/p&gt;

&lt;p&gt;本文论述了 Match Phase Query 和 Match Phrase 前缀查询 的使用，下文会讲解 Multi Match Query 敬请期待。&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.3/query-dsl-match-query-phrase.html&quot;&gt;Match Phrase Query&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;query-dsl&quot;&gt;Query DSL&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/10000052.html&quot;&gt;Query DSL 概要，MatchAllQuery，全文查询简述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/10002794.html&quot;&gt;Match Query&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;java-rest-client-api&quot;&gt;Java Rest Client API&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/9931482.html&quot;&gt;Elasticsearch Java Rest Client API 整理总结 (一)——Document API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/9946821.html&quot;&gt;Elasticsearch Java Rest Client API 整理总结 (二) —— SearchAPI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/9993094.html&quot;&gt;Elasticsearch Java Rest Client API 整理总结 (三)——Building Queries&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 24 Nov 2018 07:32:00 +0000</pubDate>
<dc:creator>ReyCG</dc:creator>
<og:description>今天再读庄子的《逍遥游》，其中鲲鹏之扶摇直上九万里之气势，蜩（tiao）与学鸠之渺小之对比，令人印象深刻，并对鲲鹏之志心生向往。而郭象在注《庄子》卷中却说，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/reycg-blog/p/10012238.html</dc:identifier>
</item>
<item>
<title>CentOS下Docker与.netcore(五）之 三剑客之一Docker-swarm集群 - 老六代码</title>
<link>http://www.cnblogs.com/chenyishi/p/10012246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyishi/p/10012246.html</guid>
<description>&lt;h2&gt;1.什么是docker-swarm&lt;/h2&gt;
&lt;p&gt;在公司网站流量爆发式增长的时候，一台服务器往往不能满足需求，之前我的解决办法是通过nginx来实现负载均衡，有了docker-machine之后，解决方案会更加简单。当流量增加时，我们按照需要往docker-swarm集群中添加主机就可以了。&lt;/p&gt;
&lt;h2&gt;2.原理&lt;/h2&gt;
&lt;p&gt;我们把一组docker-swarm集群中的所有docker容器统称作一个service，其中的每一个docker容器称做一个task，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181124103512452-112067017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.开始搭建环境&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;docker-machine&quot; href=&quot;https://www.cnblogs.com/chenyishi/p/10007125.html#_label2&quot; target=&quot;_blank&quot;&gt;上一章&lt;/a&gt;我们讲了docker-machine，在这里我们需要用到。我在我本地Hyper-v创建4个虚拟机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181124111600745-1377948327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;CentOS设置静态IP：  192.168.8.200，并在这个虚机上搭建好docker-machine&lt;/p&gt;
&lt;p&gt;CentOS2设置静态IP：192.168.8.201&lt;/p&gt;
&lt;p&gt;CentOS3设置静态IP：192.168.8.202&lt;/p&gt;
&lt;p&gt;CentOS3设置静态IP：192.168.8.203&lt;/p&gt;
&lt;p&gt;然后通过200节点，分别在201，202，203上搭建好docker&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181124112022022-83646613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 1）docker-mashine  ssh 到host1上创建leader&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# docker-machine ssh host1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@host1 ~]# docker swarm init --advertise-addr 192.168.8.201
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）docker-mashine  ssh 到host2加入集群&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# docker-machine ssh host2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3）docker-mashine  ssh 到host1上查看集群列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181124115020891-385880043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，集群构建完毕，是一个最简单的集群&lt;/p&gt;
&lt;h2&gt;5.新建.netcore项目&lt;/h2&gt;
&lt;h6&gt; 1）修改ValueController.cs&lt;/h6&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        // GET api/values
&lt;span&gt;        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt;&lt;span&gt; Get()
        {
            var ip =&lt;span&gt; HttpContext.Connection.LocalIpAddress;
            var port =&lt;span&gt; HttpContext.Connection.LocalPort;
            return new string&lt;span&gt;[] { ip.ToString(), port.ToString() };
        }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;2）修改Program.cs&lt;/h6&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args).UseUrls(&quot;http://*:5000&quot;&lt;span&gt;)
                .UseStartup&amp;lt;Startup&amp;gt;();&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;3）新建dockerfile，并经属性设置为：始终复制到输出目录&lt;/h6&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;p&gt;FROM microsoft/dotnet:2.1-aspnetcore-runtime&lt;br/&gt;MAINTAINER yishi.chen&lt;/p&gt;
&lt;p&gt;LABEL description=&quot;DockerSwarmTest&quot;&lt;br/&gt;LABEL version=&quot;1.0&quot;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;WORKDIR /app&lt;br/&gt;COPY . .&lt;br/&gt;EXPOSE 5000&lt;br/&gt;ENTRYPOINT [&quot;dotnet&quot;,&quot;DockerSwarmTest.dll&quot;]&lt;/p&gt;
&lt;/div&gt;
&lt;h6&gt;4）构建image并上传到docker-hub&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181124121914173-681465084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h6&gt;5）创建service&lt;/h6&gt;
&lt;p&gt;我们先只创建一个容器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181124125008444-564104499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181124125044528-636067119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h6&gt;6）添加一个容器&lt;/h6&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@host1 ~]# docker service update --replicas 2 cys_web
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看运行状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181124141157891-1594422584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个都已经启动&lt;/p&gt;
&lt;h2&gt;6.模拟并发请求接口&lt;/h2&gt;
&lt;p&gt;新建一个控制台程序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
using&lt;span&gt; System;
using&lt;span&gt; System.Net.Http;
using&lt;span&gt; System.Net.Http.Headers;
using&lt;span&gt; System.Threading.Tasks;

namespace&lt;span&gt; Client
{
    class&lt;span&gt; Program
    {
        static HttpClient httpClient = new&lt;span&gt; HttpClient();
        static void Main(string&lt;span&gt;[] args)
        {
            Parallel.For(1, 10000, i =&amp;gt;&lt;span&gt;
            {
                HttpResponseMessage response = httpClient.SendAsync(new&lt;span&gt; HttpRequestMessage
                {
                    Method = new HttpMethod(&quot;GET&quot;&lt;span&gt;),
                    RequestUri = new Uri(&quot;http://192.168.8.202:5000/api/values&quot;&lt;span&gt;)
                }).Result;
                var result =&lt;span&gt; response.Content.ReadAsStringAsync().Result;
                Console.WriteLine(result);
            });
        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行测试，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181124141420094-1172648893.png&quot; alt=&quot;&quot; width=&quot;882&quot; height=&quot;463&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现，请求http://192.168.8.202:5000/api/values时，是对service中的两个容器实现轮询调用的，因此，docker swarm很简单的实现了负载，我们可以再把host3加进集群里，再测试一下有三个容器的情况的结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@host1 ~&lt;span&gt;]# docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
b6qt1dnbj4hnf2jks0rnxjm8y *   host1               Ready               Active              Leader              18.09.0&lt;span&gt;
p9vfq9qt6dtv929an5hzmirn9     host2               Ready               Active                                  18.09.0&lt;span&gt;
uy37l58v2ooux2tju89ex1o7q     host3               Ready               Active                                  18.09.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行控制台测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181124151745766-1591600802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三台机器完成负载！！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;至此三剑客分享完毕&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 24 Nov 2018 07:21:00 +0000</pubDate>
<dc:creator>老六代码</dc:creator>
<og:description>1.什么是docker-swarm 在公司网站流量爆发式增长的时候，一台服务器往往不能满足需求，之前我的解决办法是通过nginx来实现负载均衡，有了docker-machine之后，解决方案会更加简单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenyishi/p/10012246.html</dc:identifier>
</item>
<item>
<title>MangoDB高级应用 - SimpleWu</title>
<link>http://www.cnblogs.com/SimpleWu/p/10012219.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/10012219.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;Author:SimpleWu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;聚合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//统计员工总数
db.emp.aggregate([{$count:&quot;countName&quot;}])
//或者
db.emp.find().count()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;$group&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用$group是对筛选的数据进行分组。类似于mysql中的group by关键字。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//根据员工gender来分组并且统计数量
db.emp.aggregate([{$group : {_id : &quot;$gender&quot;, count: {$sum : 1}}}])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里_id是表示分组的字段，名字是固定的。&lt;/li&gt;
&lt;li&gt;count表示聚合生成列的名称。&lt;/li&gt;
&lt;li&gt;$sum表示聚合函数。&lt;/li&gt;
&lt;li&gt;1统计的值，其他聚合函数也可以是字段。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;聚合表达式&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;$sum&lt;/td&gt;
&lt;td&gt;计算总和。&lt;/td&gt;
&lt;td&gt;db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : &quot;$likes&quot;}}}])&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;$avg&lt;/td&gt;
&lt;td&gt;计算平均值。&lt;/td&gt;
&lt;td&gt;db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$avg : &quot;$likes&quot;}}}])&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;$min&lt;/td&gt;
&lt;td&gt;获取集合中所有文档对应值得最小值。&lt;/td&gt;
&lt;td&gt;db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$min : &quot;$likes&quot;}}}])&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;$max&lt;/td&gt;
&lt;td&gt;获取集合中所有文档对应值得最大值。&lt;/td&gt;
&lt;td&gt;db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$max : &quot;$likes&quot;}}}])&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;$push&lt;/td&gt;
&lt;td&gt;在结果文档中插入值到一个数组中。&lt;/td&gt;
&lt;td&gt;db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, url : {$push: &quot;$url&quot;}}}])&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;$addToSet&lt;/td&gt;
&lt;td&gt;在结果文档中插入值到一个数组中，但不创建副本。&lt;/td&gt;
&lt;td&gt;db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, url : {$addToSet : &quot;$url&quot;}}}])&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;$first&lt;/td&gt;
&lt;td&gt;根据资源文档的排序获取第一个文档数据。&lt;/td&gt;
&lt;td&gt;db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, first_url : {$first : &quot;$url&quot;}}}])&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;$last&lt;/td&gt;
&lt;td&gt;根据资源文档的排序获取最后一个文档数据&lt;/td&gt;
&lt;td&gt;db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, last_url : {$last : &quot;$url&quot;}}}])&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这些聚合函数基本上与mysql，oracle中效果是一致的。&lt;/p&gt;
&lt;h5 id=&quot;索引&quot;&gt;索引&lt;/h5&gt;
&lt;p&gt;所以这东西学习过数据库的都知道是不可缺少的，当然我们的MangoDB也是有的。&lt;/p&gt;
&lt;p&gt;索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文档，并选取那些符合查询条件的记录。&lt;/p&gt;
&lt;p&gt;创建索引语法：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;db.collection.createIndex(keys, options)
/*
key：你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。如果多个字段使用,隔开
*/
db.emp.createIndex({&quot;name&quot;:1})                    #创建单列索引
db.emp.createIndex({&quot;name&quot;:1,&quot;age&quot;:-1})      #创建多列索引。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;索引的常见操作&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//查看集合索引
db.emp.getIndexes()
//查看集合索引大小
db.emp.totalIndexSize()
//删除集合所有索引
db.emp.dropIndexes()
//删除集合指定索引
db.emp.dropIndex(&quot;索引名称&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;索引的种类&lt;/strong&gt;、&lt;/p&gt;
&lt;p&gt;在mysql里面索引有许多种类当然我们的MongoDB中也有很多种类:&lt;strong&gt;id索引、单键索引、多键索引、复合索引、过期索引、全文索引。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;id索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ID索引也称为主键索引，是我们创建一个集合时，自动创建的索引。&lt;/p&gt;
&lt;p&gt;集合的默认排序是按照id来进行排序的。在mongodb中id是根据ObjectId()来生成的，这个顺序是以时间撮来进行生成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单键索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单键索引是最普通的索引。&lt;/p&gt;
&lt;p&gt;和id索引不同，单键索引不会自动创建，需要我们手动创建。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;db.col.createIndex({&quot;name&quot;:1})//创建单列索引,对name列创建索引&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;多键索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多键索引和单键索引创建形式相同，区别在于字段的值。&lt;/p&gt;
&lt;p&gt;单键索引：值是一个单一的值，例如：字符串，数字或者日期。&lt;/p&gt;
&lt;p&gt;多键索引：值有多个记录，例如：数组。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;db.emp.createIndex({&quot;name&quot;:1,&quot;age&quot;:-1})//创建多列索引,对name和age创建索引&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;复合索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们的查询条件不只一个时，就需要建立符合索引。符合索引是在多个列上同时创建索引。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;db.col.createIndex({&quot;name&quot;:1,&quot;age&quot;:-1})  //创建复合索引。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;索引的命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，索引的命名是列+1或者-1，这种方式不是很方面记忆，而且删除是也不太方面。这时候我们就需要为索引创建一个名称。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//创建索引并命名为ix_name。
db.students.createIndex({name:-1},{name:&quot;ix_name&quot;})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以为索引添加一个唯一性，从而保存该列的数据不允许重复。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//创建索引并命名为ix_name。
db.students.createIndex({name:-1},{name:&quot;ix_name&quot;,unique:true})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过期索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;过期索引：就是在一段时间后会自动过期的索引。在索引过期后，相应的数据也会被删除。&lt;/p&gt;
&lt;p&gt;适合存储一些希望一段时间后会失效的数据，比如用户登录信息，存储的日志等。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;db.collections.createIndex({time:1},{expireAfterSeconds:10})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过期索引的一些限制:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;过期索引的值必须是指定的时间类型，必须使用ISODate或者ISODate数组，不能使用时间撮，否则不会被自动删除。&lt;/li&gt;
&lt;li&gt;如果指定的是ISODate数组，则按照最小时间删除。&lt;/li&gt;
&lt;li&gt;过期索引不能是复合索引。&lt;/li&gt;
&lt;li&gt;删除时间是有一定的误差，由于删除过程是由后台程序每60秒跑一次，而且删除数据也需要一定的时间。所以存在误差。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;全文索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当要对一篇文章中的文本内容进行搜索的时候，这个时候可以考虑全文索引。全文索引可以加快检索内容关键字的效率。全文索引只能对字符串或者字符串数组有效。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//创建全文索引
db.students.createIndex({name:&quot;text&quot;,info:&quot;text&quot;})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用全文索引&lt;/p&gt;
&lt;p&gt;创建好全文索引后，我们就可以来使用全文索引，使用全文索引需要使用$text和$search两个运算符。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//查找全文索引中包含了zhangsan的文档。
db.students.find({$text:{$search:&quot;zhangsan&quot;}})

//查找全文索引中包含了zhangsan或者zhangsanfeng的文档。
db.students.find({$text:{$search:&quot;zhangsan zhangsanfeng&quot;}})

//查找全文索引中包含了zhangsan，但不包含zhangsanfeng的文档。
db.students.find({$text:{$search:&quot;zhangsan -zhangsanfeng&quot;}})

//查找全文索引中包含了zhangsan和zhangsanfeng的文档。
db.students.find({$text:{$search:&quot;\&quot;zhangsan\&quot; \&quot;zhangsanfeng\&quot;&quot;}})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全文索引的相似度&lt;/p&gt;
&lt;p&gt;我们在百度中搜索时，经常会看到和我们关键字匹配度越高的，排行就越靠前。在mongodb中，我们还可以返回查询结果的相似度，与sort一起使用效果会更好。&lt;/p&gt;
&lt;p&gt;使用方式：在find后面跟上{score:{$meta:&quot;textScore&quot;}}&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;db.students.find({$text:{$search:&quot;zhangsan&quot;}},{score:{$meta:&quot;textScore&quot;}})
.sort({score:{$meta:&quot;textScore&quot;}})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全文索引的限制&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每次查询只能指定一个text。&lt;/li&gt;
&lt;li&gt;text操作符不能出现在$nor查询中。&lt;/li&gt;
&lt;li&gt;查询中如果包含了text则hint将不再起作用。&lt;/li&gt;
&lt;li&gt;mongodb的全文索引对中文支持不是很好。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;索引的注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引像一把双刃剑，用得好可以提高查询效率，如果用不好可能会导致性能的降低。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;$where和$exists完全不能走索引&lt;/li&gt;
&lt;li&gt;ne取反操作效率很低&lt;/li&gt;
&lt;li&gt;$not、$nin$or、$in&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;explain执行计划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引的性能如何，我们可以通过explain执行计划来进行分析，从而使索引的性能达到最优。&lt;/p&gt;
&lt;p&gt;explain的使用方式非常简单，我们只需要在执行的find()命令后添加一个explain()方法即可。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;db.students.find().explain();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;文档之间的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多时候数据库中的数据不是单独存在的，数据和数据之间会有一些相互之间的联系。我们mongodb可以配置这种数据之间的关系。&lt;/p&gt;
&lt;p&gt;文档之间的关系&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一对一（one to one）&lt;/li&gt;
&lt;li&gt;一对多（one to many）&lt;/li&gt;
&lt;li&gt;多对一（many to one）&lt;/li&gt;
&lt;li&gt;多对多（many to many）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每种关系又可以有两种方式来实现。&lt;/p&gt;
&lt;p&gt;嵌入式：嵌套在一个document文档中。&lt;/p&gt;
&lt;p&gt;引用式：通过外键引用的方式来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java操作MongoDB&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下载MongoDB驱动http://mongodb.github.io/mongo-java-driver/&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.mongodb&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mongodb-driver&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连接数据库，你需要指定数据库名称，如果指定的数据库不存在，mongo会自动创建数据库。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main( String args[] ){
      try{   
         // 连接到 mongodb 服务
         MongoClient mongoClient = new MongoClient( &quot;localhost&quot; , 27017 );
       
         // 连接到数据库
         MongoDatabase mongoDatabase = mongoClient.getDatabase(&quot;students&quot;);  
         System.out.println(&quot;Connect to database successfully&quot;);
        
      }catch(Exception e){
         System.err.println( e.getClass().getName() + &quot;: &quot; + e.getMessage() );
     }
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用 com.mongodb.client.MongoDatabase 类中的createCollection()来创建集合&lt;/p&gt;
&lt;p&gt;我们可以使用com.mongodb.client.MongoCollection类的 insertMany() 方法来插入一个文档。&lt;/p&gt;
&lt;p&gt;我们可以使用 com.mongodb.client.MongoCollection 类中的 find() 方法来获取集合中的所有文档。&lt;/p&gt;
&lt;p&gt;你可以使用 com.mongodb.client.MongoCollection 类中的 updateMany() 方法来更新集合中的文档。&lt;/p&gt;
&lt;p&gt;要删除集合中的第一个文档，首先你需要使用com.mongodb.DBCollection类中的 findOne()方法来获取第一个文档，然后使用remove 方法删除。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Nov 2018 07:13:00 +0000</pubDate>
<dc:creator>SimpleWu</dc:creator>
<og:description>MongoDB高级应用 Author:SimpleWu 聚合 聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count( )。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/10012219.html</dc:identifier>
</item>
<item>
<title>Jenkins凭证及任务演示-pipeline（二）--技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/10009279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/10009279.html</guid>
<description>
&lt;h2&gt;Jenkins前言&lt;/h2&gt;

&lt;p&gt;在上一篇博客《&lt;a id=&quot;post_title_link_10001180&quot; href=&quot;https://www.cnblogs.com/kenken2018/p/10001180.html&quot;&gt;Jenkins持续集成介绍及插件安装版本更新演示（一）--技术流ken&lt;/a&gt;》中已经详细介绍了jenkins的插件安装以版本更新等，本篇博客将再深入探究jenkins的更多功能，以便能够熟练使用jenkins完成工作中的内容。&lt;/p&gt;
&lt;p&gt;本篇博客将详细讲解有关jenkins的凭证以及新建任务的演示，有关jenkins系列会一直更新到jenkins与gitlab和ansible完成动态和静态网站持续集成自动化部署为止，敬请期待。&lt;/p&gt;

&lt;h2&gt;Jenkins凭证介绍&lt;/h2&gt;

&lt;p&gt;有许多第三方网站和应用程序可以与 Jenkins 进行交互，例如程序代码仓库，云存储系统和服务等。&lt;/p&gt;
&lt;p&gt;此类应用程序的系统管理员可以在应用程序中配置凭证以专供 Jenkins 使用。通常通过将访问控制应用于这些凭证来完成这项工作，以“锁定”Jenkins可用的应用程序功能区域。一旦 Jenkins 管理员（即管理 Jenkins 站点的 Jenkins 用户）在 Jenkins 中添加/配置这些凭证，Pipeline 项目就可以使用凭证与这些第三方应用程序进行交互。&lt;/p&gt;

&lt;p&gt;Jenkins 中保存的凭证可以用于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任何适用于 Jenkins 的任何地方（即全局证书）&lt;/li&gt;
&lt;li&gt;特定的 Pipeline 项目&lt;/li&gt;
&lt;li&gt;特定的 Jenkins 用户&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Jenkins凭证的创建&lt;/h2&gt;

&lt;p&gt;第一步：创建凭证&lt;/p&gt;
&lt;p&gt;进入你的jenkins的首页，点击左边栏的凭证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123184941268-2135435115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二步：点击全局凭据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123185216608-411509932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第三步：点击 添加一些凭据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123185311011-1458645515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四步：输入信息&lt;/p&gt;
&lt;p&gt;在如下的对话框中输入你的信息点击确定即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123185349655-2128581949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第五步：首页查看&lt;/p&gt;
&lt;p&gt;即可看到我们已经添加的凭据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123185516504-605826463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;新建任务演示&lt;/h2&gt;

&lt;p&gt;如果你想使用jenkins完成日常的工作，那么你必须要学会如何使用任务。&lt;/p&gt;
&lt;p&gt;所谓的任务你可以这样理解就是你需要执行的一系列动作。&lt;/p&gt;
&lt;p&gt;第一步：点击新建任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123185915387-1818366454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二步：输入你要创建的任务名称&lt;/p&gt;
&lt;p&gt;输入完成点击下方的确定即可&lt;/p&gt;
&lt;p&gt;注意：名称不能有空格&lt;/p&gt;
&lt;p&gt;这个名称就是一个目录，接下来我们会演示git，git拉取到的内容就是保存了这个同名目录下面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123185953017-1855389876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第三步：填写你需要看到的信息&lt;/p&gt;
&lt;p&gt;在参数构建过程中参数有几个你必须知道的是文本参数和选项参数&lt;/p&gt;
&lt;p&gt;这里我选择选项参数进行演示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123190214042-1984983789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123190549406-1468672548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第四步：git获取项目&lt;/p&gt;
&lt;p&gt;URL输入你的项目地址&lt;/p&gt;
&lt;p&gt;凭证哪里添加可以获取到你的项目的用户和用户名&lt;/p&gt;
&lt;p&gt;branch哪里添加分支&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123190709429-673993634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第五步：构建&lt;/p&gt;
&lt;p&gt;这里就是把 你的命令添加在这里即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123190838987-177381039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在shell中添加如下内容并保存即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123191121430-1399283639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第六步：构建参数&lt;/p&gt;
&lt;p&gt;如果你选择了选项参数，在这个任务界面就可以看到这个选项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123191145927-158341588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点开这个，就会看到我们刚才输入的tyep以及auto了（忘记了请往上翻一下哦）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123191239450-18638842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第七步：返回结果&lt;/p&gt;
&lt;p&gt;如果执行成功了左下角的圆圈就是蓝色的&lt;/p&gt;
&lt;p&gt;执行失败了就是红色&lt;/p&gt;
&lt;p&gt;鼠标放上去也会看到提示信息的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123191349159-86883924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第八步：查看执行过程&lt;/p&gt;
&lt;p&gt;下图中的红色框都是我刚才执行的命令&lt;/p&gt;
&lt;p&gt;第一列：的/var/lib/jenkins/workspace/test_for_block 是echo 的结果，表示jenkins现在工作目录是在你的任务名称下的&lt;/p&gt;
&lt;p&gt;第二列：显示当前所在的目录，其实可以发现我们现在就处在自己的新建任务的同名目录中&lt;/p&gt;
&lt;p&gt;第三列：进入到工作目录，即当下&lt;/p&gt;
&lt;p&gt;第四列：给我们展示了当前目录下的所有文件，可以看到我们远程仓库中的文件已经被拉取到了当前文件夹下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123191524436-148966141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;pipeline结构介绍&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;层级结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一层：pipline，这是最外层&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二层：stages，这层是用来完成一个特定的工作，其中有一个或者多个子层，每个子层是一个stage&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三册：stage，这是stages的子层&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四层：steps，这层是定义具体要执行的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pipline {

 agent any;

 environment {

  user&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;deploy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

     host&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.2.3.4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

     PATH&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

 }

 stages {

  stage(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bulid job&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {

   environment {

       NEWPATH&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/bin:/sbin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

   }

   steps {

    sh &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/a.sh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

    echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hi boys&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

    script{

     xxxx

     xxxx

    }

   }

  }

 }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区域：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.  agent：定义当前的job运行在哪个jenkins节点上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  any:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  none:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  node:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  agent {node {label 'ser1'}}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  agent any&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2. environment：定义环境变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  格式：变量名=变量值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3. script：可选的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4. steps：借助于特定的jenkis模块来完成特定的工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  echo&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  git&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;pipeline演示&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt; 第一步：新建任务&lt;/p&gt;
&lt;p&gt;选择流水线&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123192924087-1322368573.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 第二步: 编写pipeline&lt;/p&gt;
&lt;p&gt;可以发现这里面的界面比我们之前选择的freestyle界面简洁的多&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123193015177-171863569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里填写你的pipeline保存即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123193151343-2004881840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第三步：构建&lt;/p&gt;
&lt;p&gt;点击立即构建即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123193226281-1163255677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四步：查看执行结果&lt;/p&gt;
&lt;p&gt;可以发现执行成功&lt;/p&gt;
&lt;p&gt;pipeline的功能很多，在接下来的博客当中会使用pipeline完成动态网站的持续集成部署。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181123193827148-675500523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 上面例子中的pipeline代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pipeline{
 agent {node {label &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}}
 environment {
  PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
 }

 parameters{
  choice(
   name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deploy_env&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
   choices: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dev\nprod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
   description: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is for liang lei xi tong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  )
  &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;(name: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,defaultValue: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, description: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;版本号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 }

 stages {
  stage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test for pipline job&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;){
   steps{
    sh &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git config --global http.sslVerify false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    dir    (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${env.WORKSPACE}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;){
     git branch:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     url:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://10.220.5.232/gp1/wordpress.git&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     credentialsId:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;119a7e29-4c6c-4f75-bfdb-56fa0edcafaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    }
   }
  }
  stage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;print bianlian&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;){
   steps{
    sh &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;     &lt;span&gt;set&lt;/span&gt; +&lt;span&gt;x
     echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===============start job==============&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
     echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你选的类型是 $deploy_env&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
     echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;your version is $version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
     echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===============stop job ==============&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
     &lt;span&gt;set&lt;/span&gt; -&lt;span&gt;x
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;   }
  }
 }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 24 Nov 2018 07:11:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>Jenkins前言 在上一篇博客《Jenkins持续集成介绍及插件安装版本更新演示（一）--技术流ken》中已经详细介绍了jenkins的插件安装以版本更新等，本篇博客将再深入探究jenkins的更多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/10009279.html</dc:identifier>
</item>
<item>
<title>从Docker 到Jenkins 到Ansible的部署经验 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/10011816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/10011816.html</guid>
<description>&lt;p&gt;工作中，除了开发功能，还负责系统的部署工作。我从频繁的部署工作中，逐渐找到了一些偷懒的方法。从传统的Java -jar命令启动服务，到通过Docker 容器构建部署服务，再后来通过自动化部署工具Jenkins来完成部署，最后再结合Ansible完成远程部署。一步步的进步极大的减少部署工作，提高了工作效率（增加了许多划水时间）。&lt;/p&gt;
&lt;h2 id=&quot;docker&quot;&gt;Docker&lt;/h2&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;blockquote readability=&quot;6.8745519713262&quot;&gt;
&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的&lt;a href=&quot;https://baike.baidu.com/item/Linux&quot;&gt;Linux&lt;/a&gt;机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Docker给我的印象很深，没有什么环境是docker pull 解决不了的，&lt;/p&gt;
&lt;h3 id=&quot;常用命令&quot;&gt;常用命令&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;docker ps           ， docker ps 默认显示运行中的容器，-a 显示所有，-l显示近期创建的容器

docker start xxx    ， 启动xxx容器

docker restart xxx  ， 重启xxx容器

docker run xxx      ， 创建并运行xxx容器

docker build -t xxx .   ，使用 Dockerfile 创建镜像

docker stop xxx     ， 关闭容器

docker rm xxx       ， 删除容器

docker images       ， 查看所有镜像

docker rmi xxx      ， 删除xxx镜像

docker exec -it xxx sh          ， 进入xxx容器中，用quit退出

docker logs -f xxx --tail 500   ， 查看xxx容器的日志，显示最后500行，常用命令

docker inspect xxxx             ， 查看容器配置信息

docker-compose -f app.yml up -d ， 按照app.yml文件配置以debug形式启动

docker-compose -f app.yml down  ， 按照app.yml文件配置形式关闭
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;第一步：在gradle项目加入docker插件，即在gradle.build 文件中加入以下代码。需要注意的有插件的版本，项目打包后的名称，Dockerfile文件目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dependencies {
    classpath(&quot;se.transmode.gradle:gradle-docker:1.2&quot;)
}

apply plugin: 'docker'

task buildDocker(type: Docker, dependsOn: build) {
    push = false
    applicationName = &quot;项目名&quot;
    dockerfile = file('src/main/docker/Dockerfile文件目录')
    doFirst {
        copy {
            from jar
            into stageDir
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：创建Dockerfile文件，文件目录要和第一步中设置的保持一致。需要配置jdk镜像和基本的启动参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM frolvlad/alpine-oraclejdk8:slim
VOLUME /tmp
ADD 项目jar名称.jar app.jar
RUN sh -c 'touch /app.jar'
ENV JAVA_OPTS=&quot;&quot;
ENV PORT=&quot;6666&quot;
ENV DB_CONNECTION=&quot;jdbc:mysql://ip:port/database&quot;
ENV DB_USER=&quot;user&quot;
ENV DB_PASSWORD=&quot;password&quot;
ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar --spring.datasource.url=$DB_CONNECTION --spring.datasource.usernam=$DB_USER --spring.datasource.password=$DB_PASSWORD --port=$PORT&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步：将jar拷贝到服务器上，然后执行编译，运行的docker命令&lt;/p&gt;
&lt;p&gt;一）、通过gradle的bootJar，将项目打包。同时需要把引入的第三方jar也要一起打入到项目jar中。&lt;/p&gt;
&lt;p&gt;二）、Windows系统中可以通过Xftp将jar和Dockerfile文件拷贝同一个目录下。Linux系统可以通过scp命令上传文件。&lt;/p&gt;
&lt;p&gt;三）、执行docker ps，查看当前运行的容器，执行docker stop和docker rm 关闭和删除之前旧版本的容器&lt;/p&gt;
&lt;p&gt;四）、找到jar的目录，并在当前目录下，执行 docker build -t 镜像名称 . 的命令编译项目，注意后面的点不要漏了。&lt;/p&gt;
&lt;p&gt;五）、编译成功后执行 docker run --name 容器名 -v /tmp:/tmp -p 对外开发的端口:项目启动的端口 镜像名:latest 。启动容器&lt;/p&gt;
&lt;p&gt;六）、执行docker ps，查看容器启动是否正常启动。同时执行docker logs -f 容器名 --tail 500，查看容器启动日志，检查是否有异常&lt;/p&gt;
&lt;p&gt;七）、最后浏览器访问一下，已确保部署成功。&lt;/p&gt;
&lt;p&gt;全称大概需要几分钟的时间，虽然不算麻烦。可次数多了，就很麻烦了。有没有什么好的工具帮助我们完成这一系列操作呢？答案是肯定的。&lt;/p&gt;
&lt;h2 id=&quot;jenkins&quot;&gt;Jenkins&lt;/h2&gt;
&lt;h3 id=&quot;简介-1&quot;&gt;简介&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The leading open source automation server, Jenkins provides hundreds of plugins to support building, deploying and automating any project.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Jenkins 的logo是一个管家的形象，很贴切。对它的理解比较肤浅。他通过管理Git上的项目，来确保每次打包的jar都是最新的。同时在构建成功后执行我们输入的shell命令，来达到自动化部署的工作。&lt;/p&gt;
&lt;h3 id=&quot;使用场景-1&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;第一步：创建一个负责编译的Jenkins项目，&lt;/p&gt;
&lt;p&gt;在Jenkins控制台页面，点击页面左上角的“新建”按钮。再输入项目名后，可以选择创建一个空项目，也可以在页面最下面选择copy from 其他项目。不管如何创建，我们需要Jenkins管理项目的源码，构建和构建后的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/806956/201811/806956-20181124150745735-1629745350.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/806956/201811/806956-20181124150801750-1408481275.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步：创建一个负责运行的Jenkins项目&lt;/p&gt;
&lt;p&gt;以同样的方式创建项目，在构建触发器上，选择第一步创建的项目，构建的Shell命令是先删除之前的容器，然后在重新运行容器。若之前的容器不存在，则会构建失败。所以第一次构建的时候把第一行命令删掉。解决方案傻乎乎的，只是因为没有花时间去处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/806956/201811/806956-20181124150834692-612139798.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/806956/201811/806956-20181124150845007-951925308.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步：选择编译项目，点击立即构建，当第一个项目构成成功后，会自动触发运行项目。等待两个项目都成功后，就可以访问浏览器，检查功能。&lt;/p&gt;
&lt;p&gt;有了Jenkins，一切变得轻松很多。但他也有一个较大的弊端，就是使用前必须要先安装。特别是在客户的服务器上，也许别人就只跑这一个服务，你给别人整了一个Jenkins，似乎有点大材小用了。有没有好的解决方法？答案是肯定的。&lt;/p&gt;
&lt;h2 id=&quot;ansible&quot;&gt;Ansible&lt;/h2&gt;
&lt;h3 id=&quot;简介-2&quot;&gt;简介&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Ansible is an IT automation tool. It can configure systems, deploy software, and orchestrate more advanced IT tasks such as continuous deployments or zero downtime rolling updates.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从接触到使用Ansible大概有一天的时间，对它的理解也是比较肤浅。我单纯的认为，他可以帮助我们在服务器之间传输文件，同时还可以执行一些shell命令。抱着这样的想法，我们可以通过Jenkins完成自动化编译，再通过Ansible传输资源文件到部署的环境中，同时执行启动Shell命令。&lt;/p&gt;
&lt;h3 id=&quot;使用场景-2&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;第一步：修改Jenkins运行项目的构建Shell，将之前的docker run改成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ansible-playbook ansible命令文件路径/app.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：创建Ansible脚本文件app.yaml，目录和第一步中设置的保存一致，模版大致如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- hosts: '需要部署的远程服务ip'
  tasks:
   - name: &quot;关闭旧版本的容器&quot;
     shell: docker stop xxx
     ignore_errors: true
   - name: &quot;删除旧版本的容器&quot;
     shell: docker rm xxx
     ignore_errors: true
   - name: &quot;删除之前的旧文件&quot;
     shell: rm -rf /旧文件路径/*
   - name: &quot;传输Dockerfile文件&quot;
     copy:
       src=/文件目录/Dockerfile
       dest=/远程服务指定目录
   - name: &quot;传输Jar文件&quot;
     copy:
       src=/jar目录/xxx.jar
       dest=/远程服务指定目录
   - name: &quot;构建docker 镜像&quot;
     shell: chdir=/jar所在目录 nohup docker build -t 镜像名 .
   - name: &quot;启动容器&quot;
     shell: nohup docker run --name 容器名 -v /挂载路径/:/挂载路径/ -p 对外端口:服务端口 -d 镜像名:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步：在Jenkins上构建编译项目。&lt;/p&gt;
&lt;h2 id=&quot;前后端项目的部署&quot;&gt;前后端项目的部署&lt;/h2&gt;
&lt;p&gt;到这里，三种部署的流程就完成了。如果你熟悉Docker的方式构建，再用Jenkins和Ansible的时候，就会简单很多。我在实际开发中，项目是前后端分离的。公司做了两个方案，&lt;/p&gt;
&lt;p&gt;第一种：前后端分开部署，即Jenkins上有四个项目。前端和后端各两个项目。这样的好处就是前后端互不影响。不会因为对方的错误而从新编译。缺点也是有的，很难保证对方部署的环境是最新的。&lt;/p&gt;
&lt;p&gt;第二种：把前后端放在一个项目中，一次构建完成两个项目的打包部署。缺点是构建慢，优点就是保证两端的代码都是最新的，适合发布到预发布环境和正式环境。&lt;/p&gt;
&lt;p&gt;那么，针对前后端一起部署的需求，Jenkins和Ansible同样也需要简单的修改。其思路就是Jenkins负责编译项目，将资源文件压缩，再通过Ansible上传到其他服务器上。执行解压，构建，启动的命令。&lt;/p&gt;
&lt;p&gt;看起来视乎很简单，但有一个坑希望你们跨过去。前端打包需要npm或者其他工具，但是你的服务器上没有安装。此时请务必通过Jenkins控制台，或者用Jenkins帐号登录服务器安装这些工具。笔者就是通过root帐号登录服务器安装的npm，通过Jenkins编译时提示没有权限。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Nov 2018 07:05:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<og:description>从Docker 到Jenkins 到Ansible的部署经验 工作中，除了开发功能，还负责系统的部署工作。我从频繁的部署工作中，逐渐找到了一些偷懒的方法。从传统的Java jar命令启动服务，到通过D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/10011816.html</dc:identifier>
</item>
<item>
<title>看完动画你还会不懂 快速排序么 - 五分钟学算法</title>
<link>http://www.cnblogs.com/fivestudy/p/10012193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fivestudy/p/10012193.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;22.416689391873&quot;&gt;
&lt;h2 id=&quot;-&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 ——-《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;快速排序&lt;/h2&gt;
&lt;p&gt;快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。&lt;br/&gt;快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。&lt;br/&gt;快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;算法步骤&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;从数列中挑出一个元素，称为 “基准”（pivot）;&lt;/li&gt;
&lt;li&gt;重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；&lt;/li&gt;
&lt;li&gt;递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；&lt;br/&gt;递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。&lt;br/&gt;来源：&lt;a href=&quot;https://github.com/hustcc/JS-Sorting-Algorithm&quot;&gt;https://github.com/hustcc/JS-Sorting-Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;-&quot;&gt;算法演示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1940317-3bf6002ba2c0b90b?imageMogr2/auto-orient/strip&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;排序动画过程解释&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;首先，操作数列中的所有数字&lt;/li&gt;
&lt;li&gt;在所有数字中选择一个数字作为排序的基准（pivot）, pivot 通常是随机选择的，在这里为了演示方便，我们选择最右边的数字作为 pivot&lt;/li&gt;
&lt;li&gt;选取好 pivot 后，在操作数列中选择最左边的数字标记为 左标记 ，最右边的数字标记为 右标记&lt;/li&gt;
&lt;li&gt;将左边的标记向右移动&lt;/li&gt;
&lt;li&gt;当 左标记 达到超过 pivot 的数字时，停止移动&lt;/li&gt;
&lt;li&gt;在这里，8 &amp;gt; 6 ,所以停止移动&lt;/li&gt;
&lt;li&gt;然后将右边的标记向左移动&lt;/li&gt;
&lt;li&gt;当 右标记 达到小于 pivot 的数字时，停止移动&lt;/li&gt;
&lt;li&gt;在这里，4 &amp;gt; 6 ,所以停止移动&lt;/li&gt;
&lt;li&gt;当左右标记停止时，更改标记的数字&lt;/li&gt;
&lt;li&gt;因此，左标记 的作用是找到一个大于 pivot 的数字，右标记 的作用是找到一个小于 pivot 的数字&lt;/li&gt;
&lt;li&gt;通过交换数字，可以在数列的左边收集小于 pivot 的数字集合，右边收集大于 pivot 的数字集合&lt;/li&gt;
&lt;li&gt;交换之后，继续移动 左标记&lt;/li&gt;
&lt;li&gt;在这里，9 &amp;gt; 6 ,所以停止移动&lt;/li&gt;
&lt;li&gt;然后将右边的标记向左移动&lt;/li&gt;
&lt;li&gt;当 右标记 碰撞到 左标记 时也停止移动&lt;/li&gt;
&lt;li&gt;如果左右侧的标记停止时，并且都在同一个位置，将这个数字和 pivot 的数字交换&lt;/li&gt;
&lt;li&gt;这就完成了第一次操作&lt;/li&gt;
&lt;li&gt;小于 6 的都在 6 的左侧，大于 6 的都在 6 的右侧&lt;/li&gt;
&lt;li&gt;然后递归对这分成的两部分都执行同样的操作&lt;/li&gt;
&lt;li&gt;完成 快速排序&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;-&quot;&gt;代码实现&lt;/h2&gt;
&lt;p&gt;为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。&lt;/p&gt;
&lt;h4 id=&quot;c-&quot;&gt;C++代码实现&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1940317-6edb0a2e86d357aa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;C++代码实现&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;java-&quot;&gt;Java代码实现&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1940317-6f2518caa5243a26?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Java代码实现&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;python-&quot;&gt;Python代码实现&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1940317-e47225f13dcfa7d4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Python代码实现&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;javascript-&quot;&gt;JavaScript代码实现&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1940317-1dabb92ad440181b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;JavaScript代码实现&quot;/&gt;&lt;br/&gt;如果你是iOS开发者，可以在GitHub上 &lt;a href=&quot;https://github.com/MisterBooo/Play-With-Sort-OC&quot;&gt;https://github.com/MisterBooo/Play-With-Sort-OC&lt;/a&gt; 获取更直观可调试运行的源码。&lt;/p&gt;
&lt;p&gt;你可以在公众号 五分钟学算法 获取更多相关内容。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 24 Nov 2018 07:05:00 +0000</pubDate>
<dc:creator>五分钟学算法</dc:creator>
<og:description>前言 由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 ——-《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fivestudy/p/10012193.html</dc:identifier>
</item>
<item>
<title>关于antd-mobile中列表下拉刷新PullToRefresh的使用 - 渴望成为大牛的男人</title>
<link>http://www.cnblogs.com/bai1218/p/10012011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bai1218/p/10012011.html</guid>
<description>&lt;h2 id=&quot;相信有很多小伙伴发现antd-mobile中的下拉刷新组件也发现例子挺难的其实这个组件并没有那么复杂只是demo例子不好理解给大家提供一个简单的demo或许可以帮到你&quot;&gt;相信有很多小伙伴发现antd-mobile中的下拉刷新组件，也发现例子挺难的，其实这个组件并没有那么复杂，只是demo例子不好理解，给大家提供一个简单的demo，或许可以帮到你&lt;/h2&gt;
&lt;h3 id=&quot;上拉刷新下拉加载&quot;&gt;上拉刷新下拉加载&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;- 因为它用react-dom做操作了，所以把react-dom也导进来
- rowID是每次的ID，rowData是每次的数据
- renderSseprator就是个分隔符
- this.state.dataSource就是数据源 
- 外围的那个const的dataSource是一种数据结构，它有一个方法叫cloneWithRows
- Button没用，删就完了
- renderFooter是为了做上拉刷新时的Loading效果
- 第一步是通过dataSource去拿数据，第二步是通过render(row)去渲染那个模板
- rowData是每一页的数据，就是每次装载进来的数据，rowID是它帮你封装好的，直接在key={rowID}用就行，
在DidMount整完数据以后在这边的rouData就是你的state.dataSource里面的数据(第一页)
- renderSeparator 就是刚开始他们行和行之间的分隔符
- pageSize是刷新的时候一次显示几条数据&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;附上代码可直接复制过去根据你的需求更改&quot;&gt;附上代码，可直接复制过去，根据你的需求更改&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import React,{ Component } from 'react'
import ReactDOM from 'react-dom'    //下拉刷新组件依赖react-dom，所以需要将其引进来

import { PullToRefresh, ListView } from 'antd-mobile';

class ListContainer extends Component {
  constructor(props) {
    super(props);
    const dataSource = new ListView.DataSource({  //这个dataSource有cloneWithRows方法
      rowHasChanged: (row1, row2) =&amp;gt; row1 !== row2,
    });   
    
    this.pageNo = 0 //定义分页信息
    this.state = {
      dataSource,
      refreshing: true,
      isLoading: true,
      height: document.documentElement.clientHeight,
      useBodyScroll: false,
      hasMore: true
    };
  }

  componentDidUpdate() {
    if (this.state.useBodyScroll) {
      document.body.style.overflow = 'auto';
    } else {
      document.body.style.overflow = 'hidden';
    }
  }

  async componentDidMount() {
    const hei = this.state.height - ReactDOM.findDOMNode(this.lv).offsetTop;

    this.rData = (await this.genData()).sceneryinfo;
    console.log(this.rData)
    this.setState({
      dataSource: this.state.dataSource.cloneWithRows(this.rData),
      height: hei,
      refreshing: false,
      isLoading: false,
    });
  }
  genData(){  //请求数据的方法
    this.pageNo++     //每次下拉的时候pageNo++                                                                                 
    return fetch('/scenery/json/scenerynearycitylist.html?CountryId=0&amp;amp;ProvinceId=3&amp;amp;CityId=53&amp;amp;LbTypes=&amp;amp;sorttype=0&amp;amp;page='+this.pageNo+'&amp;amp;gradeid=0&amp;amp;themeid=0&amp;amp;pricerange=0&amp;amp;issearchbytimenow=0&amp;amp;paytype=0&amp;amp;range=0&amp;amp;keyword=0&amp;amp;IsGlobal=0&amp;amp;IsYiYuan=0&amp;amp;cityArea=0&amp;amp;lat=0&amp;amp;lon=0', 
            {
              method: 'GET',
              headers: {
                  'content-type': 'application/json'
              },
            })
            .then(response =&amp;gt; response.json())
            .then(function(result) {
                if(result){
                  return result
                }else{
                  this.setState({
                    hasMore: false
                  })
                }
            })
  }

  onRefresh = () =&amp;gt; {
    // this.setState({ refreshing: true, isLoading: true });
    // // simulate initial Ajax
    // setTimeout(() =&amp;gt; {
    //   this.rData = genData();
    //   this.setState({
    //     dataSource: this.state.dataSource.cloneWithRows(this.rData),
    //     refreshing: false,
    //     isLoading: false,
    //   });
    // }, 600);
  };

  onEndReached = async (event) =&amp;gt; {
    // load new data
    // hasMore: from backend data, indicates whether it is the last page, here is false
    if (this.state.isLoading &amp;amp;&amp;amp; !this.state.hasMore) {
      return;
    }   //如果this.state.hasMore为false，说明没数据了，直接返回
    console.log('reach end', event);
    this.setState({ isLoading: true });
    this.rData = [...this.rData, ...((await this.genData()).sceneryinfo)];  //每次下拉之后将新数据装填过来
    this.setState({
      dataSource: this.state.dataSource.cloneWithRows(this.rData),
      isLoading: false,
    });
  };

  render() {
    //这里就是个渲染数据，rowData就是每次过来的那一批数据，已经自动给你遍历好了，rouID可以作为key值使用，直接渲染数据即可
    const row = (rowData, sectionID, rowID) =&amp;gt; {
      return (
        &amp;lt;div key={rowID} style={{&quot;height&quot;:&quot;100px&quot;}}&amp;gt;{rowData.name}&amp;lt;/div&amp;gt;
      );
    };
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;ListView
          key={this.state.useBodyScroll ? '0' : '1'}
          ref={el =&amp;gt; this.lv = el}
          dataSource={this.state.dataSource}
          renderFooter={    //renderFooter就是下拉时候的loading效果，这里的内容可以自己随需求更改
            () =&amp;gt; (
                  &amp;lt;div style={{ padding: 30, textAlign: 'center' }}&amp;gt;
                    {this.state.isLoading ? 'Loading...' : 'Loaded'}
                  &amp;lt;/div&amp;gt;
                )
          }
          renderRow={row}   //渲染你上边写好的那个row
          useBodyScroll={this.state.useBodyScroll}
          style={this.state.useBodyScroll ? {} : {
            height: this.state.height,
            border: '1px solid #ddd',
            margin: '5px 0',
          }}
          pullToRefresh={&amp;lt;PullToRefresh
            refreshing={this.state.refreshing}
            onRefresh={this.onRefresh}
          /&amp;gt;}
          onEndReached={this.onEndReached}
          pageSize={8}    //每次下拉之后显示的数据条数
        /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default ListContainer&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果说你看到了这里，是不是觉得还是有点东西的，如果你觉得帮到你了，给个评论鼓励鼓励孩子吧，发了这么多到现在就一条评论，挺可怜的。后续给大家发一个在下拉刷新组件中如何使用redux，感谢查阅~.~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 24 Nov 2018 06:24:00 +0000</pubDate>
<dc:creator>渴望成为大牛的男人</dc:creator>
<og:description>相信有很多小伙伴发现antd mobile中的下拉刷新组件，也发现例子挺难的，其实这个组件并没有那么复杂，只是demo例子不好理解，给大家提供一个简单的demo，或许可以帮到你 上拉刷新下拉加载 附上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bai1218/p/10012011.html</dc:identifier>
</item>
<item>
<title>自动化构建工具--gulp的初识和使用 - Anderson_An</title>
<link>http://www.cnblogs.com/Anderson-An/p/10011950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Anderson-An/p/10011950.html</guid>
<description>&lt;p&gt;gulp &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;首先：什么是gulp?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装使用示例：&lt;/p&gt;
&lt;h3&gt;首先新建一个文件夹：music&lt;/h3&gt;
&lt;p&gt;然后安装淘宝镜像 cnpm，当然直接用npm也可以；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1527703/201811/1527703-20181124020206503-1766672754.png&quot; alt=&quot;&quot; width=&quot;775&quot; height=&quot;179&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;初始化文件夹并一路回车： cnpm init&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1527703/201811/1527703-20181124020331610-412795542.png&quot; alt=&quot;&quot; width=&quot;751&quot; height=&quot;316&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会自动生成一个package.json 的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1527703/201811/1527703-20181124125247669-1381180822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后执行cnpm install 会自动生成一个文件夹：node_modules，并将开发环境所需要的相关依赖文件包全部下载到node_modules 文件夹下：&lt;/p&gt;
&lt;p&gt;如果该文件删除，重新执行该命令，可以重新加载相关依赖：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1527703/201811/1527703-20181124020517286-611651825.png&quot; alt=&quot;&quot; width=&quot;1143&quot; height=&quot;50&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;安装gulp：&lt;/h3&gt;
&lt;p&gt;$ cnpm install gulp --save-dev&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1527703/201811/1527703-20181124020843828-1555948470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;-save-dev和--save的区别&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;会&lt;/strong&gt;把gulp包安装到node_modules目录中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;会&lt;/strong&gt;在package.json的&lt;strong&gt;dependencies&lt;/strong&gt;属性下添加gulp&lt;/li&gt;
&lt;li&gt;之后运行npm install命令时，&lt;strong&gt;会&lt;/strong&gt;自动安装gulp到node_modules目录中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--save---&lt;/strong&gt;之后运行npm install --production或者注明NODE_ENV变量值为production时，&lt;strong&gt;会&lt;/strong&gt;自动安装gulp 到node_modules目录中(开发完后需要用到依赖包，如jquery等)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--save-dev--&lt;/strong&gt;之后运行npm install --production或者注明NODE_ENV变量值为production时，不&lt;strong&gt;会&lt;/strong&gt;自动安装gulp 到node_modules目录中（发布后用不到它，而只是在我们开发才用到它&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt; 手动新建一个gulpfile文件并配置：&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1527703/201811/1527703-20181124020951236-695482755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单测试配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; gulp = require(&quot;gulp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩图片的插件：&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; imagemin = require(&quot;glup-imagemin&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; folfer =&lt;span&gt; {
    src : &lt;/span&gt;&quot;./src/&quot;&lt;span&gt;,
    build : &lt;/span&gt;&quot;./build/&quot;&lt;span&gt;,
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;流读取文件  task  running grunt&lt;/span&gt;
gulp.task(&quot;image&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;111&lt;span&gt;);
    gulp.src( &lt;/span&gt;&quot;src/image/*&quot;&lt;span&gt;)
        .pipe(imagemin())
        .pipe(gulp.dest(&lt;/span&gt;&quot;build/image&quot;&lt;span&gt;))

})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 需要在终端安装gulp相关插件：&lt;/h3&gt;
&lt;p&gt;cnpm install gulp-imagemin --save-dev&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1527703/201811/1527703-20181124134659201-1417104605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后就可以按需求压缩图片的命令了~！&lt;/p&gt;
&lt;p&gt;另外扩展，一个插件，gulp-newer 用来检测是否有新的文件，如果是新文件，就进行压缩，如果不是新的就不执行压缩：&lt;/p&gt;
&lt;p&gt;cnpm install gulp-newer --save-dev&lt;/p&gt;
&lt;p&gt;相关gulpfile.js 中的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; newer = require(&quot;gulp-newer&quot;&lt;span&gt;);

gulp.task(&lt;/span&gt;&quot;image&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;()

{　　

　　　　gulp.sec(&lt;/span&gt;&quot;src/image/*&quot;&lt;span&gt;)

　　　　　　.pipe( newer(&lt;/span&gt;&quot;image&quot;&lt;span&gt;))

　　　　　　.pipe(imagemin())

　　　　　　.pipe(gulp.dset(&lt;/span&gt;&quot;build/image&quot;&lt;span&gt;))

})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;postBody&quot; readability=&quot;31&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;78.5&quot;&gt;

&lt;h2&gt; 更多插件安装使用示例如下：&lt;/h2&gt;
&lt;p&gt;在本地文件夹下载插件：npm install 插件名 --save-dev&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; gulp = require(&quot;gulp&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入glup&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; sass = require(&quot;gulp-sass&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拷贝并编译scss&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; server = require(&quot;gulp-connect&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立服务器&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; concat = require(&quot;gulp-concat&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并js文件&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; uglify = require(&quot;gulp-uglify&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩js文件&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; minifyCss = require(&quot;gulp-minify-css&quot;&lt;span&gt;);//压缩css
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; imagemin = require(&quot;gulp-imagemin&quot;&lt;span&gt;);//压缩图片
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rename = require(&quot;gulp-rename&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件重命名&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; rev = require(&quot;gulp-rev&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给静态资源文件名添加一个哈希值后缀&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; revCollector = require(&quot;gulp-rev-collector&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动添加版本号&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; autoprefixer = require(&quot;gulp-autoprefixer&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对css添加浏览器后缀&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; htmlmin = require(&quot;gulp-htmlmin&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对html页面进行压缩&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基本语法&lt;/span&gt;
&lt;span&gt;
Gulp.task(“任务名称”，执行行数（）{

Return gulp.src(“操作的文件路径”).pipe(插件名【与var定义名字相同】）{

相关参数

})）【可执行操作多个pipe（）处理项】.pipe(gulp.dest(“返回结果的路径”))

})；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
gulp.task(&quot;addpre&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/css/aa.css&quot;&lt;span&gt;).pipe(autoprefixer({
        browsers:[&lt;/span&gt;'last 2 versions','Android&amp;gt;=4.0'&lt;span&gt;],
        cascade:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    })).pipe(gulp.dest(&lt;/span&gt;&quot;dist/css&quot;&lt;span&gt;))
})

 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同时执行多项任务gulp.task(“合并的任务名”,[“任务1”,”任务2”,”任务3”,...]);&lt;/span&gt;
gulp.task(&quot;default&quot;,[&quot;copyindex&quot;,&quot;copy-img&quot;,&quot;copy-data&quot;&lt;span&gt;]);

&lt;/span&gt;&amp;lt;!--将src下的index页面进行压缩后拷贝到dist目录下--&amp;gt;&lt;span&gt;

gulp.task(&lt;/span&gt;&quot;copyindex&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/index.html&quot;&lt;span&gt;).pipe(htmlmin({
        minifyCss:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩css&lt;/span&gt;
        minifyJS:&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩js&lt;/span&gt;
        removeComment:&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩代码&lt;/span&gt;
        collapseWhitespace:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩空白区域&lt;/span&gt;
    })).pipe(gulp.dest(&quot;dist/&quot;&lt;span&gt;))
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;批量拷贝&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   src/images/**/*拷贝images下的所有文件下的所有资源&lt;/span&gt;
&lt;span&gt;
gulp.task(&lt;/span&gt;&quot;copy-img&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/images/**/*&quot;).pipe(imagemin()).pipe(gulp.dest(&quot;dist/images/&quot;&lt;span&gt;));
})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多组拷贝和合并&quot;!src/json/s-*.json&quot;//排除s开头的json文件&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;！文件名  表示排除&lt;/span&gt;
gulp.task(&quot;copy-data&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src([&quot;src/json/*&quot;,&quot;src/xml/*&quot;,&quot;!src/json/s-*.json&quot;]).pipe(gulp.dest(&quot;dist/data/&quot;&lt;span&gt;));
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译scss并拷贝到相关路径&lt;/span&gt;
gulp.task(&quot;scss-c&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/scss/**/*.scss&quot;).pipe(sass()).pipe(gulp.dest(&quot;dist/css/&quot;&lt;span&gt;));
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;watch监控数据，一旦文件，立即执行监视任务进行拷贝刷新&lt;/span&gt;
gulp.task(&quot;watch&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    gulp.watch(&lt;/span&gt;&quot;src/index.html&quot;,[&quot;copyindex&quot;&lt;span&gt;]);
    gulp.watch(&lt;/span&gt;&quot;src/images/**/*&quot;,[&quot;copy-img&quot;&lt;span&gt;]);
    gulp.watch(&lt;/span&gt;&quot;src/json/*&quot;,[&quot;copy-data&quot;&lt;span&gt;]);
})


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立本地服务器&lt;/span&gt;
gulp.task(&quot;server&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    server.server({
        root:&lt;/span&gt;&quot;dist&quot;&lt;span&gt;
    });
})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js合并 与 .pipe(uglify())压缩&lt;/span&gt;
gulp.task(&quot;js&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/script**/*&quot;).pipe(concat(&quot;all.js&quot;)).pipe(uglify()).pipe(gulp.dest(&quot;dist/js/&quot;)).pipe(rename(&quot;all-min.js&quot;)).pipe(gulp.dest(&quot;dist/js/&quot;&lt;span&gt;))
})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对css进行压缩并创建json文件自动添加版本号&lt;/span&gt;
gulp.task(&quot;css&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/css/*.css&quot;).pipe(minifyCss()).pipe(rev()).pipe(gulp.dest(&quot;dist/css/&quot;)).pipe(rev.manifest()).pipe(gulp.dest(&quot;dist/css/&quot;&lt;span&gt;));
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来替换HTML页面上的link标签src路径（方便更改文件名）&lt;/span&gt;
gulp.task(&quot;rev-collector&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src([&quot;dist/css/**/*.json&quot;,&quot;dist/index.html&quot;&lt;span&gt;]).pipe(revCollector({
        replaceReved:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    })).pipe(gulp.dest(&lt;/span&gt;&quot;dist/&quot;&lt;span&gt;))
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;已经配置好的gulpfile文件，参考如下：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by 13
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; gulp = require('gulp'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; clone = require('gulp-clone'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; htmlmin = require('gulp-htmlmin'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; gulpif = require('gulp-if'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cssmin = require('gulp-minify-css'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; uglify = require('gulp-uglify'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; useref = require('gulp-useref'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; clean = require('gulp-clean'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; imagemin = require('gulp-imagemin'&lt;span&gt;);
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩html&lt;/span&gt;
gulp.task('html', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options =&lt;span&gt; {
        removeComments: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除HTML注释&lt;/span&gt;
        collapseWhitespace: &lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩HTML&lt;/span&gt;
        collapseBooleanAttributes: &lt;span&gt;false&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略布尔属性的值 &amp;lt;input checked=&quot;true&quot;/&amp;gt; ==&amp;gt; &amp;lt;input checked /&amp;gt;&lt;/span&gt;
        removeEmptyAttributes: &lt;span&gt;false&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除所有空格作属性值 &amp;lt;input id=&quot;&quot; /&amp;gt; ==&amp;gt; &amp;lt;input /&amp;gt;&lt;/span&gt;
        removeScriptTypeAttributes: &lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&amp;lt;script&amp;gt;的type=&quot;text/javascript&quot;&lt;/span&gt;
        removeStyleLinkTypeAttributes: &lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&amp;lt;style&amp;gt;和&amp;lt;link&amp;gt;的type=&quot;text/css&quot;&lt;/span&gt;
        minifyJS: &lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩页面JS&lt;/span&gt;
        minifyCSS: &lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩页面CSS&lt;/span&gt;
&lt;span&gt;    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src('dev-pages/*.html'&lt;span&gt;)
    .pipe(htmlmin(options))
    .pipe(gulp.dest(&lt;/span&gt;'pages/'&lt;span&gt;));
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩js&lt;/span&gt;
gulp.task('jsmin', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(['dev-source/js/ajax.js','dev-source/js/ajax_my.js'&lt;span&gt;])
        .pipe(uglify({
            mangle: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        }))
        .pipe(gulp.dest(&lt;/span&gt;'source/js/'&lt;span&gt;))
})
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拷贝图片文件&lt;/span&gt;
gulp.task('image-copy', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src('source-dev/webslice/**/*'&lt;span&gt;)
        .pipe(clone())
        .pipe(gulp.dest(&lt;/span&gt;'source/webslice'&lt;span&gt;));
});
 
gulp.task(&lt;/span&gt;'image-min', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src('dev-source/images/*.{png,jpg}'&lt;span&gt;)
        .pipe(imagemin())
        .pipe(gulp.dest(&lt;/span&gt;'source/images/'&lt;span&gt;));
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先复制图片到source，然后再执行压缩。&lt;/span&gt;
gulp.task('image-min2', ['image-copy'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src('source/webslice/**/*'&lt;span&gt;)
        .pipe(imagemin())
        .pipe(gulp.dest(&lt;/span&gt;'source/webslice/'&lt;span&gt;));
});
 
gulp.task(&lt;/span&gt;'image-min3', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src('dev-source/webview/img/*.{png,jpg}'&lt;span&gt;)
        .pipe(imagemin())
        .pipe(gulp.dest(&lt;/span&gt;'source/webview/img/'&lt;span&gt;));
});
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩图片&lt;/span&gt;
gulp.task('images-min',['image-min','image-min2','image-min3'],&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {})
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听两个文件的文件变化&lt;/span&gt;
gulp.task('listenPages', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    gulp.watch(&lt;/span&gt;'dev-pages/*.html',['html'&lt;span&gt;]);
    gulp.watch(&lt;/span&gt;'dev-source/js/*.js',['jsmin'&lt;span&gt;]);
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构建任务流&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 执行 task build&lt;/span&gt;
gulp.task('build', ['html', 'image-min','jsmin']);
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 24 Nov 2018 06:07:00 +0000</pubDate>
<dc:creator>Anderson_An</dc:creator>
<og:description>gulp 首先：什么是gulp? gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Anderson-An/p/10011950.html</dc:identifier>
</item>
</channel>
</rss>