<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Caffe2源码解析 - jicanghai</title>
<link>http://www.cnblogs.com/jicanghai/p/9691621.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jicanghai/p/9691621.html</guid>
<description>&lt;p&gt;上一篇文章对Caffe2中的core模块进行了简单拆解&lt;a href=&quot;https://www.cnblogs.com/jicanghai/p/9689726.html&quot;&gt;Caffe2源码解析之core&lt;/a&gt;，本篇给出其它模块的拆解，目的是大致了解每个模块的内容和目标，进一步理解Caffe2的整体框架。内容不多，略做整理如下。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;core&lt;/li&gt;
&lt;li&gt;proto
&lt;ul&gt;&lt;li&gt;caffe2.proto&lt;/li&gt;
&lt;li&gt;hsm.proto&lt;/li&gt;
&lt;li&gt;metanet.proto&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;cuda_rtc&lt;/li&gt;
&lt;li&gt;db&lt;/li&gt;
&lt;li&gt;distributed&lt;/li&gt;
&lt;li&gt;ideep&lt;/li&gt;
&lt;li&gt;image&lt;/li&gt;
&lt;li&gt;mkl&lt;/li&gt;
&lt;li&gt;mobile&lt;/li&gt;
&lt;li&gt;mpi&lt;/li&gt;
&lt;li&gt;observers&lt;/li&gt;
&lt;li&gt;onnx&lt;/li&gt;
&lt;li&gt;operators&lt;/li&gt;
&lt;li&gt;opt&lt;/li&gt;
&lt;li&gt;perfkernels&lt;/li&gt;
&lt;li&gt;predictor&lt;/li&gt;
&lt;li&gt;queue&lt;/li&gt;
&lt;li&gt;sgd&lt;/li&gt;
&lt;li&gt;transform&lt;/li&gt;
&lt;li&gt;util&lt;/li&gt;
&lt;li&gt;python&lt;/li&gt;
&lt;li&gt;contrib&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参见&lt;a href=&quot;https://www.cnblogs.com/jicanghai/p/9689726.html&quot;&gt;Caffe2源码解析之core&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;包含了Caffe2中常用的protobuf定义，非常重要。我们按照所在文件进行介绍&lt;/p&gt;
&lt;h2 id=&quot;caffe2.proto&quot;&gt;caffe2.proto&lt;/h2&gt;
&lt;p&gt;首先是TensorProto，它表示张量序列化后的结果，包括了张量的维度、数据类型、数据值、名称、所在设备等信息，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message TensorProto {
    repeated int64 dims = 1;
    optional DataType data_type = 2 [default = FLOAT];
    repeated float float_data = 3 [packed = true];
    repeated int32 int32_data = 4 [packed = true];
    optional bytes byte_data = 5;
    repeated bytes string_data = 6;
    repeated double double_data = 9 [packed = true];
    repeated int64 int64_data = 10 [packed = true];
    optional string name = 7;
    
    //张量序列化之前所在的设备
    optional DeviceOption device_detail = 8;
    //张量在chunks中的位置
    message Segment {
        required int64 begin = 1;
        required int64 end = 2;
    }
    optional Segment segment = 11;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在core模块中讲到，Caffe2为了支持低精度的模型训练，设计了qtensor，当时没有详细介绍它的本质，实际上qtensor是对原张量进行了归一化，即减去bias再除以scale，然后对结果进行低精度表示，节省存储空间。因此在qtensor的序列化结果中，需要对归一化的参数进行记录，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message QTensorProto {
    repeated int64 dims = 1;
    required int32 precision = 2;
    required double scale = 3;
    required double bias = 4;
    required bool is_signed = 5;
    repeated int32 data = 6 [packed = true];
    optional string name = 7;
    optional TensorProto.DataType data_type = 8 [default = INT32];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于多个Tensor，可以使用TensorProto的复数版本，TensorProtos来存储。当然这只针对较小的张量，如果张量比较大，建议使用DB存储。&lt;/p&gt;
&lt;p&gt;对于张量的形状，也有一个结构来表示，TensorShape。记得在Tensorflow中，对于张量形状的某些维度，在运行前可能并不是完全知道，因此这里在TensorShape的定义中，会添加参数对未知张量维度做处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message TensorShape {
    repeated int64 dims = 1;
    optional TensorProto.DataType data_type = 2 [default = FLOAT];
    repeated int32 unknown_dims = 3;
    optional bool unknown_shape = 4 [default = false];
    optional string name = 5;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数用于对操作的描述（详见下文的OperatorDef定义），一个命名的参数要么包含单个的浮点型、整型或者字符串数据，要么包含上述类型的数组，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message Argument {
    optional string name = 1;
    optional float f = 2;
    optional int64 i = 3;
    optional bytes s = 4;
    optional NetDef n = 8;
    repeated float floats = 5;
    repeated int64 ints = 6;
    repeated bytes strings = 7;
    repeated NetDef nets = 9;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前Caffe2支持的设备类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;enum DeviceType {
    CPU = 0;
    CUDA = 1;
    MKLDNN = 2;
    OPENGL = 3;
    OPENCL = 4;
    IDEEP = 5;
    HIP = 6;
    COMPILE_TIME_MAX_DEVICE_TYPES = 7;
    ONLY_FOR_TEST = 20901701;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前Caffe2对于不同设备的描述proto还都是一致的，如果某个设备没有包含其中的某个字段，那么这个字段将被忽略。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message DeviceOption {
    optional int32 device_type = 1 [default = 0]; //0 is CPU
    optional int32 cuda_gpu_id = 2;
    optional uint32 random_seed = 3;
    optional string node_name = 4;
    optional int32 numa_node_id = 5;
    repeated string extra_info = 6;
    optional int32 hip_gpu_id = 7;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是操作的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message OperatorDef {
    repeated string input = 1; //输入的blob名称
    repeated string output = 2; //输出的blob名称
    optional string name = 3;
    optional string type = 4; //操作的类型，从操作注册器中创建操作对象时，需要这个信息
    optional string type = 4;
    repeated Argument arg = 5;
    optional DeviceOption device_option = 6; //操作运行所需要的设备
    
    //对于当前操作来说，如果对于指定的运行设备有多个计算引擎，这里可以指定一个具体的实现引擎。如果用户指定了一个引擎，但这个引擎在Caffe2的二进制包中并不存在，那么使用默认引擎
    optional string engine = 7;
    
    //控制输入，与Tensorflow中的控制输入类似，表达运行的先后顺序，而不是数据的输入。它仅在调度时被Net类使用
    repeated string control_input = 8;
    
    //is_gradient_op参数仅在形状推断（shape inference，与Tensorflow中类似）时使用，没有运行时的作用
    optional bool is_gradient_op = 9 [default = false];
    optional string debug_info = 10;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来NetDef的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message NetDef {
    optional string name = 1;
    repeated OperatorDef op = 2;
    optional string type = 3; //network的执行方式，默认是simple
    optional DeviceOption device_option = 5; //整个net上所有操作的设备信息，在这里设置可以避免给每个操作单独设置
    repeated Argument arg = 6; //参数，包括num_workers，即当图被并行执行的时候，worker的数量
    
    repeated string external_input = 7;
    repeated string external_output = 8;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Caffe2中也可以像Tensorflow那样进行迭代计算，它使用了一个结构叫做ExecutionStep，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message ExecutionStep {
    optional string name = 1;
    
    //ExecutionStep要么可以包含一个substep的集合，要么可以包含一些要运行的network的名称，但两者不能同时被设置
    repeated ExecutionStep substep = 2;
    repeated string network = 3;
    
    //当前的迭代需要运行的轮次，substeps和networks需要被顺序执行，每次执行被视为一轮迭代
    optional int64 num_iter = 4;
    
    //迭代执行结束的判断条件
    optional string criteria_network = 5;
    
    //如果这个字段被设置，那么就周期性的执行
    optional int64 run_every_ms = 11;
    
    //对于sub-steps，是顺序执行还是并行执行
    optional bool concurrent_substeps = 6;
    
    //一个用来判断当前执行是否需要终结的标志
    optional string should_stop_blob = 9;
    
    //如果为真，则当前执行仅执行一次，注意仅当should_stop_blob有效时才有效
    optional bool only_once = 10;
    
    //是否为当前执行构建一个子workspace
    optional bool create_workspace = 12;
    
    //子执行的并行度
    optional int32 num_concurrent_instances = 13;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果说一个ExecutionStep是一次迭代执行，那么Plan就是一个完整的执行计划，后者包含前者：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message PlanDef {
    optional string name = 1;
    repeated NetDef netowrk = 2;
    repeated ExecutionStep execution_step = 3;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于那些内部并不是Tensor的Blob，Caffe2定义了如下的结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message BlobProto {
    optional string name = 1;
    optional string type = 2;
    optional TensorProto tensor = 3;
    optional bytes content = 4;
    optional QTensorProto qtensor = 5;
    optional int32 content_num_chunks = 6;
    optional int32 content_chunk_id = 7;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，是对DBReader进行序列化的对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message DBReaderProto {
    optional string name = 1;
    optional string source = 2;
    optional string db_type = 3;
    optional string key = 4;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;hsm.proto&quot;&gt;hsm.proto&lt;/h2&gt;
&lt;p&gt;Word2Vec是早年Google提出的一个模型，目的是根据语料库获得词嵌入（embedding）。其中为了提高训练的速度提出了两种技术，一种是负采样（Negative Sampling），另外一种就是Hierarchical Softmax。因此，Caffe2专门设计了一个HSM操作，这个文件里包含的就是与之相关的proto，我们仅给出proto名称，含义比较显然：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message NodeProto;
message TreeProto;
message HierarchyProto;
message PathProto;
message PathNodeProto;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;MetaNetDef，顾名思义，包含了NetDef的元数据。其结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message MetaNetDef {
    repeated BlobMap blobs = 1;
    repeated NetsMap nets = 2;
    optional ModelInfo modelInfo = 3;
    repeated PlanMap plans = 4;
    repeated StringMap applicationSpecificInfo = 5;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，对应的xxMap结构很简单，都是键值对，ModelInfo相对比较复杂，我们看下详细的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message ModelInfo {
    optional string project = 1;
    optional string modelClass = 2;
    optional string version = 3;
    optional string predictorTtype = 4;
    optional string modelId = 5;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;cuda核生成相关的辅助代码。&lt;/p&gt;

&lt;p&gt;在Caffe2的执行过程中，需要重复使用和共享的参数，会被记录在一个db当中。在core模块中我们介绍过，db就是一个kv存储，这里包含了4种Caffe2中会用到的db，如下：&lt;/p&gt;
&lt;p&gt;graph TB db--&amp;gt;|派生|LevelDB db--&amp;gt;|派生|LMDB db--&amp;gt;|派生|ProtoDB db--&amp;gt;|派生|ZmqDB&lt;/p&gt;

&lt;p&gt;Caffe2的分布式实现，依赖外部存储来保存共享的参数。常用的外部存储包括文件和redis。&lt;/p&gt;
&lt;p&gt;外部存储的句柄用StoreHandler来表示，它包含了以下的核心API：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class StoreHandler {
  public:
    virtual void set(...) = 0;
    virtual std::string get(...) = 0;
    virtual int64_t add(...) = 0;
    virtual bool check(...) = 0;
    virtual void wait(...) = 0;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应到计算图中，就有4个对store操作的op与之对应，如下：&lt;/p&gt;
&lt;p&gt;graph TB Operator--&amp;gt;|派生|StoreSetOp Operator--&amp;gt;|派生|StoreGetOp Operator--&amp;gt;|派生|StoreAddOp Operator--&amp;gt;|派生|StoreWaitOp&lt;/p&gt;
&lt;p&gt;刚才提到了，常用的存储方式为文件存储和redis存储，对应有两种存储句柄：&lt;/p&gt;
&lt;p&gt;graph TB StoreHandler--&amp;gt;|派生|RedisStoreHandler StoreHandler--&amp;gt;|派生|FileStoreHandler&lt;/p&gt;
&lt;p&gt;另外，还有两个创建存储的操作，如下：&lt;/p&gt;
&lt;p&gt;graph TB Operator--&amp;gt;|派生|FileStoreHandlerCreateOp Operator--&amp;gt;|派生|RedisStoreHandler&lt;/p&gt;

&lt;p&gt;目前还不清楚具体含义。&lt;/p&gt;

&lt;p&gt;关于图像的操作，其中最重要的是对于图像读取的操作，ImageInputOp，它继承自PrefetchOperator，包含了图像读取的一系列功能。&lt;/p&gt;

&lt;p&gt;MKL全称是Intel Math Kernel Library，是英特尔提供的数学核心库，它对大量的数学过程进行了处理器级别的优化。这里包括了MKL相关的操作定义。注意，Tensorflow中也用到了MKL去优化数学运算，只不过它是在图优化的过程中，将MKL作为一种图优化遍历被引入，而Caffe2中将MKL直接融入到了操作内部。&lt;/p&gt;

&lt;p&gt;针对移动平台的特殊处理，具体还没看。&lt;/p&gt;

&lt;p&gt;Caffe2中的分布式计算，通过mpi实现。mpi的核心作用是在不同机器上的分布式进程中，进行数据传输和消息同步。针对mpi中的核心操作，比如Broadcast，Reduce等，Caffe2都给出了对应的操作来执行，具体如下：&lt;/p&gt;
&lt;p&gt;graph TB Operator--&amp;gt;|派生|MPICreateCommonWorldOp Operator--&amp;gt;|派生|MPIBroadcastOp Operator--&amp;gt;|派生|MPIReduceOp Operator--&amp;gt;|派生|MPIAllgatherOp Operator--&amp;gt;|派生|MPIAllreduceOp Operator--&amp;gt;|派生|MPISendTensorOp Operator--&amp;gt;|派生|MPIReceiveTensorOp&lt;/p&gt;

&lt;p&gt;给出了4种不同观察器的定义，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;operator_attaching_net_observer，负责给net中的每一个operator添加观察器；&lt;/li&gt;
&lt;li&gt;profile_observer，负责对每个操作或整张图的执行消耗进行观察；&lt;/li&gt;
&lt;li&gt;runcnt_observer，负责对每个操作或者整张图的运行次数进行观察；&lt;/li&gt;
&lt;li&gt;time_observer，负责对每个操作或者整张图的运行时间进行观察；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前还不清楚。&lt;/p&gt;

&lt;p&gt;操作的具体定义放在这里，代码量巨大，没来得及细看。&lt;/p&gt;

&lt;p&gt;优化相关的类和函数，与Tensorflow一样，Caffe2也是通过对图遍历的方式实施优化，所有的优化遍历类必须继承自OptimizationPass，它的具体定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class OptimizationPass {
  public:
    OptimizationPass(NNModule* nn) : nn_(nn) {}
    virtual void run() = 0;
    virtual ~OptimizationPass(){}
    
  protected:
    NNModule* nn_;
};
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;性能优化相关的kernel。&lt;/p&gt;

&lt;p&gt;一个predictor就是一个参数都确定好了的net。在深度学习中，我们通常会把待学习的模型表示为net，然后通过迭代的图计算，确定模型参数，将net转换为predictor。下面我们看下predictor的结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Predictor {
  public:
    Predictor(const NetDef&amp;amp; init_net, const NetDef&amp;amp; run_net, Workspace* parent = nullptr, bool run_init = true, int optimization = 1);
    Predictor(PredictorConfig config);
    
    //以下是对()的重载，给定输入得到输出
    bool operator()(const TensorMap&amp;amp; inputs, TensorList* outputs);
    bool operator()(const TensorMap&amp;amp; inputs, TensorList* outputs);
    bool operator()(const TensorMap&amp;amp; inputs, TensorMap* outputs);
    
    const NetDef&amp;amp; def() const {
        return *config_.predict_net;
    };
    
    Workspace* ws(){
        return config_.ws.get();
    };
    const std::vector&amp;lt;std::string&amp;gt;&amp;amp; input_names() const {
        return config_.input_names;
    }
    const std::vector&amp;lt;std::string&amp;gt;&amp;amp; output_names() const {
        return config_.output_names;
    }
  private:
    bool run_map_workspace(const TensorMap&amp;amp; inputs);
    PredictorConfig config_;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，Predictor类最重要的一个私有数据成员是config_，我们看下PredictorConfig的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct PredictorConfig {
    std::shared_ptr&amp;lt;PredictorParameters&amp;gt; parameters;
    std::shared_ptr&amp;lt;NetDef&amp;gt; predict_net;
    std::vector&amp;lt;std::string&amp;gt; input_names;
    std::vector&amp;lt;std::string&amp;gt; output_names;
    std::vector&amp;lt;std::string&amp;gt; parameter_names;
    std::shared_ptr&amp;lt;Workspace&amp;gt; ws;
};
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;与Tensorflow类似，Caffe2也利用队列对多个线程进行同步，比如在多线程读取输入数据的时候。对队列的所有动作都必须通过“操作”来完成，因此Caffe2又定义了队列相关的操作。&lt;/p&gt;
&lt;p&gt;先来看下BlobsQueue的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class BlobsQueue : public std::enable_shared_from_this&amp;lt;BlobsQueue&amp;gt; {
  public:
    bool blockingRead(...);
    bool blockingWrite(...);
    void close();
  private:
    size_t numBlobs_;
    std::mutex mutex_;
    std::condition_variable cv_;
    int64_t reader_{0};
    int64_t writer_{0};
    std::vector&amp;lt;std::vector&amp;lt;Blob*&amp;gt;&amp;gt; queue_; //核心队列数据
    const std::string name_;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意看其中的数据元素queue_，它就是BlobsQueue的核心队列数据。&lt;/p&gt;
&lt;p&gt;另外，BlobsQueue，也可以被看做是一种db，因此Caffe2定义了BlobQueueDB：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class BlobsQueueDB : public DB {
  public:
    BlobsQueueDB(...);
    void Close() override {}
    unique_ptr&amp;lt;Cursor&amp;gt; NetCursor() override{...}
    unique_ptr&amp;lt;Transaction&amp;gt; NewTransaction() override {...}
  private:
    std::shared_ptr&amp;lt;BlobsQueue&amp;gt; queue_;
    int key_blob_index_;
    int value_blob_index_;
    float timeout_secs_;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，Caffe2还针对BlobsQueue提出了提出了对队列进行处理的“操作”，把常用的队列处理方式，如入队、出队等，抽象为操作：&lt;/p&gt;
&lt;p&gt;graph TB Operator--&amp;gt;|派生|CreateBlobsQueueOp Operator--&amp;gt;|派生|EnqueueBlobsOp Operator--&amp;gt;|派生|DequeueBlobsOp Operator--&amp;gt;|派生|CloseBlobsQueueOp Operator--&amp;gt;|派生|SafeEnqueueBlobsOp Operator--&amp;gt;|派生|SafeDequeueBlobsOp Operator--&amp;gt;|派生|WeightedSampleDequeueBlobsOp&lt;/p&gt;
&lt;p&gt;另外，为了能支持一次多数据入队，Caffe2设计了RebatchingQueue类，它的简要结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class RebatchingQueue {
  public:
    bool enqueueOne(...);
    bool enqueueMany(...);
    bool dequeue(...);
  private:
    std::vector&amp;lt;std::vector&amp;lt;TensorCPU&amp;gt;&amp;gt; queue_;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与BlobsQueue最大的区别有两点，第一，核心数据queue_中存储的是TensorCPU而不是Blob*，第二，拥有EnqueueOne和EnqueueMany两种入队操作。&lt;/p&gt;
&lt;p&gt;与BlobsQueue类似，Caffe2也为RebatchingQueue准备了对其进行处理的“操作”，与BlobsQueue类似，这里不再赘述。&lt;/p&gt;

&lt;p&gt;包含了与随机梯度下降有关的操作。基本上可以根据文件名猜测含义，这里仅列出文件名前缀，感兴趣的读者可以查阅源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;adadelta_op
adagrad_op
adam_op
clip_tensor_op
fp16_momentum_sgd_op
fp32_momentum_sgd_op
ftrl_op
gftrl_op
iter_op
lars_op
learning_rate_adaption_op
learning_rate_functors
learning_rate_op
momentum_sgd_op
rmsprop_op
wngrad_op
yellowfin_op
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有机会可以仔细研读下其中的细节。&lt;/p&gt;

&lt;p&gt;根据core模块的内容我们知道，这里包含的是对图进行变换的方法。主要包括4种：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//公共子项消除，CSE，与Tensorflow类似
common_subexpression_elimination

//对卷积操作进行变换，提高效率
conv_to_nnpack_transform

//模式替换，允许你使用简单的接口定义模式替换规则，只需定义一模式子图和一个替换子图，在原图中寻找模式子图，然后替换为替换子图即可
pattern_net_transform

//单个操作的原地转换
single_op_transform
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些类形成了如下的继承体系：&lt;/p&gt;
&lt;p&gt;graph TB Transform--&amp;gt;|派生|CommonSubexpressionEliminationTransform Transform--&amp;gt;|派生|SingleOpTransform Transform--&amp;gt;|派生|PatternNetTransform SingleOpTransform--&amp;gt;|派生|ConvToNNPackTransform&lt;/p&gt;

&lt;p&gt;应用类和函数，比较琐碎，暂时没有细看。&lt;/p&gt;

&lt;p&gt;通过前面的介绍我们了解到，Caffe2的核心代码是用&quot;C++&quot;实现的，为了方便在python中进行调用，需要一个工具，帮助python调用&quot;C++&quot;代码。这样的工具有很多，比如boost.python, swig，ctypes，pybind11等。Caffe2选择了pybind11，因为它对&quot;C++&quot;11支持的比较好，而且API比较简单。而Tensorflow中python前端调用&quot;C++&quot;后端使用的是swig，其实swig对&quot;C++&quot;11也能支持。两种设计选择的优劣目前的知识我们还不好评判。&lt;/p&gt;
&lt;p&gt;具体的接口文件，是_import_c_extention.py，它首先会尝试载入gpu版本的Caffe2后端，如果失败了，会尝试载入CPU版本。其中，对于CPU后端的导入是通过如下的语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from caffe2.python.caffe2_pybind11_state import *
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，在编译完成后，caffe2/python目录下会生成一个名为caffe2_pybind11_state.so的文件，是包含了Caffe2的&quot;C++&quot;后端的动态链接库，可以被python载入。&lt;/p&gt;

&lt;p&gt;同Tensorflow的contrib文件夹一样，包含了第三方贡献的、未正式加入Caffe2的模块，这里面大部分代码是用python开发的。随着版本迭代，经测试稳定后，这些模块会逐渐加入Caffe2的python模块。&lt;/p&gt;

&lt;p&gt;看过Tensorflow和Caffe2的核心代码之后，讲一讲自己的感受。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码模块性，Tensorflow代码的模块性做的非常好，基础框架、运行时、图表示、图优化、op、kernel都区分的清清楚楚，而Caffe2的代码显得有些混杂，操作到处都是，给代码阅读带来了一点障碍。&lt;/li&gt;
&lt;li&gt;代码规范性，Tensorflow代码的规范性要好很多，虽然核心代码是多个作者完成的，但代码风格非常统一，文件头的协议也非常一致。反观Caffe2的代码，协议混乱，代码风格不统一，东拼西凑的感觉比较强烈，代码在形式上的美感不足。&lt;/li&gt;
&lt;li&gt;架构合理性，Tensorflow的野心很大，它的终极目标是变成一个全新的、面向数据流图计算的编程语言。这种编程语言基于op原语，利用op和kernel将编译期和运行期明确的区分开来，同时，它对于同一个数据流图的多线程并行执行机制，也像极了CPU流水线处理机制，因此，应该说，深度神经网络只是Tensorflow的一个副产品，它的真实价值远不止于此。反观Caffe2，很多设计有些短视了（比如用redis为中介做分布式执行），在提供更多灵活性的同时，也限制了它的高度。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，以上只是个人的一些猜测，随着理解的深入，我也会及时回来修正自己的观点，也欢迎大家来讨论。&lt;/p&gt;
&lt;p&gt;最后，我在github上新建了一个repo，&lt;a href=&quot;https://github.com/tengkz/pytorch_notes&quot;&gt;pytorch_notes&lt;/a&gt;，欢迎大家点星星。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Sep 2018 15:33:00 +0000</pubDate>
<dc:creator>jicanghai</dc:creator>
<og:description>写在前面 上一篇文章对Caffe2中的core模块进行了简单拆解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jicanghai/p/9691621.html</dc:identifier>
</item>
<item>
<title>HRMS(人力资源管理系统)-从单机应用到SaaS应用-架构分析(功能性、非功能性、关键约束)-下篇 - 何戈洲</title>
<link>http://www.cnblogs.com/hegezhou_hot/p/9691597.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hegezhou_hot/p/9691597.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一、开篇&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;      &lt;span&gt;上一篇&lt;span&gt;《&lt;a href=&quot;https://www.cnblogs.com/hegezhou_hot/p/9682677.html&quot;&gt;&lt;span&gt;HRMS(人力资源管理系统)-从单机应用到SaaS应用-架构分析(功能性、非功能性、关键约束)-上篇&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》&lt;/span&gt;&lt;span&gt;我们详细分析了在架构分析过程中我们需要注意的内容，架构过程的方法论及实践经验，以更好的指导我们在具体架构落地&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;span&gt;本篇主将具体结合HRMS系统进行架构概要分析，按照上篇的理论指导，开展具体的架构分析过程实践，通过分析找到关键功能、关键非功能性需求（关键质量及约束）等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &lt;strong&gt;&lt;span&gt;在阐述具体的架构工作方法之前，请大家先查看以下三方面的内容：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;strong&gt;&lt;span&gt;1、HRMS系统的介绍？（涵盖哪些功能？价值和作用是什么？行业什么情况？）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      请阅读&lt;span&gt;《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/hegezhou_hot/p/9655146.html&quot;&gt;&lt;span&gt;HRMS(人力资源管理系统)-从单机应用到SaaS应用-系统介绍&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      &lt;strong&gt;2、本章分析的内容将围绕4类企业代表的业务场景，（区分不同规模企业的关注点，规模将决定系统的设计方案）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      本篇将围绕4类企业代表来阐述不同规模企业对于HRMS的需求及应用&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;    &lt;strong&gt;  A、100人以下的中小企业&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;      B、500人以下的大中型企业&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;      C、1000人以上的集团化大企业&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;      D、全球类型的公司体系（几万人）&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;      &lt;strong&gt;3、架构师在设计该系统时的职责及具备的核心能力是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      请阅读&lt;span&gt;《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/hegezhou_hot/category/260425.html&quot;&gt;&lt;span&gt;系统架构系列-开篇介绍&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;一、架构准备阶段主要做什么？&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       架构准备阶段主要是围绕系统的全方位的需求分析来开展相关准备工作的，这里的需求涵盖功能性及非功能性2大类需求，非功能性需求又涵盖质量属性及约束两项内容，我们在实际的分析过程中需要重点考虑业务功能、质量属性及约束等内容，具体可采取表格方式进行梳理，借助科学的方法找出来哪些是关键功能、哪些是关键质量需求、哪些是关键约束。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231423433-1981925489.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231424045-1177897833.png&quot; alt=&quot;image&quot; width=&quot;648&quot; height=&quot;562&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键功能、关键质量属性及关键约束等内容对于架构设计的实际影响有哪些呢？在这里我们梳理成表格来呈现这样大家有一个比较直观的感受：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231424570-219322036.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231425337-1110056535.png&quot; alt=&quot;image&quot; width=&quot;862&quot; height=&quot;512&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;架构是围绕需求来开展的，在对需求综合分析的过程中，我们将需求划分为3个层次：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务级需求：&lt;/strong&gt;包含客户或出资者要达到的业务目标、预期投资、工期要求，以及要符合哪些标准、对哪些遗留系统进行整合等约束条件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;用户级需求：&lt;/strong&gt;用户使用系统来辅助完成哪些工作。对质量要求如何。用户群及所处的使用环境方面有何特殊要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;开发级需求：&lt;/strong&gt;开发人员需要实现什么。开发期间、维护期间有何质量考虑。开发团队的哪些情况会反过来影响架构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于此三类需求弄清楚之后，就可以形成一个初步的需求列表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　一方面为了满足上述3类需求，同时还考虑到影响架构设计3个维度方面的内容，我们采取ADMEMS的需求类型及需求层次的二维矩阵表，来进行结构化的梳理，这样更直观也更清晰，我这里先将考虑的维度放在这，后面关于HRMS系统的需求分析的过程中我将按照该方法进行整理&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231425821-1865413022.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231426362-636063072.png&quot; alt=&quot;image&quot; width=&quot;862&quot; height=&quot;583&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们了解了需求的层次、需求的类型，知道了他们对于架构的影响，也熟悉了解了他们之间的关联关系，那接下来对我们来说最重要的就是理清思路，如何把需求全方位的陈列出来，利用需求层次及需求分类罗列整理。HRMS系统非常的复杂，功能较多，应用的场景及类型也比较繁多，所以&lt;span&gt;最好的方式就是把需求列清晰：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231426801-1108804992.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231427351-601601044.png&quot; alt=&quot;image&quot; width=&quot;854&quot; height=&quot;369&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过需求的结构化整理，需要从这些需求中找到关键功能、关键质量及关键约束，并将关键质量、关键约束转化为衍生的设计需求：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231427861-1415421224.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231428342-109666116.png&quot; alt=&quot;image&quot; width=&quot;866&quot; height=&quot;392&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、&lt;span&gt;&lt;span&gt;确定业务功能&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键的业务功能包含如下四个方面：1.核心功能；2.必做功能；3.高风险功能；4.独特功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如何区别这四个方面，实际上是靠经验和感觉。它们之间实际上是有重叠部分的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;核心功能：业务层接口所反映的功能。如，HRMS系统中，前面说的8大业务内容都属于核心功能；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;必做功能：必做功能实际上是以客户为背景的，简单来说就是愿景；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高风险功能：顾名思义，哪些功能操作可能会涉及到安全和隐私等问题；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;独特功能：实际是上诉三个功能的补集，看看还有哪些没有覆盖到的，却又很关键的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　架构师在设计阶段要考虑到“关键功能”所占有的比例，没有明确的标准，一般遵循：功能少的系统比例高一些，功能多的系统比例少一些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、梳理非功能性需求涵盖质量及约束需求，将这些质量及约束背后的衍生需求梳理清晰：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231429051-102757752.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231429636-1813021108.png&quot; alt=&quot;image&quot; width=&quot;813&quot; height=&quot;365&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于质量要求这块的内容涵盖的范围非常的广泛，涵盖：1.性能  2. 安全性 3.持续可用性 4.可靠性 5.鲁棒性 6.易用性 7.可测试性 8.可重用性 9.可维护性 10.可扩展性 11.可移植性 12 可互操作性等。我们在做HRMS系统架构设计时考虑的质量属性里面也不需要把每一个指标都做上去。这些指标之间是相互影响的。其影响关系如下（+表示促进  －表示影响  空白表示无明显作用）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231430220-130477692.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231430694-743749551.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;521&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当出现多个质量属性出现互斥的时候，必须要权衡以哪个为主，那相应的另外一个质量属性就会弱化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在架构设计中，对非功能性需求的重视程度，也会影响架构设计的好与劣；但也要平衡过渡设计和适可而止的关系。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二、如何找出关键的功能性、非功能性需求、关键约束？&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231431185-140006916.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231431658-926050818.png&quot; alt=&quot;image&quot; width=&quot;863&quot; height=&quot;287&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、找到系统的关键功能（系统具体是做什么的？）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;我们可以采取职责链模式来梳理关键功能：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231432220-580821737.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231432851-413535960.png&quot; alt=&quot;image&quot; width=&quot;796&quot; height=&quot;440&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模拟不同类型的用户如何通过系统实现业务需求的过程，借助系统化的思维模拟跟踪各环节，梳理清晰后即可得出清晰的职责链，这样便可以找出各链上的关键功能点，这些关键点即是关键功能。借助职责链模式来梳理核心功能，确认系统中存在必要功能、HRMS系统中的8大业务模块，这里再强调下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180916092836257-511135340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面8项属于核心功能。除此之外，还应该会有&lt;span&gt;&lt;span&gt;&lt;strong&gt;流程管理、权限管理等功能，辅助及支撑系统运行的基础功能&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、&lt;span&gt;&lt;strong&gt;确定关键质量的5大原则（找出关键质量属性）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231433259-239936963.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231433785-1948153381.png&quot; alt=&quot;image&quot; width=&quot;696&quot; height=&quot;384&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;Ø分类合适+必要扩充&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;       &lt;span&gt;&lt;strong&gt;针对质量分类进行细化及分解&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231434269-888382319.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231435406-1979934474.png&quot; alt=&quot;image&quot; width=&quot;702&quot; height=&quot;275&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;Ø考虑多方涉众&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;       用户不仅关注功能，同时也需要质量，用户关注的质量可能包括易用性、性能、持续可用性、鲁棒性等，&lt;span&gt;客户不一定是最终用户，比如超市销售系统的客户是超市老板，但最终用户可能是收银员或上货员，他们所关注的质量属性可能不一致。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;Ø检查性思维&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;       随时检查各个质量属性，看看每一项是否确实算不上“关键质量”，从而防止遗漏关键需求。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Ø识别矛盾+划定优先级&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       &lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231436728-418743086.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231437347-147465856.png&quot; alt=&quot;image&quot; width=&quot;666&quot; height=&quot;324&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;确定这些质量属性之间的矛盾关系，明确以哪些质量属性为主。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;Ø严格程度符合领域与规模特点&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;       严格程度符合领域与规模特点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       关键质量属性个数根据项目、产品、平台不同而不一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;       诸如：银行项目（注重安全性、易用性）;互联网服务项目（注重持续可用性、易用性、性能、可靠性等）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3、找出关键约束并将这些约束转化为功能或质量需求&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231437804-1077444843.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231438257-74900071.png&quot; alt=&quot;image&quot; width=&quot;852&quot; height=&quot;431&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;首先，按照4类约束进行罗列（尽可能全面）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;其次、分析约束面向的功能、质量方面的转化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最后、确定这些约束转化后的功能、质量是否重要&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、•第1步：需求结构化；•第2步：分析约束影响；•第3步：确定关键质量；•第4步：确定关键功能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231438865-301100028.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231439414-769594333.png&quot; alt=&quot;image&quot; width=&quot;693&quot; height=&quot;424&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;三、HRMS系统的关键功能、关键质量指标及约束&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;无论&lt;span&gt;上一篇&lt;span&gt;《&lt;a href=&quot;https://www.cnblogs.com/hegezhou_hot/p/9682677.html&quot;&gt;&lt;span&gt;HRMS(人力资源管理系统)-从单机应用到SaaS应用-架构分析(功能性、非功能性、关键约束)-上篇&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;介绍的，还是本篇前面介绍的内容基本上都是理论偏多一些，当然其中有一些具体的原则及操作方法，可能大家还不清楚具体的如何下手，如果真来一个项目，我该怎么循序渐进、由浅入深呢？下面我们就以HRMS为例来简单说明，我们来具体实际操作一下大家就会有比较清晰的认识了，希望大家能够掌握其中的精髓。需要多实践和总结。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.1、梳理出需求层次及需求类型（形成表格）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在前面我们描述了4类企业类别，在梳理需求前，我这边根据实际情况将企业划分为4类：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;    &lt;strong&gt;  A、100人以下的中小企业&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;      B、500人以下的大中型企业&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;      C、1000人以上的集团化大企业&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;      D、全球类型的公司体系（几万人）&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们可直观看出上述按照企业的规模、人员数量来进行的划分，因为我们都知道在系统架构设计时，一般来说规模及数量对于架构的影响是决定性的，所以这里先基于这个维度来对企业分类。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3.1.1 业务级需求&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;       前面我们罗列的HRMS系统的功能，我这里不在重复罗列，我认为这8项是基础业务级需求，上述的4类企业都需要提供这些功能。&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;（具体请参考上面的HRMS系统功能图）&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;       同时为了区分不同规模、人员数量企业的差异性，我这边又整理了几方面的需求内容，模拟甲方提出：&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;       注意事项：（前面规模较小的公司个性化的功能，后面规模较大的企业默认会有这些功能，所以很多内容我没有重复列出）&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;   A、100人以下的中小企业（单个企业内部使用）&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不同的用户看到的内容不同、可以单独管理各自内部的事宜&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;业务审批流程，支持自定义&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;与邮件系统、OA、财务系统等集成&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;LInux环境、java语言、内外网均可使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;需要提供app与pc端服务接入&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据统计及分析&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;    B、500人以下的大中型企业（多个公司内使用）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;支持多分公司管理模式（不同分公司看到的模块及数据不同，相互隔离，总部能看到）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;各分公司主要是作为业务拓展，按照总部的管理流程及制度来执行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;功能优化及升级，由总部统一规划及实施，各地可以提需求&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;硬件及软件环境由总部统一管理及维护&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;采取云端部署模式，部署前需各地提出相关需求&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;支持wap、微信等服务接入&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;大数据跟踪（指导各部门的人力资源及管理优化）&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;     C、1000人以上的集团化大企业（业务拆分模式的集团化公司）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;大集团公司下设多个小集团公司，各集团公司的业务不同和垂直化分公司的管理模式不同，需要系统支持该类型的配置管理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;信息流转及上报的业务线需要跨多个公司及职级，业务线不能乱。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;各集团子公司自定义内部的管理体系，总公司制定统一工作要求并给予指导&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;总公司及各子公司均有信息中心，各自建设内部的信息化，最终通过总公司信息中心进行统筹&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;科学决策及指导（人才战略）&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;     D、全球类型的公司体系（几万人）（跨国公司）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不同国家分公司的内部管理系统的功能模块不同&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;系统支持各地国家当地的语言&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;总部、分公司及下属部门间的信息联动及共享支持，可按层级设置汇报线及审批流&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;HRMS系统接入的第三方系统略有不同（OA、ERP等）,根据不同国家的公司情况，各公司统筹，对于总公司统筹的服务，各分公司按要求使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;企业指挥舱（内部+外部）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;3.1.2 质量属性&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;A、开发期质量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231439913-1551947297.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231440443-81273001.png&quot; alt=&quot;image&quot; width=&quot;854&quot; height=&quot;333&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       一般来说，甲方不会是专业的软件公司，如果是默认甲方会内部自主提出相应的需求提出具体的设计规划方案，这其中便会考虑系统的质量要求，对于开发过程中的质量要求一般需要在架构设计时主动考虑，提供相应的问题来咨询或为甲方提供专业的建议及咨询。对于甲方确认的内容可重点关注，对于甲方没有主动提出的，需要我们根据行业经验做好判断来落实。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基于前面模拟提出的个性化的需求，我们来综合梳理下开发期的质量要求：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;\&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;=100人&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;=500人&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;=1000人&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;=10000人&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;可扩展性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot;&gt;
&lt;p&gt;暂时可不考虑&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;可重用性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;不是特别强烈（重用性方面主要是针对基础组件方面需要考虑）&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;可测试性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;易理解性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;可维护性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;可移植性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot;&gt;
&lt;p&gt;暂时可不考虑&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;需考虑，但非必须&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;必备&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;基于上面的分析，我们已基本确认了不同规模的企业的HRMS系统需要考虑的质量属性略有不同。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B、运行期质量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231441187-718412295.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231441836-155582997.png&quot; alt=&quot;image&quot; width=&quot;858&quot; height=&quot;420&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;针对运行期的质量考虑，主要是基于用户使用过程中的各类场景来展开进行分析，提取出上述几类质量属性方面的要点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;&lt;strong&gt;\&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot;&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;=100人&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;=500人&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;=1000人&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;=10000人&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;性能&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;100人，数据量较小，暂时可不考虑&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;500人使用时性能也不需要特别的考虑，业务量及数据量都不会太大&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;一般&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;高&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;安全性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;内网部署，非外网隔离，安全性级别（高）&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;较高&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;较高&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;较高&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;易用性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot;&gt;
&lt;p&gt;需考虑，要求较低&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;一般&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;一般&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;高&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;持续可用性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;要求不高，上班期间使用&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;一般&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;较高&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;较高&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;可伸缩性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot;&gt;
&lt;p&gt;暂时可不考虑&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;暂时可不考虑&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;一般&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;高&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;互操作性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;需考虑（但要求不高）&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;需考虑，涉及到多个子公司，需要考虑差异性的互操作性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;一般&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;高&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;可靠性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot;&gt;
&lt;p&gt;高&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;高&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;较高&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;较高&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;鲁棒性&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;204&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;需考虑（要求不高）&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot;&gt;
&lt;p&gt;需考虑（一般）&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;196&quot;&gt;
&lt;p&gt;较高&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;
&lt;p&gt;较高&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;相对于开发期的质量属性来说，运行期的质量属性更多、更复杂、更重要，所以我们需要特别重视。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;3.1.3 系统约束&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;基于前面列出的应用需求，我们综合4类企业的约束，形成统一的约束清单：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;约束类型&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;759&quot;&gt;
&lt;p&gt;具体说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;业务环境约束&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;759&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;上线时间：3个月&lt;/p&gt;
&lt;p&gt;预算限制：性价比高&lt;/p&gt;
&lt;p&gt;集成环境：公司内部OA、邮件等系统与外部社保系统等连接&lt;/p&gt;
&lt;p&gt;政策及法规：受制于人力资源管理相应的办法&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;使用环境约束&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;759&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;何阶层用户：员工、HR、高管等&lt;/p&gt;
&lt;p&gt;年龄段和偏好：覆盖22岁~65岁&lt;/p&gt;
&lt;p&gt;多个国家：（多语言支持）&lt;/p&gt;
&lt;p&gt;是否存在网络较弱或延迟情况：会存在，所以需要考虑信息的临时存储及恢复&lt;/p&gt;
&lt;p&gt;设备移动的情况下：需要提供移动端设备访问&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;开发环境约束&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;759&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;技术水平：团队技术水平高,掌握java语言&lt;/p&gt;
&lt;p&gt;城市分布：多个城市&lt;/p&gt;
&lt;p&gt;磨合程度：一般&lt;/p&gt;
&lt;p&gt;开发管理程度：较高&lt;/p&gt;
&lt;p&gt;源代码保密：高&lt;/p&gt;
&lt;p&gt;网络环境：良好&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td width=&quot;133&quot;&gt;
&lt;p&gt;技术环境约束&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;759&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;技术平台：Java、Linux&lt;/p&gt;
&lt;p&gt;中间件：Spring cloud、Redis等&lt;/p&gt;
&lt;p&gt;编程语言的流行度：主流&lt;/p&gt;
&lt;p&gt;认同度：高&lt;/p&gt;
&lt;p&gt;优缺点：应用语言，性能问题需要考虑&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;       上面我们系统化的梳理了系统的业务功能、质量属性及约束内容，下面我们采取需求层次-需求类型二维矩阵来找出关键功能、关键质量属性及关键约束。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.2、确定关键功能、关键质量属性及关键约束&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      在确定关键功能、质量属性及约束之前，我想再限定和说明个前提，以便大家更好的理解，我们需要开发一个SaaS版本的系统，全方位的支持上述4类企业的需求，过程中我们作为一个企业，&lt;span&gt;&lt;span&gt;&lt;strong&gt;需要考虑成本、商业模式、企业未来的战略及盈利等方面的内容&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       所以基于这些约束及现状，我们可以梳理得出以下的关键功能及质量、约束的表格。作为后续我们做概要架构的前提和基础。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231442461-1786081897.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231443072-1360641835.png&quot; alt=&quot;image&quot; width=&quot;858&quot; height=&quot;470&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上表的具体的推演过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A、确定组织级的功能、质量、约束等内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231443578-1278420757.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231444059-1078658198.png&quot; alt=&quot;image&quot; width=&quot;850&quot; height=&quot;466&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B、确定用户级的功能、质量、约束等内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231444571-487674015.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231445058-1591294747.png&quot; alt=&quot;image&quot; width=&quot;859&quot; height=&quot;471&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C、确定开发级的质量及约束等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231445545-1019946050.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231446058-409134752.png&quot; alt=&quot;image&quot; width=&quot;848&quot; height=&quot;465&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;D、将约束衍生为质量属性及功能、将质量属性衍生为功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231446637-1958634093.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231447290-1601098328.png&quot; alt=&quot;image&quot; width=&quot;846&quot; height=&quot;464&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;将关键约束衍生为功能：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231447841-2006386860.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231448392-88924312.png&quot; alt=&quot;image&quot; width=&quot;843&quot; height=&quot;462&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据功能提炼出非功能性需求：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231449225-2082238835.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180922231449784-1329267119.png&quot; alt=&quot;image&quot; width=&quot;839&quot; height=&quot;460&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;E、形成统一的二维表（形成关键结果）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;（如上表）&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;F、总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       通过上述的几个环节，我们把不同类型的约束转化为质量属性及功能需求，最终我们形成了最终的需求二维矩阵，这将为我们的架构指明方向，后续我们再做架构的设计及规划的时候就能够做到有的放矢，不会走错方向。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;四、更多信息&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关于更多的系统架构方面的知识，我已建立了交流群，相关资料会第一时间在群里分享，欢迎大家入群互相学习交流：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;微信群：（扫码入群-名额有限）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180920183644567-807539114.png&quot;&gt;&lt;img title=&quot;1537187479(1)&quot; src=&quot;https://img2018.cnblogs.com/blog/46256/201809/46256-20180920183645208-1180188038.png&quot; alt=&quot;1537187479(1)&quot; width=&quot;309&quot; height=&quot;409&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Sep 2018 15:16:00 +0000</pubDate>
<dc:creator>何戈洲</dc:creator>
<og:description>一、开篇 上一篇《HRMS(人力资源管理系统)-从单机应用到SaaS应用-架构分析(功能性、非功能性、关键约束)-上篇》我们详细分析了在架构分析过程中我们需要注意的内容，架构过程的方法论及实践经验，以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hegezhou_hot/p/9691597.html</dc:identifier>
</item>
<item>
<title>移动端H5混合开发设置复盘与总结 - buoge</title>
<link>http://www.cnblogs.com/buoge/p/9691573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buoge/p/9691573.html</guid>
<description>&lt;p&gt;此篇接上一篇：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;移动端H5混合开发，Touch触控，拖拽，长按, 滑屏 实现方案&lt;br/&gt;https://www.cnblogs.com/buoge/p/9346699.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;app 场布设置已经上线了，用户可以通过手机端嵌入的h5网页进行场布设置，原来只能在pc端浏览器，还得带上个笔记本电脑很是不方便，这个功能很好的解决了目前设置不顺畅的问题。上线后得到大家的认可，提升了业务效率，这一个多月的辛苦开发还是值得的，接下来是对自己这一段时间开发过程的一个总结。&lt;/p&gt;
&lt;p&gt;整体开发基于H5+Css3+Jquery,前端这个组合略显过时，不过我就这个用的熟悉，先做完再说&lt;/p&gt;
&lt;h3 id=&quot;前后端开发混合开发&quot;&gt;前后端开发混合开发&lt;/h3&gt;
&lt;p&gt;功能前端和后端是一起开发的，好处是自己灵活定制不需要沟通成本，但是缺点也有前后端切换需要切换大脑思维的上下文，一会再写JS一会回去写Java不利于思维发挥和深入思考&lt;/p&gt;
&lt;p&gt;后端开发过程中还好有现成的方法可以调用，所以并没有耗费太多时间，大部分时间在前端开发上，假如后端也要做那才真是入水两腿泥&lt;/p&gt;
&lt;p&gt;总结：后续在有类似开发，不要大包大榄，专注一端去做，这样高效省心，专注前端和专注后台分工开发速度快了，效率高了，遇到难题有时间和情景去深入思考，所以尽可能把任务分开下&lt;/p&gt;
&lt;h3 id=&quot;android-ios-与h5-互相调用的问题&quot;&gt;android iOS 与h5 互相调用的问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;H5调用相机图片方向有问题：拍照是竖屏，展示成横屏，上传上去展示也是横屏&lt;/strong&gt;&lt;br/&gt;这两个帖子讲的很清楚，我就不展开了，思路就是利用 exif.js 判断方向，然后用CanvasApi从新生成base64&lt;br/&gt;格式的图片&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;H5拍照应用开发经历的那些坑儿&lt;br/&gt;http://www.yuuuuc.me/problems-with-html5-file-api-while-uploading-images/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;利用exif.js解决ios手机上传竖拍照片旋转90度问题&lt;br/&gt;https://blog.csdn.net/linlzk/article/details/48652635&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;源码放在了这里：&lt;br/&gt;https://github.com/buoge/gist/blob/master/FrontEnd/FixH5Oritention.html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相册调用去摄像头，图片大小限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Android 有api去除摄像头相机拍照的选项&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;iOS 没法直接去除，只能通过环境判断，动态触发自定义函数，直接跳转到相册，选择完成后返回base64数据&lt;br/&gt;客户端直接使用base64类型的数据判断文件大小，展示，最终上传到服务端也是base64方式的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        // 前端    
        function selectDeviceImg(){
            console.log('selectDeviceImg');
            if (window.webkit) { // iOS
                window.webkit.messageHandlers.Photo.postMessage(null);
            } else { // Android and others
                $(&quot;#file_head&quot;).trigger(&quot;click&quot;);
            }
        }
        
        // 服务端是这样子的
        @ResponseBody
        @RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST)
        public Result uploadImage(@RequestParam(required = true) String imageBase64,
                                  @RequestParam(required = true) String projectId) {
                                  ...
                                }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;h5与native交互方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Android 通过WebView对象自定义的AndroidObjec注入到页面，页面调用AndroidObjec&lt;/li&gt;
&lt;li&gt;iOS 实现机制类似，也是在UIWebView里面创建了一个对象，页面上直接给这个对象发送消息&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;  // 假如在iOS中 
  if (window.webkit) {
       // iOS post message 的方式
       window.webkit.messageHandlers.Signature.postMessage(null);
    } else if (typeof AndroidJSObj != &quot;undefined&quot;) { 
        // AndroidObjec 方式  
        AndroidJSObj.getSignature();
    }   &lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;URL拦截的实现思路：Android和iOS的webview都在监听url的调转事件，拦截到后，不做跳转，&lt;br/&gt;直接执行本地的逻辑，在实现语音播放的时候用到这个技巧，这个技巧本来是做页面跳转时使用的，&lt;br/&gt;客户端拦截到url跳转到对应的 Controller或是Activity,如果是浏览器h5直接跳转到对应的html页面&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;另外一种WebViewJavascriptBridge的库: https://github.com/marcuswestin/WebViewJavascriptBridge 1万多个start经过实战考研，后续项目中可以使用这个提升效率&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;浏览器返回问题history&quot;&gt;浏览器返回问题：history&lt;/h3&gt;
&lt;p&gt;页面中有一个功能就是上传图片，这个功能会覆盖现有页面的背景，上传页面是一个html,完事后直接location.href跳转到了另一个，现在整个页面嵌入在app里面有返回按钮，但现在不想让页面返回到上传页面，&lt;br/&gt;试了 location.replace 也不管用，这个方法在移动端不好用，而且还存在另一个问题就是在iOS需要点击两次返回按钮才能退出webview。&lt;/p&gt;
&lt;p&gt;这个功能上也调试了好久，最后也是让客户端处理了，监听页面返回在指定页面点击返回键直接推出&lt;/p&gt;
&lt;p&gt;总结：嵌套h5的时候尽量使用单页面的布局方式，方便管理，或是用react,vue这种都有对应的路由插件，这里也暴露了前端技能二把刀，遇到这种叼酸的bug就搞不定&lt;/p&gt;
&lt;h3 id=&quot;屏幕像素与真实像素转换&quot;&gt;屏幕像素与真实像素转换&lt;/h3&gt;
&lt;p&gt;之前一个帖子写过，背景是充满屏幕的，场布上是有点位的，长按可以添加点位，点位的定位算法就比较重要：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心就是：计算点位在原始图片的left,top位置，在不同分辨率上等比展示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设备分辨率： 300&lt;em&gt;600&lt;br/&gt;图片分辨率： 600&lt;/em&gt;1200&lt;/p&gt;
&lt;p&gt;点在屏幕上的位置是（left,top）：（30,60）&lt;br/&gt;对应到图片上原始像素就是（left,top）：(60,120)&lt;/p&gt;
&lt;p&gt;在另外一个设备分辨率是： 200*400的话&lt;br/&gt;图片上原始像素：（60，120），存在数据库，前端展示会返回&lt;br/&gt;在此设备上对应的位置就是：（20，40）&lt;/p&gt;
&lt;p&gt;我这里为了方便演绎参数值经过调整，大概意思就是这样&lt;/p&gt;
&lt;h3 id=&quot;网络异常的处理loading...成功失败&quot;&gt;网络异常的处理，loading...,成功失败&lt;/h3&gt;
&lt;p&gt;所有Ajax请求刚开始的时候没有使用一个统一的异常处理，请求开始加loading...,出错或网络异常，取消loading,提示业务异常或网络异常，这块应该提早规划，再有类似需求一定注意&lt;/p&gt;
&lt;h3 id=&quot;网页认证授权的问题&quot;&gt;网页认证授权的问题&lt;/h3&gt;
&lt;p&gt;ajax api 的认证方式是目前考虑到3种：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;自己按照一定规则md5计算出来的，根据时间戳算一个不可逆的签名，客户端算好，调用h5传给页面，发送ajax时放在header里面（目前是这种）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我之前实现过一种思路是使用md5和base64一起算好之后放在cookie里面，页面发送的时候带上cookie,计算过程任然在客户端，客户端计算完成调用h5的js函数，然后在发起ajax请求，由服务器验证，验证通过返回json&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;OAuth2 标准不解释了，这个服务暂时还没有自己搭建过倒是用过别人的，后续也会单独学习这块把这个技能点补充上来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关于移动前端开发效率&quot;&gt;关于移动前端开发效率&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Jquery 为主的开发方式还可以在优化&lt;/strong&gt;&lt;br/&gt;Jquery 效率比起 mvvm 的vue,react 代码效率要低，但是比较简单，目前代码已经接近2000行功能再要叠加肯定是要混乱起来，改不好改，修不好修，除了我每人敢动&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;css3 与前端工程实践的积累不足&lt;/strong&gt;&lt;br/&gt;在浏览器返回，手机相册选取，样式兼容性展示显示出很多力不从心的感觉，只能是大家一起协作解决，或是workaround 用曲线救国的方式实现，这块其实没办法，主力没有在前端，只能遇到问题多总结，多去实践才行&lt;/p&gt;
&lt;h3 id=&quot;移动端触控库选择&quot;&gt;移动端触控库选择&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;hammer.js 做手势交互和点击，长按的操作简直太棒，这个库1024！&lt;/li&gt;
&lt;li&gt;其实回过头来讲，js开发库不该用jquery应该用 zepto.js,它本身是为移动端而生，jquery 在移动端点击事件处理有很多问题，好些时候不能响应，只能用touchstart,touchend来触发，但是使用touch事件会发生很多误操作和无触碰，体验不是很好&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;ui-框架和样式库的选择&quot;&gt;UI 框架和样式库的选择&lt;/h3&gt;
&lt;p&gt;前面说过css不是很溜，不希望自己花时间在前端样式上，所以寻找一个合适的UI库是尤为重要的，这里我选择的是&lt;strong&gt;mui&lt;/strong&gt; https://github.com/dcloudio/mui/&lt;br/&gt;&lt;strong&gt;Bootstrap4&lt;/strong&gt; 一些基础样式&lt;br/&gt;&lt;strong&gt;iconfont&lt;/strong&gt; 免费的icon&lt;/p&gt;
&lt;p&gt;** 模态弹层layui **&lt;br/&gt;使用的 layer.js的移动版非常好用，解决了移动端模态弹层的问题，推荐大家使用：&lt;br/&gt;https://layer.layui.com/mobile/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tmpl&lt;/strong&gt;&lt;br/&gt;前端模板老组件了，虽然比起mvvm逊色不少，好在够用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;滚动穿透&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里有一些详细的解释，其实在模态弹窗那里也没有解决滑动穿透的问题&lt;br/&gt;https://uedsky.com/2016-06/mobile-modal-scroll/&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;** 点击300毫秒延迟问题 **&lt;br/&gt;在iOS端尤为强烈，这里放两个链接解释下，缘由，解决方案很多自行搜索&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* 为啥会有300毫秒延迟？
 https://thx.github.io/mobile/300ms-click-delay
 https://stackoverflow.com/questions/12238587/eliminate-300ms-delay-on-click-events-in-mobile-safari&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;动态播放音频的问题&quot;&gt;动态播放音频的问题&lt;/h3&gt;
&lt;p&gt;H5页面动态播放音频，在iOS一直没有弄好，可能是页面动态添加音视频的缘故，动态播放一直有问题，从测试结果来看是我们自己的音频文件服务器不稳定导致的，无法动态预览mp3语音文件，只能通过调用原生app的方法播放声音&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;但音频播放问题&lt;br/&gt;https://www.ibm.com/developerworks/cn/web/wa-ioshtml5/index.html&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;下面是几个播放音频比较好的库个人十分推荐howler.js后续有类似需求也会直接使用这个库&lt;br/&gt;https://github.com/goldfire/howler.js#examples&lt;br/&gt;https://github.com/mediaelement/mediaelement&lt;br/&gt;https://github.com/CreateJS/SoundJS&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;上线时间点&quot;&gt;上线时间点&lt;/h3&gt;
&lt;p&gt;本来说是8月15号上线，延期到8月底上线，但是由于我弄了两天发布脚本，研究了一天的部署环境，没有尽早提测，但是感觉主要是没有沟通到位，我从其他处得知这次功能要在月底一次发版，我就没在意，没有继续推进这个事，又在打磨一些细节，一个是调试音视频播放，一个是调试window.hostory接口尝试解决页面返回的问题，最后没解决和客户端协商解决，因此耽误了时间，下次在商谈好时间节点后要尽量按照时间节点来进行活动安排，时间点关键点要多沟通，上还是不能上，还是延期上都要有个明确的结论。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Sep 2018 15:05:00 +0000</pubDate>
<dc:creator>buoge</dc:creator>
<og:description>此篇接上一篇： 移动端H5混合开发，Touch触控，拖拽，长按, 滑屏 实现方案 https://www.cnblogs.com/buoge/p/9346699.html app 场布设置已经上线了，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/buoge/p/9691573.html</dc:identifier>
</item>
<item>
<title>访问Hsql .data数据库文件 - Code_Dog</title>
<link>http://www.cnblogs.com/dongjh/p/9691566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongjh/p/9691566.html</guid>
<description>&lt;h2&gt;一、Hsql简介：&lt;/h2&gt;
&lt;p&gt;hsql数据库是一款纯Java编写的免费数据库，许可是BSD-style的协议。 仅一个hsqldb.jar文件就包括了数据库引擎，数据库驱动，还有其他用户界面操作等内容。下载地址：https://sourceforge.net/projects/hsqldb/files/hsqldb/。&lt;span&gt;其中hsqldb-2.4.x 开头的需要jdk8及以上，低于这个版本的比如hsqldb-2.2.9 jdk7可以用。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二、Hsql文件结构：&lt;/h2&gt;
&lt;p&gt;数据库会包含如下文件:&lt;br/&gt;• finedb.properties&lt;br/&gt;• finedb.script&lt;br/&gt;• finedb.log&lt;br/&gt;• finedb.data&lt;br/&gt;• finedb.backup&lt;br/&gt;finedb.properties 文件包含关于数据库的一般设置。&lt;br/&gt;finedb.script 文件包含表和其它数据库,插入没有缓存表的数据。&lt;br/&gt;finedb.log 文件包含当前数据库的变更。&lt;br/&gt;finedb.data 文件包含缓存表的数据。&lt;br/&gt;finedb.backup 文件是最近持久化状态的表的数据文件的压缩备份文件&lt;br/&gt;&lt;span&gt;如果数据库没有缓存表，finedb.data finedb.backup文件将不会存在，数据也可能存在finedb.script文件中&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;三、访问过程：&lt;/h2&gt;
&lt;p&gt;1.把下载的jar包..\hsqldb-2.2.9\hsqldb\lib\hsqldb.jar放到hsql目录下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/442973/201809/442973-20180922221828267-1486227259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.把jar包添加到classpath环境变量中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/442973/201809/442973-20180922222117850-1440769695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.创建data目录把需要访问的文件放到此目录。&lt;span&gt;也可以自己创建新的数据库文件，在命令行进入data文件夹输入命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;D:\hsqldb\data&amp;gt;java org.hsqldb.Server -database finedb&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/442973/201809/442973-20180922222152410-391556337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;span&gt;创建system.properties文件，dbname和port是随便指定的，&lt;span&gt;finedb的名字是要与需要访问的数据文件名字保持一致&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/442973/201809/442973-20180922222515346-751029461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.打开命令窗口，进入当前文件夹输入服务端命令：java org.hsqldb.Server。提示成功数据库说明已经成功启动并连到.data文件了，如果提示sql有问题可以去finedb.script中修改脚本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/442973/201809/442973-20180922222831074-740622087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.打开另外一个命令窗口，进入当前文件夹输入客户端命令：java org.hsqldb.util.DatabaseManagerSwing会弹出窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/442973/201809/442973-20180922223508991-2026758220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/442973/201809/442973-20180922223448972-499886767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.setting name随便写，URL中输入jdbc:hsqldb:hsql://localhost:8001/fineReportdb就可以成功连上db了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/442973/201809/442973-20180922223755048-877524627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、用代码访问Hsql数据库：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.Connection;

     &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.DriverManager;

     &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;

     &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;

     &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.Statement;

 

     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConnetcHsqlDb {

          &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

               String url &lt;/span&gt;= &quot;jdbc:hsqldb:hsql://localhost:8001/fineReportdb&quot;&lt;span&gt;;

               String user &lt;/span&gt;= &quot;SA&quot;&lt;span&gt;;

               String password &lt;/span&gt;= &quot;&quot;&lt;span&gt;;

               &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

                    Class.forName(&lt;/span&gt;&quot;org.hsqldb.jdbcDriver&quot;&lt;span&gt;);

                    Connection conn &lt;/span&gt;=&lt;span&gt; DriverManager.getConnection(url, user, password);

                    Statement state &lt;/span&gt;=&lt;span&gt; conn.createStatement();

                    ResultSet rs &lt;/span&gt;= state.executeQuery(&quot;SELECT FIRSTNAME,LASTNAME FROM customer&quot;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (rs.next()) {

                         System.out.print(rs.getString(&lt;/span&gt;&quot;FIRSTNAME&quot;) + &quot; &quot;&lt;span&gt;);

                         System.out.print(rs.getString(&lt;/span&gt;&quot;LASTNAME&quot;) + &quot; &quot;&lt;span&gt;);

                         System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);

                    }

               } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {

                    e.printStackTrace();

               } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {

                    e.printStackTrace();

               }

          }

     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 22 Sep 2018 15:02:00 +0000</pubDate>
<dc:creator>Code_Dog</dc:creator>
<og:description>一、Hsql简介： hsql数据库是一款纯Java编写的免费数据库，许可是BSD-style的协议。 仅一个hsqldb.jar文件就包括了数据库引擎，数据库驱动，还有其他用户界面操作等内容。下载地址</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongjh/p/9691566.html</dc:identifier>
</item>
<item>
<title>Python 列表详细使用 - |旧市拾荒|</title>
<link>http://www.cnblogs.com/xiaoyh/p/9689596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyh/p/9689596.html</guid>
<description>&lt;div id=&quot;&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;使用“=”直接将一个列表赋值给变量即可创建列表对象&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list = ['a', 'b', 'mpilgrim', 'z', 'example']&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list = []                              #创建空列表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;也可以使用list()函数将元组、range对象、字符串或其他类型的可迭代对象类型的数据转换为列表。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list = list((3,5,7,9,11))&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list&lt;br/&gt;&lt;span&gt;[3, 5, 7, 9, 11]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; list(range(1,10,2))&lt;br/&gt;&lt;span&gt;[1, 3, 5, 7, 9]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; list('hello world')&lt;br/&gt;&lt;span&gt;['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x = list()                            #创建空列表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;当不再使用时，使用&lt;span&gt;del命令&lt;/span&gt;删除整个列表，如果列表对象所指向的值不再有其他对象指向，Python将同时删除该值。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; del a_list&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list&lt;br/&gt;&lt;span&gt;Traceback (most recent call last):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;File &quot;&amp;lt;pyshell#6&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a_list&lt;/span&gt;&lt;br/&gt;&lt;span&gt;NameError: name 'a_list' is not defined&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/div&gt;&lt;div id=&quot;&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;可以使用“+”运算符将元素添加到列表中。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = [3,4,5]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = aList + [7]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 4, 5, 7]&lt;/span&gt;&lt;br/&gt;严格意义上来讲，这并不是真的为列表添加元素，&lt;span&gt;而是创建了一个新列表&lt;/span&gt;，并将原列表中的元素和新元素依次复制到新列表的内存空间。由于涉及大量元素的复制，&lt;span&gt;该操作速度较慢&lt;/span&gt;，在涉及大量元素添加时不建议使用该方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;使用列表对象的append()方法在当前列表&lt;span&gt;尾部&lt;/span&gt;追加元素，&lt;span&gt;原地修改列表&lt;/span&gt;，是真正意义上的在列表尾部添加元素，&lt;span&gt;速度较快。&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.append(9)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 4, 5, 7, 9]&lt;/span&gt;&lt;br/&gt;所谓“原地”，是指&lt;span&gt;不改变列表在内存中的首地址。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;Python采用的是基于&lt;span&gt;值的自动内存管理方式&lt;/span&gt;，当为对象修改值时，并不是真的直接修改变量的值，而是使变量指向新的值，这对于Python所有类型的变量都是一样的。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(a) 　　                         #返回对象的内存地址&lt;br/&gt;&lt;span&gt;20230752&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(a)&lt;br/&gt;&lt;span&gt;20338208&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;列表中包含的是元素值的引用，而不是直接包含元素值。&lt;/span&gt;&lt;br/&gt;如果是直接修改序列变量的值，则与Python普通变量的情况是一样的&lt;br/&gt;如果是通过&lt;span&gt;下标&lt;/span&gt;来修改序列中元素的值或通过&lt;span&gt;可变序列对象自身提供的方法&lt;/span&gt;来增加和删除元素时，序列对象在内存中的起始地址是不变的，仅仅是被改变值的元素地址发生变化，也就是所谓的“&lt;span&gt;原地操作&lt;/span&gt;”。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,4]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; b = [1,2,3]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a == b&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(a) == id(b)&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(a[0]) == id(b[0])&lt;br/&gt;&lt;span&gt;True&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(a)&lt;br/&gt;&lt;span&gt;25289752&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a.append(4)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(a)&lt;br/&gt;&lt;span&gt;25289752&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a.remove(3)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a&lt;br/&gt;&lt;span&gt;[1, 2, 4]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(a)&lt;br/&gt;&lt;span&gt;25289752&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a[0] = 5&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a&lt;br/&gt;&lt;span&gt;[5, 2, 4]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(a)&lt;br/&gt;&lt;span&gt;25289752&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;25&quot;&gt;
&lt;p&gt;使用列表对象的extend()方法可以将另一个迭代对象的所有元素添加至该列表对象&lt;span&gt;尾部&lt;/span&gt;。通过extend()方法来增加列表元素也不改变其内存首地址，属于&lt;span&gt;原地操作。&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a.extend([7,8,9])&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a&lt;br/&gt;&lt;span&gt;[5, 2, 4, 7, 8, 9]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(a)&lt;br/&gt;&lt;span&gt;25289752&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.extend([11,13])&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 4, 5, 7, 9, 11, 13]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.extend((15,17))&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 4, 5, 7, 9, 11, 13, 15, 17]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;24&quot;&gt;
&lt;p&gt;使用列表对象的insert()方法将元素添加至列表的&lt;span&gt;指定位置。&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.insert(3, 6)                    #在下标为3的位置插入元素6&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]&lt;/span&gt;&lt;br/&gt;应&lt;span&gt;尽量从列表尾部进行元素的增加与删除操作。&lt;/span&gt;&lt;br/&gt;列表的insert()可以在列表的任意位置插入元素，但由于列表的自动内存管理功能，&lt;span&gt;insert()方法会引起插入位置之后所有元素的移动&lt;/span&gt;，这会影响处理速度。&lt;br/&gt;类似的还有后面介绍的remove()方法以及使用pop()函数弹出列表非尾部元素和使用del命令删除列表非尾部元素的情况。&lt;br/&gt;import time&lt;/p&gt;
&lt;p&gt;def Insert():&lt;br/&gt;a = []&lt;br/&gt;for i in range(10000):&lt;br/&gt;a.insert(0, i)&lt;/p&gt;
&lt;p&gt;def Append():&lt;br/&gt;a = []&lt;br/&gt;for i in range(10000):&lt;br/&gt;a.append(i)&lt;/p&gt;
&lt;p&gt;start = time.time()&lt;br/&gt;for i in range(10):&lt;br/&gt;Insert()&lt;br/&gt;print('Insert:', time.time()-start)&lt;/p&gt;
&lt;p&gt;start = time.time()&lt;br/&gt;for i in range(10):&lt;br/&gt;Append()&lt;br/&gt;print('Append:', time.time()-start)&lt;br/&gt;上面代码运行结果如下：&lt;br/&gt;&lt;span&gt;Insert: 0.578000068665&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Append: 0.0309998989105&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;34&quot;&gt;
&lt;p&gt;使用乘法来扩展列表对象，将列表与整数相乘，生成一个新列表，新列表是原列表中元素的重复。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = [3,5,7]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; bList = aList&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(aList)&lt;br/&gt;&lt;span&gt;57091464&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(bList)&lt;br/&gt;&lt;span&gt;57091464&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = aList*3&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 5, 7, 3, 5, 7, 3, 5, 7]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; bList&lt;br/&gt;&lt;span&gt;[3,5,7]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(aList)&lt;br/&gt;&lt;span&gt;57092680&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(bList)&lt;br/&gt;&lt;span&gt;57091464&lt;/span&gt;&lt;br/&gt;当使用*运算符将包含列表的列表重复并创建新列表时，并不是复制子列表值，而是&lt;span&gt;复制已有元素的引用&lt;/span&gt;。因此，当修改其中一个值时，相应的引用也会被修改。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x = [[None] * 2] * 3&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x&lt;br/&gt;&lt;span&gt;[[None, None], [None, None], [None, None]]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x[0][0] = 5&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x&lt;br/&gt;&lt;span&gt;[[5, None], [5, None], [5, None]]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x = [[1,2,3]] * 3&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x[0][0] = 10&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x&lt;br/&gt;&lt;span&gt;[[10, 2, 3], [10, 2, 3], [10, 2, 3]]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/div&gt;&lt;div id=&quot;&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;使用del命令删除列表中的&lt;span&gt;指定位置&lt;/span&gt;上的元素。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list = [3,5,7,9,11]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; del a_list[1]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list&lt;br/&gt;&lt;span&gt;[3, 7, 9, 11]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;使用列表的pop()方法删除并返回指定位置（默认为最后一个）上的元素，如果给定的索引超出了列表的范围则抛出异常。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list = list((3,5,7,9,11))&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list.pop()&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list&lt;br/&gt;&lt;span&gt;[3, 5, 7, 9]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list.pop(1)&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list&lt;br/&gt;&lt;span&gt;[3, 7, 9]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;44&quot;&gt;
&lt;p&gt;使用列表对象的remove()方法删除&lt;span&gt;首次出现&lt;/span&gt;的指定元素，如果列表中不存在要删除的元素，则抛出异常。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list = [3,5,7,9,7,11]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list.remove(7)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; a_list&lt;br/&gt;&lt;span&gt;[3, 5, 9, 7, 11]&lt;/span&gt;&lt;br/&gt;代码编写好后必须要经过反复测试，不能满足于几次测试结果正确。例如，下面的代码成功地删除了列表中的重复元素，执行结果是完全正确的。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x = [1,2,1,2,1,2,1,2,1]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; for i in x:&lt;br/&gt;           if i == 1:&lt;br/&gt;               x.remove(i)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x&lt;br/&gt;&lt;span&gt;[2, 2, 2, 2]&lt;/span&gt;&lt;br/&gt;然而，上面这段代码的逻辑是错误的。同样的代码，仅仅是所处理的数据发生了一点变化，然而当循环结束后却发现并没有把所有的“1”都删除，只是删除了一部分。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x = [1,2,1,2,1,1,1]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; for i in x:&lt;br/&gt;　　    if i == 1:&lt;br/&gt;               x.remove(i)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x&lt;br/&gt;&lt;span&gt;[2, 2, 1]&lt;/span&gt;&lt;br/&gt;两组数据的本质区别在于，第一组数据中没有连续的“1”，而第二组数据中存在连续的“1”。出现这个问题的原因是&lt;span&gt;列表的自动内存管理功能。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在删除列表元素时，Python会自动对列表内存进行收缩并移动列表元素以保证所有元素之间没有空隙，增加列表元素时也会自动扩展内存并对元素进行移动以保证元素之间没有空隙。&lt;/span&gt;每当插入或删除一个元素之后，该元素位置后面所有元素的索引就都改变了。&lt;br/&gt;正确的代码：&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x = [1,2,1,2,1,1,1]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; for i in x[::]:                          #切片&lt;br/&gt;           if i == 1:&lt;br/&gt;               x.remove(i)&lt;br/&gt;或者：&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x = [1,2,1,2,1,1,1]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; for i in range(len(x)-1,-1,-1):                                    #从后往前删&lt;br/&gt;           if x[i]==1:&lt;br/&gt;              del x[i]&lt;/p&gt;
&lt;/li&gt;
&lt;/div&gt;&lt;div id=&quot;&quot;&gt;&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;使用下标直接访问列表元素，如果指定下标不存在，则抛出异常。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[3]&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[3] = 5.5&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 4, 5, 5.5, 7, 9, 11, 13, 15, 17]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[15]&lt;br/&gt;&lt;span&gt;Traceback (most recent call last):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;File &quot;&amp;lt;pyshell#34&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;aList[15]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;IndexError: list index out of range&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;使用列表对象的index()方法获取指定元素首次出现的下标，若列表对象中不存在指定元素，则抛出异常。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 4, 5, 5.5, 7, 9, 11, 13, 15, 17]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.index(7)&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.index(100)&lt;br/&gt;&lt;span&gt;Traceback (most recent call last):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;File &quot;&amp;lt;pyshell#36&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;aList.index(100)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ValueError: 100 is not in list&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;使用列表对象的count()方法统计指定元素在列表对象中出现的次数。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 4, 5, 5.5, 7, 9, 11, 13, 15, 17]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.count(7)&lt;br/&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.count(0)&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.count(8)&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/div&gt;&lt;div id=&quot;&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;切片适用于列表、元组、字符串、range对象等类型，但作用于列表时功能最强大。可以使用切片来截取列表中的任何部分，得到一个新列表，也可以通过切片来修改和删除列表中部分元素，甚至可以通过切片操作为列表对象增加元素。&lt;br/&gt;切片使用2个冒号分隔的3个数字来完成：&lt;br/&gt;第一个数字表示切片开始位置（默认为0）。&lt;br/&gt;第二个数字表示切片截止（但不包含）位置（默认为列表长度）。&lt;br/&gt;第三个数字表示切片的步长（默认为1），当步长省略时可以顺便省略最后一个冒号。&lt;br/&gt;切片操作不会因为下标越界而抛出异常，而是简单地在列表尾部截断或者返回一个空列表，代码具有更强的健壮性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;55&quot;&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; aList = [3, 4, 5, 6, 7, 9, 11, 13, 15, 17]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[::]                             #返回包含所有元素的新列表&lt;br/&gt;&lt;span&gt;[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[::-1]                           #逆序的所有元素&lt;br/&gt;&lt;span&gt;[17, 15, 13, 11, 9, 7, 6, 5, 4, 3]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[::2]                            #偶数位置，隔一个取一个&lt;br/&gt;&lt;span&gt;[3, 5, 7, 11, 15]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[1::2]                           #奇数位置，隔一个取一个&lt;br/&gt;&lt;span&gt;[4, 6, 9, 13, 17]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[3::]                            #从下标3开始的所有元素&lt;br/&gt;&lt;span&gt;[6, 7, 9, 11, 13, 15, 17]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[3:6]                             #下标在[3, 6)之间的所有元素&lt;br/&gt;&lt;span&gt;[6, 7, 9]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[0:100:1]                       #前100个元素，自动截断&lt;br/&gt;&lt;span&gt;[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[100:]                            #下标100之后的所有元素，自动截断&lt;br/&gt;&lt;span&gt;[]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[100]                             #直接使用下标访问会发生越界&lt;br/&gt;&lt;span&gt;IndexError: list index out of range&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;30&quot;&gt;
&lt;p&gt;可以使用切片来原地修改列表内容&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = [3, 5, 7]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[len(aList):] = [9]                       #在尾部追加元素&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 5, 7, 9]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[:3] = [1, 2, 3]                            #替换前3个元素&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[1, 2, 3, 9]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[:3] = []                                        #删除前3个元素&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = list(range(10))&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[::2] = [0]*5                                  #替换偶数位置上的元素&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[0, 1, 0, 3, 0, 5, 0, 7, 0, 9]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList[::2] = [0]*3                                    #切片不连续，两个元素个数必须一样多&lt;br/&gt;&lt;span&gt;ValueError: attempt to assign sequence of size 3 to extended slice of size 5&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;使用del与切片结合来删除列表元素&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = [3,5,7,9,11]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; del aList[:3]                                    #删除前3个元素&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[9, 11]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = [3,5,7,9,11]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; del aList[::2]                              #删除偶数位置上的元素&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[5, 9]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;切片返回的是列表元素的浅复制&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = [3, 5, 7]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; bList = aList                                    #bList与aList指向同一个内存&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; bList&lt;br/&gt;&lt;span&gt;[3, 5, 7]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; bList[1] = 8                                    #修改其中一个对象会影响另一个&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 8, 7]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList == bList                                #两个列表的元素完全一样&lt;br/&gt;&lt;span&gt;True&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList is bList                                 #两个列表是同一个对象&lt;br/&gt;&lt;span&gt;True&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(aList)                                        #内存地址相同&lt;br/&gt;&lt;span&gt;19061816&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(bList)&lt;br/&gt;&lt;span&gt;19061816&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;所谓浅复制，是指生成一个新的列表，并且把原列表中所有元素的引用都复制到新列表中。&lt;/span&gt;如果原列表中只包含整数、实数、复数等基本类型或元组、字符串这样的不可变类型的数据，一般是没有问题的。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = [3, 5, 7]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; bList = aList[::]                              #切片，浅复制&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList == bList                              #两个列表的元素完全一样&lt;br/&gt;&lt;span&gt;True&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList is bList                                  #但不是同一个对象&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; id(aList) == id(bList)                      #内存地址不一样&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; bList[1] = 8                                    #修改其中一个不会影响另一个&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; bList&lt;br/&gt;&lt;span&gt;[3, 8, 7]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 5, 7]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;如果原列表中包含列表之类的可变数据类型，由于浅复制时只是把子列表的引用复制到新列表中，这样的话修改任何一个都会影响另外一个。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x = [1, 2, [3,4]]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; y = x[:]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x[0] = 5&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x&lt;br/&gt;&lt;span&gt;[5, 2, [3, 4]]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; y&lt;br/&gt;&lt;span&gt;[1, 2, [3, 4]]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x[2].append(6)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; x&lt;br/&gt;&lt;span&gt;[5, 2, [3, 4, 6]]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; y&lt;br/&gt;&lt;span&gt;[1, 2, [3, 4, 6]]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/div&gt;&lt;div id=&quot;&quot;&gt;&lt;li readability=&quot;38&quot;&gt;
&lt;p&gt;使用列表对象的sort()方法进行原地排序，支持多种不同的排序方法。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = [3, 4, 5, 6, 7, 9, 11, 13, 15, 17]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; import random&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; random.shuffle(aList)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[3, 4, 15, 11, 9, 17, 13, 6, 7, 5]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.sort()                                 #默认是升序排序&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.sort(reverse = True)              #降序排序&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[17, 15, 13, 11, 9, 7, 6, 5, 4, 3]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.sort(key = lambda x:len(str(x)))                                   #按转换成字符串的长度排序&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[9, 7, 6, 5, 4, 3, 17, 15, 13, 11]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;30&quot;&gt;
&lt;p&gt;使用内置函数sorted()对列表进行排序并返回新列表&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[9, 7, 6, 5, 4, 3, 17, 15, 13, 11]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; sorted(aList)                                                      #升序排序&lt;br/&gt;&lt;span&gt;[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; sorted(aList,reverse = True)                                       #降序排序&lt;br/&gt;&lt;span&gt;[17, 15, 13, 11, 9, 7, 6, 5, 4, 3]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;使用列表对象的reverse()方法将元素原地逆序&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = [3, 4, 5, 6, 7, 9, 11, 13, 15, 17]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList.reverse()&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList&lt;br/&gt;&lt;span&gt;[17, 15, 13, 11, 9, 7, 6, 5, 4, 3]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;22&quot;&gt;
&lt;p&gt;使用内置函数reversed()对列表元素进行逆序排列并返回迭代对象&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = [3, 4, 5, 6, 7, 9, 11, 13, 15, 17]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; newList = reversed(aList)                                          #返回reversed对象&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; list(newList)                                                               #把reversed对象转换成列表&lt;br/&gt;&lt;span&gt;[17, 15, 13, 11, 9, 7, 6, 5, 4, 3]&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; for i in newList:&lt;br/&gt;           print(i, end=' ')                                             #这里没有输出内容&lt;br/&gt;                                                                               #迭代对象已遍历结束&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; newList = reversed(aList)                               #重新创建reversed对象&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; for i in newList:&lt;br/&gt;           print(i, end=' ')&lt;br/&gt;&lt;span&gt;17 15 13 11 9 7 6 5 4 3&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/div&gt;&lt;div id=&quot;&quot;&gt;&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;len(列表)：返回列表中的元素个数，同样适用于元组、字典、集合、字符串等。&lt;br/&gt;max(列表)、 min(列表)：返回列表中的最大或最小元素，同样适用于元组、字典、集合、range对象等。&lt;br/&gt;sum(列表)：对列表的元素进行求和运算，对非数值型列表运算需要指定start参数，同样适用于元组、range。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; sum(range(1, 11))                                     #sum()函数的start参数默认为0&lt;br/&gt;&lt;span&gt;55&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; sum(range(1, 11), 5)                                 #指定start参数为5，等价于5+sum(range(1,11))&lt;br/&gt;&lt;span&gt;60&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; sum([[1, 2], [3], [4]], [])                                #这个操作占用空间较大，慎用&lt;br/&gt;&lt;span&gt;[1, 2, 3, 4]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;zip()函数返回可迭代的zip对象。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; aList = [1, 2, 3]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; bList = [4, 5, 6]&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; cList = zip(a, b)                                       #返回zip对象&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; cList&lt;br/&gt;&lt;span&gt;&amp;lt;zip object at 0x0000000003728908&amp;gt;&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; list(cList)                                                  #把zip对象转换成列表&lt;br/&gt;&lt;span&gt;[(1, 4), (2, 5), (3, 6)]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;enumerate(列表):枚举列表元素，返回枚举对象，其中每个元素为包含下标和值的元组。该函数对元组、字符串同样有效。&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; for item in enumerate('abcdef'):&lt;br/&gt;           print(item)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(0, 'a')&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(1, 'b')&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(2, 'c')&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(3, 'd')&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(4, 'e')&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(5, 'f')&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 22 Sep 2018 15:00:00 +0000</pubDate>
<dc:creator>|旧市拾荒|</dc:creator>
<og:description>1. 列表 列表是Python中内置有序、可变序列，列表的所有元素放在一对中括号“[]”中，并使用逗号分隔开； 当列表元素增加或删除时，列表对象自动进行扩展或收缩内存，保证元素之间没有缝隙； 在Pyt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoyh/p/9689596.html</dc:identifier>
</item>
<item>
<title>高并发第十单:J.U.C  AQS 组件:CountDownLatch. CyclicBarrier .Semaphore - 爱呼吸的鱼</title>
<link>http://www.cnblogs.com/aihuxi/p/9691467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aihuxi/p/9691467.html</guid>
<description>&lt;p&gt;这里有一篇介绍AQS的文章 非常好: &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/waterystone/p/4920797.html&quot;&gt;Java并发之AQS详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。它实现了一个FIFO(FirstIn、FisrtOut先进先出)的队列。底层实现的数据结构是一个双向列表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180423180428455?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plc29uam9rZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; width=&quot;539&quot; height=&quot;283&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Sync queue：同步队列，是一个双向列表。包括head节点和tail节点。head节点主要用作后续的调度。&lt;/p&gt;
&lt;p&gt;Condition queue：非必须，单向列表。当程序中存在cindition的时候才会存在此列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/721070/201705/721070-20170504110246211-10684485.png&quot; alt=&quot;&quot; width=&quot;852&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。它实现了一个FIFO(FirstIn、FisrtOut先进先出)的队列。底层实现的数据结构是一个双向列表。&lt;/p&gt;
&lt;p&gt;　它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getState()&lt;/li&gt;
&lt;li&gt;setState()&lt;/li&gt;
&lt;li&gt;compareAndSetState()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里就不详细去说AQS了.因为开头的那个文章已经说得很清楚了.介绍以下他的实现类吧&lt;/p&gt;
&lt;h3&gt;1.CountDownLatch(计数器)&lt;/h3&gt;
&lt;h3 class=&quot;postTitle&quot;&gt;详解&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yanphet/p/5788260.html&quot;&gt;Java CountDownLatch源码解析（上）&lt;/a&gt;    &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yanphet/p/5852244.html&quot;&gt;Java CountDownLatch源码解析（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 class=&quot;postTitle&quot;&gt; &lt;/h3&gt;
&lt;p&gt;CountDownLatch是在java1.5被引入的，它都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://incdn1.b0.upaiyun.com/2015/04/f65cc83b7b4664916fad5d1398a36005.png&quot; alt=&quot;&quot; width=&quot;353&quot; height=&quot;338&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;主要在实时系统中的使用场景&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;实现最大的并行性&lt;/strong&gt;：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开始执行前等待n个线程完成各自任务&lt;/strong&gt;：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死锁检测：&lt;/strong&gt;一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行 (最常用的)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;构造方法：     &lt;/p&gt;
&lt;p&gt;构造一个用给定计数初始化的 CountDownLatch(int count)     &lt;/p&gt;
&lt;p&gt;普通方法：  &lt;/p&gt;
&lt;p&gt;void await()            使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。&lt;/p&gt;
&lt;p&gt;boolean await(long timeout, TimeUnit unit)            可以设置等待的时间，如果超过此时间，计数器还未清零，则不继续等待&lt;/p&gt;
&lt;p&gt;void countDown()            递减锁存器的计数，如果计数到达零，则释放所有等待的线程 &lt;/p&gt;
&lt;p&gt; long getCount()            返回当前计数&lt;/p&gt;

&lt;p&gt;看个例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountDownLatchDemo {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THREAD_COUNT_NUM = 6&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountDownLatch(THREAD_COUNT_NUM);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 6; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;第&quot; + index + &quot;个任务完成！&quot;
                            +&lt;span&gt; Thread.currentThread().getName());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟完成一个任务,随机模拟不同的寻找时间&lt;/span&gt;
                    Thread.sleep(3000&lt;span&gt;);
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;完成:&quot; +&lt;span&gt; System.currentTimeMillis());
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每完成一个任务,需要等待的任务数减1
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; countDownLatch.countDown();&lt;/span&gt;
&lt;span&gt;
            }, &lt;/span&gt;&quot;我是线程:&quot; + i + &quot;:&quot;&lt;span&gt;).start();
            ;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待检查，即上述7个线程执行完毕之后，执行await后边的代码
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; countDownLatch.await();&lt;/span&gt;
        System.out.println(&quot;所有任务完成!&quot; +&lt;span&gt; System.currentTimeMillis());

    }
}&lt;p&gt;结果:&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;所有任务完成!1537617901498&lt;/strong&gt;&lt;br/&gt;我是线程:3:第3个任务完成！我是线程:3:&lt;br/&gt;我是线程:0:第0个任务完成！我是线程:0:&lt;br/&gt;我是线程:1:第1个任务完成！我是线程:1:&lt;br/&gt;我是线程:2:第2个任务完成！我是线程:2:&lt;br/&gt;我是线程:4:第4个任务完成！我是线程:4:&lt;br/&gt;我是线程:5:第5个任务完成！我是线程:5:&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;我是线程:2:完成:1537617904499&lt;br/&gt;我是线程:1:完成:1537617904499&lt;br/&gt;我是线程:0:完成:1537617904499&lt;br/&gt;我是线程:3:完成:1537617904499&lt;br/&gt;我是线程:4:完成:1537617904499&lt;br/&gt;我是线程:5:完成:1537617904499&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加上:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountDownLatchDemo {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THREAD_COUNT_NUM = 6&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountDownLatch(THREAD_COUNT_NUM);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 6; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;第&quot; + index + &quot;个任务完成！&quot;
                            +&lt;span&gt; Thread.currentThread().getName());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟完成第i个任务,&lt;/span&gt;
                    Thread.sleep(3000&lt;span&gt;);
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;完成:&quot; +&lt;span&gt; System.currentTimeMillis());
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每完成一个任务,需要等待的任务数减1&lt;/span&gt;
&lt;span&gt;                 countDownLatch.countDown();

            }, &lt;/span&gt;&quot;我是线程:&quot; + i + &quot;:&quot;&lt;span&gt;).start();
            ;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待检查，即上述7个线程执行完毕之后，执行await后边的代码&lt;/span&gt;
&lt;span&gt;         countDownLatch.await();
        System.out.println(&lt;/span&gt;&quot;所有任务完成!&quot; +&lt;span&gt; System.currentTimeMillis());

    }
}&lt;br/&gt;结果:&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;我是线程:2:第2个任务完成！我是线程:2:&lt;br/&gt;我是线程:1:第1个任务完成！我是线程:1:&lt;br/&gt;我是线程:0:第0个任务完成！我是线程:0:&lt;br/&gt;我是线程:3:第3个任务完成！我是线程:3:&lt;br/&gt;我是线程:4:第4个任务完成！我是线程:4:&lt;br/&gt;我是线程:5:第5个任务完成！我是线程:5:&lt;br/&gt;我是线程:1:完成:1537617977385&lt;br/&gt;我是线程:3:完成:1537617977385&lt;br/&gt;我是线程:4:完成:1537617977385&lt;br/&gt;我是线程:0:完成:1537617977385&lt;br/&gt;我是线程:2:完成:1537617977385&lt;br/&gt;我是线程:5:完成:1537617977387&lt;br/&gt;&lt;strong&gt;所有任务完成!1537617977388&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;顺序有可能发生变化.但是  &lt;strong&gt;所有任务完成!1537617977388 时间肯定在他们之后,速度快最多一样.肯定不会比他们小&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有个例子 线程数 大于 锁住数时 会发生什么呢. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_1c8d30cd-f88a-4116-a85c-a07162eff778&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1c8d30cd-f88a-4116-a85c-a07162eff778&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1c8d30cd-f88a-4116-a85c-a07162eff778&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountDownLatchDemo {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THREAD_COUNT_NUM = 8&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountDownLatch(THREAD_COUNT_NUM);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;第&quot; + index + &quot;个任务完成！&quot;
                            +&lt;span&gt; Thread.currentThread().getName());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟收集第i个龙珠,随机模拟不同的寻找时间&lt;/span&gt;
                    Thread.sleep(3000&lt;span&gt;);
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;完成:&quot; +&lt;span&gt; System.currentTimeMillis());
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每收集到一颗龙珠,需要等待的颗数减1&lt;/span&gt;
&lt;span&gt;                 countDownLatch.countDown();

            }, &lt;/span&gt;&quot;我是线程:&quot; + i + &quot;:&quot;&lt;span&gt;).start();
            ;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待检查，即上述7个线程执行完毕之后，执行await后边的代码&lt;/span&gt;
&lt;span&gt;         countDownLatch.await();
        System.out.println(&lt;/span&gt;&quot;所有任务完成!&quot; +&lt;span&gt; System.currentTimeMillis());

    }
}

结果
...............
所有任务完成&lt;/span&gt;!1537618986091&lt;span&gt;
............
我是线程:&lt;/span&gt;39:完成:1537618986097&lt;span&gt;
我是线程:&lt;/span&gt;37:完成:1537618986097&lt;span&gt;
我是线程:&lt;/span&gt;38:完成:1537618986097&lt;span&gt;
我是线程:&lt;/span&gt;35:完成:1537618986096
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;所以更加证明了.&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;CountDownLatch(THREAD_COUNT_NUM); 最多锁住 THREAD_COUNT_NUM 个的线程,其他的线程就按原来的顺序运行了&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;这个就直接证明了  在await()处,让所有的任务完成了 才能继续主线程&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;CountDownLatch的优点毋庸置疑，对使用者而言，你只需要传入一个int型变量控制任务数量即可，至于同步队列的出队入队维护，state变量值的维护对使用者都是透明的，使用方便。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;CountDownLatch设置了state后就不能更改，也不能循环使用。&lt;/p&gt;

&lt;h3&gt;2.CyclicBarrier &lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180423234242640?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plc29uam9rZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;393&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然说了 CountDownLatch设置了state后就不能更改，也不能循环使用。那就来个可以循环使用的&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;举个例子:有四个游戏玩家玩游戏，游戏有三个关卡，每个关卡必须要所有玩家都到达后才能允许通过。其实这个场景里的玩家中如果有玩家A先到了关卡1，他必须等到其他所有玩家都到达关卡1时才能通过，也就是说线程之间需要相互等待。这和CountDownLatch的应用场景有区别，CountDownLatch里的线程是到了运行的目标后继续干自己的其他事情，而这里的线程需要等待其他线程后才能继续完成下面的工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;案例一: 一起等待&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CyclicBarrierDemo {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CyclicBarrier barrier = &lt;span&gt;new&lt;/span&gt; CyclicBarrier(5&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
                    System.out.println(String.format(&lt;/span&gt;&quot;我是第%s启动了&quot;&lt;span&gt;, index));
                    barrier.await();
                    System.out.println(String.format(&lt;/span&gt;&quot;我是第%s完成了&quot;&lt;span&gt;, index));
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BrokenBarrierException e) {
                    e.printStackTrace();
                }

            }, &lt;/span&gt;&quot;我是第&quot; + index + &quot;个线程:&quot;&lt;span&gt;).start();
        }

    }
}

结果:
我是第6启动了
.......
我是第0启动了
.......
我是第4完成了了&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;全部启动,然后一起等待,再继续完成任务&lt;/p&gt;
&lt;p&gt;//案例二 最多等待时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    System.out.println(String.format(&lt;/span&gt;&quot;我是第%s启动了&quot;&lt;span&gt;, index));
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最多阻塞时间&lt;/span&gt;
                    barrier.await(2000&lt;span&gt;, TimeUnit.MILLISECONDS);
                    System.out.println(String.format(&lt;/span&gt;&quot;我是第%s完成了&quot;&lt;span&gt;, index));
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (InterruptedException | BrokenBarrierException |&lt;span&gt; TimeoutException e) {
                    e.printStackTrace();
                    barrier.reset();
                }

            }).start();
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// 还有一个额外的方法是  构造是可以多构造一个Runnable，在计数器的值到达设定值后（但在释放所有线程之前），该Runnable运行一次，注，Runnable在每个屏障点只运行一个 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CyclicBarrier barrier = &lt;span&gt;new&lt;/span&gt; CyclicBarrier(1,()-&amp;gt;&lt;span&gt;{
        System.out.println(&lt;/span&gt;&quot;优先执行我&quot;&lt;span&gt;);
    });

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 2; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
                    System.out.println(String.format(&lt;/span&gt;&quot;我是第%s启动了&quot;&lt;span&gt;, index));
                    barrier.await();
                    System.out.println(String.format(&lt;/span&gt;&quot;我是第%s完成了&quot;&lt;span&gt;, index));
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BrokenBarrierException e) {
                    e.printStackTrace();
                }

            }, &lt;/span&gt;&quot;我是第&quot; + index + &quot;个线程:&quot;&lt;span&gt;).start();
        }


结果是:
我是第1启动了
我是第0启动了
优先执行自己
优先执行自己
我是第1完成了
我是第0完成了&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;CyclicBarrier 和 CountDownLatch的比较:&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;CountDownLatch: 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。--&amp;gt; 反正 你执行完  就ok.不能随意放开&lt;/li&gt;
&lt;li&gt;CyclicBarrier: N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。--&amp;gt; 可以到到某个条件.我放开就行了&lt;/li&gt;
&lt;li&gt;CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。&lt;/li&gt;
&lt;li&gt;CountDownLatch：减计数方式，CyclicBarrier：加计数方式&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3. Semaphore&lt;/h3&gt;
&lt;p&gt;信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。&lt;/p&gt;
&lt;p&gt;比喻:&lt;/p&gt;
&lt;p&gt;　　Semaphore是一件可以容纳N人的房间，如果人不满就可以进去，如果人满了，就要等待有人出来。对于N=1的情况，称为binary semaphore。一般的用法是，用于限制对于某一资源的同时访问 &lt;/p&gt;
&lt;p&gt;官方一点就是:&lt;/p&gt;
&lt;p&gt;用于保证同一时间并发访问线程的数目。&lt;/p&gt;
&lt;p&gt;信号量在操作系统中是很重要的概念，Java并发库里的Semaphore就可以很轻松的完成类似操作系统信号量的控制。&lt;/p&gt;
&lt;p&gt;Semaphore可以很容易控制系统中某个资源被同时访问的线程个数。 在数据结构中我们学过链表，链表正常是可以保存无限个节点的，而Semaphore可以实现有限大小的列表。&lt;/p&gt;
&lt;p&gt;使用场景：仅能提供有限访问的资源。比如数据库连接&lt;/p&gt;
&lt;p&gt;上例子:&lt;/p&gt;
&lt;p&gt;// 方式 一 直接获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给出10个资源 ,最多保证10个并发&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Semaphore SEMAPHORE = &lt;span&gt;new&lt;/span&gt; Semaphore(10&lt;span&gt;);
....... 
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    SEMAPHORE.acquire();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取一个许可&lt;/span&gt;
                    System.out.println(String.format(&quot;我是线程:%s&quot;, index));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要并发控制的内容&lt;/span&gt;
                    Thread.sleep(3000&lt;span&gt;);
                    SEMAPHORE.release(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放一个许可&lt;/span&gt;
                } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }

            }).start();
        }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果:&lt;/span&gt;
很明显的能看到 10个10的执行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// 方式 二 尝试获取许可，获取不到不执行  很多时候相当于只执行设置的并发量一次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Semaphore SEMAPHORE = &lt;span&gt;new&lt;/span&gt; Semaphore(10&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试获取许可，获取不到不执行&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(SEMAPHORE.tryAcquire(&lt;span&gt;) {
                        System.out.println(String.format(&lt;/span&gt;&quot;我是线程:%s&quot;, index));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要并发控制的内容&lt;/span&gt;
                        Thread.sleep(3000&lt;span&gt;);
                        SEMAPHORE.release(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放一个许可&lt;/span&gt;
&lt;span&gt;                    }
                    
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }

            }).start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; // 当时三  有个最长申请时间 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Semaphore SEMAPHORE = &lt;span&gt;new&lt;/span&gt; Semaphore(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  尝试获取许可，获取不到不执行 最长申请时间&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(SEMAPHORE.tryAcquire(5000&lt;span&gt;,TimeUnit.MILLISECONDS)) {
                        System.out.println(String.format(&lt;/span&gt;&quot;我是线程:%s&quot;, index));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要并发控制的内容&lt;/span&gt;
                        Thread.sleep(3000&lt;span&gt;);
                        SEMAPHORE.release(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放一个许可&lt;/span&gt;
&lt;span&gt;                    }
                    
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }

            }).start();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;p&gt;1 . 其中  构造方法可以加公平锁   :private static final Semaphore SEMAPHORE = new Semaphore(100,true);&lt;/p&gt;
&lt;p&gt;2. SEMAPHORE.tryAcquire()  =&amp;gt; 可以增加获取条件量 SEMAPHORE.tryAcquire(10);释放 SEMAPHORE.release(10);&lt;/p&gt;

</description>
<pubDate>Sat, 22 Sep 2018 14:49:00 +0000</pubDate>
<dc:creator>爱呼吸的鱼</dc:creator>
<og:description>AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。它实现了一个FIFO(FirstIn、Fis</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aihuxi/p/9691467.html</dc:identifier>
</item>
<item>
<title>论文笔记：CNN经典结构2（WideResNet，FractalNet，DenseNet，ResNeXt，DPN，SENet） - PilgrimHui</title>
<link>http://www.cnblogs.com/liaohuiqiang/p/9691458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liaohuiqiang/p/9691458.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/liaohuiqiang/p/9606901.html&quot;&gt;论文笔记：CNN经典结构1&lt;/a&gt;中主要讲了2012-2015年的一些经典CNN结构，从AlexNet，ZFNet，OverFeat到VGG，GoogleNetv1-v4，ResNetv1-v2。&lt;br/&gt;本文主要讲解2016-2017年的一些经典CNN结构，WideResNet，FractalNet，DenseNet，ResNeXt，DPN，SENet。&lt;/p&gt;
&lt;h3 id=&quot;wideresnet-wrn&quot;&gt;WideResNet( WRN )&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;motivation&lt;/strong&gt;：ResNet的跳连接，导致了只有少量的残差块学到了有用信息，或者大部分残差块只能提供少量的信息。于是作者探索一种新的网络WideResNet（在ResNet的基础上减小深度，增加宽度）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;：在ResNetv2的基础上改进，增大每个残差块中的卷积核数量。如下&lt;strong&gt;两个图&lt;/strong&gt;所示。其中B(3,3)表示一个两个3x3卷积，k表示一个宽度因子，当k为1时卷积核个数和ResNetv2相等，k越大网络越宽。另外WRN在卷积层之间加入dropout（下一个卷积层之前的bn和relu之后），如下第一个图的图(d)所示（在ResNetv2中把dropout放在恒等映射中实验发现效果不好于是放弃了dropout）。用WRN-n-k来表示一个网络，n表示卷积层的总数，k表示宽度因子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练配置&lt;/strong&gt;：SGD，momentum为0.9，学习率为0.1，权重衰减为0.0005，batch size为128。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实验&lt;/strong&gt;：在CIFAR，SVHN，COCO数据集上取得了state-of-the-art的结果，同时在ImageNet上也表现优秀（比某些ResNet表现好，并没有超越ResNet的最优结果）。作者根据实验结果认为ResNet的主要能力来自于残差块，而深度的效果只是一个补充。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180922221030578-2069246983.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180922221043187-393783346.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;fractalnet&quot;&gt;FractalNet&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;motivation&lt;/strong&gt;：WideResNet通过加宽ResNet得到state-of-the-art的表现，推测ResNet的主要能力来自于残差块，深度不是必要的。相比之下，分形网络则是直接认为ResNet中的残差结构也不是必要的，网络的路径长度（有效的梯度传播路径）才是训练深度网络的基本组建。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;：如&lt;strong&gt;下图&lt;/strong&gt;所示，分形网络是通过不同长度的子路经组合，让网络自身选择合适的子路经集合，另外分形网络还提出了drop paht的方法。其中local drop就是join模块以一定概率drop每个输入，但至少留下一个。global drop就是对整个网络只留下一列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实验&lt;/strong&gt;：在CIFAR和SVHN数据集上分形网络取得了优秀的结果（CIFAR上可以超越残差网络的表现，但是比WRN的表现差）。在ImageNet上可以达到和ResNet差不多的结果（好那么一丢丢，但是只对比了一种ResNet结构）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更多细节&lt;/strong&gt;：具体内容我在另一篇&lt;a href=&quot;https://www.cnblogs.com/liaohuiqiang/p/9218445.html&quot;&gt;论文笔记：分形网络&lt;/a&gt;中有所提及。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160281/201806/1160281-20180623192357262-1280399535.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;densenet&quot;&gt;DenseNet&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;motivation之stochastic depth&lt;/strong&gt;：这是作者黄高之前的一篇论文，因为ResNet中大部分残差块只提供少量信息，所以在ResNet基础上随机丢弃一些层，发现可以提高ResNet的泛化能力。随机丢弃一些层网络依然奏效，带来了两点启发，一是网络中的某一层可以不仅仅依赖于前层特征而依赖于更前层的特征。二是ResNet具有比较明显的冗余，网络的每一层只提取了很少的有用特征。基于以上两点DenseNet提出让网络的每一层和前面的所有层相连，同时把每一层设计地特别窄，学习很少的特征图以此降低冗余性。听起来密集连接似乎会大大增加参数量，但实际上不是，因为网络变窄了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;motivation之设计捷径&lt;/strong&gt;：深层网络中，输入的信息或者梯度通过很多层之后会逐渐丢失，之前的ResNet和FractalNet的一个共同特征在于，创建一个前层和后层捷径。沿着这个思路DenseNet让网络的所有层之间做一个全连接，保证所有层之间都两两连接，这么做可以加强feature的传递，更有效地利用feature（每一层可以依赖更前层的特征，每一层的特征都直接连接到输出层），减小梯度消失的问题。另外为了保留信息在连接多个输入时并没有像ResNet一样使用addition，而是使用concat。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DenseNet结构&lt;/strong&gt;：每一层都和所有前层相连接，第一层连输入层有1个前连接，第二层就有2个前连接，那么对于L层就有1+2+...+L也就是L(1+L)/2个连接。因为feature map大小不同的时候concat并不可行，DenseNet把网络分成了几个Dense块，中间用transition layer（用来改变feature map大小）连接起来。如下&lt;strong&gt;第一个图&lt;/strong&gt;所示。Dense块中为多个“BN-ReLU-Conv3x3&quot;（这一连串操作称为一个&lt;span class=&quot;math inline&quot;&gt;\(H_l\)&lt;/span&gt;的单元操作）。DenseNet的具体结构见论文阐述。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DenseNet-BC结构&lt;/strong&gt;：其中B表示bottleneck结构，把3x3替换成(1x1, 3x3)，&lt;span class=&quot;math inline&quot;&gt;\(H_l\)&lt;/span&gt;单元操作为“BN-ReLU-Conv1x1-Conv3x3&quot;。C表示压缩，在transition层设一个参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;来减小feature map个数（通道数），论文中取值为0.5，每次transition时通道数减半。结构如下&lt;strong&gt;第二个图&lt;/strong&gt;所示，其中k表示Dense块中&lt;span class=&quot;math inline&quot;&gt;\(H_l\)&lt;/span&gt;产生的feature map个数，k越小，Dense块越窄，由于k越大会导致后层concat后通道越大，论文中也称之为growth rate。进入Dense块之前使用了2k个7x7卷积。实验中1x1的卷积产生4k个feature map。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实验&lt;/strong&gt;：在CIFAR和SVHN上超越了前人的表现（超越WRN和FractalNet），在ImageNet上和ResNet达到差不多的表现但参数量不到一半，计算量为ResNet的一半。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练配置&lt;/strong&gt;：SGD，权重衰减为0.0001，momentum为0.9。CIFAT和SVHN的batch size为64，学习率为0.1，50%和75%的epoch时除以10。在CIFAR上300个epoch，在SVHN上40个epoch。ImageNet上epoch为90，batch size为256，学习率为0.1，在30轮和60轮降为原来的1/10。原生的DenseNet实现对内存的利用效率不高（大量的concat会给显存带来高负荷），作者另外写了一个技术报告来介绍如何提升DenseNet的内存使用效率，同时提供torch，pytorch，mxnet以及caffe的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络表现比较&lt;/strong&gt;：根据几篇论文的最优结果（忽略参数量不相同等因素），大体上看，CIFAR和SVHN上DenseNet优于WRN优于FractalNet。ImageNet上WRN优于DenseNet优于FractalNet。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mark&lt;/strong&gt;：黄高还提出了一个多尺度DenseNet，主要思想是用浅层特征来预测简单图片，深层特征来预测较难的图片，Multi-Scale Dense Convolutional Networks for Efficient Prediction这篇论文在这里做个标记，有空的话好好拜读一下。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180922221115854-1706924671.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180922221127392-248184445.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;resnext2016年imagenet分类任务的亚军&quot;&gt;ResNeXt（2016年ImageNet分类任务的亚军）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;motivation&lt;/strong&gt;：视觉识别的研究已经从“人工设计的特征工程”转移到“网络结构设计的网络工程”上。于是作者同时借鉴了VGG和ResNet的“堆叠相同shape子结构”思想和Inception的&quot;split-transform-merge&quot;思想，提出了ResNeXt的结构，把ResNet中残差块的结构改成如下&lt;strong&gt;第一个图&lt;/strong&gt;的图右那种结构，类似Inception块，但是里面的每个小块又是相同的结构，而且最后是addition而不是concat，通过堆叠这样的ResNeXt块来构建ResNeXt网络。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;：如下&lt;strong&gt;第二个图&lt;/strong&gt;所示，三个子图的结构是等价的，最后一个子图用了组卷积技术使得结构更加紧凑简洁，模型实现使用的是最后一个子图的结构。BN-Relu的使用遵循的是原始的ResNetv1，在每个卷积后加BN-Relu，到block的输出时（最后一个BN-Relu）把relu放在addition的后面。shortcut都用恒等映射，除了要用映射（projection）增维的时候。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ImageNet预处理和预测&lt;/strong&gt;：预处理遵循VGG的做法来裁剪图像，所有消融学习中使用single-crop-224进行预测。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ImageNet训练配置&lt;/strong&gt;：SGD，batch size为256，权重衰减为0.0001，momentum为0.9，学习率为0.1，遵循ResNet的实现做三次除以10的衰减，何凯明初始化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实验&lt;/strong&gt;：实验表示，保持同样的复杂度，增加“cardinality”（这个词下图中有解释，相同于一个ResNeXt块的分支数）可以提高准确率，另外，增加模型容量时，增加“cardinality”比增加深度或宽度更加有效。101-layer ResNeXt准确率比ResNet-200更高，同时花费一半的复杂度（Flops）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络表现比较&lt;/strong&gt;：根据几篇论文的最优结果（忽略参数量不相同等因素），大体上看，CIFAR上DenseNet优于ResNeXt优于WRN优于FractalNet。ImageNet上ResNeXt优于WRN优于DenseNet优于FractalNet。考虑到参数，网络的不同模型结构（比如DenseNet和DenseNet-BC）等因素，这个比较不是确切的，比如ResNeXt在CIFAR上是优于某些DenseNet只是差于某一个DenseNet-BC，具体数据回论文看。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180922221204023-228574431.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180922221220840-813637954.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dpn2017年imagenet定位任务的冠军&quot;&gt;DPN（2017年ImageNet定位任务的冠军）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;motivation&lt;/strong&gt;：结合ResNet的优点（重用特征）和DenseNet的优点（在重用特征上存在冗余，但是利于探索新特征），提出一种新的网络结构，称为对偶路径网络（Dual Path Network）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;：如&lt;strong&gt;下图所示&lt;/strong&gt;，d和e等价，网络分为residual path和densely connected path在卷积块最后的1x1将输出切为两路，一路连到residual path上加起来，一路练到densely connected path上concat起来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实验&lt;/strong&gt;：ImageNet（分类）上表现超过ResNeXt，而且模型更小，计算复杂度更低。另外在VOC 2007的目标检测结果和VOC 2012的语义分割结果也超越了DenseNet，ResNet和ResNeXt。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180922221228184-21193514.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;senet2017年imagenet分类任务的冠军&quot;&gt;SENet（2017年ImageNet分类任务的冠军）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;motivation&lt;/strong&gt;：已经很多工作在空间维度上提升网络性能，比如Inception嵌入多尺度信息，聚合多种不同感受野上的特征来获得性能增益。那么网络是否可以从其它层面去提升性能，比如考虑特征通道之间的关系，基于这一点作者提出了SENet（Squeeze-and-Excitation Network），通过学习的方式获取每个通道的重要程度，从而进行特征重标定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络结构&lt;/strong&gt;：如下&lt;strong&gt;第一个图&lt;/strong&gt;所示，&lt;span class=&quot;math inline&quot;&gt;\(F_{tr}\)&lt;/span&gt;表示transformation（比如一系列的卷积操作），&lt;span class=&quot;math inline&quot;&gt;\(F_{sq}\)&lt;/span&gt;表示squeeze操作，产生一个通道描述符，表征特征通道上响应的全局分布。&lt;span class=&quot;math inline&quot;&gt;\(F_{ex}\)&lt;/span&gt;表示excitation操作，通过参数w来为每个特征通道生成权重，建模特征通道间的重要性。&lt;span class=&quot;math inline&quot;&gt;\(F_{scale}\)&lt;/span&gt;表示一个reweight操作，将excitation输出的权重（特征通道的重要性）逐个乘到先前的特征，完成特征重标定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SE-ResNet模块&lt;/strong&gt;：如下&lt;strong&gt;第二个图&lt;/strong&gt;是SE嵌入到ResNet中的一个例子，这里使用全局均值池化作为squeeze操作，使用两个FC组成的bottleneck结构作为excitation操作。SE可以嵌入到任意网络中得到不同种类的SENet，比如SE-ReNeXt，SE-BN-Inception，SE-Inception-ResNet-v2等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练配置&lt;/strong&gt;：跟随VGG的标准设定进行数据增强。输入图像使用通道均值相减。使用了数据平衡策略用于mini-batch采样（这个策略引用于另一篇论文Relay bp for effective learning of deep cnn）。SGD，momentum为0.9，mini-batch为1024，学习率0.6，每30轮除以10，训练100轮，何凯明初始化。预测时使用center crop。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实验&lt;/strong&gt;：ImageNet分类中，在ResNet，ResNeXt，VGG，BN-Inception，Inception-ResNet-v2，mobileNet，shuffleNet上都做了实验，发现加入SE后表现提升。此外还在场景分类和目标检测中做了实验，加入SE后表现提升。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180922221235464-1263776172.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160281/201809/1160281-20180922221240595-677621100.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Sep 2018 14:16:00 +0000</pubDate>
<dc:creator>PilgrimHui</dc:creator>
<og:description>介绍在ResNet之后（2016-2017年）出现的几个经典CNN网络WideResNet，FractalNet，DenseNet，ResNeXt，DPN，SENet</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liaohuiqiang/p/9691458.html</dc:identifier>
</item>
<item>
<title>Linux编程 16 文件权限(组管理  groupadd, groupmod,文件权限介绍) - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/9691398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/9691398.html</guid>
<description>&lt;h4&gt;&lt;strong&gt;一.用户组&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　前面章节知道用户账户在控制单个用户安全性方面很好，但涉及到共享资源或把用户类型分组时，组概念就出来了。 组权限允许多个用户对系统中的对象(比如文件，目录，设备等)共享一组共用的权限。 在centos中创建一个用户会为该用户单独创建一个组，这样可以更安全一些。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.1   /etc/group 文件&lt;/strong&gt;&lt;br/&gt;　　　　与用户一样，组信息也保存在系统的一个文件中。/etc/group文件包含系统上用到的每个组的信息。如下图所示：&lt;br/&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180922215356576-1653055298.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　　　GID在500以内属于系统账户,而用户组的GID则从500开始分配（好像不同发布版有所不同）。上面有三个字段：组名，组密码，GID。组密码是允许非组内成员通过组密码临时成为该组成员，但这功能并不常用。创建组时不能直接通过/etc/group文件来添加用户到一个组，要用usermod命令，上篇有讲到该命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.2   创建新组 groupadd&lt;br/&gt;　　　　&lt;/strong&gt;下面使用groupadd 命令在系统上创建新组（gtest），如下图所示：&lt;br/&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180922215453420-1657601799.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　　　在创建新组后，默认没有用户被分配到该组下，使用usermod或useradd都可以将用户分配到指定组：例如之前安装mysql时，使用useradd来创建mysql用户，并指定到mysql组中.如下图所示：&lt;br/&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180922215510244-1325550060.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　　　下面使用useradd来创建用户gtest1和gtest2，指定到gtest组8001中,如下图所示：&lt;br/&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180922215530646-284205316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.3   修改组&lt;br/&gt;　　　　&lt;/strong&gt;修改组使用groupmod命令可以修改已有组的GID(-g选项)或组名(-n选项)。当修改组名时，gid和组成员不变，只有组名改变，由于所有安全权限都是基于GID的，所以随变修改组名不会影响文件的安全性。下面使用groupmod –n来修改gtest组名为gtest1。&lt;br/&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180922215629738-108786247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;二.文件权限&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在了解用户和组之后，下面来解读文件权限，通过ls 命令输出来介绍分析。下面随意定位在个目录下。&lt;br/&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201809/151560-20180922215716783-356076640.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;上面结果第一列,就是描述文件和目录权限的编码。第一列的第一个字符分别代表了对象的类型：&lt;br/&gt;(1)     – 代表文件&lt;/p&gt;
&lt;p&gt;(2)     d 代表目录&lt;/p&gt;
&lt;p&gt;(3)     l  代表链接&lt;/p&gt;
&lt;p&gt;(4)     c 代表字符型设备&lt;/p&gt;
&lt;p&gt;(5)     b 代表块设备&lt;/p&gt;
&lt;p&gt;(6)     n 代表网络设备&lt;/p&gt;
&lt;p&gt;　　　　第一列之后有3组三字符的编码，每一组定义了3种访问权限,没有权限是单破折线：&lt;br/&gt;　　　　(1)     r 代表对象是可读的&lt;/p&gt;
&lt;p&gt;　　　　(2)     w 代表对象是可写的&lt;/p&gt;
&lt;p&gt;　　　　(3)     x 代表对象是可执行的&lt;/p&gt;
&lt;p&gt;　　　　上面3组权限分别对应对象的3个安全级别：对象的属主，对象属组，系统其它用户&lt;/p&gt;
&lt;p&gt;　　　　例如：&lt;span&gt;&lt;strong&gt;rwxr-xr-x&lt;/strong&gt;&lt;/span&gt; 这样一组。前三个字符(&lt;span&gt;&lt;strong&gt;rwx&lt;/strong&gt;&lt;/span&gt;)是对象的属主权限(用户hsr)，中间三个字符&lt;span&gt;(&lt;strong&gt;r-x&lt;/strong&gt;)&lt;/span&gt;是对象属组的权限(组hsr下的用户),后面三个字符(&lt;span&gt;&lt;strong&gt;r-x&lt;/strong&gt;&lt;/span&gt;)是系统其它用户权限。&lt;/p&gt;
&lt;p&gt;　　　　在上面这一组权限中，属组和其它用户对该文件没有写入权限，只有读和执行权限。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　　　　　&lt;/p&gt;
</description>
<pubDate>Sat, 22 Sep 2018 14:07:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.用户组 前面章节知道用户账户在控制单个用户安全性方面很好，但涉及到共享资源或把用户类型分组时，组概念就出来了。 组权限允许多个用户对系统中的对象(比如文件，目录，设备等)共享一组共用的权限。 在c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/9691398.html</dc:identifier>
</item>
<item>
<title>第一节 如何用Go实现单链表 - 懒人记</title>
<link>http://www.cnblogs.com/lanrenji/p/9691195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lanrenji/p/9691195.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、概念介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面这副图是我们单链表运煤车队。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265156/201809/1265156-20180922205620504-891260481.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每节运煤车就是单链表里的元素，每节车厢里的煤炭就是元素中保存的数据。前后车通过锁链相连，作为单链表运煤车，从1号车厢开始，每节车厢都知道后面拉着哪一节车厢，却不知道前面是哪节车厢拉的自己。第一节车厢没有任何车厢拉它，我们就叫它车头，第五节车厢后面拉其他车厢，我们称为车尾。&lt;/p&gt;
&lt;p&gt;作为单链表它最大的特点就是能随意增加车队的长度，也能随意减少车队的长度。这是比数组公交车最大的优点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、Go语言实现讲解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、节点&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265156/201809/1265156-20180922205648624-1335059589.png&quot;/&gt;&lt;br/&gt;每节车厢都由车体、绳索和煤炭构成。在Go语言中表示这种自定义组合体的类型就是结构，当然为了通用性，我们这里要把车厢转换成节点也就是元素，煤炭转换成数据，绳索转换成指针。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    type Node struct {
        data Object
        next *Node
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用张图来描述这种对应关系。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265156/201809/1265156-20180922205720047-1910433859.png&quot;/&gt;&lt;br/&gt;这里结构体Node表示车厢，data表示煤炭用Object类型，next是牵着下节车厢的绳索，用指针表示。&lt;/p&gt;
&lt;p&gt;对于车厢来说，除了放煤炭外，还能放瓜果、衣物、饭菜等等，所以这里data的类型必须通用，当然Go里是没有Java里的Object类型的，所以我们就自己定义了一个。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    type Object interface{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、链表&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265156/201809/1265156-20180922205748407-523766159.png&quot;/&gt;&lt;br/&gt;光有车厢还不够，我们还要描述车厢组成的车队。每个单链表车队都有车头、车尾和车厢数量，我们同样以结构来表现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    type List struct {
        size uint64 // 车辆数量
        head *Node  // 车头
        tail *Node  // 车尾
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步就是组装单链表车队，这就是初始化。不过开始的时候车队是个空壳，一个车厢没有。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    func (list *List) Init() {
        (*list).size = 0    // 此时链表是空的
        (*list).head = nil  // 没有车头
        (*list).tail = nil  // 没有车尾
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（2）添加元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前的单链表是空的，所以我们要向里面添加元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    func (list *List) Append(node *Node) {
        (*list).head = node // 这是单链表的第一个元素，也是链表的头部
        (*list).tail = node // 同时是单链表的尾部
        (*list).size = 1    // 单链表有了第一个元素
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在单链表有了第一个元素，我还想再添加一个元素，当然是添加到单链表尾部。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    func (list *List) Append(node *Node) {
        if (*list).size == 0 { // 无元素的时候添加
            (*list).head = node // 这是单链表的第一个元素，也是链表的头部 
            (*list).tail = node // 同时是单链表的尾部
            (*list).size = 1    // 单链表有了第一个元素
        } else { // 有元素了再添加
            oldTail := (*list).tail
            (*oldTail).next = node  // node放到尾部元素后面
            (*list).tail = node     // node成为新的尾部
            (*list).size++          // 元素数量增加
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析上面的代码存在3处疑点，元芳你怎么看？属下认为&lt;br/&gt;第一，node如果为空，则添加无任何意义；&lt;br/&gt;第二，代码中存在重复的地方；&lt;br/&gt;这第三么，卑职如何才能知道新增结果？&lt;br/&gt;下面大卫哥顺着元芳的思路改进下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    func (list *List) Append(node *Node) bool {
        if node == nil {
            return false
        }
        
        (*node).next = nil
        // 将新元素放入单链表中
        if (*list).size == 0 { 
            (*list).head = node  
        } else { 
            oldTail := (*list).tail
            (*oldTail).next = node  
        }
    
        // 调整尾部位置，及链表元素数量
        (*list).tail = node // node成为新的尾部  
        (*list).size++      // 元素数量增加
    
        return true
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（3）插入元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一天领导让大卫哥把他小舅子安排到第一个，于是大卫哥为了拍好领导马屁。绞尽脑汁弄了一个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   func (list *List) Insert(node *Node) bool {
      if node == nil {
          return false
      }
 
      (*node).next = (*list).head   // 领导小舅子排到之前第一名前面
      (*list).head = node           // 领导小舅子成为第一名
      (*list).size++
      return true
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来托关系插队的人越来越多，领导的关系户不能动，只能插后面人的队了。于是大卫哥又修改了代码，增加了位置参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    func (list *List) Insert(i uint,node *Node) bool {
        // 空的节点、索引超出范围和空链表都无法做插入操作
        if node == nil || i &amp;gt; (*list).size || (*list).size == 0 {
            return false
        }
    
        if i == 0 { // 直接排第一，也就领导小舅子才可以
            (*node).next = (*list).head
            (*list).head = node
        } else {
            // 找到前一个元素
            preItem := (*list).head
            for j := 1 ; j &amp;lt; i; j++ { // 数前面i个元素
                preItem = (*preItem).next
            }
            // 原来元素放到新元素后面,新元素放到前一个元素后面
            (*node).next = (*preItem).next
            (*preItem).next = preItem
        }
    
            (*list).size++ 
    
            return true
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（4）删除元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插队的关系户太多，影响了正常排队的人，被人投诉，大卫哥只好想办法删除一些。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    func (list *List) Remove(i uint, node *Node) bool {
        if i &amp;gt;= (*list).size {
            return false
        }
        
        if i == 0 { // 删除头部
            node = (*list).head
            (*list).head = (*node).next
            if (*list).size == 1 { // 如果只有一个元素，那尾部也要调整
                (*list).tail = nil
            }
        } else {
            preItem := (*list).head
            for j := 1; j &amp;lt; i; j++ {
                preItem = (*preItem).next
            }
        
            node = (*preItem).next
            (*preItem).next = (*node).next
    
            if i == ((*list).size - 1) { // 若删除的尾部，尾部指针需要调整
                (*list).tail = preItem
            }
        }
        (*list).size--
        return true
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（5）获取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了获取某个位置的元素，我们需要一个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    func (list *List) Get(i uint) *Node {
        if i &amp;gt;= (*list).size {
            return nil
        }
    
        item := (*list).head
        for j := 0; j &amp;lt; i ; j++ {    // 从head数i个
            item = (*item).next
        }
    
        return item
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里基本框架已经出来了，不过还有几个接口还没实现，作为课后作业。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单链表就和列车类似，一个接着一个，所以本节从列车类比介绍了单链表的Go语言实现。在接口实现部分大卫哥以序号作为链表中每个节点的操作关键字。在实际应用中，我们往往以data中的某一个字段作为操作关键字。所以这也衍生出链表的不同接口，大家可以参考大卫哥留的链接中的代码实现作为理解。同时有些实现将表头独立出来并不存放数据，这在一定程度上简化了代码的实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rhan-zz/dataStructuresInGo&quot;&gt;代码下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、习题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）补全GetSize,RemoveAll,GetHead和GetTail的定义和实现。&lt;br/&gt;（2）以data作为参数，考虑单链表的实现。&lt;br/&gt;（3）将单链表的head独立出来，此时的head是独立的，不存放data，如下图，考虑单链表的实现，并比较这种实现。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265156/201809/1265156-20180922205952149-103972373.png&quot;/&gt;&lt;br/&gt;（4）如果将head和tail都独立出来，都不存放data，此时的单链表如何实现？这样实现的代码在插入删除操作时候是不是更容易点？&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265156/201809/1265156-20180922210020275-936962518.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Sep 2018 13:02:00 +0000</pubDate>
<dc:creator>懒人记</dc:creator>
<og:description>一、概念介绍 下面这副图是我们单链表运煤车队。 每节运煤车就是单链表里的元素，每节车厢里的煤炭就是元素中保存的数据。前后车通过锁链相连，作为单链表运煤车，从1号车厢开始，每节车厢都知道后面拉着哪一节车</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lanrenji/p/9691195.html</dc:identifier>
</item>
<item>
<title>Steeltoe之Service Discovery篇 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9691058.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9691058.html</guid>
<description>&lt;p&gt;在前文&lt;a href=&quot;https://www.cnblogs.com/kenwoo/p/9689019.html&quot;&gt;一窥Spring Cloud Eureka&lt;/a&gt;中，已经构建了基于Eureka的服务端与客户端，可用于实现服务注册与发现功能。而借助Steeltoe的类库，可以在.NET生态系统中使用Spring Cloud的现有模块。&lt;/p&gt;

&lt;p&gt;对于ASP.NET Core，使用&lt;code&gt;Steeltoe.Discovery.ClientCore&lt;/code&gt;类库。&lt;/p&gt;
&lt;p&gt;对于Console/ASP.NET 4.x，使用&lt;code&gt;Steeltoe.Discovery.EurekaBase&lt;/code&gt;类库。&lt;/p&gt;

&lt;p&gt;先建立一个ASP.NET Core项目，其可以找到已在Eureka的服务端注册的服务，并利用这些服务完成所需功能。&lt;/p&gt;
&lt;h2 id=&quot;appsettings.json&quot;&gt;appsettings.json&lt;/h2&gt;
&lt;p&gt;首先设置Eureka服务端地址，并确定当前应用程序能够发现服务但本身不会被注册为服务。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;eureka&quot;: {
    &quot;client&quot;: {
      &quot;serviceUrl&quot;: &quot;http://localhost:8765/eureka/&quot;,
      &quot;shouldFetchRegistry&quot;: true,
      &quot;shouldRegisterWithEureka&quot;: false
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;startup.cs&quot;&gt;Startup.cs&lt;/h2&gt;
&lt;p&gt;加入DiscoveryClient服务并使用它。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public Startup(IConfiguration configuration)
{
    Configuration = configuration;
}

public IConfiguration Configuration { get; }

public void ConfigureServices(IServiceCollection services)
{
    services.AddDiscoveryClient(Configuration);

    services.AddMvc();
}

public void Configure(IApplicationBuilder app, ...)
{
    app.UseMvc();

    app.UseDiscoveryClient();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;controller&quot;&gt;Controller&lt;/h2&gt;
&lt;p&gt;从已注册的Eureka客户端，即之前建立的Spring Cloud服务中获取数据。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class HomeController : Controller
{
    DiscoveryHttpClientHandler _handler;

    public HomeController(IDiscoveryClient client)
    {
        _handler = new DiscoveryHttpClientHandler(client);
    }
    public IActionResult Index()
    {
        var client = new HttpClient(_handler, false);
        var result = client.GetStringAsync(&quot;http://SPRINGCLOUD-EUREKA-CLIENT/hello&quot;).Result;

        ViewData[&quot;message&quot;] = result;
        return View();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该服务的地址是它用于注册的application name。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201809/991496-20180922201354487-1316665830.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动ASP.NET Core应用程序，可以看到页面显示了来自Spring Cloud服务的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201809/991496-20180922201722723-1558770135.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再建立一个ASP.NET Core API项目，并将其注册到Eureka的服务端。&lt;/p&gt;
&lt;h2 id=&quot;appsettings.json-1&quot;&gt;appsettings.json&lt;/h2&gt;
&lt;p&gt;该应用程序不需要发现服务，但需要在Eureka服务端上注册服务。这里可以看到比上一项目更多的配置，因为它需要提供应用名称，端口号及主机名称。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;eureka&quot;: {
    &quot;client&quot;: {
      &quot;serviceUrl&quot;: &quot;http://localhost:8765/eureka/&quot;,
      &quot;shouldFetchRegistry&quot;: false,
      &quot;shouldRegisterWithEureka&quot;: true
    },
    &quot;instance&quot;: {
      &quot;appName&quot;: &quot;NET-API&quot;,
      &quot;port&quot;: 5000,
      &quot;hostName&quot;: &quot;localhost&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;startup.cs-1&quot;&gt;Startup.cs&lt;/h2&gt;
&lt;p&gt;与上一项目同样的配置。&lt;/p&gt;
&lt;h2 id=&quot;controller-1&quot;&gt;Controller&lt;/h2&gt;
&lt;p&gt;建立一个简单的API方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ValuesController : ControllerBase
{
    // GET api/values
    [HttpGet]
    public ActionResult&amp;lt;string&amp;gt; Get()
    {
        return &quot;Hello World NET-API!&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动服务&quot;&gt;启动服务&lt;/h2&gt;
&lt;p&gt;可以在Eureka服务端中看到新注册的服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201809/991496-20180922202554799-1301665.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;调用服务&quot;&gt;调用服务&lt;/h2&gt;
&lt;p&gt;将上一个项目中所调用API的地址改成新服务的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IActionResult Index()
{
    var client = new HttpClient(_handler, false);
    var result = client.GetStringAsync(&quot;http://NET-API/api/values&quot;).Result;

    ViewData[&quot;message&quot;] = result;
    return View();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动后，可以看到所显示的值已发生变化，因为其是从新的服务中取得的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201809/991496-20180922203121693-2057689368.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Sep 2018 12:36:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>在前文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9691058.html</dc:identifier>
</item>
</channel>
</rss>