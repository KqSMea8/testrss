<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>phpstorm —— Xdebug 的配置和使用 - 蜗牛的古董</title>
<link>http://www.cnblogs.com/lightsrs/p/9612409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lightsrs/p/9612409.html</guid>
<description>&lt;p&gt;给phpstorm 配置Xdebug（Xdebug 是 PHP 的一个扩展, 用于帮助调试和开发。它包含一个与 ide 一起使用的单步调试器。它升级了 PHP 的 var_dump () 功能）&lt;/p&gt;
&lt;p&gt;这篇文章主要介绍和记录了window中Xdebug的安装配置和在phpStorm的配置调试和使用。&lt;/p&gt;
&lt;hr/&gt;
&lt;ol&gt;&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　打开&lt;a href=&quot;http://www.xdebug.org/download.php&quot; target=&quot;_blank&quot;&gt;http://www.xdebug.org/download.php&lt;/a&gt;下载相应的版本&lt;/p&gt;
&lt;p&gt;　　但得注意须下载跟机器上安装的php匹配的版本才行。所以可以将phpinfo网页的信息拷贝到&lt;a href=&quot;http://www.xdebug.org/find-binary.php&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://www.xdebug.org/find-binary.php&lt;/a&gt;，然后按照指导安装。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909013236257-1204361702.png&quot; alt=&quot;&quot; width=&quot;687&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909015844571-1031213858.png&quot; alt=&quot;&quot; width=&quot;875&quot; height=&quot;594&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击下载dll文件，然后复制到php的拓展目录下，如我的是：D:\phpserver\php-7.0.27-nts-x64\ext&lt;/p&gt;
&lt;p&gt;　　2.配置XDebug，打开php.ini，在末尾增加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Xdebug]  
;指定Xdebug扩展文件的绝对路径  
zend_extension&lt;/span&gt;= D:\phpserver\php-&lt;span&gt;7.0&lt;/span&gt;.&lt;span&gt;27&lt;/span&gt;-nts-x64\ext\php_xdebug-&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;7.0&lt;/span&gt;-vc14-nts-&lt;span&gt;x86_64.dll
;启用性能检测分析  
xdebug.profiler_enable&lt;/span&gt;=&lt;span&gt;On
;启用代码自动跟踪  
xdebug.auto_trace&lt;/span&gt;=&lt;span&gt;on
;允许收集传递给函数的参数变量  
xdebug.collect_params&lt;/span&gt;=&lt;span&gt;On
;允许收集函数调用的返回值  
xdebug.collect_return&lt;/span&gt;=&lt;span&gt;On
;指定堆栈跟踪文件的存放目录  
xdebug.trace_output_dir&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/phpserver/tmp/Xdebug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
;指定性能分析文件的存放目录  
xdebug.profiler_output_dir&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/phpserver/tmp/Xdebug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
xdebug.profiler_output_name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cachegrind.out.%p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
xdebug.remote_enable &lt;/span&gt;=&lt;span&gt; On
xdebug.remote_port&lt;/span&gt;=&lt;span&gt;19000&lt;/span&gt;&lt;span&gt;
xdebug.remote_handler &lt;/span&gt;=&lt;span&gt; dbgp
xdebug.remote_host &lt;/span&gt;= &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
xdebug.var_display_max_depth &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
xdebug.idekey&lt;/span&gt;= PHPSTROM
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：zend_extension修改为自己的拓展路径&lt;/p&gt;
&lt;p&gt;　　然后重启Apache。&lt;/p&gt;
&lt;p&gt;　　3. 在phpinfo页面中能够搜索到Xdebug模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909032725838-1286763638.png&quot; alt=&quot;&quot; width=&quot;899&quot; height=&quot;293&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　或者在cmd下输入php -m，能看到XDebug模块。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909032924258-123699148.png&quot; alt=&quot;&quot; width=&quot;498&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一点需要注意的是，系统的环境变量里设置的php版本。（比如配置了多个版本的PHP的时候）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;phpStorm的配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.【File】-&amp;gt;【Settings】-&amp;gt;【Languages &amp;amp; Frameworks】-&amp;gt;【PHP】的servers中配置xdebug服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909033621748-1651203268.png&quot; alt=&quot;&quot; width=&quot;821&quot; height=&quot;497&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.配置debug, debug port 为php.ini中配置的xdebug.remote_port。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909033837979-1818756781.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;386&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.打开【run】--【Edit configurations】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909034852434-269696884.png&quot; alt=&quot;&quot; width=&quot;438&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909035144492-1990320428.png&quot; alt=&quot;&quot; width=&quot;721&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909040328184-1689177101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后配置信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909040748645-1495716443.png&quot; alt=&quot;&quot; width=&quot;857&quot; height=&quot;535&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4. 设置断点，开启debug监听。点击绿色的甲壳虫开始调试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909042932938-1167636570.png&quot; alt=&quot;&quot; width=&quot;858&quot; height=&quot;340&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.运行或debug调试，即可看到调试数据在下方显示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1258197/201809/1258197-20180909042748655-1525819446.png&quot; alt=&quot;&quot; width=&quot;870&quot; height=&quot;441&quot;/&gt;&lt;/p&gt;


&lt;p&gt;6.引用&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/LWMLWM/p/8251905.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/LWMLWM/p/8251905.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mo-beifeng/articles/2446142.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/mo-beifeng/articles/2446142.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xujian2016/p/5548921.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/xujian2016/p/5548921.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;稍微总结前人经验，在此记录学习所得。&lt;/p&gt;

</description>
<pubDate>Sat, 08 Sep 2018 20:50:00 +0000</pubDate>
<dc:creator>蜗牛的古董</dc:creator>
<og:description>给phpstorm 配置Xdebug（Xdebug 是 PHP 的一个扩展, 用于帮助调试和开发。它包含一个与 ide 一起使用的单步调试器。它升级了 PHP 的 var_dump () 功能） 这篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lightsrs/p/9612409.html</dc:identifier>
</item>
<item>
<title>SSO 单点登录总结（PHP） - itabel</title>
<link>http://www.cnblogs.com/it-abel/p/9612143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/it-abel/p/9612143.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本篇文章根据个人理解的知识整理汇总，如有不足之处，请大家多多指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单点登录（SSO——Single Sign On）的应用是很普遍的，尤其在大型网站系统中，比如百度，登录百度账号和，再转到百度经验、百度贴吧等是不用重新登录的。本文将从 cookie 和 session 基础详细介绍单点登录的原理，代码实现为 PHP。&lt;/p&gt;
&lt;h2 id=&quot;cookie&quot;&gt;Cookie&lt;/h2&gt;
&lt;p&gt;Cookie 是由客户端访问服务器时服务器发送给客户端的特殊信息，且这些信息以文本文件的方式存储在客户端。第一次访问服务器时，服务器会在 HTTP 响应头（Response Header）返回 Cookie 信息。客户端保存 Cookie 信息之后，下次访问服务器时，HTTP请求头（Request Header）会包含 Cookie 信息。&lt;/p&gt;
&lt;p&gt;简单的说： 服务器不认识访问它的客户端，为了识别它们，就给每个访问它的客户端一个口令，服务器通过口令识别这些客户端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 不是访问每个服务器都会返回 Cookie 的，只有服务器中有设置 Cookie ，才会返回给客户端。&lt;/p&gt;
&lt;h3 id=&quot;cookie-生成和传递流程&quot;&gt;Cookie 生成和传递流程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在本地服务器下的 test.php 中设置 Cookie&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
// Cookie 是 HTTP 标头的一部分，因此 setcookie() 函数必须在其它信息被输出到浏览器前调用，这和对 header() 函数的限制类似
setcookie('testCookie', 'this is test cookie');&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过浏览器访问本地服务器 localhost/test.php，报文如下：&lt;br/&gt;&lt;img src=&quot;http://www.itlyb.com/uploads/markdown/20180908-113529-828.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;删除本地服务器下 test.php 中的 setcookie，再次访问 localhost/test.php，报文如下：&lt;br/&gt;&lt;img src=&quot;http://www.itlyb.com/uploads/markdown/20180908-114056-325.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;cookie-流程图&quot;&gt;Cookie 流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itlyb.com/uploads/markdown/20180908-162604-505.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;简单登录示例&quot;&gt;简单登录示例：&lt;/h3&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
# 登录
setcookie('userName', 'test');

# 判断是否已登录
if (isset($_COOKIE['userName'])) {
    echo '已登录';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关于 Cookie 的具体用法暂时不多说明，本篇文章主要讲解机制原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;session&quot;&gt;Session&lt;/h2&gt;
&lt;p&gt;Session 是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。在客户端访问服务器时，服务器会创建 Session 并生成一个 Session id 发到客户端，客户端下次访问时需要带着 Session id，服务器则根据 Session id 找到相应的 Session。&lt;/p&gt;
&lt;h3 id=&quot;session-生成和传递流程&quot;&gt;Session 生成和传递流程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;服务器设置 Session：localhost/session.php&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
session_start();
$_SESSION['testSession'] = 'This is test';&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cookie-和-session-的关系图接上节中的设置&quot;&gt;Cookie 和 Session 的关系图（接上节中的设置）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itlyb.com/uploads/markdown/20180908-175333-654.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;单点登录&quot;&gt;单点登录&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在介绍单点登录的方式之前先介绍一下 PHP 中的 Cookie 中的设置，方便容易理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;bool setcookie ( string $name [, string $value = &quot;&quot; [, int $expire = 0 [, string $path = &quot;&quot; [, string $domain = &quot;&quot; [, bool $secure = false [, bool $httponly = false ]]]]]] )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name: Cookie 名称。&lt;/li&gt;
&lt;li&gt;value: Cookie 值。&lt;/li&gt;
&lt;li&gt;expire: Cookie 的过期时间。&lt;/li&gt;
&lt;li&gt;path: Cookie 有效的服务器路径。 设置成 '/' 时，Cookie 对整个域名 domain 有效。 如果设置成 '/foo/'， Cookie 仅仅对 domain 中 /foo/ 目录及其子目录有效（比如 /foo/bar/）。 默认值是设置 Cookie 时的当前目录。&lt;/li&gt;
&lt;li&gt;domain: Cookie 的有效域名/子域名。 设置成子域名（例如 'www.example.com'），会使 Cookie 对这个子域名和它的三级域名有效（例如 w2.www.example.com）。 要让 Cookie 对整个域名有效（包括它的全部子域名），只要设置成域名就可以了（这个例子里是 'example.com'）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由上节我们知道，Session 是存放在服务器中的，客户端与服务器的通信会话是通过 Session id 识别的， 客户端 Session id 是存放在 cookie 中，因此单点登录大致分为：同域名不同站点登录、同域不同子域登录、不同域名登录。&lt;/p&gt;
&lt;h3 id=&quot;同域名不同站点登录&quot;&gt;同域名不同站点登录&lt;/h3&gt;
&lt;p&gt;由 PHP 中的 Cookie 设置说明可以看出，默认下不同站点是共享 Cookie 的除非设置了不同的有效服务器路径。如果设置了不同的有效的服务器路径怎么实现共享登录呢？哈哈哈，那就将有效服务器路径设置为默认 '/' 的就好了。&lt;/p&gt;
&lt;h3 id=&quot;同域不同子域登录&quot;&gt;同域不同子域登录&lt;/h3&gt;
&lt;p&gt;同样，由 PHP 中的 Cookie 设置说明可以看出，只要设置 Cookie 的 domain(Cookie 的有效域名/子域名) 参数就可以了，如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于 PHP 中生成 Session 会自动配置 Cookie，因此我们可以直接在 Session 中设置 Cookie 有效域&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;one.sso.test/create_session&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
session_set_cookie_params(time()+3600, '/', 'sso.test');
session_start();
$_SESSION['test'] = 'This is test';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;two.sso.test/get_session&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
session_set_cookie_params(time()+3600, '/', 'sso.test');
session_start();
echo $_SESSION['test'];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中后者是可以获取到 Session 值的。下边两图分别问以上两个子域名的报文和 Cookie 信息&lt;br/&gt;图一：&lt;br/&gt;&lt;img src=&quot;http://www.itlyb.com/uploads/markdown/20180909-001435-700.png&quot;/&gt;&lt;br/&gt;图二：&lt;br/&gt;&lt;img src=&quot;http://www.itlyb.com/uploads/markdown/20180909-001554-889.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由图可见他们的 Session id 是相同的，因此调用的是服务器上的同一个 Session。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在 PHP 中，配置 Session 的 Cookie 信息，还可以通过修改 php.ini 文件设置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;session.cookie_path = /
session.cookie_domain = '.sso.test'
session.cookie_lifetime = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;不同域名登录&quot;&gt;不同域名登录&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于涉及到用户信息安全问题，因此本文通过流程图大致说一下基本liu流程，具体操作看实际应用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itlyb.com/uploads/markdown/20180909-020425-260.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 上图中的“返回 Cookie 信息”并不是单独返回的，而是在“跳转页面”的 HTTP 响应头（Response Header）返回，同样异步请求的也是在 JS 调用 www.sso2.com 时在 HTTP 响应头Response Header 返回。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文到此结束，后续如果有新的理解会补充上去。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 08 Sep 2018 18:25:00 +0000</pubDate>
<dc:creator>itabel</dc:creator>
<og:description>本篇文章根据个人理解的知识整理汇总，包含 Cookie、Session 的基础知识和单点登录的方法，如有不足之处，请大家多多指正。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/it-abel/p/9612143.html</dc:identifier>
</item>
<item>
<title>[Linux] umask 从三类人群的权限中拿走权限数字 - 黑眼诗人</title>
<link>http://www.cnblogs.com/farwish/p/9611482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/farwish/p/9611482.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;&lt;span&gt;作用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;umask 用来设置用户创建文件、目录的默认权限，通过从权限中拿走相应的位，格式 `umask nnn`。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;理解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;rwx rwx rwx 权限对应三类人群，所属人，所属组，其它用户；每个人群的权限由 4+2+1 表示 读+写+执行。&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;文件创建时不能赋予执行权限 ( 所以每一类最多能被拿走的权限数字是6 )，只能用 chmod 给。&lt;/p&gt;

&lt;p&gt;目录允许设置执行权限 ( 所以最多拿走7 )。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;umask         # 查看当前 umask 值
umask &lt;/span&gt;&lt;span&gt;000&lt;/span&gt;     # 不拿走任何权限，创建的文件就是 &lt;span&gt;666&lt;/span&gt; ，目录即使 &lt;span&gt;777&lt;/span&gt;&lt;span&gt; 
umask &lt;/span&gt;&lt;span&gt;002&lt;/span&gt;     # 拿走普通人的写权限位，创建的文件就是 &lt;span&gt;664&lt;/span&gt;（即666减2），对目录来说就是 &lt;span&gt;775&lt;/span&gt;&lt;span&gt;（即777减2）
umask &lt;/span&gt;&lt;span&gt;020&lt;/span&gt;     # 拿走所属组的写权限位，创建的文件就是 &lt;span&gt;646&lt;/span&gt;（即666减20），对目录来说就是 &lt;span&gt;757&lt;/span&gt;（即777减20）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般在 /etc/profile 中加入设置，使永久生效。&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;Link: &lt;a href=&quot;https://www.cnblogs.com/farwish/p/9611482.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/farwish/p/9611482.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 08 Sep 2018 17:00:00 +0000</pubDate>
<dc:creator>黑眼诗人</dc:creator>
<og:description>作用 umask 用来设置用户创建文件、目录的默认权限，通过从权限中拿走相应的位，格式 `umask nnn`。 理解 rwx rwx rwx 权限对应三类人群，所属人，所属组，其它用户；每个人群的权</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/farwish/p/9611482.html</dc:identifier>
</item>
<item>
<title>安装最新版本的Oracle公司的虚拟机软件 VirtualBox + 安装虚拟机 Windows XP 系统 + 安装 Oracle 11G 软件 - 黑泽明军</title>
<link>http://www.cnblogs.com/chenmingjun/p/9611289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/9611289.html</guid>
<description>&lt;h2&gt;一、先去下载 VirtualBox 的安装文件 以及 扩展包&lt;/h2&gt;
&lt;p&gt;　　VirtualBox的下载链接：&lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot; target=&quot;_blank&quot;&gt;https://www.virtualbox.org/wiki/Downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908133938039-1798914599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908134152336-324830174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、安装文件&lt;/h2&gt;
&lt;p&gt;2.1、跟着安装向导，点击 &lt;strong&gt;“下一步”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908134344526-828118956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.2、选择安装文件路径&lt;strong&gt; &lt;/strong&gt;，选择 &lt;strong&gt;“浏览”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908135650734-1292572161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.3、默认全部安装，点击 &lt;strong&gt;“下一步”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908140244968-686799209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.4、默认全选，点击 &lt;strong&gt;“下一步”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908140616165-1081692467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.5、点击 &lt;strong&gt;“是”&lt;/strong&gt; 即可&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908140752379-1553989966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.6、点击 &lt;strong&gt;“安装”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908140910353-1768436603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.7、会弹出一些窗口，点击 &lt;strong&gt;“安装”&lt;/strong&gt; 即可&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908141120470-807030431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.8、等待安装&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908141238039-238075821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.9、安装完成，点击 &lt;strong&gt;“完成”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908141348046-1286530963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.10、安装成功后，会弹出 &lt;strong&gt;“虚拟电脑控制台”&lt;/strong&gt; ，即 &lt;strong&gt;图形用户界面&lt;/strong&gt;，之后我们需要安装 &lt;strong&gt;扩展插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908141518394-195185183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、安装扩展插件&lt;/h2&gt;
&lt;p&gt;3.1、选择 &lt;strong&gt;“管理”&lt;/strong&gt; --&amp;gt; &lt;strong&gt;“全局设定”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908142932381-1462268101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2、在设置对话框中，选择 &lt;strong&gt;“扩展”&lt;/strong&gt; ，选择 &lt;strong&gt;添加包&lt;/strong&gt; 图标，找到 &lt;strong&gt;“Oracle_VM_VirtualBox_Extension_Pack-5.2.18.vbox-extpack”&lt;/strong&gt; ，点击 &lt;strong&gt;“打开”&lt;/strong&gt;，点击 &lt;strong&gt;“安装”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908143629353-505861941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908143904425-972751591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.3、下拉到最后，点击 &lt;strong&gt;“我同意”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908144043068-754021134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.4、安装成功，点击 &lt;strong&gt;“确定”&lt;/strong&gt; ，点击 &lt;strong&gt;“OK”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908144218432-43777231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908144408218-1661164066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、导入虚拟机，我们以导入 WindowsXP 系统为例&lt;/h2&gt;
&lt;p&gt;4.1、点击 &lt;strong&gt;“新建” &lt;/strong&gt;，输入虚拟电脑  &lt;strong&gt;“名称”&lt;/strong&gt; ，选择 &lt;strong&gt;“类型“&lt;/strong&gt; 和 &lt;strong&gt;“版本”&lt;/strong&gt; ，点击 &lt;strong&gt;“下一步”&lt;/strong&gt; ，&lt;span&gt;注意：我们下载的 WindowsXP 系统是32位的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908152652021-1995689156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.2、分配内存，如1024M，点击 &lt;strong&gt;“下一步”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908153443909-934453027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.3、选择硬盘，如下图。选择 &lt;strong&gt;“使用已有的虚拟硬盘”&lt;/strong&gt;，并点击红框标识的 &lt;strong&gt;按钮 &lt;/strong&gt;，在弹出对话框中，找到下载好的 &lt;strong&gt;WinXP.vdi&lt;/strong&gt;，点击 &lt;strong&gt;“打开”&lt;/strong&gt; ，点击 &lt;strong&gt;“创建”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908154327146-190750355.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908154451444-851901977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908154519216-1509339746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908154635967-137769673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.4、我们在启动虚拟机之前，最好先改下 &lt;strong&gt;WinXP&lt;/strong&gt; 的设置，在主窗口中，&lt;strong&gt;选中刚创建的虚拟机&lt;/strong&gt;，点击 &lt;strong&gt;“设置”&lt;/strong&gt; ，在 &lt;strong&gt;“设置”&lt;/strong&gt; 对话框中，选择 &lt;strong&gt;“系统”&lt;/strong&gt; --&amp;gt; &lt;strong&gt;“硬件加速”&lt;/strong&gt;，去掉 &lt;strong&gt;“启动VT-x/AMD-V”&lt;/strong&gt; 的勾选，点击 &lt;strong&gt;“OK”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908155050546-1990519373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908155246467-890008789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.5、再选择 &lt;strong&gt;“网络”&lt;/strong&gt; ，&lt;strong&gt;“网卡1”&lt;/strong&gt; 连接方式 选择 &lt;strong&gt;“仅主机(Host only)网络” ，&lt;/strong&gt;&lt;span&gt;该连接方式的好处是：本机和虚拟机的ip地址会自动设置好了，不需要我们再来设置了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908155649210-1320486613.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908155812271-1771673403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.6、点击 &lt;strong&gt;“OK” &lt;/strong&gt;，设置完成。&lt;/p&gt;
&lt;p&gt;4.7、点击 &lt;strong&gt;“启动”&lt;/strong&gt; 按钮，开始安装 Windows XP 系统，如下图所示。其安装过程和在实体机上安装是一样的。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908162036433-648026236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908162151111-239533434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.8、我们查看下：虚拟机的ip地址 和 本机的ip地址 是否自动设置好了&lt;/p&gt;
&lt;p&gt;　　虚拟机的ip地址：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908162948128-11460508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　主机的ip地址：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908163536410-2140695591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　没有问题！自动给我们设置好了。&lt;/p&gt;
&lt;p&gt;4.9、我们尝试下主机是否ping通虚拟机（即：主机和虚拟机是否可以进行通信），如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908163653558-1329291832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　但是我们发现失败了，为什么呢？答：因为默认情况下，虚拟机的防火墙是打开着的，我们需要把虚拟机的防火墙关闭掉。&lt;/p&gt;
&lt;p&gt;　　WinXP系统中，点击右下角的 &lt;strong&gt;“Windows 安全中心” &lt;/strong&gt;--&amp;gt; &lt;strong&gt;“Windows 防火墙” &lt;/strong&gt;--&amp;gt; &lt;strong&gt;“关闭”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908165216090-48074092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908165821776-256892009.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　设置好后，我们再次尝试下主机是否ping通虚拟机，如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908170010558-1917595892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此时没有问题，主机可以ping通虚拟机。&lt;/p&gt;
&lt;p&gt;4.10、我们反过来，虚拟机却无法ping通主机，为什么呢？答：是不是是Win10防火墙的问题，我们发现真是Win10防火墙的问题！&lt;/p&gt;
&lt;p&gt;　　（&lt;strong&gt;PS&lt;/strong&gt;: 由于Win10没有安装第三方杀软，所以我不想直接关闭防火墙）。我电脑的的防火墙是打开的，如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908173437471-67236785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　方式一：在Windows中进行设置，&lt;strong&gt;控制面板&lt;/strong&gt; --&amp;gt; &lt;strong&gt;Windows防火墙&lt;/strong&gt; --&amp;gt; &lt;strong&gt;高级设置 &lt;/strong&gt;--&amp;gt; &lt;strong&gt;入站规则 &lt;/strong&gt;中 &lt;strong&gt;启用 &lt;span&gt;文件和打印机共享(回显请求 - ICMPv4-In) &lt;/span&gt;规则&lt;/strong&gt;（我不需要IPv6，所以不选择 ICMPv6-In），这样即可解决虚拟机ping主机的问题。如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908173833757-1967850585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　或者（PS：由于在Win10中很多人找不到控制面板，所以我们可以通过方式二），如下图所示：&lt;/p&gt;
&lt;p&gt;　　方式二：&lt;strong&gt;设置&lt;/strong&gt; --&amp;gt; &lt;strong&gt;更新和安全&lt;/strong&gt; --&amp;gt; &lt;strong&gt;Windows Defender&lt;/strong&gt; --&amp;gt; &lt;strong&gt;启用 Windows Defender 防病毒&lt;/strong&gt; --&amp;gt; &lt;strong&gt;防火墙和网络防护&lt;/strong&gt; --&amp;gt; &lt;strong&gt;允许应用通过防火墙  --&amp;gt; 文件和打印机共享 --&amp;gt; 专用/公用&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908174913883-568421092.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　虚拟机ping主机的效果截图如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908175221265-1779584302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;这样，主机和虚拟机就可以互相通信了！！！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;五、设置主机和虚拟机共享目录&lt;/h2&gt;
&lt;p&gt;5.1、在 &lt;strong&gt;虚拟机 &lt;/strong&gt;上，择选择 &lt;strong&gt;“设备”&lt;/strong&gt; --&amp;gt; &lt;strong&gt;“共享文件夹” &lt;/strong&gt;，我们可以把 &lt;strong&gt;本机&lt;/strong&gt; 的 &lt;strong&gt;任何一个目录 &lt;/strong&gt;添加成 &lt;strong&gt;共享文件夹&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908175754349-866649200.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908180256483-1536826845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908180519138-1348359303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击 &lt;strong&gt;“OK”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5.3、在 虚拟机 中，选择 &lt;strong&gt;“我的电脑”&lt;/strong&gt; --&amp;gt; &lt;strong&gt;“工具”&lt;/strong&gt; --&amp;gt; &lt;strong&gt;“映射网络驱动器”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908180725903-1861957969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.4、在弹出对话框中，按照下图，选择刚才共享的目录，点击 &lt;strong&gt;“确定” &lt;/strong&gt;，点击 &lt;strong&gt;“完成”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908181109480-389524886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908181544486-775428303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;六、安装Oracle 11G 软件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.0、特别注意：不要在共享目录里安装Oracle 11G 软件，不要在共享目录里安装Oracle 11G 软件，不要在共享目录里安装Oracle 11G 软件，重要的事情说三遍！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;6.1、先将文件 &lt;strong&gt;win32_11gR2_database_1of2.zip&lt;/strong&gt; 和 &lt;strong&gt;win32_11gR2_database_2of2.zip&lt;/strong&gt; 解压。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 注意：这两个文件解压到同一个目录database下，即：将Components目录合并到一起。如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908183842985-1766939244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.2、双击 &lt;strong&gt;“setup.exe”&lt;/strong&gt; ，弹出以下安装向导。去掉 &lt;strong&gt;“我希望通过 My Oracle Support 接收安全更新”&lt;/strong&gt; 复选框，点击 &lt;strong&gt;“Next”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908193133322-587420736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908195450886-495971003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在如下对话框中，点击 &lt;strong&gt;“是”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908195702480-122401133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908195903716-281091046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　网上找了一下”桌面类”和”服务器类”的区别：&lt;/p&gt;
&lt;p&gt;　　　　桌面版本：就是我们通常使用的版本；&lt;/p&gt;
&lt;p&gt;　　　　服务器版本：指的是将我们的本机作为服务器来使用，但笔记本的配置到不到要求，只能使用一些基本的功能(桌面版)，如果作为刚刚学习用桌面版足亦。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908200720839-280006944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此步骤为重要步骤：&lt;br/&gt;　　　　建议只需要将Oracle基目录更新下，目录路径不要含有中文或其它的特殊字符。&lt;br/&gt;　　　　全局数据库名可以默认，口令密码必须要牢记。Oracel建议的密码规则：必须是大写字母加小写字母加数字，而且必须是8位以上。如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908202444251-937734316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.3、验证先决条件&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908202641549-924827168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.4、出现概要界面，点击 &lt;strong&gt;“完成”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908203006646-685425887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 6.5、安装产品&lt;/p&gt;
&lt;p&gt;　　进度条到”100%”的时候请不要关闭窗口，会弹出 &lt;strong&gt;“Database Configuration Assistant”&lt;/strong&gt; 这个窗口，表示 正在进行创建数据库实例&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908203119533-1379807136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908204019738-104448469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　安装过程中，出现一个警告，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908210713639-1482182997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解决方法：。。。。。。&lt;/p&gt;
&lt;p&gt;　　数据库创建完成后，点击 &lt;strong&gt;“口令管理”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908232212642-56641170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　找到 &lt;strong&gt;HR&lt;/strong&gt; 和 &lt;strong&gt;SCOTT&lt;/strong&gt; 用户，去掉 &lt;strong&gt;“是否锁定账户？”&lt;/strong&gt; 的勾，并赋予新的密码，点击 &lt;strong&gt;“OK”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;HR 的新密码默认设置为：hr&lt;/p&gt;
&lt;p&gt;　　SCOTT的新密码默认设置为：tiger&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908232756991-1175642213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908232843748-273747822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;为什么使用这些默认的密码，这些默认的密码是有来历的，有兴趣的可以了解一下。　&lt;/p&gt;
&lt;p&gt;　　点击 &lt;strong&gt;“确定”&lt;/strong&gt; 之后，会出现一个警告，不用管它，点击 &lt;strong&gt;“是”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908233036778-1630775366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在 &lt;strong&gt;”完成”&lt;/strong&gt; 窗口中，&lt;/p&gt;
&lt;p&gt;　　其中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Enterprise Manager Database Control URL - (orcl) :&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　https://localhost:1158/em&lt;/strong&gt;&lt;br/&gt;　　为企业管理控制台的URL地址，需要启动相应的服务，单击 &lt;strong&gt;”关闭”&lt;/strong&gt; 即可，至此oracle安装完毕。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180908233428762-1127153067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.6、测试是否安装成功，出现如下图所示，表示安装成功&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/841693/201809/841693-20180909001957322-1059960422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再看下，在本机上是否可以访问虚拟机上的数据库&lt;/p&gt;
&lt;p&gt;　　未完待续。。。。。。&lt;/p&gt;
</description>
<pubDate>Sat, 08 Sep 2018 16:31:00 +0000</pubDate>
<dc:creator>黑泽明军</dc:creator>
<og:description>一、先去下载 VirtualBox 的安装文件 以及 扩展包 VirtualBox的下载链接：https://www.virtualbox.org/wiki/Downloads 二、安装文件 2.1、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/9611289.html</dc:identifier>
</item>
<item>
<title>Git - git branch - 查看本地仓分支列表 - Meng.NET</title>
<link>http://www.cnblogs.com/Meng-NET/p/9611216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Meng-NET/p/9611216.html</guid>
<description>&lt;p&gt;&lt;strong&gt;索引：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/Meng-NET/p/8963476.html&quot; target=&quot;_blank&quot;&gt;商业开发实战总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参看代码 GitHub：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liumeng0403/lm.solution/blob/master/documents/DeepIn/Command/git.txt&quot; target=&quot;_blank&quot;&gt;git.txt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; git branch
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二、说明:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　该命令将列出本地所有存在分支,&lt;/p&gt;
&lt;p&gt;　　包括 本地独有分支与远端在本地签出的分支,&lt;/p&gt;
&lt;p&gt;　　但是没有签出的远端分支不会出现在该列表中,&lt;/p&gt;
&lt;p&gt;　　并且当前分支会以绿色显示并用 &quot;*&quot; 做为标识.&lt;/p&gt;



&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　蒙&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　2018-09-09 00:08 周日&lt;/p&gt;

</description>
<pubDate>Sat, 08 Sep 2018 16:09:00 +0000</pubDate>
<dc:creator>Meng.NET</dc:creator>
<og:description>索引： 商业开发实战总结 参看代码 GitHub： git.txt 一、示例： 二、说明: 该命令将列出本地所有存在分支, 包括 本地独有分支与远端在本地签出的分支, 但是没有签出的远端分支不会出现在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Meng-NET/p/9611216.html</dc:identifier>
</item>
<item>
<title>十二、典型问题分析 - 小胖鼠</title>
<link>http://www.cnblogs.com/chenke1731/p/9611145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenke1731/p/9611145.html</guid>
<description>&lt;h4 id=&quot;问题1创建异常对象时的空指针问题&quot;&gt;问题1：创建异常对象时的空指针问题&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372866/201809/1372866-20180908234832011-1403736759.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建一个空指针异常对象，意味着这会调用父类的构造函数&lt;code&gt;Exception(0)&lt;/code&gt;，然后调用&lt;code&gt;init(0, NULL,0)&lt;/code&gt;，然后调用&lt;code&gt;m_message = strdup(0)&lt;/code&gt;，&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;/* Duplicate S, returning an identical malloc'd string.  */
char * __strdup (const char *s)
{
  size_t len = strlen (s) + 1;
  void *new = malloc (len);

  if (new == NULL)
    return NULL;

  return (char *) memcpy (new, s, len);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缺陷：没有处理参数为空指针的情况，默认为参数不能为空。&lt;/p&gt;
&lt;p&gt;参数为空指针的情况应该合法，空指针作为字符串的一个特殊值，是有意义的，如果要复制的字符串是一个空指针，只需要返回一个空指针就可以了，&lt;/p&gt;
&lt;p&gt;故&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;m_message = strdup(message);
// 改为
m_message = (message ? strdup(message) : NULL);
// 在外部对message为空的情况进行了处理&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改进之后增强了代码的健壮性&lt;/p&gt;
&lt;h4 id=&quot;问题2单链表linklist中的数据元素删除异常安全性问题&quot;&gt;问题2：单链表&lt;code&gt;LinkList&lt;/code&gt;中的数据元素删除，异常安全性问题&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Test : public Object
{
    int m_id;
public:
    Test(int id = 0)
    {
        m_id = id;
    }

    ~Test()
    {
        if( m_id == 1 )
        {
            throw m_id;
        }
    }
};

int main()
{
    LinkList&amp;lt;Test&amp;gt; list;
    Test t0(0), t1(1), t2(2);
    
    try
    {
        list.insert(t0);
        list.insert(t1);    // t1 在析构时抛出异常
        list.insert(t2);
        
        list.remove(1);
    }
    catch(int e)
    {
        cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; list.length() &amp;lt;&amp;lt; endl;
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;析构函数中抛出是一个不推荐的操作，但是强制这样做之后，要保证单链表对象&lt;code&gt;list&lt;/code&gt;的合法性，这叫异常安全性。&lt;code&gt;list.remove(1)&lt;/code&gt;删除下表为1的对象的时候，即删除&lt;code&gt;t1&lt;/code&gt;对象的时候，肯定会调用&lt;code&gt;t1&lt;/code&gt;的析构函数，从而抛出异常，那么期望的结果就是&lt;code&gt;list.length()&lt;/code&gt;长度变为2，因为删除了一个元素&lt;code&gt;t1&lt;/code&gt;。但是结果是程序直接崩溃，原因是&lt;code&gt;QT&lt;/code&gt;使用的编译器所使用的&lt;code&gt;g++&lt;/code&gt;编译器实现细节问题，不允许在析构函数中抛出异常，这个异常无法被捕捉。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;vs&lt;/code&gt;之后，发现程序有输出：&lt;code&gt;1 3&lt;/code&gt;，之后崩溃，过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;vs&lt;/code&gt;中允许析构函数抛出异常，可以捕捉，故&lt;code&gt;list.remove(1)&lt;/code&gt;之后会产生异常并被捕捉，e的信息就是&lt;code&gt;m_id&lt;/code&gt;值为1，故输出1&lt;/li&gt;
&lt;li&gt;然后打印&lt;code&gt;list.length()&lt;/code&gt;，值为3，意为着单链表的状态和我们期望的不一样，这里就是隐藏的问题，&lt;code&gt;remove()&lt;/code&gt;函数没有考虑异常安全性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;查看&lt;code&gt;remove()&lt;/code&gt;的代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool remove(int i)      // O(n)
{
    bool ret = ((i&amp;gt;=0) &amp;amp;&amp;amp; (i&amp;lt;m_length));
    if (ret)
    {
        Node* current = position(i);
        Node* toDel = current-&amp;gt;next;
        current-&amp;gt;next = toDel-&amp;gt;next;

        destroy(toDel);
        m_length--;
    }
    return ret;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现在实现这个函数的时候，是先&lt;code&gt;destroy(toDel)&lt;/code&gt;之后，再进行长度的&lt;code&gt;m_length--&lt;/code&gt;，这里就不够异常安全，因为在&lt;code&gt;destroy&lt;/code&gt;之后，就进入了异常，不会进行长度运算，修改代码，交换两条代码的位置：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool remove(int i)
{
...    
        m_length--;
        destroy(toDel);
...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，&lt;code&gt;clear()&lt;/code&gt;函数也会有问题，在&lt;code&gt;destroy&lt;/code&gt;之后再将&lt;code&gt;m_length&lt;/code&gt;清0，同样的问题存在，也会导致单链表的状态混乱&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void clear()        // O(n)
{
    // 释放每一个结点
    while(m_header.next)
    {
        Node* toDel = m_header.next;
        m_header.next = toDel-&amp;gt;next;
        //delete toDel;
        destroy(toDel);
    }
    m_length = 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改进之后：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void clear()        // O(n)
{
    // 释放每一个结点
    while(m_header.next)
    {
        Node* toDel = m_header.next;
        m_header.next = toDel-&amp;gt;next;
        // 做完指针操作之后，就意味着对应的数据元素已经从单链表中剥离出来的，长度应该--
        m_length--;

        //delete toDel;
        destroy(toDel);
    }       
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题3：&lt;code&gt;LinkList&lt;/code&gt;中遍历操作与删除操作的混合使用&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;LinkList&amp;lt;int&amp;gt; list;

for (int i = 0; i&amp;lt;5; i++)
{
    list.insert(i);
}

for (list.move(0); !list.end(); list.next())
{
    if (list.current() == 3)
    {
        list.remove(list.find(list.current()));
        // 删除成功后，list.current()的返回值是什么
        cout &amp;lt;&amp;lt; list.current() &amp;lt;&amp;lt; endl;
    }
}

for (int i = 0; i&amp;lt;list.length(); i++)
{
    cout &amp;lt;&amp;lt; list.get(i) &amp;lt;&amp;lt; endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372866/201809/1372866-20180908234906391-1525934390.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool remove(int i)      // O(n)
{
    // 注意i的范围
    bool ret = ((i&amp;gt;=0) &amp;amp;&amp;amp; (i&amp;lt;m_length));
    if (ret)
    {
        Node* current = position(i);
        Node* toDel = current-&amp;gt;next;
        current-&amp;gt;next = toDel-&amp;gt;next;

        //delete toDel;       
        m_length--;
        destroy(toDel);
    }
    return ret;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遍历之后&lt;code&gt;current()&lt;/code&gt;指向3，删除该元素之后，&lt;code&gt;current()&lt;/code&gt;的指向不明，故出现了随机数，改进：再&lt;code&gt;remove&lt;/code&gt;中对&lt;code&gt;m_current&lt;/code&gt;进行重新定位&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool remove(int i)      // O(n)
{
    // 注意i的范围
    bool ret = ((i&amp;gt;=0) &amp;amp;&amp;amp; (i&amp;lt;m_length));
    if (ret)
    {
        Node* current = position(i);
        Node* toDel = current-&amp;gt;next;
        // 对m_current进行处理，移动到下一个位置
        if (m_current == toDel)
        {
            m_current = toDel-&amp;gt;next;
        }
        current-&amp;gt;next = toDel-&amp;gt;next;
        //delete toDel;       
        m_length--;
        destroy(toDel);
    }
    return ret;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;问题4staticlinklist中数据元素删除时的效率问题&quot;&gt;问题4：&lt;code&gt;StaticLinkList&lt;/code&gt;中数据元素删除时的效率问题&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void destroy(Node* pn)
{
    SNode* space = reinterpret_cast&amp;lt;SNode*&amp;gt;(m_space);
    SNode* spn = dynamic_cast&amp;lt;SNode*&amp;gt;(pn);
    for(int i = 0; i &amp;lt; N; i++)
    {
        if (spn == space + i)
        {
            m_used[i] = 0;
            spn-&amp;gt;~SNode();
            // 空间归还，对象析构，即可跳出循环，没必要再继续循环下去，加上break
            break;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;问题5staticlinklist是否需要提供析构函数&quot;&gt;问题5：&lt;code&gt;StaticLinkList&lt;/code&gt;是否需要提供析构函数&lt;/h4&gt;
&lt;p&gt;一个类是否需要提供析构函数，由资源来决定，如果在类的构造函数中申请了系统资源，就需要提供析构函数，在析构函数中对应地释放系统资源。这个判断依据的前提条件是：&lt;/p&gt;
&lt;p&gt;所实现的类是一个独立的类，没有任何继承关系&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;StaticLinkList()
{
    for(int i = 0; i &amp;lt; N; i++)
    {
        m_used[i] = 0;
    }
}
// 从资源的角度看，构造函数只是进行了成员函数的赋值操作，没有申请系统资源，那么是不是可以不提供析构函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这里的&lt;code&gt;StaticLinkList&lt;/code&gt;是有继承关系的&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
class LinkList : public List&amp;lt;T&amp;gt;
{
...
    void clear()        // O(n)
    {
        // 释放每一个结点
        while(m_header.next)
        {
            Node* toDel = m_header.next;
            m_header.next = toDel-&amp;gt;next;
            //delete toDel;
            destroy(toDel);
        }
        m_length = 0;
    }
...    
    ~LinkList()
    {
        clear();
    }
...
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在继承的类中有析构函数，并且在析构函数中调用了一个虚函数，但是构造函数和析构函数中是不会发生多态的，这个&lt;code&gt;clear()&lt;/code&gt;函数就是类中实现的函数。所以对于&lt;code&gt;StaticLinkList&lt;/code&gt;来说，父类中提供了&lt;code&gt;clear()&lt;/code&gt;函数，但是子类中并没有提供该函数，所以不管在子类还是父类中调用这个函数，始终调用的都是&lt;code&gt;LinkList&lt;/code&gt;中的&lt;code&gt;clear()&lt;/code&gt;；继续分析&lt;code&gt;clear()&lt;/code&gt;函数，在里面又调用另外一个虚函数&lt;code&gt;destroy()&lt;/code&gt;，父类&lt;code&gt;LinkList&lt;/code&gt;中有一个&lt;code&gt;destroy()&lt;/code&gt;函数版本，子类&lt;code&gt;StaticLinkList&lt;/code&gt;中也有一个&lt;code&gt;destroy()&lt;/code&gt;函数版本，这意味着：父类的析构函数被调用的时候，始终调用到的都是父类中的&lt;code&gt;destroy()&lt;/code&gt;函数，子类中的&lt;code&gt;destroy()&lt;/code&gt;是没有办法在析构的时候被调用到的。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int main()
{
    StaticLinkList&amp;lt;int, 10&amp;gt; list;

    for (int i = 0; i&amp;lt;5; i++)
    {
        list.insert(i);
    }

    for (int i = 0; i&amp;lt;list.length(); i++)
    {
        cout &amp;lt;&amp;lt; list.get(i) &amp;lt;&amp;lt; endl;
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;对象是一个子类&lt;code&gt;StaticLinkList&lt;/code&gt;的对象，于是在主程序结束的时&lt;code&gt;list&lt;/code&gt;对象就会被析构，接着就调用到父类的析构函数，从而调用父类中的&lt;code&gt;clear()&lt;/code&gt;函数，其中的&lt;code&gt;destroy()&lt;/code&gt;函数肯定是父类中的实现，这里就会有问题了&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
class LinkList : public List&amp;lt;T&amp;gt;
{
protected:
    virtual void destroy(Node* pn)
        {
            delete pn;
        }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;父类的&lt;code&gt;destroy&lt;/code&gt;直接&lt;code&gt;delete&lt;/code&gt;对应的内存空间，这个内存空间来自于子类&lt;code&gt;creat()&lt;/code&gt;函数创建的空间&lt;code&gt;toDel&lt;/code&gt;，这个空间是子类中的&lt;code&gt;unsigned char m_space[sizeof(SNode) * N]&lt;/code&gt;中的空间，所以对于现在父类的&lt;code&gt;destroy&lt;/code&gt;的空间就不是堆空间了，这就会造成程序的不稳定了，因为&lt;code&gt;delete&lt;/code&gt;关键字只能释放堆空间，程序的崩溃时间无法预测。子类中所希望的&lt;code&gt;destroy&lt;/code&gt;函数并没有被调用，这种问题在实际工程中不允许出现。&lt;/p&gt;
&lt;p&gt;解决办法：在子类中添加自己的析构函数&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;~StaticLinkList()
{
    this-&amp;gt;clear();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用的还是父类中&lt;code&gt;clear()&lt;/code&gt;函数，但是&lt;code&gt;clear&lt;/code&gt;调用的&lt;code&gt;destroy&lt;/code&gt;函数却是当前类中的实现，原因是：构造函数和析构函数是不会发生多态的，在构造函数或析构函数中调用的虚函数必然是当前类中实现的版本，不管是直接调用还是间接调用，都是这样。所以这里一定会调用到子类中的&lt;code&gt;destroy()&lt;/code&gt;函数，断点调试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372866/201809/1372866-20180908235056542-841740290.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现在父类的&lt;code&gt;clear()&lt;/code&gt;函数中调用的确实是子类的&lt;code&gt;destroy()&lt;/code&gt;函数，符合预期。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：经典问题&lt;/p&gt;
&lt;p&gt;构造函数和析构函数中是不会发生多态的，所调用的虚函数都是当前类中实现的版本，不管直接调用还是间接调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;问题6是否有必要增加多维数组类&quot;&gt;问题6：是否有必要增加多维数组类？&lt;/h4&gt;
&lt;p&gt;没有必要&lt;/p&gt;
&lt;p&gt;多维数组的本质：数组的数组，本质还是一维数组&lt;/p&gt;
&lt;p&gt;二维数组类对象&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int main()
{
    DynamicArray&amp;lt; DynamicArray&amp;lt;int&amp;gt; &amp;gt; d;

    d.resize(3);

    for(int i=0; i&amp;lt;d.length(); i++)
    {
        // d[i].resize(3);
        d[i].resize(i + 1); // 不规则二维数组
    }

    for(int i=0; i&amp;lt;d.length(); i++)
    {
        for(int j=0; j&amp;lt;d[i].length(); j++)
        {
            d[i][j] = i + j;
        }
    }

    for(int i=0; i&amp;lt;d.length(); i++)
    {
        for(int j=0; j&amp;lt;d[i].length(); j++)
        {
            cout &amp;lt;&amp;lt; d[i][j] &amp;lt;&amp;lt; &quot; &quot;;
        }

        cout &amp;lt;&amp;lt; endl;
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 08 Sep 2018 15:51:00 +0000</pubDate>
<dc:creator>小胖鼠</dc:creator>
<og:description>问题1：创建异常对象时的空指针问题 创建一个空指针异常对象，意味着这会调用父类的构造函数 ，然后调用 ，然后调用 ， 缺陷：没有处理参数为空指针的情况，默认为参数不能为空。 参数为空指针的情况应该合法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenke1731/p/9611145.html</dc:identifier>
</item>
<item>
<title>京东Alpha平台开发笔记系列（二） - 一韦潇湘</title>
<link>http://www.cnblogs.com/Dainelcw/p/JDAlphaTwice.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dainelcw/p/JDAlphaTwice.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;第一篇博文简单讲了一下京东Alpha平台与个人idea技能，本篇将讲解Alpha平台与个人开发需要的一些知识，下面开篇&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;——》》》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398949/201808/1398949-20180822202259688-1508502467.png&quot; alt=&quot;&quot; width=&quot;797&quot; height=&quot;426&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图就是&lt;a href=&quot;http://www.cnblogs.com/Dainelcw/p/京东Alpha技能平台&quot; target=&quot;_blank&quot;&gt;京东Alpha技能平台&lt;/a&gt;的首页，Skill平台（技能平台），官方介绍：&lt;/p&gt;
&lt;p&gt;　　　　Alpha技能的开发平台，提供全套的自助式开发工具；帮开发者轻松，快速地将服务集成到Alpha平台，使用户通过自然语言即可获取服务，并通过Alpha赋能智能设备或手机应用，帮开发者获得亿级智能场景用户，从移动服务向AI服务升级。&lt;/p&gt;
&lt;p&gt;　　　　说白了就是智能音箱的小应用。&lt;/p&gt;
&lt;p&gt;　　　　点击控制台即可进入控制台界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398949/201808/1398949-20180822202824905-1264011573.png&quot; alt=&quot;&quot; width=&quot;941&quot; height=&quot;183&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　如上图进入之后就可以创建新的技能了。新创建技能后需要根据自己的需求添加意图，意图需要话术支持，话术则是由槽和槽值来实现的，所以需要自己添加槽位以及槽值，这时你也可以调用系统的槽值。系统提供的意图有：&lt;/p&gt;
&lt;p&gt;　　　　Alpha.CancelIntent：包含类似“退出”等话术的意图，用于中断正在进行的请求或服务并退出意图（为保证用户最低体验，该意图不可删除）　　&lt;/p&gt;
&lt;p&gt;　　　　Alpha.HelpIntent　：包含类似“帮助”等话术的意图，用于帮助用户了解如何使用您的技能（为保证用户最低体验，该意图不可删除）　　　　　　　　&lt;/p&gt;
&lt;p&gt;　　　　Alpha.NextIntent　：包含类似“下一条”等话术的意图，用于指向并获取下一个需要的内容　　　　　　　&lt;/p&gt;
&lt;p&gt;　　　　Alpha.RepeatIntent：包含类似“重复”等话术的意图，用于重新获取当前内容&lt;/p&gt;
&lt;p&gt;　　　　Alpha.ResumeIntent：继续\恢复&lt;/p&gt;
&lt;p&gt;　　　　Alpha.DefaultIntent：当 Alpha 接收到用户请求后，如果无法解析，则直接将该请求发送给技能，由技能自己进行分析处理&lt;/p&gt;
&lt;p&gt;　　　　Alpha.PauseIntent：暂停播放&lt;/p&gt;
&lt;p&gt;　　　　Alpha.LoopOffIntent：循环播放关&lt;/p&gt;
&lt;p&gt;　　　　Alpha.LoopOnIntent：循环播放开&lt;/p&gt;
&lt;p&gt;　　　　Alpha.PreviousIntent：上一首/曲/个&lt;/p&gt;
&lt;p&gt;　　　　Alpha.ShuffleOffIntent：随机播放关&lt;/p&gt;
&lt;p&gt;　　　　Alpha.ShuffleOnIntent：随机播放开&lt;/p&gt;
&lt;p&gt;　　　　Alpha.StartOverIntent：重新播放&lt;/p&gt;
&lt;p&gt;　　　　内置槽位：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398949/201808/1398949-20180822210705953-2115370144.png&quot; alt=&quot;&quot; width=&quot;948&quot; height=&quot;441&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;新建意图&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;如下图，在新建意图中添加槽位，这里槽位名称需要自己填写，槽位类型可选自己自定义的类型也可选择内置类型，这里就选择了内置的日期类型和数字类型，意图话术中　就是编写一句话术，使用户在说含有这些槽值的话术时触发此意图。例：今天花了20元。此句话就触发了本话术，于是就发出意图请求。发出的请求以post方式发送，数据以json格式发送给服务器，所以实现此应用还需要搭建一台服务器（小编使用的是腾讯云服务器，然后自己搭建服务器（Xampp——Mysql+tomcat+appach），然后使用eclipse建立一个web工程，用servlet方式处理请求即可）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398949/201808/1398949-20180822211020689-406108980.png&quot; alt=&quot;&quot; width=&quot;957&quot; height=&quot;446&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　下面分析数据协议：&lt;/p&gt;
&lt;p&gt;　　　　官方文档：http://alphadev.jd.com/Docs/skillCreate#shujuxieyi&lt;/p&gt;
&lt;p&gt;　　　　我的请求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
//首次建立会话
{
  &quot;request&quot;: {
    &quot;dialogState&quot;: &quot;STARTED&quot;, 
    &quot;requestId&quot;: &quot;debf33c1-7fdb-4417-b015-3313568bad7e_1310_test&quot;, 
    &quot;timestamp&quot;: 1534340485603, 
    &quot;type&quot;: &quot;LaunchRequest&quot;                             //会话正式开始
  }, 
  &quot;session&quot;: {
    &quot;application&quot;: {
      &quot;applicationId&quot;: &quot;jd.alpha.skill.c570c43sxsxa158c74abcb2e673fd06d680af&quot;
    }, 
    &quot;device&quot;: {
      &quot;deviceId&quot;: &quot;deviceId_a4f5b13d80xsce46abbf73ssxa31877d1e025_dev_test&quot;
    }, 
    &quot;isNew&quot;: true, 
    &quot;sessionId&quot;: &quot;xxxxcec8xxx1960-3a35-45ce-917d-0a1d1c2x80b04&quot;, 
    &quot;user&quot;: {
      &quot;userId&quot;: &quot;jd.account.xxxx3d8axd78643xxx18eb3b0202303b09910281&quot;
    }
  }, 
  &quot;version&quot;: &quot;1.0&quot;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　带有意图的请求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;价格查询服务&lt;/span&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;request&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;dialogState&quot;: &quot;IN_PROGRESS&quot;&lt;span&gt;, 
    &lt;/span&gt;&quot;intent&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;confirmResult&quot;: &quot;NONE&quot;&lt;span&gt;, 
      &lt;/span&gt;&quot;name&quot;: &quot;MainQuery&quot;,                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务请求名称&lt;/span&gt;
      &quot;slots&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;Date&quot;&lt;span&gt;: {
          &lt;/span&gt;&quot;confirmResult&quot;: &quot;NONE&quot;&lt;span&gt;, 
          &lt;/span&gt;&quot;matched&quot;: true&lt;span&gt;, 
          &lt;/span&gt;&quot;name&quot;: &quot;今天&quot;　　　　　　　　　　　　//符合条件的槽值&lt;span&gt;
        }, 
        &lt;/span&gt;&quot;Number&quot;&lt;span&gt;: {
          &lt;/span&gt;&quot;confirmResult&quot;: &quot;NONE&quot;&lt;span&gt;, 
          &lt;/span&gt;&quot;matched&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, 
          &lt;/span&gt;&quot;name&quot;: &quot;20&quot;&lt;span&gt;
        }&lt;/span&gt;&lt;span&gt;
      }
    }, 
    &lt;/span&gt;&quot;requestId&quot;: &quot;6e293729-56dd-47c9-a53b-abc55999ae57_1310_test&quot;&lt;span&gt;, 
    &lt;/span&gt;&quot;timestamp&quot;: 1534340380605&lt;span&gt;, 
    &lt;/span&gt;&quot;type&quot;: &quot;IntentRequest&quot;　　　　　　　　　　//请求类型&lt;span&gt;
  }, 
  &lt;/span&gt;&quot;session&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;application&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;applicationId&quot;: &quot;jd.alpha.skill.c570c431dses58c74abcb2e673fd06d680af&quot;&lt;span&gt;
    }, 
    &lt;/span&gt;&quot;contexts&quot;&lt;span&gt;: { }, 
    &lt;/span&gt;&quot;device&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;deviceId&quot;: &quot;deviceId_696caff960fa4a5f93sdde9e434c2abedad3_dev_test&quot;&lt;span&gt;
    }, 
    &lt;/span&gt;&quot;isNew&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, 
    &lt;/span&gt;&quot;sessionId&quot;: &quot;14deca02-9293-406b-9318-94dsd6949a1409&quot;&lt;span&gt;, 
    &lt;/span&gt;&quot;user&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;userId&quot;: &quot;jd.account.3d8ad7864318eb3bdfdsf0202303b09910281&quot;&lt;span&gt;
    }
  }, 
  &lt;/span&gt;&quot;version&quot;: &quot;1.0&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　更多话术请求json数据形式有待大家发现运用，详细仔细参考官方数据协议。&lt;/p&gt;
&lt;p&gt;　　下一篇介绍服务器端的搭建以及通讯流程及处理步骤。&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/Dainelcw/p/JDAlpha.html&quot; target=&quot;_blank&quot;&gt;点击这里直接跳转上一篇&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;


</description>
<pubDate>Sat, 08 Sep 2018 15:40:00 +0000</pubDate>
<dc:creator>一韦潇湘</dc:creator>
<og:description>本文继第一篇文章之后出的一篇以平台开发说明步骤为主线，阐述简易开发流程。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dainelcw/p/JDAlphaTwice.html</dc:identifier>
</item>
<item>
<title>pytesseract库的安装和使用 - 星辰之海</title>
<link>http://www.cnblogs.com/Lvg3687/p/9611104.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lvg3687/p/9611104.html</guid>
<description>&lt;p&gt;在写爬虫的时候总是遇到一些以图片的形式展示的信息，因此要怎么解析图片上的信息呢？在Google上查了一下，需要安装pytesseract和pillow（我用的python3.7）和Tesseract-OCR&lt;/p&gt;
&lt;p&gt;1. 安装pytesseract&lt;/p&gt;
&lt;p&gt;　　pip insatll pytesseract&lt;/p&gt;
&lt;p&gt;2. 安装pillow&lt;/p&gt;
&lt;p&gt;　　pip install pillow&lt;/p&gt;
&lt;p&gt;3. 安装Tesseract-OCR(https://github.com/tesseract-ocr/tesseract)&lt;/p&gt;
&lt;p&gt;4. 安装完后将Tesseract-OCR的安装路径添加到环境变量中PATH和Path中都要添加&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217976/201809/1217976-20180908232322270-1279337913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5. 在python的安装路径下的修改安装的pytesseract库里面的pytesseract.py，将默认的改成Tesseract-OCR的安装路径&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217976/201809/1217976-20180908232648078-1618228855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7. 配置完了开始撸代码吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217976/201809/1217976-20180908233041338-1739806015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行后发现会报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217976/201809/1217976-20180908233242826-1256653261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用Google查了一下，发现是因为验证码的图片模式为RGBA，是无法分配调色盘给透明通道的。更换为RGB模式则不会出现该问题。&lt;/p&gt;
&lt;p&gt;对原先的代码修改一下，变为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217976/201809/1217976-20180908233550136-1003635760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改后就能正常使用了。&lt;/p&gt;

</description>
<pubDate>Sat, 08 Sep 2018 15:39:00 +0000</pubDate>
<dc:creator>星辰之海</dc:creator>
<og:description>在写爬虫的时候总是遇到一些以图片的形式展示的信息，因此要怎么解析图片上的信息呢？在Google上查了一下，需要安装pytesseract和pillow（我用的python3.7）和Tesseract-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Lvg3687/p/9611104.html</dc:identifier>
</item>
<item>
<title>GitLab 社区版 11.0.2用户管理教程 - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/9611096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/9611096.html</guid>
<description>&lt;div class=&quot;WordSection1&quot; readability=&quot;8.5116279069767&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Gitlab地址：&lt;a href=&quot;http://172.20.10.197/users/sign_in&quot;&gt;http://xx.xx.xx.xx/users/sign_in&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;登录之后，主界面&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232621244-1498068151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;右上角功能按钮，分别为管理区域、新建、问题、合并请求、待办事件、个人设置&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232636733-1700331945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;选择管理区域按钮&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232653380-2147443497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;WordSection2&quot; readability=&quot;24&quot;&gt;
&lt;p align=&quot;left&quot;&gt;可以根据需要选择新建项目、新建用户和新建组&lt;/p&gt;
&lt;h4&gt;一、 项目管理&lt;/h4&gt;
&lt;p&gt;a)    新建项目&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232710441-804250349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 项目名称，项目名称可以为字母、数字、空格、下划线、中划线和英文点号组 成，且必须以字母或数字开头，不能使用中文；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 选择命名空间（组、用户）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 项目描述；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 可见性（库类别） ：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;私有库：只有被赋予权限的用户可见；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内部库：登录用户可以下载；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;公开库：所有人可以下载；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. 其它可以自定义库；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232751434-516463121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;根据实际情况填写完各项之后，点击创建项目，项目创建成功&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232803644-2050590322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;右上方内容即是项目地址，可发送给开发人员下载和初始化项目&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232819183-667394372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b) 编辑或删除项目&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1. 点击右上角管理区按钮，进入管理区主界面选择要删除或编辑的项目&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232829481-1599987546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;点击右上角编辑&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232841249-348847478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2. 进入编辑主页，在下图中右下角高级设置展开选择删除项目&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232850033-1759082522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232913275-1429827082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;二、组管理&lt;/h4&gt;
&lt;p&gt;a) 新建组&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232924009-337573344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908232944538-1959163138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1. 群组路径；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2. 组名称，组名称可以为字母、数字、空格、下划线、中划线和英文点号组成；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;且必须以字母或数字开头，&lt;span&gt;不能使用中文；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3. 组描述；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;b) 编辑或删除组&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1. 点击右上角管理区按钮，进入管理区主界面选择要编辑或删除的组&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908233008748-2094246664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;选择Groups&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908233019594-2035202146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;选择需要删除的组确定&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908233029622-997051215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;三、用户管理&lt;/h4&gt;
&lt;p align=&quot;left&quot;&gt;a) 新建用户&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908233043643-1444988920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908233103083-90146999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908233112412-976221579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1. 姓名（可以是中文）；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2. 用户名（可以为字母、数字、空格、下划线、中划线和英文点号组成，且必须以字 母或数字开头，不能使用中文）；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3. 邮箱地址（首次接收密码）；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;4. 建项目的数量限制；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5. 是否可以创建组；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;6. 是否是管理员；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;7．选填内容（个人联系方式）；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;b)编辑或删除用户&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;点击右上角管理区按钮，进入管理区主界面&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908233127594-986125931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;c)设置用户密码，管理区域—&amp;gt;用户—&amp;gt;编辑。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908233135010-1680310511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908233216552-1482485918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;四、项目权限管理&lt;/h4&gt;
&lt;p align=&quot;left&quot;&gt;a)点击左上角群组按钮，进入成员管理界面，可以添加组成员和设置相关权限&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908233228151-2066186915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;b)项目成员权限管理&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201809/1271786-20180908233236956-625744569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;权限分类:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Guest(访客) – 阅览项目、写留言薄；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Reporter（报告人）- 阅览项目、写留言薄、&lt;span&gt;拉项目、下载项目、创建代码片 段；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Developer（开发者）- 阅览项目、写留言薄、&lt;span&gt;拉项目、下载项目、创建代码 片段、创建合并请求、创建新分支、推送不受保护的分支、移除不受保护的分支 、创建标签、编写 wiki；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Master（管理者）- 创建项目、写留言薄、&lt;span&gt;拉项目、下载项目、创建代码片 段、创建合并请求、创建新分支、推送不受保护的分支、移除不受保护的分支 、创建标签、编写 wiki、增加团队成员、推送受保护的分支、移除受保护 的分支、编辑项目、添加部署密钥、配置项目钩子；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Owner（所有者）-  创建项目、写留言薄、&lt;span&gt;拉项目、下载项目、创建代码片段、创建合并请求、创建新分支、推送不受保护的分支、移除不受保护的分支  、创建标签、编写 wiki、增加团队成员、推送受保护的分支、移除受保护 的分支、编辑项目、添加部署密钥、配置项目钩子、开关公有模式、将项目转 移到另一个名称空间、删除项目；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;规范：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;各项目的管理员用户由超级管理员创建；&lt;/li&gt;
&lt;li&gt;组成员由管理员创建并赋予相应权限；&lt;/li&gt;
&lt;li&gt;各项目由项目管理员创建；&lt;/li&gt;
&lt;li&gt;每个项目创建四个分支(master，test，devp，verify);&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 08 Sep 2018 15:38:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<og:description>Gitlab地址：http://xx.xx.xx.xx/users/sign_in 登录之后，主界面 右上角功能按钮，分别为管理区域、新建、问题、合并请求、待办事件、个人设置 选择管理区域按钮 Git</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dev0ps/p/9611096.html</dc:identifier>
</item>
<item>
<title>非阻塞 Connect - Tattoo_Welkin</title>
<link>http://www.cnblogs.com/Tattoo-Welkin/p/9611086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tattoo-Welkin/p/9611086.html</guid>
<description>&lt;ol&gt;&lt;li&gt;可以让三路握手的处理等同与一般数据的处理，而不是一直让 &lt;code&gt;connect&lt;/code&gt;一直尝试重连或者花费一个&lt;code&gt;RTT&lt;/code&gt;时间。而且RTT时间从几毫秒到几秒不等，万一有许多连接，不论是尝试重连还是花费一个RTT时间，都将是致命的延时。&lt;/li&gt;
&lt;li&gt;可以使用该技术同时建立多个连接。Web浏览器中常用。&lt;/li&gt;
&lt;li&gt;既然使用&lt;code&gt;select&lt;/code&gt;等待连接的建立，我们就可以质地不嗯一个时间限制，使得我们能够缩短&lt;code&gt;connect&lt;/code&gt;的超时。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li&gt;处理&lt;code&gt;connect&lt;/code&gt;立即建立的情况。（比如我们连接的是同一个主机时）&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;使用&lt;code&gt;selcet&lt;/code&gt;与非阻塞&lt;code&gt;connect&lt;/code&gt;的一些注意事项：&lt;/p&gt;
&lt;p&gt;2.1. 当连接成功建立后，描述符变为可写。&lt;br/&gt;2.2 当遇到错误时，描述符变为即可写又可读。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;非阻塞connect时间获取客户程序&quot;&gt;（1）非阻塞&lt;code&gt;connect&lt;/code&gt;:时间获取客户程序&lt;/h2&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int Connect_nonblock(int sockfd, const SA *saptr, socklen_t salen, int nsec) //返回 -1 失败
{
    int flags, n, error;
    socklen_t len;
    fd_set rset, wset;
    struct timeval tval;
    flags = Fcntl(sockfd, F_GETFL, 0);
    Fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);

    error = 0;
    if ((n = connect(sockfd, saptr, salen)) &amp;lt; 0)
    {
        if (errno != EINPROGRESS) //表示连接已经启动但是还没有完成
            return (-1);
    }
    if (n == 0) //表示连接建立 立即完成
        goto done;

    FD_ZERO(&amp;amp;rset);
    FD_SET(sockfd, &amp;amp;rset);
    wset = rset;
    tval.tv_sec = nsec;
    tval.tv_usec = 0;
    if ((n = Select(sockfd + 1, &amp;amp;rset, &amp;amp;wset, NULL, nsec ? &amp;amp;tval : NULL)) == 0)//返回0，超时，关闭套接字
    {
        Close(sockfd);
        errno = ETIMEDOUT;
        return (-1);
    }
    if (FD_ISSET(sockfd, &amp;amp;rset) || FD_ISSET(sockfd, &amp;amp;wset))
    {
        len = sizeof(error);
        if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;amp;error, &amp;amp;len) &amp;lt; 0)
            return (-1);
    }
    else
        err_quit(&quot;selcet error :sockfd not set\n&quot;);
done: //直到建立才返回

    Fcntl(sockfd, F_SETFL, flags);

    if (error)
    {
        Close(sockfd);
        errno = error;
        return (-1);
    }
    return 0; //成功连接
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;一些说明&quot;&gt;一些说明：&lt;/h4&gt;
&lt;p&gt;  其实比较简单，就是&lt;code&gt;connect&lt;/code&gt;去连接，如果能够连上就连接即可，如果没有连上就让&lt;code&gt;select&lt;/code&gt;当作一般数据去处理即可！对于连接，&lt;code&gt;select&lt;/code&gt;有两种情况，成功就是可写，失败即可读又可写。那么问题来了？&lt;/p&gt;
&lt;p&gt;  如何去判断成功还是失败呐？emmmm，所谓的失败就是发生了错误，那么我们直接检测是否有错误即可 。使用&lt;code&gt;getsockopt&lt;/code&gt;函数 。&lt;/p&gt;
&lt;h3 id=&quot;getsockopt函数说明获取某个套接字关联的选项&quot;&gt;&amp;lt;1&amp;gt; &lt;code&gt;getsockopt&lt;/code&gt;函数说明：获取某个套接字关联的选项&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;
       int getsockopt(int socket, int level, int option_name,
           void *restrict option_value, socklen_t *restrict option_len);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;getcoksopt&lt;/code&gt;和&lt;code&gt;setsockopt&lt;/code&gt;都只用于套接字&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;level&lt;/code&gt;指定系统中解释选项的代码或为通用套接字代码，或为特定于某个协议的代码 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;option_value&lt;/code&gt;将已获取的选项当前值，存放在&lt;code&gt;*option_value&lt;/code&gt;中，&lt;code&gt;option_len&lt;/code&gt;为&lt;code&gt;*option_value&lt;/code&gt;的大小 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;option_name&lt;/code&gt;代表选项 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;返回值&quot;&gt;返回值：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;RETURN VALUE
       Upon  successful  completion,  getsockopt()  shall  return 0; otherwise, −1 shall be returned and errno set to indicate the
       error.
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Berkeley&lt;/code&gt;系统中：在&lt;code&gt;*option_value&lt;/code&gt;中返回待处理错误，函数返回 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Solaris&lt;/code&gt;系统中：将&lt;code&gt;errno&lt;/code&gt;置为待处理错误，函数返回 -1&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以在我们的代码中，我们将这两种情况都进行处理 。&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;&amp;lt;2&amp;gt;测试：&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int main(int argc, char **argv)
{
    int sockfd, n;
    char recvline[MAXLINE + 1] = {0};
    struct sockaddr_in servaddr;

    if (argc != 2)
        err_quit(&quot;usage: a.out &amp;lt;IPaddress&amp;gt;&quot;);

    if ((sockfd = Socket(AF_INET, SOCK_STREAM, 0)) &amp;lt; 0)
        err_sys(&quot;Socket error&quot;);

    bzero(&amp;amp;servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(13); /* daytime server */
    if (inet_pton(AF_INET, argv[1], &amp;amp;servaddr.sin_addr) &amp;lt;= 0)
        err_quit(&quot;inet_pton error for %s&quot;, argv[1]);

    if (Connect_nonblock(sockfd, (SA *)&amp;amp;servaddr, sizeof(servaddr), 10) &amp;lt; 0)
        err_sys(&quot;connect error&quot;);

    while ((n = recv(sockfd, recvline, MAXLINE, 0)) &amp;gt; 0)
    {
        recvline[n] = 0; /* null terminate */
        printf(&quot;recvline ==  %s\n&quot;, recvline);
    }
    if (n &amp;lt; 0)
        err_sys(&quot;read error&quot;);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180908224904803?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXNoZW5neGlfcm9vdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;非阻塞connect-web-客户程序&quot;&gt;（2）非阻塞&lt;code&gt;Connect&lt;/code&gt; : Web 客户程序&lt;/h2&gt;
&lt;p&gt;  先获取一个主页，然后并行多个连接获取主页的其他网络资源。很显然，这样子的并行连接序列要比串行获取资源来的快。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;结构体设计&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;#define MAXFILES 20
#define SERV &quot;80&quot;
struct file
{
    char *f_name; //资源路径
    char *f_host; //主机
    int f_fd;//套接字
    int f_flags; //当前状态，有四种值，分别是 { 0, F_CONNECTING, F_READING, F_DONE }
}
file[MAXFILES];&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;大致思路：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// 假设我们下载 10 资源
初始化 struct file files[10];

先成功建立第一个连接（获取主页）

while(xxx) {
   使用非阻塞I/O, 同时建立多个连接，每一个 f_flags = F_CONNECTING.
   select 监听套接字
   for (f in files) { // 遍历所有文件
     if (f.f_flags == F_CONNECTING) {
       // 检查连接是否成功或失败。使用我们上面用到的知识，主要是 getsockopt 函数
       如果连接成功，则发起 GET 请求，同时 f_flags = F_READING.
       如果连接失败，f_flags = F_DONE;
     }
     else if (f.f_flags == F_READING) {
       // 下载资源
       nr = read(f.f_fd, buf);
       if (nr == 0) {
         对端关闭， f.f_flags = F_DONE;
       }
     }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;web.h&lt;/code&gt;文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifndef _WEB_H
#define _WEB_H

#include &quot;../myhead.h&quot;

#define MAXFILES 20
#define SERV &quot;80&quot;
struct file
{
    char *f_name;
    char *f_host;
    int f_fd;
    int f_flags;
}
file[MAXFILES];

#define F_CONNECTING 1
#define F_READING 2
#define F_DONE 4

#define GET_CMD &quot;GET %s HTTP/1.0\r\n\r\n&quot;

int nconn, nfiles, nlefttoconn, nlefttoread, maxfd;
fd_set rset, wset;
/*
nconn:当前打开的连接数，不超过第一个命令行参数
nlefttoread:待读取的文件数量
nlefttoconn:尚未连接的文件数
nfiles:文件数量
*/
#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;web.c&lt;/code&gt;文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;web.h&quot;

struct addrinfo *Host_serv(const char *host, const char *serv, int family, int socktype);
void home_pages(const char *host, const char *fname);
void start_connect(struct file *fptr); //非阻塞连接;
void write_get_cmd(struct file *fptr);

int Tcp_connect(const char *host, const char *serv)
{
    int sockfd, n;
    struct addrinfo hints, *res, *ressave;

    bzero(&amp;amp;hints, sizeof(struct addrinfo));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((n = getaddrinfo(host, serv, &amp;amp;hints, &amp;amp;res)) != 0)
        err_quit(&quot;tcp_connect error for %s ,%s,%s : %s&quot;, host, serv, gai_strerror(n));
    ressave = res;
    do
    {
        sockfd = Socket(res-&amp;gt;ai_family, res-&amp;gt;ai_socktype, res-&amp;gt;ai_protocol);
        if (sockfd &amp;lt; 0)
            continue;
        if (connect(sockfd, res-&amp;gt;ai_addr, res-&amp;gt;ai_addrlen) == 0)
            break;
        Close(sockfd);
    } while ((res = res-&amp;gt;ai_next) != NULL);
    if (res == NULL)
        err_sys(&quot;tcp_coonnect error for %s,%s&quot;, host, serv);
    freeaddrinfo(ressave);
    return (sockfd);
}

struct addrinfo *Host_serv(const char *host, const char *serv, int family, int socktype)
{
    int n;
    struct addrinfo hints, *res;
    bzero(&amp;amp;hints, sizeof(struct addrinfo));
    hints.ai_flags = AI_CANONNAME;
    hints.ai_family = family;
    hints.ai_socktype = socktype;

    if ((n = getaddrinfo(host, serv, &amp;amp;hints, &amp;amp;res)) != 0)
        err_quit(&quot;host_serv error for %s, %s: %s&quot;,
                 (host == NULL) ? &quot;(no hostname)&quot; : host,
                 (serv == NULL) ? &quot;(no service name)&quot; : serv,
                 gai_strerror(n));
    return (res);
}

void home_pages(const char *host, const char *fname)
{
    int fd, n;
    char line[MAXLINE] = {0};
    fd = Tcp_connect(host, SERV);
    n = snprintf(line, sizeof(line), GET_CMD, fname);
    Sendlen(fd, line, n, 0);
    for (;;)
    {
        if ((n = Recvlen(fd, line, MAXLINE, 0)) == 0)
            break; //serv closed
        fprintf(stderr, &quot;recv %d bytes from server \n&quot;, n);
    }
    fprintf(stderr, &quot;end-of-home-pages\n&quot;);
    Close(fd);
}
void start_connect(struct file *fptr) //非阻塞连接
{
    int fd, flags, n;
    struct addrinfo *ai;
    ai = Host_serv(fptr-&amp;gt;f_host, SERV, 0, SOCK_STREAM);
    fd = Socket(ai-&amp;gt;ai_family, ai-&amp;gt;ai_socktype, ai-&amp;gt;ai_protocol);
    fptr-&amp;gt;f_fd = fd;

    fprintf(stderr, &quot;start_connect  for %s ,fd %d \n&quot;, fptr-&amp;gt;f_name, fd);

    flags = Fcntl(fd, F_GETFL, 0);
    Fcntl(fd, F_SETFL, flags | O_NONBLOCK);

    if ((n = connect(fd, ai-&amp;gt;ai_addr, ai-&amp;gt;ai_addrlen)) &amp;lt; 0)
    {
        if (errno != EINPROGRESS) // EINPROGRESS套接字为非阻塞套接字，且连接请求没有立即完成
            err_sys(&quot;nonblocking connect error &quot;, __LINE__);
        fptr-&amp;gt;f_flags = F_CONNECTING;
        FD_SET(fd, &amp;amp;rset);
        FD_SET(fd, &amp;amp;wset);
        if (fd &amp;gt; maxfd)
            maxfd = fd;
    }
    else if (n &amp;gt;= 0)
    { /* connect is already done */
        write_get_cmd(fptr);
    }
}
void write_get_cmd(struct file *fptr)
{
    int n;
    char line[MAXLINE];
    n = snprintf(line, sizeof(line), GET_CMD, fptr-&amp;gt;f_name);

    Writen(fptr-&amp;gt;f_fd, line, n);

    fprintf(stderr, &quot;send %d bytes for %s \n\n\n&quot;, n, fptr-&amp;gt;f_name);

    fptr-&amp;gt;f_flags = F_READING; /* clears F_CONNECTING */

    FD_SET(fptr-&amp;gt;f_fd, &amp;amp;rset); /* will read server's reply */

    if (fptr-&amp;gt;f_fd &amp;gt; maxfd)
        maxfd = fptr-&amp;gt;f_fd;
}

int main(int argc, char **argv)
{
    int i, fd, n, maxconn, flags, error;
    char buf[MAXLINE] = {0};
    fd_set rs, ws;
    if (argc &amp;lt; 5)
    {
        fprintf(stderr, &quot;use :web conns hostname homepages files.....&quot;);
        return 0;
    }
    maxconn = atoi(argv[1]);
    nfiles = min(argc - 4, MAXFILES);
    for (i = 0; i &amp;lt; nfiles; i++)
    {
        file[i].f_name = argv[i + 4];
        file[i].f_host = argv[2];
        file[i].f_flags = 0;
    }

    fprintf(stderr, &quot;nfiles ==  %d \n&quot;, nfiles);

    home_pages(argv[2], argv[3]); //建立第一个连接

    FD_ZERO(&amp;amp;rset);
    FD_ZERO(&amp;amp;wset);

    maxfd = -1;
    nlefttoread = nlefttoconn = nfiles;
    nconn = 0;

    /*
nconn :当前打开的连接数，不超过第一个命令行参数
nlefttoread:待读取的文件数量
nlefttoconn:尚未连接的文件数
nfiles:文件数量
*/
    while (nlefttoread &amp;gt; 0)
    {
        while (nconn &amp;lt; maxconn &amp;amp;&amp;amp; nlefttoconn &amp;gt; 0)
        {
            /* 4find a file to read */
            for (i = 0; i &amp;lt; nfiles; i++)
                if (file[i].f_flags == 0)
                    break;
            if (i == nfiles)
                err_quit(&quot;nlefttoconn = %d but nothing found&quot;, nlefttoconn);
            start_connect(&amp;amp;file[i]);
            nconn++;
            nlefttoconn--;
        }

        rs = rset;
        ws = wset;
        n = Select(maxfd + 1, &amp;amp;rs, &amp;amp;ws, NULL, NULL);

        for (i = 0; i &amp;lt; nfiles; i++)
        {
            flags = file[i].f_flags;
            if (flags == 0 || flags &amp;amp; F_DONE)
                continue;
            fd = file[i].f_fd;
            if (flags &amp;amp; F_CONNECTING &amp;amp;&amp;amp;
                (FD_ISSET(fd, &amp;amp;rs) || FD_ISSET(fd, &amp;amp;ws)))
            {
                n = sizeof(error);
                if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;amp;error, &amp;amp;n) &amp;lt; 0 ||
                    error != 0)
                {
                    err_ret(&quot;nonblocking connect failed for %s&quot;,
                            file[i].f_name);
                    file[i].f_flags = F_DONE;
                }
                /* 4connection established */
                fprintf(stderr, &quot;connection established for %s\n&quot;, file[i].f_name);
                FD_CLR(fd, &amp;amp;wset);       /* no more writeability test */
                write_get_cmd(&amp;amp;file[i]); /* write() the GET command */
            }
            else if (flags &amp;amp; F_READING &amp;amp;&amp;amp; FD_ISSET(fd, &amp;amp;rs))
            {
                if ((n = read(fd, buf, sizeof(buf))) == 0)
                {
                    fprintf(stderr, &quot;end-of-file on %s\n&quot;, file[i].f_name);
                    Close(fd);
                    file[i].f_flags = F_DONE; /* clears F_READING */
                    FD_CLR(fd, &amp;amp;rset);
                    nconn--;
                    nlefttoread--;
                }
                else
                {
                    fprintf(stderr, &quot;read %d bytes from %s\n&quot;, n, file[i].f_name);
                }
            }
        }
    }
    exit(0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试-1&quot;&gt;测试：&lt;/h3&gt;
&lt;p&gt;这是最大并行连接数是&lt;code&gt;3&lt;/code&gt;时的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180908232845254?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXNoZW5neGlfcm9vdA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;connect函数说明总结unp-connect-即可&quot;&gt;1. connect函数说明（总结unp connect 即可 ）&lt;/h2&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li&gt;&lt;code&gt;connect&lt;/code&gt; 激发&lt;code&gt;TCP&lt;/code&gt;的三路握手过程，而且仅在连接建立成功或者出错后才会返回。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在一个非阻塞的套接字上调用 &lt;code&gt;connect&lt;/code&gt; 时，&lt;code&gt;connect&lt;/code&gt;将立即返回一个&lt;code&gt;EINPROGRESS&lt;/code&gt;错误，不过三路握手会继续进行。然后我们通过&lt;code&gt;select&lt;/code&gt;去检测该连接成功或者失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果&lt;code&gt;connect&lt;/code&gt;连接失败，则该套接字不能再用，&lt;strong&gt;必须关闭！&lt;/strong&gt; 不能对这样的套接字再次调用&lt;code&gt;connect&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;讨论&quot;&gt;讨论：&lt;/h2&gt;
</description>
<pubDate>Sat, 08 Sep 2018 15:30:00 +0000</pubDate>
<dc:creator>Tattoo_Welkin</dc:creator>
<og:description>1.非阻塞 有什么用？ 1. 可以让三路握手的处理等同与一般数据的处理，而不是一直让 一直尝试重连或者花费一个 时间。而且RTT时间从几毫秒到几秒不等，万一有许多连接，不论是尝试重连还是花费一个RTT</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tattoo-Welkin/p/9611086.html</dc:identifier>
</item>
</channel>
</rss>