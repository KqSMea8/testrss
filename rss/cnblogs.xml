<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>标准输入输出 stdio 流缓冲 - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/7669007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/7669007.html</guid>
<description>&lt;p&gt;**From : &lt;a href=&quot;http://www.pixelbeat.org/programming/stdio_buffering/**&quot; class=&quot;uri&quot;&gt;http://www.pixelbeat.org/programming/stdio_buffering/**&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我发现找出标准流用的是什么缓冲是一件困难的事。&lt;/p&gt;
&lt;p&gt;例如下面这个使用unix shell 管道的例子：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ command1 | command2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图显示了shell fork了两个进程并通过一个管道将他们联系起来。在这个连接中移动使用了&lt;strong&gt;三个缓冲&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201710/1072319-20171014233157652-1418464708.png&quot; alt=&quot;buffers used in simple unix shell pipeline&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内核中的缓冲区室友pipe系统函数生成的，它的大小取决于操作系统的页大小。我们无法也没必要控制这个缓冲区的大小，因为它会立即转送数据（至少在linux上是这样）。[更新：这个pipe buffer 已经变化为 &lt;a href=&quot;http://lwn.net/Articles/118750/&quot;&gt;circular buffers&lt;/a&gt; (16 x 4KiB)并且有一个新的 &lt;a href=&quot;http://lkml.org/lkml/2008/5/30/180&quot;&gt;proposed patch&lt;/a&gt; 使得它的大小是动态的]&lt;/p&gt;
&lt;p&gt;另外两个缓冲是关于流的，为了提高效率，仅仅在第一次使用流的时候申请缓冲区空间。三个标准流(stdin, stdout, stderr)会在几乎所有的unix GNU C程序开始执行自动被创建，新的流也可以被创建用来连接文件、套接字、管道等等。你可以通过控制缓冲策略（无缓冲，行缓冲，满缓冲）来控制数据的读写方法。我使用&lt;a href=&quot;http://www.pixelbeat.org/programming/stdio_buffering/default_buffers.c&quot;&gt;这个程序&lt;/a&gt;来确定标准流的默认缓冲区的特性：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;28&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* Output info about the default buffering parameters&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * applied by libc to stdin, stdout and stderr.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Note the info is sent to stderr, as redirecting it&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * makes no difference to its buffering parameters.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Note gnulib has fbufmode() to make this portable.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio_ext.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

FILE* fileno2FILE(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fileno){
    &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt;(fileno) {
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stdin;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stdout;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stderr;
        &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;: &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; NULL;
    }
}

&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;* fileno2name(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fileno){
    &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt;(fileno) {
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;stdin&quot;&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;stdout&quot;&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;stderr&quot;&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;: &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; NULL;
    }
}

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isatty(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)) {
        fprintf(stderr,&lt;span class=&quot;st&quot;&gt;&quot;Hit Ctrl-d to initialise stdin&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        fprintf(stderr,&lt;span class=&quot;st&quot;&gt;&quot;Initialising stdin&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    }
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; data[&lt;span class=&quot;dv&quot;&gt;4096&lt;/span&gt;];
    fread(data,&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(data),&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,stdin);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isatty(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) {
        fprintf(stdout,&lt;span class=&quot;st&quot;&gt;&quot;Initialising stdout&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        fprintf(stdout,&lt;span class=&quot;st&quot;&gt;&quot;Initialising stdout&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
        fprintf(stderr,&lt;span class=&quot;st&quot;&gt;&quot;Initialising stdout&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    }
    fprintf(stderr,&lt;span class=&quot;st&quot;&gt;&quot;Initialising stderr&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//redundant&lt;/span&gt;

    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;; i++) {
        fprintf(stderr,&lt;span class=&quot;st&quot;&gt;&quot;%6s: tty=%d, lb=%d, size=%d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,
                fileno2name(i),
                isatty(i),
                __flbf(fileno2FILE(i))?&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,
                __fbufsize(fileno2FILE(i)));
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; EXIT_SUCCESS;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;默认缓冲策略：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stdin总是缓冲的&lt;/li&gt;
&lt;li&gt;stderr总是无缓冲的&lt;/li&gt;
&lt;li&gt;如果stdout是终端的话缓冲是行缓冲的，否则是满缓冲的。（补充一下，GNU里面定义的可交互设备，显然终端是可交互设备）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;默认缓冲大小：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓冲大小只会直接影响缓冲策略&lt;/li&gt;
&lt;li&gt;内核的pipe buffer 已经变化为 &lt;a href=&quot;http://lwn.net/Articles/118750/&quot;&gt;circular buffers&lt;/a&gt; (16 x 4KiB)并且有一个新的 &lt;a href=&quot;http://lkml.org/lkml/2008/5/30/180&quot;&gt;proposed patch&lt;/a&gt; 使得它的大小是动态的&lt;/li&gt;
&lt;li&gt;如果stdin/stdout 连接的是交互设备那么默认大小是1024，否则是4096&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;stdio-输出缓冲的问题&quot;&gt;stdio 输出缓冲的问题&lt;/h2&gt;
&lt;p&gt;现在来考虑一个问题：数据源的信息是间隔发送的，并且接受者希望立即收到新产生的数据。&lt;/p&gt;
&lt;p&gt;例如，一个人想要过滤 &lt;code&gt;tcpdump -l&lt;/code&gt; 或者 &lt;code&gt;tail -f&lt;/code&gt; 的输出等等（注意有一些过滤器比如sort要求一次缓存所有数据到内部，所以这里不能使用）。&lt;/p&gt;
&lt;p&gt;考虑下面这个操作，从动态网络日志终端数据中过滤出不一样的IP地址：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ tail -f access.log | cut -d' ' -f1 | uniq&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题在于，如果按照上面这个命令，我们将不能实时的看到增加的主机IP，示例图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201710/1072319-20171014233217277-79733456.png&quot; alt=&quot;buffering problem in unix shell pipeline&quot;/&gt;&lt;/p&gt;
&lt;p&gt;高亮的缓冲区导致了问题的发生。由于该缓存区连接了一个管道缓冲区，他会等到数据达到4096字节后再作为一个块传送给uniq。注意到tail的标准输出也有这个问题，但是&lt;code&gt;tail -f&lt;/code&gt;调用会自动清除缓冲区当有新的数据输入时，所以这里不会产生影响( &lt;code&gt;tcpdump -l&lt;/code&gt;, &lt;code&gt;grep --line-buffered&lt;/code&gt; &lt;code&gt;sed --unbuffered&lt;/code&gt; 也是这样)。另外，由于uniq标准输出连接的是一个可交互设备，所以当有新的一行数据到达时也会自动清除缓冲区，不会产生影响。&lt;/p&gt;
&lt;h2 id=&quot;stdio-输入缓冲问题&quot;&gt;stdio 输入缓冲问题&lt;/h2&gt;
&lt;p&gt;Buffering on stdin like stdout is used (to coalesce reads) for efficiency.正如向stdout一样，stdin也使用缓冲区以增加效率。&lt;/p&gt;
&lt;p&gt;One would have more control with byte by byte reads, but that would not be practical.如果一个一个字节的读入显然会有更多控制的空间，但是这样是不实际的。&lt;/p&gt;
&lt;p&gt;Consider the following issue:考虑以下命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ printf &quot;one\ntwo\nthree\n&quot; | ( sed 1q ; sed 1q ; sed 1q )
one&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（译者注：这里的q是sed流编辑器的退出命令，1q表示当输出到达第一行结束时退出。参考&lt;a href=&quot;http://www.grymoire.com/Unix/Sed.html#uh-34&quot;&gt;The q or quit command&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;正如你所见到的，第一个sed进程读取了所有数据，导致后面的sed没办法读入数据。注意仅仅将stdin缓冲区设置为行缓冲是没有用的，因为只有当输出缓冲区被清除的时候才会产生控制效果（译者注，如果没有输出的话，第一个sed还是会”一行一行的把输入数据读完）。以上的sed标准输入都是行缓冲&lt;a href=&quot;http://www.pixelbeat.org/programming/readline/&quot;&gt;Reading lines from stdin&lt;/a&gt;.通常你只能控制一个进程能否从stdin读入数据，或者读入特定规模的数据然后禁止读入。以下是这样的一个例子：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ printf &quot;one\ntwo\nthree\n&quot; | ( ssh localhost printf 'zero\\n' ; cat )
zero&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（译者注：后面的cat命令用于从stdin中读取数据输出到屏幕，防止printf的输出存储在缓冲区中。）&lt;/p&gt;
&lt;p&gt;这个远程printf命令并不会从stdin读取数据（译者注：'zero\n'是参数），但是ssh client并不知道这个，所以他会读取前面printf传入的数据即stdin中读取数据。为了告诉ssh远程命令不需要读入数据，可以加上&lt;code&gt;-n&lt;/code&gt;这个参数：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ printf &quot;one\ntwo\nthree\n&quot; | ( ssh -n localhost printf 'zero\n' ; cat )
zero
one
two
three&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常见的经历是你想要吧ssh放在后台当你知道远程命令不会读取数据的时候（利于常见的图像化程序），设置ssh client阻止读入数据可以防止远程应用程序停滞。你可以通过&lt;code&gt;-f&lt;/code&gt;参数告诉ssh忽略stdin并且fork到后台。例如：&lt;code&gt;ssh -fY localhost xterm&lt;/code&gt;(译者注：&lt;code&gt;-Y Enables trusted X11 forwarding&lt;/code&gt;)。&lt;/p&gt;
&lt;h2 id=&quot;stdio-缓冲控制&quot;&gt;stdio 缓冲控制&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;省略...&lt;/em&gt;（关键词：stdbuf, BUF_X_=Y where X = 0 (stdin), 1 (stdout), 2 (stderr) ）&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 15:31:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/7669007.html</dc:identifier>
</item>
<item>
<title>C语言/原子/编译，你真的明白了吗？ - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/7668982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/7668982.html</guid>
<description>&lt;p&gt;　　说到原子，类似于以下的代码可能人人都可以看出猫腻。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;pthread.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; cnt = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* mythread(&lt;span&gt;void&lt;/span&gt;*&lt;span&gt; arg)
{
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;500000000&lt;/span&gt;;i++&lt;span&gt;)
                cnt&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
        pthread_t id, id2;

        pthread_create(&lt;/span&gt;&amp;amp;&lt;span&gt;id, NULL, mythread, NULL);
        pthread_create(&lt;/span&gt;&amp;amp;&lt;span&gt;id2, NULL, mythread, NULL);
        pthread_join(id, NULL);
        pthread_join(id2, NULL);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cnt = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cnt);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我想大多数人都知道其结果未必会得到1000000000。&lt;/p&gt;
&lt;p&gt;　　测试一下吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
linux-p94b:/tmp/testhere # gcc test1.c -lpthread
linux-p94b:/tmp/testhere # for((i=0;i&amp;lt;10;i++));do ./a.out ; done
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 958925625
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可是真的知道猫腻了吗？如果我编译的时候优化一下呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
linux-p94b:/tmp/testhere # gcc -O2 test1.c -lpthread
linux-p94b:/tmp/testhere # for((i=0;i&amp;lt;10;i++));do ./a.out ; done
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行速度一下子变的飞快，而且似乎都得到了10亿。&lt;/p&gt;
&lt;p&gt;　　这里，mythread里cnt自加5亿次被优化成了 cnt += 500000000&lt;/p&gt;
&lt;p&gt;　　那么当然快啊，可是似乎这与我们当初想测试原子有那么一些差异，一样的代码，不一样的编译，却带来了不同的结果。&lt;/p&gt;
&lt;p&gt;　　其实原因在于，我们这里代码写的不好，才没有表达好我们当初的意思，我们是希望cnt真的自加5亿次。那么怎么办呢？其实很好办，在cnt的定义前面加个volatile，那么这里对于cnt的自加则不会优化。很多时候，为什么我们优化前和优化后的结果不一样，常常是因为写代码的人不明白程序的优化规则。在上个公司的时候，我很想临走的时候再给大家做一个培训，说说C语言的优化，同时说说我们平时写的无意依赖于编译的所谓垃圾代码，但是直到离开，我还是没有做此培训。&lt;/p&gt;
&lt;p&gt;　　我们加了volatile试一下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
linux-p94b:/tmp/testhere # gcc -O2 test1.c -lpthread
linux-p94b:/tmp/testhere # for((i=0;i&amp;lt;10;i++));do ./a.out ; done
cnt = 635981117
cnt = 675792826
cnt = 522700646
cnt = 593410055
cnt = 544306380
cnt = 630888304
cnt = 580539893
cnt = 629360072
cnt = 555570127
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们在cnt定义前加个volatile，效果果然就更明显了，因为真的是自加5亿次，导致问题的机会变多了。那么之前没加volatile并优化编译，会不会也有不得到10亿的可能呢？&lt;/p&gt;
&lt;p&gt;　　我们首先要明白的是，这里的cnt++不是原子操作，中间有随时调度的可能。&lt;/p&gt;
&lt;p&gt;　　5亿次太多，我们就拿只自加1次为例即可说明，两个线程都只自加1次，本来期待结果为2.&lt;/p&gt;
&lt;p&gt;　　cnt++在一般的处理器中至少有三条指令，我们用伪汇编来写。　　&lt;/p&gt;
&lt;p&gt;　　cnt -&amp;gt; reg　　//把cnt从内存加载到寄存器reg&lt;/p&gt;
&lt;p&gt;　　reg+1 -&amp;gt; reg //寄存器reg自加1&lt;/p&gt;
&lt;p&gt;　　reg -&amp;gt; cnt     //把reg的内容写入内存&lt;/p&gt;

&lt;p&gt;　　那么，&lt;/p&gt;

&lt;p&gt;       (线程1)cnt -&amp;gt; reg&lt;/p&gt;
&lt;p&gt;　　(线程1)reg+1 -&amp;gt; reg&lt;/p&gt;
&lt;p&gt;　　(线程1)reg -&amp;gt; cnt&lt;/p&gt;
&lt;p&gt;       (线程2)cnt -&amp;gt; reg&lt;/p&gt;
&lt;p&gt;　　(线程2)reg+1 -&amp;gt; reg&lt;/p&gt;
&lt;p&gt;　　(线程2)reg -&amp;gt; cnt&lt;/p&gt;

&lt;p&gt;　　理想中，我们认为处理器的执行是以上这样，结果cnt里的值是2。&lt;/p&gt;
&lt;p&gt;　　但假设过程中发生了调度，指令执行的顺序并非像以上这样，假如变成了以下这样&lt;/p&gt;

&lt;p&gt;       (线程1)cnt -&amp;gt; reg&lt;/p&gt;
&lt;p&gt;　　(线程1)reg+1 -&amp;gt; reg　　&lt;/p&gt;
&lt;p&gt;       (线程2)cnt -&amp;gt; reg&lt;/p&gt;
&lt;p&gt;　　(线程2)reg+1 -&amp;gt; reg&lt;/p&gt;
&lt;p&gt;　　(线程2)reg -&amp;gt; cnt&lt;/p&gt;
&lt;p&gt;　　(线程1)reg -&amp;gt; cnt &lt;/p&gt;
&lt;p&gt;　　我们再来算算，&lt;/p&gt;
&lt;p&gt;　　cnt = 0,  reg任意&lt;/p&gt;
&lt;p&gt;       (线程1)cnt -&amp;gt; reg&lt;/p&gt;
&lt;p&gt;　　cnt = 0, reg =  0&lt;/p&gt;
&lt;p&gt;　　(线程1)reg+1 -&amp;gt; reg&lt;/p&gt;
&lt;p&gt;　　cnt = 0, reg = 1&lt;/p&gt;
&lt;p&gt;　　此处调度，reg = 1会被保存，并在重新调度回来之后有效,而cnt不会管&lt;/p&gt;

&lt;p&gt;　　调度之后&lt;/p&gt;
&lt;p&gt;　　cnt = 0, reg任意　&lt;/p&gt;
&lt;p&gt;       (线程2)cnt -&amp;gt; reg&lt;/p&gt;
&lt;p&gt;　　cnt = 0, reg = 0&lt;/p&gt;
&lt;p&gt;　　(线程2)reg+1 -&amp;gt; reg&lt;/p&gt;
&lt;p&gt;　　cnt = 0, reg = 1&lt;/p&gt;
&lt;p&gt;　　(线程2)reg -&amp;gt; cnt&lt;/p&gt;
&lt;p&gt;　　cnt = 1, reg = 1&lt;/p&gt;
&lt;p&gt;　　此处又发生调度，reg会恢复之前保存的1，而cnt不会有任何变化&lt;/p&gt;
&lt;p&gt;　　所以在执行下一条指令前，&lt;/p&gt;
&lt;p&gt;　　cnt = 1, reg = 1&lt;/p&gt;
&lt;p&gt;　　(线程1)reg -&amp;gt; cnt &lt;/p&gt;
&lt;p&gt;　　cnt = 1, reg = 1&lt;/p&gt;

&lt;p&gt;　　我们可以看到，结果成了1，而不是2，这就是非原子操作导致的结果，其实之前优化成cnt += 500000000本身也依然有此问题，只是难以观察的到。&lt;/p&gt;
&lt;p&gt;　　虽然x++不是原子，但是我们可以使用锁的方式，来人为的制造“原子”，比如这里用互斥。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;pthread.h&amp;gt;

&lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cnt = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
pthread_mutex_t mutex &lt;/span&gt;=&lt;span&gt; PTHREAD_MUTEX_INITIALIZER;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* mythread(&lt;span&gt;void&lt;/span&gt;*&lt;span&gt; arg)
{
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;500000000&lt;/span&gt;;i++&lt;span&gt;) {
                pthread_mutex_lock(&lt;/span&gt;&amp;amp;&lt;span&gt;mutex);
                cnt&lt;/span&gt;++&lt;span&gt;;
                pthread_mutex_unlock(&lt;/span&gt;&amp;amp;&lt;span&gt;mutex);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
        pthread_t id, id2;

        pthread_create(&lt;/span&gt;&amp;amp;&lt;span&gt;id, NULL, mythread, NULL);
        pthread_create(&lt;/span&gt;&amp;amp;&lt;span&gt;id2, NULL, mythread, NULL);
        pthread_join(id, NULL);
        pthread_join(id2, NULL);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cnt = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cnt);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
linux-p94b:/tmp/testhere # gcc -O2 test1.c -lpthread
linux-p94b:/tmp/testhere # for((i=0;i&amp;lt;10;i++));do ./a.out ; done
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
cnt = 1000000000
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 14 Oct 2017 15:18:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/7668982.html</dc:identifier>
</item>
<item>
<title>比较两个文件不同以及生成SQL插入语句 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/7668983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/7668983.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;做一个终身学习的人！&lt;br/&gt;日拱一卒，功不唐捐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-6d1481d45d944dc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Java Duke&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天有个小小的需求，具体需求是这样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;有两个文本文件，每个文件都有一些字符串文本；&lt;/li&gt;
&lt;li&gt;比较第一个文件中，在第二个文件中，不存在的字符串文本；&lt;/li&gt;
&lt;li&gt;把这些在第二个文件中不存在的文本，拼接成SQL的插入语句，写入到文件中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体第一个文件中的内容是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Java
Redis
Spring   
Hibernate
Spring MVC
Dubbo
RabbitMq&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个文件中的内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Java 9
ZooKepper
MongoDB
Spring Boot
Git
Spring MVC
Mybatis
Memcache
Dubbo
RabbitMq&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实，这个小功能很简单，逻辑也不复杂，就是一个可能大家比较常用的一个小工具。&lt;/p&gt;
&lt;p&gt;根据我的思路，我主要使用了以下技术和工具：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 8 Lambda表达式；&lt;/li&gt;
&lt;li&gt;Java 8 中提供的集合stream方法；&lt;/li&gt;
&lt;li&gt;Google Guava 工具提供了集合比较的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体看代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.howtoprogram;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.google.common.collect.Sets;

/**
 * Created by i324779.
 * 比较两个文件中文本内容的不同，把第一个文本中不同的部分挑选出来，
 * 拼成对应的insert语句，
 * 最后写入文件中。
 */
public class FilterDifferWords {

    public static void main(String[] args) throws IOException {
    Path txtFile = Paths.get(&quot;/Users/i324779/Documents/test.txt&quot;);
    List&amp;lt;String&amp;gt; txtContent = loadContentFromFile(txtFile);

    Path csvFile = Paths.get(&quot;/Users/i324779/Documents/test.csv&quot;);
    List&amp;lt;String&amp;gt; csvContent = loadContentFromFile(csvFile);
    
    // List 转换为Set是为了文本内容去重
    // 使用Google Guava工具中的Sets类
    Set&amp;lt;String&amp;gt; differContent = Sets.difference(new HashSet&amp;lt;&amp;gt;(txtContent), new HashSet&amp;lt;&amp;gt;(csvContent));

    List&amp;lt;String&amp;gt; insertSqls = spliceSql(differContent);

    writeToFile(insertSqls);
    } // end method main

    /**
     * @param filePath 文件路径
     * @return 读取文件中内容到列表中。
     * @throws IOException
     */
    private static List&amp;lt;String&amp;gt; loadContentFromFile(Path filePath) throws IOException {
    return Files.readAllLines(filePath).stream()
        .flatMap(line -&amp;gt; Stream.of(line.trim())) // 去掉文本中空格
        .collect(Collectors.toList());
    } // end method loadContentFromFile

    /**
     *  拼装insert语句，使用MYSQL数据库的语法
     * @param differContent 两个文本比较后，第一个文本有，而第二个文本没有的内容。
     * @return 拼装好insert语句的集合
     */
    private static List&amp;lt;String&amp;gt; spliceSql(Set&amp;lt;String&amp;gt; differContent) {
    return differContent.stream().flatMap(line -&amp;gt; Stream.of(String.format(
        &quot;INSERT INTO test(search, replacement, level, expire, create_time) &quot;
        + &quot;VALUES ('%s', '*', 0, '2099-12-31 23:59:59', now());\r&quot;,
        line)))
        .collect(Collectors.toList());
    } // end method spliceSql

    /**
     * 把列表中的sql语句写入文件中
     * @param insertSqls 拼装好insert语句的集合
     * @throws IOException
     */
    private static void writeToFile(List&amp;lt;String&amp;gt; insertSqls) throws IOException {
    Path sqlFile = Paths.get(&quot;/Users/i324779/Documents/insertSql.txt&quot;);
    Files.write(sqlFile, insertSqls);
    } // end method writeToFile
    
} // end class FilterDifferWords&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-b24b47b7e3df7c7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;sql文件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你有这样类似的需求，只需要把文件路径修改一下即可。&lt;/p&gt;
&lt;p&gt;哈哈，程序员是一群为了偷懒而最勤奋想办法的一类人。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 15:18:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/7668983.html</dc:identifier>
</item>
<item>
<title>MySQL（十三）之MySQL事务 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7668041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7668041.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;　　这段时间自己会把之前学的东西都总结一遍，希望对自己以后的工作中有帮助。其实现在每天的状态都是很累的，但是我要坚持！&lt;/p&gt;
&lt;p&gt;　　进入我们今天的正题：&lt;/p&gt;
&lt;p&gt;　　为什么MySQL要 有事务呢？事务到底是用来干什么的？我们通过一个例子来说明：&lt;/p&gt;
&lt;p&gt;　　事务广泛的运用于订单系统、银行系统等多种场景。如果有以下一个场景：A用户和B用户是银行的储户。现在A要给B转账500元。那么需要做以下几件事：&lt;/p&gt;
&lt;p&gt;　　　　1）检查A的账户余额&amp;gt;500元；&lt;br/&gt;　　　　2）A账户扣除500元；&lt;br/&gt;　　　　3）账户增加500元；&lt;/p&gt;
&lt;p&gt;　　正常的流程走下来，A账户扣了500，B账户加了500，皆大欢喜。那如果A账户扣了钱之后，系统出故障了呢？A白白损失了500，而B也没有收到本该属于他的500。&lt;/p&gt;
&lt;p&gt;　　以上的案例中，隐藏着一个前提条件：A扣钱和B加钱，要么同时成功，要么同时失败。事务的需求就在于此！&lt;/p&gt;

&lt;h2&gt;1.1、MySQL事务简介&lt;/h2&gt;
&lt;p&gt;　　MySQL事务是&lt;span&gt;访问并更新数据库中各种数据项的一个程序执行单元。在事务中的操作，要么都执行修改，要么都不执行，这就是事务的目的&lt;/span&gt;，也是事务模型区别于文件系统的重要特征之一。&lt;/p&gt;
&lt;p&gt;　　MySQL事务主要&lt;span&gt;用于处理操作量大，复杂度高的数据&lt;/span&gt;。比如说，在员工管理系统中，删除一个员工，既需要删除员工的基本资料，也要删除和该员工相关的其他信息。这些数据库操作语句就构成一个事务。&lt;/p&gt;
&lt;p&gt;　　在MySQL中只有使用了&lt;span&gt;InnoDB数据库引擎&lt;/span&gt;的数据库或者表才支持事务。&lt;/p&gt;
&lt;p&gt;　　事务处理可以&lt;span&gt;用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　事务用来管理 insert,update,delete 语句&lt;/p&gt;
&lt;h2&gt;1.2、事务的四大特性（ACID特性）&lt;/h2&gt;
&lt;p&gt;　　严格上来说，&lt;span&gt;事务必须同时满足4个特性，即通常所说事务的ACID特性&lt;/span&gt;。虽然理论上定义了严格的事务要求，但是数据库厂商出于各种目的并没有严格满足事务的ACID标准。&lt;/p&gt;
&lt;p&gt;　　例如，对于MYSQL的NDB Cluster引擎，虽然支持事务，但是不满足D的要求，即持久性的要求。对于Oracle数据库来说，其默认的事务隔离级别为READ COMMITTED，不满足I的要求，即隔离性的要求。&lt;/p&gt;
&lt;p&gt;　　对于InnoDB存储引擎而言，默认的事务隔离级别是READ REPRATABLE，完全遵循和满足事务的ACID特性。&lt;/p&gt;
&lt;p&gt;　　1）原子性（Atomicity）：指&lt;span&gt;事务包含的所有操作要么全部成功，要么全部失败回滚&lt;/span&gt;，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。&lt;/p&gt;
&lt;p&gt;　　2）一致性（Consistency）：指&lt;span&gt;事务必须使数据库从一个一致性状态变换到另一个一致性状态&lt;/span&gt;，也就是说&lt;span&gt;一个事务执行之前和执行之后都必须处于一致性状态&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　（例如：拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。）&lt;/p&gt;
&lt;p&gt;　　3）隔离性（Isolation）：指&lt;span&gt;当多个用户并发访问数据库操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　4）持久性（Durability）：指&lt;span&gt;一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的&lt;/span&gt;，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。&lt;/p&gt;
&lt;p&gt;　　注意：事务的（ACID）特性是由&lt;span&gt;关系数据库管理系统（RDBMS，数据库系统）来实现的&lt;/span&gt;。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，&lt;/p&gt;
&lt;p&gt;　　　　　如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。数据库管理系统采用锁机制来实现事务的隔离性。&lt;/p&gt;
&lt;p&gt;　　　　　当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。&lt;/p&gt;
&lt;h2&gt;1.3、事务分类&lt;/h2&gt;
&lt;p&gt;　　扁平事务：最简单，使用最频繁的事务。在扁平事务中，所有的操作都处于一个层次，其有BEGIN WORK开始，有COMMIT WORK或ROLLBACK WORK结束。处于之间的操作是原子的，要么全部执行，要么全部回滚。&lt;/p&gt;
&lt;p&gt;　　带有保存点的扁平事务：除了扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能有些事务在执行过程中出现的错误并不会对有的操作都无效，&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　放弃整个事务不合乎要求，开销也太大。保存点用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。&lt;/p&gt;
&lt;p&gt;　　链事务：可视为保存点模式的一个变种。&lt;/p&gt;
&lt;p&gt;　　嵌套事务：一个层次结构框架。&lt;/p&gt;
&lt;p&gt;　　分布式事务&lt;/p&gt;

&lt;p&gt;　　在MYSQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行COMMIT操作。&lt;/p&gt;
&lt;p&gt;　　因此要显示的开启一个事务必须使用命令&lt;span&gt;BEGIN和START TRANSACTION，或者执行命令SET AUTOCOMMIT = 0，以禁用当前会话的自动提交&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　1）START TRANSACTION | BEGIN&lt;/p&gt;
&lt;p&gt;　　　　显示的开启一个事务。在存储过程中，MYSQL数据库的分析器会自动将BEGIN识别为BEGIN...END，因此在存储过程中只能使用START TRANSACTION语句来开启一个事务。&lt;/p&gt;
&lt;p&gt;　　2）COMMIT&lt;/p&gt;
&lt;p&gt;　　　　要想使用这个语句的最简形式，&lt;span&gt;只需发出COMMIT。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的&lt;/span&gt;。COMMIT和COMMIT WORK语句基本上是一致的，都是用来提交事务。&lt;/p&gt;
&lt;p&gt;　　　　不同的是COMMIT WORK用来控制事务结束后的行为是CHAIN还是RELEASE的。如果是CHAIN方式，那么事务就变成了链事务。用户可以通过参数completion_type来进行控制，默认该参数是0，表示没有任何操作。&lt;/p&gt;
&lt;p&gt;　　　　在这种设置下，COMMIT和COMMIT WORK是完全等价的。当参数值为1时，COMMIT WORK等价于COMMIT AND CHAIN，表示马上自动开启一个相同隔离级别的事务。&lt;/p&gt;
&lt;p&gt;　　　　当参数值为1时，COMMIT WORK等价于COMMIT AND RELEASE。当提交事务后会自动断开与服务器连接。&lt;/p&gt;
&lt;p&gt;　　3）ROLLBACK&lt;/p&gt;
&lt;p&gt;　　　　回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。&lt;/p&gt;
&lt;p&gt;　　4）SAVEPOINT identifiter&lt;/p&gt;
&lt;p&gt;　　　　SAVEPOINT允许用户在事务中&lt;span&gt;创建一个保存点，一个事务可以有很多个保存点&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　5）RELEASE SAVEPOINT identifier&lt;/p&gt;
&lt;p&gt;　　　　删除一个事务的保存点，当没有一个保存点执行这语句时，会抛出一个异常。&lt;/p&gt;
&lt;p&gt;　　6）ROLLBACK to [SAVEPOINT] identifier&lt;/p&gt;
&lt;p&gt;　　　　这个语句与SAVEPOINT命令一起使用&lt;span&gt;。可以把事务回滚到标记点，而不回滚到此标记点之前的任何工作&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　注意：虽然有ROLLBACK，但是它并没有真正的结束一个事务，因此即使执行了ROLLBACK TO SAVEPOINT，之后也需要显示的运行COMMIT或ROLLBACK命令。&lt;/p&gt;
&lt;p&gt;　　7）SET TRANSACTION&lt;/p&gt;
&lt;p&gt;　　　　这个语句&lt;span&gt;用来设置事务的隔离级别。InnoDB存储引擎提供的事务隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;1）用 BEGIN，ROLLBACK，COMMIT来实现&lt;/p&gt;
&lt;p&gt;　　BEGIN 开始一个事务&lt;/p&gt;
&lt;p&gt;　　ROLLBACK 事务回滚&lt;/p&gt;
&lt;p&gt;　　COMMIT 事务确认&lt;/p&gt;
&lt;p&gt;2）直接用SET来改变MySQL的自动提交模式&lt;/p&gt;
&lt;p&gt;　　SET AUTOCOMMIT=0 禁止自动提交&lt;/p&gt;
&lt;p&gt;　　SET AUTOCOMMIT=1 开启自动提交&lt;/p&gt;

&lt;h2&gt;4.1、在MySQL中如果不考虑事务的隔离性，会发生的几个问题&lt;/h2&gt;
&lt;p&gt;　　1）脏读&lt;/p&gt;
&lt;p&gt;　　指在一个事务处理过程里读取了另一个未提交的事务中的数据。&lt;/p&gt;
&lt;p&gt;　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。&lt;/p&gt;
&lt;p&gt;　　举例：&lt;/p&gt;
&lt;p&gt;　　　　用户A向用户B转账100元，对应SQL命令如下：&lt;/p&gt;
&lt;p&gt;　　　　update account set money=money+100 where name=’B’;(此时A通知B)&lt;/p&gt;
&lt;p&gt;　　　　update account set money=money-100 where name=’A’;&lt;/p&gt;
&lt;p&gt;　　　　当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。　&lt;/p&gt;
&lt;p&gt;　　2）不可重复读&lt;/p&gt;
&lt;p&gt;　　指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询的时候，被另一个事务修改并提交了。&lt;/p&gt;
&lt;p&gt;　　举例：&lt;/p&gt;
&lt;p&gt;　　　　事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。&lt;/p&gt;
&lt;p&gt;　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。&lt;/p&gt;
&lt;p&gt;　　在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了。　&lt;/p&gt;
&lt;p&gt;　　3）虚读（幻读）&lt;/p&gt;
&lt;p&gt;　　幻读是事务非独立执行时发生的一种现象。&lt;/p&gt;
&lt;p&gt;　　举例：&lt;/p&gt;
&lt;p&gt;　　　　事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。&lt;/p&gt;
&lt;p&gt;　　　　而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。&lt;/p&gt;
&lt;p&gt;　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。&lt;/p&gt;
&lt;h2&gt;4.2、MySQL数据库的四种隔离界别&lt;/h2&gt;
&lt;p&gt;　　 InnoDB存储引擎提供事务的隔离级别有&lt;span&gt;READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE&lt;/span&gt;。　　　　　　　&lt;/p&gt;
&lt;p&gt;　　1）Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。&lt;/p&gt;
&lt;p&gt;　　　　它通过强制事务串行执行，避免了前面说的幻读的问题。&lt;br/&gt;　　2）Repeatable read (可重复读)：可避免脏读、不可重复读的发生。&lt;/p&gt;
&lt;p&gt;　　　　解决了脏读，也保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重读读隔离级别还是无法解决另外一个幻读的问题，&lt;/p&gt;
&lt;p&gt;　　　　指的是当某个事务在读取某个范围内的记录时，另外一个事务也在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。&lt;br/&gt;　　3）Read committed (读已提交)：可避免脏读的发生。&lt;/p&gt;
&lt;p&gt;　　　　一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。&lt;/p&gt;
&lt;p&gt;　　　　这个级别有时候也叫做不可重复读，因为两次执行相同的查询，可能会得到不一样的结果。因为在这2次读之间可能有其他事务更改这个数据，每次读到的数据都是已经提交的。&lt;br/&gt;　　4）Read uncommitted (读未提交)：最低级别，任何情况都无法保证&lt;/p&gt;
&lt;p&gt;　　　　事务中的修改，即使没有提交，在其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。&lt;/p&gt;
&lt;p&gt;　　分析：&lt;/p&gt;
&lt;p&gt;　　　　1）以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，&lt;/p&gt;
&lt;p&gt;　　　　　就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。&lt;/p&gt;
&lt;p&gt;　　　　2）在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)。&lt;/p&gt;
&lt;p&gt;　　　　　而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。&lt;/p&gt;
&lt;p&gt;　　　　3）Repeatable read是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。&lt;/p&gt;
&lt;p&gt;　　　　　不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，&lt;/p&gt;
&lt;p&gt;　　　　　当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。&lt;/p&gt;
&lt;p&gt;　　　　4）在&lt;span&gt;MySQL数据库中查看当前事务的隔离级别：select @@tx_isolation;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　5）在MySQL数据库中&lt;span&gt;设置事务的隔离级别&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　　　　　set [glogal|session] transaction isolation level 隔离级别名称;&lt;br/&gt;　　　　　   set tx_isolation=’隔离级别名称’;&lt;/p&gt;
&lt;p&gt;　　　　　如果想启动时就设置事务的默认隔离级别，修改MYSQL的配置文件，在[mysqld]中添加如下行：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span class=&quot;hljs-section&quot;&gt;[mysqld]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-section&quot;&gt;　　　　　   &lt;span class=&quot;hljs-attr&quot;&gt;transaction-isolation = READ-COMMITTED&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　注意：设置数据库的隔离级别一定要是在开启事务之前！　　&lt;/p&gt;

</description>
<pubDate>Sat, 14 Oct 2017 14:59:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7668041.html</dc:identifier>
</item>
<item>
<title>IBatis.Net 老技术新研究 - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/7668850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/7668850.html</guid>
<description>&lt;p&gt;我们现在用的数据访问组件封装了IBatis.Net框架，提供了标准的数据访问接口和服务。正好总结一下老技术IBatis.Net&lt;br/&gt;在进行实际的数据访问开发之前，我们先了解一下：IBatis.Net中几个重要的配置文件和一些关键的技术原理：&lt;br/&gt;&lt;strong&gt;4个重要的配置文件：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Providers.config：数据库连接驱动配置文件，我们主要用SQLServer数据库连接驱动&lt;/li&gt;
&lt;li&gt;Mapper.xml，例如： DataPermissions.xml，定义SQL语句和结果集映射关系。&lt;/li&gt;
&lt;li&gt;SqlMap.config：统一管理数据库连接驱动、连接信息、Mapper文件列表&lt;/li&gt;
&lt;li&gt;Database_***.Config文件：存储数据库的连接信息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;关键的技术特性&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;IBatis是一个半自动化的ORM框架，支持多种业界主流的数据库，支持开发人员写SQL，这样开发人员就可以写出尽可能优化的SQL&lt;/li&gt;
&lt;li&gt;SqlMapper文件中主要包含alias类别名，ResultMaps结果集映射，Statements各类SQL语句&lt;/li&gt;
&lt;li&gt;SqlMapper文件中，实体类的属性对应ResultMap中的Property，实体类的属性同时对应数据库表中的Column&lt;/li&gt;
&lt;li&gt;IBatis中的SqlMapper文件中，#代表SQL绑定；$代表SQL拼接，有SQL注入风险，不建议使用&lt;/li&gt;
&lt;li&gt;基于Castle的代理类技术，支持Dao接口，Dao接口中的方法必须和SqlMapper文件中的SqlID保持一致。这样DaoService在构造Dao接口的代理实现类时才可以定位到指定的SQL，然后执行。&lt;/li&gt;
&lt;li&gt;支持批量SQL操作，例如Insert、Update和Delete&lt;/li&gt;
&lt;li&gt;支持返回一对多，多对多关联结果集&lt;/li&gt;
&lt;li&gt;支持数据库事务&lt;/li&gt;
&lt;li&gt;支持数据缓存：全局缓存和会话缓存&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;开发一个数据访问的业务功能，主要有以下4个步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;梳理好业务需求，定义接口；&lt;/li&gt;
&lt;li&gt;定义IBatis Mapper文件，根据接口的方法一一实现SQL语句；&lt;/li&gt;
&lt;li&gt;设置好数据库连接，将IBatis Mapper文件的路径添加到SqlMap配置文件中；&lt;/li&gt;
&lt;li&gt;调用DaoService，获取接口的实现，访问数据库。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;示例几个关键的写法&lt;br/&gt;1. 一对多关系，批量Insert&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;SaveDomainModel&quot;&lt;/span&gt;&lt;span&gt; parameterClass&lt;/span&gt;&lt;span&gt;=&quot;DomainModel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;      begin
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;      INSERT INTO Meta_DomainModel(ID,Name,RootDomainObjectID, IsCache, CacheStrategy, IsLogicallyDeleted, DataLoaderConfig, Version,Creator,LastModifier)VALUES(
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      #ID#,#Name#,#RootDomainObjectID#,#IsCache:VarChar#,#CacheStrategy#,#IsLogicDelete:VarChar#,#DataLoaderConfig#,#Version#,#Creator#,#LastModifier#)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iterate &lt;/span&gt;&lt;span&gt;conjunction&lt;/span&gt;&lt;span&gt;=&quot; &quot;&lt;/span&gt;&lt;span&gt; open&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; close&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;  property&lt;/span&gt;&lt;span&gt;=&quot;DomainObjects&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        INSERT INTO Meta_DomainObject(ID,Name,DomainModelID,IsRootObject,ParentObjectID,ClazzReflectType,PropertyName,IsLazyLoad,DataObjectID,Creator,LastModifier)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        VALUES(#DomainObjects[].ID#,#DomainObjects[].Name#,#DomainObjects[].DomainModelID#,#DomainObjects[].IsRootObject:VarChar#,#DomainObjects[].ParentObjectID#,#DomainObjects[].ClazzReflectType#,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        #DomainObjects[].PropertyName#,#DomainObjects[].IsLazyLoad:VarChar#,#DomainObjects[].DataObjectID#,#DomainObjects[].Creator#,#DomainObjects[].LastModifier#)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iterate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      end;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 简单批量Insert插入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;SaveDomainObjectElements&quot;&lt;/span&gt;&lt;span&gt; parameterClass&lt;/span&gt;&lt;span&gt;=&quot;ArrayList&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;      begin
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iterate &lt;/span&gt;&lt;span&gt;conjunction&lt;/span&gt;&lt;span&gt;=&quot; &quot;&lt;/span&gt;&lt;span&gt; open&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; close&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        INSERT INTO Meta_DomainObjectElement(ID,Name,Alias,DisplayName,DomainObjectID,DataType,Length,Precision,DefaultValue,IsAllowNull,ElementType,DataColumnID,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        PropertyType,PropertyName,IsForQuery,Creator,LastModifier)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        VALUES(#[].ID#,#[].Name#,#[].Alias#,#[].DisplayName#,#[].DomainObjectID#,#[].DataType#,#[].Length#,#[].Precision#,#[].DefaultValue#,#[].IsAllowNull:VarChar#,#[].ElementType#,#[].DataColumnID#,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        #[].PropertyType#,#[].PropertyName#,#[].IsForQuery:VarChar#,#[].Creator#,#[].LastModifier#)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iterate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      end;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 查询一对多结果集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;DataObjectResultMap&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;DataObject&quot;&lt;/span&gt;&lt;span&gt; groupby&lt;/span&gt;&lt;span&gt;=&quot;ID&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;ID&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;ID&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;Name&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;Name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;Descriptions&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;Descriptions&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;DataSourceName&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;DataSourceName&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;LogicTableName&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;LogicTableName&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;IsTableSharding&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;IsTableSharding&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;IsDatabaseSharding&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;IsDatabaseSharding&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;TableShardingStrategyID&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;TableShardingStrategy&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;DatabaseShardingStrategyID&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;DatabaseShardingStrategy&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;IsView&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;IsView&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;IsLogicallyDeleted&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;IsLogicallyDeleted&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;Version&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;Version&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;Columns&quot;&lt;/span&gt;&lt;span&gt; resultMapping&lt;/span&gt;&lt;span&gt;=&quot;MetadataMapper.DataColumnResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;Creator&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;Creator&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;CreateTime&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;CreateTime&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;LastModifier&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;LastModifier&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;LastModifyTime&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;LastModifyTime&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;DataColumnResultMap&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;DataColumn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;ID&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;C_ID&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;ColumnName&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;ColumnName&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;DisplayName&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;DisplayName&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;DataObjectID&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;DataObjectID&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;DataTypeID&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;DataType&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;Length&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;Length&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;Precision&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;Precision&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;DefaultValue&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;DefaultValue&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;IsNullable&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;IsNullable&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;IsPkColumn&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;IsPkColumn&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;IsSystem&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;IsSystem&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;IsShardingColumn&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;IsShardingColumn&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;      
&lt;span&gt;33&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;ColumnOrder&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;ColumnOrder&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;Creator&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;C_Creator&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;CreateTime&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;C_CreateTime&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;LastModifier&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;C_LastModifier&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;LastModifyTime&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;C_LastModifyTime&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应的Select 语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;GetDataObject&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;DataObjectResultMap&quot;&lt;/span&gt;&lt;span&gt; parameterClass&lt;/span&gt;&lt;span&gt;=&quot;string&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;      SELECT Meta_DataObject.ID,Meta_DataObject.Name,Descriptions, DataSourceName, LogicTableName, IsTableSharding, IsDatabaseSharding, TableShardingStrategy,DatabaseShardingStrategy,IsView,IsLogicallyDeleted,Version,Meta_DataObjectColumn.Creator,Meta_DataObjectColumn.LastModifier,Meta_DataObjectColumn.CreateTime,Meta_DataObjectColumn.LastModifyTime,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;      Meta_DataObjectColumn.ID as C_ID,ColumnName,DisplayName,DataObjectID,DataType,Length,Precision,DefaultValue,IsNullable,IsPkColumn,IsShardingColumn,IsSystem,ColumnOrder,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      Meta_DataObjectColumn.Creator as C_Creator,Meta_DataObjectColumn.LastModifier as C_LastModifier,Meta_DataObjectColumn.CreateTime as C_CreateTime,Meta_DataObjectColumn.LastModifyTime as C_LastModifyTime
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;      FROM Meta_DataObject
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;      LEFT JOIN Meta_DataObjectColumn on Meta_DataObjectColumn.DataObjectID = Meta_DataObject.ID
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;      WHERE Meta_DataObject.ID=#id#
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. 批量删除多张表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;delete &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;DeleteShardingStrategy&quot;&lt;/span&gt;&lt;span&gt; parameterClass&lt;/span&gt;&lt;span&gt;=&quot;string&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;      begin
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;      DELETE FROM Meta_ShardingColumn WHERE ShardingStrategyID=#id#
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      DELETE FROM Meta_ShardingStrategy WHERE ID=#id#
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;      end;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5. 删除指定数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;delete &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;DeleteShardingColumns&quot;&lt;/span&gt;&lt;span&gt; parameterClass&lt;/span&gt;&lt;span&gt;=&quot;string&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;      DELETE FROM Meta_ShardingColumn WHERE DataObjectID=#id#
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6. 查询数据行数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;IsTaskExist&quot;&lt;/span&gt;&lt;span&gt; resultClass&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; parameterClass&lt;/span&gt;&lt;span&gt;=&quot;string&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;      SELECT COUNT(1) FROM TableTask WHERE name=#Name#
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上就是一些简单的IBatis.Net总结。&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2017/10/14&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 14:51:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianqing/p/7668850.html</dc:identifier>
</item>
<item>
<title>ajax和jsonp使用总结 - 天宇之游</title>
<link>http://www.cnblogs.com/cwp-bg/p/7668840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwp-bg/p/7668840.html</guid>
<description>&lt;p&gt;前言：ajax和jsonp可以与后台通信，获取数据和信息，但是又不用刷新整个页面，实现页面的局部刷新。&lt;/p&gt;
&lt;h2 id=&quot;一ajax&quot;&gt;一、ajax&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;定义一种发送http请求与后台进行异步通讯的技术&quot;&gt;定义：一种发送http请求与后台进行异步通讯的技术。&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&quot;原理实例化xmlhttp对象使用此对象与后台通信&quot;&gt;原理：实例化xmlhttp对象，使用此对象与后台通信。&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;ajax的同源策略&quot;&gt;ajax的同源策略：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;ajax请求的页面或资源只能是同一个域下面的资源，不能是其他域的资源，这是在设计ajax时基于安全考虑。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;ajax的方法&quot;&gt;ajax的方法：&lt;/h3&gt;
&lt;h4 id=&quot;ajax&quot;&gt;1. $.ajax({}):&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;常用参数：
&lt;ul&gt;&lt;li&gt;url：请求网络地址&lt;/li&gt;
&lt;li&gt;type：请求方式，默认是'GET'，常用'POST'&lt;/li&gt;
&lt;li&gt;dataType：设置返回的数据格式，一般使用json，也可以是html和jsonp；&lt;/li&gt;
&lt;li&gt;data：设置发送给服务器的数据&lt;/li&gt;
&lt;li&gt;.done():设置请求成功后的回调函数&lt;/li&gt;
&lt;li&gt;.fail():设置请求失败后的回调函数&lt;/li&gt;
&lt;li&gt;async:设置是否异步，默认值是'true'，表示异步&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;代码运用：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$(function () {
    $(&quot;input&quot;).click(function () {
        $.ajax({
            url: &quot;./data.json&quot;,
            type: &quot;get&quot;,
            dataType: &quot;json&quot;,
        });
        .done(function(data) {//请求成功的回调函数
            $(&quot;input&quot;).val(dat.name);
        })
        .fail(function() {
            alert('服务器超时，请重试！');
        });
    });
})

......
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;input type=&quot;button&quot; value=&quot;xinzhi&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;说明data表示后台返回的数据ajax使用需要依赖服务器环境&quot;&gt;说明：data表示后台返回的数据；ajax使用需要依赖服务器环境。&lt;/h5&gt;
&lt;h4 id=&quot;get&quot;&gt;2. $.get():&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;//参考代码：
$(function () {
    $(&quot;input&quot;).click(function () {
        $.get(
            &quot;./data.json&quot;,
            function (data,status) {
                console.log(data.name);
            },
            &quot;json&quot;
        );
    
    });
})

......
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;input type=&quot;button&quot; value=&quot;xinzhi&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;$.get()方法的参数和$.ajax()不一样，网址url为必须的参数，其他三个可选。&lt;/li&gt;
&lt;li&gt;data为返回的数据，status表示请求的状态，一般有&quot;&quot;success&quot;,&quot;error&quot;,&quot;timeout&quot;等几种。&lt;/li&gt;
&lt;li&gt;如果datatype类型为jsonp，也可以跨域请求数据。&lt;/li&gt;
&lt;li&gt;无请求失败的回调函数。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;post&quot;&gt;3. $.post()&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;$.get() 方法使用POST请求从服务器加载数据;&lt;/li&gt;
&lt;li&gt;其使用的方法和$.get()方法完全一样。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;load&quot;&gt;4. $.load():&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;从服务器加载数据，不需要指定datatype,返回的数据会自动放置到元素中。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$(function () {
    $(&quot;input&quot;).click(function () {
        $(&quot;.box&quot;).load(
            &quot;./data.json&quot;,
            function (response,status) {
                console.log(data.name);
            }
        );
    });
})

......
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;input type=&quot;button&quot; value=&quot;xinzhi&quot;&amp;gt;
        &amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回的数据会放置在div中；&lt;/li&gt;
&lt;li&gt;不能跨域访问数据；&lt;/li&gt;
&lt;li&gt;response为返回的数据，status为请求的状态；&lt;/li&gt;
&lt;li&gt;无请求失败的回调函数。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;getjson&quot;&gt;4. getJSON()&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;方法使用 AJAX 的 HTTP GET 请求获取 JSON 数据。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;url: 请求网址，必须的参数；&lt;/li&gt;
&lt;li&gt;data: 发送给服务器的数据；&lt;/li&gt;
&lt;li&gt;function(data,status,xhr):请求成功的回调函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$(function () {
    $(&quot;input&quot;).click(function () {
        $.getJSON(
            &quot;./data.json&quot;,
            function(data,status) {
                console.log(data.name);
            },
        );
    
    });
})

......
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;input type=&quot;button&quot; value=&quot;xinzhi&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;方法直接获取的是json数据；&lt;/li&gt;
&lt;li&gt;无返回失败的回调函数；&lt;/li&gt;
&lt;li&gt;回调函数时命名函数，不是匿名函数；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;getscript&quot;&gt;5. getScript()&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;方法使用 AJAX 的 HTTP GET 请求获取并执行js代码。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;url: 请求网址，必须的参数；&lt;/li&gt;
&lt;li&gt;function(data,status):请求成功的回调函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$(function () {
    $(&quot;input&quot;).click(function () {
        $.getScript(
            &quot;./data.js&quot;,
            function(data,status) {
                console.log(data);
            },
        );
    
    });
})

......
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;input type=&quot;button&quot; value=&quot;xinzhi&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回结data是js代码；&lt;/li&gt;
&lt;li&gt;该方法可以用来动态加载js代码。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二jsonp&quot;&gt;二、jsonp&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;定义：一种可以实现跨域发送http请求的数据通信格式，可以嵌在ajax中使用。&lt;/li&gt;
&lt;li&gt;原理：利用script标签可以跨域链接资源的特性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;用法一函数传参&quot;&gt;用法一：函数传参&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    function aa(data){
        console.log(data.name);
    }
&amp;lt;/script&amp;gt;

&amp;lt;script type=&quot;text/javascript&quot; src=&quot;....../data.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;说明在外部定义一个data.js文件这个文件的路径可以与当前页面不在同一个域下面&quot;&gt;说明：在外部定义一个data.js文件，这个文件的路径可以与当前页面不在同一个域下面。&lt;/h5&gt;
&lt;p&gt;data.js的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aa({
    
    &quot;data&quot;:{
        &quot;name&quot;:&quot;xiaohong&quot;,
        &quot;age&quot;:&quot;18&quot;
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用法二利用ajax&quot;&gt;用法二：利用ajax&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;$.ajax({
    url:'...../data.js',//可以不是本地域名 
    type:'get',
    dataType:'jsonp',  //jsonp格式访问
    jsonpCallback:'aa'  //获取数据的函数
})
.done(function(data){
    console.log(data.name);
})
.fail(function() {
    alert('服务器超时，请重试！');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;data.js的内容和上面一样。&lt;/li&gt;
&lt;li&gt;使用ajax的方法本质上也是script标签可以跨域链接资源，不过jquery为其封装了相同的方法，看起来一样。&lt;/li&gt;
&lt;li&gt;以上代码的执行过程为：ajax通过jsonp技术跨域访问data.js文件，通过找到aa()方法将其参数传递给.done方法的data参数执行.done方法。&lt;/li&gt;
&lt;li&gt;目前这种方式仍然有其局限性，就是必须知道data.js文件的名字和定义的方法aa，如果在仅仅知道域名的情况下，需要另外的方法.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;用法三&quot;&gt;用法三&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;var $input = $(&quot;input&quot;);
$input.keyup(function () {
    $.ajax({
        url:'https://sug.so.360.cn/suggest?',//请求360搜索的联想数据
        type:'get',
        dataType:'jsonp',  //jsonp格式访问
        data: {word: $input.val()},
    })
    .done(function(data){
        console.log(data);
    })
    .fail(function() {
        alert('服务器超时，请重试！');
    });
})

....
&amp;lt;body&amp;gt;
    &amp;lt;input type=&quot;text&quot;&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过浏览器查看每次输入关键字服务器发送回的数据包，找到js文件中header的地址以及相关的提交数据，发现key为word关键字，因此可以向服务器发送data数据。&lt;/li&gt;
&lt;li&gt;服务器返回的数据会自动传给回调的匿名函数的参数data.&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 14 Oct 2017 14:51:00 +0000</pubDate>
<dc:creator>天宇之游</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwp-bg/p/7668840.html</dc:identifier>
</item>
<item>
<title>【记录一次windows技术学习】使用笔记本DOS命令搭建WLAN热点 - AK末影人</title>
<link>http://www.cnblogs.com/akenderman/p/7668901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/akenderman/p/7668901.html</guid>
<description>&lt;p&gt;时间：2017-10-14　　22:36:13　　撰写者：AK末影人　　【转发请注明出处】&lt;/p&gt;
&lt;p&gt;————————————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;首先需要进入windows系统下的CMD命令提示符，当然，这里必须是在管理员权限下运行。&lt;/p&gt;
&lt;p&gt;1.配置热点&lt;/p&gt;
&lt;p&gt;netsh wlan set hostednetwork mode=allow ssid=WiFi名称 key=passphrase &lt;/p&gt;
&lt;p&gt;用法: set hostednetwork [mode=]allow|disallow [ssid=]&amp;lt;ssid&amp;gt;&lt;br/&gt;                         [key=]&amp;lt;passphrase&amp;gt; [keyUsage=]persistent|temporary&lt;/p&gt;&lt;p&gt;参数:&lt;/p&gt;&lt;p&gt;    标记             值&lt;br/&gt;    mode            指定允许还是禁止托管网络。&lt;br/&gt;    ssid            托管网络的 SSID。&lt;br/&gt;    key             托管网络使用的用户安全密钥。&lt;br/&gt;    keyUsage        指定用户密钥密钥是永久性的还是临时的。&lt;/p&gt;&lt;p&gt;备注:&lt;/p&gt;&lt;p&gt;    此命令更改托管网络的属性，包括: 托管网络的 SSID、&lt;br/&gt;    允许或禁止系统中的托管网络、以及托管网络所使用的&lt;br/&gt;    用户安全密钥。&lt;/p&gt;&lt;p&gt;    用户安全密钥应&lt;span&gt;为 8 到 63 个 ASCII 字符组成的字符串&lt;/span&gt;，例如，密码，或 64 个十六&lt;br/&gt;    进制的数字(代表 32 个二进制字节)。&lt;/p&gt;&lt;p&gt;    如果将 keyUsage 指定为永久，将保存安全密钥并在将来再次启动托管网络时使用。&lt;br/&gt;    否则只有在当前或下一次启动托管网络时使用此密码。停止托管网络后，将从&lt;br/&gt;    系统中删除临时安全密钥。如果未指定 keyUsage，默认情况下，它是永久性的。&lt;/p&gt;&lt;p&gt;    &lt;span&gt;该命令需要管理员权限才能允许或禁止托管网络&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;示例:&lt;/p&gt;&lt;p&gt;    set hostednetwork mode=allow&lt;br/&gt;    set hostednetwork ssid=ssid1&lt;br/&gt;    set hostednetwork key=passphrase keyUsage=persistent&lt;/p&gt;
&lt;p&gt;2.启动热点&lt;/p&gt;
&lt;p&gt;　netsh wlan start hostednetwork&lt;/p&gt;
&lt;p&gt;　用法: start hostednetwork&lt;/p&gt;&lt;p&gt;备注:&lt;/p&gt;&lt;p&gt;    此命令请求 WLAN 服务启动承载网络。&lt;/p&gt;&lt;p&gt;    此命令要求具有管理员权限。&lt;/p&gt;&lt;p&gt;示例:&lt;/p&gt;&lt;p&gt;    start hostednetwork&lt;/p&gt;
&lt;p&gt;3.显示热点配置项&lt;/p&gt;
&lt;p&gt;netsh wlan show hostednetwork&lt;/p&gt;
&lt;p&gt;用法: show hostednetwork [[setting=]security]&lt;/p&gt;&lt;p&gt;参数:&lt;/p&gt;&lt;p&gt;    标记            值&lt;br/&gt;    setting         指定要显示的承载网络设置。&lt;/p&gt;&lt;p&gt;备注:&lt;/p&gt;&lt;p&gt;    此命令显示承载网络的属性及其状态(如果已启动)。&lt;/p&gt;&lt;p&gt;    如果指定了设置参数，则它将显示承载网络的安全算法&lt;br/&gt;    和密钥。&lt;/p&gt;&lt;p&gt;示例:&lt;/p&gt;&lt;p&gt;    show hostednetwork&lt;br/&gt;    show hostednetwork setting=security&lt;/p&gt;

</description>
<pubDate>Sat, 14 Oct 2017 14:49:00 +0000</pubDate>
<dc:creator>AK末影人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/akenderman/p/7668901.html</dc:identifier>
</item>
<item>
<title>详解面向对象编程——JavaScriptOOP - Realsdg</title>
<link>http://www.cnblogs.com/realsdg/p/7668896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/realsdg/p/7668896.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    前  言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;絮叨絮叨&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　学习了JS之后，不知道大家觉得怎们样呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　今天我们就来讲一下JS中最重要的一个环节，JavaScript中的面向对象编程OOP，这里的东西有点难，也有点绕。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　可是！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　不要灰心，现在我么就一起来学习一下吧。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、 OOP基础&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1.1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;什么是面向对象编程&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;1、语言的分类：&lt;br/&gt;　　① 面向机器：汇编语言&lt;br/&gt;　　② 面向过程：C语言&lt;br/&gt;　　③ 面向对象：C++ Java PHP等&lt;br/&gt;2、面向过程于面向对象&lt;br/&gt;　　① 面向过程：专注于如何去解决一个问题的过程步骤。编程特点是由一个个的函数实现每一步的过程步骤，没有类和对象的概念。&lt;br/&gt;　　② 面向对象：专注于由哪一个对象来解决这个问题。编程特点是出现了一个个的类，从类中拿到对象，由这个对象去解决这个问题。&lt;br/&gt;　　&lt;br/&gt;　　&lt;br/&gt;　　对于调用者来说，面向过程需要调用者自己去实现各种函数，&lt;br/&gt;　　而面向对象，只需要告诉调用者对象对象中具体方法的功能，而不需要调用者了解方法中的实现细节&lt;br/&gt;　　&lt;br/&gt;　　&lt;strong&gt;[面向对象的三大特征] ：&lt;/strong&gt;&lt;span&gt;继承&lt;/span&gt;、&lt;span&gt;封装&lt;/span&gt;、&lt;span&gt;多态&lt;/span&gt;&lt;br/&gt;　　JS可以模拟实现继承和封装，但是无法模拟实现多态，所以我们说JS是一门基于对象的语言，而并非是面向对象的语言！&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1.2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;类和对象&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;1、类：一类具有相同特征（属性）和行为（方法）的集合。&lt;br/&gt;　　eg：人类 --&amp;gt; 属性：身高、体重、性别；方法：吃饭、说话、走路&lt;/p&gt;&lt;p&gt;2、对象：从类中拿出具有确定属性值和方法的个体叫做对象&lt;br/&gt;　　eg：张三 --&amp;gt; 属性：身高180体重180 ； 方法：说话 --&amp;gt;我叫张三，身高180&lt;/p&gt;&lt;p&gt;3、类和对象的关系：&lt;br/&gt;　　类是抽象的，对象是具体的（类是对象的抽象化，对象是类的具体化）&lt;/p&gt;&lt;p&gt;　　类是一个抽象的概念，只能说类有属性和方法，但是不能给属性赋具体的值。&lt;br/&gt;　　比如，人类有姓名，但是不能说人类的姓名叫什么。&lt;/p&gt;&lt;p&gt;　　对象是一个具体的个例，是将类中的属性进行具体赋值而来的个体。&lt;br/&gt;　　比如，张三是人类的一个个体，可以说张三的姓名叫张三。&lt;br/&gt;　　也就是张三对人类的每一个属性进行了具体的赋值，那么张三就是有人类产生的一个对象&lt;br/&gt;　　&lt;br/&gt;4、使用类和对象的步骤：&lt;br/&gt;① 创建一个类(构造函数)：类名必须使用大驼峰法则。即每个单词首字母都要大写&lt;/p&gt;
&lt;p&gt;② 通过类，实例化(new)出一个对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function 类名(属性1){
    this.属性1 = 属性1；
    this.方法 = function(){
        //方法中要调用自身属性，必须使用this.属性
    }
}

var obj = new 类名(属性1的具体值);
obj.属性;   //调用属性
obj.方法;   //调用方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 注意事项：&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;通过类名，new出一个对象的过程，叫做“累的实例化”&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;类中的this，会在实例化的时候指向新new出的对象。&lt;br/&gt;　　所以，this.属性 this.方法 实际上是将属性和方法绑定在即将new出的对象上面。&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;在类中，要调用自身属性必须this.属性名。如果直接使用变量名，则无法访问对应的属性。&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;类名必须使用大驼峰法则，注意与普通函数区分。&lt;/p&gt;

&lt;p&gt;5、两个重要属性：&lt;br/&gt;　　① constructor：返回当前对象的构造函数。&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;zhangsan.contructor == Person;&lt;/span&gt; √&lt;/p&gt;&lt;p&gt;　　②instanceof：检测一个对象，是不是一个类的实例&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;lisi instanceof Person&lt;/span&gt;                 √ lisi是通过Person类new出的&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;lisi instanceof Person&lt;/span&gt;                 √ 所有对象都是Object的实例&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;Person instanceof Object&lt;/span&gt;           √ 函数本事也是对象&lt;/p&gt;

&lt;p&gt;6、广义对象与狭义对象;&lt;br/&gt;　　① 狭义对象：只有属性和方法，除此之外没有任何其他内容。&lt;br/&gt;　　&lt;span&gt;var obj = {}&lt;/span&gt;    &lt;span&gt;var obj = new Object();&lt;/span&gt;&lt;br/&gt;　　② 广义对象：除了用字面量声明的基本数据类型之外，JS中万物皆对象。换句话说，只要能够添加属性和方法的变量，都可以称之为对象&lt;/p&gt;

&lt;p&gt;以下是两个小栗子：&lt;/p&gt;
&lt;p&gt;第一个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var s = &quot;123&quot;;              //不是对象
s.name = &quot;aaa&quot;;
console.log(typeof(s));     //String
console.log(s.name);        //undefined 字面量声明的字符串不是对象，不能添加属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 第二个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var s = new String(&quot;123&quot;);   //是对象
s.name = &quot;aaa&quot;;
console.log(typeof(s));     //Object
console.log(s.name);        //&quot;aaa&quot; 使用new声明的字符串不是对象，可以添加属性和方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr/&gt;
&lt;p&gt;以下是创建一个类的小栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name,age){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; age;
            
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.say &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(content){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在类中访问类自身的属性，必须使用this.属性调用&lt;/span&gt;
&lt;span&gt;        alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我叫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，今年&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;岁啦！我说了一句话：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;content);
    }
    }        
        
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; zhangsan &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;);
    zhangsan.say(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;哈哈哈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201710/1207874-20171014215143309-450517154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、 成员属性和静态属性和私有属性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2.1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;成员属性和成员方法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;在构造函数中，总使用this.属性声明。或者在实例化出对象以后使用“对象.属性”追加的，都属于成员属性或成员方法也叫实例属性和实例方法；&lt;/li&gt;
&lt;li&gt;成员属性/方法，是属于由类new出的对象的。&lt;/li&gt;
&lt;li&gt;需要使用“对象名.属性名”调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2.2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;静态属性与静态方法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;通过“类名.属性名”、“类名.方法名”声明的属性和方法，称为静态属性、静态方法，也叫类属性和类方法；&lt;/li&gt;
&lt;li&gt;类属性/类方法，是属于类的（属于构造函数）&lt;/li&gt;
&lt;li&gt;通过“类名.属性名”调用&lt;/li&gt;
&lt;li&gt;成员属性是属于实例化出的对象的，只能使用对象调用。&lt;/li&gt;
&lt;li&gt;静态属性是属于构造函数的，只能使用类名调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2.3&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;私有属性和私有方法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;在构造函数中，使用var声明的变量，私有属性；&lt;/li&gt;
&lt;li&gt;在构造函数中，使用function声明的函数，称为私有方法；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Person(){
    var num = 1;  //私有属性
    function func(){}  //私有方法
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;私有属性和私有方法的作用域，只在构造函数内容有效。即，只能在构造函数内部使用，在构造函数中，无论使用对象名还是类名都无法调用&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;以下是一个小栗子，简单粗暴的说明各种属性和方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name){
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; name;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明成员属性&lt;/span&gt;
            
       &lt;span&gt;var&lt;/span&gt;&lt;span&gt; sex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(sex);&lt;/span&gt;

       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sayTime &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
           alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我说的当前时间是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;getTime());
       }
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.writeTime &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
           alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我写的当前时间是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;getTime());
       }
       &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getTime(){
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
       }
　　}
        
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; zhangsan &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    zhangsan.age &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;追加成员属性&lt;/span&gt;
&lt;span&gt;    alert(zhangsan.name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用成员属性&lt;/span&gt;
&lt;span&gt;        
    Person.count &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;60亿&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明静态属性&lt;/span&gt;
&lt;span&gt;    alert(Person.count);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用静态属性&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; lisi &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    console.log(lisi.count);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Undefined 静态属性是属于类的，只能用类名调用&lt;/span&gt;
&lt;span&gt;        
    console.log(lisi.sex);
    console.log(Person.sex);
        
        
    lisi.sayTime();
    lisi.writeTime();
        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;alert(Person.name);  //系统自带成员属性名&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、 用JS模拟实现封装&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;1、什么叫封装？&lt;br/&gt;　　① 方法的封装：将内部的函数进行私有化处理，不对外提供调用接口，无法在类外部使用的方法，称为私有方法，即方法的封装。&lt;br/&gt;　　② 属性的封装：将类中的属性进行私有化处理，对外不能直接使用对象名访问(私有属性)。&lt;br/&gt;　　同时需要提供专门用于设置和读取私有属性的set/get方法，让外部使用我们提供的方法，对属性进行操作。这就叫属性的封装。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;2、注意封装不是拒绝访问，而是限制访问。要求使用者，必须使用我们提供的set/get方法进行属性操作，而不是直接拒绝操作。&lt;br/&gt;　　因此，单纯的属性私有化，不能称之为封装！必须要私有化之后，提供对应的set/get方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; age &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setAge &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ages){
        age &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; ages;
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getAge &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * 私有化的方法
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getTime(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
    }
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、 JS中的this指向&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;1、谁最终调用函数，this就指向谁！&lt;br/&gt;　　① this指向谁，不应该考虑函数在哪声明，而应该考虑函数在哪调用！！！&lt;br/&gt;　　② this指向的永远只可能是对象，而不可能是函数！！！&lt;br/&gt;　　③ this指向的对象，叫做函数的上下文context，也叫函数的调用者。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;2、this指向的规律！！！(跟函数的调用方式息息相关！)&lt;strong&gt;【this指向五大准则】&lt;/strong&gt;&lt;br/&gt;　　① 通过函数名()调用的，this永远指向window&lt;br/&gt;　　② 通过 对象.方法 调用的，this永远指向对象&lt;br/&gt;　　③ 函数作为数组中的一个元素，用数组下标调用的，this指向这个数组&lt;br/&gt;　　④ 函数作为window内置函数的回调函数使用，this指向window&lt;br/&gt;　　　　setInterval setTimeout 等&lt;br/&gt;　　⑤ 函数作为构造函数，使用new关键字调用，this指向新new出的对象。&lt;/p&gt;

&lt;p&gt;如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; func(){
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;func();&lt;/span&gt;

   &lt;span&gt;var&lt;/span&gt;&lt;span&gt; obj &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        name : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        func : func
   }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;通过函数名()调用的，this永远指向window&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   func();&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;通过 对象.方法 调用的，this永远指向对象&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   obj.func();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;狭义对象&lt;/span&gt;
&lt;span&gt;            
   window.onclick &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;   　　//&lt;/span&gt;&lt;span&gt;document.getElementById(&quot;div1&quot;).onclick = function(){&lt;/span&gt;&lt;span&gt;
　　　　　　//&lt;/span&gt;&lt;span&gt;func(); //最终还是使用func()调用，所以指向window&lt;/span&gt;&lt;span&gt;
　　　　//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;       document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).onclick &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; func; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;广义对象&lt;/span&gt;
&lt;span&gt;   }

   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;函数作为数组中的一个元素，用数组下标调用的，this指向这个数组&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;var&lt;/span&gt;&lt;span&gt; arr &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,func,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;];
   arr[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]();

   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;函数作为window内置函数的回调函数使用，this指向window&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   setTimeout(func,&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
            
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;函数作为构造函数，使用new关键字调用，this指向新new出的对象。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; objs &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; func();
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、 原型与原型链&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;5.1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;__proto__ 与 prototype&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;1、prototype：函数的原型对象&lt;br/&gt;　　① 只有函数才有prototype,而且所有函数必然有prototype&lt;br/&gt;　　② prototype本身也是一个对象！&lt;br/&gt;　　③ prototype指向了当前函数所在的引用地址&lt;/p&gt;&lt;p&gt;2、__proto__：对象的原型！&lt;br/&gt;　　① 只有对象才有__proto__，而且所有对象必然有__proto__&lt;br/&gt;　　② __proto__也是一个对象，所以也有自己的__proto__，顺着这条线向上找的顺序，就是原型链&lt;br/&gt;　　③ 函数、数组都是对象，都有自己的__proto__&lt;/p&gt;&lt;p&gt;3、实例化一个类，拿到对象的原理？&lt;br/&gt;　　实例化一个类的时候，实际上是将新对象的__proto__，指向构造函数所在的prototype&lt;/p&gt;&lt;p&gt;　　也就是说：zhangsan.__proto__ == Person.prototype √&lt;br/&gt;　　&lt;br/&gt;4、所有对象的__proto__延原型链向上查找，都将指向Object的prototype。&lt;br/&gt;　　Object的prototype的原型，指向null&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;5.2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;原型链的指向问题&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;研究原型链的指向，就是要研究各种特殊对象的__proto__的指向问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【原型链指向四大准则】&lt;/strong&gt;&lt;br/&gt;1、通过构造函数，new出的对象。新对象的__proto__指向构造函数的prototype&lt;br/&gt;2、函数的__proto__，指向Function()的prototype&lt;br/&gt;3、函数的prototype的__proto__指向Object的prototype&lt;br/&gt;　　(直接使用{}字面声明，或使用new Object拿到的对象的__proto__直接指向Object的prototype)&lt;br/&gt;4、Object的prototype的__proto__，指向null&lt;br/&gt;　　(Object作为一个特殊函数，它的__proto__指向Function()的prototype)&lt;/p&gt;

&lt;p&gt;以下有一个小栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Person(){
}
var zhangsan = new Person();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201710/1207874-20171014223552918-400774733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六、 原型属性与原型方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;1、成员属性与成员方法：&lt;br/&gt;　　&lt;span&gt;this.name = &quot;&quot;; this.func = function(){}&lt;/span&gt;&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;属于实例化出的新对象，使用 对象.属性 调用&lt;br/&gt;　　&lt;br/&gt;2、静态属性与静态方法：&lt;br/&gt;　　&lt;span&gt;Person.name = &quot;&quot;; Person.func = function(){}&lt;/span&gt;&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;属于类的，用类名.属性调用&lt;br/&gt;　　&lt;br/&gt;3、私有属性与私有方法：&lt;br/&gt;　　在构造函数中，使用var声明属性，使用function声明方法&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;只在类内部能够使用，外部无法使用任何方式调用。&lt;br/&gt;　　&lt;br/&gt;4、原型属性与原型方法：&lt;br/&gt;　　&lt;span&gt;Person.prototype.name = &quot;&quot;;&lt;/span&gt;&lt;br/&gt;　　&lt;span&gt;Person.prototype.func = function(){}&lt;/span&gt;&lt;br/&gt;　　&amp;gt;&amp;gt;&amp;gt;将属性或方法写到类的prototype上，在实例化的时候，这些属性和方法会进入到新对象的__proto__上，就可以使用对象名调用。&lt;br/&gt;　　&lt;br/&gt;　　也就是说，1和4使用对象名访问，2使用类名访问，3只能在函数内部使用&lt;br/&gt;　　&lt;br/&gt;5、当访问对象的属性或方法时，会优先使用对象自身上的成员属性和成员方法。&lt;br/&gt;　　如果没有找到，则使用__proto__上面的原型属性很原型方法。如果依然没有继续延原型链查找，最后返回Undefined&lt;br/&gt;　　&lt;br/&gt;6、习惯上，我们会将属性写为成员属性，讲方法定义为原型方法：&lt;br/&gt;　　例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Person(){
    this.name = &quot;张三&quot;;
}
Person.prototype.say = function(){}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　原因：&lt;br/&gt;　　　　① 原型属性在定义后不能改变，无法在实例化是进行赋值。所以属性不能使用原型属性。&lt;br/&gt;　　　　　　但是方法，写完以后基本不用改变，所以，方法可以使用原型方法。&lt;br/&gt;　　　　② 实例化出对象后，属性全在对象上，方法全在原型上，结构清晰。&lt;br/&gt;　　　　③ 使用for-in遍历对象时，会将方法和属性全部打印出来。&lt;br/&gt;　　　　　　而方法往往不需要展示，那么讲方法写在原型上，就可以使用hasOwnProperty将原型方法过滤掉&lt;br/&gt;　　　　④ 方法写到prototype上，将更加节省内存。&lt;br/&gt;　　　　⑤ 官方都这么写。&lt;br/&gt;　　&lt;br/&gt;7、通过prototype扩展系统内置函数的原型方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name){
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; name;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成员属性&lt;/span&gt;
       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; num &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有属性&lt;/span&gt;
&lt;span&gt;   }
   Person.count &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;60亿&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态属性&lt;/span&gt;
&lt;span&gt;   Person.prototype.age &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原型属性 &lt;/span&gt;
            
   &lt;span&gt;var&lt;/span&gt;&lt;span&gt;  zhangsan &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
   console.log(zhangsan);
            
            
   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   * 通过prototype扩展系统内置函数的原型方法
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给数组添加一个遍历打印所有值的方法&lt;/span&gt;
&lt;span&gt;   Array.prototype.eachAll &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;i&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;){
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;[i]);
        }
   }
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; arr &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;];
   arr.eachAll();
            
   String.prototype.addAbc &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
   }
   console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.addAbc());
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;七、 实现继承的三种办法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;继承：使用一个子类继承一个父类，那么子类可以自动拥有父类中的所有属性和方法，这个过程叫做继承&lt;br/&gt;　　　　&amp;gt;&amp;gt;&amp;gt;继承的方法，发生在两个类之间。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;7.1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;扩展Object&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;br/&gt;1、扩展Object实现继承&lt;br/&gt;　　① 声明一个父类：&lt;span&gt;function Person(){}&lt;/span&gt;&lt;br/&gt;　　声明一个子类：&lt;span&gt;function Son(){}&lt;/span&gt;&lt;br/&gt;　　② 通过prototype给Object类添加一个扩展方法：&lt;br/&gt;　&lt;br/&gt;　　③ 分别拿到父类对象和子类对象：&lt;br/&gt;　　　　&lt;span&gt;var p = new Person();&lt;/span&gt;&lt;br/&gt;　　　　&lt;span&gt;var s = new Student();&lt;/span&gt;&lt;br/&gt;　　④ 用子类对象，调用扩展方法，实现继承操作；&lt;br/&gt;　　　　&lt;span&gt;s.extend(p);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、实现继承的原理：&lt;br/&gt;　　通过循环将父类对象的所有属性和方法全部赋给子类对象。关键点在于for-in循环，及时不扩展Object，也能通过简单的循环实现操作&lt;br/&gt;3、扩展Object继承的缺点：&lt;br/&gt;　　① 无法通过一次实例化，直接拿到完整的子类对象。而需要先拿到父类和子类对象两个对象，再手动合并&lt;br/&gt;　　② 扩展Object的继承方法，也会保留在子类的对象上。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name,age){
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; name;
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; age;
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.say &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
           alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我叫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
       }
    }
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Student(no){
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.no &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; no;
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.study &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
           alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我在学习！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
       }
    }
            
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            var p = new Person(&quot;张三&quot;,12);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            var s = new Student(&quot;1234567&quot;);            &lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            for(var i in p){&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;                s[i] = p[i];&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            }&lt;/span&gt;
&lt;span&gt;

   Object.prototype.extend1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(parent){
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; parent){
           &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;[i] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; parent[i];
       }
   }
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; p &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234567&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);    
   s.extend1(p);
            
   console.log(s);
            
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;7.2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;使用原型继承&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;


&lt;p&gt;1、使用原型实现继承&lt;br/&gt;　　① 定义父类：&lt;span&gt;function Person(){}&lt;/span&gt;&lt;br/&gt;　　　 定义子类：&lt;span&gt;function Son(){}&lt;/span&gt;&lt;br/&gt;　　② 将父类对象，赋值给子类的prototype&lt;br/&gt;　　　　&lt;span&gt;Son.prorotype = new Person();&lt;/span&gt;&lt;br/&gt;　　③ 拿到子类对象时，就会将父类对象的所有属性和方法，添加到__proto__&lt;br/&gt;　　　　&lt;span&gt;var s = new Son();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、使用原型继承的原理&lt;br/&gt;　　将父类对象，赋值给子类的prototype，那么父类对象的属性和方法就会出现在子类的prototype中，&lt;br/&gt;　　那么，实例化子类时，子类的prototype又会到子类对象的__proto__中，父类对象的属性好方法，会出现在子类对象的__proto__中。&lt;br/&gt;3、这种继承的特点：&lt;br/&gt;　　① 子类自身的所有属性，都是成员属性；父类继承过来的的属性，都是原型属性&lt;br/&gt;　　② 依然无法通过一部实例化拿到完成的子类对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name,age){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; name;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; age;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.say &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我叫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
      }
   }
   &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Student(no){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.no &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; no;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.study &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
         alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我在学习！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      }
   }
   Student.prototype &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;);
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            
   console.log(s);
            
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;7.3&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;使用call和apply和bind&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; [call/bind/apply]&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、三个函数的作用：通过函数名调用这三个函数，可以强行将函数中的this指定为某个对象&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;2、三个函数的写法(区别)：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　call写法：使用func.call(func的this指向的obj，func参数1，func参数2，...);&lt;br/&gt;　　apply写法：使用func.call(func的this指向的obj，[func参数1，func参数2，...]);&lt;br/&gt;　　bind写法：使用func.call(func的this指向的obj)(func参数1，func参数2，...);&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;3、三个函数的唯一区别，在于接受func的参数列表的方式不同，除此之外，功能上没有任何差异！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用call/bind/apply实现继承&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;1、 定义父类：function Parent(name){}&lt;br/&gt;　　定义子类：定义子类时，在子类中使用三个函数，调用父类，将父类函数的this，指向为子类函数的this&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;2、实例化子类时，将自动继承父类属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name,age){
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; name;
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; age;
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.say &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我叫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
       }
    }
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Student(no,name,age){
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.no &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; no;
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.study &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
           alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我在学习！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
       }
       Person.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,name,age);
    }
            
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student(&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;);
    console.log(s);

&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;八、 闭包&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;JS中的作用域&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、全局变量：函数外声明的变量称为全局变量；&lt;br/&gt;　　局部变量：函数内部使用var声明的变量，称为局部变量；&lt;br/&gt;　　&lt;br/&gt;　　 在JS中之中有函数作用域，没有块级作用域！也就是说，if/for等有{}的结构体，并不能具备自己的作用域。&lt;br/&gt;　　&lt;br/&gt;　　 所以，函数外部不能访问函数内部的局部变量(私有属性)。因为函数内部的变量,在执行完毕以后,就会被释放掉。&lt;br/&gt;　　&lt;br/&gt;2、使用闭包，可以访问函数的私有变量！&lt;br/&gt;　　JS中，提供了一种“闭包”的概念：在函数内部，定义一个子函数，子函数可以访问副函数的私有变量。&lt;br/&gt;　　可以在子函数中进行操作，最后将子函数通过return返回。&lt;/p&gt;
&lt;p&gt;3、闭包的作用：&lt;br/&gt;　　① 可以在函数外部访问函数的私有变量；&lt;br/&gt;　　② 让函数内部的变量，可以始终存在于内存中，不会在函数调用完成后立即释放。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; func1(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; num &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func2(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func2;
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; num &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; func1()();
    console.log(num);
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 14 Oct 2017 14:48:00 +0000</pubDate>
<dc:creator>Realsdg</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/realsdg/p/7668896.html</dc:identifier>
</item>
<item>
<title>帧同步-自动化战斗测试流程 - 那个少年</title>
<link>http://www.cnblogs.com/lijiajia/p/7668878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiajia/p/7668878.html</guid>
<description>&lt;h2 id=&quot;自动化测试&quot;&gt;自动化测试&lt;/h2&gt;
&lt;p&gt;我们游戏的战斗测试同步问题比较麻烦，每次改动了战斗（主动技能、被动技能、BUFF、怪物等等）都需要开多个号测试一遍战斗流程，非常耗费人力&lt;/p&gt;
&lt;h2 id=&quot;原来的测试流程&quot;&gt;原来的测试流程&lt;/h2&gt;
&lt;p&gt;1.需要多个人用多台手机打战斗，&lt;br/&gt;2.开启帧同步日志&lt;br/&gt;3.战斗结束后，会根据各个玩家的数据的一致性来判断这场战斗是否是同步的&lt;br/&gt;4.如果发现有不同步的玩家，则需要把客户端输出的日志文件（在手机上或者模拟器上）发给技术人员排查问题&lt;/p&gt;
&lt;p&gt;这样的流程打几次往往一个下午就过去了，收集日志文件也比较耗时，需要把手机连接到电脑上，拷贝出来，用QQ发给技术人员排查。&lt;/p&gt;
&lt;p&gt;所以我们要优化一下这个流程，把机器能干的事情，都交给机器去做，让机器来节省人的工作量&lt;/p&gt;
&lt;h2 id=&quot;自动化测试流程&quot;&gt;自动化测试流程&lt;/h2&gt;
&lt;p&gt;1.需要多台手机打战斗，但只需要1个人在不同手机上登陆不同账号，开启自动测试模式&lt;br/&gt;2.服务端开启一个守护进程，每秒检测一次开启自动测试的玩家队列，把条件允许的玩家队伍拉进战斗&lt;br/&gt;3.客户端战斗开启自动AI&lt;br/&gt;4.战斗结束后，客户端输出帧日志，通过HTTP协议自动上传到日志收集服务器&lt;br/&gt;5.玩家退出战斗场景，加载主场景完毕后，又符合了第2点条件，继续被服务器拉入战斗，形成战斗循环&lt;/p&gt;
&lt;p&gt;这样我们可以开几个号，挂一个晚上，打他个几百把战斗，然后第二天早上来看战斗日志服务器上，有多少把不同步？直接可以查看不同步的日志文件分析问题&lt;/p&gt;
&lt;p&gt;后期还可以加入一些数据分析：比如战斗平均帧率、网络延迟、内存、CPU峰值等一些性能数据&lt;/p&gt;
&lt;p&gt;下面贴一些简单的上传文件实现原理，怕忘了以后还可以回头看看~&lt;/p&gt;
&lt;h2 id=&quot;unity中post上传文件到php端&quot;&gt;Unity中POST上传文件到PHP端&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;using UnityEngine;
using System.Collections;
using System.IO;
using System.Text;
using UnityEngine.Networking;

public class UpLoad : MonoBehaviour
{
    void Start () 
    {
            byte[] bytes = Encoding.UTF8.GetBytes(&quot;日志内容&quot;);//这里写文件的二进制，先用测试文本代替

            string url = &quot;http://localhost/UploadFightLog.php&quot;;
            WWWForm form = new WWWForm ();
            form.AddField(&quot;logName&quot;, &quot;123_战士.txt&quot;, Encoding.UTF8);
            form.AddBinaryData (&quot;fightLog&quot;, bytes);
            WWW www = new WWW (url,form);
            StartCoroutine (PostData (www));
    }


    IEnumerator PostData(WWW www)  
        {  
            yield return www;
            Debug.Log(www.text);
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在php端接收&quot;&gt;在PHP端接收&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
/*
    用于接受自动战斗测试的日志文件
    文件名格式：战斗ID_玩家名.txt
    此文件会自动以战斗ID创建父文件夹
    将日志文件存在对应战斗ID的文件夹下方便查找
    by lijia
*/
    if ($_FILES[&quot;fightLog&quot;][&quot;error&quot;] &amp;gt; 0)
    {
        echo &quot;0&quot;;
    }
    else
    {
        $f_name = iconv('utf-8','gb2312',$_POST[&quot;logName&quot;]);//转换编码格式解决乱码问题
        
        $fightID_splt = explode('_',$f_name);//分割字符串，把战斗ID取出来
        $fightID = $fightID_splt[0];
        $dir_path = &quot;AutoFightLog/&quot;.$fightID;
        
        if (!file_exists($dir_path)){
            mkdir ($dir_path,0777,true);
        }

        $f_path = $dir_path.&quot;/&quot;.$f_name;
        
        if (file_exists($f_path))
        {
            unlink($f_path);//已经存在就先删除再创建
        }
        
        move_uploaded_file($_FILES[&quot;fightLog&quot;][&quot;tmp_name&quot;], $f_path);
        echo &quot;1&quot;;
    }
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意一下如果有中文文件名的话，会出现乱码问题，所以要转换一些编码格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        $f_name = iconv('utf-8','gb2312',$_POST[&quot;logName&quot;]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实工作中还有很多繁琐的流程，重复的流程，是可以用机器代替的&lt;/p&gt;
&lt;p&gt;用代码改变世界，虽然我们暂时还改变不了整个世界，但至少还可以改变一下身边的世界~&lt;/p&gt;
</description>
<pubDate>Sat, 14 Oct 2017 14:42:00 +0000</pubDate>
<dc:creator>那个少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijiajia/p/7668878.html</dc:identifier>
</item>
<item>
<title>学习Ajax - 法克大叔叔</title>
<link>http://www.cnblogs.com/cjw-ryh/p/7663797.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjw-ryh/p/7663797.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.XHR对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        IE7+、Firefox、Opera、Chrome和Safari都支持原生XMLHttpRequest对象，IE6不支持，只支持ActiveXObject对象，该对象在IE11中已经不再支持了。&lt;/p&gt;
&lt;p&gt;IE中有三种不同版本的XHR对象MSXML2.XMLHTTP、MSXML2.XMLHTTP.3.0、MSXML2.XMLHTTP.6.0，所以可以通过一下函数创建一个兼容所有浏览器的XHR：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createXHR() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; XMLHttpRequest != &quot;undefined&quot;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; ActiveXObject != &quot;undefined&quot;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; arguments.callee.activeXString != &quot;string&quot;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; versions = [&quot;MSXML2.XMLHttp.6.0&quot;,&quot;MSXML2.XMLHttp.3.0&quot;,&quot;MSXML2.XMLHttp&quot;&lt;span&gt;],i,len;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(i=0,len=versions.length; i&amp;lt;len; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActiveXObject(versions[i]);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     arguments.callee.activeXString =&lt;span&gt; versions[i];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ex){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳过&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActiveXObject(arguments.callee.activeXString);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;No XHR object available.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者简洁一点的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(window.XMLHttpRequest != 'undefined'&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      &lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(window.ActiveXObject != 'undefined'&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;       &lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt; ActiveXObject('Microsoft.XMLHTTP'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以达到兼容ie的效果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.XHR用法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       &lt;/strong&gt; 创建完XHR对象后可通过open方法启用一个请求，传入三个参数请求方法、url、是否异步（默认true）。调用完open方法后，请求并没有被发送，需要通过send（）方法发送，发送时可附带一些请求数据，无需附带数据时传入null。通过readystatechange事件监听请求状态和http状态。通过responseText获取响应信息，或者通过responseType来设置响应信息的类型直接通过response属性获得响应数据来进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        请求方式有两种GET、POST，get方式用于向服务器请求一些数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; btn = document.getElementById('btn'&lt;span&gt;);
        btn.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(window.XMLHttpRequest != 'undefined'&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(window.ActiveXObject != 'undefined'&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt; ActiveXObject('Microsoft.XMLHTTP'&lt;span&gt;);
            }
            xhr.onreadystatechange &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200&lt;span&gt;){
                    alert(xhr.responseText);
                }
            }

            xhr.open(&lt;/span&gt;&quot;GET&quot;,'data.txt',&lt;span&gt;true&lt;/span&gt;&lt;span&gt;); //获取data.txt
            xhr.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;readyState为请求的状态码，每次状态变化都会触发readystatechange事件，通过监听该事件来判断是否成功收到响应。&lt;/p&gt;
&lt;p&gt;0：未初始化&lt;/p&gt;
&lt;p&gt;1：启用，调用了open方法&lt;/p&gt;
&lt;p&gt;2：发送数据，调用了send&lt;/p&gt;
&lt;p&gt;3：接收数据，但未完全接收&lt;/p&gt;
&lt;p&gt;4：数据接收完毕，可以使用&lt;/p&gt;
&lt;p&gt;当状态码为4的时候，服务器响应就完成了，但此时只是完成了响应，数据是否可用还要通过http的状态吗status来判断：&lt;/p&gt;
&lt;p&gt;1xx：信息，服务器收到请求&lt;/p&gt;
&lt;p&gt;2xx：成功，操作被成功接收并处理&lt;/p&gt;
&lt;p&gt;3xx：重定向，需要进一步操做以完成请求&lt;/p&gt;
&lt;p&gt;4xx：客户端错误，（404）请求资源地址不正确&lt;/p&gt;
&lt;p&gt;5xx：服务器错误&lt;/p&gt;
&lt;p&gt;当状态码为200是，则成功收到响应数据，所以只需判断status==200&amp;amp;&amp;amp;readyState==4就可以了。&lt;/p&gt;
&lt;p&gt;get方式也可以发送少量数据，将数据附在url上传给服务器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; btn = document.getElementById('btn'&lt;span&gt;);
        btn.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; text = encodeURIComponent(document.getElementById('active'&lt;span&gt;).value); //用encodeURIComponent对字符串进行编码，会将多余的空格等进行转码
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(window.XMLHttpRequest != 'undefined'&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(window.ActiveXObject != 'undefined'&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt; ActiveXObject('Microsoft.XMLHTTP'&lt;span&gt;);
            }
            xhr.onreadystatechange &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200&lt;span&gt;){
                    alert(xhr.responseText);
                }
            }

            xhr.open(&lt;/span&gt;&quot;GET&quot;,'test.php?active='+text,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);//将数据以键值对的形式附在url尾部，多个键值对之间用‘&amp;amp;’连接
            xhr.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; PHP：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$active&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;['active'&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$active&lt;/span&gt; == 'login'&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '{&quot;key&quot;:&quot;value&quot;}'&lt;span&gt;;
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; 'error'&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141140/201710/1141140-20171014110252949-682448790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是get请求传递的数据都在url中所以安全性不高，需要发送数据一般用post请求，将请求数据通过send发送到服务器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; btn = document.getElementById('btn'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         btn.onclick = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; text = encodeURIComponent(document.getElementById('active'&lt;span&gt;).value);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(window.XMLHttpRequest != 'undefined'&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(window.ActiveXObject != 'undefined'&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt; ActiveXObject('Microsoft.XMLHTTP'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             xhr.onreadystatechange = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    alert(xhr.responseText);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;             xhr.open(&quot;POST&quot;,'test.php',&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;&lt;span&gt;);//设置头信息，以表单的形式发送
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; str='active='+&lt;span&gt;text;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            xhr.send(str);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用post请求发送数据时，服务器并不会像处理表单一样来处理收到的数据，所以要在send之前并且在open之后要通过setRequestHeader设置头信息，告诉服务器这是表单。 &lt;span&gt;从性能角度看，post请求消耗的资源更多一点，get请求速度更快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 3.超时设定&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为XHR对象添加一个timeout属性来设置超时，当超过这个值时还未得到响应就会触发timeout事件并且会终止请求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; xhr.open(&quot;POST&quot;,'test1.php',&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; str = 'active='+&lt;span&gt;text;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             xhr.timeout = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             xhr.ontimeout = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                 alert(&quot;Request did not return in a second.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;             xhr.send(str);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;timeout属性和ontimeout事件要放在open之后send之前，不然ie会报错，并且只有ie8+支持。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.进度事件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在浏览器接收新数据期间会周期性的触发progress事件。该事件接收一个event对象，对象包含三个二外属性：lengthComputable、loaded、total，分别表示进度信息是否可用，接收到的字节数和总字节数。下面是一个通过Ajax请求图片的例子：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;button id=&quot;btn&quot;&amp;gt;获取信息&amp;lt;/button&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;div id=&quot;result&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &amp;lt;div id=&quot;picture&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 5&lt;/span&gt; btn.onclick = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建xhr对象&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; xhr;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(window.XMLHttpRequest){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         xhr = &lt;span&gt;new&lt;/span&gt; ActiveXObject('Microsoft.XMLHTTP'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; xhr.onprogress = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){//监听progress事件来显示接收进度
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     e= e ||&lt;span&gt; event;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(e.lengthComputable){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         document.getElementById('result').innerHTML = '已接收:'+e.loaded+' /'+&lt;span&gt;e.total;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; xhr.onreadystatechange = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; xhr.response;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; img = document.createElement(&quot;img&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         img.src = URL.createObjectURL(data);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个指向data的url&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         img.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            URL.revokeObjectURL(img.src);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         document.getElementById('picture'&lt;span&gt;).appendChild(img);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; xhr.open('GET','RYH.png',&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; xhr.responseType = 'blob';    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;响应数据类型为二进制数据&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; xhr.send(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &amp;lt;/script&amp;gt;    
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;这里的URL.createObjectURL(file | blob)传入一个file对象或blob（二进制对象）对象，创建一个指向该对象的URL。但是每次调用该方法时都会创建一个新的URL对象，即使指向的是同一个对象，所以每次创建完一个URL对象不再使用后要手动释放，通过URL.revokeObjextURL()来释放。&lt;/p&gt;

</description>
<pubDate>Sat, 14 Oct 2017 14:00:00 +0000</pubDate>
<dc:creator>法克大叔叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjw-ryh/p/7663797.html</dc:identifier>
</item>
</channel>
</rss>