<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>卷积神经网络（Convolutional Neural Network，CNN） - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/9488045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/9488045.html</guid>
<description>&lt;p&gt;　　全连接神经网络（Fully connected neural network）处理图像最大的问题在于全连接层的参数太多。参数增多除了导致计算速度减慢，还很容易导致过拟合问题。所以需要一个更合理的神经网络结构来有效地减少神经网络中参数的数目。而卷积神经网络（Convolutional Neural Network，CNN）可以做到。&lt;/p&gt;

&lt;h2&gt;1. 卷积神经网络构成&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1351564/201808/1351564-20180816172036251-916919934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 1：卷积神经网络&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;整个网络的输入，一般代表了一张图片的像素矩阵。图 1中最左侧三维矩阵代表一张输入的图片，三维矩阵的长、宽代表了图像的大小，而三维矩阵的深度代表了图像的色彩通道（channel）。黑白图片的深度为 1，RGB 色彩模式下，图片的深度为 3。&lt;/p&gt;
&lt;p&gt;CNN 中最为重要的部分。与全连接层不同，卷积层中每一个节点的输入只是上一层神经网络中的一小块，这个小块常用的大小有 3×3 或者 5×5。一般来说，通过卷积层处理过的节点矩阵会变的更深。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;池化层（Pooling）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;池化层不改变三维矩阵的深度，但是可以缩小矩阵的大小。池化操作可以认为是将一张分辨率高的图片转化为分辨率较低的图片。通过池化层，可以进一步缩小最后全连接层中节点的个数，从而到达减少整个神经网络参数的目的。池化层本身没有可以训练的参数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全连接层，最后一层激活函数使用 softmax。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;经过多轮卷积层和池化层的处理后，在CNN的最后一般由1到2个全连接层来给出最后的分类结果。经过几轮卷积和池化操作，可以认为图像中的信息已经被抽象成了信息含量更高的特征。我们可以将卷积和池化看成自动图像提取的过程，在特征提取完成后，仍然需要使用全连接层来完成分类任务。&lt;/p&gt;
&lt;p&gt;对于多分类问题，最后一层激活函数可以选择 softmax，这样我们可以得到样本属于各个类别的概率分布情况。&lt;/p&gt;

&lt;h2&gt;2. 卷积层&lt;/h2&gt;
&lt;h3&gt;2.1 filter&lt;/h3&gt;
&lt;p&gt;　　卷积神经网络结构中最重要的部分，过滤器（filter），如图 2中黄色和橙色的 3×3×3 矩阵所示。具体卷积操作如何进行，可以参考 &lt;a href=&quot;http://cs231n.github.io/convolutional-networks/&quot; target=&quot;_blank&quot;&gt;Convolutional Neural Networks (CNNs / ConvNets)&lt;/a&gt; 中的 Convolution Demo 或者参考图 3。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1351564/201808/1351564-20180817232547621-2130453849.png&quot; alt=&quot;&quot; width=&quot;575&quot; height=&quot;298&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 2：卷积操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　filter 可以将当前层神经网络上的一个子节点矩阵转化为下一层神经网络上的一个单位节点矩阵。单位节点矩阵制的是长和宽都是 1，但深度不限的节点矩阵。&lt;/p&gt;
&lt;p&gt;　　进行卷积操作，需要注意 filter 的个数 $K$、filter 的尺寸 $F$、卷积步长 stride 的大小 $S$ 以及 padding 的大小 $P$。图 2 中 $K = 2$，$F = 3$，$S = 1$，$P = 0$。&lt;/p&gt;
&lt;p&gt;　　常用的 filter 尺寸有 3×3 或 5×5，即图 2 黄色和橙色矩阵中的前两维，这个是人为设定的；filter 的节点矩阵深度，即图 2 黄色和橙色矩阵中的最后一维（filter 尺寸的最后一维），是由当前层神经网络节点矩阵的深度（RGB 图像节点矩阵深度为 3）决定的；卷积层输出矩阵的深度（也称为 filter 的深度）是由该卷积层中 filter 的个数决定，该参数也是人为设定的，一般随着卷积操作的进行越来越大。&lt;/p&gt;
&lt;p&gt;　　图 2中 filter 的尺寸为 3×3×3，filter 的深度为 2。&lt;/p&gt;
&lt;p&gt;　　卷积操作中，一个 3×3×3 的子节点矩阵和一个 3×3×3 的 filter 对应元素相乘，得到的是一个 3×3×3 的矩阵，此时将该矩阵所有元素求和，得到一个 1×1×1 的矩阵，将其再加上 filter 的 bias，经过激活函数得到最后的结果，将最后的结果填入到对应的输出矩阵中。输出矩阵中第一个元素 $g(0, 0, 0)$ 的计算如下所示：&lt;/p&gt;
&lt;p&gt;\begin{equation} g(0, 0, 0) = f( \sum_{x}^3\sum_{y}^3\sum_{z}^3a_{x,y,z} × w_{x,y,z}^{(0)} + b^{(0)}   ) \end{equation}&lt;/p&gt;
&lt;p&gt;公式(1)中，$a_{x,y,z}$ 表示当前层的一个子节点矩阵，即 6×6×3 矩阵中左上角 3×3×3 部分； $w_{x,y,z}^{(0)}$ 表示第一个 filter 的权重，即第一个 filter 每个位置的值；$b^{(0)}$ 表示第一个 filter 的偏置 bias，是一个实数；$f$ 表示激活函数，如 ReLU 激活函数。&lt;/p&gt;
&lt;p&gt;　　“卷积层结构的前向传播过程就是通过将一个 filter 从神经网络当前层的左上角移动到右下角，并且在移动中计算每一个对应的单位矩阵得到的。”&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1351564/201808/1351564-20180817144903687-737820916.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 3：卷积操作流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（注意：图 2 和 图 3 神经网络当前层输入不一样，图 2 是 6×6×3，而图 3 是5×5×3 再加上 $P = 1$ 的 padding。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　图 3 中，卷积步长 $S = 2$，padding的大小 $P = 1$。&lt;/p&gt;

&lt;h3&gt;2.2 padding&lt;/h3&gt;
&lt;p&gt;　　padding，顾名思义，就是在图像周围进行填充，一般常用 zero padding，即用 0 来填充。当 $P = 1$ 时，在图像周围填充一圈；当 $P = 2$ 时，填充两圈。&lt;/p&gt;
&lt;p&gt;　　Q: Why padding?&lt;/p&gt;
&lt;p&gt;　　A: Two reasons: 1) shrinking output: 随着卷积操作的进行，图像会越来越小; 2) throwing away information from the edges of the images: filter 对图片边缘信息和内部信息的重视程度不一样，边缘信息 filter 只经过一次，而内部信息会被经过多次。&lt;/p&gt;
&lt;p&gt;　　Q: Valid and Same convolutions?&lt;/p&gt;
&lt;p&gt;　　A: &quot;valid&quot;: no padding;&lt;/p&gt;
&lt;p&gt;　　    &quot;Same&quot;:  Pad so that output size is the same as the input size.&lt;/p&gt;

&lt;h3&gt;2.3 stride&lt;/h3&gt;
&lt;p&gt;　　卷积步长 stride 就是像在图 3 中 filter 一次移动的步子，图 3 中 stride 的大小 $S = 2$。&lt;/p&gt;
&lt;p&gt;　　卷积层输出矩阵的大小 $\mbox{size}_{output}$ 与输入图片大小 $N$、 filter 的尺寸 $F$、padding 的大小 $P$、卷积步长 $S$ 都有关。（假设输入的图片是方形的）&lt;/p&gt;
&lt;p&gt;\begin{equation} \mbox{size}_{output}=  \lfloor \frac{N + 2P - F}{S} \rfloor + 1\end{equation}&lt;/p&gt;
&lt;p&gt;当 $ S \neq 1$ 时，可能存在 $\frac{N + 2P - F}{S}$ 不是整数的情况，这个时候对 $\frac{N + 2P - F}{S}$ 取下整或者使用整除。&lt;/p&gt;
&lt;p&gt;　　依据《TensorFlow实战Google深度学习框架》，$\mbox{size}_{output}$ 也可以写成如下形势：&lt;/p&gt;
&lt;p&gt;\begin{equation} \mbox{size}_{output}=  \lceil \frac{N + 2P - F + 1 }{S} \rceil \end{equation}&lt;/p&gt;
&lt;p&gt;公式(2)和(3)最后的结果会是一样。&lt;/p&gt;

&lt;h2&gt;3. 池化层&lt;/h2&gt;
&lt;p&gt;　　池化层可以非常有效地缩小矩阵的尺寸（主要减少矩阵的长和宽，一般不会去减少矩阵深度），从而减少最后全连接层中的参数。“使用池化层既可以加快计算速度也有防止过拟合问题的作用。”&lt;/p&gt;
&lt;p&gt;　　与卷积层类似，池化层的前向传播过程也是通过一个类似 filter 的结构完成的。不过池化层 filter 中的计算不是节点的加权和，而是采用更加简单的最大值或者平均值运算。使用最大值操作的池化层被称为最大池化层（max pooling），这是使用最多的池化层结构。使用平均值操作的池化层被称为平均池化层（average pooling）。&lt;/p&gt;
&lt;p&gt;　　与卷积层的 filter 类似，池化层的 filter 也需要人工设定 filter 的尺寸、是否使用全 0 填充 以及 filter 移动的步长等设置，而且这些设置的意义也是一样的。&lt;/p&gt;
&lt;p&gt;　　卷积层和池化层中 filter 的移动方式是相似的，唯一的区别在于卷积层使用的 filter 是横跨整个深度的，而池化层使用的 filter 只影响一个深度上的节点。所以池化层的过滤器除了在长和宽两个维度移动之外，它还需要在深度这个维度移动。也就是说，在进行 max 或者 average 操作时，只会在同一个矩阵深度上进行，而不会跨矩阵深度进行。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1351564/201808/1351564-20180817224155953-1368217601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 4：max pooling&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　图 4 中，池化层 filter 的尺寸为 2×2，即 $F = 2$，padding 大小 $P = 0$，filter 移动的步长 $S = 2$。 &lt;/p&gt;
&lt;p&gt;　　池化层一般不改变矩阵的深度，只改变矩阵的长和宽。&lt;/p&gt;
&lt;p&gt;　　池化层没有 trainable 参数，只有一些需要人工设定的超参数。&lt;/p&gt;

&lt;h2&gt;4. 卷积神经网络的特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;局部连接：&lt;/strong&gt;卷积层输出矩阵上的某个位置只与部分输入矩阵有关，而不是全部的输入矩阵。卷积层输出的某个特征可能只和输入图片的某一部分相关，和其它位置的信息没有任何关联，局部连接可以让特征只关注其应该关注的部分。同时也减少了神经网络的参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数共享：&lt;/strong&gt;同一卷积层中 filter 的参数是共享的，一个 filter 无论在哪个位置进行卷积操作，filter 矩阵中的值都是一样的。（当然同一层不同的 filter 参数不一样，不同层之间 filter 的参数也不一样。）共享 filter 的参数可以使得图像中的内容不受位置的影响。以MNIST手写数字识别为例，无论数字“1”出现在左上角还是右下角，图片的种类的都是不变的。共享卷积层 filter 的参数还可以巨幅减少神经网络上的参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　图 2 中池化层拥有的 trainable 参数数目为 3×3×3×2+2，其中 “3×3×3” 表示 filter 的尺寸， “×2” 表示 filter 的深度/个数，“+2” 表示 2 个 filter 的 bias。卷积层的参数要远远小于同等情况下的全连接层。而且卷积层参数的个数和输入图片的大小无关，这使得卷积神经网络可以很好地扩展到更大的图像数据上。&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;
&lt;p id=&quot;convolutional-neural-networks-cnns--convnets&quot;&gt;&lt;a target=&quot;_blank&quot;&gt;Convolutional Neural Networks (CNNs / ConvNets)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mooc.study.163.com/learn/2001281004?tid=2001392030#/learn/content?type=detail&amp;amp;id=2001728686&quot; target=&quot;_blank&quot;&gt;Course 4 Convolutional Neural Networks by Andrew Ng&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《TensorFlow实战Google深度学习框架》&lt;/p&gt;

</description>
<pubDate>Fri, 17 Aug 2018 15:28:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>全连接神经网络（Fully connected neural network）处理图像最大的问题在于全连接层的参数太多。参数增多除了导致计算速度减慢，还很容易导致过拟合问题。所以需要一个更合理的神经网</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/9488045.html</dc:identifier>
</item>
<item>
<title>七、线性表的链式存储结构 - 小胖鼠</title>
<link>http://www.cnblogs.com/chenke1731/p/9495573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenke1731/p/9495573.html</guid>
<description>&lt;h3 id=&quot;问题引入&quot;&gt;1、问题引入&lt;/h3&gt;
&lt;p&gt;开发数组类模板的原因在于：在创建基于顺序存储结构的线性表时，发现这样的线性表可能被误用，因为重载了数组访问操作符，使用时跟数组类似，但是线性表和数组有很大的区别，所以激发了新的需求：开发数组类替换C++原生数组类，因为原生数组类也存在着很大缺陷，使用不方便。&lt;/p&gt;
&lt;p&gt;基于顺序存储结构的线性表的另一个缺点：插入或删除元素时，涉及到大量数据元素的移动，对于效率的影响非常大&lt;/p&gt;
&lt;p&gt;一个新的需求：在插入或删除元素时不需要大量移动数据元素的一种数据结构，即基于链式存储结构的线性表&lt;/p&gt;
&lt;h3 id=&quot;链式结构的定义&quot;&gt;2、链式结构的定义&lt;/h3&gt;
&lt;p&gt;为了表示每个数据元素于其直接后继元素之间的逻辑关系；数据元素除了存储本身的信息外，还需要存储其直接后继的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372866/201808/1372866-20180817222745037-1071623465.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(a_{i+1}\)&lt;/span&gt;是线性表中的两个相邻数据元素，在物理内存中无相邻关系。&lt;/p&gt;
&lt;p&gt;一个数据元素包含了两部分：&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;是数据元素本身的数据信息，还有一个地址信息，地址是第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个元素的直接后继，即第&lt;span class=&quot;math inline&quot;&gt;\(i+1\)&lt;/span&gt;个的元素在内存中的地址信息。换句话说就是如果找到了第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个元素，不仅可以得到第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个元素的本身的值之外，还可以得到第&lt;span class=&quot;math inline&quot;&gt;\(i+1\)&lt;/span&gt;个元素在内存中的位置&lt;/p&gt;
&lt;h3 id=&quot;链式存储逻辑结构&quot;&gt;3、链式存储逻辑结构&lt;/h3&gt;
&lt;p&gt;基于链式存储结构的线性表中，每个结点都包含数据域和指针域&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据域：存储数据元素本身&lt;/li&gt;
&lt;li&gt;指针域：存储相邻结点的地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372866/201808/1372866-20180817222801707-1986803877.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两种线性表名称统一：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;顺序表：基于顺序存储结构的线性表&lt;/li&gt;
&lt;li&gt;链表：基于链式存储结构的线性表
&lt;ul&gt;&lt;li&gt;单链表：每个结点只包含直接后继的地址信息&lt;/li&gt;
&lt;li&gt;循环链表：单链表的最后一个结点的直接后继为第一个结点&lt;/li&gt;
&lt;li&gt;双向链表：单链表中的结点包含直接前驱和后继的地址信息&lt;/li&gt;
&lt;li&gt;双向循环链表......&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;链表中的基本概念&quot;&gt;4、链表中的基本概念&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;头结点：链表中的辅助结点，包含指向第一个数据元素的指针；不包含任何数据信息，是为了简化代码进行辅助&lt;/li&gt;
&lt;li&gt;数据结点：链表中代表数据元素的结点，表现形式为：(数据元素，地址)&lt;/li&gt;
&lt;li&gt;尾结点：链表中的最后一个数据结点。单独放出的原因：尾结点包含的地址信息直接决定了链表的性质，地址信息为空，就是单链表；地址为第0个元素的地址信息，就是循环链表；地址信息为随机值，就是一个非法链表&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;单链表&quot;&gt;5、单链表&lt;/h3&gt;
&lt;h4 id=&quot;单链表中的结点定义&quot;&gt;5.1 单链表中的结点定义&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 用struct定义类，默认属性是public
// T是泛指类型，链表可以存储各种类型的数据
struct Node : public Object
{
    T value;
    Node* next; // 指向后继结点的指针
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;单链表的内部结构&quot;&gt;5.2 单链表的内部结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372866/201808/1372866-20180817222810908-1837731497.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;头结点在单链表中的意义是：辅助数据元素的定位，方便插入和删除操作，因此，头结点不存储实际的数据元素。&lt;/p&gt;
&lt;h4 id=&quot;在目标位置处插入数据元素&quot;&gt;5.3 在目标位置处插入数据元素&lt;/h4&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从头结点开始，通过&lt;code&gt;current&lt;/code&gt;指针定位到目标位置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从堆空间申请新的Node结点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行操作&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;node-&amp;gt;value = e;
node-&amp;gt;next = current-&amp;gt;next;
current-&amp;gt;next - node;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;在目标位置删除数据元素&quot;&gt;5.4 在目标位置删除数据元素&lt;/h4&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从头结点开始，通过&lt;code&gt;previous&lt;/code&gt;指针定位到目标位置的前一个地址&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用&lt;code&gt;toDel&lt;/code&gt;指针指向需要删除的结点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行操作：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;toDel = previous-&amp;gt;next;
previous-&amp;gt;next = toDel-&amp;gt;next;
delete toDel;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;小结&quot;&gt;6、小结&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;链表中的数据元素在物理内存中无相邻关系&lt;/p&gt;
&lt;p&gt;链表中的结点都包含数据域和指针域&lt;/p&gt;
&lt;p&gt;头结点用于辅助数据元素定位，方便插入和删除操作&lt;/p&gt;
&lt;p&gt;插入和删除操作需要保证链表的完整性&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 17 Aug 2018 14:29:00 +0000</pubDate>
<dc:creator>小胖鼠</dc:creator>
<og:description>1、问题引入 开发数组类模板的原因在于：在创建基于顺序存储结构的线性表时，发现这样的线性表可能被误用，因为重载了数组访问操作符，使用时跟数组类似，但是线性表和数组有很大的区别，所以激发了新的需求：开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenke1731/p/9495573.html</dc:identifier>
</item>
<item>
<title>微信小程序实战–集阅读与电影于一体的小程序项目（三） - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/9495518.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/9495518.html</guid>
<description>&lt;h3 id=&quot;wx.showtoast交互反馈&quot;&gt;14.wx.showToast交互反馈&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/api-react.html&quot; title=&quot;wx.showToast文档&quot;&gt;wx.showToast文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;post-detail.js添加个消息提示框&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;onCollectionTap: function(ev) {
    var postsCollected = wx.getStorageSync('posts_Collected')
    var postCollected = postsCollected[this.data.currentPostId]
    postCollected = !postCollected;
    postsCollected[this.data.currentPostId] = postCollected;
    // 更新文章是否收藏的缓存值
    wx.setStorageSync('posts_Collected', postsCollected)
    // 更新数据绑定变量，实现切换图片
    this.setData({
      collected: postCollected
    })

    wx.showToast({
      title: postCollected ? &quot;收藏成功&quot; : &quot;取消成功&quot;,
      duration: 1000,
      icon: &quot;success&quot;
    })
  } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://139.199.131.146/wp-content/uploads/2018/08/ab3798711ce460671fa6561177d1751b.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://139.199.131.146/wp-content/uploads/2018/08/412ab369b4d58dceb703b7700c66f85f.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;音乐播放功能&quot;&gt;15.音乐播放功能&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/media-background-audio.html#wxplaybackgroundaudioobject&quot; title=&quot;音乐播放API文档&quot;&gt;音乐播放API文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在posts-data.js里面给每篇文章添加一个music属性&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt; music: {
    url: &quot;http://music.163.com/song/media/outer/url?id=108242.mp3&quot;,
    title: &quot;她说-林俊杰&quot;,
    coverImg: &quot;http://y.gtimg.cn/music/photo_new/T002R150x150M000001TEc6V0kjpVC.jpg?max_age=2592000&quot;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;post-detail.wxml&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没播放音乐就显示文章图片，播放音乐就显示音乐歌手图片&lt;/li&gt;
&lt;li&gt;绑定事件，添加播放和暂停音乐以及图片切换功能&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt; &amp;lt;!-- &amp;lt;image class=&quot;head-image&quot; src=&quot;{{postData.headImgSrc}}&quot;&amp;gt;&amp;lt;/image&amp;gt; --&amp;gt;
  &amp;lt;image class='head-image' src=&quot;{{isPlayingMusic?postData.music.coverImg:postData.headImgSrc}}&quot;&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;image catchtap='onMusicTap' class='audio' src=&quot;{{isPlayingMusic? '/images/music/music-stop.png': '/images/music/music-start.png'}}&quot;&amp;gt;&amp;lt;/image&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;post-detail.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 播放音乐
  onMusicTap: function (ev) {
    var currentPostId = this.data.currentPostId;
    var postData = postsData.postlist[currentPostId];
    var isPlayingMusic = this.data.isPlayingMusic;
    if (isPlayingMusic) {
      wx.pauseBackgroundAudio();
      this.setData({
        isPlayingMusic: false
      })
    }
    else {
      wx.playBackgroundAudio({
        dataUrl: postData.music.url,
        title: postData.music.title,
        coverImgUrl: postData.music.coverImg,
      })
      this.setData({
        isPlayingMusic: true
      })
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;监听音乐播放事件&quot;&gt;16.监听音乐播放事件&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/media-background-audio.html#wxonbackgroundaudioplaycallback&quot; title=&quot;监听音乐播放文档&quot;&gt;监听音乐播放文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;post-detail.js的onLoad函数里面添加监听事件&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var that = this;
    wx.onBackgroundAudioPlay(function(){
      that.setData({
        isPlayingMusic: true
      })
    });
    wx.onBackgroundAudioPause(function () {
      that.setData({
        isPlayingMusic: false
      })
    });
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;绑定监听事件后，播放按钮的状态就可以同步切换了&lt;/p&gt;
&lt;h3 id=&quot;完善音乐播放功能&quot;&gt;17.完善音乐播放功能&lt;/h3&gt;
&lt;p&gt;在文章详情页，点击播放音乐后，然后返回到文章列表页，再进到详情页，发现播放按钮是暂停状态，这是因为应用程序存在生命周期，下面就解决这个问题。&lt;/p&gt;
&lt;p&gt;app.js绑定一个全局的变量（音乐播放状态）&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;App({
  globalData: {
    g_isPlayingMusic: false,
    g_currentMusicPostId: null,
  },
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;post-detail.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var app = getApp();

Page({

  data: {
    isPlayingMusic: false
  },

  onLoad: function(options) {
    .
    .
    .

    if (app.globalData.g_isPlayingMusic &amp;amp;&amp;amp; app.globalData.g_currentMusicPostId === postId) {
      this.setData({
        isPlayingMusic: true
      })
    }
    this.setMusicMonitor()
  },

  setMusicMonitor:function(){
    var that = this;
    wx.onBackgroundAudioPlay(function () {
      that.setData({
        isPlayingMusic: true
      })
      app.globalData.g_currentMusicPostId = that.data.currentPostId
      app.globalData.g_isPlayingMusic = true
    });
    wx.onBackgroundAudioPause(function () {
      that.setData({
        isPlayingMusic: false
      })
      app.globalData.g_currentMusicPostId = null
      app.globalData.g_isPlayingMusic = false
    });  
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;轮播图跳转到文章详情&quot;&gt;18.轮播图跳转到文章详情&lt;/h3&gt;
&lt;p&gt;post.wxml&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;swiper catchtap='onSwiperTap' indicator-dots='true' autoplay='true' interval='2000'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;post.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;onSwiperTap(event) {
    var postId = event.target.dataset.postid
    wx.navigateTo({
      url: 'post-detail/post-detail?id=' + postId
    })
  },&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 17 Aug 2018 14:13:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<og:description>14.wx.showToast交互反馈</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/9495518.html</dc:identifier>
</item>
<item>
<title>讲一下Asp.net core MVC2.1 里面的 ApiControllerAttribute - Sheldon_Lou</title>
<link>http://www.cnblogs.com/sheldon-lou/p/9495377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheldon-lou/p/9495377.html</guid>
<description>&lt;h3 id=&quot;先贴文章链接&quot;&gt;先贴文章&lt;a href=&quot;https://www.strathweb.com/2018/02/exploring-the-apicontrollerattribute-and-its-features-for-asp-net-core-mvc-2-1/&quot;&gt;链接&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;ASP.NET Core MVC 2.1 特意为构建 HTTP API 提供了一些小特性，今天主角就是 &lt;code&gt;ApiControllerAttribute&lt;/code&gt;. （注：文章是18年2月份的，所以文章提到了core2.1还没发布）。&lt;/p&gt;
&lt;h3 id=&quot;apicontrollerattribute-继承自-controllerattribute&quot;&gt;0. ApiControllerAttribute 继承自 ControllerAttribute&lt;/h3&gt;
&lt;p&gt;ASP.NET Core MVC 已经有了ControllerAttribute，这个用来标注一个类型是否是Controller。标注了之后框架就知道哪些是系统里面的Controller了。（框架也有其他方法来获取程序里面的Controller，所以，这个ControllerAttribute不是必须的）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ApiControllerAttribute&lt;/code&gt;是&lt;code&gt;ControllerAttribute&lt;/code&gt;的子类，所以，框架在处理Controller发现的时候和&lt;code&gt;ControllerAttribute&lt;/code&gt;标注的对象是一样的。&lt;/p&gt;
&lt;p&gt;但是，因为&lt;code&gt;ApiControllerAttribute&lt;/code&gt; 实现了&lt;code&gt;IApiBehaviorMetadata&lt;/code&gt;接口，所以提供了一些额外的特这些特性是以HTTP Api为出发点的。下面介绍一下这些特性。&lt;/p&gt;
&lt;h3 id=&quot;自动模型状态验证&quot;&gt;1. 自动模型状态验证&lt;/h3&gt;
&lt;p&gt;这个是重点，框架会帮你自动验证model的state，也就是&lt;code&gt;ModelState&lt;/code&gt;.(注:不过我就是因为用FluentValidation的时候模型验证不管用了出问题了才找到这篇文章的).&lt;/p&gt;
&lt;p&gt;框架会为你自动注册&lt;code&gt;ModelStateInvalidFilter&lt;/code&gt;，这个会运行在&lt;code&gt;OnActionExecuting&lt;/code&gt;事件里面（具体来说：在action执行之前，model绑定之后)。他内部会检查&lt;code&gt;ModelState&lt;/code&gt;是否为Valid，如果为InValid会直接返回400 BadRequest，这样就没有必要执行后面的代码，提高效率。&lt;/p&gt;
&lt;p&gt;它会自动把model state 放到response里面，content type 是&lt;code&gt;application/problem+json&lt;/code&gt;。当然你也可以自定义，因为毕竟你会有自己的验证，后文会讲。&lt;/p&gt;
&lt;p&gt;下面，我们先来举个例子说一下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;之前的写法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Route(&quot;[controller]&quot;)]
public class BookController : Controller
{
    [HttpPost(&quot;&quot;)]
    public IActionResult PostBook([FromBody]Book book)
    {
        if (ModelState.IsValid) //判断状态
        {
            return BadRequest(ModelState);
        }
        //其他代码。。。
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;现在可以这么写&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[ApiController]
[Route(&quot;[controller]&quot;)]
public class BookController : Controller
{
    [HttpPost(&quot;&quot;)]
    public IActionResult PostBook(Book book)
    {
        //直接写，不用验证modelstate
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;顺道说一下，&lt;code&gt;ModelStateInvalidFilter&lt;/code&gt;是个公共类，所以，不用&lt;code&gt;ApiControllerAttribute&lt;/code&gt;也可以使用它。&lt;/p&gt;
&lt;h3 id=&quot;参数绑定策略的自动推断&quot;&gt;2.参数绑定策略的自动推断&lt;/h3&gt;
&lt;p&gt;另一个非常有用的特性是action里面的参数的模型绑定可以自动推断。&lt;/p&gt;
&lt;p&gt;ASP.NET Core MVC里面有一个比较令人恼怒的问题你需要手动给参数指定&lt;code&gt;[FromBody]&lt;/code&gt;这个特性，以便让系统知道如何从Request body里面反序列化他们，比如反序列化json。因此，写了很多第三方的库来解决这个问题，比如：&lt;/p&gt;
&lt;p&gt;现在，这些可以自动解决了。&lt;/p&gt;
&lt;p&gt;除此之外，如果一个参数在route里面定义了，他会自动从先从path，也就是url上尝试绑定，不行的话会去从查询参数上绑定。&lt;code&gt;IFormFlie&lt;/code&gt;默认从form表单上绑定获取。&lt;/p&gt;
&lt;p&gt;下面看代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Route(&quot;[controller]&quot;)]
public class BookController : Controller
{
    [HttpPost(&quot;&quot;)]
    public IActionResult PostBook([FromBody]Book book)
    {
        // 写代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[ApiController]
[Route(&quot;[controller]&quot;)]
public class BookController : Controller
{
    [HttpPost(&quot;&quot;)]
    public IActionResult PostBook(Book book)//FromBody没必要写了
    {
        // 写代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;处理multipartform-data请求&quot;&gt;3. 处理&lt;code&gt;multipart/form-data&lt;/code&gt;请求&lt;/h3&gt;
&lt;p&gt;如果你的action里面的一个参数指定了&lt;code&gt;[FromFile]&lt;/code&gt;特性（这通常是用于文件上传的),框架会自动假设请求是&lt;code&gt;multipart/form-data&lt;/code&gt;。这个是用来解决社区里面提的这个&lt;a href=&quot;https://github.com/aspnet/Mvc/issues/6965&quot;&gt;问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不过这个也是可选的，只要你自己定义在action上定义一下&lt;code&gt;[Consumes(...)]&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;其他&quot;&gt;4.其他&lt;/h3&gt;
&lt;p&gt;有两个注意点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ApiExplorer 的可见性。 默认所有的controller对&lt;code&gt;ApiExplorer&lt;/code&gt;都是可见的，所以，不影响swagger 等的生成。&lt;/li&gt;
&lt;li&gt;只是一个基于特性的路由。集中的路由机制不会应用在API controller，框架要求只能使用基于特性的路由，即在action上指定&lt;code&gt;[Route(&quot;XXX&quot;)]&lt;/code&gt;的方式。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;行为自定义&quot;&gt;5. 行为自定义&lt;/h3&gt;
&lt;p&gt;像MVC框架的大部分组件一样，&lt;code&gt;ApiControllerAttribute&lt;/code&gt;的行为是高度可自定义的。首先，上面说的大部分内容都是可以简单的用 on/off 来切换。&lt;/p&gt;
&lt;p&gt;具体的设置是在startup方法里面通过&lt;code&gt;ApiBehaviorOptions&lt;/code&gt;来实现，先来看一下这个类。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class ApiBehaviorOptions
    {
        public Func&amp;lt;ActionContext, IActionResult&amp;gt; InvalidModelStateResponseFactory { get; set; }

        public bool SuppressModelStateInvalidFilter { get; set; }

        public bool SuppressInferBindingSourcesForParameters { get; set; }

        public bool SuppressConsumesConstraintForFormFileParameters { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有bool类型的属性默认都是false。Suppres有阻止的意思。可以通过以下方法进行设置。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.Configure&amp;lt;ApiBehaviorOptions&amp;gt;(options =&amp;gt;
{
    options.SuppressModelStateInvalidFilter = true;
    options.SuppressConsumesConstraintForFormFileParameters = true;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看一下&lt;code&gt;InvalidModelStateResponseFactory&lt;/code&gt;属性，他是一个返回&lt;code&gt;IActionResult&lt;/code&gt;的Func，通过他，我们可以注入自己的委托来实现需要的返回类型，举个例子。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.Configure&amp;lt;ApiBehaviorOptions&amp;gt;(options =&amp;gt;
{
    options.InvalidModelStateResponseFactory = actionContext =&amp;gt; 
    {
        var errors = actionContext.ModelState
            .Where(e =&amp;gt; e.Value.Errors.Count &amp;gt; 0)
            .Select(e =&amp;gt; new Error
            {
            Name = e.Key,
            Message = e.Value.Errors.First().ErrorMessage
            }).ToArray();
 
        return new BadRequestObjectResult(errors);
    }
});
 
class Error
{
    public string Name { get; set; }
 
    public string Message { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 17 Aug 2018 13:30:00 +0000</pubDate>
<dc:creator>Sheldon_Lou</dc:creator>
<og:description>先贴文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sheldon-lou/p/9495377.html</dc:identifier>
</item>
<item>
<title>使用Pabot并行运行RF案例 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/9495264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/9495264.html</guid>
<description>&lt;p&gt; 一、问题引入&lt;/p&gt;
&lt;p&gt;在做接口自动化时随着案例增多，特别是流程类案例增多，特别是asp.net的webform类型的项目，再加上数据库校验也比较耗时，导致RF执行案例时间越来越长，就遇到这样一个问题，705个接口测试案例(案例包含流程类案例，一个流程类案例可能包含3、4个单个案例，单个案例又都包含登录)，通过Jenkins在单机上要跑13小时30分钟，而且目前还不是整个项目所有的接口测试案例，案例个数还在继续增长，一个系统假如有3、4000个接口那如果按照这个速度可能得跑一两天，这是很可怕的。&lt;/p&gt;
&lt;p&gt;二、解决方案&lt;/p&gt;
&lt;p&gt;于是就是在想有没有方法能缩短运行时间呢？一是将大的项目分成几个子模块，测试案例也是分为几个子模块，这样可以做分布式测试，二是进行并行测试，在一台机子上开启多个进程进行测试，最好的方案是一、二的结合，在网上搜了下，没想到已经有开源的类库Pabot。Pabot通过开启多个进程以Suite为单位并行运行RF测试案例，而且对于进程之间资源共享问题也有锁机制。它也兼容RF命令行参数，这样在Jenkins中修改之前RF命令也很容易，只需加几个参数就可以了。&lt;/p&gt;
&lt;p&gt;三、测试&lt;/p&gt;
&lt;p&gt;这里新建了一个PabotDemo，包含3个Suite，每个Suite中还有3个Test，每个Test都是执行相同的步骤sleep 10s,暂停10s。如果在RF中运行9个Test，每个Test耗时10s，那就需要90s。下图为在RF中运行的测试结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201808/733213-20180817201845268-1035216852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果使用Pabot，开启多个进程并行运行案例，那就会减少运行时间，这里分别2个进程和3个进程。&lt;/p&gt;
&lt;p&gt;2个进程：pabot --processes 2 PabotDemo，这里原本要90s的案例耗时63s。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201808/733213-20180817202111012-878633815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201808/733213-20180817202145990-126991357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3个进程：pabot --processes 3 PabotDemo，这里原本要90s的案例耗时32s。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201808/733213-20180817202242952-1577559997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201808/733213-20180817202312160-895076892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面简单测试了使用Pabot开启多个进程并行执行RF案例，这里没有进程间的资源共享，所以没加锁，具体使用可以参考：https://github.com/mkorpela/pabot。使用Pabot开启2个进程还是在原来单个执行机运行上面提到的705个测试案例，耗时减少5个小时，通过率也有提升，运行时间下降到8小时30分。&lt;/p&gt;
&lt;p&gt;四、进一步优化&lt;/p&gt;
&lt;p&gt;在开启2个进程并行运行705个案例减少5小时的运行时间，如果再多开启几个进程还是有下降的空间，除了多开几个进程外，还可以对案例进行优化。我们应该都下载过文件，有的大文件几个G，有的只有几M，小的文件很快下载完了，大的文件可能才刚开始，影响下载时间的关键因素可能就是几个大的文件，为了达到并行下载的目的，可以将大文件分为几个小文件，这样并行下载效果更好。由于Pabot并行运行是以Suite为单位运行的，因为项目的案例结构有的Suite中案例个数100多个，有的只有几个，这样就导致案例少的Suite几个可能已经运行完了，案例多的Suite可能才刚开始，并不能发挥并行运行的最大效果，分布不均，所以需要对案例进行调整，将案例多的Suite进行拆分，这样也能开启多个进程，不然总共有3个Suite开启5个进程，那也没用，还是只有3个进程在运行，上面只是举了下载文件的例子，还有好多整体与部分的关系，有点类似木桶原理。&lt;/p&gt;
&lt;p&gt;五、优缺点&lt;/p&gt;
&lt;p&gt;这里只是使用Pabot进行的接口案例执行，对于UI测试案例可能会杀浏览器进程的，这里没测是否能用Pabot进行测试。&lt;/p&gt;
&lt;p&gt;六、总结&lt;/p&gt;
&lt;p&gt;上面优化案例结构也是为了并行执行案例进行的优化，其实还有地方进行优化，比如登录，目前每个案例在执行时都会先进行登录，算是多了一个get和post请求，特别是那种json的，可能就是先get、post进行登录，然后就只有post请求就结束的，如果能模拟人的操作，同一个用户只登录一次，那效率应该也会有所提高，案例少的话可能不明显，案例多的话应该就会明显些。&lt;/p&gt;
</description>
<pubDate>Fri, 17 Aug 2018 12:54:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>一、问题引入 在做接口自动化时随着案例增多，特别是流程类案例增多，特别是asp.net的webform类型的项目，再加上数据库校验也比较耗时，导致RF执行案例时间越来越长，就遇到这样一个问题，705个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/9495264.html</dc:identifier>
</item>
<item>
<title>构架人生~报纸上的求职 - 张占岭</title>
<link>http://www.cnblogs.com/lori/p/9495256.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lori/p/9495256.html</guid>
<description>&lt;h2 id=&quot;构架人生报纸上的求职&quot;&gt;&lt;span&gt;构架人生~报纸上的求职&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;骑车去良乡&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;网吧申请email&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;手递手报刊&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;无意中发现育才电脑学校在招教师&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;勇敢的去尝试&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;感谢刘老师给我机会&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;骑车去良乡&quot;&gt;&lt;span&gt;骑车去良乡&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;从同方回来后，我开始自己从报纸上找工作，说起报纸可没那么简单，农村是没有的，我需要骑车到离家10里的良乡去购买，忘记多少钱一张了，因为自己平时很少看报，只是在有需要时才买报纸看，在那段时间里，自己一个人骑着车可以走很远，自己也会边骑车边思考人生！&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;求职，租房时才购买报纸&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;网吧申请email&quot;&gt;&lt;span&gt;网吧申请email&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;记得自己带着几块钱就去良乡了，先去了文化路那边的小网吧，好像是3块钱1小时，自己去申请了电子邮箱，Yahoo的号，现在早就不知所踪了，小网吧环境不是很好，大家一般是在做9聊，相互对着骂，还有就是玩局域网游戏的，像CS，红警都是那个时代的产物！&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;手递手报刊&quot;&gt;&lt;span&gt;手递手报刊&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;从网吧出来后去了报刊，通过发小的推荐，我购买了手递手报纸，这种报纸信息量非常大，有好几份，大概是2块钱一份，足足有4到8张，里面各位招聘，求职，房产，二手物品等信息，感觉它就是现在的58，赶集的前身，记得从2003年到2006年几年中，我找工作都用这个手递手！&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;无意中发现育才电脑学校在招教师&quot;&gt;&lt;span&gt;无意中发现育才电脑学校在招教师&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在回到家后，我打开了报纸，开始找关于电脑的工作，我知道自己的实力，没工作经验，没学历，要想去公司做开发是不可能的，而自己在学校里学的只是过时的技术，学的也不是很精，找工作没戏。而我知道自己计算机基础知道学的还是不错的，是否可以当个培训学校的老师呢？就在我兴趣的驱使下，我看到了报纸的一个角落里写着『招聘计算机讲师，要求...学历...』，我被这个模块吸引了，我想我应该去试试，最起码可以发挥我的所学！&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;勇敢的去尝试&quot;&gt;&lt;span&gt;勇敢的去尝试&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;我拿起了电话，拨通了育才电脑学校的热线，接电话的是个女老师，简单的聊了几句我就过去面试了，开始时很紧张，而这个女教师还是对我比较友善，她说她也是中专毕业，然后感谢校长给他机会，让她在这里工作，并且在教学生的同时，对自己也是一种积累。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;这位老师就是小刘老师，对人比较和蔼，她主要较五笔，office等。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 17 Aug 2018 12:50:00 +0000</pubDate>
<dc:creator>张占岭</dc:creator>
<og:description>构架人生~报纸上的求职 骑车去良乡 网吧申请email 手递手报刊 无意中发现育才电脑学校在招教师 勇敢的去尝试 感谢刘老师给我机会 骑车去良乡 从同方回来后，我开始自己从报纸上找工作，说起报纸可没那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lori/p/9495256.html</dc:identifier>
</item>
<item>
<title>Tensorflow中的数据对象Dataset - molearner</title>
<link>http://www.cnblogs.com/wkslearner/p/9484443.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wkslearner/p/9484443.html</guid>
<description>&lt;h3 id=&quot;基础概念&quot;&gt;基础概念&lt;/h3&gt;
&lt;p&gt;在tensorflow的官方文档是这样介绍Dataset数据对象的：&lt;/p&gt;
&lt;p&gt;Dataset可以用来表示输入管道元素集合（张量的嵌套结构）和“逻辑计划“对这些元素的转换操作。在Dataset中元素可以是向量，元组或字典等形式。&lt;br/&gt;另外，Dataset需要配合另外一个类Iterator进行使用，Iterator对象是一个迭代器，可以对Dataset中的元素进行迭代提取。&lt;/p&gt;
&lt;p&gt;看个简单的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#创建一个Dataset对象
dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

#创建一个迭代器
iterator = dataset.make_one_shot_iterator()

#get_next()函数可以帮助我们从迭代器中获取元素
element = iterator.get_next()

#遍历迭代器，获取所有元素
with tf.Session() as sess:
   for i in range(9):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上打印结果为：1 2 3 4 5 6 7 8 9&lt;/p&gt;

&lt;h3 id=&quot;dataset方法&quot;&gt;Dataset方法&lt;/h3&gt;

&lt;h4 id=&quot;from_tensor_slices&quot;&gt;1.from_tensor_slices&lt;/h4&gt;
&lt;p&gt;from_tensor_slices用于创建dataset,其元素是给定张量的切片的元素。&lt;/p&gt;
&lt;p&gt;函数形式：from_tensor_slices（tensors）&lt;/p&gt;
&lt;p&gt;参数tensors:张量的嵌套结构,每个都在第0维中具有相同的大小。&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#创建切片形式的dataset
dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

#创建一个迭代器
iterator = dataset.make_one_shot_iterator()

#get_next()函数可以帮助我们从迭代器中获取元素
element = iterator.get_next()

#遍历迭代器，获取所有元素
with tf.Session() as sess:
   for i in range(3):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果：1 2 3&lt;/p&gt;

&lt;h4 id=&quot;from_tensors&quot;&gt;2.from_tensors&lt;/h4&gt;
&lt;p&gt;创建一个Dataset包含给定张量的单个元素。&lt;/p&gt;
&lt;p&gt;函数形式：from_tensors（tensors）&lt;/p&gt;
&lt;p&gt;参数tensors:张量的嵌套结构。&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset = tf.data.Dataset.from_tensors([1,2,3,4,5,6,7,8,9])

iterator = concat_dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(1):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果：[1,2,3,4,5,6,7,8,9]&lt;br/&gt;即from_tensors是将tensors作为一个整体进行操纵，而from_tensor_slices可以操纵tensors里面的元素。&lt;/p&gt;

&lt;h4 id=&quot;from_generator&quot;&gt;3.from_generator&lt;/h4&gt;
&lt;p&gt;创建Dataset由其生成元素的元素generator。&lt;/p&gt;
&lt;p&gt;函数形式：from_generator(generator,output_types,output_shapes=None,args=None)&lt;/p&gt;
&lt;p&gt;参数generator:一个可调用对象，它返回支持该iter()协议的对象 。如果args未指定，generator则不得参数; 否则它必须采取与有值一样多的参数args。&lt;br/&gt;参数output_types：tf.DType对应于由元素生成的元素的每个组件的对象的嵌套结构generator。&lt;br/&gt;参数output_shapes:tf.TensorShape 对应于由元素生成的元素的每个组件的对象 的嵌套结构generator&lt;br/&gt;参数args:tf.Tensor将被计算并将generator作为NumPy数组参数传递的对象元组。&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#定义一个生成器
def data_generator():
    dataset = np.array(range(9))
    for i in dataset:
        yield i

#接收生成器，并生产dataset数据结构
dataset = tf.data.Dataset.from_generator(data_generator, (tf.int32))

iterator = concat_dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(3):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果：0 1 2&lt;/p&gt;

&lt;h4 id=&quot;batch&quot;&gt;4.batch&lt;/h4&gt;
&lt;p&gt;batch可以将数据集的连续元素合成批次。&lt;/p&gt;
&lt;p&gt;函数形式：batch(batch_size,drop_remainder=False)&lt;/p&gt;
&lt;p&gt;参数batch_size:表示要在单个批次中合并的此数据集的连续元素个数。&lt;br/&gt;参数drop_remainder：表示在少于batch_size元素的情况下是否应删除最后一批 ; 默认是不删除。&lt;/p&gt;
&lt;p&gt;具体例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#创建一个Dataset对象
dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

'''合成批次'''
dataset=dataset.batch(3)

#创建一个迭代器
iterator = dataset.make_one_shot_iterator()

#get_next()函数可以帮助我们从迭代器中获取元素
element = iterator.get_next()

#遍历迭代器，获取所有元素
with tf.Session() as sess:
   for i in range(9):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果为：&lt;br/&gt;[1 2 3]&lt;br/&gt;[4 5 6]&lt;br/&gt;[7 8 9]&lt;/p&gt;
&lt;p&gt;即把目标对象合成3个批次，返回的对象是传入Dataset对象。&lt;/p&gt;

&lt;h4 id=&quot;concatenate&quot;&gt;5.concatenate&lt;/h4&gt;
&lt;p&gt;concatenate可以将两个Dataset对象进行合并或连接.&lt;/p&gt;
&lt;p&gt;函数形式：concatenate(dataset)&lt;/p&gt;
&lt;p&gt;参数dataset:表示需要传入的dataset对象。&lt;/p&gt;
&lt;p&gt;具体例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#创建dataset对象
dataset_a=tf.data.Dataset.from_tensor_slices([1,2,3])
dataset_b=tf.data.Dataset.from_tensor_slices([4,5,6])

#合并dataset
concat_dataset=dataset_a.concatenate(dataset_b)

iterator = concat_dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(6):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果：1 2 3 4 5 6&lt;/p&gt;

&lt;h4 id=&quot;filter&quot;&gt;6.filter&lt;/h4&gt;
&lt;p&gt;filter可以对传入的dataset数据进行条件过滤.&lt;/p&gt;
&lt;p&gt;函数形式：filter(predicate)&lt;/p&gt;
&lt;p&gt;参数predicate:条件过滤函数&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

#对dataset内的数据进行条件过滤
dataset=dataset.filter(lambda x:x&amp;gt;3)

iterator = dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
    for i in range(6):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果：4 5 6 7 8 9&lt;/p&gt;

&lt;h4 id=&quot;map&quot;&gt;7.map&lt;/h4&gt;
&lt;p&gt;map可以将map_func函数映射到数据集&lt;/p&gt;
&lt;p&gt;函数形式：flat_map(map_func，num_parallel_calls=None)&lt;/p&gt;
&lt;p&gt;参数map_func:映射函数&lt;br/&gt;参数num_parallel_calls：表示要并行处理的数字元素。如果未指定，将按顺序处理元素。&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

#进行map操作
dataset=dataset.map(lambda x:x+1)

iterator = dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(6):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果：2 3 4 5 6 7&lt;/p&gt;

&lt;h4 id=&quot;flat_map&quot;&gt;8.flat_map&lt;/h4&gt;
&lt;p&gt;flat_map可以将map_func函数映射到数据集（与map不同的是flat_map传入的数据必须是一个dataset）。&lt;/p&gt;
&lt;p&gt;函数形式：flat_map(map_func)&lt;/p&gt;
&lt;p&gt;参数map_func:映射函数&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

#进行flat_map操作
dataset=dataset.flat_map(lambda x:tf.data.Dataset.from_tensor_slices(x+[1]))

iterator = dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(6):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果：2 3 4 5 6 7&lt;/p&gt;

&lt;h4 id=&quot;make_one_shot_iterator&quot;&gt;9.make_one_shot_iterator&lt;/h4&gt;
&lt;p&gt;创建Iterator用于枚举此数据集的元素。（可自动初始化）&lt;/p&gt;
&lt;p&gt;函数形式：make_one_shot_iterator()&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

iterator = dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(6):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;make_initializable_iterator&quot;&gt;10.make_initializable_iterator&lt;/h4&gt;
&lt;p&gt;创建Iterator用于枚举此数据集的元素。(使用此函数前需先进行迭代器的初始化操作)&lt;/p&gt;
&lt;p&gt;函数形式：make_initializable_iterator(shared_name=None)&lt;/p&gt;
&lt;p&gt;参数shared_name:(可选）如果非空，则返回的迭代器将在给定名称下共享同一设备的多个会话（例如，使用远程服务器时）&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

iterator = dataset.make_initializable_iterator()

element = iterator.get_next()

with tf.Session() as sess:

   #对迭代器进行初始化操作
   sess.run(iterator.initializer)

   for i in range(5):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;padded_batch&quot;&gt;11.padded_batch&lt;/h4&gt;
&lt;p&gt;将数据集的连续元素组合到填充批次中,此转换将输入数据集的多个连续元素组合为单个元素。&lt;/p&gt;
&lt;p&gt;函数形式：padded_batch(batch_size,padded_shapes,padding_values=None,drop_remainder=False)&lt;/p&gt;
&lt;p&gt;参数batch_size：表示要在单个批次中合并的此数据集的连续元素数。&lt;br/&gt;参数padded_shapes：嵌套结构tf.TensorShape或 tf.int64类似矢量张量的对象，表示在批处理之前应填充每个输入元素的相应组件的形状。任何未知的尺寸（例如，tf.Dimension(None)在一个tf.TensorShape或-1类似张量的物体中）将被填充到每个批次中该尺寸的最大尺寸。&lt;br/&gt;参数padding_values:(可选）标量形状的嵌套结构 tf.Tensor，表示用于各个组件的填充值。默认值0用于数字类型，空字符串用于字符串类型。&lt;br/&gt;参数drop_remainder:(可选）一个tf.bool标量tf.Tensor，表示在少于batch_size元素的情况下是否应删除最后一批 ; 默认行为是不删除较小的批处理。&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

dataset=dataset.padded_batch(2,padded_shapes=[])

iterator = dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(6):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果：&lt;br/&gt;[1 2]&lt;br/&gt;[3 4]&lt;/p&gt;

&lt;h4 id=&quot;repeat&quot;&gt;12.repeat&lt;/h4&gt;
&lt;p&gt;重复此数据集count次数&lt;/p&gt;
&lt;p&gt;函数形式：repeat(count=None)&lt;/p&gt;
&lt;p&gt;参数count:(可选）表示数据集应重复的次数。默认行为（如果count是None或-1）是无限期重复的数据集。&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

#无限次重复dataset数据集
dataset=dataset.repeat()

iterator = dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(30，35):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果： 1 2 3 4 5&lt;/p&gt;

&lt;h4 id=&quot;shard&quot;&gt;13.shard&lt;/h4&gt;
&lt;p&gt;将Dataset分割成num_shards个子数据集。这个函数在分布式训练中非常有用，它允许每个设备读取唯一子集。&lt;/p&gt;
&lt;p&gt;函数形式：shard( num_shards,index)&lt;/p&gt;
&lt;p&gt;参数num_shards:表示并行运行的分片数。&lt;br/&gt;参数index:表示工人索引。&lt;/p&gt;

&lt;h4 id=&quot;shuffle&quot;&gt;14.shuffle&lt;/h4&gt;
&lt;p&gt;随机混洗数据集的元素。&lt;/p&gt;
&lt;p&gt;函数形式：shuffle(buffer_size,seed=None,reshuffle_each_iteration=None)&lt;/p&gt;
&lt;p&gt;参数buffer_size:表示新数据集将从中采样的数据集中的元素数。&lt;br/&gt;参数seed:(可选）表示将用于创建分布的随机种子。&lt;br/&gt;参数reshuffle_each_iteration:(可选）一个布尔值，如果为true，则表示每次迭代时都应对数据集进行伪随机重组。（默认为True。）&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

#随机混洗数据
dataset=dataset.shuffle(3)

iterator = dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(30，35):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果：3 2 4&lt;/p&gt;

&lt;h4 id=&quot;skip&quot;&gt;15.skip&lt;/h4&gt;
&lt;p&gt;生成一个跳过count元素的数据集。&lt;/p&gt;
&lt;p&gt;函数形式：skip(count)&lt;/p&gt;
&lt;p&gt;参数count:表示应跳过以形成新数据集的此数据集的元素数。如果count大于此数据集的大小，则新数据集将不包含任何元素。如果count 为-1，则跳过整个数据集。&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset = tf.data.Dataset.from_tensor_slices([1,2,3,4,5,6,7,8,9])

#跳过前5个元素
dataset=dataset.skip(5)

iterator = dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(30，35):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果： 6 7 8&lt;/p&gt;

&lt;h4 id=&quot;take&quot;&gt;16.take&lt;/h4&gt;
&lt;p&gt;提取前count个元素形成性数据集&lt;/p&gt;
&lt;p&gt;函数形式：take(count)&lt;/p&gt;
&lt;p&gt;参数count:表示应该用于形成新数据集的此数据集的元素数。如果count为-1，或者count大于此数据集的大小，则新数据集将包含此数据集的所有元素。&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset = tf.data.Dataset.from_tensor_slices([1,2,2,3,4,5,6,7,8,9])

#提取前5个元素形成新数据
dataset=dataset.take(5)

iterator = dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(30，35):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果： 1 2 2&lt;/p&gt;

&lt;h4 id=&quot;zip&quot;&gt;17.zip&lt;/h4&gt;
&lt;p&gt;将给定数据集压缩在一起&lt;/p&gt;
&lt;p&gt;函数形式：zip（datasets）&lt;/p&gt;
&lt;p&gt;参数datesets:数据集的嵌套结构。&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dataset_a=tf.data.Dataset.from_tensor_slices([1,2,3])

dataset_b=tf.data.Dataset.from_tensor_slices([2,6,8])

zip_dataset=tf.data.Dataset.zip((dataset_a,dataset_b))

iterator = dataset.make_one_shot_iterator()

element = iterator.get_next()

with tf.Session() as sess:
   for i in range(30，35):
       print(sess.run(element))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码运行结果：&lt;br/&gt;(1, 2)&lt;br/&gt;(2, 6)&lt;br/&gt;(3, 8)&lt;/p&gt;
&lt;p&gt;到这里Dataset中大部分方法 都在这里做了初步的解释，当然这些方法的配合使用才能够在建模过程中发挥大作用。&lt;/p&gt;
&lt;p&gt;更多信息可查看tensorflow官方文档&lt;br/&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset&quot; class=&quot;uri&quot;&gt;https://www.tensorflow.org/api_docs/python/tf/data/Dataset&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Aug 2018 12:26:00 +0000</pubDate>
<dc:creator>molearner</dc:creator>
<og:description>基础概念 在tensorflow的官方文档是这样介绍Dataset数据对象的： Dataset可以用来表示输入管道元素集合（张量的嵌套结构）和“逻辑计划“对这些元素的转换操作。在Dataset中元素可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wkslearner/p/9484443.html</dc:identifier>
</item>
<item>
<title>内核开发知识3之串口过滤.绑定设备. - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/9495039.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/9495039.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一丶理论知识&lt;/span&gt;,&lt;span&gt;什么是过滤&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;过滤就是在不影响上层跟下层的情况下&lt;/span&gt;,&lt;span&gt;加入我们的新一层的设备&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当请求数据发送过来的时候&lt;/span&gt;.&lt;span&gt;我们可以对这个数据进行操作&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;这个就是过滤的基本含义&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二丶过滤使用的&lt;/span&gt;API.&lt;span&gt;以及简单的功能&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/h2&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;30.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p&gt;&lt;span&gt;APi&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p&gt;&lt;span&gt;功能&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;8&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;NTSTATUS &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;strong&gt;IoAttachDevice(&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN PDEVICE_OBJECT&lt;/strong&gt;  SourceDevice,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN PUNICODE_STRING&lt;/strong&gt;  TargetDevice,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    OUT PDEVICE_OBJECT&lt;/strong&gt;  &lt;strong&gt;*&lt;/strong&gt;AttachedDevice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    );&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt; 绑定到一个设备上&lt;span&gt;.&lt;/span&gt;&lt;span&gt;通过设备名字绑定&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;1:&lt;/span&gt; &lt;span&gt;我们自己生成的设备&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;2:&lt;/span&gt; &lt;span&gt;我们要绑定设备的设备名称&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;3:&lt;/span&gt; &lt;span&gt;绑定成功后返回设备对象指针的指针&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;PDEVICE_OBJECT &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;strong&gt;IoAttachDeviceToDeviceStack(&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN PDEVICE_OBJECT&lt;/strong&gt;  SourceDevice,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN PDEVICE_OBJECT&lt;/strong&gt;  TargetDevice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    );&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;绑定到一个设备上&lt;span&gt;.&lt;/span&gt;&lt;span&gt;通过设备指针绑定&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;1:&lt;/span&gt; &lt;span&gt;我们生成的过滤设备&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;2:&lt;/span&gt; &lt;span&gt;要绑定的设备的指针&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回值&lt;span&gt;:&lt;/span&gt; &lt;span&gt;返回值中保存了我们绑定成功后的设备对象指针&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;9&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;NTSTATUS&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;strong&gt;IoAttachDeviceToDeviceStackSafe(&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN PDEVICE_OBJECT&lt;/strong&gt;  SourceDevice,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN PDEVICE_OBJECT&lt;/strong&gt;  TargetDevice,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN OUT PDEVICE_OBJECT&lt;/strong&gt;  &lt;em&gt;*&lt;/em&gt;AttachedToDeviceObject &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    );&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;同上面&lt;span&gt;API&lt;/span&gt;&lt;span&gt;功能一样&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只不过其参数三当做传出参数&lt;span&gt;.&lt;/span&gt;&lt;span&gt;保存了我们绑定成功之后的设备的这指针&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;34.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;14&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;NTSTATUS &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;strong&gt;IoCreateDevice(&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN PDRIVER_OBJECT&lt;/strong&gt;  DriverObject,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN ULONG&lt;/strong&gt;  DeviceExtensionSize,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN PUNICODE_STRING&lt;/strong&gt;  DeviceName  &lt;strong&gt;OPTIONAL,&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN DEVICE_TYPE&lt;/strong&gt;  DeviceType,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN ULONG&lt;/strong&gt;  DeviceCharacteristics,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN BOOLEAN&lt;/strong&gt;  Exclusive,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    OUT PDEVICE_OBJECT&lt;/strong&gt;  &lt;em&gt;*&lt;/em&gt;DeviceObject&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    );&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;生成一个过滤设备&lt;span&gt;.&lt;/span&gt;&lt;span&gt;我们这个设备要绑定到我们要绑定的设备上面&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;1 :&lt;/span&gt; &lt;span&gt;驱动对象&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;一个内核程序只有一个驱动对象&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; &lt;span&gt;可以填写&lt;/span&gt;&lt;span&gt;DriverEntry&lt;/span&gt;&lt;span&gt;的参数&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;2:  &lt;/span&gt;&lt;span&gt;设备扩展&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;暂时传入&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;3:  &lt;/span&gt;&lt;span&gt;设备名称&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;如果是过滤设备&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;那么有一个规则就是一般不需要名称&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;4:  &lt;/span&gt;&lt;span&gt;设备类型&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;保持跟绑定设备的设备类型一致即可&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;5:&lt;/span&gt; &lt;span&gt;设备的特征&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; &lt;span&gt;一般是&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;6:&lt;/span&gt; &lt;span&gt;此设备是否是独占设备&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;一般给&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;7:&lt;/span&gt; &lt;span&gt;传出参数&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;传出设备对象指针&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;22.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;10&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;NTSTATUS &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;strong&gt;IoGetDeviceObjectPointer(&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN PUNICODE_STRING&lt;/strong&gt;  ObjectName,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN ACCESS_MASK&lt;/strong&gt;  DesiredAccess,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    OUT PFILE_OBJECT&lt;/strong&gt;  &lt;strong&gt;*&lt;/strong&gt;FileObject,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    OUT PDEVICE_OBJECT&lt;/strong&gt;  &lt;strong&gt;*&lt;/strong&gt;DeviceObject&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    );&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;通过名字获取设备对象&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;1:&lt;/span&gt; &lt;span&gt;设备对象名称&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;2:&lt;/span&gt; &lt;span&gt;访问权限&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;一般是&lt;/span&gt; &lt;span&gt;FILE_ALL_ACCESS&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;3:&lt;/span&gt; &lt;span&gt;返回参数&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;即获得这个设备对象的同时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会得到一个文件对象&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;注意&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;不管这个参数在程序中有没有用&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;我们都要解除引用&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;否则内存泄漏&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;4:&lt;/span&gt; &lt;span&gt;得到的设备对象在参数&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;中存放&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;VOID &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;strong&gt;IoDeleteDevice(&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    IN PDEVICE_OBJECT&lt;/strong&gt;  DeviceObject&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    );&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;销毁设备&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;span&gt;1:&lt;/span&gt; &lt;span&gt;设备对象指针&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;通过以上我们其实使用几个简单的&lt;/span&gt;API&lt;span&gt;就可以做一个串口过滤&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三丶实战步骤&lt;/span&gt;.&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;生成我们自己的过滤设备&lt;/span&gt;. &lt;span&gt;使用&lt;/span&gt;&lt;span&gt;IoCreateDevice&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;拷贝标志位&lt;/span&gt;.&lt;span&gt;我们的生成的过滤设备跟要绑定的设备的标志要一样&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;利用&lt;/span&gt;IoAttachDeviceToDeviceStack(&lt;span&gt;也可以是安全的那个&lt;/span&gt;&lt;span&gt;.)&lt;/span&gt;&lt;span&gt;将我们的设备跟要绑定的设备行绑定&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;设置这个设备已经启动&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;span&gt;封装函数&lt;/span&gt;.&lt;span&gt;通过设备名称获取设备对象指针&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;内部并对文件对象进程解除引用&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;封装函数&lt;/span&gt;.&lt;span&gt;进行绑定&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;如果简单封装其实就是&lt;/span&gt;2&lt;span&gt;步骤&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;通过设备名称获得设备对象指针&lt;/span&gt;. 并解除文件引用.&lt;/li&gt;
&lt;li&gt;&lt;span&gt;生成设备&lt;/span&gt;,&lt;span&gt;进行绑定&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;当然&lt;/span&gt;,&lt;span&gt;上面两步骤都是我们封装的函数&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;justify&quot;&gt;&lt;span&gt;四丶串口绑定代码例子&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;根据上面的理论.我们可以根据API. 写简单的串口绑定了. 注意下方代码是串口绑定的代码.相当于我们在这个设备上加了一层.但是我们还没有写获取请求数据的代码.&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
#include &amp;lt;Ntddk.h&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编写内核驱动需要包含NTddk头文件.&lt;/span&gt;
#include &amp;lt;ntdef.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Ntstrsafe.h&amp;gt;&lt;span&gt;
VOID DriverUnload(PDRIVER_OBJECT pObj);

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; MAX_COM_ID 32  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设我们的串口有32个.&lt;/span&gt;


&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
函数功能.格式化端口字符串.根据端口字符串打开端口.返回获取到的设备对象指针.
参数1: id. 根据id依次初始化字符串.
参数2: 返回值状态. 因为返回值是设备对象指针.所以我们通过定义传出参数来保存真实的返回值状态.
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
PDEVICE_OBJECT RetOpenComDevicePoint(ULONG id, NTSTATUS &lt;/span&gt;*&lt;span&gt;status); 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
函数功能: 根据驱动对象.传入获取的设备对象.内部创建过滤设备.进而进行绑定. 过滤设备跟 获取的设备进行绑定.
参数1: 驱动对象.
参数2: 获取的设备对象
参数3: 创建的过滤驱动.内部创建.这个参数会保存过滤设备指针. 
参数4: 临时的过滤设备指针.保存当前过滤设备最顶端的设备.
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
NTSTATUS MyAttachDevice(__in PDRIVER_OBJECT pDriverObj,
    __in PDEVICE_OBJECT oldDeviceObj,
    __in PDEVICE_OBJECT &lt;/span&gt;*&lt;span&gt;CreateDeviceObj,
    __in PDEVICE_OBJECT &lt;/span&gt;*&lt;span&gt;NextDeviceObj);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; PDEVICE_OBJECT New_Obj[MAX_COM_ID] = { &lt;span&gt;0&lt;/span&gt; }; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们生成的过滤设备.&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; PDEVICE_OBJECT Next_Obj[MAX_COM_ID] = { &lt;span&gt;0&lt;/span&gt; }; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要绑定的设备.&lt;/span&gt;
&lt;span&gt;

NTSTATUS DriverEntry(__in &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; _DRIVER_OBJECT  *&lt;span&gt;DriverObject,
                      __in PUNICODE_STRING  RegistryPath)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;UNICODE_STRING str = RTL_CONSTANT_STRING(L&quot;My Frist Driver \r\n&quot;);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;串口过滤&lt;/span&gt;
&lt;span&gt;    ULONG i;
    NTSTATUS  status;
    PDEVICE_OBJECT pGetOldDevicePoint &lt;/span&gt;= NULL; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取的旧的设备对象&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;依次遍历进行串口绑定过滤&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; MAX_COM_ID; i++&lt;span&gt;)
    {
        pGetOldDevicePoint &lt;/span&gt;= RetOpenComDevicePoint(i, &amp;amp;&lt;span&gt;status);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; pGetOldDevicePoint)
        {
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行绑定.&lt;/span&gt;
        MyAttachDevice(DriverObject, pGetOldDevicePoint, &amp;amp;New_Obj[i], &amp;amp;&lt;span&gt;Next_Obj[i]);
    }
    
    DriverObject&lt;/span&gt;-&amp;gt;DriverUnload =&lt;span&gt; DriverUnload;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_SUCCESS;
}

VOID DriverUnload(PDRIVER_OBJECT pObj)
{
    DbgPrint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnLoad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过设备对象名称.获取设备对象指针.&lt;/span&gt;
PDEVICE_OBJECT RetOpenComDevicePoint(ULONG id,NTSTATUS *&lt;span&gt;status)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们知道在windows中设备名字都是依次递进的.所以我们根据id格式化字符串.\Device\Serial0 C语言中要进行转义&lt;/span&gt;
    UNICODE_STRING  CreateDeviceStr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备名称字符串.&lt;/span&gt;
    PFILE_OBJECT pFileObj  = NULL; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件对象指针.&lt;/span&gt;
    PDEVICE_OBJECT pDeviceObj = NULL;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备对象指针.&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; WCHAR name[&lt;span&gt;32&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据ID格式化字符串转换成串口名字.&lt;/span&gt;
    memset(name, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(WCHAR) * &lt;span&gt;32&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空内存&lt;/span&gt;
    RtlStringCchPrintfW(name, &lt;span&gt;32&lt;/span&gt;, L&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\Device\\Serial%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行字符串格式化输出. 输入到name字符串当中.
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后将字符串初始化到Unicode字符串当中.&lt;/span&gt;
    RtlInitUnicodeString(&amp;amp;CreateDeviceStr, name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意,要传入地址.

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开设备对象.&lt;/span&gt;
    *status = IoGetDeviceObjectPointer(&amp;amp;CreateDeviceStr, FILE_ALL_ACCESS, &amp;amp;pFileObj,&amp;amp;&lt;span&gt;pDeviceObj);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时FileObj执向文件对象指针.  也会获得驱动对象指针.

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否成功,如果成功,对文件对象进行引用解除.否则内存泄漏.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (STATUS_SUCCESS == *&lt;span&gt;status)
    {
        ObDereferenceObject(pFileObj);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; pDeviceObj; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回设备对象指针.&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
根据驱动对象,以及获取到设备对象.进行生成设备对象.并绑定设备对象.
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
NTSTATUS MyAttachDevice(__in PDRIVER_OBJECT pDriverObj,
                        __in PDEVICE_OBJECT oldDeviceObj,
                        __in PDEVICE_OBJECT &lt;/span&gt;*&lt;span&gt;CreateDeviceObj,
                        __in PDEVICE_OBJECT &lt;/span&gt;*&lt;span&gt;NextDeviceObj)
{
    NTSTATUS status;
    PDEVICE_OBJECT TopBindingDevice &lt;/span&gt;= NULL; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定的设备.


        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一步,生成我们的设备对象. 最后一个参数是一个二级指针.保存我们的设备对象指针.&lt;/span&gt;
    status = IoCreateDevice(pDriverObj, &lt;span&gt;0&lt;/span&gt;, NULL, oldDeviceObj-&amp;gt;DeviceType, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, FALSE, CreateDeviceObj);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (STATUS_SUCCESS !=&lt;span&gt; status)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拷贝标志位.&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (oldDeviceObj-&amp;gt;Flags &amp;amp; DO_BUFFERED_IO) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断标志是什么状态.&lt;/span&gt;
&lt;span&gt;    {
        (&lt;/span&gt;*CreateDeviceObj)-&amp;gt;Flags |= DO_BUFFERED_IO; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置我们的过滤设备的标志&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldDeviceObj-&amp;gt;Flags &amp;amp;&lt;span&gt; DO_DIRECT_IO)
    {
        (&lt;/span&gt;*CreateDeviceObj)-&amp;gt;Flags |=&lt;span&gt; DO_DIRECT_IO;
    }
    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (oldDeviceObj-&amp;gt;Characteristics &amp;amp;&lt;span&gt; FILE_DEVICE_SECURE_OPEN)
    {
        (&lt;/span&gt;*CreateDeviceObj)-&amp;gt;Characteristics |= oldDeviceObj-&amp;gt;&lt;span&gt;Characteristics;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标志位拷贝完毕.此时进行设备绑定. 也可以用另一个API&lt;/span&gt;
    status = IoAttachDeviceToDeviceStackSafe((*CreateDeviceObj), oldDeviceObj,&amp;amp;&lt;span&gt;TopBindingDevice);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (STATUS_SUCCESS !=&lt;span&gt; status)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定失败.删除我们的设备&lt;/span&gt;
        IoDeleteDevice((*&lt;span&gt;CreateDeviceObj));
        &lt;/span&gt;*CreateDeviceObj =&lt;span&gt; NULL;
        status &lt;/span&gt;=&lt;span&gt; STATUS_UNSUCCESSFUL;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
    }
    
    &lt;/span&gt;*NextDeviceObj = TopBindingDevice;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存最顶层的绑定设备.

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定设备已经启动.&lt;/span&gt;
    (*CreateDeviceObj)-&amp;gt;Flags = (*CreateDeviceObj)-&amp;gt;Flags &amp;amp;&lt;span&gt; DO_DEVICE_INITIALIZING;
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_SUCCESS;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;五丶获取过滤数据理论&lt;/h2&gt;
&lt;h3&gt; 1.过滤的理论知识.&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;在获取过滤之前.我们要知道.windows 会通过请求发送数据.所以我们要先明白请求的区分.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;我们现在知道了 设备对象(DEVICE_OBJECT) 驱动对象(DRIVER_OBJECT) 文件对象(FILE_OBJECT)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;现在我们需要知道以下的理论:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;1.没一个驱动程序都已一个驱动对象.有且只有一个.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2.每个驱动程序.可以生成如若干个设备对象.这些对象都属于驱动对象.可以从驱动对象中遍历出所有设备对象.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;3.若干个设备对象可以属于不同的驱动.依次绑定的时候会形成一个设备栈. 而在栈最前边的设备总会第一个接受请求的.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;所以我们知道. 在内核结构中请求的传递都是用 IRP结构传递的.常见的数据结构就是IRP. 但是并不是唯一的.因为内核程序中.传递请求还有很多种方法.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;不同设备也可能使用不同的请求结构来传递.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;串口设备接收到的都是IRP请求.所以我们需要对IRP请求做过滤即可. 而串口过滤的时候我们只关心两种请求, 1.读请求. 2.写请求.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;而过滤IRP请求则要关心他的功能号.  IRP请求的有主功能号跟次功能号. 相应的在IRP栈空间中.会有一个字节保存了这些功能号.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;读请求的功能号: IRP_MJ_READ&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;写请求的功能号: IRP_MJ_WRITE&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;可以通过API 来获取IRP的堆栈空间&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;PIO_STACK_LOCATION &lt;/strong&gt;&lt;br/&gt;  &lt;strong&gt;IoGetCurrentIrpStackLocation(&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    IN PIRP&lt;/strong&gt;  &lt;em&gt;&lt;a class=&quot;synParam&quot;&gt;Irp&lt;/a&gt;&lt;/em&gt;&lt;br/&gt;&lt;strong&gt;    );&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数.IRP结构体 通过IRP结构.获取当前IRP堆栈空间. 然后进行标志位判断.判断是什么数据即可.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.过滤的结局&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 我们要进行过滤数据.那么会有三种结局.&lt;/p&gt;
&lt;p&gt;1.数据通过. 那么我们过滤不会做任何事情.&lt;/p&gt;
&lt;p&gt;2.请求被否决了.我们的过滤设备否定了这个数据往下传递.那么我们上层就会弹出错误.说数据操作失败.比如CreateFile API调用的时候.我们请求让它失败.那么就不能创建文件了.&lt;/p&gt;
&lt;p&gt;3.数据被我们拷贝了一份.继续往下传递. 关于第三个应该是用得着的. 我们记录这个数据都做了什么. 如果是读我们可以记录读了什么数据.&lt;/p&gt;
&lt;p&gt; 关于第一种,我们调用两个API即可进行操作.&lt;/p&gt;
&lt;p&gt;分别是跳过当前栈空间. 然后将请求发送给真实的设备.注意,因为真实的设备已经被我们的过滤设备绑定了.所以先接受IRP请求的其实是我们的设备对象.&lt;/p&gt;
&lt;p&gt;API:&lt;/p&gt;


&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;366&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;API&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;作用&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;366&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;VOID &lt;/strong&gt;&lt;br/&gt;  &lt;strong&gt;IoSkipCurrentIrpStackLocation(&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    IN PIRP&lt;/strong&gt;  Irp&lt;br/&gt;&lt;strong&gt;    );&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;传入&lt;span&gt;IRP&lt;/span&gt;&lt;span&gt;结构&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;跳过当前的堆栈空间&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;366&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;NTSTATUS &lt;/strong&gt;&lt;br/&gt;  &lt;strong&gt;IoCallDriver(&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    IN PDEVICE_OBJECT&lt;/strong&gt;  DeviceObject,&lt;br/&gt;&lt;strong&gt;    IN OUT PIRP&lt;/strong&gt;  Irp&lt;br/&gt;&lt;strong&gt;    );&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;传入真实设备对象指针&lt;span&gt;.&lt;/span&gt;&lt;span&gt;传入&lt;/span&gt;&lt;span&gt;IRP&lt;/span&gt;&lt;span&gt;结构&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;进而将请求发送到真实的&lt;span&gt;IRP&lt;/span&gt;&lt;span&gt;结构中&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt; 3.写请求数据发送的分析&lt;/h3&gt;
&lt;p&gt; 写请求也就是串口一次发送的请求数据. 在IRP结构中有三个缓冲区.&lt;/p&gt;
&lt;p&gt;1.irp-&amp;gt;MdlAddress&lt;/p&gt;
&lt;p&gt;2.irp-&amp;gt;UserBuffer&lt;/p&gt;
&lt;p&gt;3.irp-&amp;gt;AssociatedIrp.SystemBuffer;&lt;/p&gt;
&lt;p&gt;关于IRP结构中的是哪个成员我们可以做一次解析.&lt;/p&gt;
&lt;p&gt;SystemBuffer比较简单.一般用于比较简单且不追求效率的情况下的解决方案.也就是说吧R3(应用层数据) 拷贝到内核空间.&lt;/p&gt;
&lt;p&gt;UserBuffer是追求效率的. UserBuffer直接放到应用层数据当中.我们在内核中访问.当前进程跟发送请求进程一致的情况下.内核访问应用层空间没错.但是不一致也就是说内核进程切换了.那么这个访问就结束了.&lt;/p&gt;
&lt;p&gt;因为在Windows内核中内存是一样的.但是在R3中.UserBuffer则不一致.所以切换了如果在访问UserBuffer则会访问到别的进程中.&lt;/p&gt;
&lt;p&gt;MdlAddress 这一个是将应用层的空间映射到内核空间中进行访问的.当然需要在页表(PTE)中添加一个映射.如果做开发则不需要关心这个.不用手工修改页表. 而是构造MDL就能实现,&lt;/p&gt;
&lt;p&gt;MDL可以称为 &lt;strong&gt;内存描述符表 IRP中的MdlAddress是一个MDL指针.可以从这个MDL独处一个内核空间的虚拟地址. 比UserBuffer强.同时比拷贝到SystemBuffer的方法还要好.因为内存还是在实际的地方.没有进行拷贝. 只是进行了一个映射.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以通过MdlAddress内存地址进行读取.也可以通过SystemBuffer,也可以通过UserBuffer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
PBYTE Buffer =&lt;span&gt; NULL;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种方式.&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (irp-&amp;gt;MdlAddress !=&lt;span&gt; NULL)
{
    Buffer &lt;/span&gt;= (PBYTE)MmGetSystemAddressForMdlSafe(irp-&amp;gt;&lt;span&gt;MdlAddress);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种方式.&lt;/span&gt;

&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
{
   Buffer &lt;/span&gt;= (PBYTE)Irp-&amp;gt;&lt;span&gt;UserBuffer;
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
{
   Buffer &lt;/span&gt;= (PBYTE)Irp-&amp;gt;&lt;span&gt;AssociatedIrp.SystemBuffer;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上都可以.其中有一个陌生的函数.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PVOID &lt;/strong&gt;&lt;br/&gt;  &lt;strong&gt;MmGetSystemAddressForMdlSafe(&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    __in PMDL&lt;/strong&gt;  &lt;em&gt;&lt;a class=&quot;synParam&quot;&gt;Mdl&lt;/a&gt;,&lt;/em&gt;&lt;br/&gt;&lt;strong&gt;    __in MM_PAGE_PRIORITY&lt;/strong&gt;  &lt;em&gt;&lt;a class=&quot;synParam&quot;&gt;Priority&lt;/a&gt;&lt;/em&gt;&lt;br/&gt;&lt;strong&gt;    );&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个宏返回MDL非分页虚拟内存.&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;六丶获取过滤数据的完整代码&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt; 通过上面理解请求.理解过滤. 以及获取IRP堆栈. 获取IRP Buffer空间.那么我们则可以进行写代码了.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NTSTATUS FilterData(PDEVICE_OBJECT pDeviceObj,PIRP irp)
{
    PIO_STACK_LOCATION pIrpStack &lt;/span&gt;= IoGetCurrentIrpStackLocation(irp);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前的IRP堆栈&lt;/span&gt;
&lt;span&gt;    NTSTATUS status;
    ULONG i, j;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行遍历.我们要知道发送隔了那个设备. 设备一共有32个.我们自己定义的.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后我们的真实设备都已经保存在了Next_obj数组中了.&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; MAX_COM_ID; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断真实设备是否相等.如果相等我们则进行操作.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (pDeviceObj ==&lt;span&gt; Next_Obj[i])
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
            所有电源操作.全部直接放过
            &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pIrpStack-&amp;gt;MajorFunction == IRP_MJ_POWER) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断功能号&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;直接发送说明我们已经处理了&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                PoStartNextPowerIrp(irp); 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳过当前IRP栈空间.&lt;/span&gt;
&lt;span&gt;                IoSkipCurrentIrpStackLocation(irp);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用真实设备&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; PoCallDriver(Next_Obj[i], irp);
            }

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;否则过滤我们的请求.对写请求进行过滤吧&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pIrpStack-&amp;gt;MajorFunction ==&lt;span&gt; IRP_MJ_WRITE)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取缓冲区&lt;/span&gt;
                PUCHAR Buffer =&lt;span&gt; NULL;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取长度.&lt;/span&gt;
                ULONG len = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

                len &lt;/span&gt;= pIrpStack-&amp;gt;&lt;span&gt;Parameters.Write.Length;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取MDL缓冲区&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (NULL != irp-&amp;gt;&lt;span&gt;MdlAddress)
                {
                    Buffer &lt;/span&gt;= (PUCHAR)MmGetSystemAddressForMdlSafe(irp-&amp;gt;&lt;span&gt;MdlAddress, NormalPagePriority);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取UserBuffer&lt;/span&gt;
                    Buffer = (PUCHAR)irp-&amp;gt;&lt;span&gt;UserBuffer;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; Buffer)
                {
                    Buffer &lt;/span&gt;= (PUCHAR)irp-&amp;gt;&lt;span&gt;AssociatedIrp.SystemBuffer;
                }
                
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历数组打印内容. &lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++&lt;span&gt;)
                {
                    DbgPrint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Send Data = %2x\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Buffer[j]);
                }

            }

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;然后跳过当前的IRP堆栈空间.发送到我们的真实设备.我们并不拦截如果拦截可以在这里拦截&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            IoSkipCurrentIrpStackLocation(irp);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; IoCallDriver(Next_Obj[i], irp);
        }
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;如果没有在被绑定的设备中.那么是又问题的.直接返回参数错误即可.&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    irp&lt;/span&gt;-&amp;gt;IoStatus.Information = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    irp&lt;/span&gt;-&amp;gt;IoStatus.Status =&lt;span&gt; STATUS_INVALID_PARAMETER;
    IoCompleteRequest(irp, IO_NO_INCREMENT);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成IRP请求&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_SUCCESS;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完成的驱动代码.可以直接编译.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
#include &amp;lt;Ntddk.h&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编写内核驱动需要包含NTddk头文件.&lt;/span&gt;
#include &amp;lt;ntdef.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Ntstrsafe.h&amp;gt;


&lt;span&gt;#define&lt;/span&gt; MAX_COM_ID 32  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设我们的串口有32个.&lt;/span&gt;&lt;span&gt;

VOID DriverUnload(PDRIVER_OBJECT pObj);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
函数功能.格式化端口字符串.根据端口字符串打开端口.返回获取到的设备对象指针.
参数1: id. 根据id依次初始化字符串.
参数2: 返回值状态. 因为返回值是设备对象指针.所以我们通过定义传出参数来保存真实的返回值状态.
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
PDEVICE_OBJECT RetOpenComDevicePoint(ULONG id, NTSTATUS &lt;/span&gt;*&lt;span&gt;status); 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
函数功能: 根据驱动对象.传入获取的设备对象.内部创建过滤设备.进而进行绑定. 过滤设备跟 获取的设备进行绑定.
参数1: 驱动对象.
参数2: 获取的设备对象
参数3: 创建的过滤驱动.内部创建.这个参数会保存过滤设备指针. 
参数4: 临时的过滤设备指针.保存当前过滤设备最顶端的设备.
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
NTSTATUS MyAttachDevice(__in PDRIVER_OBJECT pDriverObj,
    __in PDEVICE_OBJECT oldDeviceObj,
    __in PDEVICE_OBJECT &lt;/span&gt;*&lt;span&gt;CreateDeviceObj,
    __in PDEVICE_OBJECT &lt;/span&gt;*&lt;span&gt;NextDeviceObj);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数作用封装外层的串口绑定.&lt;/span&gt;
&lt;span&gt;VOID AttachCom(PDRIVER_OBJECT pDirVerObj);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
函数功能.过滤数据
参数1: 真实设备 Next_obj数组内容.
参数2: irp请求结构.
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
NTSTATUS FilterData(PDEVICE_OBJECT pDeviceObj, PIRP irp);

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; PDEVICE_OBJECT New_Obj[MAX_COM_ID] = { &lt;span&gt;0&lt;/span&gt; }; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们生成的过滤设备.&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; PDEVICE_OBJECT Next_Obj[MAX_COM_ID] = { &lt;span&gt;0&lt;/span&gt; }; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要绑定的设备.&lt;/span&gt;
&lt;span&gt;

NTSTATUS DriverEntry(__in &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; _DRIVER_OBJECT  *&lt;span&gt;DriverObject, __in PUNICODE_STRING  RegistryPath)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;UNICODE_STRING str = RTL_CONSTANT_STRING(L&quot;My Frist Driver \r\n&quot;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置分发函数.请求发送过来的时候会拦截.

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;串口过滤&lt;/span&gt;
    ULONG i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; IRP_MJ_MAXIMUM_FUNCTION; i++)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置分发函数.当请求发送过来的时候驱动对象会过滤.&lt;/span&gt;
&lt;span&gt;    {
        DriverObject&lt;/span&gt;-&amp;gt;MajorFunction[i] =&lt;span&gt; FilterData;
    }
    AttachCom(DriverObject); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定所有设备对象.&lt;/span&gt;
    DriverObject-&amp;gt;DriverUnload =&lt;span&gt; DriverUnload;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_SUCCESS;
}

VOID DriverUnload(PDRIVER_OBJECT pObj)
{
    DbgPrint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnLoad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数作用封装外层的串口绑定.&lt;/span&gt;
&lt;span&gt;VOID AttachCom(PDRIVER_OBJECT pDirVerObj)
{
    ULONG i;
    NTSTATUS  status;
    PDEVICE_OBJECT pGetOldDevicePoint &lt;/span&gt;= NULL; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取的旧的设备对象&lt;/span&gt;
                                              &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;依次遍历进行串口绑定过滤&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; MAX_COM_ID; i++&lt;span&gt;)
    {
        pGetOldDevicePoint &lt;/span&gt;= RetOpenComDevicePoint(i, &amp;amp;&lt;span&gt;status);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; pGetOldDevicePoint)
        {
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行绑定.&lt;/span&gt;
        MyAttachDevice(pDirVerObj, pGetOldDevicePoint, &amp;amp;New_Obj[i], &amp;amp;&lt;span&gt;Next_Obj[i]);
    }

}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过设备对象名称.获取设备对象指针.&lt;/span&gt;
PDEVICE_OBJECT RetOpenComDevicePoint(ULONG id,NTSTATUS *&lt;span&gt;status)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们知道在windows中设备名字都是依次递进的.所以我们根据id格式化字符串.\Device\Serial0 C语言中要进行转义&lt;/span&gt;
    UNICODE_STRING  CreateDeviceStr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备名称字符串.&lt;/span&gt;
    PFILE_OBJECT pFileObj  = NULL; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件对象指针.&lt;/span&gt;
    PDEVICE_OBJECT pDeviceObj = NULL;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备对象指针.&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; WCHAR name[&lt;span&gt;32&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据ID格式化字符串转换成串口名字.&lt;/span&gt;
    memset(name, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(WCHAR) * &lt;span&gt;32&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空内存&lt;/span&gt;
    RtlStringCchPrintfW(name, &lt;span&gt;32&lt;/span&gt;, L&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\Device\\Serial%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行字符串格式化输出. 输入到name字符串当中.
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后将字符串初始化到Unicode字符串当中.&lt;/span&gt;
    RtlInitUnicodeString(&amp;amp;CreateDeviceStr, name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意,要传入地址.

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开设备对象.&lt;/span&gt;
    *status = IoGetDeviceObjectPointer(&amp;amp;CreateDeviceStr, FILE_ALL_ACCESS, &amp;amp;pFileObj,&amp;amp;&lt;span&gt;pDeviceObj);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时FileObj执向文件对象指针.  也会获得驱动对象指针.

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否成功,如果成功,对文件对象进行引用解除.否则内存泄漏.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (STATUS_SUCCESS == *&lt;span&gt;status)
    {
        ObDereferenceObject(pFileObj);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; pDeviceObj; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回设备对象指针.&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
根据驱动对象,以及获取到设备对象.进行生成设备对象.并绑定设备对象.
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
NTSTATUS MyAttachDevice(__in PDRIVER_OBJECT pDriverObj,__in PDEVICE_OBJECT oldDeviceObj,__in PDEVICE_OBJECT &lt;/span&gt;*CreateDeviceObj,__in PDEVICE_OBJECT *&lt;span&gt;NextDeviceObj)
{
    NTSTATUS status;
    PDEVICE_OBJECT TopBindingDevice &lt;/span&gt;= NULL; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定的设备.


        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一步,生成我们的设备对象. 最后一个参数是一个二级指针.保存我们的设备对象指针.&lt;/span&gt;
    status = IoCreateDevice(pDriverObj, &lt;span&gt;0&lt;/span&gt;, NULL, oldDeviceObj-&amp;gt;DeviceType, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, FALSE, CreateDeviceObj);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (STATUS_SUCCESS !=&lt;span&gt; status)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拷贝标志位.&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (oldDeviceObj-&amp;gt;Flags &amp;amp; DO_BUFFERED_IO) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断标志是什么状态.&lt;/span&gt;
&lt;span&gt;    {
        (&lt;/span&gt;*CreateDeviceObj)-&amp;gt;Flags |= DO_BUFFERED_IO; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置我们的过滤设备的标志&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldDeviceObj-&amp;gt;Flags &amp;amp;&lt;span&gt; DO_DIRECT_IO)
    {
        (&lt;/span&gt;*CreateDeviceObj)-&amp;gt;Flags |=&lt;span&gt; DO_DIRECT_IO;
    }
    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (oldDeviceObj-&amp;gt;Characteristics &amp;amp;&lt;span&gt; FILE_DEVICE_SECURE_OPEN)
    {
        (&lt;/span&gt;*CreateDeviceObj)-&amp;gt;Characteristics |= oldDeviceObj-&amp;gt;&lt;span&gt;Characteristics;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标志位拷贝完毕.此时进行设备绑定. 也可以用另一个API&lt;/span&gt;
    status = IoAttachDeviceToDeviceStackSafe((*CreateDeviceObj), oldDeviceObj,&amp;amp;&lt;span&gt;TopBindingDevice);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (STATUS_SUCCESS !=&lt;span&gt; status)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定失败.删除我们的设备&lt;/span&gt;
        IoDeleteDevice((*&lt;span&gt;CreateDeviceObj));
        &lt;/span&gt;*CreateDeviceObj =&lt;span&gt; NULL;
        status &lt;/span&gt;=&lt;span&gt; STATUS_UNSUCCESSFUL;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
    }
    
    &lt;/span&gt;*NextDeviceObj = TopBindingDevice;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存最顶层的绑定设备.

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定设备已经启动.&lt;/span&gt;
    (*CreateDeviceObj)-&amp;gt;Flags = (*CreateDeviceObj)-&amp;gt;Flags &amp;amp;&lt;span&gt; DO_DEVICE_INITIALIZING;
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_SUCCESS;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
函数功能: 过滤数据.进行对数据的操作.
参数1: 真实设备指针
参数2: Irp堆栈.
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
NTSTATUS FilterData(PDEVICE_OBJECT pDeviceObj,PIRP irp)
{
    
    NTSTATUS status;
    ULONG i, j;
    PIO_STACK_LOCATION pIrpStack &lt;/span&gt;= IoGetCurrentIrpStackLocation(irp);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前的IRP堆栈&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/进行遍历.我们要知道发送隔了那个设备. 设备一共有32个.我们自己定义的.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/然后我们的真实设备都已经保存在了Next_obj数组中了.&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; MAX_COM_ID; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断真实设备是否相等.如果相等我们则进行操作.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (pDeviceObj ==&lt;span&gt; Next_Obj[i])
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
            所有电源操作.全部直接放过
            &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pIrpStack-&amp;gt;MajorFunction == IRP_MJ_POWER) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断功能号&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;直接发送说明我们已经处理了&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                PoStartNextPowerIrp(irp);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳过当前IRP栈空间.&lt;/span&gt;
&lt;span&gt;                IoSkipCurrentIrpStackLocation(irp);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用真实设备&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; PoCallDriver(Next_Obj[i], irp);
            }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    /*否则过滤我们的请求.对写请求进行过滤吧*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pIrpStack-&amp;gt;MajorFunction ==&lt;span&gt; IRP_MJ_WRITE)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取缓冲区&lt;/span&gt;
                PUCHAR Buffer =&lt;span&gt; NULL;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取长度.&lt;/span&gt;
                ULONG len = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

                len &lt;/span&gt;= pIrpStack-&amp;gt;&lt;span&gt;Parameters.Write.Length;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取MDL缓冲区&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (NULL != irp-&amp;gt;&lt;span&gt;MdlAddress)
                {
                    Buffer &lt;/span&gt;= (PUCHAR)MmGetSystemAddressForMdlSafe(irp-&amp;gt;&lt;span&gt;MdlAddress, NormalPagePriority);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取UserBuffer&lt;/span&gt;
                    Buffer = (PUCHAR)irp-&amp;gt;&lt;span&gt;UserBuffer;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (NULL ==&lt;span&gt; Buffer)
                {
                    Buffer &lt;/span&gt;= (PUCHAR)irp-&amp;gt;&lt;span&gt;AssociatedIrp.SystemBuffer;
                }
                
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历数组打印内容. &lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++&lt;span&gt;)
                {
                    DbgPrint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Send Data = %2x\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Buffer[j]);
                }

            }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    /*然后跳过当前的IRP堆栈空间.发送到我们的真实设备.我们并不拦截如果拦截可以在这里拦截*/&lt;/span&gt;
&lt;span&gt;            IoSkipCurrentIrpStackLocation(irp);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; IoCallDriver(Next_Obj[i], irp);
        }
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;*如果没有在被绑定的设备中.那么是又问题的.直接返回参数错误即可.*/&lt;/span&gt;
    irp-&amp;gt;IoStatus.Information = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    irp&lt;/span&gt;-&amp;gt;IoStatus.Status =&lt;span&gt; STATUS_INVALID_PARAMETER;
    IoCompleteRequest(irp, IO_NO_INCREMENT);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成IRP请求&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_SUCCESS;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译的时候对应的sources 文件内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
TARGETNAME=&lt;span&gt;frist
TARGETPATH&lt;/span&gt;=&lt;span&gt;obj
TARGETTYPE&lt;/span&gt;=&lt;span&gt;DRIVER
SOURCES&lt;/span&gt;=frist.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意,使用WDK写的在XP下面进行测试. 使用Debug版本编译.&lt;/p&gt;
&lt;p&gt;过滤驱动的动态卸载还没有写.明天补充.&lt;/p&gt;
</description>
<pubDate>Fri, 17 Aug 2018 11:44:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>一丶理论知识,什么是过滤. 过滤就是在不影响上层跟下层的情况下,加入我们的新一层的设备. 当请求数据发送过来的时候.我们可以对这个数据进行操作.这个就是过滤的基本含义. 二丶过滤使用的API.以及简单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/9495039.html</dc:identifier>
</item>
<item>
<title>深入理解Java中的反射机制 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/9495001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/9495001.html</guid>
<description>&lt;p&gt;JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。&lt;/p&gt;
&lt;h2 id=&quot;一class类&quot;&gt;一：Class类&lt;/h2&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;在面向对象的世界里，万物皆对象。类也是对象，类是java.lang.Class类的实例对象。&lt;/p&gt;
&lt;p&gt;Class类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。&lt;/p&gt;
&lt;p&gt;基本的 Java 类型（&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;byte&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;、&lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt;）和关键字 &lt;code&gt;void&lt;/code&gt; 也表示为 Class 对象。&lt;/p&gt;
&lt;p&gt;Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 &lt;code&gt;defineClass&lt;/code&gt; 方法自动构造的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面来自于JDK的罗里吧嗦，下面我来说下自己的体会：&lt;/p&gt;
&lt;p&gt;类不是抽象的，类是具体的！&lt;/p&gt;
&lt;p&gt;类是.class字节码文件，要想获取一个Class实例对象，首先需要获取.class字节码文件！&lt;/p&gt;
&lt;p&gt;然后调用Class对象的一些方法，进行动态获取信息以及动态调用对象方法！&lt;/p&gt;
&lt;h2 id=&quot;二类类型&quot;&gt;二：类类型&lt;/h2&gt;
&lt;p&gt;新建一个Foo类。Foo这个类也是实例对象，是Class的实例对象。&lt;/p&gt;
&lt;p&gt;不知道你是否在意过类的声明与方法的声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Foo{
       Foo(){
          //构造方法
       }
}
public Foo method(){
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道public后跟返回类型，也就可以知道class也是一个类型。&lt;/p&gt;
&lt;h4 id=&quot;如何表示class的实例对象&quot;&gt;如何表示Class的实例对象？&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        //Foo的实例对象，new 就出来了
        Foo foo1 = new Foo();
        
        //如何表示？
        //第一种：告诉我们任何一个类都有一个隐含的静态成员变量class
        Class c1 = Foo.class;
        
        //第二种:已经知道该类的对象通过getClass方法
        Class c2 = foo1.getClass();
        System.out.println(c1 == c2);
        
        //第三种：动态加载
        Class c3 = null;
        try {
            c3 = Class.forName(&quot;cn.zyzpp.reflect.Foo&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        
        System.out.println(c2 == c3);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述打印结果全是&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;尽管 c1或c2 都代表了Foo的类类型，一个类只能是Class类的一个实例变量。&lt;/p&gt;
&lt;p&gt;我们完全可以通过类的类类型（Class类型）创建类的实例对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        //此时c1 c2 c3为Class的实例对象
        try {
//            Foo foo = (Foo)c1.newInstance();
            Foo foo = (Foo)c3.newInstance();
            foo.print();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;静态加载&quot;&gt;静态加载&lt;/h4&gt;
&lt;p&gt;new 创建对象是静态加载类，在编译时刻就需要加载所有的可能使用到的类 。&lt;/p&gt;
&lt;h4 id=&quot;动态加载&quot;&gt;动态加载&lt;/h4&gt;
&lt;p&gt;使用 Class.forName(&quot;类的全称&quot;) 加载类称作为动态加载 。&lt;/p&gt;
&lt;p&gt;编译时刻加载类是静态加载类，运行时刻加载类是动态加载类。&lt;/p&gt;
&lt;h4 id=&quot;举个例子&quot;&gt;举个例子&lt;/h4&gt;
&lt;p&gt;定义Office类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Office {
    public void print() {
        System.out.println(&quot;office&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义Loading类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Loading {

    public static void main(String[] args) {
        try {
            //在运行时再动态加载类
            //arg[0] 为java执行命令时传的参数
            Class&amp;lt;?&amp;gt; a = Class.forName(args[0]);
            Office office = (Office) a.newInstance();
            office.print();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行过程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D:\&amp;gt;javac -encoding utf-8 Loading.java Office.java

D:\&amp;gt;java Loading Office
office&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;Class a=Class.forName(arg[0])&lt;/code&gt;动态加载获取类，因编译时不知道使用哪个类，因此编译没有加载任何类，直接通过编译，运行时，根据 &lt;code&gt;java Loading Office&lt;/code&gt; （office是一个类类型/类，下标arg[0]）,去确定a是哪个类。这就是动态加载。如果Office类不存在，此时运行会报错。这就是为何有时候会出现编译通过，运行报错的原因。&lt;/p&gt;
&lt;p&gt;这里需要有一个具体的概念，类就是.class字节码文件的实例对象！&lt;/p&gt;
&lt;p&gt;动态加载一个好处，就是可以随时增加需要编译的类。例如把Office改造为抽象类或接口，定义不同的子类，动态选择加载。&lt;/p&gt;
&lt;h2 id=&quot;三类的反射&quot;&gt;三：类的反射&lt;/h2&gt;
&lt;p&gt;通过上面的三种方法获取到类的类类型，就可以获取到该类的成员方法，成员变量，方法参数注释等信息。&lt;/p&gt;
&lt;p&gt;方法对象是Method类，一个成员方法就是一个Method对象。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;getMethods()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回该类继承以及自身声明的所有public的方法数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;getDeclaredMethods()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回该类自身声明的所有public的方法数组，不包括继承而来&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;成员变量也是对象，是java.lang.reflect.Field对象，Field类封装了关于成员变量的操作。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;getFields()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取所有的public的成员变量信息，包括继承的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;getDeclaredFields()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取该类自己声明的成员变量信息，public，private等&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;获取Java语言修饰符（public、private、final、static）的int返回值，再调用&lt;code&gt;Modifier.toString()&lt;/code&gt;获取修饰符的字符串形式，注意该方法会返回所有修饰符。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;getModifiers()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;以整数形式返回由此对象表示的字段的 Java 语言修饰符。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;获取注释&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;getAnnotations()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回此元素上存在的所有注释。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;getDeclaredAnnotations()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回直接存在于此元素上的所有注释。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;构造函数也是对象，是java.lang.reflect.Constructor的对象。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;getConstructors()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回所有public构造方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;getDeclaredConstructors()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回类的所有构造方法，不止public&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;完整示例&quot;&gt;完整示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    private void printClassMessage(Object obj){
        //要获取类的信息，首先获取类的类类型
        Class clazz = obj.getClass();
        //获取类的名称
        System.out.println(Modifier.toString(clazz.getModifiers())+&quot; &quot;+ clazz.getClass().getName()+&quot; &quot;+clazz.getName()+&quot;{&quot;);
        
        System.out.println(&quot;----构造方法----&quot;);
        
        //构造方法
        Constructor[] constructors = clazz.getDeclaredConstructors();
        for (Constructor constructor: constructors){
            //构造方法修饰符与名字
            System.out.print(Modifier.toString(constructor.getModifiers())+&quot; &quot;+constructor.getName()+&quot;(&quot;);
            //构造函数的所有参数类型
            Class[] parameterTypes = constructor.getParameterTypes();
            for (Class c: parameterTypes){
                System.out.print(c.getName()+&quot;, &quot;);
            }
            System.out.println(&quot;){}&quot;);
        }
        
        System.out.println(&quot;----成员变量----&quot;);
        
        //成员变量
        Field[] fields = clazz.getDeclaredFields();
        for (Field field: fields){
            System.out.println(&quot; &quot;+Modifier.toString(field.getModifiers())+&quot; &quot;+field.getType().getName() + &quot; &quot; + field.getName()+&quot;;&quot;);
        }
        
        System.out.println(&quot;----成员方法----&quot;);
        
        //Method类，方法对象,一个成员方法就是一个Method对象
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods){
            //获取方法返回类型
            Class returnType = method.getReturnType();
            //获取方法上的所有注释
            Annotation[] annotations = method.getAnnotations();
            for (Annotation annotation: annotations){
                //打印注释类型
                System.out.println(&quot; @&quot;+annotation.annotationType().getName()+&quot; &quot;);
            }
            //打印方法声明
            System.out.print(&quot; &quot;+Modifier.toString(returnType.getModifiers())+&quot; &quot;+returnType.getName()+&quot; &quot;+method.getName()+&quot;(&quot;);
            //获取方法的所有参数类型
            Class&amp;lt;?&amp;gt;[] parameterTypes = method.getParameterTypes();
            //获取方法的所有参数
            Parameter[] parameters = method.getParameters();
            for (Parameter parameter: parameters){
                //参数的类型，形参（全是arg123..）
                System.out.print(parameter.getType().getName()+&quot; &quot;+parameter.getName()+&quot;, &quot;);
            }
            System.out.println(&quot;)&quot;);
        }
        System.out.println(&quot;}&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以String对象为例，打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final java.lang.Class java.lang.String{
----构造方法----
public java.lang.String([B, int, int, ){}
 java.lang.String([C, boolean, ){}
----成员变量----
 private final [C value;
 private int hash;
----成员方法----
 @java.lang.Deprecated 
 public abstract final void getBytes(int arg0, int arg1, [B arg2, int arg3, )
 ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四方法的反射&quot;&gt;四：方法的反射&lt;/h2&gt;
&lt;p&gt;定义了一个类Foo用于测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Foo{
    public void print(String name,int num) {
        System.out.println(&quot;I am &quot;+name+&quot; age &quot;+num);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目标：通过反射获取该方法，传入参数，执行该方法！&lt;/p&gt;
&lt;p&gt;1.获取类的方法就是获取类的信息，获取类的信息首先要获取类的类类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class clazz = Foo.class;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.通过名称+参数类型获取方法对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Method method = clazz.getMethod(&quot;print&quot;, new Class[]{String.class,int.class});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.方法的反射操作是通过方法对象来调用该方法，达到和new Foo().print()一样的效果&lt;/p&gt;
&lt;p&gt;方法若无返回值则返回null&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object o = method.invoke(new Foo(),new Object[]{&quot;name&quot;,20});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五通过反射认识泛型&quot;&gt;五：通过反射认识泛型&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        ArrayList&amp;lt;String&amp;gt; stringArrayList = new ArrayList&amp;lt;&amp;gt;();
        stringArrayList.add(&quot;hello&quot;);
        ArrayList arrayList = new ArrayList();
        
        Class c1 = stringArrayList.getClass();
        Class c2 = arrayList.getClass();
        
        System.out.println(c1 == c2);

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果为&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;c1==c2的结果返回说明编译之后集合的泛型是去泛型化的。换句话说，泛型不同，对类型没有影响。&lt;/p&gt;
&lt;p&gt;Java中集合的泛型其实只是为了防止错误输入，只在编译阶段有效，绕过编译就无效。&lt;/p&gt;
&lt;h4 id=&quot;验证&quot;&gt;验证&lt;/h4&gt;
&lt;p&gt;我们可以通过反射来操作，绕过编译。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        ArrayList&amp;lt;String&amp;gt; stringArrayList = new ArrayList&amp;lt;&amp;gt;();
        stringArrayList.add(&quot;hello&quot;);
        ArrayList arrayList = new ArrayList();
        Class c1 = stringArrayList.getClass();
        Class c2 = arrayList.getClass();
        System.out.println(c1 == c2);

        try {
            Method method = c1.getMethod(&quot;add&quot;,Object.class);
            method.invoke(stringArrayList,20);
            System.out.println(stringArrayList.toString());
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;true
[hello, 20]&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 17 Aug 2018 11:32:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/9495001.html</dc:identifier>
</item>
<item>
<title>强化学习（四）用蒙特卡罗法（MC）求解 - 刘建平Pinard</title>
<link>http://www.cnblogs.com/pinard/p/9492980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pinard/p/9492980.html</guid>
<description>&lt;p&gt;　　　　在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinard/p/9463815.html&quot;&gt;强化学习（三）用动态规划（DP）求解&lt;/a&gt;中，我们讨论了用动态规划来求解强化学习预测问题和控制问题的方法。但是由于动态规划法需要在每一次回溯更新某一个状态的价值时，回溯到该状态的所有可能的后续状态。导致对于复杂问题计算量很大。同时很多时候，我们连环境的状态转化模型$P$都无法知道，这时动态规划法根本没法使用。这时候我们如何求解强化学习问题呢？本文要讨论的蒙特卡罗(Monte-Calo, MC)就是一种可行的方法。&lt;/p&gt;
&lt;p&gt;　　　　蒙特卡罗法这一篇对应Sutton书的第五章和UCL强化学习课程的第四讲部分，第五讲部分。&lt;/p&gt;

&lt;p&gt;　　　　在动态规划法中，强化学习的两个问题是这样定义的：&lt;/p&gt;
&lt;p&gt;　　　　预测问题，即给定强化学习的6个要素：状态集$S$, 动作集$A$, 模型状态转化概率矩阵$P$, 即时奖励$R$，衰减因子$\gamma$,  给定策略$\pi$， 求解该策略的状态价值函数$v(\pi)$&lt;/p&gt;
&lt;p&gt;　　　　控制问题，也就是求解最优的价值函数和策略。给定强化学习的5个要素：状态集$S$, 动作集$A$, 模型状态转化概率矩阵$P$, 即时奖励$R$，衰减因子$\gamma$, 求解最优的状态价值函数$v_{*}$和最优策略$\pi_{*}$　&lt;/p&gt;
&lt;p&gt;　　　　可见, 模型状态转化概率矩阵$P$始终是已知的，即MDP已知，对于这样的强化学习问题，我们一般称为基于模型的强化学习问题。&lt;/p&gt;
&lt;p&gt;　　　　不过有很多强化学习问题，我们没有办法事先得到模型状态转化概率矩阵$P$，这时如果仍然需要我们求解强化学习问题，那么这就是不基于模型的强化学习问题了。它的两个问题一般的定义是：　　　　&lt;/p&gt;
&lt;p&gt;　　　　预测问题，即给定强化学习的5个要素：状态集$S$, 动作集$A$, 即时奖励$R$，衰减因子$\gamma$,  给定策略$\pi$， 求解该策略的状态价值函数$v(\pi)$&lt;/p&gt;
&lt;p&gt;　　　　控制问题，也就是求解最优的价值函数和策略。给定强化学习的5个要素：状态集$S$, 动作集$A$, 即时奖励$R$，衰减因子$\gamma$, 探索率$\epsilon$, 求解最优的动作价值函数$q_{*}$和最优策略$\pi_{*}$　&lt;/p&gt;
&lt;p&gt;　　　　本文要讨论的蒙特卡罗法就是上述不基于模型的强化学习问题。&lt;/p&gt;

&lt;p&gt;　　　　 蒙特卡罗这个词之前的博文也讨论过，尤其是在之前的&lt;a title=&quot;MCMC系列&quot; href=&quot;http://www.cnblogs.com/pinard/p/MCMC(一)蒙特卡罗方法&quot; target=&quot;_blank&quot;&gt;MCMC系列&lt;/a&gt;中。它是一种通过采样近似求解问题的方法。这里的蒙特卡罗法虽然和MCMC不同，但是采样的思路还是一致的。那么如何采样呢？&lt;/p&gt;
&lt;p&gt;　　　　蒙特卡罗法通过采样若干经历完整的状态序列(episode)来估计状态的真实价值。所谓的经历完整，就是这个序列必须是达到终点的。比如下棋问题分出输赢，驾车问题成功到达终点或者失败。有了很多组这样经历完整的状态序列，我们就可以来近似的估计状态价值，进而求解预测和控制问题了。&lt;/p&gt;
&lt;p&gt;　　　　从特卡罗法法的特点来说，一是和动态规划比，它不需要依赖于模型状态转化概率。二是它从经历过的完整序列学习，完整的经历越多，学习效果越好。&lt;/p&gt;

&lt;p&gt;　　　　这里我们先来讨论蒙特卡罗法求解强化学习控制问题的方法，即策略评估。一个给定策略$\pi$的完整有T个状态的状态序列如下：$$S_1,A_1,R_2,S_2,A_2,...S_t,A_t,R_{t+1},...R_T, S_T$$&lt;/p&gt;
&lt;p&gt;　　　　回忆下&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinard/p/9426283.html&quot;&gt;强化学习（二）马尔科夫决策过程(MDP)&lt;/a&gt;中对于价值函数$v_{\pi}(s)$的定义:$$v_{\pi}(s) = \mathbb{E}_{\pi}(G_t|S_t=s ) = \mathbb{E}_{\pi}(R_{t+1} + \gamma R_{t+2} + \gamma^2R_{t+3}+...|S_t=s)$$&lt;/p&gt;
&lt;p&gt;　　　　可以看出每个状态的价值函数等于所有该状态收获的期望，同时这个收获是通过后续的奖励与对应的衰减乘积求和得到。那么对于蒙特卡罗法来说，如果要求某一个状态的状态价值，只需要求出所有的完整序列中该状态出现时候的收获再取平均值即可近似求解，也就是：$$G_t =R_{t+1} + \gamma R_{t+2} + \gamma^2R_{t+3}+...  \gamma^{T-t-1}R_{T}$$ $$v_{\pi}(s) \approx average(G_t), s.t. S_t=s$$&lt;/p&gt;
&lt;p&gt;　　　　可以看出，预测问题的求解思路还是很简单的。不过有几个点可以优化考虑。&lt;/p&gt;
&lt;p&gt;　　　　第一个点是同样一个状态可能在一个完整的状态序列中重复出现，那么该状态的收获该如何计算？有两种解决方法。第一种是仅把状态序列中第一次出现该状态时的收获值纳入到收获平均值的计算中；另一种是针对一个状态序列中每次出现的该状态，都计算对应的收获值并纳入到收获平均值的计算中。两种方法对应的蒙特卡罗法分别称为：首次访问(first visit) 和每次访问(every visit) 蒙特卡罗法。第二种方法比第一种的计算量要大一些，但是在完整的经历样本序列少的场景下会比第一种方法适用。&lt;/p&gt;
&lt;p&gt;　　　　第二个点是累进更新平均值（incremental mean)。在上面预测问题的求解公式里，我们有一个average的公式，意味着要保存所有该状态的收获值之和最后取平均。这样浪费了太多的存储空间。一个较好的方法是在迭代计算收获均值，即每次保存上一轮迭代得到的收获均值与次数，当计算得到当前轮的收获时，即可计算当前轮收获均值和次数。通过下面的公式就很容易理解这个过程：$$\mu_k = \frac{1}{k}\sum\limits_{j=1}^k x_j = \frac{1}{k}(x_k + \sum\limits_{j=1}^{k-1}x_j) =  \frac{1}{k}(x_k + (k-1)\mu_{k=1}) = \mu_{k=1} +  \frac{1}{k}(x_k -\mu_{k-1})$$&lt;/p&gt;
&lt;p&gt;　　　　这样上面的状态价值公式就可以改写成：$$N(S_t) = N(S_t)  +1 $$ $$V(S_t) = V(S_t)  + \frac{1}{N(S_t)}(G_t -  V(S_t) )$$&lt;/p&gt;
&lt;p&gt;　　　　这样我们无论数据量是多还是少，算法需要的内存基本是固定的 。&lt;/p&gt;
&lt;p&gt;　　　　有时候，尤其是海量数据做分布式迭代的时候，我们可能无法准确计算当前的次数$N(S_t)$,这时我们可以用一个系数$\alpha$来代替，即：$$V(S_t) = V(S_t)  + \alpha(G_t -  V(S_t) )$$&lt;/p&gt;
&lt;p&gt;　　　　对于动作价值函数$Q(S_t,A_t)$,也是类似的，比如对上面最后一个式子，动作价值函数版本为：$$Q(S_t, A_t) = Q(S_t, A_t) +\alpha(G_t -  Q(S_t, A_t) )$$&lt;/p&gt;
&lt;p&gt;　　　　以上就是蒙特卡罗法求解预测问题的整个过程，下面我们来看控制问题求解。&lt;/p&gt;

&lt;p&gt;　　　　蒙特卡罗法求解控制问题的思路和动态规划价值迭代的的思路类似。回忆下动态规划价值迭代的的思路， 每轮迭代先做策略评估，计算出价值$v_k(s)$，然后基于据一定的方法（比如贪婪法）更新当前策略$\pi$。最后得到最优价值函数$v_{*}$和最优策略$\pi_{*}$。&lt;/p&gt;
&lt;p&gt;　　　　和动态规划比，蒙特卡罗法不同之处体现在三点：一是预测问题策略评估的方法不同，这个第三节已经讲了。第二是蒙特卡罗法一般是优化最优动作价值函数$q_{*}$，而不是状态价值函数$v_{*}$。三是动态规划一般基于贪婪法更新策略。而蒙特卡罗法一般采用$\epsilon-$贪婪法更新。这个$\epsilon$就是我们在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinard/p/9385570.html&quot;&gt;强化学习（一）模型基础&lt;/a&gt;中讲到的第8个模型要素$\epsilon$。$\epsilon-$贪婪法通过设置一个较小的ϵ值，使用$1-\epsilon$的概率贪婪地选择目前认为是最大行为价值的行为，而用$\epsilon$ 的概率随机的从所有m 个可选行为中选择行为。用公式可以表示为：$$\pi(a|s)= \begin{cases} \epsilon/m + 1- \epsilon &amp;amp; {if\; a^{*} = \arg\max_{a \in A}Q(s,a)}\\ \epsilon/m &amp;amp; {else} \end{cases}$$&lt;/p&gt;
&lt;p&gt;　　　　在实际求解控制问题时，为了使算法可以收敛，一般$\epsilon$会随着算法的迭代过程逐渐减小，并趋于0。这样在迭代前期，我们鼓励探索，而在后期，由于我们有了足够的探索量，开始趋于保守，以贪婪为主，使算法可以稳定收敛。这样我们可以得到一张和动态规划类似的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1042406/201808/1042406-20180817164828651-1814136312.jpg&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　在这里总结下蒙特卡罗法求解强化学习控制问题的算法流程，这里的算法是在线(on-policy)版本的,相对的算法还有离线(off-policy)版本的。在线和离线的区别我们在后续的文章里面会讲。同时这里我们用的是every-visit,即个状态序列中每次出现的相同状态，都会计算对应的收获值。&lt;/p&gt;
&lt;p&gt;　　　　在线蒙特卡罗法求解强化学习控制问题的算法流程如下:&lt;/p&gt;
&lt;p&gt;　　　　输入：状态集$S$, 动作集$A$, 即时奖励$R$，衰减因子$\gamma$, 探索率$\epsilon$&lt;/p&gt;
&lt;p&gt;　　　　输出：最优的动作价值函数$q_{*}$和最优策略$\pi_{*}$&lt;/p&gt;
&lt;p&gt;　　　　1. 初始化所有的动作价值$Q(s,a) = 0$， 状态次数$N(s,a) = 0$，采样次数$k=0$，随机初始化一个策略$\pi$&lt;/p&gt;
&lt;p&gt;　　　　2. k=k+1, 基于策略$\pi$进行第k次蒙特卡罗采样，得到一个完整的状态序列: $$S_1,A_1,R_2,S_2,A_2,...S_t,A_t,R_{t+1},...R_T, S_T$$&lt;/p&gt;
&lt;p&gt;　　　　3. 对于该状态序列里出现的每一状态行为对$(S_t, A_t)$，计算其收获$G_t$, 更新其计数$N(s,a)$和行为价值函数$Q(s,t)$：$$G_t =R_{t+1} + \gamma R_{t+2} + \gamma^2R_{t+3}+...  \gamma^{T-t-1}R_{T}$$$$N(S_t, A_t) = N(S_t, A_t)  +1 $$$$Q(S_t, A_t) = Q(S_t, A_t) + \frac{1}{N(S_t, A_t)}(G_t -  Q(S_t, A_t) )$$&lt;/p&gt;
&lt;p&gt;　　       4. 基于新计算出的动作价值，更新当前的$\epsilon-$贪婪策略：$$\epsilon = \frac{1}{k}$$$$\pi(a|s)= \begin{cases} \epsilon/m + 1- \epsilon &amp;amp; {if\; a^{*} = \arg\max_{a \in A}Q(s,a)}\\ \epsilon/m &amp;amp; {else} \end{cases}$$&lt;/p&gt;
&lt;p&gt;　　　　5. 如果所有的$Q(s,a)$收敛，则对应的所有$Q(s,a)$即为最优的动作价值函数$q_{*}$。对应的策略$\pi(a|s)$即为最优策略$\pi_{*}$。否则转到第二步。&lt;/p&gt;

&lt;p&gt;　　　　蒙特卡罗法是我们第二个讲到的求解强化问题的方法，也是第一个不基于模型的强化问题求解方法。它可以避免动态规划求解过于复杂，同时还可以不事先知道环境转化模型，因此可以用于海量数据和复杂模型。但是它也有自己的缺点，这就是它每次采样都需要一个完整的状态序列。如果我们没有完整的状态序列，或者很难拿到较多的完整的状态序列，这时候蒙特卡罗法就不太好用了， 也就是说，我们还需要寻找其他的更灵活的不基于模型的强化问题求解方法。&lt;/p&gt;
&lt;p&gt;　　　　下一篇我们讨论用时序差分方法来求解强化学习预测和控制问题的方法。&lt;/p&gt;

&lt;p&gt;（欢迎转载，转载请注明出处。欢迎沟通交流： liujianping-ok@163.com） &lt;/p&gt;
</description>
<pubDate>Fri, 17 Aug 2018 10:04:00 +0000</pubDate>
<dc:creator>刘建平Pinard</dc:creator>
<og:description>在强化学习（三）用动态规划（DP）求解中，我们讨论了用动态规划来求解强化学习预测问题和控制问题的方法。但是由于动态规划法需要在每一次回溯更新某一个状态的价值时，回溯到该状态的所有可能的后续状态。导致对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pinard/p/9492980.html</dc:identifier>
</item>
</channel>
</rss>