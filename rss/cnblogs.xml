<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【全网最全的博客美化系列教程】01.添加Github项目链接 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/9346853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/9346853.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/ECJTUACM-873284962/p/9346853.html&quot; target=&quot;_blank&quot;&gt;【全网最全的博客美化系列教程】01.添加Github项目链接&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】02.添加QQ交谈链接&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】03.给博客添加一只萌萌哒的小仓鼠&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】04.访客量统计的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】05.公告栏个性时间显示的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】06.&lt;span class=&quot;postTitle2&quot;&gt;推荐和反对炫酷样式的实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】07.添加一个分享的按钮吧&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】08.自定义地址栏Logo&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】09.&lt;span class=&quot;postTitle2&quot;&gt;添加&quot;扩大/缩小浏览区域大小&quot; 按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】10.小火箭置顶特效的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】11.鼠标点击爱心特效的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】12.修改鼠标图案&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】13.鼠标点击效果升级的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】14.代码高亮设置的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】15.动画幻灯效果的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】16.给博客添加一个打赏的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】17.博客背景刷新切换效果的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】18.数学之美---动态几何线条的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】19.旋转立方体的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】20.给博客添加一个萌萌哒的看板娘&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】21.给博客添加一个夜间模式吧&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】22.添加一个文章目录特效&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】23.图片水纹特效的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】24.给博客增加一个音乐播放器特效&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】25.给博客增加一个音乐播放器特效&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】26.评论头像旋转的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】27.IP地址定位及天气预报的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】28.3D标签云动画的实现&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】29.自制HTML源码运行Javascript特效&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】30.博客文章实现markdown书写机制&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】31.用Canvas和requestAnimFrame做动画特效&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】32.公告栏添加自己的头像&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】33.添加一只舞动的小知音&lt;/p&gt;
&lt;p&gt;【全网最全的博客美化系列教程】34.皮肤背景的选择与定制&lt;/p&gt;

&lt;p&gt;你们肯定对左上角的Fork me on Github比较好奇吧，这个是怎么弄的呢，其实你们通过F12控制台去找到这个控件，你们也能实现这个效果，如下图，很明显，我们可以看到是我用红色矩形框住的这部分语句控制着这个图标，点击以后会跳转到我的Github项目管理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201807/1100338-20180721150233138-1397104225.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;139&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;https://github.com/AngelKitty&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;position: absolute; top: 0; left: 0; border: 0;&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;Fork me on GitHub&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把href的内容替换为自己的GitHub仓库地址&lt;/p&gt;
&lt;p&gt;src的图片链接地址可以设置为其他地址，我就选择直接引用了。&lt;/p&gt;
&lt;p&gt;添加方式：进入自己的博客园-&amp;gt;设置，将以上html代码添加到“页首Html代码”&lt;/p&gt;
&lt;p&gt;原理：学过一点前端知识的人就知道，这是一个很简单的东西，通过href引用链接跳转，再用img标签装上一个图片的样式。&lt;/p&gt;
&lt;p&gt;添加以后效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201807/1100338-20180721152725633-1813297021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多风格请移步至这里：&lt;a href=&quot;https://blog.github.com/2008-12-19-github-ribbons/&quot; target=&quot;_blank&quot;&gt;https://blog.github.com/2008-12-19-github-ribbons/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有很多不同风格的形式供你选择，上面都提供了源码，你只需要更改href地址，复制粘贴到指定位置就行了~~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201807/1100338-20180721154149058-411830641.png&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;455&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 21 Jul 2018 07:35:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/9346853.html</dc:identifier>
</item>
<item>
<title>浅谈Mybatis连接原理 - 只喝牛奶的杀手</title>
<link>http://www.cnblogs.com/viaiu/p/9346575.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viaiu/p/9346575.html</guid>
<description>&lt;p&gt;       众所周知数据库连接的过程，但是最近面试的人(菜面菜)，都说用的SSM框架，但是我问了一下，mybatis是怎么连接上mysql的，基本上都会说：配置好的，直接用了，今天我来抛砖引玉一下，欢迎拍砖！&lt;/p&gt;
&lt;p&gt;       什么是JDBC?&lt;/p&gt;
&lt;p&gt;       Java语言访问数据库的一种规范,是一套API。JDBC (Java Database Connectivity) API，即Java数据库编程接口，是一组标准的Java语言中的接口和类，使用这些接口和类，Java客户端程序可以访问各种不同类型的数据库。JDBC规范采用接口和实现分离的思想设计了Java数据库编程的框架。接口包含在java.sql及javax.sql包中，其中java.sql属于JavaSE，javax.sql属于JavaEE。为了使客户端程序独立于特定的数据库驱动程序，JDBC规范建议开发者使用基于接口的编程方式，即尽量使应用仅依赖java.sql及javax.sql中的接口和类。&lt;/p&gt;
&lt;p&gt;        JAVA使用JDBC访问数据库的步骤：&lt;/p&gt;
&lt;p&gt;        1.得到数据库驱动程序&lt;/p&gt;
&lt;p&gt;        2.创建数据库连接&lt;/p&gt;
&lt;p&gt;        3.执行SQL语句&lt;/p&gt;
&lt;p&gt;        4.得到结果集&lt;/p&gt;
&lt;p&gt;        5.对结果集做相应的处理(增,删,改,查)&lt;/p&gt;
&lt;p&gt;        6.关闭资源:这里释放的是DB中的资源&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;        mysql的驱动包提供了java.sql.Driver这个SPI的实现，实现类是com.mysql.jdbc.Driver，在mysql-connector-java-5.1.6.jar中，我们可以看到有一个META-INF/services目录，目录下有一个文件名为java.sql.Driver的文件，其中的内容是com.mysql.jdbc.Driver。&lt;br/&gt;在运行DriverManager.getDriver并传入参数“com.mysql.jdbc.Driver”时，DriverManager会从mysql-connector-java-5.1.6.jar中找到com.mysql.jdbc.Driver并实例化返回一个com.mysql.jdbc.Driver的实例。而SPI（Service Provider Interface）是指一些提供给你继承、扩展，完成自定义功能的类、接口或者方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;29&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/810680/201807/810680-20180721141335647-1892005076.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;       SPI是一种回调的思想，回调是指我们在使用api时，我们可以向API传入一个类或者方法，API在合适的时间调用类或者方法。SPI是在一些通用的标准中，为标准的实现产商提供的扩展点。标准在上层提供API，API内部使用了SPI，当API被客户使用时，会动态得从当前运行的classpath中寻找该SPI的实现，然后使用该SPI的实现来完成API的功能。&lt;/p&gt;
&lt;p&gt;       SPI的实现方式是：提供实现的实现类打包成Jar文件，这个Jar文件里面必须有META-INF目录，其下又有services目录，其下有一个文本文件，文件名即为SPI接口的全名，文件的内容该jar包中提供的SPI接口的实现类名。&lt;/p&gt;
&lt;p&gt;       大家看项目中Mybaits的jar包会发现：&lt;/p&gt;
&lt;div readability=&quot;44.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
private class SqlSessionInterceptor implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      SqlSession sqlSession = getSqlSession(
          SqlSessionTemplate.this.sqlSessionFactory,
          SqlSessionTemplate.this.executorType,
          SqlSessionTemplate.this.exceptionTranslator);
      try {
        Object result = method.invoke(sqlSession, args);
        if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) {
          // force commit even on non-dirty sessions because some databases require
          // a commit/rollback before calling close()
          sqlSession.commit(true);
        }
        return result;
      } catch (Throwable t) {
        Throwable unwrapped = unwrapThrowable(t);
        if (SqlSessionTemplate.this.exceptionTranslator != null &amp;amp;&amp;amp; unwrapped instanceof PersistenceException) {
          // release the connection to avoid a deadlock if the translator is no loaded. See issue #22
          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);
          sqlSession = null;
          Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);
          if (translated != null) {
            unwrapped = translated;
          }
        }
        throw unwrapped;
      } finally {
        if (sqlSession != null) {
          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);
        }
      }
    }
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      sqlSessionTemplate.SqlSessionInterceptor源码，有没有一种很熟悉的感觉？至于getConnection自己去看；用过ElasticSearch和Redis的童鞋，细心的童鞋会发现连接字符串都大同小异，连接都是类似的，标准的连接方式，提高效率，有效控制连接；&lt;/p&gt;
&lt;p&gt;      ElasticSearch的连接字符串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
protected SearchResponse getSearchResponse(String fieldName, String indexName) {
    client = null;
    SearchResponse response = null;
    try {
        getClient();
        MaxAggregationBuilder aggregation =
                AggregationBuilders
                        .max(&quot;agg&quot;)
                        .field(fieldName);
        SearchRequestBuilder request = client.prepareSearch(indexName).addAggregation(aggregation);
        response = request.execute().actionGet();
    } catch (Exception ex) {
        logger.error(&quot;getSearchResponse&quot;, ex);
    } finally {
        if (client != null) {
            client.close();
        }
        return response;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     Jedis连接字符串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
执行命令如下：
Jedis jedis = null;
try {
    jedis = jedisPool.getResource();
    //具体的命令
    jedis.executeCommand()
} catch (Exception e) {
    logger.error(&quot;op key {} error: &quot; + e.getMessage(), key, e);
} finally {
    //注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。
    if (jedis != null) 
        jedis.close(); 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       拦截器的实现都是基于代理的设计模式实现的，简单的说就是要创造一个目标类的代理类，在代理类中执行目标类的方法并在方法之前执行拦截器代码，拦截器一般有登陆拦截器——验证会话信息，权限拦截器——验证权限信息，那么SqlSessionInterceptor是干什么的？&lt;/p&gt;
&lt;p&gt;       Mybatis拦截器设计的一个初衷就是为了供用户在某些时候可以实现自己的逻辑而不必去动Mybatis固有的逻辑。打个比方，对于Executor，Mybatis中有几种实现：BatchExecutor、ReuseExecutor、SimpleExecutor和CachingExecutor。&lt;br/&gt;这个时候如果你觉得这几种实现对于Executor接口的query方法都不能满足你的要求，那怎么办呢？是要去改源码吗？当然不。我们可以建立一个Mybatis拦截器用于拦截Executor接口的query方法，在拦截之后实现自己的query方法逻辑，之后可以选择是否继续执行原来的query方法。允许你在已映射语句执行过程中的某一点进行拦截调用。有的用Mybatis拦截器统封装分页，有的用它实现读写分离等，如果读写分离还是建议配置多数据源；&lt;/p&gt;
&lt;p&gt;       spring整合mybatis之后，通过动态代理的方式，使用SqlSessionTemplate持有的sqlSessionProxy属性来代理执行sql操作，由spring管理的sqlSeesion在sql方法(增删改查等操作)执行完毕后就自行关闭了sqlSession，不需要我们对其进行手动关闭。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;       愿你有情人终成眷属，愿你有个有趣的灵魂，愿你拍我一砖！&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 21 Jul 2018 07:19:00 +0000</pubDate>
<dc:creator>只喝牛奶的杀手</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viaiu/p/9346575.html</dc:identifier>
</item>
<item>
<title>DirectX11 With Windows SDK--11 混合状态与光栅化状态 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/9346640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/9346640.html</guid>
<description>&lt;p&gt;DirectX11 With Windows SDK完整目录：&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/X-Jun/p/9028764.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然这一部分的内容主要偏向于混合（Blending），但这里还需提及一下，关于渲染管线可以绑定的状态主要有如下三种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;光栅化状态（光栅化阶段）&lt;/li&gt;
&lt;li&gt;混合状态（输出合并阶段）&lt;/li&gt;
&lt;li&gt;深度/模板状态（输出合并阶段）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Direct3D是基于状态机的，我们可以通过修改这些状态来修改渲染管线的当前行为。&lt;/p&gt;
&lt;p&gt;实际上这一章会讲述光栅化状态和混合状态这两个部分，在后续的章节会主要讲述深度/模板状态&lt;/p&gt;
&lt;p&gt;项目源码点此：&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;https://github.com/MKXJun/DX11-Without-DirectX-SDK&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于两个相同位置的像素点，规定&lt;span class=&quot;math inline&quot;&gt;\(C_{src}\)&lt;/span&gt;为源像素的颜色（从像素着色器输出的像素），&lt;span class=&quot;math inline&quot;&gt;\(C_{dst}\)&lt;/span&gt;为目标像素的颜色（已经存在于后备缓冲区上的像素）。在Direct3D中使用下面的混合等式来将源像素色和目标像素色进行混合：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{C} = \mathbf{C}_{src} \otimes \mathbf{F}_{src} \boxplus \mathbf{C}_{dst} \otimes \mathbf{F}_{dst}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\otimes\)&lt;/span&gt;运算符为分量乘法，即&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C}_{src} \otimes \mathbf{F}_{src}\)&lt;/span&gt; 实际上得到的是&lt;span class=&quot;math inline&quot;&gt;\((R_{src}*R_{dst}, G_{src}*G_{dst}, B_{src}*B_{dst})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}_{src}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}_{dst}\)&lt;/span&gt;的值，以及运算符 &lt;span class=&quot;math inline&quot;&gt;\(\boxplus\)&lt;/span&gt; 的具体含义都需要在程序中进行指定。&lt;/p&gt;
&lt;p&gt;对于Alpha通道的值，运算公式和上面的类似，并且两个等式的运算是分开进行的：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ A = A_{src} * F_{src} \boxplus A_{dst} * F_{dst}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同理该运算符 &lt;span class=&quot;math inline&quot;&gt;\(\boxplus\)&lt;/span&gt; 的含义也需要另外进行设置。&lt;/p&gt;

&lt;h2 id=&quot;混合运算符的设置&quot;&gt;混合运算符的设置&lt;/h2&gt;
&lt;p&gt;对于运算符 &lt;span class=&quot;math inline&quot;&gt;\(\boxplus\)&lt;/span&gt; 的含义，可以使用下面的枚举类型&lt;code&gt;D3D11_BLEND_OP&lt;/code&gt;来描述：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D3D11_BLEND_OP_ADD = 1&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = \mathbf{C}_{src} \otimes \mathbf{F}_{src} + \mathbf{C}_{dst} \otimes \mathbf{F}_{dst}\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(A = A_{src} * F_{src} + A_{dst} * F_{dst}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;D3D11_BLEND_OP_SUBTRACT = 2&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = \mathbf{C}_{dst} \otimes \mathbf{F}_{dst} - \mathbf{C}_{src} \otimes \mathbf{F}_{src}\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(A = A_{dst} * F_{dst} - A_{src} * F_{src}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;D3D11_BLEND_OP_REV_SUBTRACT = 3&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = \mathbf{C}_{src} \otimes \mathbf{F}_{src} - \mathbf{C}_{dst} \otimes \mathbf{F}_{dst}\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(A = A_{src} * F_{src} - A_{dst} * F_{dst}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;D3D11_BLEND_OP_MIN = 4&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = min(\mathbf{C}_{src}, \mathbf{C}_{dst})\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(A = min(A_{src}, A_{dst})\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;D3D11_BLEND_OP_MAX = 5&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = max(\mathbf{C}_{src}, \mathbf{C}_{dst})\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(A = max(A_{src}, A_{dst})\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;再次提醒，你可以分开指定运算颜色和Alpha通道的运算符。&lt;/p&gt;
&lt;h2 id=&quot;混合因子的设置&quot;&gt;混合因子的设置&lt;/h2&gt;
&lt;p&gt;对于混合公式，我们可以按需要设置混合因子。混合因子使用枚举类型&lt;code&gt;D3D11_BLEND&lt;/code&gt;类型进行描述：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;36&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;D3D11_BLEND_ZERO = 1&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}=(0,0,0)\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(F=0\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;D3D11_BLEND_ONE = 2&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}=(1,1,1)\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(F=1\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;D3D11_BLEND_SRC_COLOR = 3&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}=(r_{src},g_{src},b_{src})\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;D3D11_BLEND_INV_SRC_COLOR = 4&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}=(1-r_{src},1-g_{src},1-b_{src})\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;D3D11_BLEND_SRC_ALPHA = 5&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}=(a_{src},a_{src},a_{src})\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(F=a_{src}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;D3D11_BLEND_INV_SRC_ALPHA = 6&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}=(1-a_{src},1-a_{src},1-a_{src})\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(F=1-a_{src}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;D3D11_BLEND_DEST_ALPHA = 7&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}=(a_{dst},a_{dst},a_{dst})\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(F=a_{dst}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;D3D11_BLEND_INV_DEST_ALPHA = 8&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}=(1-a_{dst},1-a_{dst},1-a_{dst})\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(F=1-a_{dst}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;D3D11_BLEND_DEST_COLOR = 9&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}=(r_{dst},g_{dst},b_{dst})\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;D3D11_BLEND_INV_DEST_COLOR = 10&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}=(1-r_{dst},1-g_{dst},1-b_{dst})\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;D3D11_BLEND_SRC_ALPHA_SAT = 11&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}=(sat(a_{src}),sat(a_{src}),sat(a_{src}))\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(F=sat(a_{src})\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;D3D11_BLEND_BLEND_FACTOR = 14&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}\)&lt;/span&gt; 的值来自于&lt;code&gt;ID3D11DeviceContext::OMSetBlendState&lt;/code&gt;方法的&lt;code&gt;BlendFactor&lt;/code&gt;参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;D3D11_BLEND_INV_BLEND_FACTOR = 15&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{F}\)&lt;/span&gt; 的值来自于&lt;code&gt;ID3D11DeviceContext::OMSetBlendState&lt;/code&gt;方法的&lt;code&gt;BlendFactor&lt;/code&gt;参数,并设为&lt;code&gt;1 - BlendFactor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中&lt;code&gt;sat&lt;/code&gt;函数将值限定在[0.0, 1.0]之间。&lt;/p&gt;
&lt;h2 id=&quot;id3d11devicecreateblendstate方法--创建混合状态&quot;&gt;ID3D11Device::CreateBlendState方法--创建混合状态&lt;/h2&gt;
&lt;p&gt;在创建混合状态前，需要填充&lt;code&gt;D3D11_BLEND_DESC&lt;/code&gt;结构体：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct D3D11_BLEND_DESC
{
    BOOL AlphaToCoverageEnable;    // 默认关闭，这里
    BOOL IndependentBlendEnable;   // 是否每个渲染目标都有独立的混合混合描述，关闭的话都使用索引为0的描述信息
    D3D11_RENDER_TARGET_BLEND_DESC RenderTarget[ 8 ];
}   D3D11_BLEND_DESC;

typedef struct D3D11_RENDER_TARGET_BLEND_DESC
{
    BOOL BlendEnable;             // 是否开启混合
    D3D11_BLEND SrcBlend;         // 源颜色混合因子
    D3D11_BLEND DestBlend;        // 目标颜色混合因子
    D3D11_BLEND_OP BlendOp;       // 颜色混合运算符
    D3D11_BLEND SrcBlendAlpha;    // 源Alpha混合因子
    D3D11_BLEND DestBlendAlpha;   // 目标Alpha混合因子
    D3D11_BLEND_OP BlendOpAlpha;  // Alpha混合运算符
    UINT8 RenderTargetWriteMask;  // D3D11_COLOR_WRITE_ENABLE枚举类型来指定可以写入的颜色
}   D3D11_RENDER_TARGET_BLEND_DESC;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;枚举类型&lt;code&gt;D3D11_COLOR_WRITE_ENABLE&lt;/code&gt;有如下枚举值：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_COLOR_WRITE_ENABLE_RED = 1&lt;/td&gt;
&lt;td&gt;可以写入红色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_COLOR_WRITE_ENABLE_GREEN = 2&lt;/td&gt;
&lt;td&gt;可以写入绿色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_COLOR_WRITE_ENABLE_BLUE = 4&lt;/td&gt;
&lt;td&gt;可以写入蓝色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_COLOR_WRITE_ENABLE_ALPHA = 8&lt;/td&gt;
&lt;td&gt;可以写入ALPHA通道&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_COLOR_WRITE_ENABLE_ALL = 15&lt;/td&gt;
&lt;td&gt;可以写入所有颜色&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;若你想指定红色和ALPHA通道可以写入，可以用位运算与结合起来，即&lt;code&gt;D3D11_COLOR_WRITE_ENABLE_RED | D3D11_COLOR_WRITE_ENABLE_ALPHA&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ID3D11Device::CreateBlendState&lt;/code&gt;含义如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT ID3D11Device::CreateBlendState( 
    const D3D11_BLEND_DESC *pBlendStateDesc,    // [In]混合状态描述
    ID3D11BlendState **ppBlendState);           // [Out]输出混合状态&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;id3d11devicecontextomsetblendstate方法--输出合并阶段设置混合状态&quot;&gt;ID3D11DeviceContext::OMSetBlendState方法--输出合并阶段设置混合状态&lt;/h2&gt;
&lt;p&gt;方法如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ID3D11DeviceContext::OMSetBlendState(
  ID3D11BlendState *pBlendState,      // [In]混合状态，如果要使用默认混合状态则提供nullptr
  const FLOAT [4]  BlendFactor,       // [In]混合因子，如不需要可以为nullptr
  UINT             SampleMask);       // [In]采样掩码，默认为0xffffffff&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认混合状态如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;AlphaToCoverageEnable = false;
IndependentBlendEnable = false;
RenderTarget[0].BlendEnable = false;
RenderTarget[0].SrcBlend = D3D11_BLEND_ONE
RenderTarget[0].DestBlend = D3D11_BLEND_ZERO
RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD
RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE
RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO
RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD
RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;采样掩码的设置主要是针对多重采样的操作，若采样掩码的第i位为0，则对应第i次采样将不进行，但这得在实际上进行不小于i次的采样时才会起作用。通常情况下设为&lt;code&gt;0xffffffff&lt;/code&gt;来允许所有采样操作&lt;/p&gt;
&lt;h2 id=&quot;常用混合等式&quot;&gt;常用混合等式&lt;/h2&gt;
&lt;h3 id=&quot;无颜色写入混合&quot;&gt;无颜色写入混合&lt;/h3&gt;
&lt;p&gt;无颜色写入混合公式如下：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = \mathbf{C}_{src} \otimes \mathbf{F}_{src} \boxplus \mathbf{C}_{dst} \otimes \mathbf{F}_{dst}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = \mathbf{C}_{src} \otimes (0,0,0) + \mathbf{C}_{dst} \otimes (1,1,1)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = \mathbf{C}_{dst}\)&lt;/span&gt;&lt;br/&gt;同样，Alpha值也应当保留&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(A = A_{dst}\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;颜色加法混合&quot;&gt;颜色加法混合&lt;/h3&gt;
&lt;p&gt;颜色加法混合公式如下：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = \mathbf{C}_{src} \otimes \mathbf{F}_{src} \boxplus \mathbf{C}_{dst} \otimes \mathbf{F}_{dst}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = \mathbf{C}_{src} \otimes (1,1,1) + \mathbf{C}_{dst} \otimes (1,1,1)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = \mathbf{C}_{src} + \mathbf{C}_{dst}\)&lt;/span&gt;&lt;br/&gt;最终的Alpha值是多少并不影响前面的运算，因此可以设为任意值，这里设为源像素Alpha值：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(A = A_{src}\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;透明混合&quot;&gt;透明混合&lt;/h3&gt;
&lt;p&gt;透明混合公式如下：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = \mathbf{C}_{src} \otimes \mathbf{F}_{src} \boxplus \mathbf{C}_{dst} \otimes \mathbf{F}_{dst}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = \mathbf{C}_{src} \otimes (A_{src},A_{src},A_{src}) + \mathbf{C}_{dst} \otimes ((1-A_{src}),(1-A_{src}),(1-A_{src}))\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{C} = A_{src}\mathbf{C}_{src} + (1-A_{src})\mathbf{C}_{dst}\)&lt;/span&gt;&lt;br/&gt;最终的Alpha值是多少并不影响前面的运算，因此可以设为任意值，这里设为源像素Alpha值：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(A = A_{src}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但需要注意的是，透明混合的绘制顺序是十分重要的。首先必须按照摄像机到物体的距离，对物体进行排序，然后按照从后到前的顺序进行混合。因为如果一个对象是透明的，我们就可以通过它看到背后的场景。如果先绘制较前的透明物体，那么深度缓冲区的值会被刷新，然后较后的透明物体会因为深度测试不通过而不被绘制：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201807/1172605-20180721124808333-1591754041.png&quot;/&gt;&lt;br/&gt;可以看到，上图是先绘制水面然后绘制篱笆盒，这样会导致篱笆盒的下半部分因为深度比水面大而导致不通过深度测试，从而没有被绘制出来。所以在绘制透明物体前，要么关闭深度测试，要么对物体到摄像机的先后顺序进行排序，并按从后到前的顺序进行绘制。&lt;/p&gt;

&lt;h2 id=&quot;id3d11devicecreaterasterizerstate方法--创建光栅化状态&quot;&gt;ID3D11Device::CreateRasterizerState方法--创建光栅化状态&lt;/h2&gt;
&lt;p&gt;在创建光栅化状态前，我们需要先填充&lt;code&gt;D3D11_RASTERIZER_DESC&lt;/code&gt;结构体来描述光栅化状态：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct D3D11_RASTERIZER_DESC
{
    D3D11_FILL_MODE FillMode;          // 填充模式
    D3D11_CULL_MODE CullMode;          // 裁剪模式
    BOOL FrontCounterClockwise;        // 是否三角形顶点按逆时针排布时为正面
    INT DepthBias;                     // 深度偏移值
    FLOAT DepthBiasClamp;              // 深度最大允许偏移值
    FLOAT SlopeScaledDepthBias;        // 忽略
    BOOL DepthClipEnable;              // 是否允许深度测试将范围外的像素进行裁剪，默认TRUE
    BOOL ScissorEnable;                // 是否允许指定矩形范围的裁剪，若TRUE，则需要在RSSetScissor设置像素保留的矩形区域
    BOOL MultisampleEnable;            // 是否允许多重采样
    BOOL AntialiasedLineEnable;        // 是否允许反走样线，仅当多重采样为FALSE时才有效
}   D3D11_RASTERIZER_DESC;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于枚举类型&lt;code&gt;D3D11_FILL_MODE&lt;/code&gt;有如下枚举值：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;D3D11_FILL_WIREFRAME = 2&lt;/td&gt;
&lt;td&gt;线框填充方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;D3D11_FILL_SOLID = 3&lt;/td&gt;
&lt;td&gt;面填充方式&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;枚举类型&lt;code&gt;D3D11_CULL_MODE&lt;/code&gt;有如下枚举值：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_CULL_NONE = 1&lt;/td&gt;
&lt;td&gt;无背面裁剪，即三角形无论处在视野的正面还是背面都能看到&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_CULL_FRONT = 2&lt;/td&gt;
&lt;td&gt;对处在视野正面的三角形进行裁剪&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_CULL_BACK = 3&lt;/td&gt;
&lt;td&gt;对处在视野背面的三角形进行裁剪&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;光栅化创建的方法如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT ID3D11Device::CreateRasterizerState( 
    const D3D11_RASTERIZER_DESC *pRasterizerDesc,    // [In]光栅化状态描述
    ID3D11RasterizerState **ppRasterizerState) = 0;  // [Out]输出光栅化状态
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ID3D11DeviceContext::RSSetState(
  ID3D11RasterizerState *pRasterizerState);  // [In]光栅化状态，若为nullptr，则使用默认光栅化状态&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认光栅化状态如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;FillMode = D3D11_FILL_SOLID;
CullMode = D3D11_CULL_BACK;
FrontCounterClockwise = FALSE;
DepthBias = 0;
SlopeScaledDepthBias = 0.0f;
DepthBiasClamp = 0.0f;
DepthClipEnable = TRUE;
ScissorEnable = FALSE;
MultisampleEnable = FALSE;
AntialiasedLineEnable = FALSE;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;首先在常量缓冲区上，需要将材质移到每物体绘制的常量缓冲区内，因为现在从现在的例子开始，不同的物体在材质上是不同的，需要频繁更新：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;cbuffer CBChangesEveryDrawing : register(b0)
{
    row_major matrix gWorld;
    row_major matrix gWorldInvTranspose;
    row_major matrix gTexTransform;
    Material gMaterial;    // 不同物体有不同的材质
}

cbuffer CBChangesEveryFrame : register(b1)
{
    row_major matrix gView;
    float3 gEyePosW;
}

cbuffer CBChangesOnResize : register(b2)
{
    row_major matrix gProj;
}

cbuffer CBNeverChange : register(b3)
{
    DirectionalLight gDirLight[10];
    PointLight gPointLight[10];
    SpotLight gSpotLight[10];
    int gNumDirLight;
    int gNumPointLight;
    int gNumSpotLight;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在像素着色器上，可以对alpha值过低的像素进行裁剪，通过调用&lt;code&gt;clip&lt;/code&gt;函数，若参数的值小于0，则该像素会被裁剪掉，从而避免后续的光照运算。在下面的例子中，alpha值低于0.1的像素都会被裁剪掉。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 像素着色器(3D)
float4 PS_3D(VertexOut pIn) : SV_Target
{
    // 提前进行裁剪，对不符合要求的像素可以避免后续运算
    float4 texColor = tex.Sample(samLinear, pIn.Tex);
    clip(texColor.a - 0.1f);

   // ...
    
    // 计算   
    float4 litColor = texColor * (ambient + diffuse) + spec;
    litColor.a = texColor.a * gMaterial.Diffuse.a;
    return litColor;
}

// ...

// 像素着色器(2D)
float4 PS_2D(VertexOut pIn) : SV_Target
{
    float4 color = tex.Sample(samLinear, pIn.Tex);
    clip(color.a - 0.1f);
    return color;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;renderstates类&quot;&gt;RenderStates类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RenderStates&lt;/code&gt;类可以一次性创建出所有可能需要用到的状态对象，然后在需要的时候可以获取它的静态成员，并且因为使用了ComPtr智能指针，无需管理内存：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class RenderStates
{
public:
    template &amp;lt;class T&amp;gt;
    using ComPtr = Microsoft::WRL::ComPtr&amp;lt;T&amp;gt;;

    static void InitAll(const ComPtr&amp;lt;ID3D11Device&amp;gt;&amp;amp; device);
    // 使用ComPtr无需手工释放

public:
    static ComPtr&amp;lt;ID3D11RasterizerState&amp;gt; RSWireframe;   // 光栅化器状态：线框模式
    static ComPtr&amp;lt;ID3D11RasterizerState&amp;gt; RSNoCull;      // 光栅化器状态：无背面裁剪模式

    static ComPtr&amp;lt;ID3D11SamplerState&amp;gt; SSLinear;         // 采样器状态：线性过滤
    static ComPtr&amp;lt;ID3D11SamplerState&amp;gt; SSAnistropic;     // 采样器状态：各项异性过滤

    static ComPtr&amp;lt;ID3D11BlendState&amp;gt; BSNoColorWrite;     // 混合状态：不写入颜色
    static ComPtr&amp;lt;ID3D11BlendState&amp;gt; BSTransparent;      // 混合状态：透明混合
    static ComPtr&amp;lt;ID3D11BlendState&amp;gt; BSAlphaToCoverage;  // 混合状态：Alpha-To-Coverage
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而具体实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;using namespace Microsoft::WRL;

ComPtr&amp;lt;ID3D11RasterizerState&amp;gt; RenderStates::RSNoCull        = nullptr;
ComPtr&amp;lt;ID3D11RasterizerState&amp;gt; RenderStates::RSWireframe     = nullptr;

ComPtr&amp;lt;ID3D11SamplerState&amp;gt; RenderStates::SSAnistropic       = nullptr;
ComPtr&amp;lt;ID3D11SamplerState&amp;gt; RenderStates::SSLinear           = nullptr;

ComPtr&amp;lt;ID3D11BlendState&amp;gt; RenderStates::BSAlphaToCoverage    = nullptr;
ComPtr&amp;lt;ID3D11BlendState&amp;gt; RenderStates::BSNoColorWrite       = nullptr;
ComPtr&amp;lt;ID3D11BlendState&amp;gt; RenderStates::BSTransparent        = nullptr;

void RenderStates::InitAll(const ComPtr&amp;lt;ID3D11Device&amp;gt;&amp;amp; device)
{
    // ***********初始化光栅化器状态***********
    D3D11_RASTERIZER_DESC rasterizerDesc;
    ZeroMemory(&amp;amp;rasterizerDesc, sizeof(rasterizerDesc));

    // 线框模式
    rasterizerDesc.FillMode = D3D11_FILL_WIREFRAME;
    rasterizerDesc.CullMode = D3D11_CULL_BACK;
    rasterizerDesc.FrontCounterClockwise = false;
    rasterizerDesc.DepthClipEnable = true;
    HR(device-&amp;gt;CreateRasterizerState(&amp;amp;rasterizerDesc, &amp;amp;RSWireframe));

    // 无背面剔除模式
    rasterizerDesc.FillMode = D3D11_FILL_SOLID;
    rasterizerDesc.CullMode = D3D11_CULL_NONE;
    rasterizerDesc.FrontCounterClockwise = false;
    rasterizerDesc.DepthClipEnable = true;
    HR(device-&amp;gt;CreateRasterizerState(&amp;amp;rasterizerDesc, &amp;amp;RSNoCull));

    
    // ***********初始化采样器状态***********
    D3D11_SAMPLER_DESC sampDesc;
    ZeroMemory(&amp;amp;sampDesc, sizeof(sampDesc));

    // 线性过滤模式
    sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
    sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
    sampDesc.MinLOD = 0;
    sampDesc.MaxLOD = D3D11_FLOAT32_MAX;
    HR(device-&amp;gt;CreateSamplerState(&amp;amp;sampDesc, SSLinear.GetAddressOf()));

    // 各向异性过滤模式
    sampDesc.Filter = D3D11_FILTER_ANISOTROPIC;
    sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
    sampDesc.MaxAnisotropy = 4;
    sampDesc.MinLOD = 0;
    sampDesc.MaxLOD = D3D11_FLOAT32_MAX;
    HR(device-&amp;gt;CreateSamplerState(&amp;amp;sampDesc, SSAnistropic.GetAddressOf()));
    
    // ***********初始化混合状态***********
    D3D11_BLEND_DESC blendDesc;
    ZeroMemory(&amp;amp;blendDesc, sizeof(blendDesc));
    auto&amp;amp; rtDesc = blendDesc.RenderTarget[0];
    // Alpha-To-Coverage模式
    blendDesc.AlphaToCoverageEnable = true;
    blendDesc.IndependentBlendEnable = false;
    rtDesc.BlendEnable = false;
    rtDesc.RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
    HR(device-&amp;gt;CreateBlendState(&amp;amp;blendDesc, BSAlphaToCoverage.GetAddressOf()));

    // 透明混合模式
    // Color = SrcAlpha * SrcColor + (1 - SrcAlpha) * DestColor 
    // Alpha = SrcAlpha
    blendDesc.AlphaToCoverageEnable = false;
    blendDesc.IndependentBlendEnable = false;
    rtDesc.BlendEnable = true;
    rtDesc.SrcBlend = D3D11_BLEND_SRC_ALPHA;
    rtDesc.DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
    rtDesc.BlendOp = D3D11_BLEND_OP_ADD;
    rtDesc.SrcBlendAlpha = D3D11_BLEND_ONE;
    rtDesc.DestBlendAlpha = D3D11_BLEND_ZERO;
    rtDesc.BlendOpAlpha = D3D11_BLEND_OP_ADD;

    HR(device-&amp;gt;CreateBlendState(&amp;amp;blendDesc, BSTransparent.GetAddressOf()));
    
    // 无颜色写入混合模式
    // Color = DestColor
    // Alpha = DestAlpha
    rtDesc.SrcBlend = D3D11_BLEND_ZERO;
    rtDesc.DestBlend = D3D11_BLEND_ONE;
    rtDesc.BlendOp = D3D11_BLEND_OP_ADD;
    rtDesc.SrcBlendAlpha = D3D11_BLEND_ZERO;
    rtDesc.DestBlendAlpha = D3D11_BLEND_ONE;
    rtDesc.BlendOpAlpha = D3D11_BLEND_OP_ADD;
    HR(device-&amp;gt;CreateBlendState(&amp;amp;blendDesc, BSNoColorWrite.GetAddressOf()));
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gameapp类的变化&quot;&gt;GameApp类的变化&lt;/h2&gt;
&lt;p&gt;首先内含的&lt;code&gt;GameObject&lt;/code&gt;类需要添加&lt;code&gt;Material&lt;/code&gt;类的存储，并提供&lt;code&gt;GameObject::SetMaterial&lt;/code&gt;方法用于设置材质。这里不详细描述。&lt;/p&gt;
&lt;h3 id=&quot;gameappinitresource方法的变化&quot;&gt;GameApp::InitResource方法的变化&lt;/h3&gt;
&lt;p&gt;该方法有如下变化：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化了篱笆盒、墙体、地板和静止水面物体&lt;/li&gt;
&lt;li&gt;将摄像机设置为仅第三人称&lt;/li&gt;
&lt;li&gt;设置了光栅化状态为无背面裁剪模式（因为透明情况下可以看到物体的背面）&lt;/li&gt;
&lt;li&gt;设置了混合状态为透明混合模式&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool GameApp::InitResource()
{
    
    // ******************
    // 省略常量缓冲区的创建过程...
    
    // ******************
    // 初始化游戏对象
    ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; texture;
    Material material;
    material.Ambient = XMFLOAT4(0.5f, 0.5f, 0.5f, 1.0f);
    material.Diffuse = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);
    material.Specular = XMFLOAT4(0.2f, 0.2f, 0.2f, 16.0f);
    // 初始化篱笆盒
    HR(CreateDDSTextureFromFile(md3dDevice.Get(), L&quot;Texture\\WireFence.dds&quot;, nullptr, texture.GetAddressOf()));
    mWireFence.SetBuffer(md3dDevice, Geometry::CreateBox());
    mWireFence.SetWorldMatrix(XMMatrixTranslation(0.0f, 0.01f, 0.0f));
    mWireFence.SetTexTransformMatrix(XMMatrixIdentity());
    mWireFence.SetTexture(texture);
    mWireFence.SetMaterial(material);
    
    // 初始化地板
    HR(CreateDDSTextureFromFile(md3dDevice.Get(), L&quot;Texture\\floor.dds&quot;, nullptr, texture.ReleaseAndGetAddressOf()));
    mFloor.SetBuffer(md3dDevice, 
        Geometry::CreatePlane(XMFLOAT3(0.0f, -1.0f, 0.0f), XMFLOAT2(20.0f, 20.0f), XMFLOAT2(5.0f, 5.0f)));
    mFloor.SetWorldMatrix(XMMatrixIdentity());
    mFloor.SetTexTransformMatrix(XMMatrixIdentity());
    mFloor.SetTexture(texture);
    mFloor.SetMaterial(material);

    // 初始化墙体
    mWalls.resize(4);
    HR(CreateDDSTextureFromFile(md3dDevice.Get(), L&quot;Texture\\brick.dds&quot;, nullptr, texture.ReleaseAndGetAddressOf()));
    // 这里控制墙体四个面的生成
    for (int i = 0; i &amp;lt; 4; ++i)
    {
        mWalls[i].SetBuffer(md3dDevice,
            Geometry::CreatePlane(XMFLOAT3(0.0f, 0.0f, 0.0f), XMFLOAT2(20.0f, 8.0f), XMFLOAT2(5.0f, 1.5f)));
        XMMATRIX world = XMMatrixRotationX(-XM_PIDIV2) * XMMatrixRotationY(XM_PIDIV2 * i)
            * XMMatrixTranslation(i % 2 ? -10.0f * (i - 2) : 0.0f, 3.0f, i % 2 == 0 ? -10.0f * (i - 1) : 0.0f);
        mWalls[i].SetMaterial(material);
        mWalls[i].SetWorldMatrix(world);
        mWalls[i].SetTexTransformMatrix(XMMatrixIdentity());
        mWalls[i].SetTexture(texture);
    }
        
    // 初始化水
    material.Ambient = XMFLOAT4(0.5f, 0.5f, 0.5f, 1.0f);
    material.Diffuse = XMFLOAT4(1.0f, 1.0f, 1.0f, 0.5f);
    material.Specular = XMFLOAT4(0.8f, 0.8f, 0.8f, 32.0f);
    HR(CreateDDSTextureFromFile(md3dDevice.Get(), L&quot;Texture\\water.dds&quot;, nullptr, texture.ReleaseAndGetAddressOf()));
    mWater.SetBuffer(md3dDevice,
        Geometry::CreatePlane(XMFLOAT3(), XMFLOAT2(20.0f, 20.0f), XMFLOAT2(10.0f, 10.0f)));
    mWater.SetWorldMatrix(XMMatrixIdentity());
    mWater.SetTexTransformMatrix(XMMatrixIdentity());
    mWater.SetTexture(texture);
    mWater.SetMaterial(material);

    // 省略初始化采样器状态...

    
    // ******************
    // 初始化常量缓冲区的值
    // 初始化每帧可能会变化的值
    mCameraMode = CameraMode::ThirdPerson;
    auto camera = std::shared_ptr&amp;lt;ThirdPersonCamera&amp;gt;(new ThirdPersonCamera);
    mCamera = camera;
    
    camera-&amp;gt;SetTarget(XMFLOAT3(0.0f, 0.5f, 0.0f));
    camera-&amp;gt;SetDistance(5.0f);
    camera-&amp;gt;SetDistanceMinMax(2.0f, 14.0f);
    mCBFrame.view = mCamera-&amp;gt;GetView();
    XMStoreFloat4(&amp;amp;mCBFrame.eyePos, mCamera-&amp;gt;GetPositionXM());

    // 初始化仅在窗口大小变动时修改的值
    mCamera-&amp;gt;SetFrustum(XM_PI / 3, AspectRatio(), 0.5f, 1000.0f);
    mCBOnReSize.proj = mCamera-&amp;gt;GetProj();

    // 省略灯光的初始化...

    // 更新不容易被修改的常量缓冲区资源
    md3dImmediateContext-&amp;gt;UpdateSubresource(mConstantBuffers[2].Get(), 0, nullptr, &amp;amp;mCBOnReSize, 0, 0);
    md3dImmediateContext-&amp;gt;UpdateSubresource(mConstantBuffers[3].Get(), 0, nullptr, &amp;amp;mCBNeverChange, 0, 0);

    // 初始化所有渲染状态
    RenderStates::InitAll(md3dDevice);
    
    
    // ******************************
    // 设置好渲染管线各阶段所需资源

    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexLayout3D.Get());
    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    
    md3dImmediateContext-&amp;gt;VSSetShader(mVertexShader3D.Get(), nullptr, 0);
    // 预先绑定各自所需的缓冲区，其中每帧更新的缓冲区需要绑定到两个缓冲区上
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(0, 1, mConstantBuffers[0].GetAddressOf());
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(1, 1, mConstantBuffers[1].GetAddressOf());
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(2, 1, mConstantBuffers[2].GetAddressOf());

    md3dImmediateContext-&amp;gt;RSSetState(RenderStates::RSNoCull.Get());

    md3dImmediateContext-&amp;gt;PSSetConstantBuffers(0, 1, mConstantBuffers[0].GetAddressOf());
    md3dImmediateContext-&amp;gt;PSSetConstantBuffers(1, 1, mConstantBuffers[1].GetAddressOf());
    md3dImmediateContext-&amp;gt;PSSetConstantBuffers(3, 1, mConstantBuffers[3].GetAddressOf());
    md3dImmediateContext-&amp;gt;PSSetShader(mPixelShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;PSSetSamplers(0, 1, mSamplerState.GetAddressOf());

    md3dImmediateContext-&amp;gt;OMSetBlendState(RenderStates::BSTransparent.Get(), nullptr, 0xFFFFFFFF);

    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappupdatescene方法的变化&quot;&gt;GameApp::UpdateScene方法的变化&lt;/h3&gt;
&lt;p&gt;现在摄像机只有第三人称：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::UpdateScene(float dt)
{

    // 更新鼠标事件，获取相对偏移量
    Mouse::State mouseState = mMouse-&amp;gt;GetState();
    Mouse::State lastMouseState = mMouseTracker.GetLastState();
    POINT center = { mClientWidth / 2, mClientHeight / 2 };
    int dx = mouseState.x - center.x, dy = mouseState.y - center.y;
    mMouseTracker.Update(mouseState);
    Keyboard::State keyState = mKeyboard-&amp;gt;GetState();
    mKeyboardTracker.Update(keyState);
    // 固定鼠标位置到窗口中间
    ClientToScreen(MainWnd(), &amp;amp;center);
    SetCursorPos(center.x, center.y);
    // 获取子类
    auto cam3rd = std::dynamic_pointer_cast&amp;lt;ThirdPersonCamera&amp;gt;(mCamera);

    
    // 第三人称摄像机的操作
    // 绕原点旋转
    cam3rd-&amp;gt;SetTarget(XMFLOAT3());
    cam3rd-&amp;gt;RotateX(dy * dt * 1.25f);
    cam3rd-&amp;gt;RotateY(dx * dt * 1.25f);
    cam3rd-&amp;gt;Approach(-mouseState.scrollWheelValue / 120 * 1.0f);

    // 更新观察矩阵，并更新每帧缓冲区
    mCamera-&amp;gt;UpdateViewMatrix();
    XMStoreFloat4(&amp;amp;mCBFrame.eyePos, mCamera-&amp;gt;GetPositionXM());
    mCBFrame.view = mCamera-&amp;gt;GetView();
    

    // 重置滚轮值
    mMouse-&amp;gt;ResetScrollWheelValue();
    
    
    // 退出程序，这里应向窗口发送销毁信息
    if (keyState.IsKeyDown(Keyboard::Escape))
        SendMessage(MainWnd(), WM_DESTROY, 0, 0);
    
    md3dImmediateContext-&amp;gt;UpdateSubresource(mConstantBuffers[1].Get(), 0, nullptr, &amp;amp;mCBFrame, 0, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappdrawscene方法的变化&quot;&gt;GameApp::DrawScene方法的变化&lt;/h3&gt;
&lt;p&gt;对于3D物体的，要先绘制不透明的物体，然后再绘制透明的物体。而对于透明的物体，这里一定要先绘制靠后的物体，然后才是靠前的物体。这里无论视角怎么变化，物体的先后顺序都是不会改变的，所以不会出现有物体的一部分无法绘制的情况：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::DrawScene()
{
    assert(md3dImmediateContext);
    assert(mSwapChain);

    md3dImmediateContext-&amp;gt;ClearRenderTargetView(mRenderTargetView.Get(), reinterpret_cast&amp;lt;const float*&amp;gt;(&amp;amp;Colors::Black));
    md3dImmediateContext-&amp;gt;ClearDepthStencilView(mDepthStencilView.Get(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);

    
    // 绘制几何模型
    // 绘制不透明对象
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    for (auto&amp;amp; wall : mWalls)
        wall.Draw(md3dImmediateContext);
    mFloor.Draw(md3dImmediateContext);

    // 绘制透明对象
    md3dImmediateContext-&amp;gt;RSSetState(RenderStates::RSNoCull.Get());
    // 篱笆盒稍微抬起一点高度
    mWireFence.SetWorldMatrix(XMMatrixTranslation(2.0f, 0.01f, 0.0f));
    mWireFence.Draw(md3dImmediateContext);
    mWireFence.SetWorldMatrix(XMMatrixTranslation(-2.0f, 0.01f, 0.0f));
    mWireFence.Draw(md3dImmediateContext);
    // 绘制了篱笆盒后再绘制水面
    mWater.Draw(md3dImmediateContext);
    
    // 绘制Direct2D部分
    md2dRenderTarget-&amp;gt;BeginDraw();
    std::wstring text = L&quot;当前摄像机模式：第三人称视角  Esc退出\n&quot;
        &quot;鼠标移动控制视野 滚轮控制第三人称观察距离&quot;;
    md2dRenderTarget-&amp;gt;DrawTextW(text.c_str(), (UINT32)text.length(), mTextFormat.Get(),
        D2D1_RECT_F{ 0.0f, 0.0f, 500.0f, 60.0f }, mColorBrush.Get());
    HR(md2dRenderTarget-&amp;gt;EndDraw());

    HR(mSwapChain-&amp;gt;Present(0, 0));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终效果如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201807/1172605-20180721142200781-1762243781.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Jul 2018 06:59:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/9346640.html</dc:identifier>
</item>
<item>
<title>T-SQL:是NULL不是NULL（七） - 荔枝味可乐。</title>
<link>http://www.cnblogs.com/yuanzijian-ruiec/p/9346713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanzijian-ruiec/p/9346713.html</guid>
<description>&lt;p&gt;首先SQL SERVER 是一个三值逻辑 即谓词计算结果为TRUE,FALSE,UNKNOWN &lt;/p&gt;
&lt;p&gt;标准的谓词都是遵循这种规则的&lt;/p&gt;
&lt;p&gt;如 slary&amp;gt;0  会返回计算结果为TRUE 结果的行拒绝FALSE和UNKNOWN 结果&lt;/p&gt;
&lt;p&gt;   但不是所有的谓词处理都是这样的  如果出现在CHECK约束中   计算结果为不为FALSE 拒绝FALSE 意味着接受TRUE和UNKNOWN&lt;/p&gt;
&lt;p&gt;TRUE 和FALSE 我们都知道什么意思 那 UNKNOWN 具体怎么避免呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.UNKNOWN &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IS UNKNOWN  得到结果 NULL  这很正常   NOT IS 取反结果 还NULL  这让人很费解 NOT UNKNOWN依旧等于UNKNOWN&lt;/p&gt;
&lt;p&gt;NULL=NULL 计算结果为UNKNOWN  NULL表示缺失，简单点说就是 一未知的值不可能等于另一个未知的值&lt;/p&gt;
&lt;p&gt;所以 SQL 提供两个谓词 来判断是不是NULL  IS NULL 和 IS NOT NULL  替代=NULL &amp;lt;&amp;gt;NULL&lt;/p&gt;
&lt;p&gt;记住  &amp;lt;&amp;gt;    计算结果不包括空 例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; custid, country, region, city
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Sales.Customers
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; region &lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;WA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201807/1222663-20180721144735035-1751149758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201807/1222663-20180721144854674-1605115796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到第一幅图并无NULL 行&lt;/p&gt;
&lt;p&gt;接着我们查询为NULL的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; custid, country, region, city
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Sales.Customers
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; region &lt;span&gt;=&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201807/1222663-20180721144958920-2014017001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们用 IS NULL 代替 =&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; custid, country, region, city
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Sales.Customers
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; region &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201807/1222663-20180721145105827-1546215658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想反回 不等于 wa 包括NULL &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; custid, country, region, city
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Sales.Customers
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; region &lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;WA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
   &lt;span&gt;OR&lt;/span&gt; region &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201807/1222663-20180721145218340-1945938975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;奇怪的是 在分组和排序谓词中 NULL=NULL 是成立的&lt;/p&gt;
&lt;p&gt;在 唯一约束中 NULL 也是被认为相等的&lt;/p&gt;

</description>
<pubDate>Sat, 21 Jul 2018 06:57:00 +0000</pubDate>
<dc:creator>荔枝味可乐。</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanzijian-ruiec/p/9346713.html</dc:identifier>
</item>
<item>
<title>Bootstrap 可视化布局--拖拽后弹窗进行编辑 - 木石心</title>
<link>http://www.cnblogs.com/sinosaurus/p/9346680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sinosaurus/p/9346680.html</guid>
<description>&lt;blockquote readability=&quot;7.1775700934579&quot;&gt;
&lt;p&gt;最近后台想一个需求，使用&lt;a href=&quot;http://www.bootcss.com/p/layoutit/&quot;&gt;可视化布局-中文&lt;/a&gt; | &lt;a href=&quot;https://www.layoutit.com/build&quot;&gt;en&lt;/a&gt;中拖拽表格后，弹窗进行编辑，保存下载后在后台生成pdf格式。&lt;br/&gt;奈何各种问题不断，使用 &lt;code&gt;jquery-ui&lt;/code&gt;中的 &lt;a href=&quot;https://jqueryui.com/draggable/&quot;&gt;draggable&lt;/a&gt;各种坑不断，哎，一言难尽，最怕这种不是自己写的，只能不断踩坑，踩着踩着就好了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最终目的效果图&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Sinosaurus/myBlogs/9dcd4ae89dd07c4ae5654a5796d3e6cc8de47433/imgs/jquery/layoutS.gif&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原始效果是没有之后的弹窗，需要点击才会有&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;思路1： 将点击的代码直接放到 拖拽结束时使用即可&lt;/li&gt;
&lt;li&gt;思路2： 找到被拖拽的对象，对其进行修改即可&lt;/li&gt;
&lt;li&gt;思路3： 找到点击弹窗的按钮(需要对应到指定的对象)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;难点&quot;&gt;难点&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如何找到指定的元素，每次拖拽添加都会克隆元素，若是通过元素查找便会是一个数组，很多个，这个完全不现实，因而考虑给每一个添加指定的标识。&lt;br/&gt;若是考虑找到被克隆对象，目前我尝试多种方式，直接是找不到，一脸懵逼我，我也很无奈，直接两者间没有联系，尝试过&lt;code&gt;event&lt;/code&gt;来找，依旧没有任何效果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;代码看问题&quot;&gt;代码看问题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;preview&quot;&amp;gt;表格&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;view&quot;&amp;gt;
    &amp;lt;table class=&quot;table&quot; contenteditable=&quot;true&quot;&amp;gt;
        &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;编号&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;产品&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;交付时间&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;状态&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;/thead&amp;gt;
        &amp;lt;tbody&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;TB - Monthly&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;01/04/2012&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;Default&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr class=&quot;success&quot;&amp;gt;
            &amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;TB - Monthly&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;01/04/2012&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;Approved&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr class=&quot;error&quot;&amp;gt;
            &amp;lt;td&amp;gt;2&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;TB - Monthly&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;02/04/2012&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;Declined&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr class=&quot;warning&quot;&amp;gt;
            &amp;lt;td&amp;gt;3&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;TB - Monthly&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;03/04/2012&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;Pending&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr class=&quot;info&quot;&amp;gt;
            &amp;lt;td&amp;gt;4&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;TB - Monthly&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;04/04/2012&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;Call in to confirm&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;/tbody&amp;gt;
    &amp;lt;/table&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 拖拽的代码
$(&quot;.sidebar-nav .box&quot;).draggable({
    connectToSortable: &quot;.column&quot;,
    helper: &quot;clone&quot;,
    handle: &quot;.drag&quot;,
    start: function(e,t) {
        if (!startdrag) stopsave++;
        startdrag = 1;
    },
    drag: function(e, t) {
        t.helper.width(400)
    },
    stop: function(e) {
        handleJsIds(e);
        if(stopsave&amp;gt;0) stopsave--;
        startdrag = 0;
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果图&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Sinosaurus/myBlogs/9dcd4ae89dd07c4ae5654a5796d3e6cc8de47433/imgs/jquery/layout.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;各种思路尝试的结果就不一一列举了都是泪&quot;&gt;各种思路尝试的结果，就不一一列举了，都是泪&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用 &lt;code&gt;jquery-ui&lt;/code&gt;的&lt;code&gt;draggable&lt;/code&gt;的各类属性，始终无效果，&lt;code&gt;modal:ture&lt;/code&gt;无法弹窗，结合&lt;code&gt;dialog&lt;/code&gt;却无法找到指定被修改对象&lt;/li&gt;
&lt;li&gt;最终症结所在，便是如何找到你刚拖拽的对象身上，这样一切都好解决&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;开启找到指定拖拽的对象之旅&quot;&gt;开启找到指定拖拽的对象之旅&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;思路是有，一直不知道如何有效实现，当看到此处代码时，一切就豁然开朗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 此处是在拖拽 stop时被调用的
function handleJsIds(e) {
    handleModalIds();
    handleAccordionIds();
    handleCarouselIds();
    handleTabsIds();
    handleDialog()
}
// 这里看到给每个添加属性，就知道还是要走这条路了
function handleCarouselIds() {
    var e = $(&quot;.demo #myCarousel&quot;);
    var t = randomNumber();
    var n = &quot;carousel-&quot; + t;
    e.attr(&quot;id&quot;, n);
    e.find(&quot;.carousel-indicators li&quot;).each(function(e, t) {
        $(t).attr(&quot;data-target&quot;, &quot;#&quot; + n)
    });
    e.find(&quot;.left&quot;).attr(&quot;href&quot;, &quot;#&quot; + n);
    e.find(&quot;.right&quot;).attr(&quot;href&quot;, &quot;#&quot; + n)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;开始时，一直都在找弹出按钮，因为点击，会出现修改的modal层&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Sinosaurus/myBlogs/9dcd4ae89dd07c4ae5654a5796d3e6cc8de47433/imgs/jquery/layoutY.gif&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;重新定义一个函数&lt;code&gt;hangleDialog&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 用来触发弹窗
function handleDialog(params) {
    // 找到所有的按钮
    var e = $('body.edit .demo [data-target=#editorModal]')
    const n = randomNumber()
    e.each(function(i, t) {
        // 判断是否添加了flag属性
        if (!$(t).attr('flag')) {
            $(t).attr('flag', n)
            // 触发按钮弹窗
            $(t).trigger('click')
        }
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;目前而言，这个是改动最小的，基本没有对源代码进行修改，只是单纯添加一段而已，个人十分喜欢，其他方式改动幅度过大，效果既没出来，还不敢保证是否会影响其他效果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;补充&quot;&gt;补充&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;源代码 ，虽说原作者不允许公开，但还是让我找到了，仅供技术探讨吧&lt;a href=&quot;https://github.com/justjavac/layoutit&quot;&gt;layoutit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一个插件 通过html可以找到对应绑定的事件 &lt;a href=&quot;https://chrome.google.com/webstore/detail/visual-event/pbmmieigblcbldgdokdjpioljjninaim?utm_source=chrome-ntp-icon&quot;&gt;visual event&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 21 Jul 2018 06:55:00 +0000</pubDate>
<dc:creator>木石心</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sinosaurus/p/9346680.html</dc:identifier>
</item>
<item>
<title>基于Prometheus搭建SpringCloud全方位立体监控体系 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9346547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9346547.html</guid>
<description>&lt;p&gt;最近公司在联合运维做一套全方位监控的系统，应用集群的技术栈是SpringCloud体系。虽然本人没有参与具体基础架构的研发，但是从应用引入的包和一些资料的查阅大致推算出具体的实现方案，这里做一次推演，详细记录一下整个搭建过程。&lt;/p&gt;

&lt;p&gt;Prometheus(普罗米修斯，官网是https://prometheus.io/)，是一个开源的系统监控和告警的工具包，其采用Pull方式采集时间序列的度量数据，通过Http协议传输。它的工作方式是被监控的服务需要公开一个Prometheus端点，这端点是一个HTTP接口，该接口公开了度量的列表和当前的值，然后Prometheus应用从此接口定时拉取数据，一般可以存放在时序数据库中，然后通过可视化的Dashboard(例如Promdash或者Grafana)进行数据展示。当然，此文章不打算深入研究这个工具，只做应用层面的展示。这篇文章将会用到下面几个技术栈：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SpringCloud体系，主要是注册中心和注册客户端。&lt;/li&gt;
&lt;li&gt;spring-boot-starter-actuator，主要是提供了Prometheus端点，不用重复造轮子。&lt;/li&gt;
&lt;li&gt;Prometheus的Java客户端。&lt;/li&gt;
&lt;li&gt;Prometheus应用。&lt;/li&gt;
&lt;li&gt;io.micrometer，SpringBoot标准下使用的度量工具包。&lt;/li&gt;
&lt;li&gt;Grafana，可视化的Dashboard。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里所有的软件或者依赖全部使用当前的最新版本，如果有坑踩了再填。其实，Prometheus本身也开发了一套Counter、Gauge、Timer等相关接口，不过SpringBoot中使用了io.micrometer中的套件，所以本文不深入分析Prometheus的Java客户端。&lt;/p&gt;

&lt;p&gt;在SpringBoot2.X中，spring-boot-starter-actuator引入了&lt;a href=&quot;https://micrometer.io/&quot;&gt;io.micrometer&lt;/a&gt;，对1.X中的metrics进行了重构，主要特点是支持tag/label，配合支持tag/label的监控系统，使得我们可以更加方便地对metrics进行多维度的统计查询及监控。io.micrometer目前支持Counter、Gauge、Timer、Summary等多种不同类型的度量方式(不知道有没有遗漏)，下面逐个简单分析一下它们的作用和使用方式。 需要在SpringBoot项目下引入下面的依赖：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;micrometer-core&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;${micrometer.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前最新的micrometer.version为1.0.5。注意一点的是：&lt;strong&gt;io.micrometer支持Tag(标签)的概念&lt;/strong&gt;，Tag是其metrics是否能够有多维度的支持的基础，Tag必须成对出现，也就是必须配置也就是偶数个Tag，有点类似于K-V的关系。&lt;/p&gt;
&lt;h2 id=&quot;counter&quot;&gt;Counter&lt;/h2&gt;
&lt;p&gt;Counter(计数器)简单理解就是一种只增不减的计数器。它通常用于记录服务的请求数量、完成的任务数量、错误的发生数量等等。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;

/**
 * @author throwable
 * @version v1.0
 * @description
 * @since 2018/7/19 23:10
 */
public class CounterSample {

    public static void main(String[] args) throws Exception {
        //tag必须成对出现，也就是偶数个
        Counter counter = Counter.builder(&quot;counter&quot;)
                .tag(&quot;counter&quot;, &quot;counter&quot;)
                .description(&quot;counter&quot;)
                .register(new SimpleMeterRegistry());
        counter.increment();
        counter.increment(2D);
        System.out.println(counter.count());
        System.out.println(counter.measure());
        //全局静态方法
        Metrics.addRegistry(new SimpleMeterRegistry());
        counter = Metrics.counter(&quot;counter&quot;, &quot;counter&quot;, &quot;counter&quot;);
        counter.increment(10086D);
        counter.increment(10087D);
        System.out.println(counter.count());
        System.out.println(counter.measure());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;3.0
[Measurement{statistic='COUNT', value=3.0}]
20173.0
[Measurement{statistic='COUNT', value=20173.0}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Counter的Measurement的statistic(可以理解为度量的统计角度)只有COUNT，也就是它只具备计数(它只有增量的方法，因此只增不减)，这一点从它的接口定义可知：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Counter extends Meter {

  default void increment() {
        increment(1.0);
  }

  void increment(double amount);

  double count();

  //忽略其他方法或者成员
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Counter还有一个衍生类型FunctionCounter，它是基于函数式接口ToDoubleFunction进行计数统计的，用法差不多。&lt;/p&gt;
&lt;h2 id=&quot;gauge&quot;&gt;Gauge&lt;/h2&gt;
&lt;p&gt;Gauge(仪表)是一个表示单个数值的度量，它可以表示任意地上下移动的数值测量。Gauge通常用于变动的测量值，如当前的内存使用情况，同时也可以测量上下移动的&quot;计数&quot;，比如队列中的消息数量。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import io.micrometer.core.instrument.Gauge;
import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author throwable
 * @version v1.0
 * @description
 * @since 2018/7/19 23:30
 */
public class GaugeSample {

    public static void main(String[] args) throws Exception {
        AtomicInteger atomicInteger = new AtomicInteger();
        Gauge gauge = Gauge.builder(&quot;gauge&quot;, atomicInteger, AtomicInteger::get)
                .tag(&quot;gauge&quot;, &quot;gauge&quot;)
                .description(&quot;gauge&quot;)
                .register(new SimpleMeterRegistry());
        atomicInteger.addAndGet(5);
        System.out.println(gauge.value());
        System.out.println(gauge.measure());
        atomicInteger.decrementAndGet();
        System.out.println(gauge.value());
        System.out.println(gauge.measure());
        //全局静态方法，返回值竟然是依赖值，有点奇怪，暂时不选用
        Metrics.addRegistry(new SimpleMeterRegistry());
        AtomicInteger other = Metrics.gauge(&quot;gauge&quot;, atomicInteger, AtomicInteger::get);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;5.0
[Measurement{statistic='VALUE', value=5.0}]
4.0
[Measurement{statistic='VALUE', value=4.0}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Gauge关注的度量统计角度是VALUE(值)，它的构建方法中依赖于函数式接口ToDoubleFunction的实例(如例子中的实例方法引用AtomicInteger::get)和一个依赖于ToDoubleFunction改变自身值的实例(如例子中的AtomicInteger实例)，它的接口方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Gauge extends Meter {

  double value();

  //忽略其他方法或者成员
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;timer&quot;&gt;Timer&lt;/h2&gt;
&lt;p&gt;Timer(计时器)同时测量一个特定的代码逻辑块的调用(执行)速度和它的时间分布。简单来说，就是在调用结束的时间点记录整个调用块执行的总时间，适用于测量短时间执行的事件的耗时分布，例如消息队列消息的消费速率。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import io.micrometer.core.instrument.Timer;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;

import java.util.concurrent.TimeUnit;

/**
 * @author throwable
 * @version v1.0
 * @description
 * @since 2018/7/19 23:44
 */
public class TimerSample {

    public static void main(String[] args) throws Exception{
        Timer timer = Timer.builder(&quot;timer&quot;)
                .tag(&quot;timer&quot;,&quot;timer&quot;)
                .description(&quot;timer&quot;)
                .register(new SimpleMeterRegistry());
        timer.record(()-&amp;gt;{
            try {
                TimeUnit.SECONDS.sleep(2);
            }catch (InterruptedException e){
                //ignore
            }
        });
        System.out.println(timer.count());
        System.out.println(timer.measure());
        System.out.println(timer.totalTime(TimeUnit.SECONDS));
        System.out.println(timer.mean(TimeUnit.SECONDS));
        System.out.println(timer.max(TimeUnit.SECONDS));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;1
[Measurement{statistic='COUNT', value=1.0}, Measurement{statistic='TOTAL_TIME', value=2.000603975}, Measurement{statistic='MAX', value=2.000603975}]
2.000603975
2.000603975
2.000603975&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Timer的度量统计角度主要包括记录执行的最大时间、总时间、平均时间、执行完成的总任务数，它提供多种的统计方法变体：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Timer extends Meter, HistogramSupport {

  void record(long amount, TimeUnit unit);

  default void record(Duration duration) {
      record(duration.toNanos(), TimeUnit.NANOSECONDS);
  }

  &amp;lt;T&amp;gt; T record(Supplier&amp;lt;T&amp;gt; f);
    
  &amp;lt;T&amp;gt; T recordCallable(Callable&amp;lt;T&amp;gt; f) throws Exception;

  void record(Runnable f);

  default Runnable wrap(Runnable f) {
      return () -&amp;gt; record(f);
  }

  default &amp;lt;T&amp;gt; Callable&amp;lt;T&amp;gt; wrap(Callable&amp;lt;T&amp;gt; f) {
    return () -&amp;gt; recordCallable(f);
  }

  //忽略其他方法或者成员
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些record或者包装方法可以根据需要选择合适的使用，另外，一些度量属性(如下限和上限)或者单位可以自行配置，具体属性的相关内容可以查看DistributionStatisticConfig类，这里不详细展开。&lt;/p&gt;
&lt;p&gt;另外，Timer有一个衍生类LongTaskTimer，主要是用来记录正在执行但是尚未完成的任务数，用法差不多。&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Summary(摘要)用于跟踪事件的分布。它类似于一个计时器，但更一般的情况是，它的大小并不一定是一段时间的测量值。在micrometer中，对应的类是DistributionSummary，它的用法有点像Timer，但是记录的值是需要直接指定，而不是通过测量一个任务的执行时间。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import io.micrometer.core.instrument.DistributionSummary;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;

/**
 * @author throwable
 * @version v1.0
 * @description
 * @since 2018/7/19 23:55
 */
public class SummarySample {

    public static void main(String[] args) throws Exception {
        DistributionSummary summary = DistributionSummary.builder(&quot;summary&quot;)
                .tag(&quot;summary&quot;, &quot;summary&quot;)
                .description(&quot;summary&quot;)
                .register(new SimpleMeterRegistry());
        summary.record(2D);
        summary.record(3D);
        summary.record(4D);
        System.out.println(summary.measure());
        System.out.println(summary.count());
        System.out.println(summary.max());
        System.out.println(summary.mean());
        System.out.println(summary.totalAmount());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[Measurement{statistic='COUNT', value=3.0}, Measurement{statistic='TOTAL', value=9.0}, Measurement{statistic='MAX', value=4.0}]
3
4.0
3.0
9.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Summary的度量统计角度主要包括记录过的数据中的最大值、总数值、平均值和总次数。另外，一些度量属性(如下限和上限)或者单位可以自行配置，具体属性的相关内容可以查看DistributionStatisticConfig类，这里不详细展开。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;一般情况下，上面的Counter、Gauge、Timer、DistributionSummary例子可以满足日常开发需要，但是有些高级的特性这里没有展开，具体可以参考&lt;code&gt;micrometer-spring-legacy&lt;/code&gt;这个依赖包，毕竟源码是老师，源码不会骗人。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;spring-boot-starter-actuator&lt;/code&gt;在2.X版本中不仅升级了metrics为io.micrometer，很多配置方式也和1.X完全不同，鉴于前段时间没有维护SpringBoot技术栈的项目，现在重新看了下官网复习一下。引入依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${springboot.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前最新的springboot.version为2.0.3.RELEASE。在&lt;code&gt;spring-boot-starter-actuator&lt;/code&gt;中，最大的变化就是配置的变化，原来在1.X版本是通过&lt;code&gt;management.security.enabled&lt;/code&gt;控制是否可以忽略权限访问所有的监控端点，在2.X版本中，必须显式配置不需要权限验证对外开放的端点：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;management.endpoints.web.exposure.include=*
management.endpoints.web.exposure.exclude=env,beans
management.endpoints.jmx.exposure.include=
management.endpoints.jmx.exposure.include=*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如上面的配置，访问非/env和非/beans的端点，可以不受权限控制，也就是所有人都可以访问非/env和非/beans的端点。例如，如果我只想暴露/health端点，只需配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;management.endpoints.web.exposure.include=health&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一点需要特别注意，其他使用和1.X差不多。还有一点是，2.X中所有监控端点的访问url的默认路径前缀为：http://${host}/${port}/actuator/，也就是想访问health端点就要访问http://${host}/${port}/actuator/health，当然也可以修改/actuator这个路径前缀。其他细节区别没有深入研究，可以参考&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle&quot;&gt;文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;接着先搭建一个SpringCloud应用群，主要包括注册中心(registry-center)和一个简单的服务节点(cloud-prometheus-sample)，其中注册中心只引入eureka-server的依赖，而服务节点用于对接Prometheus，引入eureka-client、spring-boot-starter-actuator、prometheus等依赖。&lt;/p&gt;
&lt;h2 id=&quot;registry-center&quot;&gt;registry-center&lt;/h2&gt;
&lt;p&gt;registry-center是一个单纯的服务注册中心，只需要引入eureka-server的依赖，添加一个启动类即可，添加的依赖如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加一个启动类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * @author throwable
 * @version v1.0
 * @description
 * @since 2018/7/21 9:06
 */
@SpringBootApplication
@EnableEurekaServer
public class RegistryCenterApplication {

    public static void main(String[] args) {
        SpringApplication.run(RegistryCenterApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件application.yaml如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;server:
  port: 9091
spring:
  application:
    name: registry-center
eureka:
  instance:
    hostname: localhost
  client:
    enabled: true
    register-with-eureka: false
    fetch-registry: false
    service-url:
         defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是这么简单，启动入口类即可，启动的端口为9091。&lt;/p&gt;
&lt;h2 id=&quot;cloud-prometheus-sample&quot;&gt;cloud-prometheus-sample&lt;/h2&gt;
&lt;p&gt;cloud-prometheus-sample主要作为eureka-client，接入spring-boot-starter-actuator和prometheus依赖，引入依赖如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;micrometer-registry-prometheus&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里引入的是&lt;code&gt;micrometer-registry-prometheus&lt;/code&gt;而不是&lt;code&gt;micrometer-spring-legacy&lt;/code&gt;是因为&lt;code&gt;micrometer-spring-legacy&lt;/code&gt;是&lt;code&gt;spring-integration&lt;/code&gt;(spring系统集成)的依赖，这里没有用到，但是里面很多实现可以参考。&lt;code&gt;micrometer-registry-prometheus&lt;/code&gt;提供了基于actuator的端点，路径是../prometheus。启动类如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

/**
 * @author throwable
 * @version v1.0
 * @description
 * @since 2018/7/21 9:13
 */
@SpringBootApplication
@EnableEurekaClient
public class SampleApplication {

    public static void main(String[] args) {
        SpringApplication.run(SampleApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件application.yaml如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;server:
  port: 9092
spring:
  application:
    name: cloud-prometheus-sample
eureka:
  instance:
    hostname: localhost
  client:
    service-url: http://localhost:9091/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动端口为9092，eureka的服务注册地址为：http://localhost:9091/eureka/，也就是&lt;code&gt;registry-center&lt;/code&gt;中指定的默认数据区(defaultZone)的注册地址，先启动&lt;code&gt;registry-center&lt;/code&gt;，再启动&lt;code&gt;cloud-prometheus-sample&lt;/code&gt;，然后访问http://localhost:9091/：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-1.png&quot; alt=&quot;sp-p-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问http://localhost:9092/actuator/prometheus：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-2.png&quot; alt=&quot;sp-p-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些数据就是实时的度量数据，Prometheus(软件)配置好任务并且启动执行后，就是通过定时拉取/prometheus这个端点返回的数据进行数据聚合和展示的。&lt;/p&gt;
&lt;p&gt;接着，我们先定制一个功能，统计&lt;code&gt;cloud-prometheus-sample&lt;/code&gt;所有入站的Http请求数量(包括成功、失败和非法的)，添加如下代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//请求拦截器
@Component
public class SampleMvcInterceptor extends HandlerInterceptorAdapter {

    private static final Counter COUNTER = Counter.builder(&quot;Http请求统计&quot;)
            .tag(&quot;HttpCount&quot;, &quot;HttpCount&quot;)
            .description(&quot;Http请求统计&quot;)
            .register(Metrics.globalRegistry);

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object handler, Exception ex) throws Exception {
        COUNTER.increment();
    }
}
//自定义Mvc配置
@Component
public class SampleWebMvcConfigurer implements WebMvcConfigurer {

    @Autowired
    private SampleMvcInterceptor sampleMvcInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(sampleMvcInterceptor);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启&lt;code&gt;cloud-prometheus-sample&lt;/code&gt;，直接访问几次不存在的根节点路径http://localhost:9092/，再查看端点统计数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-3.png&quot; alt=&quot;sp-p-3&quot;/&gt;&lt;/p&gt;

&lt;p&gt;先从&lt;a href=&quot;https://prometheus.io/download/&quot;&gt;Prometheus官方下载地址&lt;/a&gt;下载软件，这里用Windows10平台演示，直接下载prometheus-2.3.2.windows-amd64.tar.gz，个人有软件洁癖，用软件或者依赖喜欢最高版本，出现坑了自己填。解压后目录如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-4.png&quot; alt=&quot;sp-p-4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动的话，直接运行prometheus.exe即可，这里先配置一下prometheus.yml：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;global:
  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
alerting:
  alertmanagers:
  - static_configs:
    - targets:
      # - alertmanager:9093
scrape_configs:
  - job_name: 'prometheus'
    metrics_path: /actuator/prometheus
    static_configs:
    - targets: ['localhost:9092']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们主要修改的是scrape_configs节点下的配置，这个节点时配置同步任务的，这里配置一个任务为'prometheus'，拉取数据的路径为/actuator/prometheus，目标host-port为'localhost:9092'，也就是&lt;code&gt;cloud-prometheus-sample&lt;/code&gt;暴露的prometheus端点，Prometheus(软件)的默认启动端口为9090。启动后，同级目录下会生成一个data目录，实际上起到&quot;时序数据库&quot;的类似作用。访问Prometheus(软件)的控制台http://localhost:9090/targets:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-5.png&quot; alt=&quot;sp-p-5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-6.png&quot; alt=&quot;sp-p-6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Prometheus度量统计的所有监控项可以在http://localhost:9090/graph中查看到。这里可以观察到HttpCount的统计，但是界面不够炫酷，配置项也少，因此需要引入Grafana。&lt;/p&gt;

&lt;p&gt;Grafana的安装也十分简单，它也是开箱即用的，就是配置的时候需要熟悉它的语法。先到&lt;a href=&quot;https://grafana.com/grafana/download&quot;&gt;Grafana官网下载页面&lt;/a&gt;下载一个适合系统的版本，这里选择Windows版本。解压之后，直接运行bin目录下的grafana-server.exe即可，默认的启动端口是3000，访问http://localhost:3000/，初始化账号密码是admin/admin，首次登陆需要修改密码，接着添加一个数据源：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-7.png&quot; alt=&quot;sp-p-7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着添加一个新的命名为'sample'的Dashboard，添加一个Graph类型的Panel，配置其属性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-8.png&quot; alt=&quot;sp-p-8&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-9.png&quot; alt=&quot;sp-p-9&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A记录(查询命令)就是对应http://localhost:9090/graph中的查询命令的目标：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-10.png&quot; alt=&quot;sp-p-10&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很简单，配置完毕之后，就可以看到高大上的统计图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-11.png&quot; alt=&quot;sp-p-11&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里只是介绍了Grafana使用的冰山一角，更多配置和使用命令可以自行查阅它的官方文档。&lt;/p&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;下面是Prometheus的工作原理流程图，来源于其官网：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-12.png&quot; alt=&quot;sp-p-12&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在SpringBoot项目中，它的工作原理如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-13.png&quot; alt=&quot;sp-p-13&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是为什么能够使用Metrics的静态方法直接进行数据统计，因为Spring内部用MeterRegistryPostProcessor对Metrics内部持有的全局的CompositeMeterRegistry进行了合成操作，也就是所有MeterRegistry类型的Bean都会添加到Metrics内部持有的静态globalRegistry。&lt;/p&gt;
&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;p&gt;下面来个相对有生产意义的扩展实现，这篇文章提到SpringCloud体系的监控，我们需要扩展一个功能，记录一下每个有效的请求的执行时间。添加下面几个类或者方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//注解
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MethodMetric {

    String name() default &quot;&quot;;

    String description() default &quot;&quot;;

    String[] tags() default {};
}
//切面类
@Aspect
@Component
public class HttpMethodCostAspect {

    @Autowired
    private MeterRegistry meterRegistry;

    @Pointcut(&quot;@annotation(club.throwable.sample.aspect.MethodMetric)&quot;)
    public void pointcut() {
    }

    @Around(value = &quot;pointcut()&quot;)
    public Object process(ProceedingJoinPoint joinPoint) throws Throwable {
        Method targetMethod = ((MethodSignature) joinPoint.getSignature()).getMethod();
        //这里是为了拿到实现类的注解
        Method currentMethod = ClassUtils.getUserClass(joinPoint.getTarget().getClass())
                .getDeclaredMethod(targetMethod.getName(), targetMethod.getParameterTypes());
        if (currentMethod.isAnnotationPresent(MethodMetric.class)) {
            MethodMetric methodMetric = currentMethod.getAnnotation(MethodMetric.class);
            return processMetric(joinPoint, currentMethod, methodMetric);
        } else {
            return joinPoint.proceed();
        }
    }

    private Object processMetric(ProceedingJoinPoint joinPoint, Method currentMethod,
                                 MethodMetric methodMetric) throws Throwable {
        String name = methodMetric.name();
        if (!StringUtils.hasText(name)) {
            name = currentMethod.getName();
        }
        String desc = methodMetric.description();
        if (!StringUtils.hasText(desc)) {
            desc = name;
        }
        String[] tags = methodMetric.tags();
        if (tags.length == 0) {
            tags = new String[2];
            tags[0] = name;
            tags[1] = name;
        }
        Timer timer = Timer.builder(name).tags(tags)
                .description(desc)
                .register(meterRegistry);
        return timer.record(() -&amp;gt; {
            try {
                return joinPoint.proceed();
            } catch (Throwable throwable) {
                throw new IllegalStateException(throwable);
            }
        });
    }
}
//启动类里面添加方法
@SpringBootApplication
@EnableEurekaClient
@RestController
public class SampleApplication {

    public static void main(String[] args) {
        SpringApplication.run(SampleApplication.class, args);
    }

    @MethodMetric
    @GetMapping(value = &quot;/hello&quot;)
    public String hello(@RequestParam(name = &quot;name&quot;, required = false, defaultValue = &quot;doge&quot;) String name) {
        return String.format(&quot;%s say hello!&quot;, name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置好Grafana的面板，重启项目，多次调用/hello接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/sp-p-14.png&quot; alt=&quot;sp-p-14&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果想把监控界面做得更炫酷、更直观、更详细，可以先熟悉一下Prometheus的查询语法和Grafana的面板配置，此外，Grafana或者Prometheus都支持预警功能，可以接入钉钉机器人等以便及时发现问题作出预警。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;https://prometheus.io/&lt;/li&gt;
&lt;li&gt;https://spring.io/&lt;/li&gt;
&lt;li&gt;https://github.com/percona/grafana-dashboards&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文Demo项目仓库：https://github.com/zjcscut/spring-cloud-prometheus-sample&lt;/p&gt;
&lt;p&gt;（本文完）&lt;/p&gt;
</description>
<pubDate>Sat, 21 Jul 2018 06:10:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9346547.html</dc:identifier>
</item>
<item>
<title>实体类的动态生成（二） - Zongsoft</title>
<link>http://www.cnblogs.com/Zongsoft/p/entity-dynamic-generation-2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zongsoft/p/entity-dynamic-generation-2.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;由于采用字典的方式来保存属性变更值的底层设计思想，导致了性能问题，虽然.NET的字典实现已经很高效了，但相对于直接读写字段的方式而言依然有巨大的性能差距，同时也会导致对属性的读写过程中产生不必要的装箱和拆箱。&lt;br/&gt;那么这次我们就来彻底解决这个问题，同时还要解决“&lt;strong&gt;哪些属性发生过变更&lt;/strong&gt;”、“&lt;strong&gt;获取变更的属性集&lt;/strong&gt;”这些功能特性，所以我们先把接口定义出来，以便后续问题讲解。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/* 源码位于 Zongsoft.CoreLibary 项目的 Zongsoft.Data 命名空间中 */

/// &amp;lt;summary&amp;gt; 表示数据实体的接口。&amp;lt;/summary&amp;gt;
public interface IEntity
{
    /// &amp;lt;summary&amp;gt;
    /// 判断指定的属性或任意属性是否被变更过。
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;names&quot;&amp;gt;指定要判断的属性名数组，如果为空(null)或空数组则表示判断任意属性。&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;
    ///     &amp;lt;para&amp;gt;如果指定的&amp;lt;paramref name=&quot;names&quot;/&amp;gt;参数有值，当只有参数中指定的属性发生过更改则返回真(True)，否则返回假(False)；&amp;lt;/para&amp;gt;
    ///     &amp;lt;para&amp;gt;如果指定的&amp;lt;paramref name=&quot;names&quot;/&amp;gt;参数为空(null)或空数组，当实体中任意属性发生过更改则返回真(True)，否则返回假(False)。&amp;lt;/para&amp;gt;
    /// &amp;lt;/returns&amp;gt;
    bool HasChanges(params string[] names);

    /// &amp;lt;summary&amp;gt;
    /// 获取实体中发生过变更的属性集。
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;如果实体没有属性发生过变更，则返回空(null)，否则返回被变更过的属性键值对。&amp;lt;/returns&amp;gt;
    IDictionary&amp;lt;string, object&amp;gt; GetChanges();

    /// &amp;lt;summary&amp;gt;
    /// 尝试获取指定名称的属性变更后的值。
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;name&quot;&amp;gt;指定要获取的属性名。&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;value&quot;&amp;gt;输出参数，指定属性名对应的变更后的值。&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;如果指定名称的属性是存在的并且发生过变更，则返回真(True)，否则返回假(False)。&amp;lt;/returns&amp;gt;
    /// &amp;lt;remarks&amp;gt;注意：即使指定名称的属性是存在的，但只要其值未被更改过，也会返回假(False)。&amp;lt;/remarks&amp;gt;
    bool TryGetValue(string name, out object value);

    /// &amp;lt;summary&amp;gt;
    /// 尝试设置指定名称的属性值。
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;name&quot;&amp;gt;指定要设置的属性名。&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;value&quot;&amp;gt;指定要设置的属性值。&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;如果指定名称的属性是存在的并且可写入，则返回真(True)，否则返回假(False)。&amp;lt;/returns&amp;gt;
    bool TrySetValue(string name, object value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设计思想&quot;&gt;设计思想&lt;/h2&gt;
&lt;p&gt;根本要点是取消用字典来保存属性值回归到字段方式，只有这样才能确保性能，关键问题是如何在写入字段值的时候，标记对应的属性发生过变更的呢？应用布隆过滤器(&lt;span data-type=&quot;color&quot;&gt;&lt;span data-type=&quot;background&quot;&gt;Bloom Filter&lt;/span&gt;&lt;/span&gt;)算法的思路来处理这个应用场景是一个完美的解决方案，因为布隆过滤器的空间效率和查询效率极高，而它的缺点在此恰好可以针对性的优化掉。&lt;/p&gt;
&lt;p&gt;将每个属性映射到一个整型数（byte/ushort/uint/ulong）的某个比特位(&lt;strong&gt;bit&lt;/strong&gt;)，如果发生过变更则将该 &lt;strong&gt;bit&lt;/strong&gt; 置为 &lt;strong&gt;1&lt;/strong&gt;，只要确保属性与二进制位顺序是确定的即可，算法复杂度是O(1)常量，并且比特位操作的效率也是极高的。&lt;/p&gt;
&lt;h2 id=&quot;实现示范&quot;&gt;实现示范&lt;/h2&gt;
&lt;p&gt;有了算法，我们写一个简单范例来感受下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Person : IEntity
{
    #region 静态字段
    private static readonly string[] __NAMES__ = new string[] { &quot;Name&quot;, &quot;Gender&quot;, &quot;Birthdate&quot; };
    private static readonly Dictionary&amp;lt;string, PropertyToken&amp;lt;Person&amp;gt;&amp;gt; __TOKENS__ = new Dictionary&amp;lt;string, PropertyToken&amp;lt;Person&amp;gt;&amp;gt;()
    {
        { &quot;Name&quot;, new PropertyToken&amp;lt;Person&amp;gt;(0, target =&amp;gt; target._name, (target, value) =&amp;gt; target.Name = (string) value) },
        { &quot;Gender&quot;, new PropertyToken&amp;lt;Person&amp;gt;(1, target =&amp;gt; target._gender, (target, value) =&amp;gt; target.Gender = (Gender?) value) },
        { &quot;Birthdate&quot;, new PropertyToken&amp;lt;Person&amp;gt;(2, target =&amp;gt; target._birthdate, (target, value) =&amp;gt; target.Birthdate = (DateTime) value) },
    };
    #endregion

    #region 标记变量
    private byte _MASK_;
    #endregion

    #region 成员字段
    private string _name;
    private bool? _gender;
    private DateTime _birthdate;
    #endregion

    #region 公共属性
    public string Name
    {
        get =&amp;gt; _name;
        set
        {
            _name = value;
            _MASK_ |= 1;
        }
    }

    public bool? Gender
    {
        get =&amp;gt; _gender;
        set
        {
            _gender = value;
            _MASK_ |= 2;
        }
    }

    public DateTime Birthdate
    {
        get =&amp;gt; _birthdate;
        set
        {
            _birthdate = value;
            _MASK_ |= 4;
        }
    }
    #endregion

    #region 接口实现
    public bool HasChanges(string[] names)
    {
        PropertyToken&amp;lt;Person&amp;gt; property;

        if(names == null || names.Length == 0)
            return _MASK_ != 0;

        for(var i = 0; i &amp;lt; names.Length; i++)
        {
            if(__TOKENS__.TryGetValue(names[i], out property) &amp;amp;&amp;amp; (_MASK_ &amp;gt;&amp;gt; property.Ordinal &amp;amp; 1) == 1)
                return true;
        }

        return false;
    }

    public IDictionary&amp;lt;string, object&amp;gt; GetChanges()
    {
        if(_MASK_ == 0)
            return null;

        var dictionary = new Dictionary&amp;lt;string, object&amp;gt;(__NAMES__.Length);

        for(int i = 0; i &amp;lt; __NAMES__.Length; i++)
        {
            if((_MASK_ &amp;gt;&amp;gt; i &amp;amp; 1) == 1)
                dictionary[__NAMES__[i]] = __TOKENS__[__NAMES__[i]].Getter(this);
        }

        return dictionary;
    }

    public bool TryGetValue(string name, out object value)
    {
        value = null;

        if(__TOKENS__.TryGetValue(name, out var property) &amp;amp;&amp;amp; (_MASK_ &amp;gt;&amp;gt; property.Ordinal &amp;amp; 1) == 1)
        {
            value = property.Getter(this);
            return true;
        }

        return false;
    }

    public bool TrySetValue(string name, object value)
    {
        if(__TOKENS__.TryGetValue(name, out var property))
        {
            property.Setter(this, value);
            return true;
        }

        return false;
    }
    #endregion
}

// 辅助结构
public struct PropertyToken&amp;lt;T&amp;gt;
{
    public PropertyToken(int ordinal, Func&amp;lt;T, object&amp;gt; getter, Action&amp;lt;T, object&amp;gt; setter)
    {
        this.Ordinal = ordinal;
        this.Getter = getter;
        this.Setter = setter;
    }

    public readonly int Ordinal;
    public readonly Func&amp;lt;T, object&amp;gt; Getter;
    public readonly Action&amp;lt;T, object&amp;gt; Setter;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面实现代码，主要有以下几个要点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;属性设置器中除了对字段赋值外，多了一个位或赋值操作（这是一句非常低成本的代码）；&lt;/li&gt;
&lt;li&gt;需要一个额外的整型数的实例字段 &lt;code&gt;_MASK_&lt;/code&gt; ，来标记对应更改属性序号；&lt;/li&gt;
&lt;li&gt;分别增加 &lt;code&gt;__NAMES__&lt;/code&gt; 和* *&lt;code&gt;__TOKENS__&lt;/code&gt; 两个静态只读变量，来保存实体类的元数据，以便更高效的实现 &lt;a href=&quot;https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/feature-data/src/Data/IEntity.cs&quot;&gt;IEntity&lt;/a&gt;接口方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;根据代码可分析出其理论执行性能与原生实现基本一致，内存消耗只多了一个字节（如果可写属性数量小于9），由于 &lt;code&gt;__NAMES__&lt;/code&gt; 和 &lt;code&gt;__TOKENS__&lt;/code&gt; 是静态变量，因此不占用实例空间，理论上该方案的整体效率非常高。&lt;/p&gt;
&lt;h2 id=&quot;性能对比&quot;&gt;性能对比&lt;/h2&gt;
&lt;p&gt;上面我们从代码角度简单分析了下整个方案的性能和消耗，那么实际情况到底怎样呢？跑个分呗（性能对比测试代码地址：&lt;a href=&quot;https://github.com/Zongsoft/Zongsoft.CoreLibrary/tree/feature-data/samples/Zongsoft.Samples.Entities&quot; class=&quot;uri&quot;&gt;https://github.com/Zongsoft/Zongsoft.CoreLibrary/tree/feature-data/samples/Zongsoft.Samples.Entities&lt;/a&gt;），具体代码就不在这里占用版面了，下面给出某次在我的老旧台式机（CPU:Intel &lt;strong&gt;i5-3470&lt;/strong&gt;@&lt;strong&gt;3.2GHz&lt;/strong&gt; | RAM:&lt;strong&gt;8GB&lt;/strong&gt; | &lt;strong&gt;Win10&lt;/strong&gt; | &lt;strong&gt;.NET 4.6&lt;/strong&gt;）上生成&lt;strong&gt;100万&lt;/strong&gt;个实例的截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zongsoft.github.io/blog/images/performance-entity-event.png&quot; alt=&quot;跑分截图&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“Native Object: &lt;strong&gt;295&lt;/strong&gt;”表示原生实现版（即简单的读写字段）的运行时长（&lt;em&gt;单位：&lt;/em&gt;&lt;em&gt;&lt;strong&gt;毫秒&lt;/strong&gt;&lt;/em&gt;&lt;em&gt;，下同&lt;/em&gt;）；&lt;/li&gt;
&lt;li&gt;“Data Entity: &lt;strong&gt;295&lt;/strong&gt;”为本案的运行时长，通常本方案比原生方案要慢10毫秒左右，偶尔能跑平（&lt;em&gt;属于运行环境抖动，可忽略&lt;/em&gt;）；&lt;/li&gt;
&lt;li&gt;“Data Entity(TrySet): &lt;strong&gt;835&lt;/strong&gt;”为本方案中 &lt;code&gt;TrySet(...)&lt;/code&gt; 方法的运行时长，由于 &lt;code&gt;TrySet(...)&lt;/code&gt; 方法内部需要进行字典查询所以有性能损耗亦属正常，在百万量级跑到这个时长说明性能也是很不错的，如果切换到 .NET Core 2.1 的话，得益于基础类库的性能改善，还能再享受一波性能红利。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上所述，该方案付出极少的内存成本获得了与原生简单属性访问基本一致的性能，同时还提供了属性变更跟踪等新功能（即高效完成了 &lt;a href=&quot;https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/feature-data/src/Data/IEntity.cs&quot;&gt;Zongsoft.Data.IEntity&lt;/a&gt; 接口中定义的那些重要功能特性），为后续业务开发提供了有力的基础支撑。&lt;/p&gt;
&lt;h2 id=&quot;实现完善&quot;&gt;实现完善&lt;/h2&gt;
&lt;p&gt;上面的实现范例代码并没有实现 &lt;code&gt;INotifyPropertyChanged&lt;/code&gt; 接口，下面补充完善下实现该接口后的属性定义：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Person : IEntity, INotifyPropertyChanged
{
    // 事件声明
    public event PropertyChangedEventHandler PropertyChanged;

    public string Name
    {
        get =&amp;gt; _name;
        set
        {
            if(_name == value)
                return;

            _name = value;
            _MASK_ |= 1;
            this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Name)));
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，属性的设置器中的做了一个新旧值的比对判断和对 &lt;code&gt;PropertyChanged&lt;/code&gt; 事件激发，其他代码没有变化。&lt;/p&gt;
&lt;p&gt;另外，我们使用的是 byte 类型的 &lt;code&gt;_MASK_&lt;/code&gt; 的标记变量来保存属性的更改状态，如果当实体的属性数量超过 8 个，就需要根据具体数量换成相应的 &lt;code&gt;UInt16,UInt32,UInt64&lt;/code&gt; 类型，但如果超过 64 就需要采用 &lt;code&gt;byte[]&lt;/code&gt; 了，当然必须要变动下相关代码，假设以下实体类有 &lt;strong&gt;100&lt;/strong&gt; 个属性（注意仅例举了第一个 &lt;code&gt;Property1&lt;/code&gt; 和最后一个 &lt;code&gt;Property100&lt;/code&gt; 属性）：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MyEntity : IEntity
{
    #region 标记变量
    private readonly byte[] _MASK_;
    #endregion

    public Person()
    {
        _MASK_ = new byte[13]; // 13 = Math.Ceiling(100 / 8)
    }

    public object Property1
    {
        get =&amp;gt; _property1;
        set
        {
            _property1 = value;
            _MASKS_[0] |= 1; // _MASK_[0 / 8] |= (byte)Math.Pow(2, 0 % 8);
        }
    }

    public object Property100
    {
        get =&amp;gt; _property100;
        set
        {
            _property100 = value;
            _MASKS_[12] |= 8; // _MASK_[99 / 8] |= (byte)Math.Pow(2, 99 % 8);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变化内容为先根据当前属性的顺序号来确定到对应的标记数组的下标，然后再确定对应的掩码值。当然，也别忘了调整 Zongsoft.Data.IEntity 接口中各方法的实现。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MyEntity : IEntity
{
    public bool HasChanges(params string[] names)
    {
        PropertyToken&amp;lt;UserEntity&amp;gt; property;

        if(names == null || names.Length == 0)
        {
            for(int i = 0; i &amp;lt; _MASK_.Length; i++)
            {
                if(_MASK_[i] != 0)
                    return true;
            }

            return false;
        }

        for(var i = 0; i &amp;lt; names.Length; i++)
        {
            if(__TOKENS__.TryGetValue(names[i], out property) &amp;amp;&amp;amp; (_MASK_[property.Ordinal / 8] &amp;gt;&amp;gt; (property.Ordinal % 8) &amp;amp; 1) == 1)
                return true;
        }

        return false;
    }

    public IDictionary&amp;lt;string, object&amp;gt; GetChanges()
    {
        var dictionary = new Dictionary&amp;lt;string, object&amp;gt;(__NAMES__.Length);

        for(int i = 0; i &amp;lt; __NAMES__.Length; i++)
        {
            if((_MASK_[i / 8] &amp;gt;&amp;gt; (i % 8) &amp;amp; 1) == 1)
                dictionary[__NAMES__[i]] = __TOKENS__[__NAMES__[i]].Getter(this);
        }

        return dictionary.Count == 0 ? null : dictionary;
    }

    public bool TryGet(string name, out object value)
    {
        value = null;

        if(__TOKENS__.TryGetValue(name, out var property) &amp;amp;&amp;amp; (_MASK_[property.Ordinal / 8] &amp;gt;&amp;gt; (property.Ordinal % 8) &amp;amp; 1) == 1)
        {
            value = property.Getter(this);
            return true;
        }

        return false;
    }

    public bool TrySetValue(string name, object value)
    {
        /* 相对之前版本没有变化 */
        /* No changes relative to previous versions */
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码变化部分比较简单，只有掩码处理部分需要调整。&lt;/p&gt;
&lt;h2 id=&quot;新问题&quot;&gt;新问题&lt;/h2&gt;
&lt;p&gt;有了这些实现范式，定义个实体基类并在基类中完成主要功能即可推广应用了，但是，这里有个掩码类型和处理方式无法通用化实现的问题，如果要把这部分代码交由子类来实现的话，那么代码复用度会大打折扣甚至完全失去复用的意义。&lt;/p&gt;
&lt;p&gt;为展示这个问题的艰难，在 &lt;a href=&quot;https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/feature-data/tests/Entities.cs&quot; class=&quot;uri&quot;&gt;https://github.com/Zongsoft/Zongsoft.CoreLibrary/blob/feature-data/tests/Entities.cs&lt;/a&gt; 源文件中，写了属性数量不等的几个实体类（Person、Customer、Employee、SpecialEmployee），采用继承方式进行复用性验证，可清晰看到实现的非常冗长繁琐，对实现者的细节把控要求很高、实现上非常容易出错，更致命的是复用度还极差。并且当实体类需要进行属性增减，是非常麻烦的，需要仔细调整原有代码结构中掩码的映射位置，这对于代码维护无意是场恶梦。&lt;/p&gt;
&lt;h2 id=&quot;新办法&quot;&gt;新办法&lt;/h2&gt;
&lt;p&gt;解决办法其实很简单，正是本文的标题——“&lt;strong&gt;动态生成&lt;/strong&gt;”，彻底解放实现者并确保实现的正确性。业务方不再定义具体的实体类，而是定义实体接口即可，实体类将由实体生成器来动态生成。我们依然“从场景出发”，先来看看业务层的使用。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IPerson : IEntity
{
    string Name { get; set; }
    bool? Gender { get; set; }
    DateTime Birthdate { get; set; }
}

public interface IEmployee : IPerson
{
    byte Status { get; set; }
    decimal Salary { get; set; }
}

var person = Entity.Build&amp;lt;IPerson&amp;gt;();
var employee = Entity.Build&amp;lt;IEmployee&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此，终于得到了一个兼顾性能与功能并易于使用且无需繁琐的手动实现的最终方案，虽然刚开始看起来是一个多么平常又简单的任务。那么接下来我们该怎么实现这个动态生成器呢？最终它能性能无损的被实现出来吗？&lt;span data-type=&quot;color&quot;&gt;&lt;span data-type=&quot;background&quot;&gt;请关注我们的公众号（&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span data-type=&quot;color&quot;&gt;&lt;u&gt;Zongsoft&lt;/u&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span data-type=&quot;color&quot;&gt;&lt;span data-type=&quot;background&quot;&gt;）留言讨论。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;提示&quot;&gt;提示：&lt;/h3&gt;
&lt;p&gt;本文可能会更新，请阅读原文：&lt;a href=&quot;https://zongsoft.github.io/blog/zh-cn/zongsoft/entity-dynamic-generation-2&quot; class=&quot;uri&quot;&gt;https://zongsoft.github.io/blog/zh-cn/zongsoft/entity-dynamic-generation-2&lt;/a&gt;，以避免因内容陈旧而导致的谬误，同时亦有更好的阅读体验。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-type=&quot;color&quot;&gt;敬请期待更精彩的下篇，关注我们的公众号可以第一时间看到哦！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Jul 2018 05:36:00 +0000</pubDate>
<dc:creator>Zongsoft</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Zongsoft/p/entity-dynamic-generation-2.html</dc:identifier>
</item>
<item>
<title>《1024伐木累》-职业规划（中篇四）-总章节十八 - ITIBB-Shrek</title>
<link>http://www.cnblogs.com/sall/p/9346302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sall/p/9346302.html</guid>
<description>&lt;p&gt;引子&lt;br/&gt;耗仔歉意的示意了明儿，走出小火锅店，接听了电话。&lt;br/&gt;“阿芳，买好票了吗？”&lt;br/&gt;“嗯，买好了，周五的火车，周六早上到。”&lt;br/&gt;“周六到？你不是说下周再来吗？”&lt;br/&gt;“我怕肚子再大了，被看出来，还是快点解决掉好点。”&lt;br/&gt;“那好吧，周六早上我去接你，然后我们直接去医院吧”&lt;br/&gt;“对不起，我。。。”阿芳。&lt;br/&gt;“没什么对不起的，事已至此，努力面对吧，只是我觉得一条生命，你真的就这样放弃了吗？”耗仔。&lt;br/&gt;“我。。。我不想给他生孩子，我。。。”阿芳欲言又止。&lt;br/&gt;又聊了一会儿，耗仔嘱咐阿芳一些路上的注意事项后，便挂断了电话。&lt;br/&gt;回到小火锅店，耗仔歉意的和明儿说道：&lt;br/&gt;“明儿，不好意思，周末有点急事，我们改天约吧。”&lt;/p&gt;
&lt;p&gt;#region&lt;/p&gt;
&lt;p&gt;时间过的真快，眼看到了周五晚上下班，老王科技最近正在搞产品升级，全员996。耗仔和阿芳约好周六早七点半去北京站接她，耗仔盘算着，打车过去需要大概一半五十多块钱，还得起个大早，不如周五晚上在附近找个宾馆住下，早上直接步行去接站。也没什么心情加班，于是耗仔和老王请了假，下班后，匆匆的就走了。&lt;br/&gt;望着耗仔离去的背影，明儿在心里默默的说了一句什么，然后又扭头工作了。&lt;br/&gt;反正也没什么事儿，定好房间后，耗仔打算去天安门转一圈，不多会就来到了长安街，一路向西，悠哉的向天安门走去。耗仔掏出自己的索爱手机，看着和阿芳那些纠结的短信息，心里空落落的，本来好好的一对儿，就这么阴差阳错了；再想想在老王科技的工作，算算从二月份入职，大概也有七个月的时间了，对于目前来说，老王还是很能够放手去给自己空间发展的，虽然公司小，如果依托于老王在军队的关系，似乎想要做大拿到第一桶金，倒时再有个合理的、顺应市场的产品推出，想要在五六年内上市，也并不是痴人说梦。&lt;br/&gt;想着想着，不知觉中已经来到了天安门前。耗仔目不转睛的注视着毛主席的头像，心里异样的激动，呆站了有十多分钟，没有说一句话。&lt;br/&gt;“兄弟，一个人吗？”旁边传来的男性声音，打断了耗仔的遐想。&lt;br/&gt;扭头一看，中年男性，中等个头，稍显瘦肉，口音没太听出来，普通话说的还是不错的，花色丝质衬衫，深色西裤，还有一双擦的倍儿量的皮鞋，胸前则挂着一个黑黝黝的单反照相机。&lt;br/&gt;耗仔大量了一番，站那儿没说话，还在看。中间男子有点沉不住气了，没等耗仔回答，又问了一句：“怎么了？兄弟，我哪里不对吗？”&lt;br/&gt;“哦，没。。没有，我就是突然感觉好像在哪里见过你。”耗仔并没有说话，他们两人以前还真的有过一面之缘，只不过那会儿还在念书，而且那次聚会两人没有直接说过话。&lt;br/&gt;“呵！那一切正常就好，我也是看你眼熟，兄弟从哪里来？”&lt;br/&gt;“辽宁的，毕业后就来北京了，你呢？”耗仔不假思索的回应着。&lt;br/&gt;“辽宁？我去过几次，我在那边和很多高校都有过合作。我是湖南的！”中年男子笑容满面的说，然后又继续问道：“兄弟自己一个人吧？我也一个人，不如搭个伴儿，正好也没人给我照相，咱们互助一下怎么样？”。&lt;br/&gt;耗仔正没什么去向，一听来人如此一说，也便答应了。于是两个人在天安门广场、人民英雄纪念碑、中南海门前、国家大剧院、中山公园等地好好的转悠的一番。中年男子看了下表，说：“兄弟，十点多了，晚上有约吗？不如一起去牛街逛逛？”&lt;br/&gt;“牛街？也不错啊，走！”&lt;br/&gt;“能喝点不？我们来点白牛二，咋样？”中年男子饶有兴致的说。&lt;br/&gt;“没问题，舍命陪君子！”耗仔也起了兴致。&lt;br/&gt;两个人打了一辆出租车，大概是来分钟的时间便到了牛街，随便找了一家清真风格的烧烤店，便走了进去。&lt;br/&gt;耗仔早就听说过牛街，这条街由于聚居了较多的回民，并且，还因为这条街有个牛街礼拜寺而闻名于世。算是北京历史最为悠久的清真寺了。之前的牛街，其实叫榴街，原本是一片的石榴园。由于这里居住的多为回民，并且回民做的牛肉特别好吃，在加上“牛”、“榴”发音比较接近，后来干脆改名叫牛街了。这里的小吃特别的多，面茶、豆汁、豆腐脑、豆面丸子汤、卤炸豆腐、杂碎汤、漏鱼、糖耳朵、糖火烧、焦圈、麻花、炸糕、奶油炸糕、螺丝转、墩饽饽、豆馅火烧、豆馅酥、蜂糕、碗糕、驴打滚、艾窝窝、豌豆黄、江米凉糕、蜜三刀、开口笑、姜汁排叉、卷果、爆肚，真是应有尽有。&lt;br/&gt;一路走来，耗仔对中年男子也大概有了一些判断，细心、敏感，不太拘于小节，有些讲究小排场，特别是在外面，会有些许的爱面子。对于吃，他不是特别的考究，但是一定要有辣，这恰恰和耗仔比较对路子。耗仔第一次来，不太会点菜，中年男子也没有让他，自顾自的点了起来，最后，来了六瓶冰镇的燕京。&lt;br/&gt;“兄弟，开喝第一杯酒之前，我们正式认识一下吧，我是华仔，今年二十八。”，中年男子举起酒杯，笑盈盈的看着耗仔。&lt;br/&gt;噗！耗仔差点没喷了，二十八，擦！长得也太老了点吧，我当都三十八了，还华仔。。。。&lt;br/&gt;“额，对不起，哥，叫我耗仔就行，我今年23。”耗仔尴尬的朝着华仔笑了笑。&lt;br/&gt;“哦，没关系，兄弟，直爽！”华仔也没多说什么。&lt;br/&gt;两个人天南海北的神侃了一番，各自也都保持着自己的底线，没有太过深入，又不显过于隐秘。一直喝到凌晨两点，大概干掉了二十四瓶啤酒，两人已经醉的打转了。&lt;br/&gt;后来耗仔回想起当晚，觉得华仔也是比较细心和谨慎的，如果两人话不投机，大概不会一起喝酒，如果两人品性不和，喝完开始点的六瓶啤酒可能就各奔东西了，当时的华仔欠缺一些机遇，从大学时就开始创业，最多的时候手里挣到过500多万，但是过于冒进，就这样一直反反复复的折腾着。和耗仔在天安门那晚的相遇，即时缘分，也是注定的，当四年后两人再次注定相逢的时候，他们竟然一起点燃了创业的火苗。&lt;br/&gt;第二天一早，耗仔准时的关掉了吵闹的铃声，梳洗过罢，也没吃早饭，就向北京站走去。。。&lt;/p&gt;
&lt;p&gt;#endregion&lt;/p&gt;
</description>
<pubDate>Sat, 21 Jul 2018 04:58:00 +0000</pubDate>
<dc:creator>ITIBB-Shrek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sall/p/9346302.html</dc:identifier>
</item>
<item>
<title>补习系列-springboot中的几种scope - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/9345801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/9345801.html</guid>
<description>&lt;h2 id=&quot;目标&quot;&gt;目标&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;了解HTTP 请求/响应头及常见的属性；&lt;/li&gt;
&lt;li&gt;了解如何使用SpringBoot处理头信息 ；&lt;/li&gt;
&lt;li&gt;了解如何使用SpringBoot处理Cookie ；&lt;/li&gt;
&lt;li&gt;学会如何对 Session 进行读写；&lt;/li&gt;
&lt;li&gt;了解如何在不同请求间传递 flash参数&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;一http-头信息&quot;&gt;一、Http 头信息&lt;/h2&gt;
&lt;p&gt;HTTP 头(Header)是一种附加内容，独立于请求内容和响应内容。&lt;br/&gt;HTTP 协议中的大量特性都通过Header信息交互来实现，比如内容编解码、缓存、连接保活等等。&lt;br/&gt;如下面的一个请求响应：&lt;br/&gt;&lt;strong&gt;&lt;em&gt;Request&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cache-Control: max-age=0
Connection: keep-alive
Host: www.cnblogs.com
If-Modified-Since: Wed, 18 Jul 2018 13:47:45 GMT
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;客户端期望的MIME 类型列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Encoding&lt;/td&gt;
&lt;td&gt;客户端期望的编解码方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Accept-Language&lt;/td&gt;
&lt;td&gt;客户端期望的语言&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Cache-Control&lt;/td&gt;
&lt;td&gt;缓存控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;连接行为(keep-alive)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Host&lt;/td&gt;
&lt;td&gt;请求访问的主机&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;If-Modified-Since&lt;/td&gt;
&lt;td&gt;缓存控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Upgrade-Insecure-Requests&lt;/td&gt;
&lt;td&gt;支持安全加密标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;User-Agent&lt;/td&gt;
&lt;td&gt;用户代理(客户端标识)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Response&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Cache-Control: private, max-age=10
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Wed, 18 Jul 2018 13:47:51 GMT
Expires: Wed, 18 Jul 2018 13:48:01 GMT
Last-Modified: Wed, 18 Jul 2018 13:47:51 GMT
Transfer-Encoding: chunked
Vary: Accept-Encoding
X-Frame-Options: SAMEORIGIN
X-UA-Compatible: IE=10&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Cache-Control&lt;/td&gt;
&lt;td&gt;缓存控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;连接行为(keep-alive)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Content-Encoding&lt;/td&gt;
&lt;td&gt;编解码方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Content-Type&lt;/td&gt;
&lt;td&gt;内容类型(MIME)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;当前响应时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Expires&lt;/td&gt;
&lt;td&gt;文档过期时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Last-Modified&lt;/td&gt;
&lt;td&gt;最后一次更新时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Transfer-Encoding&lt;/td&gt;
&lt;td&gt;传输编码方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Vary&lt;/td&gt;
&lt;td&gt;需要刷新的请求Header&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;X-Frame-Options&lt;/td&gt;
&lt;td&gt;FRAME展示策略(用于同源控制)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;X-UA-Compatible&lt;/td&gt;
&lt;td&gt;IE兼容属性&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;更多的** Http Header **可以从&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers&quot;&gt;这里找到&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二springboot-处理头信息&quot;&gt;二、SpringBoot 处理头信息&lt;/h2&gt;
&lt;p&gt;前面的内容中已经讲过如何完成Controller方法及请求的映射。&lt;br/&gt;在SpringBoot可通过&lt;strong&gt;@RequestHeader&lt;/strong&gt;注解方式&lt;br/&gt;将请求头信息映射到参数，如下面的片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @GetMapping(&quot;/some&quot;)
    @ResponseBody
    public String someHeader(@RequestHeader(value = &quot;Host&quot;) String host,
            @RequestHeader(value = &quot;User-Agent&quot;) String userAgent,
            @RequestHeader(value = &quot;Cache-Control&quot;, required = false) String cacheControl,
            HttpServletResponse response) {

        logger.info(&quot;host:{}&quot;, host);
        logger.info(&quot;User-Agent:{}&quot;, userAgent);
        logger.info(&quot;Cache-Control:{}&quot;, cacheControl);

        // 设置响应头
        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache,no-store,must-revalidate&quot;);
        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);
        response.setDateHeader(&quot;Expires&quot;, 0);

        return &quot;OK&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而响应头呢，可以通过声明一个HttpServletResponse参数后，&lt;br/&gt;通过该对象进行设置，上面的代码非常容易理解。&lt;/p&gt;
&lt;p&gt;如果希望获得全部的请求头，可以使用&lt;strong&gt;HttpHeaders&lt;/strong&gt;对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @GetMapping(&quot;/all&quot;)
    public ResponseEntity&amp;lt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;&amp;gt; allHeaders(@RequestHeader HttpHeaders headers) {

        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; valueMap = new HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;();
        for (String header : headers.keySet()) {
            valueMap.put(header, headers.get(header));
            logger.info(&quot;header[{}]={}&quot;, header, headers.get(header));
        }

        // 通过ResponseEntity设置响应头
        ResponseEntity&amp;lt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;&amp;gt; entity = ResponseEntity.status(HttpStatus.OK)
                .header(&quot;new header&quot;, UUID.randomUUID().toString()).body(valueMap);
        return entity;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的一段代码中，可以将所有请求头信息全部打印出来。&lt;br/&gt;此外还须注意到，返回响应使用了&lt;strong&gt;ResponseEntity&lt;/strong&gt;对象，这是一个用于直接表示&lt;br/&gt;响应信息头、内容的对象，利用ResponseEntity可以很方便的设置响应头信息。&lt;/p&gt;
&lt;h2 id=&quot;三cookie处理&quot;&gt;三、Cookie处理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Cookie&lt;/strong&gt;一开始服务器用于辨别用户信息而记录在浏览器上的信息。&lt;br/&gt;到目前为止Cookie作为客户端的存储有了非常多的应用场景。&lt;/p&gt;
&lt;p&gt;SpringBoot 提供了&lt;strong&gt;@CookieValue&lt;/strong&gt;以支持参数方式注入，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @GetMapping(&quot;/some&quot;)
    @ResponseBody
    public String someCookie(@CookieValue(value = &quot;counter&quot;, defaultValue = &quot;0&quot;) int counter,
            HttpServletResponse response) {

        logger.info(&quot;counter:{}&quot;, counter);
        counter += 1;

        String newValue = counter + &quot;&quot;;

        // 设置Cookie
        response.addCookie(new Cookie(&quot;counter&quot;, newValue));
        return newValue;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中，访问/some 可以获得一个counter的cookie值，&lt;br/&gt;且每访问一次则自增一次，这是一个简单的访问计数器功能。&lt;/p&gt;
&lt;p&gt;如果希望获取全部的Cookie，可以参考以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @GetMapping(&quot;/all&quot;)
    public ResponseEntity&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;allCookies(HttpServletRequest request, HttpServletResponse response) {

        Map&amp;lt;String, String&amp;gt; valueMap = new HashMap&amp;lt;String, String&amp;gt;();
        for (Cookie cookie : request.getCookies()) {

            valueMap.put(cookie.getName(), cookie.getValue());
            logger.info(&quot;cookie[{}]={}&quot;, cookie.getName(), cookie.getValue());
        }

        // 设置Cookie
        response.addCookie(new Cookie(&quot;key&quot;, UUID.randomUUID().toString()));
        return new ResponseEntity&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;(valueMap, HttpStatus.OK);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;清理全部Cookie&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @GetMapping(&quot;/clear&quot;)
    public ResponseEntity&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; clearCookies(HttpServletRequest request, HttpServletResponse response) {

        Map&amp;lt;String, String&amp;gt; valueMap = new HashMap&amp;lt;String, String&amp;gt;();
        for (Cookie cookie : request.getCookies()) {

            valueMap.put(cookie.getName(), cookie.getValue());
            logger.info(&quot;cookie[{}]={}&quot;, cookie.getName(), cookie.getValue());

            // 清除
            cookie.setMaxAge(0);
            response.addCookie(cookie);
        }

        return new ResponseEntity&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;(valueMap, HttpStatus.OK);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Cookie机制存在一定的缺陷，尽可能在考虑一些风险后使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;安全性无法保证，除非使用HTTPS；&lt;/li&gt;
&lt;li&gt;浏览器端只有4KB大小的存储上限；&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四session处理&quot;&gt;四、Session处理&lt;/h2&gt;
&lt;p&gt;Session 指的是会话，是建立于Cookie机制上的一种身份识别方式。&lt;br/&gt;由于Cookie自身的安全性和容量限制，大多数应用中是在Cookie中存放一个唯一凭证；&lt;br/&gt;服务侧通过凭证再进行身份信息的存取，这就是会话的由来。&lt;br/&gt;不同的语言、框架采用的实现方式有些差异，比如JavaEE采用JSESSION_ID，而PHP则是PHPSESSID&lt;/p&gt;
&lt;p&gt;Session的交互原理可以参考下面一个图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201807/242916-20180721103211233-1359650189.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Springboot 内嵌了Servlet容器，则是沿用的&lt;strong&gt;JSESSION_ID&lt;/strong&gt;。因此在浏览一些JavaWeb站点时会发现该Cookie。&lt;br/&gt;使用&lt;strong&gt;@SessionAttribute&lt;/strong&gt;可以将会话中的属性映射到方法参数；&lt;/p&gt;
&lt;p&gt;如果希望对Session属性进行操作，可以在Controller上声明&lt;strong&gt;@SessionAttributes注解&lt;/strong&gt;以指定想要变更的属性；&lt;br/&gt;之后，通过Model参数进行写入即可(由框架自动检测并修改Session)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SessionAttributes(&quot;seed&quot;)
public class SessionController {

    private static final Logger logger = LoggerFactory.getLogger(SessionController.class);
    @GetMapping(&quot;/some&quot;)
    @ResponseBody
    public String someSession(@SessionAttribute(value = &quot;seed&quot;, required = false) Integer seed, Model model) {

        logger.info(&quot;seed:{}&quot;, seed);
        if (seed == null) {
            seed = (int) (Math.random() * 10000);
        } else {
            seed += 1;
        }
        model.addAttribute(&quot;seed&quot;, seed);

        return seed + &quot;&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子与&lt;strong&gt;Cookie实现访问计数器&lt;/strong&gt;的功能是一样的！&lt;br/&gt;如果希望获取全部会话，可以使用&lt;strong&gt;HttpSession&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @GetMapping(&quot;/all&quot;)
    public ResponseEntity&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; allSessions(HttpSession session) {

        Map&amp;lt;String, Object&amp;gt; valueMap = new HashMap&amp;lt;String, Object&amp;gt;();
        Enumeration&amp;lt;String&amp;gt; iSession = session.getAttributeNames();

        while (iSession.hasMoreElements()) {
            String sessionName = iSession.nextElement();
            Object sessionValue = session.getAttribute(sessionName);

            valueMap.put(sessionName, sessionValue);
            logger.info(&quot;sessoin[{}]={}&quot;, sessionName, sessionValue);
        }

        // 写入session
        session.setAttribute(&quot;timestmap&quot;, new Date());
        return new ResponseEntity&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;(valueMap, HttpStatus.OK);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;清除会话&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @GetMapping(&quot;/clear&quot;)
    public ResponseEntity&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; clearSessions(HttpSession session) {

        Map&amp;lt;String, Object&amp;gt; valueMap = new HashMap&amp;lt;String, Object&amp;gt;();
        Enumeration&amp;lt;String&amp;gt; iSession = session.getAttributeNames();

        while (iSession.hasMoreElements()) {
            String sessionName = iSession.nextElement();
            Object sessionValue = session.getAttribute(sessionName);

            valueMap.put(sessionName, sessionValue);
            logger.info(&quot;sessoin[{}]={}&quot;, sessionName, sessionValue);
            
            session.removeAttribute(sessionName);
        }
      
        return new ResponseEntity&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;(valueMap, HttpStatus.OK);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五flash参数传递&quot;&gt;五、Flash参数传递&lt;/h2&gt;
&lt;p&gt;Flash的意思是&lt;strong&gt;一瞬间，一闪而过的&lt;/strong&gt;，因此很好理解，这是一类仅用来消费一次的参数，有些类似&lt;strong&gt;&lt;em&gt;阅后即焚&lt;/em&gt;&lt;/strong&gt;。&lt;br/&gt;试想这样的场景，你确认完购物车，完成订单支付后进入订单管理界面，而此时界面上提示你&quot;下单成功，请等待发货&quot;。&lt;br/&gt;这便可以通过Flash传参来实现。&lt;/p&gt;
&lt;p&gt;Flash的意义是用作请求之间的瞬时参数传递，仅消费一次后便不再用。&lt;br/&gt;以下是一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   /**
     * 执行跳转，并设置传值
     *
     * @param counter
     * @param response
     * @return
     */
    @GetMapping(&quot;/first&quot;)
    public String first(final RedirectAttributes redirectAttrs) {

        logger.info(&quot;redirect start:{}&quot;);

        redirectAttrs.addFlashAttribute(&quot;flash&quot;, UUID.randomUUID().toString());
        return &quot;redirect:/flash/second&quot;;
    }

    /**
     * 获取传值
     * 
     * @param session
     * @param response
     * @return
     */
    @GetMapping(&quot;/second&quot;)
    @ResponseBody
    public String second(@ModelAttribute(&quot;flash&quot;) String flash) {

        logger.info(&quot;redirect receive {}&quot;, flash);
        return flash;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;交互原理&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201807/242916-20180721103225248-2128286794.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Sprintboot中Flash机制也是&lt;strong&gt;利用Session&lt;/strong&gt;实现的，其中FlashMapManager接口实现了Flash参数的管理。&lt;br/&gt;默认的实现是&lt;strong&gt;SessionFlashMapManager&lt;/strong&gt;，可以通过&lt;strong&gt;RequestContextUtils&lt;/strong&gt;获得上下文中的FlashMapManager对象。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;RequestContextUtils通过Request Scope(请求上下文)存取对象&lt;br/&gt;这也是一个本文未提及的scope域，Request上下文是利用线程变量实现的，通常用于线程内业务处理的数据交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;HTTP 头信息是一种附加内容，用于实现HTTP协议中的各种特性，在开始部分介绍了常见的头信息定义。&lt;br/&gt;本文主要介绍了几种常见的HTTP scope信息的存取方法，包括如何对header、cookie进行读取及修改。&lt;br/&gt;springboot 内嵌了Servlet容器，会话处理机制上沿用了JSESSIONID，通过代码示例介绍了会话的处理方法；&lt;br/&gt;Flash参数是一种&lt;strong&gt;&lt;em&gt;阅后即焚&lt;/em&gt;&lt;/strong&gt;的数据，其底层实现也用了session的实现方案。&lt;br/&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Sat, 21 Jul 2018 02:33:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/9345801.html</dc:identifier>
</item>
<item>
<title>6.ASP.NET全栈开发之前后台校验结合 - Gxqsd</title>
<link>http://www.cnblogs.com/Gxqsd/p/9345678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Gxqsd/p/9345678.html</guid>
<description>&lt;p&gt;前五篇博文分别介绍并实现了前端校验和服务器校验，这篇博文主要是介绍如何将两者结合起来使用，并总结。&lt;/p&gt;
&lt;p&gt;之前，我们在ASP.NET MVC中集成了基于FluentValidator的验证器，并通过扩展Controller，在ControllEx中 使用 OnActionExecuting 进行统一校验。最后将所有错误信息存放在ViewData[&quot;Error&quot;]内部后返回视图。&lt;/p&gt;
&lt;p&gt;在视图呈现方面，我们使用了HtmlHelper的扩展方法来帮呈现，这样有效避免了Null的尴尬局面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示指定属性的错误消息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;htmlHelper&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;HtmlHelper&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;property&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;指定的属性&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;error&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;ViewData[&quot;Error&quot;]&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;tagType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;标签类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;htmlAttribute&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;标签属性&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MvcHtmlString ValidatorMessageFor(&lt;span&gt;this&lt;/span&gt; HtmlHelper htmlHelper, &lt;span&gt;string&lt;/span&gt; property, &lt;span&gt;object&lt;/span&gt; error, &lt;span&gt;string&lt;/span&gt; tagType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt; htmlAttribute = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dicError = error &lt;span&gt;as&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dicError != &lt;span&gt;null&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有错误&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dicError.ContainsKey(property))
                {
                    StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (htmlAttribute != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        htmlAttribute.GetType().GetProperties().ToList().ForEach((p) &lt;/span&gt;=&amp;gt;&lt;span&gt;
                        {
                            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; key =&lt;span&gt; p.Name;
                            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; value =&lt;span&gt; p.GetValue(htmlAttribute).ToString();
                            sb.AppendFormat(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {0}='{1}' &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, key, value);
                        });
                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MvcHtmlString(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;{0} {2}&amp;gt;{1}&amp;lt;/{0}&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tagType, dicError[property], sb.ToString()));
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MvcHtmlString(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如今我对HtmlHelper做了一定修改，使它支持自定义标签类型和定义Html的属性，这会让我们好的管理呈现效果。比方为他加一个样式。&lt;/p&gt;
&lt;p&gt;通过以上步骤我们就实现了服务端的验证。&lt;/p&gt;
&lt;p&gt;在前端，与前几章说讲的一样，我们使用Vue，并自编写了基于Vue的验证插件vuefluentvalidator，为什么叫它vuefluentvalidator，因为编写它的时候就是借鉴的咱们后台验证框架FluentValidator的使用方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using ValidationWebTest.Mvc.MvcHelperEx
@{
    ViewBag.Title = &quot;ValidatorTest&quot;;
}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ValidatorTest&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    @using (Html.BeginForm())
    {
        @Html.AntiForgeryToken()

        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Person&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
            @Html.ValidationSummary(true, &quot;&quot;, new { @class = &quot;text-danger&quot; })
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;Name&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;control-label col-md-2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-md-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Name&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;model.name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;model.error.name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                    @Html.ValidatorMessageFor(&quot;Name&quot;, ViewData[&quot;Error&quot;], &quot;span&quot;, new { @class = &quot;text-info&quot; })
                &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;Age&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;control-label col-md-2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年龄&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-md-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Age&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;model.age&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;model.error.age&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                    @Html.ValidatorMessageFor(&quot;Age&quot;, ViewData[&quot;Error&quot;], &quot;strong&quot;)
                &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;Home&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;control-label col-md-2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;住址&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-md-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Address.Home&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;model.address.home&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;model.error.address.home&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                    @Html.ValidatorMessageFor(&quot;Address.Home&quot;, ViewData[&quot;Error&quot;])
                &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;Phone&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;control-label col-md-2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;电话&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-md-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Address.Phone&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;model.address.phone&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;model.error.address.phone&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                    @Html.ValidatorMessageFor(&quot;Address.Phone&quot;, ViewData[&quot;Error&quot;])
                &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-md-offset-2 col-md-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Create&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-default&quot;&lt;/span&gt;&lt;span&gt; v-on:click&lt;/span&gt;&lt;span&gt;=&quot;formSubmit($event)&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

@section scripts{
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/Content/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/Content/vuefluentvalidator.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        let vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#box&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            data: {
                validator: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Validator({
                    model: {
                        name: undefined,
                        age: undefined,
                        address: {
                            home: undefined,
                            phone: undefined
                        },
                    },
                    rule: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (than) {
                        than.ruleFor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;姓名不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                            .MinimumLength(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)
                            .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;最短长度为5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                        than.ruleFor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年龄不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                        than.ruleFor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address.home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;家庭地址不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                        than.ruleFor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address.phone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                            .NotEmpty()
                            .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;电话不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }),
            },
            methods: {
                formSubmit: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ev) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.validator.passValidation()) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                    ev.preventDefault();

                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.validator.validation(ev.target);
                }
            },
            computed: {
                model: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.validator.model;
                }
            }
        });
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用方式和之前前端验证所讲的都一模一样，只是在验证下边加了一行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 @Html.ValidatorMessageFor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ViewData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; { @class = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么我会这样写？因为在正常情况下，我们前端会进行校验，如果前端校验不通过的时候，请求不会发送到后台，所以这一行在正常情况下是用不到的。&lt;/p&gt;
&lt;p&gt;那在什么时候会用到他？在前端校验失效时或伪造请求时。&lt;/p&gt;
&lt;p&gt;首先分析第一种&lt;/p&gt;
&lt;p&gt;前端校验失效，也就意味着javascript失效，这种情况下我们的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;model.error.name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;什么都显示不出来。&lt;/p&gt;
&lt;p&gt;而在验证失败的时候 @Html.ValidatorMessageFor(&quot;Name&quot;, ViewData[&quot;Error&quot;], &quot;span&quot;, new { @class = &quot;text-info&quot; }) 就会起作用了，由于我们对标签的呈现效果控制的灵活性，在视觉体验上，没有任何区别。&lt;/p&gt;
&lt;p&gt;如果在第二种情况下，他都不是一个正常的请求，我管它干什么？阻止就是了。&lt;/p&gt;
&lt;p&gt;如果你认为既然使用Vue，那为什么不将错误信息绑定到我们的验证器上呢？&lt;/p&gt;
&lt;p&gt;事实上我也想过这么做，一是它的工作量比现在这种方式更大（原谅我偷了个懒），二是，如果javascript失效的话，那岂不是根本显示不出来？&lt;/p&gt;
&lt;p&gt;综上所述，于是我决定就让它这样简单而愉快的结束吧。到此我们的前后端校验功能就算全部实现。&lt;/p&gt;
&lt;p&gt;由于博文是前五篇的延续，在一些重复的内容上，不过多介绍，如果您在阅读时，有任何疑问，请从前面开始阅读。&lt;/p&gt;
</description>
<pubDate>Sat, 21 Jul 2018 02:00:00 +0000</pubDate>
<dc:creator>Gxqsd</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Gxqsd/p/9345678.html</dc:identifier>
</item>
</channel>
</rss>