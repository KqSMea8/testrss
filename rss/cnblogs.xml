<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>解决微信公众平台IP白名单 - 小特工作室</title>
<link>http://www.cnblogs.com/xiyang1011/p/7952924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyang1011/p/7952924.html</guid>
<description>&lt;p&gt;微信公众平台，作为自媒体的旗舰级产品，越来越多的人已经投入它的怀抱。正如它的广告词所说：再小的个体，也有品牌&lt;/p&gt;
&lt;p&gt;好吧，闲话不多说，今天要说的是它的IP白名单机制。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/70305/201712/70305-20171202072859261-859717094.png&quot;&gt;&lt;img title=&quot;查看白名单&quot; src=&quot;http://images2017.cnblogs.com/blog/70305/201712/70305-20171202072859651-273619108.png&quot; alt=&quot;查看白名单&quot; width=&quot;644&quot; height=&quot;464&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/70305/201712/70305-20171202072859839-808092393.png&quot;&gt;&lt;img title=&quot;修改白名单&quot; src=&quot;http://images2017.cnblogs.com/blog/70305/201712/70305-20171202072900011-727379237.png&quot; alt=&quot;修改白名单&quot; width=&quot;693&quot; height=&quot;287&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我们现在安装的大部分都是电信的家庭宽带，它的公网IP是随机的，当然也可以加钱变成固定IP，也可以通过其他软件映射，都可以变成固定IP&lt;/p&gt;
&lt;p&gt;我说的这个方案，也算其中一种吧，就是通过WebAPI方式，把某一台机器的公网IP固定，然后访问公众号的程序部署在这上面，最后这些程序再通过WebAPI方式被其他客户端调用&lt;/p&gt;
&lt;p&gt;好了，还是上代码吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3,需先将封面上传至目标公众号              
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.1,下载原公众号中封面图片.判断是否存在?不存在,则下载
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注:需判断文件夹是否存在?若不存在,则创建&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt; folderName = CurrentAppInfo.AppPath + &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;\MaterialFile\thumb\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Directory.Exists(folderName))
{
    Directory.CreateDirectory(folderName);
}
&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; fileFullName = folderName + sourceThumbMediaId + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
FileInfo fi &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInfo(fileFullName);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;fi.Exists)
{
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sourceAccessToken = &lt;span&gt;this&lt;/span&gt;.wxpService.GetAccessToken(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sourceSourceID);
    Stream imageStream &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.wxpService.GetMaterial(sourceAccessToken, sourceThumbMediaId);
    Image image &lt;/span&gt;=&lt;span&gt; Image.FromStream(imageStream);
    Bitmap bitmap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bitmap(image);

    bitmap.Save(fileFullName);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.2,再上传至目标公众号
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处是上传封面图片&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt; targetAccessToken = &lt;span&gt;this&lt;/span&gt;.wxpService.GetAccessToken(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetSourceID);
UploadMaterialApiResultModel modelApiResult1 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.wxpService.UploadMaterialAny(targetAccessToken, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; wxpmaterialBillModel()
{
    IsTemp &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    FileFullName &lt;/span&gt;=&lt;span&gt; fi.FullName,
    MaterialType &lt;/span&gt;=&lt;span&gt; MaterialType.thumb.ToString()
});
&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; targetThumbMediaId =&lt;span&gt; modelApiResult1.media_id;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3,加工数据&lt;/span&gt;
wxpapiaccountBillModel modelSourceApiAccount = &lt;span&gt;this&lt;/span&gt;.listApiAccount.FirstOrDefault(c =&amp;gt; c.SourceID == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sourceSourceID);
wxpapiaccountBillModel modelTargetApiAccount &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.listApiAccount.FirstOrDefault(c =&amp;gt; c.SourceID == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetSourceID);
content &lt;/span&gt;=&lt;span&gt; content.Replace(modelSourceApiAccount.SourceCode, modelTargetApiAccount.SourceCode);
content &lt;/span&gt;=&lt;span&gt; content.Replace(modelSourceApiAccount.SourceName, modelTargetApiAccount.SourceName);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维码图片可能有多个,分隔符是:分号
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注:目标地址只获取第1个即可&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt;[] qrcodeUrl1s = modelSourceApiAccount.QRCodeUrlPath.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; qrcodeUrl2 = modelTargetApiAccount.QRCodeUrlPath.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; qrcodeUrl1 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; qrcodeUrl1s)
{
    content &lt;/span&gt;=&lt;span&gt; content.Replace(qrcodeUrl1, qrcodeUrl2);
}

UploadNewsModel modelUpload &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UploadNewsModel()
{
    title &lt;/span&gt;=&lt;span&gt; title,
    author &lt;/span&gt;=&lt;span&gt; author,
    digest &lt;/span&gt;=&lt;span&gt; digest,
    content &lt;/span&gt;=&lt;span&gt; content,
    content_source_url &lt;/span&gt;=&lt;span&gt; targetSourceUrl,
    show_cover_pic &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    thumb_media_id &lt;/span&gt;=&lt;span&gt; targetThumbMediaId
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4,上传素材至目标公众号                &lt;/span&gt;
UploadMaterialApiResultModel modelResult = &lt;span&gt;this&lt;/span&gt;.wxpService.UploadMaterialNews(targetAccessToken, &lt;span&gt;new&lt;/span&gt; List&amp;lt;UploadNewsModel&amp;gt;&lt;span&gt;() { modelUpload });

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.1,需标记源公众号中此素材已转发&lt;/span&gt;
wxpmaterialBillModel modelEditToSource = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; wxpmaterialBillModel()
{
    SourceID &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sourceSourceID,
    MaterialCode &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sourceMaterialCode,
    IsTranspond &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    ActionName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SetIsTranspond&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
};
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.wxpService.UpdateMaterial(&lt;span&gt;new&lt;/span&gt; List&amp;lt;wxpmaterialBillModel&amp;gt;() { modelEditToSource });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上图所示，这是实现图文素材从公众号A复制至公众号B里的代码，这种情况下，我每天在家里打开电脑时，都要在IP白名单中重新设置下电脑的公网IP，不然，会提示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/70305/201712/70305-20171202073310542-135586669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;改成下面的代码就可以轻松解决，我把程序部署到阿里云上，so easy，换个思路，又是一片新的天空。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
copymaterialQueryModel copymaterialParamModel = new Base.Models.copymaterialQueryModel()
{
    sourceSourceID = this.sourceSourceID,
    sourceMaterialCode = this.sourceMaterialCode,
    targetSourceID = this.targetSourceID,
    title = title,
    digest = digest,
    author = author,
    targetSourceUrl = targetSourceUrl,
    wxAccessToken = wxAccessToken
};
UploadMaterialApiResultModel modelResult = WebAPIHelper.WebAPIPostData&amp;lt;UploadMaterialApiResultModel&amp;gt;(ControllerName.WXPublicApi, WXPublicApiActionName.CopyMaterial.ToString(), copymaterialParamModel);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后，发布一个彩蛋，做自媒体的可以看看&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/xiyang1011/p/7620110.html&quot; target=&quot;_blank&quot;&gt;Navi.Soft31.微信WinForm框架(含下载地址)　&lt;/a&gt;　&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/xiyang1011/p/7837148.html&quot; target=&quot;_blank&quot;&gt;Navi.Soft31.产品.登录器(永久免费)&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 01 Dec 2017 23:29:00 +0000</pubDate>
<dc:creator>小特工作室</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyang1011/p/7952924.html</dc:identifier>
</item>
<item>
<title>websocket（三） 进阶！netty框架实现websocket达到高并发 - 黄新宇的博客</title>
<link>http://www.cnblogs.com/tohxyblog/p/7946498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tohxyblog/p/7946498.html</guid>
<description>&lt;h4 id=&quot;h4--&quot;&gt;引言：&lt;/h4&gt;
&lt;p&gt;在前面两篇文章中，我们对原生websocket进行了了解，且用demo来简单的讲解了其用法。但是在实际项目中，那样的用法是不可取的，理由是tomcat对高并发的支持不怎么好，特别是tomcat9之前，可以测试发现websocket连接达到的数量很低，且容易断开。&lt;br/&gt;所以有现在的第三篇，对websocket的一种进阶方法。&lt;/p&gt;
&lt;h4 id=&quot;h4--netty&quot;&gt;什么是Netty&lt;/h4&gt;
&lt;p&gt;Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，它已经得到成百上千的商用项目验证，例如Hadoop的RPC框架Avro就使用了Netty作为底层通信框架，其他还有业界主流的RPC框架，也使用Netty来构建高性能的异步通信能力。&lt;br/&gt;通过对Netty的分析，我们将它的优点总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;API使用简单，开发门槛低；&lt;/li&gt;
&lt;li&gt;功能强大，预置了多种编解码功能，支持多种主流协议；&lt;/li&gt;
&lt;li&gt;定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；&lt;/li&gt;
&lt;li&gt;性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优；&lt;/li&gt;
&lt;li&gt;成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；&lt;/li&gt;
&lt;li&gt;社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会加入；&lt;/li&gt;
&lt;li&gt;经历了大规模的商业应用考验，质量得到验证。Netty在互联网、大数据、网络游戏、企业应用、电信软件等众多行业已经得到了成功商用，证明它已经完全能够满足不同行业的商业应用了。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h4--netty-websocket-&quot;&gt;基于Netty的websocket压力测试&lt;/h4&gt;
&lt;p&gt;&lt;a title=&quot;点此进入&quot; href=&quot;http://blog.csdn.net/joeyon1985/article/details/53411357&quot;&gt;点此进入&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;h4-demo-&quot;&gt;Demo详解&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.导入netty包&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- netty --&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;netty-all&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;5.0.0.Alpha1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.server启动类&lt;/strong&gt;&lt;br/&gt;以下&lt;a class=&quot;at-link&quot; title=&quot;@Service&quot; href=&quot;https://github.com/Service&quot;&gt;@Service&lt;/a&gt;，&lt;a class=&quot;at-link&quot; title=&quot;@PostConstruct&quot; href=&quot;https://github.com/PostConstruct&quot;&gt;@PostConstruct&lt;/a&gt;注解是标注spring启动时启动的注解，新开一个线程去开启netty服务器端口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.nettywebsocket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.PostConstruct;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.bootstrap.ServerBootstrap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.Channel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.EventLoopGroup;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.NioEventLoopGroup;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.socket.nio.NioServerSocketChannel;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* ClassName:NettyServer 注解式随spring启动
* Function: TODO ADD FUNCTION.
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; hxy
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NettyServer {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyServer().run();
}
@PostConstruct
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initNetty(){
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NettyServer().run();
}
}.start();
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
System.out.println(&lt;/span&gt;&quot;===========================Netty端口启动========&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Boss线程：由这个线程池提供的线程是boss种类的，用于创建、连接、绑定socket， （有点像门卫）然后把这些socket传给worker线程池。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在服务器端每个监听的socket都有一个boss线程来处理。在客户端，只有一个boss线程来处理所有的socket。&lt;/span&gt;
EventLoopGroup bossGroup = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioEventLoopGroup();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Worker线程：Worker线程执行所有的异步I/O，即处理操作&lt;/span&gt;
EventLoopGroup workGroup = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioEventLoopGroup();
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ServerBootstrap 启动NIO服务的辅助启动类,负责初始话netty服务器，并且开始监听端口的socket请求&lt;/span&gt;
ServerBootstrap b = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerBootstrap();
b.group(bossGroup, workGroup);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置非阻塞,用它来建立新accept的连接,用于构造serversocketchannel的工厂类&lt;/span&gt;
b.channel(NioServerSocketChannel.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ChildChannelHandler 对出入的数据进行的业务操作,其继承ChannelInitializer&lt;/span&gt;
b.childHandler(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChildChannelHandler());
System.out.println(&lt;/span&gt;&quot;服务端开启等待客户端连接 ... ...&quot;&lt;span&gt;);
Channel ch &lt;/span&gt;= b.bind(7397&lt;span&gt;).sync().channel();
ch.closeFuture().sync();
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
e.printStackTrace();
}&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
bossGroup.shutdownGracefully();
workGroup.shutdownGracefully();
}
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.channle注册类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.nettywebsocket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelInitializer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.socket.SocketChannel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpObjectAggregator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpServerCodec;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.stream.ChunkedWriteHandler;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* ClassName:ChildChannelHandler
* Function: TODO ADD FUNCTION.
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; hxy
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ChildChannelHandler &lt;span&gt;extends&lt;/span&gt; ChannelInitializer&amp;lt;SocketChannel&amp;gt;&lt;span&gt;{
@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initChannel(SocketChannel e) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置30秒没有读到数据，则触发一个READER_IDLE事件。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pipeline.addLast(new IdleStateHandler(30, 0, 0));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HttpServerCodec：将请求和应答消息解码为HTTP消息&lt;/span&gt;
e.pipeline().addLast(&quot;http-codec&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpServerCodec());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HttpObjectAggregator：将HTTP消息的多个部分合成一条完整的HTTP消息&lt;/span&gt;
e.pipeline().addLast(&quot;aggregator&quot;,&lt;span&gt;new&lt;/span&gt; HttpObjectAggregator(65536&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ChunkedWriteHandler：向客户端发送HTML5文件&lt;/span&gt;
e.pipeline().addLast(&quot;http-chunked&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChunkedWriteHandler());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在管道中添加我们自己的接收数据实现方法&lt;/span&gt;
e.pipeline().addLast(&quot;handler&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyWebSocketServerHandler());
}
}
&lt;/span&gt;4&lt;span&gt;.存储类
以下类是用来存储访问的channle，channelGroup的原型是set集合，保证channle的唯一，如需根据参数标注存储，可以使用currentHashMap来存储。

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.nettywebsocket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.group.ChannelGroup;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.group.DefaultChannelGroup;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.util.concurrent.GlobalEventExecutor;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* ClassName:Global
* Function: TODO ADD FUNCTION.
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; hxy
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Global {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ChannelGroup group = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5.实际处理类&lt;/strong&gt;&lt;br/&gt;以下处理类虽然做了注释，但是在这里还是详细讲解下。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这个类是单例的，每个线程处理会新实例化一个类。&lt;/li&gt;
&lt;li&gt;每个成功的线程访问顺序：channelActive（开启连接）-handleHttpRequest（http握手处理）-messageReceived（消息接收处理）-handlerWebSocketFrame（实际处理，可以放到其他类里面分业务进行）&lt;/li&gt;
&lt;li&gt;注意：这个demo中我做了路由功能，在handleHttpRequest中对每个channel连接的时候对每个连接的url进行绑定参数，然后在messageReceived中获取绑定的参数进行分发处理（handlerWebSocketFrame或handlerWebSocketFrame2），同时也获取了uri后置参数，有注释。&lt;/li&gt;
&lt;li&gt;针对第三点路由分发，还有一种方法就是handshaker的uri（）方法，看源码即可，简单好用。&lt;/li&gt;
&lt;li&gt;群发的时候遍历集合或者map的时候，必须每个channle都实例化一个TextWebSocketFrame对象，否则会报错或者发不出。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.nettywebsocket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.logging.Level;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.logging.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.buffer.ByteBuf;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.buffer.Unpooled;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelFuture;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelFutureListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelHandlerContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.SimpleChannelInboundHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.DefaultFullHttpResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.FullHttpRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpHeaders;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpMethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpResponseStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpVersion;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.QueryStringDecoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.websocketx.WebSocketFrame;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.util.AttributeKey;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.util.CharsetUtil;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* ClassName:MyWebSocketServerHandler Function: TODO ADD FUNCTION.
*
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; hxy
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyWebSocketServerHandler &lt;span&gt;extends&lt;/span&gt; SimpleChannelInboundHandler&amp;lt;Object&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = Logger.getLogger(WebSocketServerHandshaker.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; WebSocketServerHandshaker handshaker;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* channel 通道 action 活跃的 当客户端主动链接服务端的链接后，这个通道就是活跃的了。也就是客户端与服务端建立了通信通道并且可以传输数据
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelActive(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加&lt;/span&gt;
&lt;span&gt;Global.group.add(ctx.channel());
System.out.println(&lt;/span&gt;&quot;客户端与服务端连接开启：&quot; +&lt;span&gt; ctx.channel().remoteAddress().toString());
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* channel 通道 Inactive 不活跃的 当客户端主动断开服务端的链接后，这个通道就是不活跃的。也就是说客户端与服务端关闭了通信通道并且不可以传输数据
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelInactive(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移除&lt;/span&gt;
&lt;span&gt;Global.group.remove(ctx.channel());
System.out.println(&lt;/span&gt;&quot;客户端与服务端连接关闭：&quot; +&lt;span&gt; ctx.channel().remoteAddress().toString());
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 接收客户端发送的消息 channel 通道 Read 读 简而言之就是从通道中读取数据，也就是服务端接收客户端发来的数据。但是这个数据在不进行解码时它是ByteBuf类型的
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; messageReceived(ChannelHandlerContext ctx, Object msg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传统的HTTP接入&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; FullHttpRequest) {
handleHttpRequest(ctx, ((FullHttpRequest) msg));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; WebSocket接入&lt;/span&gt;
} &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; WebSocketFrame) {
System.out.println(handshaker.uri());
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&quot;anzhuo&quot;.equals(ctx.attr(AttributeKey.valueOf(&quot;type&quot;&lt;span&gt;)).get())){
handlerWebSocketFrame(ctx, (WebSocketFrame) msg);
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
handlerWebSocketFrame2(ctx, (WebSocketFrame) msg);
}
}
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* channel 通道 Read 读取 Complete 完成 在通道读取完成后会在这个方法里通知，对应可以做刷新操作 ctx.flush()
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelReadComplete(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
ctx.flush();
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handlerWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否关闭链路的指令&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (frame &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; CloseWebSocketFrame) {
System.out.println(&lt;/span&gt;1&lt;span&gt;);
handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否ping消息&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (frame &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; PingWebSocketFrame) {
ctx.channel().write(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PongWebSocketFrame(frame.content().retain()));
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 本例程仅支持文本消息，不支持二进制消息&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (!(frame &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TextWebSocketFrame)) {
System.out.println(&lt;/span&gt;&quot;本例程仅支持文本消息，不支持二进制消息&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException(
String.format(&lt;/span&gt;&quot;%s frame types not supported&quot;&lt;span&gt;, frame.getClass().getName()));
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回应答消息&lt;/span&gt;
String request =&lt;span&gt; ((TextWebSocketFrame) frame).text();
System.out.println(&lt;/span&gt;&quot;服务端收到：&quot; +&lt;span&gt; request);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isLoggable(Level.FINE)) {
logger.fine(String.format(&lt;/span&gt;&quot;%s received %s&quot;&lt;span&gt;, ctx.channel(), request));
}
TextWebSocketFrame tws &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TextWebSocketFrame(&lt;span&gt;new&lt;/span&gt; Date().toString() + ctx.channel().id() + &quot;：&quot; +&lt;span&gt; request);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 群发&lt;/span&gt;
&lt;span&gt;Global.group.writeAndFlush(tws);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回【谁发的发给谁】
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ctx.channel().writeAndFlush(tws);&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handlerWebSocketFrame2(ChannelHandlerContext ctx, WebSocketFrame frame) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否关闭链路的指令&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (frame &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; CloseWebSocketFrame) {
handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否ping消息&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (frame &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; PingWebSocketFrame) {
ctx.channel().write(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PongWebSocketFrame(frame.content().retain()));
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 本例程仅支持文本消息，不支持二进制消息&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (!(frame &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TextWebSocketFrame)) {
System.out.println(&lt;/span&gt;&quot;本例程仅支持文本消息，不支持二进制消息&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException(
String.format(&lt;/span&gt;&quot;%s frame types not supported&quot;&lt;span&gt;, frame.getClass().getName()));
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回应答消息&lt;/span&gt;
String request =&lt;span&gt; ((TextWebSocketFrame) frame).text();
System.out.println(&lt;/span&gt;&quot;服务端2收到：&quot; +&lt;span&gt; request);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isLoggable(Level.FINE)) {
logger.fine(String.format(&lt;/span&gt;&quot;%s received %s&quot;&lt;span&gt;, ctx.channel(), request));
}
TextWebSocketFrame tws &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TextWebSocketFrame(&lt;span&gt;new&lt;/span&gt; Date().toString() + ctx.channel().id() + &quot;：&quot; +&lt;span&gt; request);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 群发&lt;/span&gt;
&lt;span&gt;Global.group.writeAndFlush(tws);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回【谁发的发给谁】
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ctx.channel().writeAndFlush(tws);&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果HTTP解码失败，返回HHTP异常&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (!req.getDecoderResult().isSuccess() || (!&quot;websocket&quot;.equals(req.headers().get(&quot;Upgrade&quot;&lt;span&gt;)))) {
sendHttpResponse(ctx, req,
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST));
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取url后置参数&lt;/span&gt;
HttpMethod method=&lt;span&gt;req.getMethod();
String uri&lt;/span&gt;=&lt;span&gt;req.getUri();
QueryStringDecoder queryStringDecoder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryStringDecoder(uri);
Map&lt;/span&gt;&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; parameters =&lt;span&gt; queryStringDecoder.parameters();
System.out.println(parameters.get(&lt;/span&gt;&quot;request&quot;).get(0&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(method==HttpMethod.GET&amp;amp;&amp;amp;&quot;/webssss&quot;&lt;span&gt;.equals(uri)){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....处理&lt;/span&gt;
ctx.attr(AttributeKey.valueOf(&quot;type&quot;)).set(&quot;anzhuo&quot;&lt;span&gt;);
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(method==HttpMethod.GET&amp;amp;&amp;amp;&quot;/websocket&quot;&lt;span&gt;.equals(uri)){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...处理&lt;/span&gt;
ctx.attr(AttributeKey.valueOf(&quot;type&quot;)).set(&quot;live&quot;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造握手响应返回，本机测试&lt;/span&gt;
WebSocketServerHandshakerFactory wsFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebSocketServerHandshakerFactory(
&lt;/span&gt;&quot;ws://&quot;+req.headers().get(HttpHeaders.Names.HOST)+uri, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
handshaker &lt;/span&gt;=&lt;span&gt; wsFactory.newHandshaker(req);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handshaker == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
handshaker.handshake(ctx.channel(), req);
}
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, DefaultFullHttpResponse res) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回应答给客户端&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (res.getStatus().code() != 200&lt;span&gt;) {
ByteBuf buf &lt;/span&gt;=&lt;span&gt; Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8);
res.content().writeBytes(buf);
buf.release();
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是非Keep-Alive，关闭连接&lt;/span&gt;
ChannelFuture f =&lt;span&gt; ctx.channel().writeAndFlush(res);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!HttpHeaders.isKeepAlive(req) || res.getStatus().code() != 200&lt;span&gt;) {
f.addListener(ChannelFutureListener.CLOSE);
}
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* exception 异常 Caught 抓住 抓住异常，当发生异常的时候，可以做一些相应的处理，比如打印日志、关闭链接
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
cause.printStackTrace();
ctx.close();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;以上就是netty-websocket的Demo了，应该已经解释的很详细了，同时应对的并发量也满足一般企业用于websocket的连接，如果需要不够，可以用nginx负载均衡增加。&lt;/li&gt;
&lt;li&gt;最后给大家一条建议，在实际项目中，别让这种长连接一直保持，在nginx中可以设置连接无交流超时断开，大概设置10分钟左右，然后每8分钟定时从服务端发送一条心跳，具体想法就看你们喽~&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;　&lt;span&gt;　&lt;strong&gt;&lt;span&gt;亲们，请点此链接，博主自己的博客更需要你们的光临。&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt; &lt;a href=&quot;http://heartblog.xin/index/&quot; target=&quot;_blank&quot;&gt;时光盒&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 18:03:00 +0000</pubDate>
<dc:creator>黄新宇的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tohxyblog/p/7946498.html</dc:identifier>
</item>
<item>
<title>不要在极端情绪下处理感情，好吗？ - 柒小栈主</title>
<link>http://www.cnblogs.com/qixiaoyizhan/p/7946114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qixiaoyizhan/p/7946114.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/998608/201712/998608-20171202012729214-1785472782.jpg&quot; alt=&quot;&quot; width=&quot;835&quot; height=&quot;464&quot;/&gt;&lt;/p&gt;

&lt;p&gt;感情有时候很坚强，天崩地裂，海枯石烂。&lt;/p&gt;
&lt;p&gt;感情有时候很脆弱，惊弓之鸟，弱不禁风。&lt;/p&gt;
&lt;p&gt;总结三个字：看心情！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;公司团建，晚上十点正要回家，突然收到女朋友的微信消息说她下班了，好久没有收到来自她的消息的我心想，亲终于“早”下班一回了，打着奋斗的名义北漂的人们，大概能理解其中的心酸与无奈。&lt;/p&gt;
&lt;p&gt;在说话的间隔我大概安排了一下明日的行程安排，稍加整理了一下思绪，准备了三个问题准备等会和女友商量。&lt;/p&gt;
&lt;p&gt;“登登登…”&lt;/p&gt;
&lt;p&gt;“Hello~”&lt;/p&gt;
&lt;p&gt;“Hi~”&lt;/p&gt;
&lt;p&gt;厮杀几十回合后，中场休息。&lt;/p&gt;
&lt;p&gt;程序员女友接到了同事更改需求的消息…&lt;/p&gt;
&lt;p&gt;小斗几回合，正处在尴尬点上，“砰”，突然黑屏，哦，冬日里的iphone。&lt;/p&gt;
&lt;p&gt;小区门前有人要开门进去，没有门卡的我以百米冲刺的速度，终于在门要合上之前挤了进去，然后站在单元楼门口，傻眼了。&lt;/p&gt;
&lt;p&gt;单元楼门是刷卡进入的，新装修的单元门已经是坏掉了，屋里的远程开关是打不开的，所以一般单元门是一直敞开着的，一周遇到两次被关门外的我站在月色下北京城冬日里的小区单元楼门口瑟瑟发抖却无可奈何。&lt;/p&gt;
&lt;p&gt;前两次都是微信喊舍友下楼开门，而如今手机关机的我正一筹莫展之时，瞄到了亮着灯的一层出租屋里的小哥。&lt;/p&gt;
&lt;p&gt;敲了敲窗户，示意帮忙开下门。&lt;/p&gt;
&lt;p&gt;一脸不耐烦。&lt;/p&gt;
&lt;p&gt;“去找物业开门。”&lt;/p&gt;
&lt;p&gt;“物业在哪？”&lt;/p&gt;
&lt;p&gt;“就在那按门铃。”&lt;/p&gt;
&lt;p&gt;“好的，谢谢！”&lt;/p&gt;
&lt;p&gt;把门上的按钮全部按了一遍，看着门上没一个不坏的按钮，我脑海里反射出了一万个MMP！&lt;/p&gt;
&lt;p&gt;诶？楼道的灯亮了，这个点还有出门的人？&lt;/p&gt;
&lt;p&gt;还真的有！&lt;/p&gt;
&lt;p&gt;回到家急忙给手机充上电，找到了女友的微信，解释了原因，刚要说如此奇葩的经历，说到嘴边，女友发来了一连串催促我感紧休息的消息，并很没耐心地怼回了我提议的第一件事。&lt;/p&gt;
&lt;p&gt;第一反应是女友因为需求的事很烦躁，可能把早回家的一系列开心的情绪已经污染成了一团糟。第二反应，女友正在烦躁点上，再多说话可能会殃及池鱼，而且也会让其心情更糟糕，殃及的可能就不是池鱼了。第三反应，明显要赶上姨妈，没必要和人亲戚找茬。&lt;/p&gt;
&lt;p&gt;识时务者为俊杰，立马暗示语结束了微信，并短信郑重捋了下事件的情景，并主动道歉认错，自己该打，让人家不开心，乖乖隐退。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;爱情里没有绝对的对错，没必要非要争个孰是孰非，最后赢了道理，却输掉了感情！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主动道歉有时候并不是因为真的做错，而是因为爱。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/998608/201712/998608-20171202013253308-430001981.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;自从看到曾经的同窗有情人终未成眷属之后，我就默默在空间新建了一个相册，名字叫旅途中的你们还好吗？只对自己可见。&lt;/p&gt;
&lt;p&gt;这个相册里面存的都是所有我认识的人秀过恩爱后的合照，当然我并不会在任何时候拿出来做什么蠢事，那也不是我的为人准则。这个相册的目的只有一个，不定期去关注一下他们的感情发展情况，好的或是不好的，总结经验。有的初心还在，有的却物是人非。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;爱情是一门学问，不是靠顺其自然就可以和和美美，地老天荒。感情是需要用心经营的，同样美好的感情都是用心经营过的，顺其自然，美好感情的几率微乎其微。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经营爱情是需要认真学习，不断进步的，不是自己有一颗上进的心就可以，还要有对此付出的行动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我认为我虽然行动了很多，关注各种情感类公众号，树立正确的情感观念；关注各大星座论坛，分析各种星座人的通用行为模式；关注各类女性专题，了解女性的新思维新思想；但是还远远不够，有的时候仍然是处理的一团糟。&lt;/p&gt;
&lt;p&gt;如果有人非要过来说就喜欢顺其自然，那我不说什么话，发来照片默默进此相册即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/998608/201712/998608-20171202013048386-1568506964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;水瓶座。&lt;/p&gt;
&lt;p&gt;嗯，为什么单单要拿出来说水瓶座呢？很简单，因为女友就是那个蛇精大水瓶！&lt;/p&gt;
&lt;p&gt;如果经常关注各大星座媒介，那一定听说过如下几句典型的描述：&lt;/p&gt;
&lt;p&gt;“水瓶座最适合做单身狗，因为不喜被束缚，有一颗强烈追求自由的心。”&lt;/p&gt;
&lt;p&gt;“水瓶座是一个能把爱情的无限可能性在自己的世界里一点点抹掉的星座。”&lt;/p&gt;
&lt;p&gt;“水瓶座最适合的恋爱姿势是从朋友做起，发展成为恋人。”&lt;/p&gt;
&lt;p&gt;“和水瓶座谈恋爱，必受伤！”&lt;/p&gt;
&lt;p&gt;“最伤人星座排行榜名列前茅。”&lt;/p&gt;
&lt;p&gt;“水瓶座，玻璃心。”&lt;/p&gt;
&lt;p&gt;“忽冷忽热的星座。”&lt;/p&gt;
&lt;p&gt;不继续列举了，我们先就上述的几条一一做出解释，我们不说水瓶座优秀的其他方面，我们光说情感上的得与失：&lt;/p&gt;
&lt;p&gt;水瓶座愿意单身是因为还没有找到自己的真爱，如果找到真爱，还是不喜欢束缚，喜欢有自己的生活。&lt;/p&gt;
&lt;p&gt;哈哈哈，是不是有种被骗的感觉，事实上确实这样，通过自己的亲身体会和多方观察，这类星座不管是何时心里都住着一颗自由之心，所以她们想追求什么如果没有什么毛病就去尽量满足吧。虽然和中华传统文化里的贤妻良母有着巨大的差别，但是选择了水瓶，就需要忍受着她们的“自我”。&lt;/p&gt;
&lt;p&gt;无限可能化为乌有。水瓶座是一个喜欢理性思考的星座，总是心里想着各种各样的发展可能，但是就是不愿意让自己相信美好的爱情，不相信海誓山盟，不相信海枯石烂。她们享受美好的爱情，她们在爱情里付出，但是她们并不会去好好规划爱情，因此，不相信永恒的爱情也是理所当然的，活在当下的一类人必然是如此的。鉴于此，如果选择了水瓶座，那么请付出大量的尽力去担起规划未来的重任，如果不在这方面付出，想必爱情的走向是一团糟，最后迷茫的生活会逐渐消磨掉所有的美好…&lt;/p&gt;
&lt;p&gt;朋友发展为恋人，这点不置可否。水瓶座的朋友很多，嫉恶如仇，黑白分明的性格让她们对朋友进行了一轮一轮的筛选，长久的朋友发展成恋人的可能性也并非不存在。&lt;/p&gt;
&lt;p&gt;最后四条属于一类，和水瓶座相处的问题，恐怕最有资格发言的是那些瓶子的恋人们了，为什么受伤，为什么伤人指数如此之高，答案就在四条里，那就是“忽冷忽热”！&lt;/p&gt;
&lt;p&gt;任何事物都有两面性，忽冷忽热，有冷必有热，没有人可以百分百地说出自己对另一半就是一直火热的态度，因为人非圣贤。为什么光水瓶就被排在了前排呢？答案又是说过了的，嫉恶如仇，黑白分明的性格，加上忽冷忽热的态度，那么最终结果就是极端的忽冷忽热！&lt;/p&gt;
&lt;p&gt;为什么一般人的忽冷忽热没有什么，因为他们忽冷忽热的不够极端，不够明显，而瓶子们极端的做法很容易让深处深渊的人瞬间升上了天堂，又会让天堂的人跌落如湿寒的深渊，忽上忽下的感觉，如果不能适应，理所当然的难受。&lt;/p&gt;
&lt;p&gt;热的阶段的瓶子们是非常好的伴侣，她们会花功夫在你的身上，嘘寒问暖，各方面为你好。相处心情愉悦，百依百顺，甚至会粘人，撒娇，想要和你一直在一起度过美好的时光。嗯，理想中情人模样。&lt;/p&gt;
&lt;p&gt;如果突然有一天，瓶子们对你爱答不理的，你留言很久才回复，即便回复也是丝毫没有温度的言辞，话不多说，甚至你和她们说话她们都不知道同时在干嘛。更不会在这时候和你说什么天长地久，以及一切美好的话题，她们会默默生活自己的世界里。这时候急性子的情侣一定会感到不爽怼回去，碰上水瓶万事随缘，独立的性格，这时候就呵呵了，突然默默明白了为什么天秤和水瓶契合。&lt;/p&gt;
&lt;p&gt;所以和水瓶的情感处理点就总结到了如何处理水瓶冷淡期的感情问题上。&lt;/p&gt;
&lt;p&gt;处于冷淡期的水瓶不谈任何和感情相关的事情，因为很容易由于一时冲动造成遗憾。由于一时冲动而造成的遗憾并不能单单指责水瓶座。任何靠冲动而来的感情都不会太容易维持下去，而由于冲动造成的情感问题却是最多的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要在极端情绪下处理感情。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为这时候都是最为不理智的时候，在这时候做出的决定是被冲动控制的，往往会令人后悔和造成一生的遗憾。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无论是我自己，我的恋人，还是千千万万的伴侣们，在有问题有冲突的时候一定首先要冷静，不要回避问题，要去直面问题，解决问题。如果实在不能保持冷静，那么就用时间去缓解吧。一个很好的建议就是停止一切活动，过一两个晚上再做出决定。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也只有这时候做出的决定，才是自己内心长久以来真正想要的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后祝天下所有的有情人相互谅解，遇事勿冲动，相濡以沫，拥抱美好的明天。&lt;/p&gt;
&lt;p&gt;顺路给所有的北漂人加油打气！&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 17:34:00 +0000</pubDate>
<dc:creator>柒小栈主</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qixiaoyizhan/p/7946114.html</dc:identifier>
</item>
<item>
<title>今天用node的cheerio模块做了个某乎的爬虫 - 三十亿少女的梦</title>
<link>http://www.cnblogs.com/yonglin/p/7944512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yonglin/p/7944512.html</guid>
<description>&lt;p&gt;　    一时兴起，想做个爬虫，经过各种深思熟虑，最后选择了某乎，毕竟现在某乎的数据质量还是挺高的。说干就干&lt;/p&gt;
&lt;p&gt;　　 打开某乎首页，随便搜索了一串关键字，相关的问题和答案就展现在眼前，我就思考怎么把这些搜索结果全部通过爬虫爬下来，方便收集（我也不知道收集来干嘛嘻嘻）。&lt;/p&gt;
&lt;p&gt; 　　发现搜索结果每页只会显示10条数据，某乎用的是点击加载更多数据，于是打开chrome的network工具，点击加载更多的按钮，发现多了一个新的ajax请求，很明显这个请求就是用来请求后十条数据的。&lt;/p&gt;
&lt;p&gt; 　   分析这个请求头，观察这个get请求的url最后的参数，offset=10，用脚都想的出来，这明显就是告诉后台我要的数据从哪条开始，而我要通过爬虫把后面的数据爬下来就是要在这个参数上做些手脚，我只要改一下后面的offset构造新的url，然后发送新的请求，就可以得到其他页面的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1091597/201712/1091597-20171201210604214-1179390301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然而事情并没有那么简单，我们先自己手动构造一个请求url，用浏览器打开看一下，服务器返回如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1091597/201712/1091597-20171201211318886-794395145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我滴个乖乖，这是什么鬼，但是不要慌张，虽然一眼看上去很恐怖，但是仔细分析一下就知道这是用了unicode编码而已，还有一堆转意字符。&lt;/p&gt;
&lt;p&gt;      我用的是node的https模块来进行get请求，拿到数据之后，先把拿到的数据（也就是上一张图上的那些乱七八糟的东西）用正则匹配把\/替换成/，把\&quot;替换成&quot;,然后用node的cheerio模块就能解析出dom结构，然后就是提取出我们需要的信息，到这里我们已经可以把搜索结果的所有问题都爬下来了，但是这只是抓取到了问题，问题的答案我们还要跳转对应问题的链接才知道，同样打开chrome的开发者工具，这次用elements的功能，看一下问题对应的超链接&lt;img src=&quot;http://images2017.cnblogs.com/blog/1091597/201712/1091597-20171201212739011-971611282.png&quot; alt=&quot;&quot;/&gt;，可以看到这是一个相对路径。所以我们只要把这个相对路径改为绝对路径就可以，其实也就是在这个相对路径前面加上www.zhihu.com就可以，得到路径之后，我们就可以用node的https.get方法去进行get请求，这样就可以得到对应问题的答案。美滋滋，爬下来的数据如下图（我利用node的fs模块把爬下来的数据写到了项目路径下的txt文档里）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1091597/201712/1091597-20171201225215823-2134544520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   果然，事情再一次没有想象中的简单，从数据可以看到，答案只抓取到了两个，然而答案并不应该只有两条，所以可以初步推测，当我们进入答案的页面，后台返回页面的时候只返回了两条答案，其他答案应该是用ajax后加载的。为了验证我的假设，我把答案页面的javascript禁止了，然后刷新，果然答案只返回了两条，所以，可以证明我的假设是正确的，下面要做的就是找到加载更多答案的那个ajax请求，国际惯例，打开chrome的network工具，查看有哪些ajax请求，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1091597/201712/1091597-20171201230338854-366117827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过各种分析（响应大小，响应内容分析等等），最终锁定目标，上图被选中的get请求就是加载更多答案的那个get请求，把这个get请求url拷贝下来，我们在浏览器中打开看一下，结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1091597/201712/1091597-20171201230715464-2112564996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　标准结局，结果又是一堆乱七八糟的东西，但是静下心来仔细分析，可以看到结果其实是一个json格式的数据，并且做了unicode编码，所以我们要做的就是把这些结果解码，之后用JSON.parse()方法把这个json字符串转换为json对象，然后就是对这个json对象进行一顿操作，最后分析出来。我们需要的内容就在这里面，把我们需要的内容拿到之后保存在txt文档中。&lt;/p&gt;
&lt;p&gt;　　这样爬虫基本上就算完成了。效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1091597/201712/1091597-20171201233422511-663296643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;踩坑总结：&lt;/p&gt;
&lt;p&gt;　　1.正则表达式转意字符，例： 我们要匹配 &quot; 这个符号，正则表达式中需要在该符号之前加上转意字符\ &lt;/p&gt;
&lt;p&gt;      2.刚开始url请求更多答案的时候，服务器是返回100状态给我的，经过各种分析，最后发现是有登陆信息才能请求所有答案，所以我用node请求答案的时候需要做的一件事就是假装我是浏览器，并且我已经登陆了，嘻嘻嘻，这无非就是在请求头上做手脚。比如修改UA，添加一些对应的cookie,authorization等等&lt;/p&gt;

&lt;p&gt;为了造福人民，我已经把源码在git开源了，点击&lt;a href=&quot;https://github.com/nayonglin/zhihu_spiders&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;，如能star，必将以身相许，嘻嘻嘻&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 16:22:00 +0000</pubDate>
<dc:creator>三十亿少女的梦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yonglin/p/7944512.html</dc:identifier>
</item>
<item>
<title>Geth控制台使用及Web3.js使用实战 - Tiny熊</title>
<link>http://www.cnblogs.com/tinyxiong/p/7944921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tinyxiong/p/7944921.html</guid>
<description>&lt;p&gt;在开发以太坊去中心化应用，免不了和以太坊进行交互，那就离不开Web3。&lt;br/&gt;Geth 控制台（REPL）实现了所有的&lt;a href=&quot;http://web3js.readthedocs.io/en/1.0/index.html&quot;&gt;web3 API&lt;/a&gt;及&lt;a href=&quot;https://github.com/ethereum/go-ethereum/wiki/Management-APIs#admin&quot;&gt;Admin API&lt;/a&gt;，&lt;br/&gt;使用好 Geth 就是必修课。结合&lt;a href=&quot;https://learnblockchain.cn/2017/11/29/geth_cmd_options/&quot;&gt;Geth命令用法&lt;/a&gt;阅读效果更佳。&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;阅读本文之前，你需要对以太坊（区块链）有初步的了解，如果你不知道以太坊是什么，请先阅读&lt;a href=&quot;https://learnblockchain.cn/2017/11/20/whatiseth/&quot;&gt;以太坊是什么&lt;/a&gt;。&lt;br/&gt;如果你在我的小专栏之外的地方阅读到本文，你可能只能阅读本文的节选，阅读完整全文请订阅小专栏&lt;a href=&quot;https://xiaozhuanlan.com/blockchaincore&quot;&gt;区块链技术&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;geth控制台初探---启动退出&quot;&gt;geth控制台初探 - 启动、退出&lt;/h2&gt;
&lt;p&gt;安装参考&lt;a href=&quot;https://learnblockchain.cn/2017/11/24/init-env/&quot;&gt;智能合约开发环境搭建&lt;/a&gt;&lt;br/&gt;最简单启动方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ geth console&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;geth控制台启动成功之后，可以看到&lt;strong&gt;&amp;gt;&lt;/strong&gt;提示符。&lt;br/&gt;退出输入exit&lt;/p&gt;
&lt;h2 id=&quot;geth-日志控制&quot;&gt;geth 日志控制&lt;/h2&gt;
&lt;h3 id=&quot;重定向日志到文件&quot;&gt;重定向日志到文件&lt;/h3&gt;
&lt;p&gt;使用&lt;strong&gt;geth console&lt;/strong&gt;启动是，会在当前的交互界面下时不时出现日志。&lt;br/&gt;可以使用以下方式把日志输出到文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ geth console 2&amp;gt;&amp;gt;geth.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以新开一个命令行终端输入以下命令查看日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ tail -f geth.log&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重定向另一个终端&quot;&gt;重定向另一个终端&lt;/h3&gt;
&lt;p&gt;也可以把日志重定向到另一个终端，先在想要看日志的终端输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ tty&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就可以获取到终端编号，如：/dev/ttys003&lt;br/&gt;然后另一个终端使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ geth console 2&amp;gt;&amp;gt; /dev/ttys003&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动geth, 这是日志就输出到另一个终端。&lt;br/&gt;如果不想看到日志还可以重定向到空终端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ geth console 2&amp;gt;&amp;gt; /dev/null&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;日志级别控制&quot;&gt;日志级别控制&lt;/h3&gt;
&lt;p&gt;使用&lt;strong&gt;--verbosity&lt;/strong&gt;可以控制日志级别，如不想看到日志还可以使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ geth --verbosity 0 console&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动一个开发模式测试节点&quot;&gt;启动一个开发模式测试节点&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;geth --datadir /home/xxx/testNet --dev console&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;技巧：如果我们经常使用一个方式来启动，可以把命令存为一个bash脚本。&lt;br/&gt;~/bin你可以放一些常用的脚本，并把~/bin加入到环境变量PATH里。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;连接geth节点&quot;&gt;连接geth节点&lt;/h2&gt;
&lt;p&gt;另外一个启动geth的方法是连接到一个geth节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ geth attach ipc:/some/custom/path
$ geth attach http://191.168.1.1:8545
$ geth attach ws://191.168.1.1:8546&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如连接刚刚打开的开发模式节点使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;geth attach ipc:testNet/geth.ipc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多内容请前往区块链技术小专栏查看&lt;a href=&quot;https://xiaozhuanlan.com/topic/5617843029&quot;&gt;全文链接&lt;/a&gt;。&lt;br/&gt;&lt;a href=&quot;https://learnblockchain.cn/&quot;&gt;深入浅出区块链&lt;/a&gt; - 系统学习区块链，打造最好的区块链技术博客&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 15:55:00 +0000</pubDate>
<dc:creator>Tiny熊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tinyxiong/p/7944921.html</dc:identifier>
</item>
<item>
<title>多个线程实现顺序打印数据，（可自定义线程一次打印数量和总数量） - 宇的季节</title>
<link>http://www.cnblogs.com/chenkeyu/p/7944879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenkeyu/p/7944879.html</guid>
<description>&lt;p&gt;　　最近看到一道面试题：让3个线程顺序打印数字，如线程1打印1-5，线程2打印6-10，线程3打印11-15,然后是线程1打印16-20...一直打印到75结束。&lt;/p&gt;
&lt;p&gt;　　这到题主要问题有两点：&lt;/p&gt;
&lt;p&gt;　　　　第一点是不能让线程打印的过程中出现其他线程&lt;/p&gt;
&lt;p&gt;　　　　第二点是要实现线程进入的过程是有序的，如上123123..这样。&lt;/p&gt;
&lt;p&gt;　　我先是把基本的功能实现了，后来发现可以改造一下，做成可扩展的，即每次打印的数量可自定义，总的数量可自定义，并且保证线程的顺序是有序的，下面是具体代码：&lt;/p&gt;
&lt;p&gt;　　PrintQueue.java 文件，同步线程，控制打印顺序，也是最主要的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cky;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedHashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PrintQueue {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; targetNum=0;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要打印的目标数量&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; printOnce=0;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一次要打印的次数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nowNum=1;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;目前打印到的数量&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; targetNum    要打印的目标数量
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; printOnce 一次要打印的次数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; PrintQueue(&lt;span&gt;int&lt;/span&gt; targetNum, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; printOnce) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.targetNum =&lt;span&gt; targetNum;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.printOnce =&lt;span&gt; printOnce;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nextThreadNum=0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下次要执行线程的下标&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threadCount=0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总的线程数量
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;map集合，存放线程，键是具体线程，值存放线程打印的顺序&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;Thread,Integer&amp;gt; threads=&lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;Thread,Integer&amp;gt;&lt;span&gt;();
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加线程&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setThread(Thread thread) {
        threads.put(thread, threadCount);
        threadCount&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行线程&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Thread thread : threads.keySet()) {
            thread.start();
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printNum() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前线程&lt;/span&gt;
        Thread currentThread=&lt;span&gt;Thread.currentThread();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前线程坐标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; currentNum=&lt;span&gt;threads.get(currentThread);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否为期望线程&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(currentNum==&lt;span&gt;nextThreadNum) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;printOnce;i++&lt;span&gt;) {
                System.out.println(&lt;/span&gt;&quot;当前线程：&quot;+currentThread.getName()+&quot;:&quot;+nowNum++&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(nowNum&amp;gt;&lt;span&gt;targetNum) {
                    System.out.println(&lt;/span&gt;&quot;工作完成&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.wait();
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;期望线程名+1&lt;/span&gt;
            nextThreadNum=(++nextThreadNum)%&lt;span&gt;threadCount;
        }
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　RunTest.java  很简单的Runable接口实现，功能就是请求打印&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cky;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; RunTest &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    PrintQueue ps;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RunTest(PrintQueue ps ) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ps=&lt;span&gt;ps;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                ps.printNum();
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ThreadDemo.java 测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cky;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String [] args) {
        //设置一共打印20个，每个线程一次只打印3个&lt;br/&gt;　　　　　PrintQueue ps&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; PrintQueue(20, 3&lt;span&gt;);&lt;br/&gt;　　　　　//添加线程
        ps.setThread(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; RunTest(ps),&quot;王大锤&quot;&lt;span&gt;));
        ps.setThread(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; RunTest(ps),&quot;张全蛋&quot;&lt;span&gt;));
        ps.setThread(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; RunTest(ps),&quot;二狗&quot;&lt;span&gt;));
        ps.run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1003414/201712/1003414-20171201233250995-794947247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 01 Dec 2017 15:33:00 +0000</pubDate>
<dc:creator>宇的季节</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenkeyu/p/7944879.html</dc:identifier>
</item>
<item>
<title>【读书笔记】《Maven实战》 第7章 生命周期与插件 - Ye_yang</title>
<link>http://www.cnblogs.com/yeyang/p/7944875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yeyang/p/7944875.html</guid>
<description>[unable to retrieve full-text content]7.1什么是生命周期 软件开发人员每天都在对项目进行清理、编译、测试及部署，Maven生命周期是对所有构建过程进行抽象和统一，含项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。 7.2生命周期详解 7.2.1三套相互独立的生命周期 clean：目的是清理项目 </description>
<pubDate>Fri, 01 Dec 2017 15:32:00 +0000</pubDate>
<dc:creator>Ye_yang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yeyang/p/7944875.html</dc:identifier>
</item>
<item>
<title>EntityFramework For Mysql 动态切换数据源 - nele</title>
<link>http://www.cnblogs.com/nele/p/7944838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nele/p/7944838.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;1.简介&lt;/h2&gt;
&lt;p&gt;在工作中遇到一个问题。项目有三个数据库（三个数据库表结构一样），用户可以选择使用哪个数据库。其实就是动态切换数据库连接。&lt;/p&gt;
&lt;h2 id=&quot;entityframework-for-mysql&quot;&gt;2.EntityFramework For Mysql&lt;/h2&gt;
&lt;p&gt;先来简单的介绍下mysql使用EntityFramework来操作数据库。&lt;br/&gt;直接上代码：&lt;/p&gt;
&lt;h4 id=&quot;先建个项目安装mysqlentityframework相关包&quot;&gt;(1).先建个项目，安装mysql，entityframework相关包&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-f55d52a1d0a9265a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;nuget安装&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;建立实体和对应的数据库表&quot;&gt;(2).建立实体和对应的数据库表&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-d48cbd94a7ebd4f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;人员实体&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-e9fba8386f87a49a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;文章实体&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-3562ee47eeef43b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;建表语句&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;编写数据库连接字符串编写context实体&quot;&gt;(3).编写数据库连接字符串，编写context实体&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-1c9a369c416ec422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;数据库连接字符串&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-5cea09dc4d394e20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;context实体类&quot;/&gt;&lt;br/&gt;这样就可以来使用Entityframework来访问mysql数据了。&lt;/p&gt;
&lt;h4 id=&quot;简单测试&quot;&gt;(4).简单测试&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-f807a3fa33cb8013.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;测试代码&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-cc0dc3eac8202882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;person测试结果&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-a6b5d124f73d4af9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;article测试结果&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;动态切换数据库&quot;&gt;3.动态切换数据库&lt;/h2&gt;
&lt;h4 id=&quot;在建一个blog1数据库表如blog数据库&quot;&gt;(1).在建一个blog1数据库，表如blog数据库。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-4f4fbfed5f748183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;两个数据库&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;对context进行改造&quot;&gt;(2).对context进行改造&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-e4e07ec1396a22af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;context改造后&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;改造测试&quot;&gt;(3).改造测试&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-f6a1ac115c28d082.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;测试blog1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-9b6f651bd0e6ef8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;blog1表&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-fda0c74c7d3be712.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;blog&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-5b524330654d8e3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;blog表&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么可以直接传链接字符串&quot;&gt;4.为什么可以直接传链接字符串&lt;/h2&gt;
&lt;p&gt;从DbContext构造函数的方法签名可以看出端倪。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/301624-ee8cf00a9bdb8e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;DbContext构造函数&quot;/&gt;&lt;br/&gt;可以看出我们传数据库连接字符串名字和直接传数据库连接字符串都是可以的。EntityFramework会去做判断，如果是name，再去配置文件取数据库连接字符串和providerName。如果是数据库连接字符串则直接拿来用。&lt;/p&gt;
&lt;h2 id=&quot;遇到的坑&quot;&gt;5.遇到的坑&lt;/h2&gt;
&lt;p&gt;其实EntityFramework对mysql的支持并不是很好，还有些bug。我在进行以上实验的时候遇到了一个问题。当我直接将数据库连接字符串的传到父类的构造函数时，报了： Keyword not supported:'port'错误。经过一番查找，最终找到三个方案：&lt;a href=&quot;https://stackoverflow.com/questions/45217166/c-sharp-entity-framework-keyword-not-supported-port&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/45217166/c-sharp-entity-framework-keyword-not-supported-port&lt;/a&gt;。&lt;br/&gt;遇到坑的童鞋们可以去看下。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 15:18:00 +0000</pubDate>
<dc:creator>nele</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nele/p/7944838.html</dc:identifier>
</item>
<item>
<title>php数据类型 - 韦大大</title>
<link>http://www.cnblogs.com/average/p/7944707.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/average/p/7944707.html</guid>
<description>&lt;p&gt;记得上篇中最后用&lt;strong&gt;var_dump&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 函数打印出来的数据前面显示的是数据类型，这篇就对php的数据类型做个简单说明。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;PHP的数据类型有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;color_h1&quot;&gt;String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;color_h1&quot;&gt;好，下面我们来一一具体介绍：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;PHP 字符串&lt;/h3&gt;
&lt;p&gt;一个字符串是一串字符的序列，就像 &quot;Hello world!&quot;。&lt;/p&gt;
&lt;p&gt;你可以将任何文本放在单引号和双引号中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$x = &quot;Hello world!&quot;; 
echo $x; echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = 'Hello world!'; 
echo $x; 
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
Hello world!
Hello world!
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;PHP 整型&lt;/h3&gt;
&lt;p&gt;整数是一个没有小数的数字。&lt;/p&gt;
&lt;p&gt;整数规则:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整数必须至少有一个数字 (0-9)&lt;/li&gt;
&lt;li&gt;整数不能包含逗号或空格&lt;/li&gt;
&lt;li&gt;整数是没有小数点的&lt;/li&gt;
&lt;li&gt;整数可以是正数或负数&lt;/li&gt;
&lt;li&gt;整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在以下实例中我们将测试不同的数字。 PHP var_dump() 函数返回变量的数据类型和值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$x = 5985; 
var_dump($x); 
echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = -345; // 负数 
var_dump($x); 
echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = 0x8C; // 十六进制数 
var_dump($x); 
echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = 047; // 八进制数 
var_dump($x); 
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
int(5985) 
int(-345) 
int(140) 
int(39)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;PHP 浮点型&lt;/h3&gt;
&lt;p&gt;浮点数是带小数部分的数字，或是指数形式。&lt;/p&gt;
&lt;p&gt;在以下实例中我们将测试不同的数字。 PHP var_dump() 函数返回变量的数据类型和值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$x = 10.365; 
var_dump($x); 
echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = 2.4e3; 
var_dump($x); 
echo &quot;&amp;lt;br&amp;gt;&quot;; 
$x = 8E-5; 
var_dump($x); 
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
float(10.365) 
float(2400) 
float(8.0E-5)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;PHP 布尔型&lt;/h3&gt;
&lt;p&gt;布尔型可以是 TRUE 或 FALSE。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$x=true;
    

        
$y=false;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;布尔型通常用于条件判断。&lt;/p&gt;
&lt;h3&gt;PHP 数组&lt;/h3&gt;
&lt;p&gt;数组可以在一个变量中存储多个值。&lt;/p&gt;
&lt;p&gt;在以下实例中创建了一个数组， 然后使用 PHP var_dump() 函数返回数组的数据类型和值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); 
var_dump($cars); 
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
array(3) { [0]=&amp;gt; string(5) &quot;Volvo&quot; [1]=&amp;gt; string(3) &quot;BMW&quot; [2]=&amp;gt; string(6) &quot;Toyota&quot; }  
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;PHP 对象&lt;/h3&gt;
&lt;p&gt;对象数据类型也可以用于存储数据。&lt;/p&gt;
&lt;p&gt;在 PHP 中，对象必须声明。&lt;/p&gt;
&lt;p&gt;首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。// 关于类更详细的解释请看：http://www.php.cn/php-weizijiaocheng-360220.html&lt;/p&gt;
&lt;p&gt;然后我们在类中定义数据类型，然后在实例化的类中使用数据类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php
class Point2D {
    var $x, $y;
    var $label;

    function Point2D($x, $y)//跟类名相同的情况下，在类被实例化以后
    {
        $this-&amp;gt;x = $x;
        $this-&amp;gt;y = $y;
    }

    function setLabel($label)
    {
        $this-&amp;gt;label = $label;
    }

    function getPoint()
    {
        return array(&quot;x&quot; =&amp;gt; $this-&amp;gt;x,
                     &quot;y&quot; =&amp;gt; $this-&amp;gt;y,
                     &quot;label&quot; =&amp;gt; $this-&amp;gt;label);
    }
}

// &quot;$label&quot; 已声明，但未定义
$p1 = new Point2D(1.233, 3.445);//声明类对象
print_r(get_object_vars($p1));

$p1-&amp;gt;setLabel(&quot;point #1&quot;);
print_r(get_object_vars($p1));

?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上实例中PHP关键字this就是指向当前对象实例的指针，不指向任何其他对象或类。　　&lt;/p&gt;
&lt;p&gt;这里用到了函数get_object_vars() —&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;dc-title&quot;&gt;返回由对象属性组成的关联数组。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
Array
 (
     [x] =&amp;gt; 1.233
     [y] =&amp;gt; 3.445
     [label] =&amp;gt;
 )

 Array
 (
     [x] =&amp;gt; 1.233
     [y] =&amp;gt; 3.445
     [label] =&amp;gt; point #1
 )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　由于类和对象这块知识点比较绕，我计划下篇专门剖析一下&lt;/p&gt;
&lt;h3&gt;PHP NULL 值&lt;/h3&gt;
&lt;p&gt;NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。&lt;/p&gt;
&lt;p&gt;NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。&lt;/p&gt;
&lt;p&gt;可以通过设置变量值为 NULL 来清空变量数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php 
$x=&quot;Hello world!&quot;; 
$x=null; 
var_dump($x); 
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;


&lt;p&gt;PHP的数据类型就到这里了，由于今天知识点较多，所以用的时间有点多，搞的好累，嘿嘿，，，你也休息下吧。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 14:34:00 +0000</pubDate>
<dc:creator>韦大大</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/average/p/7944707.html</dc:identifier>
</item>
<item>
<title>《Linux命令行与shell脚本编程大全》第十七章 创建函数 - xcywt</title>
<link>http://www.cnblogs.com/xcywt/p/7944596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcywt/p/7944596.html</guid>
<description>&lt;p&gt;可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用它了。&lt;/p&gt;
&lt;h2&gt;17.1 基本的脚本函数&lt;/h2&gt;
&lt;p&gt;函数：是一个脚本代码块，可以为其命名并在代码中任何位置重用。&lt;/p&gt;
&lt;h3&gt;17.1.1 创建函数&lt;/h3&gt;
&lt;p&gt;有两种格式：name 是函数名&lt;/p&gt;
&lt;p&gt;1）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;function name&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;{&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;         commands&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;}&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）这种就比较接近c语言风格了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;name()&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;{&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;         commands&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;}&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;17.1.2 使用函数&lt;/h3&gt;
&lt;p&gt;跟其他shell命令一样，在行中指定函数名就好了。&lt;/p&gt;
&lt;p&gt;在函数定义前使用函数，会收到一条错误消息。&lt;/p&gt;
&lt;p&gt;函数名是唯一的，如果重定义了函数，新的会覆盖旧的，并且不会产生任何错误消息。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;em&gt;  1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  3 function fun&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  4 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  5         echo &quot;hahahaha, i am a function&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  6 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  7&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  8 count=1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  9 while [ $count -lt 5 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 10 do&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 11         fun&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 12         count=$[ $count + 1 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 13 done&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 14&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 15 fun2  # Error fun2 not define&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 16 fun2() #&lt;/em&gt; &lt;em&gt;声明函数的另外一种方式&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 17 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 18         echo &quot;I am Fun2, hahaha&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 19 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 20 fun2&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;17.2 返回值&lt;/h2&gt;
&lt;p&gt;函数运行结束会返回一个退出状态码，有3种方法为函数生成退出状态码。&lt;/p&gt;
&lt;h3&gt;17.2.1 默认退出状态码&lt;/h3&gt;
&lt;p&gt;在函数结束时用 $? 来确定函数的退出状态码。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;…&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;fun&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;echo “return code:$?”&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;…&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果函数最后执行的语句失败了，这里就会返回非0，最后成功了（不管前面有没有失败）返回都是0.&lt;/p&gt;

&lt;h3&gt;17.2.2 使用return命令&lt;/h3&gt;
&lt;p&gt;bashshell使用return命令来退出函数并返回特定的退出状态码。return允许指定一个整数值来定义函数的退出状态码。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;函数一结束就要立即取返回值&lt;/p&gt;
&lt;p&gt;退出状态码必须是0 – 255.（大于255会产生一个错误值）&lt;/p&gt;

&lt;h3&gt;17.2.3 使用函数输出&lt;/h3&gt;
&lt;p&gt;可以将函数输出（&lt;span&gt;任何类型的函数输出&lt;/span&gt;）保存到shell变量中。&lt;/p&gt;
&lt;p&gt;语法：&lt;span&gt;&lt;em&gt;result=$(fun)&lt;/em&gt; &lt;/span&gt; 这个命令会将fun函数的输出赋给$result变量&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;em&gt;  1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  3 function fun&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  4 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  5         echo &quot;hahahaha, i am a function&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  6         return 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  7 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  8&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  9 fun&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 10 echo &quot;fun return $?&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 11&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 12 function fun2&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 13 {&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 14         echo &quot;This is Function fun2&quot;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 15         read -p &quot;Enter a value:&quot; num&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 16         echo $[ $num * 2 ]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 17 }&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 18&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 19 #fun2 #&lt;/em&gt; &lt;em&gt;如果加上这句就会调两次了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 20 &lt;span&gt;&lt;strong&gt;result=$(fun2)&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 21 &lt;span&gt;echo &quot;fun2 return:$&lt;strong&gt;result&lt;/strong&gt;&quot;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 这样就可以返回浮点数和字符串了。&lt;/p&gt;

&lt;h2&gt;17.3 在函数中使用变量&lt;/h2&gt;
&lt;p&gt;介绍一些处理shell脚本函数内外变量的方法&lt;/p&gt;

&lt;h3&gt;17.3.1 向函数传递参数&lt;/h3&gt;
&lt;p&gt;就跟向脚本传递参数一样，可以用$# $0 $1 $2&lt;/p&gt;
&lt;p&gt;注意脚本主体的$1 $2 和传到函数里面的并不相同。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;32&quot;&gt;
&lt;p&gt;&lt;em&gt;  1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  2 function add&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  3 {&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  4         if [ $# -eq 0 ] || [ $# -gt 2 ]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  5         then&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  6                 echo -1&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  7         elif [ $# -eq 1 ]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  8         then&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;  9                 echo $[ $1 + $1 ]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 10         else&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 11                 echo $[ $1 + $2 ]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 12         fi&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 13 }&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 14&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 15 #ret=$(add)&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 16 #ret=$(add 34) #&lt;/em&gt; &lt;em&gt;这里说明的如何传入参数&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt; 17 ret=$(add 23 18)&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 18 if [ $ret -eq -1 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 19 then&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 20         echo &quot;Function add Error&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 21 else&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 22         echo &quot;The value = $ret&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 23 fi&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 24&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 25 if [ $# -eq 2 ] #&lt;/em&gt; &lt;em&gt;这个的脚本主体接收的参数个数&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 26 then&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 27         &lt;strong&gt;&lt;span&gt;echo &quot;The value is $(add $1 $2)&quot; #&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt; &lt;strong&gt;&lt;span&gt;将脚本主体的参数传给里面的函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 28 else&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 29         echo &quot;Input Error&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 30 fi&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;17.3.2 在函数中处理变量&lt;/h3&gt;
&lt;p&gt;变量的作用域比较麻烦。作用域是变量可见的区域。&lt;/p&gt;
&lt;p&gt;函数中定义的变量和普通变量的作用域不同，也就是说对脚本的其他部分来说它们是隐藏的&lt;/p&gt;
&lt;p&gt;函数使用两种类型的变量：&lt;strong&gt;&lt;span&gt;全局变量和局部变量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.全局变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;是指在shell脚本中任何地方都有效的变量。&lt;/p&gt;
&lt;p&gt;在脚本主体部分定义了全局变量，那么在函数内可以读取它的值。&lt;/p&gt;
&lt;p&gt;在函数内定义了全局变量，在脚本的主体部分也可以读取它的值。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，在脚本中定义的任何变量都是全局变量&lt;/span&gt;。函数外定义的变量可在函数内访问&lt;/p&gt;
&lt;p&gt;这样要特别注意变量的使用。很容易就改变了变量。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.局部变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以在函数内部使用的任何变量都声明成局部变量。&lt;/p&gt;
&lt;p&gt;在变量声明前加上local关键字就好了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;local temp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;em&gt;  1 #!/bin/bash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  2 function fun&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  3 {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  4         &lt;strong&gt;#temp=$[ $value + 5 ] #&lt;/strong&gt;&lt;/em&gt; &lt;strong&gt;&lt;em&gt;如果这个是全局变量下面的结果就会异常&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;  5         local temp=$[ $value + 5 ]&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  6         ret=$[ $temp * 2 ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  7 }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  8&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;  9 temp=4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 10 value=6&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 11 &lt;strong&gt;fun&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 12 echo &quot;fun: ret = $ret&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 13 if [ $temp -gt $value ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 14 then&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 15         echo &quot;temp is big&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 16 else&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 17         echo &quot;value is big&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 18 fi&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h2&gt;17.4 数组变量和函数&lt;/h2&gt;
&lt;p&gt;第6章讨论了数组来在单个变量中保存多个值的高级用法&lt;/p&gt;

&lt;h3&gt;17.4.1 向函数传数组参数&lt;/h3&gt;
&lt;p&gt;复习�&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 13:57:00 +0000</pubDate>
<dc:creator>xcywt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcywt/p/7944596.html</dc:identifier>
</item>
</channel>
</rss>