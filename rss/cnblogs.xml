<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>lazy-mock ，一个生成后端模拟数据的懒人工具 - 若若若邪</title>
<link>http://www.cnblogs.com/jaycewu/p/9247302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaycewu/p/9247302.html</guid>
<description>&lt;h2 id=&quot;lazy-mock&quot;&gt;lazy-mock&lt;/h2&gt;
&lt;p&gt;  &lt;a href=&quot;https://github.com/wjkang/lazy-mock&quot;&gt;lazy-mock&lt;/a&gt; 是基于&lt;a href=&quot;https://github.com/koajs/koa&quot;&gt;koa2&lt;/a&gt;构建的，使用&lt;a href=&quot;https://github.com/typicode/lowdb&quot;&gt;lowdb&lt;/a&gt;持久化数据到JSON文件。只需要简单的配置就可以实现和&lt;a href=&quot;https://github.com/typicode/json-server&quot;&gt;json-server&lt;/a&gt;差不多的功能，但是比json-server更加灵活，后期可配置性更强，完全可以模拟真实后端业务逻辑。&lt;/p&gt;
&lt;p&gt;  lazy-mock默认包含了jwt实现的登录与登出，实现了基于RBAC模型的通用权限控制逻辑。具体可查看&lt;a href=&quot;https://github.com/wjkang/vue-quasar-admin&quot;&gt;vue-quasar-admin&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;clone&quot;&gt;Clone&lt;/h2&gt;
&lt;pre class=&quot;bush&quot;&gt;
&lt;code&gt;git clone https://github.com/wjkang/lazy-mock.git&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;install&quot;&gt;Install&lt;/h2&gt;
&lt;pre class=&quot;bush&quot;&gt;
&lt;code&gt;npm install&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;run&quot;&gt;Run&lt;/h2&gt;
&lt;pre class=&quot;bush&quot;&gt;
&lt;code&gt;npm run start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Postman模拟登录功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wjkang/lazy-mock/master/screenshot/2.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;use&quot;&gt;Use&lt;/h2&gt;
&lt;p&gt;下面通过模拟图书的增删改查 介绍lazy-mock的简单使用&lt;/p&gt;
&lt;h3 id=&quot;修改codegenerateconfigconfig.js&quot;&gt;修改codeGenerate/config/config.js：&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;ApiServer&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'http://localhost:3000'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;ServerRootPath&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'G:/GitHubProject/lazy-mock'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//server&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;RouteRelativePath&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/src/routes/'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;ControllerRelativePath&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/src/controllers/'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;ServiceRelativePath&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/src/services/'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;ModelRelativePath&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/src/models/'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;DBRelativePath&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/src/db/'&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要修改&lt;code&gt;ServerRootPath&lt;/code&gt;为当前项目的根目录。&lt;/p&gt;
&lt;h3 id=&quot;接着修改codegenerateconfigmodel.js&quot;&gt;接着修改codeGenerate/config/model.js：&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; shortid &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'shortid'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; Mock &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'mockjs'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; Random &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Mock&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Random&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//必须包含字段id&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;book&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Book&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [
        &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;书名&quot;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;author&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;作者&quot;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;press&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;出版社&quot;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    ]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;buildMockData&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//不需要生成设为false&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;shortid&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;generate&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Random&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;cword&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Random&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;cname&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;press&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Random&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;cword&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;)
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; data
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多生成模拟数据的规则可看&lt;a href=&quot;https://github.com/nuysoft/Mock&quot; class=&quot;uri&quot;&gt;https://github.com/nuysoft/Mock&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;生成代码&quot;&gt;生成代码&lt;/h3&gt;
&lt;p&gt;确保之前&lt;code&gt;npm run start&lt;/code&gt;的窗口还开着，打开新的命令行窗口，执行&lt;code&gt;npm run code&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wjkang/lazy-mock/master/screenshot/3.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;复制src/routes/bookApiMap.txt某一行数据到Postman访问&lt;/p&gt;
&lt;p&gt;&lt;code&gt;txt get http://localhost:3000/book/get?id=&lt;/code&gt;&lt;br/&gt;&lt;code&gt;txt get http://localhost:3000/book/paged?pageIndex=&amp;amp;pageSize=&amp;amp;sortBy=&amp;amp;descending=&amp;amp;id=&amp;amp;name=&amp;amp;author=&amp;amp;press=&lt;/code&gt;&lt;br/&gt;&lt;code&gt;txt delete http://localhost:3000/book/del?id=&lt;/code&gt;&lt;br/&gt;&lt;code&gt;txt delete http://localhost:3000/book/batchdel?ids=[]&lt;/code&gt;&lt;br/&gt;```txt&lt;br/&gt;//不设置id则新增，否则为更新&lt;br/&gt;post &lt;a href=&quot;http://localhost:3000/book/save&quot; class=&quot;uri&quot;&gt;http://localhost:3000/book/save&lt;/a&gt;&lt;br/&gt;{&lt;/p&gt;
&lt;p&gt;&quot;id&quot;:&quot;&quot;,&lt;/p&gt;
&lt;p&gt;&quot;name&quot;:&quot;&quot;,&lt;/p&gt;
&lt;p&gt;&quot;author&quot;:&quot;&quot;,&lt;/p&gt;
&lt;p&gt;&quot;press&quot;:&quot;&quot;,&lt;/p&gt;
&lt;p&gt;}&lt;br/&gt;```&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wjkang/lazy-mock/master/screenshot/4.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求头记得加上Authorization:Bearer token&lt;/p&gt;
&lt;p&gt;token之前模拟登录获取的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wjkang/lazy-mock/master/screenshot/5.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;## More&lt;/p&gt;
&lt;p&gt;### 修改自动生成的代码格式&lt;/p&gt;
&lt;p&gt;直接修改codeGenerate/serverTemplates 下文件&lt;/p&gt;
&lt;h3 id=&quot;去掉接口需要授权访问的限制&quot;&gt;去掉接口需要授权访问的限制&lt;/h3&gt;
&lt;p&gt;去掉scr/app.js 里的&lt;code&gt;.use(jwt({ secret: publicKey }).unless({ path: [/^\/public|\/auth\/login|\/assets/] }))&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改接口返回格式&quot;&gt;修改接口返回格式&lt;/h3&gt;
&lt;p&gt;修改src/lib/responseTemplate.js&lt;/p&gt;
&lt;h3 id=&quot;修改路由&quot;&gt;修改路由&lt;/h3&gt;
&lt;p&gt;修改src/routes 下文件&lt;/p&gt;
&lt;h3 id=&quot;添加更多业务逻辑&quot;&gt;添加更多业务逻辑&lt;/h3&gt;
&lt;p&gt;主要修改src/services下文件，具体可参考&lt;a href=&quot;https://github.com/wjkang/lazy-mock/blob/master/src/services/memuService.js&quot;&gt;memuService.js&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用权限控制逻辑&quot;&gt;使用权限控制逻辑&lt;/h3&gt;
&lt;p&gt;前端参考&lt;a href=&quot;https://github.com/wjkang/vue-quasar-admin&quot;&gt;vue-quasar-admin&lt;/a&gt;。实现了页面(菜单)，接口，元素级的权限控制。&lt;/p&gt;
&lt;p&gt;后端在路由处加上权限控制的中间件，比如&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/function/pagedlist'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;PermissionCheck&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;permission&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;function_view&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;test&quot;&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;controllers&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;function&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getFunctionPagedList&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;permission表明当前登录用户必须具备数组里的任意一个权限码，才能访问当前接口。&lt;/p&gt;
&lt;p&gt;role表明当前登录用户必须具备数组里的任意一个角色码，才能访问当前接口&lt;/p&gt;
&lt;p&gt;permission与role为或关系&lt;/p&gt;
</description>
<pubDate>Sat, 30 Jun 2018 07:30:00 +0000</pubDate>
<dc:creator>若若若邪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jaycewu/p/9247302.html</dc:identifier>
</item>
<item>
<title>项目经理需了解的技术 - SanMaoSpace</title>
<link>http://www.cnblogs.com/SanMaoSpace/p/9247285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SanMaoSpace/p/9247285.html</guid>
<description>&lt;p&gt;题记：&lt;br/&gt;前段时间，在微信项目管理沟通群，讨论项目经理是否需要掌握的研发技术，尤其是非研发转型的项目经理。为什么呢？因为软件项目管理，会经常给开发沟通，需要制定项目计划、项目工作量、项目技术细节解决、透过现象看本质，如果对技术不是太了解，会存在相对性的阻碍，项目开展效率会低一些。应小伙伴们的需求，对于非研发出身的项目经理，需要掌握的研发技术做简单的分享交流，这篇文章由此而写。&lt;br/&gt;关于不懂技术带来项目低效的问题，举个简单的栗子：在项目开展中，工程师碰到技术细节需要攻克，因开发能力有限，告诉你说解决不了。这个时候就需要懂技术的人，帮忙一起分析，讨论技术逻辑，形成解决问题的新思路，继续开发不能卡在这里。如果是技术性项目经理，在不忙的情况下，可以拉一个凳子跟开发坐在一起，一起分析解决；而非技术性项目经理，则需要向领导或技术经理申请协调资源，找能力强的工程师辅助解决，申请资源和沟通成本就会形成项目的低效。为什么呢？因为每个人都很忙，每个人都有自己的事情，会被排到不同的项目处理不同的事项，借调资源是相对麻烦的事情。他山之玉，《&lt;a title=&quot;项目经理需不需要懂技术&quot; href=&quot;https://blog.csdn.net/zh8706/article/details/51809686&quot; target=&quot;_blank&quot;&gt;项目经理需不需要懂技术&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;一、为什么转型项目经理&lt;/strong&gt;&lt;br/&gt;在解决上述问题之前，我们先来讨论下大家转型项目经理的初衷和方式。其实，问每一位项目经理，为啥带项目呢？每个人都有自己的答案，每个人的出发点也会不一致；问职业发展怎么做到项目经理的呢？会发现通向目标的道路有很多，有的坎坷曲折、有的相对顺利，每个人的职业规划和发展也是不一致的。就转型项目经理的初衷和方式两个方面，做如下分析和整理，仅供大家学习参考。&lt;br/&gt;&lt;span&gt;1.转型初衷&lt;/span&gt;&lt;br/&gt;(1).职业规划的提升，职业规划一直沿着项目路线进阶；&lt;br/&gt;(2).职业规划的转型，现有职业遇到瓶颈，需要新空间；&lt;br/&gt;(3).兴趣发展的驱动，兴趣使然，性格匹配高，挑战新领域；&lt;br/&gt;(4).薪资提高的诱惑，职业上升空间更大，薪资高，虚荣心使然；&lt;br/&gt;(5).被逼上岗的无奈，公司事务繁杂，原项目经理离职，项目时间紧迫；&lt;br/&gt;(6).内部转岗的机会，技术能力强，公司业务复杂学习成本高，公司内部提拔。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.转型方式&lt;/span&gt;&lt;br/&gt;(1).规划提升，项目专员-&amp;gt;项目助理-&amp;gt;项目经理；&lt;br/&gt;职业发展，一直沿着项目管理岗位规划，具备一定能力和资历，进行对应岗位的晋升；&lt;br/&gt;(2).规划转型，研发-&amp;gt;项目经理；&lt;br/&gt;高级研发，深入学习框架，沉闷研究，技术瓶颈明显；对项目管理岗感兴趣，项目管理知识储备到位；&lt;br/&gt;(3).规划转型，实施-&amp;gt;项目经理；&lt;br/&gt;高级实施，对售后客户各种问题的处理到位，沟通能力、实施管控能力相对较足，项目管理知识储备到位；&lt;br/&gt;(4).规划转型，售前-&amp;gt;项目经理；&lt;br/&gt;高级售前，对产品的市场和前瞻性的资讯敏感、捕捉能力强，与市场沟通紧密，计划性强、做方案能力强；&lt;br/&gt;(5).被迫上岗，研发、实施、售前-&amp;gt;项目经理；&lt;br/&gt;由于公司发展的需求，原项目经理离职，业务的复杂，学习成本高，外聘成本高，项目紧急度高，内部提拔，定岗上岗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;二、转型项目经理所需的软硬实力&lt;/strong&gt;&lt;br/&gt;尽快每个人转型的初衷不一样，总会有或多或少共同的想法；尽快每个人转型的方式有差异，条条大路通罗马，总会有适合自己的那条路。无论是走在转型路上或已经转型成功的项目经理，需要具备胜任项目经理的硬实力和软实力，不断的修炼提升，让项目开展更顺利、更容易成功。就转型项目经理的硬实力、软实力和加分项三个方面，做如下分析和整理，仅供大家学习参考。&lt;br/&gt;&lt;span&gt;1.硬实力&lt;/span&gt;&lt;br/&gt;(1).对主流项目管理体系了解、熟悉、灵活运用，如：PMP、Scrum、ACP等；&lt;br/&gt;(2).对主流项目管理工具了解、熟悉、灵活运用，如：JIRA、禅道、Redmine等；&lt;br/&gt;(3).对主流软件研发流程了解、熟悉、灵活运用，如：瀑布、敏捷、精益、规模化敏捷等；&lt;br/&gt;(4).对项目管理最佳工程实践了解、熟悉、灵活运用，如：站立会、回顾会、共识和确认等；&lt;br/&gt;(5).具有项目管理思维，繁杂事务中的全局观，既可以站在全局把握方向，又可以深入细节解决问题；&lt;br/&gt;(6).具有项目管理能力，曾负责项目全生命周期交付，如：计划管理、风险管理、整合资源、沟通管理等；&lt;br/&gt;(7).具备项目集管理能力，曾负责多项目的并行交付，进行跨团队、跨部门、跨公司的沟通协调，推动共赢。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.软实力&lt;/span&gt;&lt;br/&gt;(1).沟通能力，每个项目的形态不一样，每个项目的干系人性格有差异，需要确保项目信息流通顺畅，形成共识性的沟通机制；&lt;br/&gt;(2).统筹能力，对项目全局进行统筹性的把握，处乱不惊的掌控力，对问题的抽丝剥茧，透过现象看本质，把握主要问题和次要问题；&lt;br/&gt;(3).领导能力，可以很好的聆听他人、激励他人、引导他人，接受他人不足，取得他人的信任，在团队迷惘的时候，引领前进的方向；&lt;br/&gt;(4).共赢能力，可以与不同团队、不同公司、不同立场的人，达成共识性的认知和方案，进行适当让步和强势的调整，促成共赢的达成；&lt;br/&gt;(5).冲突处理能力，可以很好的处理团队内部的冲突、跨团队的冲突，将冲突转化为合作的能力，促进大家后续更加密切的合作；&lt;br/&gt;(6).协调推动能力，可以积极主动协调各个团队的资源，促进彼此合作，成为龙卷风的漩涡，卡在哪里就去解除，推动项目高效开展；&lt;br/&gt;(7).学习总结能力，可以根据项目形态、项目问题、团队成熟度等项目因素，不断地反思总结，提升研发效率，精进业务，为项目成功提供保障；&lt;br/&gt;(8).打不死的小强，在沟通、统筹、协调、领导、共赢、推动等方面，都在挑战你的承受力、忍耐力、攻坚能力，需要有小强打不死的精神，即使碰到阻力也要推动项目前进，没有任何一个项目是顺顺利利的，要有顽强的精神，向前多走几步，再多解决几个问题，项目就会明朗好多。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.加分项&lt;/span&gt;&lt;br/&gt;(1).系统项目管理的学习和认证考试，如：PMP、ACP、CSM等；&lt;br/&gt;(2).对软件技术和主流框架了解、熟悉、灵活运用；&lt;br/&gt;(3).较强的逻辑推理能力，缜密和考虑周全的思维；&lt;br/&gt;(4).较强的繁杂中共识约束建设，团队自运转推动；&lt;br/&gt;(5).较强的学习能力，对业务和概念进行快速熟悉；&lt;br/&gt;(6).较强的文案、宣讲和打鸡血能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;三、转型项目经理所需了解的相关技术&lt;/strong&gt;&lt;br/&gt;聊了些项目经理硬实力、软实力、加分项的能力要求，就大家关心的项目经理需了解的技术，做几点整理和分享。从下面三个方面介绍，了解技术的目的、程度、范围，其中技术范围涉及比较广，时代在变化层出不穷的技术不断涌现和淘汰。对于非研发出身的项目经理，需要了解通用数据库可视化工具的使用、通用设计技术概念的理解、前后台数据交互的逻辑、常用基础算法。通用数据库可视化工具的安装和使用，可以跟开发同学要下，熟悉常规增、删、改、查操作(不是写数据库脚本奥，是操作可视化工具进行数据处理)。不建议项目经理去学习具体某项技术的开发，因为最需要、最应该做好的事情就是项目管理，当然，感兴趣是可以研究下的嘛。记住，不要跟研发争论技术实现的细节，相信他在技术领域是最棒的，若担心技术风险对项目开展造成不可预期的影响，可组织相关的技术评审，一起讨论使用什么技术方案解决。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.了解技术目的&lt;/span&gt;&lt;br/&gt;(1).更好的支撑项目工作量评估、项目计划和迭代的制定；&lt;br/&gt;(2).更好的支撑项目开发中工程师技术问题的分析和解决；&lt;br/&gt;(3).更好的支撑项目技术风险评估和相关措施的应对；&lt;br/&gt;(4).更好的支撑项目技术细节的讨论分析，形成共识方案；&lt;br/&gt;(5).更好的汇报项目进度细节、卡顿节点，风险和影响等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.了解技术程度&lt;/span&gt;&lt;br/&gt;每个公司的组织架构不一样，团队各个岗位的人员配备不一样，对项目经理的技术能力需求也就会不一样。需要项目经理，结合团队的人员配备，进行适当程度的技术参与和辅助。当然，如果是研发出身的项目经理，基本的技术沟通和问题解决应该有很大帮助；如果非研发出身的项目经理，可以优先根据团队对技术的要求，紧急的补课，做技术的概要理解；如果时间相对比较充分，可以系统化的了解技术的概要内容。&lt;br/&gt;项目经理，最主要的工作、应该做好的工作，就是项目管理。常规项目团队成员，涉及产品同学、设计同学、开发同学、测试同学、运维同学，他们在各自的领域有所擅长。比较好的团队、高效的团队是每个职能岗位的同学都是能力很强的，基本不需要你去帮忙处理专业内部的事情。基于每个团队的能力或组成不一样，会存在相对性的能力偏差，这种情况需要项目经理去辅助、协调处理的事情就比较多。项目经理首先要把本职工作做好，在时间充足的情况下，或一些紧急节点要处理的情况下，团队向你提出支持的诉求，要积极快速响应，尽快解决处理好。&lt;br/&gt;项目经理在项目管理中不能抓小丢大，过多跟产品讨论原型，跟设计讨论风格，跟技术讨论实现，跟测试讨论用例，跟运维讨论部署等，不可太深入细节管理，而忽略项目的全生命周期管理。很多计划性事项、风险性事项、协调沟通事项，不能被前置处理，到了交付节点，就像热锅上的蚂蚁或救火队长，做紧急处理，搞的团队和你很疲惫。如果相关计划安排、资源申请、协调事项，提前开展，或许到交付节点，大家会轻松好多。&lt;br/&gt;项目经理的时间会成为项目的时间， 项目经理忙成狗，团队很轻松；团队忙成狗，项目经理很轻松，是不可取的。项目是一个平衡，一个度的把握，项目经理动起来，团队也要动起来；项目经理既要安排自己的事情，也要安排团队的事情，大家都动起来，才能更好协调合作、更快高效搞定项目。&lt;br/&gt;对于非研发出身的项目经理，在研发技术方面只需要做相应的熟悉和了解，可以跟研发团队进行技术沟通，懂得、理解他们表达的意思，以达到提高项目效率的目的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.了解相关技术&lt;/span&gt;&lt;br/&gt;(1).通用技术介绍&lt;br/&gt;通用系统技术：C、C++等；&lt;br/&gt;通用存储技术：文本文件、XML、Access、Excel、SQLite、MySQL、MS SQL、NoSQL、Oracle等；&lt;br/&gt;通用后台技术：Delphi、JSP、ASP、VB.NET、ASP.NET、Java、.Net、PHP、Python、Ruby、Go等；&lt;br/&gt;通用前端技术：MFC、WinForm、WPF、Silverlight、HTML、DIV、CSS、Vbscript、JavaScript、Ajax、H5、IOS、Android等；&lt;br/&gt;通用JS框架：JQuery、ExtJS、Node.Js、Angular.Js等；&lt;br/&gt;通用Java框架：Hibernate、Struts2、Struts、MyBatis、Spring、Spring MVC、Springboot等；&lt;br/&gt;通过.NET框架：Nhibernate、StructureMap、Spring.net、LINQ、Entity Framework、.NET MVC、WCF等；&lt;br/&gt;通用Web服务：XML、Jason、IIS、Apache、Nginx、Kangle、WebSphere、WebLogic、Tomcat、Jboss等；&lt;br/&gt;通用设计技术：设计模式、面向过程、面向对象、面向服务、集群管理、微服务、大数据、分布式、高并发、高可用、高扩展、高维护、高可读等；&lt;br/&gt;通用他人之玉：《&lt;a title=&quot;常用.NET框架汇总&quot; href=&quot;https://www.cnblogs.com/lhxsoft/p/8609089.html&quot; target=&quot;_blank&quot;&gt;常用.NET框架汇总&lt;/a&gt;》《&lt;a title=&quot;常用Java框架汇总&quot; href=&quot;https://www.cnblogs.com/byqh/p/5595384.html&quot; target=&quot;_blank&quot;&gt;常用Java框架汇总&lt;/a&gt;》《&lt;a title=&quot;常用JS框架汇总&quot; href=&quot;https://www.cnblogs.com/mbailing/p/5627792.html&quot; target=&quot;_blank&quot;&gt;常用JS框架汇总&lt;/a&gt;》《&lt;a title=&quot;常用IOS框架汇总&quot; href=&quot;https://blog.csdn.net/app_ios/article/details/52622309&quot; target=&quot;_blank&quot;&gt;常用IOS框架汇总&lt;/a&gt;》《&lt;a title=&quot;常用Android框架汇总&quot; href=&quot;https://blog.csdn.net/congmingyizhiha/article/details/70011020&quot; target=&quot;_blank&quot;&gt;常用Android框架汇总&lt;/a&gt;》《&lt;a title=&quot;常用Web服务器汇总&quot; href=&quot;http://baijiahao.baidu.com/s?id=1546765508325924&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot;&gt;常用Web服务器汇总&lt;/a&gt;》《&lt;a title=&quot;常用算法汇总&quot; href=&quot;https://blog.csdn.net/langxifu/article/details/73696967&quot; target=&quot;_blank&quot;&gt;常用算法汇总&lt;/a&gt;》&lt;br/&gt;(2).需了解的技术概念&lt;br/&gt;《&lt;a title=&quot;C/S和B/S结构区别整理&quot; href=&quot;http://www.cnblogs.com/SanMaoSpace/archive/2013/06/11/3131693.html&quot; target=&quot;_blank&quot;&gt;C/S和B/S结构区别整理&lt;/a&gt;》&lt;br/&gt;《&lt;a title=&quot;Web请求响应简单整理&quot; href=&quot;http://www.cnblogs.com/SanMaoSpace/archive/2013/06/12/3132489.html&quot; target=&quot;_blank&quot;&gt;Web请求响应简单整理&lt;/a&gt;》&lt;br/&gt;《&lt;a title=&quot;JavaScript特点、优缺点及常用框架&quot; href=&quot;http://www.cnblogs.com/SanMaoSpace/archive/2013/06/14/3136774.html&quot; target=&quot;_blank&quot;&gt;JavaScript特点、优缺点及常用框架&lt;/a&gt;》&lt;br/&gt;《&lt;a title=&quot;AJAX工作原理及其优缺点&quot; href=&quot;http://www.cnblogs.com/SanMaoSpace/archive/2013/06/15/3137180.html&quot; target=&quot;_blank&quot;&gt;AJAX工作原理及其优缺点&lt;/a&gt;》&lt;br/&gt;《&lt;a title=&quot;w3cschool在线教程&quot; href=&quot;http://www.w3school.com.cn/&quot; target=&quot;_blank&quot;&gt;w3cschool在线教程&lt;/a&gt;》&lt;br/&gt;《&lt;a title=&quot;常用Web服务器汇总&quot; href=&quot;http://baijiahao.baidu.com/s?id=1546765508325924&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot;&gt;常用Web服务器汇总&lt;/a&gt;》&lt;br/&gt;《&lt;a title=&quot;面向过程编程介绍&quot; href=&quot;https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/9957246?fr=aladdin&quot; target=&quot;_blank&quot;&gt;面向过程编程介绍&lt;/a&gt;》&lt;br/&gt;《&lt;a title=&quot;面向对象编程介绍&quot; href=&quot;https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089?fr=aladdin&quot; target=&quot;_blank&quot;&gt;面向对象编程介绍&lt;/a&gt;》&lt;br/&gt;《&lt;a title=&quot;编程思想：面向对象和面向过程&quot; href=&quot;https://www.cnblogs.com/BeiGuo-FengGuang/p/5935763.html&quot; target=&quot;_blank&quot;&gt;编程思想：面向对象和面向过程&lt;/a&gt;》&lt;br/&gt;《&lt;a title=&quot;面向服务编程介绍&quot; href=&quot;https://baike.baidu.com/item/SOA/2140650&quot; target=&quot;_blank&quot;&gt;面向服务编程介绍&lt;/a&gt;》&lt;br/&gt;《&lt;a title=&quot;分布式和集群管理介绍&quot; href=&quot;http://baijiahao.baidu.com/s?id=1594350667415915046&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot;&gt;分布式和集群管理介绍&lt;/a&gt;》&lt;br/&gt;《&lt;a title=&quot;微服务架构介绍&quot; href=&quot;https://www.cnblogs.com/imyalost/p/6792724.html&quot; target=&quot;_blank&quot;&gt;微服务架构介绍&lt;/a&gt;》&lt;br/&gt;《数据库可视化工具的安装和使用》&lt;/p&gt;

</description>
<pubDate>Sat, 30 Jun 2018 07:27:00 +0000</pubDate>
<dc:creator>SanMaoSpace</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SanMaoSpace/p/9247285.html</dc:identifier>
</item>
<item>
<title>对话Task - 成天</title>
<link>http://www.cnblogs.com/chengtian/p/9247094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengtian/p/9247094.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一篇简单讲解了&lt;/span&gt; &lt;span&gt;线程和线程池以及上下文切换。创建线程代价高昂，默认每个线程都要占用大量虚拟内存&lt;/span&gt;1M&lt;span&gt;。更有效的做法使用线程池，重复利用线程。在&lt;/span&gt;&lt;span&gt;.NET4.0&lt;/span&gt;&lt;span&gt;中引入了&lt;/span&gt;&lt;span&gt;TPL&lt;/span&gt;&lt;span&gt;任务并行库，你可以在将精力集中于程序要完成的工作，同时最大程度地提高代码的性能。&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;C#5.0&lt;span&gt;中引入了&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt;关键字，基于任务的异步模式&lt;/span&gt;&lt;span&gt;(TAP),所以了解Task对后面学习异步操作会简单些&lt;/span&gt;&lt;span&gt;。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;任务是封装了以异步方式执行的工作。当启动一个任务，控制几乎立即返回调用者，无论任务要执行多少工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;创建&lt;/span&gt;Task&lt;span&gt;任务&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;有三种创建方式&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用&lt;/span&gt;task&lt;span&gt;构造函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;工厂类静态方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;.NET4.5&lt;/span&gt;&lt;span&gt;新引入的&lt;/span&gt;&lt;span&gt;Task.run()&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们创建一个输出&lt;/span&gt;&lt;span&gt;300&lt;/span&gt;&lt;span&gt;万个&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;位字符的&lt;/span&gt;&lt;span&gt;GUID&lt;/span&gt;&lt;span&gt;任务分别使用三种不同方式实现。代码如下&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;RepeatCount =&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重复次数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; listGuid = &lt;span&gt;new&lt;/span&gt; BlockingCollection&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Action无返回值 &lt;/span&gt;
            Action dowork = () =&amp;gt;&lt;span&gt;
           {
               &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;; count &amp;lt; RepeatCount; count++&lt;span&gt;)
               {
                   listGuid.Add(Guid.NewGuid().ToString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
               }
           };
            Task task1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Task(dowork);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1)使用构造函数&lt;/span&gt;
&lt;span&gt;            task1.Start();
            Task task2 &lt;/span&gt;= Task.Factory.StartNew(dowork); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2)Task工厂方法,直接运行，不需要在调用start()&lt;/span&gt;
            Task task3 = Task.Run(dowork); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3)4.5 Task.Run 是Task.Factory.StartNew简化方式；直接运行，不需要在调用start()&lt;/span&gt;
&lt;span&gt;
            Task.WaitAll(task1, task2, task3); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待所有任务完成，相当于 thread.join()&lt;/span&gt;
            Console.Write($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生成数量：{listGuid.Count / 10000}万&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;img src=&quot;https://images2018.cnblogs.com/blog/449569/201806/449569-20180630111350374-872181996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述实例创建一个没有返回值的任务，当然也可以通过Task&amp;lt;TResult&amp;gt; 来创建返回值的异步操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;连续任务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个任务生成&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;位字符的&lt;/span&gt;&lt;span&gt;Guid任务，利用返回的结果再&lt;/span&gt;&lt;span&gt;转化成对应的ASCII&lt;/span&gt;&lt;span&gt;码，最后ASCII码十进制的值相加。代码如下&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Func &lt;/span&gt;
            Func&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; doWork = () =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Guid.NewGuid().ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延续任务&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; task = Task.Run(doWork).ContinueWith(&lt;span&gt;async&lt;/span&gt; strGuid =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; resut = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; strGuid;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; array =&lt;span&gt; Encoding.ASCII.GetBytes(resut);

                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mLenght =&lt;span&gt; array.Length;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sumResult = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; m = &lt;span&gt;0&lt;/span&gt;; m &amp;lt; mLenght; m++&lt;span&gt;)
                {
                    sumResult &lt;/span&gt;+=&lt;span&gt; array[m];
                }
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Guid对应10进制相加结果:{sumResult}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;img src=&quot;https://images2018.cnblogs.com/blog/449569/201806/449569-20180630113806048-293913498.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;处理任务异常&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同步代码要想捕获异常，只需在代码块上添加Try ...Catch即可。但是异步调用不能这么做。因为控制会立即从调用返回，然后控制会离开&lt;/span&gt;Try&lt;span&gt;块，而这时距离工作者线程发生异常可能还有好久呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了处理出错的任务，一个技术是显式创建延续任务作为那个任务的&lt;/span&gt;“错误处理程序”。检测到先驱任务引发未处理的异常，任务调度器会自动调度延续任务。但是，如果没有这种处理程序，同时在出错的任务上执行wait()（或其他试图获取result的动作），就会引发一个AggregateException，示例代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  Task task = Task.Run(() =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvalidOperationException();
            });

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                task.Wait();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;常规erro:{ex.Message};type:{ex.GetType()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                AggregateException excetion &lt;/span&gt;=&lt;span&gt; (AggregateException)ex;
                excetion.Handle(eachException &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;erro:{eachException.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                });
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;img src=&quot;https://images2018.cnblogs.com/blog/449569/201806/449569-20180630135511103-2111508658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然工作者线程上已发的未处理异常是InvalidOperationException类型，但主线程捕捉的仍是一个AggregateException。由于编译时不知道工作者任务将要引发一个还是多个异常，所以未处理的出错任务总是引发一个AggregateException。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  还可查看任务的E&lt;/span&gt;xception&lt;span&gt;属性来了解出错任务的状态，这样不会造成在当前线程上重新引发异常。代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;bool&lt;/span&gt; paraentTaskFaulted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Task task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Task(() =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvalidOperationException();
            });

            Task continuationTask &lt;/span&gt;= task.ContinueWith(t =&amp;gt;&lt;span&gt;
            {

                paraentTaskFaulted &lt;/span&gt;=&lt;span&gt; t.IsFaulted;
            }, TaskContinuationOptions.OnlyOnFaulted);

            task.Start();
            Console.Write(continuationTask.Status);
            continuationTask.Wait();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果断言失败 则显示一个消息框，其中显示调用堆栈。&lt;/span&gt;
&lt;span&gt;            Trace.Assert(paraentTaskFaulted);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;task.IsFaulted)
            {
                task.Wait();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                task.Exception.Handle(eachException &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;erro:{eachException.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                });
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意，为了获取原始任务上的未处理异常，我们使用Exception属性。结果和上面示例输出一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;取消任务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 任务支持取消，比如常用在指定时间内的任务或者基于某些条件手动的取消，支持取消的任务要监听一个CancellationToken对象。任务轮询它，检查是否出发了取消请求。如下代码展示了取消请求和对请求的响应。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 取消任务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TaskTopic5()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; stars = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.PadRight(Console.LargestWindowWidth-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;push enter to exit.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            CancellationTokenSource cancellationTokenSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CancellationTokenSource(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向应该被取消的 System.Threading.CancellationToken 发送信号&lt;/span&gt;
            Task task =&lt;span&gt; Task.Run(
                ()&lt;/span&gt;=&amp;gt;&lt;span&gt;
                Count(cancellationTokenSource.Token,&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;),
                cancellationTokenSource.Token);

            Console.Read();
            cancellationTokenSource.Cancel();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下enter键， 传达取消请求&lt;/span&gt;
&lt;span&gt;            
            Console.WriteLine(stars);
            Console.WriteLine(task.IsCanceled);
            task.Wait();
            Console.WriteLine();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 数数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;token&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;countTo&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Count(CancellationToken token,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; countTo)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;1&lt;/span&gt;; count &amp;lt; countTo; count++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监控是否取消&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (token.IsCancellationRequested)
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数数喊停了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }

                Console.Write(count&lt;/span&gt;+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=》&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Thread.Sleep(TimeSpan.FromSeconds(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数数结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出&lt;img src=&quot;https://images2018.cnblogs.com/blog/449569/201806/449569-20180630151621484-741346012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  调用Cancel()实际会在从cancellationTokenSource.Token复制的所有取消标志上设置IsCancellationRequested属性。&lt;/p&gt;
&lt;p&gt; 到此任务的一些基本的操作已经完成了，下一节关注下C#5.0的async/await上下文关键字。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Jun 2018 07:26:00 +0000</pubDate>
<dc:creator>成天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengtian/p/9247094.html</dc:identifier>
</item>
<item>
<title>deno深入揭秘及未来展望 - royalrover</title>
<link>http://www.cnblogs.com/accordion/p/9247016.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/accordion/p/9247016.html</guid>
<description>&lt;h2 id=&quot;deno&quot;&gt;deno&lt;/h2&gt;
&lt;p&gt;node.js之父Ryan Dahl在一个月前发起了名为deno的项目，项目的初衷是&lt;strong&gt;打造一个基于v8引擎的安全的TypeScript运行时&lt;/strong&gt;，同时实现HTML5的基础API。所谓的安全运行时，是将TS代码运行在一个沙盒里，访问受限的文件系统、网络功能，这比较类似于web里的iframe sandbox。&lt;/p&gt;
&lt;p&gt;现阶段，deno的变化可谓翻天覆地。Ryan的项目一个月前提供了golang版本的deno简易源码，而如今不仅仅重构了项目，底层语言都切换为c++，接口也做了很大的更新，这源自于社区内热情的讨论，有太多太多的开发者、协作人员提出了太多的优化以及改进意见，这也就导致接下来未来几个月deno仍然会出现大改变，这在后文会提及。现在，我就带领大家进入最初的deno微观世界探索deno最初的设计。&lt;/p&gt;
&lt;h2 id=&quot;架构&quot;&gt;架构&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;q 本文讲解deno的golang版本，当前最新的deno处于性能问题放弃了golang的实现，但这不影响我们分析deno的原理。未来在七月deno估计会释放出基于Rust的底层特权级实现，性能更优。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;q 由于deno涉及之处是为了直接运行TS，因此下文会用TS来代指JS（现阶段TS没有自己的运行时，仍是基于编译为JS在运行在v8）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;deno的设计初期来看比较简单，宏观上看包括三部分：deno的go运行时、v8引擎以及连接go运行时和v8的v8worker2库。&lt;br/&gt;&lt;img src=&quot;http://si.geilicdn.com/hz_img_2c09000001644e9c9a1d0a02853e_1248_938_unadjust.png&quot; alt=&quot;deno简易架构&quot;/&gt;&lt;br/&gt;go运行时是deno的特权级，它负责deno对系统资源的申请、使用、释放；v8引擎此处不仅仅执行JS代码，同时也负责TypeScript的编译；而v8worker2负责go与v8的全双工通信，通过ArrayBuffer传输数据，传输的协议规范为protobuf。&lt;/p&gt;
&lt;p&gt;深入到go运行时里，目前deno对TS层提供了几种能力：&lt;strong&gt;Console、fetch、fs、module、timer、stack trace&lt;/strong&gt;，虽然有些功能没有提供用户端API，不过golang的接口已完成，扩展很容易。&lt;br/&gt;&lt;img src=&quot;http://si.geilicdn.com/hz_img_3432000001644eae9fd50a02685e_1216_876_unadjust.png&quot; alt=&quot;deno详细&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;go运行时&quot;&gt;go运行时&lt;/h2&gt;
&lt;p&gt;deno在特权级代码执行了3端逻辑：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化go运行时环境&lt;/li&gt;
&lt;li&gt;初始化TS运行时环境&lt;/li&gt;
&lt;li&gt;启动go这一侧的事件循环（该事件循环不同于node的基于libuv的event loop，下文会提到）&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;初始化go运行时环境&quot;&gt;初始化go运行时环境&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    // HOME目录下创建 cache和src目录
    createDirs()
    // 利用 afero 库创建虚拟fs对象；同时订阅 v8端的 os事件，在go端实现 文件抓取、获取缓存、磁盘I/O，同时返回 proto序列化数据 给v8
    InitOS()
    // 心跳
    InitEcho()
    // 接受v8消息，进行 timeout、interval和clear
    InitTimers()
    // 订阅 fetch 事件，代理服务器。当代理请求结束时，返回两个消息：第一个为状态码；第二个为body体
    InitFetch()

    // recv为 v8-&amp;gt;go 的回调函数，处理v8的消息
    worker = v8worker2.New(recv)

    // 初始化ts的相关环境，和go端对应
    main_js = stringAsset(&quot;main.js&quot;)
    err := worker.Load(&quot;/main.js&quot;, main_js)
    exitOnError(err)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依次执行以下任务：&lt;br/&gt;- 创建缓存目录，存储TS文件编译后的JS文件&lt;br/&gt;- 订阅 os 事件，处理来自v8层的操作，如fs等&lt;br/&gt;- 订阅 timer 事件，处理来自v8的定时器操作&lt;br/&gt;- 订阅 fetch 事件，处理来自v8的http request&lt;br/&gt;- 初始化v8worker2实例，实现go与v8的绑定&lt;br/&gt;- 加载js入口文件main.js，该文件定义了js的全局接口、初始化逻辑和与go运行时通信的方法，等待下一阶段的执行。&lt;/p&gt;
&lt;h3 id=&quot;初始化js运行时环境&quot;&gt;初始化js运行时环境&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// v8端执行 denoMain函数，在main.ts中定义
deno.Eval(&quot;deno_main.js&quot;, &quot;denoMain()&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上一步v8已经加载并执行了&lt;strong&gt;main.js&lt;/strong&gt;文件，现在该执行denoMain方法了。denoMain是在main.js中定义的初始化方法，它定义了deno在js层的API以及v8worker实例，也是开发者密切相关的一层。&lt;/p&gt;
&lt;p&gt;关于ts层的逻辑留在下文讲述。&lt;/p&gt;
&lt;h3 id=&quot;启动事件循环&quot;&gt;启动事件循环&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    var resChan = make(chan *BaseMsg, 10)
    var doneChan = make(chan bool)
    var wg sync.WaitGroup
    wg.Add(1)
    first := true

    // In a goroutine, we wait on for all goroutines to complete (for example
    // timers). We use this to signal to the main thread to exit.
    // wg.Add(1) basically translates to uv_ref, if this was Node.
    // wg.Done() basically translates to uv_unref
    go func() {
        wg.Wait()
        doneChan &amp;lt;- true
    }()

    for {
        select {
        case msg := &amp;lt;-resChan:
            out, err := proto.Marshal(msg)
            check(err)
            err = worker.SendBytes(out)
            stats.v8workerSend++
            stats.v8workerBytesSent += len(out)
            exitOnError(err)
            wg.Done() // Corresponds to the wg.Add(1) in Pub().
        case &amp;lt;-doneChan:
            // All goroutines have completed. Now we can exit main().
            checkChanEmpty()
            return
        }

        // We don't want to exit until we've received at least one message.
        // This is so the program doesn't exit after sending the &quot;start&quot;
        // message.
        if first {
            wg.Done()
        }
        first = false
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;熟悉go语言的人会发现这是协程goroutine的典型用法：&lt;br/&gt;main协程开启循环，监听来自resChan channel的消息，当接受到resChan的消息时意味着此刻go运行时需要向v8返回相关数据，如定时器执行结果、网络请求结果，执行对应的select case，通过v8worker2写入经过protobuf处理后的数据，进入下一次循环；直到go运行时此刻处理完所有的ts请求，会执行协程中的逻辑&lt;code&gt;doneChan &amp;lt;- true&lt;/code&gt;，最终触发main协程的case &lt;code&gt;case &amp;lt;-doneChan&lt;/code&gt;,结束事件循环退出程序。&lt;/p&gt;
&lt;p&gt;因此，deno的golang版本的事件循环与node基于libuv的事件循环并不是一回事，因此不能一概而论。&lt;/p&gt;
&lt;h2 id=&quot;ts运行时与v8worker2&quot;&gt;TS运行时与v8worker2&lt;/h2&gt;
&lt;p&gt;TS运行时对应于v8的实例isolate，在isolate上定义了handscope、context以及在handscope范围内的一系列句柄对象。TS运行时的初始化配置是在v8worker2中定义的，在v8worker2中，借助cgo模块实现go与c的通信：go可以调用c库，同时也可到处go函数给c程序使用。在本文中，这不是要讲述的重点，有兴趣的同学可以等下一篇文章的介绍。&lt;/p&gt;
&lt;p&gt;总之，TS运行时的初始化是由go的v8worker2模块执行，它向v8暴露了global全局变量，同时提供了global变量下提供V8Worker2对象，用于v8与golang的通信。&lt;/p&gt;
&lt;p&gt;TS运行时初始化完毕后，看是准备deno在TS层的执行环境，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化定时器事件，监听go运行时返回的timer事件，该事件对象里有TS调用定时器的返回结果&lt;/li&gt;
&lt;li&gt;初始化 fetch 事件，该事件对象里有TS请求net、fs的返回值&lt;/li&gt;
&lt;li&gt;订阅 start 事件，等待执行deno程序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 start事件处理函数中，deno做了两件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编译TS源文件&lt;/li&gt;
&lt;li&gt;执行JS文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;deno使用typescript模块提供的LanguageServiceHost功能，采用硬编码的编译规则&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ts.CompilerOptions = {
    allowJs: true,
    module: ts.ModuleKind.AMD,
    outDir: &quot;$deno$&quot;,
    inlineSourceMap: true,
    lib: [&quot;es2017&quot;],
    inlineSources: true,
    target: ts.ScriptTarget.ES2017
  };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认使用es2017规范，模块规范使用AMD规范。&lt;/p&gt;
&lt;h3 id=&quot;ts模块的加载&quot;&gt;ts模块的加载&lt;/h3&gt;
&lt;p&gt;目前ts模块加载支持&lt;strong&gt;fs和nfs&lt;/strong&gt;，也就是“相对路径加载和网络加载”，如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { printHello } from &quot;./subdir/print_hello.ts&quot;;
import { printHelloNfs } from &quot;http://localhost:4545/testdata/subdir/print_hello.ts&quot;;

printHello();
printHelloNfs();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TS模块如何转换为AMD规范并且如何确定加载顺序，下面举例说明：&lt;br/&gt;有两个ts文件： a.ts和say.ts&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  a.ts:

  import say from './say';
  say('hello world');
  --------------------
  say.ts:

  export function say(msg){
    console.log(msg)
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行命令&lt;code&gt;deno a.ts&lt;/code&gt;,返回“hello world”。&lt;/p&gt;
&lt;p&gt;经过ts运行时的编译后，a.ts的编译后的代码为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;define([&quot;require&quot;, &quot;exports&quot;, &quot;./say.ts&quot;], function (require, exports, say) {
    &quot;use strict&quot;;
    Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
    say(msg);
  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，回调函数的require参数简单的require实现，exports为a.ts模块的导出对象，say模块则为say.ts的导出对象。&lt;/p&gt;
&lt;p&gt;对于“./say.ts”文件，是由ts运行时通过v8worker2传递消息由go运行时获取对应源文件（此处通过fs或者net），通过ArrayBuffer传递给ts运行时，并进行编译、运行，传递给引用模块a.ts。最后，当所有依赖模块加载完毕之后，a.ts的回调函数执行，实现模块间时序的调度。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;q 关于模块加载问题，社区内有提出异议，即增加绝对路径的引用方式： import &quot;/abc/test.ts&quot;. 不过Ryan认为这种绝对路径方式会与系统的根目录进行冲突，而且不符合deno所提出的“安全的TS运行时”，这样会暴露系统的路径或文件信息。不过社区也提出了解决方案，即在deno运行时提供命令行参数 --baseDir，标识当前deno进程的根目录，防止访问系统的文件系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;颇具争议的v8worker2与protobuf&quot;&gt;颇具争议的v8worker2与protobuf&lt;/h2&gt;
&lt;p&gt;其实deno的golang实现被诟病最多的也正是v8worker2与protobuf。这两个模块非常有名，但是不太适用于deno的场景。&lt;/p&gt;
&lt;p&gt;首先说道protobuf，这是google提出的一种跨平台跨语言的结构化数据存储格式，它是有类型声明的，通过protobuf的命令行工具可以生成不同语言的代码，操作对应的数据结构。但是protobuf的性能瓶颈在于序列化与反序列化，这也正是protobuf作者在deno项目下之一Ryan的原因，他推荐使用 Cap'n Proto来进行数据传递。 Cap'n Proto比较有意思，它使用ArrayBuffer进行传递，并且不需要序列化为对应语言的相关变量，直接提供一套方法读取二进制数据（类似于访问数组使用的偏移量），更快。&lt;/p&gt;
&lt;p&gt;对于v8worker2模块，笔者通读了这个binding实现，其实Ryan对于v8worker2已经尽可能优化了，不过并没有开启v8的snapshot特性，对于重复引入的模块会有些性能损失。但是最重要的瓶颈其实在于v8worker2依赖的cgo模块。cgo对于c库以及编译器的支持非常的不错，但是在数据类型的转换耗费性能比较多。&lt;/p&gt;
&lt;p&gt;下图为社区针对golang版本的deno做出的go运行时的性能分析：&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/20110/41383530-3ead3348-6f3f-11e8-9aa8-8a9bc9e1f5a1.png&quot; alt=&quot;性能分析&quot;/&gt;&lt;br/&gt;可以看出v8worker2的SendBytes和Load执行占比已超过70%。而这两个函数主要逻辑是使用cgo完成数据传递以及TS执行。&lt;br/&gt;社区也有相关&lt;a href=&quot;https://stackoverflow.com/questions/28272285/why-cgos-performance-is-so-slow-is-there-something-wrong-with-my-testing-code&quot;&gt;cgo性能瓶颈&lt;/a&gt;的介绍，即go中的协程goroutien不同于OS的线程，在具体实现上取决于GOMAXPROCS设置以及调度策略。一旦通过cgo在c语言进行系统调用，那么会导致当前go routine所在的线程睡眠，直到调用返回。那么其他跑在当前线程的go routine都会被阻塞导致性能下降。因此，Ryan下个版本也会放弃使用go的v8worker2模块。&lt;/p&gt;
&lt;h2 id=&quot;deno的golang版本生命终结&quot;&gt;deno的golang版本生命终结&lt;/h2&gt;
&lt;p&gt;终于到了这个话题，golang实现的deno现在已经被放弃了，这是由于性能问题导致的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;与c/c++绑定性能差，这是由cgo模块导致的，也直接导致deno的golang实现tps小，rt比较大&lt;/li&gt;
&lt;li&gt;golang的GC机制导致的性能的不确定性。目前v8采用的是标记清楚+整理的GC算法，而golang运行时也运行类似的GC算法，这样在多线程中存在两个并行的GC线程会对程序运行造成非常大的不确定性&lt;/li&gt;
&lt;li&gt;社区内Rust力量壮大，Rust的服务器性能越发强大，而且没有GC机制，与c通信性能高过golang，因此也算是个推进因素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不过，虽然golang版本的deno走到了终点，我们通过Ryan的实现仍然很容易把握住deno的脉络，因此对于相关的开发者仍有借鉴和参考意义。&lt;/p&gt;
&lt;h2 id=&quot;deno的未来及感慨&quot;&gt;deno的未来及感慨&lt;/h2&gt;
&lt;p&gt;就目前社区内部的讨论以及Ryan的决定来看，deno在七月份仍有重大改变：底层的代码会切换为Rust，会使用libdeno作为Rust和C的binding。deno社区目前还非常活跃，各种想法和思潮互相碰撞，比如关于模块管理与加载、API的设计、v8编译TS的优化等，在这个时代我们必须要跟上浪潮，学习这些弄潮人的思想及设计理念。&lt;/p&gt;
&lt;p&gt;笔者之前非常专注于node的摄入挖掘与应用，不过自从deno出来之后带给笔者的震撼远飞语言之能形容。因此学习golang、阅读v8文档通读deno，尽量走出自己的舒适区感受墙外的先进思想，碰撞中学习，求同中存异，收货颇丰。最后感慨下，是不是国内相对封闭的互联网环境导致国内前端或全栈领域的思维有些僵化，无法产生并主导这种非常有意思的idea和项目，当然也有可能是我们每天忙于业务需求中无法自拔。愿国内开发者且行且珍惜，不能被国外的同行甩开太多。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Jun 2018 06:06:00 +0000</pubDate>
<dc:creator>royalrover</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/accordion/p/9247016.html</dc:identifier>
</item>
<item>
<title>supervisor管理进程 superlance对进程状态报警 - 冰蓝的天空</title>
<link>http://www.cnblogs.com/binglansky/p/9246780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binglansky/p/9246780.html</guid>
<description>
&lt;h2 id=&quot;supervisor介绍&quot;&gt;supervisor介绍&lt;/h2&gt;
&lt;p&gt;首先，介绍一下supervisor。Supervisor（&lt;a href=&quot;http://supervisord.org/&quot;&gt;http://supervisord.org/&lt;/a&gt;）是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统。它可以很方便的监听、启动、停止、重启一个或多个进程。用Supervisor管理的进程，当一个进程意外被杀死，supervisort监听到进程死后，会自动将它重新拉起，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制&lt;/p&gt;

&lt;p&gt;之所以写这篇文章，是前两天的一个需求。。。哎 没办法 运维狗....&lt;/p&gt;
&lt;p&gt;环境：centos7.4&lt;/p&gt;

&lt;h2 id=&quot;安装supervisor&quot;&gt;安装supervisor&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
pip install supervisor
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为是python开发的一个库，可以直接用pip来安装，很方便。&lt;br/&gt;supervisor安装完成后会生成三个执行程序：supervisortd、supervisorctl、echo_supervisord_conf，分别是supervisor的守护进程服务（用于接收进程管理命令）、客户端（用于和守护进程通信，发送管理进程的指令）、生成初始配置文件程序。&lt;/p&gt;

&lt;h2 id=&quot;配置supervisor&quot;&gt;配置supervisor&lt;/h2&gt;
&lt;p&gt;创建目录，初始化配置文件&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:false;&quot;&gt;
mkdir /etc/supervisor
echo_supervisord_conf &amp;gt; /etc/supervisor/supervisord.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;主配置文件参数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
[unix_http_server]
file=/tmp/supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用
;chmod=0700                 ; socket 文件的 mode，默认是 0700
;chown=nobody:nogroup       ; socket 文件的 owner，格式： uid:gid
 
;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面
;port=127.0.0.1:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性
;username=user              ; 登录管理后台的用户名
;password=123               ; 登录管理后台的密码
 
[supervisord]
logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log
logfile_maxbytes=50MB        ; 日志文件大小，超出会 rotate，默认 50MB
logfile_backups=10           ; 日志文件保留备份数量默认 10
loglevel=info                ; 日志级别，默认 info，其它: debug,warn,trace
pidfile=/tmp/supervisord.pid ; pid 文件
nodaemon=false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动
minfds=1024                  ; 可以打开的文件描述符的最小值，默认 1024
minprocs=200                 ; 可以打开的进程数的最小值，默认 200
 
; the below section must remain in the config file for RPC
; (supervisorctl/web interface) to work, additional interfaces may be
; added by defining them in separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface
 
[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致
;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord
 
; 包含其他的配置文件
[include]
files = relative/directory/*.ini    ; 可以是 *.conf 或 *.ini
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;管理一个进程&quot;&gt;管理一个进程&lt;/h2&gt;
&lt;p&gt;把所有被管理的进程配置文件都放在同一个目录，主配置文件包含进去。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:false;&quot;&gt;
mkdir /etc/supervisor/config.d
vim /etc/supervisor/supervisord.conf
    [include]
    files = /etc/supervisor/config.d/*.conf
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面创建一个nginx的配置文件&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[program:nginx]
command &lt;/span&gt;= /usr/local/nginx/sbin/nginx -g &lt;span&gt;'&lt;/span&gt;&lt;span&gt;daemon off;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
startsecs &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
autostart &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
autorestart &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt; 
user &lt;/span&gt;=&lt;span&gt; root
stdout_logfile &lt;/span&gt;= /etc/supervisor/logs/supervisord-&lt;span&gt;nginx.log
stderr_logfile &lt;/span&gt;= /etc/supervisor/logs/supervisord-nginx-error.log
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;来启动supervisor&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
supervisord -c /etc/supervisor/supervisord.conf 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;刚开始有个坑，command = /usr/local/nginx/sbin/nginx 我是这样写的 结果就一直启动nginx 因为这样的话 是后台运行的nginx，然而supervisor 不能管理后台运行进程，所以把nginx daemon off 守护关掉，就让他阻塞在前台bash运行，方便supervisor来管理。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@test /&lt;span&gt;]# supervisorctl status
nginx                            RUNNING   pid &lt;/span&gt;&lt;span&gt;17541&lt;/span&gt;, uptime &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;&lt;span&gt;
 
[root@test &lt;/span&gt;/]# netstat -&lt;span&gt;ntlp
Active Internet connections (only servers)
Proto Recv&lt;/span&gt;-Q Send-Q Local Address           Foreign Address         State       PID/&lt;span&gt;Program name    
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;17541&lt;/span&gt;/nginx: master 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此时nginx PID是一致的。&lt;/p&gt;
&lt;h2 id=&quot;常用supervisorctl命令&quot;&gt;常用supervisorctl命令&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;supervisorctl status    查看当期进程状态
supervisorctl stop &lt;/span&gt;&amp;lt;name&amp;gt;&lt;span&gt;  停止一个进程
supervisorctl start &lt;/span&gt;&amp;lt;name&amp;gt;&lt;span&gt;  启动
supervisorctl restart &lt;/span&gt;&amp;lt;name&amp;gt;&lt;span&gt; 重启
supervisorctl reload     重启supervisord主进程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;web界面管理&quot;&gt;web界面管理&lt;/h2&gt;
&lt;p&gt;开启web访问&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
vim /etc/supervisor/&lt;span&gt;supervisord.conf
  [inet_http_server]        
  port&lt;/span&gt;=&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;9001&lt;/span&gt;&lt;span&gt;       
  username&lt;/span&gt;=&lt;span&gt;user            
  password&lt;/span&gt;=&lt;span&gt;123&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1334074/201806/1334074-20180630131258681-1838599973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;hr/&gt;
&lt;p&gt;好了，上面说完了supervisor管理进程，下面开始说报警的事，有些时候，进程莫名其妙的退出了，然后又立刻被supervisor给拉起来了，导致了一些问题出现，想立刻知道这个进程已经被重启过了怎么办？这时候 就可以用superlance来了&lt;/p&gt;

&lt;h2 id=&quot;superlance介绍&quot;&gt;superlance介绍&lt;/h2&gt;
&lt;p&gt;superlance就是基于supervisor的事件机制实现的一系列命令行的工具集，它实现了许多supervisor本身没有实现的实用的进程监控和管理的特性，包括内存监控，http接口监控，邮件和短信通知机制等。同样的，superlance本身也是使用python编写的&lt;/p&gt;

&lt;h2 id=&quot;superlance命令&quot;&gt;superlance命令&lt;/h2&gt;
&lt;p&gt;superlance是一系列命令行工具的集合，其包括以下这些命令：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;httpok&lt;br/&gt;通过定时对一个HTTP接口进行GET请求，根据请求是否成功来判定一个进程是否处于正常状态，如果不正常则对进程进行重启。&lt;/li&gt;
&lt;li&gt;crashmail&lt;br/&gt;当一个进程意外退出时，发送邮件告警。&lt;/li&gt;
&lt;li&gt;memmon&lt;br/&gt;当一个进程的内存占用超过了设定阈值时，发送邮件告警。&lt;/li&gt;
&lt;li&gt;crashmailbatch&lt;br/&gt;类似于crashmail的告警，但是一段时间内的邮件将会被合成起来发送，以避免邮件轰炸。&lt;/li&gt;
&lt;li&gt;fatalmailbatch&lt;br/&gt;当一个进程没有成功启动多次后会进入FATAL状态，此时发送邮件告警。与crashmailbatch一样会进行合成报警。&lt;/li&gt;
&lt;li&gt;crashsms&lt;br/&gt;当一个进程意外退出时发送短信告警，这个短信也是通过email网关来发送的&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;.当supervisord启动的时候，如果我们的listener配置为autostart=&lt;span&gt;true的话，listener就会作为supervisor的子进程被启动。

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;.listener被启动之后，会向自己的stdout写一个&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;READY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的消息,此时父进程也就是supervisord读取到这条消息后，会认为listener处于就绪状态。

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.listener处于就绪状态后，当supervisord产生的event在listener的配置的可接受的events中时，supervisord就会把该event发送给该listener。

&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.listener接收到event后，我们就可以根据event的head，body里面的数据，做一系列的处理了。我们根据event的内容，判断，提取，报警等等操作。

&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;.该干的活都干完之后，listener需要向自己的stdout写一个消息&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RESULTnOK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;，supervisord接受到这条消息后。就知道listener处理event完毕了。
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;Supervisord支持的Event&quot;&gt;Supervisord支持的Event&lt;/h2&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
PROCESS_STATE    进程状态发生改变
PROCESS_STATE_STARTING  进程状态从其他状态转换为正在启动(Supervisord的配置项中有startsecs配置项， 是指程序启动时需要程序至少稳定运行x秒才认为程序运行正常，在这x秒中程序状态为正在启动)
PROCESS_STATE_RUNNING   进程状态由正在启动转换为正在运行
PROCESS_STATE_BACKOFF   进程状态由正在启动转换为失败
PROCESS_STATE_STOPPING   进程状态由正在运行转换为正在停止
PROCESS_STATE_EXITED   进程状态由正在运行转换为退出
PROCESS_STATE_STOPPED   进程状态由正在停止转换为已经停止(exited和stopped的区别是exited是程序自行退出，而stopped为人为控制其退出)
PROCESS_STATE_FATAL   进程状态由正在运行转换为失败
PROCESS_STATE_UNKNOWN   未知的进程状态
REMOTE_COMMUNICATION   使用Supervisord的RPC接口与Supervisord进行通信
PROCESS_LOG   进程产生日志输出，包括标准输出和标准错误输出
PROCESS_LOG_STDOUT   进程产生标准输出
PROCESS_LOG_STDERR   进程产生标准错误输出
PROCESS_COMMUNICATION   进程的日志输出包含 和
PROCESS_COMMUNICATION_STDOUT   进程的标准输出包含 和
PROCESS_COMMUNICATION_STDERR   进程的标准错误输出包含 和
SUPERVISOR_STATE_CHANGE_RUNNING Supervisord  启动
SUPERVISOR_STATE_CHANGE_STOPPING Supervisord  停止
TICK_5   每隔5秒触发
TICK_60   每隔60秒触发
TICK_3600   每隔3600触发
PROCESS_GROUP   Supervisord的进程组发生变化
PROCESS_GROUP_ADDED   新增了Supervisord的进程组
PROCESS_GROUP_REMOVED   删除了Supervisord的进程组
 
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;安装superlance&quot;&gt;安装superlance&lt;/h2&gt;
&lt;p&gt;也是python程序，直接pip 安装&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install superlance
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;既然有了上面的event特性，下面就配置一个发邮件报警，当nginx莫名其妙的重启后 就立刻发邮件通知。&lt;/p&gt;
&lt;p&gt;这里在说一下，centos下如何用命令行直接发邮件的，我一直都没有用过默认 自带的，也不好用。推荐一个比较好用的。&lt;/p&gt;
&lt;p&gt;sendEmail,用perl语言写好的 也都封装好了，只需要提供发件人 邮箱账号 密码 smtp服务 收件人 就可以了。&lt;/p&gt;
&lt;p&gt;先配置一下&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
wget http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;caspian.dotconf.net/menu/Software/SendEmail/sendEmail-v1.56.tar.gz&lt;/span&gt;
tar zxvf sendEmail-v1.&lt;span&gt;56&lt;/span&gt;&lt;span&gt;.tar.gz
cp sendEmail&lt;/span&gt;-v1.&lt;span&gt;56&lt;/span&gt;/sendEmail /usr/bin/&lt;span&gt;sendemail
 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ok，发邮件测试一下，这里我把邮箱信息隐藏一下了.....&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
sendemail -f 发件人邮箱 -t 收件人邮箱 -s 发件人邮箱smtp服务器 -u &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sendEmail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -m &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;haha&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -xu 发件人邮箱 -&lt;span&gt;xp 发件人邮箱密码 
 
&lt;/span&gt;-&lt;span&gt;f 发件人
&lt;/span&gt;-&lt;span&gt;t 收件人
&lt;/span&gt;-&lt;span&gt;s 发件人smtp服务器
&lt;/span&gt;-&lt;span&gt;u 主题
&lt;/span&gt;-&lt;span&gt;m 内容
&lt;/span&gt;-&lt;span&gt;xu 发件人用户名
&lt;/span&gt;-&lt;span&gt;xp 发件人密码
 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我这里用的163发的 qq邮箱收件的，测试没啥问题的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1334074/201806/1334074-20180630131605198-875441913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;ok 现在要做的就是配置一个supervisor配置文件，来一直监听进程的状态变化&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
[root@test /]# cat /etc/supervisor/config.d/mail.conf 
[eventlistener:crashmail-exited]
command=crashmail -a -s &quot;/usr/bin/sendemail -f xxxxxx@163.com -t xxxxxx@qq.com -s smtp.163.com -u 'nginx' -xu xxxxxxx@163.com -xp xxxxxxxx -m&quot; -m xxxxxxxx@qq.com
events=PROCESS_STATE_EXITED
redirect_stderr=false
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;添加好一个进程配置文件后，supervisorctl reload 重启一下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1334074/201806/1334074-20180630131635752-825548858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;已经是两个进程在running了&lt;/p&gt;
&lt;p&gt;下面测试一下 kill 掉nginx进程&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 ps aux |&lt;span&gt; grep nginx
 kill &lt;/span&gt;-&lt;span&gt;9&lt;/span&gt; &lt;span&gt;17659&lt;/span&gt; &lt;span&gt;17660&lt;/span&gt; 
 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1334074/201806/1334074-20180630131655693-2032899871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;然后看一下supervisor&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1334074/201806/1334074-20180630131708946-1344241569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;此时 nginx pid已经变化，说明kill之后 又被拉起来了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1334074/201806/1334074-20180630131719074-158315056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;也很快 就收到邮件报警了。嘿嘿。。&lt;/p&gt;
&lt;p&gt;写这篇文章，在加上实战操作也都一小时了。。。中午都忘了吃饭了.....&lt;/p&gt;
&lt;p&gt;好了，就到这里了， 全过程我是实战的一遍的，此方法绝对可行，只要按照我做的去配置，那就没问题。。&lt;/p&gt;

&lt;p&gt;前几天搞了个vps  又弄了个博客。。。嘿嘿  以后就博客园 自己博客都同步起来。各位大佬不要喷我，来点访问量  : ) 地址：http://www.binglansky.com&lt;/p&gt;

</description>
<pubDate>Sat, 30 Jun 2018 05:23:00 +0000</pubDate>
<dc:creator>冰蓝的天空</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/binglansky/p/9246780.html</dc:identifier>
</item>
<item>
<title>Apache SkyWalking的架构设计【译文】 - SuperSnowYao</title>
<link>http://www.cnblogs.com/supersnowyao/p/9246742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/supersnowyao/p/9246742.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　Apache SkyWalking提供了一个功能强大并且很轻量级的后端。在此，将介绍为什么采用以下方式来设计它，以及它又是如何工作的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/116014/201806/116014-20180630124233287-1102022447.png&quot; alt=&quot;&quot; width=&quot;1062&quot; height=&quot;561&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　架构图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于APM而言，agent或SDKs仅是如何使用libs的技术细节。手动或自动的形式与架构无关，因此在本文中，我们不讲这些内容，可将这些看成为Client lib。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　基本原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;关于SkyWalking架构设计的基本原则就是：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）易于维护；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）可控；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）基于流；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;为了达到此目的，SkyWalking后端提供了如下设计：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）模块化设计；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）为客户端提供多种连接方式；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）集群发现机制；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4）流模式；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5）可切换的存储实现；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一、&lt;strong&gt;模块化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SkyWalking收集器（collector）是基于模块化设计，用户可以根据自己的需要，更改或集成收集器的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　二、&lt;strong&gt;模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　模块定义了一组特性，其中可包括一些技术上的实现（如：grpc/jetty服务器管理）、跟踪分析（如：trace segment或者zipkin span解析器）或聚合特征。总而言之，这些都是由模块来定义和实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　每个模块都可以通过Java接口定义自身的服务，而实现类均要实现这些服务。并且这些实现类要根据实现的功能定义所依赖的类有哪些。这意味着，即使是模块的两个不同的实现，也可以依赖于不同的模块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另外，收集器中的模块化核心会检查启动序列，如果没有发现循环依赖或者依赖项，该核心功能会终止收集器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　收集器会启动所有模块，这些模块在application.yml文件中定义。此文件结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）根节点是模块名称，如：cluster，naming；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）次级节点是此模块的功能实现名称，如：zookeeper是cluster模块；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）第三级节点是功能实现的属性，如：hostPort和sessionTimeout是zookeeper需要的属性；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　三、&lt;strong&gt;多连接方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，收集器提供两种类型的连接，也就是两种协议的支持：HTTP和gRPC。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）在HTTP中命名服务，在后端集群中，返回所有可用的收集器；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）Uplink服务支持gRPC（主要用于SkyWalking的本地代理）和HTTP，它跟踪和度量收集器。每个客户端只向单个收集器发送监测数据（跟踪和度量）。若连接的收集器断线，，则尝试连接其他的收集器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　客户端lib和收集器集群之间的处理流示例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/116014/201806/116014-20180630115620692-981999917.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　四、收集器集群发现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-0&quot;&gt;　　当收集器以集群模式运行时，收集器必须以某种方式发现彼此。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-1&quot;&gt;在默认情况下，SkyWalking使用zookeeper进行协调，并以此作为发现的注册中心。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如此说来，客户端的lib将不会使用&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-1&quot;&gt;zookeeper&lt;/span&gt;&lt;/span&gt;来查找集群。建议用户不要这样做。因为集群&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-2&quot;&gt;发现机制是可切换的，由模块化核心提供。基&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-3&quot;&gt;于这一点，就打破了可切换的能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们希望社区能够提供更多的关于集群发现的功能实现。如现在有的Eureka，Consul，Kubernate。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;五、流模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　流模式倾向于轻量级的storm/spark实现，并允许使用api来构建流过程图（DAG），以及每个节点的输入/输出的数据约定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　新模块可以找到并扩展已有的过程图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在处理过程中有三种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）同步过程。传统的方法调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）异步过程，基于队列缓冲区的a.k.a批处理过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）远程过程，聚合矩阵收集器，通过这种方式，选择器在节点中定义，以决定如何在集群中找到收集器。（HashCode，Rolling，ForeverFirst是三种支持的方式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过这些特性，收集器就像一个流动的网一样运行。通过聚合指标和不依赖于存储实现功能来支持同时编写同样的id。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;六、可切换的存储实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因为流模式负责并发，所以存储实现的职责是提供高速写和组查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在，支持ElasticSearch，也支持H2预览版，同时支持ShardingSphere项目用于MySql关系数据库集群的管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;七、Web UI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　除了收集器设计的原则之外，UI也是SkyWalking中的另一个核心部分。它基于React、Antd和Zuul代理来提供收集器集群发现、查询分派和可视化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Web UI使用localhost:10800来为收集器集群做命名查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考链接：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38442093?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=54098577588224&amp;amp;from=timeline&amp;amp;isappinstalled=0&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/38442093?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=54098577588224&amp;amp;from=timeline&amp;amp;isappinstalled=0&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Jun 2018 04:54:00 +0000</pubDate>
<dc:creator>SuperSnowYao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/supersnowyao/p/9246742.html</dc:identifier>
</item>
<item>
<title>一文了解JAVA虚拟机的重要组成 - 姜小泮</title>
<link>http://www.cnblogs.com/jpcflyer/p/9226988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpcflyer/p/9226988.html</guid>
<description>&lt;p&gt;&lt;span&gt;        JVM是JAVA平台的重要组成之一，因涉及知识点太多，故从以下几个方面对JVM进行浅层面的介绍，如果需要深入理解，推荐学习机械工业出版社的《深入理解JAVA虚拟机》。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、JAVA内存结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       Java虚拟机规范中规定的JVM运行时数据区如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/364723/201806/364723-20180626230136209-1947488699.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       总体来说，分为线程共享部分（方法区、堆）和线程隔离区（虚拟机栈、本地方法栈和程序计数器）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1.方法区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。其中常量存储于运行时常量区中，运行时常量区是区的一部分，用于存储编译期生成的字面量和符号引用。但运行时常量区的内容并不只是在编译期间产生，通过String.intern()也可以实现在运行时向常量区中添加内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2.堆&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       是JVM中最大的一块内存区域，该区域的目的只是用于存储对象实例及数组。该区域也是GC的最主要区域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3.虚拟机栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       每个线程方法在执行时都会创建一个栈帧，包含局部变量表、返回地址、操作数栈等信息。每个方法的执行与完成就对应的栈帧的入栈与出栈过程 。局部变量表占用空间的大小在编译期就确定了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       4.本地方法栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       与虚拟机栈类似，不过其中执行是本地方法。对于HotSpot虚拟机而言，本地方法栈和虚拟机栈是统一的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       5.程序计数器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       是一个小的内存空间，如果线程正在执行的是一个java方法，则此内存区域记录正在执行的虚拟机字节码指令；如果线程正在执行的是native方法，则计算器中的值为空。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、JAVA垃圾回收机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       JAVA的垃圾回收主要涉及到确定对象是否存活、垃圾收集等算法，其中确定对象回收算法采用的是可达性分析算法，垃圾收集目前各JVM厂商广泛采用的是分代收集算法。这里面主要描述下分代收集算法的过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/364723/201806/364723-20180630105306799-1577940106.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       分代收集算法的核心思想是将内存区域按照对象的生存周期阶段进行划分，其中将堆区划分为新生代（young generation）和老年代(old generation)。将非堆区（一般指方法区）划分为持久代（permanent generation）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1.新生代&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       新生代又可再分为Eden区和两个Survivor区（两个Survivor区的大小是一样的，便于交换）。新生成的对象都会先在新生代的Eden区进行保存。新生代的特点是每次垃圾回收都会有大量的内存被回收，而且收集比较频繁，所以新生代适合如下的收集算法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       首先，新生成的对象分配到Eden区，如果eden区满了，则将可达性的对象复制到survivor1区，后清空eden区。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       然后，如果survivor1区满了，则将eden区与survivor1区的可达性对象复制到survivor2区，后清空eden区和survivor1区，清空完后将survivor2区与survivor1区交换，即保持survivor2是空的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       再次，如果survivor2区也满了，则将eden区、survivor1区、survivor2区的可达性对象复制到老年代中，并清空新生代中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       最后，如果老年代也满了，就触发full gc了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2.老年代&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       老年代的内存比新生代大的多，这个区域执行垃圾回收的频度不高。当老年代满时，会触发full gc。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3.持久代&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       持久代一般指方法区，该区需要回收的有废弃的常量和类。对于常量可用可达性分析的方法进行判断回收，对于类则需要同时满足以下条件才会被回收：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       首先，该类的所有实例对象都已被回收；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       其次，该类的类加载器也已被回收；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       再次，该类的Class方法没有在任何地方被引用，即无法通过在任何地方通过反射访问到该类的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        4.什么时候会解决垃圾回收？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       综上所述，当eden满时，就会触发scavenge gc，当出现以下情况时会触发full gc：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       老年代已满；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       持久代已满；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       调用System.gc()方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、JAVA类加载过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        JVM类加载过程具体装载、验证、准备、解析、初始化这五个部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1.装载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       在装载过程中，需要完成以下事情：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1）通过类的全限定名获取类的二进制字节流；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2）将类的二进制字节流转换为方法区的运行时数据结构；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3）生成一个代表此类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2.验证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       验证、解析和初始化又称为是连接阶段，在验证验证主要是确保二进制字节流符合JVM的规范，不会危害计算机的安全。具体验证阶段需要做的事情如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1）文件格式验证，验证字节流是否符合Class文件格式规范；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2）元数据验证，对字节码进行语义验证，以保证其描述信息符合JAVA语言规范；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3）字节码验证，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       4）符号引用验证，对常量池中的各种符号引用的信息进行匹配性验证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3.准备&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       准备的过程其实是分配内存的过程。在这个阶段有两个容易产生混淆的概念：一是此阶段分配内存的只是类变量（static变量），不包含实例变量，实例变量的内存分配是在对象实例化时随对象一起分配在堆中；二是该阶段分配内存中保存的值只是数据类型的零值，具体值需要在初始化阶段进行赋值。也有特殊情况，就是对于静态常量（final修饰）会在准备阶段将值赋值为真实值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       4.解析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       解析阶段就是将常量池内折符号引用转换为直接引用的过程，具体包括类和接口的解析、字段的解析、方法的解析、接口方法和解析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       5.初始化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       初始化阶段其实就是执行类构造函数（clinit）的阶段。对于clinit()需要说明以下几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1）clinit()中的程序是自动收集类中static变量及static块产生的，执行顺序与代码中的顺序一致。静态语句块中只能访问在其之前声明的static变量，在其之后声明的static变量只能赋值，不能访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2）执行clinit()方法前，JVM会自动调用父类的clinit()方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3）虚拟机会保证一个类的clinit()在多线程环境中，自动加锁、同步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、JVM的类加载器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       JVM的类加载是通过类加载器实现的，常用的类加载器包括下面三种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1.启动类加载器（bootstrap classloader）：加载{JDK_HOME}/lib下的类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2.扩展类加载器（extension classloader）：加载{JDK_HOME}/lib/ext下的类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3.应用程序类加载器（application classloader）：加载classpath指定的类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       对于不同类加载器以及他们之间的协作可以参考下面的双亲委派模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/364723/201806/364723-20180630115848239-1404945529.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       双亲委派模型的工作过程是：如果一个类加载器收到了类的加载请求，会首先把请求委派给自己的父类，每个层次的类加载器都会如此，因为所有的加载请求最终都会发送到bootstarp加载器中，只有当父加载器确实无法自己完成加载请求时，子加载器才会尝试自己加载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       双亲委派模型使得JAVA类能够按层次进行加载，不会造成混乱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、JVM的相关工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       JDK中有很多强大的监控工具，可以直接在命令行运行。这对于在生产环境进行监控是非常有用的。例如SUN JDK中就包含了以下监控和故障处理工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       jps: jvm process status tool,显示指定系统内所有的hotspot虚拟机进程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       jstat: jvm statistics monitoring tool,用于收集hotspot虚拟机各方面的运行数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       jinfo: configuration info for java，显示虚拟机配置信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       jmap: memory map for java,生成虚拟机的内存转储快照（heapdump文件）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       jhat: jvm heap dump browser，用于分析heapmap文件，它会建立一个http/html服务器,让用户可以在浏览器上查看分析结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       jstack: stack trace for java ,显示虚拟机的线程快照&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       先介绍这么多，后面有机会再介绍JVM在并发方面的相关支持。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Jun 2018 04:33:00 +0000</pubDate>
<dc:creator>姜小泮</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jpcflyer/p/9226988.html</dc:identifier>
</item>
<item>
<title>Redis笔记-在 Centos7.4单机中部署Redis集群（二） - Acdante</title>
<link>http://www.cnblogs.com/acdante/p/9244614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/acdante/p/9244614.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@centos7 src]# cat redis-&lt;span&gt;trib.rb 
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; #!/usr/bin/&lt;span&gt;env ruby
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; # TODO (temporary here, we&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ll move this into the Github issues once&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; #       redis-trib initial implementation &lt;span&gt;is&lt;/span&gt;&lt;span&gt; completed).
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; # - Make sure that &lt;span&gt;if&lt;/span&gt; the rehashing fails &lt;span&gt;in&lt;/span&gt; the middle redis-trib will &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;#   to recover.
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; # - When redis-trib performs a cluster check, &lt;span&gt;if&lt;/span&gt; it detects a slot move &lt;span&gt;in&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; #   progress it should prompt the user to &lt;span&gt;continue&lt;/span&gt; the move &lt;span&gt;from&lt;/span&gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt; it
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;#   stopped.
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; # - Gracefully handle Ctrl+C &lt;span&gt;in&lt;/span&gt; move_slot to prompt the user &lt;span&gt;if&lt;/span&gt;&lt;span&gt; really stop
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; #   &lt;span&gt;while&lt;/span&gt; rehashing, and performing the best cleanup possible &lt;span&gt;if&lt;/span&gt;&lt;span&gt; the user
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;#   forces the quit.
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; # - When doing &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; a &lt;span&gt;global&lt;/span&gt; Fix to &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, and prompt the user to
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; #   fix the problem &lt;span&gt;if&lt;/span&gt; automatically fixable every time there &lt;span&gt;is&lt;/span&gt;&lt;span&gt; something
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;#   to fix. For instance:
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; #   &lt;span&gt;1&lt;/span&gt;) If there &lt;span&gt;is&lt;/span&gt;&lt;span&gt; a node that pretend to receive a slot, or to migrate a
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; #      slot, but has no entries &lt;span&gt;in&lt;/span&gt;&lt;span&gt; that slot, fix it.
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; #   &lt;span&gt;2&lt;/span&gt;) If there &lt;span&gt;is&lt;/span&gt; a node having keys &lt;span&gt;in&lt;/span&gt;&lt;span&gt; slots that are not owned by it
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; #      fix &lt;span&gt;this&lt;/span&gt; condition moving the entries &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the same node.
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; #   &lt;span&gt;3&lt;/span&gt;&lt;span&gt;) Perform more possibly slow tests about the state of the cluster.
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; #   &lt;span&gt;4&lt;/span&gt;) When aborted slot migration &lt;span&gt;is&lt;/span&gt;&lt;span&gt; detected, fix it.
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; require &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rubygems&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; require &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; ClusterHashSlots = &lt;span&gt;16384&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt; MigrateDefaultTimeout = &lt;span&gt;60000&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; MigrateDefaultPipeline = &lt;span&gt;10&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; RebalanceDefaultThreshold = &lt;span&gt;2&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; $verbose = &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;def xputs(s)
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; s[&lt;span&gt;0&lt;/span&gt;..&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     when &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;         color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;29;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     when &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[ER&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;         color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;31;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;     when &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[WA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;31;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;     when &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;         color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;     when &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[FA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;***&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;         color=&lt;span&gt;nil
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt;     color = nil &lt;span&gt;if&lt;/span&gt; ENV[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TERM&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xterm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;     print &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[#{color}m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; color
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    print s
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     print &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[0m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; color
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     print &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;end
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClusterNode
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;    def initialize(addr)
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         s = addr.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;].split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; s.length &amp;lt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;            puts &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid IP or Port (given as #{addr}) - use IP:Port format&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;            exit &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         port = s.pop # removes port &lt;span&gt;from&lt;/span&gt;&lt;span&gt; split array
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         ip = s.join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) # &lt;span&gt;if&lt;/span&gt; s.length &amp;gt; &lt;span&gt;1&lt;/span&gt; here, it&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s IPv6, so restore address&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;         @r =&lt;span&gt; nil
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         @info =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         @info[:host] =&lt;span&gt; ip
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         @info[:port] =&lt;span&gt; port
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         @info[:slots] =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         @info[:migrating] =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         @info[:importing] =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         @info[:replicate] = &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;         @dirty = &lt;span&gt;false&lt;/span&gt; # True &lt;span&gt;if&lt;/span&gt;&lt;span&gt; we need to flush slots info into node.
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         @friends =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;    def friends
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        @friends
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    def slots
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        @info[:slots]
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt;     def has_flag?&lt;span&gt;(flag)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;        @info[:flags].index(flag)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;    def to_s
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{@info[:host]}:#{@info[:port]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;     def connect(o=&lt;span&gt;{})
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; @r
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         print &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connecting to node #{self}: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; $verbose
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        STDOUT.flush
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;        begin
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             @r = Redis.&lt;span&gt;new&lt;/span&gt;(:host =&amp;gt; @info[:host], :port =&amp;gt; @info[:port], :timeout =&amp;gt; &lt;span&gt;60&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            @r.ping
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        rescue
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[ERR] Sorry, can't connect to node #{self}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;             exit &lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; o[:abort]
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             @r =&lt;span&gt; nil
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; $verbose
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt; &lt;span&gt;    def assert_cluster
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         info =&lt;span&gt; @r.info
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; !info[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cluster_enabled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] || info[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cluster_enabled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].to_i == &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;             xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[ERR] Node #{self} is not configured as a cluster node.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt;             exit &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;    def assert_empty
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; !(@r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cluster_known_nodes:1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) ||
&lt;span&gt;120&lt;/span&gt;             (@r.info[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;             exit &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt;     def load_info(o=&lt;span&gt;{})
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;        self.connect
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;         nodes = @r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nodes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         nodes.each{|n|
&lt;span&gt;130&lt;/span&gt; &lt;span&gt;            # name addr flags role ping_sent ping_recv link_status slots
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             split =&lt;span&gt; n.split
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             name,addr,flags,master_id,ping_sent,ping_recv,config_epoch,link_status = split[&lt;span&gt;0&lt;/span&gt;..&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;             slots = split[&lt;span&gt;8&lt;/span&gt;..-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;             info =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                 :name =&amp;gt;&lt;span&gt; name,
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                 :addr =&amp;gt;&lt;span&gt; addr,
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;                 :flags =&amp;gt; flags.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                 :replicate =&amp;gt;&lt;span&gt; master_id,
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                 :ping_sent =&amp;gt;&lt;span&gt; ping_sent.to_i,
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;                 :ping_recv =&amp;gt;&lt;span&gt; ping_recv.to_i,
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                 :link_status =&amp;gt;&lt;span&gt; link_status
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             info[:replicate] = &lt;span&gt;false&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; master_id == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; info[:flags].index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myself&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;                 @info =&lt;span&gt; @info.merge(info)
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;                 @info[:slots] =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                 slots.each{|s|
&lt;span&gt;149&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; s[&lt;span&gt;0&lt;/span&gt;..&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;150&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; s.index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&amp;gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) # Migrating
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;                             slot,dst = s[&lt;span&gt;1&lt;/span&gt;..-&lt;span&gt;1&lt;/span&gt;].split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&amp;gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;                             @info[:migrating][slot.to_i] =&lt;span&gt; dst
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;                         elsif s.index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&amp;lt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) # Importing
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                             slot,src = s[&lt;span&gt;1&lt;/span&gt;..-&lt;span&gt;1&lt;/span&gt;].split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&amp;lt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;                             @info[:importing][slot.to_i] =&lt;span&gt; src
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;                        end
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;                     elsif s.index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;                         start,stop = s.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;                        self.add_slots((start.to_i)..(stop.to_i))
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt; &lt;span&gt;                        self.add_slots((s.to_i)..(s.to_i))
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;                    end
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;                 } &lt;span&gt;if&lt;/span&gt;&lt;span&gt; slots
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;                 @dirty = &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;165&lt;/span&gt;                 @r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).each{|e|
&lt;span&gt;166&lt;/span&gt;                     k,v=e.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;                     k =&lt;span&gt; k.to_sym
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;                     v.chop!
&lt;span&gt;169&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; k !=&lt;span&gt; :cluster_state
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;                         @info[k] =&lt;span&gt; v.to_i
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;172&lt;/span&gt;                         @info[k] =&lt;span&gt; v
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;                    end
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;            elsif o[:getfriends]
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;                 @friends &amp;lt;&amp;lt;&lt;span&gt; info
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;            end
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt; &lt;span&gt;    def add_slots(slots)
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;         slots.each{|s|
&lt;span&gt;183&lt;/span&gt;             @info[:slots][s] = :&lt;span&gt;new&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;         @dirty = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;186&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; 
&lt;span&gt;188&lt;/span&gt; &lt;span&gt;    def set_as_replica(node_id)
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;         @info[:replicate] =&lt;span&gt; node_id
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;         @dirty = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;191&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; 
&lt;span&gt;193&lt;/span&gt; &lt;span&gt;    def flush_node_config
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; !&lt;span&gt;@dirty
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; @info[:replicate]
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;            begin
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;                 @r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;replicate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,@info[:replicate])
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; &lt;span&gt;            rescue
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;                 # If the cluster did not already joined it &lt;span&gt;is&lt;/span&gt;&lt;span&gt; possible that
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;                # the slave does not know the master node yet. So on errors
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;                 # we &lt;span&gt;return&lt;/span&gt; ASAP leaving the dirty flag &lt;span&gt;set&lt;/span&gt;&lt;span&gt;, to flush the
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; &lt;span&gt;                # config later.
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;
&lt;span&gt;204&lt;/span&gt; &lt;span&gt;            end
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;             @info[:slots].each{|s,val|
&lt;span&gt;208&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; val == :&lt;span&gt;new&lt;/span&gt;
&lt;span&gt;209&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; s
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;                     @info[:slots][s] = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;211&lt;/span&gt; &lt;span&gt;                end
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;             @r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addslots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*&lt;span&gt;new&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;         @dirty = &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;216&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; 
&lt;span&gt;218&lt;/span&gt; &lt;span&gt;    def info_string
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;         # We want to display the hash slots assigned to &lt;span&gt;this&lt;/span&gt;&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;         # &lt;span&gt;as&lt;/span&gt; ranges, like &lt;span&gt;in&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1-5,8-9,20-25,30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;221&lt;/span&gt; &lt;span&gt;        #
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;         # Note: &lt;span&gt;this&lt;/span&gt;&lt;span&gt; could be easily written without side effects,
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;         # we use &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slots&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; just to split the computation into steps.
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; 
&lt;span&gt;225&lt;/span&gt; &lt;span&gt;        # First step: we want an increasing array of integers
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;         # &lt;span&gt;for&lt;/span&gt; instance: [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;21&lt;/span&gt;,&lt;span&gt;22&lt;/span&gt;,&lt;span&gt;23&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;         slots =&lt;span&gt; @info[:slots].keys.sort
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; 
&lt;span&gt;229&lt;/span&gt; &lt;span&gt;        # As we want to aggregate adjacent slots we convert all the
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;        # slot integers into ranges (with just one element)
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;         # So we have something like [&lt;span&gt;1&lt;/span&gt;..&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;..&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, ... and so forth.
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;         slots.map!{|x|&lt;span&gt; x..x}
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt; 
&lt;span&gt;234&lt;/span&gt; &lt;span&gt;        # Finally we group ranges with adjacent elements.
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;         slots = slots.reduce([]) {|a,b|
&lt;span&gt;236&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; !a.empty? &amp;amp;&amp;amp; b.first == (a[-&lt;span&gt;1&lt;/span&gt;].last)+&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;237&lt;/span&gt;                 a[&lt;span&gt;0&lt;/span&gt;..-&lt;span&gt;2&lt;/span&gt;] + [(a[-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].first)..(b.last)]
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;239&lt;/span&gt;                 a +&lt;span&gt; [b]
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; &lt;span&gt;            end
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; 
&lt;span&gt;243&lt;/span&gt;         # Now our task &lt;span&gt;is&lt;/span&gt;&lt;span&gt; easy, we just convert ranges with just one
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;         # element into a number, and a real range into a start-&lt;span&gt;end format.
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;         # Finally we join the array &lt;span&gt;using&lt;/span&gt; the comma &lt;span&gt;as&lt;/span&gt;&lt;span&gt; separator.
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;         slots = slots.map{|x|
&lt;span&gt;247&lt;/span&gt;             x.count == &lt;span&gt;1&lt;/span&gt; ? x.first.to_s : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{x.first}-#{x.last}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;248&lt;/span&gt;         }.join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt; 
&lt;span&gt;250&lt;/span&gt;         role = self.has_flag?(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;251&lt;/span&gt; 
&lt;span&gt;252&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.info[:replicate] and @dirty
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;             &lt;span&gt;is&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;S: #{self.info[:name]} #{self.to_s}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;254&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;255&lt;/span&gt;             &lt;span&gt;is&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{role}: #{self.info[:name]} #{self.to_s}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+
&lt;span&gt;256&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;   slots:#{slots} (#{self.slots.length} slots) &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+
&lt;span&gt;257&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{(self.info[:flags]-[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;myself&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]).join(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;258&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.info[:replicate]
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;             &lt;span&gt;is&lt;/span&gt; += &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n   replicates #{info[:replicate]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;261&lt;/span&gt;         elsif self.has_flag?(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt; self.info[:replicas]
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;             &lt;span&gt;is&lt;/span&gt; += &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n   #{info[:replicas].length} additional replica(s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;263&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;         &lt;span&gt;is&lt;/span&gt;
&lt;span&gt;265&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt; 
&lt;span&gt;267&lt;/span&gt;     # Return a single &lt;span&gt;string&lt;/span&gt;&lt;span&gt; representing nodes and associated slots.
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt;     # TODO: remove slaves &lt;span&gt;from&lt;/span&gt;&lt;span&gt; config when slaves will be handled
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt; &lt;span&gt;    # by Redis Cluster.
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt; &lt;span&gt;    def get_config_signature
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt;         config =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt;         @r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nodes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).each_line{|l|
&lt;span&gt;273&lt;/span&gt;             s =&lt;span&gt; l.split
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt;             slots = s[&lt;span&gt;8&lt;/span&gt;..-&lt;span&gt;1&lt;/span&gt;].&lt;span&gt;select&lt;/span&gt; {|x| x[&lt;span&gt;0&lt;/span&gt;..&lt;span&gt;0&lt;/span&gt;] != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt;             next &lt;span&gt;if&lt;/span&gt; slots.length == &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;276&lt;/span&gt;             config &amp;lt;&amp;lt; s[&lt;span&gt;0&lt;/span&gt;]+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+(slots.sort.join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;         config.sort.join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt; 
&lt;span&gt;281&lt;/span&gt; &lt;span&gt;    def info
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt; &lt;span&gt;        @info
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt; 
&lt;span&gt;285&lt;/span&gt;     def is_dirty?
&lt;span&gt;286&lt;/span&gt; &lt;span&gt;        @dirty
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt; 
&lt;span&gt;289&lt;/span&gt; &lt;span&gt;    def r
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt; &lt;span&gt;        @r
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt; &lt;span&gt;end
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt; 
&lt;span&gt;294&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisTrib
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt; &lt;span&gt;    def initialize
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt;         @nodes =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;         @fix = &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;298&lt;/span&gt;         @errors =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt;         @timeout =&lt;span&gt; MigrateDefaultTimeout
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt; 
&lt;span&gt;302&lt;/span&gt; &lt;span&gt;    def check_arity(req_args, num_args)
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((req_args &amp;gt; &lt;span&gt;0&lt;/span&gt; and num_args != req_args) ||
&lt;span&gt;304&lt;/span&gt;            (req_args &amp;lt; &lt;span&gt;0&lt;/span&gt; and num_args &amp;lt;&lt;span&gt; req_args.abs))
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt;            xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[ERR] Wrong number of arguments for specified sub command&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;306&lt;/span&gt;            exit &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;307&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt; 
&lt;span&gt;310&lt;/span&gt; &lt;span&gt;    def add_node(node)
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt;         @nodes &amp;lt;&amp;lt;&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;313&lt;/span&gt; 
&lt;span&gt;314&lt;/span&gt; &lt;span&gt;    def reset_nodes
&lt;/span&gt;&lt;span&gt;315&lt;/span&gt;         @nodes =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt; 
&lt;span&gt;318&lt;/span&gt; &lt;span&gt;    def cluster_error(msg)
&lt;/span&gt;&lt;span&gt;319&lt;/span&gt;         @errors &amp;lt;&amp;lt;&lt;span&gt; msg
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt; &lt;span&gt;        xputs msg
&lt;/span&gt;&lt;span&gt;321&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt; 
&lt;span&gt;323&lt;/span&gt; &lt;span&gt;    # Return the node with the specified ID or Nil.
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt; &lt;span&gt;    def get_node_by_name(name)
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;         @nodes.each{|n|
&lt;span&gt;326&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; n &lt;span&gt;if&lt;/span&gt; n.info[:name] ==&lt;span&gt; name.downcase
&lt;/span&gt;&lt;span&gt;327&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;328&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt; 
&lt;span&gt;331&lt;/span&gt; &lt;span&gt;    # Like get_node_by_name but the specified name can be just the first
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt;     # part of the node ID &lt;span&gt;as&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; the prefix &lt;span&gt;in&lt;/span&gt;&lt;span&gt; unique across the
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt; &lt;span&gt;    # cluster.
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt; &lt;span&gt;    def get_node_by_abbreviated_name(name)
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt;         l =&lt;span&gt; name.length
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt;         candidates =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt;         @nodes.each{|n|
&lt;span&gt;338&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; n.info[:name][&lt;span&gt;0&lt;/span&gt;...l] ==&lt;span&gt; name.downcase
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt;                 candidates &amp;lt;&amp;lt;&lt;span&gt; n
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt; &lt;span&gt;            end
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; nil &lt;span&gt;if&lt;/span&gt; candidates.length != &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;343&lt;/span&gt;         candidates[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;345&lt;/span&gt; 
&lt;span&gt;346&lt;/span&gt; &lt;span&gt;    # This function returns the master that has the least number of replicas
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt;     # &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the cluster. If there are multiple masters with the same smaller
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt;     # number of replicas, one at random &lt;span&gt;is&lt;/span&gt;&lt;span&gt; returned.
&lt;/span&gt;&lt;span&gt;349&lt;/span&gt; &lt;span&gt;    def get_master_with_least_replicas
&lt;/span&gt;&lt;span&gt;350&lt;/span&gt;         masters = @nodes.&lt;span&gt;select&lt;/span&gt;{|n| n.has_flag? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt;         sorted = masters.sort{|a,b|
&lt;span&gt;352&lt;/span&gt;             a.info[:replicas].length &amp;lt;=&amp;gt;&lt;span&gt; b.info[:replicas].length
&lt;/span&gt;&lt;span&gt;353&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;354&lt;/span&gt;         sorted[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;355&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt; 
&lt;span&gt;357&lt;/span&gt;     def check_cluster(opt=&lt;span&gt;{})
&lt;/span&gt;&lt;span&gt;358&lt;/span&gt;         xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node #{@nodes[0]})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;359&lt;/span&gt;         show_nodes &lt;span&gt;if&lt;/span&gt; !&lt;span&gt;opt[:quiet]
&lt;/span&gt;&lt;span&gt;360&lt;/span&gt; &lt;span&gt;        check_config_consistency
&lt;/span&gt;&lt;span&gt;361&lt;/span&gt; &lt;span&gt;        check_open_slots
&lt;/span&gt;&lt;span&gt;362&lt;/span&gt; &lt;span&gt;        check_slots_coverage
&lt;/span&gt;&lt;span&gt;363&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;364&lt;/span&gt; 
&lt;span&gt;365&lt;/span&gt; &lt;span&gt;    def show_cluster_info
&lt;/span&gt;&lt;span&gt;366&lt;/span&gt;         masters = &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;367&lt;/span&gt;         keys = &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;368&lt;/span&gt;         @nodes.each{|n|
&lt;span&gt;369&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; n.has_flag?(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;370&lt;/span&gt;                 puts &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{n} (#{n.info[:name][0...8]}...) -&amp;gt; #{n.r.dbsize} keys | #{n.slots.length} slots | &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+
&lt;span&gt;371&lt;/span&gt;                      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{n.info[:replicas].length} slaves.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;372&lt;/span&gt;                 masters += &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;373&lt;/span&gt;                 keys +=&lt;span&gt; n.r.dbsize
&lt;/span&gt;&lt;span&gt;374&lt;/span&gt; &lt;span&gt;            end
&lt;/span&gt;&lt;span&gt;375&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;376&lt;/span&gt;         xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[OK] #{keys} keys in #{masters} masters.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;377&lt;/span&gt;         keys_per_slot = sprintf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%.2f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,keys/&lt;span&gt;16384.0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;378&lt;/span&gt;         puts &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{keys_per_slot} keys per slot on average.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;379&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;380&lt;/span&gt; 
&lt;span&gt;381&lt;/span&gt; &lt;span&gt;    # Merge slots of every known node. If the resulting slots are equal
&lt;/span&gt;&lt;span&gt;382&lt;/span&gt; &lt;span&gt;    # to ClusterHashSlots, then all slots are served.
&lt;/span&gt;&lt;span&gt;383&lt;/span&gt; &lt;span&gt;    def covered_slots
&lt;/span&gt;&lt;span&gt;384&lt;/span&gt;         slots =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;385&lt;/span&gt;         @nodes.each{|n|
&lt;span&gt;386&lt;/span&gt;             slots =&lt;span&gt; slots.merge(n.slots)
&lt;/span&gt;&lt;span&gt;387&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;388&lt;/span&gt; &lt;span&gt;        slots
&lt;/span&gt;&lt;span&gt;389&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;390&lt;/span&gt; 
&lt;span&gt;391&lt;/span&gt; &lt;span&gt;    def check_slots_coverage
&lt;/span&gt;&lt;span&gt;392&lt;/span&gt;         xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; Check slots coverage...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;393&lt;/span&gt;         slots =&lt;span&gt; covered_slots
&lt;/span&gt;&lt;span&gt;394&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; slots.length ==&lt;span&gt; ClusterHashSlots
&lt;/span&gt;&lt;span&gt;395&lt;/span&gt;             xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[OK] All #{ClusterHashSlots} slots covered.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;396&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;397&lt;/span&gt; &lt;span&gt;            cluster_error \
&lt;/span&gt;&lt;span&gt;398&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[ERR] Not all #{ClusterHashSlots} slots are covered by nodes.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;399&lt;/span&gt;             fix_slots_coverage &lt;span&gt;if&lt;/span&gt;&lt;span&gt; @fix
&lt;/span&gt;&lt;span&gt;400&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;401&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;402&lt;/span&gt; 
&lt;span&gt;403&lt;/span&gt; &lt;span&gt;    def check_open_slots
&lt;/span&gt;&lt;span&gt;404&lt;/span&gt;         xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; Check for open slots...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;405&lt;/span&gt;         open_slots =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;406&lt;/span&gt;         @nodes.each{|n|
&lt;span&gt;407&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; n.info[:migrating].size &amp;gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;408&lt;/span&gt; &lt;span&gt;                cluster_error \
&lt;/span&gt;&lt;span&gt;409&lt;/span&gt;                     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[WARNING] Node #{n} has slots in migrating state (#{n.info[:migrating].keys.join(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}).&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;410&lt;/span&gt;                 open_slots +=&lt;span&gt; n.info[:migrating].keys
&lt;/span&gt;&lt;span&gt;411&lt;/span&gt; &lt;span&gt;            end
&lt;/span&gt;&lt;span&gt;412&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; n.info[:importing].size &amp;gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;413&lt;/span&gt; &lt;span&gt;                cluster_error \
&lt;/span&gt;&lt;span&gt;414&lt;/span&gt;                     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[WARNING] Node #{n} has slots in importing state (#{n.info[:importing].keys.join(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}).&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;415&lt;/span&gt;                 open_slots +=&lt;span&gt; n.info[:importing].keys
&lt;/span&gt;&lt;span&gt;416&lt;/span&gt; &lt;span&gt;            end
&lt;/span&gt;&lt;span&gt;417&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;418&lt;/span&gt;         open_slots.uniq!
&lt;span&gt;419&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; open_slots.length &amp;gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;420&lt;/span&gt;             xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[WARNING] The following slots are open: #{open_slots.join(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;421&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;422&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; @fix
&lt;/span&gt;&lt;span&gt;423&lt;/span&gt;             open_slots.each{|slot|&lt;span&gt; fix_open_slot slot}
&lt;/span&gt;&lt;span&gt;424&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;425&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;426&lt;/span&gt; 
&lt;span&gt;427&lt;/span&gt; &lt;span&gt;    def nodes_with_keys_in_slot(slot)
&lt;/span&gt;&lt;span&gt;428&lt;/span&gt;         nodes =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;429&lt;/span&gt;         @nodes.each{|n|
&lt;span&gt;430&lt;/span&gt;             next &lt;span&gt;if&lt;/span&gt; n.has_flag?(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;431&lt;/span&gt;             nodes &amp;lt;&amp;lt; n &lt;span&gt;if&lt;/span&gt; n.r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getkeysinslot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,slot,&lt;span&gt;1&lt;/span&gt;).length &amp;gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;432&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;433&lt;/span&gt; &lt;span&gt;        nodes
&lt;/span&gt;&lt;span&gt;434&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;435&lt;/span&gt; 
&lt;span&gt;436&lt;/span&gt; &lt;span&gt;    def fix_slots_coverage
&lt;/span&gt;&lt;span&gt;437&lt;/span&gt;         not_covered = (&lt;span&gt;0&lt;/span&gt;...ClusterHashSlots).to_a -&lt;span&gt; covered_slots.keys
&lt;/span&gt;&lt;span&gt;438&lt;/span&gt;         xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; Fixing slots coverage...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;439&lt;/span&gt;         xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;List of not covered slots: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + not_covered.join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;440&lt;/span&gt; 
&lt;span&gt;441&lt;/span&gt; &lt;span&gt;        # For every slot, take action depending on the actual condition:
&lt;/span&gt;&lt;span&gt;442&lt;/span&gt;         # &lt;span&gt;1&lt;/span&gt;) No node has keys &lt;span&gt;for&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt; slot.
&lt;/span&gt;&lt;span&gt;443&lt;/span&gt;         # &lt;span&gt;2&lt;/span&gt;) A single node has keys &lt;span&gt;for&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt; slot.
&lt;/span&gt;&lt;span&gt;444&lt;/span&gt;         # &lt;span&gt;3&lt;/span&gt;) Multiple nodes have keys &lt;span&gt;for&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt; slot.
&lt;/span&gt;&lt;span&gt;445&lt;/span&gt;         slots =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;446&lt;/span&gt;         not_covered.each{|slot|
&lt;span&gt;447&lt;/span&gt;             nodes =&lt;span&gt; nodes_with_keys_in_slot(slot)
&lt;/span&gt;&lt;span&gt;448&lt;/span&gt;             slots[slot] =&lt;span&gt; nodes
&lt;/span&gt;&lt;span&gt;449&lt;/span&gt;             xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Slot #{slot} has keys in #{nodes.length} nodes: #{nodes.join(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;450&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;451&lt;/span&gt; 
&lt;span&gt;452&lt;/span&gt;         none = slots.&lt;span&gt;select&lt;/span&gt; {|k,v| v.length == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;453&lt;/span&gt;         single = slots.&lt;span&gt;select&lt;/span&gt; {|k,v| v.length == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;454&lt;/span&gt;         multi = slots.&lt;span&gt;select&lt;/span&gt; {|k,v| v.length &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;455&lt;/span&gt; 
&lt;span&gt;456&lt;/span&gt;         # Handle &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: keys &lt;span&gt;in&lt;/span&gt;&lt;span&gt; no node.
&lt;/span&gt;&lt;span&gt;457&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; none.length &amp;gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;458&lt;/span&gt;             xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The folowing uncovered slots have no keys across the cluster:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;459&lt;/span&gt;             xputs none.keys.join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;460&lt;/span&gt;             yes_or_die &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fix these slots by covering with a random node?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;461&lt;/span&gt;             none.each{|slot,nodes|
&lt;span&gt;462&lt;/span&gt;                 node =&lt;span&gt; @nodes.sample
&lt;/span&gt;&lt;span&gt;463&lt;/span&gt;                 xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; Covering slot #{slot} with #{node}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;464&lt;/span&gt;                 node.r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addslots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,slot)
&lt;/span&gt;&lt;span&gt;465&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;466&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;467&lt;/span&gt; 
&lt;span&gt;468&lt;/span&gt;         # Handle &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: keys only &lt;span&gt;in&lt;/span&gt;&lt;span&gt; one node.
&lt;/span&gt;&lt;span&gt;469&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; single.length &amp;gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;470&lt;/span&gt;             xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The folowing uncovered slots have keys in just one node:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;471&lt;/span&gt;             puts single.keys.join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;472&lt;/span&gt;             yes_or_die &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fix these slots by covering with those nodes?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;473&lt;/span&gt;             single.each{|slot,nodes|
&lt;span&gt;474&lt;/span&gt;                 xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; Covering slot #{slot} with #{nodes[0]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;475&lt;/span&gt;                 nodes[&lt;span&gt;0&lt;/span&gt;].r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addslots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,slot)
&lt;/span&gt;&lt;span&gt;476&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;477&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;478&lt;/span&gt; 
&lt;span&gt;479&lt;/span&gt;         # Handle &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: keys &lt;span&gt;in&lt;/span&gt;&lt;span&gt; multiple nodes.
&lt;/span&gt;&lt;span&gt;480&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; multi.length &amp;gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;481&lt;/span&gt;             xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The folowing uncovered slots have keys in multiple nodes:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;482&lt;/span&gt;             xputs multi.keys.join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;483&lt;/span&gt;             yes_or_die &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fix these slots by moving keys into a single node?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;484&lt;/span&gt;             multi.each{|slot,nodes|
&lt;span&gt;485&lt;/span&gt;                 target =&lt;span&gt; get_node_with_most_keys_in_slot(nodes,slot)
&lt;/span&gt;&lt;span&gt;486&lt;/span&gt;                 xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; Covering slot #{slot} moving keys to #{target}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;487&lt;/span&gt; 
&lt;span&gt;488&lt;/span&gt;                 target.r.cluster(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;addslots&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,slot)
&lt;/span&gt;&lt;span&gt;489&lt;/span&gt;                 target.r.cluster(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;setslot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,slot,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;490&lt;/span&gt;                 nodes.each{|src|
&lt;span&gt;491&lt;/span&gt;                     next &lt;span&gt;if&lt;/span&gt; src ==&lt;span&gt; target
&lt;/span&gt;&lt;span&gt;492&lt;/span&gt;                     # Set the source node &lt;span&gt;in&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;importing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; state (even &lt;span&gt;if&lt;/span&gt;&lt;span&gt; we will
&lt;/span&gt;&lt;span&gt;493&lt;/span&gt;                     # actually migrate keys away) &lt;span&gt;in&lt;/span&gt;&lt;span&gt; order to avoid receiving
&lt;/span&gt;&lt;span&gt;494&lt;/span&gt;                     # redirections &lt;span&gt;for&lt;/span&gt;&lt;span&gt; MIGRATE.
&lt;/span&gt;&lt;span&gt;495&lt;/span&gt;                     src.r.cluster(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;setslot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,slot,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;importing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,target.info[:name])
&lt;/span&gt;&lt;span&gt;496&lt;/span&gt;                     move_slot(src,target,slot,:dots=&amp;gt;&lt;span&gt;true&lt;/span&gt;,:fix=&amp;gt;&lt;span&gt;true&lt;/span&gt;,:cold=&amp;gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;497&lt;/span&gt;                     src.r.cluster(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;setslot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,slot,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;498&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;499&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;500&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;501&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;502&lt;/span&gt; 
&lt;span&gt;503&lt;/span&gt; &lt;span&gt;    # Return the owner of the specified slot
&lt;/span&gt;&lt;span&gt;504&lt;/span&gt; &lt;span&gt;    def get_slot_owners(slot)
&lt;/span&gt;&lt;span&gt;505&lt;/span&gt;         owners =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;506&lt;/span&gt;         @nodes.each{|n|
&lt;span&gt;507&lt;/span&gt;             next &lt;span&gt;if&lt;/span&gt; n.has_flag?(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;508&lt;/span&gt;             n.slots.each{|s,_|
&lt;span&gt;509&lt;/span&gt;                 owners &amp;lt;&amp;lt; n &lt;span&gt;if&lt;/span&gt; s ==&lt;span&gt; slot
&lt;/span&gt;&lt;span&gt;510&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;511&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;512&lt;/span&gt; &lt;span&gt;        owners
&lt;/span&gt;&lt;span&gt;513&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;514&lt;/span&gt; 
&lt;span&gt;515&lt;/span&gt;     # Return the node, among &lt;span&gt;'&lt;/span&gt;&lt;span&gt;nodes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; with the greatest number of keys
&lt;/span&gt;&lt;span&gt;516&lt;/span&gt;     # &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the specified slot.
&lt;/span&gt;&lt;span&gt;517&lt;/span&gt; &lt;span&gt;    def get_node_with_most_keys_in_slot(nodes,slot)
&lt;/span&gt;&lt;span&gt;518&lt;/span&gt;         best =&lt;span&gt; nil
&lt;/span&gt;&lt;span&gt;519&lt;/span&gt;         best_numkeys = &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;520&lt;/span&gt;         @nodes.each{|n|
&lt;span&gt;521&lt;/span&gt;             next &lt;span&gt;if&lt;/span&gt; n.has_flag?(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;522&lt;/span&gt;             numkeys = n.r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;countkeysinslot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,slot)
&lt;/span&gt;&lt;span&gt;523&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; numkeys &amp;gt; best_numkeys || best ==&lt;span&gt; nil
&lt;/span&gt;&lt;span&gt;524&lt;/span&gt;                 best =&lt;span&gt; n
&lt;/span&gt;&lt;span&gt;525&lt;/span&gt;                 best_numkeys =&lt;span&gt; numkeys
&lt;/span&gt;&lt;span&gt;526&lt;/span&gt; &lt;span&gt;            end
&lt;/span&gt;&lt;span&gt;527&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;528&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; best
&lt;/span&gt;&lt;span&gt;529&lt;/span&gt; &lt;span&gt;    end
&lt;/span&gt;&lt;span&gt;530&lt;/span&gt; 
&lt;span&gt;531&lt;/span&gt;     # Slot &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; was found to be &lt;span&gt;in&lt;/span&gt; importing or migrating state &lt;span&gt;in&lt;/span&gt;&lt;span&gt; one or
&lt;/span&gt;&lt;span&gt;532&lt;/span&gt;     # more nodes. This function fixes &lt;span&gt;this&lt;/span&gt; condition by migrating keys &lt;span&gt;where&lt;/span&gt;
&lt;span&gt;533&lt;/span&gt; &lt;span&gt;    # it seems more sensible.
&lt;/span&gt;&lt;span&gt;534&lt;/span&gt; &lt;span&gt;    def fix_open_slot(slot)
&lt;/span&gt;&lt;span&gt;535&lt;/span&gt;         puts &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; Fixing open slot #{slot}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;536&lt;/span&gt; 
&lt;span&gt;537&lt;/span&gt; &lt;span&gt;        # Try to obtain the current slot owner, according to the current
&lt;/span&gt;&lt;span&gt;538&lt;/span&gt; &lt;span&gt;        # nodes configuration.
&lt;/span&gt;&lt;span&gt;539&lt;/span&gt;         owners =&lt;span&gt; get_slot_owners(slot)
&lt;/span&gt;&lt;span&gt;540&lt;/span&gt;         owner = owners[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;if&lt;/span&gt; owners.length == &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;541&lt;/span&gt; 
&lt;span&gt;542&lt;/span&gt;         migrating =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;543&lt;/span&gt;         importing =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;544&lt;/span&gt;         @nodes.each{|n|
&lt;span&gt;545&lt;/span&gt;             next &lt;span&gt;if&lt;/span&gt; n.has_flag? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;546&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; n.info[:migrating][slot]
&lt;/span&gt;&lt;span&gt;547&lt;/span&gt;                 migrating &amp;lt;&amp;lt;&lt;span&gt; n
&lt;/span&gt;&lt;span&gt;548&lt;/span&gt; &lt;span&gt;            elsif n.info[:importing][slot]
&lt;/span&gt;&lt;span&gt;549&lt;/span&gt;                 importing &amp;lt;&amp;lt;&lt;span&gt; n
&lt;/span&gt;&lt;span&gt;550&lt;/span&gt;             elsif n.r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;countkeysinslot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,slot) &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; n !=&lt;span&gt; owner
&lt;/span&gt;&lt;span&gt;551&lt;/span&gt;                 xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*** Found keys about slot #{slot} in node #{n}!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;552&lt;/span&gt;                 importing &amp;lt;&amp;lt;&lt;span&gt; n
&lt;/span&gt;&lt;span&gt;553&lt;/span&gt; &lt;span&gt;            end
&lt;/span&gt;&lt;span&gt;554&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;555&lt;/span&gt;         puts &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Set as migrating in: #{migrating.join(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;556&lt;/span&gt;         puts &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Set as importing in: #{importing.join(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;557&lt;/span&gt; 
&lt;span&gt;558&lt;/span&gt;         # If there &lt;span&gt;is&lt;/span&gt; no slot owner, &lt;span&gt;set&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;&lt;span&gt; owner the slot with the biggest
&lt;/span&gt;&lt;span&gt;559&lt;/span&gt;         # number of keys, among the &lt;span&gt;set&lt;/span&gt; of migrating /&lt;span&gt; importing nodes.
&lt;/span&gt;&lt;span&gt;560&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; !&lt;span&gt;owner
&lt;/span&gt;&lt;span&gt;561&lt;/span&gt;             xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; Nobody claims ownership, selecting an owner...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;562&lt;/span&gt;             owner =&lt;span&gt; get_node_with_most_keys_in_slot(@nodes,slot)
&lt;/span&gt;&lt;span&gt;563&lt;/span&gt; 
&lt;span&gt;564&lt;/span&gt;             # If we still don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t have an owner, we can&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t fix it.
&lt;/span&gt;&lt;span&gt;565&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; !&lt;span&gt;owner
&lt;/span&gt;&lt;span&gt;566&lt;/span&gt;                 xputs &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[ERR] Can't select a slot owner. Impossible to fix.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;567&lt;/span&gt;                 exit &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;568&lt;/span&gt; &lt;span&gt;            end
&lt;/span&gt;&lt;span&gt;569&lt;/span&gt; 
&lt;span&gt;570&lt;/span&gt; &lt;span&gt;            # Use ADDSLOTS to assign the slot.
&lt;/span&gt;&lt;span&gt;571&lt;/span&gt;             puts &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*** Configuring #{owner} as the slot owner&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;572&lt;/span&gt;             owner.r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;setslot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,slot,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;573&lt;/span&gt;             owner.r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addslots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,slot)
&lt;/span&gt;&lt;span&gt;574&lt;/span&gt;             # Make sure &lt;span&gt;this&lt;/span&gt;&lt;span&gt; information will propagate. Not strictly needed
&lt;/span&gt;&lt;span&gt;575&lt;/span&gt;             # since there &lt;span&gt;is&lt;/span&gt;&lt;span&gt; no past owner, so all the other nodes will accept
&lt;/span&gt;&lt;span&gt;576&lt;/span&gt;             # whatever epoch &lt;span&gt;this&lt;/span&gt;&lt;span&gt; node will claim the slot with.
&lt;/span&gt;&lt;span&gt;577&lt;/span&gt;             owner.r.cluster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bumpepoch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;578&lt;/span&gt; 
&lt;span&gt;579&lt;/span&gt;             # Remove the owner &lt;span&gt;from&lt;/span&gt; the list of migrating/&lt;span&gt;importing
&lt;/span&gt;&lt;span&gt;580&lt;/span&gt; &lt;span&gt;            # nodes.
&lt;/span&gt;&lt;span&gt;581&lt;/span&gt; &lt;span&gt;            migrating.delete(owner)
&lt;/span&gt;&lt;span&gt;582&lt;/span&gt; &lt;span&gt;            importing.delete(owner)
&lt;/span&gt;&lt;span&gt;583&lt;/span&gt; &lt;span&gt;        end
&lt;/span&gt;&lt;span&gt;584&lt;/span&gt; 
&lt;span&gt;585&lt;/span&gt; &lt;span&gt;        # If there are multiple owners of the slot, we need to fix it
&lt;/span&gt;&lt;span&gt;586&lt;/span&gt;         # so that a single node &lt;span&gt;is&lt;/span&gt;&lt;span&gt; the owner and all the other nodes
&lt;/span&gt;&lt;span&gt;587&lt;/span&gt;         # are &lt;span&gt;in&lt;/span&gt;&lt;span&gt; importing state. Later the fix can be handled by one
&lt;/span&gt;&lt;span&gt;588&lt;/span&gt;         # of the &lt;span&gt;base&lt;/span&gt;&lt;span&gt; cases above.
&lt;/span&gt;&lt;span&gt;589&lt;/span&gt; &lt;span&gt;        #
&lt;/span&gt;&lt;span&gt;590&lt;/span&gt;         # Note that &lt;span&gt;this&lt;/span&gt; &lt;span&gt;case&lt;/span&gt;&lt;span&gt; also covers multiple nodes having the slot
&lt;/span&gt;&lt;span&gt;591&lt;/span&gt;         # &lt;span&gt;in&lt;/span&gt; migrating state, since migrating &lt;span&gt;is&lt;/span&gt; a valid state only &lt;span&gt;for&lt;/span&gt;
&lt;span&gt;592&lt;/span&gt; &lt;span&gt;        # slot owners.
&lt;/span&gt;&lt;span&gt;593&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; owners.length &amp;gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;594&lt;/span&gt;             owner =&lt;span&gt; get_node_with_most_keys_in_slot(owners,slot)
&lt;/span&gt;&lt;span&gt;595&lt;/span&gt;             owners.each{|n|
&lt;span&gt;596&lt;/span&gt;                 next &lt;span&gt;if&lt;/span&gt; n ==&lt;span&gt; owner
&lt;/span&gt;&lt;span&gt;597&lt;/span&gt;                 n.r.cluster(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;delslots&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,slot)
&lt;/span&gt;&lt;span&gt;598&lt;/span&gt;                 n.r.cluster(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;setslot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,slot,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;importing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,owner.info[:name])
&lt;/span&gt;&lt;span&gt;599&lt;/span&gt; &lt;span&gt;                importing.delete(n) # Avoid duplciates
&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;                 importing &amp;lt;&amp;lt;&lt;span&gt; n
&lt;/span&gt;&lt;span&gt;601&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;602&lt;/span&gt;             owner.r.cluster(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bumpepoch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;603&lt;/span&gt;         end
&lt;/pre&gt;</description>
<pubDate>Sat, 30 Jun 2018 04:12:00 +0000</pubDate>
<dc:creator>Acdante</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/acdante/p/9244614.html</dc:identifier>
</item>
<item>
<title>UML类图学习 - 阳光温暖</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9246615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9246615.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;最近在学习设计模式，接触最多的就是先用UML类图画出这种设计模式。平常看其他人的博客多多少少也碰到UML类图，毕竟再多的文字，都没有一张图来的直白。掌握UML图其实对与java程序员来说，还是很有必要的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;类&quot;&gt;类&lt;/h3&gt;
&lt;p&gt;java中的类我们最熟悉不过了。比如我新建了一个下面的类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Phone {

    private String name;


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    protected void call(){

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的Phone类的UML图为&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180630080231.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图分为三层：最顶层的为类名，中间层的为属性，最底层的为方法&lt;/li&gt;
&lt;li&gt;属性的表示方式为： 【可见性】 【属性名称】 ：【类型】 = {缺省值，可选}&lt;/li&gt;
&lt;li&gt;方法的表示方式为： 【可见性】 【方法名称】 （【参数列表】）：【类型】&lt;/li&gt;
&lt;li&gt;可见性都是一样的，'-' 表示private、‘+’表示public、‘#’表示protected&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;继承关系&quot;&gt;继承关系&lt;/h3&gt;
&lt;p&gt;继承关系是用于描述父子类之间的关系的，父类又称为基类或者超类。子类又称作派生类。（ 记得之前看其他人的博客。看到超类。瞬间懵逼了，后来一查，就是父类，所以基础的东西一定要掌握牢固）&lt;/p&gt;
&lt;p&gt;下面定义个Mi和Oppo&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Mi extends Phone{

    private String miVersion;

    public void hot(){

    }
}

public class Oppo extends Phone {

    private String oppoVersion;

    public void beautiful(){
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的UML类图为&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180630085615.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;泛化关系使用带空心三角形的实现来表示&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;接口&quot;&gt;接口&lt;/h3&gt;
&lt;p&gt;接口 大家平常经常用到，在接口中通常没有属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface  Language {
    public void hello();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的UML类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180630091753.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在方法上应当有《interface》,表示是一个接口&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实现关系&quot;&gt;实现关系&lt;/h3&gt;
&lt;p&gt;我们定义了接口，就去实现接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Chinese implements Language {
    @Override
    public void hello() {
        System.out.println(&quot;你好&quot;);
    }
}


public class English implements Language{
    @Override
    public void hello() {
        System.out.println(&quot;hello&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的UML类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180630092327.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用空心三角形虚线表示&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关联关系&quot;&gt;关联关系&lt;/h3&gt;
&lt;p&gt;关联关系是类与类 之间最常见的一种关系，它是一种结构化的关系。表示一类对象与另一类对象之间有联系。关联关系分单向关联、双向关联 、自关联&lt;/p&gt;
&lt;h5 id=&quot;单向关联&quot;&gt;单向关联&lt;/h5&gt;
&lt;p&gt;单向关联指的是 关联只有一个方向，比如 我们程序员拥有电脑&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Computer 
{

}

public class Programmer
{
    private Computer computer; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的UML类图为&lt;br/&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180630095718.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;双向关联&quot;&gt;双向关联&lt;/h5&gt;
&lt;p&gt;双向关联的关系就是双向的,比如程序员买电脑 ，反之。电脑也 和程序员关联。这就是双向关联。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Computer 
{
    private Programmer programmer;
}

public class Programmer
{
    //程序员不止一台电脑
    private Computer[] computer; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的UML类图为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180630101705.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有的地方也会使用双向的箭头表示，碰到的时候 不要纠结于这个&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;自关联&quot;&gt;自关联&lt;/h5&gt;
&lt;p&gt;自关联指的就是对象中的属性为对象本身，我首先就想到了单例模式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {

    //构造函数私有化
    private Singleton(){

    }

    private static Singleton instance = new Singleton();

    public static Singleton getInstance(){
        return instance;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的UML类图为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180630102841.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;依赖关系&quot;&gt;依赖关系&lt;/h3&gt;
&lt;p&gt;可以简单理解，就是一个类A使用到了类B.这种使用关系是具有偶然性的、临时性的。但是B的变化会影响到A. 比如，驾驶员（Driver）开车，Driver类的drive()方法将车（Car）的对象作为一个参数传递，以便在drive()方法中能够调用car的move()方法，且驾驶员的drive()方法依赖车的move()方法，因此也可以说Driver依赖Car&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Car
{
    public void move();
}


public class Driver
{
    public void drive(Car car)
    {
        car.move();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的UML类图为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180630104820.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用带箭头的虚线表示&lt;/li&gt;
&lt;li&gt;依赖关系通常通过三种方式来实现
&lt;ul&gt;&lt;li&gt;将一个类的对象作为另一个类中方法的参数&lt;/li&gt;
&lt;li&gt;在一个类的方法中将另一个类的对象作为其对象的局部变量&lt;/li&gt;
&lt;li&gt;在一个类的方法中调用另一个类的静态方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;聚合关系&quot;&gt;聚合关系&lt;/h3&gt;
&lt;p&gt;聚合关系表示整体与部分的关系，在聚合关系中，成员对象实整体的一部分，但是成员对象可以脱离整体对象独立存在。比如电脑有 cpu，ssd&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Cpu
{

}

public class Ssd
{

}

public class Computer
{
    private Cpu cpu;
    private Ssd ssd;

    
    public Computer(Cpu cpu, Ssd ssd)
    {
        this.cpu= cpu;
        this.ssd= ssd;
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的UML类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180630111030.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用空心菱形直线表示&lt;/li&gt;
&lt;li&gt;代码实现聚合关系，成员对象通常以构造方法、Setter方法的方式注入到整体对象之中。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;组合关系&quot;&gt;组合关系&lt;/h3&gt;
&lt;p&gt;组合关系也表示的是一种整体和部分的关系。但是在组合关系中整体对象可以控制成员对象的声明周期，一旦整体对象不存在，成员对象也不存在，有种同生共死的感觉。比如人的 头 和嘴巴、鼻子。嘴巴和鼻子是头的组成部分之一，一旦头没了，嘴巴也没有了（好可怕）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Mouth
{

}

public class Nose
{

}

public class Head
{
    private Mouth mouth;
    private Nose nose;
    
    public Head()
    {
        mouth = new Mouth();
        nose = new Nose();
    }
    

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的UML类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180630112042.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用实心菱形直线表示&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;基本上常用的都介绍完了，不过实际应用中，不必完全纠结于细节，合理的利用对象之间的关系给出合理的设计方案即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对了。我先在画图都是用在线的 &lt;a href=&quot;https://www.processon.com/&quot;&gt;processon&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;最近公司鼓励大家进行写博客写文章。我也对大家提供下我平时写文章用到的工具以及一点总结&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用makedown写文章，用了之后就会发现 爽&lt;/li&gt;
&lt;li&gt;图片存储的话我现在用七牛云。免费的大约有10G，应该够大家用了吧&lt;/li&gt;
&lt;li&gt;我一般不会在csdn 或者 博客园的编辑器里面写。我一般会在在线的 马克飞象中书写，写完之后再粘贴到csdn或者博客园的makedown 编辑器中&lt;/li&gt;
&lt;li&gt;大家如果平时还维护着微信公众号，大家可以使用这个md2all 转下。我也是刚刚发现这个，之前一直用 &lt;a href=&quot;http://blog.didispace.com/tools/online-markdown/&quot;&gt;程序员DD（http://blog.didispace.com/tools/online-markdown/）&lt;/a&gt; 这个。&lt;/li&gt;
&lt;li&gt;写博客一定要注意文章的格式，如果写的乱七八糟，就如同你看别人写的代码一样的感受&lt;/li&gt;
&lt;li&gt;坚持写下去&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 30 Jun 2018 03:50:00 +0000</pubDate>
<dc:creator>阳光温暖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9246615.html</dc:identifier>
</item>
<item>
<title>JWT+ASP.NET MVC  时间戳防止重放攻击 - KiSs_小白</title>
<link>http://www.cnblogs.com/xiaobai123/p/9243809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobai123/p/9243809.html</guid>
<description>&lt;p&gt;&lt;strong&gt; 时间戳作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       客户端在向服务端接口进行请求,如果请求信息进行了加密处理，被第三方截取到请求包，可以使用该请求包进行重复请求操作。如果服务端不进行防重放攻击，就会服务器压力增大，而使用时间戳的方式可以解决这一问题。&lt;/p&gt;

&lt;p&gt;上一篇讲到JWT安全验证操作,现在结合时间戳进行防重复攻击和被第三方抓包工具截取到Headers中token,进行模拟请求操作。&lt;/p&gt;
&lt;h3&gt; 防篡改&lt;/h3&gt;
&lt;p&gt;      一般使用的方式就是把参数拼接，当前项目AppKey，双方约定的“密钥”，加入到Dictionary字典集中，按ABCD顺序进行排序,最后在MD5+加密.客户端将加密字符串和请求参数一起发送给服务器。服务器按照&lt;/p&gt;
&lt;p&gt;上述规则拼接加密后，与传入过来的加密字符串比较是否相等&lt;/p&gt;
&lt;h3&gt; 防复用&lt;/h3&gt;
&lt;p&gt;        上面的方式进行加密，就无法解决防复用的问题，这时需要在客户端和服务端分别生成UTC的时间戳，这个UTC是防止你的客户端与服务端不在同一个时区，呵呵，然后把时间戳timestamp拼在密文里就可以了，至于防复用的有效性&lt;/p&gt;

&lt;p&gt;下面进入正题,编码启动&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建 DESCryption 帮助类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DESCryption
    {

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; //注意了，是8个字符，64位
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PrivateRsa = ConfigurationManager.AppSettings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PrivateRsa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; //注意了，是8个字符，64位
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PublicRsa = ConfigurationManager.AppSettings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PublicRsa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 加密
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Encode(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; data)
        {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] byKey =&lt;span&gt; Encoding.ASCII.GetBytes(PrivateRsa);
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] byIV =&lt;span&gt; Encoding.ASCII.GetBytes(PublicRsa);

            DESCryptoServiceProvider cryptoProvider &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DESCryptoServiceProvider();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cryptoProvider.KeySize;
            MemoryStream ms &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream();
            CryptoStream cst &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CryptoStream(ms, cryptoProvider.CreateEncryptor(byKey, byIV), CryptoStreamMode.Write);

            StreamWriter sw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamWriter(cst);
            sw.Write(data);
            sw.Flush();
            cst.FlushFinalBlock();
            sw.Flush();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Convert.ToBase64String(ms.GetBuffer(), &lt;span&gt;0&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ms.Length);

        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 解密
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Decode(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; data)
        {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] byKey =&lt;span&gt; Encoding.ASCII.GetBytes(PrivateRsa);
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] byIV =&lt;span&gt; Encoding.ASCII.GetBytes(PublicRsa);

            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] byEnc;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                byEnc &lt;/span&gt;=&lt;span&gt; Convert.FromBase64String(data);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }

            DESCryptoServiceProvider cryptoProvider &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DESCryptoServiceProvider();
            MemoryStream ms &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream(byEnc);
            CryptoStream cst &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CryptoStream(ms, cryptoProvider.CreateDecryptor(byKey, byIV), CryptoStreamMode.Read);
            StreamReader sr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(cst);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sr.ReadToEnd();
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;然后在MyAuthorizeAttribute 加上时间戳验证方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将DESC签名时间字符串 当作请求传入&lt;/p&gt;
&lt;p&gt;如果传入的时间戳小于服务器当前时间  返回false  提示权限不足&lt;/p&gt;
&lt;p&gt;如果传入的时间戳大于服务器当前时间  返回true  可以正常访问&lt;/p&gt;
&lt;p&gt; 完美方案就是将redis中jwtToken设置过期时间    各位兄台希望我补充完整，&lt;/p&gt;
&lt;p&gt;请留言--我会及时更新GitHub将这个dmeo补充完整&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180629153805819-1600492277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求参数&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; requestTime = httpContext.Request[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rtime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求时间经过DESC签名&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(requestTime))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求时间DESC解密后加上时间戳的时间即该请求的有效时间&lt;/span&gt;
            DateTime Requestdt = DateTime.Parse(DESCryption.Decode(requestTime)).AddMinutes(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;.Parse(TimeStamp));
            DateTime Newdt &lt;/span&gt;= DateTime.Now; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器接收请求的当前时间&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (Requestdt &amp;lt;&lt;span&gt; Newdt)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行其他操作&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; userinfo =&lt;span&gt; JwtHelp.GetJwtDecode(authHeader);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;举个例子  生成jwtToken 存入redis中    
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个地方用jwtToken当作key 获取实体val   然后看看jwtToken根据redis是否一样&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (userinfo.UserName == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp; userinfo.Pwd == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 大家还有什么需要了解的新手教程知识点，可以留言给我。我会在三天内给大家写一份简单的教学demo出来&lt;/p&gt;
&lt;p&gt;后期ASP.NET API,ASP.NET Core,Java教程都可以。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yaols/JWT.MvcDemo&quot;&gt;https://github.com/yaols/JWT.MvcDemo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Jun 2018 02:45:00 +0000</pubDate>
<dc:creator>KiSs_小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaobai123/p/9243809.html</dc:identifier>
</item>
</channel>
</rss>