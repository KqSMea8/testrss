<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>信协第一学期考核 - 20175207冷南</title>
<link>http://www.cnblogs.com/ln-0407/p/8053878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ln-0407/p/8053878.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;（普通题一题&lt;/span&gt;20&lt;span&gt;分） 共七道题 选做&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目一：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;数组（&lt;/span&gt;array&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从键盘输入一个长度为&lt;/span&gt;N&lt;span&gt;（比如&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;）的整型数组，第一行输出小于零的数，第二行输出零的个数，第三行输出大于零的数，维持原数组顺序，不进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;输入描述&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：第一行键盘输入&lt;/span&gt; &lt;span&gt;n&lt;/span&gt;&lt;span&gt;，第二行输入&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;个数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出描述：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一行输出小于零的数，第二行输出零的个数，第三行输出大于零的数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;2  -5  -89  75  0  -89  0  93  48  0&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-5  -89  -89&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;2  75  93  48&lt;/p&gt;
&lt;p&gt; &lt;span&gt;解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#define N 15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int main()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    int n,a[N],i,count=0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    char c;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    scanf(&quot;%d&quot;,&amp;amp;n);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        scanf(&quot;%d&quot;,&amp;amp;a[i]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        if(a[i]&amp;lt;0)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            printf(&quot;%4d&quot;,a[i]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    printf(&quot;\n&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        if(a[i]==0)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            count++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    printf(&quot;%4d\n&quot;,count);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        if(a[i]&amp;gt;0)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            printf(&quot;%4d&quot;,a[i]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目二：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;计算两个整数的最大公约数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按如下函数原型，采用欧几里德算法编写计算两个整数的最大公约数的函数&lt;/span&gt;Gcd()&lt;span&gt;。欧几里德算法，也称辗转相除法。其基本思想是：对正整数&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;，连续进行求余运算，直到余数为&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;为止，此时非&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;的除数就是最大公约数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;/* &lt;span&gt;函数功能：计算&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;的最大公约数，输入负数时返回&lt;/span&gt;&lt;span&gt;-1 */&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;int Gcd(int a, int b)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要求如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）从键盘任意输入的两整数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;主函数调用&lt;/span&gt;&lt;span&gt;Gcd()&lt;/span&gt;&lt;span&gt;函数，并输出两整数的最大公约数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;Gcd&lt;/span&gt;&lt;span&gt;函数原型为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     int Gcd(int a, int b);&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;如果输入的数不是正整数，则返回&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;否则，返回两个数的最大公约数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）&lt;/span&gt;&lt;span&gt;**&lt;/span&gt;&lt;span&gt;输入提示信息格式要求：&lt;/span&gt;&lt;span&gt;&quot;Input a,b:\n&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;输入两个整数时用&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;号分隔&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     **&lt;span&gt;输出提示信息要求：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;如果输入的数不是正整数，则输出&lt;/span&gt;&lt;span&gt;&quot;Input error!\n&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;否则按如下格式输出&lt;/span&gt;&quot;Gcd=%d\n&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;void main()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int a,b,c;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int gcd(int,int);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;printf(&quot;input two integers:&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;scanf(&quot;%d%d&quot;,&amp;amp;a,&amp;amp;b);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if(a,b&amp;lt;=0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        printf(&quot;Input error!\n&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;c=gcd(a,b);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;printf(&quot;Greatest commondivisor is %d\n&quot;,c);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int gcd(int x,int y)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int t;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;while(y)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t=x%y;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;x=y;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;y=t;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return x;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目三：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;计算圆的面积。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要求：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）圆的半径&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;的值为&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;（包括&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;）之间的正整数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）用符号常量定义&lt;/span&gt;&lt;span&gt;PI&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;3.14&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）当圆的面积小于&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;时输出圆的面积并对圆的面积求累加和，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;大于等于&lt;/span&gt;50&lt;span&gt;时结束循环；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）输出累加和的结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）不用数组编程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;**&lt;span&gt;要求输入提示信息为：无输入提示信息和输入数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;**&lt;span&gt;要求输出格式为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;&quot;area=%.2f\n&quot;                &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;&quot;sum=%.2f\n&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;void main ()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    int r;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  float s;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  float PI=3.14;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  float sum=0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  for(r=1;r&amp;lt;11;r++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       s=PI*r*r;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  if(s&amp;lt;50)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      printf(&quot;%f&quot;,s);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      sum+=s;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      printf(&quot;%f&quot;,sum);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;break;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  return 0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目四：汉语数字&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入一个整形数，按汉语习惯输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要求&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入提示信息为：&lt;/span&gt;&lt;span&gt;请输入数字：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输&lt;/span&gt;&lt;span&gt;出&lt;/span&gt;&lt;span&gt;提示信息为：&lt;/span&gt;&lt;span&gt;汉语为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请输入数字：&lt;/span&gt;1052&lt;/p&gt;
&lt;p&gt;&lt;span&gt;汉语为：&lt;/span&gt;&lt;span&gt;一千零五十二&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;# include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# include &amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;void ChangeType1(char * px, char * pn, char * pw, int len);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;int main(void)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char x[100];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char num[10][] = {'零','一','二','三','四','五','六','七','八','九'};&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char wei[4][] = {'\0','十','百','千'};&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char danwei[3][] = {'\0','万','亿'};&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int len;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int lx;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char * pn = num, * pn2 = num2, * px = x, * pw = wei, * pw2 = wei2, * pdw = danwei&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;printf(&quot;请输入数字：&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;lx=strlen(x);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for(i=0;i&amp;lt;lx;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;x[i]=x[i]-'0';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for(i=0;i&amp;lt;lx;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;d=lx-i;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(num2[x[i]]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if(d==2||d==6||d==10)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(wei[0]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if(d==3||d==7||d==11)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(wei[1]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if(d==4||d==8||d==12)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(wei[2]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if(d==5)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(danwei[0]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if(d==9)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;puts(danwei[1])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;span&gt;？？？？？？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目五：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;统计师的难题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一天统计师小明收到上司的一大串文字，让小明找出其中的数字，英文和其他&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内容（空格与其他字符）的个数，请你写程序帮助小明解决这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入可能有多组测试用例，每个用例包含一行字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个用例包括&lt;/span&gt; 3 &lt;span&gt;个整数，分别代表英文个数、 数字个数、其他内容个数，整数间以空格分隔。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;adfawef12345 *&amp;amp;&lt;/p&gt;
&lt;p&gt;AFSAF587&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7 5 3&lt;/p&gt;
&lt;p&gt;5 3 0&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int main(int argc, char *argv[])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt; int n=0,i;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; printf(&quot;请输入行数:&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; scanf(&quot;%d&quot;,&amp;amp;n);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; char** s;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; s=(char**)malloc(sizeof(char*)*n);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  s[i]=(char*)malloc(sizeof(char)*128);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt; for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  scanf(&quot;%s&quot;,s[i]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt; for(i=0;i&amp;lt;n;i++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  int len=strlen(s[i]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  int j,alpha=0,digit=0,other=0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  for(j=0;j&amp;lt;len;j++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   if(s[i][j]&amp;gt;='0' &amp;amp;&amp;amp; s[i][j]&amp;lt;='9')&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    digit++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   else if((s[i][j]&amp;gt;='A' &amp;amp;&amp;amp; s[i][j]&amp;lt;='Z') || (s[i][j]&amp;gt;='a' &amp;amp;&amp;amp; s[i][j]&amp;lt;='z'))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    alpha++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    other++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  printf(&quot;%d %d %d\n&quot;,alpha,digit,other);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt; return 0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目六：人民币&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用&lt;/span&gt;100&lt;span&gt;元人民币兑换&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;元&lt;/span&gt;&lt;span&gt;,5&lt;/span&gt;&lt;span&gt;元和&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;元的纸币&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;每一种都要有&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;共&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;张&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;请用穷举法编程计算共有几种兑换方案&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;每种方案各兑换多少张纸币&lt;/span&gt;&lt;span&gt;.     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;****&lt;span&gt;输入提示信息要求为：无&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;****&lt;span&gt;输出格式要求为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&quot;x = %d, y = %d, z = %d\n&quot;&lt;/p&gt;
&lt;p&gt;&quot;count = %d\n&quot;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int main ()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   int x,y,z,count=0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   for(x=0;x&amp;lt;=5;x++)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       for(y=1;y&amp;lt;11;y++)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           z=50-x-y;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           if(10*x+5*y+z==100);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               count++;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               printf(&quot;x=%d,y=%d,z=%d\n&quot;,x,y,z);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目七：素性检测&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从键盘任意输入一个整数&lt;/span&gt;m，若m不是素数，则对m进行质因数分解，并将m表示为质因数从小到大顺序排列的乘积形式输出，否则输出&quot;It is a prime number&quot;。例如，用户输入90时，程序输出90 = 2 * 3 * 3 * 5；用户输入17时，程序输出&quot;It is a prime number&quot;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入提示信息：&lt;/span&gt;&quot;Input m:&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入格式：&lt;/span&gt;&quot;%d&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是素数时输出&lt;/span&gt;&quot;It is a prime number\n&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;否则输出用&lt;/span&gt;&quot;%d = &quot;，&quot;%d * &quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行示例&lt;/span&gt;1：&lt;/p&gt;
&lt;p&gt;Input m:90↙&lt;/p&gt;
&lt;p&gt;90 = 2 * 3 * 3 * 5&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行示例&lt;/span&gt;2：&lt;/p&gt;
&lt;p&gt;Input m:13↙&lt;/p&gt;
&lt;p&gt;It is a prime number&lt;/p&gt;
&lt;p&gt; &lt;span&gt;解答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;void main()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    int a,b,i,f[10]={0},t=0,flag=1;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    scanf(&quot;%d&quot;,&amp;amp;a);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    b=a;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    for(i=2;i&amp;lt;a;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        if(b%i==0)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            f[t]=i;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            b/=i;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            t++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            flag=0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            i++;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    if(flag)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        printf(&quot;It is a prime number&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        printf(&quot;%d = &quot;,a);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        for(t=1;f[t]!=0;t++)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            printf(&quot;%2d *&quot;,f[t-1]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        printf(&quot;%2d&quot;,f[t-1]);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目八：正弦&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;已知求正弦&lt;/span&gt;sin(x)&lt;span&gt;的近似值的多项式公式为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;sin(x)=x−x 3  3!  +x 5  5!  −x 7  7!  +⋯+(−1) n x 2n+1  (2n+1)!  +…&lt;/p&gt;

&lt;p&gt;&lt;span&gt;要求输入&lt;/span&gt;x&lt;span&gt;和&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;，按上述公式计算&lt;/span&gt;&lt;span&gt;sin(x)&lt;/span&gt;&lt;span&gt;的近似值，要求计算的误差小于给定的&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;**&lt;span&gt;输入格式要求：&lt;/span&gt;&lt;span&gt;&quot;%f%f&quot;&lt;/span&gt; &lt;span&gt;提示信息：&lt;/span&gt;&lt;span&gt;&quot;Enter x &amp;amp; eps:&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;**&lt;span&gt;输出格式要求：&lt;/span&gt;&lt;span&gt;&quot;sin(%f)=%f\n&quot;  &quot;%d,sin(%f)=%f\n&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序运行示例如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Enter x &amp;amp; eps:5 0.000001&lt;/p&gt;
&lt;p&gt;sin(5.000000)=-0.958924&lt;/p&gt;
&lt;p&gt;13,sin(5.000000)=-0.958924&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（提高题部分一题&lt;/span&gt;40&lt;span&gt;分）共&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;题 选做&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;提高题一：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;堆栈&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;堆栈是数据结构中的重要线性结构，最先进入栈中的元素最后才能出栈，现在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给出三种操作指令（进栈，出栈，查询栈中中位数），请你根据指令输出当前&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作的是哪个值，其中如果栈中数量为偶数，中位数定义为其中较小的元素，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如栈中元素自底向上为&lt;/span&gt; 3 1 4 2&lt;span&gt;，那么中位数为&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一行输入给出所输入指令的总条数&lt;/span&gt; N&lt;span&gt;（&lt;/span&gt; &lt;span&gt;&amp;lt;1000&lt;/span&gt;&lt;span&gt;）&lt;/span&gt; &lt;span&gt;,&lt;/span&gt;&lt;span&gt;随后&lt;/span&gt; &lt;span&gt;N&lt;/span&gt; &lt;span&gt;行给出每个指令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Push k &lt;span&gt;代表将&lt;/span&gt; &lt;span&gt;k&lt;/span&gt; &lt;span&gt;入栈，&lt;/span&gt; &lt;span&gt;k&lt;/span&gt; &lt;span&gt;为小于&lt;/span&gt; &lt;span&gt;500&lt;/span&gt; &lt;span&gt;的正整数，&lt;/span&gt; &lt;span&gt;Pop&lt;/span&gt; &lt;span&gt;代表出栈，&lt;/span&gt; &lt;span&gt;Find&lt;/span&gt; &lt;span&gt;代表查&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;询栈中中位数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对每个输入的指令，如果是&lt;/span&gt; Pop &lt;span&gt;或&lt;/span&gt; &lt;span&gt;Find&lt;/span&gt; &lt;span&gt;操作则输出相应操作的元素。指令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非法则输出&lt;/span&gt;“Error”&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;Pop&lt;/p&gt;
&lt;p&gt;Find&lt;/p&gt;
&lt;p&gt;Push 3&lt;/p&gt;
&lt;p&gt;Find&lt;/p&gt;
&lt;p&gt;Push 2&lt;/p&gt;
&lt;p&gt;Find&lt;/p&gt;
&lt;p&gt;Push 1&lt;/p&gt;
&lt;p&gt;Find&lt;/p&gt;
&lt;p&gt;Pop&lt;/p&gt;
&lt;p&gt;Pop&lt;/p&gt;
&lt;p&gt;Pop&lt;/p&gt;
&lt;p&gt;Pop&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样例输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Error&lt;/p&gt;
&lt;p&gt;Error&lt;/p&gt;
&lt;p&gt;3 2 2 1 2 3&lt;/p&gt;
&lt;p&gt;Error&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;提高题二：结构体&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;定义存放一个学生信息的结构体类型，学生信息包括：姓名，学号，性别，院系，要求在随意输入&lt;/span&gt;5&lt;span&gt;个学生的相关信息后，按照学号从小到大顺序输出这些学生的信息。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;输入&lt;/span&gt;:&lt;br/&gt;&lt;span&gt;先输入&lt;/span&gt;5&lt;span&gt;名学生的信息，按学号顺序排序输出后在输入要统计的院系名称&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;先按学号从小到大的顺序输出学生信息&lt;/span&gt; &lt;br/&gt;&lt;span&gt;样例输入&lt;/span&gt;&lt;br/&gt;zhang3 20149003 M &lt;span&gt;信息系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang5 20149005 F &lt;span&gt;信息系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang10 20149010 F &lt;span&gt;管理系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang1 20149001 M &lt;span&gt;会计系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang9 20149009 M &lt;span&gt;会计系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;样例输出&lt;/span&gt;&lt;br/&gt;zhang1 20149001 M &lt;span&gt;会计系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang3 20149003 M &lt;span&gt;信息系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang5 20149005 F &lt;span&gt;信息系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang9 20149009 M &lt;span&gt;会计系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;zhang10 20149010 F &lt;span&gt;管理系&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;提高题三：字符串插入&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过指针&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;字符串插入&lt;/span&gt;&lt;span&gt;的功能&lt;/span&gt;,&lt;span&gt;将&lt;/span&gt;&lt;span&gt;一个&lt;/span&gt;&lt;span&gt;字符串&lt;/span&gt;&lt;span&gt;插入到另一个字符串的任意位置要求&lt;/span&gt;&lt;span&gt;将源字符串&lt;/span&gt;srcStr&lt;span&gt;连接到目的字符串&lt;/span&gt;&lt;span&gt;dstStr&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;任意位置&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串&lt;/span&gt;srcStr&lt;span&gt;：&lt;/span&gt;abc&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符串&lt;/span&gt;dstStr&lt;span&gt;：&lt;/span&gt;hahaha&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插入&lt;/span&gt;dstStr&lt;span&gt;的第几位：&lt;/span&gt;3&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果为：&lt;/span&gt;hahabcaha&lt;/p&gt;

</description>
<pubDate>Sun, 17 Dec 2017 15:29:00 +0000</pubDate>
<dc:creator>20175207冷南</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ln-0407/p/8053878.html</dc:identifier>
</item>
<item>
<title>dubbo源码—dubbo自定义spring xml标签 - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/8053867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/8053867.html</guid>
<description>&lt;p&gt;dubbo为了和spring更好的集成，提供了一些xml配置标签，也就是自定义标签&lt;/p&gt;
&lt;h4 id=&quot;spring自定义标签&quot;&gt;spring自定义标签&lt;/h4&gt;
&lt;p&gt;spring自定义标签的方式如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设计配置属性和JavaBean&lt;/li&gt;
&lt;li&gt;编写xsd文件，校验xml属性和便于编辑器提示&lt;/li&gt;
&lt;li&gt;编写NamespaceHandler和BeanDefinitionParser解析xml对应的标签&lt;/li&gt;
&lt;li&gt;编写spring.handlers和spring.schemas串联起所有部件，放在META_INF下面&lt;/li&gt;
&lt;li&gt;在xml中引入对应的标签就可以使用&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;dubbo自定义标签&quot;&gt;dubbo自定义标签&lt;/h4&gt;
&lt;p&gt;dubbo对应的定义为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ApplicationConfig，ModuleConfig，RegistryConfig，MonitorConfig等&lt;/li&gt;
&lt;li&gt;META_INF/dubbo.xsd&lt;/li&gt;
&lt;li&gt;DubboNamespaceHandler,DubboBeanDefinitionParser&lt;/li&gt;
&lt;li&gt;META_INF/spring.handlers,META_INF/spring.schemas&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;spring在解析xml并加载bean定义的时候，会加载spring用来解析xml标签的handler，spring通过扫描所有类路径下的META_INF/spring.handlers来加载自定义标签的handler，紧接着会调用解析出的handler的init方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 类DefaultNamespaceHandlerResolver&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; NamespaceHandler &lt;span class=&quot;fu&quot;&gt;resolve&lt;/span&gt;(String namespaceUri) {
  &lt;span class=&quot;co&quot;&gt;// 这里namespaceUri = http://code.alibabatech.com/schema/dubbo&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 加载所有的handlers配置，并取出dubbo自定义的handler&lt;/span&gt;
  Map&amp;lt;String, Object&amp;gt; handlerMappings = &lt;span class=&quot;fu&quot;&gt;getHandlerMappings&lt;/span&gt;();
  Object handlerOrClassName = handlerMappings.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(namespaceUri);
  &lt;span class=&quot;co&quot;&gt;// ... 省略中间代码&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 实例化handler并缓存起来，然后调用init方法&lt;/span&gt;
  NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.&lt;span class=&quot;fu&quot;&gt;instantiateClass&lt;/span&gt;(handlerClass);
  namespaceHandler.&lt;span class=&quot;fu&quot;&gt;init&lt;/span&gt;();
  handlerMappings.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(namespaceUri, namespaceHandler);
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; namespaceHandler;
  &lt;span class=&quot;co&quot;&gt;// ... 省略中间代码&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; &lt;span class=&quot;fu&quot;&gt;getHandlerMappings&lt;/span&gt;() {
  &lt;span class=&quot;co&quot;&gt;// ... 省略中间代码&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 这里handlerMappingsLocation = META-INF/spring.handlers&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 加在classpath下所有spring.handlers&lt;/span&gt;
  Properties mappings =
    PropertiesLoaderUtils.&lt;span class=&quot;fu&quot;&gt;loadAllProperties&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handlerMappingsLocation&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;classLoader&lt;/span&gt;);
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (logger.&lt;span class=&quot;fu&quot;&gt;isDebugEnabled&lt;/span&gt;()) {
    logger.&lt;span class=&quot;fu&quot;&gt;debug&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Loaded NamespaceHandler mappings: &quot;&lt;/span&gt; + mappings);
  }
  Map&amp;lt;String, Object&amp;gt; handlerMappings = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Object&amp;gt;(mappings.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());
  CollectionUtils.&lt;span class=&quot;fu&quot;&gt;mergePropertiesIntoMap&lt;/span&gt;(mappings, handlerMappings);
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handlerMappings&lt;/span&gt; = handlerMappings;
  &lt;span class=&quot;co&quot;&gt;// ... 省略中间代码&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在DubboNamespaceHandler#init方法中添加所有自定义标签对应的parser，将自定义的标签对应的parser添加到NamespaceHandlerSupport#parsers中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;30&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;init&lt;/span&gt;() {
  &lt;span class=&quot;co&quot;&gt;// 参数true表示在解析的时候如果没有指定id需要生成一个id&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;registerBeanDefinitionParser&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;application&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DubboBeanDefinitionParser&lt;/span&gt;(ApplicationConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;));
  &lt;span class=&quot;fu&quot;&gt;registerBeanDefinitionParser&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;module&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DubboBeanDefinitionParser&lt;/span&gt;(ModuleConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;));
  &lt;span class=&quot;fu&quot;&gt;registerBeanDefinitionParser&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;registry&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DubboBeanDefinitionParser&lt;/span&gt;(RegistryConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;));
  &lt;span class=&quot;fu&quot;&gt;registerBeanDefinitionParser&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;monitor&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DubboBeanDefinitionParser&lt;/span&gt;(MonitorConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;));
  &lt;span class=&quot;fu&quot;&gt;registerBeanDefinitionParser&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;provider&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DubboBeanDefinitionParser&lt;/span&gt;(ProviderConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;));
  &lt;span class=&quot;fu&quot;&gt;registerBeanDefinitionParser&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;consumer&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DubboBeanDefinitionParser&lt;/span&gt;(ConsumerConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;));
  &lt;span class=&quot;fu&quot;&gt;registerBeanDefinitionParser&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;protocol&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DubboBeanDefinitionParser&lt;/span&gt;(ProtocolConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;));
  &lt;span class=&quot;fu&quot;&gt;registerBeanDefinitionParser&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;service&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DubboBeanDefinitionParser&lt;/span&gt;(ServiceBean.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;));
  &lt;span class=&quot;fu&quot;&gt;registerBeanDefinitionParser&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;reference&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DubboBeanDefinitionParser&lt;/span&gt;(ReferenceBean.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;));
  &lt;span class=&quot;fu&quot;&gt;registerBeanDefinitionParser&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;annotation&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DubboBeanDefinitionParser&lt;/span&gt;(AnnotationBean.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有的自定义标签都使用DubboBeanDefinitionParser解析，每一个自定义标签对应一个JavaBean（前面在spring自定义标签的方法中提到），在解析到自定义标签的时候根据标签名称获取到parser解析标签，调用parser.parse方法，parse方法主要作用就是解析标签构造对应JavaBean的RootBeanDefinition，构造好后注入spring容器中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; BeanDefinition &lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(Element element, ParserContext parserContext, Class&amp;lt;?&amp;gt; beanClass, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; required) {
  RootBeanDefinition beanDefinition = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RootBeanDefinition&lt;/span&gt;();
  beanDefinition.&lt;span class=&quot;fu&quot;&gt;setBeanClass&lt;/span&gt;(beanClass);
  beanDefinition.&lt;span class=&quot;fu&quot;&gt;setLazyInit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
  String id = element.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;);
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((id == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || id.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; required) {
    &lt;span class=&quot;co&quot;&gt;// 如果没有配置id，先依次试图获取name、interface作为generatedBeanName&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (generatedBeanName == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || generatedBeanName.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
      &lt;span class=&quot;co&quot;&gt;// 如果上面的属性都没有配置则直接获取class的全名作为id&lt;/span&gt;
      generatedBeanName = beanClass.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;();
    }
    &lt;span class=&quot;co&quot;&gt;// 以防该class有其他的实例（比如可以配置多协议，dubbo:protocol），在后面加上一个数字加以区分&lt;/span&gt;
    id = generatedBeanName; 
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; counter = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(parserContext.&lt;span class=&quot;fu&quot;&gt;getRegistry&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;containsBeanDefinition&lt;/span&gt;(id)) {
      id = generatedBeanName + (counter ++);
    }
  }
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (id != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; id.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
    &lt;span class=&quot;co&quot;&gt;// double check&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (parserContext.&lt;span class=&quot;fu&quot;&gt;getRegistry&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;containsBeanDefinition&lt;/span&gt;(id))  {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;st&quot;&gt;&quot;Duplicate spring bean id &quot;&lt;/span&gt; + id);
    }
    &lt;span class=&quot;co&quot;&gt;// 将BeanDefinition注册到容器&lt;/span&gt;
    parserContext.&lt;span class=&quot;fu&quot;&gt;getRegistry&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;registerBeanDefinition&lt;/span&gt;(id, beanDefinition);
    beanDefinition.&lt;span class=&quot;fu&quot;&gt;getPropertyValues&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;addPropertyValue&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;, id);
  }
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ProtocolConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(beanClass)) {
    &lt;span class=&quot;co&quot;&gt;// ... 省略中间代码&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 如果是ProtocolConfig，会找出容器中所有配置了protocol属性的bean，并设置为RuntimeBeanReference&lt;/span&gt;
    definition.&lt;span class=&quot;fu&quot;&gt;getPropertyValues&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;addPropertyValue&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;protocol&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RuntimeBeanReference&lt;/span&gt;(id));
  } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ServiceBean.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(beanClass)) {
    &lt;span class=&quot;co&quot;&gt;// ... 省略中间代码&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 如果dubbo:service配置class属性，将ref属性设置为class属性对应的bean&lt;/span&gt;
    beanDefinition.&lt;span class=&quot;fu&quot;&gt;getPropertyValues&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;addPropertyValue&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ref&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanDefinitionHolder&lt;/span&gt;(classDefinition, id + &lt;span class=&quot;st&quot;&gt;&quot;Impl&quot;&lt;/span&gt;));
  } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ProviderConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(beanClass)) {
    &lt;span class=&quot;co&quot;&gt;// 解析dubbo:provider包含的子标签&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;parseNested&lt;/span&gt;(element, parserContext, ServiceBean.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;service&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;provider&quot;&lt;/span&gt;, id, beanDefinition);
  } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ConsumerConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(beanClass)) {
    &lt;span class=&quot;co&quot;&gt;// 解析dubbo:consumer包含的子标签&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;parseNested&lt;/span&gt;(element, parserContext, ReferenceBean.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;reference&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;consumer&quot;&lt;/span&gt;, id, beanDefinition);
  }
  &lt;span class=&quot;co&quot;&gt;// ... 省略中间代码&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 下面的代码就是解析bean属性(比如：parameters、registry等)添加到beanDefinition中&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;dubbo自定义标签都是需要实例化的bean，所以dubbo解析自定义标签的主要工作就是讲bean定义注册到容器中，等getBean（或者依赖解析）的时候进行实例化。&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 15:23:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/8053867.html</dc:identifier>
</item>
<item>
<title>入职一周 - SAP梦心</title>
<link>http://www.cnblogs.com/saper/p/8045300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saper/p/8045300.html</guid>
<description>&lt;p&gt;      很意外的是我又一次跳槽了，而且是在一年内经历了三家公司。相对其他同事朋友而言，频繁更换工作环境使得我的经历其实更加丰富，见识到了很多的项目，不管是烂项目也好，优秀的项目也罢，都使我眼界大开，积累不少经验和教训；同时也见识到了三家不同企业的信息化建设程度，不管是信息化沙漠也好，稳健庞大的信息化架构也好，也都是我从业经历的一次“体验”，虽然过程不少坎坷，也见识到了一些奇葩的人，但至少我现在是幸运的。&lt;/p&gt;
&lt;p&gt;      因为经历过一次奇葩的企业和奇葩的管理，所以现在跳槽我特别关心企业文化以及所在部门的架构、人员组织以及人事制度。跳槽之前还有点担心，毕竟目前压力缠身，有房贷压着，也不敢太张扬。&lt;/p&gt;
&lt;p&gt;      J公司其实早在一年前人事就有联系过我，那时候是想让我去总部做SAP SD模块的高级主管，只是可惜的是远离大城市，我就没有答应。&lt;/p&gt;
&lt;p&gt;      J公司人事第二次联系我已经是我在厦门入职H公司半年之后。恰好J公司那边新上任CIO，大刀阔斧做了很多改革和人员精简策略，需要招一些高级项目主管，因此又一次找到我。虽然这一次岗位工作在厦门，但毕竟在H公司里环境还不错，同事也彼此比较和睦，领导也比较靠谱，所以我也就没再继续下去。&lt;/p&gt;
&lt;p&gt;      当J公司人事再一次联系我的时候已经是接近年底了，这个时候我心境也有所变化，虽然被提拔为SAP项目的负责人，但还是觉得目前工作岗位已经远远不能满足我的挑战欲望，所做的工作也都是价值度不高的事儿，当然最主要的是忍受不了作为主管的我薪资待遇远不如我的下属（可以理解为公司薪资制度不合理和领导不了解SAP行情）。后来也跟领导提了加薪的事儿，但最终给我的加薪幅度还是远没有达到我的要求。因此J公司人事联系我也就是水到渠成的感觉了。&lt;/p&gt;
&lt;p&gt;      于是乎周一初步电话沟通，周二当面面试，周三人事做背调，周四我确认意向，周五就谈薪完成定Offer了。&lt;/p&gt;
&lt;p&gt;      给领导提离职，还是让他大吃一惊，虽然极力挽留，给各种诱惑和提薪，但我去意已决。现在提离职就已经不是为了加薪了。交接工作整整持续了一个月，直到我离职的时候接我岗位的人还没入职，领导没办法只好交接给一个SAP开发人员。基本上把我会的，所负责的，各种问题点都已经交接的很清楚，该说的和不该说的，又是录屏又是整文档，甚至手把手教，但他们还是很难入门。&lt;/p&gt;
&lt;p&gt;      不得不感慨一句：&lt;span&gt;纯开发而不懂业务的人根本没有竞争力&lt;/span&gt;！&lt;/p&gt;
&lt;p&gt;      然而，不管怎么说，还是很感谢H公司，我会很怀念在H公司的日子。SO，再见了，美丽的五缘湾；再见了，坑货的ICC；再见了，和睦的同事；再见了，HXPP；&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;第一天：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      这是我第一次碰到入职时间是在下午2点的公司。准时到国金大厦B栋，前台登记之后就到人事所在的楼层。办公环境比较简洁空旷，也算是我理想中高级办公环境的样子。不过我还要在软件园办公半个月才会搬来这里。跟人事简单说明来意，人事MM让我先坐着等一会儿。我顺便看看手机帮H公司处理一下工作的事儿。差不多半个小时后，人事MM才开始处理我的入职。原以为我需要写N次姓名和身份证号，没想到才写了5次而已，整个过程非常简单清爽，连基本的人事制度培训都没有。后来才知道每个月公司都会有新员工入职培训，地点在泉州总部，今天只是简单做人事系统的数据录入。&lt;/p&gt;
&lt;p&gt;      完事儿之后就去软件园二期的办公地，骑自行车也就10分钟不到，相当近。到48号楼8层，先让之前的Leedarson同事——爷帮我带到所在的部门。恰好领导和同事们都在，大家简单围在一起互相介绍一下，这就算是我到新环境的“开门红”了。办公桌和电脑已经准备好了，空间比较狭小，自然比不上在H公司那个宽广明亮，但想到在这里只需要10天工作日，也就罢了。电脑配置也不会太差，硬盘居然是三星512G SSD，虽然内存只有4G，但整体而言不会太低端。&lt;/p&gt;
&lt;p&gt;      领导安排坐我右边的一个小姑娘引导我快速进入工作状态，除了一些基本的文档，我也咨询了很多关于项目的架构、流程、业务等问题，虽然她并不是全部都明白，涉及到开发以及更详细的她也不清楚，不过小姑娘才毕业一年，有这样的业务能力和造诣其实比我当年强许多了，由衷赞许之！&lt;/p&gt;
&lt;p&gt;      18：00准时下班，才发现软件园东二门非常多的人搭公交车，回住处的公交车基本上挤不上去。我就干脆骑自行车回去，骑到半路我就后悔了，很远也很冷，而且很多路并没有设立自行车道，基本上在跟汽车抢路，极其危险。差不多折腾了40分钟才到家里，看来以后得坐车方便。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;第二天：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      今天上班的时候坐的是641，绕来绕去到软件园东二门的时候已经是快接近八点了，都怪路上绕而且堵车太严重了。好在快速上楼，赶在8点之前刷指纹。这几天基本上没有什么任务，我除了看文档熟悉项目之外，也开始着手处理一些异常。项目可以说已经上线了，在一些门店做试点，目前处于前期运维阶段。一整天下来也就一个问题，项目稳定性没话说，异常很少，用户的问题也很少，而且数据基本上都正确。所以说一个好的项目管理以及实施过程是多么的重要。悲催的是我发现SAP系统里面我什么权限都没有，碰到问题要查的时候老是提示没权限。以前H公司的时候我是SAP_ALL，想怎么玩就怎么玩，到了这里就水土不服了。好在总部SAP团队我有人，处理事情起来比较顺手。接下来是要开始申请一些该有的权限了。&lt;/p&gt;
&lt;p&gt;      中午就在公司外面吃饭，软件园果然人员众多，吃饭都要排队很久。我也很快跟左右两个同事打成一片，都是小年轻人，比较好相处。新到一个公司作息习惯肯定没有之前那么顺了，至少中午休息的折叠床现在还没有搬过来，等公司搬到国金的时候再看看弄过来睡吧。&lt;/p&gt;
&lt;p&gt;      下午也依旧在处理问题点和到国金安装会议电视，估计下周会做项目的模拟吧。&lt;/p&gt;
&lt;p&gt;      下班走软件园西门，坐105路，也是满车都是人，不提！&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;第三天：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      基本上这天也没啥特别的，路上一样人挤人，也是踩着点刷卡。不过今天也听同事们瞎聊闲谈过往公司信息化部门的一些演变历史和故事，每家公司都会有很精彩的IT故事，J公司也不例外。我深深觉得上级领导虽然不苟言笑，但对工作有非常严格的要求，同时做项目也是非常厉害，经手的项目都运行得很好，在信息部也是德高望重很有威望，是一个不错的领导。&lt;/p&gt;
&lt;p&gt;      意外发现公司这里权限卡控非常的严格，比如外网权限，QQ和微信等都要OA申请，然后经过信息副总裁级别的人审批，而且他老人家审批不是随便审批的，需要有充分的理由。我个人觉得权限管理是一定要的，特别是外网等，但这个应该只是仅对其他非信息化的部门，而信息部是一定要有外网权限的，毕竟设计到技术和业务往往需要通过外网来查阅资料，甚至也不乏跟网友沟通交流。我很难想象没有外网的工作会有多大的阻碍，作为信息副总裁，一个CIO不应该不知道这个道理。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;第四天：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      今天也算是对SAP VC有了非常大的了解，早在之前我就有了解过，不过在这里我就又更深入一步，也感慨一些地方的设置居然可以做到这样子灵活，再次感慨一句：&lt;span&gt;SAP真不愧是世界第一的ERP，没有之一。&lt;/span&gt;如果换做其他比如渣渣友，渣渣碟和渣渣捷不知道会是什么后果。这种认识进一步让我深深觉得之前很多的选型，很多的说辞对SAP的抨击和质疑都化为深深的可笑，哪些所谓用户体验，UI不美观的说法在这些面前简直不堪一击。所以说，要做ERP就一定做SAP，否则就别做。经历过SAP系统的人再去接触其他ERP会分分钟让人觉得恶心！&lt;/p&gt;
&lt;p&gt;      部门同事算起来大概10个，总部一个，成都一个，剩下的都在厦门。彼此又因工作的不同分了一些组，居然还有2个PLM高级应用工程师，刚刚选型结束，本以为会用SAP PLM的产品，最终选了西门子的TeamCenter，传说中是PLM全世界第一。哈哈，都是全世界第一，整个信息化建设就很好玩了，空间十足！      &lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;第五天：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      这个算是我在J公司的第一周最后一天。今天也没有什么要紧的事儿，就是确定了下周一去总部测试信用额度接口的事儿，领导特意交代要多测试，多考虑几种场景，我想，发挥我的价值的机会来了，这是我最擅长的工作。小姑娘这一周对我甚是照顾，在很多工作内和外的细节上对我知无不言言无不尽。同时今天我也见到了传说中的CIO，简单开了一下会，我也意外才发现我们这个项目蓝图虽然出来了，也如今都试点上线了，但蓝图都还没签核完成。CIO只是过了一下蓝图文档，也对签核的事儿特别在意，一直嘱咐要如何如何，其实站在他的角度上看，理应如此。&lt;/p&gt;
&lt;p&gt;      之前听同事们说部门活动极少，恰好我刚来不到一周就碰到难得的一次小活动，计划与下周日到双龙潭旅游。想到8月份在H公司才去一趟，纯烧烤的活动（正是上次双龙潭之行，为我后面离开H公司买下伏笔）。本来我是建议去大嶝岛的，不过“寡不敌众”，大家都选择双龙潭了，只好做罢。&lt;/p&gt;

&lt;p&gt;      以上大概就是简要的《入职一周》，整体而言我还是挺满意的，不得不说这是一家跟立达信集团很相似的企业，信息化完备，领导也足够重视。我想，我会努力一直坚持下去，在这边好好工作，不会随意跳槽了，毕竟有成本有压力，能够在一家喜欢的企业长长久久做下去就是一种新年了。到了我这个年纪，是时候考虑安稳下来了。 &lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 15:21:00 +0000</pubDate>
<dc:creator>SAP梦心</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/saper/p/8045300.html</dc:identifier>
</item>
<item>
<title>NGUI_Button - 张三疯_1998</title>
<link>http://www.cnblogs.com/zhh19981104/p/8053861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhh19981104/p/8053861.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;十、按钮，Button&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、按钮的核心作用：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;按钮能够接收单击并触发响应事件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;按钮单击时能同时触发多个响应事件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;按钮可以有普通、悬停、单击、禁用等多个状态的不同表现&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;广泛的说，按钮的核心在于接收事件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、创建按钮：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;创建一个sprite，这个sprite将会是按钮的外形&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;选中这个sprite，然后为其添加Boxcollier,附加ButtonScript&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在Sprite的子节点上添加Laber，用来显示按钮的内容&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;【注意】：Laber的深度要高于这个按钮的深度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小提示：创建出来的Sprite记得单击Snap，让他回归到原尺寸大小，然后再去进行调整。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、参数解释：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171217225956968-63667238.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（1）、Tween Target:动画目标， 默认就是按钮自己&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）、DragOver：拖动结束事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）、Transition:过渡时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）、Color:颜色模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）、Sprites:精灵设置模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）、OnClick：按钮响应单击事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、制作按钮的放缩动画;当我们单击按钮时，按钮会有一个放缩动画&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）、在按钮上添加ButtonScale脚本&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171217230648124-37306810.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;TweenTarget：控制的动画作用的目标&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Hover:当鼠标划过的时候，按钮控件的大小变化&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Pressed；当按钮按下的时候，按钮控件的大小变化&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Duration：完成缩放动画的时间&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注意：ButtonScale只适用于为按钮制作动画&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5、制作按钮的偏移动画：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在按钮上添加ButtonOffset&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171217231233655-1111951987.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;Hover:按钮在鼠标滑过的时候的位置偏移&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Pressed:按钮在按下的位置偏移&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Duration；持续时间&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6、制作按钮的旋转动画&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在按钮上添加ButtonRotation&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171217231525733-65078337.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7、添加按钮单击音效&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在按钮上添加PlaySound&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171217231558436-998522618.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;AudioClip:音效的源文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Trigger：触发模式    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Volume：声音大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Pitch;音调&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 17 Dec 2017 15:21:00 +0000</pubDate>
<dc:creator>张三疯_1998</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhh19981104/p/8053861.html</dc:identifier>
</item>
<item>
<title>Python--Pycharm backup_ver1.py 控制台一直Backup FAILED - ~茶~</title>
<link>http://www.cnblogs.com/lsgcoder101/p/8053767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsgcoder101/p/8053767.html</guid>
<description>&lt;p&gt;1、windows不自带zip，需自行安装，http://gnuwin32.sourceforge.net/packages/zip.htm&lt;/p&gt;
&lt;p&gt;2、安装后，要配置环境变量：PATH&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/572296/201712/572296-20171217224315874-354566748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、简明Python教程 （A Byte of Python）中的 &lt;span&gt;backup_ver1.py&lt;/span&gt; 代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import os
import time

#1、需要备份的文件与目录将被指定在一个列表中。
#windows下
source = ['&quot;C:\\My Documents&quot;','C:\\Code']
#这里要注意，我们必须用双引号括住字符串，因为字符串中有空格。

#2、备份文件必须存储在一个主备份目录中
#windows下
target_dir = 'E:\\Backup'

#3、备份文件将打包压缩成 Zip文件。
#4、zip压缩文件的名字由当前日期与时间构成。
target = target_dir + os.sep + \
        time.strftime('%Y%m%d%H%M%S') + '.zip'

#如果目标目录还不存在，则进行创建
if not os.path.exists(target_dir):
    os.mkdir(target_dir) #创建目录

#5、我们是用 zip命令将文件打包成zip 格式
zip_command = 'zip -r {0} {1}'.format(target,' '.join(source))

#运行备份
print('Zip command is:')
print(zip_command)
print('Running:')
if os.system(zip_command) == 0:
    print('Successful backup to',target)
else:
    print('Backup FAILED')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、第一次运行的时候，在Pycharm 的输出台显示 Backup FAILED，并且伴有乱码，如下：&lt;/p&gt;
&lt;p&gt;'zip' �����ڲ����ⲿ���Ҳ���ǿ����еĳ���&lt;br/&gt;���������ļ���&lt;br/&gt;Backup FAILED&lt;/p&gt;
&lt;p&gt;5、网上查了好久，有的说不要用zip换用winrar、7-zip，有的说Pycharm的字体显示有问题把DE Encoding设置为GBK……等等，都试过（这中间一直没有关闭Pycharm重启），没啥效果。&lt;/p&gt;
&lt;p&gt;6、最后我烦了，就重启一个Pycharm，结果好了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/572296/201712/572296-20171217225231639-261352447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、不知道到底什么原因，一起琢磨吧！哈哈。。。&lt;/p&gt;
&lt;p&gt; 8、有一个疑问：有一次我选了如下图中的方式运行“Run File in Console”，结果就一直这样显示，关闭页面、重启Pycharm都没办法恢复原来的样子了，谁知道怎么办吗？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/572296/201712/572296-20171217225646858-1545188921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 17 Dec 2017 14:59:00 +0000</pubDate>
<dc:creator>~茶~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsgcoder101/p/8053767.html</dc:identifier>
</item>
<item>
<title>深度解剖sesssion运行原理 - 谢灿勇</title>
<link>http://www.cnblogs.com/st-leslie/p/8016951.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/st-leslie/p/8016951.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;已经大半年没有更新博客了，一方面有比博客更重要的事情要做，另外一方面也没有时间来整理知识，所以希望在接下来的日子里面能够多多的写博客来与大家交流&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt; session的官方定义是：Session:在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 说白了session就是一种可以维持服务器端的数据存储技术。session主要有以下的这些特点：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 1. session保存的位置是在服务器端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2. session一般来说是要配合cookie使用，如果是浏览器禁用了cookie功能，也就只能够使用URL重写来实现session存储的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3. 单纯的使用session来维持用户状态的话，那么当同时登录的用户数量较多的时候，或者存在较多的数量的session会导致查询慢的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 本质上：session技术就是一种基于后端有别于数据库的临时存储数据的技术&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt; &lt;span&gt;主要的一个原因就是HTTP的无状态性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 因为HTTP的无状态性，所以我们没有办法在HTTP发送请求的时候知道当前用户的状态，也就是比如说，当前是哪个用户的之类的这种信息，所以这个时候我们需要session来标识当前的状态&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;  接下来，通过一个模拟用户登录的流程图来初步理解session的原理，假设这个时候用户执行登录操作，具体的session工作流程如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201712/728493-20171210220932833-1983507345.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整个流程大概分成这样的几步：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 第一步将本地的cookie中的session标识和用户名，密码带到后台中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 第二步后台检测有没有对应的session标识，我们以php为例，那么就是检测有没有接收到对应的PHPSESSID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 没有的话直接生成一个新的session。有的话，检测对应的文件是否存在并且有效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 失效的话，我们需要清除session然后生成新的session。不失效，使用当前的session&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到这里你可能对session的工作原理有一个初步的理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;session的原理图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201712/728493-20171214234412685-1231684016.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 我们这里以PHP为例来讲解一下关于session的配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 首先我们要在PHP的安装目录下面找到php.ini文件，这个文件主要的作用是对PHP进行一些配置，具体以后涉及到再详讲。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  1. 设置session存放在cookie中中标识的字段名，php中默认为&lt;/span&gt;PHPSESSID&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  对应的设置为：&lt;/span&gt;session.name = PHPSESSID&lt;/p&gt;
&lt;p&gt; &lt;span&gt; 2. 如果客户端禁用了cookie，可以通过设置&lt;/span&gt;&lt;span&gt;session.use_trans_sid来使标识的交互方式从cookie变为url传递&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;对应的设置为： session.use_trans_sid = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;3. 设置session的保存位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  对应的设置是&lt;/span&gt;&lt;span&gt;session.save_path=&quot;D:\phpStudy\PHPTutorial\tmp\tmp&quot;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; &lt;span&gt;首先我们需要安装wamp或者是phpstudy,具体方式自行百度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 为了方便观察session文件的变化，我们需要找到session的保存路径（在php.ini中找到session.save_path），如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201712/728493-20171216201800218-1407920688.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 然后找到所指向的目录，注意一般来说session是使用files的形式来保存的，但是我们也可以根据自己的实际情况进行修改。我们可以在php.ini文件中进行修改和查看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201712/728493-20171216202116405-884878502.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;使用session的第一步，我们要打开session，使用session_start(),然后我们给创建的session添加一个变量，我们假设为demo1,值为default ,代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by PhpStorm.
 * Date: 2017/12/16
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;session_start&lt;/span&gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开session&lt;/span&gt;
&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;demo1&quot;] = &quot;default&quot;&lt;span&gt;;
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;执行效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201712/728493-20171216232943999-1642685580.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 打开对应的文件，里面的内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201712/728493-20171216233928421-1379947311.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; s:7 表示的是类型为string类型，长度为7个长度的字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 如果我们对session中的内容进行重新编辑的话，效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201712/728493-20171217000337530-57316042.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 我们观察最近一条的修改日期，我们可以发现就是日期发生了变化，但是文件名没有变化，也就是说，修改session中的内容不会导致文件被新建，而是执行对文件的重新写入操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;span&gt;session的销毁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 销毁session一般有两种方式，unset和session_destroy，我们先来说说第一种&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by PhpStorm.
 * Date: 2017/12/16
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;session_start&lt;/span&gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开session&lt;/span&gt;
&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;demo1&quot;] = &quot;default_1&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;session的销毁&lt;/span&gt;
&lt;span&gt;unset&lt;/span&gt;(&lt;span&gt;$_SESSION&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这一个相当于没有删除session文件，但是使得即使有对应的PHPSESSID也无法获取到相应的session&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;session_destroy()相对来说比较彻底，直接删除对应的session文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by PhpStorm.
 * Date: 2017/12/16
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;session_start&lt;/span&gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开session&lt;/span&gt;
&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;demo1&quot;] = &quot;default_1&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;session_name&lt;/span&gt;&lt;span&gt;());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;session的销毁&lt;/span&gt;
&lt;span&gt;session_destroy&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;运行的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201712/728493-20171217001749858-1981812993.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于个人来说比较推荐使用第二种方法，因为当要销毁session的时候，那么也就意味着session已经失效了，所以这个时候我们把它给删掉才是最好的处理方式，一方面可以减少对硬盘的存储，另外一方面可以相对优化session的查询速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 好了，这个时候我们应该要设置传递给浏览器端的cookie了,默认是自动传送，但是我们应该要学习的是怎样通过后端设置cookie过去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中有两个方法与session有关的方法我们需要记住，第一个是session_name()，这个是获取cookie的key值得，第二个是session_id，这个是session的文件名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置的示例代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by PhpStorm.
 * Date: 2017/12/16
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;session_start&lt;/span&gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开session&lt;/span&gt;
&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;demo1&quot;] = &quot;default_1&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;setCookie&lt;/span&gt;(&lt;span&gt;session_name&lt;/span&gt;(),&lt;span&gt;session_id&lt;/span&gt;(),&lt;span&gt;time&lt;/span&gt;()-1000&lt;span&gt;);
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;在设置cookie的时候，我们为了程序的安全性，我们应该要禁止JS可以对cookie进行重写，所以需要设置HTTP ONLY，具体的设置方法在Php.ini中找到session.cookie_httponly&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后将其的值设置为1或者true即可&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除此之外还可以通过setCookie和ini_set()来动态设置HTTPONLY属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在使用session的时候，虽然会从浏览器把PHPSESSID传给后端，但是这个课程不需要人为的去参与。我们只需要保证HTTPONLY被设置就行了。下面是完整的代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by PhpStorm.
 * Date: 2017/12/16
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;session_start&lt;/span&gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开session&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$_SESSION&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;demo1&quot;&lt;span&gt;]);
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;demo1&quot;] = &quot;default_&quot; . &lt;span&gt;time&lt;/span&gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$_SESSION&lt;/span&gt;[&quot;demo1&quot;&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;setCookie&lt;/span&gt;(&lt;span&gt;session_name&lt;/span&gt;(), &lt;span&gt;session_id&lt;/span&gt;(), &lt;span&gt;time&lt;/span&gt;(), &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;&lt;strong&gt; &lt;span&gt;1. 关闭浏览器session同样存在&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 如果我们没有人为的去设置cookie的生命周期的时候默认关闭浏览器session的状态是无法被保存下来的，因为没有设置cookie的生命周期，默认这个时候cookie为session cookie也就是在会话存在的时候cookie才有效，所以关闭浏览器cookie失效，导致后端拿不到对应的PHPSESSID,所以无法找到对应的session文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.  session性能瓶颈怎样解决？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是后端存在大量的session的时候，那么这个时候就会出现性能的瓶颈，例如：当后端同时存在有5000个session文件的时候，假设要找的文件是在第4999个，那么也就是说前面至少需要遍历4998次，这样就会浪费过多的时间在后端的循环遍历查找文件中，所以这个时候最有效的方法是使用redis或者mongodb,原理是通过将原本保存在本地的session文件写入到内存中，通过内存换空间的形式来达到提升速度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 一般不使用URL重写的方法来传递PHPSESSID&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中主要有两个原因，一个是URL重写方式传递的话会导致URL混乱，影响美观。另一个是增大了用户误操作的几率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多的session的相关配置请点击&lt;a href=&quot;http://blog.51cto.com/cmdschool/1714757&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;blockquote readability=&quot;51&quot;&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;[Session]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.save_handler = files &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.use_cookies= 1 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.use_only_cookies = 1 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.name = PHPSESSID &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.auto_start = 0 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.cookie_lifetime = 0 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.cookie_path = / &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.cookie_domain = &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.cookie_httponly = &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.serialize_handler = php &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.gc_probability =1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.gc_divisor =1000 &lt;/code&gt;&lt;/p&gt;


&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.gc_maxlifetime =1440 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.bug_compat_42 = off &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.bug_compat_warn = off&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.referer_check = &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.entopy_length = 0 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.cache_limiter = {nocache,private,pblic} &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.cache_expire = 180 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.use_trans_sid = 1 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.hash_function = 0 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.hash_bits_per_character = 5 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;bash plain&quot;&gt;session.save_path = &lt;/code&gt;&lt;code class=&quot;bash string&quot;&gt;&quot;/var/lib/php/session&quot;&lt;/code&gt; &lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 17 Dec 2017 14:48:00 +0000</pubDate>
<dc:creator>谢灿勇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/st-leslie/p/8016951.html</dc:identifier>
</item>
<item>
<title>DDD峰会归来话DDD - 张逸</title>
<link>http://www.cnblogs.com/wayfarer/p/2017-ddd-submit-china.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wayfarer/p/2017-ddd-submit-china.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/526/201712/526-20171217215138780-484251651.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一场大戏落幕，首届DDD中国峰会如大会主题色一般的红。或许在12月9日这一天，全中国的DDD粉丝大约有一半都汇聚在了国家会议中心。听起来是幸，其实是不幸，因为DDD在中国的人群基数实在是太少了。&lt;/p&gt;
&lt;p&gt;因为要负责大会的其中一个Track，期间又要接受采访，另外还有朋友到访，所以除了前面的两个keynote以及我自己的session（这是当然的），我没有完整听完一个session。然而单单是和DDD大咖、专家与爱好者们交谈，已经受益匪浅了。参会归来，关于DDD的idea产生了许多，我觉得有必要和DDD谈谈我的想法。&lt;/p&gt;
&lt;h4 id=&quot;ddd是什么&quot;&gt;DDD是什么&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/526/201712/526-20171217215234796-1890122407.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正如Alberto在keynote中提到，DDD不是架构。我赞同这一观点，并一直认为DDD是一种方法论（Methodology）。根据维基百科：Methodology is the systematic, theoretical analysis of the methods applied to a field of study，DDD正是针对软件领域提供的系统与理论分析方法。Eric在创造性地提出DDD时，实则是针对当时项目中聚焦在Data（主要是DB Schema）为核心的系统建模方法的批判。这种面向数据的建模方式无法应对日渐复杂的业务逻辑，也无法更好地应用当时正沸沸扬扬的OO设计思想。这是&lt;strong&gt;设计观念的转变，蕴含了全新的设计思想、设计原则与设计过程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;坦白说，Eric Evans的DDD奠基之作《Domain-Driven Design》并没有非常清晰的系统脉络，战略设计与战术设计也未成体系。Eric创造了一堆新奇的概念，隐隐中确乎有一条围绕“领域”进行设计的思想主线，但对整个设计过程的描述却是不清晰的。结构上，我更认同Vaughn Vernon一书《Implementing Domain-Driven Design》，该书清晰地给出了从战略设计到战术设计的设计过程。&lt;/p&gt;
&lt;p&gt;我在和ThoughtWorks的余丹妮聊到DDD时，我吐槽说Eric的DDD其实没有解决三个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何进行领域建模&lt;/li&gt;
&lt;li&gt;如何识别Bounded Context&lt;/li&gt;
&lt;li&gt;如何在战术层面寻找对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;余丹妮则认为DDD不是架构（设计）方法，因此不能把每个设计细节具象化。DDD是一套体系，这就决定了它必须具有开放性，在这个体系中你可以用任何一种方法来解决这些问题。我深表赞成，却也认为这些关键问题如果没有具体落地的方法，可能会让团队无可适从。这其实也是DDD在许多项目中难以推行的部分原因。&lt;/p&gt;
&lt;h4 id=&quot;edd&quot;&gt;EDD&lt;/h4&gt;
&lt;p&gt;Alberto是EventStorming的创始人，他在keynot中强调建模应该专注于event。EventStorming方法贯穿了DDD整个设计过程，包括Ubiquitous Language、Bounded Context等战略设计的元素，也能沉入战术设计中，以Event作为主要的设计驱动力。&lt;/p&gt;
&lt;p&gt;在聆听Alberto的演讲时，我突然想到这种&lt;strong&gt;以领域事件作为设计驱动力的思想&lt;/strong&gt;会否走出另一条不同的路（分支）。我之前在《或许是领域建模的真相》中模糊提到这样的思想，例如针对事件建模，实则是对业务流程以“状态机”形式进行建模。状态的迁移，就是command或者decision对event的触发。&lt;/p&gt;
&lt;p&gt;如果我们再将event视为一种不可变、可追溯的消息，那么DDD社区提出的许多知识都可以围绕着event进行设计，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EventStorming&lt;/li&gt;
&lt;li&gt;Event Sourcing&lt;/li&gt;
&lt;li&gt;CQRS&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;考虑event的不变性与消息的本质，我们还可以将如下内容引入：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Functional Programming&lt;/li&gt;
&lt;li&gt;Reactive Programming&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么我们是否可以提出Event Driven Design的设计概念呢？与EDA（Event Driven Architecture）不同，EDD算是DDD的一种分支，是一种设计方法学，涵盖了战略设计与战术设计等多个层次。而它与传统DDD的区别在于&lt;strong&gt;建模思想与编程泛型&lt;/strong&gt;的不同。&lt;/p&gt;
&lt;h4 id=&quot;微服务拯救ddd&quot;&gt;微服务拯救DDD&lt;/h4&gt;
&lt;p&gt;我说“微服务拯救了DDD”，其实是对肖然说的一句戏言，并不准确。在诸多社区力量的贡献中，DDD一直都在生长，在DDD提出来的十五个年头，不仅没有走入老年期的落寞，反而在每年都生长出不同的嫩绿新叶。既然DDD没有衰亡，何谈拯救？然而，不可否认的是因为微服务的火热，让DDD这种缓慢生长的态势突然焕发了勃勃的生机，就好像给这棵大树注入了生长剂一般，一下子开枝散叶。凡微服务所及之处，皆可见DDD的身影。这就造成了微服务拯救DDD的错觉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/526/201712/526-20171217215348280-326537217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在演讲《Bounded Context的实践意义》中提及了六边形、限界上下文与微服务之间的关系，这里不再赘述。但肖然的《为不确定性架构》演讲提及了微服务保证了系统的simplicity，却让我浮想联翩。&lt;/p&gt;
&lt;p&gt;对于架构，我一直强调对系统复杂性的应对。我曾经在十月份的一个会议上分享过《如何应对架构的高复杂度》，内容其实来源于我对复杂系统思考所撰写的一篇文章。我从理解力与预测能力两个角度剖析软件系统的复杂度。这个思考角度实际来自Jurgen Appelo对复杂系统理论的阐释。Jurgen Appelo将Complicated与Complex分别放在理解力与预测能力两个迥然不同的维度。Complicated与Simple（简单）相对，意指&lt;strong&gt;非常难以理解&lt;/strong&gt;，而Complex则介于Ordered（有序的）与Chaotic（混沌的）之间，认为&lt;strong&gt;在某种程度上可以预测，但会有很多出乎意料的事情发生&lt;/strong&gt;。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/526/201712/526-20171217214055796-572284245.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统的规模与结构会干扰我们对系统的理解，而需求的变化则是我们无法预测的。那么，微服务是怎么应对系统复杂度的呢？核心思想是“分而治之”，它从系统规模着手，将一个大的系统拆分为一个个细粒度的服务。即使不考虑拆分的合理性，我们也可以看到它虽然控制了规模带来的复杂度，却加强了结构的复杂性。&lt;/p&gt;
&lt;p&gt;个人认为，微服务对simplicity的保证，实则是将业务复杂度转移到了技术复杂度。显而易见，每个微服务的业务是非常简单的，代码易于理解和维护，也可以非常容易地进化乃至于替换。当我们需要开发和维护多个微服务时，如何管理和监控服务，如何梳理服务之间的通信，如何保证数据的一致性（最终一致性），都来自技术层面的挑战。&lt;/p&gt;
&lt;p&gt;这种复杂度的转移为何能得到多数人的认同？针对IT人员，它其实基于两个前提：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;业务是不可控的，技术却相对可控：相对于技术，业务对变化更加敏感，我们也无法正确地预测业务的变化&lt;/li&gt;
&lt;li&gt;技术的复杂性可以通过分工来解决：多数应用开发公司可以重用微服务的平台、框架或工具，然后集中精力来对付业务；降低了业务复杂度，就等同于降低了整个系统的复杂度&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;ddd的未来&quot;&gt;DDD的未来&lt;/h4&gt;
&lt;p&gt;在接受会议主办方的采访时，希望我能给DDD打call。那么DDD重要吗？非常重要，但它确实不是“银弹”。正如前面所述，DDD其实一直在生长。由于没有任何一家商业化公司推动DDD，它反而没有受到利益关系的干扰，虽然生长缓慢，但却健康。DDD以“领域”为核心，只要软件系统仍然还在处理“领域”，理论上DDD就有其生存的空间。如果我们不把DDD具象化（正如前面所说），它就可以成为一个不错的“框”，凡是和“领域”相关的理论、方法、实践与模式，都可以往这个框里塞。&lt;/p&gt;
&lt;p&gt;倘若能一直&lt;strong&gt;保持DDD的开放性，保持DDD的独立性&lt;/strong&gt;，我觉得在未来的五年乃至十年，DDD仍将焕发生命力，只是它的面貌会更加多姿多彩，甚至超过Eric Evans对DDD的原初定义。毕竟，软件系统的核心只有两个：领域和算法。也许，只有到了AI算法能把领域开发的职责都能揽过去，DDD才不会存在了，因为那时候已经没有了领域，只剩下了算法。&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 13:51:00 +0000</pubDate>
<dc:creator>张逸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wayfarer/p/2017-ddd-submit-china.html</dc:identifier>
</item>
<item>
<title>underscore源码解析（一） - liuyongjia</title>
<link>http://www.cnblogs.com/liuyongjia/p/8053489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyongjia/p/8053489.html</guid>
<description>&lt;h2 id=&quot;留存root&quot;&gt;留存root&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// Establish the root object, `window` (`self`) in the browser, `global`&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// on the server, or `this` in some virtual machines. We use `self`&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// instead of `window` for `WebWorker` support.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; root &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; self &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'object'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; self &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; self &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; global &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'object'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;global&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; global &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; global &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;{};&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// Save the previous value of the `_` variable.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; previousUnderscore &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;root&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// .......&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;noConflict&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;root&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; previousUnderscore&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在浏览器情况下，self是window自身的引用。上面的语法主要是为了保证在sever端和服务端都能正常获得根对象。&lt;br/&gt;将root._ 存起来，是为了防止命名冲突。调用noConflict方法，就能把原来的 _ 恢复，然后重新赋值到不冲突的变量上即可。&lt;/p&gt;
&lt;h2 id=&quot;保留原生方法减少变量查询&quot;&gt;保留原生方法、减少变量查询&lt;/h2&gt;
&lt;p&gt;在underscore源码常看到会将一些常用的方法保留起来。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// Save bytes in the minified (but not gzipped) version:&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ArrayProto &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ObjProto &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; SymbolProto &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; Symbol &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'undefined'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Symbol&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt; : &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// Create quick reference variables for speed access to core prototypes.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; push &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ArrayProto&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  slice &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ArrayProto&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  toString &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ObjProto&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  hasOwnProperty &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ObjProto&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;hasOwnProperty&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样做的好处有两个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;减小*.min.js的体积。&lt;/strong&gt; 在压缩时，some.func1只会被压缩成a.func1。如果把一个对象上常用的方法存为一个变量func1，那么压缩后将节省很多字节。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加快变量访问速度。&lt;/strong&gt;&lt;br/&gt;在实际中，点操作符的使用会使得JavaScript引擎检索该对象下的所有成员。如果嵌套越深，那么读取速度越慢，花费时间越久。如果不是该对象的实例属性，引擎甚至要去检索原型链，将更加耗费时间。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;题外话：实际上，为了更好得提高性能，通常将变量保存到局部作用域，检索将会加快。&lt;/p&gt;
&lt;h2 id=&quot;链式调用&quot;&gt;链式调用&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; chainResult &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(instance&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; obj) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 如果_chain为true，则return一个加了链式属性的underscore对象。&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;instance&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_chain&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;_&lt;/span&gt;(obj).&lt;span class=&quot;at&quot;&gt;chain&lt;/span&gt;() : obj&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// Add your own custom functions to the Underscore object.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 可以把自己写的扩展方法通过mixin加入到underscore （_） 上。&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;mixin&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(obj) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;each&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;functions&lt;/span&gt;(obj)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(name) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; func &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; _[name] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; obj[name]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;[name] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; args &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_wrapped&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;push&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;apply&lt;/span&gt;(args&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; arguments)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;chainResult&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;apply&lt;/span&gt;(_&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; args))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; _&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// Add all of the Underscore functions to the wrapper object.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 对underscore使用mixin，可以将全部实例方法挂载到原型上。&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;mixin&lt;/span&gt;(_)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 链式调用方法，不过是加了一个Boolean型开关，来对返回值做判断&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(obj) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; instance &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;_&lt;/span&gt;(obj)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;instance&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_chain&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; instance&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;.mixin方法用来把obj上的方法，都内置到下划线&lt;/em&gt; 上，相当于jquery的extends方法。&lt;br/&gt;此处调用 _ mixin( _ )；实际上，是将 _ 上的方法，都挂载到 _ .prototype上，以便于之后的链式调用。&lt;/p&gt;
&lt;p&gt;再来关注一下 &lt;em&gt;.chain这个方法，调用之后会返回一个underscore对象，并且把该对象的&lt;/em&gt; chain属性赋为true。在chainResult这个方法里，会对当前的这个实例的 _ chain属性进行判断，如果调用了chain方法，就认为接下来会进行链式调用，就会将这个实例包裹之后，继续返回。&lt;/p&gt;
&lt;p&gt;链式调用的关键就在于，&lt;strong&gt;函数return原对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;构造函数&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; _ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(obj) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 如果是underscore的实例，就直接返回obj&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (obj &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; _) &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; obj&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 如果this不是underscore的实例，就new一个新的underscore实例并返回&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; _)) &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;_&lt;/span&gt;(obj)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 将this._wrapped属性置为obj&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_wrapped&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; obj&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意第二步，this的指向，因为如果直接调用 _ 函数，则this指向为window，使用new构造函数，this指向为新创建的对象。&lt;/p&gt;
&lt;h2 id=&quot;一些函数&quot;&gt;一些函数&lt;/h2&gt;
&lt;p&gt;接下来对一些函数做分析。&lt;/p&gt;
&lt;h3 id=&quot;optimizecb&quot;&gt;optimizeCb&lt;/h3&gt;
&lt;p&gt;这个方法是一个优化方法，根剧不同的参数个数，返回不同的调用方式。&lt;br/&gt;好处有三：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;call比apply性能优异，因为apply传入数组，也是用调用底层的CALL方法，可以查看&lt;a href=&quot;http://www.ecma-international.org/ecma-262/8.0/index.html#sec-function.prototype.apply&quot;&gt;ecmascript262规范&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;因为arguments这个类数组对象较为消耗性能，所以不直接使用arguments来做判断。&lt;/li&gt;
&lt;li&gt;绑定上下文。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;isarray&quot;&gt;isArray&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;_&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isArray&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nativeIsArray &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(obj) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;toString&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;call&lt;/span&gt;(obj) &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'[object Array]'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目前判断数组的方法，较为公认的做法就是通过toString，查看是否是[object Array]。在ES5之后，原生带有isArray方法，兼容性不是很完善，IE9之后支持。可以把这个改一下，作为polyfill。&lt;br/&gt;在zepto中的isArray实现稍有不同：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;isArray &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isArray&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(object)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; object &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; Array &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种方法有所区别，zepto的实现在iframe的情况下会有bug，具体参见&lt;a href=&quot;https://www.cnblogs.com/huangxincheng/p/4176860.html&quot;&gt;这篇博客&lt;/a&gt;。&lt;br/&gt;不过由于移动端通常不会使用iframe，所以，不会有特别大的问题。&lt;/p&gt;
&lt;p&gt;...未完待续&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 13:46:00 +0000</pubDate>
<dc:creator>liuyongjia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyongjia/p/8053489.html</dc:identifier>
</item>
<item>
<title>用户中心系统设计 - tylercao</title>
<link>http://www.cnblogs.com/tylercao/p/8053404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylercao/p/8053404.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/524680/201712/524680-20171217212734858-488704267.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;一般来说大型互联网公司会把授权和用户信息的逻辑放到一个应用中，而这个应用我们统一称为用户中心。&lt;/p&gt;
&lt;p&gt;用户中心不关心具体的业务逻辑，只处理用户信息相关的管理及授权登录。当第三方应用需要登录的时候，会把用户的登录请求转发到用户中心处理，处理完毕后，返回给第三方应用，第三方应用根据对应的凭证登录到系统内部。&lt;/p&gt;
&lt;p&gt;主要功能如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户登录与注册&lt;/li&gt;
&lt;li&gt;基本信息查询与修改&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从功能来看，整个用户中心还是很简单单，不过其中的逻辑还挺复杂的，比如注册功能，就要分为手机注册与邮箱注册，手机要发送手机验证码，邮箱需要发送验证邮件，点击邮箱里面的链接跳转并进行后续注册流程，上面每步都需要业务上重新发送机制。&lt;/p&gt;
&lt;h2 id=&quot;功能介绍&quot;&gt;功能介绍&lt;/h2&gt;
&lt;h3 id=&quot;用户登录&quot;&gt;用户登录&lt;/h3&gt;
&lt;p&gt;在互联网用户中心体系中，一般会支持手机、邮箱、帐号、三方登录。其中三方登录一般会接入 QQ、微信、微博这三种方式。&lt;/p&gt;
&lt;h4 id=&quot;密码登录&quot;&gt;密码登录&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1. 用户在浏览器端填写 username + password ，然后提交到服务端
2. 服务端拿到用户提交的 username + password 验证。
3. 验证成功后，服务器返回请求，同时将 cookie 写到对应域&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述流程中，大家肯定会考虑到密码的安全性，我们到底该怎么做才能防止密码被泄露？对称加密还是非对称加密? 如果是对称加密，客户端被黑客反编译，就能拿到密钥，那么所有用户的密码就会存在非常大的泄露风险？如果是非对称加密，私钥要放在哪里才能保证安全？&lt;/p&gt;
&lt;p&gt;通用简单的解决方案: Https + MD5 + 随机盐&lt;/p&gt;
&lt;p&gt;Https 我就不用在述说了，基本上 Chrome、Firfox 都对不是 Https 的站点进行安全提醒，所以 Https 该上的还是尽快上吧&lt;/p&gt;
&lt;p&gt;那如果公司很穷，买不起 Https 证书咋办呢？那么只能在前端页面上做点文章。&lt;br/&gt;由于前端代码暴露在浏览器上，我们只能采用不可逆的密码或者摘要算法，类是与 MD5 / Hash 算法 。如果高级的话，就采用随机 Salt 来提高攻击成本，针对不同用户，加入不同的 Salt，而不是固定盐的方式。使用这种方式的前提「目前对安全的要求不高」&lt;/p&gt;
&lt;p&gt;那我们该如何验证密码？客户端端提交 MD5(password）密码。服务端通过 MD5 (Salt + MD5(passowrd))的逻辑来计算最终密码，同时 Salt 只会出现在服务端，且每个用户采用不同 Salt 的方式来生成。这一系列过程中，都没有接触到原始的用户密码，如果出现用户的密码被劫持的话，只会发生在用户在提交密码前截获，这个也就是为什么需要密码控件？&lt;/p&gt;
&lt;h4 id=&quot;三方登录&quot;&gt;三方登录&lt;/h4&gt;
&lt;p&gt;当用户以某种登录方式成功登录之后，我们能可以获取到对应 User 表中的用户基础信息，而登录操作只是为了认证用户这个过程，无论用本地密码验证还是第三方登录，以上过程本质上都是认证的形式。&lt;/p&gt;
&lt;p&gt;所以用户的信息与登录的授权其实是独立开来的，即 uid 与 登录方式是一对多的关系。比如： 用户 A 使用「微信」登录，服务端认证身份后 uid = abc。而下一次用户 A 使用「微博」登录，同样服务端认证出来 uid = abc。&lt;br/&gt;用户信息表（user_base）只存储用户 Profile 相关信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; id | name | city
----+------+-----------------
 A1 | Tom  | 上海
 A2 | Jack |  背景&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而本地密码验证可以当做一种授权方式，可以称为 local_auth 表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; id | user_id | password
----+---------+----------
 1 | A1      | qazwsx
 2 | A2      | edcrfv&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而通过微博登录就可以视作为另外一种登录方式，称为 weibo_auth 表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; id | user_id | weibo_id | weibo_access_token | weibo_expires
----+---------+----------+--------------------+---------------
 1 | A1      | W-qaz | xxxxxxxxxx         | 604800
 2 | A2      | W-wsx | xxxxxxxxxx         | 604800
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，如果还要增加一种登录方式的话，可以直接添加一直 xx_auth 表来存储用户认证信息，大大提高了我们授权方式的灵活性&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 13:30:00 +0000</pubDate>
<dc:creator>tylercao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tylercao/p/8053404.html</dc:identifier>
</item>
<item>
<title>使用Jenkins自动部署博客 - 青南</title>
<link>http://www.cnblogs.com/xieqiankun/p/deploy_blog_by_jenkins.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieqiankun/p/deploy_blog_by_jenkins.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: 使用Jenkins自动部署博客&lt;br/&gt;toc: true&lt;br/&gt;comment: true&lt;br/&gt;date: 2017-12-17 19:48:10&lt;br/&gt;tags: ['Jenkins', 'CI']&lt;br/&gt;category: ['Jenkins']&lt;br/&gt;---&lt;/p&gt;
&lt;p&gt;这篇文章比较简单，适合初学&lt;code&gt;持续集成&lt;/code&gt;的读者，本文可以帮助你对基于Jenkins的持续集成有一个比较全局的概念。&lt;/p&gt;
&lt;h2 id=&quot;提出问题&quot;&gt;提出问题&lt;/h2&gt;
&lt;p&gt;为了使用HTTPS，我将博客从GitHub Pages迁移到了我的服务器上。由于博客基于Hexo，在迁移之前，我的工作流程是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;本地写Markdown格式文章-&amp;gt;Hexo生成HTML并推送到GitHub-&amp;gt;GitHub Pages自动使用最新内容&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在由于Hexo渲染以后的HTML文件需要放到服务器上，那么工作流程变为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;本地写Markdown格式文章-&amp;gt;Hexo生成HTML并推送到GitHub-&amp;gt;手动登录服务器
-&amp;gt;进入放博客文章的文件夹-&amp;gt;执行命令git pull&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加的两步虽然说操作量不大，但是总显得很麻烦。于是我希望，在我把博客的HTML文件push到GitHub以后，服务器能自动从GitHub上把HTML内容拉下来。由于使用了Nginx，所以只要博客的HTML发生了更新，那么使用浏览器访问&lt;a href=&quot;https://kingname.info/&quot; class=&quot;uri&quot;&gt;https://kingname.info&lt;/a&gt;时，新内容自动就会出现。这样一来，对我来说，看起来就像是我刚刚push了网页内容到GitHub，博客就自动更新了。&lt;/p&gt;
&lt;p&gt;让服务器从GitHub上面拉代码，这个操作本身很简单。人来操作就一行代码&lt;code&gt;git pull&lt;/code&gt;。写个Python脚本也就两行代码。但问题是，服务器怎么知道GitHub发生了更新？&lt;/p&gt;
&lt;p&gt;有人说，Kingname，你不是做爬虫吗？你写个爬虫，每一秒检查一下GitHub不就可以了吗？这种办法当然可以。但问题是，我一周就更新一次博客，但这个爬虫为了等这一次更新，一周要访问GitHub高达604800次？更何况我有时候一个月都不更新。&lt;/p&gt;
&lt;p&gt;所以显然不能让服务器主动检查GitHub更新，这种“轮询”操作效率太低。那么如果反过来，一旦GitHub有更新，它就通知服务器，然后服务器再去拉代码，这不就简单高效了吗？&lt;/p&gt;
&lt;h2 id=&quot;解决问题&quot;&gt;解决问题&lt;/h2&gt;
&lt;p&gt;为了实现这个目的，就需要使用一些持续集成的工具。本文使用的是Jenkins。&lt;/p&gt;
&lt;p&gt;Jenkins在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91&quot;&gt;敏捷开发&lt;/a&gt;界可以说是大名鼎鼎了。使用Jenkins搭建一整套&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html&quot;&gt;持续集成&lt;/a&gt;环境，可以实现开发者往代码仓库一提交代码，代码自动进行单元测试，覆盖率测试，代码风格检查自动生成报告，自动通知部门同事开始Code Review。当代码被合并入主干以后，服务器自动拉下最新代码，自动编译，自动在几千几万台服务器上部署。在整个过程中，开发者只需要做一件事，那就是&lt;code&gt;git push&lt;/code&gt;（当然在实际情况下，后面还会加一些参数）。&lt;/p&gt;
&lt;p&gt;本文实现的是博客的自动部署，没有任何测试，也没有Code Review，也没有编译，服务器也只有一台，复杂程度当然远远低于持续集成。不过管中窥豹，来看看这个简单地流程是如何走通的，对初学者也会有帮助。&lt;/p&gt;
&lt;p&gt;本文假设你已经在服务器上面搭建好了Jenkins环境。如果你还没有安装Jenkins或者不会安装，那么可以“参考”这篇文章：&lt;a href=&quot;https://kingname.info/2016/05/29/raspberryCI-1/&quot;&gt;搭建持续集成环境(一)&lt;/a&gt;。由于这篇文章是18个月以前写的，系统也是小众的Arch Linux，所以建议你还是在网上搜一下最新的Jenkins安装教程比较好。&lt;/p&gt;
&lt;h3 id=&quot;设置github&quot;&gt;设置GitHub&lt;/h3&gt;
&lt;p&gt;在GitHub中进入博客所在的Repo，并点击&lt;code&gt;Settings&lt;/code&gt;，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-23-18.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在设置页面，单击左侧的&lt;code&gt;Integrations &amp;amp; services&lt;/code&gt;，并选择&lt;code&gt;Add service&lt;/code&gt;，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-25-25.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从下拉菜单中，选中&lt;code&gt;Jenkins (GitHub plugin)&lt;/code&gt;。在新打开的界面，填写Jenkins的信息，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-27-06.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;Jenkins hook url&lt;/code&gt;填写的是我的服务器的Jenkins地址加上&lt;code&gt;/GitHub-webhook/&lt;/code&gt;，所以完整的地址为&lt;code&gt;http://xx.xx.xx.xx:8080/GitHub-webhook/&lt;/code&gt;。把这里的&lt;code&gt;xx&lt;/code&gt;换成实际的IP地址或者域名即可。需要注意的是，网址末尾的斜杠一定不能省略。&lt;/p&gt;
&lt;p&gt;填写好信息以后保存，GitHub就配置好了。&lt;/p&gt;
&lt;h3 id=&quot;配置jenkins&quot;&gt;配置Jenkins&lt;/h3&gt;
&lt;p&gt;Jenkins需要安装&lt;code&gt;GitHub Plugin&lt;/code&gt;才能接收到GitHub发来的通知。进入Jenkins的&lt;code&gt;系统管理&lt;/code&gt;-&lt;code&gt;管理插件&lt;/code&gt;，在&lt;code&gt;可选插件&lt;/code&gt;选项卡中，搜索&lt;code&gt;GitHub plugin&lt;/code&gt;并安装，安装完成Jenkins会重启。重启以后可以在&lt;code&gt;已安装&lt;/code&gt;选项卡下面发现&lt;code&gt;GitHub plugin&lt;/code&gt;，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-35-50.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到Jenkins首页，单击左上角&lt;code&gt;新建&lt;/code&gt;按钮，新建一个项目，项目类型为&lt;code&gt;构建一个自由风格的软件项目&lt;/code&gt;。任务的配置信息如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-37-57.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的&lt;code&gt;项目名称&lt;/code&gt;和&lt;code&gt;描述&lt;/code&gt;可以随意填写。勾选&lt;code&gt;GitHub project&lt;/code&gt;，并把博客对应的GitHub Repo的地址填入。往下拉，看到&lt;code&gt;源码管理&lt;/code&gt;，点选&lt;code&gt;Git&lt;/code&gt;，依然填写博客对应的Repo地址。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-39-09.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续往下拉，在&lt;code&gt;构建触发器&lt;/code&gt;单击&lt;code&gt;增加构建步骤&lt;/code&gt;，在弹出的下拉菜单中选择&lt;code&gt;Execute shell&lt;/code&gt;。勾选&lt;code&gt;GitHub hook trigger for GITScm polling&lt;/code&gt;。在&lt;code&gt;Execute shell&lt;/code&gt;对应的输入框中输入命令，将当前目录下的所有文件和文件夹全部复制到&lt;code&gt;/home/bexercise/kingname.github.io/&lt;/code&gt;文件夹下。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-43-09.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，文件夹&lt;code&gt;/home/bexercise/kingname.GitHub.io/&lt;/code&gt;里面的内容如下图所示。这是Hexo生成的HTML文件和资源文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-21-06-45.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要解释一下这一条命令：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; -r ./* /home/bexercise/kingname.GitHub.io/&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的&lt;code&gt;cp -r&lt;/code&gt;表示复制文件和文件夹。&lt;code&gt;./&lt;/code&gt;表示当前目录。&lt;code&gt;./*&lt;/code&gt;表示当前目录下面的所有内容。因此整条命令的意思是把当前目录下的所有内容全部复制到&lt;code&gt;/home/bexercise/kingname.GitHub.io/&lt;/code&gt;下，并且如果文件名相同，就会直接覆盖。需要注意的是，&lt;code&gt;kingname.GitHub.io&lt;/code&gt;这仅仅是一个普通的文件夹而已，别看它的名字长得像个网址，但其实它只是一个名字比较怪的普通文件夹而已，没有什么特殊的意义。&lt;/p&gt;
&lt;p&gt;这个项目在构建的时候，它会自动从GitHub上面对应Repo所有的文件拉取到当前的文件夹下，所以执行了这一条复制命令以后，博客HTML文件自然就被复制到了网站的根目录下。&lt;/p&gt;
&lt;h3 id=&quot;修改权限&quot;&gt;修改权限&lt;/h3&gt;
&lt;p&gt;由于Jenkins在安装的时候，会自动创建一个名为&lt;code&gt;jenkins&lt;/code&gt;的普通账号，这个账号没有管理员权限。jenkins执行命令的时候，它也会使用这个账号。但是由于&lt;code&gt;kingname.GitHub.io&lt;/code&gt;这个文件夹是用户&lt;code&gt;bexercise&lt;/code&gt;创建的，所以&lt;code&gt;jenkins&lt;/code&gt;账号默认是没有权限读写这个文件夹的。现在需要给&lt;code&gt;jenkins&lt;/code&gt;账号授予权限。使用&lt;code&gt;bexercise&lt;/code&gt;这个账号登录服务器，使用以下命令给&lt;code&gt;jenkins&lt;/code&gt;赋予权限，让它可以读写&lt;code&gt;kingname.GitHub.io&lt;/code&gt;文件夹：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; chown -R jenkins:jenkins /home/bexercise/kingname.GitHub.io&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行完成这一行命令以后，jenkins才可以把其他地方的文件复制到这个文件夹里面。&lt;/p&gt;
&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;
&lt;p&gt;没有什么复杂的使用方法，在Hexo中，执行命令&lt;code&gt;hexo d&lt;/code&gt;就可以把本地生成好的HTML文件提交到GitHub中。然后打开浏览器，打开博客，发现新的文章已经出现在首页了。&lt;/p&gt;
&lt;p&gt;在Jenkins项目的执行历史里面，也可以看到它被自动触发而产生的历史记录。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-21-11-50.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;举一反三&quot;&gt;举一反三&lt;/h2&gt;
&lt;p&gt;由于Jenkins可以运行Shell命令，进行单元测试本质上也是运行一条命令，那这不就可以实现自动进行单元测试了吗？那么如果把Shell命令改成运行一个Python脚本，那不就可以做任何事情了吗？如果Python脚本里面写了发送邮件的代码，那不就实现了你一提交代码，其他人就收到邮件了吗？&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 13:26:00 +0000</pubDate>
<dc:creator>青南</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieqiankun/p/deploy_blog_by_jenkins.html</dc:identifier>
</item>
</channel>
</rss>