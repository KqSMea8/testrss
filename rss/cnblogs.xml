<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python smtplib模块实现发送邮件 - 耳听视界</title>
<link>http://www.cnblogs.com/zeshan/p/9566225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zeshan/p/9566225.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;send_mail.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;构造邮件内容 MIMETEXT&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;发送邮件：登录smtp服务器(账号、密码)--发送--关闭链接 smtplib&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; smtplib
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; email.mime.text &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MIMEText
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; email.mime.multipart &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MIMEMultipart
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; email.mime.application &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MIMEApplication

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发送邮件类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SendMail:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,content,subject,from_addr,to_addr,host,pwd,file_name=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;):
        self.content &lt;/span&gt;=&lt;span&gt; content
        self.subject &lt;/span&gt;=&lt;span&gt; subject
        self.from_addr &lt;/span&gt;=&lt;span&gt; from_addr
        self.to_addr &lt;/span&gt;=&lt;span&gt; to_addr
        self.host &lt;/span&gt;=&lt;span&gt; host
        self.pwd &lt;/span&gt;=&lt;span&gt; pwd
        self.file_name &lt;/span&gt;=&lt;span&gt; file_name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; make_multi(self):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;构造附件邮件&lt;/span&gt;
        msg =&lt;span&gt; MIMEMultipart()
        msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Subject&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.subject
        msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;From&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.from_addr
        msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;To&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.to_addr
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加文本内容&lt;/span&gt;
        msg_1 =&lt;span&gt; MIMEText(self.content)
        msg.attach(msg_1)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加附件&lt;/span&gt;
        msg_2 = MIMEApplication(open(self.file_name,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).read())
        msg_2.add_header(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,filename=&lt;span&gt;self.file_name)
        msg.attach(msg_2)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; make_text(self):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;构造纯文本邮件&lt;/span&gt;
        msg =&lt;span&gt; MIMEText(self.content)
        msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Subject&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.subject
        msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;From&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.from_addr
        msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;To&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.to_addr
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; send_mail(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断file_name如果为空，则发送纯文本邮件，不为空则发送附件邮件&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self.file_name == &lt;span&gt;''&lt;/span&gt;&lt;span&gt;:
            msg &lt;/span&gt;=&lt;span&gt; self.make_text()
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            msg &lt;/span&gt;=&lt;span&gt; self.make_multi()
        s &lt;/span&gt;=&lt;span&gt; smtplib.SMTP_SSL(self.host)
        s.login(self.from_addr,self.pwd)
        s.sendmail(self.from_addr,self.to_addr,msg.as_string())
        s.close()&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 31 Aug 2018 07:51:00 +0000</pubDate>
<dc:creator>耳听视界</dc:creator>
<og:description>#send_mail.py #send_mail.py #构造邮件内容 MIMETEXT #发送邮件：登录smtp服务器(账号、密码)--发送--关闭链接 smtplib import smtplib</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zeshan/p/9566225.html</dc:identifier>
</item>
<item>
<title>关于redis一些问题记录 - wujianqinjian</title>
<link>http://www.cnblogs.com/wujianqinjian/p/9566200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wujianqinjian/p/9566200.html</guid>
<description>&lt;p&gt;&lt;span&gt;问题一：启动&lt;/span&gt;redis时出现警告，使用下列命令（已解决）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1209230/201808/1209230-20180831154622258-107420750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;问题二：启动时，需要解决的警告（未解决）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1209230/201808/1209230-20180831154629181-274632578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;问题三：使用自己的配置文件启动&lt;/span&gt;redis时，可能会遇到：&lt;/p&gt;
&lt;p&gt;Could not connect to Redis at 127.0.0.1:6379: Connection refused&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：&lt;/span&gt;6379 没有断开，使用“exit”后，重新使用redis-cli就可以了&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1209230/201808/1209230-20180831154639273-2119088790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;问题四：&lt;/span&gt; &lt;span&gt;用户在哪个路径下启动的&lt;/span&gt;redis，则此次启动后的日志就在该路径下&lt;/p&gt;
&lt;p&gt;此问题为视频技巧备注&lt;/p&gt;

&lt;p&gt;{备注}问题五：maxmemory-policy noeviction 注意配置文件中的这个，一般不会设置成noeviction&lt;/p&gt;

&lt;p&gt;&lt;span&gt;问题六：&lt;/span&gt;java访问redis被centos7的动态防火墙：firewall-cmd阻挡，目前只能关闭防火墙&lt;/p&gt;

&lt;p&gt;{解决}问题七：因为修改配置文件导致redis-cli无法连接，修改回配置文件，&lt;/p&gt;
&lt;p&gt;可能需要杀掉进程后，再重新连接就可以&lt;/p&gt;

</description>
<pubDate>Fri, 31 Aug 2018 07:48:00 +0000</pubDate>
<dc:creator>wujianqinjian</dc:creator>
<og:description>问题一：启动redis时出现警告，使用下列命令（已解决） 问题二：启动时，需要解决的警告（未解决） 问题三：使用自己的配置文件启动redis时，可能会遇到： Could not connect to</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wujianqinjian/p/9566200.html</dc:identifier>
</item>
<item>
<title>Nodejs入门（一） - 宣火鱼竹</title>
<link>http://www.cnblogs.com/firefish1/p/9566140.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/firefish1/p/9566140.html</guid>
<description>&lt;h4 id=&quot;一nodejs介绍&quot;&gt;一、Nodejs介绍&lt;/h4&gt;
&lt;p&gt;1、nodejs是ecmascript的runtime&lt;/p&gt;
&lt;p&gt;2、nodejs使用了&lt;strong&gt;event-driven（事件驱动）&lt;/strong&gt;和&lt;strong&gt;non-blocking I/O model(无阻塞的io模型)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非阻塞：I/O时函数立即返回，进程不等I/O完成&lt;/li&gt;
&lt;li&gt;event-driven：Nodejs靠事件进行驱动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、cpu密集 vs I/O密集&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cpu密集：压缩、解压、加密、解密&lt;/li&gt;
&lt;li&gt;I/O密集：文件操作、网络操作、数据库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为JS操作是I/O密集，所以Nodejs是JS在serves上面的runtime&lt;/p&gt;
&lt;p&gt;4、高并发应对之道&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增加机器数&lt;/li&gt;
&lt;li&gt;增加每台机器的cpu数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;5、Nodejs单线程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单线程只针对主进程，I/O操作系统底层多线程调度（Nodejs自己是单线程，但它有一部分任务交给操作系统自己去做多线程）&lt;/li&gt;
&lt;li&gt;单线程不是单进程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;6、Nodejs应用场景&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Web Server&lt;/li&gt;
&lt;li&gt;本地代码构建（编译之类）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;二nodejs开发环境与调试工具&quot;&gt;二、Nodejs开发环境与调试工具&lt;/h4&gt;
&lt;p&gt;1、环境&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CommonJS 规范&lt;/li&gt;
&lt;li&gt;global 对象（类似于js里面的window对象）&lt;/li&gt;
&lt;li&gt;process 当前执行的进程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、CommonJS规范&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个文件都是一个模块，都有自己的作用域&lt;/li&gt;
&lt;li&gt;在模块内部module变量代表模块本身&lt;/li&gt;
&lt;li&gt;module.exports属性代表模块对外接口（将模块的一些东西输出）&lt;/li&gt;
&lt;li&gt;require规则
&lt;ul&gt;&lt;li&gt;/ 表示绝对路径，. / 表示相对于当前文件的&lt;/li&gt;
&lt;li&gt;支持js、json、node的拓展名&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;require特性
&lt;ul&gt;&lt;li&gt;module被加载的时候会执行一遍，并进行缓存，第二次直接用缓存里面的结果&lt;/li&gt;
&lt;li&gt;当一个模块被循环加载（a依赖b，然后b又依赖a），那么只会输出已经执行的部分（a执行在b依赖a之前a该执行的部分）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、global全局对象&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CommonJS&lt;/li&gt;
&lt;li&gt;Buffer、process、console&lt;/li&gt;
&lt;li&gt;timer&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 31 Aug 2018 07:46:00 +0000</pubDate>
<dc:creator>宣火鱼竹</dc:creator>
<og:description>这一系列博客将记录我学Nodejs的过程，第一篇是关于Nodejs的介绍，让大家了解什么是Nodejs</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/firefish1/p/9566140.html</dc:identifier>
</item>
<item>
<title>MySQL执行计划 - DB-Engineer</title>
<link>http://www.cnblogs.com/wanbin/p/9565799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanbin/p/9565799.html</guid>
<description>&lt;p&gt;EXPLAIN 语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{EXPLAIN &lt;span&gt;|&lt;/span&gt; DESCRIBE &lt;span&gt;|&lt;/span&gt; &lt;span&gt;DESC&lt;/span&gt;&lt;span&gt;}
    tbl_name &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;col_name | wild&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;

{EXPLAIN &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; DESCRIBE &lt;span&gt;|&lt;/span&gt; &lt;span&gt;DESC&lt;/span&gt;&lt;span&gt;}
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;explain_type&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
    {explainable_stmt &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;span&gt;FOR&lt;/span&gt;&lt;span&gt; CONNECTION connection_id}

explain_type: {
    EXTENDED
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; PARTITIONS
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; FORMAT &lt;span&gt;=&lt;/span&gt;&lt;span&gt; format_name
}

format_name: {
    TRADITIONAL
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; JSON
}

explainable_stmt: {
    &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; statement
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;span&gt;DELETE&lt;/span&gt;&lt;span&gt; statement
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt;&lt;span&gt; statement
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;span&gt;REPLACE&lt;/span&gt;&lt;span&gt; statement
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;&lt;span&gt; statement
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;wow0&quot;&gt;1. 使用EXPLAIN优化查询&lt;/h2&gt;
&lt;p&gt;EXPLAIN语句提供有关MySQL如何执行语句的信息：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;EXPLAIN适用于&lt;span&gt;SELECT，DELETE，INSERT，REPLACE和UPDATE&lt;/span&gt;语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;当EXPLAIN与可解释的语句一起使用时，MySQL会显示优化器中有关语句执行计划的信息。也就是说，MySQL解释了它将如何处理语句，包括有关表如何连接以及以何种顺序连接的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当EXPLAIN与&lt;span&gt;&lt;code&gt;FOR CONNECTION connection_id&lt;/code&gt;&lt;/span&gt;将显示&lt;span&gt;connection_id&lt;/span&gt;执行的语句的执行计划。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于SELECT语句，EXPLAIN会生成可以使用&lt;span&gt;SHOW WARNINGS&lt;/span&gt;显示的其他执行计划信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;EXPLAIN对于检查涉及分区表的查询很有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;FORMAT选项可用于选择输出格式。 &lt;span&gt;TRADITIONAL&lt;/span&gt;以表格格式显示输出。如果没有显示定义FORMAT选项，则默认值为TRADITIONAL。 JSON格式以JSON格式显示信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在EXPLAIN的帮助下，可以看到应该向表添加索引的位置，以便通过使用索引查找行来更快地执行语句。还可以使用EXPLAIN来检查优化程序是否以最佳顺序连接表。要提示优化器使用与SELECT语句中命名表的顺序相对应的连接顺序，请使用&lt;span&gt;&lt;code&gt;SELECT STRAIGHT_JOIN&lt;/code&gt;&lt;/span&gt;而不是SELECT来开始语句。 （请参见&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/select.html&quot;&gt;“SELECT语法”&lt;/a&gt;。）但是，STRAIGHT_JOIN可能会阻止使用索引，因为它会禁用半连接转换。请参见“&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/semi-joins.html&quot;&gt;使用半连接转换优化子查询，派生表和视图引用&lt;/a&gt;”。&lt;/p&gt;
&lt;p&gt;优化器trace有时可以提供与EXPLAIN的信息互补的信息。但是，优化程序跟踪格式和内容可能会在不同版本之间发生变化。有关详细信息，请参阅&lt;a href=&quot;https://dev.mysql.com/doc/internals/en/optimizer-tracing.html&quot;&gt;MySQL内部：跟踪优化程序&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果在您认为应该使用索引时遇到问题，请运行ANALYZE TABLE以更新可能影响优化程序所做选择的表统计信息，例如key的基数。请参见&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html&quot;&gt;“ANALYZE TABLE语法”&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意&lt;br/&gt;EXPLAIN还可用于获取有关表中列的信息。 &lt;code&gt;EXPLAIN tbl_name&lt;/code&gt;与&lt;code&gt;DESCRIBE tbl_name&lt;/code&gt;和&lt;code&gt;SHOW COLUMNS FROM tbl_name&lt;/code&gt;同义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;wow1&quot;&gt;2. EXPLAIN输出格式&lt;/h2&gt;
&lt;p&gt;EXPLAIN语句提供有关MySQL如何执行语句的信息。 EXPLAIN适用于&lt;span&gt;&lt;code&gt;SELECT&lt;/code&gt;，&lt;code&gt;DELETE&lt;/code&gt;，&lt;code&gt;INSERT&lt;/code&gt;，&lt;code&gt;REPLAC&lt;/code&gt;E和&lt;code&gt;UPDATE&lt;/code&gt;&lt;/span&gt;语句。&lt;/p&gt;
&lt;p&gt;EXPLAIN为SELECT语句中使用的每个表返回一行信息。 它按照MySQL在处理语句时读取它们的顺序列出输出中的表。 MySQL使用嵌套循环连接方法解析所有连接。 这意味着MySQL从第一个表中读取一行，然后在第二个表，第三个表中找到匹配的行，依此类推。 处理完所有表后，MySQL会通过表列表输出所选列和回溯，直到找到有更多匹配行的表。 从该表中读取下一行，并继续下一个表。&lt;/p&gt;
&lt;p&gt;EXPLAIN输出包括分区信息。 此外，对于SELECT语句，EXPLAIN生成扩展信息，可以使用EXPLAIN后的&lt;span&gt;&lt;code&gt;SHOW WARNINGS&lt;/code&gt;&lt;/span&gt;显示.&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;【注意】&lt;br/&gt;在较旧的MySQL版本中，使用&lt;code&gt;EXPLAIN PARTITIONS&lt;/code&gt;和&lt;code&gt;EXPLAIN EXTENDED&lt;/code&gt;生成分区和扩展信息。 这些语法仍然可以向后兼容，但默认情况下现在启用分区和扩展输出，因此PARTITIONS和EXTENDED关键字是多余的并且已弃用。 它们的使用会导致警告，并且在将来的MySQL版本中它们将从EXPLAIN语法中删除。&lt;/p&gt;
&lt;p&gt;您不能在同一个EXPLAIN语句中一起使用已弃用的PARTITIONS和EXTENDED关键字。 此外，这些关键字都不能与FORMAT选项一起使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;wow2&quot;&gt;2.1 EXPLAIN输出列&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; employees.t1 &lt;span&gt;where&lt;/span&gt; t1.emp_no &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; emp_no &lt;span&gt;from&lt;/span&gt;&lt;span&gt; employees.salaries);
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------+-------------+------------+--------+----------------+------------+---------+---------------------+---------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type   &lt;span&gt;|&lt;/span&gt; possible_keys  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                 &lt;span&gt;|&lt;/span&gt; rows    &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------+-------------+------------+--------+----------------+------------+---------+---------------------+---------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE       &lt;span&gt;|&lt;/span&gt; t1          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;           &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;                &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2837194&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;subquery2&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; eq_ref &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;auto_key&lt;span&gt;&amp;gt;&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;auto_key&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.t1.emp_no &lt;span&gt;|&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; MATERIALIZED &lt;span&gt;|&lt;/span&gt; salaries    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;,emp_no &lt;span&gt;|&lt;/span&gt; emp_no     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;                &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2838426&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------+-------------+------------+--------+----------------+------------+---------+---------------------+---------+----------+-------------+&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; warning (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;EXPLAIN的每个输出行都提供有关一个表的信息。如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Column&lt;/th&gt;
&lt;th&gt;JSON Name&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.8503937007874&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h1&quot;&gt;id&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;select_id&lt;/td&gt;
&lt;td&gt;查询序列号&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h2&quot;&gt;select_type&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;查询类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h3&quot;&gt;table&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;table_name&lt;/td&gt;
&lt;td&gt;输出行所引用的表&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h4&quot;&gt;partitions&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;partitions&lt;/td&gt;
&lt;td&gt;匹配的分区&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h5&quot;&gt;type&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;access_type&lt;/td&gt;
&lt;td&gt;连接使用的类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.7089552238806&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h6&quot;&gt;possible_keys&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;possible_keys&lt;/td&gt;
&lt;td&gt;指出 MySQL 能在该表中使用哪些索引有助于查询。如果为空，说明没有可用的索引&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h7&quot;&gt;key&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;key&lt;/td&gt;
&lt;td&gt;实际选择的索引&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.86&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h8&quot;&gt;key_len&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;key_length&lt;/td&gt;
&lt;td&gt;使用的索引的长度。在不损失精确性的情况下，长度越短越好&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.8636363636364&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h9&quot;&gt;ref&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ref&lt;/td&gt;
&lt;td&gt;显示索引的哪一列被使用了&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.8857142857143&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h10&quot;&gt;rows&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;rows&lt;/td&gt;
&lt;td&gt;MYSQL 认为必须检查的用来返回请求数据的行数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6862745098039&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h11&quot;&gt;filtered&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;filtered&lt;/td&gt;
&lt;td&gt;按表条件过滤行的百分比&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#h12&quot;&gt;Extra&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;附加信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;id(JSON Name: select_id)&lt;/strong&gt;&lt;br/&gt;MySQL Query Optimizer 选定的执行计划中查询的序列号。表示查询中执行 select 子句或操作表的顺序， id 值越大优先级越高，越先被执行。 id 相同，执行顺序由上至下。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;select_type (JSON name: none)&lt;/strong&gt;&lt;br/&gt;SELECT的类型，可以是下表中列出的任何类型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;select_type Value&lt;/th&gt;
&lt;th&gt;JSON Name&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SIMPLE&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;简单的SELECT（不使用UNION或子查询）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PRIMARY&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;最外层的SELECT&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UNION&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;UNION 中的第二个或随后的 select 查询， 不依赖于外部查询的结果集&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DEPENDENT UNION&lt;/td&gt;
&lt;td&gt;dependent (true)&lt;/td&gt;
&lt;td&gt;UNION中的第二个或随后的SELECT语句，依赖于外部查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UNION RESULT&lt;/td&gt;
&lt;td&gt;union_result&lt;/td&gt;
&lt;td&gt;UNION 查询的结果集&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SUBQUERY&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;子查询中的第一个SELECT查询，不依赖于外部查询的结果集&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DEPENDENT SUBQUERY&lt;/td&gt;
&lt;td&gt;dependent (true)&lt;/td&gt;
&lt;td&gt;子查询中的第一个SELECT，依赖于外部查询的结果集&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;DERIVED&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;用于 from 子句里有子查询的情况。 MySQL会递归执行这些子查询，把结果放在临时表里&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MATERIALIZED&lt;/td&gt;
&lt;td&gt;materialized_from_subquery&lt;/td&gt;
&lt;td&gt;物化子查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UNCACHEABLE SUBQUERY&lt;/td&gt;
&lt;td&gt;cacheable (false)&lt;/td&gt;
&lt;td&gt;结果集不能被缓存的子查询，必须重新为外层查询的每一行进行评估&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UNCACHEABLE UNION&lt;/td&gt;
&lt;td&gt;cacheable (false)&lt;/td&gt;
&lt;td&gt;UNION 中的第二个或随后的 select 查询，属于不可缓存的子查询&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;　　DEPENDENT&lt;/code&gt;通常表示使用相关子查询。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DEPENDENT SUBQUERY&lt;/code&gt;评估与&lt;code&gt;UNCACHEABLE SUBQUERY&lt;/code&gt;评估不同。 对于DEPENDENT SUBQUERY，子查询仅针对来自其外部上下文的变量的每组不同值重新评估一次。 对于UNCACHEABLE SUBQUERY，将为外部上下文的每一行重新评估子查询。&lt;/p&gt;
&lt;p&gt;　　子查询的可缓存性与查询缓存中查询结果的缓存不同（详见&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html&quot;&gt;“查询缓存如何操作”&lt;/a&gt;）。 查询执行期间发生子查询缓存，而查询缓存仅在查询执行完成后用于存储结果。&lt;/p&gt;
&lt;p&gt;使用EXPLAIN指定FORMAT = JSON时，输出没有直接等同于select_type的单个属性; query_block属性对应于给定的SELECT。 可以使用与刚显示的大多数SELECT子查询类型等效的属性（示例为MATERIALIZED的materialized_from_subquery），并在适当时显示。 SIMPLE或PRIMARY没有JSON等价物。&lt;/p&gt;
&lt;p&gt;非SELECT语句的select_type值显示受影响表的语句类型。 例如，对于DELETE语句，select_type是DELETE。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;table (JSON name: table_name)&lt;/strong&gt;&lt;br/&gt;输出行引用的表的名称。这也可以是以下值之一：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;&amp;lt;unionM,N&amp;gt;&lt;/code&gt;&lt;/span&gt;：该行指的是id值为M和N的行的并集。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;&amp;lt;derivedN&amp;gt;&lt;/code&gt;&lt;/span&gt;：该行引用id值为N的行的派生表结果。例如，派生表可能来自FROM子句中的子查询。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;&amp;lt;subqueryN&amp;gt;&lt;/code&gt;&lt;/span&gt;：该行引用id值为N的行的具体化子查询的结果&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul readability=&quot;19.950532124557&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;partitions (JSON name: partitions)&lt;/strong&gt;&lt;br/&gt;记录将与查询匹配的分区。对于非分区表，该值为NULL。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.62820512820513&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#t2.2&quot;&gt;type (JSON name: access_type)&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;连接类型。用于描述不同的连接类型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;possible_keys (JSON name: possible_keys)&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;possible_keys&lt;/code&gt;指出 MySQL 能在该表中使用哪些索引有助查询。如果为空，说明没有可用的索引&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;14.767441860465&quot;&gt;
&lt;p&gt;&lt;strong&gt;key (JSON name: key)&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;key&lt;/code&gt;列表示MySQL实际决定使用的&lt;code&gt;key&lt;/code&gt;（索引）。如果MySQL决定使用其中一个possible_keys索引来查找行，那么该索引将被列为key value。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;key&lt;/code&gt;可能会命名possible_keys值中不存在的索引。如果所有possible_keys索引都不适合查找行，则会发生这种情况，但查询选择的所有列都是其他索引的列。也就是说，命名索引覆盖了所选列，因此虽然它不用于确定要检索的行，但索引扫描比数据行扫描更有效。&lt;/p&gt;
&lt;p&gt;对于InnoDB，即使查询还选择主键，辅助索引也可能覆盖所选列，因为InnoDB将主键值与每个辅助索引一起存储。如果key为NULL，则MySQL找不到用于更有效地执行查询的索引。&lt;/p&gt;
&lt;p&gt;要强制MySQL使用或忽略possible_keys列中列出的索引，请在查询中使用&lt;code&gt;FORCE INDEX&lt;/code&gt;，&lt;code&gt;USE INDEX&lt;/code&gt;或&lt;code&gt;IGNORE INDEX&lt;/code&gt;。请参考&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;“索引hint”&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于MyISAM表，运行ANALYZE TABLE可帮助优化器选择更好的索引。对于MyISAM表，myisamchk --analyze也是如此。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;key_len (JSON name: key_length)&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;key_len&lt;/code&gt;列使用的索引的长度。在不损失精确性的情况下，长度越短越好&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;ref (JSON name: ref)&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;ref&lt;/code&gt;列显示哪些列或常量与key列中指定的索引进行比较，以从表中选择行。&lt;/p&gt;
&lt;p&gt;如果值为func，则使用的值是某个函数的结果。 要查看哪个函数，请使用EXPLAIN之后的SHOW WARNINGS来查看扩展的EXPLAIN输出。 该函数实际上可能是算术运算符等运算符。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;rows (JSON name: rows)&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;rows&lt;/code&gt;列指示MySQL认为必须检查以执行查询的行数。&lt;br/&gt;对于InnoDB表，此数字是估计值，可能并不总是准确的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;filtered (JSON name: filtered)&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;filtered&lt;/code&gt;列指示将按表条件筛选的表行的估计百分比。 最大值为100，这意味着不会对行进行过滤。 值从100开始减少表示过滤量增加。 rows显示已检查的估计行数，rows×filtered显示将与下表连接的行数。 例如，如果行为1000且过滤为50.00（50％），则使用下表连接的行数为1000×50％= 500。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/wanbin/p/9565799.html#t2.3&quot;&gt;Extra (JSON name: none)&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;此列包含有关MySQL如何解析查询的其他信息。 有关不同值的说明，请参阅EXPLAIN Extra 信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;wow3&quot;&gt;2.2 EXPLAIN join 类型&lt;/h3&gt;
&lt;p&gt;EXPLAIN输出的type列描述了表的连接方式。以下列表描述了从最佳类型到最差类型的连接类型：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;system&lt;/strong&gt;&lt;br/&gt;表仅有一行(=系统表)。这是 const 连接类型的一个特例。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;br/&gt;该表最多只有一个匹配行，在查询开头读取。 因为只有一行，所以优化器的其余部分可以将此行中列的值视为常量。 const表非常快，因为它们只读一次。&lt;/p&gt;
&lt;p&gt;当将PRIMARY KEY或UNIQUE索引的所有部分与常量值进行比较时，将使用const。 在以下查询中，tbl_name可用作const表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; tbl_name &lt;span&gt;WHERE&lt;/span&gt; primary_key&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; tbl_name
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; primary_key_part1&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; primary_key_part2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;ul readability=&quot;15.903444807644&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;eq_ref&lt;/strong&gt;&lt;br/&gt;除 const 类型外最好的可能实现的连接类型。它用在一个索引的所有部分被连接使用并且索引是 UNIQUE 或 PRIMARY KEY， 对于每个索引键，表中只有一条记录与之匹配&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; ref_table,other_table
 &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; ref_table.key_column&lt;span&gt;=&lt;/span&gt;other_table.&lt;span&gt;column&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; ref_table,other_table
 &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; ref_table.key_column_part1&lt;span&gt;=&lt;/span&gt;other_table.&lt;span&gt;column&lt;/span&gt;
 &lt;span&gt;AND&lt;/span&gt; ref_table.key_column_part2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;ref&lt;/strong&gt;&lt;br/&gt;连接不能基于关键字选择单个行，可能查找到多个符合条件的行。叫做 ref 是因为索引要跟某个参考值相比较。这个参考值或者是一个常数，或者是来自一个表里的多表查询的结果值&lt;/p&gt;
&lt;p&gt;ref可用于使用&lt;code&gt;=&lt;/code&gt;或&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;运算符进行比较的索引列。 在以下示例中，MySQL可以使用ref join来处理ref_table：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; ref_table &lt;span&gt;WHERE&lt;/span&gt; key_column&lt;span&gt;=&lt;/span&gt;&lt;span&gt;expr;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; ref_table,other_table
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; ref_table.key_column&lt;span&gt;=&lt;/span&gt;other_table.&lt;span&gt;column&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; ref_table,other_table
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; ref_table.key_column_part1&lt;span&gt;=&lt;/span&gt;other_table.&lt;span&gt;column&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; ref_table.key_column_part2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;fulltext&lt;/strong&gt;&lt;br/&gt;使用FULLTEXT索引执行连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;ref_or_null&lt;/strong&gt;&lt;br/&gt;这种连接类型与&lt;code&gt;ref&lt;/code&gt;类似，但附加说明MySQL会对包含NULL值的行进行额外搜索。 此连接类型优化最常用于解析子查询。 在以下示例中，MySQL可以使用ref_or_null连接来处理&lt;code&gt;ref_table&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; ref_table
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; key_column&lt;span&gt;=&lt;/span&gt;expr &lt;span&gt;OR&lt;/span&gt; key_column &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;6.3567493112948&quot;&gt;
&lt;p&gt;&lt;strong&gt;index_merge&lt;/strong&gt;&lt;br/&gt;此连接类型表示使用了索引合并优化。 在这种情况下，输出行中的key列包含使用的索引列表，key_len包含所用索引的最长键部分列表。详见 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html&quot;&gt;index merge optimization&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
root&lt;span&gt;@localhost&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; a force &lt;span&gt;index&lt;/span&gt;(idx_1,idx_2) &lt;span&gt;where&lt;/span&gt; c1&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; c2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+---------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type        &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra                                 &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+---------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; a     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; index_merge &lt;span&gt;|&lt;/span&gt; idx_2,idx_1   &lt;span&gt;|&lt;/span&gt; idx_1,idx_2 &lt;span&gt;|&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;union&lt;/span&gt;(idx_1,idx_2); Using &lt;span&gt;where&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+-------------+---------------+-------------+---------+------+------+----------+---------------------------------------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; warning (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;unique_subquery&lt;/strong&gt;&lt;br/&gt;此类型替换以下形式的某些IN子查询的eq_ref：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
value &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; primary_key &lt;span&gt;FROM&lt;/span&gt; single_table &lt;span&gt;WHERE&lt;/span&gt; some_expr)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;unique_subquery只是一个索引查找函数，它可以完全替换子查询以提高效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;range&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仅检索给定范围内的行，使用索引选择行。 输出行中的键列指示使用哪个索引。 key_len包含使用的最长密钥部分。 对于此类型，ref列为NULL。&lt;/p&gt;
&lt;p&gt;使用&lt;span&gt;&lt;code&gt;=&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;code&gt;IS NULL&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;code&gt;BETWEEN&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;code&gt;LIKE&lt;/code&gt;&lt;/span&gt;或&lt;span&gt;&lt;code&gt;IN（）&lt;/code&gt;&lt;/span&gt;运算符中的任何一个将键列与常量进行比较时，可以使用范围：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; tbl_name
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; key_column &lt;span&gt;=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; tbl_name
 &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; key_column &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; tbl_name
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; key_column &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; tbl_name
 &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; key_part1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; key_part2 &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;index&lt;/strong&gt;&lt;br/&gt;全表扫描，只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序，但是开销仍然非常大。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果索引是查询的覆盖索引，并且可用于满足表中所需的所有数据，则仅扫描索引树。 在这种情况下，Extra列显示Using index。 仅索引扫描通常比ALL快，因为索引的大小通常小于表数据。&lt;/li&gt;
&lt;li&gt;使用索引中的读取执行全表扫描，以按索引顺序查找数据行。 使用索引不会出现在Extra列中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当查询仅使用属于单个索引的列时，MySQL可以使用此连接类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;ALL&lt;/strong&gt;&lt;br/&gt;对表中的每行进行全表扫描。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;wow4&quot;&gt;2.3 EXPLAIN Extra 信息&lt;/h3&gt;
&lt;p&gt;EXPLAIN输出的Extra列包含有关MySQL如何解析查询的其他信息。 以下列表说明了此列中可能出现的值。 每个项目还指示JSON格式的输出，该属性显示Extra值。 对于其中一些，有一个特定的属性。 其他显示为消息属性的文本。&lt;/p&gt;
&lt;ul readability=&quot;34&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Child of 'table' pushed join@1 (JSON: message text)&lt;/strong&gt;&lt;br/&gt;此表在连接中被引用为表的子节点，可以将其下推到NDB内核。 仅当启用了 &lt;code&gt;pushed-down&lt;/code&gt;连接时，才适用于NDB群集。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;const row not found (JSON property: const_row_not_found)&lt;/strong&gt;&lt;br/&gt;对于诸如&lt;code&gt;SELECT ... FROM tbl_name&lt;/code&gt;之类的查询，该表为空。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Deleting all rows (JSON property: message)&lt;/strong&gt;&lt;br/&gt;对于DELETE，某些存储引擎（如MyISAM）支持一种处理程序方法，该方法以简单快捷的方式删除所有表行。 如果引擎使用此优化，则会显示此附加值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Distinct (JSON property: distinct)&lt;/strong&gt;&lt;br/&gt;MySQL正在寻找不同的值，因此它在找到第一个匹配行后停止为当前行组合搜索更多行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;FirstMatch(tbl_name) (JSON property: first_match)&lt;/strong&gt;&lt;br/&gt;半连接FirstMatch连接快捷方式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Full scan on NULL key (JSON property: message)&lt;/strong&gt;&lt;br/&gt;当优化程序无法使用 index-lookup 访问时，子查询优化将作为回退策略发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Impossible HAVING (JSON property: message)&lt;/strong&gt;&lt;br/&gt;HAVING子句始终为false，无法查询任何行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Impossible WHERE (JSON property: message)&lt;/strong&gt;&lt;br/&gt;WHERE子句始终为false，无法查询任何行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Impossible WHERE noticed after reading const tables (JSON property: message)&lt;/strong&gt;&lt;br/&gt;MySQL已经读取了所有const（和system）表，并注意到WHERE子句始终为false。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;LooseScan(m..n) (JSON property: message)&lt;/strong&gt;&lt;br/&gt;使用半连接LooseScan策略。 m和n是关键部件号。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;No matching min/max row (JSON property: message)&lt;/strong&gt;&lt;br/&gt;没有行满足查询的条件，例如SELECT MIN（...）FROM ... WHERE条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;No matching rows after partition pruning (JSON property: message)&lt;/strong&gt;&lt;br/&gt;对于&lt;code&gt;DELETE&lt;/code&gt;或&lt;code&gt;UPDATE&lt;/code&gt;，优化器在分区修剪后未发现任何要删除或更新的内容。 它与SELECT语句的Impossible WHERE的含义相似。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;No tables used (JSON property: message)&lt;/strong&gt;&lt;br/&gt;查询语句没有制定from子句，或者from dual子句。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;INSERT&lt;/code&gt;或&lt;code&gt;REPLACE&lt;/code&gt;语句，EXPLAIN在没有SELECT部分​​时显示该值。例如，它出现在&lt;code&gt;EXPLAIN INSERT INTO VALUES（10）&lt;/code&gt;中，因为它等同于&lt;code&gt;EXPLAIN INSERT INTO SELECT 101 FROM DUAL&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;Not exists (JSON property: message)&lt;/strong&gt;&lt;br/&gt;MySQL能够对查询执行LEFT JOIN优化，并且在找到与LEFT JOIN条件匹配的行之后，不会检查此表中针对上一行组合的更多行。 以下是可以通过以下方式优化的查询类型的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; t1 &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; t2 &lt;span&gt;ON&lt;/span&gt; t1.id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;t2.id
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; t2.id &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;假设&lt;code&gt;t2.id&lt;/code&gt;被定义为NOT NULL。 在这种情况下，MySQL扫描t1并使用t1.id的值在t2中查找行。 如果MySQL在t2中找到匹配的行，则它知道t2.id永远不能为NULL，并且不会扫描t2中具有相同id值的其余行。 换句话说，对于t1中的每一行，MySQL需要在t2中只进行一次查找，而不管t2中实际匹配多少行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Plan isn't ready yet (JSON property: none)&lt;/strong&gt;&lt;br/&gt;当优化器尚未完成为在命名连接中执行的语句创建执行计划时，&lt;code&gt;EXPLAIN FOR CONNECTION&lt;/code&gt;会出现此值。 如果执行计划输出包含多行，则其中的任何一个或全部都可以具有此Extra值，具体取决于优化程序在确定完整执行计划时的进度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Range checked for each record (index map: N) (JSON property: message)&lt;/strong&gt;&lt;br/&gt;MySQL发现没有好的索引可以使用，但发现在前面的表的列值已知后可能会使用某些索引。 对于上表中的每个行组合，MySQL检查是否可以使用range或index_merge访问方法来检索行。 这不是很快，但比执行没有索引的连接更快。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Scanned N databases (JSON property: message)&lt;/strong&gt;&lt;br/&gt;这表示在处理INFORMATION_SCHEMA表的查询时服务器执行的目录扫描数。 N的值可以是&lt;code&gt;0&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;all&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Select tables optimized away (JSON property: message)&lt;/strong&gt;&lt;br/&gt;使用某些聚合函数来访问存在索引的某个字段时，优化器会通过索引直接一次定位到所需要的数据行完成整个查询，例如MIN()\MAX()，这种也是比较好的结果之一&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Skip_open_table, Open_frm_only, Open_full_table (JSON property: message)&lt;/strong&gt;&lt;br/&gt;这些值表示适用于INFORMATION_SCHEMA表的查询的文件打开优化。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Skip_open_table&lt;/code&gt;：不需要打开表文件。通过扫描数据库目录，该信息已在查询中可用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Open_frm_only&lt;/code&gt;：只需要打开表的.frm文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Open_full_table&lt;/code&gt;：未经优化的信息查找。必须打开.frm，.MYD和.MYI文件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Start temporary, End temporary (JSON property: message)&lt;/strong&gt;&lt;br/&gt;这表示临时表用于半连接Duplicate Weedout策略。&lt;/li&gt;
&lt;/ul&gt;&lt;ul readability=&quot;10.567580567581&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;unique row not found (JSON property: message)&lt;/strong&gt;&lt;br/&gt;对于诸如&lt;code&gt;SELECT ... FROM tbl_name&lt;/code&gt;之类的查询，没有行满足表上UNIQUE索引或PRIMARY KEY的条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Using filesort (JSON property: using_filesort)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;表示 MySQL 会对结果使用一个外部索引排序，而不是从表里按索引次序读到相关内容。可能在内存或者磁盘上进行排序。 MySQL 中无法利用索引完成的排序操作称为“文件排序”&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;Using index (JSON property: using_index)&lt;/strong&gt;&lt;br/&gt;仅使用索引树中的信息从表中检索列信息，而不必另外寻找读取实际行。 当查询仅使用属于单个索引的列时，可以使用此策略。&lt;/p&gt;
&lt;p&gt;对于具有用户定义的聚簇索引的InnoDB表，即使Extra列中不存在使用索引，也可以使用该索引。 如果type是index并且key是PRIMARY，则会出现这种情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Using index condition (JSON property: using_index_condition)&lt;/strong&gt;&lt;br/&gt;会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Using index for group-by (JSON property: using_index_for_group_by)&lt;/strong&gt;&lt;br/&gt;与&lt;code&gt;Using index table&lt;/code&gt;访问方法类似，&lt;code&gt;Using group for group-by&lt;/code&gt;表示MySQL找到了一个索引，可用于检索GROUP BY或DISTINCT查询的所有列，而无需对实际表进行任何额外的磁盘访问。 此外，索引以最有效的方式使用，因此对于每个组，只读取少数索引条目。 有关详细信息，请参考“GROUP BY优化”。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.67469879518072&quot;&gt;
&lt;p&gt;&lt;strong&gt;Using join buffer (Block Nested Loop), Using join buffer (Batched Key Access) (JSON property: using_join_buffer)&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html&quot;&gt;将联接中的表分成几部分读入连接缓冲区，然后从缓冲区中使用它们的行来与当前表执行连接。 （Block Nested Loop）表示使用块嵌套循环算法，（Batched Key Access）表示使用批量密钥访问算法。 也就是说，来自EXPLAIN输出前一行的表中的键将被缓冲，匹配的行将从连接缓冲区的行的表中批量提取。&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Using MRR (JSON property: message)&lt;/strong&gt;&lt;br/&gt;使用多范围读取优化策略读取表,详见&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html&quot;&gt;mrr&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul readability=&quot;0.44957983193277&quot;&gt;&lt;li readability=&quot;1.7377049180328&quot;&gt;
&lt;p&gt;&lt;strong&gt;Using sort_union(...), Using union(...), Using intersect(...) (JSON property: message)&lt;/strong&gt;&lt;br/&gt;显示如何为index_merge连接类型合并索引扫描。 请参考&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html&quot;&gt;“索引合并优化”&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Using temporary (JSON property: using_temporary_table)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;表示 MySQL 在对查询结果排序时使用临时表。常见于排序 &lt;code&gt;order by&lt;/code&gt;和分组查询&lt;code&gt;group by&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Using where (JSON property: attached_condition)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;通常是进行了全表引扫描后再用WHERE子句完成结果过滤，需要添加合适的索引&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Using where with pushed condition (JSON property: message)&lt;/strong&gt;&lt;br/&gt;此项仅适用于NDB表。 这意味着NDB Cluster正在使用条件下推优化来提高非索引列和常量之间直接比较的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Zero limit (JSON property: message)&lt;/strong&gt;&lt;br/&gt;该查询具有LIMIT 0子句，无法选择任何行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;wow5&quot;&gt;3. 扩展EXPLAIN输出格式&lt;/h2&gt;
&lt;p&gt;对于SELECT语句，EXPLAIN语句生成额外的（“扩展”）信息，这些信息不是EXPLAIN输出的一部分，但可以通过在EXPLAIN之后发出&lt;code&gt;SHOW WARNINGS&lt;/code&gt;语句来查看。 &lt;code&gt;SHOW WARNINGS&lt;/code&gt;输出中的Message值显示优化器如何限定SELECT语句中的表名和列名，SELECT应用重写和优化规则后的样子，以及可能有关优化过程的其他注释。&lt;/p&gt;
&lt;p&gt;可以在EXPLAIN之后使用SHOW WARNINGS语句显示的扩展信息仅针对SELECT语句生成。 SHOW WARNINGS显示其他可解释语句的空结果（DELETE，INSERT，REPLACE和UPDATE）。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;【注意】&lt;br/&gt;在较早的MySQL版本中，扩展信息是使用EXPLAIN EXTENDED生成的。 该语法仍然可以向后兼容，但默认情况下现在启用了扩展输出，因此EXTENDED关键字是多余的并且已弃用。 它的使用会导致警告，并且在将来的MySQL版本中它将从EXPLAIN语法中删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
root&lt;span&gt;@localhost&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;employees&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dept_emp &lt;span&gt;where&lt;/span&gt; emp_no &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; emp_no &lt;span&gt;from&lt;/span&gt;&lt;span&gt; employees)\G
&lt;/span&gt;&lt;span&gt;***************************&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;. row &lt;span&gt;***************************&lt;/span&gt;&lt;span&gt;
           id: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  select_type: SIMPLE
        &lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;: employees
   partitions: &lt;/span&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;
         type: &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;
possible_keys: &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt;
          &lt;span&gt;key&lt;/span&gt;&lt;span&gt;: idx_name
      key_len: &lt;/span&gt;&lt;span&gt;66&lt;/span&gt;&lt;span&gt;
          ref: &lt;/span&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;
         rows: &lt;/span&gt;&lt;span&gt;298936&lt;/span&gt;&lt;span&gt;
     filtered: &lt;/span&gt;&lt;span&gt;100.00&lt;/span&gt;&lt;span&gt;
        Extra: Using &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;
&lt;span&gt;***************************&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;. row &lt;span&gt;***************************&lt;/span&gt;&lt;span&gt;
           id: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  select_type: SIMPLE
        &lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;: dept_emp
   partitions: &lt;/span&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;
         type: ref
possible_keys: &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;span&gt;,emp_no
          &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;: &lt;span&gt;PRIMARY&lt;/span&gt;&lt;span&gt;
      key_len: &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
          ref: employees.employees.emp_no
         rows: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
     filtered: &lt;/span&gt;&lt;span&gt;100.00&lt;/span&gt;&lt;span&gt;
        Extra: &lt;/span&gt;&lt;span&gt;NULL&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; warning (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

root&lt;/span&gt;&lt;span&gt;@localhost&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;employees&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; show warnings\G
&lt;/span&gt;&lt;span&gt;***************************&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;. row &lt;span&gt;***************************&lt;/span&gt;
  &lt;span&gt;Level&lt;/span&gt;&lt;span&gt;: Note
   Code: &lt;/span&gt;&lt;span&gt;1003&lt;/span&gt;&lt;span&gt;
Message: &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; select#1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; `employees`.`dept_emp`.`emp_no` &lt;span&gt;AS&lt;/span&gt; `emp_no`,`employees`.`dept_emp`.`dept_no` &lt;span&gt;AS&lt;/span&gt; `dept_no`,`employees`.`dept_emp`.`from_date` &lt;span&gt;AS&lt;/span&gt; `from_date`,`employees`.`dept_emp`.`to_date` &lt;span&gt;AS&lt;/span&gt; `to_date` &lt;span&gt;from&lt;/span&gt; `employees`.`employees` &lt;span&gt;join&lt;/span&gt; `employees`.`dept_emp` &lt;span&gt;where&lt;/span&gt; (`employees`.`dept_emp`.`emp_no` &lt;span&gt;=&lt;/span&gt;&lt;span&gt; `employees`.`employees`.`emp_no`)
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以下列表描述了可以出现在SHOW WARNINGS显示的扩展输出中的特殊标记：&lt;/p&gt;
&lt;ul readability=&quot;13.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;auto_key&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;自动生成的临时表key。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;cache&amp;gt;(expr)&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;表达式（例如标量子查询）执行一次，结果值保存在内存中供以后使用。 对于包含多个值的结果，可能会创建一个临时表，您将看到&amp;lt;临时表&amp;gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;exists&amp;gt;&lt;/code&gt;(query fragment)&lt;/strong&gt;&lt;br/&gt;子查询谓词转换为EXISTS谓词，子查询被转换，以便它可以与EXISTS谓词一起使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;in_optimizer&amp;gt;&lt;/code&gt;(query fragment)&lt;/strong&gt;&lt;br/&gt;这是一个内部优化器对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;index_lookup&amp;gt;&lt;/code&gt;(query fragment)&lt;/strong&gt;&lt;br/&gt;使用索引查找处理查询片段以查找符合条件的行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;if&amp;gt;&lt;/code&gt;(condition, expr1, expr2)&lt;/strong&gt;&lt;br/&gt;如果条件为真，则计算为expr1，否则为expr2。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;is_not_null_test&amp;gt;&lt;/code&gt;(expr)&lt;/strong&gt;&lt;br/&gt;用于验证表达式不计算为NULL的测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;materialize&amp;gt;&lt;/code&gt;(query fragment)&lt;/strong&gt;&lt;br/&gt;用于子查询物化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;materialized-subquery&lt;/code&gt;.col_name&lt;/strong&gt;&lt;br/&gt;对内部临时表中列col_name的引用，该列实现为保存评估子查询的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;primary_index_lookup&amp;gt;&lt;/code&gt;(query fragment)&lt;/strong&gt;&lt;br/&gt;使用主键查找处理查询片段以查找符合条件的行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;ref_null_helper&amp;gt;&lt;/code&gt;(expr)&lt;/strong&gt;&lt;br/&gt;这是一个内部优化器对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;/* select#N */&lt;/code&gt; select_stmt&lt;/strong&gt;&lt;br/&gt;SELECT与非扩展EXPLAIN输出中具有id值N的行相关联。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;outer_tables semi join (inner_tables)&lt;/strong&gt;&lt;br/&gt;半连接操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;temporary table&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;这表示为缓存中间结果而创建的内部临时表。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 31 Aug 2018 06:51:00 +0000</pubDate>
<dc:creator>DB-Engineer</dc:creator>
<og:description>MySQL执行计划 使用EXPLAIN优化查询 EXPLAIN输出格式 扩展EXPLAIN输出格式 使用EXPLAIN优化查询 EXPLAIN输出格式 扩展EXPLAIN输出格式 EXPLAIN 语法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanbin/p/9565799.html</dc:identifier>
</item>
<item>
<title>动态规划算法学习总结 - 东聃</title>
<link>http://www.cnblogs.com/Ran-Chen/p/9562225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ran-Chen/p/9562225.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;动态规划与贪心分治的区别&quot;&gt;动态规划与贪心、分治的区别&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;贪心算法(Greed alalgorithm)&lt;/strong&gt; 是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致全局结果是最好或最优的算法。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;分治算法(Divide and conquer alalgorithm)&lt;/strong&gt; 字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;动态规划算法(Dynamic programming，DP)&lt;/strong&gt; 通过将原问题分解为相对简单的子问题的方式来求解复杂问题。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;贪心法在处理每个子问题时，不能回退，而动态规划可以保存之前的结果，择优选择。下面针对Interval Scheduling 问题，分析动态规划在实际问题中的应用。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;interval-scheduling-问题&quot;&gt;Interval Scheduling 问题&lt;/h2&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如下图所示，每个长条方块代表一个工作，总有若干个工作a、b... h，横坐标是时间，方块的起点和终点分别代表这个工作的起始时间和结束时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当两个工作的工作时间没有交叉，即两个方块不重叠时，表示这两个工作是兼容的(&lt;strong&gt;compatible&lt;/strong&gt;)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当给每个工作赋权值都为1时，则称为 &lt;strong&gt;Unweighted Interval Scheduling&lt;/strong&gt; 问题；当给每个工作赋不同的正权值时，则称为 &lt;strong&gt;Weighted Interval Scheduling&lt;/strong&gt; 问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;问题最终是要找到一个工作子集，集合内所有工作&lt;strong&gt;权值之和最大&lt;/strong&gt;且&lt;strong&gt;集合内每个工作都兼容&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830202638960-1901751213.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于 Unweighted Interval Scheduling 问题，使用贪心算法即可求解，具体做法是按照&lt;strong&gt;结束时间&lt;/strong&gt;对所有工作进行排序，然后从结束最晚的工作开始，依次排除掉与前一个不兼容的工作，剩下的工作所组成的集合即为所求。&lt;/p&gt;
&lt;p&gt;然而，对于 Weighted Interval Scheduling 问题，贪心法找到的解可能不是最优的了。此时考虑使用动态规划算法解决问题，兼顾权值选择和兼容关系。&lt;/p&gt;
&lt;h4 id=&quot;定义pj&quot;&gt;定义P(j)&lt;/h4&gt;
&lt;p&gt;1、首先依然按照结束时间对所有的工作进行排序；&lt;/p&gt;
&lt;p&gt;2、定义p(j)为在工作j之前，且与j兼容的工作的最大标号，通过分析每个工作的起始时间和结束时间，可以很容易计算出p(j);&lt;/p&gt;
&lt;p&gt;3、例如下图所示，p(8)=5，因为工作7和6都与8不兼容，工作1到5都与8兼容，而5是其中索引最大的一个，所以p(8)=5。同理，p(7)=3,p(2)=0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830202703858-73557529.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;分析递归关系&quot;&gt;分析递归关系&lt;/h4&gt;
&lt;p&gt;1、定义opt(j)是j个工作中，所能选择到的最佳方案，即opt(j)是最大的权值和；&lt;/p&gt;
&lt;p&gt;2、对于第j个工作，有两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;case 1&lt;/strong&gt;: 工作j包含在最优解当中，那么往前递推一步，j之前能选择到的最优解是opt(p(j))，即&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830204702772-1786982981.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;case 2&lt;/strong&gt;: 工作j不在最优解中，那么从j个工作中选取解集和从j-1个工作中选取解集是一样的，即&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830204726098-527612866.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、当j=0时，显示结果为0，这是边界条件。&lt;/p&gt;
&lt;p&gt;后一步的结果取前一步所有可能情况的最大值，因此综上所述，能得到动态规划的递归关系为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830205141465-551397212.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码实现&quot;&gt;代码实现&lt;/h4&gt;
&lt;p&gt;1、递归法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830210012216-1448738241.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;递归会使得空间复杂度变高，一般不建议使用。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;自底向上法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830210104171-119414039.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从小到大进行计算，这样每次都可以利用前一步计算好的值来计算后一步的值，算法时间复杂度为O(nlogn)，其中排序花费O(nlogn)，后面的循环花费O(n)。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;knapsack-problem-问题&quot;&gt;Knapsack Problem 问题&lt;/h2&gt;
&lt;h4 id=&quot;背包问题的定义&quot;&gt;背包问题的定义&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如下图所示，给定一个背包Knapsack，有若干物品Item&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;每个item有自己的重量weight，对应一个价值value&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;背包的总重量限定为W&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;目标是填充背包，在不超重的情况下，使背包内物品总重量最大。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;对于下图的例子，一种常见的贪心思想是：在背包可以装得下的情况下，尽可能选择价值更高的物品。那么当背包容量是W=11时，先选择item5，再选择item2，最后只能放下item1，总价值为28+6+1=35。实际上最优解是选择item3和item4，价值18+22=40。这说明了贪心算法对于背包问题的求解可能不是zuiyou的。下面考虑使用动态规划算法求解，首先要推导递归关系式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830211954645-1811663133.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;推导递归关系式&quot;&gt;推导递归关系式&lt;/h4&gt;
&lt;p&gt;类似于Weighted Interval Scheduling问题，定义&lt;strong&gt;opt(i, w)表示在有i个item，且背包剩余容量为w时所能得到的最大价值和&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;考虑第i个item，有选和不选两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;case 1&lt;/strong&gt;: 如果选择第i个item，则&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830213056444-1480716444.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;case 2&lt;/strong&gt;: 如果不选择第i个item，则&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830213107446-460576756.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;边界条件: 当i=0时，显然opt(i,w)=0。&lt;/p&gt;
&lt;p&gt;后一步的结果取前一步所有可能情况的最大值，因此综上所述，能得到动态规划的递归关系为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830213156474-249947811.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;自底向上求解&quot;&gt;自底向上求解&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830213350980-1102815021.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;算法迭代过程如下表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830213543404-659693221.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;算法运行时间分析&quot;&gt;算法运行时间分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830213913252-501662014.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是，该算法相对于输入尺寸来说，不是一个多项式算法，虽然O(nW)看起来很像一个多项式解，&lt;strong&gt;背包问题实际上是一个NP完全问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了便于理解，可以写成这种形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830214700834-845798677.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;W在计算机中只是一个数字，以长度logW的空间存储，非常小。但是在实际运算中，随着W的改变，需要计算nW次，这是非常大的（相对于logW来说）。例如，当W为5kg的时候，以kg为基准单位，需要计算O(5n)次，当W为5t时，仍然以kg为单位，需要计算O(5000n)次，而在计算机中W的变化量相对很小。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;sequence-alignment&quot;&gt;Sequence Alignment&lt;/h2&gt;
&lt;h4 id=&quot;define-edit-distance&quot;&gt;Define edit distance&lt;/h4&gt;
&lt;p&gt;给定两个序列x1,x2...xi和y1,y2,...,yj。要匹配这两个序列，使相似度足够大。首先需要定义一个表示代价的量-Edit distance，只有优化使这个量最小，就相当于最大化匹配了这两个序列。&lt;/p&gt;
&lt;p&gt;Edit distance的定义如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830221641516-1219178582.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，匹配到空，设距离为delta，否则字母p和q匹配的距离记为alpha(p,q)，如果p=q，则alpha=0；&lt;/p&gt;
&lt;p&gt;那么两个序列匹配的总代价为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830221707269-49790103.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;建立递推关系&quot;&gt;建立递推关系&lt;/h4&gt;
&lt;p&gt;设opt(i,j)是序列x1,x2...xi和y1,y2,...,yj之间匹配所花费的最小代价。当i，j不全为0时，则分别有三种情况，分别是xi-gap，yj-gap，xi-yj，分别计算不同匹配情况所花费的代价，再加上前一步的结果，就可以建立递推关系式，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830221739987-402980022.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;算法实现&quot;&gt;算法实现&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180830221940064-31777044.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;算法复杂度&quot;&gt;算法复杂度&lt;/h4&gt;
&lt;p&gt;时间和空间复杂度皆为O(mn)。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下面再分析一个具体的编程问题，使用动态规划算法，但是和上面的DP又有一些区别。&lt;/p&gt;
&lt;h2 id=&quot;合唱团问题&quot;&gt;合唱团问题&lt;/h2&gt;
&lt;h4 id=&quot;问题定义&quot;&gt;问题定义&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，&lt;strong&gt;要求相邻两个学生的位置编号的差不超过 d&lt;/strong&gt;，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 &amp;lt;= n &amp;lt;= 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 &lt;strong&gt;ai（-50 &amp;lt;= ai &amp;lt;= 50）&lt;/strong&gt;。接下来的一行包含两个整数，k 和 d (1 &amp;lt;= k &amp;lt;= 10, 1 &amp;lt;= d &amp;lt;= 50)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;输出描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输出一行表示最大的乘积。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;问题分析&quot;&gt;问题分析&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;此题的第一个关键点是“要求相邻两个学生的位置编号的差不超过 d”，如果按照传统的DP思路，定义opt(i,k)表示在前i个学生中选取k个学生的最大乘积，建立递推关系:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180831133158932-569279044.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;则无法实现“相邻两个学生的位置编号的差不超过 d”的要求。因此，需要定义一个辅助量，来包含对当前学生的定位信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义f(i,k)表示在前i个学生中选取k个学生，且&lt;strong&gt;第i个学生必选&lt;/strong&gt;时，所选学生的能力值乘积，这样就包含对当前学生的定位信息，f的递推关系可以表示为&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180831132819437-1717559479.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，j是一个比i小的值，最大为i-1，i、j之差不超过D，f(j,k-1)表示在前j个学生中，选择k-1个学生，且第j个学生必选。f(i,k)选择了第i个学生，f(j,k-1)选择了第j个学生，i、j之差不超过D，这样就可以满足题目要求了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;辅助量f(i,k)并不是我们最终要得到的结果，最终结果opt(i,k)表示在前i个学生中选取k个学生的最大乘积，因此，可以得到opt(i,k)和f(i,k)的关系为：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180831132845759-122813612.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该问题的第二个关键点是学生的能力值在-50到+50之间，每次选择的学生的能力值有正有负，所以需要两个f记录最大和最小值，定义fmax和fmin，在每次迭代f的过程中：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180831132907898-1886844700.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当k=K，i=N时，最终所求的:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397676/201808/1397676-20180831132926589-1247713465.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;边界条件k=1时，f(i,k=1)=v(i)&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;代码实现-1&quot;&gt;代码实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/*********************************************************************
*
* Ran Chen &amp;lt;wychencr@163.com&amp;gt;
*
* Dynamic programming algorithm
*
*********************************************************************/

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;climits&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

int main()
{
    int N, D, K;  // 总共N个学生
    vector &amp;lt;int&amp;gt; value;

    while (cin &amp;gt;&amp;gt; N)
    {
    
        for (int i = 0; i &amp;lt; N; ++i)
        {
            int v;
            cin &amp;gt;&amp;gt; v;
            value.push_back(v);
        }

        break;
    }

    cin &amp;gt;&amp;gt; K;  // 选择K个学生
    cin &amp;gt;&amp;gt; D;  // 相邻被选择学生的序号差值

    // fmax/fmin[i, k]表示在选择第i个数的情况下的最大/小乘积
    vector &amp;lt;vector &amp;lt;long long&amp;gt;&amp;gt; fmax(N+1, vector &amp;lt;long long&amp;gt; (K+1));
    vector &amp;lt;vector &amp;lt;long long&amp;gt;&amp;gt; fmin(N+1, vector &amp;lt;long long&amp;gt; (K+1));

    // 边界条件k=1
    for (int i = 1; i &amp;lt;= N; ++i)
    {
        fmax[i][1] = value[i - 1];
        fmin[i][1] = value[i - 1];
    }

    // 自底向上dp, k&amp;gt;=1
    for (int k = 2; k &amp;lt;= K; ++k)
    {
        // i &amp;gt;= k
        for (int i = k; i &amp;lt;= N; ++i)
        {
            // 0 &amp;lt;= j &amp;lt;= i-1 &amp;amp;&amp;amp; i - j &amp;lt;= D &amp;amp;&amp;amp; j &amp;gt;= k-1
            long long *max_j = new long long; *max_j = LLONG_MIN;
            long long *min_j = new long long; *min_j = LLONG_MAX;
    
            // f(i, k) = max_j {f(j, k-1) * value(i)}
            int j = max(i - D, max(k - 1, 1));
            for ( ; j &amp;lt;= i - 1; ++j)
            {
                *max_j = max(*max_j, max(fmax[j][k - 1] * value[i - 1], fmin[j][k - 1] * value[i - 1]));                
                *min_j = min(*min_j, min(fmax[j][k - 1] * value[i - 1], fmin[j][k - 1] * value[i - 1]));            
            }

            fmax[i][k] = *max_j;
            fmin[i][k] = *min_j;
            
            delete max_j; 
            delete min_j;
        }
    }

    // opt(N, K) = max_i {f(i, K)}, K &amp;lt;= i &amp;lt;= N
    long long *temp = new long long;
    *temp = fmax[K][K];
    for (int i = K+1; i &amp;lt;= N; ++i)
    {
        *temp = max(*temp, fmax[i][K]);
    }
    cout &amp;lt;&amp;lt; *temp;
    delete temp;

    system(&quot;pause&quot;);
    return 0;
}

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 31 Aug 2018 05:32:00 +0000</pubDate>
<dc:creator>东聃</dc:creator>
<og:description>动态规划与贪心、分治的区别 贪心算法(Greed alalgorithm) 是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致全局结果是最好或最优的算法。 分治算法(Di</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ran-Chen/p/9562225.html</dc:identifier>
</item>
<item>
<title>从壹开始前后端分离【 .NET Core2.0 +Vue2.0 】框架之十三 || DTOs 对象映射使用，项目打包部署Windows+Linux - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/9565227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/9565227.html</guid>
<description>&lt;blockquote readability=&quot;7.4464285714286&quot;&gt;
&lt;p&gt;&lt;span&gt;番外&lt;/span&gt;：时间真快，今天终于到了系统打包的日子，虽然项目还是有很多问题，虽然后边还有很多的内容要说要学，但是想着初级基本的.Net Core 用到的基本至少就这么多了（接口文档，项目框架，持久化ORM，依赖注入，AOP，分布式缓存，CORS跨域等等），中高级的，比如在Linux高级发布，Nginx代理，微服务，Dockers等等，这个在以后的更新中会慢慢提到，不然的话，Vue就一直说不到了 [哭笑哈哈]，其实我还有很多要总结的，比如 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/power-bi/sample-customer-profitability&quot; target=&quot;_blank&quot;&gt;Power BI系列&lt;/a&gt;（没用过的点击看看），比如C#7.0系列等文章，都在慢慢酝酿中，希望能坚持下来，不过这两个系列目前还不会写到，如果有需要用或学微软&lt;a href=&quot;https://docs.microsoft.com/zh-cn/power-bi/sample-customer-profitability&quot; target=&quot;_blank&quot;&gt;Power BI&lt;/a&gt;（&lt;a href=&quot;https://docs.microsoft.com/zh-cn/power-bi/sample-customer-profitability&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/power-bi/sample-customer-profitability&lt;/a&gt;）的，可以加QQ群联系我，我在微软项目中已经用到了。还是打算从下周一开始转战Vue的文章，当然后端也会一直穿插着，这里要说下，我们的QQ群已经有一些小伙伴了，每天可以一起交流心得和问题，感觉还是很不错的，如果你有什么问题，或者其他技术上的需要讨论，咱们的群是可以试试哟，我和其他小伙伴会一直在线给大家解答（咋感觉像一个广告哈哈，大家随意哈）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　正传：好啦，书接上文，昨天说到了《&lt;a href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9560949.html&quot; target=&quot;_blank&quot;&gt;从壹开始前后端分离【 .NET Core2.0 +Vue2.0 】框架之十二 || 三种跨域方式比较，DTOs(数据传输对象)初探&lt;/a&gt;》，因为下午时间的问题，只是讲解了四种跨域方法，没有讲解完DTO，其实这个东西很简单，说白了，就是把两个实体类进行转换，不用人工手动去一一赋值，今天呢，就简单说下常见DTO框架AutoMapper的使用，然后做一个打包处理，发布到我的windows服务器里，今天刚刚买了一个Ubuntu Linux服务器，因为如果开发.Net Core，一定会接触到Linux服务器，等各种，因为它跨域了，就是酱紫。但是还没有配置好，所以会在下边留下位置，慢慢补充在Ubuntu部署的讲解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831110638460-1721090247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1、在接口 IBlogArticleServices.cs和 类BlogArticleServices.cs中，添加GetBlogDetails()方法，返回类型是BlogViewModels&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请看这两个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 　　&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 博客文章实体类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BlogArticle
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; bID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建人
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; bsubmitter { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 博客标题
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; btitle { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 类别
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; bcategory { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 内容
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; bcontent { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 访问量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; btraffic { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 评论数量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; bcommentNum { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 修改时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime bUpdateTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; System.DateTime bCreateTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 备注
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; bRemark { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
&lt;/span&gt;-------------------------------------------------
　　 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 博客信息展示类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BlogViewModels
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; bID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; 创建人
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; bsubmitter { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; 博客标题
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; btitle { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; 摘要
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; digest { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 上一篇
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; previous { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 上一篇id
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; previousID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 下一篇
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; next { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 下一篇id
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nextID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; 类别
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; bcategory { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; 内容
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; bcontent { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 访问量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; btraffic { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 评论数量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; bcommentNum { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; 修改时间
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime bUpdateTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; System.DateTime bCreateTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; 备注
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; bRemark { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;两个实体类字段还基本可以，不是很多，但是我曾经开发一个旅游网站的系统，有一个表字段都高达30多个，当然还有更多的，额，如果我们一个个赋值是这样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
            BlogViewModels models = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BlogViewModels()
            {
                bsubmitter&lt;/span&gt;=&lt;span&gt;blogArticle.bsubmitter,
                btitle &lt;/span&gt;=&lt;span&gt; blogArticle.btitle,
                bcategory &lt;/span&gt;=&lt;span&gt; blogArticle.bcategory,
                bcontent &lt;/span&gt;=&lt;span&gt; blogArticle.bcontent,
                btraffic &lt;/span&gt;=&lt;span&gt; blogArticle.btraffic,
                bcommentNum &lt;/span&gt;=&lt;span&gt; blogArticle.bcommentNum,
                bUpdateTime &lt;/span&gt;=&lt;span&gt; blogArticle.bUpdateTime,
                bCreateTime &lt;/span&gt;=&lt;span&gt; blogArticle.bCreateTime,
                bRemark &lt;/span&gt;=&lt;span&gt; blogArticle.bRemark,
            };    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以这个方法的全部代码是：&lt;/p&gt;
&lt;p&gt;接口层也要添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 　　&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IBlogArticleServices :IBaseServices&amp;lt;BlogArticle&amp;gt;&lt;span&gt;
    {
        Task&lt;/span&gt;&amp;lt;List&amp;lt;BlogArticle&amp;gt;&amp;gt;&lt;span&gt; getBlogs();
        Task&lt;/span&gt;&amp;lt;BlogViewModels&amp;gt; getBlogDetails(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('97ddbc35-3df7-4e39-9c8a-b33e011cfaa7')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_97ddbc35-3df7-4e39-9c8a-b33e011cfaa7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_97ddbc35-3df7-4e39-9c8a-b33e011cfaa7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('97ddbc35-3df7-4e39-9c8a-b33e011cfaa7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_97ddbc35-3df7-4e39-9c8a-b33e011cfaa7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取视图博客详情信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;BlogViewModels&amp;gt; getBlogDetails(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bloglist = &lt;span&gt;await&lt;/span&gt; dal.Query(a =&amp;gt; a.bID &amp;gt; &lt;span&gt;0&lt;/span&gt;, a =&amp;gt;&lt;span&gt; a.bID);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; idmin = bloglist.FirstOrDefault() != &lt;span&gt;null&lt;/span&gt; ? bloglist.FirstOrDefault().bID : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; idmax = bloglist.LastOrDefault() != &lt;span&gt;null&lt;/span&gt; ? bloglist.LastOrDefault().bID : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; idminshow =&lt;span&gt; id;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; idmaxshow =&lt;span&gt; id;

            BlogArticle blogArticle &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BlogArticle();

            blogArticle &lt;/span&gt;= (&lt;span&gt;await&lt;/span&gt; dal.Query(a =&amp;gt; a.bID ==&lt;span&gt; idminshow)).FirstOrDefault();

            BlogArticle prevblog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BlogArticle();


            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (idminshow &amp;gt;&lt;span&gt; idmin)
            {
                idminshow&lt;/span&gt;--&lt;span&gt;;
                prevblog &lt;/span&gt;= (&lt;span&gt;await&lt;/span&gt; dal.Query(a =&amp;gt; a.bID ==&lt;span&gt; idminshow)).FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prevblog != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }

            BlogArticle nextblog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BlogArticle();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (idmaxshow &amp;lt;&lt;span&gt; idmax)
            {
                idmaxshow&lt;/span&gt;++&lt;span&gt;;
                nextblog &lt;/span&gt;= (&lt;span&gt;await&lt;/span&gt; dal.Query(a =&amp;gt; a.bID ==&lt;span&gt; idmaxshow)).FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nextblog != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }


            blogArticle.btraffic &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; dal.Update(blogArticle, &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btraffic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });

            BlogViewModels models &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BlogViewModels()
            {
                bsubmitter&lt;/span&gt;=&lt;span&gt;blogArticle.bsubmitter,
                btitle &lt;/span&gt;=&lt;span&gt; blogArticle.btitle,
                bcategory &lt;/span&gt;=&lt;span&gt; blogArticle.bcategory,
                bcontent &lt;/span&gt;=&lt;span&gt; blogArticle.bcontent,
                btraffic &lt;/span&gt;=&lt;span&gt; blogArticle.btraffic,
                bcommentNum &lt;/span&gt;=&lt;span&gt; blogArticle.bcommentNum,
                bUpdateTime &lt;/span&gt;=&lt;span&gt; blogArticle.bUpdateTime,
                bCreateTime &lt;/span&gt;=&lt;span&gt; blogArticle.bCreateTime,
                bRemark &lt;/span&gt;=&lt;span&gt; blogArticle.bRemark,
            };

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nextblog != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                models.next &lt;/span&gt;=&lt;span&gt; nextblog.btitle;
                models.nextID &lt;/span&gt;=&lt;span&gt; nextblog.bID;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prevblog != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                models.previous &lt;/span&gt;=&lt;span&gt; prevblog.btitle;
                models.previousID &lt;/span&gt;=&lt;span&gt; prevblog.bID;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; models;

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;想了想这才是一个方法，一般的系统都会有少则几十，多则上百个这样的方法，这还不算，大家肯定遇到过一个情况，如果有一天要在页面多显示一个字段，噗！不是吧，首先要存在数据库，然后在该实体类就应该多一个，然后再在每一个赋值的地方增加一个，而且也没有更好的办法不是，一不小心就少了一个，然后被产品测试说咱们不细心，心塞哟，别慌！神器来了，一招搞定。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、先来引入DTO讲解，以及它的原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在学习EF的时候我们知道了ORM（Object Relational Mapping）映射，是一种对象关系的映射，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。&lt;/p&gt;
&lt;p&gt;而Automapper是一种实体转换关系的模型，AutoMapper是一个.NET的对象映射工具。主要作用是进行领域对象与模型（DTO）之间的转换、数据库查询结果映射至实体对象。&lt;/p&gt;
&lt;p&gt;下边的是基本原理，大家喵一眼就行：&lt;/p&gt;
&lt;blockquote readability=&quot;26&quot;&gt;
&lt;p&gt;Ø 什么是DTO?&lt;br/&gt;　　数据传输对象（DTO)(DataTransfer Object)，是一种设计模式之间传输数据的软件应用系统。数据传输目标往往是数据访问对象从而从数据库中检索数据。数据传输对象与数据交互对象或数据访问对象之间的差异是一个以不具有任何行为除了存储和检索的数据（访问和存取器）。&lt;/p&gt;
&lt;p&gt;Ø 为什么用？&lt;br/&gt;　　它的目的只是为了对领域对象进行数据封装，实现层与层之间的数据传递。为何不能直接将领域对象用于数据传递？因为领域对象更注重领域，而DTO更注重数据。不仅如此，由于“富领域模型”的特点，这样做会直接将领域对象的行为暴露给表现层。&lt;/p&gt;
&lt;p&gt;　　需要了解的是，数据传输对象DTO本身并不是业务对象。数据传输对象是根据UI的需求进行设计的，而不是根据领域对象进行设计的。比如，Customer领域对象可能会包含一些诸如FirstName, LastName, Email, Address等信息。但如果UI上不打算显示Address的信息，那么CustomerDTO中也无需包含这个 Address的数据”。&lt;/p&gt;
&lt;p&gt;Ø 什么是领域对象？&lt;br/&gt;　　&lt;span&gt;领域模型就是面向对象的，面向对象的一个很重要的点就是：“把事情交给最适合的类去做”，即：“你得在一个个领域类之间跳转，才能找出他们如何交互”。在我们的系统中Model（EF中的实体）就是领域模型对象。领域对象主要是面对业务的，我们是通过业务来定义Model的。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上的这些大家简单看看原理即可，意思大家肯定都懂，下边开始讲解如何使用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、在Blog.Core.Services项目中引用Nuget包，AutoMapper 和 AutoMapper.Extensions.Microsoft.DependencyInjection&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;AutoMapper.Extensions.Microsoft.DependencyInjection，这个是用来配合依赖注入的，看名字也能看的出来吧，大家回忆下，整个项目中，都是使用的依赖注入，所以尽量不要用new 来实例化，导致层耦合。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4、基于上边原理，在接口层Blog.Core 中，添加文件夹AutoMapper，然后添加映射配置文件 CustomProfile.cs，用来匹配所有的映射对象关系&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomProfile : Profile
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 配置构造函数，用来创建关系映射
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CustomProfile()
        {
            CreateMap&lt;/span&gt;&amp;lt;BlogArticle, BlogViewModels&amp;gt;&lt;span&gt;();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;大家看下F12这个CreateMap方法&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;public IMappingExpression&amp;lt;TSource, TDestination&amp;gt; CreateMap&amp;lt;TSource, TDestination&amp;gt;();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一个参数是原对象，第二个是目的对象，所以，要想好，是哪个方向转哪个，当然可以都写上，比如&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;CreateMap&amp;lt;BlogArticle, BlogViewModels&amp;gt;();&lt;/p&gt;
&lt;p&gt;CreateMap&amp;lt;BlogViewModels, BlogArticle&amp;gt;();&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、修改上边服务层BlogArticleServices.cs 中getBlogDetails 方法中的赋值，改用AutoMapper，并用构造函数注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最终的代码是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　 IBlogArticleRepository dal;
        IMapper IMapper;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BlogArticleServices(IBlogArticleRepository dal, IMapper IMapper)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dal =&lt;span&gt; dal;
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;.baseDal =&lt;span&gt; dal;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.IMapper =&lt;span&gt; IMapper;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;BlogViewModels&amp;gt; getBlogDetails(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bloglist = &lt;span&gt;await&lt;/span&gt; dal.Query(a =&amp;gt; a.bID &amp;gt; &lt;span&gt;0&lt;/span&gt;, a =&amp;gt;&lt;span&gt; a.bID);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; idmin = bloglist.FirstOrDefault() != &lt;span&gt;null&lt;/span&gt; ? bloglist.FirstOrDefault().bID : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; idmax = bloglist.LastOrDefault() != &lt;span&gt;null&lt;/span&gt; ? bloglist.LastOrDefault().bID : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; idminshow =&lt;span&gt; id;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; idmaxshow =&lt;span&gt; id;

            BlogArticle blogArticle &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BlogArticle();

            blogArticle &lt;/span&gt;= (&lt;span&gt;await&lt;/span&gt; dal.Query(a =&amp;gt; a.bID ==&lt;span&gt; idminshow)).FirstOrDefault();

            BlogArticle prevblog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BlogArticle();


            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (idminshow &amp;gt;&lt;span&gt; idmin)
            {
                idminshow&lt;/span&gt;--&lt;span&gt;;
                prevblog &lt;/span&gt;= (&lt;span&gt;await&lt;/span&gt; dal.Query(a =&amp;gt; a.bID ==&lt;span&gt; idminshow)).FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prevblog != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }

            BlogArticle nextblog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BlogArticle();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (idmaxshow &amp;lt;&lt;span&gt; idmax)
            {
                idmaxshow&lt;/span&gt;++&lt;span&gt;;
                nextblog &lt;/span&gt;= (&lt;span&gt;await&lt;/span&gt; dal.Query(a =&amp;gt; a.bID ==&lt;span&gt; idmaxshow)).FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nextblog != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }


            blogArticle.btraffic &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; dal.Update(blogArticle, &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btraffic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意就是这里&lt;/span&gt;
            BlogViewModels models = IMapper.Map&amp;lt;BlogViewModels&amp;gt;&lt;span&gt;(blogArticle);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nextblog != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                models.next &lt;/span&gt;=&lt;span&gt; nextblog.btitle;
                models.nextID &lt;/span&gt;=&lt;span&gt; nextblog.bID;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prevblog != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                models.previous &lt;/span&gt;=&lt;span&gt; prevblog.btitle;
                models.previousID &lt;/span&gt;=&lt;span&gt; prevblog.bID;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; models;

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;6、老规矩，还是在Startup中，注入服务&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;services.AddAutoMapper(typeof(Startup));//这是AutoMapper的2.0新特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;7、修改BlogController.cs中的 Get(int id)方法，运行项目，断点调试，发现已经成功了，是不是很方便，你也可以反过来试一试&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
　　　　 [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; model = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; blogArticleServices.getBlogDetails(id);//调用该方法
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;new&lt;/span&gt; { success = &lt;span&gt;true&lt;/span&gt;, data =&lt;span&gt; model };
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831114151191-823961312.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、好啦，DTOs就到这里了，我们的ConfigureServices也基本告一段落了，主要有这些&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831114312408-541462772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;1、在项目Blog.Core中，右键，发布，选择文件，相信大家都会，不会的可以联系我&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831114535427-113619262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;注意: &lt;/span&gt;这里有一个坑，还记得我们用swagger中使用的两个xml文件么，编译的时候有，但是.net core官方限制了在发布的时候包含xml文件，所以我们需要处理下&lt;/p&gt;
&lt;p&gt;在项目工程文件WebApplication1.csproj中，增加&lt;/p&gt;
&lt;p&gt;&amp;lt;PropertyGroup&amp;gt;&lt;br/&gt;　　&amp;lt;GenerateDocumentationFile&amp;gt;true&amp;lt;/GenerateDocumentationFile&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/PropertyGroup&amp;gt;&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;当然我们还可以基于CLI的Publish命令进行发布，只需切换到Light.API根目录下，输入以下命令即可：&lt;/p&gt;
&lt;p&gt;dotnet publish --framework netcoreapp1.1 --output &quot;E:\Publish&quot; --configuration Release&lt;/p&gt;
&lt;p&gt;framework表示目标框架，output表示要发布到的目录文件夹，configuration表示配置文件，等同于和上面我们通过管理器来发布的操作&lt;/p&gt;
&lt;p&gt;具体的大家可以自行实验&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2、一定要在服务器中安装.Net Core SDK (已安装则跳过):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　地址：&lt;a href=&quot;https://www.microsoft.com/net/download&quot; target=&quot;_blank&quot;&gt;https://www.microsoft.com/net/download&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　在CMD命令窗口下，输入 dotnet 查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831115119276-677368523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、安装WindowsHosting(已安装则跳过)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　IIS安装服务器上安装DotNetCore.X.X.X-WindowsHosting安装成功后重启IIS服务器。根据版本选择下载&lt;/p&gt;
&lt;p&gt;　　下载地址：&lt;a href=&quot;https://www.microsoft.com/net/download/windows&quot; target=&quot;_blank&quot;&gt;https://www.microsoft.com/net/download/windows&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、安装AspNetCoreModule托管模块(已安装则跳过),&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　下载地址：&lt;/strong&gt;&lt;a href=&quot;https://download.microsoft.com/download/5/C/1/5C190037-632B-443D-842D-39085F02E1E8/DotNetCore.2.0.3-WindowsHosting.exe&quot; target=&quot;_blank&quot;&gt;点击我下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831115012962-1021360839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、应用池配置为无托管代码&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;（网上解释：ASP.NET Core不再是由IIS工作进程（w3wp.exe）托管，而是使用自托管Web服务器（Kestrel）运行，IIS则是作为反向代理的角色转发请求到Kestrel不同端口的ASP.NET Core程序中，随后就将接收到的请求推送至中间件管道中去，处理完你的请求和相关业务逻辑之后再将HTTP响应数据重新回写到IIS中，最终转达到不同的客户端（浏览器，APP，客户端等）。而配置文件和过程都会由些许调整，中间最重要的角色便是AspNetCoreModule，它是其中一个的IIS模块，请求进入到IIS之后便立即由它转发，并迅速重定向到ASP.NET Core项目中，所以这时候我们无需设置应用程序池来托管我们的代码，它只负责转发请求而已）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831115250190-1489669653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、如果需要读写根目录权限，要更改应用池 ApplicationPoolIdentity&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、如果没有出现正常的页面，你可以打开错误日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在发布的时候，会有一个web.config出现，通过修改web.config 启用错误日志查看详细错误信息&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt; 将stdoutLogEnabled的修改为 true，并在应用程序根目录添加 logs 文件夹&lt;/p&gt;
&lt;p&gt;一定要手动添加logs文件，不然会不出现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831115641825-1601833904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、只要本地能通过，常见的错误就是生成的文件不全导致的，大家可以自行看看，如果有问题，也可以大家一起解决&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;9、在IIS中启动项目，或者直接输入服务器IP地址，加端口调试&lt;/p&gt;
&lt;p&gt;注意：这里有一个小问题，因为发布以后，默认启动页是在开发环境中重定向到了swagger，但是在服务器部署以后，不能跳转，大家打开后会这样，404找不到，不要怕，&lt;/p&gt;
&lt;p&gt;只需要在后边加上Swagger就行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831131614211-2109702618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;1、在腾讯云购买Ubuntu服务器后，登陆，然后进入命令页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831120130571-1790349775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、部署Linux系统中的微软环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继续执行下面的命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Register the trusted Microsoft signature key:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &amp;gt; microsoft.gpg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;继续&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据系统版本，执行下面的命令&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;sudo sh -c 'echo &quot;deb [arch=amd64] https://packages.microsoft.com/repos/microsoft-ubuntu-xenial-prod xenial main&quot; &amp;gt; /etc/apt/sources.list.d/dotnetdev.list'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，环境部署完毕，下面我们安装 SDK&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、部署.Ne Core 环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
sudo apt-get install apt-transport-https
sudo apt-get update
sudo apt-get install dotnet-sdk-2.1.4
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt; 安装成功后，输入命令 dotnet &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831123210190-872721508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;证明安装成功啦&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、安装代码上传工具，Fillzila或者winSCP都可以，（我用的是winSCP）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件下好打开后界面是这样的，我们需要填的就是主机名（你服务器的公网IP）、用户名（服务器的用户名）、密码（你买服务器时设置的密码），那个文件协议就是SFTP，不用改变&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831123434113-573416207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、登陆进去默认是 /Home/ubuntu 文件夹，我们都在这里操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831130050990-2076043209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;strong&gt;6、下面我们在服务器新建一个控制台项目测试一下&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
dotnet new console -o myApp
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831124704035-1622759572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就在winSCP发现多了一个项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831124746862-2065860027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 7、然后运行我们刚刚创建的项目&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cd myApp&lt;br/&gt;dotnet run&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468246/201808/1468246-20180831124924162-701969334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码一起正常！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、把我们的项目发布上去&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;未完待续中...&lt;/p&gt;


&lt;p&gt;今天暂时就先写到这里，我们学到了如何用AutoMapper来实现DTO数据对象映射，也学会了在windows下的IIS中发布项目，最后就是Linux系统中，搭建环境和运行.net core 。但是还没有完成，我会慢慢补充上来，除了继续发布以外，还包括如何桌面话Linux系统，Nginx代理等等，大家拭目以待吧&lt;/p&gt;



&lt;p&gt; &lt;a href=&quot;https://github.com/anjoy8/Blog.Core&quot; target=&quot;_blank&quot;&gt;https://github.com/anjoy8/Blog.Core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/laozhangIsPhi/Blog.Core&quot; target=&quot;_blank&quot;&gt;https://gitee.com/laozhangIsPhi/Blog.Core&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 31 Aug 2018 04:54:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>代码已上传Github+Gitee，文末有地址 番外：时间真快，今天终于到了系统打包的日子，虽然项目还是有很多问题，虽然后边还有很多的内容要说要学，但是想着初级基本的.Net Core 用到的基本至少</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/9565227.html</dc:identifier>
</item>
<item>
<title>一个小白的测试环境docker化之路 - 网易云</title>
<link>http://www.cnblogs.com/163yun/p/9565219.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/163yun/p/9565219.html</guid>
<description>&lt;p&gt;本文来自&lt;a href=&quot;https://sq.163yun.com/blog?tag=M_tg_160_65&quot; target=&quot;_self&quot;&gt;网易云社区&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者：叶子&lt;/p&gt;

&lt;p&gt;学习docker搭建测试环境断断续续也有三个多月了，希望记录一下这个过程。常言道，总结过去，展望未来嘛~文章浅显，还望各位大神路过轻拍。&lt;/p&gt;
&lt;p&gt;按照国际惯例，先说一下背景：&lt;/p&gt;
&lt;p&gt;目前我所处的项目组不断扩大和发展，因此质量保障维度也需要不断扩展。然而多种质量保障维度的开展需要多套测试环境的支持，目前项目组里只有一套测试环境，按照传统方法一步步手工搭建测试环境费时费力，有什么方法可以迅速搭建环境呢？当然是近几年大火的docker啦。可是我是docker小白，之前只是简单地看过几篇docker入门的帖子，去官网上按照tutorial敲了一遍命令，但总感觉是纸上谈兵，一到实战环节，依然无从下手。&lt;/p&gt;

&lt;p&gt;中国首富王健林说：“先定一个小目标“。我们的项目里面除了java web应用就是java app应用，java web应用说白了就是tomcat么，以前自己手动部署过，看上去不会太难，那就从这个开始，先用docker部署一个项目中的tomcat应用好了。docker方面的知识是零基础，老大推荐了一本书叫《第一本docker书》。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180831124443df12b826-071f-4276-b4ef-7a1394d26276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这本书浅显易懂，适合我这个小白，粗粗读完前4章后，我就感觉自己可以上路了。&lt;/p&gt;

&lt;p&gt;测试环境的应用模块部署都是在ndp平台上部署的，先简单了解下ndp平台部署web应用的原理，就是将代码从git上拉下来，编译打包好，找一台云主机，这台云主机上安装了jdk和tomcat，然后把打包好的代码放进tomcat里，设置下端口号，启动起来就好了。那如果用docker怎么部署呢？读完docker书就知道，其实一个docker容器就相当于一台云主机，我们的云主机是linux系统，拉一个linux系统的镜像，启动这个镜像的容器后，我在里面装个jdk和tomcat，这不就和我们的云主机环境一模一样了嘛~  &lt;/p&gt;

&lt;p&gt;到这里思路就清晰多了，第一步先搞个和云主机环境一样的docker容器，网上搜了一下后，发现直接就有现成的tomcat镜像，tomcat本身也依赖jdk，而且也是基于linux环境的，第一步立马就做完了，这速度杠杠滴。那接下来就是拉取代码，编译打包，然后放进去启动就可以了。于是乎，第一个问题就碰到了，代码是有权限的，不是随便就可以拉取的。回想以前在云主机上拉取代码，是在这台云主机上生成一对ssh密钥，然后把公钥上传到git lab上，这样就能获得拉取代码的权限了。都说实践是检验真理的唯一标准，赶紧在刚刚启动的docker容器里试了一把，恩，行得通！可是这才一个docker容器啊，如果我再来几个docker容器，每个容器都要生成一对ssh密钥，然后上传，岂不累死。 怎么办呢？马克思主义哲学说道过，要透过现象看本质，git识别权限的本质是什么？是在于私钥和公钥的匹配！公钥在git服务器上，那我本地只要有对应的私钥就可以了呀，我在创建容器的时候把一个git已有的公钥所匹配的私钥放进去，这样容器就自带git权限了嘛。  &lt;/p&gt;
&lt;p&gt;代码拉下来以后，下一步就是编译打包，那先研究下ndp平台是怎么部署我们测试环境的web应用的吧。看了一下，在ndp平台上找到了这个web应用的一个build.xml，咦，这不就是ant工具的执行脚本么，仔细一读，果然是个编译打包的脚本，其中关键的步骤是利用mvn clean install进行编译打包的。ok，那在刚刚启动的容器里安装一下ant和maven工具，然后用ant命令执行下这个build.xml，大功告成！  &lt;/p&gt;
&lt;p&gt;执行完ant命令以后，发现生成了一个compressed的文件夹，里面主要是编译打包后生成的东西，如下图：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180831124459055e6cb3-b438-4df6-8a51-0a391e866630.png&quot; alt=&quot;&quot;/&gt; 那么这些编译打包好的东西应该放在哪里呢？再一次研究一下ndp部署的tomcat应用的目录层级，心里估摸着我把docker容器中的目录层级弄得和ndp一样应该不会有什么问题。经过对比发现，compressed文件内容和测试环境tomcat应用的webroot文件内容是一样的，吼吼~  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180831124509925798f4-68ab-48e7-afb2-9961ac3387ba.png&quot; alt=&quot;&quot;/&gt; 此外，其他目录层级不一样的地方罗列了一下，大概有如下几个：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018083112451902deb610-bef3-46ab-a6fa-7b7fb67b6380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大致读了读，tomcat是个脚本文件，用于启动tomcat服务用的，里面调用了./default/tomcat、init-functions和ratatelogs文件，那就把这些需要的文件都拷贝过来，并确保tomcat脚本里所有的调用路径都正确。  &lt;/p&gt;
&lt;p&gt;另外还需要修改的server.xml，将docBase地址指定为compressed的绝对路径  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180831124530f3719a0d-3e69-4903-9390-42328b4bd076.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;将两边目录层级弄的一模一样后，就到了见证奇迹的时刻，运行启动命令：  &lt;/p&gt;
&lt;pre&gt;
./tomcat start
&lt;/pre&gt;
&lt;p&gt;查看日志发现正常启动，并无异常报错，这真是个好兆头。再用浏览器试试是否能访问成功，看到预期的网页打开了：）至此，第一个用docker方式部署的web应用模块就完成啦  &lt;/p&gt;
&lt;p&gt;鉴于项目里有多个不同的web模块，它们所依赖的基础环境都一样，因此打算构建一个基础镜像，将所需要的相同的配置文件都放入基础镜像中，然后各自模块的编译打包过程写成一个Dockerfile，这样就不用在容器里手敲命令进行编译打包了，Dockerfile伪代码如下：  &lt;/p&gt;
&lt;pre&gt;
FROM tomcat 基础镜像git clone 代码COPY build.xml, 配置文件等到容器里指定的路径RUN build.xml，生成打包文件COPY 打包文件 TO destination filestart 启动运行模块
&lt;/pre&gt;
&lt;p&gt;web应用搞定后，接下来就是java app模块了。看了一下环境依赖，只需要装个jdk环境就行，然后ndp上同样有java app的构建脚本build.xml，再研究下npd部署的java app的目录结构，该拷贝的拷贝，该修改的修改，照猫画虎弄一遍，也启动成功了。  &lt;/p&gt;
&lt;p&gt;接下来就是优化下tomcat和java app这两个基础镜像，然后再写写各自模块的Dockerfile就行了  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808311245447518e879-f314-40c0-b723-21a0aec2a791.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;每个模块都有自己的Dockerfile，这样就能迅速构建模块镜像并启动部署了。至此，利用docker部署项目的应用模块就完成了。  &lt;/p&gt;
&lt;p&gt;感谢上述过程中提供大力帮助的集美貌与才华于一身的婷婷同学~  &lt;/p&gt;
&lt;p&gt;--------------------  &lt;/p&gt;
&lt;p&gt;踩过的坑：  &lt;/p&gt;
&lt;p&gt;1、在执行build.xml脚本进行构建时，遇到类似如下的报错：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018083112460620df496c-b9c1-4bae-b6a1-88ba35bbb41a.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;

&lt;p&gt;原因是所需要的jar包因为在maven远程仓库中无法找到，首先检查一下在docker容器安装maven后，记得要把settings.xml设置成杭研的maven仓库，如果还遇到这样的错误，可能是杭研maven仓库里没有该jar包，或者因为网络等其他问题，无法下载该jar包。基本上通用的jar包都能下载成功，有一些基于模块之间依赖的jar包无法下载到，如果你本地maven仓库里有这些jar包的话，可以拷贝进容器的maven仓库里，或者在容器里拉取相互依赖模块的代码，通过mvm clean install命令将其打包进容器的maven仓库里。  &lt;/p&gt;
&lt;p&gt;2、在容器里启动应用后，遇到无法连通redis的问题：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808311246212cc0922c-062b-4088-8c45-35630632c86c.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;

&lt;p&gt;代码里填写的redis地址是云主机的私有ip地址，容器所在的宿主机与redis在不同租户下，因此无法通过私有ip进行连通访问，容器的宿主机与redis同属于一个机房，可通过机房ip进行访问，与开发协商将代码里的依赖服务的ip地址都改为机房地址。  &lt;/p&gt;
&lt;p&gt;3、在docker容器里拷贝git hub的私钥后，执行git clone命令出现以下情况：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180831124635bcdc9a7c-faee-4f46-b472-6a7ceda0d676.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;

&lt;p&gt;这个提示已经比较清楚了，.ssh/id_rsa 这个私钥文件权限 too open，修改私钥的权限：chmod 0600 id_rsa 后即可git clone代码了。  &lt;/p&gt;
&lt;p&gt;--------------------  &lt;/p&gt;
&lt;p&gt;然而好景不长，很快我们就发现针对每个应用模块写Dockerfile这种方式的不足，一是构建的镜像太多，每个模块都要构建镜像，然后启动容器，镜像也比较大，非常占空间；二是由于我们项目的特殊性，有些应用模块在构建时需要依赖别的项目的jar，当时为了图省事把依赖的jar直接放入基础镜像了，当依赖的jar发生变化时，我的基础镜像就要重新弄了，所有其他模块的镜像都要重新弄，这可要了命啊。看来此计不是长久之计，还需另谋出路。  &lt;/p&gt;
&lt;p&gt;经过之前的探索，我们知道，ndp的部署模式是一盏指路明灯，之前就是照着ndp的部署脚本照葫芦画瓢过来的，那ndp平台是怎么解决不同模块之间的打包依赖问题呢？粗粗研究了一下，发现ndp是统一在一个地方打包，然后将打包好的compressed文件分发到别的云主机上进行部署。那按照这个思路，我们也找一台容器进行统一编译打包，然后分发到不同的容器进行部署呗。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180831124648d35e1d3d-3ec6-4f02-a614-394d0f783084.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;

&lt;p&gt;如此一来，我们只需要三个基础镜像，一个是用来编译打包的镜像，只需要安装jdk，maven，ant等编译打包工程所依赖的工具，一个是tomcat镜像，一个是java环境镜像，再写一个脚本，伪代码如下：  &lt;/p&gt;
&lt;pre&gt;
get compressed file  #对应模块的打包文件get config file           #对应模块的部署配置文件start module            #启动运行模块
&lt;/pre&gt;
&lt;p&gt;如何获取对应的打包文件呢？ wget 命令可以从远程服务器上下载文件，前提是不同容器之间的网络需要互通。我们可以自己手动创建一个docker网络，然后把不同的容器都手动加入这个网络里，这样所有容器都在同一个网络里，应该就不存在网络不通的问题了。获取部署配置文件我们采用了git pull方式，在git上维护所有模块的部署配置文件。  &lt;/p&gt;
&lt;p&gt;如此一来，当部署web模块的时候就以tomcat镜像来启动容器并同时运行脚本，部署java app模块的时候就以java app镜像启动容器并同时运行脚本，如此一来就不用给每个模块写Dockerfile制作镜像了，也节省了不少构建镜像的空间。  &lt;/p&gt;
&lt;p&gt;不过虽然节省了构建镜像的空间，但容器运行的空间还是要提供的。一台云主机的基本配置是4核 CPU，8GB 内存，而项目的模块多达20几个，全部模块放在一台云主机上可吃不消。肯定要搞多台云主机作为一个集群，把容器部署到这个集群中。这时候就要用到容器编排工具了，编排工具负责以下几点：  &lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;选择最适合部署容器的机器，比如拥有最多空闲资源的机器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;发生机器故障，能自动把故障机器上的容器部署到其它节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果集群添加了新的机器，重新平衡容器的分配情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果容器故障了，重启它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Docker本身内置了容器编排功能，称为docker swarm mode。网上有很多关于docker swarm mode的资料，在此就不多阐述了，大致过程如下：  &lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建网桥：在每台云主机上创建docker_gwbridge网桥，注意，必须先创建网桥再创建swarm集群&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建集群：指定一台云主机作为manager，初始化swarm&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;加入集群：在其他云主机上运行docker swarm join命令，使其加入该swarm集群&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建服务：使用docker service create来创建service，类似docker run 命令，创建的时候可直接运行脚本，执行部署过程&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用docker service create命令创建服务的时候需要指定大量参数，每次都要敲好长的命令，可以用docker compose yaml模板，类似如下：  &lt;/p&gt;
&lt;pre&gt;
version: &quot;3.2&quot;
services:
  compile:
    image: dockercloud/hello-world
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.hostname==docker-test
    ports:
      - &quot;8080:8080&quot;
    networks:
      - overlay_net

networks:
  overlay_net:
    driver: overlay
&lt;/pre&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://www.jianshu.com/p/2217cfed29d7&quot;&gt;《Docker Compose 配置文件详解》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至此，我们解决了编译打包过程中各个模块相互依赖的问题，通过docker swarm mode方式实现了应用模块集群化部署的方式，接下来的目标就是将这些应用模块依赖的其他基础服务拆分出来，如数据库，redis，zookeeper等等，那样子才算完整的一套独立的测试环境。  &lt;/p&gt;
&lt;p&gt;&lt;span&gt;网易云&lt;/span&gt;&lt;a href=&quot;https://www.163yun.com/product/ncs?tag=M_tg_160_65&quot; target=&quot;_self&quot;&gt;容器服务&lt;/a&gt;为用户提供了无服务器容器，让企业能够快速部署业务，轻松运维服务。&lt;/p&gt;


&lt;p&gt;网易云大礼包&lt;a href=&quot;https://www.163yun.com/gift?tag=M_tg_160_65&quot;&gt;：https://www.163yun.com/gift&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来自网易云社区，经作者叶子授权发布。&lt;/p&gt;

&lt;p&gt;相关文章：&lt;br/&gt;【推荐】 &lt;a href=&quot;https://www.jianshu.com/p/d87fd6517994&quot;&gt;6本互联网技术畅销书免费送（数据分析、深度学习、编程语言）！&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 Aug 2018 04:53:00 +0000</pubDate>
<dc:creator>网易云</dc:creator>
<og:description>本文来自网易云社区 作者：叶子 学习docker搭建测试环境断断续续也有三个多月了，希望记录一下这个过程。常言道，总结过去，展望未来嘛~文章浅显，还望各位大神路过轻拍。 按照国际惯例，先说一下背景：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/163yun/p/9565219.html</dc:identifier>
</item>
<item>
<title>React Native之获取通讯录信息并实现类通讯录列表(ios android) - jackson影琪</title>
<link>http://www.cnblogs.com/jackson-zhangjiang/p/9562624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson-zhangjiang/p/9562624.html</guid>
<description>&lt;h2&gt;一,需求分析&lt;/h2&gt;
&lt;p&gt;    1,获取通讯录信息,筛选出通讯录里有多少好友在使用某个应用。&lt;/p&gt;
&lt;p&gt;    2,获取通讯录信息,实现类通讯录,可拨打电话 发短信等。&lt;/p&gt;
&lt;h2&gt;二,技术介绍与配置&lt;/h2&gt;
&lt;h3&gt;    2.1 技术介绍&lt;/h3&gt;
&lt;p&gt;          1,&lt;a href=&quot;https://www.npmjs.com/package/react-native-contacts&quot; target=&quot;_blank&quot;&gt;react-native-contacts地址&lt;/a&gt;:https://www.npmjs.com/package/react-native-contacts&lt;/p&gt;
&lt;p&gt;          2,下载安装：&lt;code&gt;npm install react-native-contacts --save&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;          3,自动链接：&lt;code&gt;react-native link react-native-contacts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;          4,react-native-contacts API介绍：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;getAll(callback)——以对象数组的形式返回所有联系人&lt;/li&gt;
&lt;li&gt;getAllWithoutPhotos——和getAll在安卓系统上是一样的，但是在iOS系统上它不会返回联系人照片的uri(因为创建这些图片会带来很大的开销)&lt;/li&gt;
&lt;li&gt;getPhotoForId(contactId, callback)——返回联系人照片的URI(或null)&lt;/li&gt;
&lt;li&gt;openContactForm (contact, callback)——在contactsUI中创建一个新的联系人并显示。添加一个联系人到通讯录。&lt;/li&gt;
&lt;li&gt;updateContact (contact, callback)——其中contact是一个具有有效recordID的对象&lt;/li&gt;
&lt;li&gt;deleteContact (contact，callback)——其中contact是一个具有有效recordID的对象&lt;/li&gt;
&lt;li&gt;getContactsMatchingString (string, callback)—其中string是匹配名称(第一个、中间、家族)的任何字符串&lt;/li&gt;
&lt;li&gt;checkPermission(callback)——只检查访问联系人ios的权限(仅限ios)&lt;/li&gt;
&lt;li&gt;requestPermission(callback)——请求仅访问ios联系人的权限(仅限ios)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          5,react-native &lt;a href=&quot;https://www.cnblogs.com/jackson-zhangjiang/p/9523927.html&quot; target=&quot;_blank&quot;&gt;SectionLis列表 类似FlatList的使用&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SectionList
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                     &lt;span&gt;{...this.props}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                    style&lt;/span&gt;&lt;span&gt;={this.props.SectionListStyle}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                     &lt;span&gt;ref&lt;/span&gt;&lt;span&gt;={s =&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; this.sectionList = s}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                    keyExtractor={this._keyExtractor}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                    sections={delData}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                    renderSectionHeader={this._renderSectionHeader}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                    renderItem={this._renderItem}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                    getItemLayout={(data, index) =&amp;gt; ({ length: this.props.sectionHeight, offset: 50 * index, index })}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;    2.2 Android配置&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;第一步&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;在android/settings.gradle文件中添加如下代码:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; include ':react-native-contacts'
&lt;span&gt;2&lt;/span&gt; project(':react-native-contacts').projectDir = &lt;span&gt;new&lt;/span&gt; File(rootProject.projectDir, '../node_modules/react-native-contacts/android')
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;第二步&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;在android/app/build.gradle文件中的dependencies标签中添加模块依赖:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt; ...
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    
&lt;span&gt;3&lt;/span&gt; &lt;span&gt; dependencies {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;   
&lt;span&gt;7&lt;/span&gt;     implementation project(':react-native-contacts')    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add this line only.&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;   
&lt;span&gt;9&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;第三步&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;在MainActivity.java文件中添加如下代码:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rt2zz.reactnativecontacts.ReactNativeContacts;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  ...
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;protected&lt;/span&gt; List&amp;lt;ReactPackage&amp;gt;&lt;span&gt; getPackages() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; Arrays.&amp;lt;ReactPackage&amp;gt;&lt;span&gt;asList(
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;           &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MainReactPackage(),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;           &lt;span&gt;new&lt;/span&gt; ReactNativeContacts()        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add this line&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     );
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;第四步&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在AndroidManifest.xml文件中添加访问通讯录权限的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 获取通讯录权限 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-permission &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.permission.READ_CONTACTS&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-permission &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.permission.WRITE_CONTACTS&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-permission &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.permission.GET_ACCOUNTS&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后直接react-native run-android运行即可 &lt;/p&gt;
&lt;h3&gt;    2.3 iOS配置  &lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;第一步&lt;/strong&gt;&lt;/h4&gt;
&lt;h4&gt;    添加库到XCode的&lt;code&gt;Libraries&lt;/code&gt;分组里 &lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1040068/201808/1040068-20180831095903835-1832977203.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1040068/201808/1040068-20180831100213425-1050820361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;    将 RCTContacts.xcodeproj下的&lt;code&gt;Products&lt;/code&gt;文件夹中的静态库文件（.a文件，拖到Xcode General--Linked FrameworksLibraries下:&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1040068/201808/1040068-20180831100149423-1156299984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;    在Xcode Build Settings--Header Searchs Paths添加下:   &lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; $(SRCROOT)/../node_modules/react-native-contacts/ios/RCTContacts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1040068/201808/1040068-20180831100700548-680458511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;第四步&lt;/h4&gt;
&lt;p&gt;    配置访问通讯录的权限，如果不配置Privacy - Contacts Usage Description到Info.plist下，会出现闪退情况。在Info.plist添加如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;NSContactsUsageDescription&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;访问通讯录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1040068/201808/1040068-20180831100941293-1663058251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面直接react-native run-ios即可运行,或直接在Xcode里 running &lt;/p&gt;
&lt;h2&gt;三,实现&lt;/h2&gt;
&lt;h3&gt;     3.1 实现的效果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1040068/201808/1040068-20180830205322380-876777029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 3.2 iOS Android 验证和请求访问权限&lt;/h3&gt;
&lt;p&gt;    Android直接可以使用react-native 自带的API验证。而iOS需要第三方验证权限。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; requestCONTACTS = () =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     let self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Platform.OS === 'android'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       PermissionsAndroid.check(PermissionsAndroid.PERMISSIONS.READ_CONTACTS).then(res =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!res || res !== 'granted'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;          PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.READ_CONTACTS, {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             'title': '申请读取通讯录权限'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             'message': '一个很牛逼的应用想借用你的通讯录，' +
&lt;span&gt; 9&lt;/span&gt;               '然后你就可以炫出自己的通讯啦。'
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;          })
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             .then(res =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt; (res !== 'granted'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 Alert.alert('访问通讯录权限没打开', '请在iPhone的“设置-隐私”选项中,允许访问您的通讯录'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;               &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                self.onButtonPressed()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;              };
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;          self.onButtonPressed()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;      });
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Contacts) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Contacts.checkPermission((err, permission) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Contacts.PERMISSION_AUTHORIZED || Contacts.PERMISSION_UNDEFINED || Contacts.PERMISSION_DENIED&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt; (permission === 'undefined'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             Contacts.requestPermission((err, permission) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt; (permission === 'authorized'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同意!&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                self.onButtonPressed()
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt; (permission === 'denied'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拒绝&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                 Alert.alert('访问通讯录权限没打开', '请在iPhone的“设置-隐私”选项中,允许访问您的通讯录'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;              }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt; (permission === 'authorized'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同意!&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            self.onButtonPressed()
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt; (permission === 'denied'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已经拒绝&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;             Alert.alert('访问通讯录权限没打开', '请在iPhone的“设置-隐私”选项中,允许访问您的通讯录'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3.3 获取通讯录列表&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;onButtonPressed() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     let self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     Contacts.getAll((err, contacts) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;       alert(JSON.stringify(contacts));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通讯录列表&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3.4 修改通讯录信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;updateContact(contacts){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; let someRecord =&lt;span&gt; contacts
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  someRecord.phoneNumbers.push({
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     label: &quot;mobile&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     number: &quot;12345678901&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  })
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; someRecord.givenName = '李四'
&lt;span&gt; 8&lt;/span&gt;   Contacts.updateContact(someRecord, (err) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; record updated&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  })
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3.5 添加通讯录信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;openContactForm(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; newPerson =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  phoneNumbers: [{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     label: &quot;mobile&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     number: &quot;15422234567&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  }],
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   familyName: &quot;张&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   givenName: &quot;张三&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  
&lt;span&gt;11&lt;/span&gt; Contacts.openContactForm(newPerson, (err) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; form is open&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3.6 删除通讯录&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;deleteContact(contacts){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;delete the second record&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   Contacts.deleteContact(contacts, (err, recordId) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; contact deleted&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;  })
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3.7 实现类通讯录列表&lt;/h3&gt;
&lt;p&gt;  ContactsList自定义的一个组件，类通讯录+字母导航，点击可滚动到对应的位置。（如需完整代码 请留言评论）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; import Contacts from 'react-native-contacts'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; import ContactsList from './ContactsList/index'
&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt; &amp;lt;View style={{ flex: 1,backgroundColor:'white',paddingTop:20,paddingBottom:20 }}&amp;gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;      &amp;lt;&lt;span&gt;ContactsList
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;           ref={s =&amp;gt; &lt;span&gt;this&lt;/span&gt;.sectionList =&lt;span&gt; s}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;           sectionListData={&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.ContactsArray}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;           sectionHeight={50&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;           initialNumToRender={&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.ContactsArray.length}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;           showsVerticalScrollIndicator={&lt;span&gt;false&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;           SectionListClickCallback={(item, index) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;           self.onDialingAction(item.number)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;          }}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;           otherAlphabet=&quot;#&quot;
&lt;span&gt;16&lt;/span&gt;         /&amp;gt;
&lt;span&gt;17&lt;/span&gt;       &amp;lt;/View&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3.8 拨打电话&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  onDialingAction = (telephone) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     let url = 'tel: ' +&lt;span&gt; telephone
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Linking.canOpenURL(url).then(supported =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;supported) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Toast.show('您的系统不支持打电话！'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Linking.openURL(url);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     }).&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; { });
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3.9 发送短信&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  onSendMessage = (telephone) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     let url = 'smsto: ' +&lt;span&gt; telephone
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Linking.canOpenURL(url).then(supported =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;supported) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Toast.show('您的系统不支持发送短信！'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Linking.openURL(url);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     }).&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; { });
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3.10 筛选出通讯录里有多少好友正在在使用某个应用&lt;/h3&gt;
&lt;p&gt;     这个功能需要后台配合,在这儿就不做过多赘述啦！&lt;/p&gt;

</description>
<pubDate>Fri, 31 Aug 2018 04:01:00 +0000</pubDate>
<dc:creator>jackson影琪</dc:creator>
<og:description>React Native之获取通讯录信息并实现类通讯录列表(ios android) 一,需求分析 1,获取通讯录信息,筛选出通讯录里有多少好友在使用某个应用。 2,获取通讯录信息,实现类通讯录,可拨</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackson-zhangjiang/p/9562624.html</dc:identifier>
</item>
<item>
<title>排查线上问题常用的几个Linux命令 - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/9562380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/9562380.html</guid>
<description>&lt;p&gt;&lt;span&gt;top&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相当于Windows任务管理器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180830181435973-1933379200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，输出结果分两部分，前5行是总览，下面是具体的进程资源占用情况。&lt;/span&gt;&lt;span&gt;下面逐行看一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第1行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;top - 18:14:58 up 112 days,  1:35,  1 user,  load average: 0.00, 0.10, 0.11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;依次表示：当前时间、系统已经运行的时间、当前登录的用户数、系统在过去的1分钟，5分钟，15分钟的负载&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（PS：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从这一行我们可以知道以下信息&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;当前时间是18:14:58&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;系统运行了112天1小时35分钟&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;当前有1个用户登录&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;在过去1分钟，5分钟，15分钟的负载分别是0.00, 0.10, 0.11&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;负载超过1，则表示超负荷&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;第2行&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Tasks: 225 total,   1 running, 224 sleeping,   0 stopped,   0 zombie&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;进程信息&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;total　　　　进程总数&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;running　　 运行中的进程数&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;sleeping　　睡眠中的进程数&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;stopped　　停止的进程数&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;zombie　　 僵尸进程数&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;（PS：&lt;/span&gt;&lt;span&gt;从这一行我们可以知道，当前总共225个进程&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第3行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cpu(s):  1.8%us,  0.9%sy,  0.0%ni, 97.1%id,  0.1%wa,  0.0%hi,  0.1%si,  0.0%st&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CPU使用情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;us ： 用户进程占用CPU百分比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sy ： 内核进程占用CPU百分比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ni ： 改变过优先级的进程占用CPU百分比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;id ： 空闲CPU百分比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wa ： IO等待的进程占用CPU百分比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;hi ： 硬中断占用CPU的百分比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;si ： 软中断占用CPU的百分比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;st ： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180830191015883-1068010877.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第4行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mem:  32879852k total, 23633040k used,  9246812k free,   311552k buffers&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;物理内存使用情况&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;total　　总的内存大小&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;used　　已使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;free　　未使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;buffers　　内核缓冲区　　　&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;可用内存 = free + buffers + cached&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第5行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Swap:  4194300k total,   255104k used,  3939196k free, 10422508k cached&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虚拟内存使用情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;其余行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180830190740590-1188957239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;free -m&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看已使用和未使用的内存情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180830192249224-379057309.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mem　　total = used + free&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Swap　　total = used + free&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可用内存 = free + buffers + cached&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(-buffers/cache) used内存数 = Mem行中的 used – buffers – cached&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(+buffers/cache) free内存数 = Mem行中的 free + buffers + cached&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iostat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180831102229753-345736082.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;格式：iostat [ 选项 ] [ &amp;lt;时间间隔&amp;gt; [ &amp;lt;次数&amp;gt; ]]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iostat -d&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iostat -d 2 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iostat -x 1 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180831104424158-1397368474.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;netstat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180831111624949-609081451.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要特别关注一下“ESTABLISHED”的数量，如果ESTABLISHED越多，表示建立的连接越多，如果一直居高不下，那么就要引起注意了，因为系统对打开的连接数是有限制的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;常见应用&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、查看连接数最多的IP&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
netstat -na | &lt;span&gt;grep&lt;/span&gt; ESTABLISHED | &lt;span&gt;awk&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $5}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; | &lt;span&gt;awk&lt;/span&gt; -F: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; | &lt;span&gt;sort&lt;/span&gt; | &lt;span&gt;uniq&lt;/span&gt; -c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;2、统计TCP不同状态的连接数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
netstat -na | &lt;span&gt;awk&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;df -h&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看文件系统磁盘空间使用情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180830173946219-30880042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;du -sh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看（计算）文件大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180830174806044-1409181080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还可以这样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;du --max-depth=2 --block-size=M&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ll --block-size=M&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其它相关&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《&lt;a href=&quot;https://www.cnblogs.com/cjsblog/p/9367043.html&quot; target=&quot;_blank&quot;&gt;Linux系统打开文件最大数量限制&lt;/a&gt;》 &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 31 Aug 2018 03:47:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<og:description>top 相当于Windows任务管理器 可以看到，输出结果分两部分，前5行是总览，下面是具体的进程资源占用情况。下面逐行看一下 第1行 top - 18:14:58 up 112 days, 1:35</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/9562380.html</dc:identifier>
</item>
<item>
<title>Asp.net Core 2.1新功能Generic Host(通用主机)深度学习 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/9564977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/9564977.html</guid>
<description>&lt;h3&gt;什么是Generic Host ?&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831113952328-1515629509.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831113953370-441769710.png&quot; alt=&quot;image&quot; width=&quot;525&quot; height=&quot;264&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是在Asp.Net Core 2.1加入了一种新的Host，现在2.1版本的Asp.Net Core中，有了两种可用的Host。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/web-host?view=aspnetcore-2.1&quot;&gt;Web Host&lt;/a&gt;&lt;/span&gt; –适用于托管Web程序的Host,就是我们所熟悉的在Asp.Net Core应用程序的Mai函数中用CreateWebHostBuilder创建出来的常用的WebHost。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831113954216-1506773566.png&quot;&gt;&lt;img title=&quot;clip_image001&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831113955237-467840215.png&quot; alt=&quot;clip_image001&quot; width=&quot;514&quot; height=&quot;172&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.1&quot;&gt;Generic Host&lt;/a&gt;&lt;/span&gt; (ASP.NET Core 2.1版本才有) – 适用于托管非 Web 应用（例如，运行后台任务的应用）。 在未来的版本中，通用主机将适用于托管任何类型的应用，包括 Web 应用。 通用主机最终将取代 Web 主机，这大概也是这种类型的主机叫做通用主机的原因，在本博客中，我们将结合源码，讨论通用主机的工作原理。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;为什么要用通用主机？&lt;/h3&gt;
&lt;p&gt;通用主机，让我可以用编写Asp.Net Core的思想（例如控制反转、依赖注入、IOC容器）来简化控制台应用程序的创建（个人见解），主机负责程序的启动和生存周期的管理，这对于不处理HTTP请求的应用程序非常有用（处理HTTP请求的是Web应用程序，用Web Host托管），通用主机的目标是将HTTP管道从Web Host中脱离出来，使得Asp.Net Core的那套东西也适用于其他.Net Core程序。&lt;/p&gt;
&lt;h3&gt;Demo下载&lt;/h3&gt;
&lt;p&gt;在开始跟随我分析通用主机之前，大家可以到Github下载这个官方Demo。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/aspnet/Docs/tree/master/aspnetcore/fundamentals/host/generic-host/samples/&quot;&gt;https://github.com/aspnet/Docs/tree/master/aspnetcore/fundamentals/host/generic-host/samples/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果觉得下载一整个比较慢，可以从我的这个Github仓库下载，没有其他多余内容，国内Github比较慢，如果你从官方那个仓库下载可能会需要很长时间甚至失败。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liuzhenyulive/Generic-Host-Demo&quot;&gt;https://github.com/liuzhenyulive/Generic-Host-Demo&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;首先，大家打开下载下来的这个官方Demo,进入Main函数。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831113956452-106969531.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831113957527-412059643.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;176&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这简直就是一个精简版的Asp.Net Core应用程序，对这个Main函数中出现的所有方法，大家对Asp.Net Core Web应用程序比较熟悉，所以我与Asp.net core 的Webhost做了一个对比，来帮助大家找找感觉。&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;346&quot;&gt;通用主机&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;490&quot;&gt;Web主机&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;361&quot;&gt;new HostBuilder()&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;490&quot;&gt;WebHost.CreateDefaultBuilder(args)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;365&quot;&gt;ConfigureAppConfiguration&lt;br/&gt;(用于配置Configuration)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;490&quot;&gt;WebHost也有这个方法，只是大家默认可能没有调用。&lt;br/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831113958480-1749314166.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831113959390-524283000.png&quot; alt=&quot;image&quot; width=&quot;474&quot; height=&quot;167&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;365&quot;&gt;ConfigureServices&lt;br/&gt;(用于配置Service，也就是依赖注入)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;490&quot;&gt;WebHost其实也有ConfigureServices方法，可以这么调用。&lt;br/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831114000261-989659843.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831114001259-612924156.png&quot; alt=&quot;image&quot; width=&quot;477&quot; height=&quot;130&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;但是我们一般很少这么用，一般都是放在Startup的ConfigureServices方法中进行依赖注入。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;365&quot;&gt;ConfigureLogging&lt;br/&gt;(是本应用程序所需要的配置，非必需）&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;490&quot;&gt;WebHost还是有！&lt;br/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831114002173-1249405742.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831114003076-82359305.png&quot; alt=&quot;image&quot; width=&quot;465&quot; height=&quot;110&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;365&quot;&gt;builder.RunConsoleAsync()&lt;br/&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831114003889-1610525799.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831114004700-22948588.png&quot; alt=&quot;image&quot; width=&quot;343&quot; height=&quot;85&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;RunConsoleAsync中其实是对hostbuilder进行&lt;br/&gt;Builder然后Run&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;490&quot; readability=&quot;5&quot;&gt;CreateWebHostBuilder(args).Build().Run();&lt;p&gt;也就是Main函数中的Build().Run();&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;365&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;无无无无&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;490&quot;&gt;Startup中的Configure()方法&lt;br/&gt;Asp.net core在此方法中进行Http请求管道的配置&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;综上对比，我做了如下概括！&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通用主机（Generic Host）有的 Web Host都有。&lt;/li&gt;
&lt;li&gt;Web Host的Http Pipeline即Startup.Configure() 在通用主机中没有。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这就应证了开头所说的：&lt;span&gt;&lt;span&gt;&lt;strong&gt;通用主机的目标是将HTTP管道从Web Host中脱离出来，使得Asp.Net Core的那套东西也适用于其他.Net Core程序。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;Run函数解读&lt;/h2&gt;
&lt;p&gt;我觉得要知道怎么用，那么我们就首先要知道Host的Run方法内到底是在执行什么？&lt;/p&gt;
&lt;p&gt;所以我们深入源码，一路F12!&lt;/p&gt;
&lt;p&gt;builder.&lt;span&gt;RunConsoleAsync();&lt;/span&gt; =&amp;gt;hostBuilder.UseConsoleLifetime().Build().&lt;span&gt;RunAsync(cancellationToken);&lt;/span&gt;=&amp;gt; await host.&lt;span&gt;StartAsync(token);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;总算找到了，最关键的在这里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task StartAsync(CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt; (CancellationToken))
    {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._logger.Starting();
      TaskCompletionSource&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; completionSource1 = &lt;span&gt;new&lt;/span&gt; TaskCompletionSource&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();

      &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt; CancellationToken local = &lt;span&gt;ref&lt;/span&gt;&lt;span&gt; cancellationToken;
      TaskCompletionSource&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; completionSource2 =&lt;span&gt; completionSource1;
      local.Register((Action&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;) (obj =&amp;gt; ((TaskCompletionSource&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;) obj).TrySetCanceled()), (&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) completionSource2);

      IHostLifetime hostLifetime1 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._hostLifetime;
      TaskCompletionSource&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; completionSource3 =&lt;span&gt; completionSource1;
      hostLifetime1.RegisterDelayStartCallback((Action&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;) (obj =&amp;gt; ((TaskCompletionSource&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;) obj).TrySetResult((&lt;span&gt;object&lt;/span&gt;) &lt;span&gt;null&lt;/span&gt;)), (&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) completionSource3);

      IHostLifetime hostLifetime2 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._hostLifetime;
      ApplicationLifetime applicationLifetime &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._applicationLifetime;
      hostLifetime2.RegisterStopCallback((Action&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;) (obj =&amp;gt; (obj &lt;span&gt;as&lt;/span&gt; IApplicationLifetime)?.StopApplication()), (&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) applicationLifetime);

      &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; task = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; completionSource1.Task;
      &lt;/span&gt;
&lt;/pre&gt;
&lt;span&gt;&lt;span&gt;this&lt;/span&gt;._hostedServices = &lt;span&gt;this&lt;/span&gt;.Services.GetService&amp;lt;IEnumerable&amp;lt;IHostedService&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;();&lt;/span&gt; &lt;span&gt;foreach&lt;/span&gt; (IHostedService hostedService &lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;._hostedServices)&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; hostedService.StartAsync(cancellationToken).ConfigureAwait(&lt;span&gt;false&lt;/span&gt;&lt;/span&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;);&lt;/span&gt;

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._applicationLifetime?&lt;span&gt;.NotifyStarted();
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._logger.Started();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;知道大家都喜欢Yellow色，所以我用Yellow把最关键的代码标示出来了，那么这些代码有什么含义呢？&lt;/p&gt;
&lt;p&gt;this._hostedServices = this.Services.GetService&amp;lt;IEnumerable&amp;lt;IHostedService&amp;gt;&amp;gt;();&lt;/p&gt;
&lt;p&gt;这一行的意思是，从容器中取出所有实现了IHostedService的服务。&lt;/p&gt;
&lt;p&gt;这就意味着，我们实现了IHostedService后，需要把该Service注册到IOC容器中。&lt;/p&gt;
&lt;p&gt;foreach (IHostedService hostedService in this._hostedServices)&lt;br/&gt;      await hostedService.StartAsync(cancellationToken).ConfigureAwait(false);&lt;/p&gt;
&lt;p&gt;执行每个服务的StartAsync方法。&lt;/p&gt;
&lt;p&gt;所以，大家是不是冥冥中猜到了怎么用的呢？&lt;img class=&quot;wlEmoticon wlEmoticon-laughingoutloud&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831114005402-1179006110.png&quot; alt=&quot;大声笑&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我总结的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自定义一个Service,继承 IHostedService接口。&lt;/li&gt;
&lt;li&gt;实现 IHostedService的StartAsync方法，把需要执行的任务放到这个方法中。&lt;/li&gt;
&lt;li&gt;把该服务注册到IOC容器（ServiceCollection）中。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;自定义任务的运行&lt;/h2&gt;
&lt;h4&gt;对于步骤1和2,对应的代码如下：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PrintTextToConsoleService : IHostedService, IDisposable
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ILogger _logger;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IOptions&amp;lt;AppConfig&amp;gt;&lt;span&gt; _appConfig;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Timer _timer;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PrintTextToConsoleService(ILogger&amp;lt;PrintTextToConsoleService&amp;gt; logger, IOptions&amp;lt;AppConfig&amp;gt;&lt;span&gt; appConfig)
        {
            _logger &lt;/span&gt;=&lt;span&gt; logger;
            _appConfig &lt;/span&gt;=&lt;span&gt; appConfig;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task StartAsync(CancellationToken cancellationToken)
        {
            _logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            _timer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Timer(DoWork, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, TimeSpan.Zero,
                TimeSpan.FromSeconds(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;));

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DoWork(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; state)
        {
            _logger.LogInformation($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Background work with text: {_appConfig.Value.TextToPrint}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task StopAsync(CancellationToken cancellationToken)
        {
            _logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stopping.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            _timer&lt;/span&gt;?.Change(Timeout.Infinite, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            _timer&lt;/span&gt;?&lt;span&gt;.Dispose();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，在StartAsync中，定义了一个定时任务，带定时任务每五秒执行一次DoWork方法。&lt;/p&gt;
&lt;p&gt;在DoWork方法中，日志记录器记录了一段内容。&lt;/p&gt;
&lt;p&gt;因为在Main方法中，对Log进行了如下的配置。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831114006184-1075711214.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831114007166-1105618302.png&quot; alt=&quot;image&quot; width=&quot;787&quot; height=&quot;102&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以，一旦日志记录了内容，该内容就会在控制台中输出。&lt;/p&gt;
&lt;h4&gt;对于步骤3,对应的代码如下&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt; HostBuilder()    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化一个通用主机&lt;/span&gt;
                .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;&lt;span&gt;
                {
                    config.AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, optional: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    config.AddEnvironmentVariables();

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        config.AddCommandLine(args);
                    }
                }) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置Configuration&lt;/span&gt;
                .ConfigureServices((hostContext, services) =&amp;gt;&lt;span&gt;
                {
                    services.AddOptions();
                    services.Configure&lt;/span&gt;&amp;lt;AppConfig&amp;gt;(hostContext.Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppConfig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                    &lt;span&gt;services.AddSingleton&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;span&gt;&amp;lt;IHostedService, PrintTextToConsoleService&amp;gt;&lt;/span&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;();&lt;/span&gt;
                })    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置Service （依赖注入）&lt;/span&gt;
                .ConfigureLogging((hostingContext, logging) =&amp;gt;&lt;span&gt; {
                    logging.AddConfiguration(hostingContext.Configuration.GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                    logging.AddConsole();
                });   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置Log （本项目中要利用Log把内容在控制台输出）&lt;/span&gt;

            &lt;span&gt;await&lt;/span&gt; builder.RunConsoleAsync();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在控制台应用程序中运行通用主机&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;黄色部分，把实现了IHostedService接口的PrintTextToConsoleService注册到容器中。&lt;/p&gt;

&lt;h2&gt;F5 运行&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831114008014-1994845398.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180831114008960-487850147.png&quot; alt=&quot;image&quot; width=&quot;676&quot; height=&quot;200&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到，控制台中，每五秒就有一次内容输出，说明DoWork方法没五秒被执行了一次，也说明PrintTextToConsoleService的StartAsync被成功调用了。&lt;/p&gt;

&lt;p&gt;希望本文对帮助大家理解通用主机能够有所帮助，如果对.Net Core的源码分析、潮流新技术感兴趣&lt;/p&gt;
&lt;p&gt;欢迎关注我&lt;/p&gt;
&lt;p&gt;不定期推出实用干活，谢谢！&lt;/p&gt;
&lt;p&gt;参考文献&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.1&quot; href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.1&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 Aug 2018 03:40:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>什么是Generic Host ? 这是在Asp.Net Core 2.1加入了一种新的Host，现在2.1版本的Asp.Net Core中，有了两种可用的Host。 Web Host –适用于托管W</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/9564977.html</dc:identifier>
</item>
</channel>
</rss>