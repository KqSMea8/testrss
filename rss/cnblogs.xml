<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>你也能写个 Shadowsocks - 云加社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/8310510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/8310510.html</guid>
<description>[unable to retrieve full-text content]本文将教你从0写一个Shadowsocks，无需任何基础，读完本文你就能完成一个轻量级、高性能的 Shadowsocks 代替品。</description>
<pubDate>Thu, 18 Jan 2018 07:31:00 +0000</pubDate>
<dc:creator>云加社区</dc:creator>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/8310510.html</dc:identifier>
</item>
<item>
<title>仓储和工作单元模式 - JoeSnail</title>
<link>http://www.cnblogs.com/JoeSnail/p/8310407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JoeSnail/p/8310407.html</guid>
<description>&lt;h2 id=&quot;仓储模式&quot;&gt;仓储模式&lt;/h2&gt;
&lt;h4 id=&quot;为什么要用仓储模式&quot;&gt;为什么要用仓储模式&lt;/h4&gt;
&lt;p&gt;通常不建议在业务逻辑层直接访问数据库。因为这样可能会导致如下结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重复的代码&lt;/li&gt;
&lt;li&gt;编程错误的可能性更高&lt;/li&gt;
&lt;li&gt;业务数据的弱类型&lt;/li&gt;
&lt;li&gt;更难集中处理数据，比如缓存&lt;/li&gt;
&lt;li&gt;无法轻松地从外部依赖项测试业务逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在业务逻辑层通过仓库模式访问数据则可以实现如下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最大化可以用自动化测试的代码量，并隔离数据层以支持单元测试。&lt;/li&gt;
&lt;li&gt;对数据集中管理、提供一致的访问规则和逻辑。&lt;/li&gt;
&lt;li&gt;通过将业务逻辑与数据或服务访问逻辑分隔开，从而提高代码的可维护性和可读性。&lt;/li&gt;
&lt;li&gt;使用强类型的&lt;code&gt;Entity&lt;/code&gt;以便在编译时识别问题而不是在运行时&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;实现仓储模式&quot;&gt;实现仓储模式&lt;/h3&gt;
&lt;p&gt;使用仓储模式是为了分离业务层和数据源层，并实现业务层的Model和数据源层的Model映射。（ViewModel和Entity之间的映射）。即业务逻辑层应该和数据源层无关，业务层只关心结果，数据源层关心细节。&lt;/p&gt;
&lt;p&gt;数据源层和业务层之间的分离有三个好处:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集中了数据逻辑或Web服务访问逻辑。&lt;/li&gt;
&lt;li&gt;为单元测试提供了一个替代点。&lt;/li&gt;
&lt;li&gt;提供了一种灵活的体系结构，可以作为应用程序的整体设计进行调整。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一定义仓储接口&quot;&gt;一、定义仓储接口&lt;/h2&gt;
&lt;p&gt;所有的仓储要实现该接口。该接口定义了对数据的基本操作。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IRepository&amp;lt;TEntity&amp;gt; where TEntity : class
{
    #region 属性
    //IQueryable Entities { get; }
    #endregion

    #region 公共方法
    void Insert(TEntity entity);

    void Insert(IEnumerable&amp;lt;TEntity&amp;gt; entities);

    void Delete(object id);

    void Delete(TEntity entity);

    void Delete(IEnumerable&amp;lt;TEntity&amp;gt; entities);

    void Update(TEntity entity);

    TEntity GetByKey(object key);
    #endregion
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二实现泛型仓储基类&quot;&gt;二、实现泛型仓储基类&lt;/h3&gt;
&lt;p&gt;该类为仓储的泛型基类，实现之前定义的仓储接口（IRepository）,并包含数据上下文(DbContext)，数据集（DataSet）。&lt;/p&gt;
&lt;p&gt;每个表都会对应一个实体（Entity）。每个实体（Entity）对应一个仓储。把实体作为泛型仓储基类的参数，来实现每个实体对应的仓储。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(使用泛型仓储基类可以把实体作为泛型参数来创建对应的仓储。)&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//泛型仓储基类
public class EFBaseRepository&amp;lt;TEntity&amp;gt; : IRepository&amp;lt;TEntity&amp;gt; where TEntity : class
{
    //数据上下文
    internal DbContext context;
    //数据集
    internal DbSet&amp;lt;TEntity&amp;gt; dbSet;

    public EFBaseRepository(DbContext context)
    {
        this.context = context;
        this.dbSet = context.Set&amp;lt;TEntity&amp;gt;();
    }
    //public IQueryable Entities =&amp;gt; context.Set&amp;lt;TEntity&amp;gt;();

    public void Delete(object id)
    {
        TEntity entityToDelete = dbSet.Find(id);
        Delete(entityToDelete);
    }

    public void Delete(IEnumerable&amp;lt;TEntity&amp;gt; entities)
    {
        dbSet.RemoveRange(entities);
    }

    public void Delete(TEntity entityToDelete)
    {
        if (context.Entry(entityToDelete).State == EntityState.Detached)
        {
            dbSet.Attach(entityToDelete);
        }
        dbSet.Remove(entityToDelete);
    }

    public TEntity GetByKey(object key)
    {
        return dbSet.Find(key);
    }

    public void Insert(TEntity entity)
    {
        dbSet.Add(entity);
    }

    public void Insert(IEnumerable&amp;lt;TEntity&amp;gt; entities)
    {
        dbSet.AddRange(entities);
    }

    public void Update(TEntity entity)
    {
        dbSet.Attach(entity);
        context.Entry(entity).State = EntityState.Modified;
    }

    public virtual IEnumerable&amp;lt;TEntity&amp;gt; Get(
        Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; filter = null,
        Func&amp;lt;IQueryable&amp;lt;TEntity&amp;gt;, IOrderedQueryable&amp;lt;TEntity&amp;gt;&amp;gt; orderBy = null,
        string includeProperties = &quot;&quot;, int topNum = 0)
    {
        IQueryable&amp;lt;TEntity&amp;gt; query = dbSet;

        if (filter != null)
        {
            query = query.Where(filter);
        }

        foreach (var includeProperty in includeProperties.Split
            (new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries))
        {
            query = query.Include(includeProperty);
        }

        if (orderBy != null)
        {
            query = orderBy(query);
        }
        if (topNum != 0)
        {
            return query.Take(topNum);
        }
        else
        {
            return query.ToList();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三访问数据&quot;&gt;三、访问数据&lt;/h3&gt;
&lt;p&gt;可以把对Person的相关操作封装到一个类中。在该类中实现PersonRepository（Person仓储），操作PersonRepository来操作数据。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（数据库有一个Person表，代码中有一个TPerson实体）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(该类提供与业务逻辑无关的仓储操作)&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class PersonService
{
    private EFBaseRepository&amp;lt;TPerson&amp;gt; _personRepository;

    public PersonService(DbContext dbContext)
    {
        var context = dbContext;
        //实现Person仓储，TPerson为对应的Entity
        _personRepository = new EFBaseRepository&amp;lt;TPerson&amp;gt;(context);
    }
    public IEnumerable&amp;lt;TPerson&amp;gt; Get()
    {
        return _personRepository.Get();
    }


    public bool AddPerson(TPerson p)
    {
        try
        {
            _personRepository.Insert(p);
        }
        catch (Exception ex)
        {
            return false;
        }
        return true;
    }

    public bool EditPerson(TPerson p)
    {
        try
        {
            _personRepository.Update(p);
        }
        catch (Exception ex)
        {
            return false;
        }
        return true;
    }

    public bool DeletePerson(TPerson p)
    {
        try
        {
            _personRepository.Delete(p);
        }
        catch (Exception)
        {
            return false;
        }
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四viewmodel和entity的映射&quot;&gt;四、ViewModel和Entity的映射&lt;/h3&gt;
&lt;p&gt;该类是对PersonService的封装，是为了提供同一数据上下文，和对数据上下文的释放，及ViewModle和Entity的映射。&lt;/p&gt;
&lt;p&gt;该类中每个方法对应一个数据上下文。如果有需要对多个表操作，将这些操作封装到一个数据上下文中。数据上下文的释放在每个方法中实现。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（所有与业务逻辑相关的操作在该类实现）&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
public class PersonManage
{
    public IList&amp;lt;PersonVM&amp;gt; GetPersons()
    {
        using (var context = new RepositoryDemoEntities())
        {
            var list = new PersonService(context).Get();
            var result = new List&amp;lt;PersonVM&amp;gt;();
            foreach (var item in list)
            {
                result.Add(new PersonVM { Name = item.Name, Age = item.Age, Home = item.Home, PersonID = item.Id });
            }
            return result;
        }
    }

    public bool AddPerson(PersonVM p)
    {
        using (var context = new RepositoryDemoEntities())
        {
            var result = new PersonService(context).AddPerson(new EntityFramework.TPerson { Name = p.Name, Home = p.Home, Age = p.Age, Id = p.PersonID });
            context.SaveChanges();
            return result;
        }
    }

    public bool DeletePerson(PersonVM p)
    {
        using (var context = new RepositoryDemoEntities())
        {
            var result = new PersonService(context).DeletePerson(new EntityFramework.TPerson { Name = p.Name, Home = p.Home, Age = p.Age, Id = p.PersonID });
            context.SaveChanges();
            return result;
        }
    }

    public bool EditPerson(PersonVM p)
    {
        using (var context = new RepositoryDemoEntities())
        {
            var result = new PersonService(context).EditPerson(new EntityFramework.TPerson { Name = p.Name, Home = p.Home, Age = p.Age, Id = p.PersonID });
            context.SaveChanges();
            return result;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;五在test中测试&quot;&gt;五、在Test中测试&lt;/h4&gt;
&lt;p&gt;仓储模式使得更容易实现单元测试&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;添加项目引用&lt;/li&gt;
&lt;li&gt;设置数据库连接字符串&lt;/li&gt;
&lt;li&gt;添加&lt;code&gt;EntityFramework&lt;/code&gt;包即可对每个方法测试&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[TestClass]
public class UnitTest1
{
    [TestMethod]
    public void TestShowPerson()
    {
        var res = new PersonManage().GetPersons();
        Assert.AreNotEqual(0, res.Count);
    }

    [TestMethod]
    public void TestAddPerson()
    {
        var p = new PersonVM { Home = &quot;zhengzhou&quot;, Age = 22, Name = &quot;Jessica&quot;, PersonID = 3 };
        var res = new PersonManage().AddPerson(p);
        Assert.IsTrue(res);
    }
    [TestMethod]
    public void TestEditPerson()
    {
        var persons = new PersonManage().GetPersons();
        var p = persons[0];
        p.Name = &quot;fixed&quot;;
        var res = new PersonManage().EditPerson(p);
        Assert.IsTrue(res);
    }


    [TestMethod]
    public void TestDeletePerson()
    {
        var persons = new PersonManage().GetPersons();
        var p = persons[0];
        var res = new PersonManage().DeletePerson(p);
        Assert.IsTrue(res);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;小结：&lt;/p&gt;
&lt;p&gt;仓储模式通过对数据库操作的封装使数据访问有一致性和对应用层和数据层的隔离，降低代码的耦合性，更加容易实现单元测试。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;工作单元模式&quot;&gt;工作单元模式&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;工作单元模式是“维护一个被业务事务影响的对象列表，协调变化的写入和并发问题的解决”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如：新入校一个同学，需要在班级，学校，学生，课程等多个表里同时操作。这些表要么都完成，要么都不完成。具有一致性。&lt;/p&gt;
&lt;p&gt;在仓储模式中使用工作单元模式是为了当你操作多个仓储时，共用一个数据上下文（DbContext）使得这些仓储具有一致性。&lt;/p&gt;
&lt;p&gt;在Entity Framework中可以把DbContext当作是一个工作单元。在同一个DbContext对多个仓储操作。所以工作单元模式并不是一定要自己实现，通过Entity Framework也可以实现。&lt;/p&gt;
&lt;p&gt;上面的仓储模式其实通过对DbContext的使用了也实现了工作单元模式。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;还是简单说下如何实现自定义的工作单元 &lt;em&gt;（如果要对每个操作都产生记录的话，可以扩展自定义工作单元来实现）&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;自定义工作单元&quot;&gt;自定义工作单元&lt;/h3&gt;
&lt;h4 id=&quot;一定义iunitofwork接口&quot;&gt;一、定义IUnitOfWork接口&lt;/h4&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 工作单元接口
/// &amp;lt;/summary&amp;gt;
public interface IUnitOfWork
{
    /// &amp;lt;summary&amp;gt;
    /// 保存当前单元操作的结果
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    void Save();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;二定义unitofwork类&quot;&gt;二、定义UnitOfWork类&lt;/h4&gt;
&lt;p&gt;UnitOfWork包含了所有的仓储，及一个数据上下文，该类实现IDisposable接口（该接口的方法中释放数据上下文）。&lt;/p&gt;
&lt;h3 id=&quot;section&quot;/&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
public class UnitOfWork : IUnitOfWork, IDisposable
{
    private RepositoryDemoEntities1 context = new RepositoryDemoEntities1();
    private EFBaseRepository&amp;lt;TPerson&amp;gt; _personRepository;

    public EFBaseRepository&amp;lt;TPerson&amp;gt; PersonRepository
    {
        get
        {
            return _personRepository ?? new EFBaseRepository&amp;lt;TPerson&amp;gt;(context);
        }
    }

    public void Save()
    {
        context.SaveChanges();
    }

    private bool disposed = false;

    protected virtual void Dispose(bool disposing)
    {
        if (!this.disposed)
        {
            if (disposing)
            {
                context.Dispose();
            }
        }
        this.disposed = true;
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三实现unitofwork实例通过该实例访问仓储&quot;&gt;三、实现UnitOfWork实例。通过该实例访问仓储。&lt;/h4&gt;
&lt;p&gt;定义一个UnitOfWork的字段，通过构造函数实例化该UnitOfWork&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(该类提供与业务逻辑无关的仓储操作)&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class PersonService
{
    private UnitOfWork unit;

    public PersonService(UnitOfWork unitOfWork)
    {
        unit = unitOfWork;
    }

    public IEnumerable&amp;lt;TPerson&amp;gt; Get()
    {

        return unit.PersonRepository.Get();
    }


    public bool AddPerson(TPerson p)
    {
        try
        {
            unit.PersonRepository.Insert(p);
        }
        catch (Exception ex)
        {

            return false;
        }
        return true;
    }

    public bool EditPerson(TPerson p)
    {
        try
        {
            unit.PersonRepository.Update(p);
        }
        catch (Exception ex)
        {
            return false;
        }
        return true;
    }

    public bool DeletePerson(TPerson p)
    {
        try
        {
            unit.PersonRepository.Delete(p);
        }
        catch (Exception)
        {
            return false;
        }
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;四通过工作单元保持操作一致性手动释放数据上下文&quot;&gt;四、通过工作单元，保持操作一致性，手动释放数据上下文&lt;/h4&gt;
&lt;p&gt;在此将PersonService封装，如果有对多个仓储的操作，封装在一个工作单元中。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（所有与业务逻辑相关的操作在该类实现）&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class PersonManage
{
    public IList&amp;lt;PersonVM&amp;gt; GetPersons()
    {
        using (var unit = new UnitOfWork())
        {
            var list = new PersonService(unit).Get();
            var result = new List&amp;lt;PersonVM&amp;gt;();
            foreach (var item in list)
            {
                result.Add(new PersonVM { Name = item.Name, Age = item.Age, Home = item.Home, PersonID = item.Id });
            }
            return result;
        }
    }

    public bool AddPerson(PersonVM p)
    {
        using (var unit = new UnitOfWork())
        {
            var result = new PersonService(unit).AddPerson(new EntityFramework.TPerson { Name = p.Name, Home = p.Home, Age = p.Age, Id = p.PersonID });
            unit.Save();
            return result;
        }
    }

    public bool DeletePerson(PersonVM p)
    {
        using (var unit = new UnitOfWork())
        {
            var result = new PersonService(unit).DeletePerson(new EntityFramework.TPerson { Name = p.Name, Home = p.Home, Age = p.Age, Id = p.PersonID });
            unit.Save();
            return result;
        }
    }

    public bool EditPerson(PersonVM p)
    {
        using (var unit = new UnitOfWork())
        {
            var result = new PersonService(unit).EditPerson(new EntityFramework.TPerson { Name = p.Name, Home = p.Home, Age = p.Age, Id = p.PersonID });
            unit.Save();
            return result;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五单元测试&quot;&gt;五、单元测试&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;  [TestClass]
public class UnitTest1
{
    [TestMethod]
    public void TestShow()
    {
        var res = new PersonManage().GetPersons();
        Console.WriteLine(res.Count);
        Assert.AreNotEqual(0, res.Count);
    }

    [TestMethod]
    public void TestAdd()
    {
        var res = new PersonManage().AddPerson(new PersonVM { Home = &quot;meiguo&quot;, Age = 11, Name = &quot;tidy&quot; });
        Assert.IsTrue(res);
    }

    [TestMethod]
    public void TestEdit()
    {
        var pmanage = new PersonManage();
        var p = pmanage.GetPersons()[0];
        p.Name = &quot;fixed&quot;;
        var res = pmanage.EditPerson(p);
        Assert.IsTrue(res);
    }

    [TestMethod]
    public void TestDelete()
    {
        var pmanage = new PersonManage();
        var p = pmanage.GetPersons()[0];
        var res = pmanage.DeletePerson(p);
        Assert.IsTrue(res);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;小结：&lt;/p&gt;
&lt;p&gt;工作单元模式是为了实现业务的事务功能。通过一个数据上下文对相关的仓储操作。但是也不是必须要自己实现模式，通过ORM也可以实现。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1ggZ7t1D&quot;&gt;代码下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如有不对，请多多指教。&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Thu, 18 Jan 2018 07:30:00 +0000</pubDate>
<dc:creator>JoeSnail</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JoeSnail/p/8310407.html</dc:identifier>
</item>
<item>
<title>工作两三年，没目标了…… - 自由飞</title>
<link>http://www.cnblogs.com/freeflying/p/8275268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeflying/p/8275268.html</guid>
<description>&lt;p&gt;唉呀！忙得要死。不要问我在忙啥，不好意思说，嘿嘿……&lt;/p&gt;
&lt;p&gt;看着我草稿箱里一堆的随笔文章，飞哥这心情啊，好吧，无论如何，今天一定要写完一篇，最紧急的那一篇！&lt;/p&gt;

&lt;p&gt;上周星期五，&lt;a href=&quot;http://17bang.ren/donate&quot; target=&quot;_blank&quot;&gt;一起帮&lt;/a&gt;收到了上线以来最大的一笔捐赠：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/49387/201801/49387-20180112105616472-398717569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不是因为QQ群里有聊天记录，是大家一起见证的这个过程，很多人恐怕一定会以为这是飞哥找的“托”！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/49387/201801/49387-20180112105828597-944135458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但这位同学和我纠葛确实比较深，和他的故事也写在园子里的：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/freeflying/p/4709539.html&quot;&gt;写在员工离职之后&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;其实他的主要问题就是现在“佛系”了，呵呵，他们公司请了个活佛给他们讲了一天的经……真事！但飞哥法力浅薄，三观问题确实没办法，只能请人家吃顿饭，从程序员的技术发展和职业生涯规划上和他聊一聊。&lt;/p&gt;
&lt;p&gt;刚好昨天，QQ群里一个网友xx（他昵称就是xx），也有类似的问题，他自己的原话：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;每天不知道自己干了什么，就这么一天天过去了，总想把工作做好，技术学好，但是没感觉自己有什么进步，看见什么都想尝试想去学，有没那么多精力，感觉我进入了一个迷茫期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这个同学，工作一年多，所以还“尝试着想去学”。dk更进一步，已经工作了两三年，所以是“神马都懒得学”了。因为一般的工作都能应付，乱七八糟学的东西也没啥卵用，不管是流行的新技术，还是什么底层基础……&lt;/p&gt;

&lt;p&gt;说到底层基础，我就得提一提我的上一篇博客：&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/freeflying/p/7905881.html&quot;&gt;内功！又是特么的内功？！&lt;/a&gt;&lt;span class=&quot;postTitle2&quot;&gt;，感谢大家的评论，给了我灵感，所以有了这一篇文章：&lt;a href=&quot;http://17bang.ren/Article/32&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;确立你的目标（二）领域之内&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。而且，“&lt;span class=&quot;postTitle2&quot;&gt;确立你的目标&lt;/span&gt;”，其实也就是xx同学和dk同学的一剂药方。因为他们问题的本质就是“没有了目标”嘛！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;postTitle2&quot;&gt;但目标在哪儿呢？这才是最重要最重要的问题啊！我特么不就是找不到目标才迷茫才佛系么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;postTitle2&quot;&gt;解决这个问题，有非常多的办法。这里，我说一个最俗最俗的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;strong&gt;学你的老大&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;postTitle2&quot;&gt;道理很简单，你想往上爬，那就要以你上面那个人为目标为榜样啊！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;postTitle2&quot;&gt;好了，到这里，就会出现几种情况，我们分别说。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;postTitle2&quot;&gt;第一种，觉得老大其实也没什么本事，甚至还不如我呢！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你这样想，我不得不非常遗憾的告诉你：在大部分情况下，这是你的错觉。老大能成为你的老大，一定是有他的道理的。为了同学们的茁壮成长，飞哥只有晒出自己的黑历史啦：&lt;a href=&quot;http://17bang.ren/Article/39&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;李全懂（《&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;http://17bang.ren/Article/39&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;折腾&lt;/span&gt;&lt;/a&gt;》卷一·青涩）&lt;span class=&quot;text-primary&quot;&gt;。虽然是法务工作，但道理其实是想通的，你觉得老大错了，其实是你没看到老大看到了但你没有看到的东西，呵呵。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;text-primary&quot;&gt;第二种，确实是老大技术还不如你。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;这里面又分两种情况，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;a)你们老大技术不行，但其他方面强。诶！这其实是好事。程序员年轻的时候，就会觉得“&lt;span class=&quot;text-primary&quot;&gt;技术第一&lt;/span&gt;”，因为这时候你又要靠技术吃饭，又没技术，所以你会有一种错觉：有了技术就会拥有一切。其实，哪里是这么回事？厉害的，工作两三年，或者一般点的，三五年过后，技术就是那个样子了，单靠技术，你又能强到哪里去？BAT三大巨头，他们老大这么有钱，是因为他们技术最强么？做事不如做人，哪怕是科技文明昌盛如今天，仍然是绝对真理。所以，还是要向你们老大学，多套套近乎，多揣摩揣摩人情世故，绝大多数时候，比你再新学一门技术强！用文绉绉的话说，技术的边际效益随着工作经验的增加递减，所以要开辟“&lt;span class=&quot;text-primary&quot;&gt;第二战场&lt;/span&gt;”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;b) 你们老大就凭年纪大资历深，甚至有关系有背景这些外在条件忝居高位。这种情况，没有办法，你学不来，所以最好的办法就是“赶紧挪地方”吧。走人，趁着年轻，还有锐气。真的，到了飞哥这种年纪，上有老下有小，很容易向命运屈服，很多时候，就是饮鸩止渴了，/(ㄒoㄒ)/~~&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;text-primary&quot;&gt;第三种，老大技术确实比你强。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;看起来，这就很简单了，向他学习就是了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;但是，这里就有一个很尴尬的问题：我知道他比我强，但我不知道他为什么比我强！？( ⊙ o ⊙ )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;憋笑，真的，这就是在&lt;span class=&quot;text-primary&quot;&gt;我&lt;/span&gt;QQ群里的同学提出的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;有一些开发经验的同学应该能够想象这种场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;语法、类库、第三方框架插件……两个人都会。但是，&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;text-primary&quot;&gt;差不多的功能，张三写得又慢又容易报bug，李四写得又快又好，没什么bug。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;text-primary&quot;&gt;中途碰到了一个稀奇古怪的问题，张三折腾来折腾去一直都搞不定，但李四接手倒腾一会儿，耶！就搞定了。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;text-primary&quot;&gt;对开发进度、使用三方代码风险的预判，李四就是比张三准确一些。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;text-primary&quot;&gt;……&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;很明显，张三不如李四，但究竟是差在哪里呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;有些同学马上就用算法、数据结构、计算机组成原理……之类的所谓“基础”“内功”来解释了。我看过的最搞笑——不，应该是“&lt;span class=&quot;text-primary&quot;&gt;气人&lt;/span&gt;”的说法：“（有些同学）不懂数据结构和算法，所以代码的可读性差……&lt;span class=&quot;text-primary&quot;&gt;”骚瑞！少年，你确定代码的可读性是数据结构和算法决定的？你不懂嘛，谦虚一点，还拽得个二百五似的，我知乎第一个拉黑的家伙。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;这种差距的原因很复杂，要具体情况具体分析。比如说，你的工作就是开发AlphaGo，那当然是和算法紧密相关的，可能你们的差距就是数据结构和算法（甚至就是智商）上面的差异。但对于绝大多数进行业务逻辑开发的程序员同学而言，这种差距是一种“经验”上的差距。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;所谓经验，是必须要用时间，用经历去换取的，几乎没有捷径可走，所以经验是非常非常宝贵的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;以前dk问我：“为什么你能想到，我就想不到呢？”我告诉他，其实很简单，“因为类似的坑我以前踩过”——这就是经验。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;我在《折腾》里写过我在上海和社区那些老头老太婆打乒乓球，上蹿下跳的被虐得很惨，我弟弟给我总结的：那是人家经年累月积累出来的手上功夫……&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;很多同学（尤其是知乎上的网友）和我说：“我想要提高……技术，推荐一本书吧！”我真不知道该怎么回答。知乎的这种风气我不知道怎么评价：看书 = 提高，好像什么事情都可以通过看书来解决似的。有些东西，看书是没用的，而书本上得不到的那些东西，才是最为宝贵的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;书，能够记录能够传播的，只是知识；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;而解决问题，需要的是能力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;知识本身是廉价的，尤其是信息时代的今天，稀缺的是能力，能够解决具体问题的能力！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;把知识转化为能力，只有一个途径：练。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;有些同学和我说：“我看了……，又看了……，还看了……，头都看晕了，感觉什么都明白了，但就是一写代码代码就傻眼，为什么呢？”不为什么，正常啊！你没练过呀！那我看了《乒乓球入门》，&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;我就能打乒乓球了？我看了&lt;/span&gt;&lt;/span&gt;《乒乓球实战技法》，我就能进行实战了；我看完了《乒乓球高级攻防》，我就有乒乓球高级水平，可以称霸乒坛了么？这不是笑话么？！你必须拿起球拍开始打，不停的打，技术才会慢慢的增长。哪怕不看书，打得多了，也可以打得不错；要是只看书不打球，哪怕你把书都倒背如流，你也是菜鸟中的菜鸟。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;真以为是武侠小说里写的，就在图书馆看看书，就自创《九阴真经》，天下无敌？同学，小说啊！知不知道什么叫小说？假的，假的，假的啊！真想拍怕你的小脸蛋：你是一个程序员，理科生啊！醒醒吧……&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;好像又跑题了？嗯，没有，还好。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;我的意思就是：弥补你和你们老大之间的差距，办法只有一个，脚踏实地的把手头的工作干好。不要觉得它“没什么技术含量”，等你真正游刃有余的时候再来说这话；不要说什么“反正都是增删改查”，能把”增删改查“做好就已经相当不容易了。无数大牛，整出那么多的框架（比如ORM, MVC），搞出那么多的理论（什么DDD,TDD）,以及花样繁多的最佳实践（比如敏捷、重构、代码规范），都没有解决软件复杂度的问题，你算老几？就敢说什么”没有技术含量“”不过是增删改查“？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;讲真，技术含量是有的，不过是你写的代码没有技术含量，就是增删改查而已。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span&gt;ʅ(‾◡◝)ʃ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;差不多了，所有的分支都走完了吧？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;其实这也回答了上一篇博客的问题，如果真要说有什么“内功”的话，在开发过程中&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;点滴积累的体会，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;长年累月磨练形成的能力，这才是真正的内功。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;最后的最后，可能还有同学会问：工作中的那点锻炼还是太少了点，我想“弯道超车”，多找点机会练练，肿么办呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;&lt;span class=&quot;text-primary&quot;&gt;嘿嘿，这可是你逼我的，三个字：&lt;a href=&quot;http://17bang.ren/&quot; target=&quot;_blank&quot;&gt;一起帮&lt;/a&gt;。O(∩_∩)O哈哈哈~&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jan 2018 06:22:00 +0000</pubDate>
<dc:creator>自由飞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeflying/p/8275268.html</dc:identifier>
</item>
<item>
<title>原来你是这样的JAVA[03]-继承、多态、抽象类 - 陈敬（Cathy）</title>
<link>http://www.cnblogs.com/janes/p/8309741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/janes/p/8309741.html</guid>
<description>&lt;p&gt;&lt;br/&gt;Java中的继承使用关键字extends ，跟C#的语法略有差别。&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;1.子类构造器&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;java会自动在子类的构造器中插入对父类构造器的调用，也就是说在子类可以访问父类之前已经完成了父类的初始化。&lt;br/&gt;如果想调用带参数的父类构造器，应该使用&lt;strong&gt;super&lt;/strong&gt;关键字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 陈敬
  * @date 18/1/17
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product {
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product(String name) {
         &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
         System.out.println(&lt;/span&gt;&quot;[Product constructor]&quot;&lt;span&gt;);
     }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Bread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Product {
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; price;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Bread(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; price) {
         &lt;/span&gt;&lt;strong&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);//调用父类构造器
         &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
         System.out.println(&lt;/span&gt;&quot;[Bread constructor]&quot;&lt;span&gt;);
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们创建一个Bread类的实例，看看调用顺序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testConstructor(){
     Bread bread&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Bread(&quot;毛毛虫面包&quot;,10&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;br/&gt;[Product constructor]&lt;br/&gt;[Bread constructor]&lt;/p&gt;
&lt;h2&gt;2.调用父类方法&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;子类是不能直接访问到父类的私有域的，如果想访问只能借助父类公开的get访问器。子类调用父类中的方法也需要使用&lt;strong&gt;super&lt;/strong&gt;关键字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Bread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Product {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Bread(String name) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display(){
        System.out.println(&lt;strong&gt;getName()&lt;/strong&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后写个单元测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testPrivate(){
        Bread bread&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Bread(&quot;毛毛虫面包&quot;&lt;span&gt;);
        bread.display();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;毛毛虫面包&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要说明一点，super并不是一个对象的引用，不能将super赋值给变量，它只是一个特殊的关键字，告诉编辑器要调用父类中的方法。&lt;/p&gt;
&lt;h2&gt;3.关于重载&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;如果父类中存在重载方法，子类又进行了重载，会覆盖父类中的方法吗？实际上，父类和子类中的方法都可以正常重载，不会被覆盖。&lt;br/&gt;首先在父类Product中添加方法getDescription()：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product {
     ……

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;[Product]name=&quot;+&lt;span&gt;name;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在子类中重载该方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Bread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Product {
     ……

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription(String storeName) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;[Bread]storename=&quot;+&lt;span&gt;storeName;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;增加一个单元测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExtendClassTests {
     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testOverload(){
         Bread bread&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Bread(&quot;豆沙面包&quot;,9&lt;span&gt;);
         System.out.println(bread.getDescription());
         System.out.println(bread.getDescription(&lt;/span&gt;&quot;味多美&quot;&lt;span&gt;));
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;br/&gt;[Product]name=豆沙面包&lt;br/&gt;[Bread]storename=味多美&lt;/p&gt;
&lt;h2&gt;4.继承准则&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;继承准则：尽量少用继承。一般用继承表达行为间的差异，用组合表示状态上的变化。&lt;/p&gt;


&lt;h2&gt;1.变量多态&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;在Java中对象变量是多态的，一个Product变量可以引用Product对象，也可以引用一个Product子类的对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;6&quot;&gt;
public void testParent(){&lt;br/&gt;Product product=new Bread(&quot;毛毛虫面包&quot;,10);&lt;br/&gt;product.display();&lt;p&gt;//强制类型转换&lt;br/&gt;if(product instanceof Bread){&lt;br/&gt;Bread brand=(Bread)product;&lt;br/&gt;brand.display(&quot;味多美&quot;);&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于Bread实例向上转型为Product类型，所以不能再调用Bread.getDescription(String storeName)方法。&lt;br/&gt;如果需要将父类强制转换为子类时，要先通过instanceof检测对象类型，我们最好尽量避免使用强制类型转换。&lt;/p&gt;
&lt;h2&gt;2.动态绑定&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;所谓动态绑定，就是在运行时根据对象的类型决定要调用的方法。在java中，动态绑定是默认行为，不需要添加额外的关键字实现多态。&lt;/p&gt;
&lt;p&gt;再写个demo来看一下，在父类和子类中重载了display方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product {
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product(String name) {
         &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
     }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display() {
         System.out.println(&lt;/span&gt;&quot;[Product]getDescription()&quot;&lt;span&gt;);
     }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Bread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Product {
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; price;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Bread(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; price) {
         &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
         &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
     }

    @Override
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display() {
         System.out.println(&lt;/span&gt;&quot;[Bread]getDescription()&quot;&lt;span&gt;);
     }
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; display(String storeName) {
         System.out.println(&lt;/span&gt;&quot;[Bread]getDescription(String storeName)&quot;&lt;span&gt;);
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加单元测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dynamicBind(){
     Product product&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Product(&quot;product&quot;&lt;span&gt;);
     product.display();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[Product]getDescription()&lt;/span&gt;
&lt;span&gt;
    Bread bread&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Bread(&quot;毛毛虫&quot;,9&lt;span&gt;);
     bread.display();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[Bread]getDescription()&lt;/span&gt;
     bread.display(&quot;maimai&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[Bread]getDescription(String storeName)&lt;/span&gt;
&lt;span&gt;
    Product product1&lt;/span&gt;=&lt;span&gt;bread;
     product1.display();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[Bread]getDescription()&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虚拟机为每个类创建一个方法表，列出所有方法的签名和实际调用的方法。这样一来，当动态调用方法的时候，只需要查找方法表就能快速的找到真正调用的方法了。&lt;br/&gt;Product:&lt;br/&gt;     display()-&amp;gt;Product.display()&lt;br/&gt;Bread:&lt;br/&gt;     display()-&amp;gt;Bread.display()&lt;br/&gt;     display(String name)-&amp;gt;Bread.display(String name)&lt;br/&gt; &lt;br/&gt;完整源码参见:&lt;a href=&quot;https://github.com/cathychen00/cathyjava&quot;&gt;https://github.com/cathychen00/cathyjava&lt;/a&gt;     /_08_extend&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;定义抽象方法用用abstract关键字，它仅有声明而没有方法体。&lt;br/&gt;包含抽象方法的类叫做抽象类，如果一个类包含一个或多个抽象方法，那么必须被定义为抽象类。&lt;br/&gt;如果一个类从抽象类继承，那么必须为抽象类中的所有抽象方法提供实现，否则该类也必须被定义为抽象类。&lt;br/&gt;看一个场景：我们有一些定时任务，要进行的工作流程类似，只有具体一部分细节内容不同。我们可以定义一个抽象基类BaseJob，再不同的部分封装为抽象方法，具体的实现在子类中进行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;strong&gt;&lt;span&gt;abstract&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseJob {
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
         System.out.println(&lt;/span&gt;&quot;==START &quot;+getDescription()+&quot;==&quot;&lt;span&gt;);
         String lastJobId&lt;/span&gt;=&lt;span&gt;getLastJobId();
         execute(lastJobId);
         writeLog();
         System.out.println(&lt;/span&gt;&quot;==END &quot;+getDescription()+&quot;==&quot;&lt;span&gt;);
     }

    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getDescription();

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(String jobId);

    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeLog() {
         System.out.println(&lt;/span&gt;&quot;write log to DB&quot;&lt;span&gt;);
     }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getLastJobId() {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;job1221&quot;&lt;span&gt;;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArticleJob &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseJob {
     @Override
     &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String getDescription() {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;抓取文章任务&quot;&lt;span&gt;;
     }

    @Override
     &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(String jobId) {
         System.out.println(&lt;/span&gt;&quot;抓取站点新闻文章 jobid=&quot;+&lt;span&gt;jobId);
     }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
         BaseJob articleJob&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArticleJob();
         articleJob.run();
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建单元测试，调用ArticleJob看看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; articleJob(){
     BaseJob articleJob&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArticleJob();
     articleJob.run();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
==START 抓取文章任务==&lt;span&gt;
抓取站点新闻文章 jobid&lt;/span&gt;=&lt;span&gt;job1221
write log to DB
&lt;/span&gt;==END 抓取文章任务==
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当再次添加符合该流程的定时任务时，只需要新建一个类，实现BaseJob就可以了。&lt;/p&gt;
&lt;p&gt;完整例子：&lt;a href=&quot;https://github.com/cathychen00/cathyjava&quot;&gt;https://github.com/cathychen00/cathyjava&lt;/a&gt; /09_abstract&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jan 2018 06:09:00 +0000</pubDate>
<dc:creator>陈敬（Cathy）</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/janes/p/8309741.html</dc:identifier>
</item>
<item>
<title>Asp.net SignalR 让实时通讯变得简单 - 思明</title>
<link>http://www.cnblogs.com/highest/p/8309920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/highest/p/8309920.html</guid>
<description>&lt;p&gt;巡更项目中，需要发送实时消息，以及需要任务开始提醒，于是便有机会接触到SignalR，在使用过程中，发现用SignalR实现通信非常简单，下面我思明将从三个方面分享一下：&lt;/p&gt;
&lt;p&gt;一、SignalR是什么&lt;/p&gt;
&lt;p&gt;Asp.net SignalR是微软为实现实时通信的一个类库。一般情况下，SignalR会使用JavaScript的长轮询(long polling)的方式来实现客户端和服务器通信，随着Html5中WebSockets出现，SignalR也支持WebSockets通信。另外SignalR开发的程序不仅仅限制于宿主在IIS中，也可以宿主在任何应用程序，包括控制台，客户端程序和Windows服务等，另外还支持Mono，这意味着它可以实现跨平台部署在Linux环境下。&lt;/p&gt;
&lt;p&gt;SignalR内部有两类对象：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Http持久连接(Persisten Connection)对象：用来解决长时间连接的功能。还可以由客户端主动向服务器要求数据，而服务器端不需要实现太多细节，只需要处理PersistentConnection 内所提供的五个事件：OnConnected, OnReconnected, OnReceived, OnError 和 OnDisconnect 即可。&lt;/li&gt;
&lt;li&gt;Hub（集线器）对象：用来解决实时(realtime)信息交换的功能，服务端可以利用URL来注册一个或多个Hub，只要连接到这个Hub，就能与所有的客户端共享发送到服务器上的信息，同时服务端可以调用客户端的脚本。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　SignalR将整个信息的交换封装起来，客户端和服务器都是使用JSON来沟通的，在服务端声明的所有Hub信息，都会生成JavaScript输出到客户端，.NET则依赖Proxy来生成代理对象，而Proxy的内部则是将JSON转换成对象。&lt;/p&gt;
&lt;p&gt;二、为什么要用SignalR&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;聊天室，如在线客服系统，IM系统等&lt;/li&gt;
&lt;li&gt;消息的实时推送服务&lt;/li&gt;
&lt;li&gt;巡更人员位置的实时推送&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;三、怎么实现SignalR，下面主要介绍一下SignalR第一大功能，聊天。以下是一个简单的DEMO:&lt;/p&gt;
&lt;p&gt;1、新建一个asp.net web 应用程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/824961/201801/824961-20180118134725849-2125730498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、选择模板MVC，同时更改无身份验证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/824961/201801/824961-20180118134835740-1759660472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、选择新建的项目，右击--&amp;gt;选择管理NuGet程序包--&amp;gt;搜索 signalr--&amp;gt; 安装Microsoft ASP.NET SignalR &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/824961/201801/824961-20180118134923990-637513555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、新建启动程序 Startup.cs &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/824961/201801/824961-20180118135054037-787939963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在类中添加代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
app.MapSignalR();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/824961/201801/824961-20180118135219553-1897664176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、新建SignalR集线器类ChatHub.cs&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/824961/201801/824961-20180118135249428-1087705758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、在集线器类ChatHub.cs中添加如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChatHub : Hub
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 供客户端调用的服务器端代码
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Send(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; message)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name =&lt;span&gt; Guid.NewGuid().ToString().ToUpper();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用所有客户端的sendMessage方法&lt;/span&gt;
&lt;span&gt;            Clients.All.sendMessage(name, message);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 客户端连接的时候调用
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task OnConnected()
        {
            Trace.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端连接成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnConnected();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7、修改Index.cshtml页面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    ViewBag.Title &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;聊天窗口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&amp;lt;h2&amp;gt;Chat&amp;lt;/h2&amp;gt;

&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sendmessage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Send&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hidden&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;displayname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;ul id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;discussion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;&lt;span&gt;

@section scripts
{
    &lt;/span&gt;&amp;lt;!--引用SignalR库. --&amp;gt;
    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/Scripts/jquery.signalR-2.2.2.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;!--引用自动生成的SignalR 集线器(Hub)脚本.在运行的时候在浏览器的Source下可看到 --&amp;gt;
    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/signalr/hubs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;&lt;span&gt;
        $(function () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、引用自动生成的集线器代理 必须用小写字母开头&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; chat =&lt;span&gt; $.connection.chatHub;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、开始连接服务器 done函数表明建立连接成功后为发送按钮注册了一个click事件&lt;/span&gt;
&lt;span&gt;            $.connection.hub.start().done(function () {
                $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#sendmessage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click(function () {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用服务器端集线器的Send方法 也要小写开头&lt;/span&gt;
                    chat.server.send($(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).val());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清空输入框信息并获取焦点&lt;/span&gt;
                    $(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).val(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;).focus();
                });
            });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、定义服务器端调用的客户端sendMessage来显示新消息&lt;/span&gt;
            chat.client.sendMessage =&lt;span&gt; function (name, message) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向页面添加消息&lt;/span&gt;
                $(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#discussion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; htmlEncode(name)
                    &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/strong&amp;gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + htmlEncode(message) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            };

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置焦点到输入框&lt;/span&gt;
            $(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#message&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).focus();
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为显示的消息进行Html编码&lt;/span&gt;
&lt;span&gt;        function htmlEncode(value) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; encodedValue = $(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text(value).html();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encodedValue;
        }
    &lt;/span&gt;&amp;lt;/script&amp;gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8、直接运行程序，打开多个网页，都可以收到相同的消息。。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/824961/201801/824961-20180118140343490-766283425.png&quot; alt=&quot;&quot; width=&quot;715&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 综上所述，SignalR使用起来很方便，而且配置很简单，功能也很强大。码字不容易，转载请注明出处&lt;/p&gt;
&lt;p&gt;借鉴微博：&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jan 2018 06:08:00 +0000</pubDate>
<dc:creator>思明</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/highest/p/8309920.html</dc:identifier>
</item>
<item>
<title>软件测试人员所不知道的软件测试七项原则 - 资深Tester_王豆豆</title>
<link>http://www.cnblogs.com/evangline/p/8309801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evangline/p/8309801.html</guid>
<description>&lt;p&gt;测试群有个小伙伴去鼎桥面试，回来分享时提到笔试题中有一道是软件测试的七项原则的题。&lt;/p&gt;
&lt;p&gt;这是一道关于软件测试理论的题，大部分测试人员并不care软件测试理论，遵循理论无用论。&lt;/p&gt;
&lt;p&gt;以前刚做软件测试时，确实并不关心软件测试理论，觉得只要能做就行，有技术就足够了，但到了后面却越来越重视理论了，这也是为什么目前公众号里理论的文章以测试理论为最多，这是估计是建立建全的软件测试思维与软件测试理论息息相关的原因吧。&lt;/p&gt;
&lt;p&gt;在面试面谈过程中遇到软件测试理论的问题的并不多，但是在笔试中却经常遇到，比如什么是自动化测试？画出V模型，阿尔法测试和贝塔测试的区别等，这些是经常会碰到的，但关于问到软件测试的七项原则却是一个比较鲜少遇见的题。&lt;/p&gt;
&lt;p&gt;那我们一起来数数软件测试的七项原则分别是什么：&lt;/p&gt;

&lt;p&gt;01&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试尽早介入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从分析不同的测试模型来看，测试介入的越早越好。&lt;/p&gt;
&lt;p&gt;为什么测试要尽早介入呢？&lt;/p&gt;
&lt;p&gt;这要先弄清楚软件测试的目的是什么？简单的来说就是保证软件质量，降低成本。&lt;/p&gt;
&lt;p&gt;测试人员一般都在需求阶段就开始介入，这时测试的对象就是需求。&lt;/p&gt;
&lt;p&gt;软件测试的目的是保证质量，预防风险，降低成本，其中成本包括缺陷的修复成本，缺陷有一个特点就是越早发现的缺陷，修复成本越低，这也是为什么测试要尽早介入，就是为了能够在需求阶段就能找出需求与设计方面的缺陷，降低后期的修复成本。&lt;/p&gt;

&lt;p&gt;02&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;穷尽测试是不可能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在的软件规模越来越大，复杂度越来越高，想做到完全性的测试就完全不可能的。就是软件的规模和复杂度有所减少，但要做完全也测试也是不能做到。&lt;/p&gt;
&lt;p&gt;那在测试阶段，软件测试人员可以根据风险和优先级来进行集中测试和高强度测试，从而保证软件的质量。&lt;/p&gt;

&lt;p&gt;03&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试显示软件存在缺陷&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件测试只能证实软件中存在缺陷，但是并不能证明软件中不存在缺陷，只能降低软件存在缺陷的可能性。&lt;/p&gt;
&lt;p&gt;如果说公司的决策层想通过软件测试来证明软件中不存在缺陷，那是行不通的。测试人员只能证明软件中存在缺陷，但并不能证明软件中没有缺陷，软件完美。&lt;/p&gt;
&lt;p&gt;软件测试人员可以通过软件测试活动，找出软件中大部分缺陷，避免软件在上线后给用户带损失，给公司带来风险。&lt;/p&gt;

&lt;p&gt;04&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺陷集群性（2/8原则)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;世界上万事万物都符合二八原则，比如著名的财富理论：世界20%的人掌握了世界上80%的财富。&lt;/p&gt;
&lt;p&gt;还有成长理论：判断一个人是否成功，主要看他20%的业余时间做什么事情。&lt;/p&gt;
&lt;p&gt;软件测试也符合二八原则:&lt;/p&gt;
&lt;p&gt;1.功能：一个软件20%为主要功能，会花费软件测试人员80%的时间。&lt;/p&gt;
&lt;p&gt;2.缺陷：一个功能模块发现的缺陷越高，那存在的未被发现的缺陷也越高，故，发现的缺陷与未发现的缺陷成正比。&lt;/p&gt;

&lt;p&gt;05&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;杀虫剂悖论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要做过软件测试的测试人员都会发现一个有趣的现象：&lt;/p&gt;
&lt;p&gt;开发刚转测当天，测试人员是一个bug接一个bug的提，但随着测试进度的推进，每天发现在的缺陷会越来越少，到最后简直就是不能够发现缺陷了。&lt;/p&gt;
&lt;p&gt;但是能说这个软件中不存在缺陷么？王豆豆相信哪个测试人员都没有这样的自信保证自己测试的软件中没有bug了，那为什么存在中明明不存在缺陷，而测试人员就是发现不了呢？&lt;/p&gt;
&lt;p&gt;这是因为测试人员对缺陷产生了免疫能力，就算是一个bug放在测试人员面前，测试人员也不一定能发现。这就像害虫对杀虫剂产生了免疫，杀不死一样的。 &lt;/p&gt;
&lt;p&gt;那应该怎么解决这个问题呢？王豆豆相信这是所有测试人员都关注的一个问题。&lt;/p&gt;
&lt;p&gt;解决方案有：&lt;/p&gt;
&lt;p&gt;1. 内部测试人员交叉测试，这也是王豆豆经常提到的一个方法。 &lt;/p&gt;
&lt;p&gt;2.测试用例常用常更新，在测试过程中根据软件的特性修改测试用例。&lt;/p&gt;
&lt;p&gt;3.不变地变化测试方法，不要使用单一的测试方法去测试软件，根据软件内容使用不同的测试手段、测试方法。&lt;/p&gt;
&lt;p&gt;根据上面三种方法交叉执行，从而发现更多的缺陷，保证软件质量，降低风险。&lt;/p&gt;


&lt;p&gt;06&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试活动依赖于测试内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在面试过程中有时总会遇到面试官部“做软件测试什么最重要”，想来做过测试的都知道“需求”最重要，对测试人员来说是需求，对公司来说就是业务。&lt;/p&gt;
&lt;p&gt;根据业务的不同，软件测试内部也分不同的行业，比如游戏行业，金融行业，电商行业等等。&lt;/p&gt;
&lt;p&gt;不同的行业，测试活动的开展都有所有不同，比如工具的选择，测试流程都不尽相同，所以软件测试活动的开展依赖于所测试的内容。&lt;/p&gt;

&lt;p&gt;07&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无错就是好是谬论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无错，对软件测试人员来说可望不可即的。&lt;/p&gt;
&lt;p&gt;那真的无错的软件就是好的软件么？&lt;/p&gt;
&lt;p&gt;假设一个软件完全没有bug，完美无缺，但是不符合用户的需求，那能说这个软件是OK的么？ &lt;/p&gt;
&lt;p&gt;判断一个软件的好与不好，主要依据的还是用户需求，是否实现用户所期盼的结果，并不是仅仅依赖于软件中是否存在缺陷&lt;/p&gt;

&lt;p&gt;有些伙伴会说测试理论没什么用，但王豆豆觉得理论看似没用，但却能培养我们的测试思维，让我们对软件测试有更多的认识和了解，测试人员不要只去追求技术上的超越，而思维上的建立也是至关重要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;欢迎关注王豆豆的微信公众号：资深Tester,了解更多的测试好文，和王豆豆一起成长。。。。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jan 2018 05:50:00 +0000</pubDate>
<dc:creator>资深Tester_王豆豆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evangline/p/8309801.html</dc:identifier>
</item>
<item>
<title>SSM框架开发web项目系列（七） SpringMVC请求接收 - 窗外天空晴朗</title>
<link>http://www.cnblogs.com/young-z/p/8303553.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/young-z/p/8303553.html</guid>
<description>&lt;p&gt;　　在上篇&lt;a href=&quot;http://www.cnblogs.com/young-z/p/8261053.html&quot; target=&quot;_blank&quot;&gt;Spring MVC入门篇&lt;/a&gt;中，我们初步了解了Spring MVC开发的基本搭建过程，本文将针对实际开发过程的着重点Controller部分，将常用的知识点罗列出来，并配以示例。在这之前，我们有必要回顾一下，Spring MVC在我们的WEB开发中，定位或者作用是什么？Spring MVC在项目中，主要作用是接收客户端请求、解析路径并分发请求到相应的控制器即Controller中执行相应方法，在方法中，我们常见的操作有，调用业务逻辑层（后面会介绍到）方法，访问数据库，获取数据或者更新数据，如果是获取数据一般是要返回给前端，常用方式有两种：1.传统的Jsp开发中，我们可以将数据封装到Model属性中，然后在页面中通过el表达式之类的方式得到；2.随着Ajax技术/RESTful风格的兴起，同样可以在前后端分离的情况下传递数据（RESTful基础学习阶段可以不作重点，但Ajax一定要掌握）。另外基于Spring MVC的开发模式下，参数的获取、匹配，以及页面的跳转都十分方便，下面我们就来实践操作一下。&lt;/p&gt;
&lt;h3&gt;　　 0.页面文件路径以及页面跳转问题&lt;/h3&gt;
&lt;p&gt;　　如果学习阶段习惯将Jsp文件直接放在web文件根目录webapp下，建议现在开始转变，将其分类放置WEB-INF下，这样一来，我们希望访问一个页面，将不再是直接通过路径去访问，而是通过Spring MVC中的请求，匹配到相应控制器中方法内部，再跳转至相应页面。区别在于WEB-INF下文件针对服务器端，而客户端例如浏览器是无法直接访问的，这样可以减少直接访问的风险，另外即使抛开安全性隐蔽性不谈，需要填充Model传递数据的Jsp页面如果在直接访问的情况下，可能会出现各种奇奇怪怪的问题，空白、无数据、样式错乱等等。页面跳转SpringMVC默认是请求转发，本文主要针对请求部分，均作默认请求转发处理。&lt;/p&gt;
&lt;h3&gt;　　1.本文注解预介绍&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;@Controller&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　该注解用于Spring识别并实例化控制器bean到上下文中，即加上这个注解的类Spring才能识别知道它是要作为控制器。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;@RequestMapping&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　该注解既可用于类上也可以用在方法上，实际开发往往两者都会用到，用于匹配url路径，接收请求，只有匹配的请求才会进入该控制器执行相关方法。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;@RequestParam&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在控制器方法中，用于将注入的参数与前台请求参数绑定&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;@PathVariable&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用于绑定url路径中占位的参数&lt;/p&gt;
&lt;h3&gt;　　2.自动匹配客户端传来的参数&lt;/h3&gt;
&lt;p&gt;　　登录应该是大家再熟悉不过的web程序操作，这里以用户名、密码为例，分别对应实体类User中属性username和password，那么我们的页面表单部分如下所示：&lt;br/&gt;   　login.jsp中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;${pageContext.request.contextPath }/user/login&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        用户名&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;  &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        密码&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;  &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;登录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Controller代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.mmm.web;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
@Controller
@RequestMapping(&lt;/span&gt;&quot;user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoController {
    
    @RequestMapping(value&lt;/span&gt;=&quot;/toLogin&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toLogin() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;login&quot;&lt;span&gt;;
    }
    
    @RequestMapping(value&lt;/span&gt;=&quot;/login&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String login(String username,String password) {
        System.out.println(&lt;/span&gt;&quot;用户名---&quot; +&lt;span&gt; username);
        System.out.println(&lt;/span&gt;&quot;密码---&quot; +&lt;span&gt; password);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;index&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有了前面的文件路径问题，这里我们先定义一个toLogin方法用于访问登录页面login.jsp，然后在页面表单点击提交后会请求到这里的login方法，重点：form表单中输入框&amp;lt;input&amp;gt;的name属性值，对应Controller中方法的参数名，即这里login方法的两个参数名，username和password，通过这两处的值，Spring MVC即可自动匹配使我们轻松获取参数。&lt;/p&gt;
&lt;p&gt;　　启动Tomcat，在地址栏输入http://localhost/spring-mvc/user/toLogin，即可访问到登录页面，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　任意输入用户名和密码内容后，点击登录，即可看到eclipse控制台输出类似如下信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARsAAAAyCAIAAADjm+g8AAAFH0lEQVR4Ae1dPW7bTBAVgxzFSmHkBPYJ4ioXCNzJTQC7T8p0aWwEKeImQKrAVRrbJ4i6FKmtMn+3UEYaeTgc/miW4tJc8xEfjJnZt7OzT3zZFSHul/38t5yo69fvv18/f/zy4Z2KwQQDYMDLwBMvEDgwAAYcDEBRDpIAAQNuBqAoN1UAggEHA1CUgyRAwICbASjKTRWAYMDBABTlIAkQMOBmAIpyUwUgGHAwAEU5SAIEDLgZ6ElRWZY5S/IjnQkBAwN9MvA0aLCtt/tyWfgFhiSnOPWtaxUYDDCQOgNhiqLZalUYkRi9GZf6mohOxTwywMDMoIzEXzAwTAbi7vpIM3VXmQ4SUhlMMAqWwZEji4tDKkeuk1s7XhIAWzT8PhigX8rq/65//Hn1+k35zuYIFaSbglzdkWzdl+dpgmXXZIjm3p0fcEX67+wmHy8JQF4urD4ZCF6j5N9tMuiOM66+B/02T5jwZHBazkyuP0mnyIPzu/xTuJlR7stvhXUqCUCnlCCZkwG9QJHd7RrVXEN+zxYt7lWM5V55gSjc3cvl7oB8MLbWktKLVJIAWzT8KAwEP5loFolppZJNRFxZiyRCBgcbemlwTPv2JDu6bBogCUDTBNAWiYFgRRklGNdfpZGNzqNtTqjBe6ffl6dN4+wKoIcO07N5wwhJABrqR1NMBoK/R9HNLRcVJjYZ7eok/dDF3XU2sdulbd3r9v1KToWd5HrXJwmTAEi1MHpmIHiN6ry+1lLsvBKd8PmzvY1LK1LVBjAJgJ4R7H4YCFCUrCSeyoLAnoS9Yab79Ox8fnmU1X2PSgLQG10YyDAQvOsz/bt1V/u/0tXtEFuz0dewwtNCesZX8CdJALZOE4BIDGT0xFynrjsLie7zhu0ZtXISxjSD9XDarutVF9d9YYOBgTDg3fU1yIlmYlqN65xqXa+6uDMtYGCgTwaGtevrc+YYCwzEYACKisEqco6XAShqvJ89Zh6DASgqBqvIOV4GoKjxfvaYeQwGoKgYrCLneBmAosb72WPmMRgYhaL4Ffbyq+1CaBIAqRbGkBloryj5ncSQp4fawEDPDHh/M1Gpn3Kw8vcNTljPM8dwYCAGA15F0diVatE1iXLE4FbT0bTqDLDBQOoMeHd9DaoQhQiGDLbFEMzD8XWwP53w9yUqJssOLxamliQApma4g2PAqygqnFXBf0kq4rJ42B3c/FRBV8eZett9fja1okoCoCYEc4gMBCjKlM+iYjlRk2iMYSQwaTIdH8idz+ll9/sDjdZvPM2vrvU6lQTggcjDsG4GvIoqK0RHKhcoCvLFxdx7+Sl/UqTajG1QZvnYHUBjrY6O+PSCB907fUuH8BlJJQEQ0mAMkwHvkwlZcPRaRLe/npVgOM6utjXY9NVNkez8ZIjVAOt324sjJQEolgxvcAx4FcWF18nDTEurzjRVurueBzZZvanefORY5bgIgoHOGQjY9ZGcSCp0cRH+RYaQ5up8GsEJF9dX9LWquCoVkiQBKFQMZxAMeNcoFhIJQxSly6+LM6ayi+7eu724OF4dyjd7uflaVSogCUCpagQGwIBXUS1KJZm16BWviz0wbHZz/5xiM2YSgHj8IHM3DIT+nwTqRqWFSF8EY1cM3Up2XdzAOnKLp8KaI2NXYyQB6IgMpInJgPd0sTohcbx512f68tpFkzJxuGDgETDQza4vSB5B4EdAMaYwKga8z/pGRQomCwZaMwBFtaYOHcFABQNQVAUpCIGB1gz8B8ms2h3PbiUXAAAAAElFTkSuQmCCAA==&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　并跳转至index.jsp页面，这里即成功获取到了前台传递来的参数，这种方式十分方便，但并不是唯一，所以下面分别介绍其它的方法。&lt;/p&gt;
&lt;p&gt;　　***基于之前学过的Servlet系列的请求对象HttpServletRequest，它有一个getParameter（String parameterName）方法,这个parameterName即前台参数名，这里即同样对应输入框&amp;lt;input&amp;gt;的name属性值。&lt;/p&gt;
&lt;p&gt;　　***应用Spring MVC的机制，通过实体类装配属性，同样可以匹配到参数，这里的用户名和密码，往往是对应实体类这里以User为例，类中有username和password这2两个字符串属性。这样一来，通过User对象我们也可以匹配到前台的这两个参数。&lt;/p&gt;
&lt;p&gt;　　下面我们汇总上面的内容，修改login方法为如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
@RequestMapping(value=&quot;/login&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String login(String username,String password, HttpServletRequest req,User user) {
        System.out.println(&lt;/span&gt;&quot;直接参数名匹配获取:用户名---&quot; +&lt;span&gt; username);
        System.out.println(&lt;/span&gt;&quot;直接参数名匹配获取:密码---&quot; +&lt;span&gt; password);
        System.out.println(&lt;/span&gt;&quot;HttpServletRequest获取:用户名---&quot; + req.getParameter(&quot;username&quot;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;HttpServletRequest获取:密码---&quot; + req.getParameter(&quot;password&quot;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;User获取:用户名---&quot; +&lt;span&gt; user.getUsername());
        System.out.println(&lt;/span&gt;&quot;User获取:密码---&quot; +&lt;span&gt; user.getPassword());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;index&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再次访问登录页面，输入内容并点击登录后，即可看到eclipse控制台输出类似如下信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　表明以上方式均可用于获取前台传递参数值。&lt;/p&gt;
&lt;p&gt;　　PS:上面第一种方式（也是常用方式中）如果前端表单中name值和我这里方法中的参数名确实不一样，有没有别的办法能解决这个问题？目前Spring MVC各方面的注解渐渐在完善，这里Spring MVC就为我们提供了这样一种注解，@RequestParam，用于指定前台参数名，即这里如果我们将上面登录页面中的密码输入框的name属性值改为pwd，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
密码&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;pwd&quot;&lt;/span&gt;  &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　按照前面我们的参数名匹配，Controller的login方法中是password，前台是pwd，这样是匹配不上，随之也无法获取数据的。但是引入上面提到的注解，方法可以中参数可以将String password修改为：@RequestParam(&quot;pwd&quot;) String password，这样一来，即可成功获取数据了。&lt;/p&gt;
&lt;p&gt;　　上面结合表单示例介绍了几种方式获取请求参数，之前学习Servlet部分，应该都熟悉doPost和doGet方法，这里的表单往往就是用的post请求方式提交。&lt;/p&gt;
&lt;p&gt;　　使用post提交时，数据将以数据块的形式提交到服务器，URL地址栏中不会出现数据，所以用这种方式提交的表单数据是相对安全的。所以表单提交包含类似于密码等数据时，建议使用post方法。&lt;/p&gt;
&lt;p&gt;　　使用get提交时地址栏上会在你当前项目路径后加上类似?pram1=value1&amp;amp;param2=value2”的形式，将表单数据附加到URL的后面，提交到服务器处理，这种方式效率更高，所以在没有私密数据时，请求推荐这种。&lt;/p&gt;
&lt;p&gt;　　除了上面提到的方式，还有一种获取路径传参的方式，这里也介绍一下，比较实用，通过@PathVariable注解，通过url路径实现动态传参并获取参数值，代码如下示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@RequestMapping(value=&quot;/show/{id}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String show(@PathVariable(value=&quot;id&quot;&lt;span&gt;) String str) {
        System.out.println(&lt;/span&gt;&quot;url获取:id参数值---&quot; +&lt;span&gt; str);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;index&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，我们在地址栏中输入localhost/spring-mvc/user/show/abcdefg，路径末尾的abcdefg即对应上面Controller代码@RequestMapping(value=&quot;/show/{id}&quot;&lt;span&gt;)中的id,我们通过{id}这个大括号加参数名的方式去动态接收它，不论你的值是多少，这里就是用id变量来对应，于是下面@PathVariable(value=&quot;id&quot;&lt;span&gt;)中的id即与之相应，随后绑定到String str上，这个str即匹配该参数值，我们便可以获取到该数据了。输入地址后回车，即可看到控制台，输出如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 　　3.改进登录模块&lt;/h3&gt;
&lt;p&gt;　　前面提到的get、post主要是讲前台请求方式，name我们后台是否可以选择接受指定方式的请求呢？当然是可以的。@RequestMapping的属性中有个method，英文是方法的意思，在这里用于指定要接收的请求方式，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了方便，Spring MVC还为我们提供了RequestMethod枚举，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 *&lt;span&gt; @author Juergen Hoeller
 &lt;/span&gt;* @since 2.5
 *&lt;span&gt; @see RequestMapping
 &lt;/span&gt;*&lt;span&gt; @see org.springframework.web.servlet.DispatcherServlet#setDispatchOptionsRequest
 &lt;/span&gt;*&lt;span&gt; @see org.springframework.web.servlet.DispatcherServlet#setDispatchTraceRequest
 &lt;/span&gt;*/
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; RequestMethod {

    GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中指定了各种请求方式，我们可以直接通过例如&lt;span&gt;RequestMetho.GET来指定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　例如上面的登录部分，我们首先要前往登录页面，请求并没有参数传递，所以我们直接通过get方式请求，然后在登录页面中输入信息后点击登录，提交表单登录时，我们往往用post。上面我们的@RequestMapping(value=&quot;&quot;&lt;span&gt;)这个value值一个是toLogin，一个是login，两个不同的值，就是为了区别这两个请求，但是其实是可以写成一样的，这里我们稍作修改为如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
@RequestMapping(value=&quot;/login&quot;,method=&lt;span&gt;RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toLogin() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;login&quot;&lt;span&gt;;
    }
    
    @RequestMapping(value&lt;/span&gt;=&quot;/login&quot;,method=&lt;span&gt;RequestMethod.POST)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String login(String username, String password) {
        System.out.println(&lt;/span&gt;&quot;直接参数名匹配获取:用户名---&quot; +&lt;span&gt; username);
        System.out.println(&lt;/span&gt;&quot;直接参数名匹配获取:密码---&quot; +&lt;span&gt; password);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;index&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　这样我们同样可以实现前面的效果。&lt;/p&gt;
&lt;h3&gt;　　4.获取请求参数后我们要干嘛？&lt;/h3&gt;
&lt;p&gt;　　在没有应用maven时，之前经常使用下面的方式新建web项目。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; width=&quot;586&quot; height=&quot;407&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们首先要理清的是，我们的web项目都是动态的（ &lt;span class=&quot;op_dict_text2&quot;&gt;dynamic）,这个动态最上层，是客户端的各种动态操作，深入到底层，大多会反映到数据库，那么两者有什么关联，或者是怎样关联起来的?其中上面讲到的请求参数往往就是一个中间人。以上面的登录为例，客户端通过表单提交了用户名和密码两个参数，那么我们到底是要到数据库中查询有没有账号和密码都同时匹配的用户记录，有的话代表输入正确，没有的话则代表输入信息有误。客户端得到的登录成功或者失败这种不确定的结果，基于他的输入，也基于数据库中数据，无数个类似这样的关联关系个构建起了我们的web项目业务逻辑结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;op_dict_text2&quot;&gt;　　所以后面我们就要理清什么是业务逻辑了。在登录过程中，我们验证用户名和密码是否正确，会调用到用户的持久层对象，去查询数据库用户表记录；但是同时我们需要记录登录信息，即在日志表中插入一条登录信息。但是持久层有查询用户表的方法，也有插入日志信息的方法，但是两种方法一起调用的并没有，所以这里需要我们在控制层和持久层之间添加一层业务逻辑层，整合这些持久操作，封装好业务逻辑方法供控制层调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;op_dict_text2&quot;&gt;　　当然这里举例日志可能有点不太恰当，因为基于Spring AOP，例如事务管理、日志信息记录等通用组件能很方便的实现，能让我们专注于实现项目中的业务逻辑，但是总的来说，这里可以先简单的理解为，业务逻辑Service层，作用于持久层(dao)和控制层（controller）之间，它往往用于组装比持久层更复杂的操作过程，并且也不局限于数据库操作，然后供控制层调用，控制层则是专注于接收请求，分发到相应业务逻辑方法进行处理，然后作出响应。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;op_dict_text2&quot;&gt;　　小结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;op_dict_text2&quot;&gt;　　以上讲到了Spring MVC通用请求相关的处理参数过程及方法，当然还有例如文件上传也是一种特殊的请求，并且常用到，后面会理出来。我们在实际开发中往往下功夫最多的是如何实现那些复杂的业务逻辑，相反控制层不应该作用到这些业务处理。所以下面会专门理清一下业务逻辑层的部分，通过注入前面我们学习的MyBatis封装的持久对象，然后将业务逻辑层对象注入到控制层，实现Spring MVC与MyBatis的整合。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jan 2018 05:25:00 +0000</pubDate>
<dc:creator>窗外天空晴朗</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/young-z/p/8303553.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core中使用IOC三部曲(三.采用替换后的Autofac来实现AOP拦截) - GuZhenYin</title>
<link>http://www.cnblogs.com/GuZhenYin/p/8309645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GuZhenYin/p/8309645.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文主要是详解一下在ASP.NET Core中,采用替换后的Autofac来实现AOP拦截&lt;/p&gt;
&lt;p&gt;觉得有帮助的朋友~可以左上角点个关注,右下角点个推荐&lt;/p&gt;
&lt;p&gt;这里就不详细的赘述IOC是什么 以及DI是什么了.. emm..不懂的可以自行百度.&lt;/p&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;a id=&quot;link_post_title&quot; class=&quot;link-post-title&quot; href=&quot;http://www.cnblogs.com/GuZhenYin/p/8297145.html&quot;&gt;ASP.NET Core中使用IOC三部曲(一.使用ASP.NET Core自带的IOC容器)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/GuZhenYin/p/8301500.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core中使用IOC三部曲(二.采用Autofac来替换IOC容器,并实现属性注入)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/GuZhenYin/p/8309645.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core中使用IOC三部曲(三.采用替换后的Autofac来实现AOP拦截)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上一篇我们讲了如何将默认的容器替换为Autofac,并使用属性注入.&lt;/p&gt;
&lt;p&gt;那么这一篇我们就来讲讲如何利用Autofac实现我们的AOP(面向切面编程) .&lt;/p&gt;
&lt;h2&gt;1.引用正确的库来实现AOP&lt;/h2&gt;
&lt;p&gt;既然是跨平台,那么在asp.net core因为采用了.net core来作为基础库(当然,其实你可以换成.NET4.6.).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新的.NET Core是基于.NET Standard的..所以我们在引用库的时候特别要注意相关的兼容问题.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在传统的ASP.NET中,使用过Autofac来进行AOP操作的,应该都知道这个库.&lt;/p&gt;
&lt;p&gt;Autofac.Extras.DynamicProxy&lt;/p&gt;
&lt;p&gt;那么我们来看看它的依赖项.如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/653851/201801/653851-20180118123959599-315263048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;.NET Standard&lt;/strong&gt;的情况下,他需要Autofac4.0+,这个就不多说了.关键在下面这个,他需要Castle.Core4.0+.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以,当我们直接安装这个库的时候,Nuget会自动关联并安装最新的&lt;/strong&gt;Castle.Core4.2.1版本..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;那么问题就出现了..在项目的依赖项中,会发现很多警告:&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/653851/201801/653851-20180118124709412-649119788.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们进入警告会发现..都是提示缺少兼容的最新的类型转换类.如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/653851/201801/653851-20180118124748506-1506456934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而且Castle.Core是属于AutoFac下面的..如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/653851/201801/653851-20180118124914256-582188856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们直接通过Nuget查找Castle.Core.&lt;/p&gt;
&lt;p&gt;可以发现,它需要System.ComponentModel.TypeConverter4.3..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/653851/201801/653851-20180118125215771-1313752371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们直接安装它,Nuget则会直接帮我们把System.ComponentModel.TypeConverter更新到4.3的版本..&lt;/p&gt;
&lt;p&gt;然后重新通过Nuget安装Autofac.Extras.DynamicProxy..就可以了.如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/653851/201801/653851-20180118125515068-1293671669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其实这应该算一个Nuget的BUG..它会帮你引用库的相关依赖..但是当依赖还有依赖需要更新的时候..它就不会更新..&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个时候我们换一种思维..返回来 一步步引用.就可以了..&lt;/p&gt;


&lt;h2&gt;2.采用Autofac来实现AOP&lt;/h2&gt;
&lt;p&gt;首先,我们创建一个拦截类,代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AOPTest : IInterceptor
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Intercept(IInvocation invocation)
        {
            System.Diagnostics.Debug.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你正在调用方法 \&quot;{0}\&quot;  参数是 {1}... &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               invocation.Method.Name,              
               &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, invocation.Arguments.Select(a =&amp;gt; (a ?? &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;).ToString()).ToArray()));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在被拦截的方法执行完毕后 继续执行           &lt;/span&gt;
&lt;span&gt;            invocation.Proceed();

            System.Diagnostics.Debug.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;方法执行完毕，返回结果：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, invocation.ReturnValue);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里,需要继承&lt;strong&gt;IInterceptor,然后实现它的Intercept方法..&lt;/strong&gt;我们直接将拦截内容输出到调试窗(正式项目..请根据业务来操作拦截)..&lt;/p&gt;
&lt;p&gt;找到我们要拦截的服务.并设置拦截特性(有多种方式.用特性的方式作为例子..个人也觉得特性AOP拦截比较方便),代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    [Intercept(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(AOPTest))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestService: ITestService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestService()
        {
            MyProperty &lt;/span&gt;=&lt;span&gt; Guid.NewGuid();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid MyProperty { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; GetList(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; a)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;() { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LiLei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZhangSan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LiSi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在容器中注入我们的AOP拦截类,并开启服务的拦截状态.代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultModule : Module
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Load(ContainerBuilder builder)
        {

            builder.Register(c &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AOPTest());
            builder.RegisterType&lt;/span&gt;&amp;lt;TestService&amp;gt;().As&amp;lt;ITestService&amp;gt;&lt;span&gt;().PropertiesAutowired().EnableInterfaceInterceptors();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里注意,一定要在你注入的服务后面加上&lt;strong&gt;EnableInterfaceInterceptors&lt;/strong&gt;来开启你的拦截.&lt;/p&gt;
&lt;p&gt;然后在控制器中调用服务的方法,代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AutoDIController : Controller
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  ITestService _testService { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: AutoDI&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
        {
            ViewBag.date &lt;/span&gt;= _testService.GetList(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后我们运行代码.&lt;/p&gt;
&lt;p&gt;效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/653851/201801/653851-20180118131021412-1177518939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样,我们就完成了使用Autofac进行AOP拦截..&lt;/p&gt;
&lt;p&gt;Autofac的AOP拦截器还有很多功能与用法.我这里就不一一举例了..请参考官网:http://docs.autofac.org/en/latest/advanced/interceptors.html&lt;/p&gt;

&lt;p&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三部曲到此就结束了.  &lt;strong&gt;喜欢的请点个推荐和关注,~有问题也希望各位批评指正~.&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jan 2018 05:14:00 +0000</pubDate>
<dc:creator>GuZhenYin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GuZhenYin/p/8309645.html</dc:identifier>
</item>
<item>
<title>virtio 简介 - bakari</title>
<link>http://www.cnblogs.com/bakari/p/8309638.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bakari/p/8309638.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我的微信公众号 aCloudDeveloper 专注于云计算技术，互联网技术，生活感悟，打造干货分享平台，每周至少一更，欢迎小伙伴们多多关注！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是-virtio&quot;&gt;什么是 virtio&lt;/h2&gt;
&lt;p&gt;virtio 是一种 I/O 半虚拟化解决方案，是一套通用 I/O 设备虚拟化的程序，是对半虚拟化 Hypervisor 中的一组通用 I/O 设备的抽象。提供了一套上层应用与各 Hypervisor 虚拟化设备（KVM，Xen，VMware等）之间的通信框架和编程接口，减少跨平台所带来的兼容性问题，大大提高驱动程序开发效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180118130644771-1488945484.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么是-virtio&quot;&gt;为什么是 virtio&lt;/h2&gt;
&lt;p&gt;在完全虚拟化的解决方案中，guest VM 要使用底层 host 资源，需要 Hypervisor 来截获所有的请求指令，然后模拟出这些指令的行为，这样势必会带来很多性能上的开销。半虚拟化通过底层硬件辅助的方式，将部分没必要虚拟化的指令通过硬件来完成，Hypervisor 只负责完成部分指令的虚拟化，要做到这点，需要 guest 来配合，guest 完成不同设备的前端驱动程序，Hypervisor 配合 guest 完成相应的后端驱动程序，这样两者之间通过某种交互机制就可以实现高效的虚拟化过程。&lt;/p&gt;
&lt;p&gt;由于不同 guest 前端设备其工作逻辑大同小异（如块设备、网络设备、PCI设备、balloon驱动等），单独为每个设备定义一套接口实属没有必要，而且还要考虑扩平台的兼容性问题，另外，不同后端 Hypervisor 的实现方式也大同小异（如KVM、Xen等），这个时候，就需要一套通用框架和标准接口（协议）来完成两者之间的交互过程，virtio 就是这样一套标准，它极大地解决了这些不通用的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180118130716959-184344513.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;virtio-的架构&quot;&gt;virtio 的架构&lt;/h2&gt;
&lt;p&gt;从总体上看，virtio 可以分为四层，包括前端 guest 中各种驱动程序模块，后端 Hypervisor （实现在Qemu上）上的处理程序模块，中间用于前后端通信的 virtio 层和 virtio-ring 层，virtio 这一层实现的是虚拟队列接口，算是前后端通信的桥梁，而 virtio-ring 则是该桥梁的具体实现，它实现了两个环形缓冲区，分别用于保存前端驱动程序和后端处理程序执行的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180118130745928-1245740398.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;严格来说，virtio 和 virtio-ring 可以看做是一层，virtio-ring 实现了 virtio 的具体通信机制和数据流程。或者这么理解可能更好，virtio 层属于控制层，负责前后端之间的通知机制（kick，notify）和控制流程，而 virtio-vring 则负责具体数据流转发。&lt;/p&gt;
&lt;h2 id=&quot;virtio-数据流交互机制&quot;&gt;virtio 数据流交互机制&lt;/h2&gt;
&lt;p&gt;vring 主要通过两个环形缓冲区来完成数据流的转发，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180118130821193-547101759.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;vring 包含三个部分，描述符数组 desc，可用的 available ring 和使用过的 used ring。&lt;/p&gt;
&lt;p&gt;desc 用于存储一些关联的描述符，每个描述符记录一个对 buffer 的描述，available ring 则用于 guest 端表示当前有哪些描述符是可用的，而 used ring 则表示 host 端哪些描述符已经被使用。&lt;/p&gt;
&lt;p&gt;Virtio 使用 virtqueue 来实现 I/O 机制，每个 virtqueue 就是一个承载大量数据的队列，具体使用多少个队列取决于需求，例如，virtio 网络驱动程序（virtio-net）使用两个队列（一个用于接受，另一个用于发送），而 virtio 块驱动程序（virtio-blk）仅使用一个队列。&lt;/p&gt;
&lt;p&gt;具体的，假设 guest 要向 host 发送数据，首先，guest 通过函数 virtqueue_add_buf 将存有数据的 buffer 添加到 virtqueue 中，然后调用 virtqueue_kick 函数，virtqueue_kick 调用 virtqueue_notify 函数，通过写入寄存器的方式来通知到 host。host 调用 virtqueue_get_buf 来获取 virtqueue 中收到的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180118130845256-2083654785.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;存放数据的 buffer 是一种分散-聚集的数组，由 desc 结构来承载，如下是一种常用的 desc 的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180118130857131-224152231.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当 guest 向 virtqueue 中写数据时，实际上是向 desc 结构指向的 buffer 中填充数据，完了会更新 available ring，然后再通知 host。&lt;/p&gt;
&lt;p&gt;当 host 收到接收数据的通知时，首先从 desc 指向的 buffer 中找到 available ring 中添加的 buffer，映射内存，同时更新 used ring，并通知 guest 接收数据完毕。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结：&lt;/h2&gt;
&lt;p&gt;virtio 是 guest 与 host 之间通信的润滑剂，提供了一套通用框架和标准接口或协议来完成两者之间的交互过程，极大地解决了各种驱动程序和不同虚拟化解决方案之间的适配问题。&lt;/p&gt;
&lt;p&gt;virtio 抽象了一套 vring 接口来完成 guest 和 host 之间的数据收发过程，结构新颖，接口清晰。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：对云计算感兴趣的小伙伴可以关注我的微信公众号：aCloudDeveloper，专注云计算领域，坚持分享干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180118131049693-1953496419.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jan 2018 05:12:00 +0000</pubDate>
<dc:creator>bakari</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bakari/p/8309638.html</dc:identifier>
</item>
<item>
<title>用Token令牌维护微服务之间的通信安全的实现 - 蓝夏</title>
<link>http://www.cnblogs.com/bluesummer/p/8309608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bluesummer/p/8309608.html</guid>
<description>&lt;p&gt;在微服务架构中,如果忽略服务的安全性，任由接口暴露在网络中，一旦遭受攻击后果是不可想象的、&lt;/p&gt;
&lt;p&gt;保护微服务键安全的常见方案有：1.JWT令牌（token） 2.双向SSL 3.OAuth 2.0 等&lt;/p&gt;
&lt;p&gt;本文主要介绍使用Token的实现方式&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/Mike-Zrw/TokenApiAuth&quot; class=&quot;uri&quot; title=&quot;https://github.com/Mike-Zrw/TokenApiAuth&quot;&gt;https://github.com/Mike-Zrw/TokenApiAuth&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1017082/201801/1017082-20180118125715240-2031343689.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中有两个服务，服务A和服务B,我们模拟的是服务A来调用服务B的过程，也可以反过来让服务B来调用服务A。&lt;/p&gt;
&lt;p&gt;整个流程简单来说只有两步&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取token&lt;/li&gt;
&lt;li&gt;携带token请求数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务端会提供一个产生token的接口供客户端来调用，而对于调用该接口的请求同样需要认证，否则岂不是所有人都可以随意调用该接口来生成token了。&lt;/p&gt;
&lt;p&gt;我的思路是每个客户端会有一个权限标识，可以是一样的。然后将权限，时间戳和一个随机数组成一个字符串，然后将该字符串以非对称加密。加密后的字符就是调用接口的参数了&lt;/p&gt;
&lt;p&gt;在token生成的服务端，会解密客户端传来的数据，并进行权限及时间的校验，验证通过就会生成一个token,该token用Aes对称加密，然后返回给客户端&lt;/p&gt;
&lt;p&gt;一个token包含的结构如下&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code&gt;public class TokenClaims
{
    /// &amp;lt;summary&amp;gt;
    /// token的发行者
    /// &amp;lt;/summary&amp;gt;
    public string Iss { get; set; }
    /// &amp;lt;summary&amp;gt;
    /// 用户权限
    /// &amp;lt;/summary&amp;gt;
    public string Role { get; set; }
    /// &amp;lt;summary&amp;gt;
    /// 用户名
    /// &amp;lt;/summary&amp;gt;
    public string Usr { get; set; }
    /// &amp;lt;summary&amp;gt;
    /// 签发时间 秒
    /// &amp;lt;/summary&amp;gt;
    public long Iat { get; set; }
    /// &amp;lt;summary&amp;gt;
    /// 到期时间 秒
    /// &amp;lt;/summary&amp;gt;
    public long Exp { get; set; }
    /// &amp;lt;summary&amp;gt;
    /// 唯一标识
    /// &amp;lt;/summary&amp;gt;
    public string SingleStr { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;其中用户名是服务端生成的，服务端会将该用户名作为键，将该token存储到缓存中。 所以对于每一个请求都会生成一个唯一的用户名，服务端会定期清理在缓存中已经失效的token&lt;/p&gt;
&lt;blockquote readability=&quot;26&quot;&gt;
&lt;pre&gt;
&lt;code&gt;    public static TokenResult MakeToken(string RequestParam, string PrimaryKey = null)
    {
        try
        {
            dynamic p = JsonConvert.DeserializeObject(RequestParam);
            string RequestAuth = p.RequestAuth;//请求人信息
            string DesAuth;//解密后的author
            if (PrimaryKey == null)
                DesAuth = RSAHelper.Decrypt(RequestAuth, Config_PrimaryKey);
            else
                DesAuth = RSAHelper.Decrypt(RequestAuth, PrimaryKey);

            #region 请求历史是否有重复
            if (MakeTokenParamHistory.Contains(DesAuth))
            {
                ToolFactory.LogHelper.Info(&quot;生成token身份验证失败:该请求的字符串与之前重复：&quot; + DesAuth);
                return new TokenResult() { Success = false, Error_Message = &quot;请求数据非法&quot; };
            }
            MakeTokenParamHistory.Insert(0, DesAuth);
            if (MakeTokenParamHistory.Count 1000)
                MakeTokenParamHistory.RemoveRange(1000, MakeTokenParamHistory.Count - 1000);
            #endregion

            string ReqAuthId = DesAuth.Substring(DesAuth.Length - 46, 10);//请求人身份标识
            long reqTimespan = long.Parse(DesAuth.Substring(0, DesAuth.Length - 46));  //客户端请求时间秒数

            if (!ValidTokenAuth(ReqAuthId))
            {
                ToolFactory.LogHelper.Info(&quot;生成token身份验证失败:DesAuth&quot; + DesAuth);
                return new TokenResult() { Success = false, Error_Message = &quot;身份验证失败&quot; };
            }

            if ((TimeHelper.GetTimeSecond() - reqTimespan) ReqToken_OverTime)
            {
                ToolFactory.LogHelper.Info(&quot;生成token请求时间超时:DesAuth&quot; + DesAuth);
                return new TokenResult() { Success = false, Error_Message = &quot;请求时间超时&quot; };
            }
            string uname = TokenBuilder.CreateUserName(ReqAuthId);
            long TokenOverTime = Token_OverTime;
            if (AuthMapOverTime != null &amp;amp;&amp;amp; AuthMapOverTime.ContainsKey(ReqAuthId))
                TokenOverTime = AuthMapOverTime[ReqAuthId];
            string tokenStr = TokenBuilder.CreateTokenStr(&quot;jwt&quot;, ReqAuthId, uname, TokenOverTime);
            ToolFactory.LogHelper.Notice(&quot;生成token:&quot; + tokenStr);
            ToolFactory.CacheHelper.SetCache(&quot;ServiceTokenCacheKey_&quot; + uname, tokenStr, TimeSpan.FromSeconds(TokenOverTime + 600)); //多存600秒
            return new TokenResult() { Success = true, Token = AesHelper.Encrypt(tokenStr) }; ;
        }
        catch (Exception ex)
        {
            ToolFactory.LogHelper.Error(&quot;生成token出现异常&quot;, ex);
            return new TokenResult() { Success = false, Error_Message = &quot;错误的请求：&quot; + ex.Message };
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;p&gt;对于携带token的请求，我将token放在http的header中，尽量减少验证对于业务代码的侵入性。&lt;/p&gt;
&lt;p&gt;服务端将token取出，并或得token中存储的用户名，然后将服务端缓存的数据取出来判断该token是否有效&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 验证客户端发来的token是否有效
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;header&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static ValidTokenResult ValidClientToken(HttpRequestHeaders header)
    {
        if (header.Authorization == null || header.Authorization.Parameter == null)
        {
            return new ValidTokenResult() { Success = false, Message = &quot;not exit token&quot; };
        }
        string tokenStr = AesHelper.Decrypt(header.Authorization.Parameter);
        //ToolFactory.LogHelper.Notice(&quot;接收到带token的请求:&quot; + tokenStr);
        TokenClaims tcParam = TokenBuilder.ParseTokenClaims(tokenStr);
        TokenClaims tcCache = TokenBuilder.ParseTokenClaims(ToolFactory.CacheHelper.GetCache&amp;lt;string&amp;gt;(&quot;ServiceTokenCacheKey_&quot; + tcParam.Usr));
        if (tcCache != null)
        {
            if (TokenIsTimeLoss(tcCache.Exp))
            {
                ToolFactory.LogHelper.Info(&quot;token过时,token:&quot; + tokenStr);
                return new ValidTokenResult() { Success = false, Message = &quot;token过时&quot; };
            }
            else if (tcCache.SingleStr != tcParam.SingleStr)
            {
                ToolFactory.LogHelper.Info(&quot;token不正确,token:&quot; + tokenStr);
                return new ValidTokenResult() { Success = false, Message = &quot;token不正确&quot; };
            }
            else
            {
                return new ValidTokenResult() { Success = true };
            }
        }
        else
        {
            ToolFactory.LogHelper.Info(&quot;ValidClientToken未授权的用户,token:&quot; + tokenStr);
            return new ValidTokenResult() { Success = false, Message = &quot;未授权的用户&quot; };
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;整个验证框架的主要流程大概就是这样，当然还有很多细节，比如缓存的刷新，请求超时配置等等，有兴趣的可以到github下载具体代码~~~&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jan 2018 04:58:00 +0000</pubDate>
<dc:creator>蓝夏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bluesummer/p/8309608.html</dc:identifier>
</item>
</channel>
</rss>