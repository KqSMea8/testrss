<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>内聚与耦合 - 繁华里流浪</title>
<link>http://www.cnblogs.com/LeslieForever/p/9280135.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LeslieForever/p/9280135.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;模块&lt;/span&gt;  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       模块是由一组语句组成，并且被标识符组成的边界元素所界定。类，方法都是可以称之为一个模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 内聚与耦合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       内聚是指一个模块内的交互程度，耦合是指模块间的交互程度。我们需要尽力做到高内聚低耦合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 内聚&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;       内聚分为如下几类：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708151413178-173263082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       &lt;strong&gt;1）偶然内聚&lt;/strong&gt;：一个模块里各个成分之间没有什么关系，就是很随意的拼凑了在了一起，被封装成了一个模块。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;例子&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;        Public void funA(){&lt;/p&gt;
&lt;p&gt;              If(a&amp;gt;b)&lt;/p&gt;
&lt;p&gt;                   c = a – b;&lt;/p&gt;
&lt;p&gt;              System.out.prinltn(“今天天气真不错”);     &lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;缺点&lt;/strong&gt;：1.可读性差（一会这个一会那个多乱呀）&lt;/p&gt;
&lt;p&gt;                2.可维护性差（这种一个功能干好多没关系的事情，维护是不可能维护的2333）&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;解决&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;                这个解决办法十分的简单，就是将那些不相关的成分，都分别拆解开来形成各自的模块，每个模块都只是执行一个任务。&lt;/p&gt;

&lt;p&gt;       &lt;strong&gt;2）逻辑内聚&lt;/strong&gt;：几个逻辑上相关的功能被封装到同一个模块里面，然后由调用函数传入控制的参数来确定调用哪个功能。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708151529392-897149018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       &lt;strong&gt;缺点&lt;/strong&gt;：1.接口不容易理解，因为传入控制参数至就会添加参数说明否则谁知道参数。&lt;/p&gt;
&lt;p&gt;                  2.修改起来不好办，如果添加或者删除逻辑功能会麻烦。&lt;/p&gt;
&lt;p&gt;                  3.增加耦合度&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;解决&lt;/strong&gt;：把那几个逻辑相关的拆解成独立的模块。&lt;/p&gt;

&lt;p&gt;       &lt;strong&gt;3）时间内聚&lt;/strong&gt;：如果一些功能仅仅是因为在同一时间执行，仅仅是由于时间关系就被封装到了一个模块。如一些初始化模块。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;缺点&lt;/strong&gt;：1.成分间的关系不强，但与其它模块相关度很高。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;4）过程内聚&lt;/strong&gt;：把一些列的过程行为放到一起形成一个模块。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;例子&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;                    &lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708151701788-2097970103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       &lt;strong&gt;缺点&lt;/strong&gt;：模块复用性低，多个行为活动封装到一起，别的函数要是用到还要重新写，导致复用性差。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;解决&lt;/strong&gt;：还是拆开。&lt;/p&gt;

&lt;p&gt;       &lt;strong&gt;5）通信内聚&lt;/strong&gt;：因为行为活动使用数据参数相同，所以就将他们封装到一个模块。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;例子&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708151750809-472786636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;缺点&lt;/strong&gt;：不可复用&lt;/p&gt;

&lt;p&gt;      &lt;strong&gt;6）&lt;/strong&gt; &lt;strong&gt;功能内聚&lt;/strong&gt;：每个模块仅仅是完成一个行为互动，这也体现了单一职责。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;例如&lt;/strong&gt;：判断大小，计算加法&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;好处&lt;/strong&gt;：1.复用性高&lt;/p&gt;
&lt;p&gt;                2.错误隔离&lt;/p&gt;

&lt;p&gt;       &lt;strong&gt;7）信息内聚&lt;/strong&gt;：一个模块它可以执行很多的行为，但是每个行为都有自己入口，每个行为与其他行为独立，并且都在统一数据结构上执行。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708151938195-892000419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;   &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt; 耦合&lt;/strong&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708152049775-1026293438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　1）内容耦合：&lt;/strong&gt;一个模块不经调用直接引用另一个模块的内容。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;例子:&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708152102159-337640799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;缺点&lt;/strong&gt;:这种耦合标明，一个模块与另一个模块联系十分紧密，如果另一个模块改变，这个模块必定收到很大影响，以至于无法正常使用。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;解决&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708152120484-544319127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　2）公共耦合：多个模共同引用一个全局数据&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708152209853-1339283591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　缺点&lt;/strong&gt;：全局变量修改会导致引用模块都收影响，不易于维护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3）控制耦合&lt;/strong&gt;：一个模块通过一个控制参数来控制另外一个模块，它与逻辑内聚有关系。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708152238784-1065228167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;缺点&lt;/strong&gt;: 1.模块见依赖不独立&lt;/p&gt;
&lt;p&gt;       　　   2.复用性低&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;解决&lt;/strong&gt;：取消控制参数，将B内不同活动拆解开，由A模块进行判断调用哪个模块，而非传递参数到B来判断执行哪个。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708152335777-2033062000.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　4）标记耦合&lt;/strong&gt;：一个数据结构作为参数进行传递，但是被调用的模块只是使用了数据结构中的一部分内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　例子：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/945570/201807/945570-20180708152359442-877561723.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;缺点&lt;/strong&gt;：1.被调用函数必须清楚参数的数据结构，并按照结构的要求进行操作数据，&lt;/p&gt;
&lt;p&gt;        　　   2.难于理解&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;　　5）数据耦合&lt;/strong&gt;：模块间传递基本数据类型或者是所有元素都被使用的数据结构进行调用。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;缺点&lt;/strong&gt;：没啥缺点&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;优点&lt;/strong&gt;：可维护性高，没啥缺点233.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;　　&lt;span&gt;参考&lt;/span&gt;：https://blog.csdn.net/gpwner/article/details/53455217&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;　　　　　 中国大学MOOC软件工程课件&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 07:29:00 +0000</pubDate>
<dc:creator>繁华里流浪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LeslieForever/p/9280135.html</dc:identifier>
</item>
<item>
<title>Dubbo架构学习整理 - butterfly100</title>
<link>http://www.cnblogs.com/butterfly100/p/9260731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/butterfly100/p/9260731.html</guid>
<description>&lt;h2&gt;一. Dubbo诞生背景&lt;/h2&gt;
&lt;p&gt;随着互联网的发展和网站规模的扩大，系统架构也从单点的垂直结构往分布式服务架构演进，如下图所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单一应用架构：一个应用部署所有功能，此时简化CRUD的ORM框架是关键&lt;/li&gt;
&lt;li&gt;垂直应用架构：应用拆分为不相干的几个应用，前后端分离，此时用于加速前端页面开发的Web MVC框架是关键&lt;/li&gt;
&lt;li&gt;分布式服务架构：抽取各垂直应用的核心业务作为独立服务，形成稳定的服务中心，此时用于提高业务复用及整合的分布式服务框架(RPC)是关键&lt;/li&gt;
&lt;li&gt;流动计算架构：当服务越来越多，容量的评估、小服务资源的浪费等问题逐渐显现，此时用于提高机器利用率的实时资源调度和治理中心(SOA)是关键&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180703201141116-2056783344.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当服务比较少时，可以通过 RMI 或 Hession 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址来调用，通过F5等硬件负载均衡&lt;/p&gt;
&lt;p&gt;当服务越来越多时，服务配置URL变的困难，F5硬件负载均衡的单点压力越来越大。此时需要&lt;strong&gt;服务注册中心，动态的注册和发现服务，使服务的位置透明。服务调用实现软负载均衡和Failover&lt;/strong&gt;，降低对F5硬件负载均衡器的依赖&lt;/p&gt;
&lt;p&gt;当服务间关系越来越复杂时，此时需要&lt;strong&gt;自动画出服务间的依赖关系图&lt;/strong&gt;，来帮助架构师理清服务关系&lt;/p&gt;
&lt;p&gt;当服务调用量越来越大时，服务需要多少台机器支撑，服务容量的问题就暴露出来了，此时需要&lt;strong&gt;统计服务每天的调用量、响应时间等性能指标&lt;/strong&gt;作为容量规划的参考。其次，还可以&lt;strong&gt;动态调整权重&lt;/strong&gt;，将某台机器权重一直加大，直到响应时间到阀值，按照此时的访问量反推服务的总容量&lt;/p&gt;
&lt;p&gt;以上是Dubbo的基本需求，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180703202059073-366765503.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二. 整体架构&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Dubbo的整体架构设计如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180708103454756-532171162.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt; &lt;/p&gt;
&lt;p&gt;Dubbo框架一共分10层，各层单向依赖。最上面的 Service 和 Config 为API，其他均为 SPI。&lt;span&gt;左边淡蓝色&lt;/span&gt;的为 consumer 使用的接口，&lt;span&gt;右边淡绿色&lt;/span&gt;的为 provider 使用的接口，中间的为双方都用到的接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;黑色箭头&lt;/strong&gt;代表层之间的依赖关系；&lt;span&gt;蓝色虚线&lt;/span&gt;为初始化过程，即启动时组装链；&lt;span&gt;红色实线&lt;/span&gt;为方法调用过程；&lt;span&gt;紫线&lt;/span&gt;为继承关系。线上的文字为调用的方法。&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;接口服务层（Service）&lt;/strong&gt;：该层与业务逻辑相关，根据 provider 和 consumer 的业务设计对应的接口和实现&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;配置层（Config）&lt;/strong&gt;：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、服务代理层（Proxy）&lt;/strong&gt;：服务接口透明代理，生成服务的客户端 Stub 和 服务端的 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、服务注册层（Registry）&lt;/strong&gt;：封装服务地址的注册和发现，以服务 URL 为中心，扩展接口为 RegistryFactory、Registry、RegistryService&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、路由层（Cluster）&lt;/strong&gt;：封装多个提供者的路由和负载均衡，并桥接注册中心，以Invoker 为中心，扩展接口为 Cluster、Directory、Router和LoadBlancce&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、监控层（Monitor）&lt;/strong&gt;：RPC调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory、Monitor和MonitorService&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、远程调用层（Protocal）&lt;/strong&gt;：封装 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocal、Invoker和Exporter&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、信息交换层（Exchange）&lt;/strong&gt;：封装请求响应模式，同步转异步。以 Request 和 Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9、网络传输层（Transport）&lt;/strong&gt;：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为Channel、Transporter、Client、Server和Codec&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10、数据序列化层（Serialize）&lt;/strong&gt;：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool &lt;/p&gt;
&lt;p&gt;各层关系说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Portocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成&lt;strong&gt;非透明的 RPC 调用，&lt;/strong&gt;然后在 Invoker 的主过程上 Filter 拦截点&lt;/li&gt;
&lt;li&gt;Cluster 是外围概念，目的是&lt;strong&gt;将多个 Invoker 伪装为一个 Invoker&lt;/strong&gt;，这样其它人只要关注 Protocol 层 Invoker 即可。只有一个 provider 时，是不需要 Cluster 的&lt;/li&gt;
&lt;li&gt;Proxy 层&lt;strong&gt;封装了所有接口的透明化代理&lt;/strong&gt;，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，看起来像调本地服务一样调远程服务&lt;/li&gt;
&lt;li&gt;Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层：Transport 层只负责&lt;strong&gt;单向消息传输&lt;/strong&gt;，是对 Mina, Netty, Grizzly 的抽象；而 Exchange 层是在传输层之上&lt;strong&gt;封装了 Request-Response 语义&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Dubbo核心领域模型：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理&lt;/li&gt;
&lt;li&gt;Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它。它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现&lt;/li&gt;
&lt;li&gt;Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Dubbo主要包括以下几个节点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Provider：暴露服务的服务提供方&lt;/li&gt;
&lt;li&gt;Consumer：调用远程服务的服务消费方&lt;/li&gt;
&lt;li&gt;Registry：服务注册和发现的注册中心&lt;/li&gt;
&lt;li&gt;Monitor：统计服务的调用次数和调用时间的监控中心&lt;/li&gt;
&lt;li&gt;Container：服务运行容器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180708121603698-1003764693.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Consumer, Provider, Registry, Monitor代表逻辑部署节点。图中只包含 RPC 层，不包含 Remoting层，Remoting整体隐藏在 Protocol 中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;蓝色方框&lt;/span&gt;代表业务有交互，&lt;span&gt;绿色方框&lt;/span&gt;代表只对Dubbo内部交互。&lt;span&gt;蓝色虚线&lt;/span&gt;为初始化时调用，&lt;span&gt;红色虚线&lt;/span&gt;为运行时异步调用，&lt;span&gt;红色实线&lt;/span&gt;为运行时同步调用&lt;/p&gt;
&lt;p&gt;0、服务在容器中启动，加载，运行Provider&lt;/p&gt;
&lt;p&gt;1、Provider在启动时，向Registry注册自己提供的服务&lt;/p&gt;
&lt;p&gt;2、Consumer在启动时，想Registry订阅自己所需的服务&lt;/p&gt;
&lt;p&gt;3、Registry给Consumer返回Provider的地址列表，如果Provider地址有变更（上线/下线机器），Registry将基于长连接推动变更数据给Consumer&lt;/p&gt;
&lt;p&gt;4、Consumer从Provider地址列表中，基于软负载均衡算法，选一台进行调用，如果失败，重试另一台调用&lt;/p&gt;
&lt;p&gt;5、Consumer和Provider，在内存中累计调用次数和时间，定时每分钟一次将统计数据发送到Monitor&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将上面的服务调用流程展开，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180706180401348-91831606.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;蓝色虚线为初始化过程，即启动时组装链；红色实线为方法调用过程，即运行时调用链；紫色实线为继承&lt;/p&gt;

&lt;h2&gt;三、实现细节&lt;/h2&gt;
&lt;p&gt;Invoker 是 Dubbo 领域模型中非常重要的一个概念，很多设计思路都是向它靠拢，这就使得 Invoker 渗透在整个实现代码里。下面用一个精简的图来说明最重要的两种 Invoker：服务提供 Invoker 和服务消费 Invoker：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180707193251354-305622677.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① 定义服务接口：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; DemoService {
    String sayHello(String name);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;② 服务提供者代码：&lt;/strong&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DemoServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DemoService {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHello(String name) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello &quot; +&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180708124441290-729539528.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ServiceConfig 类拿到对外提供服务的实际类 ref（如：DemoServiceImpl）通过 ProxyFactory.getInvoker 方法使用 ref 生成一个 AbstractProxyInvoker 实例，然后 通过 Protocol.export 方法新生成一个 Exporter 实例&lt;/p&gt;
&lt;p&gt;当网络通讯层收到一个请求后，会找到对应的 Exporter 实例，并调用它所对应的 AbstractProxyInvoker 实例，从而真正调用了服务提供者的代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ 服务消费者代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span readability=&quot;3&quot;&gt; DemoClientAction {
   &lt;br/&gt;　　private DemoService demoService;&lt;p&gt;　　public void setDemoService(DemoService demoService) {&lt;br/&gt;　　　　this.demoService = demoService;&lt;br/&gt;　　}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;　　public void start() {&lt;br/&gt;　　　　String hello = demoService.sayHello(&quot;world&quot;);&lt;br/&gt;　　}
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180708125717716-1451542740.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先通过 ReferenceConfig.init 方法调用 Protocal.refer 方法生成 Invoker 实例，接下来通过 ProxyFactory.getProxy 方法将 Invoker 转换为客户端需要的接口（如：DemoService）&lt;/p&gt;
&lt;p&gt;DemoService 就是 consumer 端的 proxy，用户代码通过这个 proxy 调用其对应的 Invoker，通过 Invoker 实现真正的远程调用&lt;/p&gt;

&lt;h2&gt;四. 功能特性&lt;/h2&gt;
&lt;h3&gt;1. 配置&lt;/h3&gt;
&lt;p&gt;Dubbo可以采用全Spring的配置方式，基于Spring的Schema扩展进行加载，接入对业务透明，无API侵入。配置项可参考：&lt;span&gt;&lt;a href=&quot;http://dubbo.apache.org/#/docs/user/references/xml/introduction.md&quot;&gt;&lt;span&gt;schema&lt;/span&gt;&lt;/a&gt; &lt;a href=&quot;http://dubbo.apache.org/#/docs/user/references/xml/introduction.md&quot;&gt;&lt;span&gt;配置参考手册&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;a title=&quot;schema 配置参考手册&quot; href=&quot;http://dubbo.apache.org/#/docs/user/references/xml/introduction.md?lang=zh-cn&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了Spring配置，也可以使用API配置、属性配置和注解配置方式。&lt;/p&gt;
&lt;p&gt;配置之间的关系，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180705160450095-83673471.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;provider side：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&lt;strong&gt;&amp;lt;dubbo:protocol/&amp;gt;&lt;/strong&gt;：协议配置。用于配置提供服务的协议信息，协议由provider指定，consumer被动接受&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;&amp;lt;dubbo:service/&amp;gt;&lt;/strong&gt;： 服务配置。暴露一个service，定义service的元信息，一个service可以用多个协议暴露，也可以注册到多个注册中心&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;&amp;lt;dubbo:provider/&amp;gt;&lt;/strong&gt;：提供方配置【可选】。当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;consumer side：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&lt;strong&gt;&amp;lt;dubbo:reference/&amp;gt;&lt;/strong&gt;：引用配置。用于创建一个远程服务代理，一个引用可以指向多个注册中心&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;&amp;lt;dubbo:consumer/&amp;gt;&lt;/strong&gt;：消费方配置【可选】。当 ReferenceConfig 某属性没有配置时，采用此缺省值&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;application shared：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&lt;strong&gt;&amp;lt;dubbo:application/&amp;gt;&lt;/strong&gt;：应用配置。配置应用信息，包括provider和consumer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;&amp;lt;dubbo:registry/&amp;gt;&lt;/strong&gt;：注册中心配置。配置连接注册中心相关信息&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;&amp;lt;dubbo:monitor/&amp;gt;&lt;/strong&gt;：监控中心配置【可选】。配置连接监控中心相关信息&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;sub-config：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&lt;strong&gt;&amp;lt;dubbo:method/&amp;gt;&lt;/strong&gt;：方法配置。用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;&amp;lt;dubbo:argument/&amp;gt;&lt;/strong&gt;：参数配置。用于指定方法参数配置&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 集群容错&lt;/h3&gt;
&lt;p&gt;服务调用时的过程如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180705165735227-1598649777.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Invoker：是&lt;strong&gt;Provider的一个可调用Service的抽象&lt;/strong&gt;，封装了Provider地址和Service接口信息&lt;/p&gt;
&lt;p&gt;Directory：代表多个Invoker，可将它看为&lt;strong&gt;List&amp;lt;Invoker&amp;gt;，它的值是动态变化的&lt;/strong&gt;，比如注册中心推送变更&lt;/p&gt;
&lt;p&gt;Cluster：将&lt;strong&gt;Directory的多个Invoker伪装为一个Invoker&lt;/strong&gt;，对上层透明。伪装过程中包括容错逻辑，例如：一个Invoker调用失败后重试另一个Invoker&lt;/p&gt;
&lt;p&gt;Router：从&lt;strong&gt;多个Invoker中按路由规则选出子集&lt;/strong&gt;，例如：读写分离、应用隔离等&lt;/p&gt;
&lt;p&gt;LoadBlance：从&lt;strong&gt;多个Invoker中选出具体的一个Invoker用于本次调用&lt;/strong&gt;，选的过程包括负载均衡算法，调用失败后需要重选&lt;/p&gt;
&lt;p&gt;当Cluster集群调用失败时，Dubbo提供了多种容错方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Failover【默认】：失败时自动切换，重试其它服务器。通常用于读操作，可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)&lt;/li&gt;
&lt;li&gt;Failfast：快速失败，只调用一次，失败立即报错。通常用于非幂等的写操作，比如：新增记录&lt;/li&gt;
&lt;li&gt;Failsafe：失败安全，失败时直接忽略。通常用于写入审计日志等操作&lt;/li&gt;
&lt;li&gt;Failback：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知等操作&lt;/li&gt;
&lt;li&gt;Forking：并行调用多个服务器，只要一个成功即返回。通常用于实时性较高的读操作，但浪费更多服务资源。可通过 forks=&quot;2&quot; 设置最大并行数&lt;/li&gt;
&lt;li&gt;Broadcast：广播调用者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新本地资源信息，如缓存、日志等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. 路由规则&lt;/h3&gt;
&lt;p&gt;路由规则决定一次dubbo服务调用的目标服务器，分为脚本路由规则和条件路由规则，支持可扩展。向注册中心写入路由规则的操作通常由治理中心的页面完成&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;脚本路由规则：支持JDK脚本引擎的所有脚本，例如：javascript, groovy 等&lt;/li&gt;
&lt;li&gt;条件路由规则：基于条件的路由规则，例如：host = 10.20.153.10 =&amp;gt; hsot = 10.20.153.11。=&amp;gt;之前是consumer匹配条件，所有参数和consumer的URL进行对比，如果consumer满足匹配条件，则对consumer执行后面的过滤规则。=&amp;gt;之后是provider地址列表的过滤条件，所有参数和provider的URL进行对比，consumer只拿到过滤后的地址列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. 负载均衡&lt;/h3&gt;
&lt;p&gt;如上图 LoadBlance 模块所示：在集群负载均衡时，Dubbo提供了不同的策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Random【默认】：&lt;strong&gt;随机&lt;/strong&gt;，按权重设置随机概率。调用量越大越均匀，有利于动态调整权重&lt;/li&gt;
&lt;li&gt;RoundRobin：&lt;strong&gt;轮询&lt;/strong&gt;，按公约后的权限设置轮询比率。如果有台机器很慢，但没挂，当请求到那一台时就卡在那儿，久而久之，所有请求都卡在那台机器上&lt;/li&gt;
&lt;li&gt;LeastActive：&lt;strong&gt;最少活跃调用数&lt;/strong&gt;，活跃数指调用前后计数差，越慢的provider的调用前后计数差越大，使得慢的provider收到更少请求&lt;/li&gt;
&lt;li&gt;ConsistentHash：&lt;strong&gt;一致性Hash&lt;/strong&gt;，相同参数的请求发往同一台provider，当一台provider挂掉时，原本发往该机器的请求，基于虚拟节点会平摊到其他机器，不会引起剧烈变动&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5. 线程派发模型 &lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180705174204708-762792187.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果事件处理的逻辑能迅速完成，并且不发生新的IO请求（例如在内存中记个标识），则在IO线程上处理更快，因为减少了线程池调度&lt;/p&gt;
&lt;p&gt;如果事件处理的逻辑较慢，或需要发起新的IO请求（例如需要查询数据库），则必须派发到线程池，否则 IO 线程阻塞，将导致不能接受其他请求&lt;/p&gt;
&lt;p&gt;因此需要不同的派发策略和不同的线程池组合来应对不同的场景：&lt;/p&gt;
&lt;p&gt;Dispatcher：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;all：所有消息派发到 ThreadPool，包括请求、响应、连接事件、断开事件、心跳等&lt;/li&gt;
&lt;li&gt;direct：所有消息不派发 ThreadPool，全在 IO 线程上执行&lt;/li&gt;
&lt;li&gt;message：只有请求响应消息派发到 ThreadPool，其他连接事件、断开事件、心跳等，在 IO 线程上执行&lt;/li&gt;
&lt;li&gt;execution：只请求消息派发到 ThreadPool，其他事件包括响应事件、连接断开事件、心跳等消息，在 IO 线程上执行&lt;/li&gt;
&lt;li&gt;connection：在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其他时间派发到 ThreadPool&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ThreadPool：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fixed【默认】：固定大小线程池，启动时建立线程，一直持有不关闭&lt;/li&gt;
&lt;li&gt;cached：缓存线程池，空闲一分钟自动删除，需要时重建&lt;/li&gt;
&lt;li&gt;limited：可伸缩线程池，线程数只增长不收缩，目的是为了避免收缩时大流量引起的性能问题&lt;/li&gt;
&lt;li&gt;eager：优先创建Worker线程池，corePoolSize &amp;lt; 任务数量 &amp;lt; maximumPoolSize时，优先创建 Worker 处理任务。任务数量 &amp;gt; maximumPoolSize时，任务放入阻塞队列中，阻塞队列充满时抛出 RejectExecutionException&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6. 上下文信息和隐式参数&lt;/h3&gt;
&lt;p&gt;上下文中存放着当前调用过程中所需的环境信息。RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收或发起 RPC 请求时，RpcContext 都会发生变化。比如：A调用B，B调用C，在B调C之前，B机器上 RpcContext 记录的是A调用B的信息。&lt;/p&gt;
&lt;p&gt;通过 RpcContext 的 setAttachment 和 getAttachment 可以在 provider 和 consumer 之间进行参数的隐式传递&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180705202205728-892547187.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;7. 异步调用&lt;/h3&gt;
&lt;p&gt;基于NIO的非阻塞实现并行调用，客户端不需要启动多线程即可完成多个远程服务的并行调用，相对比多线程开销较小&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180706111009384-661719946.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;8. 注册中心&lt;/h3&gt;
&lt;p&gt;对于 provider，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；对于 consumer，它最关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用&lt;/p&gt;
&lt;p&gt;服务注册中心通过特性协议将服务统一管理起来，有效的优化内部应用对服务发布/使用的流程。Dubbo提供的注册中心有如下几种类型可供选择：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① ZooKeeper注册中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180706150105654-817555629.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ZK是一个树形的服务目录，支持变更推送，适合作为Dubbo服务的注册中心。流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;provider启动时，向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址&lt;/li&gt;
&lt;li&gt;consumer启动时，订阅 /dubbo/com.foo.BarService/providers 目录下的 providers 地址，并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址&lt;/li&gt;
&lt;li&gt;监控中心启动时，订阅 /dubbo/com.foo.BarService 目录下的所有 provider 和 consumer URL地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当 provider 出现断电等异常停机时，注册中心能自动删除 provider 信息。当注册中心重启、或会话过期时，能自动恢复注册数据和订阅请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② Multicase注册中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180706151256605-576028631.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Multicast注册中心不需要启动任何中心节点，只要广播地址即可互相发现&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;provider 启动时广播自己的地址&lt;/li&gt;
&lt;li&gt;consumer 启动时广播订阅请求&lt;/li&gt;
&lt;li&gt;provider 收到订阅请求时，单播自己的地址给订阅者，若设置了 unicast=false，则广播给订阅者&lt;/li&gt;
&lt;li&gt;consumer 收到 provider 地址时，连接地址进行 RPC 调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;组播受网络结构限制，只适合小规模应用或开发阶段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ Redis注册中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278254/201807/1278254-20180706153927831-643002961.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 redis 的 Key/Map 结构存储数据结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主 Key 为服务名和类型&lt;/li&gt;
&lt;li&gt;Map 中的 Key 为 URL 地址&lt;/li&gt;
&lt;li&gt;Map 中的 Value 为过期时间，用于判断脏数据，脏数据由监控中心删除&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;provider 启动时，向 Key:/dubbo/com.foo.BarService/providers 下，添加当前 provider 的地址&lt;/li&gt;
&lt;li&gt;并向 Channel:/dubbo/com.foo.BarService/providers 发送 register 事件&lt;/li&gt;
&lt;li&gt;consumer 启动时，向 Key:/dubbo/com.foo.BarService/providers 下，添加当前 consumer 的地址&lt;/li&gt;
&lt;li&gt;并从 Channel:/dubbo/com.foo.BarService/providers 订阅 register 和 unregister 事件&lt;/li&gt;
&lt;li&gt;consumer 收到 register 和 unregister 事件后，从 Key:/dubbo/com.foo.BarService/providers 下获取 provider 地址列表&lt;/li&gt;
&lt;li&gt;服务监控中心启动时，从 Channel:/dubbo/* 订阅 register 和 unregister，以及 subscribe 和 unsubscribe 事件&lt;/li&gt;
&lt;li&gt;监控中心收到 register 和 unregister 事件后，从 Key:/dubbo/com.foo.BarService/providers 下获取 provider 地址列表&lt;/li&gt;
&lt;li&gt;监控中心收到 subscribe 和 unsubscribe 事件后，从 Key:/dubbo/com.foo.BarService/comsumers 下获取 consumer 地址列表&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p class=&quot;entry-title&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://dubbo.apache.org/#/?lang=zh-cn&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Dubbo开发文档&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 06:33:00 +0000</pubDate>
<dc:creator>butterfly100</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/butterfly100/p/9260731.html</dc:identifier>
</item>
<item>
<title>微服务架构—自动化测试全链路设计 - 王清培</title>
<link>http://www.cnblogs.com/wangiqngpei557/p/9279984.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangiqngpei557/p/9279984.html</guid>
<description>&lt;ul&gt;&lt;li&gt;背景&lt;/li&gt;
&lt;li&gt;被忽视的软件工程环节 - &lt;strong&gt;&lt;em&gt;DEVTESTOPS&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;微服务架构下测试复杂度和效率问题&lt;/li&gt;
&lt;li&gt;开发阶段 &lt;strong&gt;&lt;em&gt;unitTest mock&lt;/em&gt;&lt;/strong&gt; 外部依赖&lt;/li&gt;
&lt;li&gt;连调阶段 &lt;strong&gt;&lt;em&gt;mock&lt;/em&gt;&lt;/strong&gt; 外部依赖&lt;/li&gt;
&lt;li&gt;自动化测试阶段 &lt;strong&gt;&lt;em&gt;mock&lt;/em&gt;&lt;/strong&gt; 需求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;autoTest Mock Gateway&lt;/em&gt;&lt;/strong&gt; 浮出水面&lt;/li&gt;
&lt;li&gt;轻量级版本实现
&lt;ul&gt;&lt;li&gt;整体逻辑架构&lt;/li&gt;
&lt;li&gt;将 &lt;strong&gt;mock parameter&lt;/strong&gt; 纳入服务框架标准 &lt;strong&gt;request contract&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;AOP + RestEasy HttpClientRequest SPI&lt;/strong&gt; 初步实现 &lt;strong&gt;Mock&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从 &lt;strong&gt;SOA&lt;/strong&gt; 架构到现在大行其道的微服务架构，系统越拆越小，整体架构的复杂度也是直线上升，我们一直老生常谈的微服务架构下的技术难点及解决方案也日渐成熟（包括典型的数据一致性，系统调用带来的一致性问题，还是跨节点跨机房复制带来的一致性问题都有了很多解决方案），但是有一个环节我们明显忽略了。&lt;/p&gt;
&lt;p&gt;在现在的微服务架构趋势下，微服务在运维层面和自动化部署方面基本上是比较完善了。从我个人经验来看，上层的开发、测试对微服务架构带来的巨大变化还在反应和学习中。&lt;/p&gt;
&lt;p&gt;开发层面讨论微服务的更多是框架、治理、性能等，但是从完整的软件工程来看我们严重缺失分析、设计知识，这也是我们现在的工程师普遍缺乏的技术。&lt;/p&gt;
&lt;p&gt;我们经常会发现一旦你想重构点东西是多么的艰难，就是因为在初期构造这栋建筑的时候严重缺失了通盘的分析、设计，最终导致这个建筑慢慢僵化最后人见人怕，因为他逐渐变成一个怪物。（比如，开发很少写 &lt;strong&gt;unitTest&lt;/strong&gt; ，我们总是忽视单元测试背后产生的软件工程的价值。）&lt;/p&gt;

&lt;p&gt;我们有没有发现一个现象，在整个软件过程里，测试这个环节容易被忽视。任何一种软件工程模型都有 &lt;strong&gt;QA&lt;/strong&gt; 环节，但是这个环节似乎很薄很弱，目前我们绝大多数工程师、架构师都严重低估了这个环节的力量和价值，还停留在无技术含量，手动功能测试低级效率印象里。&lt;/p&gt;
&lt;p&gt;这主要是测试这个角色整个技术体系、工程化能力偏弱，一部分是客观大环境问题，还有一部分自身问题，没有让自己走出去，多去学习整个工程化的技术，多去了解开发的技术，生产上的物理架构，这会有助于测试放大自己的声音。&lt;/p&gt;
&lt;p&gt;导致测试环节在国内整个设计创新薄弱的原因还有一个主要原因就是，开发工程师普遍没有完整的工程基础。在国外IT发达国家，日本、美国等，一个合格的开发工程师、测试工程师都是边界模糊的，自己开发产品自己测试，这需要切换思维模式，需要同时具备这两种能力，但是这才是整个软件工程的完整流程。&lt;/p&gt;
&lt;p&gt;我们有没有想过一个问题，为什么现在大家都在谈论 &lt;strong&gt;DevOps&lt;/strong&gt;，而不是 &lt;strong&gt;DevTestOps&lt;/strong&gt;，为什么偏偏跳过测试这个环节，难道开发的系统需要具备良好的可运维性就不需要可测试性吗，开发需要具备运维能力，运维需要具备开发能力，为什么测试环节忽略了。&lt;/p&gt;
&lt;p&gt;我们对 &lt;strong&gt;QA&lt;/strong&gt; 环节的轻视，对测试角色的不重视其实带来的副作用是非常大的。&lt;/p&gt;

&lt;p&gt;微服务的拆分粒度要比 &lt;strong&gt;SOA&lt;/strong&gt; 细了很多，从容器化镜像自动部署来衡量，是拆小了之后很方便，但是拆小了之后会给整个开发、测试环节增加很大的复杂度和效率问题。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;SOA&lt;/strong&gt; 时期，&lt;strong&gt;&lt;em&gt;契约驱动&lt;/em&gt;&lt;/strong&gt; 这个原则在微服务里也一样适用，跨部门需求定义好契约你就可以先开发上线了。但是这个里面最大的问题就是当前系统的部分连调问题和自动化回归问题，如果是新系统上线还需要做性能压测，这外部的依赖如何解决。&lt;/p&gt;
&lt;p&gt;也许我们会说，不是应该依赖方先ready，然后我们紧接着进行测试、发布吗。如果是业务、架构合理的情况下，这种场景最大的问题就是我们的项目容易被依赖方牵制，这会带来很多问题，比如，研发人员需要切换出来做其他事情，&lt;strong&gt;branch&lt;/strong&gt; 一直挂着，不知道哪天突然来找你说可以对接了，也许这已经过去一个月或者更久，这种方式一旦养成习惯性研发流程就很容易产生线上 &lt;strong&gt;BUG&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;还有一种情况也是合理的情况就是平台提供方需要调用业务方的接口，这里面有一般调用的 &lt;strong&gt;callback&lt;/strong&gt; 接口、交易链路上的 &lt;strong&gt;marketing&lt;/strong&gt; 接口、配送 &lt;strong&gt;routing&lt;/strong&gt; 接口等。&lt;/p&gt;
&lt;p&gt;这里给大家分享我们目前正在进行中的 &lt;strong&gt;marketing-cloud (营销云) 规则引擎&lt;/strong&gt; 项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;marketing-cloud&lt;/strong&gt; 提供了一些营销类业务，有 &lt;strong&gt;团购&lt;/strong&gt;、&lt;strong&gt;优惠券&lt;/strong&gt;、&lt;strong&gt;促销&lt;/strong&gt; 等，但是我们的业务方需要有自己个性化的营销活动玩法，我们需要在 &lt;strong&gt;marketing-cloud&lt;/strong&gt; &lt;strong&gt;规则引擎&lt;/strong&gt; 中抽象出业务方营销活动的返回信息，同时打通个性化营销活动与公共交易、结算环节，形成一个完整的业务流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/microservice-auto/1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个 &lt;strong&gt;marketing-cloud&lt;/strong&gt; 逻辑架构图，跟我们主题相关的就是 &lt;strong&gt;营销规则引擎&lt;/strong&gt; ，他就是我们这里所说的合理的业务场景。&lt;/p&gt;
&lt;p&gt;在整个正向下单过程中，营销规则引擎要肩负起既要提供 &lt;strong&gt;marketing-cloud&lt;/strong&gt; 内的共用营销活动，还需要桥接外部营销中心的各类营销玩法，外部的营销中心会有多个，目前我们主要有两个。&lt;/p&gt;
&lt;p&gt;由于这篇文章不是介绍营销平台怎么设计，所以这里不打算扩展话题。主要是起到抛砖引玉的目的，平台型的业务会存在各种各样的对外系统依赖的业务场景。文章接下来的部分将展开 &lt;strong&gt;marketing-cloud 规则引擎&lt;/strong&gt; 在打通测试链路上的实践。&lt;/p&gt;

&lt;p&gt;在开发阶段，我们会经常性的编写单元测试来测试我们的逻辑，在编写 &lt;strong&gt;unitTest&lt;/strong&gt; 的时候都需要 &lt;strong&gt;mock&lt;/strong&gt; 周边的依赖，&lt;strong&gt;mock&lt;/strong&gt; 出来的对象分为两种类型，一种是不具有 &lt;strong&gt;Assert&lt;/strong&gt; 逻辑的 &lt;strong&gt;stub 桩&lt;/strong&gt; 对象，还有一种就是需要支持 &lt;strong&gt;Assert&lt;/strong&gt; 的 &lt;strong&gt;mocker&lt;/strong&gt; 模拟对象。&lt;/p&gt;
&lt;p&gt;但是我们也不需要明显区分他们，两者的区别不是太明显，在编码规范内可能需要区分。&lt;/p&gt;
&lt;p&gt;我们关心的是如何解决对象之间的依赖问题，各种 &lt;strong&gt;mock&lt;/strong&gt; 框架其实提供了很多非常好用的工具，我们可以很轻松的 &lt;strong&gt;mock&lt;/strong&gt; 周边的依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;given(marketingService.mixMarketingActivity(anyObject())).willReturn(stubResponse);
RuleCalculateResponse response = this.ruleCalculatorBiz.ruleCalculate(request);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们 &lt;strong&gt;mock&lt;/strong&gt; 了 &lt;strong&gt;marketingService.mixMarketingActivity()&lt;/strong&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java&lt;/strong&gt; 世界里提供了很多好用的 &lt;strong&gt;mock&lt;/strong&gt; 框架，比较流行好用的框架之一 &lt;strong&gt;mockito&lt;/strong&gt; 可以轻松 &lt;strong&gt;mock Service&lt;/strong&gt; 层的依赖，当然除了 &lt;strong&gt;mockito&lt;/strong&gt; 之外还有很多优秀的 &lt;strong&gt;mock&lt;/strong&gt; 框架。&lt;/p&gt;
&lt;p&gt;这些框架大同小异，编写 &lt;strong&gt;unitTest&lt;/strong&gt; 最大的问题就是如何重构逻辑使之更加便于测试，也就是代码是否具备很好的可测试性，是否已经消除了绝大多数 &lt;strong&gt;private&lt;/strong&gt; 方法，&lt;strong&gt;private&lt;/strong&gt; 方法是否有某些指责是我们没有捕捉到业务概念。&lt;/p&gt;

&lt;p&gt;在我们完成了所有的开发，完善的单元测试保证了我们内部的逻辑是没有问题的（当然这里不讨论 &lt;strong&gt;unitTest&lt;/strong&gt; 的 &lt;strong&gt;case&lt;/strong&gt; 的设计是否完善情况）。&lt;/p&gt;
&lt;p&gt;现在我们需要对接周边系统开发进行连调了，这个周边系统还是属于本平台之类的其他支撑系统。比如我们的 &lt;strong&gt;marketing-cloud 规则引擎系统&lt;/strong&gt; 与 &lt;strong&gt;下单系统&lt;/strong&gt; 之间的关系。在开发的时候我们编写 &lt;strong&gt;unitTest&lt;/strong&gt; 是顺利的完成了开发解决的验证工作，但是现在面对连调问题。&lt;/p&gt;
&lt;p&gt;系统需要正式的跑起来，但是我们缺乏对外部营销中心的依赖，我们怎么办。其实我们也需要在连调阶段 &lt;strong&gt;mock&lt;/strong&gt; 外部依赖，只不过这个 &lt;strong&gt;mock&lt;/strong&gt; 的技术和方法不是通过 &lt;strong&gt;unitTest&lt;/strong&gt; 框架来支持，而是需要我们自己来设计我们的整个服务的开发架构。&lt;/p&gt;
&lt;p&gt;首先要能识别本次 &lt;strong&gt;request&lt;/strong&gt; 是需要 &lt;strong&gt;mock&lt;/strong&gt; 的，那就需要某种 &lt;strong&gt;mock parameter&lt;/strong&gt; 参数来提供识别能力。&lt;/p&gt;
&lt;p&gt;我们来看下 &lt;strong&gt;marketing-cloud 营销规则引擎&lt;/strong&gt; 在这块的一个初步尝试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface CCMarketingCentralFacade {
    CallResponse callMarketingCentral(CallRequest request);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public interface ClassMarketingCentralFacade {
    CallResponse callMarketingCentral(CallRequest request);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;营销规则引擎使用 &lt;strong&gt;RestEasy client api&lt;/strong&gt; 作为 &lt;strong&gt;rest&lt;/strong&gt; 调用框架。这两个 &lt;strong&gt;Facade&lt;/strong&gt; 是营销平台对 &lt;strong&gt;CCTalk&lt;/strong&gt; 、&lt;strong&gt;沪江网校&lt;/strong&gt; 沪江两大子公司营销中心发起调用的 &lt;strong&gt;Facade&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;(为了尽量还原我们的工程实践干货同时需要消除一些敏感信息的情况下，整篇文章所有的代码实例，我都删除了一些不影响阅读且和本文无关的代码，同时做了一些伪编码和省略，使代码更精简更便于阅读。)&lt;/p&gt;
&lt;p&gt;在正常逻辑下，我们会根据营销路由 &lt;strong&gt;key&lt;/strong&gt; 来决定调用哪个公司的营销中心接口，但是由于我们在开发这个项目的时候暂时业务方还没有存在的地址让我们对接，所以我们自己做了 &lt;strong&gt;mock facade&lt;/strong&gt;，来解决连调问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CCMarketingCentralFacadeMocker implements CCMarketingCentralFacade {

    @Override
    public CallResponse callMarketingCentral(CallRequest request) {

        CallResponse response = ...
        MarketingResultDto marketingResultDto = ...
        marketingResultDto.setTotalDiscount(new BigDecimal(&quot;90.19&quot;));
        marketingResultDto.setUseTotalDiscount(true);

        response.getData().setMarketingResult(marketingResultDto);

        return response;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class ClassMarketingCentralFacadeMocker implements ClassMarketingCentralFacade {

    @Override
    public CallResponse callMarketingCentral(CallRequest request) {
        CallResponse response = ...

        MarketingResultDto marketingResultDto = ...
        marketingResultDto.setUseCoupon(true);
        marketingResultDto.setTotalDiscount(null);
        marketingResultDto.setUseTotalDiscount(false);

        List&amp;lt;MarketingProductDiscountDto&amp;gt; discountDtos = ...

        request.getMarketingProductTagsParameter().getMarketingTags().forEach(item -&amp;gt; {

            MarketingProductDiscountDto discountDto = ...
            discountDto.setProductId(item.getProductID());
            ...
            discountDtos.add(discountDto);
        });
...
        return response;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义了两个 &lt;strong&gt;mock&lt;/strong&gt; 类，都是一些测试数据，就是为了解决在连调阶段的问题，也就是在 &lt;strong&gt;DEV&lt;/strong&gt; 环境上的依赖问题。&lt;/p&gt;
&lt;p&gt;有了 &lt;strong&gt;mock facade&lt;/strong&gt; 之后就需要 &lt;strong&gt;request&lt;/strong&gt; 定义 &lt;strong&gt;mock parameter&lt;/strong&gt; 参数了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class BaseRequest implements Serializable {
    public MockParameter mockParameter;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class MockParameter {

    /**
     * mock cc 营销调用接口
     */
    public Boolean mockCCMarketingInterface;

    /**
     * mock class 营销调用接口
     */
    public Boolean mockClassMarketingInterface;

    /**
     * 是否自动化测试 mock
     */
    public Boolean useAutoTestMock;

    /**
     * 测试mock参数
     */
    public String testMockParam;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们暂且忽略通用型之类的设计，这里只是我们在赶项目的情况下做的一个迭代尝试，等我们把这整个流程都跑通了再来考虑重构提取框架。&lt;/p&gt;
&lt;p&gt;有了输入参数，我们就可以根据参数判断来动态注入 &lt;strong&gt;mock facade&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我们继续向前推进，过了连调阶段紧接着就进入测试环节，现在基本上大多数互联网公司都是自动化的测试，很少在有手动的，尤其是后端系统。&lt;/p&gt;
&lt;p&gt;那么在 &lt;strong&gt;autoTest&lt;/strong&gt; 阶段面临的一个问题就是，我们需要一个公共的 &lt;strong&gt;autoTest&lt;/strong&gt; 地址，这个测试地址是不变的，我们在自动化测试下 &lt;strong&gt;mock&lt;/strong&gt; 的 &lt;strong&gt;facade bean&lt;/strong&gt; 的地址就是这个地址，这个地址输出的值需要能够对应到每次自动化脚本执行的上下文中。&lt;/p&gt;
&lt;p&gt;我们有很多微服务系统来组成一个平台，每个服务都有依赖的第三方接口，原来在自动化测试这些服务的时候都需要去了解业务方系统的接口、&lt;strong&gt;DB&lt;/strong&gt;、前台入口等，因为在编写自动化脚本的时候需要同步创建测试数据，最后才能 &lt;strong&gt;Assert&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个跨部门的沟通和协作效率严重低下，而且人员变动、系统变动都会直接影响上线周期，这里绝对值得创新来解决这个效率严重阻塞问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Value(&quot;${marketing.cloud.business.access.url.mock}&quot;)
private String mockUrl;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**
     * 自动化测试 mocker bean
     */
    @Bean(&quot;CCMarketingCentralFacadeTestMock&quot;)
    public CCMarketingCentralFacade CCMarketingCentralFacadeTestMock() {
        RestClientProxyFactoryBean&amp;lt;CCMarketingCentralFacade&amp;gt; restClientProxyFactoryBean ...
        restClientProxyFactoryBean.setBaseUri(this.mockUrl);
        ...
    }

    /**
     * 自动化测试 mocker bean
     */
    @Bean(&quot;ClassMarketingCentralFacadeTestMock&quot;)
    public ClassMarketingCentralFacade ClassMarketingCentralFacadeTestMock()  {
        RestClientProxyFactoryBean&amp;lt;ClassMarketingCentralFacade&amp;gt; restClientProxyFactoryBean ...
        restClientProxyFactoryBean.setBaseUri(this.mockUrl);
        ...
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;strong&gt;mockUrl&lt;/strong&gt; 就是我们抽象出来的统一的 &lt;strong&gt;autoTest&lt;/strong&gt; 地址，在前面的 &lt;strong&gt;mock parameter&lt;/strong&gt; 中有一个 &lt;strong&gt;useAutoTestMock Boolean&lt;/strong&gt; 类型的参数，如果当前请求此参数为 &lt;strong&gt;true&lt;/strong&gt;，我们将动态注入自动化测试 &lt;strong&gt;mock bean&lt;/strong&gt; ，后续的所有调用都会走到 &lt;strong&gt;mockUrl&lt;/strong&gt; 指定的地方。&lt;/p&gt;

&lt;p&gt;到目前为止，我们遇到了自动化测试统一的 &lt;strong&gt;mock&lt;/strong&gt; 地址要收口所有微服务在这方面的需求。现在最大的问题就是，所有的微服务对外依赖的 &lt;strong&gt;response&lt;/strong&gt; 都不相同，自动化脚本在执行的时候预先创建好的 &lt;strong&gt;response&lt;/strong&gt; 要能适配到当前测试的上下文中。&lt;/p&gt;
&lt;p&gt;比如，营销规则引擎，我们的自动化脚本在创建一个订单的时候需要预先构造好当前商品（比如，&lt;strong&gt;productID：101010&lt;/strong&gt;），在获取外部营销中心提供的活动信息和抵扣信息的 &lt;strong&gt;response&lt;/strong&gt; ，最后才能去 &lt;strong&gt;Assert&lt;/strong&gt; 订单的金额和活动信息记录是否正确，这就是一次 &lt;strong&gt;autoTest context&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/microservice-auto/2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有两种方式来识别当前 &lt;strong&gt;autoTest context&lt;/strong&gt; ，一种是在 &lt;strong&gt;case&lt;/strong&gt; 执行的时候确定商品ID，最后通过商品ID来获取 &lt;strong&gt;mock&lt;/strong&gt; 的 &lt;strong&gt;response&lt;/strong&gt; 。还有一种就是支持传递 &lt;strong&gt;autoTest mock&lt;/strong&gt; 参数给到 &lt;strong&gt;mockUrl&lt;/strong&gt; 指定的服务，可以使用这个参数来识别当前测试上下文。&lt;/p&gt;
&lt;p&gt;一个测试 &lt;strong&gt;case&lt;/strong&gt; 可能会穿过很多微服务，这些所有的依赖服务可能都需要预设 &lt;strong&gt;mock response&lt;/strong&gt;，这基本上是一劳永逸的。&lt;/p&gt;
&lt;p&gt;所以，我们抽象出了 &lt;strong&gt;autoTest Mock Gateway（自动化测试mock网关服务）&lt;/strong&gt; ，在整个自动化测试环节还有很多需要支持的工作，服务之间的鉴权，鉴权 &lt;strong&gt;key&lt;/strong&gt; 的 &lt;strong&gt;mock&lt;/strong&gt;，加解密，加解密 &lt;strong&gt;key&lt;/strong&gt; 的 &lt;strong&gt;mock&lt;/strong&gt;，自动化测试 &lt;strong&gt;case&lt;/strong&gt; 交替并行执行等。&lt;/p&gt;
&lt;p&gt;作为工程师的我们都希望用系统化、工程化的方式来解决整体问题，而不是个别点状问题。有了这个 &lt;strong&gt;mock gateway&lt;/strong&gt; 我们可以做很多事情，也可以普惠所有需要的其他部门。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/microservice-auto/3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在一次 &lt;strong&gt;autoTest context&lt;/strong&gt; 里构造好 &lt;strong&gt;mock response&lt;/strong&gt;，然后通过 &lt;strong&gt;mock parameter&lt;/strong&gt; 来动态识别具体的来源服务进行路由、鉴权、加解密等操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MockGateway&lt;/strong&gt; 是一个支点，我相信这个支点可以撬动很多测试空间和创新能力。&lt;/p&gt;

&lt;p&gt;接下来我们将展示在 &lt;strong&gt;marketing-cloud 营销规则引擎&lt;/strong&gt; 中的初步尝试。&lt;/p&gt;
&lt;h2 id=&quot;整体逻辑架构&quot;&gt;整体逻辑架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/microservice-auto/4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自动化脚本在每跑一个 &lt;strong&gt;case&lt;/strong&gt; 的时候会创建当前 &lt;strong&gt;case&lt;/strong&gt; 对应的 &lt;strong&gt;autoTestContext&lt;/strong&gt;，这里面都是一些 &lt;strong&gt;meta data&lt;/strong&gt;，用来表示这个 &lt;strong&gt;case&lt;/strong&gt; 中所有涉及到的微服务系统哪些是需要走 &lt;strong&gt;mock gateway&lt;/strong&gt; 的。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;mockGateway&lt;/strong&gt; 中所有的配置都是有一个 &lt;strong&gt;autoTestContext&lt;/strong&gt; 所对应，如果没有 &lt;strong&gt;autoTestContext&lt;/strong&gt; 说明是所有 &lt;strong&gt;case&lt;/strong&gt; 共用。&lt;/p&gt;
&lt;h2 id=&quot;将-mock-parameter-纳入服务框架标准-request-contract&quot;&gt;将 mock parameter 纳入服务框架标准 request contract&lt;/h2&gt;
&lt;p&gt;要想打通整个微服务架构中的所有通道，就需要在标准 &lt;strong&gt;request contract&lt;/strong&gt; 定义 &lt;strong&gt;mockParameter&lt;/strong&gt; ，这是这一切的前提。&lt;/p&gt;
&lt;p&gt;服务与服务之间调用走标准微服务 &lt;strong&gt;request contract&lt;/strong&gt;，服务与外部系统的依赖可以选择走 &lt;strong&gt;HTTP Header&lt;/strong&gt;，也可以选择走标准 &lt;strong&gt;request&lt;/strong&gt; ，就要看我们的整个服务框架是否已经覆盖所有的产线及一些遗留系统的问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class BaseRequest implements Serializable {
    public MockParameter mockParameter;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;BaseRequest&lt;/strong&gt; 是所有 &lt;strong&gt;request&lt;/strong&gt; 的基类，这样才能保证所有的请求能够正常的传递。&lt;/p&gt;
&lt;h2 id=&quot;使用-aop-resteasy-httpclientrequest-spi-初步实现-mock&quot;&gt;使用 &lt;strong&gt;AOP + RestEasy HttpClientRequest SPI&lt;/strong&gt; 初步实现 Mock&lt;/h2&gt;
&lt;p&gt;整个系统的开发架构分层依赖是：&lt;strong&gt;facade-&amp;gt;biz-&amp;gt;service&lt;/strong&gt;，基本的所有核心逻辑都是在 &lt;strong&gt;service&lt;/strong&gt; 中，请求的 &lt;strong&gt;request dto&lt;/strong&gt; 最多不能越界到 &lt;strong&gt;service&lt;/strong&gt; 层，按照规范讲 &lt;strong&gt;request dto&lt;/strong&gt; 顶多滞留在 &lt;strong&gt;biz&lt;/strong&gt; 层，但是在互联网的世界中一些都是可以快速迭代的，并不是多么硬性规定，及时重构是偿还技术债务的主要方法。&lt;/p&gt;
&lt;p&gt;前面我们已经讲过，我们采用的 &lt;strong&gt;RPC&lt;/strong&gt; 框架是 &lt;strong&gt;RestEasy + RestEasy client&lt;/strong&gt; ，我们先来看下入口的地方。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
@Path(&quot;v1/calculator/&quot;)
public class RuleCalculatorFacadeImpl extends BaseFacade implements RuleCalculatorFacade {
    @MockFacade(Setting = MockFacade.SETTING_REQUEST_MOCK_PARAMETER)
    public RuleCalculateResponse ruleCalculate(RuleCalculateRequest request)  {
    ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看下 &lt;strong&gt;service&lt;/strong&gt; 对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class MarketingServiceImpl extends MarketingBaseService implements MarketingService {
    @MockFacade(Setting = MockFacade.SETTING_FACADE_MOCK_BEAN)
    public MarketingResult onlyExtendMarketingActivity(Marketing..Parameter tagsParameter) {
    ...
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们重点看下 &lt;strong&gt;@MockFacade&lt;/strong&gt; annotation 声明。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MockFacade {

    String SETTING_REQUEST_MOCK_PARAMETER = &quot;setting_request_mock_parameter&quot;;
    String SETTING_FACADE_MOCK_BEAN = &quot;setting_facade_mock_bean&quot;;

    String Setting();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个 annotation 我们的主要目的就是将 &lt;strong&gt;mockParameter&lt;/strong&gt; 放到 &lt;strong&gt;ThreadLocal&lt;/strong&gt; 中去和请求处理完时的清理工作。还有一个功能就是 &lt;strong&gt;service&lt;/strong&gt; 层的 &lt;strong&gt;mock bean&lt;/strong&gt; 处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Aspect
@Component
@Slf4j
public class MockMarketingFacadeInterceptor {

    @Before(&quot;@annotation(mockFacade)&quot;)
    public void beforeMethod(JoinPoint joinPoint, MockFacade mockFacade) {

        String settingName = mockFacade.Setting();

        if (MockFacade.SETTING_REQUEST_MOCK_PARAMETER.equals(settingName)) {

            Object[] args = joinPoint.getArgs();
            if (args == null) return;

            List&amp;lt;Object&amp;gt; argList = Arrays.asList(args);
            argList.forEach(item -&amp;gt; {

                if (item instanceof BaseRequest) {
                    BaseRequest request = (BaseRequest) item;

                    if (request.getMockParameter() != null) {
                        MarketingBaseService.mockParameterThreadLocal.set(request.getMockParameter());
                        log.info(&quot;----setting mock parameter:{}&quot;, JSON.toJSONString(request.getMockParameter()));
                    }
                }
            });
        } else if (MockFacade.SETTING_FACADE_MOCK_BEAN.equals(settingName)) {

            MarketingBaseService marketingBaseService = (MarketingBaseService) joinPoint.getThis();
            marketingBaseService.mockBean();
            log.info(&quot;----setting mock bean.&quot;);
        }
    }

    @After(&quot;@annotation(mockFacade)&quot;)
    public void afterMethod(JoinPoint joinpoint, MockFacade mockFacade) {

        if (MockFacade.SETTING_FACADE_MOCK_BEAN.equals(mockFacade.Setting())) {

            MarketingBaseService marketingBaseService = (MarketingBaseService) joinpoint.getThis();
            marketingBaseService.mockRemove();

            log.info(&quot;----remove mock bean.&quot;);
        }

        if (MockFacade.SETTING_REQUEST_MOCK_PARAMETER.equals(mockFacade.Setting())) {

            MarketingBaseService.mockParameterThreadLocal.remove();

            log.info(&quot;----remove ThreadLocal. ThreadLocal get {}&quot;, MarketingBaseService.mockParameterThreadLocal.get());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些逻辑完全基于一个约定，就是 MarketingBaseService，不具有通用型，只是在逐步的重构和提取中，最终会是一个 &lt;strong&gt;plugin&lt;/strong&gt; 框架。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class MarketingBaseService extends BaseService {

    protected ClassMarketingCentralFacade classMarketingCentralFacade;

    protected CCMarketingCentralFacade ccMarketingCentralFacade;

    public static ThreadLocal&amp;lt;MockParameter&amp;gt; mockParameterThreadLocal = new ThreadLocal&amp;lt;&amp;gt;();

    public void mockBean() {

        MockParameter mockParameter = mockParameterThreadLocal.get();

        if (mockParameter != null &amp;amp;&amp;amp; mockParameter.mockClassMarketingInterface) {
            if (mockParameter.useAutoTestingMock) {
                this.setClassMarketingCentralFacade(SpringContextHolder.getBean(&quot;ClassMarketingCentralFacadeTestMock&quot;, ClassMarketingCentralFacade.class));
            } else {
                this.setClassMarketingCentralFacade(SpringContextHolder.getBean(&quot;ClassMarketingCentralFacadeMocker&quot;, ClassMarketingCentralFacadeMocker.class));
            }
        } else {
            this.setClassMarketingCentralFacade(SpringContextHolder.getBean(&quot;ClassMarketingCentralFacade&quot;, ClassMarketingCentralFacade.class));
        }

        if (mockParameter != null &amp;amp;&amp;amp; mockParameter.mockCCMarketingInterface) {
            if (mockParameter.useAutoTestingMock) {
                this.setCcMarketingCentralFacade(SpringContextHolder.getBean(&quot;CCMarketingCentralFacadeTestMock&quot;, CCMarketingCentralFacade.class));
            } else {
                this.setCcMarketingCentralFacade(SpringContextHolder.getBean(&quot;CCMarketingCentralFacadeMocker&quot;, CCMarketingCentralFacadeMocker.class));
            }
        } else {
            this.setCcMarketingCentralFacade(SpringContextHolder.getBean(&quot;CCMarketingCentralFacade&quot;, CCMarketingCentralFacade.class));
        }
    }

    public void mockRemove() {
        mockParameterThreadLocal.remove();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以顺利的将 &lt;strong&gt;request&lt;/strong&gt; 中的 &lt;strong&gt;mockParameter&lt;/strong&gt; 放到 &lt;strong&gt;ThreadLocal&lt;/strong&gt; 中，可以动态的通过 &lt;strong&gt;AOP&lt;/strong&gt; 的方式来注入相应的 &lt;strong&gt;mockerBean&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在我们还要处理的就是对 &lt;strong&gt;mockGateway&lt;/strong&gt; 的调用将 __mockParameter_ 中的 &lt;strong&gt;autoContext&lt;/strong&gt; 中的标示字符串放到 &lt;strong&gt;HTTP Header&lt;/strong&gt; 中去。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class MockHttpHeadSetting implements ClientRequestFilter {

    @Override
    public void filter(ClientRequestContext requestContext) throws IOException {

        MultivaluedMap&amp;lt;String, Object&amp;gt; header = requestContext.getHeaders();

        MockParameter mockParameter = MarketingBaseService.mockParameterThreadLocal.get();

        if (mockParameter != null &amp;amp;&amp;amp; StringUtils.isNotBlank(mockParameter.getTestingMockParam())) {
            header.add(&quot;Mock-parameter&quot;, mockParameter.getTestingMockParam());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着在 &lt;strong&gt;SPI（javax.ws.rs.ext.Providers ）&lt;/strong&gt; 文件中配置即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;com.hujiang.marketingcloud.ruleengine.service.MockHttpHeadSetting&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在整个微服务架构的实践中，工程界一直缺少探讨的就是在微服务架构的测试这块，离我们比较近的是自动化测试，因为自动化测试基本上是所有系统都需要的。&lt;/p&gt;
&lt;p&gt;但是有一块我们一直没有重视的就是 &lt;strong&gt;全链路压力测试&lt;/strong&gt; 这块，在生产上进行全链路的真实的压力测试需要解决很多问题，比较重要的就是 &lt;strong&gt;DB&lt;/strong&gt; 这块，压测的时候产生的所有交易数据不能够参与结算、财务流程，这就需要借助 &lt;strong&gt;影子表&lt;/strong&gt; 来解决，所有的数据都不会写入最终的真实的交易数据中去。当然还有其他地方都需要解决，一旦打开全链路压测开关，应该需要处理所有产生数据的地方，这是一个庞大的工程，但是也会非常有意思。&lt;/p&gt;
&lt;p&gt;本篇文章只是我们在这块的一个初步尝试，我们会继续扩展下去，在下次产线全链路压测的时候我们就可以借助现在的实践架构扩展起来。&lt;/p&gt;
&lt;p&gt;作者：王清培 （沪江集团资深JAVA架构师）&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 06:32:00 +0000</pubDate>
<dc:creator>王清培</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangiqngpei557/p/9279984.html</dc:identifier>
</item>
<item>
<title>Docker下安装Jenkins - hackyo</title>
<link>http://www.cnblogs.com/hackyo/p/9279922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hackyo/p/9279922.html</guid>
<description>&lt;p&gt; Docker安装参见：&lt;a href=&quot;https://www.cnblogs.com/hackyo/p/9280042.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hackyo/p/9280042.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装Jenkins：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;docker run \
  &lt;/span&gt;-&lt;span&gt;u root \
  &lt;/span&gt;--&lt;span&gt;rm&lt;/span&gt;&lt;span&gt; \
  &lt;/span&gt;-&lt;span&gt;d \
  &lt;/span&gt;-p &lt;span&gt;8081&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt; \
  &lt;/span&gt;-v jenkins-data:/var/&lt;span&gt;jenkins_home \
  &lt;/span&gt;-v /var/run/docker.sock:/var/run/&lt;span&gt;docker.sock \
  jenkinsci&lt;/span&gt;/blueocean
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于这里映射了8081端口，所以安装完成后访问：http://localhost:8081&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1028599/201807/1028599-20180708151021187-294171858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，出现了密码存储的地址&lt;/p&gt;
&lt;p&gt;由于该目录是容器内目录，所以我们先查找该容器所对应的真实路径&lt;/p&gt;
&lt;p&gt;查看Jenkins容器ID：&lt;/p&gt;

&lt;p&gt;将查找出来的CONTAINER ID代入下面的命令，替换掉“b57fd47dff42”，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker inspect b57fd47dff42 | &lt;span&gt;grep&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Source&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1028599/201807/1028599-20180708151824498-190249556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一行就是容器对应的真实路径了。&lt;/p&gt;
&lt;p&gt;这时候再将路径代入查看密码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cat&lt;/span&gt; /var/lib/docker/volumes/jenkins-data/_data/secrets/initialAdminPassword
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后将查出的密码输入网页即可。&lt;/p&gt;
&lt;p&gt;之后完成设置即可使用。&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 06:06:00 +0000</pubDate>
<dc:creator>hackyo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hackyo/p/9279922.html</dc:identifier>
</item>
<item>
<title>微信小程序 canvas 绘图问题总结 - 和牛</title>
<link>http://www.cnblogs.com/heniu/p/9279895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heniu/p/9279895.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;94.696700957786&quot;&gt;
&lt;hr/&gt;
业务中碰到微信小程序需要生成海报进行朋友圈分享，这个是非常常见的功能，没想到实际操作的时候花了整整一天一夜才搞好，微信的 canvas 绘图实在是太难用了，官方快点优化一下吧。
&lt;p&gt;业务非常简单，只需要将用到的图片，文案素材拼装到一张图片，保存到本地就可以了。&lt;/p&gt;
&lt;p&gt;首先创建画布，将一张网上的图片画到画布上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; ctx = wx.createCanvasContext(&lt;span class=&quot;hljs-string&quot;&gt;'shareCanvas'&lt;/span&gt;);
ctx.drawImage(&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://img3.doubanio.com/view/photo/l/public/p2327709524.jpg&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;);
ctx.draw();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;网络图片&lt;/h3&gt;
&lt;p&gt;这时候出现一个问题：在模拟器上没有报错，可是真机测试却什么也没画出来。网上搜索一阵发现微信小程序的 canvas.drawImage 是不支持网络图片的，只支持本地图片。所以，任何的网络图片都需要先缓存到本地，再通过 drawImage 调用存储的本地资源进行绘制，缓存可以通过 wx.getImageInfo 和 wx.downloadFile 实现，这次选用了 wx.getImageInfo, wx.downloadFile 没有试过，不知道可不可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-javascript&quot;&gt;wx.getImageInfo({
  src: &lt;span class=&quot;hljs-string&quot;&gt;'https://img3.doubanio.com/view/photo/l/public/p2327709524.jpg'&lt;/span&gt;,
  success: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(res)&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(res.width)
    &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(res.path)
  }
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法可以拿到存储的本地图片地址，长宽以及一些简单的图形变化，将本地缓存的图片地址保存到全局变量或者缓存供 wx.drawImage 调用。&lt;/p&gt;
&lt;p&gt;还有一点需要注意的是 draw 方法是异步的，如果图片还没加载成功，有可能画出来的是空的，所以 draw 方法通常都会带有定时器这样的回调。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-javascript&quot;&gt;ctx.draw(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,setTimeout(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
    wx.canvasToTempFilePath({
        canvasId: &lt;span class=&quot;hljs-string&quot;&gt;'shareCanvas'&lt;/span&gt;,
        success: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(res)&lt;/span&gt;&lt;/span&gt;{
            that.data.tmpPath = res.tempFilePath
        },
    })
},&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;图片保存的授权问题&lt;/h3&gt;
&lt;p&gt;绘图后通过 1 秒的延时将画好的新图片保存到本地，然后通过 wx.saveImageToPhotosAlbum() 保存到手机相册。这一步存在授权问题，需要考虑拒绝授权后的兼容性，也就是如果用户拒接授权以后怎么办？常见的做法是先通过 wx.getSetting() 获取用户的权限设置，如果用户拒绝了访问相册的权限，可以跳转到授权设置页面要求用户更改授权信息。&lt;/p&gt;
&lt;p&gt;小程序的授权设置 api 已经弃用了，现在只能通过组件形式，将 button 的 open-type 属性设置成 openSetting，自动跳转到设置页面，总体来说没有之前方便了。如果页面本来已经有 button可以先将 open-type 属性设成 null，当遇到需要跳转的逻辑再通过 setData 设置，这样处理非常复杂，很容易出错，但是可以节省页面或者跳转；另一种处理方式是，当没有授权时先跳转到说明页面，说明需要授权的信息，在这个页面上添加一个 open-type 的button，点击以后跳转到设置页面，这次我们采用的是第一种方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/07/5b403d77b82f1.gif&quot; alt=&quot;result.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;文字编辑换行&lt;/h3&gt;
&lt;p&gt;下一步是文字编辑的问题，微信画文字是不支持自动换行的，所以只能手动计算每一行能够容纳的文字个数进行手动换行，比如一个文字加间距占 10 px，一行整体可以使用 100 px，那就是每行只能容纳 10 个字，第 11 个字另起一行开始画。&lt;/p&gt;
&lt;p&gt;将文字分割成 10 个字的数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;canvasWorkBreak&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(maxWidth, fontSize, text)&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; maxLength = maxWidth / fontSize
  &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; textLength = text.length
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; textRowArr = []
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; tmp = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {
    textRowArr.push(text.substr(tmp, maxLength))
    tmp += maxLength
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (tmp &amp;gt;= textLength) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; textRowArr
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将数组一行一行画到画布上：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; height = &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; item of [&lt;span class=&quot;hljs-string&quot;&gt;'我的舍利佛'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'搜房法拉'&lt;/span&gt;]) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (item !== &lt;span class=&quot;hljs-string&quot;&gt;'a'&lt;/span&gt;) {
        ctx.setFontSize(&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;);
        ctx.setFillStyle(&lt;span class=&quot;hljs-string&quot;&gt;&quot;#484a3d&quot;&lt;/span&gt;);
        ctx.fillText(item, &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;, height);
        height += &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;多图绘制&lt;/h3&gt;
&lt;p&gt;把每一种元素画完以后整个海报制作的流程就已经跑通了，但并不代表在实际业务中就可以使用了。首先面对的是海报生成的质量问题，假设我们的手机像素是 320 * 400 的，如果要将图片展示在手机上用于预览，只有两种选择：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;画一个分辨率小于手机分辨率的海报，让手机能完整的展示出来。但是这样的海报由于分辨率小，下载到手机相册分享用大屏手机观看的时候就非常影响体验了。这种做法的解决方案可以是画 2 张图，手机预览时隐藏大图，只显示小图；下载的时候将大图保存起来。&lt;/li&gt;
&lt;li&gt;画一张大图，直接通过 previewImage 进入手机预览模式，预览模式的图片可以直接保存到本地。这种方案的缺点在于预览模式无法设计 UI，且下载的时候不能自定义文案，由于下载保存的入口很隐蔽，用户不一定能发现。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;-&quot;&gt;图片太长怎么办？&lt;/h3&gt;
&lt;p&gt;上面的图实际上是比较长的，你可以截取一部分显示出来，这样图片看起来就会更协调。在通过正常比例绘制完图片以后，可以通过填充矩形的方式覆盖一部分图片，然后在矩形上输入其他的内容，这样图片的一部分就被隐藏起来了。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;按钮置于最上层&lt;/h3&gt;
&lt;p&gt;由于 canvas 是优先级最高的，总是会覆盖页面上的其他内容，所以「保存图片」的按钮可能会被覆盖掉而显示不出来，可以通过在 button 上套一层 cover-view 来解决。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;图片绘制本来应该是一个非常简单也非常成熟的技术，其他的框架都会有对应的组件来处理这些事情，可是微信小程序的 canvas 绘制可以用「非常难用」来形容，希望微信团队能尽快优化。&lt;/p&gt;
&lt;p&gt;你可以点击&lt;a href=&quot;https://github.com/looker53/study/blob/master/titleprogram/canvas/canvas.js&quot;&gt;「阅读原文」&lt;/a&gt;获取源码。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 08 Jul 2018 05:54:00 +0000</pubDate>
<dc:creator>和牛</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heniu/p/9279895.html</dc:identifier>
</item>
<item>
<title>数据库性能测试：sysbench用法详解 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9279703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9279703.html</guid>
<description>&lt;p&gt;sysbench是一个很不错的数据库性能测试工具。&lt;/p&gt;
&lt;p&gt;官方站点：https://github.com/akopytov/sysbench/&lt;/p&gt;
&lt;p&gt;rpm包下载：https://packagecloud.io/akopytov/sysbench/packages/el/7/sysbench-1.0.15-1.el7.centos.x86_64.rpm&lt;/p&gt;
&lt;p&gt;源码包下载：https://github.com/akopytov/sysbench/archive/1.0.15.tar.gz&lt;/p&gt;
&lt;p&gt;如果是编译安装，需要先安装好mysql的开发包(尽管编译错误时提示的是缺少Mysql库文件)。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;yum -y install mysql-community-devel

tar xf 1.0.15.tar.gz
cd sysbench-1.0.15
./autogen.sh
./configure
make -j
make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装后，只有一个二进制文件sysbench，还提供了很多个lua脚本。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@s1 ~]# rpm -ql sysbench | grep 'bin\|lua'  
/usr/bin/sysbench
/usr/share/sysbench/bulk_insert.lua
/usr/share/sysbench/oltp_common.lua
/usr/share/sysbench/oltp_delete.lua
/usr/share/sysbench/oltp_insert.lua
/usr/share/sysbench/oltp_point_select.lua
/usr/share/sysbench/oltp_read_only.lua
/usr/share/sysbench/oltp_read_write.lua
/usr/share/sysbench/oltp_update_index.lua
/usr/share/sysbench/oltp_update_non_index.lua
/usr/share/sysbench/oltp_write_only.lua
/usr/share/sysbench/select_random_points.lua
/usr/share/sysbench/select_random_ranges.lua
/usr/share/sysbench/tests/include/inspect.lua
/usr/share/sysbench/tests/include/oltp_legacy/bulk_insert.lua
/usr/share/sysbench/tests/include/oltp_legacy/common.lua
/usr/share/sysbench/tests/include/oltp_legacy/delete.lua
/usr/share/sysbench/tests/include/oltp_legacy/insert.lua
/usr/share/sysbench/tests/include/oltp_legacy/oltp.lua
/usr/share/sysbench/tests/include/oltp_legacy/oltp_simple.lua
/usr/share/sysbench/tests/include/oltp_legacy/parallel_prepare.lua
/usr/share/sysbench/tests/include/oltp_legacy/select.lua
/usr/share/sysbench/tests/include/oltp_legacy/select_random_points.lua
/usr/share/sysbench/tests/include/oltp_legacy/select_random_ranges.lua
/usr/share/sysbench/tests/include/oltp_legacy/update_index.lua
/usr/share/sysbench/tests/include/oltp_legacy/update_non_index.lua&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文介绍的是新版本sysbench oltp lua脚本的用法(&lt;code&gt;/usr/share/sysbench/*.lua&lt;/code&gt;)，所以不涉及传统的lua(&lt;code&gt;tests/include/oltp_legacy/*.lua&lt;/code&gt;)，如果想要了解这些传统Lua脚本的用法，网上随便找。&lt;/p&gt;


&lt;p&gt;以下列出了sysbench对测试mysql时常用的选项。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi ~]# sysbench --help
Usage:
  sysbench [options]... [test_lua] [lua_options] [command]

Commands implemented by most tests: prepare run cleanup help

通用选项：以下中括号中的值表示默认值
  --threads=N                     指定线程数[1]
  --events=N                      限制最大请求数，0表示不限制[0]
  --time=N                        限制最长执行时间，0表示不限制[10]
                    --events和--time二者选一即可
  --forced-shutdown=STRING        达到最长执行时间后还需等待多久关闭sysbench
                                  off表示禁用该功能[off]
  --thread-stack-size=SIZE        每个线程使用的栈空间大小[64K]
  --rate=N                        平均事务处理速率，0表示不限制[0]
  --report-interval=N             每隔几秒报告一次结果，0表示禁用间隔报告[0]
  --config-file=FILENAME          从文件中读取命令行选项
  --tx-rate=N                     已废弃，是--rate的别名[0]
  --max-requests=N                已废弃，是--events的别名[0]
  --max-time=N                    已废弃，是--time的别名[0]
  --num-threads=N                 已废弃，是--threads的别名[1]

mysql相关选项：
  --mysql-host=[LIST,...]          MySQL server host [localhost]
  --mysql-port=[LIST,...]          MySQL server port [3306]
  --mysql-socket=[LIST,...]        MySQL socket
  --mysql-user=STRING              MySQL user [sbtest]
  --mysql-password=STRING          MySQL password []
  --mysql-db=STRING                MySQL database name [sbtest]
  --mysql-ignore-errors=[LIST,...] 要忽略的错误代码，值可为&quot;all&quot; [1213,1020,1205]

Compiled-in tests:
  fileio - File I/O test
  cpu - CPU performance test
  memory - Memory functions speed test
  threads - Threads subsystem performance test
  mutex - Mutex performance test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，command部分有4类：prepare run cleanup和help：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;prepare&lt;/code&gt;：准备数据的命令。例如，在sysbench压力测试之前，需要先准备好测试库、测试表以及测试表中的数据。具体用法见后文。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;run&lt;/code&gt;：表示进行压力测试。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cleanup&lt;/code&gt;：清除测试时产生的数据。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;help&lt;/code&gt;：输出给定lua脚本的帮助信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;test_lua是想要使用的lua脚本，如果是rpm包安装的sysbench，则这些脚本都是/usr/share/sysbench目录下。对于一般的数据库测试，只需使用和oltp有关的lua脚本就足够。&lt;/p&gt;
&lt;p&gt;options和lua_options是不同的，options是sysbench的选项，lua_options是lua脚本的选项，lua_options应该要放在test_lua的后面(非必需，但建议)。&lt;/p&gt;
&lt;p&gt;例如，要查看oltp_common.lua的用法，可以：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sysbench /usr/share/sysbench/oltp_common.lua help&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;首先创建sysbench所需数据库&lt;code&gt;sbtest&lt;/code&gt;(这是sysbench默认使用的库名，必须创建测试库)。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mysqladmin -h127.0.0.1 -uroot -pP@ssword1! -P3306 create sbtest;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，准备测试所用的表，这些测试表放在测试库sbtest中。这里使用的lua脚本为&lt;code&gt;/usr/share/sysbench/oltp_common.lua&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sysbench --mysql-host=127.0.0.1 \
         --mysql-port=3306 \
         --mysql-user=root \
         --mysql-password=P@ssword1! \
         /usr/share/sysbench/oltp_common.lua \
         --tables=10 \
         --table_size=100000 \
         prepare&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;--tables=10&lt;/code&gt;表示创建10个测试表，&lt;code&gt;--table_size=100000&lt;/code&gt;表示每个表中插入10W行数据，&lt;code&gt;prepare&lt;/code&gt;表示这是准备数的过程。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;mysql&amp;gt; show tables from sbtest;
+------------------+
| Tables_in_sbtest |
+------------------+
| sbtest1          |
| sbtest10         |
| sbtest2          |
| sbtest3          |
| sbtest4          |
| sbtest5          |
| sbtest6          |
| sbtest7          |
| sbtest8          |
| sbtest9          |
+------------------+

mysql&amp;gt; select count(*) from sbtest.sbtest1;
+----------+
| count(*) |
+----------+
|   100000 |
+----------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要清除这10个表，可使用cleanup命令。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sysbench --mysql-host=127.0.0.1 \
         --mysql-port=3306 \
         --mysql-user=root \
         --mysql-password=P@ssword1! \
         /usr/share/sysbench/oltp_common.lua \
         --tables=10 \
         cleanup&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;稍微修改下之前准备数据的语句，就可以拿来测试了。&lt;/p&gt;
&lt;p&gt;需要注意的是，之前使用的lua脚本为&lt;code&gt;oltp_common.lua&lt;/code&gt;，它是一个通用脚本，是被其它lua脚本调用的，它不能直接拿来测试。&lt;/p&gt;
&lt;p&gt;所以，我这里用&lt;code&gt;oltp_read_write.lua&lt;/code&gt;脚本来做读、写测试。还有很多其它类型的测试，比如只读测试、只写测试、删除测试、大批量插入测试等等。可找到对应的lua脚本进行调用即可。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sysbench --threads=4 \
         --time=20 \
         --report-interval=5 \
         --mysql-host=127.0.0.1 \
         --mysql-port=3306 \
         --mysql-user=root \
         --mysql-password=P@ssword1! \
         /usr/share/sysbench/oltp_read_write.lua \
         --tables=10 \
         --table_size=100000 \
         run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是测试返回的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Initializing worker threads...

Threads started!


####以下是每5秒返回一次的结果，统计的指标包括：
#### 线程数、tps(每秒事务数)、qps(每秒查询数)、
#### 每秒的读/写/其它次数、延迟、每秒错误数、每秒重连次数
[ 5s ] thds: 4 tps: 130.16 qps: 2606.30 (r/w/o: 1824.51/520.66/261.13) lat (ms,95%): 104.84 err/s: 0.00 reconn/s: 0.00
[ 10s ] thds: 4 tps: 126.74 qps: 2539.17 (r/w/o: 1778.17/507.52/253.47) lat (ms,95%): 108.68 err/s: 0.00 reconn/s: 0.00
[ 15s ] thds: 4 tps: 136.54 qps: 2736.34 (r/w/o: 1915.25/548.01/273.07) lat (ms,95%): 102.97 err/s: 0.00 reconn/s: 0.00
[ 20s ] thds: 4 tps: 107.44 qps: 2148.65 (r/w/o: 1505.60/428.17/214.89) lat (ms,95%): 132.49 err/s: 0.00 reconn/s: 0.00

SQL statistics:
    queries performed:
        read:          35098   # 执行的读操作数量
        write:         10028   # 执行的写操作数量
        other:         5014    # 执行的其它操作数量
        total:         50140
    transactions:      2507   (124.29 per sec.)    # 执行事务的平均速率
    queries:           50140  (2485.82 per sec.)   # 平均每秒能执行多少次查询
    ignored errors:    0      (0.00 per sec.)
    reconnects:        0      (0.00 per sec.)

General statistics:
    total time:                  20.1694s     # 总消耗时间
    total number of events:      2507         # 总请求数量(读、写、其它)

Latency (ms):
         min:                            2.32
         avg:                           32.13
         max:                          575.78
         95th percentile:              118.92    # 采样计算的平均延迟
         sum:                        80554.96

Threads fairness:
    events (avg/stddev):           626.7500/2.49
    execution time (avg/stddev):   20.1387/0.04&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;sysbench内置了几个测试指标。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Compiled-in tests:
  fileio - File I/O test
  cpu - CPU performance test
  memory - Memory functions speed test
  threads - Threads subsystem performance test
  mutex - Mutex performance test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可直接help输出测试方法。例如，fileio测试。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@xuexi ~]# sysbench fileio help
sysbench 1.0.15 (using bundled LuaJIT 2.1.0-beta2)

fileio options:
  --file-num=N                  number of files to create [128]
  --file-block-size=N           block size to use in all IO operations [16384]
  --file-total-size=SIZE        total size of files to create [2G]
  --file-test-mode=STRING       test mode {seqwr, seqrewr, seqrd, rndrd, rndwr, rndrw}
  --file-io-mode=STRING         file operations mode {sync,async,mmap} [sync]
  --file-async-backlog=N        number of asynchronous operatons to queue per thread [128]
  --file-extra-flags=[LIST,...] list of additional flags to use to open files {sync,dsync,direct} []
  --file-fsync-freq=N           do fsync() after this number of requests (0 - don't use fsync()) [100]
  --file-fsync-all[=on|off]     do fsync() after each write operation [off]
  --file-fsync-end[=on|off]     do fsync() at the end of test [on]
  --file-fsync-mode=STRING      which method to use for synchronization {fsync, fdatasync} [fsync]
  --file-merged-requests=N      merge at most this number of IO requests if possible (0 - don't merge) [0]
  --file-rw-ratio=N             reads/writes ratio for combined test [1.5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，创建5个文件，总共1G，每个文件大概200M。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sysbench fileio --file-num=5 --file-total-size=1G prepare

[root@xuexi ~]# ls -lh test*
-rw------- 1 root root 205M Jul  8 12:15 test_file.0
-rw------- 1 root root 205M Jul  8 12:15 test_file.1
-rw------- 1 root root 205M Jul  8 12:15 test_file.2
-rw------- 1 root root 205M Jul  8 12:15 test_file.3
-rw------- 1 root root 205M Jul  8 12:15 test_file.4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，运行测试。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sysbench --events=5000 \
         --threads=16 \
         fileio \
         --file-num=5 \
         --file-total-size=1G \
         --file-test-mode=rndrw \
         --file-fsync-freq=0 \
         --file-block-size=16384 \
         run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;File operations:
    reads/s:                      98.67
    writes/s:                     66.85
    fsyncs/s:                     6.26

Throughput:     # 吞吐量
    read, MiB/s:                  1.54  # 表示读的带宽
    written, MiB/s:               1.04  # 表示读的带宽

General statistics:
    total time:                   12.7426s
    total number of events:       2117

Latency (ms):
         min:                          0.00
         avg:                         86.66
         max:                       2919.41
         95th percentile:            646.19
         sum:                     183460.80

Threads fairness:
    events (avg/stddev):          132.3125/24.19
    execution time (avg/stddev):  11.4663/1.09&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再比例cpu性能测试：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@xuexi ~]# sysbench cpu --threads=40 --events=10000 --cpu-max-prime=20000 run
sysbench 1.0.15 (using bundled LuaJIT 2.1.0-beta2)

Running the test with following options:
Number of threads: 40
Initializing random number generator from current time


Prime numbers limit: 20000

Initializing worker threads...

Threads started!

CPU speed:
    events per second:  2127.81

General statistics:
    total time:                          4.6986s
    total number of events:              10000

Latency (ms):
         min:                                    1.72
         avg:                                   18.16
         max:                                  302.17
         95th percentile:                      110.66
         sum:                               181628.49

Threads fairness:
    events (avg/stddev):           250.0000/30.81
    execution time (avg/stddev):   4.5407/0.10&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 08 Jul 2018 04:28:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9279703.html</dc:identifier>
</item>
<item>
<title>二叉搜索树的java实现 - 不懂是非</title>
<link>http://www.cnblogs.com/qm-article/p/9279655.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qm-article/p/9279655.html</guid>
<description>&lt;p&gt;&lt;span&gt; 转载请注明出处&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;二叉搜索树也成二叉排序树，它有这么一个特点，某个节点，若其有两个子节点，则一定满足，左子节点值一定小于该节点值，右子节点值一定大于该节点值，对于非基本类型的比较，可以实现Comparator接口，在本文中为了方便，采用了int类型数据进行操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  要想实现一颗二叉树，肯定得从它的增加说起，只有把树构建出来了，才能使用其他操作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;   &lt;span&gt;谈起二叉树的增加，肯定先得构建一个表示节点的类，该节点的类，有这么几个属性，节点的值，节点的父节点、左节点、右节点这四个属性，代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        Node parent;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        Node leftChild;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        Node rightChild;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Node(Node parent, Node leftChild, Node rightChild,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.leftChild =&lt;span&gt; leftChild;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.rightChild =&lt;span&gt; rightChild;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.val =&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,val);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; Node(Node node,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;(node,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,val);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       &lt;span&gt; 这里采用的是内部类的写法，构建完节点值后，再对整棵树去构建，一棵树，先得有根节点，再能延伸到余下子节点，那在这棵树里，也有一些属性，比如基本的根节点root,树中元素大小size，这两个属性，如果采用了泛型，可能还得增加Comparator属性，或提供其一个默认实现。具体代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SearchBinaryTree {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node root;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SearchBinaryTree() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    &lt;span&gt;当要进行添加元素的时候，得考虑根节点的初始化，一般情况有两种、当该类的构造函数一初始化就对根节点root进行初始化，第二种、在进行第一次添加元素的时候，对根节点进行添加。理论上两个都可以行得通，但通常采用的是第二种懒加载形式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在进行添加元素的时候，有这样几种情况需要考虑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       一、添加时判断root是否初始化，若没初始化，则初始化，将该值赋给根节点，size加一。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       二、因为二叉树搜索树满足根节点值大于左节点，小于右节点，需要将插入的值，先同根节点比较，若大，则往右子树中进行查找，若小，则往左子树中进行查找。直到某个子节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       这里的插入实现，可以采用两种，一、递归、二、迭代(即通过while循环模式)。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;  3.1、递归版本插入&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(val);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             size++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Node node =&lt;span&gt; getAdapterNode(root, val);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Node newNode = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(val);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(node.val &amp;gt;&lt;span&gt; val){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             node.leftChild =&lt;span&gt; newNode;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             newNode.parent =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(node.val &amp;lt;&lt;span&gt; val){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             node.rightChild =&lt;span&gt; newNode;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             newNode.parent =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂不做处理&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         size++;&lt;span&gt;19&lt;/span&gt;         return true;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * 获取要插入的节点的父节点，该父节点满足以下几种状态之一
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     *  1、父节点为子节点
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     *  2、插入节点值比父节点小，但父节点没有左子节点
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     *  3、插入节点值比父节点大，但父节点没有右子节点
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     *  4、插入节点值和父节点相等。
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     *  5、父节点为空
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     *  如果满足以上5种情况之一，则递归停止。
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; val
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Node getAdapterNode(Node node,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(node == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 往左子树中插入，但没左子树，则返回&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(node.val &amp;gt; val &amp;amp;&amp;amp; node.leftChild == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 往右子树中插入，但没右子树，也返回&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(node.val &amp;lt; val &amp;amp;&amp;amp; node.rightChild == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该节点是叶子节点，则返回&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(node.leftChild == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; node.rightChild == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(node.val &amp;gt; val &amp;amp;&amp;amp; node.leftChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getAdaptarNode(node.leftChild, val);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(node.val &amp;lt; val &amp;amp;&amp;amp; node.rightChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getAdaptarNode(node.rightChild, val);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   &lt;span&gt;使用递归，先找到递归的结束点，再去把整个问题化为子问题，在上述代码里，逻辑大致是这样的，先判断根节点有没有初始化，没初始化则初始化，完成后返回，之后通过一个函数去获取适配的节点。&lt;/span&gt;&lt;span&gt;之后进行插入值。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.2、迭代版本&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; put(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; putVal(root,val);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; putVal(Node node,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(node == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化根节点&lt;/span&gt;
            node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(val);
            root &lt;/span&gt;=&lt;span&gt; node;
            size&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        Node temp &lt;/span&gt;=&lt;span&gt; node;
        Node p;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 通过do while循环迭代获取最佳节点，
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;do&lt;/span&gt;&lt;span&gt;{ 
            p &lt;/span&gt;=&lt;span&gt; temp;
            t &lt;/span&gt;= temp.val-&lt;span&gt;val;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t &amp;gt; 0&lt;span&gt;){
                temp &lt;/span&gt;=&lt;span&gt; temp.leftChild;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(t &amp;lt; 0&lt;span&gt;){
                temp &lt;/span&gt;=&lt;span&gt; temp.rightChild;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                temp.val &lt;/span&gt;=&lt;span&gt; val;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(temp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Node newNode &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(p, val);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t &amp;gt; 0&lt;span&gt;){
            p.leftChild &lt;/span&gt;=&lt;span&gt; newNode;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(t &amp;lt; 0&lt;span&gt;){
            p.rightChild &lt;/span&gt;=&lt;span&gt; newNode;
        }
        size&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;原理其实和递归一样，都是获取最佳节点，在该节点上进行操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;论起性能，肯定迭代版本最佳，所以一般情况下，都是选择迭代版本进行操作数据。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;  可以说在二叉搜索树的操作中，删除是最复杂的，要考虑的情况也相对多，在常规思路中，删除二叉搜索树的某一个节点，肯定会想到以下四种情况,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/900767/201807/900767-20180708112515976-1583219796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt; 1、要删除的节点没有左右子节点，如上图的D、E、G节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2、要删除的节点只有左子节点，如B节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   3、要删除的节点只有右子节点，如F节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   4、要删除的节点既有左子节点，又有右子节点，如 A、C节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于前面三种情况，可以说是比较简单，第四种复杂了。下面先来分析第一种&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 若是这种情况，比如 删除D节点，则可以将B节点的左子节点设置为null，若删除G节点，则可将F节点的右子节点设置为null。具体要设置哪一边，看删除的节点位于哪一边。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二种，删除B节点，则只需将A节点的左节点设置成D节点，将D节点的父节点设置成A即可。具体设置哪一边，也是看删除的节点位于父节点的哪一边。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三种，同第二种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四种，也就是之前说的有点复杂，比如要删除C节点，将F节点的父节点设置成A节点，F节点左节点设置成E节点，将A的右节点设置成F，E的父节点设置F节点(也就是将F节点替换C节点)，还有一种，直接将E节点替换C节点。那采用哪一种呢，如果删除节点为根节点，又该怎么删除？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 对于第四种情况，可以这样想，找到C或者A节点的后继节点，删除后继节点，且将后继节点的值设置为C或A节点的值。先来补充下后继节点的概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个节点在整棵树中的后继节点必满足，大于该节点值得所有节点集合中值最小的那个节点，即为后继节点，当然，也有可能不存在后继节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是对于第四种情况，后继节点一定存在，且一定在其右子树中，而且还满足，只有一个子节点或者没有子节点两者情况之一。具体原因可以这样想，因为后继节点要比C节点大，又因为C节点左右子节一定存在，所以一定存在右子树中的左子节点中。就比如C的后继节点是F，A的后继节点是E。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了以上分析，那么实现也比较简单了，代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Node node =&lt;span&gt; getNode(val);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(node == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Node parent =&lt;span&gt; node.parent;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Node leftChild =&lt;span&gt; node.leftChild;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Node rightChild =&lt;span&gt; node.rightChild;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下所有父节点为空的情况，则表明删除的节点是根节点&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(leftChild == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; rightChild == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有子节点&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(parent.leftChild ==&lt;span&gt; node){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     parent.leftChild = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(parent.rightChild ==&lt;span&gt; node){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     parent.rightChild = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不存在父节点，则表明删除节点为根节点&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             node = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(leftChild == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; rightChild != &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有右节点&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(parent != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; parent.val &amp;gt; val){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存在父节点，且node位置为父节点的左边&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 parent.leftChild =&lt;span&gt; rightChild;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(parent != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; parent.val &amp;lt; val){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存在父节点，且node位置为父节点的右边&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                 parent.rightChild =&lt;span&gt; rightChild;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 root =&lt;span&gt; rightChild;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             node = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(leftChild != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; rightChild == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有左节点&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(parent != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; parent.val &amp;gt; val){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存在父节点，且node位置为父节点的左边&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                 parent.leftChild =&lt;span&gt; leftChild;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(parent != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; parent.val &amp;lt; val){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存在父节点，且node位置为父节点的右边&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                 parent.rightChild =&lt;span&gt; leftChild;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 root =&lt;span&gt; leftChild;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(leftChild != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; rightChild != &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 两个子节点都存在&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             Node successor = getSuccessor(node);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这种情况，一定存在后继节点&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; successor.val;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; delete =&lt;span&gt; delete(temp);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(delete){
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 node.val =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             successor = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;     * 找到node节点的后继节点
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;     * 1、先判断该节点有没有右子树，如果有，则从右节点的左子树中寻找后继节点，没有则进行下一步
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;     * 2、查找该节点的父节点，若该父节点的右节点等于该节点，则继续寻找父节点，
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;     *   直至父节点为Null或找到不等于该节点的右节点。
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;     * 理由，后继节点一定比该节点大，若存在右子树，则后继节点一定存在右子树中，这是第一步的理由
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;     *      若不存在右子树，则也可能存在该节点的某个祖父节点(即该节点的父节点，或更上层父节点)的右子树中，
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;     *      对其迭代查找，若有，则返回该节点，没有则返回null
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node getSuccessor(Node node){
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(node.rightChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             Node rightChild =&lt;span&gt; node.rightChild;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(rightChild.leftChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 rightChild =&lt;span&gt; rightChild.leftChild;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rightChild;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         Node parent =&lt;span&gt; node.parent;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(parent != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (node ==&lt;span&gt; parent.rightChild)){
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             node =&lt;span&gt; parent;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;             parent =&lt;span&gt; parent.parent;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; parent;
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;具体逻辑，看上面分析，这里不作文字叙述了，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了这种实现，在算法导论书中，提供了另外一种实现。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Node node =&lt;span&gt; getNode(val);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(node == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(node.leftChild == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;// &lt;/span&gt;&lt;span&gt;1、左节点不存在，右节点可能存在，包含两种情况  ，两个节点都不存在和只存在右节点&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            transplant(node, node.rightChild);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(node.rightChild == &lt;span&gt;null&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、左孩子存在，右节点不存在&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            transplant(node, node.leftChild);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;// &lt;/span&gt;&lt;span&gt;3、两个节点都存在&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             Node successor = getSuccessor(node);&lt;span&gt;// &lt;/span&gt;&lt;span&gt;得到node后继节点 &lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(successor.parent != node){&lt;span&gt;// &lt;/span&gt;&lt;span&gt;后继节点存在node的右子树中。&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 transplant(successor, successor.rightChild);&lt;span&gt;// &lt;/span&gt;&lt;span&gt;用后继节点的右子节点替换该后继节点&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 successor.rightChild = node.rightChild;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;将node节点的右子树赋给后继节点的右节点，即类似后继与node节点调换位置&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 successor.rightChild.parent = successor;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;接着上一步  给接过来的右节点的父引用复制&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            transplant(node, successor);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             successor.leftChild =&lt;span&gt; node.leftChild;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             successor.leftChild.parent =&lt;span&gt; successor;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * 将child节点替换node节点
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; root    根节点
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; node    要删除的节点
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; child   node节点的子节点
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; transplant(Node node,Node child){
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;         * 1、先判断 node是否存在父节点
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;         *    1、不存在，则child替换为根节点
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;         *    2、存在，则继续下一步
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;         * 2、判断node节点是父节点的那个孩子(即判断出 node是右节点还是左节点)，
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;         *    得出结果后，将child节点替换node节点 ，即若node节点是左节点 则child替换后 也为左节点，否则为右节点
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;         * 3、将node节点的父节点置为child节点的父节点
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(node.parent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.root =&lt;span&gt; child;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(node.parent.leftChild ==&lt;span&gt; node){
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             node.parent.leftChild =&lt;span&gt; child;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(node.parent.rightChild ==&lt;span&gt; node){
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             node.parent.rightChild =&lt;span&gt; child;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(child != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             child.parent =&lt;span&gt; node.parent;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;  &lt;span&gt;查找也比较简单，其实在增加的时候，已经实现了。实际情况中，这部分可以抽出来单独方法。代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; Node getNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Node temp =&lt;span&gt; root;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             t = temp.val-&lt;span&gt;val;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(t &amp;gt; 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 temp =&lt;span&gt; temp.leftChild;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(t &amp;lt; 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 temp =&lt;span&gt; temp.rightChild;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         }&lt;span&gt;while&lt;/span&gt;(temp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;  &lt;span&gt;在了解二叉搜索树的性质后，很清楚的知道，它的中序遍历是从小到大依次排列的，这里提供中序遍历代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        print(root);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print(Node root){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(root != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            print(root.leftChild);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             System.out.println(root.val);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 位置在中间，则中序，若在前面，则为先序，否则为后续&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            print(root.rightChild);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;-------------------------------------------------------------------------------------------------------华丽分割线----------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 以上都是个人见解，若有错误或不足之处，还望指正！！！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 04:05:00 +0000</pubDate>
<dc:creator>不懂是非</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qm-article/p/9279655.html</dc:identifier>
</item>
<item>
<title>同一域环境下SQLServer DB Failover故障转移配置详解 - dotnetgeek</title>
<link>http://www.cnblogs.com/waynechan/p/9279433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/waynechan/p/9279433.html</guid>
<description>&lt;p&gt;前 言：&lt;/p&gt;
&lt;p&gt; 　  很多情况下，虽然我们的站点、APIService、Redis等已经做成了分布式架构，但是SQLServer依然还是单体结构，当出现网络异常、服务器宕机时便存在极大的风险，这时候我们需要一种SQLServer故障转移技术，当A数据库服务器出现故障的时候，能迅速将请求转移到B数据库服务器上面去，从而保证系统的高可用。 &lt;/p&gt;

&lt;p&gt;一、准备工作&lt;/p&gt;

&lt;p&gt;1、准备一个域账号&lt;/p&gt;
&lt;p&gt;2、准备三台机器，均在同一域环境中，都安装上SQLServer2008实例，最终搭建出来的架构如下图所示&lt;/p&gt;

&lt;div readability=&quot;14.5&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708100127055-1851579354.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;二、基本配置步骤&lt;/p&gt;

&lt;p&gt;1、在服务中列表中找到SQL Server ，属性-&amp;gt;登录-&amp;gt; 选择“此账号”，浏览输入域账号配置该服务的登录账户。&lt;/p&gt;
&lt;div readability=&quot;20.5&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708100452343-564593604.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;2、在SQLServer-&amp;gt;Security-&amp;gt;Logins，将域账号设为sql的登录账户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708100608319-82375920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、点击 &quot;Facets&quot;，启动 “外围应用配置器”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708100648799-1657062371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、将RemoteDacEnabled设为true&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708100724733-1094692624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注：在镜像服务器、见证服务器也同样执行以上步骤&lt;/p&gt;


&lt;p&gt;三、主服务器备份数据库到镜像服务器&lt;/p&gt;

&lt;p&gt;在主服务器对数据库进行备份前，需要对数据库进行设置，将恢复模式设置为“完整”，备份好之后，在镜像服务器中进行还原数据库操作。&lt;/p&gt;
&lt;div readability=&quot;25&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708100755510-1579322629.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;四、主服务器、见证者、镜像服务器配置&lt;/p&gt;

&lt;p&gt;接下来要配置主服务器、见证者、镜像服务器三者之间的角色关系，&lt;span&gt;需要使用那个域账号登录操作系统进行操作。&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708100913040-263368373.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;点击Configure Security 开始配置向导&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708101149810-1165516793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 向导询问：是否包含见证服务器，这里我们选择Yes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708101230919-1053094123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要包含以下安装实例：主服务器实例、镜像服务器实例、见证服务器实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708101309038-1962587003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击Next，接下来确认主服务器信息，主服务器就是本机，因为不能修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708101358402-2044338121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Next 下一步选择镜像服务器，点击Connect会弹出镜像服务器SQLServer登录框，使用准备好的域账号进行登录即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708101500091-247303857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同理操作，选择见证服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708104304875-1268618435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;配置完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708101636333-1939678923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Principal：主服务器&lt;/p&gt;
&lt;p&gt;Mirror：   镜像服务器&lt;/p&gt;
&lt;p&gt;Witness：见证服务器&lt;/p&gt;
&lt;p&gt;点击Star Mirroring 开始镜像工作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708102555107-1875667386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从数据库列表可以看到，现在这台电脑已经是主服务器的状态了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708102411805-1266883404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如何测试故障转移：&lt;/p&gt;
&lt;p&gt;1、数据库-&amp;gt;Tasks-&amp;gt;Mirror ，点击FailOver能让当前主服务器变成故障状态，主服务器数据库状态就变成了Mirror镜像，镜像服务器就变成了 Principal主服务器；&lt;/p&gt;
&lt;p&gt;2、拔网线，拔掉主服务器的网线，见证服务器监测到之后，自动将镜像数据库服务器升级为主服务器。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708102843256-1219506711.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/257851/201807/257851-20180708102904982-1038042363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 08 Jul 2018 02:55:00 +0000</pubDate>
<dc:creator>dotnetgeek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/waynechan/p/9279433.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务之基于Ocelot+IdentityServer实现统一验证与授权 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/integration_authentication-authorization_service_foundation.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/integration_authentication-authorization_service_foundation.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;Tip:&lt;/strong&gt; &lt;/em&gt;此篇已加入&lt;a title=&quot;find more ?&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index.html&quot; target=&quot;_blank&quot;&gt;.NET Core微服务基础系列文章索引&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180707233626474-935369616.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里，假设我们有两个客户端（一个Web网站，一个移动App），他们要使用系统，需要先向IdentityService进行Login以进行验证并获取Token，在IdentityService的验证过程中会访问数据库以验证。然后再带上Token通过API网关去访问具体的API Service。这里我们的IdentityService基于IdentityServer4开发，它具有统一登录验证和授权的功能。当然，我们也可以将统一登录验证独立出来，写成一个单独的API Service，托管在API网关中，这里我不想太麻烦，便直接将其也写在了IdentityService中。&lt;/p&gt;

&lt;p&gt;　　这里主要基于前两篇已经搭好的API Gateway进行改写，如不熟悉，可以先浏览前两篇文章：&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/api_gateway_ocelot_foundation_01.html&quot; target=&quot;_blank&quot;&gt;Part 1&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/api_gateway_ocelot_foundation_02.html&quot; target=&quot;_blank&quot;&gt;Part 2&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;2.1 配置文件的改动&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  ......  
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthenticationOptions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthenticationProviderKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClientServiceKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowedScopes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: []
  }
  ......  
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthenticationOptions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthenticationProviderKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProductServiceKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowedScopes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: []
  }
  ......  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面分别为两个示例API Service增加Authentication的选项，为其设置ProviderKey。下面会对不同的路由规则设置的ProviderKey设置具体的验证方式。&lt;/p&gt;
&lt;h2&gt;2.2 改写StartUp类&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IdentityServer&lt;/span&gt;
        &lt;span&gt;#region&lt;/span&gt; IdentityServerAuthenticationOptions =&amp;gt; need to refactor&lt;span&gt;
        Action&lt;/span&gt;&amp;lt;IdentityServerAuthenticationOptions&amp;gt; isaOptClient = option =&amp;gt;&lt;span&gt;
            {
                option.Authority &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService:Uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                option.ApiName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                option.RequireHttpsMetadata &lt;/span&gt;= Convert.ToBoolean(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService:UseHttps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
                option.SupportedTokens &lt;/span&gt;=&lt;span&gt; SupportedTokens.Both;
                option.ApiSecret &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService:ApiSecrets:clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            };

        Action&lt;/span&gt;&amp;lt;IdentityServerAuthenticationOptions&amp;gt; isaOptProduct = option =&amp;gt;&lt;span&gt;
        {
            option.Authority &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService:Uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            option.ApiName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            option.RequireHttpsMetadata &lt;/span&gt;= Convert.ToBoolean(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService:UseHttps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
            option.SupportedTokens &lt;/span&gt;=&lt;span&gt; SupportedTokens.Both;
            option.ApiSecret &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService:ApiSecrets:productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
        }; 
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;

        services.AddAuthentication()
            .AddIdentityServerAuthentication(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClientServiceKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, isaOptClient)
            .AddIdentityServerAuthentication(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProductServiceKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, isaOptProduct);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ocelot&lt;/span&gt;
&lt;span&gt;        services.AddOcelot(Configuration);
        ......       
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的ApiName主要对应于IdentityService中的ApiResource中定义的ApiName。这里用到的配置文件定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bb8f13dc-81fa-4e1e-a778-e62ffeef7782')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_bb8f13dc-81fa-4e1e-a778-e62ffeef7782&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bb8f13dc-81fa-4e1e-a778-e62ffeef7782&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bb8f13dc-81fa-4e1e-a778-e62ffeef7782',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bb8f13dc-81fa-4e1e-a778-e62ffeef7782&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UseHttps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApiSecrets&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　这里的定义方式，我暂时还没想好怎么重构，不过肯定是需要重构的，不然这样一个一个写比较繁琐，且不利于配置。&lt;/p&gt;

&lt;p&gt;这里我们会基于之前基于IdentityServer的两篇文章，新增一个IdentityService，不熟悉的朋友可以先浏览一下&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_01.html&quot; target=&quot;_blank&quot;&gt;Part 1&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_02.html&quot; target=&quot;_blank&quot;&gt;Part 2&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;3.1 准备工作&lt;/h2&gt;
&lt;p&gt;　　新建一个ASP.NET Core Web API项目，绑定端口5100，NuGet安装IdentityServer4。配置好证书，并设置其为“较新则复制”，以便能够在生成目录中读取到。&lt;/p&gt;
&lt;h2&gt;3.2 定义一个InMemoryConfiguration用于测试&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; One In-Memory Configuration for IdentityServer =&amp;gt; Just for Demo Use
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InMemoryConfiguration
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Define which APIs will use this IdentityServer
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;ApiResource&amp;gt;&lt;span&gt; GetApiResources()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Client Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Product Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS Agent Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            };
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Define which Apps will use thie IdentityServer
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt;&lt;span&gt; GetClients()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.sg.web.nb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS NB System MPA Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;websecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPassword,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.sg.mobile.nb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS NB System Mobile App Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mobilesecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPassword,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.sg.spa.nb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS NB System SPA Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientSecrets &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spasecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256()) },
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPassword,
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; [] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile }
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.sg.mvc.nb.implicit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CAS NB System MVC App Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.Implicit,
                    RedirectUris &lt;/span&gt;= { Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Clients:MvcClient:RedirectUri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] },
                    PostLogoutRedirectUris &lt;/span&gt;= { Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Clients:MvcClient:PostLogoutRedirectUri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] },
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; [] {
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agentservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;productservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    },
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;AccessTokenLifetime = 3600, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; one hour&lt;/span&gt;
                    AllowAccessTokensViaBrowser = &lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; can return access_token to this client&lt;/span&gt;
&lt;span&gt;                }
            };
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Define which IdentityResources will use this IdentityServer
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;IdentityResource&amp;gt;&lt;span&gt; GetIdentityResources()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;IdentityResource&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.OpenId(),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.Profile(),
            };
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里使用了上一篇的内容，不再解释。实际环境中，则应该考虑从NoSQL或数据库中读取。&lt;/p&gt;
&lt;h2&gt;3.3 定义一个ResourceOwnerPasswordValidator&lt;/h2&gt;
&lt;p&gt;　　在IdentityServer中，要实现自定义的验证用户名和密码，需要实现一个接口：IResourceOwnerPasswordValidator&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ILoginUserService loginUserService;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResourceOwnerPasswordValidator(ILoginUserService _loginUserService)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loginUserService =&lt;span&gt; _loginUserService;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
        {
            LoginUser loginUser &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; isAuthenticated = loginUserService.Authenticate(context.UserName, context.Password, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; loginUser);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isAuthenticated)
            {
                context.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; GrantValidationResult(TokenRequestErrors.InvalidGrant, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid client credential&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                context.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GrantValidationResult(
                    subject : context.UserName,
                    authenticationMethod : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;custom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    claims : &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim[] {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, context.UserName),
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, loginUser.Id.ToString()),
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RealName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, loginUser.RealName),
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, loginUser.Email)
                    }
                );
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的ValidateAsync方法中（你也可以把它写成异步的方式，这里使用的是同步的方式），会调用EF去访问数据库进行验证，数据库的定义如下（密码应该做加密，这里只做demo，没用弄）：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180707235654934-1087905540.png&quot; alt=&quot;&quot; width=&quot;501&quot; height=&quot;116&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至于EF部分，则是一个典型的简单的Service调用Repository的逻辑，下面只贴Repository部分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7eef021f-b63a-4851-8fdb-3e74b020350d')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_7eef021f-b63a-4851-8fdb-3e74b020350d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7eef021f-b63a-4851-8fdb-3e74b020350d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7eef021f-b63a-4851-8fdb-3e74b020350d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7eef021f-b63a-4851-8fdb-3e74b020350d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoginUserRepository : RepositoryBase&amp;lt;LoginUser, IdentityDbContext&amp;gt;&lt;span&gt;, ILoginUserRepository
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LoginUserRepository(IdentityDbContext dbContext) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(dbContext)
        {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LoginUser Authenticate(&lt;span&gt;string&lt;/span&gt; _userName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _userPassword)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; entity = DbContext.LoginUsers.FirstOrDefault(p =&amp;gt; p.UserName == _userName &amp;amp;&amp;amp;&lt;span&gt;
                p.Password &lt;/span&gt;==&lt;span&gt; _userPassword);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; entity;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　其他具体逻辑请参考示例代码。&lt;/p&gt;
&lt;h2&gt;3.4 改写StarUp类&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IoC - DbContext&lt;/span&gt;
        services.AddDbContextPool&amp;lt;IdentityDbContext&amp;gt;&lt;span&gt;(
            options &lt;/span&gt;=&amp;gt; options.UseSqlServer(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DB:Dev&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IoC - Service &amp;amp; Repository&lt;/span&gt;
        services.AddScoped&amp;lt;ILoginUserService, LoginUserService&amp;gt;&lt;span&gt;();
        services.AddScoped&lt;/span&gt;&amp;lt;ILoginUserRepository, LoginUserRepository&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IdentityServer4&lt;/span&gt;
        &lt;span&gt;string&lt;/span&gt; basePath =&lt;span&gt; PlatformServices.Default.Application.ApplicationBasePath;
        InMemoryConfiguration.Configuration &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Configuration;
        services.AddIdentityServer()
            .AddSigningCredential(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; X509Certificate2(Path.Combine(basePath,
                Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Certificates:CerPath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]),
                Configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Certificates:Password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.AddTestUsers(InMemoryConfiguration.GetTestUsers().ToList())&lt;/span&gt;
&lt;span&gt;            .AddInMemoryIdentityResources(InMemoryConfiguration.GetIdentityResources())
            .AddInMemoryApiResources(InMemoryConfiguration.GetApiResources())
            .AddInMemoryClients(InMemoryConfiguration.GetClients())
            &lt;span&gt;&lt;strong&gt;.AddResourceOwnerValidator&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;ResourceOwnerPasswordValidator&amp;gt;&lt;span&gt;()
            .AddProfileService&lt;/span&gt;&amp;lt;ProfileService&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;();&lt;/strong&gt;&lt;/span&gt;
        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里高亮的是新增的部分，为了实现自定义验证。关于ProfileService的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bb40ffc2-fdb0-42c4-88a5-9525de3aad00')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_bb40ffc2-fdb0-42c4-88a5-9525de3aad00&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bb40ffc2-fdb0-42c4-88a5-9525de3aad00&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bb40ffc2-fdb0-42c4-88a5-9525de3aad00',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bb40ffc2-fdb0-42c4-88a5-9525de3aad00&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProfileService : IProfileService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task GetProfileDataAsync(ProfileDataRequestContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claims =&lt;span&gt; context.Subject.Claims.ToList();
            context.IssuedClaims &lt;/span&gt;=&lt;span&gt; claims.ToList();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task IsActiveAsync(IsActiveContext context)
        {
            context.IsActive &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.5 新增统一Login入口&lt;/h2&gt;
&lt;p&gt;　　这里新增一个LoginController:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    [Produces(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/Login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoginController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IConfiguration configuration;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoginController(IConfiguration _configuration)
        {
            configuration &lt;/span&gt;=&lt;span&gt; _configuration;
        }

        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt;&lt;span&gt; RequestToken([FromBody]LoginRequestParam model)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; dict = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
            dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; model.ClientId;
            dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client_secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = configuration[$&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityClients:{model.ClientId}:ClientSecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grant_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = configuration[$&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityClients:{model.ClientId}:GrantType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; model.UserName;
            dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; model.Password;

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (HttpClient http = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; content = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormUrlEncodedContent(dict))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; msg = &lt;span&gt;await&lt;/span&gt; http.PostAsync(configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService:TokenUri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;], content);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;msg.IsSuccessStatusCode)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StatusCode(Convert.ToInt32(msg.StatusCode));
                }

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; msg.Content.ReadAsStringAsync();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Content(result, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里假设客户端会传递用户名，密码以及客户端ID(ClientId，比如上面InMemoryConfiguration中的cas.sg.web.nb或cas.sg.mobile.nb)。然后构造参数再调用connect/token接口进行身份验证和获取token。这里将client_secret等机密信息封装到了服务器端，无须客户端传递（对于机密信息一般也不会让客户端知道）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityClients&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.sg.web.nb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClientSecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;websecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GrantType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cas.sg.mobile.nb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClientSecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mobilesecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GrantType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4.1 ClientService&lt;/h2&gt;
&lt;p&gt;　　（1）安装IdentityServer4.AccessTokenValidation&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;NuGet&amp;gt;Install-Package IdentityServer4.AccessTokenValidation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　（2）改写StartUp类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IServiceProvider ConfigureServices(IServiceCollection services)
    {
        ......

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IdentityServer&lt;/span&gt;
        services.AddAuthentication(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService:DefaultScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
            .AddIdentityServerAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                options.Authority &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService:Uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                options.RequireHttpsMetadata &lt;/span&gt;= Convert.ToBoolean(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService:UseHttps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
            });

        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里配置文件的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IdentityService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UseHttps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApiSecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientsecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.2 ProductService&lt;/h2&gt;
&lt;p&gt;　　与ClientService一致，请参考示例代码。&lt;/p&gt;

&lt;h2&gt;5.1 测试Client: cas.sg.web.nb&lt;/h2&gt;
&lt;p&gt;　　（1）统一验证&amp;amp;获取token&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180708001314234-1577085890.png&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）访问clientservice （by API网关）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180708001548116-1086239793.png&quot; alt=&quot;&quot; width=&quot;582&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）访问productservice（by API网关）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180708001601126-1194160489.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5.2 测试Client: cas.sg.mobile.nb&lt;/h2&gt;
&lt;p&gt;　　由于在IdentityService中我们定义了一个mobile的客户端，但是其访问权限只有productservice，所以我们来测试一下：&lt;/p&gt;
&lt;p&gt;　　（1）统一验证&amp;amp;获取token&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180708001804069-941019279.png&quot; alt=&quot;&quot; width=&quot;564&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）访问ProductService（by API网关）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180708001936694-1387965290.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）访问ClientService（by API网关） =&amp;gt; &lt;span&gt;401 Unauthorized&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180708001952367-416070339.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本篇主要基于前面Ocelot和IdentityServer的文章的基础之上，将Ocelot和IdentityServer进行结合，通过建立IdentityService进行统一的身份验证和授权，最后演示了一个案例以说明如何实现。不过，本篇实现的Demo还存在诸多不足，比如需要重构的代码较多如网关中各个Api的验证选项的注册，没有对各个请求做用户角色和权限的验证等等，相信随着研究和深入的深入，这些都可以逐步解决。后续会探索一下数据一致性的基本知识以及框架使用，到时再做一些分享。&lt;/p&gt;

&lt;p&gt;　　Click Here =&amp;gt; &lt;a href=&quot;https://github.com/EdisonChou/EDC.IntegratedIdentityService.Demo&quot; target=&quot;_blank&quot;&gt;点我进入GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　杨中科，《&lt;a title=&quot;pdf&quot; href=&quot;https://pan.baidu.com/s/18AzEKGG2pGJplaiwHHDMXw&quot; target=&quot;_blank&quot;&gt;.NET Core微服务介绍课程&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180630115826129-548700250.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 08 Jul 2018 02:28:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/integration_authentication-authorization_service_foundation.html</dc:identifier>
</item>
<item>
<title>第二节. SignalR开篇以及如何指定传输协议 - Yaopengfei</title>
<link>http://www.cnblogs.com/yaopengfei/p/9276234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaopengfei/p/9276234.html</guid>
<description>&lt;p&gt;&lt;span&gt;一. 声明&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该节主要介绍SignalR的一些理论知识，代码量很小，在后续章节编写中，会不断回来更新该节，完善该节的介绍；待该系列结束时，该节会和目录章节合并。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面的理论介绍相对枯燥，但对于后面的理解有一定意义，不感兴趣的朋友可以右上角离开了，从下一节开始，正式开始撸代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt; 原计划三天更新一篇，结果周五下班前忘记提交代码了，加上周六公司组织活动，该系列推迟一天，今天大清早跑到公司，务必也要写完这一节，这里分享一下昨天公司组织活动拍摄的照片。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180708084341291-2086835510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;上面废话说多了，下面进入正题。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二. SignalR简介&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;SignalR是微软的一个开源项目，为客户端和服务器端实时通讯的问题提供了很好的解决方案，通过简单的配置和API调用，即可完成相应的通讯功能的开发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　(PS：截止目前【2018-07-08】最新版本为 2.3.0，GitHub地址为：https://github.com/SignalR/SignalR)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   前面一节提到已经有了WebSocket，那么为什么还要SignalR呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先WebSocket兼容性存在问题，针对这一点，SignalR对目前为止几类主流的传输协议进行了封装，让浏览器自行选择可以兼容的版本（当然也可以自行指定），这样就解决了开发者使用WebSocket时候的痛点了。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;SignalR大一统：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;span&gt;它封装了 WebSocket、ForeverFrame、ServerSentEvents、LongPolling四种主要的传输协议。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　① WebSocket：它是HTML5提供的一种在单个 TCP 连接上进行全双工通讯的协议。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　② ForeverFrame&lt;/span&gt;&lt;span&gt;&lt;span&gt;(永久帧)&lt;/span&gt;&lt;span&gt;：它适用于IE浏览器，是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长链接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　③ SeverSentEvents（服务器发送事件，也成EventSourse）：顾名思义。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　④ longPolling(Ajax长轮询)：长轮询是对轮询的改进，客户端通过请求连接到服务器，并保持一段时间的连接状态，直到消息更新或超时才返回Response并中止连接，可以有效减少无效请求的次数。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 　　&lt;strong&gt;&lt;span&gt;如何指定传输协议：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　(1). 默认选择：conn.start().done(function () {});&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　(2). 手动指定：&lt;/span&gt;&lt;/span&gt;conn.start({ transport: 'serverSentEvents' }).done(function () {});&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;span&gt;注. 可选参数有：webSockets、foreverFrame、serverSentEvents、longPolling&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;&lt;span&gt;(3). 手动指定多个，如果不兼容，依次向后选择：&lt;/span&gt;conn.start({ transport: ['foreverFrame','webSockets'] }).done(function () {});&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这里简单分享一下我这里使用的代码，不介绍了后面章节有详细的介绍。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;前端代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3937a3aa-8732-443f-bb1f-caca962028cb')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_3937a3aa-8732-443f-bb1f-caca962028cb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3937a3aa-8732-443f-bb1f-caca962028cb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3937a3aa-8732-443f-bb1f-caca962028cb',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3937a3aa-8732-443f-bb1f-caca962028cb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    Layout = null;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/Scripts/jquery-3.3.1.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/Scripts/jquery.signalR-2.3.0.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; conn &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $.connection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/myPreConnection1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启日志&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            conn.logging &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 默认的形式选择&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            conn.start().done(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 手动指定通讯方式&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;webSockets、foreverFrame、serverSentEvents、longPolling&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;conn.start({ transport: 'serverSentEvents' }).done(function () {&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;});&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3. 手动指定多个通讯方式，按顺序选择(第一个不支持的话，依次往后类推)&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;conn.start({ transport: ['foreverFrame','webSockets'] }).done(function () {&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;});&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;OWIN Startup Class：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d2a560da-31f0-43ee-a3b4-0ccae7f0cef1')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d2a560da-31f0-43ee-a3b4-0ccae7f0cef1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d2a560da-31f0-43ee-a3b4-0ccae7f0cef1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d2a560da-31f0-43ee-a3b4-0ccae7f0cef1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d2a560da-31f0-43ee-a3b4-0ccae7f0cef1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Owin;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Owin;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; [assembly: OwinStartup(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(SignalRDemo.Startup))]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SignalRDemo
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configuration(IAppBuilder app)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有关如何配置应用程序的详细信息，请访问 &lt;/span&gt;&lt;span&gt;https://go.microsoft.com/fwlink/?LinkID=316888&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;             app.MapSignalR&amp;lt;MyPresitentConnection1&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/myPreConnection1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;永久连接模型类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('14aa2f2d-311c-4c5d-99c6-74b44573f521')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_14aa2f2d-311c-4c5d-99c6-74b44573f521&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_14aa2f2d-311c-4c5d-99c6-74b44573f521&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('14aa2f2d-311c-4c5d-99c6-74b44573f521',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_14aa2f2d-311c-4c5d-99c6-74b44573f521&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNet.SignalR;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SignalRDemo
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyPresitentConnection1 : PersistentConnection
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的两个方法OnConnected 和 OnReceived默认带的&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 连接成功后的方法(已测试)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;connectionId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Task OnConnected(IRequest request, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; connectionId)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Connection.Send(connectionId, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Welcome!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 接收请求的方法(已测试)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;connectionId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Task OnReceived(IRequest request, &lt;span&gt;string&lt;/span&gt; connectionId, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; data)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Connection.Broadcast(data);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 测试一下： &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; ① 默认的形式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180708092004404-1889867808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180708092143200-2089844312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;② 手动指定&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180708092217474-958030865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180708092319536-482794484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以自行去测试不同浏览器不同版本兼容哪些协议，这里就不在过多测试了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果不指定协议，默认选择传输的协议的顺序为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180708092727617-517092417.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三. 两种通讯模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;SignalR客户端和服务器端通讯有两种模型：分别是永久连接模型(PresistentConnection)和中心模型(Hubs)，其中永久连接更加偏向底层，代码编写与原生的WebSocket很像，我个人不是很喜欢这种模式；中心模型Hubs更像面向开发者的模式，它实质上是对PresitentConnection做了封装，使其更加友好，个人非常推荐这种模式，该模式有一个非常好的地方，它允许&lt;strong&gt;客户端和服务器端自定义方法然后相互之间调用&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(1). PresistentConnection：用于单个发件人、分组、广播消息的简单终结点，开发人员通过使用持久性连接Api，直接访问SignalR公开的底层通信协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　(2). Hub: 基于永久连接之上更高层的封装，它允许客户端和服务器端自定义方法并且相互调用，它还允许将强类型的参数传递给方法并且绑定模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;下面可以很好的说明这两种模式的关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180708093943648-609330530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　简单看看PresitentConnection模型的代码和WebSocket确实有点像。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1b63c1a5-6d1c-4763-b2a1-ead4b514ab3a')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_1b63c1a5-6d1c-4763-b2a1-ead4b514ab3a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1b63c1a5-6d1c-4763-b2a1-ead4b514ab3a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1b63c1a5-6d1c-4763-b2a1-ead4b514ab3a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1b63c1a5-6d1c-4763-b2a1-ead4b514ab3a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; conn &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $.connection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/myPreConnection1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 开启连接&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            conn.start().done(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 接受服务器发来的消息&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            conn.received(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                console.log(data);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3. 连接断开的方法&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            conn.disconnected(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#j_notice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).html(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接中断&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;断开连接事件&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#j_close&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                conn.stop();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;群发事件&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#j_send&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                conn.send(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好啊&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('81f04312-d401-474b-a45a-b893683f0156')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_81f04312-d401-474b-a45a-b893683f0156&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_81f04312-d401-474b-a45a-b893683f0156&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('81f04312-d401-474b-a45a-b893683f0156',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_81f04312-d401-474b-a45a-b893683f0156&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNet.SignalR;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SignalRDemo
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyPresitentConnection1 : PersistentConnection
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的两个方法OnConnected 和 OnReceived默认带的&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 连接成功后的方法(已测试)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;connectionId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Task OnConnected(IRequest request, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; connectionId)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Connection.Send(connectionId, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Welcome!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 接收请求的方法(已测试)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;connectionId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Task OnReceived(IRequest request, &lt;span&gt;string&lt;/span&gt; connectionId, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; data)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Connection.Broadcast(data);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 连接中断调用方法(已测试)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;connectionId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;stopCalled&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Task OnDisconnected(IRequest request, &lt;span&gt;string&lt;/span&gt; connectionId, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; stopCalled)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnDisconnected(request, connectionId, stopCalled);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当连接在超时后重新连接时调用该方法
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;connectionId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Task OnReconnected(IRequest request, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; connectionId)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnReconnected(request, connectionId);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;四. 一些环境的要求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. .Net Framework的版本&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　SignalR 2 起仅支持在 .Net FrameWork 4.5及以上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 操作系统&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Win7、Win8、Win10、WinServer 2008 R2、WinServer 2012、WinServer 2016.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;注：如果SignalR使用WebSocket协议，需要配置启动Web套接字。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. IIS版本&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先IIS必须使用集成模式，不支持经典模式，另外如果SignalR使用WebSocket协议的话，必须使用IIS8及以上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;&lt;span&gt;　注：程序必须在完全信任的模式下运行&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. web浏览器对传输协议的要求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　首先配合使用的JQuery版本需在 1.6.4 及以上。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180708101226297-729484711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 桌面程序对传输协议的要求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180708101348684-1486874754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　该节到此结束，写了大约两个小时，下一个章节开始撸代码，先介绍PresistentConnection这种模式，大约下周二(2018-7-10)更新，感兴趣的朋友可以关注一下，相互学习。　　&lt;/p&gt;


&lt;div&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;作       者 : &lt;span&gt;Yaopengfei(姚鹏飞)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;博客地址 : &lt;a href=&quot;http://www.cnblogs.com/yaopengfei/&quot;&gt;&lt;span&gt;http://www.cnblogs.com/yaopengfei/&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;声     明1 : 本人才疏学浅，用郭德纲的话说“我是一个小学生”，如有错误，欢迎讨论，请勿谩骂^_^。&lt;/li&gt;
&lt;li&gt;声     明2 : 原创博客请在转载时保留原文链接或在文章开头加上本人博客地址，如需代码请在评论处留下你的邮箱&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;/div&gt;

</description>
<pubDate>Sun, 08 Jul 2018 02:16:00 +0000</pubDate>
<dc:creator>Yaopengfei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaopengfei/p/9276234.html</dc:identifier>
</item>
</channel>
</rss>