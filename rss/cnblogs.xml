<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core Identity 实战（4）授权过程 - RocketRobin</title>
<link>http://www.cnblogs.com/rocketRobin/p/9317945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rocketRobin/p/9317945.html</guid>
<description>&lt;p&gt;这篇文章我们将一起来学习 Asp.Net Core 中的(注：这样描述不准确，稍后你会明白)授权过程&lt;/p&gt;
&lt;h2 id=&quot;前情提要&quot;&gt;前情提要&lt;/h2&gt;
&lt;p&gt;在之前的文章里，我们有提到认证和授权是两个分开的过程，而且认证过程不属于Identity。同样授权过程也不属于Identity，授权过程放在Identity系列中将的原因和认证过程一样——和成员系统放在一起容易理解。&lt;/p&gt;
&lt;h2 id=&quot;动手做&quot;&gt;动手做&lt;/h2&gt;
&lt;p&gt;在弄清的是授权过程在哪里发生的之前，我们先来动手写一写授权的代码，如果了解策略授权，那么你可以快速浏览过这部分&lt;/p&gt;
&lt;p&gt;打开之前创建的项目，添加一个名为Demo的控制器，控制器代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace IdentityDemo.Controllers
{
    [Produces(&quot;application/json&quot;)]
    [Route(&quot;api/demo&quot;)]
    public class DemoController : Controller
    {
        [Authorize]
        [HttpGet]
        public object Get()
        {
            return new
            {
                User.Identity.Name,
                User.Identity.IsAuthenticated
                略...
          &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用之前注册的账户登录系统，&lt;br/&gt;访问&lt;code&gt;/api/demo&lt;/code&gt;，你将得到如下结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;name&quot;: &quot;jbl-2011@163.com&quot;,
    &quot;isAuthenticated&quot;: true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后退出登录，再次访问&lt;code&gt;/api/demo&lt;/code&gt;，那么将会跳转到登陆页面，在这个过程中&lt;code&gt;Authorize&lt;/code&gt;特性起到了至关重要的作用，接下来去掉Authorize特性，重复上两个操作，未登录的结果将是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;name&quot;: null,
    &quot;isAuthenticated&quot;: false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这两个小例子，我们很容易就能推断出Authorize特性拦截了没有登陆的用户，等等，是Authorize特性拦截了请求吗？&lt;/p&gt;
&lt;h3 id=&quot;授权过程的发生地&quot;&gt;授权过程的发生地&lt;/h3&gt;
&lt;p&gt;很显然，不是Authorize特性拦截了请求，特性只是标记了这个方法需要被授权才能访问，而真正拦截了请求的是——“&lt;strong&gt;Mvc 中间件&lt;/strong&gt;”。Action是由Mvc执行的，Mvc执行时会确认Action上的Authorize特性，来确定是否要进行授权操作（成功授权可以访问，失败了会被阻止（比如跳转到登陆）），以及如何授权（动物园例子中，第二个门卫根据切实的情况决定），也就是自定义授权（角色等等）。&lt;/p&gt;
&lt;p&gt;另外，如果我们只是简单的为 Action方法打上&lt;code&gt;[Authorize]&lt;/code&gt;标记，那么它的默认行为就是验证IsAuthenticated是否是true，也就是在认证环节（Authentication 中间件）是否通过了认证&lt;/p&gt;
&lt;p&gt;现在，我们知道了两个点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;认证过程 Authentication 发生在 Authentication 中间件中&lt;/li&gt;
&lt;li&gt;授权过程 Authorization 发生在 Mvc中间件中&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;基于策略的灵活授权&quot;&gt;基于策略的灵活授权&lt;/h3&gt;
&lt;p&gt;在企业应用中最为常见的就是基于角色的授权，实现角色授权的方式有两种，一种是直接写在&lt;code&gt;Authorize&lt;/code&gt;特性上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Authorize(Roles = &quot;admin,super-admin,&quot;)]
[HttpPost]
[ValidateAntiForgeryToken]
public async Task&amp;lt;IActionResult&amp;gt; Test()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过这种方式，不推荐，因为这样的话我们就将“角色”和“Uri”的绑定“&lt;strong&gt;硬编码在代码里了&lt;/strong&gt;”，在很多场景这显然不合适，所以接下来我们要介绍的&lt;strong&gt;基于策略的授权&lt;/strong&gt;就允许我们&lt;strong&gt;自定义授权逻辑&lt;/strong&gt;，这样就灵活多了&lt;/p&gt;
&lt;h3 id=&quot;基于策略policy的授权&quot;&gt;基于策略&lt;em&gt;Policy&lt;/em&gt;的授权&lt;/h3&gt;
&lt;p&gt;我们假设我们的授权规则是要求和上方代码片段实现相同效果，即用户具有角色“admin”或者角色“super-admin”，我们来逐步实现这个目标：&lt;/p&gt;
&lt;h4 id=&quot;第一步在-di-中注册一个用于我们需要的-policy&quot;&gt;第一步在 DI 中注册一个用于我们需要的 policy&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;services.AddAuthorization(options =&amp;gt;
{
    options.AddPolicy(&quot;role-policy&quot;, policy =&amp;gt;
    {
        policy.AddRequirements(new RoleRequirement(&quot;admin&quot;,&quot;super-admin&quot;));
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们为该策略指定了一个名字&lt;code&gt;role-policy&lt;/code&gt;，并且指定了这个策略的&lt;strong&gt;需求条件&lt;/strong&gt;，需求条件主要是为了设置策略的初始值，我们可以在策略注册时更改需求条件从而灵活控制授权。&lt;/p&gt;
&lt;p&gt;接下来我们来编写 &lt;code&gt;RoleRequirement&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RoleRequirement : IAuthorizationRequirement
{
    public IEnumerable&amp;lt;string&amp;gt; Roles { get;   }
    public RoleRequirement(params string[] roles)
    {
        Roles = roles ?? throw new ArgumentNullException(nameof(roles));
        略...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那我们的 &lt;code&gt;RoleRequirement&lt;/code&gt; 主要实现的功能就是确定要包含的角色，因为要包含的角色是在构造函数中确定的，那么我们就将&lt;strong&gt;角色授权的逻辑&lt;/strong&gt;（稍后介绍的Handler）和&lt;strong&gt;具体授权的数据&lt;/strong&gt;分开了。&lt;/p&gt;
&lt;p&gt;然后我们来实现&lt;code&gt;RoleRequirement&lt;/code&gt;对应的处理程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RoleHandler : AuthorizationHandler&amp;lt;RoleRequirement&amp;gt;
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, RoleRequirement requirement)
    {

        foreach (var item in requirement.Roles)
        {
            if (context.User.IsInRole(item))
            {
                context.Succeed(requirement);
                return Task.CompletedTask;
            }
        }
        context.Fail();
        return Task.CompletedTask;
        略...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个处理器的工作十分简单就是验证当前用户是否在任意一个由&lt;code&gt;RoleRequirement&lt;/code&gt;指定的角色中。在这里&lt;code&gt;context.Succeed(requirement);&lt;/code&gt;指示授权成功，而授权失败一般不需要调用&lt;code&gt;context.Fail();&lt;/code&gt;因为对于这个需求还可能有其它处理器进行处理，而此例中调用&lt;code&gt;context.Fail();&lt;/code&gt;可以确保授权失败，因为&lt;code&gt;RoleRequirement&lt;/code&gt;的处理器只有一个，所以这样做是没有问题的。&lt;/p&gt;
&lt;p&gt;要注意的是刚刚提到的，我们已经将&lt;strong&gt;角色授权的逻辑&lt;/strong&gt;（稍后介绍的Handler）和&lt;strong&gt;具体授权的数据&lt;/strong&gt;分开了。&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;RoleHandler&lt;/code&gt;并不清楚要求用户有哪些角色，&lt;code&gt;RoleHandler&lt;/code&gt;只知道如何去验证用户含有哪些角色，而具体要求用户含有哪些角色，是由 &lt;code&gt;RoleRequirement&lt;/code&gt;来决定的，这符合关注点分离和单一职责这两个编程概念。&lt;/p&gt;
&lt;p&gt;再然后，我们要将刚刚写好的&lt;code&gt;RoleHandler&lt;/code&gt;注册进Di&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddSingleton&amp;lt;IAuthorizationHandler, RoleHandler&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一步，更换原来的Attribute：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// [Authorize(Roles = &quot;admin,super-admin,&quot;)]
[Authorize(Policy =&quot;role-policy&quot;)]
[HttpPost]
[ValidateAntiForgeryToken]
public async Task&amp;lt;IActionResult&amp;gt; Test()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，一个最基本的基于策略的授权就完成了。&lt;/p&gt;
&lt;p&gt;本文中的示例较为简单，也并没有使用全部的授权特性，更详细的使用方法参考资料很多，本文也就不多做介绍。&lt;br/&gt;另外你可以参考&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/security/authorization/policies?view=aspnetcore-2.1#security-authorization-policies-based-multiple-handlers&quot;&gt;ASP.NET Core中基于策略的授权&lt;/a&gt;来学习更过关于策略授权的内容&lt;/p&gt;
&lt;h2 id=&quot;授权时指定authenticationscheme&quot;&gt;授权时指定AuthenticationScheme&lt;/h2&gt;
&lt;p&gt;指定AuthenticationScheme的代码类似这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// [Authorize(Roles = &quot;admin,super-admin,&quot;)]
[Authorize(AuthenticationSchemes =&quot;jwt&quot;/*注意，这里的名字取决于你添加AuthenticationHandler时的名字*/, Policy =&quot;role-policy&quot;)]     [HttpPost]
[AllowAnonymous]
[ValidateAntiForgeryToken]
public async Task&amp;lt;IActionResult&amp;gt; Test()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上一篇博客&lt;a href=&quot;https://www.cnblogs.com/rocketRobin/p/9105720.html&quot;&gt;ASP.NET Core Identity 实战（3）认证过程&lt;/a&gt;中提到，在Authentication中间件中可以放置多个Handler，而有一个是默认激活的，那么剩下的是被动调用的，现在我们的情况就是由我们在Authorize特性中去挑选一个Handler来执行，例如我们在Authentication中间件上放置两个Handler——CookieAuthenticationHandler和JwtAuthenticationHandler，并经CookieAuthenticationHandler指定为默认，那么我们想经由Jwt认证时怎么办？&lt;/p&gt;
&lt;p&gt;这里有一个重要问题就是：&lt;strong&gt;当HttpContext流过Authentication中间件后才到Mvc中间件，而Mvc在确认Action指定的AuthenticationHandler时，Authentication过程已经结束了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那这是怎么做到的呢？&lt;/p&gt;
&lt;p&gt;还记的HttpContext中有一个扩展方法叫&lt;code&gt;AuthenticateAsync&lt;/code&gt;,作为HttpContext的扩展方法也就意味着，我们可以在任何时候调用它进行认证操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace Microsoft.AspNetCore.Authentication
{
    public static class AuthenticationHttpContextExtensions
    {
        public static Task&amp;lt;AuthenticateResult&amp;gt; AuthenticateAsync(this HttpContext context);
        public static Task&amp;lt;AuthenticateResult&amp;gt; AuthenticateAsync(this HttpContext context, string scheme);
        略...
     &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看它的第二个重载，它是指定了 AuthenticationScheme的名字的，所以在Mvc中间件探查到Attribute指定了AuthenticationScheme时，就会重新挑选指定的AuthenticationHandler再次对请求进行认证&lt;/p&gt;
&lt;h2 id=&quot;授权的发生地authorizationfilter&quot;&gt;授权的发生地——AuthorizationFilter&lt;/h2&gt;
&lt;p&gt;在旧的Asp.Net时代，我们知道MvcFilter这个东西，现在它仍然在，如果你不了解它，我建议你稍作了解，建议参考&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-2.1&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正如这一节的标题，授权发生在&lt;code&gt;Microsoft.AspNetCore.Mvc.Authorization.AuthorizationFilter&lt;/code&gt;中,授权的逻辑类似这样：&lt;/p&gt;
&lt;h3 id=&quot;先进行认证&quot;&gt;先进行认证&lt;/h3&gt;
&lt;p&gt;如果指定了scheme，那么重新认证，如果没有，则使用之前 Authentication中间件的授权结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public virtual async Task&amp;lt;AuthenticateResult&amp;gt; Microsoft.AspNetCore.Authorization.Policy.PolicyEvaluator.AuthenticateAsync(AuthorizationPolicy policy, HttpContext context)
    {
        if (policy.AuthenticationSchemes != null &amp;amp;&amp;amp; policy.AuthenticationSchemes.Count &amp;gt; 0)
        {
            ClaimsPrincipal newPrincipal = null;
            foreach (var scheme in policy.AuthenticationSchemes)
            {
                var result = await context.AuthenticateAsync(scheme);
                if (result != null &amp;amp;&amp;amp; result.Succeeded)
                {
                    newPrincipal = SecurityHelper.MergeUserPrincipal(newPrincipal, result.Principal);
                }
            }

            if (newPrincipal != null)
            {
                context.User = newPrincipal;
                return AuthenticateResult.Success(new AuthenticationTicket(newPrincipal, string.Join(&quot;;&quot;, policy.AuthenticationSchemes)));
            }
            else
            {
                context.User = new ClaimsPrincipal(new ClaimsIdentity());
                return AuthenticateResult.NoResult();
            }
        }

        return (context.User?.Identity?.IsAuthenticated ?? false) 
            ? AuthenticateResult.Success(new AuthenticationTicket(context.User, &quot;context.User&quot;))
            : AuthenticateResult.NoResult();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面值得再次深入探讨的是 &lt;code&gt;context.AuthenticateAsync(scheme)&lt;/code&gt;，这是在 HttpAbstractions项目中的扩展方法，它的实现是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static Task&amp;lt;AuthenticateResult&amp;gt; AuthenticateAsync(this HttpContext context, string scheme) =&amp;gt;
        context.RequestServices.GetRequiredService&amp;lt;IAuthenticationService&amp;gt;().AuthenticateAsync(context, scheme);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IAuthenticationService&lt;/code&gt;我们在 Authentication中间件中也见过，Authentication中间件也是使用了&lt;code&gt;IAuthenticationService&lt;/code&gt;，之前的文章有提到过，这也再次证明了单一原则职责，身份认证中间件负责&lt;strong&gt;在管道&lt;/strong&gt;中认证，而认证本身并非是和身份认证中间件捆绑的，上一篇博客&lt;a href=&quot;https://www.cnblogs.com/rocketRobin/p/9105720.html&quot;&gt;ASP.NET Core Identity 实战（3）认证过程&lt;/a&gt;的最后有认证的源代码&lt;/p&gt;
&lt;h3 id=&quot;再进行授权&quot;&gt;再进行授权&lt;/h3&gt;
&lt;p&gt;授权总共分三步&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;拿到IAuthorizeHandler的实例（前面我们写了一个）（可能一个&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/security/authorization/policies?view=aspnetcore-2.1#why-would-i-want-multiple-handlers-for-a-requirement&quot;&gt;或者多个&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;执行授权（每个Handler都会进行授权）&lt;/li&gt;
&lt;li&gt;没了&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这部分代码还是很简单的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public async Task&amp;lt;AuthorizationResult&amp;gt; AuthorizeAsync(ClaimsPrincipal user, object resource, IEnumerable&amp;lt;IAuthorizationRequirement&amp;gt; requirements)
    {
        // 第一步
        var authContext = _contextFactory.CreateContext(requirements, user, resource);
        var handlers = await _handlers.GetHandlersAsync(authContext);
        // 第二部
        foreach (var handler in handlers)
        {
            await handler.HandleAsync(authContext);
            if (!_options.InvokeHandlersAfterFailure &amp;amp;&amp;amp; authContext.HasFailed)
            {
                break;
            }
        }

        // 没了（这主要是对结果进行处理）
        var result = _evaluator.Evaluate(authContext);
        if (result.Succeeded)
        {
            _logger.UserAuthorizationSucceeded(GetUserNameForLogging(user));
        }
        else
        {
            _logger.UserAuthorizationFailed(GetUserNameForLogging(user));
        }
        return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面和我们在项目中写的代码有关就是IAuthorizeHandler的实例，在本文中，我们写了一个&lt;code&gt;RoleHandler&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;到此，授权过程就结束了，另外一些就是边边角角的知识点，比如授权之后如何操作，这些不难，就不再文中赘述了&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 07:50:00 +0000</pubDate>
<dc:creator>RocketRobin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rocketRobin/p/9317945.html</dc:identifier>
</item>
<item>
<title>移动端触摸滑动插件Swiper使用指南 - zhangyin88</title>
<link>http://www.cnblogs.com/zhangyin88/p/9311902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyin88/p/9311902.html</guid>
<description>&lt;p&gt;Swiper是一款开源、免费、功能十分强大的移动端内容触摸滑动插件，目前的最新版本是Swiper4。Swiper主要面向的是手机、平板电脑等移动设备，帮助开发者轻松实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。本文简单介绍一下Swiper的使用方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1441217/201807/1441217-20180715094412388-1039293861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;下载和安装Swiper&lt;/h2&gt;
&lt;p&gt;首先我们需要下载Swiper的相关文件：&lt;/p&gt;
&lt;p&gt;我们可以直接从&lt;a href=&quot;https://github.com/nolimits4web/Swiper/tree/master/dist&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;代码仓库中下载。&lt;/p&gt;
&lt;p&gt;或者通过Bower下载：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ bower &lt;span&gt;install&lt;/span&gt; swiper
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者使用Atmosphere将Swiper制作成Meteor包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ meteor add nolimits4web:swiper
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者使用NMP（JavaScript包管理工具）下载：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ npm &lt;span&gt;install&lt;/span&gt; swiper
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载压缩包后解压，我们需要用到的js文件和css文件都在dist目录中。&lt;/p&gt;
&lt;h2&gt;从CDN引用Swiper&lt;/h2&gt;
&lt;p&gt;如果你不想将Swiper文件资源放到自己的项目中或者服务器上，那么可以使用CDN上的资源，这样可以让不同地区的用户有最快的加载速度，也可以减轻你服务器的负担，下面是可用的CDN文件列表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.x.x/css/swiper.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.x.x/css/swiper.min.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.x.x/js/swiper.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.x.x/js/swiper.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.x.x/js/swiper.esm.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.x.x/js/swiper.esm.bundle.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不要忘记将版本号&lt;strong&gt;4.x.x&lt;/strong&gt;替换成自己使用的版本号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;将Swiper文件包含到网站中&lt;/h2&gt;
&lt;p&gt;接下来我们将Swiper的JS文件和CSS文件分别包含到自己的网站或者App中，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;path/to/swiper.min.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;path/to/swiper.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;为滑块添加HTML布局结构&lt;/h2&gt;
&lt;p&gt;下面我们创建最基本的布局：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Slider main container &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Additional required wrapper &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-wrapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Slides &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-slide&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Slide 1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-slide&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Slide 2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-slide&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Slide 3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; If we need pagination &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-pagination&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; If we need navigation buttons &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-button-prev&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-button-next&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; If we need scrollbar &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;swiper-scrollbar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;设置滑块大小&lt;/h2&gt;
&lt;p&gt;我们可以为Swiper滑块自定义大小，通过CSS实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.swiper-container &lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 600px&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 300px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;初始化&lt;/h2&gt;
&lt;p&gt;最后我们需要调用Swiper库初始化滑块，设置非常方便。&lt;/p&gt;
&lt;p&gt;将下面的代码添加到&amp;lt;body&amp;gt;末尾：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&amp;lt;body&amp;gt;&lt;span&gt;
  ...
  &lt;/span&gt;&amp;lt;script&amp;gt;
  &lt;span&gt;var&lt;/span&gt; mySwiper = &lt;span&gt;new&lt;/span&gt; Swiper ('.swiper-container'&lt;span&gt;, {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Optional parameters&lt;/span&gt;
    direction: 'vertical'&lt;span&gt;,
    loop: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we need pagination&lt;/span&gt;
&lt;span&gt;    pagination: {
      el: &lt;/span&gt;'.swiper-pagination'&lt;span&gt;,
    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Navigation arrows&lt;/span&gt;
&lt;span&gt;    navigation: {
      nextEl: &lt;/span&gt;'.swiper-button-next'&lt;span&gt;,
      prevEl: &lt;/span&gt;'.swiper-button-prev'&lt;span&gt;,
    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; And if we need scrollbar&lt;/span&gt;
&lt;span&gt;    scrollbar: {
      el: &lt;/span&gt;'.swiper-scrollbar'&lt;span&gt;,
    },
  })
  &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你使用jQuery库，那么上面这段初始化的代码可以放在页面任何位置，但必须在document.ready代码块中调用。示例代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;initialize swiper when document ready&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; mySwiper = &lt;span&gt;new&lt;/span&gt; Swiper ('.swiper-container'&lt;span&gt;, {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Optional parameters&lt;/span&gt;
  direction: 'vertical'&lt;span&gt;,
  loop: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
})
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者在window.onload方法中调用（不推荐）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;initialize swiper when document ready&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; mySwiper = &lt;span&gt;new&lt;/span&gt; Swiper ('.swiper-container'&lt;span&gt;, {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Optional parameters&lt;/span&gt;
  direction: 'vertical'&lt;span&gt;,
  loop: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
})
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;作为CommonJs模块&lt;/h2&gt;
&lt;p&gt;Swiper与CommonJs模块完全兼容，可以在类似Node.js的环境中使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Swiper = require('swiper'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mySwiper = &lt;span&gt;new&lt;/span&gt; Swiper('.swiper-container', { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ... &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;作为ES模块&lt;/h2&gt;
&lt;p&gt;Swiper包附带ES模块版本，可以在支持ES的地方使用，也可以与Webpack或Rollup等捆绑一起使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import Swiper from 'swiper'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mySwiper = &lt;span&gt;new&lt;/span&gt; Swiper('.swiper-container', { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ... &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Swiper的功能确实比较强大，还有很多高级的配置，大家可以在&lt;a href=&quot;https://www.tutorialdocs.com/tutorial/swiper/api-initialize.html&quot; target=&quot;_blank&quot;&gt;Swiper API文档&lt;/a&gt;（英文）中了解。下面附上API文档的章节目录：&lt;/p&gt;
&lt;h3&gt;Swiper API Docs&lt;/h3&gt;
&lt;h3&gt;Swiper Components&lt;/h3&gt;
</description>
<pubDate>Mon, 16 Jul 2018 07:48:00 +0000</pubDate>
<dc:creator>zhangyin88</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyin88/p/9311902.html</dc:identifier>
</item>
<item>
<title>Zookeeper的前世今生 - jolivan</title>
<link>http://www.cnblogs.com/Jolivan/p/9303357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jolivan/p/9303357.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;到底发生了什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在电商架构中，早期是单体架构，可以很快的解决交互问题和产品初期的迭代。但是随着架构的发展，后端无法支撑大流量。一开始的解决办法是增加服务器等垂直解决方法，但是这样的效率太低并且成本太高。因此开发者开始考虑水平伸缩来提高整体的性能。&lt;/p&gt;
&lt;p&gt;　　首先是对产品的拆分：按照类型拆分成不同的模块，那么模块之间的交互就需要实现远程调用，比如webservice。这样其实就简单的形成了一个分布式架构。服务越来越多，我们就拆分的越来越细，随着流量不断提升，后端规模越来越大。举个例子：用户调用订单服务，它是通过http协议来调用，那么首先订单服务那必须给用户一个地址。如果说订单系统是一个大的集群，那么可能我们就需要维护多个这样的地址。那么应该如何解决大规模地址管理？集群里的地址如何去转发？如果其中一个节点down机了怎么办，怎么去管理服务动态上下线感知？&lt;/p&gt;
&lt;p&gt;　　那我们就通过解决以上三个问题来引出本文的主角---Zookeeper&lt;/p&gt;
&lt;p&gt;　　我们可以考虑设置一个中间件，它的存在可以让我们的服务发布的时候注册上去，充当一个电话本，记住你所有的地址，并且及时了解你是不是断开。用户服务只需要拿到中间件的地址，就可以获得对应的相关的调用的目标服务的信息，拿到这个信息，根据负载均衡算法，就可以做一个转发。&lt;/p&gt;
&lt;p&gt;　　Zookeeper是一个什么东西呢？它是一个文件存储类似的树型结构，entry是key-value。每个子节点由父节点管理，子节点是父节点详细的分类。比如说，对于订单服务系统，它的子节点存放着各种地址。Zookeeper适不适合作为一个注册中心？很多人说不是很合适，但是目前大部分企业仍然用它来做注册中心的功能。Zookeeper的学术名称为分布式协调服务，它的本意是解决分布式锁的，比如说几个服务访问共享资源，就会出现资源竞争的问题，这时候就会需要一个协调者来解决这个问题，Zookeeper就是用来解决这个问题的，可以看作一个交警。这样一来共享资源就变成了一个单点访问资源，你先来我中间件里来，我再判断让不让你去访问。当然为了保持单点的特点，Zookeeper一般是以集群出现，在满足单点的功能，提高其可用性。集群的出现带来的问题众所周知，那就是数据同步。Zookeeper内部角色分为Leader、Follower、observer，数据提交方式基于二阶提交，写数据写在follower上，其他的follower去同步数据。请求命令放在leader上，然后让其他的节点知道，这里满足一个CAP原则。&lt;/p&gt;
&lt;p&gt;　　Zookeeper作为一个分布式协调服务，目标是为了解决分布式架构中一致性问题。&lt;/p&gt;
&lt;p&gt;　　Zookeeper客户端可以提供增删改查节点的功能，删除的时候必须一层一层的删除。而且节点具有唯一性，可以参考电脑文件结构。同时节点还分为临时节点 -e和持久化节点、有序节点 -s和无序节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Zookeeper应用场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　注册中心、配置中心（和注册中心大同小异，类似于application.properties，用来统一维护配置信息）、负载均衡（知道机器的状态以及选举leader）和分布式锁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[zk: localhost:&lt;span&gt;2181&lt;/span&gt;(CONNECTED) &lt;span&gt;0&lt;/span&gt;] create /userservice &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Created &lt;/span&gt;/&lt;span&gt;userservice
[zk: localhost:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt;(CONNECTED) &lt;span&gt;2&lt;/span&gt;] &lt;span&gt;ls&lt;/span&gt; /&lt;span&gt;
[zookeeper, userservice]
[zk: localhost:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt;(CONNECTED) &lt;span&gt;3&lt;/span&gt;] &lt;span&gt;ls&lt;/span&gt; /&lt;span&gt;userservice
[]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　配置zoo.cfg文件，将三个服务器的ip、访问Zookeeper的端口以及选举的端口配置好&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
server.&lt;span&gt;1&lt;/span&gt;=&lt;span&gt;10.10&lt;/span&gt;.&lt;span&gt;101.7&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;span&gt;
server.&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;=&lt;span&gt;10.10&lt;/span&gt;.&lt;span&gt;101.104&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;span&gt;
server.&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;=&lt;span&gt;10.10&lt;/span&gt;.&lt;span&gt;101.108&lt;/span&gt;:&lt;span&gt;2888&lt;/span&gt;:&lt;span readability=&quot;2&quot;&gt;3888&lt;br/&gt;server.n=ip:prot:prot&lt;p&gt;其中n在 /tmp/zookeeper/myid里配置&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　除了Leader和Follower之外，还有一个Observer的节点，它的作用是用来监控整个集群的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Zookeeper特性分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　ACL属于一种权限控制，控制你创建的文件夹（节点）的0访问权限。它提供了create、write、read、delete和admin五种权限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;角色&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　leader用来处理事务请求的，就是所有的添加修改删除都会去leader那，非事务请求（查询）可能会落到任一节点上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　数据模型是Zookeeper里较为核心的东西，它的结构类似于树，也类似于电脑的文件管理系统。节点特性分为持久化和有序性，每个znode可以保存少量数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　客户端和服务端连接会建立会话&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进阶&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Zookeeper的技术层面由来&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　假设分布式系统中有三个节点作为一个集群，在这个集群里运行一个任务，所以每个节点都有权限去执行这个任务。那我我有几个问题想问：&lt;/p&gt;
&lt;p&gt;　　（1）怎么保证各个节点数据一致？&lt;/p&gt;
&lt;p&gt;　　（2）怎么保证任务只在一个节点执行？&lt;/p&gt;
&lt;p&gt;　　（3）如果在执行任务的1节点挂了，那么其他的节点如何发现并接替任务？&lt;/p&gt;
&lt;p&gt;　　（4）它们对于共享资源是怎么处理的？&lt;/p&gt;
&lt;p&gt; 　　我们可以先将节点注册到Zookeeper中，然后因为节点有顺序性，所以说我们第一个看到的节点就认为他是最具优先权的，那么它就可以去做这个操作，这就是Zookeeper起到的能够给集群节点进行一个协调的作用。&lt;/p&gt;
&lt;p&gt;　　那么按照上面的几个问题，如果我们想设计一个中间件，那么应该注意哪些事情呢？&lt;/p&gt;
&lt;p&gt;　　（1）单点故障 &lt;/p&gt;
&lt;p&gt;　　存在leader、follower节点。同时也会分担请求（高可用、高性能）。&lt;/p&gt;
&lt;p&gt;　　（2）为啥集群要有master&lt;/p&gt;
&lt;p&gt;　　（3）如果集群中的maser挂了怎么办？数据如何恢复？如何选举？&lt;/p&gt;
&lt;p&gt;　　　　Zookeeper选举使用了ZAB协议&lt;/p&gt;
&lt;p&gt;　　（4）如何保证数据一致性？（分布式事务）&lt;/p&gt;
&lt;p&gt;　　2PC（二阶提交）：当一个事务涉及多个节点提交，为了保证进行，引入一个协调者，通过协调者控制整个集群工作的顺利进行。当一个事务开始时，由协调者将请求发给所有节点，然后节点若能执行，则向协调者发起可以执行请求。如果一个参与者失败，不能进行事务执行，那么其他节点都将发起回滚提交。否则，所有节点顺利提交，这个事务顺利完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Zookeeper集群内部成员介绍：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1204324/201807/1204324-20180716111022672-1646709361.png&quot; alt=&quot;&quot; width=&quot;779&quot; height=&quot;442&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么Zookeeper集群是2*n+1的数量？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　因为Zookeeper集群如果正常对外服务，必须有投票机制，集群内部有过半节点正常服务，保证投票能够有结果。而且能够保证对n个服务器的容灾处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ZAB协议&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　它是Zookeeper里面专门用来处理崩溃恢复的原子广播协议，依赖ZAB协议实现分布式数据一致性。如果集群中leader出现了问题，ZAB协议就会进行恢复模式并选举产生新的leader，选举产生之后，并且集群中有过半节点与leader数据同步之后，ZAB就会退出恢复模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　消息广播&lt;/strong&gt;：属于一个简化的二阶提交机制，leader收到请求后，会给事务请求赋予一个zxid，可以通过zxid的大小去比较生成因果有序这个特性。leader会给每个follower给一个FIFO队列，然后将带有zxid的消息作为一个提案分发给所有的leader，follower收到请求后，将提案写入磁盘，并给leader发送ack。如果leader收到半数以上的ack，就确定这个消息要执行，然后给所有的follower发送commit指令，同时也会在本地执行这个请求。如果没有通过，所有节点执行回滚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　崩溃恢复&lt;/strong&gt;：leader挂掉之后，那么就需要恢复选举和数据。当leader失去了过半节点联系、leader挂了这两种情况发生，集群就会进入崩溃恢复阶段。对于数据恢复来说：（1）已经被处理的消息不能丢失，也就是来个栗子：当follower收到commit之前，leader挂掉了，怎么办？这时部分节点收到commit，部分节点没有收到，这时ZAB协议保证已经处理的消息不能被丢失，被丢弃的消息不能再次出现（当leader节点收到事务请求之后，在生成提案时挂了，那么新选举的leader节点要跳过这个消息）。&lt;/p&gt;
&lt;p&gt;　　ZAB协议需要满足这两个要求，必须设计出算法。&lt;/p&gt;
&lt;p&gt;　　ZAB协议中保证选举出来的leader有着整个集群zxid最大的提案，这样第一是保证新的leader之前是正常工作的，第二是因为zxid是64位的，高32为epoch编号，每当leader选举产生一个新的leader，新的leader的epoch号就+1，低32位是消息计数器，每当接受一条消息，就+1。新的leader被选举之后就会清空。这样可以保证老的leader挂掉之后，不可能被再次选举。可以把epoch看做成皇帝的年号，现在统治的事哪个皇帝。&lt;/p&gt;
&lt;p&gt;　　zxid在上面已经简单介绍了，下面说一下它的简单特性：Zookeeper中所有提议在被提出时都会加上zxid。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;leader选举&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　基于fast leader选举，基于几个方面：zxid最大会设置成leader，epoch；myid（服务器id），myid越大，在leader选举权重中越大；事务id，事务id越大，表示事务越新；epoch（逻辑时钟）每一次投票，epoch都会递增；选举状态：LOOKING-&amp;gt;LEADING（FOLLOWING、OBSERVING）&lt;/p&gt;
&lt;p&gt;　　启动的时候：每个Server都会发起一个投票，每个节点都会先将自己作为一个leader，并将自己的zxid、myid等信息发给其他节点。其他节点会进行比较：zxid相同就检查myid，myid大的会作为leader，之后开始进行统计投票，最后选出leader。&lt;/p&gt;
&lt;p&gt;　　前一个leader挂掉：所有节点编程looking状态，然后会查看其他节点的信息，来做出投票。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看一下源码理解一下&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initializeAndRun(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ConfigException, IOException
    {
        org.apache.zookeeper.server.quorum.QuorumPeerConfig config &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.server.quorum.QuorumPeerConfig();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.length == 1&lt;span&gt;) {
            config.parse(args[&lt;/span&gt;0&lt;span&gt;]);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start and schedule the the purge task&lt;/span&gt;
        DatadirCleanupManager purgeMgr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DatadirCleanupManager(config
                .getDataDir(), config.getDataLogDir(), config
                .getSnapRetainCount(), config.getPurgeInterval());
        purgeMgr.start();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是单机还是集群模式&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (args.length == 1 &amp;amp;&amp;amp; config.servers.size() &amp;gt; 0&lt;span&gt;) {
            runFromConfig(config);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            LOG.warn(&lt;/span&gt;&quot;Either no config or no quorum defined in config, running &quot;
                    + &quot; in standalone mode&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; there is only server in the quorum -- run as standalone&lt;/span&gt;
&lt;span&gt;            ZooKeeperServerMain.main(args);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为只有集群模式才会有选举，这时候我们会进入到runFromConfig方法中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; runFromConfig(org.apache.zookeeper.server.quorum.QuorumPeerConfig config) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          ManagedUtil.registerLog4jMBeans();
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMException e) {
          LOG.warn(&lt;/span&gt;&quot;Unable to register log4j JMX control&quot;&lt;span&gt;, e);
      }
  
      LOG.info(&lt;/span&gt;&quot;Starting quorum peer&quot;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          ServerCnxnFactory cnxnFactory &lt;/span&gt;=&lt;span&gt; ServerCnxnFactory.createFactory();
          cnxnFactory.configure(config.getClientPortAddress(),
                                config.getMaxClientCnxns());
  
          quorumPeer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.server.quorum.QuorumPeer();
          quorumPeer.setClientPortAddress(config.getClientPortAddress());
          quorumPeer.setTxnFactory(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileTxnSnapLog(
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(config.getDataLogDir()),
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(config.getDataDir())));
          quorumPeer.setQuorumPeers(config.getServers());
          quorumPeer.setElectionType(config.getElectionAlg());
          quorumPeer.setMyid(config.getServerId());
          quorumPeer.setTickTime(config.getTickTime());
          quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());
          quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());
          quorumPeer.setInitLimit(config.getInitLimit());
          quorumPeer.setSyncLimit(config.getSyncLimit());
          quorumPeer.setQuorumVerifier(config.getQuorumVerifier());
          quorumPeer.setCnxnFactory(cnxnFactory);
          quorumPeer.setZKDatabase(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZKDatabase(quorumPeer.getTxnFactory()));
          quorumPeer.setLearnerType(config.getPeerType());
          quorumPeer.setSyncEnabled(config.getSyncEnabled());
          quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());
  
          quorumPeer.start();
          quorumPeer.join();
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; warn, but generally this is ok&lt;/span&gt;
          LOG.warn(&quot;Quorum Peer interrupted&quot;&lt;span&gt;, e);
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，它会从配置文件中加载一些信息，最后启动start来开始进行选举。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
        loadDataBase();
        cnxnFactory.start(); 
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始进行选举Leader&lt;/span&gt;
&lt;span&gt;        startLeaderElection();
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.start();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startLeaderElection() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            currentVote &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.server.quorum.Vote(myid, getLastLoggedZxid(), getCurrentEpoch());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException e) {
            RuntimeException re &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e.getMessage());
            re.setStackTrace(e.getStackTrace());
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; re;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (QuorumServer p : getView().values()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.id ==&lt;span&gt; myid) {
                myQuorumAddr &lt;/span&gt;=&lt;span&gt; p.addr;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (myQuorumAddr == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;My id &quot; + myid + &quot; not in the peer list&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (electionType == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                udpSocket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DatagramSocket(myQuorumAddr.getPort());
                responder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ResponderThread();
                responder.start();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SocketException e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
            }
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.electionAlg =&lt;span&gt; createElectionAlgorithm(electionType);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从上段代码的一开始，表示它会存储三个信息：myid、zxid和epoch，然后配置选举类型来使用选举算法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; org.apache.zookeeper.server.quorum.Election createElectionAlgorithm(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; electionAlgorithm){
        org.apache.zookeeper.server.quorum.Election le&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO: use a factory rather than a switch&lt;/span&gt;
        &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (electionAlgorithm) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 0&lt;span&gt;:
            le &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; org.apache.zookeeper.server.quorum.LeaderElection(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
            le &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; org.apache.zookeeper.server.quorum.AuthFastLeaderElection(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 2&lt;span&gt;:
            le &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; org.apache.zookeeper.server.quorum.AuthFastLeaderElection(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 3&lt;span&gt;:
            qcm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; org.apache.zookeeper.server.quorum.QuorumCnxManager(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            org.apache.zookeeper.server.quorum.QuorumCnxManager.Listener listener &lt;/span&gt;=&lt;span&gt; qcm.listener;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(listener != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                listener.start();
                le &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; org.apache.zookeeper.server.quorum.FastLeaderElection(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, qcm);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                LOG.error(&lt;/span&gt;&quot;Null listener when initializing cnx manager&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; le;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里面提供着一些选举算法，最后会设置一个负责选举的IO类，然后启动来进行选举。&lt;/p&gt;

&lt;p&gt;　&lt;em&gt;本文思路来源于&lt;a href=&quot;http://product.dangdang.com/23625430.html&quot; target=&quot;_blank&quot;&gt;《从Paxos到Zookeeper：分布式一致性原理与实践》&lt;/a&gt;一书&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 07:46:00 +0000</pubDate>
<dc:creator>jolivan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jolivan/p/9303357.html</dc:identifier>
</item>
<item>
<title>V8源码边缘试探-黑魔法指针偏移 - 书生小龙</title>
<link>http://www.cnblogs.com/QH-Jimmy/p/9317297.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QH-Jimmy/p/9317297.html</guid>
<description>&lt;p&gt;　　这博客是越来越难写了，参考资料少，难度又高，看到什么写什么吧！&lt;/p&gt;
&lt;p&gt;　　众多周知，在JavaScript中有几个基本类型，包括字符串、数字、布尔、null、undefined、Symbol，其中大部分都可以在我之前那篇博客(https://www.cnblogs.com/QH-Jimmy/p/9212923.html)中找到，均继承于Primitive类。但是仔细看会发现少了两个，null和undefined呢？这一节，就来探索一下，V8引擎是如何处理null、undefined两种类型的。&lt;/p&gt;
&lt;p&gt;　　在没有看源码之前，我以为是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Null : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Primitive {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Type testing.&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; IsNull() &lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然而实际上没有这么简单粗暴，V8对null、undefined(实际上还包括了true、false、空字符串)都做了特殊的处理。&lt;/p&gt;
&lt;p&gt;　　回到故事的起点，是我在研究LoadEnvironment函数的时候发现的。上一篇博客其实就是在讲这个方法，包装完函数名、函数体，最后一步就是配合函数参数来执行函数了，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Bootstrap internal loaders&lt;/span&gt;
Local&amp;lt;Value&amp;gt;&lt;span&gt; bootstrapped_loaders;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ExecuteBootstrapper(env, loaders_bootstrapper,
                        arraysize(loaders_bootstrapper_args),
                        loaders_bootstrapper_args,
                        &lt;/span&gt;&amp;amp;&lt;span&gt;bootstrapped_loaders)) {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的参数分别为：&lt;/p&gt;
&lt;p&gt;1、env =&amp;gt; 当前V8引擎的环境变量，包含Isolate、context等。&lt;/p&gt;
&lt;p&gt;2、loaders_bootstrapper =&amp;gt; 函数体&lt;/p&gt;
&lt;p&gt;3、arraysize(loaders_bootstrapper_args) =&amp;gt; 参数长度，就是4&lt;/p&gt;
&lt;p&gt;4、loaders_bootstrapper_args =&amp;gt; 参数数组，包括process对象及3个C++内部方法&lt;/p&gt;
&lt;p&gt;5、&amp;amp;bootstrapped_loaders =&amp;gt; 一个局部变量指针&lt;/p&gt;
&lt;p&gt;　　参数是啥并不重要，进入方法，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ExecuteBootstrapper(Environment* env, Local&amp;lt;Function&amp;gt;&lt;span&gt; bootstrapper,
                                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; argc, Local&amp;lt;Value&amp;gt;&lt;span&gt; argv[],
                                Local&lt;/span&gt;&amp;lt;Value&amp;gt;* &lt;span&gt;out&lt;/span&gt;&lt;span&gt;) {
  &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; ret = bootstrapper-&amp;gt;&lt;span&gt;Call(
      env&lt;/span&gt;-&amp;gt;context(), Null(env-&amp;gt;isolate()), argc, argv).ToLocal(&lt;span&gt;out&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ret) {
    env&lt;/span&gt;-&amp;gt;async_hooks()-&amp;gt;&lt;span&gt;clear_async_id_stack();
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看起来就像JS里面的call方法，其中函数参数包括context、null、形参数量、形参，当时看到Null觉得比较好奇，就仔细的看了一下实现。&lt;/p&gt;

&lt;p&gt;　　这个方法其实很简单，但是实现的方式非常有意思，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Local&amp;lt;Primitive&amp;gt; Null(Isolate*&lt;span&gt; isolate) {
    typedef &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt;::Object*&lt;span&gt; S;
    typedef &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt;&lt;span&gt;::Internals I;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检测当前V8引擎实例是否存活&lt;/span&gt;
&lt;span&gt;    I::CheckInitialized(isolate);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 核心方法&lt;/span&gt;
    S* slot =&lt;span&gt; I::GetRoot(isolate, I::kNullValueRootIndex);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型强转 直接是Primitive类而不是继承&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; Local&amp;lt;Primitive&amp;gt;(reinterpret_cast&amp;lt;Primitive*&amp;gt;&lt;span&gt;(slot));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　只有GetRoot是真正生成null值的地方，注意第二个参数 &lt;span class=&quot;cnblogs_code&quot;&gt;I::kNullValueRootIndex&lt;/span&gt; ，这是一个静态整形值，除去null还有其他几个，所有的类似值定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; kUndefinedValueRootIndex = &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; kTheHoleValueRootIndex = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; kNullValueRootIndex = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; kTrueValueRootIndex = &lt;span&gt;7&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; kFalseValueRootIndex = &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; kEmptyStringRootIndex = &lt;span&gt;9&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的数字就是区分这几个类型的关键所在，继续进入GetRoot方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
V8_INLINE &lt;span&gt;static&lt;/span&gt; &lt;span&gt;internal&lt;/span&gt;::Object** GetRoot(v8::Isolate* isolate,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前isolate地址并进行必要的空间指针偏移
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; static const int kIsolateRootsOffset = kExternalMemoryLimitOffset + kApiInt64Size + kApiInt64Size + kApiPointerSize + kApiPointerSize;&lt;/span&gt;
    uint8_t* addr = reinterpret_cast&amp;lt;uint8_t*&amp;gt;(isolate) +&lt;span&gt; kIsolateRootsOffset;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据上面的数字以及当前操作系统指针大小进行偏移
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; const int kApiPointerSize = sizeof(void*);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NOLINT&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; reinterpret_cast&amp;lt;&lt;span&gt;internal&lt;/span&gt;::Object**&amp;gt;(addr + index *&lt;span&gt; kApiPointerSize);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个方法就对应了标题，指针偏移。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;实际上根本不存在一个正规的null类来生成一个对应的对象，而只是把一个特定的地址当成一个null值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　敢于用这个方法，是因为对于每一个V8引擎来说isolate对象是独一无二的，所以在当前引擎下，获取到的isolate地址也是唯一的。&lt;/p&gt;
&lt;p&gt;　　如果还不明白，我这个灵魂画手会让你明白，超级简单：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201807/858904-20180716152132286-618978328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后返回一个地址，这个地址就是null，强转成Local&amp;lt;Primitive&amp;gt;也只是为了垃圾回收与类型区分，实际上并不关心这个指针指向什么，因为null本身不存在任何方法可以调用，大多数情况下也只是用来做变量重置。&lt;/p&gt;
&lt;p&gt;　　就这样，只用了很小的空间便生成了一个null值，并且每一次获取都会返回同一个值。&lt;/p&gt;

&lt;p&gt;　　验证的话就很简单了，随意的在node启动代码里加一段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
auto test = Null(env-&amp;gt;isolate());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后看局部变量的调试框，当前isolate的地址如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201807/858904-20180716153129673-157453735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第一次指针偏移后，addr的地址为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201807/858904-20180716153209859-1664163899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过简单计算，这个差值是72(16进制的48)，跟第一次偏移量大小一致，这里根本不关心指针指向什么东西，所以字符无效也没事。&lt;/p&gt;
&lt;p&gt;　　第二次偏移后，得到的null地址为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201807/858904-20180716153741099-728968025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过计算得到差值为48(16进制的30)，算一算，刚好是6*8。&lt;/p&gt;
&lt;p&gt;　　最后对这个地址进行强转，返回一个Local&amp;lt;Primitive&amp;gt;类型的null对象。&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 07:41:00 +0000</pubDate>
<dc:creator>书生小龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QH-Jimmy/p/9317297.html</dc:identifier>
</item>
<item>
<title>datatables表格行内编辑的实现 - Gaia_bing</title>
<link>http://www.cnblogs.com/GaiaBing/p/9317702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GaiaBing/p/9317702.html</guid>
<description>&lt;p&gt;Datatables是一款jquery表格插件，它是一个高度灵活的工具，灵活就意味着很多功能需要自己去实现，比如说行内编辑功能。&lt;/p&gt;
&lt;p&gt;Datatables自己是没有行内编辑功能的，最简单的是通过modal弹窗增改数据实现表格数据的修改，行内编辑我是通过操作DOM实现的，话不多说，先看效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1001539/201807/1001539-20180716142210524-1715302780.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;85&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initEditTable(){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; comboData =&lt;span&gt; {
                &lt;/span&gt;&quot;4&quot;:[&quot;是&quot;,&quot;否&quot;&lt;span&gt;],
                &lt;/span&gt;&quot;5&quot;:[&quot;ManyToOne&quot;,&quot;OneToMany&quot;,&quot;无&quot;&lt;span&gt;],
                &lt;/span&gt;&quot;6&quot;:[&quot;String&quot;,&quot;Long&quot;,&quot;Integer&quot;,&quot;Boolean&quot;,&quot;Date&quot;,&quot;当前实体&quot;&lt;span&gt;]
            };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options =&lt;span&gt; {
                id:&lt;/span&gt;&quot;myGridEdit&quot;&lt;span&gt;,
                parent:&lt;/span&gt;&quot;gridEditArea&quot;&lt;span&gt;,
                th: [&lt;/span&gt;&quot;显示名称&quot;,&quot;属性名称&quot;,&quot;可为空&quot;,&quot;关联关系&quot;,&quot;属性类型&quot;&lt;span&gt;],
                columns : [
                    {&lt;/span&gt;&quot;data&quot;: &quot;display&quot;&lt;span&gt;},
                    {&lt;/span&gt;&quot;data&quot;: &quot;name&quot;&lt;span&gt;},
                    {&lt;/span&gt;&quot;data&quot;: &quot;nullable&quot;&lt;span&gt;},
                    {&lt;/span&gt;&quot;data&quot;: &quot;relation&quot;&lt;span&gt;},
                    {&lt;/span&gt;&quot;data&quot;: &quot;type&quot;&lt;span&gt;}
                ],
                columnDefs:[{
                    &lt;/span&gt;&quot;targets&quot;: [2,3&lt;span&gt;],
                    createdCell:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(cell, cellData, rowData, rowIndex, colIndex){
                        $(cell).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                            $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).html('&amp;lt;input type=&quot;text&quot; size=&quot;16&quot;/&amp;gt;'&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; aInput = $(&lt;span&gt;this&lt;/span&gt;).find(&quot;:input&quot;&lt;span&gt;);
                            aInput.focus().val(cellData);
                        });
                        $(cell).on(&lt;/span&gt;&quot;blur&quot;,&quot;:input&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; text = $(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).val();
                            $(cell).html(text);
                            editTableObj.table.cell( cell ).data(text)
                        })
                    }
                },{
                    &lt;/span&gt;&quot;targets&quot;: [4,5,6&lt;span&gt;],
                    createdCell:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(cell, cellData, rowData, rowIndex, colIndex){
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; aInput;
                        $(cell).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                            $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).html(createCombox(comboData[colIndex]));
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; aInput = $(&lt;span&gt;this&lt;/span&gt;).find(&quot;:input&quot;&lt;span&gt;);
                            aInput.focus().val(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
                        });
                        $(cell).on(&lt;/span&gt;&quot;click&quot;,&quot;:input&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
                            e.stopPropagation();
                        });
                        $(cell).on(&lt;/span&gt;&quot;change&quot;,&quot;:input&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                            $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).blur();
                        });
                        $(cell).on(&lt;/span&gt;&quot;blur&quot;,&quot;:input&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; text = $(&lt;span&gt;this&lt;/span&gt;).find(&quot;option:selected&quot;&lt;span&gt;).text();
                            editTableObj.table.cell( cell ).data(text)
                        });
                    }
                }],
                data:[],
                ordering:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                paging:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                info:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
            };
            editTableObj &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; fmcpTables(options);
        }

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createCombox(data){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _html = '&amp;lt;select style=&quot;width:100px;&quot;&amp;gt;'&lt;span&gt;;
            data.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ele,index){
                _html&lt;/span&gt;+='&amp;lt;option&amp;gt;'+ele+'&amp;lt;/option&amp;gt;'&lt;span&gt;;
            });
            _html&lt;/span&gt;+='&amp;lt;/select&amp;gt;'&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _html;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面js代码并不完整，&lt;span&gt;fmcpTables&lt;/span&gt;是我封装的生成表格的对象，&lt;span&gt;重点是&lt;/span&gt;&lt;span&gt;columnDefs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官网上的说明是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;和 &lt;a href=&quot;http://www.datatables.club/reference/option/columns.html&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;option&quot;&gt;columnsOption&lt;/code&gt; &lt;/a&gt;参数很像，这个参数允许你给指定列设置选项，应用到一个或这多个列。而不像 &lt;a href=&quot;http://www.datatables.club/reference/option/columns.html&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;option&quot;&gt;columnsOption&lt;/code&gt; &lt;/a&gt;需要每列都要定义&lt;/p&gt;
&lt;p&gt;这个参数是一个列定义对象数组，通过使用 &lt;a href=&quot;http://www.datatables.club/reference/option/columnDefs.targets.html&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;columnDefs.targets&lt;/code&gt; &lt;/a&gt;选项，告诉Datatables是定义的是那一列，他可以是下列情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0或者正整数-列从左到右是从0开始&lt;/li&gt;
&lt;li&gt;一个负数-列从右到左的索引(-1代表最后一列)&lt;/li&gt;
&lt;li&gt;一个字符串-将字符串和类名匹配列&lt;/li&gt;
&lt;li&gt;字符串&quot;_all&quot;-所有列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;另外， &lt;code&gt;targets&lt;/code&gt;可以同时指定多列，接受一个数组（比如 &lt;code&gt;targets: [ -1, -2 ]&lt;/code&gt; ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;createCell可以操作指定的DOM，它的五个参数分别是：td节点，单元格里的数据，正行的数据对象，单元格的行索引，单元格的列索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为序号列和单选占据了0和1所以从2开始，target为2和3的编辑形式是text，target为4/5/6的编辑形式是select，其他的编辑形式也可以。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;text形式的是点击单元格的时候出现文本框并且手动让其得焦，失去焦点的时候改变单元格的数据，这个很容易理解，唯一要注意的是，改变单元格数据的时候不能直接操作dom，那样的话只是修改了页面中节点内容，获取表格数据的时候会发现表格数据还是没有变化。修改单元格的数据要用到&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;table&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;cell&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;k&quot;&gt;&lt;span class=&quot;p&quot;&gt;).&lt;span class=&quot;nx&quot;&gt;data&lt;span class=&quot;p&quot;&gt;()&lt;span&gt;这个方法，可以获取和修改单元格的数据，cell的参数是要操作的单元格的dom节点，data不传参数是获取数据，传入参数是修改数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;k&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span&gt;select形式遇到了一个坑，就是在点击单元格出现select下拉框后，发现下拉不下来，后来发现是因为点击select下拉框的时候触发了事件冒泡，导致又执行了一遍点击单元格的事件，所以select又重新生成了一遍导致展不开。所以给select的点击事件里加了阻止事件冒泡 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;e.stopPropagation()。另外本来打算点击单元格的时候出现下拉框并且自动展开，选择一项后select消失并且把数据放进去，结果发现select标签貌似不支持js展开，看了下其它网上的例子都是自己用div模拟的select来展开的，退而求其次就点击单元格后再次手动点击select让它展开，以后有需求再用模拟的方式修改。&lt;/p&gt;
&lt;p&gt;Datatables确实功能很多，自由度非常高，但是文档很分散，以后要多多整理才能熟练起来。&lt;/p&gt;
&lt;p&gt;最后附一下Datatables中文网链接：&lt;a href=&quot;http://www.datatables.club/&quot; target=&quot;_blank&quot;&gt;http://www.datatables.club/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 16 Jul 2018 07:05:00 +0000</pubDate>
<dc:creator>Gaia_bing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GaiaBing/p/9317702.html</dc:identifier>
</item>
<item>
<title>localStorage/cookie 用法分析与简单封装 - 杨小匠</title>
<link>http://www.cnblogs.com/yangshifu/p/9301388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangshifu/p/9301388.html</guid>
<description>&lt;p&gt;　　本地存储是HTML5中提出来的概念，分localStorage和sessionStorage。通过本地存储，web应用程序能够在用户浏览器中对数据进行本地的存储。与 cookie 不同，存储限制要大得多（至少5MB），并且信息不会被传输到服务器。&lt;/p&gt;

&lt;h3&gt;什么时候用本地存储？&lt;/h3&gt;
&lt;p&gt;　　跨期：不同时间打开页面，比如这次登录需要用到上次登录时保存的数据。&lt;/p&gt;
&lt;p&gt;　　跨页：在同一个浏览器打开同域的多个标签页，它们之间需要互通数据。&lt;/p&gt;

&lt;h3&gt;选用哪种存储方式？&lt;/h3&gt;
&lt;p&gt;　　最简单的数据保存方式就是在js里定义变量并赋值，这不属于本地存储的范畴，但大多数情况下这样做就够了。&lt;/p&gt;
&lt;p&gt;　　cookie的适用场景：数据量小；数据需要随http请求传递到服务端；存储有具体时限的数据；低版本浏览器，不支持localStorage和sessionStorage时。&lt;/p&gt;
&lt;p&gt;　　localStorage的使用场景：数据大于4k；需要跨标签页使用数据；长期存储数据；&lt;/p&gt;
&lt;p&gt;　　sessionStorage的适用场景：数据只在本次会话有效；数据仅在当前标签页有效。sessionStorage对比直接js赋值变量的优势，是可以在同页面跨iframe使用。&lt;/p&gt;
&lt;p&gt;　　浏览器自身会缓存img、js、css等数据，localStorage也可以起到类似作用。&lt;/p&gt;

&lt;h3&gt;整理本地存储方法&lt;/h3&gt;
&lt;p&gt;　　基于localStorage制作一个本地存储插件storage.js，针对只能存字符串、不能设置时限等进行补充，设想：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在不支持localStorage时自动使用cookie&lt;/li&gt;
&lt;li&gt;类型转换，可存储数字、布尔、对象等&lt;/li&gt;
&lt;li&gt;可设置时限，超时就自我删除&lt;/li&gt;
&lt;li&gt;附带整理cookie方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　用法展示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
    /** setItem( key, value, time)
     *  key：  键名，字符串
     *  value：键值，可以是Stirng/Boolean/Number/Object等类型
     *  time： 超时时间，非必填，数字型（单位毫秒）。默认长期有效。
     **/
    storage.setItem(&quot;text&quot;, &quot;this is string&quot;);
    storage.setItem(&quot;money&quot;, 1234);
    storage.setItem(&quot;person&quot;, {name: &quot;Jone&quot;}, 24*60*60*1000);

    // getItem 获取值
    storage.getItem(&quot;money&quot;); //返回数字类型的值1234

    // removeItem 删除某数据
    storage.removeItem(&quot;money&quot;);

    // clear 清除所有数据
    storage.clear();

    // 类似方法，操作cookie，只限于存储字符串
    storage.setCookie(&quot;mycookie&quot;, &quot;this is string&quot;, 60*60*24*30);
    storage.getCookie(&quot;mycookie&quot;);
    storage.removeCookie(&quot;mycookie&quot;);
    storage.clearCookie();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　storage.js ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
(function(window) {
    var storage = {};

    // 是否支持localStorage
    if (!window.localStorage) {
        storage.support = false;
    } else {
        storage.support = true;
    }

    // time为超时时间（单位毫秒），非必填
    storage.setItem = function(key, value, time) {
        if (this.support) {
            if (typeof key != &quot;string&quot;) {
                console.log(&quot;*STORAGE ERROR* key必须是字符串&quot;);
                return;
            }
            if (time) {
                if (typeof time != &quot;number&quot;) {
                    console.log(&quot;*STORAGE ERROR* time必须是数字&quot;);
                    return;
                } else {
                    time = parseInt(time) + (new Date()).getTime();
                }
            } else {
                time = null;
            }
            var setValue = {
                value: JSON.stringify(value),
                time: time
            }
            localStorage.setItem(key, JSON.stringify(setValue));
        } else {
            storage.setCookie(key, value, time)
        }
    };

    // 不存在的值会返回null
    storage.getItem = function(key) {
        if (this.support) {
            var getValue = JSON.parse(localStorage.getItem(key));
            if (!getValue) {
                return null;
            }
            if (getValue.time &amp;amp;&amp;amp; getValue.time &amp;lt; (new Date()).getTime()) {
                localStorage.removeItem(key);
                return null;
            } else {
                return JSON.parse(getValue.value)
            }
        } else {
            storage.getCookie(key)
        }
    };

    // 移除某个值
    storage.removeItem = function(key) {
        if (this.support) {
            localStorage.removeItem(key);
        } else {
            storage.removeCookie(key)
        }
    };
    // 清空存储
    storage.clear = function() {
        if (this.support) {
            localStorage.clear();
        } else {
            storage.clearCookie();
        }
    };

        /**** cookie方法 ****/
    storage.setCookie = function(key, value, time) {
        if (typeof key != &quot;string&quot;) {
            console.log(&quot;*STORAGE ERROR* key必须是字符串&quot;);
            return;
        } else {
            if (typeof time != &quot;number&quot;) {
                // cookie默认存365天
                time = 365 * 24 * 60 * 60 * 1000;
            }
            var d = new Date();
            d.setTime(d.getTime() + time);
            document.cookie = key + &quot;=&quot; + value + &quot;; expires=&quot; + d.toGMTString();
        }
    };
    storage.getCookie = function(key) {
        var cookies = document.cookie.split(&quot;;&quot;)
        var cookieValue;
        for (var i = 0; i &amp;lt; cookies.length; i++) {
            if (key == cookies[i].split(&quot;=&quot;)[0]) {
                cookieValue = cookies[i].split(&quot;=&quot;)[1];
                break;
            }
        }
        return cookieValue;
    };
    storage.removeCookie = function(key) {
        document.cookie = key + &quot;=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;;
    };
    storage.clearCookie = function() {
        var cookies = document.cookie.split(&quot;;&quot;)
        for (var i = 0; i &amp;lt; cookies.length; i++) {
            document.cookie = cookies[i].split(&quot;=&quot;)[0] + &quot;=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;;
        }
    };

    window.storage = storage;
})(window)
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Mon, 16 Jul 2018 06:59:00 +0000</pubDate>
<dc:creator>杨小匠</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangshifu/p/9301388.html</dc:identifier>
</item>
<item>
<title>微服务实战(二)：落地微服务架构到直销系统(构建消息总线框架接口) - 曹剑</title>
<link>http://www.cnblogs.com/malaoko/p/9316070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/malaoko/p/9316070.html</guid>
<description>&lt;p&gt;从上一篇文章大家可以看出，实现一个自己的消息总线框架是非常重要的内容，消息总线可以将界限上下文之间进行解耦，也可以为大并发访问提供必要的支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/56104/201807/56104-20180716091044110-1745491571.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;消息总线的作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.界限上下文解耦：在DDD第一波文章中，当更新了订单信息后，我们通过调用经销商界限上下文的领域模型和仓储，进行了经销商信息的更新，这造成了耦合。通过一个消息总线，可以在订单界限上下文的WebApi服务(来源微服务-生产者)更新了订单信息后，发布一个事件消息到消息总线的某个队列中，经销商界限上下文的WebApi服务(消费者)订阅这个事件消息，然后交给自己的Handler进行消息处理，更新自己的经销商信息。这样就实现了订单界限上下文与经销商界限上下文解耦。&lt;/p&gt;
&lt;p&gt;2.大并发支持：可以通过消息总线进一步提升下单的性能。我们可以将用户下单的操作直接交给一个下单命令WebApi接收，下单命令WebApi接收到命令后，直接丢给一个消息总线的队列，然后立即给前端返回下单结果。这样用户就不用等待后续的复杂订单业务逻辑，加快速度。后续订单的一系列处理交给消息的Handler进行后续的处理与消息的进一步投递。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;消息总线设计重点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.定义消息(事件)的接口：所有需要投递与处理的消息，都从这个消息接口继承，因为需要约束消息中必须包含的内容，比如消息的ID、消息产生的时间等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IEvent
    {
        Guid Id { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        DateTime CreateDate { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.定义消息(事件)处理器接口：当消息投递到消息总线队列中后，一定有消费者WebApi接收并处理这个消息，具体的处理方法逻辑在订阅方处理器中实现，这里先需要定义处理器的接口，便于在消息总线框架中使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IEventHandler
    {
        Task&lt;/span&gt;&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt; HandleAsync&amp;lt;TEvent&amp;gt;(TEvent @event) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEvent : IEvent;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面代码可以看出，消息(事件)处理器处理的类型就是从IEvent接口继承的消息类。&lt;/p&gt;
&lt;p&gt;3.定义消息(事件)与消息(事件)处理器关联接口：一种类型的消息被投递后，一定要在订阅方找到这种消息的处理器进行处理，所以一定要定义二者的关联接口，这样才能将消息与消息处理器对应起来，才能实现消息被订阅后的处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IEventHandlerExecutionContext
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; RegisterEventHandler&amp;lt;TEvent, TEventHandler&amp;gt;() &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEvent : IEvent
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEventHandler : IEventHandler;
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; IsRegisterEventHandler&amp;lt;TEvent, TEventHandler&amp;gt;() &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEvent : IEvent
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEventHandler : IEventHandler;
        Task HandleAsync&lt;/span&gt;&amp;lt;TEvent&amp;gt;(TEvent @event) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEvent : IEvent;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RegisterEventHandler方法就是建立消息与消息处理器的关联，这个方法其实是在订阅方使用，订阅方告诉消息总线，什么样的消息应该交给我的哪个处理器进行处理。&lt;/p&gt;
&lt;p&gt;IsRegisterEventHandler方法是判断消息与处理器之间是否已经存在关联。&lt;/p&gt;
&lt;p&gt;HandleAsync方法是通过查找到消息对应的处理器后，然后调用处理器自己的Handle方法进行消息的处理.&lt;/p&gt;
&lt;p&gt;4.定义消息发布、订阅与消息总线接口：消息总线至少要支持两个功能，一个是生产者能够发布消息到我的消息总线，另一个是订阅方需要能够从我这个消息总线订阅消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IEventPublisher
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Publish&amp;lt;TEvent&amp;gt;(TEvent @event) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEvent : IEvent;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面代码可以看出，生产者发布的消息仍然要从IEvent继承的类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IEventSubscriber
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Subscribe&amp;lt;TEvent, TEventHandler&amp;gt;() &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEvent : IEvent
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEventHandler : IEventHandler;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码是订阅方用于从消息总线订阅消息，从代码中可以看出，它的最终的实现其实就是建立消息与处理器之间的关联。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IEventBus:IEventPublisher,IEventSubscriber
    {
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;消息(事件)总线从两个接口继承下来，同时支持消息的发布与消息的订阅。&lt;/p&gt;
&lt;p&gt;5.实现事件基类：上面已经订阅了消息(事件)的接口，这里来实现事件的基类，其实就是实现消息ID与产生的时间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEvent : IEvent
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime CreateDate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseEvent()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Id =&lt;span&gt; Guid.NewGuid();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CreateDate =&lt;span&gt; DateTime.Now;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.实现消息总线基类：消息总线底层的依赖可以是各种消息代理产品，比如RabbitMq、Kafaka或第三方云平台提供的消息代理产品，通常我们要封装这些消息代理产品。在封装之前，我们需要定义顶层的消息总线基类实现，主要的目的是未来依赖于它的具体实现可替换，另外也将消息与消息处理器的关联接口传递进来，便于订阅方使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEventBus : IEventBus
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IEventHandlerExecutionContext eventHandlerExecutionContext;
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; BaseEventBus(IEventHandlerExecutionContext eventHandlerExecutionContext)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eventHandlerExecutionContext =&lt;span&gt; eventHandlerExecutionContext;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Publish&amp;lt;TEvent&amp;gt;&lt;span&gt;(TEvent @event)
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEvent : IEvent;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Subscribe&amp;lt;TEvent, TEventHandler&amp;gt;&lt;span&gt;()
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEvent : IEvent
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEventHandler : IEventHandler;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.实现消息与处理器关联：消息必须与处理器关联，订阅方收到特定类型的消息后，才知道交给哪个处理器处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EventHandlerExecutionContext : IEventHandlerExecutionContext
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IServiceCollection registry;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IServiceProvider serviceprovider;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Dictionary&amp;lt;Type, List&amp;lt;Type&amp;gt;&amp;gt; registrations = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;Type, List&amp;lt;Type&amp;gt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; EventHandlerExecutionContext(IServiceCollection registry,Func&amp;lt;&lt;span&gt;IServiceCollection,
            IServiceProvider&lt;/span&gt;&amp;gt; serviceProviderFactory = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.registry =&lt;span&gt; registry;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.serviceprovider = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registry.BuildServiceProvider();
        }

       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找消息关联的处理器，然后调用处理器的处理方法&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task HandleAsync&amp;lt;TEvent&amp;gt;(TEvent @event) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEvent : IEvent
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; eventtype =&lt;span&gt; @event.GetType();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(registrations.TryGetValue(eventtype,&lt;span&gt;out&lt;/span&gt; List&amp;lt;Type&amp;gt; handlertypes) &amp;amp;&amp;amp; handlertypes.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; childscope = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serviceprovider.CreateScope())
                {
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; handlertype &lt;span&gt;in&lt;/span&gt;&lt;span&gt; handlertypes)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handler = Activator.CreateInstance(handlertype) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IEventHandler;
                        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; handler.HandleAsync(@event);
                    }
                }
            }
        }

       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断消息与处理器之间是否有关联&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsRegisterEventHandler&amp;lt;TEvent, TEventHandler&amp;gt;&lt;span&gt;()
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEvent : IEvent
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEventHandler : IEventHandler
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(registrations.TryGetValue(&lt;span&gt;typeof&lt;/span&gt;(TEvent),&lt;span&gt;out&lt;/span&gt; List&amp;lt;Type&amp;gt;&lt;span&gt; handlertypelist))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; handlertypelist != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; handlertypelist.Contains(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IEventHandler));
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
       
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将消息与处理器关联起来，可以在内存中建立关联，也可以建立在数据库单独表中&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RegisterEventHandler&amp;lt;TEvent, TEventHandler&amp;gt;&lt;span&gt;()
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEvent : IEvent
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; TEventHandler : IEventHandler
        {
            Utils.DictionaryRegister(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(TEvent), &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TEventHandler), registrations);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面我们基本上就将消息总线的架子搭建起来了，也实现了基本的功能，下一章我们基于它来实现RabbitMq的消息总线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QQ讨论群：309287205 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务实战视频请关注微信公众号：&lt;/strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/56104/201804/56104-20180404152324246-1012833899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 16 Jul 2018 03:58:00 +0000</pubDate>
<dc:creator>曹剑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/malaoko/p/9316070.html</dc:identifier>
</item>
<item>
<title>Apache Pulsar简介 - 杭州.Mark</title>
<link>http://www.cnblogs.com/hzmark/p/pulsar.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hzmark/p/pulsar.html</guid>
<description>&lt;h2 id=&quot;toc_0&quot;&gt;Apache Pulsar&lt;/h2&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;What is Pulsar&lt;/h3&gt;
&lt;p&gt;&quot;Pulsar is a distributed pub-sub messaging platform with a very flexible messaging model and an intuitive client API.&quot;&lt;/p&gt;
&lt;p&gt;Pulsar是pub-sub模式的分布式消息平台，拥有灵活的消息模型和直观的客户端API。&lt;/p&gt;
&lt;p&gt;Pulsar由雅虎开发并开源的下一代消息系统，目前是Apache软件基金会的孵化器项目。&lt;/p&gt;
&lt;h4 id=&quot;toc_2&quot;&gt;概念&lt;/h4&gt;
&lt;h5 id=&quot;toc_3&quot;&gt;Topic&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471426/201807/471426-20180714162808830-2052924543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Topic是Pulsar的核心概念，表示一个“channel”，Producer可以写入数据，Consumer从中消费数据（Kafka、RocketMQ都是这样）。&lt;/p&gt;
&lt;p&gt;Topic名称的URL类似如下的结构：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-none&quot;&gt;{persistent|non-persistent}://tenant/namespace/topic&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;persistent|non-persistent表示数据是否持久化（Pulsar支持消息持久化和非持久化两种模式）&lt;/li&gt;
&lt;li&gt;Tenant为租户&lt;/li&gt;
&lt;li&gt;Namespace一般聚合一系列相关的Topic，一个租户下可以有多个Namespace&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;toc_4&quot;&gt;租户和Namespace&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471426/201807/471426-20180714162820262-1813573242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中Property即为租户，每个租户下可以有多个Namespace，每个Namespace下有多个Topic。&lt;/p&gt;
&lt;p&gt;Namespace是Pulsar中的操作单元，包括Topic是配置在Namespace级别的，包括多地域复制，消息过期策略等都是配置在Namespace上的。&lt;/p&gt;
&lt;h5 id=&quot;toc_5&quot;&gt;订阅模型&lt;/h5&gt;
&lt;p&gt;Pulsar提供了灵活的消息模型，支持三种订阅类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Exclusive subscription：排他的，只能有一个Consumer，接收一个Topic所有的消息&lt;/li&gt;
&lt;li&gt;Shared subscription：共享的，可以同时存在多个Consumer，每个Consumer处理Topic中一部消息（Shared模型是不保证消息顺序的，Consumer数量可以超过分区的数量）&lt;/li&gt;
&lt;li&gt;Failover subscription：Failover模式，同一时刻只有一个有效的Consumer，其余的Consumer作为备用节点，在Master Consumer不可用后进行替代（看起来适用于数据量小，且解决单点故障的场景）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471426/201807/471426-20180714162833476-634182507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;toc_6&quot;&gt;分区&lt;/h5&gt;
&lt;p&gt;为了解决吞吐等问题，Pulsar和Kafka一样，采用了分区（Partition）的机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471426/201807/471426-20180714162843060-675502339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Pulsar提供了一些策略来处理消息到Partition的路由（MessageRouter）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Single partitioning：Producer随机选择一个Partition并将所有消息写入到这个分区&lt;/li&gt;
&lt;li&gt;Round robin partitioning ：采用Round robin的方式，轮训所有分区进行消息写入&lt;/li&gt;
&lt;li&gt;Hash partitioning：这种模式每条消息有一个Key，Producer根据消息的Key的哈希值进行分区的选择（Key相同的消息可以保证顺序）。&lt;/li&gt;
&lt;li&gt;Custom partitioning：用户自定义路由策略&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同于别的MQ系统，Pulsar允许Consumer的数量超过分区的数量（对于RocketMQ，超过分区数的Consumer会分配不到分区而“空跑”）。&lt;/p&gt;
&lt;p&gt;在Shared subscription的订阅模式下，Consumer数量可以大于分区的数量，每个Consumer处理每个Partition中的一部分消息，不保证消息的顺序。&lt;/p&gt;
&lt;h5 id=&quot;toc_7&quot;&gt;持久化&lt;/h5&gt;
&lt;p&gt;Pulsar通过BookKeeper来存储消息，保证消息不会丢失（BookKeeper：A scalable, fault-tolerant, and low-latency storage service optimized for real-time workloads）。&lt;/p&gt;
&lt;h4 id=&quot;toc_8&quot;&gt;架构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471426/201807/471426-20180714162901299-1229896903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Pulsar采用“存储和服务分离”的两层架构（这是Pulsar区别于其他MQ系统最重要的一点，也是所谓的“下一代消息系统”的核心）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Broker：提供发布和订阅的服务（Pulsar的组件）&lt;/li&gt;
&lt;li&gt;Bookie：提供存储能力（BookKeeper的存储组件）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优势是Broker成为了stateless的组件，可以水平扩容（RocketMQ的Broker是包含存储的，是有状态的，Broker的扩容更像是“拆分”）。高可靠，一致性等通过BookKeeper去保证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471426/201807/471426-20180714162914825-1931786340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是Pulsar Cluster的架构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;采用ZooKeeper存储元数据，集群配置，作为coordination
&lt;ul&gt;&lt;li&gt;local zk负责Pulsar Cluster内部的配置等&lt;/li&gt;
&lt;li&gt;global zk则用于Pulsar Cluster之间的数据复制等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;采用Bookie作为存储设备(大多数MQ系统都采用本地磁盘或者DB作为存储设备)&lt;/li&gt;
&lt;li&gt;Broker负责负载均衡和消息的读取、写入等&lt;/li&gt;
&lt;li&gt;Global replicators负责集群间的数据复制&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;toc_9&quot;&gt;GEO-REPLICATOIN&lt;/h5&gt;
&lt;p&gt;多个Broker节点组成一个Pulsar Cluster；多个Pulsar Cluster组成一个Pulsar Instance。&lt;/p&gt;
&lt;p&gt;Pulsar通过GEO-REPLICATION支持一个Instance内在不同的地域发送和消费消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471426/201807/471426-20180714162930672-330316037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，Producer P1、P2、P3在不同的Cluster发送给Topic T1的消息，会在Cluster之间进行复制，Consumer C1、C2可以在自己所在的Cluster消费到所有的消息。&lt;/p&gt;
&lt;p&gt;当消息被写入Pulsar时，首先消息被持久化在local cluster，之后异步的发送到其他cluster。在没有链接问题的情况下，通常复制的latency相近于网络的RTT。&lt;/p&gt;
&lt;h3 id=&quot;toc_10&quot;&gt;Pulsar的应用&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471426/201807/471426-20180714162945365-757032197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作为普通的Pub-Sub模型的消息队列使用，类似于RocketMQ&lt;/li&gt;
&lt;li&gt;支持Function（Stream），整合到Stream平台&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;toc_11&quot;&gt;Pulsar VS RocketMQ&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; &lt;/th&gt;
&lt;th&gt;RocketMQ&lt;/th&gt;
&lt;th&gt;Pulsar&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;架构&lt;/td&gt;
&lt;td&gt;单层架构，Broker服务也负责存储&lt;/td&gt;
&lt;td&gt;存储和服务分离，Broker负责提供服务，BookKeeper提供存储能力&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;存储&lt;/td&gt;
&lt;td&gt;Master-Slave结构&lt;/td&gt;
&lt;td&gt;BookKeeper，高可用存储&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;多域部署&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;GEO-REPLICATION&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;订阅模式&lt;/td&gt;
&lt;td&gt;集群消费、广播消费&lt;/td&gt;
&lt;td&gt;Exclusive、Shared、Failover三种模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Stream&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ACK&lt;/td&gt;
&lt;td&gt;cumulative ack&lt;/td&gt;
&lt;td&gt;individual &amp;amp; cumulative ack&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;顺序消息&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;事务消息&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;二级消息&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;定时消息&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;toc_12&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;主要是简单的介绍了Pulsar的概念和架构，最重要的是去理解“存储和服务”分离的两层架构。之后和Rocket进行了对比，RocketMQ提供了更多消息领域的能力比比如事务消息、定时消息等等，而Pulsar在Streaming方便做的更好一些。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471426/201807/471426-20180714163005084-2070683510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/hzmark/公众号名片.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 02:30:00 +0000</pubDate>
<dc:creator>杭州.Mark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hzmark/p/pulsar.html</dc:identifier>
</item>
<item>
<title>SpringCloud之服务注册 - Mr.chengJQ</title>
<link>http://www.cnblogs.com/qiyuan880794/p/9315934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiyuan880794/p/9315934.html</guid>
<description>&lt;p&gt;类似于DUBBO 的zookeeper, SpringCloud本身提供一套服务注册中心--eureka&lt;/p&gt;
&lt;p&gt;与zookeeper的区别在于&lt;/p&gt;
&lt;p&gt;1：zookeeper本身就是一个应用，安装即可用；eureka其实是一个jar，需要新建一个maven项目，以及手动配置端口和pom文件。发布后即可使用&lt;/p&gt;
&lt;p&gt;2：zookeeper本身不提供web端展示，需要重新安装配置dubbo客户端或者dubbokeeper实时监控服务；eureka发布成功后，即可有对应的spring 服务监控页面。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;搭建SpringCloud的服务注册中心-eureka&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.新建maven项目eureka-server，eureka-server是作为一个子项目，目录结构如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1106775/201807/1106775-20180716084940513-1843720405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;eureka-server还是比较简单的，主要需要修改这三个文件：EurekaServerApplication,application.yml,pom.xml&lt;/p&gt;
&lt;p&gt;1.pom.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;properties&amp;gt;
         &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
         &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
         &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
     &amp;lt;/properties&amp;gt;
 
     &amp;lt;dependencies&amp;gt;
         &amp;lt;!--eureka server --&amp;gt;
         &amp;lt;dependency&amp;gt;
             &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
         &amp;lt;/dependency&amp;gt;
         &amp;lt;dependency&amp;gt;
             &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt;
         &amp;lt;/dependency&amp;gt;
         &amp;lt;!-- spring boot test--&amp;gt;
         &amp;lt;dependency&amp;gt;
             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
             &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
         &amp;lt;/dependency&amp;gt;
     &amp;lt;/dependencies&amp;gt;

     &amp;lt;dependencyManagement&amp;gt;
         &amp;lt;dependencies&amp;gt;
             &amp;lt;dependency&amp;gt;
                 &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                 &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                 &amp;lt;version&amp;gt;Dalston.RC1&amp;lt;/version&amp;gt;
                 &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                 &amp;lt;scope&amp;gt;&lt;span&gt;import&lt;/span&gt;&amp;lt;/scope&amp;gt;
             &amp;lt;/dependency&amp;gt;
         &amp;lt;/dependencies&amp;gt;
     &amp;lt;/dependencyManagement&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
spring-cloud-starter-eureka-server:erueka注册中心核心依赖包&lt;br/&gt;当然，作为一个springboot项目，需要依赖于：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;parent&amp;gt;
         &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;1.5.3.RELEASE&amp;lt;/version&amp;gt;
         &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
  &amp;lt;/parent&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有的子项目都是springcoot项目，所以该依赖放在了父项目的pom中&lt;/p&gt;
&lt;p&gt;2.application.yml&lt;/p&gt;
&lt;p&gt;springboot启动时，会自动扫描该配置文件，当然，application.properties也是可以的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; server:
    port: &lt;/span&gt;8761&lt;span&gt;
 
 eureka:
    instance:
        hostname: localhost
    client:
        registerWithEureka: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        fetchRegistry: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        serviceUrl:
            defaultZone: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;${eureka.instance.hostname}:${server.port}/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中：server.port:定义端口号&lt;/p&gt;
&lt;p&gt;　       eureka.instance.hostname:定义eureka为本地ip，发布测试或者线上环境视情况配置&lt;/p&gt;
&lt;p&gt;　　　eureka.client.registerWithEureka:是否注册本身，这里不需要。所以为false&lt;/p&gt;
&lt;p&gt;           eureka.client.fetchRegister:是否从服务器获取注册信息，这里也不需要&lt;/p&gt;
&lt;p&gt;           eureka.client.serviceUrl.defaultZone:定义服务注册地址，后续的提供或者消费都需要通过该地址进行注册&lt;/p&gt;
&lt;p&gt;3.EurekaServerApplication.java&lt;/p&gt;
&lt;p&gt;springboot启动文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@EnableEurekaServer
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EurekaServerApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(EurekaServerApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@EnableEurekaServer：表明他是服务注册中心&lt;/p&gt;
&lt;p&gt;@SpringBootApplication：表明他是springboot项目&lt;/p&gt;

&lt;p&gt;最后：启动该项目，就可以了&lt;/p&gt;
&lt;p&gt;浏览器打开：http://localhost:8761/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1106775/201807/1106775-20180716092908329-1371950921.png&quot; alt=&quot;&quot; width=&quot;991&quot; height=&quot;449&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从中可以看出，eureka服务注册中心已经启动成功。只是目前的application中没有任何内容，当然，我们只是搞定了这个注册中心，还没有任何的服务呢&lt;/p&gt;
&lt;p&gt;下面，我们来尝试写一个服务，同时注册到该注册中心&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注册服务eureka-client&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先，还是来看下这个项目eureka-client的结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1106775/201807/1106775-20180716094727369-463654795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是修改这三个文件：EurekaClientApplication,application.yml,pom.xml（所有的springboot项目，这三个文件也是最基本的，缺一不可）&lt;/p&gt;
&lt;p&gt;1.pom.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;dependencies&amp;gt;
         &amp;lt;dependency&amp;gt;
             &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
         &amp;lt;/dependency&amp;gt;
         &amp;lt;dependency&amp;gt;
             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
         &amp;lt;/dependency&amp;gt;
 
         &amp;lt;dependency&amp;gt;
             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
             &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
         &amp;lt;/dependency&amp;gt;
     &amp;lt;/dependencies&amp;gt;
 
     &amp;lt;dependencyManagement&amp;gt;
         &amp;lt;dependencies&amp;gt;
             &amp;lt;dependency&amp;gt;
                 &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                 &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                 &amp;lt;version&amp;gt;Dalston.RC1&amp;lt;/version&amp;gt;
                 &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                 &amp;lt;scope&amp;gt;&lt;span&gt;import&lt;/span&gt;&amp;lt;/scope&amp;gt;
             &amp;lt;/dependency&amp;gt;
         &amp;lt;/dependencies&amp;gt;
     &amp;lt;/dependencyManagement&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.application.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;eureka:
    client:
         serviceUrl:
             defaultZone: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8761/eureka/&lt;/span&gt;
&lt;span&gt;server:
     port: &lt;/span&gt;8762&lt;span&gt;
spring:
     application:
         name: eureka&lt;/span&gt;-client
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;eureka.client.serviceUrl.defaultZone:与eureka-server中的配置文件配置一样就行了&lt;/p&gt;
&lt;p&gt;server.port:定义端口号&lt;/p&gt;
&lt;p&gt;spring.application.name:定义项目名，方便在注册中心查看&lt;/p&gt;
&lt;p&gt;3.EurekaClientApplication.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableEurekaClient
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EurekaClientApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(EurekaClientApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

    @Value(&lt;/span&gt;&quot;${server.port}&quot;&lt;span&gt;)
    String port;

    @RequestMapping(&lt;/span&gt;&quot;/&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String home() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello world from port &quot; +&lt;span&gt; port;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@EnableEurekaClient:同意注册到注册中心&lt;/p&gt;

&lt;p&gt;再启动eureka-client 后，会发现如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1106775/201807/1106775-20180716101347382-1018849353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;eureka-client已经注册成功&lt;/p&gt;
&lt;p&gt;直接输入：http://localhost:8762/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1106775/201807/1106775-20180716101610570-1922659663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，基础的服务注册中心搭建成功，有问题希望大家多提意见，谢谢！&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 02:17:00 +0000</pubDate>
<dc:creator>Mr.chengJQ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiyuan880794/p/9315934.html</dc:identifier>
</item>
<item>
<title>本地IDC机房数据库容灾解决方案 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/9316273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/9316273.html</guid>
<description>&lt;p&gt;&lt;strong&gt;欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.5079365079365&quot;&gt;
&lt;p&gt;本文由&lt;a href=&quot;https://cloud.tencent.com/developer/user/1002332?fromSource=waitui&quot;&gt;腾讯云数据库 TencentDB&lt;/a&gt; 发表于&lt;a href=&quot;https://cloud.tencent.com/developer/column/1551?fromSource=waitui&quot;&gt;云+社区专栏&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者介绍：李明，腾讯云数据库架构师华南区负责人，曾在某专业数据库服务商、51job任职DBA。&lt;/p&gt;

&lt;p&gt;​ 风险无处不在，包括自然灾害以及突发事件等，有时候我们无法预测到一些风险，比如天津港爆炸事件。IT领域也一样，总是有意想不到的事情，风险具有不可预测性，万全之策就是做好灾难应对的各种准备。&lt;/p&gt;
&lt;p&gt;​ 随着云计算如火如茶的进行，IT资源可进行快速部署，弹性扩容及超高的性价比，这对于我们创建本地IDC机房数据库容灾提供极大的便利性。如何利用云数据库做容灾成为DBA的基本功。&lt;/p&gt;
&lt;p&gt;当前腾讯云已对外提供的腾讯云数据库（TencentDB）产品：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关系型数据库：云数据库 MySQL、云数据库 MariaDB、云数据库 SQL Server、云数据库 PostgreSQL&lt;/li&gt;
&lt;li&gt;云数据库 Redis&lt;/li&gt;
&lt;li&gt;云数据库 MongoDB&lt;/li&gt;
&lt;li&gt;分布式数据库&lt;/li&gt;
&lt;li&gt;云数据库 Memcached&lt;/li&gt;
&lt;li&gt;云数据库 HBase&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​ 下文以腾讯云数据库 MySQL为例，介绍如何充分利用腾讯云的优势，减轻DBA的负担，轻松来搭建数据库（MySQL）的：同城同区灾备、同城不同区灾备、跨地域灾备。&lt;/p&gt;

&lt;p&gt;​ 针对业务连续服务和数据可靠性有强需求或是监管需要的场景，用户在购买云数据库 MySQL 时会默认提供灾备实例，帮助用户以较低的成本提升业务连续服务的能力，同时提升数据的可靠性。&lt;/p&gt;
&lt;h2 id=&quot;同地域同可用区部署&quot;&gt;同地域同可用区部署&lt;/h2&gt;
&lt;p&gt;​ 云数据库 MySQL同可用区部署架构示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1002332/voiaseou0k.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;云数据库MySQL 普通实例架构(同个可用区)&lt;/p&gt;
&lt;h2 id=&quot;同地域不同可用区部署&quot;&gt;同地域不同可用区部署&lt;/h2&gt;
&lt;p&gt;​ 云数据库 MySQL 同城灾备实例架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1002332/4wrr9yiivo.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;云数据库 MySQL 同城灾备实例架构（不同可用区）&lt;/p&gt;
&lt;p&gt;​ 说明：腾讯云数据库多可用区部署目前仅支持深圳金融专区，其他可用区的支持还在规划中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1002332/ro3uw0muuk.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;跨地域部署&quot;&gt;跨地域部署&lt;/h2&gt;
&lt;p&gt;​ 云数据库 MySQL 异地灾备实例架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1002332/wm18uhvi14.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;云数据库 MySQL 异地灾备实例架构&lt;/p&gt;

&lt;p&gt;​ 通过上面的介绍，我们基本了解云数据库 MySQL的架构，接下来我们来说说本地IDC的数据库怎么迁移到TencentDB上并建立同步关系。&lt;/p&gt;
&lt;p&gt;第一步：首先确定本地IDC如何与腾讯云建立通信。&lt;/p&gt;
&lt;p&gt;1、通过专线的方式；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/document/product/216/541&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/document/product/216/541&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1002332/ttbku7ozwy.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、通过vpn的方式；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/document/product/215/4956&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/document/product/215/4956&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1002332/9slrofk6hx.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步：拉取本地IDC数据至云上，并建立同步关系。&lt;/p&gt;
&lt;p&gt;1、创建DTS（数据传输服务）同步任务,这里假设CDB实例已申请购买完毕。&lt;/p&gt;
&lt;p&gt;操作步骤：&lt;/p&gt;
&lt;p&gt;新建 DTS 数据迁移服务&lt;/p&gt;
&lt;p&gt;登录控制台，进入数据迁移页面，单击【新建任务】，输入相关信息及本地IDC实例的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1002332/g5i0rtt5gh.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择目标实例实例，点击保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1002332/sd7zhhg3bb.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择同步类型，这里需要选【全量+增量数据迁移】，即一直与本地IDC的数据库保持同步关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1002332/66dtmgxrtm.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.38&quot;&gt;
&lt;h2 id=&quot;问答&quot;&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/126750?fromSource=waitui&quot;&gt;自适应数据库？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关阅读&quot;&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1158021?fromSource=waitui&quot;&gt;【转】腾讯云 API 3.0实践分享&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1158234?fromSource=waitui&quot;&gt;彭磊：TencentHub的架构实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1158503?fromSource=waitui&quot;&gt;MySQL 8.0 版本功能变更介绍&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，原文链接：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1158589?fromSource=waitui&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/article/1158589?fromSource=waitui&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎大家前往腾讯云+社区或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;海量技术实践经验，尽在&lt;a href=&quot;https://cloud.tencent.com/developer?fromSource=waitui&quot;&gt;云加社区&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 02:05:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/9316273.html</dc:identifier>
</item>
</channel>
</rss>