<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python操作excel表格 - 张璨</title>
<link>http://www.cnblogs.com/zhang-can/p/7652702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhang-can/p/7652702.html</guid>
<description>&lt;p&gt;用Python操作Excel在工作中还是挺常用的，因为毕竟不懂Excel是一个用户庞大的数据管理软件&lt;/p&gt;
&lt;p&gt;注：本篇代码在Python3环境下运行&lt;/p&gt;
&lt;p&gt;首先导入两个模块xlrd和xlwt，xlrd用来读取Excel表格，xlwt是写Excel表格&lt;/p&gt;
&lt;p&gt;在命令提示行输入命令：&lt;/p&gt;
&lt;p&gt;　　pip install xlrd&lt;/p&gt;
&lt;p&gt;　　pip install xlwt&lt;/p&gt;
&lt;p&gt;下面我们学习一下这两个模块的使用&lt;/p&gt;
&lt;p&gt;一、xlrd&lt;/p&gt;
&lt;p&gt;1.首先导入模块，import xlrd&lt;/p&gt;
&lt;p&gt;2.先写一个表用来实验，表的内容是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1164899/201710/1164899-20171011195058371-1392657403.png&quot; alt=&quot;&quot; width=&quot;385&quot; height=&quot;93&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlrd

file_path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

xlrd.Book.encoding &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置编码&lt;/span&gt;
data = xlrd.open_workbook(file_path)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开文件&lt;/span&gt;
sheet_names = data.sheet_names()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看文件中包含sheet的名称&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取工作簿，有三种方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; table = data.sheets()[0]&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; table = data.sheet_by_name('Sheet1')&lt;/span&gt;
table = data.sheet_by_index(0) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;取第一张工作簿(三种方法）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取总行数和总列数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rows_count = table.nrows &lt;span&gt;#&lt;/span&gt;&lt;span&gt;取总行数&lt;/span&gt;
cols_count = table.ncols&lt;span&gt;#&lt;/span&gt;&lt;span&gt;取总列数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 获取第一行及第一列数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
row_data = table.row_values(0)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取第一行数据(数组)&lt;/span&gt;
col_data = table.col_values(0)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取第一列数据(数组)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取某个单元格的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
cell_data = row_data[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;取第0行第0列的值   战士&lt;/span&gt;
cell_data_A1 = table.cell(1, 1).value  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;取第1行第1列的值    李白&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;循环读取所有数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0,rows_count):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; col &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0,cols_count):
        data1 &lt;/span&gt;=&lt;span&gt; table.cell(row,col).value
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data1,end=&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是基本操作，下面扩展一点&lt;/p&gt;
&lt;p&gt;关于时间格式：&lt;/p&gt;
&lt;p&gt;　　看一下取时间那一列数据，得到的什么 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 42993.0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017.01.12&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 40900.0]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这并不是我们想要的，这个时间格式是Excel中，以1900年1月1日为起始时间，以天为单位的得到的数据&lt;/p&gt;
&lt;p&gt;其实在这个模块中，有个属性可以显示单元格数据的类型，ctype,有这几种类型：&lt;/p&gt;
&lt;p&gt;　　ctype = 1 # 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error&lt;/p&gt;
&lt;p&gt; 我们可以查看一下，它打印的这个是什么类型 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(table.cell(1,6).ctype)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(table.cell(2,6).ctype)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(table.cell(3,6).ctype)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原来他能识别这是时间格式，那我们要处理一下了，让他显示格式化时间&lt;/p&gt;
&lt;p&gt;可以用这条命令来转换一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43.5&quot;&gt;
&lt;pre readability=&quot;10&quot;&gt;
date_value = xlrd.xldate_as_tuple(table.cell_value(1,6),data.datemode)&lt;p&gt;print(date_value)#(2017, 9, 15, 0, 0, 0)
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个格式就可以用了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; date,datetime

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(date(*date_value[:3]))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2017-09-15  &lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(date(*date_value[:3]).strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y/%m/%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2017/09/15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以当我们循环读取并打印数据的时候，可以做一个判断，如果数据的ctype为3，就做这样一个转换&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0,rows_count):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; col &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0,cols_count):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (table.cell(row, col).ctype == 3):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果读到时间格式的数据，就转换&lt;/span&gt;
            data_value =&lt;span&gt; xlrd.xldate_as_tuple(table.cell_value(row, col), data.datemode)
            data1 &lt;/span&gt;= date(*data_value[:3]).strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y/%m/%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            data1 &lt;/span&gt;=&lt;span&gt; table.cell(row,col).value
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data1,end=&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;战士 刺客 法师 坦克 辅助 射手 时间 

老夫子 李白 甄姬 亚瑟 蔡文姬 鲁班 &lt;/span&gt;2017/09/15&lt;span&gt; 

杨戬 韩信 小乔 牛魔 大乔 狄仁杰 &lt;/span&gt;2017.01.12&lt;span&gt; 

典韦 赵云 妲己 钟无艳 孙斌 虞姬 &lt;/span&gt;2011/12/23 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实，xlrd也能实现简单的修改数据，但是这只是临时的修改，好像并没有什么用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;简单的写入数据&lt;/span&gt;
row = 1&lt;span&gt;
col &lt;/span&gt;=&lt;span&gt; 0
ctype &lt;/span&gt;= 1 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error&lt;/span&gt;
value = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1212&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
xf &lt;/span&gt;= 0 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 扩展的格式化 (默认是0)&lt;/span&gt;
&lt;span&gt;table.put_cell_unragged(row, col, ctype, value, xf)
table.put_cell(row, col, ctype, value, xf)&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只是暂时的修改，而且只能是修改已有的数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再读取数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0,rows_count):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; col &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0,cols_count):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (table.cell(row, col).ctype == 3):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果读到时间格式的数据，就转换&lt;/span&gt;
            data_value =&lt;span&gt; xlrd.xldate_as_tuple(table.cell_value(row, col), data.datemode)
            data1 &lt;/span&gt;= date(*data_value[:3]).strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y/%m/%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            data1 &lt;/span&gt;=&lt;span&gt; table.cell(row,col).value
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data1,end=&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拿到的结果就是修改了的，但是这只是临时的，原表格并没有修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;战士 刺客 法师 坦克 辅助 射手 时间 

&lt;/span&gt;1212 李白 甄姬 亚瑟 蔡文姬 鲁班 2017/09/15&lt;span&gt; 

杨戬 韩信 小乔 牛魔 大乔 狄仁杰 &lt;/span&gt;2017.01.12&lt;span&gt; 

典韦 赵云 妲己 钟无艳 孙斌 虞姬 &lt;/span&gt;2011/12/23 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于合并的单元格的读取&lt;/p&gt;
&lt;p&gt;默认读取合并的单元格的时候，只会在合并单元格出现的第一个位置有值，其他合并的位置 就是空了，我们可以拿到合并的单元格所在表中的位置&lt;/p&gt;
&lt;p&gt;用一张新表，内容如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1164899/201710/1164899-20171011203634684-1090434890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
workbook = xlrd.open_workbook(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
table2 &lt;/span&gt;=&lt;span&gt; workbook.sheet_by_index(0) 
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(table2.merged_cells)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;[(3, 5, 3, 4), (3, 5, 0, 1)]  读取表中有合并单元格的位置&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
#merged_cells返回的这四个参数的含义是：(row,row_range,col,col_range),其中[row,row_range)&lt;br/&gt;# 即(3, 5, 3, 4)的含义是：第3到4列（3,4）的第4到5行（3,5）合并，(3, 5, 0, 1)的含义是：第0到1列（0,1）的第4到5行（3，5）合并。
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;二、xlwt&lt;/p&gt;
&lt;p&gt;1.导入模块 import xlwt&lt;/p&gt;
&lt;p&gt;2.创建工作簿，工作表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
myWorkbook = xlwt.Workbook()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个工作簿&lt;/span&gt;
mySheet = myWorkbook.add_sheet(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A Test Sheet&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个工作表&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.创建数据格式，写入数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
myStyle = xlwt.easyxf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font: name Times New Roman, color-index red, bold on&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, num_format_str=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#,##0.00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据格式&lt;/span&gt;
mySheet.write(3, 0,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abcd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, myStyle)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;写数据的时候可以用这个格式，也可以不用&lt;/span&gt;
mySheet.write(2, 0, 1)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入A3，数值等于1&lt;/span&gt;
mySheet.write(2, 1, 1)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入B3，数值等于1&lt;/span&gt;
mySheet.write(2, 2, xlwt.Formula(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A3+B3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入C3，数值等于2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.保存&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
myWorkbook.save(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.xls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 11 Oct 2017 15:20:00 +0000</pubDate>
<dc:creator>张璨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhang-can/p/7652702.html</dc:identifier>
</item>
<item>
<title>PE文件格式详解,第三讲,可选头文件格式,以及节表 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7653418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7653418.html</guid>
<description>
&lt;p&gt;作者：IBinary&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/iBinary/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/iBinary/&lt;/a&gt;&lt;br/&gt;版权所有，欢迎保留原文链接进行转载：)&lt;/p&gt;
&lt;h2&gt;一丶可选头结构以及作用&lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;h2&gt;typedef struct _IMAGE_OPTIONAL_HEADER {&lt;/h2&gt;
&lt;pre&gt;
&lt;span&gt;
    WORD    Magic;　　　　　　　　　　　　　　　　　　/*机器型号,判断是PE是32位还是64位*/
    BYTE    MajorLinkerVersion;　　　　　　　　　　/*连接器版本号高版本*/
    BYTE    MinorLinkerVersion;　　　　　　　　　　/*连接器版本号低版本,组合起来就是 5.12 其中5是高版本,C是低版本*/
    DWORD   SizeOfCode;　　　　　　　　　　　　　　　/*代码节的总大小(512为一个磁盘扇区)*/
    DWORD   SizeOfInitializedData;　　　　　　　　/*初始化数据的节的总大小,也就是.data*/
    DWORD   SizeOfUninitializedData;　　　　　　 /*未初始化数据的节的大小,也就是 .data ? */
    DWORD   AddressOfEntryPoint;　　　　　　　　  /*程序执行入口(OEP) RVA(相对偏移)*/
    DWORD   BaseOfCode;　　　　　　　　　　　　　　 /*代码的节的起始RVA(相对偏移)也就是代码区的偏移,偏移+模块首地址定位代码区*/
    DWORD   BaseOfData;　　　　　　　　　　　　　　 /*数据结的起始偏移(RVA),同上*/&lt;/span&gt;&lt;span&gt;
    DWORD   ImageBase;　　　　　　　　　　　　　　　/*程序的建议模块基址(意思就是说作参考用的,模块地址在哪里)*/&lt;br/&gt;DWORD   SectionAlignment;　　　　　　　　　　　/*内存中的节对齐*/
    DWORD   FileAlignment;　　　　　　　　　　　　　/*文件中的节对齐*/
    WORD    MajorOperatingSystemVersion;　　　　/*操作系统版本号高位*/
    WORD    MinorOperatingSystemVersion;　　　　/*操作系统版本号低位*/
    WORD    MajorImageVersion;　　　　　　　　　　/*PE版本号高位*/
    WORD    MinorImageVersion;　　　　　　　　　　/*PE版本号低位*/
    WORD    MajorSubsystemVersion;　　　　　　　　/*子系统版本号高位*/
    WORD    MinorSubsystemVersion;　　　　　　　　/*子系统版本号低位*/
    DWORD   Win32VersionValue;　　　　　　　　　　/*32位系统版本号值,注意只能修改为4 5 6表示操作系统支持nt4.0 以上,5的话依次类推*/
    DWORD   SizeOfImage;　　　　　　　　　　　　   /*整个程序在内存中占用的空间(PE映尺寸)*/
    DWORD   SizeOfHeaders;　　　　　　　　　　　　/*所有头(头的结构体大小)+节表的大小*/
    DWORD   CheckSum;　　　　　　　　　　　　　　 /*校验和,对于驱动程序,可能会使用*/
    WORD    Subsystem;　　　　　　　　　　　　　　/*文件的子系统 :重要*/
    WORD    DllCharacteristics;　　　　　　　　 /*DLL文件属性,也可以成为特性,可能DLL文件可以当做驱动程序使用*/
    DWORD   SizeOfStackReserve;　　　　　　　　/*预留的栈的大小*/
    DWORD   SizeOfStackCommit;　　　　　　　　 /*立即申请的栈的大小(分页为单位)*/
    DWORD   SizeOfHeapReserve;　　　　　　　　/*预留的堆空间大小*/
    DWORD   SizeOfHeapCommit;　　　　　　　　 /*立即申请的堆的空间的大小*/
    DWORD   LoaderFlags;　　　　　　　　　　　　/*与调试有关*/
    DWORD   NumberOfRvaAndSizes;　　　　　　　/*下面的成员,数据目录结构的项目数量*/
    IMAGE_DATA_DIRECTORY DataDirectory[16];/*数据目录,默认16个,16是宏,这里方便直接写成16*/
} IMAGE_OPTIONAL_HEADER32, &lt;/span&gt;*PIMAGE_OPTIONAL_HEADER32;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的成员:&lt;/p&gt;
&lt;h3&gt;1.PE类型&lt;/h3&gt;
&lt;p&gt;这个有宏定义了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b　　　　/*32位PE*/
&lt;span&gt;#define&lt;/span&gt; IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b　　　　/*64位PE*/
&lt;span&gt;#define&lt;/span&gt; IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107　　　　/*其它,单片机*/
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2丶.OEP,程序执行入口位置.&lt;/h3&gt;
&lt;p&gt;我们利用昨天写的程序,可以完成一个反调试.&lt;/p&gt;
&lt;p&gt;思路:&lt;/p&gt;
&lt;p&gt;1.修改OEP偏移,置为0位置处(也就是MZ的位置)&lt;/p&gt;
&lt;p&gt;2.在MZ位置后面添加我们自己的代码&lt;/p&gt;
&lt;p&gt;3.添加完成之后,继续跳到以前OEP的位置.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011212914809-530319449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先,看PE文件的值,OEP的偏移位置是00001008偏移,那么OD调试,看下位置在哪里.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011213007746-1592901233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道了入口偏移是00401008位置,那么我们就知道了模块首地址是00400000&lt;/p&gt;
&lt;p&gt;公式  00401008 - 1008 = 00400000  因为我们知道1008是相对于模块地址来的所以可以求出模块地址,我们跳转过去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011213149965-1820093835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,前边正好是4D5A,那么我们可以修改一下,添加自己的代码,首先4D5A正好是汇编代码&lt;/p&gt;
&lt;p&gt;那么我们可以去平栈,然后跳转到我们以前的OEP位置.&lt;/p&gt;
&lt;p&gt;修改成下边那样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011223513715-1058671835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先,我们以前讲DOS头的时候说过,如果这个EXE文件运行在32位系统下,那么DOS头中就地一个和最后一个成员有用,那么后面我们随便修改.&lt;/p&gt;
&lt;p&gt;上面代码很简单,首先栈平衡,然后跳转到我们以前代码执行位置.&lt;/p&gt;
&lt;p&gt;文件中(PE)我们把后面的二进制都修改为我们的代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011223644824-1406935539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;入后偏移(RVA)修改为0000000&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011213759199-526761867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行我们的程序,和调试我们的程序&lt;/p&gt;
&lt;p&gt;运行程序:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011223709652-2124176970.png&quot; alt=&quot;&quot;/&gt;可以正常运行&lt;/p&gt;
&lt;p&gt;调试程序:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171011223744512-1087748612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序出错,反调试了&lt;/p&gt;
&lt;h2&gt;二丶数据目录&lt;/h2&gt;
&lt;p&gt;数据目录,主要是存放各种表格的,看下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;　　　　　　　　虚拟地址(表格位置)
    DWORD   Size;　　　　　　　　　　　　　　大小
} IMAGE_DATA_DIRECTORY, &lt;/span&gt;*PIMAGE_DATA_DIRECTORY;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于表格,这里有很多宏定义.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_EXPORT          0   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Export Directory&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_IMPORT          1   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Import Directory&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_RESOURCE        2   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Resource Directory&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Exception Directory&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_SECURITY        4   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Security Directory&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_BASERELOC       5   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Base Relocation Table&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_DEBUG           6   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Debug Directory&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (X86 usage)&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Architecture Specific Data&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; RVA of GP&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_TLS             9   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TLS Directory&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load Configuration Directory&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Bound Import Directory in headers&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_IAT            12   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Import Address Table&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Delay Load Import Descriptors&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; COM Runtime descriptor&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它是按照位来计算的.　　　　&lt;/p&gt;
&lt;h2&gt; 三丶节表&lt;/h2&gt;
&lt;p&gt;在NT头下面,紧跟着的是节表&lt;/p&gt;
&lt;p&gt;节表是什么意思? 可以理解为分区,就是几个区&lt;/p&gt;
&lt;p&gt;那么意思就是保存了区&lt;/p&gt;
&lt;p&gt;那么我们猜想一下,都需要什么成员&lt;/p&gt;
&lt;p&gt;地址&lt;/p&gt;
&lt;p&gt;地址大小&lt;/p&gt;
&lt;p&gt;文件中的地址&lt;/p&gt;
&lt;p&gt;文件大小&lt;/p&gt;
&lt;p&gt;等等....&lt;/p&gt;
&lt;p&gt;看下节表的信息吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];　　/*节区的名字*/
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;　　　　　　　　/*节区的尺寸*/
    } Misc;
    DWORD   VirtualAddress;　　　　　　　　　　/*虚拟地址 节区的RVA地址(偏移)*/
    DWORD   SizeOfRawData;　　　　　　　　　　 /*在文件中对齐的尺寸*/
    DWORD   PointerToRawData;　　　　　　　　 /*在文件中的偏移*/
    DWORD   PointerToRelocations;　　　　　　/*在OBJ文件中使用*/
    DWORD   PointerToLinenumbers;　　　　　　/*行号表位置,调试使用*/
    WORD    NumberOfRelocations;　　　　　　/*在OBJ文件中使用*/
    WORD    NumberOfLinenumbers;　　　　　　/*行号表的数量*/
    DWORD   Characteristics;　　　　　　　　/*节的属性*/
} IMAGE_SECTION_HEADER, &lt;/span&gt;*PIMAGE_SECTION_HEADER;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重要成员&lt;/p&gt;
&lt;p&gt;1.节的尺寸&lt;/p&gt;
&lt;p&gt;2.虚拟地址,RVA(偏移)&lt;/p&gt;
&lt;p&gt;3.文件中的大小&lt;/p&gt;
&lt;p&gt;4.文件中的偏移&lt;/p&gt;
&lt;p&gt;5.节的属性&lt;/p&gt;
&lt;p&gt;其中节的属性有很多,(表达这个分区是一个什么样的分区,代码区,常量区等等)&lt;/p&gt;
&lt;p&gt;看下宏定义(按位来的,可以看下第二讲的最后关于文件属性的讲解,其中讲解了这个怎么按位来)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_CNT_CODE                   0x00000020  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section contains code.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section contains initialized data.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section contains uninitialized data.&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_LNK_OTHER                  0x00000100  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reserved.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_LNK_INFO                   0x00000200  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section contains comments or some other type of information.&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      IMAGE_SCN_TYPE_OVER                  0x00000400  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reserved.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_LNK_REMOVE                 0x00000800  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section contents will not become part of image.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_LNK_COMDAT                 0x00001000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section contents comdat.&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                                           0x00002000  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reserved.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reset speculative exceptions handling bits in the TLB entries for this section.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_GPREL                      0x00008000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section content can be accessed relative to GP&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section contains extended relocations.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_MEM_DISCARDABLE            0x02000000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section can be discarded.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_MEM_NOT_CACHED             0x04000000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section is not cachable.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_MEM_NOT_PAGED              0x08000000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section is not pageable.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_MEM_SHARED                 0x10000000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section is shareable.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_MEM_EXECUTE                0x20000000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section is executable.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_MEM_READ                   0x40000000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section is readable.&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_SCN_MEM_WRITE                  0x80000000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Section is writeable.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中保留的没有写.&lt;/p&gt;
&lt;p&gt;作者：IBinary&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/iBinary/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/iBinary/&lt;/a&gt;&lt;br/&gt;版权所有，欢迎保留原文链接进行转载：)&lt;/p&gt;
</description>
<pubDate>Wed, 11 Oct 2017 15:09:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7653418.html</dc:identifier>
</item>
<item>
<title>C#泛型基础知识点总结 - 如此拉风的女人</title>
<link>http://www.cnblogs.com/wwym/p/7646935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wwym/p/7646935.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1.0&lt;/strong&gt;  &lt;strong&gt;什么是泛型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      泛型是&lt;strong&gt;C#2.0&lt;/strong&gt;和&lt;strong&gt;CLR（公共语言运行时）&lt;/strong&gt;升级的一个新特性，泛型为.NET 框架引入了一个叫 &lt;strong&gt;type parameters（类型参数）&lt;/strong&gt;的概念，&lt;strong&gt;type parameters&lt;/strong&gt; 使得程序在设计的时候，不必设计其具体的参数，其具体的参数可以延迟到需要的时候声明或调用。使用泛型代码运行时避免了类型转换的装箱和拆箱操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;2.0 泛型的延迟声明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; _20171010Generic
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;8&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;9&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 泛型方法相关类&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GenericMethod
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;&lt;span&gt;     {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 泛型方法：方法带&lt;/span&gt;&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span&gt;和type parameters（类型参数 T）的&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;tParameters&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show&amp;lt;T&amp;gt;&lt;span&gt;(T tParameters)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;         {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}方法，parameter={1}参数，type={2}类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(GenericMethod).Name, tParameters, tParameters.GetType().Name);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;&lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;24&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如代码所示，在声明泛型方法的时候没有指定具体的参数类型，等到需要调用的时候再指定，这就叫做延迟声明。泛型的设计思想（延迟思想，推迟一切可以推迟的）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; _20171010Generic
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;8&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;9&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;     {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;         {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; iValue = &lt;span&gt;123&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; sValue = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;             DateTime dtValue =&lt;span&gt; DateTime.Now;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;             &lt;span&gt;object&lt;/span&gt; oValue = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;&lt;span&gt;             GenericMethod.Show(iValue);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;             GenericMethod.Show(sValue);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;&lt;span&gt;             GenericMethod.Show(oValue);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;&lt;span&gt;             GenericMethod.Show(dtValue);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;———————我是华丽的分割线————————&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;24&lt;/span&gt;             GenericMethod.Show&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(iValue);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;25&lt;/span&gt;             GenericMethod.Show&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(sValue);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;26&lt;/span&gt;             GenericMethod.Show&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;(oValue);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;27&lt;/span&gt;             GenericMethod.Show&amp;lt;DateTime&amp;gt;&lt;span&gt;(dtValue);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;28&lt;/span&gt;            
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;29&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;———————我是华丽的分割线————————&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;             Console.WriteLine(&lt;span&gt;typeof&lt;/span&gt;(List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;31&lt;/span&gt;             Console.WriteLine(&lt;span&gt;typeof&lt;/span&gt;(Dictionary&amp;lt;,&amp;gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;32&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;———————我是华丽的分割线————————&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;33&lt;/span&gt;&lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;34&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;35&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/951104/201710/951104-20171010182110230-1059713758.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 泛型方法的调用，第一种  GenericMethod.Show(iValue);调用方法不指定类型参数，在编译的时候编译器自动编译推算(语法糖)，第二种  GenericMethod.Show&amp;lt;int&amp;gt;(iValue);调用方法指定类型参数，类型参数和参数类型须一致，否则编译不通过。VS2017鼠标移上去会提示可以简化方法名称。编译的时候，类型参数编译为占位符，程序运行的时候，JIT(即时编译（Just In-Time compile）即时编译为真实类型。所以使用泛型性能会比使用object作为参数的方法好，(ps:经过测试)。 Console.WriteLine(typeof(List&amp;lt;int&amp;gt;)); 和Console.WriteLine(typeof(Dictionary&amp;lt;,&amp;gt;));的运行结果中有个~1,和~2就表示类型参数的占位符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;　3.0 泛型主要的四种：&lt;/strong&gt;泛型类，&lt;/span&gt; 泛型方法，&lt;strong&gt;泛型接口，&lt;/strong&gt;泛型委托&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _20171010Generic
{
    /// &amp;lt;summary&amp;gt;
    /// 动物类
    /// &amp;lt;/summary&amp;gt;
    public class AnimalModel
    {
        public int Id { get; set; }
        public String Name { get; set; }
        public virtual void Cry()
        { }
    }
    public interface IEat
    {
        void Eat();
    }
    public interface ISleep
    {
        void Sleep();
    }

    /// &amp;lt;summary&amp;gt;
    /// 狗类
    /// &amp;lt;/summary&amp;gt;
    public class Dog:AnimalModel
    {
        public override void Cry()
        {
            Console.WriteLine(&quot;旺旺旺。。。。。&quot;);
        }
    }
    /// &amp;lt;summary&amp;gt;
    /// 猫类
    /// &amp;lt;/summary&amp;gt;
    public class Cat : AnimalModel
    {
        public override void Cry()
        {
            Console.WriteLine(&quot;喵喵瞄。。。。。。。&quot;);
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 玫瑰花类
    /// &amp;lt;/summary&amp;gt;
    public class Rose
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 首先先新建了一个AnimalModel类，里面定义了一个动物类，动物类里有个虚方法Cry，一个狗类，狗类继承了动物类，一个猫类，重写了虚方法Cry。一个IEat接口和ISleep接口，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; _20171010Generic
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 泛型类
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;类型参数&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;S&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;类型参数&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;K&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;类型参数&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericClass&amp;lt;T, S, K&amp;gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 无返回值的泛型方法
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show(T t)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 有返回值的泛型方法
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T Get()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 泛型接口
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;W&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ISleep&amp;lt;W&amp;gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        W Sleep(W t);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 有返回值的泛型委托
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;Y&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; Y DlgYFun&amp;lt;Y&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; DlgIntFun();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 泛型类
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;W&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;Y&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;M&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericChild&amp;lt;T, S, K&amp;gt;
&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;: GenericClass&amp;lt;T, S, K&amp;gt;直接继承泛型类
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;: GenericClass&amp;lt;T, S, string&amp;gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类型参数可直接指定
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;: ISleep&amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;         : ISleep&amp;lt;T&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现泛型接口&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         T ISleep&amp;lt;T&amp;gt;&lt;span&gt;.Sleep(T t)
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 普通类
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Child
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; :GenericClass&amp;lt;T,S,K&amp;gt;错误的继承，普通类不能直接继承泛型类
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;: GenericClass&amp;lt;string, int, double&amp;gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须指定全部确定的类型参数后可继承泛型
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;:ISleep&amp;lt;W&amp;gt;错误的实现泛型接口，普通类不能直接实现泛型接口，&lt;/span&gt;
&lt;span&gt;79&lt;/span&gt;        : ISleep&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt;80&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Sleep(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; t)
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;实现了sleep泛型接口，返回参数是：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, t);
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;泛型类就在普通类名字后面加上&amp;lt;&amp;gt;和多个类型参数，需要注意的是 1.普通类不能直接继承泛型类和泛型接口，因为泛型的类型参数不确定，但是泛型类或泛型接口指定类型后可以继承泛型类或实现泛型接口，2.泛型类可以直接继承泛型类，也可以直接实现泛型接口,其子类的类型参数相当于声明了局部参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4.0泛型的约束(基类约束，接口约束，引用类型约束，值类型约束，无参构造函数约束)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;　　回到上面写的那个GenericMethod类里的show方法，new 一个cat对象，Cat cat=new Cat(){ Id=1,Name=&quot;小黑猫&quot;}; 然后调用genericMentod.show(cat)方法。但是如果想要在show方法里访问Id,或者Name却不行。T是个不明确类型参数，所以无法访问，如图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/951104/201710/951104-20171011141507715-1887885213.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用泛型约束解决方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; _20171010Generic
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 泛型约束
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Constraint
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show&amp;lt;T&amp;gt;&lt;span&gt;(T tParameter)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;where T: AnimalModel  基类约束，就可以访问该类的方法或属性&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;where&lt;/span&gt; T:Cat &lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者该子类       &lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;泛型约束show方法--------id={0},name={1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,tParameter.Id,tParameter.Name);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show(AnimalModel model)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;普通show方法--------id={0},name={1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, model.Id, model.Name);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShowInterface&amp;lt;T&amp;gt;&lt;span&gt;(T tParameter)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;where T: AnimalModel  基类约束，就可以访问该类的方法或属性&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;            &lt;span&gt;where&lt;/span&gt; T : Cat,ISleep,IEat&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者该子类约束，多个接口约束 &lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;泛型约束ShowInterface方法--------id={0},name={1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tParameter.Id, tParameter.Name);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             tParameter.Sleep();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口的方法&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            tParameter.Eat();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;Constraint&lt;/strong&gt;类里的第一个&lt;strong&gt;show&lt;/strong&gt;方法中在后面带个 &lt;strong&gt;where关键字&lt;/strong&gt; 和&lt;strong&gt; 约束类型，&lt;/strong&gt;泛型方法里就能访问Id和Name,第二个&lt;strong&gt;show&lt;/strong&gt;方法是作为对比，虽然第二个方法也能实现同样的效果，但是相对泛型方法不灵活，泛型方法可以同时约束多个，比如第三个方法约束多个接口，和类，多个约束的关系是&amp;amp;&amp;amp;关系&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;泛型约束除了基类约束和接口约束几种，还有值类型约束，无参构造约束，引用类型约束等这几种。&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T TestFun&amp;lt;T&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; where T:class    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用类型约束
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; where T:struct   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;值类型约束&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;            &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;new&lt;/span&gt;()      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;无参构造函数约束&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;            T t = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; T();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   5.0协变和逆变&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　out 协变(covariant) 修饰返回值，in 逆变(contravariant) 修饰传入参数。out和in只能放在接口或者泛型委托的的参数前面，类没有协变和逆变。&lt;/strong&gt;在.NET Framework里面，&lt;strong&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/strong&gt;转到定义去看，其实就是个带out参数的泛型接口，&lt;strong&gt;Action&amp;lt;T&amp;gt;&lt;/strong&gt;转到定义去看就是个带in参数的泛型委托。还有一个逆变+协变的&lt;strong&gt;Func&amp;lt;T&amp;gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/951104/201710/951104-20171011170818184-374139711.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/951104/201710/951104-20171011171018949-620377652.png&quot; alt=&quot;&quot; width=&quot;1330&quot; height=&quot;408&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;像平常一样写代码：  AnimalModel animal = new AnimalModel();//实例化一个动物。&lt;/p&gt;
&lt;p&gt;　　　　　　             Dog dog = new Dog();//实例化一个条单身狗&lt;/p&gt;
&lt;p&gt;　　　　　　　　　&lt;strong&gt; AnimalModel dog2 = new Dog();//实例化一条单身狗（狗继承了动物父类，父类出现的地方都可以用子类代替，对的，狗一定是个动物）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　// Dog dog3 = new AnimalModel();动物不一定是条单身狗，程序编译不通过&lt;/p&gt;
&lt;p&gt;new一条单身狗没问题，new 一群单身狗试试看。&lt;/p&gt;
&lt;p&gt;　　　　　　　　List&amp;lt;Dog&amp;gt; dogList = new List&amp;lt;Dog&amp;gt;();//实例化一群单身狗（编译通过）&lt;/p&gt;
&lt;p&gt;　　　　　&lt;strong&gt;　　　List&amp;lt;AnimalModel&amp;gt; animalDog = new List&amp;lt;Dog&amp;gt;();//实例化一群单身狗（语法上不通过）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理论上来说第二种实例化一群狗的方式是没毛病的，一群狗也一定是一群动物，但是程序上是不通过是因为Listt&amp;lt;T&amp;gt;是个泛型　 &lt;strong&gt;List&amp;lt;Dog&amp;gt;不是继承&lt;/strong&gt;&lt;strong&gt;List&amp;lt;AnimalModel&amp;gt;，没有父子关系，程序只认关系。。。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PS:写到这里我就快写不下去了，狗快被我自己玩坏了。&lt;/p&gt;
&lt;p&gt;要使上面那句代码编译通过，可以通过lambda表达式转化&lt;strong&gt; &lt;/strong&gt; &lt;strong&gt;List&amp;lt;&lt;/strong&gt;AnimalModel&amp;gt; animalDog = new List&amp;lt;Dog&amp;gt;().Select(x =&amp;gt; (&lt;strong&gt;&lt;strong&gt;AnimalModel&lt;/strong&gt;&lt;/strong&gt;)x).ToList();&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用IEnumerable：&lt;strong&gt;&lt;span&gt;IEnumerable&lt;/span&gt;&amp;lt;AnimalModel&amp;gt; animalDog= new List&amp;lt;Dog&amp;gt;();   //这就叫协变。&lt;/strong&gt;&lt;span&gt;IEnumerable&lt;/span&gt;&amp;lt;out  T&amp;gt;在编译的时候就通过转化了，我个人理解为out 是表示转化后的T返回标识。平常在工作中，有用过out 关键字作为标识的返回参数，会用，但是不其所以然。原理明白后自己也可以定义一个协变的泛型接口。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IMyTest&amp;lt;&lt;span&gt;out&lt;/span&gt; T&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test&amp;lt;T&amp;gt; : IMyTest&amp;lt;T&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;    IMyTest&amp;lt;Animal&amp;gt; test3 = &lt;span&gt;new&lt;/span&gt; Test&amp;lt;Dog&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;逆变就和协变相反。逆变的in 的参数只能作为传入值，不能作为返回值。说白了，也是一种约束。协变和逆变的关键作用就是让编译器在运行时不报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IMyTest&amp;lt;inT&amp;gt;
&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt;&lt;span&gt;     {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test&amp;lt;T&amp;gt; : IMyTest&amp;lt;T&amp;gt;
&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt;&lt;span&gt;     {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;8&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;    IMyTest&amp;lt;Dog&amp;gt; test3 = &lt;span&gt;new&lt;/span&gt; Test&amp;lt;Animal&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;关于泛型的知识点还有很多，比如还有泛型的缓存，这个就有点难理解了。以上知识点是我平常通过各种途径学习总结的几点。如有不对欢迎指正。欢迎转载和分享，转载分享时请注明原创出处：&lt;a title=&quot;如此拉风的女人&quot; href=&quot;http://www.cnblogs.com/wwym/p/7646935.html&quot; target=&quot;_blank&quot;&gt;如此拉风的女人&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 11 Oct 2017 15:08:00 +0000</pubDate>
<dc:creator>如此拉风的女人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wwym/p/7646935.html</dc:identifier>
</item>
<item>
<title>Entity Framework Code First实现乐观并发 - 东城慕水</title>
<link>http://www.cnblogs.com/chen-jie/p/Optimistic-Concurrency-in-Entity-Framework-Code-Fi.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chen-jie/p/Optimistic-Concurrency-in-Entity-Framework-Code-Fi.html</guid>
<description>&lt;p&gt;&lt;strong&gt;不定时更新翻译系列，此系列更新毫无时间规律，文笔菜翻译菜求各位看官老爷们轻喷，如觉得我翻译有问题请挪步原博客地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本博文翻译自：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://www.codeproject.com/Articles/817432/Optimistic-Concurrency-in-Entity-Framework-Code-Fi&quot;&gt;&lt;strong&gt;https://www.codeproject.com/Articles/817432/Optimistic-Concurrency-in-Entity-Framework-Code-Fi&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;本文描述了使用Entity Framework Code First处理乐观并发性的不同配置&lt;/p&gt;
&lt;h3 id=&quot;并发性&quot;&gt;并发性&lt;/h3&gt;
&lt;p&gt;在计算机科学中，&lt;a href=&quot;http://en.wikipedia.org/wiki/Concurrency_(computer_science)&quot;&gt;并发性&lt;/a&gt;是系统的一个属性，在这个系统中，多个计算同时执行，并且有可能相互影响。&lt;/p&gt;
&lt;p&gt;在web应用程序中，这是一个多用户环境，在保存数据库中的数据时，可能存在并发性。并发性大致分为两种类型:1)悲观并发2)乐观并发&lt;/p&gt;
&lt;h4 id=&quot;悲观并发&quot;&gt;1) 悲观并发&lt;/h4&gt;
&lt;p&gt;数据库中的悲观并发包括锁行，以防止其他用户以影响当前用户的方式修改数据。&lt;/p&gt;
&lt;p&gt;在这种方法中，用户执行一个操作，其中一个锁被应用，其他用户不能在该记录上执行相同的操作，直到该锁被释放。&lt;/p&gt;
&lt;h4 id=&quot;乐观并发&quot;&gt;2) 乐观并发&lt;/h4&gt;
&lt;p&gt;相比之下，在&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa0416cz(v=vs.110).aspx&quot;&gt;乐观并发&lt;/a&gt;中，当用户阅读时，行不会被锁定。当用户试图更新这一行时，系统必须确定该记录是否被另一个用户修改过，因为它被读取了。&lt;/p&gt;
&lt;h2 id=&quot;开始编写代码&quot;&gt;开始编写代码&lt;/h2&gt;
&lt;p&gt;让我们创建一个控制台应用程序来探索处理乐观并发的不同情况。&lt;/p&gt;
&lt;h3 id=&quot;步骤&quot;&gt;步骤&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;使用Visual Studio，创建控制台应用程序(&lt;em&gt;文件 -&amp;gt;新建-&amp;gt;项目-&amp;gt;控制台程序(使用 Visual C# 模板)&lt;/em&gt;) 并将其命名为 &lt;strong&gt;ConcurrencyCheck.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;向项目添加一个新的文件夹 &lt;strong&gt;Models&lt;/strong&gt;. 然后在这个文件夹中添加两个类文件: &lt;strong&gt;EducationContext.cs&lt;/strong&gt; 和 &lt;strong&gt;Student.cs&lt;/strong&gt; .&lt;/li&gt;
&lt;li&gt;在这个控制台应用程序中安装&lt;strong&gt;EntityFramework&lt;/strong&gt; Nuget包。在包管理器控制台中运行&quot;_Install-Package EntityFramework&quot;_命令来执行此操作。或者，您也可以&quot;&lt;a href=&quot;http://docs.nuget.org/docs/start-here/managing-nuget-packages-using-the-dialog&quot;&gt;Nuget包管理器&lt;/a&gt;&quot;理窗口安装相同的程序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下表显示了用于乐观并发的不同配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;配置乐观并发&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;strong&gt;Data Annotation&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;[Timestamp]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;strong&gt;Fluent API&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;.IsRowVersion()&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;convention&quot;&gt;1) Convention&lt;/h4&gt;
&lt;p&gt;Entity Framework Code First 没有任何处理乐观并发的约定。您可以使用Data Annotation或Fluent API来处理乐观并发。&lt;/p&gt;
&lt;h4 id=&quot;data-annotation&quot;&gt;2) Data Annotation&lt;/h4&gt;
&lt;p&gt;Code First使用&lt;strong&gt;[Timestamp]&lt;/strong&gt; 处理乐观并发性的属性。&lt;/p&gt;
&lt;p&gt;a) 修改 &lt;em&gt;EducationContext.cs&lt;/em&gt; 文件如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System.Data.Entity;

namespace ConcurrencyCheck.Models
{
    class EducationContext : DbContext
    {
        public EducationContext()
            : base(&quot;EducationContext&quot;)
        {
        }

        public DbSet&amp;lt;Student&amp;gt; Students { get; set; }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;strong&gt;base(&quot;EducationContext&quot;)&lt;/strong&gt;中通过Code First 指令在 &lt;em&gt;App.config&lt;/em&gt; 文件中使用名为&quot;EducationContext&quot;的连接字符串&lt;/p&gt;
&lt;p&gt;b) 修改 &lt;em&gt;Student.cs&lt;/em&gt; 文件如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System.ComponentModel.DataAnnotations;

namespace ConcurrencyCheck.Models
{
    public class Student
    {
        public int StudentId { get; set; }

        public string RollNumber { get; set; }

        public string FirstName { get; set; }

        public string LastName { get; set; }

        [Timestamp]
        public byte[] RowVersion { get; set; }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，在 &lt;em&gt;Student&lt;/em&gt; 类中有一个属性 &lt;strong&gt;RowVersion&lt;/strong&gt; ，它是 &lt;em&gt;byte[]&lt;/em&gt; 类型，并被分配使用 &lt;em&gt;[Timestamp]&lt;/em&gt; 属性来处理乐观的并发性。&lt;/p&gt;
&lt;p&gt;c) 将 &lt;strong&gt;App.config&lt;/strong&gt; 文件中的连接字符串更改为指向一个有效的数据库:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;connectionStrings&amp;gt;
    &amp;lt;add name=&quot;EducationContext&quot; providerName=&quot;System.Data.SqlClient&quot; connectionString=&quot;Server=DUKHABANDHU-PC; Database=ConcurrencyCheck;Integrated Security=SSPI&quot; /&amp;gt;
&amp;lt;/connectionStrings&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我们将数据库名称作为ConcurrencyCheck，它将在应用程序运行时通过 Code First 创建。&lt;/p&gt;
&lt;p&gt;d) 修改 &lt;em&gt;Program.cs&lt;/em&gt; 文件在每次应用程序运行时都要删除和创建数据库:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void Main(string[] args)
{
    Database.SetInitializer(new DropCreateDatabaseAlways&amp;lt;EducationContext&amp;gt;());

    using (var context = new EducationContext())
    {
        context.Students.Add(new Student
        {
            FirstName = &quot;Dukhabandhu&quot;,
            LastName = &quot;Sahoo&quot;,
            RollNumber = &quot;1&quot;
        });

        context.SaveChanges();
    }

    Console.WriteLine(&quot;Database Created!!!&quot;);
    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果运行该应用程序，代码首先将创建数据库 &lt;strong&gt;ConcurrenCheck&lt;/strong&gt; 它拥有两个表 &lt;em&gt;MigrationHistory&lt;/em&gt; 和 &lt;em&gt;Students&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;如果您看到 &lt;em&gt;Students&lt;/em&gt; 表中的 &lt;em&gt;RowVersion&lt;/em&gt; 列(在SQL Sever中)，它的数据类型是 &lt;em&gt;timestamp&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201710/774226-20171011222924043-1145979263.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RowVersion&lt;/strong&gt; 和 &lt;strong&gt;TimeStamp&lt;/strong&gt; 是不同数据库提供程序用于相同目的的两个术语。当创建或更新 &lt;em&gt;Students&lt;/em&gt; 表中的记录时，数据库将自动更新 RowVersion 值到新值。即使您为 &lt;em&gt;rowversion&lt;/em&gt; 列发送值，数据库(SQL Server)也不使用该值来进行插入或更新操作。&lt;/p&gt;
&lt;p&gt;当添加到 &lt;em&gt;Students&lt;/em&gt; 表的新记录时生成的SQL:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec sp_executesql N'INSERT [dbo].[Students]([RollNumber], [FirstName], [LastName])
VALUES (@0, @1, @2)
SELECT [StudentId], [RowVersion]
FROM [dbo].[Students]
WHERE @@ROWCOUNT &amp;gt; 0 AND [StudentId] = scope_identity()',N'@0 nvarchar(max) ,@1 nvarchar(max) ,@2 nvarchar(max) ',@0=N'1',@1=N'Dukhabandhu',@2=N'Sahoo'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您可以看到查询不仅插入了一个新记录，而且还返回了 &lt;em&gt;RowVersion&lt;/em&gt; 的值。&lt;/p&gt;
&lt;p&gt;当进行更新和删除操作时，会发生实际的并发检查。在更新和删除 &lt;em&gt;Students&lt;/em&gt; 表的记录时，请参阅下面如何发生并发检查。&lt;/p&gt;
&lt;h4 id=&quot;update-sql&quot;&gt;UPDATE SQL&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;exec sp_executesql N'UPDATE [dbo].[Students]
SET [RollNumber] = @0 WHERE (([StudentId] = @1) AND ([RowVersion] = @2))
SELECT [RowVersion] FROM [dbo].[Students]
WHERE @@ROWCOUNT &amp;gt; 0 AND [StudentId] = @1',N'@0 nvarchar(max) ,@1 int,@2 binary(8)',@0=N'2',@1=1,@2=0x00000000000007D1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到 &lt;em&gt;WHERE&lt;/em&gt; 条件,在更新记录时，它比较了 &lt;em&gt;studentid&lt;/em&gt; (主键)和 &lt;em&gt;RowVersion&lt;/em&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;delete-sql&quot;&gt;DELETE SQL&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;exec sp_executesql N'DELETE [dbo].[Students]
WHERE (([StudentId] = @0) AND ([RowVersion] = @1))',N'@0 int,@1 binary(8)',@0=1,@1=0x00000000000007D1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在删除记录代码之前，先创建一个查询来比较标识符(主键 &lt;em&gt;StudentId&lt;/em&gt; )和行版本( &lt;em&gt;RowVersion&lt;/em&gt; 字段)用于乐观并发。&lt;/p&gt;
&lt;h4 id=&quot;fluent-api&quot;&gt;3) Fluent API&lt;/h4&gt;
&lt;p&gt;Fluent API使用 &lt;strong&gt;IsRowVersion()&lt;/strong&gt; 方法来配置乐观并发。&lt;/p&gt;
&lt;p&gt;为了测试Fluent API的配置，从 &lt;em&gt;Students&lt;/em&gt; 类的 &lt;em&gt;RowVersion&lt;/em&gt; 属性中删除 &lt;em&gt;[Timestamp]&lt;/em&gt; 属性，并在 &lt;em&gt;EducationContext&lt;/em&gt; 类中覆盖 ** onmodel()** 方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
    modelBuilder.Entity&amp;lt;Student&amp;gt;().Property(s =&amp;gt; s.RowVersion).IsRowVersion();
    base.OnModelCreating(modelBuilder);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置非时间戳字段&quot;&gt;配置非时间戳字段&lt;/h2&gt;
&lt;p&gt;如果不保留对并发检查的专用列，您仍然可以处理并发性。有些数据库不支持 &lt;em&gt;RowVersion / Timestamp&lt;/em&gt; 类型的列。在这些类型的场景中，您可以使用Data Annotation或Fluent API配置来配置一个或多个用于并发检查的字段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;配置非时间戳字段&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;strong&gt;Data Annotation&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;[ConcurrencyCheck]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;strong&gt;Fluent API&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;.IsConcurrencyToken()&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;data-annotation-1&quot;&gt;1) Data Annotation&lt;/h3&gt;
&lt;p&gt;修改 &lt;em&gt;Student&lt;/em&gt; 类，以使用 &lt;em&gt;[ConcurrencyCheck]&lt;/em&gt; Data Annotation属性:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Student
{
    public int StudentId { get; set; }

    [ConcurrencyCheck]
    public string RollNumber { get; set; }

    public string FirstName { get; set; }

    public string LastName { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当应用程序运行时，代码首先创建 &lt;strong&gt;Students&lt;/strong&gt; 表(参见下图)。数据库在 &lt;em&gt;RollNumber&lt;/em&gt; 列中不为 &lt;em&gt;[ConcurrencyCheck]&lt;/em&gt; 属性做任何特殊的事情。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201710/774226-20171011224728449-1296709307.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是当任何修改/更改发生在Students表时，代码首先处理并发检查。接下来阅读代码如何创建更新和删除并处理并发检查。&lt;/p&gt;
&lt;h4 id=&quot;update-sql-1&quot;&gt;UPDATE SQL&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;exec sp_executesql N'UPDATE [dbo].[Students]
SET [RollNumber] = @0
WHERE (([StudentId] = @1) AND ([RollNumber] = @2))
',N'@0 nvarchar(max) ,@1 int,@2 nvarchar(max) ',@0=N'2',@1=1,@2=N'1'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意 &lt;em&gt;WHERE&lt;/em&gt; 条件。它在更新记录时比较 &lt;em&gt;StudentId&lt;/em&gt; (主键)和 &lt;em&gt;RollNumber&lt;/em&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;delete-sql-1&quot;&gt;DELETE SQL&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;exec sp_executesql N'DELETE [dbo].[Students]
WHERE (([StudentId] = @0) AND ([RollNumber] = @1))',N'@0 int,@1 nvarchar(max) ',@0=1,@1=N'2'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在删除 &lt;em&gt;Students&lt;/em&gt; 表的记录时，它还检查 &lt;em&gt;StudentId&lt;/em&gt; 和 &lt;em&gt;RollNumber&lt;/em&gt; 列值。如果 &lt;em&gt;RollNumber&lt;/em&gt; 列值改变了,你现在正在更新那个记录，然后你就会得到&lt;strong&gt;OptimisticConcurrencyException&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;fluent-api-1&quot;&gt;2) Fluent API&lt;/h3&gt;
&lt;p&gt;使用Code First的 &lt;strong&gt;IsConcurrencyToken()&lt;/strong&gt; 方法来处理非时间戳字段的并发性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
    modelBuilder.Entity&amp;lt;Student&amp;gt;().Property(s =&amp;gt; s.RollNumber).IsConcurrencyToken();
    base.OnModelCreating(modelBuilder);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注意&quot;&gt;注意&lt;/h2&gt;
&lt;p&gt;为了测试并发效果，添加代码来更新Students表中已有的记录如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var student = context.Students.FirstOrDefault(u =&amp;gt; u.StudentId == 1);

if (student != null)
{
    student.RollNumber = &quot;2&quot;;
    context.SaveChanges();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Visual Studio中为 &lt;em&gt;context.SaveChanges()&lt;/em&gt; 行添加断点。在 &lt;strong&gt;SaveChanges()&lt;/strong&gt; 方法执行之前，修改数据库中 &lt;em&gt;Students&lt;/em&gt; 表记录条件是StudentId = 1。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;UPDATE Students SET RollNumber = '123' WHERE StudentId = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，如果你要执行下一行语句savechanges()然后你会得到如下的一个提示:&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;DbUpdateConcurrencyException:&lt;/p&gt;
&lt;p&gt;Store update, insert, or delete statement affected an unexpected number of rows (0). Entities may have been modified or deleted since entities were loaded. Refresh ObjectStateManager entries.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;DbUpdateConcurrencyException&lt;/em&gt; 异常抛出,因为记录已经修改为只读。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在本文中，我们学习了如何通过Entity Framework Code First将专用字段保存在表中，或者通过添加特殊data annotation属性或Fluent API配置来配置处理乐观并发性的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎转载，转载请注明翻译原文出处(本文章)，原文出处(原博客地址)，然后谢谢观看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果觉得我的翻译对您有帮助，请点击推荐支持：）&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Oct 2017 15:00:00 +0000</pubDate>
<dc:creator>东城慕水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chen-jie/p/Optimistic-Concurrency-in-Entity-Framework-Code-Fi.html</dc:identifier>
</item>
<item>
<title>理解js中的运算符优先级 - nobody-junior</title>
<link>http://www.cnblogs.com/imgss/p/7653200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imgss/p/7653200.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我是有过这样的经历，获取年月日时写出这样的代码:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new Date().getFullYear()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时的我是心虚的，因为我不知道是先执行&lt;code&gt;.&lt;/code&gt;运算还是&lt;code&gt;new&lt;/code&gt;运算，于是赶紧贴到控制台里，哎呦😀，没报错，看来是先执行&lt;code&gt;new&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;让我们再牛逼一点，把Date后面的()去掉！🤔然后变成这样--&lt;code&gt;new Date.getFullYear()&lt;/code&gt;。结果这回浏览器说此路不通。&lt;/p&gt;
&lt;p&gt;或者有时候看到这样的眼花缭乱的黑魔法代码会一脸懵逼&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[[[] == []] + []][+![]][+![]] //'f'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就说明同学们，该打打怪，学学优先级了&lt;/p&gt;
&lt;h3 id=&quot;表达式&quot;&gt;表达式&lt;/h3&gt;
&lt;p&gt;按MDN的说法， &lt;em&gt;运算符的优先级决定了表达式中运算执行的先后顺序&lt;/em&gt;可以看出,优先级这个概念是针对表达式的执行而产生的。所以要谈优先级，先说什么是表达式。参考链接5给出一个不严谨的定义，但我觉得很合我的胃口：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个表达式会产生一个值,它可以放在任何需要一个值的地方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据这个定义，，我们可以这样来验证一段代码是不是表达式，就是让把这段代码赋值给一个变量(不严谨了^^)，如果不报错，那就是一个表达式了:举个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//a=3 ok，所以a是一个表达式&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date &lt;span class=&quot;co&quot;&gt;//a=new Date 也是一个表达式&lt;/span&gt;

a&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//a=a=3 所以a=3也是一个表达式&lt;/span&gt;

a&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date : &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//可以赋值，也是表达式&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//a=function(){} ok&lt;/span&gt;

a &lt;span class=&quot;co&quot;&gt;//a=a报错，然而a是一个表达式。。。，JS中的原始表达式：常量或者直接量、关键字和变量（参考链接4）&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;链接4总结了以下的表达式种类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原始表达式：常量或者直接量、关键字和变量&lt;/li&gt;
&lt;li&gt;字面量表达式&lt;/li&gt;
&lt;li&gt;函数定义表达式&lt;/li&gt;
&lt;li&gt;属性访问表达式&lt;/li&gt;
&lt;li&gt;调用表达式&lt;/li&gt;
&lt;li&gt;对象创建表达式&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;优先级结合性求值顺序&quot;&gt;优先级、结合性、求值顺序&lt;/h3&gt;
&lt;p&gt;接下来进入正题,MDN上是这么解释的:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;运算符的优先级决定了表达式中运算执行的先后顺序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;结合性决定了拥有相同优先级的运算符的执行顺序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链接1里有知乎大神关于优先级的语法树级别的描述，看懂了你大概就明白V8是怎么看懂你的代码的。我们这里说一个不精确的描述就是优先级高的运算符就是给自己负责的运算加了一个括号。回到一开始举的那个Date的例子:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Date&lt;/span&gt;().&lt;span class=&quot;at&quot;&gt;getFullYear&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;//等于(new Date()).getFullYear()&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Date&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getFullYear&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;//等于(new (Date.getFullYear())报错&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里第二种方法报错就是优先级的锅。根据MDN给的&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence&quot;&gt;优先级顺序表&lt;/a&gt;,可以看到，带括号的 &lt;code&gt;new Date()&lt;/code&gt;优先级在19的位置，不带括号的&lt;code&gt;new Date&lt;/code&gt;则在18的位置，而&lt;code&gt;.&lt;/code&gt;运算则在19的位置，优先级的差异造成了两种不同的结果。&lt;/p&gt;
&lt;p&gt;接下来在说说什么是运算符结合性。考虑下面的代码:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;a&lt;span class=&quot;op&quot;&gt;=!&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;5+6+7&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到第一条的时候，你脑子里肯定是先考虑了&lt;code&gt;!3&lt;/code&gt;。为什么不先考虑&lt;code&gt;a=&lt;/code&gt; 或者 &lt;code&gt;=！&lt;/code&gt;呢,而第二段代码我们则从左往右读的。这就是结合性,取反运算是右结合的，而且优先级比赋值运算高，所以先考虑&lt;code&gt;!3&lt;/code&gt;,而&lt;code&gt;+&lt;/code&gt;运算是从左向右的。所以我们在读代码的时候已经用到优先级和结合性，只是没意识到而已。&lt;/p&gt;
&lt;h4 id=&quot;运算符&quot;&gt;运算符&lt;/h4&gt;
&lt;p&gt;哦,还要说以下下运算符的作用，运算符就是拉着身边的表达式构成一个新的表达式，最后产生一个值：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//表达式&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//新的表达式 由！和表达式3构成&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+!&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//+带了俩个表达式构成一个新表达式&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+!&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; : &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// ? :运算符和true,1+!3,0一起玩4p构成的新表达式&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说到这里，差不多就完了，如果各位看官老爷还嫌不过瘾，可以看看参考链接4的运算符8关，或者研究这个打印出来是什么,我就不打扰各位老爷了(ε=ε=ε=┏(゜ロ゜;)┛&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(!(~+[])+{})[--[~+&quot;&quot;][+[]]*[~+[]] + ~~!+[]]+({}+[])[[~!+[]]*~+[]]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考链接&quot;&gt;参考链接&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/52116922&quot;&gt;JavaScript中运算符优先级的问题？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rednaxelafx.iteye.com/blog/492667&quot;&gt;虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence&quot;&gt;运算符优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/Fresh-Air/archive/2013/03/24/2976278.html&quot;&gt;你能过我8关js运算符的题目吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/ziyunfei/archive/2012/09/16/2687589.html&quot;&gt;JavaScript中:表达式和语句的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 11 Oct 2017 14:15:00 +0000</pubDate>
<dc:creator>nobody-junior</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imgss/p/7653200.html</dc:identifier>
</item>
<item>
<title>jvm系列(十):如何优化Java GC「译」 - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/7653129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/7653129.html</guid>
<description>&lt;p&gt;本文由&lt;a href=&quot;https://crowhawk.github.io/&quot;&gt;CrowHawk&lt;/a&gt;翻译，地址：&lt;a href=&quot;https://crowhawk.github.io/2017/08/21/jvm_4/&quot;&gt;如何优化Java GC「译」&lt;/a&gt;，是Java GC调优的经典佳作。&lt;/p&gt;
&lt;p&gt;Sangmin Lee发表在&lt;a href=&quot;http://www.cubrid.org/blog&quot;&gt;Cubrid&lt;/a&gt;上的&quot;Become a Java GC Expert&quot;系列文章的第三篇&lt;a href=&quot;http://www.cubrid.org/blog/how-to-tune-java-garbage-collection&quot;&gt;《How to Tune Java Garbage Collection》&lt;/a&gt;,本文的作者是韩国人，写在JDK 1.8发布之前，虽然有些地方有些许过时，但整体内容还是非常有价值的。译者此前也看到有人翻译了本文，发现其中有许多错漏生硬和语焉不详之处，因此决定自己翻译一份，供大家分享。&lt;/p&gt;
&lt;p&gt;本文是“成为Java GC专家”系列文章的第三篇，在系列的第一篇文章&lt;a href=&quot;http://www.cubrid.org/blog/understanding-java-garbage-collection&quot;&gt;《理解Java GC》&lt;/a&gt;中，我们了解到了不同GC算法的执行过程、GC的工作原理、新生代和老年代的概念、JDK 7中你需要了解的5种GC类型以及每一种GC对性能的影响。&lt;/p&gt;
&lt;p&gt;在系列的第二篇文章&lt;a href=&quot;http://www.cubrid.org/blog/how-to-monitor-java-garbage-collection&quot;&gt;《如何监控Java GC》&lt;/a&gt;中笔者已经解释了JVM进行实时GC的原理、监控GC的方法以及可以使这一过程更加迅速高效的工具。&lt;/p&gt;
&lt;p&gt;在第三篇文章中，笔者将基于实际生产环境中的案例，介绍几个GC优化的最佳参数设置。在此我们假设你已经理解了本系列前两篇文章的内容，因此为了更深入的理解本文所讲内容，我建议你在阅读本篇文章之前先仔细阅读这两篇文章。&lt;/p&gt;

&lt;h2 id=&quot;gc优化是必要的吗&quot;&gt;GC优化是必要的吗？&lt;/h2&gt;
&lt;p&gt;或者更准确地说，GC优化对Java基础服务来说是必要的吗？答案是否定的，事实上GC优化对Java基础服务来说在有些场合是可以省去的，但前提是这些正在运行的Java系统，必须包含以下参数或行为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存大小已经通过&lt;strong&gt;-Xms&lt;/strong&gt;和&lt;strong&gt;-Xmx&lt;/strong&gt;参数指定过&lt;/li&gt;
&lt;li&gt;运行在server模式下（使用&lt;strong&gt;-server&lt;/strong&gt;参数）&lt;/li&gt;
&lt;li&gt;系统中没有残留超时日志之类的错误日志&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;换句话说，如果你在运行时没有手动设置内存大小并且打印出了过多的超时日志，那你就需要对系统进行GC优化。&lt;/p&gt;
&lt;p&gt;不过你需要时刻谨记一句话：&lt;strong&gt;GC tuning is the last task to be done.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在来想一想GC优化的最根本原因，垃圾收集器的工作就是清除Java创建的对象，垃圾收集器需要清理的对象数量以及要执行的GC数量均取决于已创建的对象数量。因此，为了使你的系统在GC上表现良好，首先需要减少创建对象的数量。&lt;/p&gt;
&lt;p&gt;俗话说“冰冻三尺非一日之寒”，我们在编码时要首先要把下面这些小细节做好，否则一些琐碎的不良代码累积起来将让GC的工作变得繁重而难于管理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;StringBuilder&lt;/code&gt;或&lt;code&gt;StringBuffer&lt;/code&gt;来代替&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;尽量少输出日志&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;尽管如此，仍然会有我们束手无策的情况。XML和JSON解析过程往往占用了最多的内存，即使我们已经尽可能地少用String、少输出日志，仍然会有大量的临时内存（大约10-100MB）被用来解析XML或JSON文件，但我们又很难弃用XML和JSON。在此，你只需要知道这一过程会占据大量内存即可。&lt;/p&gt;
&lt;p&gt;如果在经过几次重复的优化后应用程序的内存用量情况有所改善，那么久可以启动GC优化了。&lt;/p&gt;
&lt;p&gt;笔者总结了GC优化的两个目的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;将进入老年代的对象数量降到最低&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少Full GC的执行时间&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;将进入老年代的对象数量降到最低&quot;&gt;将进入老年代的对象数量降到最低&lt;/h2&gt;
&lt;p&gt;除了可以在JDK 7及更高版本中使用的G1收集器以外，其他分代GC都是由Oracle JVM提供的。关于分代GC，就是对象在Eden区被创建，随后被转移到Survivor区，在此之后剩余的对象会被转入老年代。也有一些对象由于占用内存过大，在Eden区被创建后会直接被传入老年代。老年代GC相对来说会比新生代GC更耗时，因此，减少进入老年代的对象数量可以显著降低Full GC的频率。你可能会以为减少进入老年代的对象数量意味着把它们留在新生代，事实正好相反，新生代内存的大小是可以调节的。&lt;/p&gt;

&lt;h2 id=&quot;降低full-gc的时间&quot;&gt;降低Full GC的时间&lt;/h2&gt;
&lt;p&gt;Full GC的执行时间比Minor GC要长很多，因此，如果在Full GC上花费过多的时间（超过1s），将可能出现超时错误。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果&lt;strong&gt;通过减小老年代内存来减少Full GC时间&lt;/strong&gt;，可能会引起&lt;code&gt;OutOfMemoryError&lt;/code&gt;或者导致Full GC的频率升高。&lt;/li&gt;
&lt;li&gt;另外，如果&lt;strong&gt;通过增加老年代内存来降低Full GC的频率&lt;/strong&gt;，Full GC的时间可能因此增加。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，&lt;strong&gt;你需要把老年代的大小设置成一个“合适”的值&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;影响gc性能的参数&quot;&gt;影响GC性能的参数&lt;/h2&gt;
&lt;p&gt;正如我在系列的第一篇文章&lt;a href=&quot;http://www.cubrid.org/blog/understanding-java-garbage-collection&quot;&gt;《理解Java GC》&lt;/a&gt;末尾提到的，不要幻想着“如果有人用他设置的GC参数获取了不错的性能，我们为什么不复制他的参数设置呢？”，因为对于不用的Web服务，它们创建的对象大小和生命周期都不相同。&lt;/p&gt;
&lt;p&gt;举一个简单的例子，如果一个任务的执行条件是A，B，C，D和E，另一个完全相同的任务执行条件只有A和B，那么哪一个任务执行速度更快呢？作为常识来讲，答案很明显是后者。&lt;/p&gt;
&lt;p&gt;Java GC参数的设置也是这个道理，设置好几个参数并不会提升GC执行的速度，反而会使它变得更慢。&lt;strong&gt;GC优化的基本原则&lt;/strong&gt;是将不同的GC参数应用到两个及以上的服务器上然后比较它们的性能，然后将那些被证明可以提高性能或减少GC执行时间的参数应用于最终的工作服务器上。&lt;/p&gt;
&lt;p&gt;下面这张表展示了与内存大小相关且会影响GC性能的GC参数&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;表1：GC优化需要考虑的JVM参数&lt;/strong&gt;&lt;/center&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;堆内存大小&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;-Xms&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;启动JVM时堆内存的大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;-Xmx&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;堆内存最大限制&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;新生代空间大小&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;-XX:NewRatio&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新生代和老年代的内存比&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;-XX:NewSize&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新生代内存大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;-XX:SurvivorRatio&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Eden区和Survivor区的内存比&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;笔者在进行GC优化时最常用的参数是&lt;code&gt;-Xms&lt;/code&gt;,&lt;code&gt;-Xmx&lt;/code&gt;和&lt;code&gt;-XX:NewRatio&lt;/code&gt;。&lt;code&gt;-Xms&lt;/code&gt;和&lt;code&gt;-Xmx&lt;/code&gt;参数通常是必须的，所以&lt;code&gt;NewRatio&lt;/code&gt;的值将对GC性能产生重要的影响。&lt;/p&gt;
&lt;p&gt;有些人可能会问&lt;strong&gt;如何设置永久代内存大小&lt;/strong&gt;，你可以用&lt;code&gt;-XX:PermSize&lt;/code&gt;和&lt;code&gt;-XX:MaxPermSize&lt;/code&gt;参数来进行设置，但是要记住，只有当出现&lt;code&gt;OutOfMemoryError&lt;/code&gt;错误时你才需要去设置永久代内存。&lt;/p&gt;
&lt;p&gt;还有一个会影响GC性能的因素是&lt;a href=&quot;https://crowhawk.github.io/2017/08/15/jvm_3/&quot;&gt;垃圾收集器的类型&lt;/a&gt;,下表展示了关于GC类型的可选参数（基于JDK 6.0）：&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;表2：GC类型可选参数&lt;/strong&gt;&lt;/center&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;Serial GC&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-XX:+UseSerialGC&lt;/td&gt;
&lt;td align=&quot;left&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;Parallel GC&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-XX:+UseParallelGC&lt;br/&gt;-XX:ParallelGCThreads=value&lt;/td&gt;
&lt;td align=&quot;left&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;Parallel Compacting GC&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-XX:+UseParallelOldGC&lt;/td&gt;
&lt;td align=&quot;left&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;CMS GC&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-XX:+UseConcMarkSweepGC&lt;br/&gt;-XX:+UseParNewGC&lt;br/&gt;-XX:+CMSParallelRemarkEnabled&lt;br/&gt;-XX:CMSInitiatingOccupancyFraction=value&lt;br/&gt;-XX:+UseCMSInitiatingOccupancyOnly&lt;/td&gt;
&lt;td align=&quot;left&quot;/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;G1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-XX:+UnlockExperimentalVMOptions&lt;br/&gt;-XX:+UseG1GC&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;在JDK 6中这两个参数必须配合使用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;除了G1收集器外，可以通过设置上表中每种类型第一行的参数来切换GC类型，最常见的非侵入式GC就是Serial GC，它针对客户端系统进行了特别的优化。&lt;/p&gt;
&lt;p&gt;会影响GC性能的参数还有很多，但是上述的参数会带来最显著的效果，请切记，设置太多的参数并不一定会提升GC的性能。&lt;/p&gt;

&lt;h2 id=&quot;gc优化的过程&quot;&gt;GC优化的过程&lt;/h2&gt;
&lt;p&gt;GC优化的过程和大多数常见的提升性能的过程相似，下面是笔者使用的流程：&lt;/p&gt;
&lt;h3 id=&quot;监控gc状态&quot;&gt;1.监控GC状态&lt;/h3&gt;
&lt;p&gt;你需要监控GC从而检查系统中运行的GC的各种状态，具体方法请查看系列的第二篇文章&lt;a href=&quot;http://www.cubrid.org/blog/how-to-monitor-java-garbage-collection&quot;&gt;《如何监控Java GC》&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;分析监控结果后决定是否需要优化gc&quot;&gt;2.分析监控结果后决定是否需要优化GC&lt;/h3&gt;
&lt;p&gt;在检查GC状态后，你需要分析监控结构并决定是否需要进行GC优化。如果分析结果显示运行GC的时间只有0.1-0.3秒，那么就不需要把时间浪费在GC优化上，但如果运行GC的时间达到1-3秒，甚至大于10秒，那么GC优化将是很有必要的。&lt;/p&gt;
&lt;p&gt;但是，如果你已经分配了大约10GB内存给Java，并且这些内存无法省下，那么就无法进行GC优化了。在进行GC优化之前，你需要考虑为什么你需要分配这么大的内存空间，如果你分配了1GB或2GB大小的内存并且出现了&lt;code&gt;OutOfMemoryError&lt;/code&gt;，那你就应该执行&lt;strong&gt;堆转储（heap dump）&lt;/strong&gt;来消除导致异常的原因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;堆转储（heap dump）&lt;/strong&gt;是一个用来检查Java内存中的对象和数据的内存文件。该文件可以通过执行JDK中的&lt;code&gt;jmap&lt;/code&gt;命令来创建。在创建文件的过程中，所有Java程序都将暂停，因此，不要再系统执行过程中创建该文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6.875&quot;&gt;
&lt;p&gt;你可以在互联网上搜索heap dump的详细说明。对于韩国读者，可以直接参考我去年发布的书：&lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=6654751&quot;&gt;《The story of troubleshooting for Java developers and system operators》&lt;/a&gt; (Sangmin Lee, Hanbit Media, 2011, 416 pages)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;设置gc类型内存大小&quot;&gt;3.设置GC类型/内存大小&lt;/h3&gt;
&lt;p&gt;如果你决定要进行GC优化，那么你需要选择一个GC类型并且为它设置内存大小。此时如果你有多个服务器，请如上文提到的那样，在每台机器上设置不同的GC参数并分析它们的区别。&lt;/p&gt;
&lt;h3 id=&quot;分析结果&quot;&gt;4.分析结果&lt;/h3&gt;
&lt;p&gt;在设置完GC参数后就可以开始收集数据，请在收集至少24小时后再进行结果分析。如果你足够幸运，你可能会找到系统的最佳GC参数。如若不然，你还需要分析输出日志并检查分配的内存，然后需要通过不断调整GC类型/内存大小来找到系统的最佳参数。&lt;/p&gt;
&lt;h3 id=&quot;如果结果令人满意将参数应用到所有服务器上并结束gc优化&quot;&gt;5.如果结果令人满意，将参数应用到所有服务器上并结束GC优化&lt;/h3&gt;
&lt;p&gt;如果GC优化的结果令人满意，就可以将参数应用到所有服务器上，并停止GC优化。&lt;/p&gt;
&lt;p&gt;在下面的章节中，你将会看到上述每一步所做的具体工作。&lt;/p&gt;

&lt;h2 id=&quot;监控gc状态并分析结果&quot;&gt;监控GC状态并分析结果&lt;/h2&gt;
&lt;p&gt;在运行中的Web应用服务器（Web Application Server,WAS）上查看GC状态的最佳方式就是使用&lt;code&gt;jstat&lt;/code&gt;命令。笔者在&lt;a href=&quot;http://www.cubrid.org/blog/how-to-monitor-java-garbage-collection&quot;&gt;《如何监控Java GC》&lt;/a&gt;中已经介绍过了&lt;code&gt;jstat&lt;/code&gt;命令，所以在本篇文章中我将着重关注数据部分。&lt;/p&gt;
&lt;p&gt;下面的例子展示了某个还没有执行GC优化的JVM的状态（虽然它并不是运行服务器）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ jstat -gcutil 21719 1s
S0    S1    E    O    P    YGC    YGCT    FGC    FGCT GCT
48.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.673
48.66 0.00 48.10 49.70 77.45 3428 172.623 3 59.050 231.673&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先看一下YGC（从应用程序启动到采样时发生 Young GC 的次数）和YGCT（从应用程序启动到采样时 Young GC 所用的时间(秒)），计算YGCT/YGC会得出，平均每次新生代的GC耗时50ms，这是一个很小的数字，通过这个结果可以看出，我们大可不必关注新生代GC对GC性能的影响。&lt;/p&gt;
&lt;p&gt;现在来看一下FGC（ 从应用程序启动到采样时发生 Full GC 的次数）和FGCT（从应用程序启动到采样时 Full GC 所用的时间(秒)），计算FGCT/FGC会得出，平均每次老年代的GC耗时19.68s。有可能是执行了三次Full GC，每次耗时19.68s，也有可能是有两次只花了1s,另一次花了58s。不管是哪一种情况，GC优化都是很有必要的。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;jstat&lt;/code&gt;命令可以很容易地查看GC状态，但是分析GC的最佳方式是加上&lt;code&gt;-verbosegc&lt;/code&gt;参数来生成日志。在之前的文章中笔者已经解释了如何分析这些日志。&lt;strong&gt;HPJMeter&lt;/strong&gt;是笔者最喜欢的用于分析&lt;code&gt;-verbosegc&lt;/code&gt;生成的日志的工具，它简单易用，使用HPJmeter可以很容易地查看GC执行时间以及GC发生频率。&lt;/p&gt;
&lt;p&gt;此外，如果GC执行时间满足下列所有条件，就没有必要进行GC优化了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Minor GC执行非常迅速（50ms以内）&lt;/li&gt;
&lt;li&gt;Minor GC没有频繁执行（大约10s执行一次）&lt;/li&gt;
&lt;li&gt;Full GC执行非常迅速（1s以内）&lt;/li&gt;
&lt;li&gt;Full GC没有频繁执行（大约10min执行一次）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;括号中的数字并不是绝对的，它们也随着服务的状态而变化。有些服务可能要求一次Full GC在0.9s以内，而有些则会放得更宽一些。因此，对于不同的服务，需要按照不同的标准考虑是否需要执行GC优化。&lt;/p&gt;
&lt;p&gt;当检查GC状态时，不能只查看Minor GC和Full GC的时间，还必须要&lt;strong&gt;关注GC执行的次数&lt;/strong&gt;。如果新生代空间太小，Minor GC将会非常频繁地执行（有时每秒会执行一次，甚至更多）。此外，传入老年代的对象数目会上升，从而导致Full GC的频率升高。因此，在执行&lt;code&gt;jstat&lt;/code&gt;命令时，请使用&lt;code&gt;-gccapacity&lt;/code&gt;参数来查看具体占用了多少空间。&lt;/p&gt;

&lt;h2 id=&quot;设置gc类型内存大小-1&quot;&gt;设置GC类型/内存大小&lt;/h2&gt;
&lt;h3 id=&quot;设置gc类型&quot;&gt;设置GC类型&lt;/h3&gt;
&lt;p&gt;Oracle JVM有5种垃圾收集器，但是在JDK 7以前的版本中，你只能在Parallel GC, Parallel Compacting GC 和CMS GC之中选择，至于具体选择哪个，则没有具体的原则和规则。&lt;/p&gt;
&lt;p&gt;既然这样的话，&lt;strong&gt;我们如何来选择GC呢？&lt;/strong&gt;最好的方法是把三种都用上，但是有一点必须明确——CMS GC通常比其他并行（Parallel）GC都要快（这是因为CMS GC是并发的GC），如果确实如此，那只选择CMS GC就可以了，不过CMS GC也不总是更快，当出现&lt;strong&gt;concurrent mode failure&lt;/strong&gt;时，CMS GC就会比并行GC更慢了。&lt;/p&gt;
&lt;p&gt;&lt;big&gt;&lt;strong&gt;Concurrent mode failure&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;现在让我们来深入地了解一下&lt;strong&gt;concurrent mode failure&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;并行GC和CMS GC的最大区别是并行GC采用“标记-整理”(Mark-Compact)算法而CMS GC采用“标记-清除”(Mark-Sweep)算法（具体内容可参照译者的文章&lt;a href=&quot;https://crowhawk.github.io/2017/08/10/jvm_2/&quot;&gt;《GC算法与内存分配策略》&lt;/a&gt;）,compact步骤就是通过移动内存来消除内存碎片，从而消除分配的内存之间的空白区域。&lt;/p&gt;
&lt;p&gt;对于并行GC来说，无论何时执行Full GC，都会进行compact工作，这消耗了太多的时间。不过在执行完Full GC后，下次内存分配将会变得更快（因为直接顺序分配相邻的内存）。&lt;/p&gt;
&lt;p&gt;相反，CMS GC没有compact的过程，因此CMS GC运行的速度更快。但是也是由于没有整理内存，在进行磁盘清理之前，内存中会有很多零碎的空白区域，这也导致没有足够的空间分配给大对象。例如，在老年代还有300MB可用空间，但是连一个10MB的对象都没有办法被顺序存储在老年代中，在这种情况下，会报出&lt;strong&gt;“concurrent mode failure”&lt;/strong&gt;的warning，然后系统执行compact操作。但是CMS GC在这种情况下执行的compact操作耗时要比并行GC高很多，并且这还会导致另一个问题，关于&lt;strong&gt;“concurrent mode failure”&lt;/strong&gt;的详细说明，可用参考Oracle工程师撰写的&lt;a href=&quot;https://blogs.oracle.com/poonam/understanding-cms-gc-logs&quot;&gt;《Understanding CMS GC Logs》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;综上所述，你需要根据你的系统情况为其选择一个最适合的GC类型。&lt;/p&gt;
&lt;p&gt;每个系统都有最适合它的GC类型等着你去寻找，如果你有6台服务器，我建议你每两个服务器设置相同的参数，然后加上&lt;code&gt;-verbosegc&lt;/code&gt;参数再分析结果。&lt;/p&gt;
&lt;h3 id=&quot;设置内存大小&quot;&gt;设置内存大小&lt;/h3&gt;
&lt;p&gt;下面展示了内存大小、GC运行次数和GC运行时间之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大内存空间&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;减少了GC的次数&lt;/li&gt;
&lt;li&gt;提高了GC的运行时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;小内存空间&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增多了GC的次数&lt;/li&gt;
&lt;li&gt;降低了GC的运行时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于如何设置内存的大小，没有一个标准答案，如果服务器资源充足并且Full GC能在1s内完成，把内存设为10GB也是可以的，但是大部分服务器并不处在这种状态中，当内存设为10GB时，Full GC会耗时10-30s,具体的时间自然与对象的大小有关。&lt;/p&gt;
&lt;p&gt;既然如此，&lt;strong&gt;我们该如何设置内存大小呢？&lt;/strong&gt;通常我推荐设为500MB，这不是说你要通过&lt;code&gt;-Xms500m&lt;/code&gt;和&lt;code&gt;-Xmx500m&lt;/code&gt;参数来设置WAS内存。根据GC优化之前的状态，如果Full GC后还剩余300MB的空间，那么把内存设为1GB是一个不错的选择（300MB（默认程序占用）+ 500MB（老年代最小空间）+200MB（空闲内存））。这意味着你需要为老年代设置至少500MB空间，因此如果你有三个运行服务器，可以把它们的内存分别设置为1GB，1.5GB，2GB，然后检查结果。&lt;/p&gt;
&lt;p&gt;理论上来说，GC执行速度应该遵循1GB&amp;gt; 1.5GB&amp;gt; 2GB，1GB内存时GC执行速度最快。然而，理论上的1GB内存Full GC消耗1s、2GB内存Full GC消耗2 s在现实里是无法保证的，实际的运行时间还依赖于服务器的性能和对象大小。因此，最好的方法是创建尽可能多的测量数据并监控它们。&lt;/p&gt;
&lt;p&gt;在设置内存空间大小时，你还需要设置一个参数：&lt;code&gt;NewRatio&lt;/code&gt;。&lt;code&gt;NewRatio&lt;/code&gt;的值是新生代和老年代空间大小的比例。如果&lt;code&gt;XX:NewRatio=1&lt;/code&gt;，则新生代空间:老年代空间=1:1，如果堆内存为1GB，则新生代:老年代=500MB:500MB。如果&lt;code&gt;NewRatio&lt;/code&gt;等于2，则新生代:老年代=1:2，因此，&lt;code&gt;NewRatio&lt;/code&gt;的值设置得越大，则老年代空间越大，新生代空间越小。&lt;/p&gt;
&lt;p&gt;你可能会认为把&lt;code&gt;NewRatio&lt;/code&gt;设为1会是最好的选择，然而事实并非如此，根据笔者的经验，当&lt;code&gt;NewRatio&lt;/code&gt;设为2或3时，整个GC的状态表现得更好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完成GC优化最快地方法是什么？&lt;/strong&gt;答案是比较性能测试的结果。为了给每台服务器设置不同的参数并监控它们，最好查看的是一或两天后的数据。当通过性能测试来进行GC优化时，你需要在不同的测试时保证它们有相同的负载和运行环境。然而，即使是专业的性能测试人员，想精确地控制负载也很困难，并且需要大量的时间准备。因此，更加方便容易的方式是直接设置参数来运行，然后等待运行的结果（即使这需要消耗更多的时间）。&lt;/p&gt;
&lt;h2 id=&quot;分析gc优化的结果&quot;&gt;分析GC优化的结果&lt;/h2&gt;
&lt;p&gt;在设置了GC参数和&lt;code&gt;-verbosegc&lt;/code&gt;参数后，可以使用tail命令确保日志被正确地生成。如果参数设置得不正确或日志未生成，那你的时间就被白白浪费了。如果日志收集没有问题的话，在收集一或两天数据后再检查结果。最简单的方法是把日志从服务器移到你的本地PC上，然后用&lt;strong&gt;HPJMeter&lt;/strong&gt;分析数据。&lt;/p&gt;
&lt;p&gt;在分析结果时，请关注下列几点（这个优先级是笔者根据自己的经验拟定的，我认为选取GC参数时应考虑的最重要的因素是Full GC的运行时间。）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单次Full GC运行时间&lt;/li&gt;
&lt;li&gt;单次Minor GC运行时间&lt;/li&gt;
&lt;li&gt;Full GC运行间隔&lt;/li&gt;
&lt;li&gt;Minor GC运行间隔&lt;/li&gt;
&lt;li&gt;整个Full GC的时间&lt;/li&gt;
&lt;li&gt;整个Minor GC的运行时间&lt;/li&gt;
&lt;li&gt;整个GC的运行时间&lt;/li&gt;
&lt;li&gt;Full GC的执行次数&lt;/li&gt;
&lt;li&gt;Minor GC的执行次数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;找到最佳的GC参数是件非常幸运的，然而在大多数时候，我们并不会如此幸运，在进行GC优化时一定要小心谨慎，因为当你试图一次完成所有的优化工作时，可能会出现&lt;code&gt;OutOfMemoryError&lt;/code&gt;错误。&lt;/p&gt;

&lt;h2 id=&quot;优化案例&quot;&gt;优化案例&lt;/h2&gt;
&lt;p&gt;到目前为止，我们一直在从理论上介绍GC优化，现在是时候将这些理论付诸实践了，我们将通过几个例子来更深入地理解GC优化。&lt;/p&gt;
&lt;h3 id=&quot;示例1&quot;&gt;示例1&lt;/h3&gt;
&lt;p&gt;下面这个例子是针对&lt;strong&gt;Service S&lt;/strong&gt;的优化，对于最近刚开发出来的Service S，执行Full GC需要消耗过多的时间。&lt;/p&gt;
&lt;p&gt;现在看一下执行&lt;code&gt;jstat -gcutil&lt;/code&gt;的结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;S0 S1 E O P YGC YGCT FGC FGCT GCT
12.16 0.00 5.18 63.78 20.32 54 2.047 5 6.946 8.993&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;左边的Perm区的值对于最初的GC优化并不重要，而YGC参数的值更加对于这次优化更为重要。&lt;/p&gt;
&lt;p&gt;平均执行一次Minor GC和Full GC消耗的时间如下表所示：&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;表3：Service S的Minor GC 和Full GC的平均执行时间&lt;/strong&gt;&lt;/center&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;Minor GC&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;54&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;2.047s&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;37ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;Full GC&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;6.946s&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;1.389s&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;37ms&lt;/strong&gt;对于Minor GC来说还不赖，但1.389s对于Full GC来说意味着当GC发生在数据库Timeout设置为1s的系统中时，可能会频繁出现超时现象。&lt;/p&gt;
&lt;p&gt;首先，你需要检查开始GC优化前内存的使用情况。使用&lt;code&gt;jstat -gccapacity&lt;/code&gt;命令可以检查内存用量情况。在笔者的服务器上查看到的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC PGCMN PGCMX PGC PC YGC FGC
212992.0 212992.0 212992.0 21248.0 21248.0 170496.0 1884160.0 1884160.0 1884160.0 1884160.0 262144.0 262144.0 262144.0 262144.0 54 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的关键值如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新生代内存用量：212,992 KB&lt;/li&gt;
&lt;li&gt;老年代内存用量：1,884,160 KB&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，除了永久代以外，被分配的内存空间加起来有2GB，并且新生代：老年代=1：9，为了得到比使用&lt;code&gt;jstat&lt;/code&gt;更细致的结果，还需加上&lt;code&gt;-verbosegc&lt;/code&gt;参数获取日志，并把三台服务器按照如下方式设置（除此以外没有使用任何其他参数）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NewRatio=2&lt;/li&gt;
&lt;li&gt;NewRatio=3&lt;/li&gt;
&lt;li&gt;NewRatio=4&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一天后我得到了系统的GC log，幸运的是，在设置完NewRatio后系统没有发生任何Full GC。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是为什么呢？&lt;/strong&gt;这是因为大部分对象在创建后很快就被回收了，所有这些对象没有被传入老年代，而是在新生代就被销毁回收了。&lt;/p&gt;
&lt;p&gt;在这样的情况下，就没有必要去改变其他的参数值了，只要选择一个最合适的&lt;code&gt;NewRatio&lt;/code&gt;值即可。那么，&lt;strong&gt;如何确定最佳的NewRatio值呢？&lt;/strong&gt;为此，我们分析一下每种&lt;code&gt;NewRatio&lt;/code&gt;值下Minor GC的平均响应时间。&lt;/p&gt;
&lt;p&gt;在每种参数下Minor GC的平均响应时间如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NewRatio=2：45ms&lt;/li&gt;
&lt;li&gt;NewRatio=3：34ms&lt;/li&gt;
&lt;li&gt;NewRatio=4：30ms&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以根据GC时间的长短得出NewRatio=4是最佳的参数值（尽管NewRatio=4时新生代空间是最小的）。在设置完GC参数后，服务器没有发生Full GC。&lt;/p&gt;
&lt;p&gt;为了说明这个问题，下面是服务执行一段时间后执行&lt;code&gt;jstat –gcutil&lt;/code&gt;的结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;S0 S1 E O P YGC YGCT FGC FGCT GCT
8.61 0.00 30.67 24.62 22.38 2424 30.219 0 0.000 30.219&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能会认为是服务器接收的请求少才使得GC发生的频率较低，实际上，虽然Full GC没有执行过，但Minor GC被执行了2424次。&lt;/p&gt;
&lt;h3 id=&quot;示例2&quot;&gt;示例2&lt;/h3&gt;
&lt;p&gt;这是一个Service A的例子。我们通过公司内部的应用性能管理系统（APM）发现JVM暂停了相当长的时间（超过8秒），因此我们进行了GC优化。我们努力寻找JVM暂停的原因，后来发现是因为Full GC执行时间过长，因此我们决定进行GC优化。&lt;/p&gt;
&lt;p&gt;在GC优化的开始阶段，我们加上了&lt;code&gt;-verbosegc&lt;/code&gt;参数，结果如下图所示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://pic.yupoo.com/crowhawk/ebb4b181/a24f4e9b.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;strong&gt;图1：进行GC优化之前STW的时间&lt;/strong&gt;&lt;/center&gt;
&lt;p&gt;上图是由HPJMeter生成的图片之一。横坐标表示JVM执行的时间，纵坐标表示每次GC的时间。CMS为绿点，表示Full GC的结果，而Parallel Scavenge为蓝点，表示Minor GC的结果。&lt;/p&gt;
&lt;p&gt;之前我说过CMS GC是最快的GC，但是上面的结果显示在一些时候CMS耗时达到了15s。&lt;strong&gt;是什么导致了这一结果？&lt;/strong&gt;请记住我之前说的：CMS在执行compact（整理）操作时会显著变慢。此外，服务的内存通过&lt;code&gt;-Xms1g&lt;/code&gt;和&lt;code&gt;=Xmx4g&lt;/code&gt;设置了，而分配的内存只有4GB。&lt;/p&gt;
&lt;p&gt;因此笔者将GC类型从CMS GC改为了Parallel GC，把内存大小设为2GB，并把&lt;code&gt;NewRatio&lt;/code&gt;设为3。在执行&lt;code&gt;jstat -gcutil&lt;/code&gt;几小时后的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;S0 S1 E O P YGC YGCT FGC FGCT GCT
0.00 30.48 3.31 26.54 37.01 226 11.131 4 11.758 22.890&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Full GC的时间缩短了，变成了每次3s，跟15s比有了显著提升。但是3s依然不够快，为此笔者创建了以下6种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Case 1: &lt;code&gt;-XX:+UseParallelGC -Xms1536m -Xmx1536m -XX:NewRatio=2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Case 2: &lt;code&gt;-XX:+UseParallelGC -Xms1536m -Xmx1536m -XX:NewRatio=3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Case 3: &lt;code&gt;-XX:+UseParallelGC -Xms1g -Xmx1g -XX:NewRatio=3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Case 4: &lt;code&gt;-XX:+UseParallelOldGC -Xms1536m -Xmx1536m -XX:NewRatio=2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Case 5: &lt;code&gt;-XX:+UseParallelOldGC -Xms1536m -Xmx1536m -XX:NewRatio=3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Case 6: &lt;code&gt;-XX:+UseParallelOldGC -Xms1g -Xmx1g -XX:NewRatio=3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;上面哪一种情况最快？&lt;/strong&gt;结果显示，内存空间越小，运行结果最少。下图展示了性能最好的Case 6的结果图，它的最慢响应时间只有1.7s，并且响应时间的平均值已经被控制到了1s以内。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://pic.yupoo.com/crowhawk/026cb5ec/dd3bdbb9.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;strong&gt;图2：Case 6的持续时间图&lt;/strong&gt;&lt;/center&gt;
&lt;p&gt;基于上图的结果，按照Case 6调整了GC参数，但这却导致每晚都会发生&lt;code&gt;OutOfMemoryError&lt;/code&gt;。很难解释发生异常的具体原因，简单地说，应该是批处理程序导致了内存泄漏，我们正在解决相关的问题。&lt;/p&gt;
&lt;p&gt;如果只对GC日志做一些短时间的分析就将相关参数部署到所有服务器上来执行GC优化，这将是非常危险的。切记，只有当你同时仔细分析服务的执行情况和GC日志后，才能保证GC优化没有错误地执行。&lt;/p&gt;
&lt;p&gt;在上文中，我们通过两个GC优化的例子来说明了GC优化是怎样执行的。正如上文中提到的，例子中设置的GC参数可以设置在相同的服务器之上，但前提是他们具有相同的CPU、操作系统、JDK版本并且运行着相同的服务。此外，不要把我使用的参数照搬到你的应用上，它们可能在你的机器上并不能起到同样良好的效果。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;笔者没有执行heap dump并分析内存的详细内容，而是通过自己的经验进行GC优化。精确地分析内存可以得到更好的优化效果，不过这种分析一般只适用于内存使用量相对固定的场景。如果服务严重过载并占有了大量的内存，则建议你根据之前的经验进行GC优化。&lt;/p&gt;
&lt;p&gt;笔者已经在一些服务上设置了G1 GC参数并进行了性能测试，但还没有应用于正式的生产环境。G1 GC的速度快于任何其他的GC类型，但是你必须要升级到JDK 7。此外，暂时还无法保证它的稳定性，没有人知道运行时是否会出现致命的错误，因此G1&lt;br/&gt;GC暂时还不适合投入应用。&lt;/p&gt;
&lt;p&gt;等未来JDK 7真正稳定了（这并不是说它现在不稳定），并且WAS针对JDK 7进行优化后，G1 GC最终能按照预期的那样来工作，等到那一天我们可能就不再需要GC优化了。&lt;/p&gt;
&lt;p&gt;想了解关于GC优化的更多细节，请前往&lt;a href=&quot;https://www.slideshare.net/&quot;&gt;Slideshare.com&lt;/a&gt; 查看相关资料。强烈推荐&lt;a href=&quot;https://www.slideshare.net/aszegedi/everything-i-ever-learned-about-jvm-performance-tuning-twitter&quot;&gt;Everything I Ever Learned About JVM Performance Tuning @Twitter&lt;/a&gt;,作者是Attila Szegedi, 一名Twitter工程师，请花些时间好好阅读它。&lt;/p&gt;
</description>
<pubDate>Wed, 11 Oct 2017 14:04:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ityouknow/p/7653129.html</dc:identifier>
</item>
<item>
<title>图论引导笔记 第七章 有向图 - uangjianghui</title>
<link>http://www.cnblogs.com/uangjianghui/p/7652955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/uangjianghui/p/7652955.html</guid>
<description>&lt;p&gt;定义：    &lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;弧/有向边&lt;/strong&gt;：有向图的集合E中的元素，E中元素为不同顶点的有序对。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;定向图&lt;/strong&gt;：(u,v)与(v,u)至多有一个是有向图D的弧的有向图。定向图可以是给无向图G的每一条边定下一个方向，故可以称是图G的一个定向。&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;子有向图&lt;/strong&gt;：如果V(H)V(D), E(H)E(D)，则有向图H是有向图D的一个子有向图。&lt;/p&gt;
&lt;p&gt;4、&lt;strong&gt;对称的&lt;/strong&gt;(有向图)：当(u,v)是有向图的一条弧度，则(v,u)也是有向图的一条弧。&lt;/p&gt;
&lt;p&gt;5、&lt;strong&gt;出/入度&lt;/strong&gt;：顶点v所邻接/邻接自的顶点个数，记id/od v。&lt;/p&gt;

&lt;p&gt;6、&lt;strong&gt;链&lt;/strong&gt;：有向图的一条路径，链上弧出现的次数为链的长度。记作&lt;/p&gt;
&lt;p&gt;7、(有向)&lt;strong&gt;迹&lt;/strong&gt;：一条没有重复弧的链。可以记作&lt;em&gt;u-v&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;8、(有向)&lt;strong&gt;路&lt;/strong&gt;：一条没有重复顶点的链。&lt;/p&gt;
&lt;p&gt;9、(链的)&lt;strong&gt;开/闭&lt;/strong&gt;：若则为闭的，若则为闭的。&lt;/p&gt;
&lt;p&gt;10、&lt;strong&gt;回路&lt;/strong&gt;：长度至少为2的闭迹。（没有重复弧）&lt;/p&gt;
&lt;p&gt;11、&lt;strong&gt;圈&lt;/strong&gt;：除了起始点外没有重复出现的顶点称为闭链。（没有重复点）&lt;/p&gt;

&lt;p&gt;12、&lt;strong&gt;基础图&lt;/strong&gt;：由图D通过除去D中弧的方向且用单边代替每对平行边所获得的图。与定向是相反的概念&lt;/p&gt;
&lt;p&gt;13、(有向图)&lt;strong&gt;连通/弱连通&lt;/strong&gt;：有向图D的基础图是连通的。&lt;/p&gt;
&lt;p&gt;14、&lt;strong&gt;强的/强连通图&lt;/strong&gt;：对于任意顶点对，均有一条&lt;em&gt;u-v&lt;/em&gt; 与&lt;em&gt;v-u&lt;/em&gt; 路.&lt;/p&gt;
&lt;p&gt;15、&lt;strong&gt;有向距离&lt;/strong&gt;：图D中最短的一条u-v路的长度。记作d(u,v)&lt;/p&gt;
&lt;p&gt;16、&lt;strong&gt;测地线&lt;/strong&gt;：长度为d(u,v)的u-v路。&lt;/p&gt;

&lt;p&gt;17、(强连通)有向图的&lt;strong&gt;Euler 回路&lt;/strong&gt;：包含图D每一条弧的回路。&lt;/p&gt;
&lt;p&gt;18、&lt;strong&gt;Euler有向图&lt;/strong&gt;：含有Euler回路的有向图。&lt;/p&gt;

&lt;p&gt;定理：    &lt;/p&gt;
&lt;p&gt;7.1 (有向图理论第一定理) 所有顶点的入度的总和等于出度的总和等于|G.E|。证明：显然&lt;/p&gt;
&lt;p&gt;7.2 u-v链长≥某条u-v路长。证明：显然&lt;/p&gt;
&lt;p&gt;7.3 有向图是强连通的当且仅当D含有一条闭生成链。证明：&quot;生成&quot;表示保留所有原来顶点，其余直接证明&lt;/p&gt;
&lt;p&gt;7.4 非平凡图是Euler的，当且仅当对于图D的每个顶点v，均有od v=id v。证明：顶点的每一次出现对出入度均贡献了1&lt;/p&gt;
&lt;p&gt;7.5 非平凡连通图G有一个强连通定向当且仅当G不含有割边（2边连通）。证明：充分性显然，必要性先给图中的圈定向&lt;/p&gt;



&lt;p&gt;定义：&lt;/p&gt;
&lt;p&gt;1、竞赛图：完全图的一个定向&lt;/p&gt;
&lt;p&gt;2、(有向图的)同构：\(G_1.V=G_2.V , G_1.E=G_2.E \),记作&lt;/p&gt;
</description>
<pubDate>Wed, 11 Oct 2017 14:04:00 +0000</pubDate>
<dc:creator>uangjianghui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/uangjianghui/p/7652955.html</dc:identifier>
</item>
<item>
<title>Django 1.10中文文档-聚合 - j_hao104</title>
<link>http://www.cnblogs.com/jhao/p/7653045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jhao/p/7653045.html</guid>
<description>&lt;p&gt;&lt;a class=&quot;reference internal&quot; href=&quot;http://django-chinese-doc.readthedocs.io/zh_CN/latest/topics/db/queries.html&quot;&gt;Django 数据库抽象API&lt;/a&gt; 描述了使用Django 查询来增删查改单个对象的方法。 然而，有时候你要获取的值需要根据一组对象聚合后才能得到。 这个主题指南描述了如何使用Django的查询来生成和返回聚合值的方法。&lt;/p&gt;
&lt;p&gt;整篇指南我们都将引用以下模型。这些模型用来记录多个网上书店的库存。&lt;/p&gt;
&lt;div class=&quot;highlight-python&quot; id=&quot;queryset-model-example&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num_awards&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;price&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DecimalField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_digits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;decimal_places&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rating&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FloatField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;authors&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ManyToManyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;publisher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ForeignKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pubdate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DateField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;books&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ManyToManyField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;registered_users&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PositiveIntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;id2&quot; readability=&quot;7&quot;&gt;
&lt;h2&gt;速查表&lt;/h2&gt;
&lt;p&gt;下面是在上面的模型上如何执行常见的聚合查询:&lt;/p&gt;
&lt;div class=&quot;highlight-python&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;# book 总数.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2452&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# publisher=BaloneyPress的book总数.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;publisher__name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'BaloneyPress'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;73&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 所有book的平均价格.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db.models&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price__avg'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;34.35&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 所有book的最高价格&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db.models&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Max&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price__max'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Decimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'81.20'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 每页均价&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db.models&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FloatField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sum&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;price_per_page&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'pages'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output_field&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FloatField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price_per_page'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.4470664529184653&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 下面的所有查询都涉及到遍历 Book&amp;lt;-&amp;gt;Publisher&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# foreign key relationship backwards.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Each publisher, each with a count of books as a &quot;num_books&quot; attribute.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db.models&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pubs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_books&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pubs&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QuerySet&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BaloneyPress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SalamiPress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pubs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_books&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;73&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# The top 5 publishers, in order by number of books.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pubs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_books&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order_by&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'-num_books'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pubs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_books&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1323&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;queryset&quot; readability=&quot;24.766791044776&quot;&gt;
&lt;h2&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 聚合&lt;/h2&gt;
&lt;p&gt;Django提供了两种生成聚合的方法。第一种方法是从整个 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 生成统计值。 比如，你想要计算所有在售书的平均价钱。Django的查询语法提供了一种方式描述所有图书的集合。:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot;&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们需要在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 对象上计算出汇总的值。这可以通过在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 后面添加 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/code&gt; 子句来实现:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db.models&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;{'price__avg': 34.35}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其实 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;all()&lt;/span&gt;&lt;/code&gt; 在这里可以省略，简化为:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;{'price__avg': 34.35}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/code&gt; 子句的参数是想要计算的聚合值，在这个例子中，是 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Book&lt;/span&gt;&lt;/code&gt; 模型中 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;price&lt;/span&gt;&lt;/code&gt; 字段的平均值。 &lt;a class=&quot;reference internal&quot; href=&quot;http://django-chinese-doc.readthedocs.io/zh_CN/latest/ref/models/querysets.html#aggregation-functions&quot;&gt;查询集参考&lt;/a&gt; 有所有的聚合函数。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/code&gt; 是 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 的一个终止子句，意思是说，它返回一个包含键值对的字典。 键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。 如果你想要为聚合值指定一个名称，可以在聚合子句中指定:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;average_price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;{'average_price': 34.35}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果你想要计算多个聚合，你可以在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/code&gt; 子句作为参数添加。比如， 如果你也想知道所有图书价格的最大值和最小值，可以这样查询:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db.models&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Min&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;{'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;id3&quot; readability=&quot;29.238938053097&quot;&gt;
&lt;h2&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 逐个对象的聚合&lt;/h2&gt;
&lt;p&gt;生成汇总值的第二种方法，是为 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 中每一个对象都生成一个独立的汇总值。 比如，你可能想知道每一本书有多少作者参与。每本书和作者是多对多的关系。 我们需要汇总 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 中每本书的这种关系。&lt;/p&gt;
&lt;p&gt;逐个对象的汇总结果可以由 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 子句生成。 当 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 子句被指定之后， &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 中的每个对象都会被注上特定的值。&lt;/p&gt;
&lt;p&gt;annotate(注解)的语法都和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/code&gt; 子句相同。 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 的每个参数都描述了将要被计算的聚合值。&lt;/p&gt;
&lt;p&gt;比如，给图书添加作者数量的注解:&lt;/p&gt;
&lt;div class=&quot;highlight-python&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;# Build an annotated queryset&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db.models&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'authors'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 查询queryset中的第一个对象&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;The&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Definitive&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Guide&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Django&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;authors__count&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 查询queryset中的第二个对象&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Practical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Django&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Projects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;authors__count&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/code&gt; 一样，注解的名称也根据聚合函数的名称和聚合字段的名称自动生成。 同样可以在指定注释时，通过提供别名来覆盖此默认名称:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_authors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'authors'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_authors&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_authors&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/code&gt; 不同的是， &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; &lt;em&gt;不是&lt;/em&gt; 结束子句。它返回的结果是一个 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 。 这个 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 可以使用任何 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 方法进行再次操作。包括 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;filter()&lt;/span&gt;&lt;/code&gt;, &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;order_by()&lt;/span&gt;&lt;/code&gt;, 甚至是再次使用 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 。&lt;/p&gt;
&lt;div class=&quot;section&quot; id=&quot;combining-multiple-aggregations&quot; readability=&quot;13.608391608392&quot;&gt;&lt;span id=&quot;id4&quot;/&gt;
&lt;h3&gt;组合多个聚合&lt;/h3&gt;
&lt;p&gt;组合多个 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 会产生 &lt;a class=&quot;reference external&quot; href=&quot;https://code.djangoproject.com/ticket/10060&quot;&gt;错误的结果&lt;/a&gt; ，因为使用的是join而不是子查询:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;authors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store_set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'authors'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'store'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;authors__count&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store__count&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;对于大多数的聚合, 都有这个没法避免的问题, 但是 &lt;a class=&quot;reference internal&quot; href=&quot;http://django-chinese-doc.readthedocs.io/zh_CN/latest/ref/models/querysets.html#django.db.models.Count&quot; title=&quot;django.db.models.Count&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Count&lt;/span&gt;&lt;/code&gt;&lt;/a&gt; 聚合带有一个 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;distinct&lt;/span&gt;&lt;/code&gt; 参数可以避免:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'authors'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distinct&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'store'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distinct&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;authors__count&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store__count&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonition-sql-query admonition&quot; readability=&quot;9&quot;&gt;
&lt;p class=&quot;first admonition-title&quot;&gt;如果不明白，可以查看SQL query!&lt;/p&gt;
&lt;p class=&quot;last&quot;&gt;如果想知道查询具体做了什么，请查看 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;query&lt;/span&gt;&lt;/code&gt; 属性。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;join&quot; readability=&quot;35.563235294118&quot;&gt;
&lt;h2&gt;Join和聚合&lt;/h2&gt;
&lt;p&gt;到目前为止，都是被查询的模型相关字段的聚合。然而，有时可能聚合的值是与所查询模型相关的模型。&lt;/p&gt;
&lt;p&gt;在聚合函数中指定聚合字段时，可以使用 &lt;a class=&quot;reference internal&quot; href=&quot;http://django-chinese-doc.readthedocs.io/zh_CN/latest/topics/db/queries.html#field-lookups-intro&quot;&gt;双下划线&lt;/a&gt; 指定关联关系，Django会自动读取关联表，计算关联对象的聚合。&lt;/p&gt;
&lt;p&gt;例如，要查找每个商店提供的图书的价格范围，可以使用注解:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db.models&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Min&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min_price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'books__price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'books__price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这段代码告诉 Django 获取 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Store&lt;/span&gt;&lt;/code&gt; 模型, join (通过多对多关系) 到 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Book&lt;/span&gt;&lt;/code&gt; 模型，然后对每本书的价格进行聚合，得出最小值和最大值。&lt;/p&gt;
&lt;p&gt;同样，这也适用于 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/code&gt; 子句。 如果你想知道所有书店中最便宜的书和最贵的书价格分别是多少:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min_price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'books__price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_price&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'books__price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Join链可以按需求一直延伸。 例如，想得到所有作者当中最小的年龄，可以这样写:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;youngest_age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'books__authors__age'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;id6&quot; readability=&quot;30.599137931034&quot;&gt;
&lt;h3&gt;遵循反向关系&lt;/h3&gt;
&lt;p&gt;和 &lt;a class=&quot;reference internal&quot; href=&quot;http://django-chinese-doc.readthedocs.io/zh_CN/latest/topics/db/queries.html#lookups-that-span-relationships&quot;&gt;夸关联关系查询&lt;/a&gt; 类似，作用在所查询模型的关联模型或者字段上的聚合和注解可以遍历”反向”关系。 这里也使用了相关模型的小写名称和双下划线。&lt;/p&gt;
&lt;p&gt;例如，查询所有出版商，并注解它们一共出了多少本书（注意是使用 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;book&lt;/span&gt;&lt;/code&gt; 指定 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Publisher&lt;/span&gt;&lt;/code&gt; -&amp;gt; &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Book&lt;/span&gt;&lt;/code&gt;的反向外键关系）:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db.models&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;(&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet``结果中，每个&lt;/span&gt; &lt;span class=&quot;pre&quot;&gt;``Publisher&lt;/span&gt;&lt;/code&gt; 都会包含一个额外的属性 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;book__count&lt;/span&gt;&lt;/code&gt; 。)&lt;/p&gt;
&lt;p&gt;也可以按照每个出版商，查询所有图书中最旧的那本:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldest_pubdate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book__pubdate'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;(返回的字典会包含一个键叫做 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;'oldest_pubdate'&lt;/span&gt;&lt;/code&gt; 。如果没有指定这样的别名，它将是 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;'book__pubdate__min'&lt;/span&gt;&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;这不仅仅是在外键关系上是这样。多对多关系也是如此。 例如，查询每个作者，注解上它写的所有书（以及合著的书）一共有多少页（ 注意如何使用 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;'book'&lt;/span&gt;&lt;/code&gt; 来指定 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Author&lt;/span&gt;&lt;/code&gt; -&amp;gt; &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Book&lt;/span&gt;&lt;/code&gt; 的多对多的反向关系）:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_pages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book__pages'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;(返回的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 中，每个 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Author&lt;/span&gt;&lt;/code&gt; 都有一个额外属性 叫做 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;total_pages&lt;/span&gt;&lt;/code&gt; 。如果没有指定这样的别名，默认将是 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;book__pages__sum&lt;/span&gt;&lt;/code&gt; 。)&lt;/p&gt;
&lt;p&gt;或者查询所有图书的平均评分，这些图书由存档过的作者所写:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;average_rating&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book__rating'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;(返回的字典会包含一个叫做 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;'average_rating'&lt;/span&gt;&lt;/code&gt; 的键。 如果没有指定这样的别名，它将是 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;'book__rating__avg'&lt;/span&gt;&lt;/code&gt;.)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;id7&quot; readability=&quot;23.906341463415&quot;&gt;
&lt;h2&gt;聚合 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 子句&lt;/h2&gt;
&lt;div class=&quot;section&quot; id=&quot;filter-and-exclude&quot; readability=&quot;34.903285231808&quot;&gt;
&lt;h3&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;filter()&lt;/span&gt;&lt;/code&gt; and &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;exclude()&lt;/span&gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;聚合也可以在过滤器中使用。 作用于普通模型字段的任何 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;filter()&lt;/span&gt;&lt;/code&gt; (或 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;exclude()&lt;/span&gt;&lt;/code&gt; ) 都会对聚合涉及的对象进行限制。&lt;/p&gt;
&lt;p&gt;使用 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 子句时, 筛选器具有约束注释被计算对象的作用。 例如，计算每本以 “Django” 为书名开头的图书的作者的总数:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db.models&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name__startswith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Django&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_authors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'authors'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/code&gt; 子句, 筛选器具有约束聚合被计算对象的作用。 例如，计算所有以 “Django” 为书名开头的图书平均价格:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name__startswith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Django&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'price'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;id8&quot; readability=&quot;12&quot;&gt;
&lt;h4&gt;对注解过滤&lt;/h4&gt;
&lt;p&gt;注解的值也可以被过滤。 而注解的别名也可以和模型字段一样，在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;filter()&lt;/span&gt;&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;exclude()&lt;/span&gt;&lt;/code&gt; 子句中使用。&lt;/p&gt;
&lt;p&gt;例如，要得到不止一个作者的图书，可以用:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_authors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'authors'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_authors__gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个查询首先计算注解结果，然后再生成一个作用于注解上的过滤器。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;annotate-filter&quot; readability=&quot;35.849721706865&quot;&gt;
&lt;h4&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;filter()&lt;/span&gt;&lt;/code&gt; 的顺序&lt;/h4&gt;
&lt;p&gt;在写一个包含 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;filter()&lt;/span&gt;&lt;/code&gt; 的复杂查询时，要特别注意作用于 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 子句的顺序。&lt;/p&gt;
&lt;p&gt;使用 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 子句作用于某个查询时,要根据查询的状态才能得出注解值，而状态由&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()``的位置决定，所以&lt;/span&gt; &lt;span class=&quot;pre&quot;&gt;``filter()&lt;/span&gt;&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 不能随意交换位置。&lt;/p&gt;
&lt;p&gt;比如，有以下数据:&lt;/p&gt;
&lt;ul class=&quot;simple&quot;&gt;&lt;li&gt;Publisher A 有两本 book，ratings 分别为4和5.&lt;/li&gt;
&lt;li&gt;Publisher B 有两本 book，ratings 分别为1和4.&lt;/li&gt;
&lt;li&gt;Publisher C 有一本 book，rating 为1.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Count&lt;/span&gt;&lt;/code&gt; 聚合为例:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;13&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;21&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_books&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distinct&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book__rating__gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_books&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;(&amp;lt;Publisher: A&amp;gt;, 2)&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_books&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;(&amp;lt;Publisher: B&amp;gt;, 2)&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book__rating__gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_books&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_books&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;(&amp;lt;Publisher: A&amp;gt;, 2)&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_books&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;(&amp;lt;Publisher: B&amp;gt;, 1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;两个查询都返回至少有一本书的rating大于3的publisher列表，因此publisher C不在列表中。&lt;/p&gt;
&lt;p&gt;在第一个查询中, 注解先于过滤, 因此过滤不会影响注解。设置 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;distinct=True&lt;/span&gt;&lt;/code&gt; 避免 &lt;a class=&quot;reference internal&quot; href=&quot;http://django-chinese-doc.readthedocs.io/zh_CN/latest/topics/db/aggregation.html#combining-multiple-aggregations&quot;&gt;query bug&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;第二个查询先计算每个publisher中rating的值超过3.0的图书。筛选器先于注释，因此筛选器在计算注释时已经约束了对象。&lt;/p&gt;
&lt;p&gt;下面是另一个是 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Avg&lt;/span&gt;&lt;/code&gt; 聚合的例子:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;20&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avg_rating&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book__rating'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book__rating__gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avg_rating&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;(&amp;lt;Publisher: A&amp;gt;, 4.5)  # (5+4)/2&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avg_rating&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;(&amp;lt;Publisher: B&amp;gt;, 2.5)  # (1+4)/2&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;book__rating__gt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avg_rating&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book__rating'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avg_rating&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;(&amp;lt;Publisher: A&amp;gt;, 4.5)  # (5+4)/2&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avg_rating&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;(&amp;lt;Publisher: B&amp;gt;, 4.0)  # 4/1 (book with rating 1 excluded)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;第一个查询是计算至少有一本书的rating超过3.0的publisher的所有图书的平均rating， 第二个查询要计算publisher的rating超过3.0的书的平均rating。&lt;/p&gt;
&lt;p&gt;这种情况，很难直观地了解ORM如何将复杂的queryset翻译成SQL查询， 因此在不清楚时，可以使用 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;str(queryset.query)&lt;/span&gt;&lt;/code&gt; 来检查SQL，并且多一点测试。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;order-by&quot; readability=&quot;10&quot;&gt;
&lt;h3&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;order_by()&lt;/span&gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;注解可以用来做为排序项。当你定义 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;order_by()&lt;/span&gt;&lt;/code&gt; 子句时， 也可以引用定义在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 中的任何别名。&lt;/p&gt;
&lt;p&gt;例如，根据图书作者数量的多少对 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 进行排序:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_authors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'authors'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order_by&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'num_authors'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;values&quot; readability=&quot;42.762545018007&quot;&gt;
&lt;h3&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;通常，注解值会添加到每个对象上- 一个被注解的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 会为初始 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 的每个对象返回一个结果集。 但是，如果使用了 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 子句，它就会限制结果中列的范围，对注解赋值的方法就会完全不同。不是在原始的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/code&gt; 返回结果中对每个对象中添加注解, 而是根据定义在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt;子句中的字段组合先对结果进行分组，再根据每个分组算出注解值， 这个注解值是根据分组中所有的成员计算而得的。&lt;/p&gt;
&lt;p&gt;例如，查询出每个作者所写的书的平均评分：:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;average_rating&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book__rating'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这段代码返回的是数据库中所有的作者以及他们所著图书的平均评分。&lt;/p&gt;
&lt;p&gt;但是如果你使用了 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 子句，结果是完全不同的:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'name'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;average_rating&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book__rating'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在这个例子中，作者会按名称分组，所以你只能得到某个唯一的作者分组的注解值。 也就是说如果你有两个作者同名，那么他们原本各自的查询结果将被合并到同一个结果中；两个作者的所有评分将被计算为一个平均分。&lt;/p&gt;
&lt;div class=&quot;section&quot; id=&quot;annotate-values&quot; readability=&quot;26&quot;&gt;
&lt;h4&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 的顺序&lt;/h4&gt;
&lt;p&gt;和使用 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;filter()&lt;/span&gt;&lt;/code&gt; 一样, 作用于某个查询的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 子句的顺序非常重要。如果&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 子句在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 之前, 就会根据 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 子句产生的分组来计算注解。&lt;/p&gt;
&lt;p&gt;但是，如果 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 子句在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 之前, 就会根据整个查询集生成注解。这种情况下，&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 子句只能限制输出的字段。&lt;/p&gt;
&lt;p&gt;举个例子，如果互换了上个例子中 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 子句的顺序:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;average_rating&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'book__rating'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'name'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'average_rating'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这段代码将给每个作者添加一个唯一的字段，但只有作者名称和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;average_rating&lt;/span&gt;&lt;/code&gt; 注解会返回在输出结果中。&lt;/p&gt;
&lt;dl class=&quot;docutils&quot;&gt;&lt;dt&gt;这里 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;average_rating&lt;/span&gt;&lt;/code&gt; 显式地包含在返回的列表当中。这也正是因为&lt;/dt&gt;
&lt;dd&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 子句的顺序问题。&lt;/dd&gt;
&lt;/dl&gt;&lt;p&gt;如果 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 子句在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 之前, 注解会被自动添加到结果集中。 但是，如果 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 子句作用于 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 之后, 您需要在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values&lt;/span&gt;&lt;/code&gt; 中显式地包含聚合列。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;aggregation-ordering-interaction&quot; readability=&quot;29.628832705756&quot;&gt;&lt;span id=&quot;id9&quot;/&gt;
&lt;h4&gt;默认排序和 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;order_by()&lt;/span&gt;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;查询集中的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;order_by()&lt;/span&gt;&lt;/code&gt; 部分(或是模型中默认定义的排序项) 会在选择输出数据时被用到。 即使这些字段没有在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 中指定也会被用到。 这些字段用来组合“相似”结果，它们可以使相似的结果行看起来是独立的。尤其是在计数的时候。&lt;/p&gt;
&lt;p&gt;通过例子中的方法，假设有一个这样的模型:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CharField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntegerField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ordering&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;关键的部分就是在模型默认排序项中设置的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;name&lt;/span&gt;&lt;/code&gt; 字段。 如果你想知道每个非重复的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;data&lt;/span&gt;&lt;/code&gt; 值出现的次数。可以这样写:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;# Warning: not quite correct!&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;...这部分代码的用意是想通过它们相同的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;data&lt;/span&gt;&lt;/code&gt; 值来分组 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Item&lt;/span&gt;&lt;/code&gt; 对象。然后在每个分组中计算 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;id&lt;/span&gt;&lt;/code&gt;总数。但是上面那样做是行不通的，这是因为默认排序项中的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;name&lt;/span&gt;&lt;/code&gt; 也是一个分组项。 所以这个查询会根据非重复的 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;(data,&lt;/span&gt; &lt;span class=&quot;pre&quot;&gt;name)&lt;/span&gt;&lt;/code&gt; 进行分组。想要得到正确的结果应该这样写:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;n&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order_by&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;...这样就清空了查询中的所有排序项。你也可以在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;order_by()&lt;/span&gt;&lt;/code&gt; 中使用“data”。这样结果还是一样的。&lt;/p&gt;
&lt;p&gt;这个行为与查询集文档中提到的 &lt;a class=&quot;reference internal&quot; href=&quot;http://django-chinese-doc.readthedocs.io/zh_CN/latest/ref/models/querysets.html#django.db.models.query.QuerySet.distinct&quot; title=&quot;django.db.models.query.QuerySet.distinct&quot;&gt;&lt;code class=&quot;xref py py-meth docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;distinct()&lt;/span&gt;&lt;/code&gt;&lt;/a&gt; 一样， 而且生成规则也一样： 通常情况下，如果希望在结果中有额外的列，就可以清除排序，或者确保它只有在 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;values()&lt;/span&gt;&lt;/code&gt; 中调用的字段。&lt;/p&gt;
&lt;div class=&quot;admonition note&quot; readability=&quot;8.5760869565217&quot;&gt;
&lt;p class=&quot;first admonition-title&quot;&gt;注解&lt;/p&gt;
&lt;p class=&quot;last&quot;&gt;您可能会问为什么Django没有删除多余的列。主要原因就是要保证使用 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;distinct()&lt;/span&gt;&lt;/code&gt; 和其他方法的一致性。Django &lt;strong&gt;从不&lt;/strong&gt; 从不删除您指定的排序约束 (不会改动那些方法的行为，因为这会违背 &lt;a class=&quot;reference internal&quot; href=&quot;http://django-chinese-doc.readthedocs.io/zh_CN/latest/misc/api-stability.html&quot;&gt;API stability&lt;/a&gt; 原则)。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;id10&quot; readability=&quot;11&quot;&gt;
&lt;h3&gt;聚合注解&lt;/h3&gt;
&lt;p&gt;你也可以在注解的结果上生成聚合。当你定义一个 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/code&gt; 子句时， 可以使用 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;annotate()&lt;/span&gt;&lt;/code&gt; 子句中定义的任何别名。&lt;/p&gt;
&lt;p&gt;例如，如果你想计算平均每本书有几个作者，可以注解每本图书的作者总数，然后再聚合作者总数:&lt;/p&gt;
&lt;div class=&quot;highlight-default&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.db.models&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_authors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'authors'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aggregate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'num_authors'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;{'num_authors__avg': 1.66}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 11 Oct 2017 13:47:00 +0000</pubDate>
<dc:creator>j_hao104</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jhao/p/7653045.html</dc:identifier>
</item>
<item>
<title>即时通信系统Openfire分析之五：会话管理 - Fordestiny</title>
<link>http://www.cnblogs.com/Fordestiny/p/7487053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Fordestiny/p/7487053.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　A拨了B的电话
　　电话接通
　　A问道：Are you OK？ 
　　B回复：I have a bug！
　　A挂了电话&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上面所喻整个过程就是所谓的会话。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　会话(Session)是一个客户与服务器之间的不中断的请求响应序列。注意其中“不中断”一词。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Openfire的通信，是以服务器为中转站的消息转发机制，客户端与服务器要实现通信，必须保持连接，即持有会话。Session的管理，集中在SessionManager模块中。&lt;/span&gt;&lt;/p&gt;

&lt;p data-source-line=&quot;17&quot;&gt;　　SessionManager提供了一系统与Session生命周期相关的管理功能，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LocalClientSession createClientSession(Connection conn, StreamID id, Locale language) ;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addSession(LocalClientSession session) ;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ClientSession getSession(JID from) ;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; removeSession(LocalClientSession session) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;17&quot;&gt;&lt;span&gt;　　Session的整个生命周期，大致的讲可以分为：预创建、认证、移除&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li data-source-line=&quot;19&quot;&gt;&lt;span&gt;　　预创建：在连接打开后，服务端收到客户端的第一个消息请求（即初始化流）时完成，此时的Session还不能用于通信&lt;/span&gt;&lt;/li&gt;
&lt;li data-source-line=&quot;21&quot;&gt;&lt;span&gt;　　认证：在资源绑定时完成，此时的Session被添加到会话管理队列以及路由表中，象征着已具备通信功能&lt;/span&gt;&lt;/li&gt;
&lt;li data-source-line=&quot;23&quot;&gt;&lt;span&gt;　　移除：当连接空闲或者关闭时，Session被移除&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;25&quot;&gt;&lt;span&gt;　　下面，就重点来看看，Openfire是具体是如何实现对Session的管理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　回顾一下上一章的内容：ConnectionHandler类作为MINA的处理器，ConnectionHandler中的messageReceived()方法是消息的接收入口，接收到的消息交由StanzaHandler类处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　StanzaHandler.process()方法在处理消息时，首先调用本类中createSession()方法，完成了对Session的预创建。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; createSession(String namespace, String serverName, XmlPullParser xpp, Connection connection)
&lt;/span&gt;&lt;span&gt;throws&lt;/span&gt; XmlPullParserException;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上面的createSession()是一个抽象方法，由其子类完成。本文我们以C2S通信为研究对象，故其实现子类为：ClientStanzaHandler类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ClientStanzaHandler.createSession()方法代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; createSession(String namespace, String serverName, XmlPullParser xpp, Connection connection)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; XmlPullParserException {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;jabber:client&quot;&lt;span&gt;.equals(namespace)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The connected client is a regular client so create a ClientSession&lt;/span&gt;
        session =&lt;span&gt; LocalClientSession.createSession(serverName, xpp, connection);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里创建了一个LocalClientSession类型的Session对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LocalClientSession.createSession()方法如下，只保留与创建流程相关的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LocalClientSession createSession(String serverName, XmlPullParser xpp, Connection connection)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; XmlPullParserException {
  
    ......

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create a ClientSession for this user.&lt;/span&gt;
    LocalClientSession session =&lt;span&gt; SessionManager.getInstance().createClientSession(connection, language);
    ......
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; session;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;SessionManager.createClientSession()方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LocalClientSession createClientSession(Connection conn, StreamID id, Locale language) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (serverName == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Server not initialized&quot;&lt;span&gt;);
    }
    LocalClientSession session &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LocalClientSession(serverName, conn, id, language);
    conn.init(session);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register to receive close notification on this session so we can
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove  and also send an unavailable presence if it wasn't
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sent before&lt;/span&gt;
&lt;span&gt;    conn.registerCloseListener(clientSessionListener, session);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add to pre-authenticated sessions.&lt;/span&gt;
&lt;span&gt;    localSessionManager.getPreAuthenticatedSessions().put(session.getAddress().getResource(), session);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increment the counter of user sessions&lt;/span&gt;
&lt;span&gt;    connectionsCounter.incrementAndGet();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; session;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上面的方法，生成了一个LocalClientSession类型的Session对象，并添加到preAuthenticatedSessions队列中，表示预创建完成。便此时的Session并没有加入到路由表，还不能用来通信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另外，createClientSession()方法中，conn.registerCloseListener()则是注册了Session的关闭监听，作用是当Connection关掉时，Session也相应清除掉。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　在第一章，《Openfire与XMPP协议》一中已经介绍，资源绑定其实是用户登录过程的其中一步。亦即，在这里完成了Session的认证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　资源绑定是一个IQ消息，结合上一章《消息路由》中的分析，对于IQ消息，PacketRouterImpl模块使用IQRouter来完成路由。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　IQRouter.route()方法如下，其中只保留资源绑定部分代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; route(IQ packet) {
    ......
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        ......
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (session == &lt;span&gt;null&lt;/span&gt; || session.getStatus() == Session.STATUS_AUTHENTICATED ||&lt;span&gt; (
                childElement &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; isLocalServer(to) &amp;amp;&amp;amp;&lt;span&gt; (
                    &lt;/span&gt;&quot;jabber:iq:auth&quot;.equals(childElement.getNamespaceURI()) ||
                    &quot;jabber:iq:register&quot;.equals(childElement.getNamespaceURI()) ||
                    &quot;urn:ietf:params:xml:ns:xmpp-bind&quot;&lt;span&gt;.equals(childElement.getNamespaceURI())))) {
            handle(packet);
        } 
        ......
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (PacketRejectedException e) {
        ......
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　其中，handle()方法创建了处理该IQ的IQHandler，并调用IQandler中的process()进行包处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　IQRouter.handle()：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handle(IQ packet) {
    JID recipientJID &lt;/span&gt;=&lt;span&gt; packet.getTo();
    ......
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isLocalServer(recipientJID)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (namespace == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            ......
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            IQHandler handler &lt;/span&gt;=&lt;span&gt; getHandler(namespace);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
               ......
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                handler.process(packet);
            }
        }
    }
    ......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;传入的参数&quot;namespace&quot;，是IQ的唯一标识码，将决定了这个IQ由谁来处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　资源绑定的namespace为：urn:ietf:params:xml:ns:xmpp-bind，也就是说，这个IQ，最终将交给IQBindHandler来处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看到，IQBindHandler的构造方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IQBindHandler() {
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(&quot;Resource Binding handler&quot;&lt;span&gt;);
    info &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; IQHandlerInfo(&quot;bind&quot;, &quot;urn:ietf:params:xml:ns:xmpp-bind&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　包处理方法IQHandler.process()：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; process(Packet packet) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; PacketException {
    IQ iq &lt;/span&gt;=&lt;span&gt; (IQ) packet;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        IQ reply &lt;/span&gt;=&lt;span&gt; handleIQ(iq);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (reply != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            deliverer.deliver(reply);
        }
    }
   ......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　IQBindHandler.handleIQ()中，setAuthToken()方法实现对Session认证。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IQ handleIQ(IQ packet) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UnauthorizedException {
    LocalClientSession session &lt;/span&gt;=&lt;span&gt; (LocalClientSession) sessionManager.getSession(packet.getFrom());
    IQ reply &lt;/span&gt;=&lt;span&gt; IQ.createResultIQ(packet);
    Element child &lt;/span&gt;= reply.setChildElement(&quot;bind&quot;, &quot;urn:ietf:params:xml:ns:xmpp-bind&quot;&lt;span&gt;);
    ......
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (authToken.isAnonymous()) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; User used ANONYMOUS SASL so initialize the session as an anonymous login&lt;/span&gt;
&lt;span&gt;        session.setAnonymousAuth();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        ......
        session.setAuthToken(authToken, resource);
    }
    child.addElement(&lt;/span&gt;&quot;jid&quot;&lt;span&gt;).setText(session.getAddress().toString());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send the response directly since a route does not exist at this point.&lt;/span&gt;
&lt;span&gt;    session.process(reply);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; After the client has been informed, inform all listeners as well.&lt;/span&gt;
&lt;span&gt;    SessionEventDispatcher.dispatchEvent(session, SessionEventDispatcher.EventType.resource_bound);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　Session的认证后，其实就是将Session加入SessionManager中，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;LocalClientSession.setAuthToken():

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAuthToken(AuthToken auth, String resource) {
    ......
    sessionManager.addSession(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在第四章分析消息路由时，发送消息前，首先用ToJID从路由表中获取Session，接着再进行消息路由。也就是说，一条消息能否被接收到，取决于接收者的Session是否存在于路由表中。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　而SessionManager.addSession()刚好就是将Session加入路由表，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SessionManager.addSession()：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addSession(LocalClientSession session) {

    routingTable.addClientRoute(session.getAddress(), session);
    ....
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　此时，就代表了这个Session拥有了全部的功能，可以用来进行通信了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　移除工作就相对简单一些了，当监听到Connection关闭时，应清除掉相应的Session。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在SessionManager的私有类ClientSessionListener实现了ConnectionCloseListener，能及时地监听到Connection关闭并进行Session的清除工作。监听是在Session预创建时注册，上文已经介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Session的关闭监听，ClientSessionListener类如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClientSessionListener &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ConnectionCloseListener {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Handle a session that just closed.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; handback The session that just closed
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onConnectionClose(Object handback) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            LocalClientSession session &lt;/span&gt;=&lt;span&gt; (LocalClientSession) handback;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((session.getPresence().isAvailable() || !session.wasAvailable()) &amp;amp;&amp;amp;&lt;span&gt;
                        routingTable.hasClientRoute(session.getAddress())) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send an unavailable presence to the user's subscribers
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Note: This gives us a chance to send an unavailable presence to the
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; entities that the user sent directed presences&lt;/span&gt;
                    Presence presence = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Presence();
                    presence.setType(Presence.Type.unavailable);
                    presence.setFrom(session.getAddress());
                    router.route(presence);
                }

                session.getStreamManager().onClose(router, serverAddress);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove the session&lt;/span&gt;
&lt;span&gt;                removeSession(session);
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Can't do anything about this problem...&lt;/span&gt;
            Log.error(LocaleUtils.getLocalizedString(&quot;admin.error.close&quot;&lt;span&gt;), e);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　先关闭Sessoin，然后移除出队列。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Over！&lt;/p&gt;

</description>
<pubDate>Wed, 11 Oct 2017 13:23:00 +0000</pubDate>
<dc:creator>Fordestiny</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Fordestiny/p/7487053.html</dc:identifier>
</item>
<item>
<title>Hadoop（三）手把手教你搭建Hadoop全分布式集群 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7652686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7652686.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　上一篇介绍了伪分布式集群的搭建，其实在我们的生产环境中我们肯定不是使用只有一台服务器的伪分布式集群当中的。接下来我将给大家分享一下全分布式集群的搭建！&lt;/p&gt;
&lt;p&gt;　　其实搭建最基本的全分布式集群和伪分布式集群基本没有什么区别，只有很小的区别。&lt;/p&gt;

&lt;h2&gt;1.1、网络&lt;/h2&gt;
&lt;p&gt;　　1）如果是在一台虚拟机中安装多个linux操作系统的话，可以使用NAT或桥接模式都是可以的。试一试可不可以相互ping通！&lt;/p&gt;
&lt;p&gt;　　2）如果在一个局域网当中，自己的多台电脑（每台电脑安装相同版本的linux系统）搭建，将所要使用的Ubuntu操作系统的网络模式调整为桥接模式。&lt;/p&gt;
&lt;p&gt;　　　　步骤：&lt;/p&gt;
&lt;p&gt;　　　　　　一是：在要使用的虚拟机的标签上右键单击，选择设置，选择网络适配器，选择桥接模式，确定&lt;/p&gt;
&lt;p&gt;　　　　　　二是：设置完成之后，重启一下虚拟机　&lt;/p&gt;
&lt;p&gt;　　　　　　三是：再设置桥接之前将固定的IP取消　　　&lt;/p&gt;
&lt;p&gt;　　　　　　　　桌面版：通过图形化界面设置的。&lt;br/&gt;　　　　　　　　服务器版：在/etc/network/interfaces&lt;br/&gt;　　　　　　　　　　　　iface ens33 inet dhcp&lt;br/&gt;　　　　　　　　　　　　#address ...&lt;/p&gt;
&lt;p&gt;　　　　　　四是：ifconfig获取IP。172.16.21.xxx　　　&lt;/p&gt;
&lt;p&gt;　　　　　　最后试一试能不能ping通&lt;/p&gt;
&lt;h2&gt;1.2、安装jdk&lt;/h2&gt;
&lt;p&gt;　　每一个要搭建集群的服务器都需要安装jdk，这里就不介绍了，可以查看上一篇&lt;/p&gt;
&lt;h2&gt;1.3、安装hadoop&lt;/h2&gt;
&lt;p&gt;　　每一个要搭建集群的服务器都需要安装hadoop，这里就不介绍了，可以查看上一篇。&lt;/p&gt;

&lt;p&gt;配置/opt/hadoop/etc/hadoop相关文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011210631637-1313576504.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;146&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.1、hadoop-env.sh　　&lt;/h2&gt;
&lt;p&gt;　　25行左右：export JAVA_HOME=${JAVA_HOME}&lt;br/&gt;　　改成：export JAVA_HOME=/opt/jdk&lt;/p&gt;
&lt;h2&gt;2.2、core-site.xml　&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;hdfs:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mip:9000&amp;lt;/value&amp;gt;&lt;/span&gt;
            &amp;lt;/property&amp;gt;
        &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　分析：&lt;/p&gt;
&lt;p&gt;　　　　　　mip：在主节点的mip就是自己的ip，而所有从节点的mip是主节点的ip。&lt;/p&gt;
&lt;p&gt;　　　　　　9000：主节点和从节点配置的端口都是9000&lt;/p&gt;
&lt;h2&gt;2.3、hdfs-site.xml&lt;/h2&gt;
&lt;p&gt;　　注意：**:下面配置了几个目录。需要将/data目录使用-R给权限为777。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;dfs.nameservices&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;hadoop-cluster&amp;lt;/value&amp;gt;
            &amp;lt;/property&amp;gt;
            &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;dfs.replication&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;/value&amp;gt;
            &amp;lt;/property&amp;gt;
            &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;dfs.namenode.name.dir&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/nn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
            &amp;lt;/property&amp;gt;
            &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;dfs.namenode.checkpoint.dir&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/snn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
            &amp;lt;/property&amp;gt;
            &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;dfs.namenode.checkpoint.edits.dir&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/snn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
            &amp;lt;/property&amp;gt;
            &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;dfs.datanode.data.dir&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/dn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
            &amp;lt;/property&amp;gt;
        &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　分析：&lt;/p&gt;
&lt;p&gt;　　　　　　dfs.nameservices：在一个全分布式集群大众集群当中这个的value要相同&lt;/p&gt;
&lt;p&gt;　　　　　　dfs.replication：因为hadoop是具有可靠性的，它会备份多个文本，这里value就是指备份的数量（小于等于从节点的数量）&lt;/p&gt;
&lt;p&gt;　　　一个问题：&lt;/p&gt;
&lt;p&gt;　　　　　　dfs.datanode.data.dir：这里我在配置的时候遇到一个问题，就是当使用的这个的时候从节点起不来。当改成fs.datanode.data.dir就有用了。&lt;/p&gt;
&lt;p&gt;　　　　　　但是官方给出的文档确实就是这个呀！所以很邪乎。因为只有2.0版本之前是fs&lt;/p&gt;
&lt;h2&gt;2.4.mapred-site.xml　　　　　　　　&lt;/h2&gt;
&lt;p&gt;　　注意：如果在刚解压之后，是没有这个文件的，需要将mapred-site.xml.template复制为mapred-site.xml。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;property&amp;gt;&lt;br/&gt;　　　　　　&amp;lt;!-指定Mapreduce运行在yarn上--&amp;gt;
                &amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt;
            &amp;lt;/property&amp;gt;
        &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.5、yarn-site.xml　　&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;!-- 指定ResourceManager的地址--&amp;gt;
            &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;yarn.resourcemanager.hostname&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;&lt;span&gt;mip&lt;/span&gt;&amp;lt;/value&amp;gt;
            &amp;lt;/property&amp;gt;
            &amp;lt;!-- 指定reducer获取数据的方式--&amp;gt;
            &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;
            &amp;lt;/property&amp;gt;
            &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;yarn.nodemanager.local-dirs&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/yarn/nm&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
            &amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　分析：&lt;/p&gt;
&lt;p&gt;　　　　mip：在主节点的mip就是自己的ip，而所有从节点的mip是主节点的ip。&lt;/p&gt;
&lt;h2&gt;2.6、创建上面配置的目录&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    sudo mkdir -p /data/hadoop/hdfs/&lt;span&gt;nn
    sudo mkdir &lt;/span&gt;-p /data/hadoop/hdfs/&lt;span&gt;dn
    sudo mkdir &lt;/span&gt;-p /data/hadoop/hdfs/&lt;span&gt;snn
    sudo mkdir &lt;/span&gt;-p /data/hadoop/yarn/nm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一定要设置成：sudo chmod -R 777 /data&lt;/p&gt;

&lt;h2&gt;3.1、运行环境&lt;/h2&gt;
&lt;p&gt;　　有三台ubuntu服务器（ubuntu 17.04）：&lt;/p&gt;
&lt;p&gt;　　　　　　主机名：udzyh1   IP：1.0.0.5     作为主节点（名字节点）&lt;/p&gt;
&lt;p&gt;　　　　　　主机名：server1   IP：1.0.0.3     作为从节点（数据节点）&lt;/p&gt;
&lt;p&gt;　　　　　　主机名：udzyh2    IP：1.0.0.7     作为从节点（数据节点）　&lt;/p&gt;
&lt;p&gt;　　jdk1.8.0_131&lt;/p&gt;
&lt;p&gt;　　hadoop 2.8.1&lt;/p&gt;
&lt;h2&gt;3.2、服务器集群的启动与关闭&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011194818699-1664586371.png&quot; alt=&quot;&quot; width=&quot;702&quot; height=&quot;315&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　名字节点、资源管理器：这是在主节点中启动或关闭的。&lt;/p&gt;
&lt;p&gt;　　数据节点、节点管理器：这是在从节点中启动或关闭的。&lt;/p&gt;
&lt;p&gt;　　MR作业日志管理器：这是在主节点中启动或关闭的。&lt;/p&gt;
&lt;h2&gt;3.3、效果&lt;/h2&gt;
&lt;p&gt;　　在主节点：udzyh1中&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011195415371-1892475792.png&quot; alt=&quot;&quot; width=&quot;675&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　在从节点：server1中&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011195608199-2048709922.png&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;210&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　在从节点：udzyh2中&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011195838699-1832720293.png&quot; alt=&quot;&quot; width=&quot;643&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们在主节点的web控制页面中:http:1.0.0.5:50070中查看到两个从节点&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011200817105-585668931.png&quot; alt=&quot;&quot; width=&quot;763&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　说明配置成功&lt;/p&gt;
&lt;h2&gt;3.4、监控平台&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011200947637-148028421.png&quot; alt=&quot;&quot; width=&quot;447&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;

&lt;p&gt;配置这个是为了实现主节点管理（开启和关闭）从节点的功能：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011201144496-1993881608.png&quot; alt=&quot;&quot; width=&quot;279&quot; height=&quot;151&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们只需要在主节点中&lt;span&gt;使用start-dfs.sh/stop-dfs.sh就能开启或关闭namenode和所有的datanode，使用start-yarn.sh/stop-yarn.sh就能开启或关闭resourcemanager和所有的nodemanager。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.1、配置主从节点之间的免密登录&lt;/h2&gt;
&lt;p&gt;　　1）在所有的主从节点中执行&lt;/p&gt;
&lt;p&gt;　　　　如果以前配置过免密登录的话，建议删除重新建立过，因为我们需要配置的是多台服务器：&lt;/p&gt;
&lt;p&gt;　　　　　　rm -r  ~/.ssh&lt;/p&gt;
&lt;p&gt;　　　　 执行ssh-keygen为了在主节点中生成公钥和私钥，在从从节点生成.ssh目录&lt;/p&gt;
&lt;p&gt;　　2）在主节点中执行　&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　　　scp  ~/.ssh/id_rsa.pub   从节点的用户名@从节点ip:~&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　注意：第一次远程连接的话，首先输入yes，然后是从节点密码&lt;/p&gt;
&lt;div readability=&quot;39&quot;&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011201600840-690474627.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;170&quot;/&gt;&lt;p&gt;　　3）在所有的从节点中执行&lt;/p&gt;
&lt;p&gt;　　　　我们把主节点的公钥已经拿到了所有的从节点中，接下来就是：&lt;/p&gt;
&lt;p&gt;　　　　　　cat id_rsa.pub&amp;gt;&amp;gt;.ssh/authorized_keys当中&lt;/p&gt;
&lt;p&gt;　　　　在从节点:1.0.0.3&lt;/p&gt;
&lt;div readability=&quot;60&quot;&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011201639840-1135694903.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　　　在从节点1.0.0.7&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011201700168-1694874764.png&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;125&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4）测试&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011201935605-185158499.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　我们可以查看他们是用户名相同的，所以可以直接使用ssh 1.0.0.3远程连接&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011202039949-404146050.png&quot; alt=&quot;&quot; width=&quot;440&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.2、实现主节点控制从节点&lt;/h2&gt;
&lt;p&gt;　　1）在主节点中&lt;/p&gt;
&lt;p&gt;　　　　打开vi  /opt/hadoop/etc/hadoop/slaves&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011202328855-1601683571.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　　　把它删掉，然后配置上&lt;span&gt;所有从节点的主机名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　注意：这样配置的前提是&lt;span&gt;主节点要能免密登录到从节点中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　当&lt;span&gt;你去执行start-dfs.sh时，它会去slaves文件中去找从节点&lt;/span&gt;（这就是配置免密登录的原因）&lt;/p&gt;
&lt;p&gt;　　　　然后去启动从节点。同时&lt;span&gt;自己也需要做免密登录也就是说要自己对自己做免密登录&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;　　2）在主节点中&lt;/p&gt;
&lt;p&gt;　　　　&lt;span class=&quot;Apple-converted-space&quot;&gt;   cat .ssh/id_rsa.pub &amp;gt;&amp;gt; .ssh/authorized_keys &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　3）&lt;span class=&quot;Apple-converted-space&quot;&gt; 测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　ssh  127.0.0.1&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011202537762-1318761404.png&quot; alt=&quot;&quot; width=&quot;498&quot; height=&quot;194&quot;/&gt;　
&lt;p&gt;　　注意：在主节点&lt;span&gt;执行start-dfs.sh中主节点的用户名必须和所有从节点的用户名相同&lt;/span&gt;。因为那个服务器执&lt;span&gt;行这个脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　  就以这个用户名去远程登录到其他从节点的服务器中，所以在所有的生产环境中控制同一类集群的用户一定要相同。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;4.3、测试实现主节点控制从节点&lt;/h2&gt;
&lt;p&gt;　　1）在主节点的服务器中执行start-dfs.sh&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011210915496-105192459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）在web监控平台查询&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011211016043-1972889960.png&quot; alt=&quot;&quot; width=&quot;885&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）在主节点的服务器中执行stop-dfs.sh&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011211139527-1781672298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）在主节点的服务器中执行start-yarn.sh&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011211221902-446838606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4）在web监控平台查询到&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011211345637-264777332.png&quot; alt=&quot;&quot; width=&quot;721&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5）在主节点的服务器中执行stop-yarn.sh&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011211502590-263932362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2）主节点和从节点启动了，但是在主节点的web控制页面查找不到从节点（linux系统安装在不同的物理机上面）&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011202149418-1361764742.png&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解决方案：　　　&lt;/p&gt;
&lt;p&gt;　　 在服务器添加完公钥之后，ssh服务器然后报了这个错误&lt;/p&gt;
&lt;p&gt;       　　 sign_and_send_pubkey: signing failed: agent refused operation&lt;/p&gt;
&lt;p&gt;        然后执行了以下命令才好。。&lt;/p&gt;
&lt;p&gt;        　　eval &quot;$(ssh-agent -s)&quot;  注意：-s前面有空格&lt;/p&gt;
&lt;p&gt;         　 ssh-add&lt;/p&gt;
&lt;p&gt;　　3）&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011202702855-657846724.png&quot; alt=&quot;&quot; width=&quot;777&quot; height=&quot;222&quot;/&gt;&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;　　　　在所有主节点和从节点的服务器中的/etc/hosts中：   删除所有关于ipv6的配置&lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171011202723934-1795732772.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　　　它不能建立IPv6的连接，所以删除了IPv6之后系统会使用IPv4（在主节点上添加从节点的标识的）&lt;/p&gt;
&lt;p&gt;　　4）在主节点的web控制页面查询不到从节点信息（但是使用jps可以查询到）&lt;/p&gt;
&lt;p&gt;    　　我说过需要在etc/hosts文件中加入所有集群服务器的ip和主机名&lt;/p&gt;
&lt;p&gt;    　　但是今天今天我测试的时候出现问题，然后我就把&lt;span&gt;主从节点的在hosts文件配置的各个节点的ip+主机的配置删除了&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　　我估计这是因为我是在一台虚拟机中安装了多台的ubuntu中进行搭建集群的原因。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;喜欢就点个“推荐”哦！ &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 11 Oct 2017 13:22:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7652686.html</dc:identifier>
</item>
</channel>
</rss>