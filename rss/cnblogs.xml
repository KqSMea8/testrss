<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python Deep learning 学习笔记（4） - 范中豪</title>
<link>http://www.cnblogs.com/zhhfan/p/9978099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhhfan/p/9978099.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本节讲卷积神经网络的可视化&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;三种方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;可视化卷积神经网络的中间输出（中间激活）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有助于理解卷积神经网络连续的层如何对输入进行变换，也有助于初步了解卷积神经网络每个过滤器的含义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可视化卷积神经网络的过滤器&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有助于精确理解卷积神经网络中每个过滤器容易接受的视觉模式或视觉概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;可视化图像中类激活的热力图&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有助于理解图像的哪个部分被识别为属于某个类别，从而可以定位图像中的物体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;可视化中间激活&lt;/strong&gt;&lt;br/&gt;是指对于给定输入，展示网络中各个卷积层和池化层输出的特征图，这让我们可以看到输入如何被分解为网络学到的不同过滤器。我们希望在三个维度对特征图进行可视化：宽度、高度和深度（通道）。每个通道都对应相对独立的特征，所以将这些特征图可视化的正确方法是将每个通道的内容分别绘制成二维图像&lt;/p&gt;
&lt;p&gt;Keras加载模型方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from keras.models import load_model
model = load_model('cats_and_dogs_small_2.h5')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可视化方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from keras.models import load_model
from keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt
from keras import models


model = load_model('dogVScat.h5')
# 查看模型
model.summary()
img_path = &quot;C:\\Users\\fan\\Desktop\\testDogVSCat\\test\\cats\\cat.1700.jpg&quot;

img = image.load_img(img_path, target_size=(150, 150))
img_tensor = image.img_to_array(img)
img_tensor = np.expand_dims(img_tensor, axis=0)
img_tensor /= 255
# shape(1, 150, 150, 3)
print(img_tensor.shape)
plt.title(&quot;original cat&quot;)
plt.imshow(img_tensor[0])
plt.show()
# 提取前 8 层的输出
layer_outputs = [layer.output for layer in model.layers[:8]]
# 创建一个模型，给定模型输入，可以返回这些输出
activation_model = models.Model(inputs=model.input, outputs=layer_outputs)
# 返回8个Numpy数组组成的列表，每个层激活对应一个 Numpy 数组
activations = activation_model.predict(img_tensor)
first_layer_activation = activations[0]
# 将第 4 个通道可视化
plt.matshow(first_layer_activation[0, :, :, 4])
plt.show()
# 将每个中间激活的所有通道可视化
layer_names = []
for layer in model.layers[:8]:
    layer_names.append(layer.name)
images_per_row = 16
for layer_name, layer_activation in zip(layer_names, activations):
    # 特征图中的特征个数
    n_features = layer_activation.shape[-1]
    size = layer_activation.shape[1]
    # 在这个矩阵中将激活通道平铺
    n_cols = n_features // images_per_row
    display_grid = np.zeros((size * n_cols, images_per_row * size))
    for col in range(n_cols):
        for row in range(images_per_row):
            channel_image = layer_activation[0, :, :, col * images_per_row + row]
            # 对特征进行后处理，使其看起来更美观
            channel_image -= channel_image.mean()
            if channel_image.std() != 0:
                channel_image /= channel_image.std()
            channel_image *= 64
            channel_image += 128
            channel_image = np.clip(channel_image, 0, 255).astype('uint8')
            display_grid[col * size: (col + 1) * size,
            row * size: (row + 1) * size] = channel_image
    scale = 1. / size
    plt.figure(figsize=(scale * display_grid.shape[1],
                        scale * display_grid.shape[0]))
    plt.title(layer_name)
    plt.grid(False)
    plt.imshow(display_grid, aspect='auto', cmap='viridis')
    plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;br/&gt;原始猫&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153117739-313475574.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模型，使用之上第一个介绍的猫狗二分类的模型&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153136300-1604382245.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一层&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153147501-1687990486.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四层&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153156214-1930650653.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第七层&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153207057-987317739.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第八层&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153215817-184222930.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着层数的加深，激活变得越来越抽象，并且越来越难以直观地理解。它们开始表示更高层次的概念&lt;br/&gt;即，随着层数的加深，层所提取的特征变得越来越抽象。更高的层激活包含关于特定输入的信息越来越少，而关于目标的信息越来越多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可视化卷积神经网络的过滤器&lt;/strong&gt;&lt;br/&gt;想要观察卷积神经网络学到的过滤器，另一种简单的方法是显示每个过滤器所响应的视觉模式。这可以通过在输入空间中进行&lt;strong&gt;梯度上升&lt;/strong&gt;来实现：从空白输入图像开始，将&lt;strong&gt;梯度下降&lt;/strong&gt;应用于卷积神经网络输入图像的值，其目的是让某个过滤器的响应最大化。得到的输入图像是选定过滤器具有最大响应的图像&lt;/p&gt;
&lt;p&gt;过程&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;首先，需要构建一个损失函数，其目的是让某个卷积层的某个过滤器的值最大化；然后，我们要使用随机梯度下降来调节输入图像的值，以便让这个激活值最大化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;from keras import backend as K
import numpy as np
from keras.applications import VGG16
import matplotlib.pyplot as plt
from keras.preprocessing import image


# 将张量转换为有效图像
def deprocess_image(x):
    x -= x.mean()
    x /= (x.std() + 1e-5)
    x *= 0.1
    x += 0.5
    # 将 x 裁切（clip）到 [0, 1] 区间
    x = np.clip(x, 0, 1)
    x *= 255
    # 将 x 转换为 RGB 数组
    x = np.clip(x, 0, 255).astype('uint8')
    return x


# 生成过滤器可视化
def generate_pattern(layer_name, filter_index, size=150):
    layer_output = model.get_layer(layer_name).output
    loss = K.mean(layer_output[:, :, :, filter_index])
    grads = K.gradients(loss, model.input)[0]
    grads /= (K.sqrt(K.mean(K.square(grads))) + 1e-5)
    iterate = K.function([model.input], [loss, grads])
    input_img_data = np.random.random((1, size, size, 3)) * 20 + 128.
    step = 1.
    for i in range(40):
        loss_value, grads_value = iterate([input_img_data])
        input_img_data += grads_value * step
    img = input_img_data[0]
    return deprocess_image(img)


# 为过滤器的可视化定义损失张量
model = VGG16(weights='imagenet', include_top=False)
layer_name = 'block3_conv1'
filter_index = 0
layer_output = model.get_layer(layer_name).output
loss = K.mean(layer_output[:, :, :, filter_index])
# 　获取损失相对于输入的梯度
grads = K.gradients(loss, model.input)[0]
# 将梯度张量除以其 L2 范数来标准化
grads /= (K.sqrt(K.mean(K.square(grads))) + 1e-5)
# 　给定 Numpy 输入值，得到 Numpy 输出值
iterate = K.function([model.input], [loss, grads])
loss_value, grads_value = iterate([np.zeros((1, 150, 150, 3))])

# 　通过随机梯度下降让损失最大化
# 从一个带噪声的随机图像开始
input_img_data = np.random.random((1, 150, 150, 3)) * 20 + 128.
plt.imshow(image.array_to_img(input_img_data[0]))
plt.show()
step = 1.
for i in range(40):
    loss_value, grads_value = iterate([input_img_data])
    input_img_data += grads_value * step


def draw_layer_filter(layer_name):
    size = 64
    margin = 5
    results = np.zeros((8 * size + 7 * margin, 8 * size + 7 * margin, 3))
    for i in range(8):
        for j in range(8):
            filter_img = generate_pattern(layer_name, i + (j * 8), size=size)
            horizontal_start = i * size + i * margin
            horizontal_end = horizontal_start + size
            vertical_start = j * size + j * margin
            vertical_end = vertical_start + size
            results[horizontal_start: horizontal_end, vertical_start: vertical_end, :] = filter_img
    plt.figure(figsize=(20, 20))
    results = image.array_to_img(results)
    plt.imshow(results)
    plt.show()


draw_layer_filter(layer_name='block1_conv1')
draw_layer_filter(layer_name='block4_conv1')

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;br/&gt;输入图像&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153253540-1508015726.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;过滤器: block1_conv1&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153304568-1917738436.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;过滤器：block4_conv1&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153315485-314331895.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过对比发现&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;模型第一层（block1_conv1）的过滤器对应简单的方向边缘和颜色（还有一些是彩色边缘）&lt;br/&gt;高层的过滤器类似于自然图像中的纹理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;可视化类激活的热力图&lt;/strong&gt;&lt;br/&gt;这种可视化方法有助于了解一张图像的哪一部分让卷积神经网络做出了最终的分类决策。这有助于对卷积神经网络的决策过程进行调试，特别是出现分类错误的情况下。这种方法还可以定位图像中的特定目标&lt;br/&gt;这种通用的技术叫作&lt;strong&gt;类激活图（CAM，class activation map）可视化&lt;/strong&gt;，它是指对输入图像生成类激活的热力图。类激活热力图是与特定输出类别相关的二维分数网格，对任何输入图像的每个位置都要进行计算，它表示每个位置对该类别的重要程度&lt;br/&gt;&lt;strong&gt;&lt;a&gt;一种方法&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;给定一张输入图像，对于一个卷积层的输出特征图，用类别相对于通道的梯度对这个特征图中的每个通道进行加权&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;from keras.applications.vgg16 import VGG16
from keras.preprocessing import image
from keras.applications.vgg16 import preprocess_input, decode_predictions
import numpy as np
from keras import backend as K
import matplotlib.pyplot as plt
from PIL import Image
import cv2


model = VGG16(weights='imagenet')
img_path = 'E:\\study\\研究生\\笔记\\studyNote\\bookStudy\\bookNote\\imgs\\testImg.png'
img = image.load_img(img_path, target_size=(224, 224))
x = image.img_to_array(img)
# 添加一个维度，将数组转换为(1, 224, 224, 3) 形状的批量
x = np.expand_dims(x, axis=0)
x = preprocess_input(x)

preds = model.predict(x)
print('Predicted:', decode_predictions(preds, top=3)[0])
# 索引编号
np.argmax(preds[0])
# 来使用 Grad-CAM 算法展示图像中哪些部分最像非洲象
african_elephant_output = model.output[:, 386]
last_conv_layer = model.get_layer('block5_conv3')
grads = K.gradients(african_elephant_output, last_conv_layer.output)[0]
pooled_grads = K.mean(grads, axis=(0, 1, 2))
iterate = K.function([model.input], [pooled_grads, last_conv_layer.output[0]])
pooled_grads_value, conv_layer_output_value = iterate([x])
for i in range(512):
    conv_layer_output_value[:, :, i] *= pooled_grads_value[i]
heatmap = np.mean(conv_layer_output_value, axis=-1)

# 热力图后处理
heatmap = np.maximum(heatmap, 0)
heatmap /= np.max(heatmap)
plt.matshow(heatmap)
plt.show()

# 将热力图与原始图像叠加
img = Image.open(img_path).convert('RGB')
img = np.array(img)

heatmap = cv2.resize(heatmap, (img.shape[1], img.shape[0]))

heatmap = np.uint8(255 * heatmap)
heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)

superimposed_img = heatmap * 0.4 + img
cv2.imwrite('elephant_cam.jpg', superimposed_img)

superimposed_img = image.array_to_img(superimposed_img)
plt.imshow(superimposed_img)
plt.show()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原始图像&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153343626-1276862148.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;热力图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153357178-1383825648.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;混合图像&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153404220-1153829341.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存的图像&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503464/201811/1503464-20181118153415906-1746334420.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此处保存的图像和显示的图像不一致&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhhfan/p/9974805.html&quot;&gt;python Deep learning 学习笔记（3）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 07:35:00 +0000</pubDate>
<dc:creator>范中豪</dc:creator>
<og:description>卷积神经网络的可视化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhhfan/p/9978099.html</dc:identifier>
</item>
<item>
<title>Vue脚手架搭建项目 - ProsperLee</title>
<link>http://www.cnblogs.com/lprosper/p/9978085.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lprosper/p/9978085.html</guid>
<description>&lt;p&gt;&lt;strong&gt;全局安装vue脚手架&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;$ npm install -g vue-cli&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;卸载方法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;$ npm uninstall -g vue-cli&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;查看vue版本（注意：大写的V）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;$&lt;/strong&gt; &lt;strong&gt;vue -V&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;创建项目&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;$ vue init webpack vue-app&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;? Project name &lt;span&gt;vue-app&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;? Project description &lt;span&gt;Vue Project&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;? Author &lt;span&gt;ProsperLee &amp;lt;lcsshengsss@outlook.com&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;? Vue build (Use arrow keys)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;gt; Runtime + Compiler: recommended for most users&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specific HTML) are ONLY allowed in .vue files - render functions are required elsewhere&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;? Install vue-router? &lt;span&gt;No&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;? Use ESLint to lint your code? No? Set up unit tests &lt;span&gt;No&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;? Setup e2e tests with Nightwatch? &lt;span&gt;No&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;? Should we run `npm install` for you after the project has been created? (recommended)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(Use arrow keys)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;gt; Yes, use NPM&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  Yes, use Yarn&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  No, I will handle that myself&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目根目录下执行：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;$ npm run dev&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;安装路由&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;$ npm install vue-router --save-dev&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;安装vue-resource&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;$ npm install vue-resource --save-dev&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;安装WangEditor&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;$ npm install wangeditor --save-dev&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;打包项目&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;$ npm run dev&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401533/201811/1401533-20181118153311991-1480288368.png&quot; alt=&quot;&quot; width=&quot;100%&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 18 Nov 2018 07:31:00 +0000</pubDate>
<dc:creator>ProsperLee</dc:creator>
<og:description>全局安装vue脚手架 $ npm install -g vue-cli 卸载方法 $ npm uninstall -g vue-cli 查看vue版本（注意：大写的V） $ vue -V 创建项目 $</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lprosper/p/9978085.html</dc:identifier>
</item>
<item>
<title>一个秒杀系统设计详解 - 王守昌</title>
<link>http://www.cnblogs.com/wangshouchang/p/9978080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangshouchang/p/9978080.html</guid>
<description>&lt;p&gt;一些数据：&lt;/p&gt;
&lt;p&gt;大家还记得2013年的小米秒杀吗？三款小米手机各11万台开卖，走的都是大秒系统，3分钟后成为双十一第一家也是最快破亿的旗舰店。经过日志统计，前端系统双11峰值有效请求约60w以上的QPS ，而后端cache的集群峰值近2000w/s、单机也近30w/s，但到真正的写时流量要小很多了，当时最高下单减库存tps是红米创造，达到1500/s。&lt;/p&gt;
&lt;p&gt;热点隔离：&lt;/p&gt;
&lt;p&gt;秒杀系统设计的第一个原则就是将这种热点数据隔离出来，不要让1%的请求影响到另外的99%，隔离出来后也更方便对这1%的请求做针对性优化。针对秒杀我们做了多个层次的隔离：&lt;/p&gt;

&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;业务隔离。&lt;/strong&gt;把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就是已知热点，当真正开始时我们可以提前做好预热。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;系统隔离。&lt;/strong&gt;系统隔离更多是运行时的隔离，可以通过分组部署的方式和另外99%分开。秒杀还申请了单独的域名，目的也是让请求落到不同的集群中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;数据隔离。&lt;/strong&gt;秒杀所调用的数据大部分都是热数据，比如会启用单独cache集群或MySQL数据库来放热点数据，目前也是不想0.01%的数据影响另外99.99%。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然实现隔离很有多办法，如可以按照用户来区分，给不同用户分配不同cookie，在接入层路由到不同服务接口中；还有在接入层可以对URL的不同Path来设置限流策略等。服务层通过调用不同的服务接口；数据层可以给数据打上特殊的标来区分。目的都是把已经识别出来的热点和普通请求区分开来。&lt;/p&gt;
&lt;p&gt;动静分离：&lt;/p&gt;
&lt;p&gt;前面介绍在系统层面上的原则是要做隔离，接下去就是要把热点数据进行动静分离，这也是解决大流量系统的一个重要原则。如何给系统做动静分离的静态化改造我以前写过一篇《高访问量系统的静态化架构设计》详细介绍了淘宝商品系统的静态化设计思路，感兴趣的可以在《程序员》杂志上找一下。我们的大秒系统是从商品详情系统发展而来，所以本身已经实现了动静分离，如图1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/106546/201603/106546-20160311085422741-351230722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外还有如下特点：&lt;/p&gt;

&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把整个页面Cache在用户浏览器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果强制刷新整个页面，也会请求到CDN&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实际有效请求只是“刷新抢宝”按钮&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样把90%的静态数据缓存在用户端或者CDN上，当真正秒杀时用户只需要点击特殊的按钮“刷新抢宝”即可，而不需要刷新整个页面，这样只向服务端请求很少的有效数据，而不需要重复请求大量静态数据。秒杀的动态数据和普通的详情页面的动态数据相比更少，性能也比普通的详情提升3倍以上。所以“刷新抢宝”这种设计思路很好地解决了不刷新页面就能请求到服务端最新的动态数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于时间分片削峰&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;熟悉淘宝秒杀的都知道，第一版的秒杀系统本身并没有答题功能，后面才增加了秒杀答题，当然秒杀答题一个很重要的目的是为了防止秒杀器，2011年秒杀非常火的时候，秒杀器也比较猖獗，而没有达到全民参与和营销的目的，所以增加的答题来限制秒杀器。增加答题后，下单的时间基本控制在2s后，秒杀器的下单比例也下降到5%以下。新的答题页面如图2。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/106546/201603/106546-20160311085525069-839354616.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实增加答题还有一个重要的功能，就是把峰值的下单请求给拉长了，从以前的1s之内延长到2~10s左右，请求峰值基于时间分片了，这个时间的分片对服务端处理并发非常重要，会减轻很大压力，另外由于请求的先后，靠后的请求自然也没有库存了，也根本到不了最后的下单步骤，所以真正的并发写就非常有限了。其实这种设计思路目前也非常普遍，如支付宝的“咻一咻”已及微信的摇一摇。&lt;/p&gt;

&lt;p&gt;除了在前端通过答题在用户端进行流量削峰外，在服务端一般通过锁或者队列来控制瞬间请求。&lt;/p&gt;
&lt;p&gt;数据分层校验&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/106546/201603/106546-20160311085634288-326981967.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;364&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对大流量系统的数据做分层校验也是最重要的设计原则，所谓分层校验就是对大量的请求做成“漏斗”式设计，如图3所示：在不同层次尽可能把无效的请求过滤，“漏斗”的最末端才是有效的请求，要达到这个效果必须对数据做分层的校验，下面是一些原则：&lt;/p&gt;

&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先做数据的动静分离&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将90%的数据缓存在客户端浏览器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将动态请求的读数据Cache在Web端&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对读数据不做强一致性校验&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对写数据进行基于时间的合理分片&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对写请求做限流保护&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对写数据进行强一致性校验&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;秒杀系统正是按照这个原则设计的系统架构，如图4所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/106546/201603/106546-20160311090220319-1269411862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把大量静态不需要检验的数据放在离用户最近的地方；在前端读系统中检验一些基本信息，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束等；在写数据系统中再校验一些如是否是非法请求，营销等价物是否充足（淘金币等），写的数据一致性如检查库存是否还有等；最后在数据库层保证数据最终准确性，如库存不能减为负数。&lt;/p&gt;
&lt;p&gt;实时热点发现：&lt;/p&gt;
&lt;p&gt;其实秒杀系统本质是还是一个数据读的热点问题，而且是最简单一种，因为在文提到通过业务隔离，我们已能提前识别出这些热点数据，我们可以提前做一些保护，提前识别的热点数据处理起来还相对简单，比如分析历史成交记录发现哪些商品比较热门，分析用户的购物车记录也可以发现那些商品可能会比较好卖，这些都是可以提前分析出来的热点。比较困难的是那种我们提前发现不了突然成为热点的商品成为热点，这种就要通过实时热点数据分析了，目前我们设计可以在3s内发现交易链路上的实时热点数据，然后根据实时发现的热点数据每个系统做实时保护。 具体实现如下：&lt;/p&gt;

&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;构建一个异步的可以收集交易链路上各个中间件产品如Tengine、Tair缓存、HSF等本身的统计的热点key（Tengine和Tair缓存等中间件产品本身已经有热点统计模块）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（详情、购物车、交易、优惠、库存、物流）访问的时间差，把上游已经发现的热点能够透传给下游系统，提前做好保护。比如大促高峰期详情系统是最早知道的，在统计接入层上Tengine模块统计的热点URL。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将上游的系统收集到热点数据发送到热点服务台上，然后下游系统如交易系统就会知道哪些商品被频繁调用，然后做热点保护。如图5所示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/106546/201603/106546-20160311090334897-1850634288.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;重要的几个：其中关键部分包括：&lt;/p&gt;

&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这个热点服务后台抓取热点数据日志最好是异步的，一方面便于做到通用性，另一方面不影响业务系统和中间件产品的主流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;热点服务后台、现有各个中间件和应用在做的没有取代关系，每个中间件和应用还需要保护自己，热点服务后台提供一个收集热点数据提供热点订阅服务的统一规范和工具，便于把各个系统热点数据透明出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;热点发现要做到实时（3s内）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关键技术及优化点：&lt;/p&gt;
&lt;p&gt;前面介绍了一些如何设计大流量读系统中用到的原则，但是当这些手段都用了，还是有大流量涌入该如何处理呢？秒杀系统要解决几个关键问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java处理大并发动态请求优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实Java和通用的Web服务器相比（Nginx或Apache）在处理大并发HTTP请求时要弱一点，所以一般我们都会对大流量的Web系统做静态化改造，让大部分请求和数据直接在Nginx服务器或者Web代理服务器（Varnish、Squid等）上直接返回（可以减少数据的序列化与反序列化），不要将请求落到Java层上，让Java层只处理很少数据量的动态请求，当然针对这些请求也有一些优化手段可以使用：&lt;/p&gt;

&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;直接使用Servlet处理请求。&lt;/strong&gt;避免使用传统的MVC框架也许能绕过一大堆复杂且用处不大的处理逻辑，节省个1ms时间，当然这个取决于你对MVC框架的依赖程度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;直接输出流数据。&lt;/strong&gt;使用resp.getOutputStream()而不是resp.getWriter()可以省掉一些不变字符数据编码，也能提升性能；还有数据输出时也推荐使用JSON而不是模板引擎（一般都是解释执行）输出页面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;同一商品大并发读问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你会说这个问题很容易解决，无非放到Tair缓存里面就行，集中式Tair缓存为了保证命中率，一般都会采用一致性Hash，所以同一个key会落到一台机器上，虽然我们的Tair缓存机器单台也能支撑30w/s的请求，但是像大秒这种级别的热点商品还远不够，那如何彻底解决这种单点瓶颈？答案是采用应用层的Localcache，即在秒杀系统的单机上缓存商品相关的数据，如何cache数据？也分动态和静态：&lt;/p&gt;

&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;像商品中的标题和描述这些本身不变的会在秒杀开始之前全量推送到秒杀机器上并一直缓存直到秒杀结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;像库存这种动态数据会采用被动失效的方式缓存一定时间（一般是数秒），失效后再去Tair缓存拉取最新的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可能会有疑问，像库存这种频繁更新数据一旦数据不一致会不会导致超卖？其实这就要用到我们前面介绍的读数据分层校验原则了，读的场景可以允许一定的脏数据，因为这里的误判只会导致少量一些原本已经没有库存的下单请求误认为还有库存而已，等到真正写数据时再保证最终的一致性。这样在数据的高可用性和一致性做平衡来解决这种高并发的数据读取问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同一数据大并发更新问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;解决大并发读问题采用Localcache和数据的分层校验的方式，但是无论如何像减库存这种大并发写还是避免不了，这也是秒杀这个场景下最核心的技术难题。&lt;/p&gt;

&lt;p&gt;同一数据在数据库里肯定是一行存储（MySQL），所以会有大量的线程来竞争InnoDB行锁，当并发度越高时等待的线程也会越多，TPS会下降RT会上升，数据库的吞吐量会严重受到影响。说到这里会出现一个问题，就是单个热点商品会影响整个数据库的性能，就会出现我们不愿意看到的0.01%商品影响99.99%的商品，所以一个思路也是要遵循前面介绍第一个原则进行隔离，把热点商品放到单独的热点库中。但是无疑也会带来维护的麻烦（要做热点数据的动态迁移以及单独的数据库等）。&lt;/p&gt;

&lt;p&gt;分离热点商品到单独的数据库还是没有解决并发锁的问题，要解决并发锁有两层办法。&lt;/p&gt;

&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;应用层做排队。&lt;/strong&gt;按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多数据库连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;数据库层做排队。&lt;/strong&gt;应用层只能做到单机排队，但应用机器数本身很多，这种排队方式控制并发仍然有限，所以如果能在数据库层做全局排队是最理想的，淘宝的数据库团队开发了针对这种MySQL的InnoDB层上的patch，可以做到数据库层上对单行记录做到并发排队，如图6所示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/106546/201603/106546-20160311090450663-913788151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可能会问排队和锁竞争不要等待吗？有啥区别？如果熟悉MySQL会知道，InnoDB内部的死锁检测以及MySQL Server和InnoDB的切换会比较耗性能，淘宝的MySQL核心团队还做了很多其他方面的优化，如COMMIT_ON_SUCCESS和ROLLBACK_ON_FAIL的patch，配合在SQL里面加hint，在事务里不需要等待应用层提交COMMIT而在数据执行完最后一条SQL后直接根据TARGET_AFFECT_ROW结果提交或回滚，可以减少网络的等待时间（平均约0.7ms）。据我所知，目前阿里MySQL团队已将这些patch及提交给MySQL官方评审。&lt;/p&gt;
&lt;p&gt;大促热点问题思考：&lt;/p&gt;
&lt;p&gt;以秒杀这个典型系统为代表的热点问题根据多年经验我总结了些通用原则：隔离、动态分离、分层校验，必须从整个全链路来考虑和优化每个环节，除了优化系统提升性能，做好限流和保护也是必备的功课。&lt;/p&gt;

&lt;p&gt;除去前面介绍的这些热点问题外，淘系还有多种其他数据热点问题：&lt;/p&gt;

&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;数据访问热点，比如Detail中对某些热点商品的访问度非常高，即使是Tair缓存这种Cache本身也有瓶颈问题，一旦请求量达到单机极限也会存在热点保护问题。有时看起来好像很容易解决，比如说做好限流就行，但你想想一旦某个热点触发了一台机器的限流阀值，那么这台机器Cache的数据都将无效，进而间接导致Cache被击穿，请求落地应用层数据库出现雪崩现象。这类问题需要与具体Cache产品结合才能有比较好的解决方案，这里提供一个通用的解决思路，就是在Cache的client端做本地Localcache，当发现热点数据时直接Cache在client里，而不要请求到Cache的Server。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;数据更新热点，更新问题除了前面介绍的热点隔离和排队处理之外，还有些场景，如对商品的lastmodifytime字段更新会非常频繁，在某些场景下这些多条SQL是可以合并的，一定时间内只执行最后一条SQL就行了，可以减少对数据库的update操作。另外热点商品的自动迁移，理论上也可以在数据路由层来完成，利用前面介绍的热点实时发现自动将热点从普通库里迁移出来放到单独的热点库中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照某种维度建的索引产生热点数据，比如实时搜索中按照商品维度关联评价数据，有些热点商品的评价非常多，导致搜索系统按照商品ID建评价数据的索引时内存已经放不下，交易维度关联订单信息也同样有这些问题。这类热点数据需要做数据散列，再增加一个维度，把数据重新组织。&lt;/p&gt;




&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;转载自 &lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/jifeng/p/5264268.html&quot;&gt;http://www.cnblogs.com/jifeng/p/5264268.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 07:30:00 +0000</pubDate>
<dc:creator>王守昌</dc:creator>
<og:description>一些数据： 大家还记得2013年的小米秒杀吗？三款小米手机各11万台开卖，走的都是大秒系统，3分钟后成为双十一第一家也是最快破亿的旗舰店。经过日志统计，前端系统双11峰值有效请求约60w以上的QPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangshouchang/p/9978080.html</dc:identifier>
</item>
<item>
<title>Windows 安装并配置 MySQL 5.6 - 蜗牛丨</title>
<link>http://www.cnblogs.com/alan-lin/p/9966917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alan-lin/p/9966917.html</guid>
<description>&lt;p&gt;Windows 下安装 MySQL 有两种方式，一种是下载安装包，根据提示一路 next 安装，不需要什么配置，比较简单；另一种是下载压缩包，通过命令和配置来安装，也不难，个人感觉更简单。本篇就采用第二种方法安装。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，下载MySQL压缩包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.1，打开&lt;a title=&quot;https://www.mysql.com/&quot; href=&quot;https://www.mysql.com/&quot;&gt;https://www.mysql.com/&lt;/a&gt;，进入MySQL的官方网站，点击 Downloads，进入 下载中心&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181115234208566-346670594.png&quot; alt=&quot;&quot; width=&quot;641&quot; height=&quot;473&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.2，在 下载中心，滑到页面的最下面，可以看到 MySQL Community Edition(GPL)  &lt;a href=&quot;https://dev.mysql.com/downloads/&quot;&gt;Community (GPL) Downloads »&lt;/a&gt;  的字样，点击 &lt;a href=&quot;https://dev.mysql.com/downloads/&quot; target=&quot;_blank&quot;&gt;Community (GPL) Downloads »&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181115235109878-1092412336.png&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;99&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.3，打开页面后，点击 &lt;a class=&quot;title&quot; href=&quot;https://dev.mysql.com/downloads/mysql/&quot;&gt;MySQL Community Server&lt;/a&gt; &lt;span class=&quot;subheading&quot;&gt;(GPL)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;subheading&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181115235638751-2081747703.png&quot; alt=&quot;&quot; width=&quot;583&quot; height=&quot;291&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.4，打开页面后，进入 MySQL 下载页面，默认的是最新版，如果安装最新版的话，就滑到下面，下载最新版的包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181116000248151-1900615951.png&quot; alt=&quot;&quot; width=&quot;863&quot; height=&quot;543&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个红框是选择操作系统，我们选 Windows；第二个红框是安装包文件，上面说的第一种安装方法用的；第三个红框就是压缩包安装所需要的压缩包，上面说的第二种安装方法用的压缩包。&lt;/p&gt;
&lt;p&gt;由于目前最新是 8.0 版，我们要安装 5.6 版，我们在这个页面上面部分找到 &lt;a href=&quot;https://dev.mysql.com/downloads/mysql/5.6.html#downloads&quot;&gt;MySQL Community Server 5.6 »&lt;/a&gt; ，选择 5.6 版点击打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181116001049055-2037461918.png&quot; alt=&quot;&quot; width=&quot;874&quot; height=&quot;639&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面打开后，滑到下面，跟上面类似，第一个红框是系统，第二个红框是安装包文件，第三个是压缩包文件。&lt;/p&gt;
&lt;p&gt;我们选择第三个红框里的，根据系统是32位还是64位选择下载，点击后面的 Download，进入下载页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181116001739181-1630982798.png&quot; alt=&quot;&quot; width=&quot;850&quot; height=&quot;591&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以用 Oracle 账号登录来下载，如果没有或不想登录直接点击 &lt;a href=&quot;https://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.42-win32.zip&quot;&gt;No thanks, just start my download.&lt;/a&gt; 进行下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181116002925002-1006563594.png&quot; alt=&quot;&quot; width=&quot;710&quot; height=&quot;501&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为防止有的同学无法下载，这里贴出下载链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL Installer 5.6 ：&lt;a href=&quot;https://dev.mysql.com/get/Downloads/MySQLInstaller/mysql-installer-community-5.6.42.0.msi&quot; target=&quot;_blank&quot;&gt;https://dev.mysql.com/get/Downloads/MySQLInstaller/mysql-installer-community-5.6.42.0.msi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MySQL 5.6 Windows (x86, 32-bit), ZIP Archive ：&lt;a href=&quot;https://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.42-win32.zip&quot; target=&quot;_blank&quot;&gt;https://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.42-win32.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MySQL 5.6 Windows (x86, 64-bit), ZIP Archive ：&lt;a href=&quot;https://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.42-winx64.zip&quot; target=&quot;_blank&quot;&gt;https://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.42-winx64.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MySQL Installer 只有32位的，没有64位的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，安装MySQL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.1，解压下载下来的压宿包，然后把解压后的文件夹迁到想要安装的目录，如：D:\Program Files 下面&lt;/p&gt;
&lt;p&gt;为了方便我把文件夹重命名为 mysql-5.6&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181117151146161-457519693.png&quot; alt=&quot;&quot; width=&quot;303&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181117151337441-587089730.png&quot; alt=&quot;&quot; width=&quot;301&quot; height=&quot;128&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.2，右击 我的电脑-&amp;gt;属性-&amp;gt;高级-&amp;gt;环境变量，在系统变量里选择PATH，在其后面添加: mysql bin文件夹的路径 (如: &lt;span&gt;D:\Program Files\mysql-5.6\bin&lt;/span&gt; )，注意是追加，不是覆盖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181117152319362-766359579.png&quot; alt=&quot;&quot; width=&quot;403&quot; height=&quot;453&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.3，在mysql目录中找到 data 文件夹，如果不存在就新建一个 data 文件夹&lt;/p&gt;
&lt;p&gt;修改一下配置文件，拷贝 mysql 目录中的my-default.ini，重命名为 my.ini，打开my.ini，修改或添加配置，然后保存&lt;/p&gt;
&lt;p&gt;&lt;span&gt;basedir = D:\Program Files\mysql-5.6&lt;/span&gt;（mysql所在目录）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;datadir = D:\Program Files\mysql-5.6\data&lt;/span&gt;（mysql所在目录\data）&lt;/p&gt;
&lt;p&gt;在配置文件中我们还看到 port，为配置 mysql 端口，如果不想用 3306 默认端口，可以配置想要的端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181117153530917-699483575.png&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;355&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181117154131412-1973849569.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;352&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.4，以管理员身份运行cmd（一定要用管理员身份运行，不然权限不够），通过命令，进入mysql bin 目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181117155021424-489286433.png&quot; alt=&quot;&quot; width=&quot;398&quot; height=&quot;172&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.5，输入 &lt;span&gt;mysqld --initialize-insecure --user=mysql&lt;/span&gt; 回车&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181117155347524-657076791.png&quot; alt=&quot;&quot; width=&quot;862&quot; height=&quot;130&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.6，输入 &lt;span&gt;mysqld install&lt;/span&gt; 回车&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181117155644748-1707164555.png&quot; alt=&quot;&quot; width=&quot;340&quot; height=&quot;66&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此 mysql 安装成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，启动 MySQL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入 &lt;span&gt;net start mysql&lt;/span&gt; 回车，启动mysql服务，start 启动，stop 停止&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181117160102951-1493745295.png&quot; alt=&quot;&quot; width=&quot;351&quot; height=&quot;95&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，本地命令行连接MySQL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入 &lt;span&gt;mysql -u root -p&lt;/span&gt; ，回车，出现 &lt;span&gt;Enter passwore:&lt;/span&gt; ，输入密码，由于刚安装，没有设置密码，直接回车 Enter 进入 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181117161817768-1672014628.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;249&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入 &lt;span&gt;show databases;&lt;/span&gt; 命令查看默认安装数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181118142607638-496484223.png&quot; alt=&quot;&quot; width=&quot;216&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5，设置root密码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依次通过以下命令修改root用户名密码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;use mysql; 
mysql&amp;gt;update user set password=password('your password') where user='root'; &lt;br/&gt;mysql&amp;gt;flush privileges;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;your password&lt;/span&gt; 为你要修改的密码&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181118145336584-1756309311.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入 &lt;span&gt;quit&lt;/span&gt; 命令退出当前登录，用新的密码重新连接 mysql&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、设置远程登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql默认只能本机登录，如果只是本机使用，就可以不用设置远程登录，使用 localhost 做为主机地址登录&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181118145446628-329664936.png&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;461&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181118145727842-414041160.png&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想远程登录，通过以下命令，设置允许远程登录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;GRANT ALL PRIVILEGES ON *.* TO 'your username'@'%' IDENTIFIED BY 'your password' WITH GRANT OPTION;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;your username 和 your password 改成 mysql 数据库的用户和密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181118151939240-1630759967.png&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;73&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，在 Windows 上安装 MySQL 5.6 完成。&lt;/p&gt;
&lt;p&gt;mysql 默认3306，确保 3306 端口是通的，在要远程的电脑上安装一个mysql管理工具（sqlyog或navicat），通过 Windows 系统的IP、端口，mysql的用户名、密码 远程连接数据库，管理数据库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181118151306804-883702093.png&quot; alt=&quot;&quot; width=&quot;569&quot; height=&quot;457&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1145599/201811/1145599-20181118151334417-1798831219.png&quot; alt=&quot;&quot; width=&quot;353&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;远程连接成功。&lt;/p&gt;

</description>
<pubDate>Sun, 18 Nov 2018 07:21:00 +0000</pubDate>
<dc:creator>蜗牛丨</dc:creator>
<og:description>Windows 下安装 MySQL 有两种方式，一种是下载安装包，根据提示一路 next 安装，不需要什么配置，比较简单；另一种是下载压缩包，通过命令和配置来安装，也不难，个人感觉更简单。本篇就采用第</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alan-lin/p/9966917.html</dc:identifier>
</item>
<item>
<title>Spring boot webSocket从入门到放弃 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/9978021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/9978021.html</guid>
<description>&lt;p&gt;在构建Spring boot项目时已经提供webSocket依赖的勾选。webSocket是TCP之上的一个非常薄的轻量级层 ，webSocket主要的应用场景离不开即时通讯与消息推送，但只要应用程序需要在浏览器和服务器之间来回发送消息，就可以使用webSocket来降低客户端流量与服务器的负载。&lt;/p&gt;
&lt;p&gt;下面将基于Spring boot实现一个非常简单的HelloWorld程序，用来熟悉项目构建逻辑。&lt;/p&gt;

&lt;p&gt;主要的webSocket依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-websocket&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一些js库依赖，这里也使用maven方式导入，官网&lt;a href=&quot;https://www.webjars.org/&quot; class=&quot;uri&quot;&gt;https://www.webjars.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.webjars&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;webjars-locator-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.webjars&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;sockjs-client&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.webjars&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;stomp-websocket&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.3.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.webjars&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;bootstrap&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.3.7&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.webjars&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jquery&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Thymeleaf模板引擎，不用多说了吧&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;接下来开启webSocket并配置一番&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint(&quot;/gs-guide-websocket&quot;).withSockJS();
    }
    
    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker(&quot;/topic&quot;);
        config.setApplicationDestinationPrefixes(&quot;/app&quot;); 
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里从上向下说一下，&lt;/p&gt;
&lt;p&gt;1）@EnableWebSocketMessageBroker注解用于开启使用STOMP协议来传输基于代理（MessageBroker）的消息，这时候控制器（controller）开始支持@MessageMapping,就像是使用@requestMapping一样。&lt;/p&gt;
&lt;p&gt;2）registerStompEndpoints()方法只写了一行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;registry.addEndpoint(&quot;/gs-guide-websocket&quot;).withSockJS();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一是用来注册一个Stomp的节点（endpoint）,也就是webSocket的服务端地址，客户端在链接时使用到；&lt;/p&gt;
&lt;p&gt;二是withSockJs()方法指定使用SockJS协议。SockJs是一个WebSocket的通信js库，Spring对这个js库进行了后台的自动支持，如果使用它不需要进行过多配置。&lt;/p&gt;
&lt;p&gt;3）配置消息代理（MessageBroker），该方法干了两件事，一是启用一个简单的message broker并配置一个或多个前缀来过滤针对代理的目的地(例如以“/topic”为前缀的目的地)，该前戳限制了网页客户端设置本地地址时的前戳。 二是设置了一个客户端访问服务端地址的前缀。比如我们设置@MessageMapping(&quot;/hello&quot;)，那客户端要发送消息到服务器上的地址是 /app/hello。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;@Controller
public class GreetingController {

    @MessageMapping(&quot;/hello&quot;)
    @SendTo(&quot;/topic/greetings&quot;)
    public Greeting greeting(HelloMessage message) throws Exception {
        System.out.println(&quot;收到：&quot; + message.toString() + &quot;消息&quot;);
        return new Greeting(&quot;Hello, &quot; + HtmlUtils.htmlEscape(message.getName()) + &quot;!&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）@MessageMapping和@RequestMapping功能类似，用于设置URL映射地址，浏览器向服务器发起请求，需要通过该地址。&lt;/p&gt;
&lt;p&gt;需要注意，这里设置路径为/hello，但是客户端需要访问/app/hello，原因前面已经讲述。&lt;/p&gt;
&lt;p&gt;2）@SendTo(&quot;/topic/greetings&quot;) 设置目的地，这里的目的地是站在服务端的角度对客户端而言。客户端也需要设置相同的地址，而且必须使用/topic前戳，前面也已经讲述。&lt;/p&gt;
&lt;p&gt;本示例中如果服务器接受到了消息，就会对订阅了@SendTo括号中的地址传送消息。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;备注：HtmlUtils.htmlEscape()方法会将特殊字符转换为HTML字符引用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HelloMessage.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HelloMessage {
    private String name;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Greeting.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Greeting {
    private String content;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在resources/static目录下：&lt;/p&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Hello WebSocket&amp;lt;/title&amp;gt;
    &amp;lt;link href=&quot;/webjars/bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
    &amp;lt;link href=&quot;/main.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
    &amp;lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; /&amp;gt;
    &amp;lt;script src=&quot;/webjars/jquery/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;/webjars/sockjs-client/sockjs.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;/webjars/stomp-websocket/stomp.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;/app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;noscript&amp;gt;&amp;lt;h2 style=&quot;color: #ff0000&quot;&amp;gt;Seems your browser doesn't support Javascript! Websocket relies on Javascript being
    enabled. Please enable
    Javascript and reload this page!&amp;lt;/h2&amp;gt;&amp;lt;/noscript&amp;gt;
&amp;lt;div id=&quot;main-content&quot; class=&quot;container&quot;&amp;gt;
    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;div class=&quot;col-md-6&quot;&amp;gt;
            &amp;lt;form class=&quot;form-inline&quot;&amp;gt;
                &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                    &amp;lt;label for=&quot;connect&quot;&amp;gt;WebSocket connection:&amp;lt;/label&amp;gt;
                    &amp;lt;button id=&quot;connect&quot; class=&quot;btn btn-default&quot; type=&quot;submit&quot;&amp;gt;Connect&amp;lt;/button&amp;gt;
                    &amp;lt;button id=&quot;disconnect&quot; class=&quot;btn btn-default&quot; type=&quot;submit&quot; disabled=&quot;disabled&quot;&amp;gt;Disconnect
                    &amp;lt;/button&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/form&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;col-md-6&quot;&amp;gt;
            &amp;lt;form class=&quot;form-inline&quot;&amp;gt;
                &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                    &amp;lt;label for=&quot;name&quot;&amp;gt;What is your name?&amp;lt;/label&amp;gt;
                    &amp;lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;form-control&quot; placeholder=&quot;Your name here...&quot;&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;button id=&quot;send&quot; class=&quot;btn btn-default&quot; type=&quot;submit&quot;&amp;gt;Send&amp;lt;/button&amp;gt;
            &amp;lt;/form&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;div class=&quot;col-md-12&quot;&amp;gt;
            &amp;lt;table id=&quot;conversation&quot; class=&quot;table table-striped&quot;&amp;gt;
                &amp;lt;thead&amp;gt;
                &amp;lt;tr&amp;gt;
                    &amp;lt;th&amp;gt;Greetings&amp;lt;/th&amp;gt;
                &amp;lt;/tr&amp;gt;
                &amp;lt;/thead&amp;gt;
                &amp;lt;tbody id=&quot;greetings&quot;&amp;gt;
                &amp;lt;/tbody&amp;gt;
            &amp;lt;/table&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;main.css&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;body {
    background-color: #f5f5f5;
}

#main-content {
    max-width: 940px;
    padding: 2em 3em;
    margin: 0 auto 20px;
    background-color: #fff;
    border: 1px solid #e5e5e5;
    -webkit-border-radius: 5px;
    -moz-border-radius: 5px;
    border-radius: 5px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;app.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var stompClient = null;

function setConnected(connected) {
    $(&quot;#connect&quot;).prop(&quot;disabled&quot;, connected);
    $(&quot;#disconnect&quot;).prop(&quot;disabled&quot;, !connected);
    if (connected) {
        $(&quot;#conversation&quot;).show();
    }
    else {
        $(&quot;#conversation&quot;).hide();
    }
    $(&quot;#greetings&quot;).html(&quot;&quot;);
}

function connect() {
    var socket = new SockJS('/gs-guide-websocket'); 
    stompClient = Stomp.over(socket);
    stompClient.connect({&quot;id&quot;: &quot;header&quot;}, function (frame) {
        setConnected(true);
        console.log('Connected: ' + frame);
        stompClient.subscribe('/topic/greetings', function (greeting) { 
            showGreeting(JSON.parse(greeting.body).content);
        });
    });
}

function disconnect() {
    if (stompClient !== null) {
        stompClient.disconnect();
    }
    setConnected(false);
    console.log(&quot;Disconnected&quot;);
}

function sendName() {
    stompClient.send(&quot;/app/hello&quot;, {}, JSON.stringify({'name': $(&quot;#name&quot;).val()})); 
}

function showGreeting(message) {
    $(&quot;#greetings&quot;).append(&quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&quot; + message + &quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&quot;);
}

$(function () {
    $(&quot;form&quot;).on('submit', function (e) {
        e.preventDefault();
    });
    $( &quot;#connect&quot; ).click(function() { connect(); });
    $( &quot;#disconnect&quot; ).click(function() { disconnect(); });
    $( &quot;#send&quot; ).click(function() { sendName(); });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这部分最值得说的就是JS部分了，比较简单主要就是3个点击事件，包括连接、断开、发送消息。&lt;/p&gt;
&lt;p&gt;当我们点击了连接后，会新建SockjS对象，并设置服务端的连接点（/gs-guide-websocket），这里的连接点由服务端提供。&lt;/p&gt;
&lt;p&gt;subscribe()方法的第一个参数是注册客户端地址，注意前戳必须是/topic开头，因为在前面服务端已经配置了目的地前戳。与@SendTo中的地址对应。&lt;/p&gt;
&lt;p&gt;客户端发送消息只需要调用send()方法，还方法的第一个参数是服务端@MessageMapping地址并且加了指定的/app前戳，第二个参数为header头部信息，第三个是发送的消息内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201811/1136672-20181118151340308-2141512340.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功实现Hello World程序，下面将通过搭建一个一对一聊天服务器，深入学习更多的socket知识。&lt;/p&gt;

&lt;p&gt;在前面我们写了一个自动回复的小例子，用到了@MessageMapping(&quot;/hello&quot;)和@SendTo(&quot;/topic/greetings&quot;)两个注解，其实我们还可以使用编程的方式发送消息。&lt;/p&gt;
&lt;p&gt;其实很简单，直接引用该消息模板&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Autowired
    private SimpMessagingTemplate messagingTemplate;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消息模板内置了一系列方法，比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void convertAndSendToUser(String user, String destination, Object payload)

void convertAndSend(D destination, Object payload)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这俩方法会包装为消息并将其发送到给定的目的地。&lt;/p&gt;

&lt;p&gt;监听webSocket服务器的连接只需要实现ApplicationListener&amp;lt;&amp;gt;接口。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class STOMPConnectEventListener implements ApplicationListener&amp;lt;SessionConnectEvent&amp;gt; {

    @Override
    public void onApplicationEvent(SessionConnectEvent event) {
        StompHeaderAccessor sha = StompHeaderAccessor.wrap(event.getMessage());
        //判断客户端的连接状态
        switch (sha.getCommand()) {
            case CONNECT:
                System.out.println(&quot;上线&quot;);
                break;
            case DISCONNECT:
                System.out.println(&quot;下线&quot;);
                break;
            case SUBSCRIBE:
                System.out.println(&quot;订阅&quot;);
                break;
            case SEND:
                System.out.println(&quot;发送&quot;);
                break;
            case UNSUBSCRIBE:
                System.out.println(&quot;取消订阅&quot;);
                break;
            default:
                break;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;监听的所有状态被封装在一个枚举类中，其实还有很多，这里不再一一列举。&lt;/p&gt;
&lt;p&gt;有了上面这些知识，我们就可以基于此开发一对一聊天服务器。&lt;/p&gt;

&lt;p&gt;webSocket提供的是一个socket框架，并不会帮我们管理session，我们需要自己去编写session管理类，进行session的读写。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class SocketSessionMap {
    private final static ConcurrentMap&amp;lt;String, String&amp;gt; sessionMap = new ConcurrentHashMap&amp;lt;&amp;gt;();

    /**
     * 注册Session
     * @param userId
     * @param sessionId
     */
    public synchronized void registerSession(String userId, String sessionId) {
        sessionMap.put(userId,sessionId);
    }

    /**
     * 移除Session
     * @param userId
     * @param sessionId
     */
    public synchronized void removeSession(String userId, String sessionId) {
        sessionMap.remove(userId);
    }

    /**
     * 获取用户的SessionId
     * @param userId
     * @return
     */
    public String getUserSessionId(String userId){
        return sessionMap.get(userId);
    }

    /**
     * 获取所有Session集合
     * @return
     */
    public Map&amp;lt;String, String&amp;gt; queryAllSession(){
        return sessionMap;
    }
    /**
     * 获取集合的大小
     */
    public int onlineCount(){
        return sessionMap.size();
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;接着，对STOMP监听类进行扩展。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class STOMPConnectEventListener implements ApplicationListener&amp;lt;SessionConnectEvent&amp;gt; {

    @Autowired
    SocketSessionMap socketSessionMap;

    @Override
    public void onApplicationEvent(SessionConnectEvent event) {
        StompHeaderAccessor sha = StompHeaderAccessor.wrap(event.getMessage());
        String userId = sha.getFirstNativeHeader(&quot;id&quot;); 
        String sessionId = sha.getSessionId();
        switch (sha.getCommand()) {
            case CONNECT:
                System.out.println(&quot;上线：&quot; + userId + &quot;  &quot; + sessionId);
                socketSessionMap.registerSession(userId, sessionId);
                break;
            default:
                break;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端通过&lt;code&gt;sha.getFirstNativeHeader(&quot;id&quot;)&lt;/code&gt;读取到客户端的ID，这个值需要网页客户端手动在header头部信息中设置。&lt;/p&gt;
&lt;p&gt;当服务端监听到客户端连接时，会将用户SessionId注册到Map中。&lt;/p&gt;

&lt;p&gt;这里我们使用更可靠的请求下线方式，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @MessageMapping(&quot;/chatOut&quot;)
    public void sayHello(String userId) {
        String sessionId = socketSessionMap.getUserSessionId(userId);
        System.out.println(&quot;下线：&quot; + userId + &quot;  &quot; + sessionId);
        socketSessionMap.removeSession(userId,sessionId);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当收到下线请求时，移除SessionId。&lt;/p&gt;
&lt;p&gt;关于Session，也可以设置一个最大值，超时自动移除。&lt;/p&gt;

&lt;p&gt;在一对一服务器中，主要处理的就是一对一的消息发送。大致逻辑是接收客户端消息，分析消息结构，通过SessionMap判断对方是否在线，然后发送相应内容。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @MessageMapping(&quot;/chat&quot;)
    public void sayHello(Message user) {
        System.out.println(user.getId()+&quot;--&amp;gt;&quot;+user.getPid()+&quot;:&quot;+user.getContent());
        String userPid = String.valueOf(user.getPid());
        String userId = String.valueOf(user.getId());
        String sendTo = &quot;/topic/chat/&quot;+userPid;
        String content = user.getId()+&quot;:&quot;+user.getContent();
        if (socketSessionMap.getUserSessionId(userPid)!=null){
            messagingTemplate.convertAndSend(sendTo, HtmlUtils.htmlEscape(content));
        }else {
            sendTo = &quot;/topic/chat/&quot;+userId;
            content = &quot;对方已下线&quot;;
            messagingTemplate.convertAndSend(sendTo, HtmlUtils.htmlEscape(content));
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得一体的是，关于用户ID的处理，这里使用的是自定义客户端地址，不同的地址表示不同的用户。最后通过convertAndSend()方法发送，这种方式比较可靠方便。&lt;/p&gt;
&lt;p&gt;Message.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Message {
    private int id; //用户ID
    private String content;//发送内容
    private int pid;    //发送到用户&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;服务端使用FreeMarker模板引擎返回html网页，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @RequestMapping(&quot;/chat/{id}&quot;)
    public String chat_page(@PathVariable int id, ModelMap model) {
        model.addAttribute(&quot;id&quot;, id);
        int count = socketSessionMap.onlineCount();
        model.addAttribute(&quot;count&quot;, count);
        return &quot;chat&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过RESTful形式的URl注册ID。&lt;/p&gt;
&lt;p&gt;chat.html&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html &amp;gt;
&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Hello WebSocket&amp;lt;/title&amp;gt;
    &amp;lt;link href=&quot;/webjars/bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
    &amp;lt;link href=&quot;/main.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
    &amp;lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; /&amp;gt;
    &amp;lt;script src=&quot;/webjars/jquery/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;/webjars/sockjs-client/sockjs.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;/webjars/stomp-websocket/stomp.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;/chat.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;noscript&amp;gt;&amp;lt;h2 style=&quot;color: #ff0000&quot;&amp;gt;Seems your browser doesn't support Javascript! Websocket relies on Javascript being
    enabled. Please enable
    Javascript and reload this page!&amp;lt;/h2&amp;gt;&amp;lt;/noscript&amp;gt;
&amp;lt;div id=&quot;main-content&quot; class=&quot;container&quot;&amp;gt;
    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;div class=&quot;col-md-6&quot;&amp;gt;
            &amp;lt;form class=&quot;form-inline&quot;&amp;gt;
                &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                    &amp;lt;label for=&quot;connect&quot;&amp;gt;WebSocket connection:&amp;lt;/label&amp;gt;
                    &amp;lt;button id=&quot;connect&quot; class=&quot;btn btn-default&quot; type=&quot;submit&quot;&amp;gt;Connect&amp;lt;/button&amp;gt;
                    &amp;lt;button id=&quot;disconnect&quot; class=&quot;btn btn-default&quot; type=&quot;submit&quot; disabled=&quot;disabled&quot;&amp;gt;Disconnect
                    &amp;lt;/button&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/form&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;col-md-6&quot;&amp;gt;
            &amp;lt;form class=&quot;form-inline&quot;&amp;gt;
                &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                    &amp;lt;label th:text=&quot;'Online:'+${count}&quot;&amp;gt; &amp;lt;/label&amp;gt;
                    &amp;lt;input type=&quot;text&quot; id=&quot;id&quot; class=&quot;form-control&quot; th:value=&quot;${id}&quot;required&amp;gt;
                    &amp;lt;input type=&quot;text&quot; id=&quot;content&quot; class=&quot;form-control&quot; placeholder=&quot;Your name here...&quot;required&amp;gt;
                    &amp;lt;input type=&quot;text&quot; id=&quot;pid&quot; class=&quot;form-control&quot; placeholder=&quot;Your PID&quot;required&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;button id=&quot;send&quot; class=&quot;btn btn-default&quot; type=&quot;submit&quot;&amp;gt;Send&amp;lt;/button&amp;gt;
            &amp;lt;/form&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;div class=&quot;col-md-12&quot;&amp;gt;
            &amp;lt;table id=&quot;conversation&quot; class=&quot;table table-striped&quot;&amp;gt;
                &amp;lt;thead&amp;gt;
                &amp;lt;tr&amp;gt;
                    &amp;lt;th&amp;gt;Greetings&amp;lt;/th&amp;gt;
                &amp;lt;/tr&amp;gt;
                &amp;lt;/thead&amp;gt;
                &amp;lt;tbody id=&quot;greetings&quot;&amp;gt;
                &amp;lt;/tbody&amp;gt;
            &amp;lt;/table&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;chat.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var stompClient = null;

function setConnected(connected) {
    $(&quot;#connect&quot;).prop(&quot;disabled&quot;, connected);
    $(&quot;#disconnect&quot;).prop(&quot;disabled&quot;, !connected);
    if (connected) {
        $(&quot;#conversation&quot;).show();
    }
    else {
        $(&quot;#conversation&quot;).hide();
    }
    $(&quot;#greetings&quot;).html(&quot;&quot;);
}

function connect() {
    var socket = new SockJS('/gs-guide-websocket');
    stompClient = Stomp.over(socket);
    stompClient.connect({&quot;id&quot;: $(&quot;#id&quot;).val()}, function (frame) { //客户端ID
        setConnected(true);
        console.log('Connected: ' + frame);
        stompClient.subscribe('/topic/chat/' + $(&quot;#id&quot;).val(), function (greeting) { //表明客户端地址
            showGreeting(greeting.body);
        }, {&quot;id&quot;: &quot;Host_&quot; + $(&quot;#id&quot;).val()});
    });
}

function disconnect() {
    if (stompClient !== null) {
        stompClient.send(&quot;/app/chatOut&quot;, {},$(&quot;#id&quot;).val());
        stompClient.disconnect();
    }
    setConnected(false);
    console.log(&quot;Disconnected&quot;);
}

function sendName() {
    stompClient.send(&quot;/app/chat&quot;, {}, JSON.stringify({
        'content': $(&quot;#content&quot;).val(),
        'id': $(&quot;#id&quot;).val(),
        'pid': $(&quot;#pid&quot;).val()
    }));
    showGreeting(&quot;我:&quot; + $(&quot;#content&quot;).val())
}

function showGreeting(message) {
    $(&quot;#greetings&quot;).append(&quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&quot; + message + &quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&quot;);
}

$(function () {
    $(&quot;form&quot;).on('submit', function (e) {
        e.preventDefault();
    });
    $(&quot;#connect&quot;).click(function () {
        connect();
    });
    $(&quot;#disconnect&quot;).click(function () {
        disconnect();
    });
    $(&quot;#send&quot;).click(function () {
        sendName();
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网页客户端的主要逻辑在chat.js中。非常有必要的是在stompClient.connect()方法的第一个参数中传入header头信息，该头部信息必须设置id字段的值，因为服务端会读取该ID值，该值最终会取自URL中的参数。&lt;/p&gt;
&lt;p&gt;其次是在用户断开链接前，会向服务端发送断开通知。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stompClient.send(&quot;/app/chatOut&quot;, {},$(&quot;#id&quot;).val());&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;打开两个网页，URl分别为http://localhost:8080/chat/100和http://localhost:8080/chat/101，点击连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201811/1136672-20181118151427065-930233865.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201811/1136672-20181118151440339-1699619279.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看控制台输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201811/1136672-20181118151455298-1259826152.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来演示用户101向用户100发送消息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201811/1136672-20181118151505657-522858511.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看用户100收到信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201811/1136672-20181118151516173-688035991.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次查看控制输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201811/1136672-20181118151537452-57844610.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;消息成功发送！&lt;/p&gt;
&lt;p&gt;当用户断开链接时，控制台输出为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201811/1136672-20181118151549318-733302180.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;关于Spring boot webSocket就先到这里，更多请持续关注我的博客！&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 07:16:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>在构建Spring boot项目时已经提供webSocket依赖的勾选。webSocket是TCP之上的一个非常薄的轻量级层 ，webSocket主要的应用场景离不开即时通讯与消息推送，但只要应用程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/9978021.html</dc:identifier>
</item>
<item>
<title>关于工作一年的畅想 - NothingIsEverything</title>
<link>http://www.cnblogs.com/techecho/p/9977970.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techecho/p/9977970.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Sun, 18 Nov 2018 07:01:00 +0000</pubDate>
<dc:creator>NothingIsEverything</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Ftechecho%2Fp%2F9977970.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>2018年11月17号第一次参加源创会记录 - Danni3</title>
<link>http://www.cnblogs.com/ouyida3/p/9977936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ouyida3/p/9977936.html</guid>
<description>&lt;p&gt;昨天下午，到网易大厦参加了源创会的微信小程序技术沙龙。之前也参加过一些技术沙龙，但是原创会的还是第一次，总体感觉，还是很不错的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720375/201811/720375-20181118145058538-1503022703.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;细雨纷飞，准时来到会场之后，竟然发觉早已经人满为患，后边陆续还有不少参会者进场，后来的人就只能够站着听了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720375/201811/720375-20181118145109633-2022678623.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一共有四个主题，基本都与微信小程序和前端开发相关的。其实我也不知道为什么选题主要都和小程序或者前端相关，也许可能微信总部在广州吧，又或者广州这个城市比较着重商贸，所以微商或者搞前端这些讲求快捷实用的小公司更多吧。毕竟大部份的科技巨头都集中在北京上海深圳。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720375/201811/720375-20181118145053479-1516290924.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;主题一&quot;&gt;主题一&lt;/h2&gt;
&lt;p&gt;小程序自动化测试，主要介绍了网易自己研发的一套小程序自动化测试框架，这个框假也开源了，我们可以自己上网搜索得到。&lt;/p&gt;
&lt;p&gt;根据主讲人介绍，这个框架实现的原理主要有两种，一个是根据图像识别，也就是你截图小程序介面的那个按钮图像，框架进行图像识别，然后进行自动化测试时候的相应点击或其他操作。第二种就是根据ui的搜索，也就是需要你进行脚本的编写，但是这种情况不能保证百分百的准确，所以需要与第一种结合使用，因为毕竟图像是基本100%准确的。&lt;/p&gt;
&lt;p&gt;另外这个框架也支持集群的测试，主讲人展示了网易几百台各个型号的手机连接到集群测试框架，然后一起自动化测试的壮观场景，可惜我忘记了拍照，那个动态图片看起来还是挺壮观的。&lt;/p&gt;
&lt;h2 id=&quot;主题二&quot;&gt;主题二&lt;/h2&gt;
&lt;p&gt;第二个主题是关于微信小游戏和微信小程序的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720375/201811/720375-20181118145125870-853185723.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微信开发平台提供的小程序和小游戏的编程语言都是JS，框假看上去也比较类似，但是有一个很大的区别就是小程序提供了一套可以复用的ui组件库，以小游戏是没有提供的，其实这也很好理解，小程序最主要着重的是功能，游戏主要着重的是体验，如果每个游戏看上去都一样，那就没有人玩了。所以游戏用Canvas-2d写了几十行代码可能也只是画了一个点。&lt;/p&gt;
&lt;p&gt;另外，还着重强调了虽然技术上可以用小游戏这个酷炫的框架来实现小程序的功能，但是从非技术的角度比如与微信支付分成等这些方面考虑，主讲人认为千万不要用小游戏来实现小程序。&lt;/p&gt;
&lt;p&gt;然后就是下午茶时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720375/201811/720375-20181118145154389-1272830771.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;场面何其壮观。&lt;/p&gt;
&lt;h2 id=&quot;主题三&quot;&gt;主题三&lt;/h2&gt;
&lt;p&gt;第三个主题是关于小程序里的音频和视频的。&lt;/p&gt;
&lt;p&gt;由于音频和视频传输的内容量比较大，而实时性要求也比较高，所以对转码和加速都有比较高的要求。底层当然使用的还是udp协议，但是需要封装加速，同时CDn加速等也是需要的。还列举了一些比较复杂的业务场景。比如视频通话时，与观看视频的最大不同是双向的，如果你在一边说了一句话，而在另一边把播放的这句话也作为音频输出过去了，就会形成一个回声的死循环。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720375/201811/720375-20181118145205361-849084644.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;主题四&quot;&gt;主题四&lt;/h2&gt;
&lt;p&gt;最后一个主题是具体的一个小程序应用的实验过程，涵盖了前端和后端。&lt;/p&gt;
&lt;p&gt;比如开始小程序是限定大小不能超过一兆，后来扩大到两兆，现在扩大到四兆。菜单的层级开头只能五级，现在可以十级了。这些都是要注意的。&lt;/p&gt;
&lt;p&gt;另外，需要注意授权的腾出提示。因为在过去下载app是导致用户离开的一个重要原因，而到了小程序时代，虽然不要下载，但是弹出授权提示就变成了导致用户离开的一个新的重要原因了。&lt;/p&gt;
&lt;p&gt;最后还介绍了使用消息队列提高处理效率，提升用户体验。使用容器等技术自动发布等等。&lt;/p&gt;

&lt;p&gt;总结，收获不算特别大。其实说实话，这些主讲人这么辛苦来演讲，稍微卖一点点广告是可以理解的，讲的内容还是很好的，但是主要还是我自己的问题，很多东西听完了，昨天觉得受益非浅，但是睡了一觉今天几本忘光了，所以现在我也写不出什么东西，所以，还是需要多看书，多学习，一起共勉吧。&lt;/p&gt;
&lt;p&gt;抽奖，飘过。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720375/201811/720375-20181118145702783-1181495271.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;散场。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720375/201811/720375-20181118145341586-478132221.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720375/201811/720375-20181118145450796-1717559761.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720375/201811/720375-20181118145427394-1661283588.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拜。也许下次再会。&lt;/p&gt;
&lt;p&gt;2018.11.17&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 07:01:00 +0000</pubDate>
<dc:creator>Danni3</dc:creator>
<og:description>前言 昨天下午，到网易大厦参加了源创会的微信小程序技术沙龙。之前也参加过一些技术沙龙，但是原创会的还是第一次，总体感觉，还是很不错的。 细雨纷飞，准时来到会场之后，竟然发觉早已经人满为患，后边陆续还有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ouyida3/p/9977936.html</dc:identifier>
</item>
<item>
<title>golang cgo 使用总结 - _toby</title>
<link>http://www.cnblogs.com/tobycnblogs/p/9977944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tobycnblogs/p/9977944.html</guid>
<description>&lt;h4 id=&quot;原文地址&quot;&gt;&lt;a href=&quot;http://litang.me/post/golang-cgo/&quot;&gt;原文地址&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;CGO 提供了 golang 和 C 语言相互调用的机制。某些第三方库可能只有 C/C++ 的实现，完全用纯 golang 的实现可能工程浩大，这时候 CGO 就派上用场了。可以通 CGO 在 golang 在调用 C 的接口，C++ 的接口可以用 C 包装一下提供给 golang 调用。被调用的 C 代码可以直接以源代码形式提供或者打包静态库或动态库在编译时链接。推荐使用静态库的方式，这样方便代码隔离，编译的二进制也没有动态库依赖方便发布也符合 golang 的哲学。&lt;br/&gt;CGO 的具体使用教程本文就不涉及了，这里主要介绍下一些细节避免使用 CGO 的时候踩坑。&lt;/p&gt;
&lt;h3 id=&quot;参数传递&quot;&gt;参数传递&lt;/h3&gt;
&lt;h4 id=&quot;基本数值类型&quot;&gt;基本数值类型&lt;/h4&gt;
&lt;p&gt;golang 的基本数值类型内存模型和 C 语言一样，就是连续的几个字节(1 / 2 / 4 / 8 字节)。因此传递数值类型时可以直接将 golang 的基本数值类型转换成对应的 CGO 类型然后传递给 C 函数调用，反之亦然：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

/*
#include &amp;lt;stdint.h&amp;gt;

static int32_t add(int32_t a, int32_t b) {
    return a + b;
}
*/
import &quot;C&quot;
import &quot;fmt&quot;

func main() {
    var a, b int32 = 1, 2
    var c int32 = int32(C.add(C.int32_t(a), C.int32_t(b)))
    fmt.Println(c) // 3
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;golang 和 C 的基本数值类型转换对照表如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;C.char&lt;/td&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;singed char&lt;/td&gt;
&lt;td&gt;C.schar&lt;/td&gt;
&lt;td&gt;int8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;unsigned char&lt;/td&gt;
&lt;td&gt;C.uchar&lt;/td&gt;
&lt;td&gt;uint8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;C.short&lt;/td&gt;
&lt;td&gt;int16&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;unsigned short&lt;/td&gt;
&lt;td&gt;C.ushort&lt;/td&gt;
&lt;td&gt;uint16&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;C.int&lt;/td&gt;
&lt;td&gt;int32&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;unsigned int&lt;/td&gt;
&lt;td&gt;C.uint&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;C.long&lt;/td&gt;
&lt;td&gt;int32&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;C.ulong&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;long long int&lt;/td&gt;
&lt;td&gt;C.longlong&lt;/td&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;unsigned long long int&lt;/td&gt;
&lt;td&gt;C.ulonglong&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;C.float&lt;/td&gt;
&lt;td&gt;float32&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;C.double&lt;/td&gt;
&lt;td&gt;float64&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;size_t&lt;/td&gt;
&lt;td&gt;C.size_t&lt;/td&gt;
&lt;td&gt;uint&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注意 C 中的整形比如 int 在标准中是没有定义具体字长的，但一般默认认为是 4 字节，对应 CGO 类型中 C.int 则明确定义了字长是 4 ，但 golang 中的 int 字长则是 8 ，因此对应的 golang 类型不是 int 而是 int32 。为了避免误用，C 代码最好使用 C99 标准的数值类型，对应的转换关系如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;int8_t&lt;/td&gt;
&lt;td&gt;C.int8_t&lt;/td&gt;
&lt;td&gt;int8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;uint8_t&lt;/td&gt;
&lt;td&gt;C.uint8_t&lt;/td&gt;
&lt;td&gt;uint8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;int16_t&lt;/td&gt;
&lt;td&gt;C.int16_t&lt;/td&gt;
&lt;td&gt;int16&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;uint16_t&lt;/td&gt;
&lt;td&gt;C.uint16_t&lt;/td&gt;
&lt;td&gt;uint16&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;int32_t&lt;/td&gt;
&lt;td&gt;C.int32_t&lt;/td&gt;
&lt;td&gt;int32&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;uint32_t&lt;/td&gt;
&lt;td&gt;C.uint32_t&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;int64_t&lt;/td&gt;
&lt;td&gt;C.int64_t&lt;/td&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;uint64_t&lt;/td&gt;
&lt;td&gt;C.uint64_t&lt;/td&gt;
&lt;td&gt;uint64&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;切片&quot;&gt;切片&lt;/h4&gt;
&lt;p&gt;golang 中切片用起来有点像 C 中的数组，但实际的内存模型还是有点区别的。C 中的数组就是一段连续的内存，数组的值实际上就是这段内存的首地址。golang 切片的内存模型如下所示(参考源码 &lt;code&gt;$GOROOT/src/runtime/chan.go&lt;/code&gt;)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://litang.me/image/slice.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于底层内存模型的差异，不能直接将 golang 切片的指针传给 C 函数调用，而是需要将存储切片数据的内部缓冲区的首地址及切片长度取出传传递：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

/*
#include &amp;lt;stdint.h&amp;gt;

static void fill_255(char* buf, int32_t len) {
    int32_t i;
    for (i = 0; i &amp;lt; len; i++) {
        buf[i] = 255;
    }
}
*/
import &quot;C&quot;
import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {
    b := make([]byte, 5)
    fmt.Println(b) // [0 0 0 0 0]
    C.fill_255((*C.char)(unsafe.Pointer(&amp;amp;b[0])), C.int32_t(len(b)))
    fmt.Println(b) // [255 255 255 255 255]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;字符串&quot;&gt;字符串&lt;/h4&gt;
&lt;p&gt;golang 的字符串和 C 中的字符串在底层的内存模型也是不一样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://litang.me/image/string.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;golang 字串符串并没有用 '\0' 终止符标识字符串的结束，因此直接将 golang 字符串底层数据指针传递给 C 函数是不行的。一种方案类似切片的传递一样将字符串数据指针和长度传递给 C 函数后，C 函数实现中自行申请一段内存拷贝字符串数据然后加上未层终止符后再使用。更好的方案是使用标准库提供的 &lt;code&gt;C.CString()&lt;/code&gt; 将 golang 的字符串转换成 C 字符串然后传递给 C 函数调用：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

/*
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

static char* cat(char* str1, char* str2) {
    static char buf[256];
    strcpy(buf, str1);
    strcat(buf, str2);

    return buf;
}
*/
import &quot;C&quot;
import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {
    str1, str2 := &quot;hello&quot;, &quot; world&quot;
    // golang string -&amp;gt; c string
    cstr1, cstr2 := C.CString(str1), C.CString(str2)
    defer C.free(unsafe.Pointer(cstr1)) // must call
    defer C.free(unsafe.Pointer(cstr2))
    cstr3 := C.cat(cstr1, cstr2)
    // c string -&amp;gt; golang string
    str3 := C.GoString(cstr3)
    fmt.Println(str3) // &quot;hello world&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是 &lt;code&gt;C.CString()&lt;/code&gt; 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，使用完后需要自行调用 &lt;code&gt;C.free()&lt;/code&gt; 释放，否则会造成内存泄露，而且这种内存泄露用前文中介绍的 pprof 也定位不出来。&lt;/p&gt;
&lt;h4 id=&quot;其他类型&quot;&gt;其他类型&lt;/h4&gt;
&lt;p&gt;golang 中其他类型(比如 map) 在 C/C++ 中并没有对等的类型或者内存模型也不一样。传递的时候需要了解 golang 类型的底层内存模型，然后进行比较精细的内存拷贝操作。传递 map 的一种方案是可以把 map 的所有键值对放到切片里，然后把切片传递给 C++ 函数，C++ 函数再还原成 C++ 标准库的 map 。由于使用场景比较少，这里就不赘述了。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文主要介绍了在 golang 中使用 CGO 调用 C/C++ 接口涉及的一些细节问题。C/C++ 比较底层的语言，需要自己管理内存。使用 CGO 时需要对 golang 底层的内存模型有所了解。另外 goroutine 通过 CGO 进入到 C 接口的执行阶段后，已经脱离了 golang 运行时的调度并且会独占线程，此时实际上变成了多线程同步的编程模型。如果 C 接口里有阻塞操作，这时候可能会导致所有线程都处于阻塞状态，其他 goroutine 没有机会得到调度，最终导致整个系统的性能大大较低。总的来说，只有在第三方库没有 golang 的实现并且实现起来成本比较高的情况下才需要考虑使用 CGO ，否则慎用。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
</description>
<pubDate>Sun, 18 Nov 2018 06:55:00 +0000</pubDate>
<dc:creator>_toby</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tobycnblogs/p/9977944.html</dc:identifier>
</item>
<item>
<title>SpringMVC入门学习三 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/9977891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/9977891.html</guid>
<description>&lt;p&gt;今天是Springmvc学习的第三天，今天我将主要介绍一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常用注解的使用&lt;/li&gt;
&lt;li&gt;关于非post、get请求的处理&lt;/li&gt;
&lt;li&gt;文件上传与下载&lt;/li&gt;
&lt;li&gt;拦截器&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1439869/201811/1439869-20181118143814621-592977427.jpg&quot; alt=&quot;&quot; name=&quot;SpringMVC入门学习三/1.jpg&quot; data-src=&quot;SpringMVC%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E4%B8%89/1.jpg&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;h2&gt;常用注解的使用&lt;/h2&gt;

&lt;h3&gt;老大在此&lt;/h3&gt;

&lt;h4&gt;@Controller&lt;/h4&gt;
&lt;p&gt;@Controller放在类的上面，用于将一个类标记为Controller，处理DispatcherServlet分发的请求，当然真正处理请求的还是使用@RequestMapping注解的方法。&lt;/p&gt;
&lt;hr class=&quot;xsj_minus&quot;/&gt;
&lt;h3&gt;处理request URI的注解&lt;/h3&gt;

&lt;h4&gt;@RequestMapping&lt;/h4&gt;
&lt;p&gt;@RequestMapping是一个用来处理请求地址映射的注解，可用于类上面【代表模块】和方法上面【代表业务】&lt;/p&gt;
&lt;p&gt;里面&lt;code&gt;参数属性&lt;/code&gt;，其中所有的参数都可以传入&lt;code&gt;数组&lt;/code&gt;的形式：&lt;/p&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;value：代表请求的地址如&quot;/login&quot;,可以写多个【使用数组】，只写它时，可以省略不写&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;name：value的别名，作用是一样的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;method:请求的method类型,里面要传入&lt;code&gt;RequestMethod&lt;/code&gt;类型的数据，如GET,POST,PUT等等，可以指令多个（使用数组传递即可）&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1439869/201811/1439869-20181118143815054-1601345180.png&quot; alt=&quot;&quot; name=&quot;SpringMVC入门学习三/2.png&quot; data-src=&quot;SpringMVC%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E4%B8%89/2.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;它的衍生品：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@GetMapping：专门处理get请求&lt;/li&gt;
&lt;li&gt;@PostMapping：专门处理Post请求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;params：设置需要的参数，如果没有，请求就过不去，还可以设置参数是否等于或则不等于&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/test1&quot;&lt;/span&gt;,params = &lt;span class=&quot;hljs-string&quot;&gt;&quot;data!=not&quot;&lt;/span&gt;)

&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/test1&quot;&lt;/span&gt;,params = &lt;span class=&quot;hljs-string&quot;&gt;&quot;data=have&quot;&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ps:中间注意&lt;code&gt;别打空格&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;headers&lt;br/&gt;指定request中必须包含某些指定的header值，该方法才会处理请求。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/hello&quot;&lt;/span&gt;，headers=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Referer=https://baidu.com&quot;&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;consumes 消费者，指令请求提交内容的类型（Content-Type），例如可以限令必须为application/json;charset=UTF-8，指令多个使用数组形式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;produces 生产者，指令放回的内容的类型，但是必须是请求头所包含的类型&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;@PathVariable&lt;/h4&gt;
&lt;p&gt;这个是restful风格的请求方式,用于将URL中的模板变量映射到方法的参数上面，这个在我的上一篇博客有所介绍。&lt;/p&gt;
&lt;hr class=&quot;xsj_minus&quot;/&gt;
&lt;h3&gt;共享数据&lt;/h3&gt;

&lt;h4&gt;@ModelAttribute&lt;/h4&gt;
&lt;p&gt;@ModelAttribute注解可以被应用在方法参数上面和方法声明上面。其中被@ModelAttribute注解的方法会优先于controller方法（被@RequestMapping注解）之前执行，因为模型对象优先于controller方法创建。&lt;/p&gt;
&lt;p&gt;简单的来说，@ModelAttribute有两个作用，&lt;code&gt;将数据保存在model上面&lt;/code&gt;【标注在方法上面】，将数据从&lt;code&gt;model取出来&lt;/code&gt;【标注在参数里面】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将数据保存在model上面&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;使用@ModelAttribute注解无返回值方法&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@ModelAttribute&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;model1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Model model)&lt;/span&gt;&lt;/span&gt;{
    model.addAttribute(&lt;span class=&quot;hljs-string&quot;&gt;&quot;modle1&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;你好呀&quot;&lt;/span&gt;);
}

&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/modleC&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;modleC&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实这个就相当于&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/modleC&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;modleC&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Model model)&lt;/span&gt;&lt;/span&gt;{
    model.addAttribute(&lt;span class=&quot;hljs-string&quot;&gt;&quot;modle1&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;你好呀&quot;&lt;/span&gt;);
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;注解有返回值的方法&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@ModelAttribute&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;modeler02&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
    String Hello = &lt;span class=&quot;hljs-string&quot;&gt;&quot;你好呀&quot;&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Hello;
    
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;
&lt;p&gt;与@RequestParam结合使用&lt;br/&gt;@RequestParam的具体用法将在下面介绍&lt;/p&gt;
&lt;p&gt;加入此时我们发送了一个这样的请求：&lt;code&gt;/test/name=googboy&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@ModelAttribute&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;modeler02&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(@RequestParam()&lt;/span&gt;String name)&lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; name;
}

&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/test&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;将数据从model取出来&lt;/strong&gt;&lt;br/&gt;假如此时有了一个model，&lt;code&gt;key为name,value为Tom&lt;/code&gt;数据，那么我们可以通过@ModelAttribute将数据取出来。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/test&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(@ModelAttribute(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;)&lt;/span&gt;String name)&lt;/span&gt;{
    
    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;名字是&quot;&lt;/span&gt;+name);
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;保存数据&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;@SessionAttributes&lt;/h4&gt;
&lt;p&gt;假如希望在多个请求之间共用数据，则可以在控制器类上面标注一个@SessionAttributes，其中value指令是model中的哪一个存入session，type为数据类型,两者都可以放数组类型的数据。&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1439869/201811/1439869-20181118143815291-327816582.png&quot; alt=&quot;&quot; name=&quot;SpringMVC入门学习三/3.png&quot; data-src=&quot;SpringMVC%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E4%B8%89/3.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;取出数据&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;@SessionAttribute&lt;/h4&gt;
&lt;p&gt;@SessionAttribute的作用很简单，就是获得session的值&lt;/p&gt;
&lt;p&gt;假如此时有一个session &lt;code&gt;key为name，value为Tom&lt;/code&gt;，获得session&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/test2&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(@SessionAttribute(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;)&lt;/span&gt; String name)&lt;/span&gt;{
    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;session结果是&quot;&lt;/span&gt;+name);
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如此时不存在就会报错，这是可以使用required来确定是否必须&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/test2&quot;&lt;/span&gt;)
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(@SessionAttribute(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;,required = &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;)&lt;/span&gt; String name)&lt;/span&gt;{
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;session结果是&quot;&lt;/span&gt;+name);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;;
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;对于取出参数的处理&lt;/h3&gt;

&lt;h4&gt;@RequestParam&lt;/h4&gt;
&lt;p&gt;@RequestParam主要是用于在Springmvc后台控制层获得参数，类似request.getParameter(&quot;name&quot;)&lt;/p&gt;
&lt;p&gt;它有下列参数&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;value：value表示要取出的参数，当只有value这个参数时，可以省略不写。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;name：value的别名，作用和value一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;required：默认值是true，当传入的参数值不存在时，程序就会报错，这时候就可以将required设置为false。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;defaultValue：当设置defaultValue时，会自动的将required设置为false，如果此时请求参数不存在，就会默认的将参数设置为defaultValue。当然，如果参数存在，defaultValue也就是不会发挥作用了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/test3&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;test3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(@RequestParam(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;,defaultValue = &lt;span class=&quot;hljs-string&quot;&gt;&quot;TomCat&quot;&lt;/span&gt;)&lt;/span&gt; String name)&lt;/span&gt;{
    
    
    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;名字是&quot;&lt;/span&gt;+name);
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;@RequestBody&lt;/h4&gt;
&lt;p&gt;这时候大家可能会问，既然有@RequestParam来处理方式了，为什么我们还要使用@RequestBody来获取参数呢？&lt;/p&gt;
&lt;p&gt;这个主要主要是因为他们处理数据的类型&lt;code&gt;Content-Type&lt;/code&gt;不一样&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;@RequestParam：处理application/x-www-form-urlencoded编码的内容，提交方式为Get，Post。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;@RequestBody：通常是来处理非&lt;code&gt;application/x-www-form-urlencoded编码格式&lt;/code&gt;的内容的数据，比如说&lt;code&gt;application/json&lt;/code&gt;和&lt;code&gt;application/xml&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;既然是处理json数据，那么就需要使用json的jar包。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml hljs&quot; data-info=&quot;xml&quot;&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jackson-databind&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.9.7&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jackson-core&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.9.7&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jackson-annotations&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.9.7&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当发了一个如下所示的json请求时&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js hljs javascript&quot; data-info=&quot;js&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;document&lt;/span&gt;).ready(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; () &lt;/span&gt;{
    $(&lt;span class=&quot;hljs-string&quot;&gt;&quot;button&quot;&lt;/span&gt;).click(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; () &lt;/span&gt;{
        $.ajax({
            &lt;span class=&quot;hljs-attr&quot;&gt;url&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;/test4&quot;&lt;/span&gt;,
            &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;post&quot;&lt;/span&gt;,
            &lt;span class=&quot;hljs-attr&quot;&gt;data&lt;/span&gt;:&lt;span class=&quot;hljs-built_in&quot;&gt;JSON&lt;/span&gt;.stringify({
                &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;TODO&quot;&lt;/span&gt;
            }),
            &lt;span class=&quot;hljs-attr&quot;&gt;dataType&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;json&quot;&lt;/span&gt;,
            &lt;span class=&quot;hljs-attr&quot;&gt;contentType&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;application/json; charset=utf-8&quot;&lt;/span&gt;,
            &lt;span class=&quot;hljs-attr&quot;&gt;success&lt;/span&gt;:&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;data&lt;/span&gt;) &lt;/span&gt;{
                &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(data)
            }
        });
    });
});
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;controller代码,在参数里面加上@RequestBody：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/test4&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;test4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(@RequestBody String name)&lt;/span&gt;&lt;/span&gt;{
    
    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;名字是&quot;&lt;/span&gt;+name);
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;对于返回数据的处理&lt;/h3&gt;

&lt;h4&gt;@ResposeBody&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;返回json数据&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在大多数的情况下，我们不一定是想返回一个视图，只想返回一个json数据或者说xml数据，那么这时候我们就要使用@RequestBody了。@ResponseBody注解被应用于方法上，标志着响应会写到响应体里面去，而不是放到视图Model里面去。&lt;/p&gt;
&lt;p&gt;那么就可以这样使用：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/test4&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-meta&quot;&gt;@ResponseBody&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; User &lt;span class=&quot;hljs-title&quot;&gt;test4&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(@RequestBody String name)&lt;/span&gt;&lt;/span&gt;{
    
    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;名字是&quot;&lt;/span&gt;+name);
    User u = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; User();
    u.setName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小明&quot;&lt;/span&gt;);
    u.setAge(&lt;span class=&quot;hljs-string&quot;&gt;&quot;17&quot;&lt;/span&gt;);
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; u;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;返回xml数据&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;要导入额外的jacksonxml jar包&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml hljs&quot; data-info=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.dataformat&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jackson-dataformat-xml&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.9.7&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;

&lt;span class=&quot;hljs-meta&quot;&gt;@ResponseBody&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/test5&quot;&lt;/span&gt;,produces = org.springframework.http.MediaType.APPLICATION_XML_VALUE)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; User &lt;span class=&quot;hljs-title&quot;&gt;test5&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
    User u = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; User();
    u.setName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小红&quot;&lt;/span&gt;);
    u.setAge(&lt;span class=&quot;hljs-string&quot;&gt;&quot;18&quot;&lt;/span&gt;);
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; u;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;SpringMVC关于非post、get请求的处理&lt;/h2&gt;
&lt;p&gt;在HTML5的规范中，表单元素唯二允许的HTTP的方法是GET和POST，但是如果我们想使用PUT或则DELET方法，那怎么办呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在浏览器中装作自己是post或则get请求，实际上是PUT请求&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html hljs xml&quot; data-info=&quot;html&quot;&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;form&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;action&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/put&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;method&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;post&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;_method&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;PUT&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    姓名 &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;text&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;提交&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;form&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在web.xml文件中，从&lt;code&gt;_method&lt;/code&gt;找到真正的http请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;加入&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml hljs&quot; data-info=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;filter&lt;/span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;filter-name&lt;/span&gt;&amp;gt;&lt;/span&gt;HiddenHttpMethodFilter&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;filter-name&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;filter-class&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;filter-class&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;filter&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;filter-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;filter-name&lt;/span&gt;&amp;gt;&lt;/span&gt;HiddenHttpMethodFilter&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;filter-name&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;springmvc&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;filter-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;


&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;springmvc&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;init-param&lt;/span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;param-name&lt;/span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;param-name&lt;/span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;param-value&lt;/span&gt;&amp;gt;&lt;/span&gt;classpath:springmvc.xml&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;param-value&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;init-param&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;


&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;springmvc&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;/&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;文件上传与下载&lt;/h2&gt;

&lt;h3&gt;文件上传&lt;/h3&gt;
&lt;p&gt;文件上传同时也是使用form表单进行提交，一般我们的表单的提交是文本型的数据，实际上就是进行字符串的拼接。那么文件便不是这样的进行处理，这时候我们就要使用到multipart表单了。&lt;/p&gt;
&lt;p&gt;首先我们的配置一个MultipartResolver来告诉DispatchServlet如何来处理multipart请求。&lt;/p&gt;
&lt;p&gt;在Servlet3.0中，Spring会默认注册一个StandardServletMultipartResolver，我们只需要在web.xml启用&lt;code&gt;&amp;lt;multipart-config&amp;gt;&lt;/code&gt;就行。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml hljs&quot; data-info=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;multipart-config&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;location&lt;/span&gt;&amp;gt;&lt;/span&gt;/tmp&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;location&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;multipart-config&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table class=&quot;table table-striped table-celled&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;location&lt;/td&gt;
&lt;td&gt;上传文件所存放的临时目录。必须指定&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;max-file-size&lt;/td&gt;
&lt;td&gt;文件的最大大小，单位为字节。默认没有限制&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;max-request-size&lt;/td&gt;
&lt;td&gt;请求的最大大小，单位为字节。默认没有限制&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;file-size-threshold&lt;/td&gt;
&lt;td&gt;文件大小阈值，当大于这个阈值时将写入到磁盘，否则在内存中。默认值为0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;前端代码&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html hljs xml&quot; data-info=&quot;html&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;form&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;action&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/upload&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;method&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;post&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;enctype&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;multipart/form-data&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    文件 &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;file&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;file&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;提交&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;form&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制文件上传的代码&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/upload&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;upload&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(@RequestParam(&lt;span class=&quot;hljs-string&quot;&gt;&quot;file&quot;&lt;/span&gt;)&lt;/span&gt;MultipartFile file, HttpServletRequest request) &lt;/span&gt;{
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!file.isEmpty()) {
        
        String fileName = file.getOriginalFilename();
        
        String fileSuffix = fileName.substring(fileName.lastIndexOf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;.&quot;&lt;/span&gt;));
        
        String newName = UUID.randomUUID() + fileSuffix;
        
        String filePath = request.getSession().getServletContext().getRealPath(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/upload&quot;&lt;/span&gt;);

        File fileForPath = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(filePath);
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!fileForPath.exists()) {
            
            fileForPath.mkdir();
        }

        File targetFile = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(filePath, newName);
        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
            
            file.transferTo(targetFile);
        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.printStackTrace();
        }
    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;文件不存在&quot;&lt;/span&gt;);
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;文件下载&lt;/h3&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;down&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;down&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(HttpServletResponse response,HttpServletRequest request)&lt;/span&gt;&lt;/span&gt;{

    
    String fileName= &lt;span class=&quot;hljs-string&quot;&gt;&quot;鬼刀.jpg&quot;&lt;/span&gt;;

    String parentPath = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/home/xiaohiu/images&quot;&lt;/span&gt;;

    
    Path path = Paths.get(parentPath,fileName);

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (Files.exists(path)){
        
        String fileSuffix = fileName.substring(fileName.lastIndexOf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;.&quot;&lt;/span&gt;)+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
        
        response.setContentType(&lt;span class=&quot;hljs-string&quot;&gt;&quot;application/&quot;&lt;/span&gt;+fileSuffix);

        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
            
            response.addHeader(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Content-Disposition&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;attachment;filename=&quot;&lt;/span&gt;+&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; String(fileName.getBytes(&lt;span class=&quot;hljs-string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;),&lt;span class=&quot;hljs-string&quot;&gt;&quot;ISO8859-1&quot;&lt;/span&gt;));
        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
        
            Files.copy(path,response.getOutputStream());
        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.printStackTrace();
        }
    }&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;文件不存在&quot;&lt;/span&gt;);
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;SpringMVC拦截器&lt;/h2&gt;
&lt;p&gt;拦截器实在我们请求之前做检查，同时有权决定我们接下来是否继续，同时也可以对我们的请求进行加工处理，可以设置多个拦截器。&lt;/p&gt;
&lt;p&gt;看到这里，是不是想到了我在前面介绍的&lt;code&gt;AOP&lt;/code&gt;，其实我们可以理解为&lt;code&gt;Spring拦截器是&lt;/code&gt;SpringMVC对AOP的一种实现方式。AOP是通过配置&lt;code&gt;&amp;lt;aop:config&amp;gt;&lt;/code&gt;进行配置，而拦截器是通过&lt;code&gt;&amp;lt;mvc:interceptors&amp;gt;&lt;/code&gt;进行配置。&lt;/p&gt;
&lt;p&gt;那么我们怎么实现呢？&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;10.5&quot;&gt;
&lt;p&gt;实现HandlerInterceptorAdapter接口&lt;/p&gt;
&lt;p&gt;在SpringMVC中，为实现拦截器功能，有两种方式，一个是实现&lt;code&gt;HandlerInterceptor&lt;/code&gt;接口，第二个是实现&lt;code&gt;WebRequestInterceptor&lt;/code&gt;接口，这里我们选择使用HandlerInterceptor。&lt;/p&gt;
&lt;p&gt;在HandlerInterceptor接口中，定义了三个方法&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;preHandle():请求之前调用，返回&lt;code&gt;true&lt;/code&gt;或则&lt;code&gt;false&lt;/code&gt;，返回true，接下来的postHandle和afterCompletion才会起作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;postHandle():在请求之后调用，也就是controller方法执行完后再调用，但是却是在DispatcherServlet进行&lt;code&gt;视图返回渲染之前&lt;/code&gt;被调用。也就是说，这个可以对modle进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;afterCompletion()：在DispatcherServlet进行完试图渲染之后才执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TestInterceptor&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;HandlerInterceptor&lt;/span&gt; &lt;/span&gt;{

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(HttpServletRequest request, HttpServletResponse response, Object handler)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{

        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;请求前进行拦截&quot;&lt;/span&gt;);

        
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;视图渲染前进行拦截&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;视图渲染后进行拦截&quot;&lt;/span&gt;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;
&lt;p&gt;拦截器的配置&lt;/p&gt;
&lt;p&gt;在springmvc的xml配置文件中&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml hljs&quot; data-info=&quot;xml&quot;&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;mvc:interceptors&lt;/span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;mvc:interceptor&lt;/span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;mvc:mapping&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;path&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/*&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
        
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;mvc:exclude-mapping&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;path&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/get&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;cc.weno.interceptor.TestInterceptor&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;mvc:interceptor&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;mvc:interceptors&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候就可以进行拦截了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;拦截器顺序的问题&lt;/p&gt;
&lt;p&gt;拦截器顺序是根据配置的顺序来决定的，但是pre、post、after却有些区别,这张图就可以表示了。&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/1439869/201811/1439869-20181118143815513-2132059893.png&quot; alt=&quot;&quot; name=&quot;SpringMVC入门学习三/4.png&quot; data-src=&quot;SpringMVC%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E4%B8%89/4.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好了，今天的Springmvc就到了这里了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;君子不行陌路，管它咫尺还是天涯&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 06:38:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>今天是Springmvc学习的第三天，今天我将主要介绍一下： 常用注解的使用 关于非post、get请求的处理 文件上传与下载 拦截器 &lt;!-- more --&gt; 常用注解的使用 老大在此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuiduan/p/9977891.html</dc:identifier>
</item>
<item>
<title>ByteBuf（图解） - 疯狂创客圈</title>
<link>http://www.cnblogs.com/crazymakercircle/p/9977872.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crazymakercircle/p/9977872.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Netty ByteBuf（图解 ）之一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之15 【 &lt;span&gt;博客园 总入口&lt;/span&gt; 】&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;源码工程&quot;&gt;源码工程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;源码IDEA工程获取链接&lt;/strong&gt;：&lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;Java 聊天室 实战 源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;​ 大家好，我是作者尼恩。&lt;/p&gt;
&lt;p&gt;​ 今天是百万级流量 Netty 聊天器 打造的系列文章的第15篇，这是一个基础篇。&lt;/p&gt;
&lt;p&gt;​ 由于关于ByteBuf的内容比较多，分两篇文章：&lt;/p&gt;
&lt;p&gt;​ 第一篇：图解 ByteBuf的分配、释放和如何避免内存泄露&lt;/p&gt;
&lt;p&gt;​ 第二篇：图解 ByteBuf的具体使用&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;本篇为第一篇&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;netty-bytebuf-优势&quot;&gt;Netty ByteBuf 优势&lt;/h2&gt;
&lt;p&gt;Netty 提供了ByteBuf，来替代Java NIO的 ByteBuffer 缓，来操纵内存缓冲区。&lt;/p&gt;
&lt;p&gt;与Java NIO的 ByteBuffer 相比，ByteBuf的优势如下：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Pooling (池化，这点减少了内存复制和GC，提升效率)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以自定义缓冲类型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过一个内置的复合缓冲类型实现零拷贝&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;扩展性好，比如 StringBuffer&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不需要调用 flip()来切换读/写模式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;读取和写入索引分开&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法链&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用计数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;手动获取与释放bytebuf&quot;&gt;手动获取与释放ByteBuf&lt;/h2&gt;
&lt;p&gt;Netty环境下，业务处理的代码，基本上都在Handler处理器中的各个入站和出站方法中。&lt;/p&gt;
&lt;p&gt;一般情况下，采用如下方法获取一个Java 堆中的缓冲区：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ByteBuf heapBuffer = ctx.alloc().heapBuffer();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用完成后，通过如下的方法，释放缓冲区：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ReferenceCountUtil.release(heapBuffer );&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的代码很简单，通过release方法减去 heapBuffer 的使用计数，Netty 会自动回收 heapBuffer 。&lt;/p&gt;
&lt;p&gt;缓冲区内存的回收、二次分配等管理工作，是 Netty 自动完成的。&lt;/p&gt;
&lt;h2 id=&quot;自动获取和释放-bytebuf&quot;&gt;自动获取和释放 ByteBuf&lt;/h2&gt;
&lt;h3 id=&quot;方式一tailhandler-自动释放&quot;&gt;方式一：TailHandler 自动释放&lt;/h3&gt;
&lt;p&gt;​ Netty默认会在ChannelPipline的最后添加的那个 TailHandler 帮你完成 ByteBuf的release。&lt;/p&gt;
&lt;p&gt;​ 先看看，自动创建的ByteBuf实例是如何登场的？&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Netty自动创建 ByteBuf实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ Netty 的 Reactor 线程会在 AbstractNioByteChannel.NioByteUnsafe.read() 处调用 ByteBufAllocator创建ByteBuf实例，将TCP缓冲区的数据读取到 Bytebuf 实例中，并调用 pipeline.fireChannelRead(byteBuf) 进入pipeline 入站处理流水线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认情况下，TailHandler自动释放掉ByteBuf实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ Netty的ChannelPipleline的流水线的末端是TailHandler，默认情况下如果每个入站处理器Handler都把消息往下传，TailHandler会释放掉ReferenceCounted类型的消息。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118141229704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;上图中，&lt;strong&gt;TailHandler 写成了TailContext&lt;/strong&gt;，这个是没有错的。&lt;/p&gt;
&lt;p&gt;对于流水线的头部和尾部Hander来说， Context和Hander ，是同一个类。&lt;/p&gt;
&lt;p&gt;HeadContext 与HeadHandler ，也是同一个类。&lt;/p&gt;
&lt;p&gt;关于Context与Handler 的关系，请看 疯狂创客圈 的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​ &lt;strong&gt;如果没有到达末端呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 一种没有到达入站处理流水线pipeline末端的情况，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118141415696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 这种场景下，也有一种自动释放的解决办法，它就是：&lt;/p&gt;
&lt;p&gt;​ 可以继承 SimpleChannelInboundHandler，实现业务Handler。 SimpleChannelInboundHandler 会完成ByteBuf 的自动释放，释放的处理工作，在其入站处理方法 channelRead 中。&lt;/p&gt;
&lt;h3 id=&quot;方式二simplechannelinboundhandler-自动释放&quot;&gt;方式二：SimpleChannelInboundHandler 自动释放&lt;/h3&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​ 如果业务Handler需要将 ChannelPipleline的流水线的默认处理流程截断，不进行后边的inbound入站处理操作,这时候末端 TailHandler自动释放缓冲区的工作，自然就失效了。&lt;/p&gt;
&lt;p&gt;​ 这种场景下，业务Handler 有两种选择：&lt;/p&gt;
&lt;p&gt;本小节，我们聚焦的是第二种选择：看看 SimpleChannelInboundHandler是如何自动释放的。&lt;/p&gt;
&lt;p&gt;利用这种方法，业务处理Handler 必须继承 SimpleChannelInboundHandler基类。并且，业务处理的代码，必须 &lt;strong&gt;移动到&lt;/strong&gt; 重写的 channelRead0(ctx, msg)方法中。&lt;/p&gt;
&lt;p&gt;如果好奇，想看看 SimpleChannelInboundHandler 是如何释放ByteBuf 的，那就一起来看看Netty源码。&lt;/p&gt;
&lt;p&gt;截取的代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class SimpleChannelInboundHandler&amp;lt;I&amp;gt; extends ChannelInboundHandlerAdapter 
{
//...
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    boolean release = true;
    try {
        if (acceptInboundMessage(msg)) {
            @SuppressWarnings(&quot;unchecked&quot;)
            I imsg = (I) msg;
            channelRead0(ctx, imsg);
        } else {
            release = false;
            ctx.fireChannelRead(msg);
        }
    } finally {
        if (autoRelease &amp;amp;&amp;amp; release) {
            ReferenceCountUtil.release(msg);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码中，执行完重写的channelRead0()后，在 finally 语句块中，ByteBuf 的生命被结束掉了。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上面两种，都是&lt;strong&gt;入站处理&lt;/strong&gt;（inbound）过程中的自动释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出站处理（outbound）&lt;/strong&gt;流程，又是如何自动释放呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;方式三headhandler-自动释放&quot;&gt;方式三：HeadHandler 自动释放&lt;/h3&gt;
&lt;p&gt;出站处理流程中，申请分配到的 ByteBuf，通过 HeadHandler 完成自动释放。&lt;/p&gt;
&lt;p&gt;出站处理用到的 Bytebuf 缓冲区，一般是要发送的消息，通常由应用所申请。在出站流程开始的时候，通过调用 ctx.writeAndFlush(msg)，Bytebuf 缓冲区开始进入出站处理的 pipeline 流水线 。在每一个出站Handler中的处理完成后，最后消息会来到出站的最后一棒 HeadHandler，再经过一轮复杂的调用，在flush完成后终将被release掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118141458951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;强调一下，&lt;strong&gt;HeadContext （HeadHandler）是出站处理流程的最后一棒&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出站处理的全过程，请查看疯狂创客圈的专门文章&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;如何避免内存泄露&quot;&gt;如何避免内存泄露&lt;/h2&gt;
&lt;p&gt;​ 基本上，在 Netty的开发中，通过 ChannelHandlerContext 或 Channel 获取的缓冲区ByteBuf 默认都是Pooled，所以需要再合适的时机对其进行释放，避免造成内存泄漏。&lt;/p&gt;
&lt;h3 id=&quot;自动释放的注意事项&quot;&gt;自动释放的注意事项&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们已经知道了三种自动释放方法：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过 TailHandler 自动释放入站 ByteBuf&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;继承 SimpleChannelInboundHandler 的完成 入站ByteBuf 自动释放&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过HeadHandler自动释放出站 ByteBuf&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动释放，注意事项如下&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;入站处理流程中，如果对原消息不做处理，默认会调用 ctx.fireChannelRead(msg) 把原消息往下传，由流水线最后一棒 TailHandler 完成自动释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果截断了入站处理流水线，则可以继承 SimpleChannelInboundHandler ，完成入站ByteBuf 自动释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;出站处理过程中，申请分配到的 ByteBuf，通过 HeadHandler 完成自动释放。&lt;/p&gt;
&lt;p&gt;出站处理用到的 Bytebuf 缓冲区，一般是要发送的消息，通常由应用所申请。在出站流程开始的时候，通过调用 ctx.writeAndFlush(msg)，Bytebuf 缓冲区开始进入出站处理的 pipeline 流水线 。在每一个出站Handler中的处理完成后，最后消息会来到出站的最后一棒 HeadHandler，再经过一轮复杂的调用，在flush完成后终将被release掉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;手动释放的注意事项&quot;&gt;手动释放的注意事项&lt;/h3&gt;
&lt;p&gt;​ 手动释放是自动释放的重要补充和辅助。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;手动释放操作，大致有如下注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;入站处理中，如果将原消息转化为新的消息并调用 ctx.fireChannelRead(newMsg)往下传，那必须把原消息release掉;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;入站处理中，如果已经不再调用 ctx.fireChannelRead(msg) 传递任何消息，也没有继承SimpleChannelInboundHandler 完成自动释放，那更要把原消息release掉;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;多层的异常处理机制，有些异常处理的地方不一定准确知道ByteBuf之前释放了没有，可以在释放前加上引用计数大于0的判断避免异常； 有时候不清楚ByteBuf被引用了多少次，但又必须在此进行彻底的释放，可以循环调用reelase()直到返回true。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别需要强调的，是上边的第一种情况&lt;/strong&gt;。&lt;br/&gt;如果在入站处理的 handlers 传递过程中，传递了新的ByteBuf 值，老ByteBuf 值需要自己手动释放。老的ByteBuf 值，就是从pipeline流水线入口传递过来的 ByteBuf 实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;总之，&lt;strong&gt;只要是在传递过程中，没有传递下去的ByteBuf就需要手动释放，避免不必要的内存泄露&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;缓冲区-allocator-分配器&quot;&gt;缓冲区 Allocator 分配器&lt;/h2&gt;
&lt;p&gt;Netty通过 ByteBufAllocator分配缓冲区。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Netty提供了ByteBufAllocator的两种实现：PoolByteBufAllocator和UnpooledByteBufAllocator。前者将ByteBuf实例放入池中，提高了性能，将内存碎片减少到最小。这个实现采用了一种内存分配的高效策略，称为 &lt;strong&gt;jemalloc&lt;/strong&gt;。它已经被好几种现代操作系统所采用。后者则没有把ByteBuf放入池中，每次被调用时，返回一个新的ByteBuf实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;分配器-allocator的类型&quot;&gt;分配器 Allocator的类型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118141551763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PooledByteBufAllocator：可以重复利用之前分配的内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了减少内存的分配回收以及产生的内存碎片，Netty提供了PooledByteBufAllocator 用来分配可回收的ByteBuf，可以把PooledByteBufAllocator 看做一个池子，需要的时候从里面获取ByteBuf，用完了放回去，以此提高性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UnpooledByteBufAllocator：不可重复利用，由JVM GC负责回收&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;顾名思义Unpooled就是不会放到池子里，所以根据该分配器分配的ByteBuf，不需要放回池子，由JVM自己GC回收。&lt;/p&gt;
&lt;p&gt;这两个类，都是AbstractByteBufAllocator的子类，AbstractByteBufAllocator实现了一个接口，叫做ByteBufAllocator。&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;可以做一个对比试验&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;使用UnpooledByteBufAllocator的方式创建ByteBuf的时候，单台24核CPU的服务器，16G内存，刚启动时候，10000个长连接，每秒所有的连接发一条消息，短时间内，可以看到内存占到10G多点，但随着系统的运行，内存不断增长，直到整个系统内存溢出挂掉。&lt;/p&gt;
&lt;p&gt;把UnpooledByteBufAllocator换成PooledByteBufAllocator，通过试验，内存使用量机器能维持在一个连接占用1M左右，内存在10G左右，经常长期的运行测试，发现都能维持在这个数量，系统内存不会崩溃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;默认的分配器&quot;&gt;默认的分配器&lt;/h3&gt;
&lt;p&gt;​ 默认的分配器 ByteBufAllocator.DEFAULT ，可以通过 Java 系统参数（SystemProperty ）选项 io.netty.allocator.type 去配置，使用字符串值：&quot;unpooled&quot;，&quot;pooled&quot;。&lt;/p&gt;
&lt;p&gt;​ 关于这一段，Netty的源代码截取如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        String allocType = SystemPropertyUtil.get(&quot;io.netty.allocator.type&quot;, &quot;unpooled&quot;).toLowerCase(Locale.US).trim();
        Object alloc;
        if(&quot;unpooled&quot;.equals(allocType)) {
            alloc = UnpooledByteBufAllocator.DEFAULT;
            logger.debug(&quot;-Dio.netty.allocator.type: {}&quot;, allocType);
        } else if(&quot;pooled&quot;.equals(allocType)) {
            alloc = PooledByteBufAllocator.DEFAULT;
            logger.debug(&quot;-Dio.netty.allocator.type: {}&quot;, allocType);
        } else {
            alloc = UnpooledByteBufAllocator.DEFAULT;
            logger.debug(&quot;-Dio.netty.allocator.type: unpooled (unknown: {})&quot;, allocType);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;不同的Netty版本，源码不一样。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 上面的代码，是4.0版本的源码，默认为UnpooledByteBufAllocator。&lt;/p&gt;
&lt;p&gt;​ 而4.1 版本，默认为 PooledByteBufAllocator。因此，4.1版本的代码，是和上面的代码稍微有些不同的。&lt;/p&gt;
&lt;h3 id=&quot;设置通道channel的分配器&quot;&gt;设置通道Channel的分配器&lt;/h3&gt;
&lt;p&gt;在4.x版本中，UnpooledByteBufAllocator是默认的allocator，尽管其存在某些限制。&lt;/p&gt;
&lt;p&gt;现在PooledByteBufAllocator已经广泛使用一段时间，并且我们有了增强的缓冲区泄漏追踪机制，所以是时候让PooledByteBufAllocator成为默认了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ServerBootstrap b = new ServerBootstrap()
        .group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .localAddress(port)
        .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
        .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
            @Override
            public void initChannel(SocketChannel ch) throws Exception {
                ch.pipeline().addLast(...);
            }
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Netty带来的又一个好处就是内存管理。只需一行简单的配置，就能获得到内存池带来的好处。在底层，Netty实现了一个Java版的Jemalloc内存管理库，为我们做完了所有“脏活累活”！&lt;/p&gt;
&lt;h2 id=&quot;缓冲区内存的类型&quot;&gt;缓冲区内存的类型&lt;/h2&gt;
&lt;p&gt;​ 说完了分配器的类型，再来说下缓冲区的类型。&lt;/p&gt;
&lt;p&gt;​ 依据内存的管理方不同，分为堆缓存和直接缓存。也就是Heap ByteBuf 和 Direct ByteBuf。另外，为了方便缓冲区进行组合，提供了一种组合缓存区。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118141630347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;​&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;​ 三种缓冲区的介绍如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;堆缓冲区&lt;/td&gt;
&lt;td&gt;数据存存储在JVM的堆空间中，又称为支撑数组，通过 hasArray 来判断是不是在堆缓冲区中&lt;/td&gt;
&lt;td&gt;没使用池化情况下能提供快速的分配和释放&lt;/td&gt;
&lt;td&gt;发送之前都会拷贝到直接缓冲区&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;直接缓冲区&lt;/td&gt;
&lt;td&gt;存储在物理内存中&lt;/td&gt;
&lt;td&gt;能获取超过jvm堆限制大小的空间；&lt;br/&gt;写入channel比堆缓冲区更快&lt;/td&gt;
&lt;td&gt;释放和分配空间昂贵(使用系统的方法) ；&lt;br/&gt;操作时需要复制一次到堆上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;复合缓冲&lt;/td&gt;
&lt;td&gt;单个缓冲区合并多个缓冲区表示&lt;/td&gt;
&lt;td&gt;操作多个更方便&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;​ 上面三种缓冲区的类型，无论哪一种，都可以通过池化、非池化的方式，去获取。&lt;/p&gt;
&lt;h2 id=&quot;unpooled-非池化缓冲区的使用方法&quot;&gt;Unpooled 非池化缓冲区的使用方法&lt;/h2&gt;
&lt;p&gt;Unpooled也是用来创建缓冲区的工具类，Unpooled 的使用也很容易。&lt;/p&gt;
&lt;p&gt;看下面代码：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;//创建复合缓冲区&lt;/p&gt;
&lt;p&gt;CompositeByteBuf compBuf = Unpooled.compositeBuffer();&lt;/p&gt;
&lt;p&gt;//创建堆缓冲区&lt;br/&gt;ByteBuf heapBuf = Unpooled.buffer(8);&lt;br/&gt;//创建直接缓冲区&lt;br/&gt;ByteBuf directBuf = Unpooled.directBuffer(16);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Unpooled 提供了很多方法，详细方法大致如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;buffer()&lt;br/&gt;buffer(int initialCapacity)&lt;br/&gt;buffer(int initialCapacity, int maxCapacity)&lt;/td&gt;
&lt;td&gt;返回 heap ByteBuf&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;directBuffer()&lt;br/&gt;directBuffer(int initialCapacity)&lt;br/&gt;directBuffer(int initialCapacity, intmaxCapacity)&lt;/td&gt;
&lt;td&gt;返回 direct ByteBuf&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;compositeBuffer()&lt;/td&gt;
&lt;td&gt;返回 CompositeByteBuf&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;copiedBuffer()&lt;/td&gt;
&lt;td&gt;返回 copied ByteBuf&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;Unpooled类的应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Unpooled类让ByteBuf也同样适用于不需要其他的Netty组件的、无网络操作的项目，这些项目可以从这个高性能的、可扩展的buffer API中获益。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;​ 至此为止，终于完成ByteBuf的分配、释放和如何避免内存泄露介绍。&lt;/p&gt;
&lt;p&gt;​ 接下来是：&lt;/p&gt;
&lt;p&gt;​ 第二篇：图解 ByteBuf的具体使用&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;疯狂创客圈-java-死磕系列&quot;&gt;疯狂创客圈 Java 死磕系列&lt;/h2&gt;
&lt;ul readability=&quot;-0.85082872928177&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Java (Netty) 聊天程序【 亿级流量】实战 开源项目实战&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Netty 源码、原理、JAVA NIO 原理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java 面试题 一网打尽&lt;/strong&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.37209302325581&quot;&gt;
&lt;p&gt;疯狂创客圈 &lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;&lt;strong&gt;【 博客园 总入口 】&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;</description>
<pubDate>Sun, 18 Nov 2018 06:32:00 +0000</pubDate>
<dc:creator>疯狂创客圈</dc:creator>
<og:description>Netty ByteBuf（图解 ）之一 疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之15 【 博客园 总入口 】 [toc] 源码工程 源码IDEA工程获取链接 ：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crazymakercircle/p/9977872.html</dc:identifier>
</item>
</channel>
</rss>