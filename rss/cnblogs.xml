<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>算法初级01——认识时间复杂度、对数器、 master公式计算时间复杂度、小和问题和逆序对问题 - kent鹏</title>
<link>http://www.cnblogs.com/xieyupeng/p/9915699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieyupeng/p/9915699.html</guid>
<description>&lt;p&gt;虽然以前学过，再次回顾还是有别样的收获~&lt;/p&gt;

&lt;div class=&quot;Section4&quot;&gt;
&lt;h2&gt;认识时间复杂度&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;常数时间的操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;时间复杂度为一个算法流程中，常数操作数量的指标。常用&lt;/span&gt;O&lt;span&gt;（读作&lt;/span&gt;big O）来表示。具体来说，在常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果记为f(N)，那么时间复杂度为O(f(N))。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是常数项时间。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;h2&gt;例子一&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;一个简单的理解时间复杂度的例子&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Section6&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;一个有序数组&lt;/span&gt;A，另一个无序数组B，请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;算法流程&lt;/span&gt;1：对于数组B中的每一个数，都在A中通过遍历的方式找一下；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;算法流程&lt;/span&gt;2：对于数组B中的每一个数，都在A中通过二分的方式找一下；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;算法流程&lt;/span&gt;3：先把数组B排序，然后用类似外排的方式打印所有在A中出现的数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;三个流程，三种时间复杂度的表达&lt;/span&gt;...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如何分析好坏？&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h2&gt;例子二&lt;/h2&gt;
&lt;p&gt; &lt;span&gt;对数器的概念和使用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Section8&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;0，有一个你想要测的方法a，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1，实现一个绝对正确但是复杂度不好的方法b，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2，实现一个随机样本产生器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;3，实现比对的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;4，把方法a和方法b比对很多次来验证方法a是否正确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;5，如果有一个样本使得比对出错，打印样本分析是哪个方法出&lt;/span&gt;&lt;span&gt;错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;6，当样本数量很多时比对测试依然正确，可以确定方法a已经&lt;/span&gt;&lt;span&gt;正确。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_881647b6-3984-4018-91ef-f4d8633c3a36&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_881647b6-3984-4018-91ef-f4d8633c3a36&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_881647b6-3984-4018-91ef-f4d8633c3a36&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Code_01_InsertionSort {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insertionSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr == &lt;span&gt;null&lt;/span&gt; || arr.length &amp;lt; 2&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; arr.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j] &amp;gt; arr[j + 1]; j--&lt;span&gt;) {
                swap(arr, j, j &lt;/span&gt;+ 1&lt;span&gt;);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j) {
        arr[i] &lt;/span&gt;= arr[i] ^&lt;span&gt; arr[j];
        arr[j] &lt;/span&gt;= arr[i] ^&lt;span&gt; arr[j];
        arr[i] &lt;/span&gt;= arr[i] ^&lt;span&gt; arr[j];
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; comparator(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        Arrays.sort(arr);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] generateRandomArray(&lt;span&gt;int&lt;/span&gt; maxSize, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxValue) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[(&lt;span&gt;int&lt;/span&gt;) ((maxSize + 1) *&lt;span&gt; Math.random())];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arr.length; i++&lt;span&gt;) {
            arr[i] &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;) ((maxValue + 1) * Math.random()) - (&lt;span&gt;int&lt;/span&gt;) (maxValue *&lt;span&gt; Math.random());
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] copyArray(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] res = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[arr.length];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arr.length; i++&lt;span&gt;) {
            res[i] &lt;/span&gt;=&lt;span&gt; arr[i];
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isEqual(&lt;span&gt;int&lt;/span&gt;[] arr1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr2) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((arr1 == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; arr2 != &lt;span&gt;null&lt;/span&gt;) || (arr1 != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; arr2 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr1 == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; arr2 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr1.length !=&lt;span&gt; arr2.length) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arr1.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr1[i] !=&lt;span&gt; arr2[i]) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printArray(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arr.length; i++&lt;span&gt;) {
            System.out.print(arr[i] &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        }
        System.out.println();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; testTime = 500000&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; maxSize = 100&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; maxValue = 100&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; succeed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; testTime; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr1 =&lt;span&gt; generateRandomArray(maxSize, maxValue);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr2 =&lt;span&gt; copyArray(arr1);
            insertionSort(arr1);
            comparator(arr2);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isEqual(arr1, arr2)) {
                succeed &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        System.out.println(succeed &lt;/span&gt;? &quot;Nice!&quot; : &quot;Fucking fucked!&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr =&lt;span&gt; generateRandomArray(maxSize, maxValue);
        printArray(arr);
        insertionSort(arr);
        printArray(arr);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;对数器的例子&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h2&gt;例子三&lt;/h2&gt;

&lt;p&gt; &lt;span&gt;冒泡排序细节的讲解与复杂度分析&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Section10&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;时间复杂度&lt;/span&gt;O(N^2)，额外空间复杂度O(1)&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bubbleSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr == &lt;span&gt;null&lt;/span&gt; || arr.length &amp;lt; 2&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; e = arr.length - 1; e &amp;gt; 0; e--&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; e; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr[i] &amp;gt; arr[i + 1&lt;span&gt;]) {
                    swap(arr, i, i &lt;/span&gt;+ 1&lt;span&gt;);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;h2&gt;例子四&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择排序的细节讲解与复杂度分析&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Section12&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;时间复杂度&lt;/span&gt;O(N^2)，额外空间复杂度O(1)&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; selectionSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr == &lt;span&gt;null&lt;/span&gt; || arr.length &amp;lt; 2&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arr.length - 1; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; minIndex =&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i + 1; j &amp;lt; arr.length; j++&lt;span&gt;) {
                minIndex &lt;/span&gt;= arr[j] &amp;lt; arr[minIndex] ?&lt;span&gt; j : minIndex;
            }
            swap(arr, i, minIndex);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;

&lt;h2&gt;例子五&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;插入排序（类似整理扑克牌）的细节讲解与复杂度分析&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Section14&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;时间复杂度&lt;/span&gt;O(N^2)，额外空间复杂度O(1)&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insertionSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr == &lt;span&gt;null&lt;/span&gt; || arr.length &amp;lt; 2&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; arr.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j] &amp;gt; arr[j + 1]; j--&lt;span&gt;) {
                swap(arr, j, j &lt;/span&gt;+ 1&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;h2&gt;例子六&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;Section16&quot; readability=&quot;24&quot;&gt;
&lt;p&gt;&lt;span&gt;剖析递归行为和递归行为时间复杂度的估算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;一个递归行为的例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;master公式的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;T(N) = a*T(N/b) + O(N^d)  [a是过程发生次数，N/b是子问题，O(N^d)&lt;span&gt;剩下的时间复杂度&lt;/span&gt;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) log(b,a) &amp;gt; d -&amp;gt; 复杂度为O(N^log(b,a))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2) log(b,a) = d -&amp;gt; 复杂度为O(N^d * logN)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;3) log(b,a) &amp;lt; d -&amp;gt; 复杂度为O(N^d)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;补充阅读：&lt;/span&gt;www.gocalf.com/blog/algorithm-complexity-and-master-theorem.html&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;h2&gt;例子七&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;&lt;span&gt;归并排序的细节讲解与复杂度分析&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Section18&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;时间复杂度&lt;/span&gt;O(N*logN)，额外空间复杂度O(N)&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mergeSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr == &lt;span&gt;null&lt;/span&gt; || arr.length &amp;lt; 2&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        mergeSort(arr, &lt;/span&gt;0, arr.length - 1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mergeSort(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (l ==&lt;span&gt; r) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid = l + ((r - l) &amp;gt;&amp;gt; 1&lt;span&gt;);
        mergeSort(arr, l, mid);
        mergeSort(arr, mid &lt;/span&gt;+ 1&lt;span&gt;, r);
        merge(arr, l, mid, r);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; merge(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; m, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] help = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[r - l + 1&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; p1 =&lt;span&gt; l;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; p2 = m + 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p1 &amp;lt;= m &amp;amp;&amp;amp; p2 &amp;lt;=&lt;span&gt; r) {
            help[i&lt;/span&gt;++] = arr[p1] &amp;lt; arr[p2] ? arr[p1++] : arr[p2++&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p1 &amp;lt;=&lt;span&gt; m) {
            help[i&lt;/span&gt;++] = arr[p1++&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p2 &amp;lt;=&lt;span&gt; r) {
            help[i&lt;/span&gt;++] = arr[p2++&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; help.length; i++&lt;span&gt;) {
            arr[l &lt;/span&gt;+ i] =&lt;span&gt; help[i];
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;h2&gt;例子八&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小和问题和逆序对问题&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Section20&quot; readability=&quot;23&quot;&gt;

&lt;p&gt;&lt;span&gt;小和问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[1,3,4,2,5]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;1左边比1小的数，没有；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;3左边比3小的数，1；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;4左边比4小的数，1、3；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2左边比2小的数，1；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;5左边比5小的数，1、3、4、2；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;所以小和为&lt;/span&gt;1+1+3+1+1+3+4+2=16&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逆序对问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_fc8ced16-acd7-4a3d-abca-b787b86634a1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fc8ced16-acd7-4a3d-abca-b787b86634a1&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fc8ced16-acd7-4a3d-abca-b787b86634a1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; smallSum(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (arr == &lt;span&gt;null&lt;/span&gt; || arr.length &amp;lt; 2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; mergeSort(arr, 0, arr.length - 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mergeSort(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (l ==&lt;span&gt; r) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; mid = l + ((r - l) &amp;gt;&amp;gt; 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) +&lt;span&gt; merge(arr, l, mid, r);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; merge(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; m, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] help = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[r - l + 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; p1 =&lt;span&gt; l;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; p2 = m + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; res = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (p1 &amp;lt;= m &amp;amp;&amp;amp; p2 &amp;lt;=&lt;span&gt; r) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             res += arr[p1] &amp;lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             help[i++] = arr[p1] &amp;lt; arr[p2] ? arr[p1++] : arr[p2++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (p1 &amp;lt;=&lt;span&gt; m) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             help[i++] = arr[p1++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (p2 &amp;lt;=&lt;span&gt; r) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             help[i++] = arr[p2++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; help.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             arr[l + i] =&lt;span&gt; help[i];
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;答案&lt;/span&gt;&lt;/div&gt;


&lt;/div&gt;

</description>
<pubDate>Tue, 06 Nov 2018 07:45:00 +0000</pubDate>
<dc:creator>kent鹏</dc:creator>
<og:description>虽然以前学过，再次回顾还是有别样的收获~ 认识时间复杂度 常数时间的操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。 时间复杂度为一个算法流程中，常数操作数量的指标。常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieyupeng/p/9915699.html</dc:identifier>
</item>
<item>
<title>python函数定义及作用域 - Kmnskd</title>
<link>http://www.cnblogs.com/kmnskd/p/9915685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kmnskd/p/9915685.html</guid>
<description>[unable to retrieve full-text content]函数 按照过程编写代码，一般功能都是一次性的，非常不好维护，把功能封装集成，方便二次开发和维护 语法定义：在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 def func_name(arg)</description>
<pubDate>Tue, 06 Nov 2018 07:43:00 +0000</pubDate>
<dc:creator>Kmnskd</dc:creator>
<og:description>函数 按照过程编写代码，一般功能都是一次性的，非常不好维护，把功能封装集成，方便二次开发和维护 语法定义：在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kmnskd/p/9915685.html</dc:identifier>
</item>
<item>
<title>Owin + WebApi + OAuth2 搭建授权模式（授权码模式 Part I） - Light Xun</title>
<link>http://www.cnblogs.com/lightxun/p/9915672.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lightxun/p/9915672.html</guid>
<description>&lt;p&gt;绪&lt;/p&gt;
&lt;p&gt;　　最近想要整理自己代码封装成库，也十分想把自己的设计思路贴出来让大家指正，奈何时间真的不随人意。&lt;/p&gt;
&lt;p&gt;　　想要使用 OWIN 做中间件服务，该服务中包含 管线、授权 两部分。于是决定使用 webapi 、OAuth2 来做。&lt;/p&gt;
&lt;p&gt;　　在搭建途中，几乎是步步遇坎，由于对 OAuth2 内部流转的不了解，在网上到处找大牛的文献介绍，也整理不少，最后贴出。&lt;/p&gt;
&lt;p&gt;　　在捋顺出验证整个内部过程后，遇到了如何使用 js 来发送请求达到验证，以及解决了遇到的跨域问题。&lt;/p&gt;
&lt;p&gt;　　目前仅整理出了 授权码模式 ，闲言少叙，说说自己的理解吧。&lt;/p&gt;

&lt;p&gt;1. 授权码理论，此部分摘要网上介绍较为详细的贴图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557447/201811/557447-20181106134033653-254000890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.1 结合例子来说，当我们与某网站进行合作，需要得到他们的授权信息，在双方协商后，确立了&lt;/p&gt;
&lt;p&gt;　　1.1.1 http://127.0.0.1:10000 对方授权地址&lt;/p&gt;
&lt;p&gt;　　1.1.2 grant_type : authorization_code 授权码模式&lt;/p&gt;
&lt;p&gt;　　1.1.3 response_type : code 授权类型&lt;/p&gt;
&lt;p&gt;　　1.1.4 client_id : lightxun 客户端ID&lt;/p&gt;
&lt;p&gt;　　1.1.5 redirect_uri : http://localhost:58632 返回接收 authorization_code 的地址&lt;/p&gt;
&lt;p&gt;　　1.1.6 state : login 状态，我用来做标识当前请求状态&lt;/p&gt;
&lt;p&gt;1.2 当我们在某网站进行登录时，会可以快捷的使用QQ、微博等账号进行授权登录。那么我们第一步点击登录方式，页面会调转到 对方授权地址，同时携带以上参数，最终获得授权码，触发【A】Authorization Request&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:10000/authorize?grant_type=authorization_code&amp;amp;response_type=code&amp;amp;client_id=lightxun&amp;amp;redirect_uri=http://localhost:58632/&amp;amp;state=login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; target=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_blank&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;authorize&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1.2.1  在某网站后台授权中 首先进行验证被注册的重定向url， 此处我的做法，在其内部将传来的 client_id 与 之前协商的 client_id 进行对比，如无误，则通过验证之前协商的 redirect_uri，为了安全，防止钓鱼，该方法对应为 OpenAuthorizationServerProvider 下的 ValidateClientRedirectUri 方法。此类为继承于 OAuthAuthorizationServerProvider ，并重写其中几部重要的处理方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 验证 redirect_uri, 用于验证被注册的跳转Url
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ValidateClientRedirectUri(OAuthValidateClientRedirectUriContext context)
{
&lt;/span&gt;&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt;验证uri 为了安全,防钓鱼&lt;/span&gt;
&lt;span&gt;　　if&lt;/span&gt;(context.ClientId ==&lt;span&gt; OpenAuthorizationClients.Client.Id)
　　{
&lt;/span&gt;&lt;span&gt;　　　　//&lt;/span&gt;&lt;span&gt;将传来的redirectUri 与 参数验证对比, 所以该参数最好取自数据库&lt;/span&gt;
&lt;span&gt;　　　　context.Validated(OpenAuthorizationClients.Client.RedirectUri);
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1.2.2 在通过了上面的方法验证后，会验证 authorization_code 请求，该方法对应为 OpenAuthorizationServerProvider 下的 ValidateAuthorizeRequest 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 验证 authorization_code 的请求
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ValidateAuthorizeRequest(OAuthValidateAuthorizeRequestContext context)
{
&lt;/span&gt;&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; IsAuthorizationCodeGrantType : 如果“response_type”查询字符串参数为“code”，则为 True
&lt;/span&gt;&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; IsImplicitGrantType : 如果“response_type”查询字符串参数为“token”，则为 True&lt;/span&gt;
&lt;span&gt;　　if&lt;/span&gt; (context.AuthorizeRequest.ClientId == OpenAuthorizationClients.Client.Id &amp;amp;&amp;amp;&lt;span&gt;
　　　　(context.AuthorizeRequest.IsAuthorizationCodeGrantType &lt;/span&gt;||&lt;span&gt; context.AuthorizeRequest.IsImplicitGrantType))
　　{
&lt;/span&gt;&lt;span&gt;　　　　//&lt;/span&gt;&lt;span&gt; 满足以上条件, 标记为已验证&lt;/span&gt;
&lt;span&gt;　　　　context.Validated();
 　　}
&lt;/span&gt;&lt;span&gt;　　else&lt;/span&gt;&lt;span&gt;
　　{
　　　　context.Rejected();
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1.2.3 接着开始处理 authorization_code 请求，来生成授权码，该过程当中整理了一下逻辑，通过 state 来判断当前请求的状态， 如果是 login 则证明需要登录，登录后会将state修改为 validate 并重新发送验证请求。如果是 validate 则说明已成功登录，可以生成授权码了。该方法对应为 OpenAuthorizationServerProvider 下的 AuthorizeEndpoint 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;br/&gt;/// 处理登录逻辑&lt;br/&gt;/// &amp;lt;summary&amp;gt;&lt;br/&gt;[HttpPost]
[Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OAuth/Login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Model.ApiResult Login([FromBody]&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt; obj)
{
&lt;/span&gt;&lt;span&gt;　　///&lt;/span&gt;&lt;span&gt;验证用户名密码&lt;/span&gt;
&lt;span&gt;

　　IOwinContext _context &lt;/span&gt;= (OwinContext)Request.Properties[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MS_OwinContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
　　IOwinRequest _request &lt;/span&gt;=&lt;span&gt; _context.Request;
　　IOwinResponse _response &lt;/span&gt;=&lt;span&gt; _context.Response;

&lt;/span&gt;&lt;span&gt;　　string&lt;/span&gt; _redirectUri = HttpUtility.UrlDecode(_request.Headers[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redirect_uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;　　string&lt;/span&gt; _clientId = _request.Headers[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;　　string&lt;/span&gt; _host =&lt;span&gt; _request.Host.Value;
            
&lt;/span&gt;&lt;span&gt;　　return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Model.ApiResult
　　{
　　　　Data &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/authorize?grant_type=authorization_code&amp;amp;response_type=code&amp;amp;client_id={_clientId}&amp;amp;redirect_uri={_redirectUri}&amp;amp;state=validate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
　　　　Msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;for test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　};
、}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成 authorization_code（authorization code 授权方式）、生成 access_token （implicit 授权模式）
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task AuthorizeEndpoint(OAuthAuthorizeEndpointContext context)
{

　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;implicit 授权方式&lt;/span&gt;
　　&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (context.AuthorizeRequest.IsImplicitGrantType)
　　{
&lt;/span&gt;&lt;span&gt;　　　　var&lt;/span&gt; identity = &lt;span&gt;new&lt;/span&gt; ClaimsIdentity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　　　context.OwinContext.Authentication.SignIn(identity);
　　　　context.RequestCompleted();
　　}
&lt;/span&gt;&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt;authorization code 授权方式&lt;/span&gt;
&lt;span&gt;　　else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (context.AuthorizeRequest.IsAuthorizationCodeGrantType)
　　{
&lt;/span&gt;&lt;span&gt;　　　　//&lt;/span&gt;&lt;span&gt; 通过state 来判断, 是登录还是 已登录的获取 code阶段&lt;/span&gt;
&lt;span&gt;　　　　switch&lt;/span&gt;&lt;span&gt; (context.AuthorizeRequest.State)
　　　　{
&lt;/span&gt;&lt;span&gt;　　　　　　//&lt;/span&gt;&lt;span&gt;如果是登录状态, 则直接跳转, 进行账户验证&lt;/span&gt;
&lt;span&gt;　　　　　　case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
　　　　　　　　context.Response.Redirect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + context.Request.Host.Value + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Page/OAuth/Login.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　　　　　　　context.RequestCompleted();
&lt;/span&gt;&lt;span&gt;　　　　　　　　break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;　　　　　　case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;validate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;　　　　　　　　var&lt;/span&gt; redirectUri = context.Request.Query[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redirect_uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;　　　　　　　　var&lt;/span&gt; clientId = context.Request.Query[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;　　　　　　　　var&lt;/span&gt; identity = &lt;span&gt;new&lt;/span&gt; ClaimsIdentity(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GenericIdentity(clientId, OAuthDefaults.AuthenticationType));

&lt;/span&gt;&lt;span&gt;　　　　　　　　var&lt;/span&gt; authorizeCodeContext = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthenticationTokenCreateContext(
　　　　　　　　　　context.OwinContext,
　　　　　　　　　　context.Options.AuthorizationCodeFormat,
&lt;/span&gt;&lt;span&gt;　　　　　　　　　　new&lt;/span&gt;&lt;span&gt; AuthenticationTicket(
　　　　　　　　　　　　identity,
&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　　new&lt;/span&gt; AuthenticationProperties(&lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
　　　　　　　　　　　　{
　　　　　　　　　　　　　　{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, clientId},
　　　　　　　　　　　　　　{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redirect_uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, redirectUri}
　　　　　　　　　　　　})
　　　　　　　　　　　　{
　　　　　　　　　　　　　　IssuedUtc &lt;/span&gt;=&lt;span&gt; DateTimeOffset.UtcNow,
　　　　　　　　　　　　　　ExpiresUtc &lt;/span&gt;=&lt;span&gt; DateTimeOffset.UtcNow.Add(context.Options.AuthorizationCodeExpireTimeSpan)
　　　　　　　　　　　　}));

&lt;/span&gt;&lt;span&gt;　　　　　　　　await&lt;/span&gt;&lt;span&gt; context.Options.AuthorizationCodeProvider.CreateAsync(authorizeCodeContext);
　　　　　　　　context.Response.Redirect(redirectUri &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?code=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Uri.EscapeDataString(authorizeCodeContext.Token));
　　　　　　　　context.RequestCompleted();
&lt;/span&gt;&lt;span&gt;　　　　　　　　break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;　　　　　　default&lt;/span&gt;&lt;span&gt;:

&lt;/span&gt;&lt;span&gt;　　　　　　　　break&lt;/span&gt;&lt;span&gt;;
　　　　}
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1.2.4 生成 authorization_code 并返回 , 该方法对应 OpenAuthorizationCodeProvider 下的 Create 方法。该类继承于 AuthenticationTokenProvider， 触发【B】Authorization Grant&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;/ &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;/ 生成 authorization_code&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;/ &amp;lt;/summary&amp;gt;&lt;/span&gt;
public override &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Create(AuthenticationTokenCreateContext context)
{
　　context.SetToken(Guid.NewGuid().ToString(&lt;/span&gt;&quot;n&quot;) + Guid.NewGuid().ToString(&quot;n&quot;&lt;span&gt;));
　　_authenticationCodes[context.Token] &lt;/span&gt;=&lt;span&gt; context.SerializeTicket();&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1.3 在接收到授权码之后，我们携带授权码、授权类型、重定向地址，以及设置请求header中加入 Authorization 参数。去寻要 token。触发【C】Authorization Grant&lt;/p&gt;
&lt;p&gt;　　1.3.1 发送请求 js 代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$.ajax({
　　async: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
　　type: &lt;/span&gt;'post'&lt;span&gt;,
　　url: &lt;/span&gt;'http://127.0.0.1:10000/token'&lt;span&gt;,&lt;/span&gt;
　　beforeSend: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(xhr){
　　　　xhr.setRequestHeader(&lt;/span&gt;'Authorization', &quot;Basic &quot; + Base64_Encode(&quot;lightxun:shinichi&quot;&lt;span&gt;))
　　},
　　data: {
　　　　grant_type: &lt;/span&gt;'authorization_code'&lt;span&gt;,
　　　　code: _code,　　//授权码
　　　　redirect_uri: &lt;/span&gt;&quot;http://localhost:58632/&quot;&lt;span&gt;
　　},
　　dataType: &lt;/span&gt;'json'&lt;span&gt;,
　　contentType: &lt;/span&gt;'application/json;charset=utf-8'&lt;span&gt;,
　　success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
　　　　_token &lt;/span&gt;=&lt;span&gt; data.access_token;
　　　　_refreshToken &lt;/span&gt;=&lt;span&gt; data.refresh_token;
　　}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1.3.2 后台接收请求处理，首先验证 client 身份信息（ClientId 及 ClientSecret），该方法对应 OpenAuthorizationServerProvider 下的 ValidateClientAuthentication&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 验证Client的身份（ClientId以及ClientSecret）
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 验证 client 信息, 验证从Basic架构的请求头或Form表单提交过来的客户端凭证
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ValidateClientAuthentication(OAuthValidateClientAuthenticationContext context)
{
&lt;/span&gt;&lt;span&gt;　　string&lt;/span&gt;&lt;span&gt; clientId;
&lt;/span&gt;&lt;span&gt;　　string&lt;/span&gt;&lt;span&gt; clientSecret;
&lt;/span&gt;&lt;span&gt;　　if&lt;/span&gt; (!context.TryGetBasicCredentials(&lt;span&gt;out&lt;/span&gt; clientId, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; clientSecret))
　　{
　　　　context.TryGetFormCredentials(&lt;/span&gt;&lt;span&gt;out&lt;/span&gt; clientId, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; clientSecret);
　　}

&lt;/span&gt;&lt;span&gt;　　if&lt;/span&gt; (clientId !=&lt;span&gt; OpenAuthorizationClients.Client.Id)
　　{
　　　　context.SetError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;invalid_client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client is not valid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;　　　　return&lt;/span&gt;&lt;span&gt;;
　　}
　　context.Validated();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1.3.3  验证后，开始将 authorization_code 解析成 access_token，该方法对应 OpenAuthorizationCodeProvider 下的 Receive&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 由 authorization_code 解析成 access_token
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Receive(AuthenticationTokenReceiveContext context)
{
&lt;/span&gt;&lt;span&gt;　　string&lt;/span&gt;&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;　　if&lt;/span&gt; (_authenticationCodes.TryRemove(context.Token, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; value))
　　{
　　　　context.DeserializeTicket(value);
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1.3.4 验证 token，该方法对应 OpenAuthorizationServerProvider 下的 ValidateTokenRequest&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 验证 access_token 的请求
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ValidateTokenRequest(OAuthValidateTokenRequestContext context)
{
&lt;/span&gt;&lt;span&gt;　　if&lt;/span&gt; (context.TokenRequest.IsAuthorizationCodeGrantType ||&lt;span&gt; context.TokenRequest.IsRefreshTokenGrantType)
　　{
　　　　context.Validated();
　　}
&lt;/span&gt;&lt;span&gt;　　else&lt;/span&gt;&lt;span&gt;
　　{
　　　　context.Rejected();
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1.3.5 生成 token，该方法对应 OpenRefreshTokenProvider 下的 Create 。触发【D】Access Token&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成 refresh_token
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Create(AuthenticationTokenCreateContext context)
{
　　context.Ticket.Properties.IssuedUtc &lt;/span&gt;=&lt;span&gt; DateTime.UtcNow;
　　context.Ticket.Properties.ExpiresUtc &lt;/span&gt;= DateTime.UtcNow.AddDays(&lt;span&gt;60&lt;/span&gt;&lt;span&gt;);

　　context.SetToken(Guid.NewGuid().ToString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + Guid.NewGuid().ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
　　_refreshTokens[context.Token] &lt;/span&gt;=&lt;span&gt; context.SerializeTicket();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1.4 最后我们携带着 token 去请求资源即可。触发【E】Access Token 和 【F】Protected Resource&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$.ajax({
　　async: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
　　type: &lt;/span&gt;'post'&lt;span&gt;,
　　url: &lt;/span&gt;'http://127.0.0.1:10000/token'&lt;span&gt;,
　　beforeSend: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (xhr) {
　　　　xhr.setRequestHeader(&lt;/span&gt;'Authorization', &quot;Basic &quot; + Base64_Encode(&quot;lightxun:shinichi&quot;&lt;span&gt;))
　　},
　　data: {
　　　　grant_type: &lt;/span&gt;'refresh_token'&lt;span&gt;,
　　　　refresh_token: _refreshToken,
　　},
　　dataType: &lt;/span&gt;'json'&lt;span&gt;,
　　contentType: &lt;/span&gt;'application/json;charset=utf-8'&lt;span&gt;,
　　success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
　　　　_token &lt;/span&gt;=&lt;span&gt; data.access_token;
　　　　_refreshToken &lt;/span&gt;=&lt;span&gt; data.refresh_token;
　　}
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;今天整理的有点儿多，还有许多没有写到位，后续慢慢补充，也会把全额代码贴出来，包括 OAuth 部分全额配置及代码。&lt;/p&gt;
&lt;p&gt;期间参考过的大牛博文连接如下&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/xishuai/p/aspnet-webapi-owin-oauth2.html&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/YamatAmain/p/5029466.html&lt;/p&gt;
&lt;p&gt;https://www.code996.cn/post/2018/token-front/&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/xizz/archive/2015/12/18/5056195.html&lt;/p&gt;
&lt;p&gt;https://cloud.tencent.com/developer/article/1090017&lt;/p&gt;
&lt;p&gt;https://cloud.tencent.com/developer/article/1340117&lt;/p&gt;
&lt;p&gt;https://cloud.tencent.com/developer/article/1157890&lt;/p&gt;
&lt;p&gt;https://cloud.tencent.com/developer/article/1096046&lt;/p&gt;
&lt;p&gt;http://blogread.cn/it/article/7808?f=wb_blogread&lt;/p&gt;
&lt;p&gt;---- 以下为跨域文献&lt;/p&gt;
&lt;p&gt;http://jcblog.net.cn/2016/07/19/webapi%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%EF%BC%88cors%EF%BC%89%E9%85%8D%E7%BD%AE/&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/baiyunchen/p/5769884.html&lt;/p&gt;
</description>
<pubDate>Tue, 06 Nov 2018 07:42:00 +0000</pubDate>
<dc:creator>Light Xun</dc:creator>
<og:description>绪 最近想要整理自己代码封装成库，也十分想把自己的设计思路贴出来让大家指正，奈何时间真的不随人意。 想要使用 OWIN 做中间件服务，该服务中包含 管线、授权 两部分。于是决定使用 webapi 、O</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lightxun/p/9915672.html</dc:identifier>
</item>
<item>
<title>二维码神器QRCoder - 山治先生</title>
<link>http://www.cnblogs.com/EminemJK/p/9915377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EminemJK/p/9915377.html</guid>
<description>&lt;p&gt;　　好久没有写Blog，都是因为不小心坠入了爱河，时间都给我家那位了，都没时间加班了（嗨呀，不小心撒了一下狗粮）&lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201811/720686-20181106143727300-1731105656.png&quot; alt=&quot;&quot;/&gt;，不过，还是希望单身的赶紧找到心仪的另一半，实在找不到，那就加班啊。&lt;/p&gt;

&lt;p&gt;现在出门在外，二维码随处可见，吃个东西、买个青菜，没有weixin或者zhifubao的扫一扫来付款，阿姨都嫌弃你了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201811/720686-20181106151511096-135867631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里推荐一款开源二维码的第三方库：QRCoder&lt;/p&gt;
&lt;p&gt;QRCoder：https://github.com/codebude/QRCoder/&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QRCoder是一个简单的库，用C＃.NET编写，可以创建QR码，没有与其他的库有&lt;/span&gt;&lt;span&gt;任何依赖关系， 引用就一个几百kb的dll，并且效率还不错。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;引入&lt;/h2&gt;
&lt;p&gt;新建一个winform项目，然后从nuget上引入即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201811/720686-20181106144903138-1757632539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再引入命名空间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Forms;

&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; QRCoder; //就是它，没有多余的
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建第一张二维码&lt;/h2&gt;
&lt;p&gt;在GayHub上，QRCoder的readme已经介绍过了，只要4行简单的代码，就可以完成二维码生成了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
QRCodeGenerator qrGenerator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QRCodeGenerator();
QRCodeData qrCodeData &lt;/span&gt;= qrGenerator.CreateQrCode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The text which should be encoded.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QRCodeGenerator.ECCLevel.Q);
QRCode qrCode &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QRCode(qrCodeData);
Bitmap qrCodeImage &lt;/span&gt;= qrCode.GetGraphic(&lt;span&gt;20&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过这里做了一个简单的winform来使用它，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CreateQR(&lt;span&gt;int&lt;/span&gt; pixelsPerModule, &lt;span&gt;string&lt;/span&gt; info, Color qrColor, Color qrBackgroundColor, Bitmap logo, &lt;span&gt;int&lt;/span&gt; iconSizePercent = &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; iconBorderWidth = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
{
    QRCodeGenerator qrGenerator &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QRCodeGenerator();
    QRCodeData qrCodeData &lt;/span&gt;=&lt;span&gt; qrGenerator.CreateQrCode(info, QRCodeGenerator.ECCLevel.Q);
    QRCode qrCode &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QRCode(qrCodeData);
    Bitmap qrCodeImage &lt;/span&gt;= qrCode.GetGraphic(pixelsPerModule, qrColor, qrBackgroundColor, logo, iconSizePercent, iconBorderWidth, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    picBoxQRCode.Image &lt;/span&gt;=&lt;span&gt; qrCodeImage;
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CreateQR(&lt;span&gt;int&lt;/span&gt; pixelsPerModule, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; info, Color qrColor, Color qrBackgroundColor)
{
    QRCodeGenerator qrGenerator &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QRCodeGenerator();
    QRCodeData qrCodeData &lt;/span&gt;=&lt;span&gt; qrGenerator.CreateQrCode(info, QRCodeGenerator.ECCLevel.Q);
    QRCode qrCode &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QRCode(qrCodeData);
    Bitmap qrCodeImage &lt;/span&gt;= qrCode.GetGraphic(pixelsPerModule, qrColor, qrBackgroundColor, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    picBoxQRCode.Image &lt;/span&gt;=&lt;span&gt; qrCodeImage;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;界面效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720686/201811/720686-20181106153337763-1780505936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;QRCoder还有许多设置，根据不同需要来传入不同参数即可。&lt;/p&gt;
&lt;p&gt;文章中的Demo代码很简单，大家借鉴参考玩玩，欢迎大家来到GayHub交流：https://github.com/EminemJK/QRCodeForm&lt;/p&gt;
&lt;p&gt;.Net生态社区希望越来越壮大，不断有优秀的开源组件的加入。&lt;/p&gt;
</description>
<pubDate>Tue, 06 Nov 2018 07:27:00 +0000</pubDate>
<dc:creator>山治先生</dc:creator>
<og:description>好久没有写Blog，都是因为不小心坠入了爱河，时间都给我家那位了，都没时间加班了（嗨呀，不小心撒了一下狗粮），不过，还是希望单身的赶紧找到心仪的另一半，实在找不到，那就加班啊。 二维码神器 现在出门在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EminemJK/p/9915377.html</dc:identifier>
</item>
<item>
<title>为何要花费精力琢磨人工意识? - 鬼柒</title>
<link>http://www.cnblogs.com/7rhythm/p/9755131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/7rhythm/p/9755131.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;人工意识的人工智能的区别&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　大概我不用解释什么是人工意识，但是这个概念其实跟AI有一些细微差别，叫强人工智能也可以，但是最近我认识到 “智能” 跟“意识”之间是俩回事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;机器智能是这样的，比如说最基础的计算器，这个也属于机器智能，它会按照一定规则+指令解决一些复杂问题，但是缺乏主观能动性，这个计算器没有源动力，如果它突然有一天自己决定开始计算圆周率的N个小数位。那么这个时候可以称之为具备自我意识。当然现阶段科学理论，还没有一种非常可信的方式验证某一个“非我”个体具备自我意识，这个问题在学界有个很有名气的说法叫“他心问题”，有兴趣的童鞋另行研究。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　那么细化一下机器智能，那么最近的十年间我们称之为AI技术的东西，跟一百年前创造的电脑技术在智能这个方面有什么区别呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　其实本质是一样的，就是遵循一定规则一定指令来解决问题，但是现阶段的机器智能是学习大量数据中特定规则的过程。算法工程师们设定了一个学习规则，让机器智能按照某种学习方式，去学习数据中的规则，然后通过学习到的规则解决问题，而这个待学习的规则，只有模糊的定义，没有办法知悉明确算法逻辑。所以很多人说这是一个黑箱子算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　上面这段话估计有点难理解，我再举一个例子来做附加说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　就是图片识别，我之前在其他文章里讲过 CNN 卷积神经网络，这是一个图片识别的算法，CNN算法学习了大量分类好的图片（假设是一堆猫图，一堆花草图），然后算法分别提取了猫和花草的识别规则保存下来，下次再来一张完全新的猫图，就能轻易的识别正确。 那么问题来了，这个所谓是“猫的规则”是什么？  如果你随便问一个人，“大佬，你是怎么识别一只猫的？”  那么回答大概可以是这样“猫有毛发，尖耳朵，胡须，尾巴，四只爪子等等一系列特征” 而且只要具备局部特征，大佬也能识别出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　但是CNN算法不是这样的，就算你掰开这个算法盒子，给你看到里面保存的所有数据，你也没办法回答，它是通过什么特征识别猫的？因为它的理论基础是“万能近似定理” 就是一个万能函数，只要设定好一些变量，它可以近似成任意的函数。但不能100%等于，所以虽然这个算法找到了最优的近似函数，但是它还是不知道它近似的这个函数是什么？逻辑是什么？没有因果，只有近似。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/194179/201811/194179-20181106145425233-1648299996.jpg&quot; alt=&quot;&quot;/&gt;  （猫草了解一下）&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　　　终于非常粗浅的讲完智能跟意识的区别，回到主题，我为什么要开始琢磨这件事？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　概括性讲这是一个横穿非常多学科的课题。我大概列一下这几年我看的一些书的主题范围：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1，计算机类　2，生物学 　　3，概率论　　4，代数　　　5，心理学　……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　就这几个领域也够头疼了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　人工意识是目前尚未解决的课题，这个一个无从下手的难题，但是很欣喜的是智能问题也在被一一破解，相信不久将来这个课题也可以被攻克。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我大概是前几年在一家外包公司任职的时候，可能是技术经验积累到一定量后，开始浪了，内心一直渴望解决一些超级难题，心态膨胀了。所以把目光聚焦到了AI领域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　当然后来也经历过很长时间的停滞，因为完全找不到头绪，连入门也是摸索了很久才学习到了一些有用的知识。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　有一阵子我想着放弃，这尼玛妥妥的是一个世界难题，花一生时间估计都会像打水漂一样，可能一点像样的东西也做不出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是写这篇文章的时候我终于想通一件事了，因为我比较喜欢玩游戏，解决这个问题犹如游戏里的开荒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开荒下副本，没有现成攻略，没有指南 指北，没有任何一个人可以说我的方法是对或者是错。如果我是结果论者，那么一个看不到结果的过程会让人绝望，成功固然欣喜，失败却让人止步不前。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是开荒这件事本身就让人兴奋不已，做的每一件尝试都是前人所未知的，每时每刻可能都有新的发现。每一小点的成就，都可能是独一无二的，在这样一个高度专业化的领域里，只要稍微的往前挪一步，在这个方向上就是独创的，就是TOP。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样的探索过程，难道不值得欢欣雀跃么？至于结果如何，不用太过执着，成功是好的，失败了我也有所收获。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　这就好像一个可以玩一辈子的副本，有起有落，可能几年过去了，一点收获也没有，又可能某个喝咖啡的瞬间突然灵感涌现。如果时不时有这种惊喜，这样的人生还有什么遗憾？&lt;/span&gt;&lt;span&gt;　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 06 Nov 2018 07:17:00 +0000</pubDate>
<dc:creator>鬼柒</dc:creator>
<og:description>人工意识的人工智能的区别 大概我不用解释什么是人工意识，但是这个概念其实跟AI有一些细微差别，叫强人工智能也可以，但是最近我认识到 “智能” 跟“意识”之间是俩回事。 机器智能是这样的，比如说最基础的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/7rhythm/p/9755131.html</dc:identifier>
</item>
<item>
<title>为什么需要创建型模式以及简单工厂模式（三） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/9915249.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/9915249.html</guid>
<description>&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181106145155538-1916207761.png&quot;&gt;&lt;img title=&quot;image_5be1399f_7e53&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181106145155848-366084377.png&quot; alt=&quot;image_5be1399f_7e53&quot; width=&quot;237&quot; height=&quot;157&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ps：包名不应该有大写，应该尽可能地使用一个单词，实在无法避免也不要驼峰命名，全部小写&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; simpleFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/9.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Fruit {
String description();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; simpleFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/9.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Apple &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Fruit {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String description() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;apple&quot;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; simpleFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/9.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Orange &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Fruit {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String description() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Orange&quot;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; simpleFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/9.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; FruitType {
APPLE,
ORANGE
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; simpleFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/9.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleFruitFactory {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Fruit create(FruitType fruitType){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(fruitType.equals(FruitType.APPLE)){
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Apple();
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(fruitType.equals(FruitType.ORANGE)){
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Orange();
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181106145156072-2036855953.png&quot;&gt;&lt;img title=&quot;image_5be1399f_4868&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181106145156275-1474428950.png&quot; alt=&quot;image_5be1399f_4868&quot; width=&quot;684&quot; height=&quot;409&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;结构&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;通过示例可以看得出来，简单工厂模式的确很简单&lt;/p&gt;
&lt;p&gt;关键点就是这个静态create方法，内部使用if else结构或者switch结构&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;由于通常都是静态方法，所以又叫做静态工厂方法模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;模式如下图所示&lt;/p&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181106145156470-2068988490.png&quot;&gt;&lt;img title=&quot;image_5be1399f_34dd&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181106145156669-428486050.png&quot; alt=&quot;image_5be1399f_34dd&quot; width=&quot;324&quot; height=&quot;194&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;工厂类根据传入的参数决定创建哪一种类型的具体产品&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;工厂类Factory&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一般就是具体的Java实现类，在客户端程序的请求下直接创建具体的产品，提供静态工厂方法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;抽象产品 Product&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;工厂所创建对象的父类或者公共接口，一般是接口或者抽象类&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;具体产品 ConcreteProduct&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;创建的具体的实例对象&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;特点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;简单工厂模式特点：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;静态方法&lt;/strong&gt;&lt;/span&gt;、&lt;span&gt;&lt;strong&gt;根据参数确定待创建对象的类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然，也可以不在一个方法中处理，&lt;span&gt;&lt;strong&gt;也可以创建多个方法&lt;/strong&gt;&lt;/span&gt;来创建不同的具体产品对象&lt;/p&gt;

&lt;p&gt;而且，如果产品只有一种的话，也可以省略抽象的产品Product角色&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181106145156847-488370583.png&quot;&gt;&lt;img title=&quot;image_5be1399f_54d5&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181106145157056-944204391.png&quot; alt=&quot;image_5be1399f_54d5&quot; width=&quot;324&quot; height=&quot;86&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;简单工厂模式&lt;span&gt;&lt;strong&gt;处于产品实例化的核心位置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;他知道每个产品，也就是内部直接清楚创建的对象类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;他决定哪一个产品类应该被实例化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;允许客户端程序与具体产品的创建过程独立，在系统引入新产品时，不需要修改客户端代码&lt;/p&gt;
&lt;p&gt;所以说站在客户端程序的视角看待的话， 算是符合开闭原则&lt;/p&gt;
&lt;p&gt;对于简单的场景，简单工厂模式是一个不错的选择，既能够获得工厂型模式的优点&lt;/p&gt;
&lt;p&gt;又足够的简便清晰&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;简单工厂模式根本特点就是一个工厂类包打天下，创建所有的产品&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;简单工厂模式缺点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;既然叫做简单工厂模式，他的优点之一自然是简单&lt;/p&gt;
&lt;p&gt;所有的创建逻辑都封装在了一个工厂类中，以不变应万变，所有产品的创建都尽在其中&lt;/p&gt;
&lt;p&gt;但是&lt;span&gt;&lt;strong&gt;面对复杂的产品体系结构，优点就变成了缺点 ，可能就会过于臃肿复杂不易维护复用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;比如，如果新增加了子类，怎么办？&lt;/p&gt;
&lt;p&gt;显然需要修改工厂的静态方法&lt;/p&gt;
&lt;p&gt;想要扩展功能必须修改工厂类的代码，也就是&lt;span&gt;&lt;strong&gt;站在工厂类的角度，不符合开闭原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而且，面对复杂的产品体系结构，这个工厂类提供所有的创建逻辑&lt;/p&gt;
&lt;p&gt;成了一个功能大而全的类，显然这&lt;span&gt;&lt;strong&gt;违背了单一职责原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也会更容易出现问题&lt;/p&gt;

</description>
<pubDate>Tue, 06 Nov 2018 07:03:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>简单工厂模式又称为静态工厂模式是设计模式的基础模式，本文首先介绍了创建型设计模式的特点，使用场景，然后介绍了简单工厂模式的概念，特点，示例代码，以及简单工厂模式的缺点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/9915249.html</dc:identifier>
</item>
<item>
<title>Chrome DevTools 的 Sources  调试 - lsc183</title>
<link>http://www.cnblogs.com/lsc183/p/9915285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsc183/p/9915285.html</guid>
<description>&lt;p&gt;在 Chrome 中调试 JS 代码，那你不得不与 Chrome DevTools 的 Sources 面板打交道，所以文章主要通过介绍 Sources 面板上的各部分功能来介绍如何调试网页中的 JS。&lt;/p&gt;
&lt;h2&gt;熟悉 Sources 面板&lt;/h2&gt;
&lt;p&gt;先来认识一下 Sources 面板(以我的 Github 首页举例)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-1.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-1.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到面板被分为左中右三个部分，左边是文件导航，中间是文件的具体内容，右边可以统称为调试面板。整个面板就像一个 IDE，所以还是挺亲切的。&lt;/p&gt;
&lt;p&gt;左边的文件导航面板包含 3 个面板：&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-11.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-11.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;，分别是：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Sources：这个面板很好理解，展示了网页所用到的所有文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Content scripts：Content scripts 指的是 Chrome 拓展注入在网页中的脚本。比如我安装了一个叫 JSONView 的 Chrome 拓展，打开我的 Content scripts 面板会看到：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-12.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-12.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Snippets：Snippets 的含义是片段，在这里指的是一小段程序，这个一小段程序跟在其他地方不一样的是，可以访问这个页面中的变量和函数等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;中间面板的其他操作都比较显而易见，只是有 4 点需要简单提一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-2.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-2.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记 1、2 处可以隐藏/展开左右两个面板，标记 3 处格式化代码，使得代码变得易于阅读，当代码被压缩时尤其有用。另外需要提一下的是打开文件的快捷方式，可以用 Cmd + p / Ctrl + p 在任何一个功能面板上搜索一个文件，按 enter 键在 Sources 面板上打开。&lt;/p&gt;
&lt;p&gt;右边的调试面板比较复杂，需要借助调试的例子来解释作用。不过我们可以先大概熟悉一下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-1.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-1.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;右侧的面板为上下结构，上面是一组功能按钮，下面由很多面板组成，这些面板中，看名字大概能知道第二个显示的是调用栈，从四个开始就是各种类型的断点。那真相是什么呢？我们下面结合调试实例来解释这些按钮/面板的功能。&lt;/p&gt;
&lt;h2&gt;添加断点与断点类型&lt;/h2&gt;
&lt;p&gt;本文用到的测试代码为自己所写的 Demo。&lt;/p&gt;
&lt;h3&gt;添加断点&lt;/h3&gt;
&lt;p&gt;打开一个文件，中间的面板中显示了代码，代码的左侧有代码行号，代码行号所在的位置叫做行号槽，点击行号槽，为相应的行添加断点，并在相应的行号上面加上一个类似肩章的五边形图标。特别提一下的是，这个图标的颜色是蓝色的。如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-3.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-3.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外，如果一条语句由多行组成，如果在这条语句的行中添加断点的话，那么断点将会被加到下一条语句。举例如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-4.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-4.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在上面的代码中，你可以在 13 行添加断点，但如果你想在 14-17 行添加断点的话，那么断点将会被添加到 19 行。另外，你也不能为空行添加断点，那也会被添加到下一条语句上。比如你想在 18 行添加断点，但实际会被添加到 19 行。&lt;/p&gt;
&lt;p&gt;条件断点&lt;/p&gt;
&lt;p&gt;右键一个没有添加断点的行号，选择 &quot;Add conditional breakpoint&quot;，输入你的条件，当条件满足时，断点才会生效。回车后，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-5.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-5.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看见，条件断点跟一般断点的区别就是颜色变成了黄色。&lt;/p&gt;
&lt;p&gt;行内断点&lt;/p&gt;
&lt;p&gt;之前有人在评论里问，为什么我的这个系列文章要加一个 v57 这个前提，行内断点就是一个很好的回答。行内断点是从 Chrome(v55) 才有的一个功能，意思是你可以在一行内添加多个断点。看下面的例子：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/source-debug-13.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/source-debug-13.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;跟前面添加断点方式一样，我先在 15 行添加了一个断点，当程序中断在 15 行时，出现了上图的例子。但与一般的例子不同的是，上面有 3 处标红的位置，表示 3 处断点。但第 1 个断点跟后 2 个不一样的是，第 1 个断点是默认处于激活状态，而后 2 个则不是，只有点击激活后才能生效。&lt;/p&gt;
&lt;h3&gt;断点的其他操作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;忽略：如果你想暂时忽略某个断点，右键断点，选择 &quot;Disable breakpoint&quot;&lt;/li&gt;
&lt;li&gt;修改：修改断点生效的条件。你可以将一个非条件断点通过这个方式修改成条件断点，也可以将条件断点变成非条件断点&lt;/li&gt;
&lt;li&gt;删除：你可以直接点击断点，或者右键 &quot;Remove breakpoint&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;黑盒脚本&lt;/h3&gt;
&lt;p&gt;右键行号槽的时候，第一个选项总是：&quot;Blackbox Script&quot;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-6.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-6.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那什么是黑盒脚本呢？&lt;/p&gt;
&lt;p&gt;我们写项目时，很多时候是要引用第三方库或框架的，当我们调试时，调试的对象应该是我们自己写的代码，但很多时候，我们经常在焦灼地进行下一步下一步时，突然代码跳到了第三方库或框架的源码上去，这让我们焦灼的内心更添了一把柴火。黑盒脚本就是用来解决这个问题的。它能够将一个脚本文件标记为 &quot;Blackbox Script&quot;，那么我们就永远不可能进入这个文件内部，这个文件对我们来讲就是一个黑盒子。为什么要强调“永远”呢？因为不仅普通的断点不能访问这个被标记了的脚本，其他的，比如说 DOM 断点、事件断点等等都无法访问那个脚本文件内部。&lt;/p&gt;
&lt;h3&gt;面板介绍 -- Breakpoints&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-2.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-2.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个面板会显示你所有的通过行号留下的断点。你可以右键管理某个或全部断点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Remove Breakpoints：删除选中的断点&lt;/li&gt;
&lt;li&gt;Deactivate Breakpoints：暂时忽略所有断点&lt;/li&gt;
&lt;li&gt;Disable all Breakpoints：功能同上（与上一功能有细微差别，但表现类似）&lt;/li&gt;
&lt;li&gt;Remove all Breakpoints：删除所有断点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了普通的中断类型，我们下面再介绍几款其他类型的。&lt;/p&gt;
&lt;h3&gt;面板介绍 -- DOM Breakpoints&lt;/h3&gt;
&lt;p&gt;在 Elements 面板，右键 body 元素，插入 &quot;attribute modifications breakpoint&quot;，在 Sources 面板中显示如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-3.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-3.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看 DOM 断点的详细信息请查看另一篇博客：&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/Elements.md&quot;&gt;Elements&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;面板介绍 -- XHR Breakpoints&lt;/h3&gt;
&lt;p&gt;XHR 断点跟 DOM 断点很类似，通过 XHR 断点可以很容易的找到 ajax 调用的触发点和调用堆栈。最新的 Chrome DevTools 中要么为所有 ajax 调用添加断点，要么都不添加断点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-4.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-4.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;面板介绍 -- Event Listener Breakpoints&lt;/h3&gt;
&lt;p&gt;展开 Event Listener Breakpoints 可以看到一组事件类型，展开一个事件类型可以看到具体的事件名称。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-5.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-5.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每个事件名称和事件类型前面都有个复选框，选中即指当页面中触发了所选的事件的话，就会触发中断。&lt;/p&gt;
&lt;h3&gt;面板介绍 -- Global Listeners&lt;/h3&gt;
&lt;p&gt;显示全局监听器，在浏览器中 window 是全局对象，所以在 Global Listeners 面板中显示绑定在 window 对象上的事件监听。&lt;/p&gt;
&lt;h3&gt;异常中断&lt;/h3&gt;
&lt;p&gt;这个跟上面几种不一样，这个是放在功能按钮组里面的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-6.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-6.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选中 &quot;Pause on exceptions&quot; 按钮，如上图，当执行的脚本出现异常时会触发中断。&lt;/p&gt;
&lt;p&gt;介绍了如何添加断点的方式以及几款中断类型，下面介绍一下如何利用断点进行调试。&lt;/p&gt;
&lt;h2&gt;断点调试&lt;/h2&gt;
&lt;h3&gt;功能按钮&lt;/h3&gt;
&lt;p&gt;我们先来介绍几个功能按钮：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-7.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-7.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;面板介绍 -- Scope&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-8.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-8.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Scope 面板显示了你当前定义的所有属性的值，例子如上图。除了 Scope 面板，你还可以在左侧的代码区域，中断的旁边看到语句中包含的变量的值。除此以外，你还可以把鼠标放在变量上面，也显示对应变量的值。&lt;/p&gt;
&lt;p&gt;Scope 会显示三种类型的值： Local、Closure 和 Global。&lt;/p&gt;
&lt;h3&gt;面板介绍 -- Call Stack&lt;/h3&gt;
&lt;p&gt;当代码中断在一处时，Call Stack 面板会显示代码的执行路径。比如在 a() 中调用了 b()，b() 中调用了 c()，那么中断如果在 c() 内部的话，那么 Call Stack 面板会依次显示 c、b、a。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-9.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-9.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 JS 中，我们常常会写匿名函数，显而易见，在调试时，尤其在查看调用栈时，这样很不友好，所以建议尽量为每个函数命名。&lt;/p&gt;
&lt;p&gt;如果还记得前面所讲的黑盒脚本（Blackbox Script）的话，这里就再重复一句，是的，黑盒脚本永远不可见，所以你即使在查看调用栈时你也没法看到黑盒脚本里的内容。这种情况下会出现下面这样的结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-10.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-10.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;查看与修改你的值&lt;/h3&gt;
&lt;p&gt;前面讲 Scope 面板时介绍了三种查看中断状态下的变量值，还有一个隐蔽的小技巧也能查看，按 esc 按键打开 Console drawer（不清楚是什么可以看&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/Console.md&quot;&gt;Console&lt;/a&gt;），然后在里面输入你想查看的值，回车，bingo~&lt;/p&gt;
&lt;p&gt;如果你以为 Chrome DevTools 就简单看看这些值那就太小瞧她了，在中断状态下，还能动态修改变量的值。比如中断处有个变量叫 v，值是 1，如果我直接按 &quot;Resume script execution&quot; 的话，那么下一次的 v 也是 1，但如果我在按恢复执行按钮之前，我在 Console drawer 中输入 &lt;code&gt;v = 2&lt;/code&gt; 回车，那么，下一处的 v 就是 2 了。&lt;/p&gt;
&lt;p&gt;还有更厉害的，你不仅可以修改变量的值，你还可以修改代码！当程序中断时，你可以在 Sources 面板修改你的代码。&lt;/p&gt;
&lt;p&gt;介绍到这，还有一个面板：Watch，下面就讲讲这个。&lt;/p&gt;
&lt;h3&gt;面板介绍 -- Watch&lt;/h3&gt;
&lt;p&gt;正如名字所表示的，观察，观察什么呢？主要观察变量。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CompileYouth/front-end-study/blob/master/tool/devtools/res/sources-debug-13.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/CompileYouth/front-end-study/raw/master/tool/devtools/res/sources-debug-13.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面我们讲过，当程序中断时，可以查看这个状态下的变量的值，但局限是只能一个一个查看，而 Watch 的好处是可以让我们同时查看多个变量。你可以通过 &quot;+&quot; 来添加变量，当添加的变量存在时会显示对应的值，不存在的话则会显示 &quot;not availble&quot;。需要注意的是，这里的变量不会随着代码的执行而发生改变，所以到了下一个状态时，你需要点击刷新按钮来获得关注的变量的新的值。&lt;/p&gt;
&lt;h3&gt;源码调试&lt;/h3&gt;
&lt;p&gt;现在的项目几乎都是经过编译过的，所以当我们调试时会与编译后的代码打交道，但那并不是我们想要的。不要急，Chrome DevTools 提供了预处理过的代码与源码的映射，主要表现在两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 console 上，源链接指向的是源码，而不是编译后的文件&lt;/li&gt;
&lt;li&gt;在 debug 时，在 Call Stack 面板上的源链接指向的也是源码，不是编译后的文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不过需要注意的是，上面所讲的能查看源码的前提是 Chrome DevTools 在设置中提供了相应权限，具体是：Settings - Sources - Enable Javascript source maps / Enable CSS source maps，勾选这两项即可。不过，默认情况下就是勾选。&lt;/p&gt;
</description>
<pubDate>Tue, 06 Nov 2018 06:58:00 +0000</pubDate>
<dc:creator>lsc183</dc:creator>
<og:description>在 Chrome 中调试 JS 代码，那你不得不与 Chrome DevTools 的 Sources 面板打交道，所以文章主要通过介绍 Sources 面板上的各部分功能来介绍如何调试网页中的 JS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsc183/p/9915285.html</dc:identifier>
</item>
<item>
<title>Mysql8.0使用JDBC连接数据库错误总结 - HNU张斌</title>
<link>http://www.cnblogs.com/hnuzb/p/9915274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hnuzb/p/9915274.html</guid>
<description>&lt;p&gt;&lt;strong&gt;如果使用了mysql8.0以上的版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常信息：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你如果用的包是以前的包的话，会提示使用caching_sha2_password&lt;/p&gt;
&lt;p&gt;或者是&lt;/p&gt;
&lt;p&gt;Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mysql已经推出了新的mysql-connector-java包，引入后，驱动使用com.mysql.cj.jdbc.driver&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;原本的驱动器是&lt;/span&gt;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;我们要将驱动改成&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);&lt;/p&gt;
&lt;p&gt;static final String DB_URL = &quot;jdbc:mysql://localhost:3306//*这里是数据库名*/?useSSL=false&amp;amp;serverTimezone=UTC&quot;;&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;在改完之后要确定你的包是最新版本的&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常信息&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;CST 2018 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在url中添加&amp;amp;useSSL=false或者添加&amp;amp;useSSL=true&lt;/p&gt;
&lt;p&gt;这是由于我们使用了最新的jar包导致的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;异常信息&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Public Key Retrieval is not allowed&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;连接数据库的url中，加上allowPublicKeyRetrieval=true参数，&lt;/p&gt;
&lt;p&gt;连接成功一次后，去掉allowPublicKeyRetrieval=true参数，还是能够正常连接，难道数据库连接过一次之后会自动缓存相同连接的配置信息吗，不是很懂&lt;/p&gt;
</description>
<pubDate>Tue, 06 Nov 2018 06:57:00 +0000</pubDate>
<dc:creator>HNU张斌</dc:creator>
<og:description>如果使用了mysql8.0以上的版本 异常信息： 你如果用的包是以前的包的话，会提示使用caching_sha2_password 或者是 Loading class `com.mysql.jdbc.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hnuzb/p/9915274.html</dc:identifier>
</item>
<item>
<title>Spring知识点总结(二)之Spring IOC - 南岭寒</title>
<link>http://www.cnblogs.com/nanlinghan/p/9914898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nanlinghan/p/9914898.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.创建bean类，并在spring中进行配置交由spring来管理1. IOC(DI) - 控制反转(依赖注入)&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;    所谓的IOC称之为控制反转，简单来说就是将对象的创建的权利及对象的生命周期的管理过程交由Spring框架来处理，从此在开发过程中不再需要关注对象的创建和生命周期的管理，而是在需要时由Spring框架提供，这个由spring框架管理对象创建和生命周期的机制称之为控制反转。而在 创建对象的过程中Spring可以依据配置对对象的属性进行设置，这个过称之为依赖注入,也即DI。&lt;br/&gt;    &lt;br/&gt;&lt;strong&gt;&lt;span&gt;2. IOC的入门案例&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;    a. 下载Spring&lt;br/&gt;        访问Spring官网,下载Spring相关的包&lt;br/&gt;    b. 解压下载好的压缩包&lt;br/&gt;        其中包含着Spring的依赖包&lt;br/&gt;    c. 创建一个java项目&lt;br/&gt;        spring并不是非要在javaweb环境下才可以使用，一个普通的java程序中也可以使用Spring。&lt;br/&gt;　d.导入Spring的libs目录下IOC相关的jar包&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1176659/201811/1176659-20181106134502992-2017437569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    e. 创建Spring的配置文件&lt;br/&gt;　　Spring采用xml文件作为配置文件，xml文件名字任意，但通常都取名为applicationContext.xml，通常将该文件放置在类加载的目录里下　　(src目录)，方便后续使用。&lt;/p&gt;
&lt;p&gt;　 f.创建bean类，并在spring中进行配置交由spring来管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;1&lt;/span&gt;     &amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
            &lt;span&gt;2&lt;/span&gt;     &amp;lt;beans xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
            &lt;span&gt;3&lt;/span&gt;             xmlns:xsi=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
            &lt;span&gt;4&lt;/span&gt;             xsi:schemaLocation=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans &lt;/span&gt;
            &lt;span&gt;5&lt;/span&gt;             http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&amp;gt;&lt;/span&gt;
            &lt;span&gt;6&lt;/span&gt;&lt;span&gt;             
            &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cn.tedu.beans.Person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/bean&amp;gt;
            &lt;span&gt;8&lt;/span&gt;&lt;span&gt;             
            &lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    g. 在程序中通过Spring容器获取对象并使用&lt;br/&gt;       &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    　　　　 1   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person_Test {
            &lt;/span&gt;2&lt;span&gt;             @Test
            &lt;/span&gt;3             &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
            4              * SpringIOC的入门案例
            5              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            6             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  test1(){
            &lt;/span&gt;7                     ApplicationContext context =
            8                                     &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
            &lt;/span&gt;9                     Person p = (Person) context.getBean(&quot;person&quot;&lt;span&gt;);
           &lt;/span&gt;10&lt;span&gt;                     p.say();
           &lt;/span&gt;11&lt;span&gt;             }
           &lt;/span&gt;12     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. IOC的实现原理&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;    在初始化一个Spring容器时，Spring会去解析指定的xml文件，当解析到其中的&amp;lt;bean&amp;gt;标签时，会根据该标签中的class属性指定的类的全路径名，通过反射创建该类的对象，并将该对象存入内置的Map中管理。其中键就是该标签的id值，值就是该对象。&lt;br/&gt;    之后，当通过getBean方法来从容器中获取对象时，其实就是根据传入的条件在内置的Map中寻找是否有匹配的键值，如果有则将该键值对中保存的对象返回，如果没有匹配到则抛出异常。&lt;br/&gt;    &lt;br/&gt;    由此可以推测而知：&lt;br/&gt;        默认情况下，多次获取同一个id的bean，得到的将是同一个对象。&lt;br/&gt;        即使 是同一个类，如果配置过多个&amp;lt;bean&amp;gt;标签具有不同的id，每个id都会在内置Map中有一个键值对，其中的值是这个类创建的不同的对象&lt;br/&gt;        同一个&amp;lt;beans&amp;gt;标签下不允许配置多个同id的&amp;lt;bean&amp;gt;标签，如果配置则启动抛异常&lt;br/&gt;    &lt;br/&gt;&lt;strong&gt;&lt;span&gt;4. IOC获取对象的方式&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;    通过context.getBeans()方法获取bean时，可以通过如下两种方式获取：&lt;br/&gt;        传入id值&lt;br/&gt;        传入class类型&lt;br/&gt;    通过class方式获取bean时，如果同一个类配置过多个bean，则在获取时因为无法确定到底要获取哪个bean会抛出异常。&lt;br/&gt;    而id是唯一的，不存在这样的问题，所以建议大家尽量使用id获取bean。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        1&lt;span&gt;     @Test
        &lt;/span&gt;2     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
        3      * SpringIOC获取bean的方式
        4      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        5     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  test3(){
        &lt;/span&gt;6             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        7              &amp;lt;bean id=&quot;person&quot; class=&quot;cn.tedu.beans.Person&quot;&amp;gt;&amp;lt;/bean&amp;gt;
        8              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        9             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
       10              &amp;lt;bean id=&quot;person&quot; class=&quot;cn.tedu.beans.Person&quot;&amp;gt;&amp;lt;/bean&amp;gt;
       11              &amp;lt;bean id=&quot;personx&quot; class=&quot;cn.tedu.beans.Person&quot;&amp;gt;&amp;lt;/bean&amp;gt;
       12              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       13             ApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
       &lt;/span&gt;14             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--通过id获取&lt;/span&gt;
       15             Person p1 = (Person) context.getBean(&quot;person&quot;&lt;span&gt;);
       &lt;/span&gt;16&lt;span&gt;             p1.say();
       &lt;/span&gt;17             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--通过class获取&lt;/span&gt;
       18             Person p2 = context.getBean(Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
       &lt;/span&gt;19&lt;span&gt;             p2.say();
       &lt;/span&gt;20     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 别名标签&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;    在 Spring中提供了别名标签&amp;lt;alias&amp;gt;可以为配置的&amp;lt;bean&amp;gt;起一个别名，要注意的是这仅仅是对指定的&amp;lt;bean&amp;gt;起的一个额外的名字，并不会额外的创建对象存入map。&lt;br/&gt;        &amp;lt;alias name=&quot;要起别名的bean的id&quot;  alias=&quot;要指定的别名&quot;/&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        1&lt;span&gt;     @Test
        &lt;/span&gt;2     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
        3      * SpringIOC中bean别名
        4      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        5     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  test4(){
        &lt;/span&gt;6             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        7                     &amp;lt;bean id=&quot;person&quot; class=&quot;cn.tedu.beans.Person&quot;&amp;gt;&amp;lt;/bean&amp;gt;
        8                     &amp;lt;alias name=&quot;person&quot; alias=&quot;personx&quot;/&amp;gt;       
        9              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       10             ApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
       &lt;/span&gt;11             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--通过id获取&lt;/span&gt;
       12             Person p1 = (Person) context.getBean(&quot;personx&quot;&lt;span&gt;);
       &lt;/span&gt;13&lt;span&gt;             p1.say();
       &lt;/span&gt;14     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;6. Spring创建对象的方式&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;    a. 通过类的无法构造方法创建对象&lt;br/&gt;        在入门案例中使用的就是这种方式。当用最普通方式配置一个&amp;lt;bean&amp;gt;时,默认就是采用类的无参构造创建对象。在Spring容器初始化时，通过&amp;lt;bean&amp;gt;上配置的class属性反射得到字节码对象，通过newInstance()创建对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
                1     Class c = Class .forName(&quot;类的全路径名称&quot;&lt;span&gt;)
                &lt;/span&gt;2     Object obj =&lt;span&gt; c.newInstance()
        这种方式下spring创建对象，要求类必须有无参的构造，否则无法通过反射创建对象，会抛出异常。
                &lt;/span&gt;1     &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
                &lt;/span&gt;2     
                3     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
                &lt;/span&gt;4             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String arg) {
                &lt;/span&gt;5                     System.out.println(&quot;Person的无参构造执行了。。。&quot;&lt;span&gt;);
                &lt;/span&gt;6&lt;span&gt;             }
                &lt;/span&gt;7             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say(){
                &lt;/span&gt;8                     System.out.println(&quot;person hello spring~&quot;&lt;span&gt;);
                &lt;/span&gt;9&lt;span&gt;             }
               &lt;/span&gt;10&lt;span&gt;     }
               &lt;/span&gt;11&lt;span&gt;     @Test
               &lt;/span&gt;12     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
               13      * SpringIOC 创建对象方式 1 - 通过无参构造方法创建对象
               14      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
               15     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test5(){
               &lt;/span&gt;16             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
               17                      &amp;lt;bean id=&quot;person&quot; class=&quot;cn.tedu.beans.Person&quot;&amp;gt;&amp;lt;/bean&amp;gt;
               18              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
               19             ApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
               &lt;/span&gt;20             Person p  = (Person) context.getBean(&quot;person&quot;&lt;span&gt;);
               &lt;/span&gt;21&lt;span&gt;             p.say();
               &lt;/span&gt;22     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;    &lt;br/&gt;    b. 通过静态工厂创建对象&lt;br/&gt;        很多的时候，我们面对的类是无法通过无参构造去创建的，例如该类没有无参构造、是一抽象类 等等情况 ，此时无法要求spring通过无参构造创建对象，此时可以使用静态工厂 方式创建对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            1     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CalendarStaticFactory {
            &lt;/span&gt;2             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Calendar getCalendar(){
            &lt;/span&gt;3                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Calendar.getInstance();
            &lt;/span&gt;4&lt;span&gt;             }
            &lt;/span&gt;5&lt;span&gt;     }
            &lt;/span&gt;1     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
            2     &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
            3             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            4             xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            5             http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&amp;gt;&lt;/span&gt;
            6            
            7             &amp;lt;bean id=&quot;calendar&quot;  &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.factory.CalendarStaticFactory&quot; factory-method=&quot;getCalendar&quot;&amp;gt;&amp;lt;/bean&amp;gt;
            8     
            9     &amp;lt;/beans&amp;gt;
            1&lt;span&gt;     @Test
            &lt;/span&gt;2     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
            3      * SpringIOC 创建对象方式 2 - 静态工厂
            4      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            5     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test6(){
            &lt;/span&gt;6             ApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
            &lt;/span&gt;7             Calendar calendar = (Calendar) context.getBean(&quot;calendar&quot;&lt;span&gt;);
            &lt;/span&gt;8&lt;span&gt;             System.out.println(calendar);
            &lt;/span&gt;9     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;    &lt;br/&gt;    c. 实例工厂创建对象&lt;br/&gt;        实例工厂也可以解决类是无法通过无参构造创建的问题，解决的思路和静态 工厂类似，只不过实例工厂提供的方法不是静态的。spring需要先创建出实例工厂的对象，在调用实例工厂对象上指定的普通方法来创建对象。所以实例工厂也需要配置到Spring中管理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            1     &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.factory;
            &lt;/span&gt;2     
            3     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Calendar;
            &lt;/span&gt;4     
            5     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CalendarFactory {
            &lt;/span&gt;6             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Calendar getCalendar(){
            &lt;/span&gt;7                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Calendar.getInstance();
            &lt;/span&gt;8&lt;span&gt;             }
            &lt;/span&gt;9&lt;span&gt;     }
            &lt;/span&gt;1     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
            2     &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
            3             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            4             xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            5             http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&amp;gt;&lt;/span&gt;
            6            
            7             &amp;lt;bean id=&quot;calendarFactory&quot;  &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.factory.CalendarFactory&quot;&amp;gt;&amp;lt;/bean&amp;gt;
            8             &amp;lt;bean id=&quot;calendar&quot; factory-bean=&quot;calendarFactory&quot; factory-method=&quot;getCalendar&quot;/&amp;gt;
            9     
           10     &amp;lt;/beans&amp;gt;
            1&lt;span&gt;     @Test
            &lt;/span&gt;2     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
            3      * SpringIOC 创建对象方式 3 - 实例工厂
            4      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            5     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test7(){
            &lt;/span&gt;6             ApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
            &lt;/span&gt;7             Calendar calendar = (Calendar) context.getBean(&quot;calendar&quot;&lt;span&gt;);
            &lt;/span&gt;8&lt;span&gt;             System.out.println(calendar);
            &lt;/span&gt;9     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;    d. Spring工厂创建对象&lt;br/&gt;        Spring内置了工厂接口，也可以通过实现这个接口来开发Spring工厂，通过这个工厂创建对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            1     &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.factory;
            &lt;/span&gt;2     
            3     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Calendar;
            &lt;/span&gt;4     
            5     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.FactoryBean;
            &lt;/span&gt;6     
            7     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CalendarSpringFactory &lt;span&gt;implements&lt;/span&gt; FactoryBean&amp;lt;Calendar&amp;gt;&lt;span&gt;{
            &lt;/span&gt;8     
            9             &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
           10              * Spring工厂生产对象的方法
           11              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
           12&lt;span&gt;             @Override
           &lt;/span&gt;13             &lt;span&gt;public&lt;/span&gt; Calendar getObject() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
           &lt;/span&gt;14                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Calendar.getInstance();
           &lt;/span&gt;15&lt;span&gt;             }
           &lt;/span&gt;16     
           17             &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
           18              * 获取当前工厂生产的对象的类型的方法
           19              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
           20&lt;span&gt;             @Override
           &lt;/span&gt;21             &lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; getObjectType() {
           &lt;/span&gt;22                     &lt;span&gt;return&lt;/span&gt; Calendar.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;23&lt;span&gt;             }
           &lt;/span&gt;24     
           25             &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
           26              * Spring工厂生产对象时是否采用单例模式
           27              * 如果返回true，则在spring中该对象只创建一次 后续 重复使用
           28              * 如果返回false，则每次获取该bean 都重新 创建对象
           29              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
           30&lt;span&gt;             @Override
           &lt;/span&gt;31             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isSingleton() {
           &lt;/span&gt;32                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
           &lt;/span&gt;33&lt;span&gt;             }
           &lt;/span&gt;34     
           35&lt;span&gt;     }
            &lt;/span&gt;1     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
            2     &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
            3             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            4             xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            5             http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&amp;gt;&lt;/span&gt;
            6            
            7             &amp;lt;bean id=&quot;calendar&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.factory.CalendarSpringFactory&quot;&amp;gt;&amp;lt;/bean&amp;gt;
            8            
            9     &amp;lt;/beans&amp;gt;
            1&lt;span&gt;     @Test
            &lt;/span&gt;2     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
            3      * SpringIOC 创建对象方式 3 - spring工厂
            4      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            5     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test8(){
            &lt;/span&gt;6             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
            7                     &amp;lt;bean id=&quot;calendar&quot; class=&quot;cn.tedu.factory.CalendarSpringFactory&quot;&amp;gt;&amp;lt;/bean&amp;gt;
            8             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            9             ApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
           &lt;/span&gt;10             Calendar calendar = (Calendar) context.getBean(&quot;calendar&quot;&lt;span&gt;);
           &lt;/span&gt;11&lt;span&gt;             System.out.println(calendar);
           &lt;/span&gt;12     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7. 单例和多例&lt;br/&gt;    Spring容器管理的bean在默认情况下是单例的，也即，一个bean只会创建一个对象，存在内置 map中，之后无论获取多少次该bean，都返回同一个对象。&lt;br/&gt;    &lt;br/&gt;    Spring默认采用单例方式，减少了对象的创建，从而减少了内存的消耗。&lt;br/&gt;    但是在实际开发中是存在多例的需求的，Spring也提供了选项可以将bean设置为多例模式。&lt;br/&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
         1     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
            2     &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
            3             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            4             xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            5             http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&amp;gt;&lt;/span&gt;
            6            
            7             &amp;lt;!--
            8&lt;span&gt;                     scope属性控制当前bean的创建模式：
            &lt;/span&gt;9&lt;span&gt;                             singleton:则当前bean处在单例模式中,默认就是此模式
           &lt;/span&gt;10&lt;span&gt;                             prototype:则当前bean处在多例模式中
           &lt;/span&gt;11              --&amp;gt;
           12             &amp;lt;bean id=&quot;cart&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.beans.Cart&quot; scope=&quot;prototype&quot;&amp;gt;&amp;lt;/bean&amp;gt;
           13            
           14     &amp;lt;/beans&amp;gt;
    
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;    bean在单例模式下的生命周期：&lt;br/&gt;        bean在单例模式下，spring容器启动时解析xml发现该bean标签后，直接创建该bean的对象存入内部map中保存，此后无论调用多少次getBean()获取该bean都是从map中获取该对象返回，一直是一个对象。此对象一直被Spring容器持有，直到容器退出时，随着容器的退出对象被销毁。&lt;br/&gt;    &lt;br/&gt;    bean在多例模式下的生命周期：&lt;br/&gt;        bean在多例模式下，spring容器启动时解析xml发现该bean标签后，只是将该bean进行管理，并不会创建对象，此后每次使用 getBean()获取该bean时，spring都会重新创建该对象返回，每次都是一个新的对象。这个对象spring容器并不会持有，什么销毁取决于使用该对象的用户自己什么时候销毁该对象。&lt;br/&gt;    &lt;br/&gt;        实验：通过断点调试模式 ，观察spring单例和多例的bean执行构造的过程&lt;br/&gt;                1     略&lt;/p&gt;&lt;p&gt;8. 懒加载机制&lt;br/&gt;    Spring默认会在容器初始化的过程中，解析xml，并将单例的bean创建并保存到map中，这样的机制在bean比较少时问题不大，但一旦bean非常多时，spring需要在启动的过程中花费大量的时间来创建bean 花费大量的空间存储bean，但这些bean可能很久都用不上，这种在启动时在时间和空间上的浪费显得非常的不值得。&lt;br/&gt;    所以Spring提供了懒加载机制。所谓的懒加载机制就是可以规定指定的bean不在启动时立即创建，而是在后续第一次用到时才创建，从而减轻在启动过程中对时间和内存的消耗。&lt;br/&gt;    懒加载机制只对单例bean有作用，对于多例bean设置懒加载没有意义。&lt;br/&gt;    &lt;br/&gt;    懒加载的配置方式：&lt;br/&gt;        为指定bean配置懒加载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
                1     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
                2     &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
                3             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                4             xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                5             http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&lt;/span&gt;
                6             &amp;gt;
                7            
                8             &amp;lt;bean id=&quot;cart&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.beans.Cart&quot; lazy-init=&quot;true&quot;&amp;gt;&amp;lt;/bean&amp;gt;
                9            
               10     &amp;lt;/beans&amp;gt;&lt;span&gt;
        为全局配置懒加载
                &lt;/span&gt;1     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
                2     &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
                3             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                4             xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                5             http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&lt;/span&gt;
                6             &lt;span&gt;default&lt;/span&gt;-lazy-init=&quot;true&quot;
                7             &amp;gt;
                8            
                9             &amp;lt;bean id=&quot;cart&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.beans.Cart&quot;&amp;gt;&amp;lt;/bean&amp;gt;
               10            
               11     &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;        **如果同时设定全局和指定bean的懒加载机制，且配置不相同，则对于该bean局部配置覆盖全局配置。&lt;br/&gt;    &lt;br/&gt;        实验：通过断点调试，验证懒加载机制的执行过程&lt;br/&gt;           &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    1     &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
                &lt;/span&gt;2     
                3     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cart {
                &lt;/span&gt;4             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cart() {
                &lt;/span&gt;5                     System.out.println(&quot;Cart init...&quot;&lt;span&gt;);
                &lt;/span&gt;6&lt;span&gt;             }
                &lt;/span&gt;7&lt;span&gt;     }
                &lt;/span&gt;1     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
                2     &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
                3             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                4             xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                5             http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&lt;/span&gt;
                6             &amp;gt;
                7            
                8             &amp;lt;bean id=&quot;cart&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.beans.Cart&quot; lazy-init=&quot;true&quot;&amp;gt;&amp;lt;/bean&amp;gt;
                9            
               10     &amp;lt;/beans&amp;gt;
                1&lt;span&gt;     @Test
                &lt;/span&gt;2     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                3      * SpringIOC 懒加载机制
                4      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                5     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test10(){
                &lt;/span&gt;6             ApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
                &lt;/span&gt;7             Cart cart1 = (Cart) context.getBean(&quot;cart&quot;&lt;span&gt;);
                &lt;/span&gt;8             Cart cart2 = (Cart) context.getBean(&quot;cart&quot;&lt;span&gt;);
                &lt;/span&gt;9             System.out.println(cart1 ==&lt;span&gt; cart2);
               &lt;/span&gt;10     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;    &lt;br/&gt;9. 配置初始化和销毁的方法&lt;br/&gt;    在Spring中如果某个bean在初始化之后 或 销毁之前要做一些 额外操作可以为该bean配置初始化和销毁的方法 ，在这些方法中完成要功能。&lt;br/&gt;    &lt;br/&gt;        实验：通过断点调试模式，测试初始化方法 和 销毁方法的执行&lt;br/&gt;      &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
     1     &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
            &lt;/span&gt;2     
            3     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProdDao {
            &lt;/span&gt;4            
            5             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ProdDao() {
            &lt;/span&gt;6                     System.out.println(&quot;ProdDao 被创建。。。&quot;&lt;span&gt;);
            &lt;/span&gt;7&lt;span&gt;             }
            &lt;/span&gt;8            
            9             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
           &lt;/span&gt;10                     System.out.println(&quot;init。。连接数据库。。。。。&quot;&lt;span&gt;);
           &lt;/span&gt;11&lt;span&gt;             }
           &lt;/span&gt;12            
           13            
           14             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destory(){
           &lt;/span&gt;15                     System.out.println(&quot;destory。。断开数据库。。。。。&quot;&lt;span&gt;);
           &lt;/span&gt;16&lt;span&gt;             }
           &lt;/span&gt;17            
           18             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  addProd(){
           &lt;/span&gt;19                     System.out.println(&quot;增加商品。。&quot;&lt;span&gt;);
           &lt;/span&gt;20&lt;span&gt;             }
           &lt;/span&gt;21             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  updateProd(){
           &lt;/span&gt;22                     System.out.println(&quot;修改商品。。&quot;&lt;span&gt;);
           &lt;/span&gt;23&lt;span&gt;             }
           &lt;/span&gt;24             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  delProd(){
           &lt;/span&gt;25                     System.out.println(&quot;删除商品。。&quot;&lt;span&gt;);
           &lt;/span&gt;26&lt;span&gt;             }
           &lt;/span&gt;27             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  queryProd(){
           &lt;/span&gt;28                     System.out.println(&quot;查询商品。。&quot;&lt;span&gt;);
           &lt;/span&gt;29&lt;span&gt;             }
           &lt;/span&gt;30     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
         1     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
            2     &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
            3             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            4             xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            5             http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&lt;/span&gt;
            6             &amp;gt;
            7            
            8             &amp;lt;bean id=&quot;prodDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.beans.ProdDao&quot;
            9                     init-method=&quot;init&quot; destroy-method=&quot;d y&quot;&amp;gt;&amp;lt;/bean&amp;gt;
           10            
           11     &amp;lt;/beans&amp;gt;
            1&lt;span&gt;     @Test
            &lt;/span&gt;2     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
            3      * SpringIOC 初始化和 销毁方法
            4      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            5     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test11(){
            &lt;/span&gt;6             ClassPathXmlApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
            &lt;/span&gt;7             ProdDao prodDao = (ProdDao) context.getBean(&quot;prodDao&quot;&lt;span&gt;);
            &lt;/span&gt;8&lt;span&gt;             prodDao.addProd();
            &lt;/span&gt;9&lt;span&gt;             context.close();
           &lt;/span&gt;10&lt;span&gt;     }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;    **Spring中关键方法的执行顺序：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;        在Spring创建bean对象时，先创建对象(通过无参构造或工厂)，之后立即调用init方法来执行初始化操作，之后此bean就可以哪来调用其它普通方法,而在对象销毁之前，spring容器调用其destory方法来执行销毁操作。&lt;/p&gt;

</description>
<pubDate>Tue, 06 Nov 2018 05:56:00 +0000</pubDate>
<dc:creator>南岭寒</dc:creator>
<og:description>1.创建bean类，并在spring中进行配置交由spring来管理1. IOC(DI) - 控制反转(依赖注入) 所谓的IOC称之为控制反转，简单来说就是将对象的创建的权利及对象的生命周期的管理过程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nanlinghan/p/9914898.html</dc:identifier>
</item>
<item>
<title>大数据系列博客之 --- 深入简出 Shell 脚本语言（基础篇） - 房上的猫</title>
<link>http://www.cnblogs.com/lsy131479/p/9914747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsy131479/p/9914747.html</guid>
<description>&lt;p&gt;首先声明，此系列shell系列博客分为四篇发布，分别是：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/lsy131479/p/9914747.html&quot; target=&quot;_blank&quot;&gt;基础篇：https://www.cnblogs.com/lsy131479/p/9914747.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/lsy131479/p/9914897.html&quot; target=&quot;_blank&quot;&gt;提升篇：https://www.cnblogs.com/lsy131479/p/9914897.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/lsy131479/p/9914962.html&quot; target=&quot;_blank&quot;&gt;高级篇：https://www.cnblogs.com/lsy131479/p/9914962.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　面试篇：&lt;/p&gt;


&lt;p&gt;&lt;span&gt;为什么要&lt;/span&gt;&lt;span&gt;学习&lt;/span&gt;Shell&lt;span&gt;呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;需要看懂运维人员&lt;/span&gt;&lt;span&gt;编写的&lt;/span&gt;Shell&lt;span&gt;程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;偶尔会编写一些简单&lt;/span&gt;Shell&lt;span&gt;程序&lt;/span&gt;&lt;span&gt;来管理集群、&lt;/span&gt;&lt;span&gt;提高开发效率&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1211814/201811/1211814-20181106132259022-1380936352.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;Linux&lt;span&gt;提供的&lt;/span&gt;&lt;span&gt;Shell&lt;/span&gt;&lt;span&gt;解析器有：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 ~]$ cat /etc/&lt;span&gt;shells 
&lt;/span&gt;/bin/&lt;span&gt;sh
&lt;/span&gt;/bin/&lt;span&gt;bash
&lt;/span&gt;/sbin/&lt;span&gt;nologin
&lt;/span&gt;/bin/&lt;span&gt;dash
&lt;/span&gt;/bin/&lt;span&gt;tcsh
&lt;/span&gt;/bin/csh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 常用的解析一般是 ： /bin/&lt;span data-mce-=&quot;&quot;&gt;bash&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;bash&lt;span&gt;和&lt;/span&gt;sh&lt;span&gt;的关系&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[fsdm@hadoop101 bin]$ ll | grep bash
&lt;/span&gt;-rwxr-xr-x. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;941880&lt;/span&gt; 5月  &lt;span&gt;11&lt;/span&gt; &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; bash
lrwxrwxrwx. &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; root root      &lt;span&gt;4&lt;/span&gt; 5月  &lt;span&gt;27&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt; sh -&amp;gt; bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 可以看到sh是引用的bash&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）&lt;/span&gt;Centos&lt;span&gt;默认的&lt;/span&gt;&lt;span&gt;解析&lt;/span&gt;&lt;span&gt;器&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;bash&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[fsdm@hadoop102 bin]$ echo $SHELL
&lt;/span&gt;/bin/bash
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1&lt;span&gt;．&lt;/span&gt;&lt;span&gt;脚本格式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;脚本以&lt;/span&gt;#!/bin/bash&lt;span&gt;开头&lt;/span&gt;&lt;span&gt;（&lt;span&gt;指定解析&lt;/span&gt;&lt;/span&gt;&lt;span&gt;器&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2&lt;span&gt;．&lt;/span&gt;&lt;span&gt;第一个&lt;/span&gt;Shell&lt;span&gt;脚本&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;helloworld&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）需求：创建一个&lt;/span&gt;&lt;span&gt;Shell&lt;/span&gt;&lt;span&gt;脚本，输出&lt;/span&gt;&lt;span&gt;helloworld&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;案例&lt;/span&gt;&lt;span&gt;实操：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[fsdm@hadoop101 datas]$ touch helloworld.sh
[fsdm@hadoop101 datas]$ vi helloworld.sh

在helloworld.sh中输入如下内容
&lt;/span&gt;#!/bin/&lt;span&gt;bash
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;helloworld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）&lt;/span&gt;&lt;span&gt;脚本的常用执行方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第&lt;/span&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;种：&lt;/span&gt;&lt;span&gt;采用&lt;/span&gt;bash&lt;span&gt;或&lt;/span&gt;&lt;span&gt;sh+&lt;/span&gt;&lt;span&gt;脚本&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;相对路径或绝对路径（不用赋予脚本&lt;/span&gt;+x&lt;span&gt;权限）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;001.sh+&lt;span&gt;脚本的相&lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt;路径&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[fsdm@hadoop101 datas]$ sh helloworld.sh 
Helloworld&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;002.sh+&lt;span&gt;脚本的&lt;/span&gt;&lt;span&gt;绝对&lt;/span&gt;&lt;span&gt;路径&lt;/span&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ sh /home/fsdm/datas/&lt;span&gt;helloworld.sh 
helloworld&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;003.bash+&lt;span&gt;脚本&lt;/span&gt;&lt;span&gt;的相对路径&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[fsdm@hadoop101 datas]$ bash helloworld.sh 
Helloworld&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;004.bash+&lt;span&gt;脚本&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;绝对&lt;/span&gt;&lt;span&gt;路径&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ bash /home/fsdm/datas/helloworld.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; 
Helloworld&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第&lt;/span&gt;&lt;span&gt;二&lt;/span&gt;&lt;span&gt;种：&lt;/span&gt;&lt;span&gt;采用&lt;/span&gt;&lt;span&gt;输入脚本的绝对路径或相对路径&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;&lt;span&gt;脚本&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;必须&lt;/span&gt;&lt;span&gt;具有可执行权限&lt;/span&gt;+x&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;a&lt;span&gt;）首先要赋予&lt;/span&gt;&lt;span&gt;helloworld.sh&lt;/span&gt; &lt;span&gt;脚本的&lt;/span&gt;&lt;span&gt;+x&lt;/span&gt;&lt;span&gt;权限&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ &lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;777&lt;/span&gt; helloworld.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;b&lt;span&gt;）执行脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相对&lt;/span&gt;&lt;span&gt;路径&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ ./helloworld.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; 
Helloworld&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;绝对&lt;/span&gt;&lt;span&gt;路径&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ /home/fsdm/datas/helloworld.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; 
Helloworld&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;注意：第一种&lt;/span&gt;&lt;span&gt;执行方法，&lt;/span&gt;&lt;span&gt;本质&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;bash&lt;span&gt;解析器&lt;/span&gt;&lt;span&gt;帮你执行脚本，&lt;/span&gt;&lt;span&gt;所以&lt;/span&gt;&lt;span&gt;脚本本身不需要&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;&lt;span&gt;权限。&lt;/span&gt;&lt;span&gt;第&lt;/span&gt;&lt;span&gt;二种&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;&lt;span&gt;方法，本质是脚本需要&lt;/span&gt;&lt;span&gt;自己&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;所&lt;/span&gt;&lt;span&gt;以&lt;/span&gt;&lt;span&gt;需要执行权限。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;3&lt;span&gt;．&lt;/span&gt;&lt;span&gt;第&lt;/span&gt;&lt;span&gt;二&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;Shell&lt;span&gt;脚本&lt;/span&gt;&lt;span&gt;：多命令处理&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）需求&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在&lt;/span&gt;/home/fsdm/&lt;span&gt;目录&lt;/span&gt;&lt;span&gt;下创建一个&lt;/span&gt;banzhang.txt,&lt;span&gt;在&lt;/span&gt;banzhang.txt&lt;span&gt;文件&lt;/span&gt;&lt;span&gt;中增加&lt;/span&gt;“I love cls”&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）案例实操：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ &lt;span&gt;touch&lt;/span&gt; batch.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
[fsdm@hadoop101 datas]$ &lt;/span&gt;&lt;span&gt;vi&lt;/span&gt; batch.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;

在batch.sh中输入如下内容
#&lt;/span&gt;!/bin/&lt;span&gt;bash

cd &lt;/span&gt;/home/&lt;span&gt;fsdm
&lt;/span&gt;&lt;span&gt;touch&lt;/span&gt;&lt;span&gt; cls.txt
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I love cls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt;cls.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;strong&gt;4.1&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;系统&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;变量&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1. &lt;span&gt;常用&lt;/span&gt;&lt;span&gt;系统变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$HOME&lt;span&gt;、&lt;/span&gt;&lt;span&gt;$PWD&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;$SHELL&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;$USER&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;．&lt;/span&gt;&lt;span&gt;案例实操&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）查看&lt;/span&gt;&lt;span&gt;系统变量的值&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ &lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $HOME
&lt;/span&gt;/home/fsdm
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;显示当前&lt;/span&gt;Shell&lt;span&gt;中所有变量：&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[fsdm@hadoop101 datas]$ set
BASH&lt;/span&gt;=/bin/&lt;span&gt;bash
BASH_ALIASES&lt;/span&gt;=&lt;span&gt;()
BASH_ARGC&lt;/span&gt;=&lt;span&gt;()
BASH_ARGV&lt;/span&gt;=()
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;4.2&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;自定义&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;变量&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1&lt;span&gt;．&lt;/span&gt;&lt;span&gt;基本语法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）定义变量：变量&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;值&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）撤销变量：&lt;/span&gt;&lt;span&gt;unset&lt;/span&gt; &lt;span&gt;变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）声明静态变量：&lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;&lt;span&gt;变量，注意：不能&lt;/span&gt;&lt;span&gt;unset&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;．&lt;/span&gt;&lt;span&gt;变量定义规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）变量名称可以由字母、数字和下划线组成，但是不能以数字开头&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;span&gt;环境&lt;/span&gt;&lt;span&gt;变量名&lt;/span&gt;&lt;span&gt;建议&lt;/span&gt;&lt;span&gt;大写&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;span&gt;等号两侧不能有空格&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;bash&lt;span&gt;中，变量默认类型都是字符串类型，无法直接进行数值运算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）变量的值如果有空格，需要使用双引号或单引号括起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;．&lt;/span&gt;&lt;span&gt;案例实操&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）定义变量&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ A=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
[fsdm@hadoop101 datas]$ &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $A
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;给&lt;/span&gt;&lt;span&gt;变量&lt;/span&gt;A&lt;span&gt;重新&lt;/span&gt;&lt;span&gt;赋值&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ A=&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
[fsdm@hadoop101 datas]$ &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $A
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）撤销变量&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[fsdm@hadoop101 datas]$ unset A
[fsdm@hadoop101 datas]$ &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $A
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）声明&lt;span&gt;静态&lt;/span&gt;的&lt;span&gt;变量&lt;/span&gt;&lt;/span&gt;&lt;span&gt;B=2&lt;/span&gt;&lt;span&gt;，不能&lt;/span&gt;&lt;span&gt;unset或改变变量值&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ readonly B=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
[fsdm@hadoop101 datas]$ &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $B
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
[fsdm@hadoop101 datas]$ B&lt;/span&gt;=&lt;span&gt;9&lt;/span&gt;
-bash: B: readonly variable
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　readonly 只读（静态变量）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;bash&lt;span&gt;中，变量默认类型都是字符串类型，无法直接进行数值运算&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop102 ~]$ C=&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
[fsdm@hadoop102 &lt;/span&gt;~]$ &lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $C
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;6&lt;span&gt;）&lt;/span&gt;&lt;span&gt;变量的值如果有空格，需要使用双引号或单引号括起来&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop102 ~]$ D=&lt;span&gt;I love banzhang
&lt;/span&gt;-&lt;span&gt;bash: world: command not found
[fsdm@hadoop102 &lt;/span&gt;~]$ D=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I love banzhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
[fsdm@hadoop102 &lt;/span&gt;~]$ &lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $A
I love banzhang&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;7&lt;span&gt;）可把变量提升为全局环境变量，可供其他&lt;/span&gt;&lt;span&gt;Shell&lt;/span&gt;&lt;span&gt;程序使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;export &lt;span data-mce-=&quot;&quot;&gt;变量名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ vim helloworld.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; 

在helloworld.sh文件中增加echo $B
#&lt;/span&gt;!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;helloworld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $B

[fsdm@hadoop101 datas]$ .&lt;/span&gt;/helloworld.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; 
Helloworld&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;发现并&lt;/span&gt;&lt;span&gt;没有打印输出变量&lt;/span&gt;B&lt;span&gt;的值&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span data-mce-=&quot;&quot;&gt;我们 export 一下B，然后执行脚本：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[fsdm@hadoop101 datas]$ export B
[fsdm@hadoop101 datas]$ .&lt;/span&gt;/helloworld.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; 
helloworld
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;4.3&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;特殊&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;变量&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;$n&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1&lt;span&gt;．&lt;/span&gt;&lt;span&gt;基本语法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$n &lt;span&gt;（功能描述：&lt;/span&gt;n&lt;span&gt;为数字，&lt;/span&gt;&lt;span&gt;$0&lt;/span&gt;&lt;span&gt;代表&lt;/span&gt;&lt;span&gt;该脚本名称&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;$1-$9&lt;span&gt;代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如&lt;/span&gt;&lt;span&gt;${10}&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;．&lt;/span&gt;&lt;span&gt;案例实操&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）输出&lt;/span&gt;&lt;span&gt;该脚本文件名称&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;输入&lt;/span&gt;&lt;span&gt;参数&lt;/span&gt;1&lt;span&gt;和输入&lt;/span&gt;&lt;span&gt;参数&lt;/span&gt;2 &lt;span&gt;的&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ &lt;span&gt;touch&lt;/span&gt; parameter.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; 
[fsdm@hadoop101 datas]$ vim parameter.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;

#&lt;/span&gt;!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$0  $1   $2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

[fsdm@hadoop101 datas]$ &lt;/span&gt;&lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;777&lt;/span&gt; parameter.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;

[fsdm@hadoop101 datas]$ .&lt;/span&gt;/parameter.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; cls  xz
.&lt;/span&gt;/parameter.&lt;span&gt;sh&lt;/span&gt;  cls   xz
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;4.4&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;特殊&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;变量&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;$#&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1&lt;span&gt;．&lt;/span&gt;&lt;span&gt;基本语法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$# &lt;span&gt;（功能描述：&lt;/span&gt;&lt;span&gt;获取所有&lt;/span&gt;&lt;span&gt;输入参数个数&lt;/span&gt;&lt;span&gt;，常用于循环&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;．&lt;/span&gt;&lt;span&gt;案例实操&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;获取输入&lt;/span&gt;&lt;span&gt;参数的个数&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ vim parameter.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;

#&lt;/span&gt;!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$0  $1   $2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $#

[fsdm@hadoop101 datas]$ &lt;/span&gt;&lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;777&lt;/span&gt; parameter.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;

[fsdm@hadoop101 datas]$ .&lt;/span&gt;/parameter.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; cls  xz
parameter.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; cls xz 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;4.5&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;特殊&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;变量&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;$*&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;、&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;$@&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1&lt;span&gt;．&lt;/span&gt;&lt;span&gt;基本语法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$* &lt;span&gt;（功能描述：这个变量代表命令行中所有的参数，&lt;/span&gt;$*&lt;span&gt;把所有的参数看成一个整体）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$@ &lt;span&gt;（功能描述：这个变量也代表命令行中所有的参数，不过&lt;/span&gt;$@&lt;span&gt;把每个参数区分对待）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;．&lt;/span&gt;&lt;span&gt;案例实操&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）打印输入&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;所有&lt;/span&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ vim parameter.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;

#&lt;/span&gt;!/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$0  $1   $2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $#
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $*
&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $@

[fsdm@hadoop101 datas]$ bash parameter.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
parameter.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt;   &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;4.6&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;特殊&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;变量&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;$&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1&lt;span&gt;．&lt;/span&gt;&lt;span&gt;基本语法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$&lt;span&gt;？&lt;/span&gt; &lt;span&gt;（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为&lt;/span&gt;0&lt;span&gt;，证明上一个命令正确执行；如果这个变量的值为非&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;．&lt;/span&gt;&lt;span&gt;案例实操&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;判断&lt;/span&gt;helloworld.sh&lt;span&gt;脚本&lt;/span&gt;&lt;span&gt;是否正确执行&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ ./helloworld.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; 
hello world
[fsdm@hadoop101 datas]$ &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $?
&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1&lt;span&gt;．&lt;/span&gt;&lt;span&gt;基本语法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;“$((&lt;/span&gt;&lt;span&gt;运算式&lt;/span&gt;&lt;span&gt;))”&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;“$[&lt;/span&gt;&lt;span&gt;运算式&lt;/span&gt;&lt;span&gt;]”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;expr  + , - , \*,  /,  %    &lt;/span&gt;&lt;span&gt;加&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;减&lt;/span&gt;&lt;span&gt;，乘，除，取余&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注意&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;expr&lt;span&gt;运算符间要有空格&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;．&lt;/span&gt;&lt;span&gt;案例实操：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;计算&lt;/span&gt;3+2&lt;span&gt;的值&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ &lt;span&gt;expr&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;span&gt;计算&lt;/span&gt;3-2&lt;span&gt;的值&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ &lt;span&gt;expr&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; - &lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）&lt;/span&gt;&lt;span&gt;计算（&lt;/span&gt;2+3&lt;span&gt;）&lt;/span&gt;&lt;span&gt;*4&lt;/span&gt;&lt;span&gt;的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;a&lt;span&gt;）&lt;/span&gt;&lt;span&gt;expr&lt;/span&gt;&lt;span&gt;一步完成计算&lt;/span&gt;&lt;/p&gt;




&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]$ &lt;span&gt;expr&lt;/span&gt; `&lt;span&gt;expr&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;3&lt;/span&gt;` \* &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;b&lt;span&gt;）采用&lt;/span&gt;&lt;span&gt;$[&lt;/span&gt;&lt;span&gt;运算式&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;方式&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[fsdm@hadoop101 datas]# S=$[(&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;)*&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]
[fsdm@hadoop101 datas]# &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $S
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;基础篇结束，如需深入请阅读后续篇章，如有疑问私信或评论指出&lt;/p&gt;

</description>
<pubDate>Tue, 06 Nov 2018 05:50:00 +0000</pubDate>
<dc:creator>房上的猫</dc:creator>
<og:description>首先声明，此系列shell系列博客分为四篇发布，分别是： 基础篇：https://www.cnblogs.com/lsy131479/p/9914747.html 提升篇：https://www.cn</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsy131479/p/9914747.html</dc:identifier>
</item>
</channel>
</rss>