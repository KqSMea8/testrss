<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Cocos2d-x Lua游戏开发Mac环境搭建以及一点点感悟 - Zxiao..旭</title>
<link>http://www.cnblogs.com/taoxu/p/7639940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taoxu/p/7639940.html</guid>
<description>
&lt;p&gt;接触Cocos2d-x&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;       最近由于公司项目的需要，自己开始接触Cocos，开始做一些简单的轻量级的游戏，以前没有接触过这一块的东西，也是借助这个机会学习一下游戏的开发，由于以前自己接触的全都是iOS和Android移动端App的开发，所以这整个Cocos的学习总结的文章会在真个过程中贯穿对比自己相对熟悉的iOS和Android对比学习，要是也有和我自己情况类似的朋友，接下来总结的这整个Cocos系列的文章也许可以帮助到你，有不足的地方也希望指正，我们一同进步。&lt;/p&gt;
&lt;p&gt;       刚开始的时候，由于以前的游戏是用C++开发，自己就去慢慢的开始学习用Cocos2d-x C++简单的了解项目。自己看了最基本的一些Cocos的东西之后，说以后的游戏用JS做，然后又开始学习JS，最后决定用Lua开发，可能这就是人生.....其实上面说的意思就是想总结一些开发游戏的时候我们可以有的选择，开发语言就有 C++，JavaScript , Lua 三个选择，它们和你真正利用它们做游戏就像你懂OC、Swift。懂Java之后去做iOS或者Android之间的距离，这个可以仔细的想一想，懂这些语言和开发实际项目之间距离是什么，然后也就明白懂这些语言和实际的游戏项目开发之间欠缺的就是Cocos2d-x的东西，要认清了这些也就了解了“游戏怎么做”这个基本的问题吧！ &lt;/p&gt;

&lt;p&gt;说说Cocos  &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      Cocos是一个大概念，等我们具体的开发中使用到的是Cocos2d-x模块的东西，看看这个Cocos 产品的一个架构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/739006/201710/739006-20171009141309762-880478599.png&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1: Cocos Creator 这是一个为我们开发游戏做的IDE，具体的可以看这个 &lt;a href=&quot;http://www.cocos.com/docs/creator/&quot; target=&quot;_blank&quot;&gt;Cocos Creator v1.5.x 用户手册&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2: Framework 这个就是开发的核心Cocos2d-x，其实按照我自己的理解，和iOS中我们常说的框架是类似的，比如你处理一些基本数据你就需要Foundation框架，处理UI的东西需要UIKit框架一样，这个Cocos2d-x就是我们开发游戏是需要的“框架”。&lt;/p&gt;
&lt;p&gt;3: SDK 这一部分的AnySDK是为CP商提供一套第三方SDK接入解决方案，包括我们常用的像支付、分享、统计分析等等。具体的也可以看看 &lt;a href=&quot;http://docs.anysdk.com/&quot; target=&quot;_blank&quot;&gt;SDK文档&lt;/a&gt;，可能有些人还知道棱镜SDK、anysdk、易接（1SDk），关于这几个有什么区别，甚至在什么时候用哪个等等的额问题，下面这篇文章可能能说明问题：&lt;/p&gt;
&lt;p&gt;     &lt;a href=&quot;https://www.zhihu.com/question/24680586&quot; target=&quot;_blank&quot;&gt;如何评价棱镜SDK、anysdk、易接（1SDk），他们都有什么差别&lt;/a&gt;？&lt;/p&gt;
&lt;p&gt;4、&lt;/p&gt;

&lt;p&gt;通过上面的分析和阐述能明白 Cocos 是什么 这个问题就可以了。&lt;/p&gt;

&lt;p&gt;说说Cocos开发语言&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      前面Framework提到过游戏开发的语言，就是C++ 、JavaScript 、Lua这三种，按照我自己的一点点小小的理解，要说什么语言比较好一点这种问题也不够资格回答，在知乎上看到过这样的问题，有兴趣的可以去看看，也许里面一些回答能让你有自己的理解：&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;https://www.zhihu.com/question/23363748&quot; target=&quot;_blank&quot;&gt;最适合游戏开发的语言是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      相信每一个程序猿对C/C++是有一定的掌握的，按照自己学习JS和Lua的过程，它们的学习难度都不大，完全可以通过对C掌握来相对容易的拿下它们。所以千万不要为你要学习一门新的开发语言而担心或者害怕，哪有程序猿不需要学习新东西更新自己的知识库的！当然这点难度的是也难不倒伟大的程序猿。&lt;/p&gt;
&lt;p&gt;      接下来说说Lua，Lua是一个脚本语言，具体的Lua语法什么的我们就不提了，在后面具体说到Lua的时候再说，知道了Cocos2d-Lua你还需要知道这个： Quick-Coco2d-x&lt;/p&gt;
&lt;p&gt;      下面这段话是在泰然网（也就是Quick-Coco2d-x官网）的教程里面说的，具体的告诉我们，什么是 Quick-Coco2d-x  &lt;/p&gt;
&lt;p&gt;      首先，想了解 Quick-Coco2d-x 就必须先知道 Cocos2d-x 是什么，不过我想关于 Cocos2d-x 的介绍这里就不用我来废话了吧，毕竟这么牛的游戏引擎还是应该很点名气的吧！&lt;/p&gt;
&lt;p&gt;      其次，由于 Cocos2d-x 中使用的是 C++ 语言，而 C++ 又对开发人员要求较高，所以逐渐地，开发者们开始将 Cocos2d-x 的 C++ 接口转成了 Lua 接口，从而衍生出了 Cocos2d-lua 的版本。而 Quick（Quick-Coco2d-x）是 Cocos2d-Lua 的一个豪华增强和扩展版本，它重写了支持代码、解决了内存泄露和只能使用全局函数做回调等等问题。Quick 能让开发者使用 Lua 这种简单易懂的脚本语言来编写游戏，并大大提高了开发效率。现在Quick 团队也已接手了 Cocos2d-lua 的开发和维护工作，所以未来 Quick 和 Cocos2d-lua 将有望完全合并起来。&lt;/p&gt;
&lt;p&gt;      我想通过上面两段话也就理解了Quick-Coco2d-x 和 Cocos2d-lua的关系！而下面的开发环境的搭建我们也就这两个方面说说，用Quick-Coco2d-lua 和Cocos2d-lua进行一个对比，也就能知道怎样的开发环境对于开发人员是最友好的。&lt;/p&gt;

&lt;p&gt;在Mac上开发游戏环境选择搭建&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      首先通过环境的搭建和各种对比之后在这抛出一个见解： 目前自己觉得比较友好的方式是 Quick-Coco2d-x + Sublime Text 3(2/3都可以)&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;http://www.sublimetext.com/&quot; target=&quot;_blank&quot;&gt;Sublime Text 3&lt;/a&gt; 你可以直接去官网下载    具体的 Quick-Coco2d-x 你可以看看这个：&lt;a href=&quot;http://www.cocoachina.com/bbs/read.php?tid-331250.html%20%20&quot; target=&quot;_blank&quot;&gt;Quick社区版第一个稳定版，Quick-Cocos2dx-Community 3.6 release发布&lt;/a&gt;！&lt;/p&gt;
&lt;p&gt;      它详细的介绍了Mac版本的客户端Paly3安装方式，下面就是一个Paly3运行起来的样子：&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;http://images2017.cnblogs.com/blog/739006/201710/739006-20171023233431207-2059861720.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;552&quot;/&gt;&lt;/p&gt;

&lt;p&gt;         接下来这个Paly3 我们就不再说了，新建项目/导入项目  或者打开已有的项目等等的相信都能理解。要是安装中出现一些问题，希望都可以自己动手上网解决了，当然也可以加我QQ多多交流。&lt;/p&gt;
&lt;p&gt;        Mac 搭建游戏开发环境还有一些方式，比如：还有利用 Cocos Studio 2 的，这个具体的可以看它的官网：  &lt;a href=&quot;http://www.cocos.com/&quot; target=&quot;_blank&quot;&gt;Cocos 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        看看官网的下载，相信创建一个基本的Demo这种事也难不住你。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;http://images2017.cnblogs.com/blog/739006/201710/739006-20171023234706910-202682848.png&quot; alt=&quot;&quot; width=&quot;804&quot; height=&quot;386&quot;/&gt;&lt;/p&gt;

&lt;p&gt;          直接运行你创建在项目，也就可以看到Demo啦。&lt;/p&gt;
&lt;p&gt;          再给大家分享个链接： &lt;a href=&quot;http://www.tairan.com/AboutQuick&quot;&gt;Quick-Cocos2d-x教程汇总&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;后面文章做的事&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      其实这篇文章起笔真的也是许久之前的事情了，自己接触Cocos也就两个多月，感觉也度过了最艰难的入门时期，最近也真的是太忙，没有时间留给自己总结这两个多月的东西了，没错，国庆加班到现在，真的是累！&lt;/p&gt;
&lt;p&gt;      不传播负能量啦，说说后面的，其实很想仔细的把iOS内存管理，Block以及多线程的东西也好好的总结一下的，最近给游戏里面负责添加了苹果原生支付，所以Lua和iOS的交互以及苹果内购方面的东西也值得好好总结一下啦。&lt;/p&gt;
&lt;p&gt;      接下来应该会先总结Lua和iOS交互以及支付的事，毕竟也要给客户写文档，到时顺便把这些一起做了。&lt;/p&gt;
&lt;p&gt;      猿猿们，1024快乐！！！&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 15:57:00 +0000</pubDate>
<dc:creator>Zxiao..旭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taoxu/p/7639940.html</dc:identifier>
</item>
<item>
<title>hash在URL上的用法及作用 - 畅园</title>
<link>http://www.cnblogs.com/dsfads/p/7719906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dsfads/p/7719906.html</guid>
<description>&lt;div id=&quot;navCategory&quot;&gt;
&lt;p&gt;&lt;strong&gt;阅读目录&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h3&gt;1. #&lt;/h3&gt;
&lt;p&gt;    10年9月，twitter改版。一个显著变化，就是URL加入了&quot;#!&quot;符号。比如，改版前的用户主页网址为&lt;a href=&quot;http://twitter.com/username&quot;&gt;http://twitter.com/username&lt;/a&gt;改版后，就变成了&lt;a href=&quot;http://twitter.com/#!/username&quot;&gt;http://twitter.com/#!/username&lt;/a&gt;&lt;br/&gt;　　这是主流网站第一次将&quot;#&quot;大规模用于重要URL中。这表明井号（Hash）的作用正在被重新认识。本文根据HttpWatch的文章，整理与井号有关的所有重要知识点。&lt;br/&gt;&lt;strong&gt;一、#的涵义&lt;/strong&gt;&lt;br/&gt;　　#代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如，http://www.example.com/index.html#print就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。&lt;br/&gt;　　为网页位置指定标识符，有两个方法。一是使用锚点，比如&amp;lt;a name=&quot;print&quot;&amp;gt;&amp;lt;/a&amp;gt;，二是使用id属性，比如&amp;lt;div id=&quot;print&quot;&amp;gt;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;二、HTTP请求不包括#&lt;/strong&gt;&lt;br/&gt;　　#是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括#。&lt;br/&gt;比如，访问下面的网址，&lt;a href=&quot;http://www.example.com/index.html#print&quot;&gt;http://www.example.com/index.html#print&lt;/a&gt;，浏览器实际发出的请求是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /index.html HTTP/1.1
Host: www.example.com
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;三、#后的字符&lt;/strong&gt;&lt;br/&gt;　　在第一个#后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。&lt;br/&gt;比如，下面URL的原意是指定一个颜色值：&lt;a href=&quot;http://www.example.com/?color=#fff&quot;&gt;http://www.example.com/?color=#fff&lt;/a&gt;，但是，浏览器实际发出的请求是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /?color= HTTP/1.1
Host: www.example.com
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;四、改变#不触发网页重载&lt;/strong&gt;&lt;br/&gt;　　单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页。&lt;br/&gt;比如，从http://www.example.com/index.html#location1改成http://www.example.com/index.html#location2，浏览器不会重新向服务器请求index.html。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、改变#会改变浏览器的访问历史&lt;/strong&gt;&lt;br/&gt;　　每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用&quot;后退&quot;按钮，就可以回到上一个位置。这对于&lt;strong&gt;ajax&lt;/strong&gt;应用程序特别有用，可以用不同的#值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、window.location.hash读取#值&lt;/strong&gt;&lt;br/&gt;　　window.location.hash这个属性可读可写。读取时，可以用来判断网页状态是否改变；写入时，则会在不重载网页的前提下，创造一条访问历史记录。&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七、onhashchange事件&lt;/strong&gt;&lt;br/&gt;　　这是一个HTML 5新增的事件，当#值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。&lt;br/&gt;　　它的使用方法有三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;window.onhashchange = func;&lt;/li&gt;
&lt;li&gt;&amp;lt;body onhashchange=&quot;func();&quot;&amp;gt;&lt;/li&gt;
&lt;li&gt;window.addEventListener(&quot;hashchange&quot;， func, false);&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;八、Google抓取#的机制&lt;/strong&gt;&lt;br/&gt;　　默认情况下，Google的网络蜘蛛&lt;strong&gt;忽视&lt;/strong&gt;URL的#部分。&lt;br/&gt;　　但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用&quot;#!&quot;，Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。&lt;br/&gt;　　比如，Google发现新版twitter的URL：&lt;a href=&quot;http://twitter.com/#!/username&quot;&gt;http://twitter.com/#!/username&lt;/a&gt;&lt;br/&gt;　　就会自动抓取另一个URL：&lt;a href=&quot;http://twitter.com/?_escaped_fragment_=/username&quot;&gt;http://twitter.com/?_escaped_fragment_=/username&lt;/a&gt;&lt;br/&gt;　　通过这种机制，Google就可以索引动态的Ajax内容。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/subview/1641/5762264.htm?fr=aladdin&quot;&gt;AJAX&lt;/a&gt; = 异步 &lt;a href=&quot;http://baike.baidu.com/view/16168.htm&quot; target=&quot;_blank&quot;&gt;JavaScript&lt;/a&gt;和&lt;a href=&quot;http://baike.baidu.com/view/63.htm&quot; target=&quot;_blank&quot;&gt;XML&lt;/a&gt;（&lt;a href=&quot;http://baike.baidu.com/view/5286041.htm&quot; target=&quot;_blank&quot;&gt;标准通用标记语言&lt;/a&gt;的子集）。AJAX 是一种用于创建快速动态网页的技术。&lt;/p&gt;
&lt;h3&gt;2. ？&lt;/h3&gt;
&lt;p&gt;1）连接作用：比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http://www.xxx.com/Show.asp?id=77&amp;amp;nameid=2905210001&amp;amp;page=1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）清除缓存：比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http://www.xxxxx.com/index.html 
http://www.xxxxx.com/index.html?test123123
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个url打开的页面一样，但是后面这个有问号，说明不调用缓存的内容，而认为是一个新地址，重新读取。&lt;/p&gt;

&lt;h3&gt;3. &amp;amp;&lt;/h3&gt;
&lt;p&gt;不同参数的间隔符&lt;/p&gt;

</description>
<pubDate>Mon, 23 Oct 2017 15:53:00 +0000</pubDate>
<dc:creator>畅园</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dsfads/p/7719906.html</dc:identifier>
</item>
<item>
<title>如何升级laravel5.4到laravel5.5并使用新特性？ - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/7719893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/7719893.html</guid>
<description>&lt;p&gt;修改composer.json:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;laravel/framework&quot;: &quot;5.5.*&quot;,

&quot;phpunit/phpunit&quot;: &quot;~6.0&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;scripts增加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        &quot;post-autoload-dump&quot;: [
            &quot;Illuminate\\Foundation\\ComposerScripts::postAutoloadDump&quot;,
            &quot;@php artisan package:discover&quot;
        ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行composer update -vvv&lt;/p&gt;

&lt;p&gt;为扩展包增加了一个自动发现功能。&lt;/p&gt;
&lt;p&gt;以barryvdh/laravel-debugbar为例，先删除这个包。composer remove barryvdh/laravel-debugbar&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/136188/201710/136188-20171023234627519-1875875714.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先把APP里面的Barryvdh\Debugbar\ServiceProvider::class,去掉。&lt;/p&gt;
&lt;p&gt;就删除成功了。&lt;/p&gt;
&lt;p&gt;再重新安装：&lt;/p&gt;
&lt;p&gt;我们看github上这个包最新版的&lt;br/&gt;Installing barryvdh/laravel-debugbar (v3.1.0): Downloading (100%)&lt;/p&gt;
&lt;p&gt;里面的包的composer.json有这么一个说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;extra&quot;: {
        &quot;branch-alias&quot;: {
            &quot;dev-master&quot;: &quot;3.0-dev&quot;
        },
        &quot;laravel&quot;: {
            &quot;providers&quot;: [
                &quot;Barryvdh\\Debugbar\\ServiceProvider&quot;
            ],
            &quot;aliases&quot;: {
                &quot;Debugbar&quot;: &quot;Barryvdh\\Debugbar\\Facade&quot;
            }
        }
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到，在bootstrap/cache/packages.php里面已经写上了debugbar，并且我们在页面上也可以看到有debugbar的存在。但是我们并不需要在app.php里面增加debugbar的serviceProvider了。非常方便!!!&lt;/p&gt;
&lt;p&gt;就是说，我们引入的包里面，只要有这个extra.laravel的说明，后面的providers和alias会自动增加到框架中去。&lt;/p&gt;

&lt;p&gt;这个特性的功能就是把资源直接作为api返回给前端，并且进行需要的包装。&lt;/p&gt;
&lt;p&gt;这里的resource就是返回资源，我们可以创建这么一个返回资源，这个资源会被包装在data字段中，json，api返回。&lt;/p&gt;
&lt;p&gt;比如创建一个PostCollection资源。代表文章集合。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;php artisan make:resource PostCollection&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我希望返回的api里面有两个字段：data和meta，data代表的就是文章集合，meta代表的是一些附属的元数据信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php

namespace App\Http\Resources;

use Illuminate\Http\Resources\Json\ResourceCollection;

class PostCollection extends ResourceCollection
{
    /**
     * Transform the resource collection into an array.
     *
     * @param  \Illuminate\Http\Request
     * @return array
     */
    public function toArray($request)
    {
        return parent::toArray($request);
    }


    public function with($request)
    {
        return [
            'meta' =&amp;gt; [
                'site' =&amp;gt; 'laravel55',
            ],
        ];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在路由中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Route::get('/api/posts', function () {
    return new \App\Http\Resources\PostCollection(\App\Post::all());
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且在\App\Post中重新定义toArray()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public function toArray()
    {
        return [
            &quot;id&quot; =&amp;gt; $this-&amp;gt;id,
            &quot;title&quot; =&amp;gt; $this-&amp;gt;title,
        ];
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这个时候就返回了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/136188/201710/136188-20171023234732613-1101718611.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有人说，其实laravel中在控制器中直接返回对象也就是调用它们的toArray方法，那么如果你把上式的路由修改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Route::get('/api/posts', function () {
    return new \App\Http\Resources\PostCollection(\App\Post::paginate(3));
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你就感觉到增加这个&quot;api resource&quot;的方便性了：统一API返回结构，并且让你少写了很多代码。&lt;/p&gt;

&lt;p&gt;我们之前自定义的Command需要在Console\Commands\Kernel.php中写上每个Command:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Kernel extends ConsoleKernel
{
    /**
     * The Artisan commands provided by your application.
     *
     * @var array
     */
    protected $commands = [
        \App\Console\Commands\ESInit::class
    ];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，不用了，只修改commands函数:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected function commands()
    {
        $this-&amp;gt;load(__DIR__ . '/Commands');

        require base_path('routes/console.php');
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这个规则是为了我们的自定义验证规则。比如，我们的登录，需要邮箱后缀为gmail.com才能登录。那么这个时候我们就需要定义一个验证规则类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;php artisan make:rule ValidLoginEmail&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在App\Rules文件夹下面看到ValidLoginEmail类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class ValidLoginEmail implements Rule
{
    /**
     * Create a new rule instance.
     *
     * @return void
     */
    public function __construct()
    {
        //
    }

    /**
     * Determine if the validation rule passes.
     *
     * @param  string  $attribute
     * @param  mixed  $value
     * @return bool
     */
    public function passes($attribute, $value)
    {
        $strs = explode(&quot;@&quot;, $value);
        if (count($strs) == 2 &amp;amp;&amp;amp; $strs[1] == &quot;gmail.com&quot;) {
            return true;
        }
        return false;
    }

    /**
     * Get the validation error message.
     *
     * @return string
     */
    public function message()
    {
        return '邮箱必须是gmail结尾';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再修改loginController的login()的验证部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$this-&amp;gt;validate(request(),[
            'email' =&amp;gt; ['required', new ValidLoginEmail(), 'email'],
            'password' =&amp;gt; 'required|min:5|max:10',
            'is_remember' =&amp;gt; 'integer'
        ]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/136188/201710/136188-20171023234831473-608339696.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;还是login方法，我们也可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public function login(Request $request)
    {
        // 验证
        $request-&amp;gt;validate([
            'email' =&amp;gt; ['required', new ValidLoginEmail(), 'email'],
            'password' =&amp;gt; 'required|min:5|max:10',
            'is_remember' =&amp;gt; 'integer'
        ]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不再需要使用&lt;br/&gt;&lt;code&gt;$this-&amp;gt;validate(request(),[&lt;/code&gt;&lt;br/&gt;这样做的好处是更语义化了：验证请求符合下列规则...&lt;/p&gt;

&lt;p&gt;在以前，我们自定义一个Exception类，要想这个异常单独处理，就需要在Handler.php里面的render方法这么写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public function render($request, Exception $exception)
    {
        if ($exception instanceof \App\Exceptions\ForbiddenException) {
            return response()-&amp;gt;view(&quot;exceptions/forbidden&quot;);
        }
        return parent::render($request, $exception);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样自定义异常定义多了，这个函数就非常冗余。&lt;/p&gt;
&lt;p&gt;现在的方法就是，在自定义异常里面定义一下render方法就行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
namespace App\Exceptions;

class ForbiddenException extends \Exception
{
    /**
     * Report the exception.
     *
     * @return void
     */
    public function report()
    {
        //
    }

    /**
     * Report the exception.
     *
     * @param  \Illuminate\Http\Request
     * @return void
     */
    public function render($request)
    {
        return response()-&amp;gt;view(&quot;exceptions/forbidden&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果你这个路由什么逻辑都没有，只是渲染一个模版，那么就很适合使用这个方法。比如创建文章页面：&lt;/p&gt;
&lt;p&gt;原先：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Route::get('/posts/create', '\App\Http\Controllers\PostController@create');


    // 创建页面
    public function create()
    {
        return view(&quot;post/create&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 创建文章
    Route::view('/posts/create', 'post/create');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个功能大赞，能让人少写很多代码。&lt;/p&gt;
&lt;p&gt;更多5.5新特性请看：&lt;br/&gt;&lt;a href=&quot;https://laravel.com/docs/5.5/releases&quot; class=&quot;uri&quot;&gt;https://laravel.com/docs/5.5/releases&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 15:50:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjf512/p/7719893.html</dc:identifier>
</item>
<item>
<title>80806汇编(5)——[BX]和Loop指令 - exRunner</title>
<link>http://www.cnblogs.com/exRunner/p/7719894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/exRunner/p/7719894.html</guid>
<description>&lt;p&gt;已经好久没写点东西了，国庆节就一直想弄个个人网站，这段时间一直在弄那个，虽然有现成的框架（Hexo），但是总想弄出自己的效果来，但是最后还是有些差强人意，只好打翻了有重来（强迫症表示难受），也懒得弄那么多了。好在最近差不多事情也理顺了，今天强迫自己静下来写了点东西。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;简述&quot;&gt;简述&lt;/h2&gt;
&lt;p&gt;今天看了下汇编中的[BX]和Loop指令，Loop指令容易知道，一看就是用来做循环的指令，那么[BX]又是什么呢？&lt;/p&gt;
&lt;p&gt;首先我们知道，要完整的描述一个内存单元，需要两种信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存单元的地址&lt;/li&gt;
&lt;li&gt;内存单元的长度（类型：字节或字等）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于第一个——【内存单元的地址】，我们知道，用[addr]可以表示一个内存单元，其中addr表示这个内存单元的偏移地址，段地址默认在DS寄存器中。而单元的长度（类型）则可以由指令中的其他操作对象指出（如寄存器），就像下面这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么，在这里[BX]也表示一个内存单元，其偏移地址存于BX寄存器中，段地址默认在DS寄存器中。也把BX寄存器叫做&lt;strong&gt;基址寄存器&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;两个约定&quot;&gt;两个约定&lt;/h2&gt;
&lt;p&gt;为了方便后面的叙述，这里作两个约定，当然也是跟着书上的来啦，哈哈，不过我发现很多书上也都默认有这个叙述方法。&lt;/p&gt;
&lt;h3 id=&quot;描述性符号&quot;&gt;1. 描述性符号&quot;( )&quot;&lt;/h3&gt;
&lt;p&gt;用描述性符号“( )”表示一个寄存器或一个内存单元中的内容，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(ax) 表示寄存器AX中的内容，(al) 表示寄存器AL中的内容。
(addr) 表示物理地址为addr的内存单元中的内容。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此&quot;( )&quot;中的元素类型有3种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;寄存器名；&lt;/li&gt;
&lt;li&gt;段寄存器名；&lt;/li&gt;
&lt;li&gt;内存单元的物理地址。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其所表示的数据类型有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字节；&lt;/li&gt;
&lt;li&gt;字。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体是那种类型则由寄存器名或具体的运算符决定。&lt;/p&gt;
&lt;h3 id=&quot;常量符号idata&quot;&gt;2. 常量符号&quot;idata&quot;&lt;/h3&gt;
&lt;p&gt;用idata表示一个常量。&lt;br/&gt;如用&lt;code&gt;mov ax, [idata]&lt;/code&gt;代表&lt;code&gt;mov ax, [1]&lt;/code&gt;、&lt;code&gt;mov ax, [2]&lt;/code&gt;等。&lt;br/&gt;如用&lt;code&gt;mov bx, idata&lt;/code&gt;代表&lt;code&gt;mov bx, 1&lt;/code&gt;、&lt;code&gt;mov bx, 2&lt;/code&gt;等。&lt;/p&gt;
&lt;h2 id=&quot;bx&quot;&gt;[BX]&lt;/h2&gt;
&lt;p&gt;我们对[BX]的使用有如下用法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, [&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]  &lt;span class=&quot;co&quot;&gt;; bx中存放的数据作为偏移地址，段地址默认在ds中，(ax) = ((ds) * 16 + (bx))&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; [&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;], &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;; bx中存放的数据作为偏移地址，段地址默认在ds中，((ds) * 16 + (bx)) = (ax)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;loop指令&quot;&gt;Loop指令&lt;/h2&gt;
&lt;p&gt;Loop指令用于实现循环功能，循环次数存于CX寄存器中 。&lt;br/&gt;【格式】loop 标号&lt;br/&gt;示例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;cx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;; 设置循环次数&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;s:&lt;/span&gt;                  &lt;span class=&quot;co&quot;&gt;; 标号&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;; 循环执行的程序段&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;loop&lt;/span&gt; s           &lt;span class=&quot;co&quot;&gt;; Loop指令&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Loop指令通常用于执行某些需要重复运行的指令，比如操作某一块连续的内存地址块。通常把循环次数存于CX寄存器中，CPU通过判断CX里面的值是否为零来决定是否执行循环。CPU执行Loop指令的描述如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. (CX) = (CX) -1
2. (CX)不为零，转去标号处执行，反之不执行循环，向下执行指令&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的标号&quot;s&quot;并不是固定的，你也可以指定其他的标号。在这里标号实际上是标识了一个地址，在该地址处存在着我们的程序指令（如上面的add ax, ax），在执行循环的时候，若CX的值不为零，则&quot;Loop 标号&quot;指令将IP的值设置为标号所标识的地址，CPU就将执行IP所指向的指令。&lt;/p&gt;
&lt;p&gt;我们可以得到这样一个Loop指令的简单框架：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;cx&lt;/span&gt;, 循环次数
&lt;span class=&quot;ot&quot;&gt;label&lt;/span&gt;:
需要循环执行的程序段
&lt;span class=&quot;kw&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;label&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【注意】书上的一个实例程序中提到在汇编程序中的数据表示问题，我们知道，在汇编中，数据多以16进制表示，而16进制中有 'A~F' 6个字母，但是在汇编源程序中，数据的书写不能以字母开头，如“9876H”可以直接书写为“9876H”，但是“A000H”不能书写成“A000H”，而需写为“0A000H”（以0开头）。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;bx和loop指令&quot;&gt;[BX]和Loop指令&lt;/h2&gt;
&lt;p&gt;在实际编程中可能会遇到要处理某一段地址连续的内存单元中的数据，通常可用循环来解决这类问题。在这样的循环过程中，需要一个变量来保存内存单元的偏移地址，这时候“基址寄存器——BX”就起作用了。&lt;/p&gt;
&lt;p&gt;【注：以下内容来自王爽的《汇编语言》(第三版)】&lt;br/&gt;考虑这么一个问题，我们要计算 ffff:0~ffff:b 单元中的数据的和，要求将结果存储在dx寄存器中。&lt;br/&gt;我们首先分析一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;运算后的结果是否会超出dx能存储的范围？&lt;br/&gt;&lt;code&gt;ffff:0~ffff:b 内存单元中的数据是字节型的数据，范围在0~255之间，12个这样的数据相加的结果不会大于65535，是可以存储在dx寄存器中的。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我们能否将 ffff:0~ffff:b 中的数据直接累加到dx中？&lt;br/&gt;&lt;code&gt;这是比不可能的，为什么？因为数据类型不匹配，dx是16位寄存器，而 ffff:0~ffff:b 中的数据是8位的。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;那么是否可以将其累加到dl中，并设置(dh)=0，从而实现累加到dx中？&lt;br/&gt;&lt;code&gt;看第一条分析，12个8字节的数据相加是有可能超过255的，而我们的dl是8位寄存器，那么答案很明显了。不能！&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;那到底应该如何做呢？&lt;br/&gt;&lt;code&gt;这里有两个问题，类型的匹配和结果的不超界，我们可以考虑用一个16位的寄存器来做中介。将内存单元中的8位数据赋值到一个16位寄存器ax中，再将ax中的数据加到dx上，从而使两个运算对象类型匹配并且结果不会超界。&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;考虑完以上问题，很明显，如果是在高级语言中，这是一个很容易做的问题，一个循环就可以实现，那么在汇编中，我们也可以用循环来实现这个操作。我们可以把BX用作存储内存单元偏移地址的变量，在每次循环的时候改变BX中的值，从而实现把 ffff:0~ffff:b 12个内存单元中的数据相加。&lt;br/&gt;实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;assume &lt;span class=&quot;kw&quot;&gt;cs&lt;/span&gt;:code
code &lt;span class=&quot;kw&quot;&gt;segment&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;    start:&lt;/span&gt;             &lt;span class=&quot;co&quot;&gt;;程序入口&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;, 0ffffh&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ds&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;;初始化ds:bx指向ffff:0&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;dx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;;初始化累加寄存器dx，(dx)=0&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;cx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;    s:&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;al&lt;/span&gt;, [&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt; ah, &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;dx&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;inc&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;;使ds:bx指向下一个内存单元&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;loop&lt;/span&gt; s

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;, 4c00h&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt; 21h&lt;/span&gt;
code ends
&lt;span class=&quot;ot&quot;&gt;end&lt;/span&gt; start        &lt;span class=&quot;co&quot;&gt;;程序结束&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;段前缀&quot;&gt;段前缀&lt;/h2&gt;
&lt;p&gt;在指令“mov ax, [bx]”中，内存单元的偏移地址由bx指出，而段地址则默认存储在ds中。但是我们可以在访问内存单元的指令中显示给出内存单元的段地址所在的段寄存器，如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ds&lt;/span&gt;:[&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;cs&lt;/span&gt;:[&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ss&lt;/span&gt;:[&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;es&lt;/span&gt;:[&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ss&lt;/span&gt;:[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;cs&lt;/span&gt;:[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些出现在访问内存单元的指令中，用于显示地指明内存单元的段地址的“ds:” “cs:” “es:” “ss:”，在汇编语言中称为&lt;strong&gt;段前缀&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;段前缀的使用&quot;&gt;段前缀的使用&lt;/h3&gt;
&lt;p&gt;考虑一个问题，将内存单元 ffff:0~ffff:b 单元中的数据复制到 0:200~0:20b 单元中。&lt;br/&gt;分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;0:200 ~0:20b 单元等同于 0020:0~0020:b 单元，它们描述的是同一段内存空间。&lt;/li&gt;
&lt;li&gt;复制过程用循环实现，我们可以使用一个变量[BX]同时操作两段内存单元（使用段前缀来标识不同的段）。&lt;/li&gt;
&lt;li&gt;将 0:200~0:20b 用 0020:0~0020:b 描述，是为了使目标单元的偏移地址和源始单元的偏移地址从同一数值0开始。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;assume &lt;span class=&quot;kw&quot;&gt;cs&lt;/span&gt;:code
code &lt;span class=&quot;kw&quot;&gt;segment&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;, 0ffffh&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ds&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;;(ds)=0ffffh&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;, 0020h&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;es&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;;(es)=0020h&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;;此时ds:bx指向ffff:0，es:dx指向0020:0&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;cx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;    s:&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;dl&lt;/span&gt;, [&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]      &lt;span class=&quot;co&quot;&gt;;段地址默认在ds中&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;es&lt;/span&gt;:[&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;], &lt;span class=&quot;kw&quot;&gt;dl&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;;段前缀指明内存段&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;inc&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;loop&lt;/span&gt; s

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;, 4c00h&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt; 21h&lt;/span&gt;
code ends
&lt;span class=&quot;ot&quot;&gt;end&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 23 Oct 2017 15:50:00 +0000</pubDate>
<dc:creator>exRunner</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/exRunner/p/7719894.html</dc:identifier>
</item>
<item>
<title>记录一个Unity播放器插件的开发 - HarlanC</title>
<link>http://www.cnblogs.com/harlanc/p/7719863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harlanc/p/7719863.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;公司最近在做VR直播平台，VR开发我们用到了Unity，而在Unity中播放视频就需要一款视频插件，我们调研了几个视频插件，记录两个，如下：&lt;/p&gt;
&lt;h2 id=&quot;unity视频插件调研&quot;&gt;Unity视频插件调研&lt;/h2&gt;
&lt;p&gt;网上搜了搜，最流行的有以下两款Unity插件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.assetstore.unity3d.com/en/#!/content/52745&quot;&gt;AVPro&lt;/a&gt; 这个在Unity商店售价150$，最新release版本为&lt;a href=&quot;https://forum.unity.com/threads/released-avpro-video-complete-video-playback-solution.385611/&quot;&gt;1.6.15&lt;/a&gt;,功能包括：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Powerful cross-platform video playback solution for Unity.&lt;/p&gt;
&lt;p&gt;Native video playback on Android, iOS, macOS and tvOS (Apple TV), WebGL, Windows, Windows Phone and UWP.&lt;/p&gt;
&lt;p&gt;Features include:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;New&lt;/em&gt; Unity 2017 supported&lt;/li&gt;
&lt;li&gt;&lt;em&gt;New&lt;/em&gt; New iOS video playback path that uses less memory&lt;/li&gt;
&lt;li&gt;One API for video playback on all supported platforms&lt;/li&gt;
&lt;li&gt;Unity 4.6 - 5.x supported&lt;/li&gt;
&lt;li&gt;8K video (on supported hardware)&lt;/li&gt;
&lt;li&gt;VR Support (mono, stereo, equirectangular and cubemap)&lt;/li&gt;
&lt;li&gt;Transparency support (native and packed)&lt;/li&gt;
&lt;li&gt;Subtitles support (external SRT)&lt;/li&gt;
&lt;li&gt;Fast flexible video playback&lt;/li&gt;
&lt;li&gt;In-editor playback support for Windows and macOS&lt;/li&gt;
&lt;li&gt;Free watermarked trial version available&lt;/li&gt;
&lt;li&gt;Components for IMGUI, uGUI and NGUI&lt;/li&gt;
&lt;li&gt;Over 64 PlayMaker actions included&lt;/li&gt;
&lt;li&gt;Easy to use drag and drop components&lt;/li&gt;
&lt;li&gt;Linear and Gamma colour spaces supported&lt;/li&gt;
&lt;li&gt;Fast native Direct3D, OpenGL and Metal texture updates&lt;/li&gt;
&lt;li&gt;Desktop support for Hap, Hap Alpha, Hap Q and Hap Q Alpha&lt;/li&gt;
&lt;li&gt;Streaming video from URL (when supported by platform)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此插件支持HLS视频播放,&lt;a href=&quot;http://downloads.renderheads.com/docs/UnityAVProVideo.pdf&quot;&gt;使用文档&lt;/a&gt;很详细，但是此插件没有源码，不适合做以后的个性化开发。&lt;/p&gt;
&lt;p&gt;Supported resolutions:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Android: General devices support up to 1920 * 1080.&lt;br/&gt;The latest device supports up to 4k.&lt;/li&gt;
&lt;li&gt;iOS: General devices support up to 1920 * 1080.&lt;br/&gt;The latest device is support up to 2560 * 1440.&lt;br/&gt;iPhone 6s Plus supports up to 4k.&lt;/li&gt;
&lt;li&gt;It also supports StreamingAssets, external storage, and streaming services.&lt;/li&gt;
&lt;li&gt;Android streaming support list: http, HLS (http live streaming),rtsp&lt;/li&gt;
&lt;li&gt;iOS streaming support list: http,HLS (http live streaming)&lt;/li&gt;
&lt;li&gt;EasyMovieTexture requires Android 4.0 or above.&lt;/li&gt;
&lt;li&gt;EasyMovieTexture requires iOS 6.0 or Above.&lt;/li&gt;
&lt;li&gt;Unity 4.X requires an iOS Pro.&lt;/li&gt;
&lt;li&gt;In Unity 5.X it does not require a Pro.&lt;/li&gt;
&lt;li&gt;Supports multithreaded rendering options. (Only supports Unity 5.X.)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个插件貌似是个人开发的，没有说明文档，有部分java源码，native code并没有给出。我们需要有源码的插件方便以后的个性化开发。&lt;/p&gt;
&lt;h2 id=&quot;自己动手风衣足食&quot;&gt;自己动手，风衣足食&lt;/h2&gt;
&lt;p&gt;综合以上调研结果，我们决定自己动手实现一个简单能满足我们要求的Unity播放器插件，有两个难点要突破：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个是找一个合适的开源播放器。&lt;/li&gt;
&lt;li&gt;另一个就是如何把播放视频画面映射到Unity中的物体表面，这个是最关键的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;寻找素材&quot;&gt;寻找素材&lt;/h2&gt;
&lt;p&gt;从下面这个帖子中，找到了一些可以参考的资料。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/37751298/answer/157669701&quot;&gt;unity 3d 中如何实现以物体的表面作为播放视频的位置，比如在墙面播放视频？&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;寻找开源播放器&quot;&gt;寻找开源播放器&lt;/h4&gt;
&lt;p&gt;本来打算使用VLC播放器的，但是同事发现有一个商用的开源播放器，并且使用的人数也不少，B站的&lt;a href=&quot;https://github.com/Bilibili/ijkplayer&quot;&gt;ijkplayer&lt;/a&gt;。正好在上面的帖子中回复人也提到了这个播放器，我们决定使用这个播放器。&lt;/p&gt;
&lt;h4 id=&quot;如何做视频画面映射&quot;&gt;如何做视频画面映射&lt;/h4&gt;
&lt;p&gt;没有一点Unity开发经验，只能从头一点点学起，知乎的帖子里面，有个人回复可以参考OVR里面的例子。阅读了里面的代码，同时也参考了easyMovieTexture中的源码（easyMovie中只有java代码，关键的native code并没有给）。看的有些似懂非懂，尝试了之后，居然成功了。&lt;/p&gt;
&lt;p&gt;最关键的一点我描述成下面的话：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将Ijkplayer的AndroidSurfaceTexture纹理ID和Unity中Texture2D的纹理ID分别同时绑定到不同的目标上。AndroidSurfaceTexture绑定到GL_TEXTURE_EXTERNAL_OES，Unity的纹理ID绑定到GL_TEXTURE_2D&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;从头到尾梳理一遍流程&quot;&gt;从头到尾梳理一遍流程&lt;/h2&gt;
&lt;h4 id=&quot;初始化&quot;&gt;初始化&lt;/h4&gt;
&lt;p&gt;Unity端初始化一个Texture2D纹理ID用于显示视频帧。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;m_VideoTexture = new Texture2D (Call_GetVideoWidth (), Call_GetVideoHeight (), TextureFormat.RGB565, false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用了OVR里面的native code，OVR中初始化AndroidSurfaceTexture和相关的函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static const char * className = &quot;android/graphics/SurfaceTexture&quot;;
    const jclass surfaceTextureClass = jni-&amp;gt;FindClass(className);
    if ( surfaceTextureClass == 0 ) {
        FAIL( &quot;FindClass( %s ) failed&quot;, className );
    }

    // find the constructor that takes an int
    const jmethodID constructor = jni-&amp;gt;GetMethodID( surfaceTextureClass, &quot;&amp;lt;init&amp;gt;&quot;, &quot;(I)V&quot; );
    if ( constructor == 0 ) {
        FAIL( &quot;GetMethodID( &amp;lt;init&amp;gt; ) failed&quot; );
    }

    jobject obj = jni-&amp;gt;NewObject( surfaceTextureClass, constructor, textureId );
    if ( obj == 0 ) {
        FAIL( &quot;NewObject() failed&quot; );
    }

    javaObject = jni-&amp;gt;NewGlobalRef( obj );
    if ( javaObject == 0 ) {
        FAIL( &quot;NewGlobalRef() failed&quot; );
    }

    // Now that we have a globalRef, we can free the localRef
    jni-&amp;gt;DeleteLocalRef( obj );

    updateTexImageMethodId = jni-&amp;gt;GetMethodID( surfaceTextureClass, &quot;updateTexImage&quot;, &quot;()V&quot; );
    if ( !updateTexImageMethodId ) {
        FAIL( &quot;couldn't get updateTexImageMethodId&quot; );
    }

    getTimestampMethodId = jni-&amp;gt;GetMethodID( surfaceTextureClass, &quot;getTimestamp&quot;, &quot;()J&quot; );
    if ( !getTimestampMethodId ) {
        FAIL( &quot;couldn't get getTimestampMethodId&quot; );
    }

    setDefaultBufferSizeMethodId = jni-&amp;gt;GetMethodID( surfaceTextureClass, &quot;setDefaultBufferSize&quot;, &quot;(II)V&quot; );
    if ( !setDefaultBufferSizeMethodId ) {
        FAIL( &quot;couldn't get setDefaultBufferSize&quot; );
    }

    // jclass objects are localRefs that need to be freed
    jni-&amp;gt;DeleteLocalRef( surfaceTextureClass );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化纹理ID，并将其绑定到目标GL_TEXTURE_2D上:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;glGenTextures( 1, &amp;amp;textureId );
    glBindTexture( GL_TEXTURE_EXTERNAL_OES, textureId );
    glTexParameterf( GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
    glTexParameterf( GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
    glTexParameterf( GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
    glTexParameterf( GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
    glBindTexture( GL_TEXTURE_EXTERNAL_OES, 0 );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将Unity的纹理ID传递到OVR中，用于绑定到目标GL_TEXTURE_EXTERNAL_OES上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
jobject OVR_Media_Surface( void * texPtr, int const width, int const height )
{
    GLuint texId = (GLuint)(size_t)(texPtr);
    LOG( &quot;OVR_Media_Surface(%i, %i, %i)&quot;, texId, width, height );
    return _msp.VideoSurface.Bind( texId, width, height );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个播放器，注意这里我们使用OVR中已经实例化的AndroidMovieTexture来初始化播放器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; m_IjkMediaPlayer.setSurface(m_Surface);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;刷新&quot;&gt;刷新&lt;/h4&gt;
&lt;p&gt;刷新操作由Unity中的Update函数触发，最终在OVR中执行，首先调用AndroidMovieTexture中的Update函数，接下来就是绑定纹理操作，Ijkplayer的纹理ID每刷新一次绑定一次。而Unity的纹理ID只有在视频图像长度或者宽度发生变化才会绑定。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void MediaSurface::Update()
{
    if ( !AndroidSurfaceTexture )
    {
        LOG( &quot;!AndroidSurfaceTexture&quot; );
        return;
    }
    if ( TexId &amp;lt;= 0 )
    {
        //LOG( &quot;TexId &amp;lt;= 0&quot; );
        return;
    }
    AndroidSurfaceTexture-&amp;gt;Update();
    if ( AndroidSurfaceTexture-&amp;gt;GetNanoTimeStamp() == LastSurfaceTexNanoTimeStamp )
    {
        //LOG( &quot;No new surface!&quot; );
        return;
    }
    LastSurfaceTexNanoTimeStamp = AndroidSurfaceTexture-&amp;gt;GetNanoTimeStamp()

   // If the SurfaceTexture has changed dimensions, we need to
    // reallocate the texture and FBO.
    glActiveTexture( GL_TEXTURE0 );
    glBindTexture( GL_TEXTURE_EXTERNAL_OES, AndroidSurfaceTexture-&amp;gt;GetTextureId() );
    if ( TexIdWidth != BoundWidth || TexIdHeight != BoundHeight )
    {
        LOG( &quot;New surface size: %ix%i&quot;, BoundWidth, BoundHeight );

        TexIdWidth = BoundWidth;
        TexIdHeight = BoundHeight;

        if ( Fbo )
        {
            glDeleteFramebuffers( 1, &amp;amp;Fbo );
        }

        glActiveTexture( GL_TEXTURE1 );
        glBindTexture( GL_TEXTURE_2D, TexId );
        glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA,
                TexIdWidth, TexIdHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL );
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );

        glBindTexture( GL_TEXTURE_2D, 0 );
        glActiveTexture( GL_TEXTURE0 );

        glGenFramebuffers( 1, &amp;amp;Fbo );
        glBindFramebuffer( GL_FRAMEBUFFER, Fbo );
        glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
                TexId, 0 );
        glBindFramebuffer( GL_FRAMEBUFFER, 0 );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后的结果可能是这个样子的：Ijkplayer负责推动视频不停向前播放，播放器的纹理也会不停刷新，这会带动Unity纹理跟着刷新，最终显示在Unity的Material上。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 15:39:00 +0000</pubDate>
<dc:creator>HarlanC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/harlanc/p/7719863.html</dc:identifier>
</item>
<item>
<title>华为笔试题--LISP括号匹配 解析及源码实现 - DHUtoBUAA</title>
<link>http://www.cnblogs.com/DHUtoBUAA/p/7719839.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DHUtoBUAA/p/7719839.html</guid>
<description>&lt;p&gt;　　在17年校招中3道题目AC却无缘华为面试，大概是华为和东华互不待见吧！分享一道华为笔试原题，共同进步！&lt;/p&gt;
&lt;p&gt;***************************************************************************************************************************************************************************&lt;/p&gt;
&lt;p&gt;题目描述：&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;LISP语言唯一的语法就是括号要匹配。&lt;br/&gt;形如（OP P1 P2 …），括号内元素由单个空格分割。&lt;br/&gt;其中第一个元素OP为操作符，后续元素均为其参数，参数个数取决于操作符类型&lt;br/&gt;注意：参数P1,P2也有可能是另外一个嵌套的（OP P1 P2 …）&lt;br/&gt;其中OP类型为add/sub/mul/div（全小写），分别代表整数的加减乘除法&lt;br/&gt;其中add/mul参数个数2或以上，sub/div参数个数为2&lt;br/&gt;举例：&lt;br/&gt;-输入：（mul 3 -7） 输出：-21&lt;br/&gt;-输入：（add1 2 3） 输出：6&lt;br/&gt;-输入：（sub (mul 2 4) (div 9 3)） 输出：5&lt;br/&gt;-输入：（div 1 0） 输出：error&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;题目涉及数字均为整数，可能为负；不考虑32位溢出翻转&lt;br/&gt;除零错误时，输出&quot;error&quot;，除法遇除不尽，取整，即3/2=1&lt;/p&gt;
&lt;p&gt;输入描述：&lt;br/&gt;合法C字符串，字符串长度不超过512；用例保证了无语法错误&lt;/p&gt;
&lt;p&gt;输出描述：&lt;br/&gt;合法C字符串，字符包括'0'-'9'及负号'-'或者'error'&lt;/p&gt;
&lt;p&gt;示例&lt;br/&gt;输入 （add 1 2 3） 输出 6&lt;br/&gt;*********************************************************&lt;/p&gt;
&lt;p&gt;　　这是数据结构中括号匹配问题的变形。在检验括号是否匹配的方法中，可用“期待的急迫程度”这个概念来描述。在算法中设置了一个栈，每读入一个括号，若是右括号，则或者使置于栈顶的最急迫的期待得以消解，或者是不合法的情况；若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的在栈中的所有未消解的期待的急迫性降了一级。另外，在算法的开始和结束时，栈都应该是空的。&lt;br/&gt;　　同样的道理，针对LISP的括号匹配，我们不仅需要一个符号栈opstack去保存每一个括号里的操作符OP，还需要一个栈strstack去保存括号里的参数P1、P2及符号位。&lt;br/&gt;　　从头到尾对输入的C字符串进行遍历，当遇到左括号&quot;(&quot;时，将&quot;(&quot;压入strstack中，其后的操作符压入opstack栈中；当遇到参数P时，通过字符串分割，放入strstack中；当遇到右括号&quot;)&quot;时，在strstack栈中依次弹出参数，压入tmps栈，直到遇到&quot;(&quot;为止，那么tmps中为一个不包含子括号参数列表，运算符为opstack的栈顶元素，其中根据操作符和参数可以进行加减乘除运运算，这部分不讨论。注意，运算结果需要在压入strstack栈中作为参数P。&lt;br/&gt;　　如下图所示，以（sub (mul 2 4) (div 9 3)）为例，在遇到第一个&quot;)&quot;时，strstack中分别为｛(,(,2,4｝,opstack中分别为{sub ,mul},则strstack中依次弹出4,2,(,运算符为opstack的栈顶元素mul,可以得到结果为8,其中运算结果再压入strstack中作为参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/932612/201710/932612-20171023232328207-936316599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　程序输入输出，运行结果示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/932612/201710/932612-20171023232317816-1863476105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　源码分享：&lt;/p&gt;
&lt;p&gt;　　代码同步更新于  https://github.com/wylloong/TinyPrograms/blob/master/Coding%20Interviews/LISPGenerateParentheses.cpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stack&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;vector&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstring&amp;gt;

&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; chs[&lt;span&gt;512&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; error = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    gets_s(chs);  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gets(chs); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;old version&lt;/span&gt;
    std::&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str(chs);
    std::stack&lt;/span&gt;&amp;lt;std::&lt;span&gt;string&lt;/span&gt;&amp;gt; opstack;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; operations&lt;/span&gt;
    std::stack&amp;lt;std::&lt;span&gt;string&lt;/span&gt;&amp;gt; strstack;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; divided strings&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;&lt;span&gt; str.size();)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str[i] == &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        {
            i &lt;/span&gt;= i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str[i] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        {
            strstack.push(std::&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; spaceIndex = str.find(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;, i);
            std::&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; tmp = str.substr(i + &lt;span&gt;1&lt;/span&gt;, spaceIndex - i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            opstack.push(tmp);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; operation&lt;/span&gt;
            i =&lt;span&gt; spaceIndex;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (str[i] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        {
            std::&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; curOp =&lt;span&gt; opstack.top();
            opstack.pop();
            std::vector&lt;/span&gt;&amp;lt;std::&lt;span&gt;string&lt;/span&gt;&amp;gt; tmps; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; strs temp&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (strstack.top() != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                tmps.push_back(strstack.top());
                strstack.pop();
            }
            strstack.pop();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (curOp == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i&amp;lt;=tmps.size() - &lt;span&gt;1&lt;/span&gt;; ++&lt;span&gt;i)
                {
                    temp &lt;/span&gt;+=&lt;span&gt; atoi(tmps[i].c_str());
                }
                strstack.push(to_string(temp));
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sub&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (curOp == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sub&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tmps.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    temp &lt;/span&gt;= atoi(tmps[tmps.size() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;].c_str());
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = tmps.size() - &lt;span&gt;2&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; --&lt;span&gt;i)
                {
                    temp &lt;/span&gt;-=&lt;span&gt; atoi(tmps[i].c_str());
                }
                strstack.push(to_string(temp));
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mul&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (curOp == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mul&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tmps.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    temp &lt;/span&gt;= atoi(tmps[tmps.size() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;].c_str());
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = tmps.size() - &lt;span&gt;2&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; --&lt;span&gt;i)
                {
                    temp &lt;/span&gt;*=&lt;span&gt; atoi(tmps[i].c_str());
                }
                strstack.push(to_string(temp));
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; div&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (curOp == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tmps.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    temp &lt;/span&gt;= atoi(tmps[tmps.size() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;].c_str());
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = tmps.size() - &lt;span&gt;2&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; --&lt;span&gt;i)
                {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; data1 =&lt;span&gt; atoi(tmps[i].c_str());
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data1 == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        error &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        temp &lt;/span&gt;/=&lt;span&gt; data1;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (error)
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    strstack.push(to_string(temp));
            }
            &lt;/span&gt;++&lt;span&gt;i;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; substrs&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; get substring by ' ' or ')'&lt;/span&gt;
            auto index = str.find(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;, i);
            auto index2&lt;/span&gt;= str.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index &amp;lt;&lt;span&gt; index2)
            {
                strstack.push(str.substr(i, index &lt;/span&gt;-&lt;span&gt; i));
                i &lt;/span&gt;=&lt;span&gt; index;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                strstack.push(str.substr(i, index2 &lt;/span&gt;-&lt;span&gt; i));
                i &lt;/span&gt;=&lt;span&gt; index2;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (error)
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        cout &lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt; atoi(strstack.top().c_str());
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 23 Oct 2017 15:31:00 +0000</pubDate>
<dc:creator>DHUtoBUAA</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DHUtoBUAA/p/7719839.html</dc:identifier>
</item>
<item>
<title>go基础编程  day-2 - WrYcF</title>
<link>http://www.cnblogs.com/wuyongcong/p/7719549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyongcong/p/7719549.html</guid>
<description>&lt;h2&gt;Go的常亮&lt;/h2&gt;
&lt;p&gt;关键字： Const&lt;/p&gt;
&lt;p&gt;Go常亮的多个定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义常亮的关键字 const

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义多个常亮&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt;&lt;span&gt;(
    PI &lt;/span&gt;= &lt;span&gt;3.14&lt;/span&gt;&lt;span&gt;
    const1 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    const2 &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    const3 &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;   
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;全局变量的声明与赋值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; (
    name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    name1 &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    name2 &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    name3 &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般类型声明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;type (
    newType &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
    type1 float32
    type2 &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    type3 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Go的基本类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;布尔型：
    &lt;/span&gt;-&lt;span&gt; 长度 1字节
    &lt;/span&gt;- 取值范围： &lt;span&gt;true&lt;/span&gt;、&lt;span&gt;false&lt;/span&gt;
    - 注意事项： 不可以使用数字来代表true或false
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
整型： &lt;span&gt;int&lt;/span&gt;/&lt;span&gt;uint&lt;/span&gt;
     - 根据运行平台可能为32或64位
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
8位整型：  int8/&lt;span&gt;uint8
    &lt;/span&gt;-&lt;span&gt; 长度： 1字节
    &lt;/span&gt;- 取值范围：  -&lt;span&gt;128&lt;/span&gt;~&lt;span&gt;127&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;~&lt;span&gt;255&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
字节型： &lt;span&gt;byte&lt;/span&gt;(uint8别名)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
16位整型：   &lt;span&gt;int&lt;/span&gt;/&lt;span&gt;uint16
    &lt;/span&gt;-&lt;span&gt; 长度： 2字节
    &lt;/span&gt;- 取值范围：  -&lt;span&gt;32768&lt;/span&gt;~&lt;span&gt;32767&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;~&lt;span&gt;65535&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
32位整型：   int32(rune)   int32/&lt;span&gt;uint32
    &lt;/span&gt;-&lt;span&gt; 长度： 4字节
    &lt;/span&gt;- 取值范围： -&lt;span&gt;2&lt;/span&gt;^&lt;span&gt;64&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;~&lt;span&gt;2&lt;/span&gt;^&lt;span&gt;64&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;~&lt;span&gt;2&lt;/span&gt;^&lt;span&gt;64&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;64位整型：
    &lt;/span&gt;-&lt;span&gt; 长度 8字节
    &lt;/span&gt;- 取值范围： -&lt;span&gt;2&lt;/span&gt;^&lt;span&gt;64&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;~&lt;span&gt;2&lt;/span&gt;^&lt;span&gt;64&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;~&lt;span&gt;2&lt;/span&gt;^&lt;span&gt;64&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
浮点型： float32 /&lt;span&gt; float64
    &lt;/span&gt;- 长度：  &lt;span&gt;8&lt;/span&gt;/&lt;span&gt;8字符
    &lt;/span&gt;- 小数位：  精确到7/15小数位
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
复数类型：  complex64/&lt;span&gt;complex128
    &lt;/span&gt;- 长度：  &lt;span&gt;8&lt;/span&gt;/16字节
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
足够保存指针的32位或64位整数型：  uintptr
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他值类型：&lt;/span&gt;
    - array、 &lt;span&gt;struct&lt;/span&gt;、&lt;span&gt;string&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引用类型： &lt;/span&gt;
    -&lt;span&gt; slice、map、chan


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接口函数  ：   inteface

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数接口  ：   func&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类型零值：&lt;/p&gt;
&lt;p&gt;　　零值并不等于空值，而是当变量声明为某种来兴后的默认零值，通常情况下默认值为0，bool为false，string为空字符串。&lt;/p&gt;
&lt;p&gt;类型别名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;type(
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;   int8
    rune   int32
    文本   &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;   
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;别名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; a 文本
b &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好中国&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;零值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;   
)

func main() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a &lt;span&gt;int&lt;/span&gt;&lt;span&gt;
    fmt.Println(a)
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结果： 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;math包&lt;/h2&gt;
&lt;p&gt;math包可以检查类型是否超出范围&lt;/p&gt;
&lt;p&gt;math.Min   记录了一个最小值和一个最大值&lt;/p&gt;
&lt;p&gt;int型的最小值：&lt;/p&gt;
&lt;p&gt;math.MinInt8      int类型的最小值就会打印出来，    -128&lt;/p&gt;

&lt;h2&gt;类型声明&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;   
)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型的定义&lt;/span&gt;
&lt;span&gt;type (
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;  int8
    rune int32
    文本  &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;   
)

func main() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; a 文本
    a &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好中国&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    fmt.Println(a)
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在实际应用中最好还是不要使用中文，它有可能会引起一些不必要的错误。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;单个变量的声明与赋值 and 多个变量的声明与赋值&lt;/p&gt;
&lt;p&gt;单个变量： &lt;/p&gt;
&lt;p&gt;　　单个变量的声明格式：    var &amp;lt;变量名称&amp;gt; &amp;lt;变量类型&amp;gt;&lt;/p&gt;
&lt;p&gt;       变量的赋值的格式    ：  &amp;lt;变量名称&amp;gt; = &amp;lt;表达式&amp;gt;&lt;/p&gt;
&lt;p&gt;       变量声明的同时赋值  :   var &amp;lt;变量名称&amp;gt; &amp;lt;变量类型&amp;gt; = [表达式]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/940171/201710/940171-20171023232809457-1784363619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/940171/201710/940171-20171023232957801-700001311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多个变量 ： &lt;/p&gt;
&lt;p&gt;        全局变量的声明格式：   var &amp;lt;变量名称&amp;gt; &amp;lt;变量类型&amp;gt;&lt;/p&gt;
&lt;p&gt;        全局变量的声明不可以省略 var， 但可使用并行方式&lt;/p&gt;
&lt;p&gt;        所有变量都可以使用类型推断&lt;/p&gt;
&lt;p&gt;        局部变量不可以使用 var() 的方式简写，只能使用并行方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 常规方式&lt;/span&gt;
    aaa = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用并行方式以及类型推断&lt;/span&gt;
    w,y,c = &lt;span&gt;11&lt;/span&gt;,&lt;span&gt;22&lt;/span&gt;,&lt;span&gt;33&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;　ccc := 3 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不可以省略 var&lt;/span&gt;
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多个变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多个变量声明&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a,b,c,d &lt;span&gt;int&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多个变量赋值&lt;/span&gt;
a,b,c,d = &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多个变量声明的同时赋值&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; w,y,c &lt;span&gt;int&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略变量类型，由系统推断类型&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; w,y,c = &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多个变量的声明与赋值的最简的写法&lt;/span&gt;
w,y,c := &lt;span&gt;11&lt;/span&gt;,&lt;span&gt;22&lt;/span&gt;,&lt;span&gt;33&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

func main() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; var w,y,c int
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; w,y,c = 1,2,3&lt;/span&gt;
    w,y,c := &lt;span&gt;11&lt;/span&gt;,&lt;span&gt;22&lt;/span&gt;,&lt;span&gt;33&lt;/span&gt;&lt;span&gt;
    fmt.Println(w,y,c)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/940171/201710/940171-20171023232728879-726297934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/940171/201710/940171-20171023232741535-1729119264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;// 下划线可以表示不需要的元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package  main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

func main() {
    w,_,c :&lt;/span&gt;= &lt;span&gt;11&lt;/span&gt;,&lt;span&gt;22&lt;/span&gt;,&lt;span&gt;33&lt;/span&gt;&lt;span&gt;
    fmt.Println(w,c)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/940171/201710/940171-20171023232858426-691717547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;变量的类型转换&lt;/p&gt;
&lt;p&gt;Go中不存在隐式转换，所有类型转换必须显示声明。&lt;/p&gt;
&lt;p&gt;转换只能发生两种相互兼容的类型之间&lt;/p&gt;
&lt;p&gt;类型转换的格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;Value&amp;gt;[:] = &amp;lt;TypeOfValueA&amp;gt; (&amp;lt;ValueB&amp;gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

func main() {
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a float32 = &lt;span&gt;1.1&lt;/span&gt;&lt;span&gt;
   b :&lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;&lt;span&gt;(a)
   fmt.Println(b)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/940171/201710/940171-20171023232913238-1025187087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/940171/201710/940171-20171023232921738-805279953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Oct 2017 15:30:00 +0000</pubDate>
<dc:creator>WrYcF</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyongcong/p/7719549.html</dc:identifier>
</item>
<item>
<title>ES6的Iterator遍历器 - wangmeijian</title>
<link>http://www.cnblogs.com/wangmeijian/p/7719795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangmeijian/p/7719795.html</guid>
<description>&lt;p&gt;JS表示集合的对象主要有Array、Set、Object、Map，在以前，遍历它们需要使用2种不同的方法，而现在，JS提出了Iterator机制，可以给不同的数据结构提供统一的遍历方法，就是for…of。换句话说，只有部署了Iterator的数据才能用for…of遍历。&lt;/p&gt;
&lt;p&gt;Iterator的遍历过程是这样的：&lt;/p&gt;
&lt;p&gt;（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。&lt;/p&gt;
&lt;p&gt;（2）第一次调用指针对象的&lt;code&gt;next&lt;/code&gt;方法，可以将指针指向数据结构的第一个成员。&lt;/p&gt;
&lt;p&gt;（3）第二次调用指针对象的&lt;code&gt;next&lt;/code&gt;方法，指针就指向数据结构的第二个成员。&lt;/p&gt;
&lt;p&gt;（4）不断调用指针对象的&lt;code&gt;next&lt;/code&gt;方法，直到它指向数据结构的结束位置。&lt;/p&gt;
&lt;p&gt;每一次调用&lt;code&gt;next&lt;/code&gt;方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;done&lt;/code&gt;两个属性的对象。其中，&lt;code&gt;value&lt;/code&gt;属性是当前成员的值，&lt;code&gt;done&lt;/code&gt;属性是一个布尔值，表示遍历是否结束。&lt;/p&gt;
&lt;p&gt;ES6 规定，默认的 Iterator 接口部署在数据结构的&lt;code&gt;Symbol.iterator&lt;/code&gt;属性，或者说，一个数据结构只要具有&lt;code&gt;Symbol.iterator&lt;/code&gt;属性，就可以认为是“可遍历的”（iterable）。&lt;/p&gt;
&lt;p&gt;默认部署了Iterator的数据有&lt;/p&gt;
&lt;p&gt;-Array&lt;/p&gt;
&lt;p&gt;-Map&lt;/p&gt;
&lt;p&gt;-Set&lt;/p&gt;
&lt;p&gt;-String&lt;/p&gt;
&lt;p&gt;-&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot; target=&quot;_blank&quot;&gt;TypedArray&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;-arguments&lt;/p&gt;
&lt;p&gt;-NodeList 对象&lt;/p&gt;
&lt;p&gt;一个对象要被for…of遍历，必须部署Iterator，或者在其原型上部署Iterator，普通对象并没有部署Iterator，如果用for…of遍历，会抛出“not iterable”错误&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/664733/201710/664733-20171023224440504-209187826.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而，一个类似于数组的普通对象直接调用数组的Symbol.iterator，也是可以用for…of遍历的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let iterable =&lt;span&gt; {
  &lt;/span&gt;0: 'a'&lt;span&gt;,
  &lt;/span&gt;1: 'b'&lt;span&gt;,
  &lt;/span&gt;2: 'c'&lt;span&gt;,
  length: &lt;/span&gt;3&lt;span&gt;,
  [Symbol.iterator]: Array.prototype[Symbol.iterator]
};
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of iterable) {
  console.log(item); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'a', 'b', 'c'&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是，“类似于数组”这个条件，不仅仅要以数字为索引，length属性也必不可少&lt;/p&gt;
&lt;p&gt;两个条件中，任何一条不满足（就是普通对象），调用数组的Symbol.iterator是行不通的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/664733/201710/664733-20171023225819254-2034739773.jpg&quot; alt=&quot;&quot; width=&quot;440&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么普通对象到底要怎样才能被for…of遍历？&lt;/p&gt;
&lt;p&gt;一是利用Object.keys得到对象的键名然后遍历这个数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt;&lt;span&gt; key of Object.keys(someObject)) {
  console.log(key &lt;/span&gt;+ ': ' +&lt;span&gt; someObject[key]);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Iterator的遍历过程看着像Generator，Generator可以很简单就实现Iterator接口，所以第二种方法就是利用Generator方法将对象包装一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;*&lt;span&gt; entries(obj) {
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let key of Object.keys(obj)) {
    yield [key, obj[key]];
  }
}

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let [key, value] of entries(obj)) {
  console.log(key, &lt;/span&gt;'-&amp;gt;'&lt;span&gt;, value);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;总结参考：&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/iterator&quot; target=&quot;_blank&quot;&gt;http://es6.ruanyifeng.com/#docs/iterator&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Oct 2017 15:24:00 +0000</pubDate>
<dc:creator>wangmeijian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangmeijian/p/7719795.html</dc:identifier>
</item>
<item>
<title>Java 递归调用 recursive  给一个参数 返回一大堆 - 三目鸟</title>
<link>http://www.cnblogs.com/sanmubird/p/7719759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanmubird/p/7719759.html</guid>
<description>&lt;p&gt;需求: 需要组装成对象多层嵌套式的 json字符串; &lt;/p&gt;
&lt;p&gt;想到使用 递归来完成这个多层嵌套: &lt;/p&gt;
&lt;p&gt;憋了四个小时,终于写出来了;&lt;/p&gt;
&lt;p&gt;先看效果: &lt;/p&gt;
&lt;p&gt;数据库中的数据:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1029076/201710/1029076-20171023224806848-22383996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拼装后的效果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;107&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[
    EmpVO{
        ename&lt;/span&gt;='孙老三1'&lt;span&gt;,
        empno&lt;/span&gt;=10&lt;span&gt;,
        mgr&lt;/span&gt;=0&lt;span&gt;,
        subordinates&lt;/span&gt;=&lt;span&gt;[
            EmpVO{
                ename&lt;/span&gt;='KING'&lt;span&gt;,
                empno&lt;/span&gt;=7839&lt;span&gt;,
                mgr&lt;/span&gt;=10&lt;span&gt;,
                subordinates&lt;/span&gt;=&lt;span&gt;[
                    EmpVO{
                        ename&lt;/span&gt;='JONES'&lt;span&gt;,
                        empno&lt;/span&gt;=7566&lt;span&gt;,
                        mgr&lt;/span&gt;=7839&lt;span&gt;,
                        subordinates&lt;/span&gt;=&lt;span&gt;[
                            EmpVO{
                                ename&lt;/span&gt;='SCOTT'&lt;span&gt;,
                                empno&lt;/span&gt;=7788&lt;span&gt;,
                                mgr&lt;/span&gt;=7566&lt;span&gt;,
                                subordinates&lt;/span&gt;=&lt;span&gt;[
                                    EmpVO{
                                        ename&lt;/span&gt;='ADAMS'&lt;span&gt;,
                                        empno&lt;/span&gt;=7876&lt;span&gt;,
                                        mgr&lt;/span&gt;=7788&lt;span&gt;,
                                        subordinates&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                                    }
                                ]
                            },
                            EmpVO{
                                ename&lt;/span&gt;='FORD'&lt;span&gt;,
                                empno&lt;/span&gt;=7902&lt;span&gt;,
                                mgr&lt;/span&gt;=7566&lt;span&gt;,
                                subordinates&lt;/span&gt;=&lt;span&gt;[
                                    EmpVO{
                                        ename&lt;/span&gt;='SMITH'&lt;span&gt;,
                                        empno&lt;/span&gt;=7369&lt;span&gt;,
                                        mgr&lt;/span&gt;=7902&lt;span&gt;,
                                        subordinates&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                                    }
                                ]
                            }
                        ]
                    },
                    EmpVO{
                        ename&lt;/span&gt;='BLAKE'&lt;span&gt;,
                        empno&lt;/span&gt;=7698&lt;span&gt;,
                        mgr&lt;/span&gt;=7839&lt;span&gt;,
                        subordinates&lt;/span&gt;=&lt;span&gt;[
                            EmpVO{
                                ename&lt;/span&gt;='ALLEN'&lt;span&gt;,
                                empno&lt;/span&gt;=7499&lt;span&gt;,
                                mgr&lt;/span&gt;=7698&lt;span&gt;,
                                subordinates&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                            },
                            EmpVO{
                                ename&lt;/span&gt;='WARD'&lt;span&gt;,
                                empno&lt;/span&gt;=7521&lt;span&gt;,
                                mgr&lt;/span&gt;=7698&lt;span&gt;,
                                subordinates&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                            },
                            EmpVO{
                                ename&lt;/span&gt;='MARTIN'&lt;span&gt;,
                                empno&lt;/span&gt;=7654&lt;span&gt;,
                                mgr&lt;/span&gt;=7698&lt;span&gt;,
                                subordinates&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                            },
                            EmpVO{
                                ename&lt;/span&gt;='TURNER'&lt;span&gt;,
                                empno&lt;/span&gt;=7844&lt;span&gt;,
                                mgr&lt;/span&gt;=7698&lt;span&gt;,
                                subordinates&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                            },
                            EmpVO{
                                ename&lt;/span&gt;='JAMES'&lt;span&gt;,
                                empno&lt;/span&gt;=7900&lt;span&gt;,
                                mgr&lt;/span&gt;=7698&lt;span&gt;,
                                subordinates&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                            }
                        ]
                    },
                    EmpVO{
                        ename&lt;/span&gt;='CLARK'&lt;span&gt;,
                        empno&lt;/span&gt;=7782&lt;span&gt;,
                        mgr&lt;/span&gt;=7839&lt;span&gt;,
                        subordinates&lt;/span&gt;=&lt;span&gt;[
                            EmpVO{
                                ename&lt;/span&gt;='MILLER'&lt;span&gt;,
                                empno&lt;/span&gt;=7934&lt;span&gt;,
                                mgr&lt;/span&gt;=7782&lt;span&gt;,
                                subordinates&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                            }
                        ]
                    }
                ]
            }
        ]
    },
    EmpVO{
        ename&lt;/span&gt;='陈老五1'&lt;span&gt;,
        empno&lt;/span&gt;=20&lt;span&gt;,
        mgr&lt;/span&gt;=0&lt;span&gt;,
        subordinates&lt;/span&gt;=&lt;span&gt;[
            EmpVO{
                ename&lt;/span&gt;='1'&lt;span&gt;,
                empno&lt;/span&gt;=200&lt;span&gt;,
                mgr&lt;/span&gt;=20&lt;span&gt;,
                subordinates&lt;/span&gt;=&lt;span&gt;[
                    EmpVO{
                        ename&lt;/span&gt;='钱老二'&lt;span&gt;,
                        empno&lt;/span&gt;=2000&lt;span&gt;,
                        mgr&lt;/span&gt;=200&lt;span&gt;,
                        subordinates&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                    }
                ]
            }
        ]
    },
    EmpVO{
        ename&lt;/span&gt;='zas1'&lt;span&gt;,
        empno&lt;/span&gt;=30&lt;span&gt;,
        mgr&lt;/span&gt;=0&lt;span&gt;,
        subordinates&lt;/span&gt;=&lt;span&gt;[
            EmpVO{
                ename&lt;/span&gt;='陈生'&lt;span&gt;,
                empno&lt;/span&gt;=300&lt;span&gt;,
                mgr&lt;/span&gt;=30&lt;span&gt;,
                subordinates&lt;/span&gt;=&lt;span&gt;[
                    EmpVO{
                        ename&lt;/span&gt;='李四'&lt;span&gt;,
                        empno&lt;/span&gt;=3000&lt;span&gt;,
                        mgr&lt;/span&gt;=300&lt;span&gt;,
                        subordinates&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                    }
                ]
            }
        ]
    }
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上代码: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RecursiveDemo {

    EmpService service &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmpService();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException, ClassNotFoundException {

        EmpVO emp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmpVO();
        RecursiveDemo rd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RecursiveDemo();
        List&lt;/span&gt;&amp;lt;EmpVO&amp;gt; l = rd.recursive21(0&lt;span&gt;);
        System.out.println(l);
    }

    List&lt;/span&gt;&amp;lt;EmpVO&amp;gt; recursive21(&lt;span&gt;int&lt;/span&gt; mgr) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException, ClassNotFoundException {
        List&lt;/span&gt;&amp;lt;EmpVO&amp;gt; l = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;EmpVO&amp;gt; subordinates =&lt;span&gt; service.getEmpsByMgr(mgr);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subordinates != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; subordinates.size() &amp;gt; 0&lt;span&gt;) {
            l &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;EmpVO&amp;gt;&lt;span&gt;();
            List&lt;/span&gt;&amp;lt;EmpVO&amp;gt; list = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (EmpVO empvo : subordinates) {
                list &lt;/span&gt;=&lt;span&gt; recursive21(empvo.getEmpno());
                empvo.setSubordinates(list);
                l.add(empvo);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; l;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 很有意思的是: 参数和返回结果:&lt;/p&gt;
&lt;p&gt;我先后尝试了  : 参数是 emp  返回结果是 emp  ; 参数是 list 返回结果是 list  ;   参数是emp 返回结果是list ; 终于后来又尝试 参数 int  返回结果list ; &lt;/p&gt;
&lt;p&gt;从我对参数和返回结果的预设 可以看出: &lt;/p&gt;
&lt;p&gt;开始时 我的理解时:  最终的目标是返回一个对象 ;  所以 返回结果类型是 对象; &lt;/p&gt;
&lt;p&gt;又参考 dom4j 遍历 xml 文档 ; 觉得 返回应该是一个list ; &lt;/p&gt;
&lt;p&gt;对传入参数的理解 : 刚开始也是不对的 ; 认为可能是 list 或者 对象 ;&lt;/p&gt;
&lt;p&gt;后来 又 参考 dom4j 遍历 xml 文档 : 觉得 参数可能不是一个直接的, 而是一个间接的 ;&lt;/p&gt;
&lt;p&gt;综上所述: &lt;/p&gt;
&lt;p&gt; 递归 最常用的形式可能就是 :  给一个 返回一大堆 ; &lt;/p&gt;
&lt;p&gt;如: Java 递归遍历文件夹; &lt;/p&gt;
&lt;p&gt;如: dom4j递归遍历xml文件;&lt;/p&gt;
&lt;p&gt;再问一个问题:  这种递归调用 可以 使用 尾递归 优化么?  &lt;/p&gt;
&lt;p&gt;不可以 : 遍历的缘故 .&lt;/p&gt;

</description>
<pubDate>Mon, 23 Oct 2017 15:12:00 +0000</pubDate>
<dc:creator>三目鸟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanmubird/p/7719759.html</dc:identifier>
</item>
<item>
<title>UVW源码漫谈（四） - bearyin</title>
<link>http://www.cnblogs.com/yxfangcs/p/7709223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yxfangcs/p/7709223.html</guid>
<description>&lt;p&gt;十一假期后就有点懒散，好长时间都没想起来写东西了。另外最近在打LOL的S赛。接触LOL时间不长，虽然平时玩的比较少，水平也相当菜，但是像这种大型的赛事有时间还是不会错过的。主要能够感受到选手们对竞技的激情，对瞬息万变的战局的应变，非常精彩。KeKe～～。&lt;/p&gt;
&lt;p&gt;这一篇主要对UVW的源码讨论来收个尾，就介绍一下项目中其他的一些好玩的东西，稍微丰富一下知识。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、模版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前说了很多东西，但是都把它给忽略了，对于C++的模版，很多人对此有看法，说它难以理解，编写困难等等。&lt;/p&gt;
&lt;p&gt;我们都知道，模版也是C++多态的一种，属于编译期多态，也就是说C++把很多运行期的工作加到编译期了，你的代码保持了在语言层面的抽象层次。然而实际上编译器在编译时却对同类型模版的使用进行了特化。所以相比较运行时的多态，模版的运行性能是更好的，但是编译的时间可能就稍长了一些。&lt;/p&gt;
&lt;p&gt;虽然那些对模版的看法都讲的过去，但是模版在应用中所带来的作用是相当大的。举一个最简单的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
std::shared_ptr&amp;lt;uvw::TcpHandle&amp;gt; tcp = loop.resource&amp;lt;uvw::TcpHandle&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是我们项目中一个创建TcpHandle的语句，如果我们按照一般C的思路，写出来的代码很可能是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
TcpHandle* tcp = loop.resource(type);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; OK，看上去很正常，但是暴露了很多问题，这个resource函数的原型应该是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;* loop::resource(&lt;span&gt;int&lt;/span&gt; type); 或者 Handle* loop::resource(int type);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它肯定是返回void*或者Handle这个基类的指针，但是你只能通过你对代码的理解和type的值来判定，它返回的是TcpHandle*类型。万一我不小心把返回类型写成了UdpHandle*，它同样继承自Handle类，C++是没有对此的检测的。那这时候模版的价值就显示出来了，它可以直接根据模版的类型，对返回的类型起到限制作用。避免了上面情况的出现。&lt;/p&gt;
&lt;p&gt;再比如我们在 &lt;a href=&quot;http://www.cnblogs.com/yxfangcs/p/7541842.html&quot; target=&quot;_blank&quot;&gt;第二篇&lt;/a&gt; 中讲static的时候，没有模版就不能实现那样的功能。&lt;/p&gt;
&lt;p&gt;有些朋友在编码的时候很少或者根本就不用模版，顶多在用一些容器的时候。或许因为就算用模版，也会造成上面提到的一些负面影响。所以很多人知道模版，但是不常使用，不常使用的东西往往也会忘的非常快，造成这样一个不好的循环。如果模版可以解决切实的编码问题，大胆一点用就是了，不要怕用错，错了才能更好的用嘛！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、enum &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;enum就是枚举类型，但是C++11对enum有扩展。先看这段代码：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;fs.hpp　　55 ~ 69&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UVDirentTypeT: std::underlying_type_t&amp;lt;uv_dirent_type_t&amp;gt;&lt;span&gt; {
     UNKNOWN &lt;/span&gt;=&lt;span&gt; UV_DIRENT_UNKNOWN,
     FILE &lt;/span&gt;=&lt;span&gt; UV_DIRENT_FILE,    
      。。。。。。
 };

&lt;/span&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UVCopyFileFlags: &lt;span&gt;int&lt;/span&gt;&lt;span&gt; {
    EXCL &lt;/span&gt;=&lt;span&gt; UV_FS_COPYFILE_EXCL
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;enum和enum class的区别，有下面几点：&lt;/p&gt;
&lt;p&gt;1、如果在同一个头文件中，有下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; HandleType{TCP,UDP,POLL,FS};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; StreamType{TCP,UDP,POLL,FS};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这是编译不通过的，因为本身enum就相当于 #define 的一个集合，名字是不能一样的。但是用 enum class 来写，则是OK的，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HandleType{TCP,UDP,POLL,FS};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StreamType{TCP,UDP,POLL,FS};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是使用的时候是需要加上作用域的。&lt;/p&gt;
&lt;p&gt;2、我们都知道enum中的每个元素都是可以直接转为int型的（对于不同的编译器，可能类型不一样）。但是 enum class 是不可以的。比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; HandleType{TCP,UDP,POLL,FS};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StreamType{TCP,UDP,POLL,FS};
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; handleType =&lt;span&gt; TCP;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; streanType = StreamType::TCP;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第5行就会产生编译错误，enum很容易被隐式的转为int，在某种意义上，是enum的一种缺陷，所以enum class解决了这个问题.&lt;/p&gt;
&lt;p&gt;另外enum class的元素是可以指定类型的，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; smallenum: int16_t
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    a,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    b,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    c
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; altitude: &lt;span&gt;char&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{ 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      high=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      low=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，这个 enum class中的 “class” 是可以省略的。那如果我有需求，要将enum class转为需要的类型怎么办？比如上面的两个例子，可以这样搞：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; smallenum s =&lt;span&gt; smallenum::a;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; int16_t i = static_cast&amp;lt;int16_t&amp;gt;&lt;span&gt;(s);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; altitude e =&lt;span&gt; altitude::high;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; c = static_cast&amp;lt;&lt;span&gt;char&lt;/span&gt;&amp;gt;(e);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，在switch 。。。 case。。。语句中是可以直接用的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到这里源码中关于语法一类的、使用的一些技术和方法就介绍到这里。这些东西其实也不难，也许大家都知道，不知道的通过介绍也有一些了解了，主要是让大家在看源码的时候可以舒服点，排除一些障碍。&lt;/p&gt;
&lt;p&gt;有些看官可能对项目中的代码的书写形式，使用方式等很多东西不是很习惯，但是我想说这应该就是现代C++的一个编码模式。你可能在一个项目中看不见一个指针，看不见一个强转，使用大量的模版，使用很多限制关键字，类实现和定义放在同一个文件，如同java一般，还有其他很多看不习惯的地方。但是当你熟悉了，明白了，习惯了，说不定效率就上升了。其实这些说到底还是要提升对C++的认知。&lt;/p&gt;

&lt;p&gt;之后我会再找一些在比较好的项目来和大家分享，比如架构，算法等方面的。由于水平有限，博客中若有错误，烦请指正。&lt;/p&gt;

</description>
<pubDate>Mon, 23 Oct 2017 15:06:00 +0000</pubDate>
<dc:creator>bearyin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yxfangcs/p/7709223.html</dc:identifier>
</item>
</channel>
</rss>