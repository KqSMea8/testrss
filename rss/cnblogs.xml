<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Elasticsearch之删除索引 - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/9493576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/9493576.html</guid>
<description>&lt;p&gt;&lt;span&gt;   1、 #删除指定索引&lt;/span&gt;&lt;br/&gt;    [root@elk-node1 local]# curl -XDELETE -u elastic:changeme http://localhost:9200/acc-apply-2018.08.09&lt;br/&gt;    {&quot;acknowledged&quot;:true}&lt;br/&gt;&lt;span&gt;    2、#删除多个指定索引，中间用逗号隔开&lt;/span&gt;&lt;br/&gt;    [root@elk-node1 local]# curl -XDELETE -u elastic:changeme http://localhost:9200/acc-apply-2018.08.09,acc-apply-2018.08.10&lt;br/&gt;&lt;span&gt;    3、#模糊匹配删除&lt;/span&gt;&lt;br/&gt;    [root@pcidta-gitlab ~]# curl -XDELETE -u elastic:changeme http://localhost:9200/acc-apply-*&lt;br/&gt;    {&quot;acknowledged&quot;:true}&lt;br/&gt;&lt;span&gt;    4、#使用通配符,删除所有的索引&lt;/span&gt;&lt;br/&gt;     curl -XDELETE http://localhost:9200/_all&lt;br/&gt;     或 curl -XDELETE http://localhost:9200/*&lt;br/&gt;    _all ,* 通配所有的索引&lt;br/&gt;    通常不建议使用通配符，误删了后果就很严重了，所有的index都被删除了&lt;br/&gt;    禁止通配符为了安全起见，可以在elasticsearch.yml配置文件中设置禁用_all和*通配符&lt;br/&gt;    action.destructive_requires_name = true&lt;br/&gt;    这样就不能使用_all和*了&lt;/p&gt;
</description>
<pubDate>Fri, 17 Aug 2018 07:34:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<og:description>1、 #删除指定索引 [root@elk-node1 local]# curl -XDELETE -u elastic:changeme http://localhost:9200/acc-apply</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dev0ps/p/9493576.html</dc:identifier>
</item>
<item>
<title>unity游戏开发之entitas框架 - 禹泽鹏鹏</title>
<link>http://www.cnblogs.com/IAMTOM/p/9493272.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IAMTOM/p/9493272.html</guid>
<description>&lt;div readability=&quot;98.598962404946&quot;&gt;
&lt;p&gt;&lt;span&gt;框架介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;entitas是一个超快、超轻量的c# Entity-Component-System (ECS)框架，专门为Unity引擎设计。提供内部缓存和高速的组件访问，经过精心设计，可以在垃圾收集环境中最优地工作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;框架解析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要理解框架，就需要知道这四种概念，分别是：Entiy实体、Context环境、Group组、Collector收集器。如图，在一个Context中，会有很多Entity，每个Entity都拥有若干Component，Component中只有数据，而Group是拥有相同Component的Entity集合，用于快速查找拥有特定属性的Entity。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Entity&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Entity&lt;span&gt;实体是保存数据的容器，用于表示应用程序中的某些对象。可以以IComponent的形式从实体中添加、替换或删除数据。实体有相应的事件来让你知道组件是否被添加、替换或删除。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Context&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Context环境是用来创建和销毁entity的工厂，用它来过滤感兴趣的entity。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Group&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Group&lt;span&gt;支持对Context中的实体进行超级快速过滤。当实体发生变化时，它们会不断更新，并且可以立即返回实体组。假设有数千个实体，而你只想要那些具有PositionComponent的实体——只需为这个Group询问Context，就可以很方便的获得结果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Collector&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Collector &lt;span&gt;收集器提供了一种随时间变化对组中的更改作出反应的简单方法。它能很方便的汇总处理特定的Entity。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;基本使用&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Group&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Group总是最新的，并且包含与指定匹配程序匹配的所有实体。每个环境都有一个特定的匹配器类型——如果在你的游戏环境中寻找实体(比如游戏实体)，你需要使用&lt;/span&gt;GameMatcher&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var context = contexts.game;

var movables = context.GetGroup(GameMatcher.Movable);
var count = movables.count; // count is 0, the group is empty

var entity1 = context.CreateEntity();
entity1.isMovable = true;
var entity2 = context.CreateEntity();
entity2.IsMovable = true;

count = movables.count; // count is 2, the group contains the entity1 and entity2

// GetEntities() always provides an up to date list
var movableEntities = movables.GetEntities();
foreach (var e in movableEntities) {
    // Do sth
}

entity1.Destroy();
entity2.Destroy();

count = movables.count; // count is 0, the group is empty
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Matcher&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Matcher匹配器由代码生成器生成，可以组合。匹配器通常用于从感兴趣的上下文中获取实体组。需要在匹配器前加上你感兴趣的上下文名称(例如GameMatcher, InputMatcher等)。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var matcher = GameMatcher.Movable;

GameMatcher.AllOf(GameMatcher.Movable, GameMatcher.Position);

GameMatcher.AnyOf(GameMatcher.Move, GameMatcher.Position);

GameMatcher
    .AllOf(GameMatcher.Position)
    .AnyOf(GameMatcher.Health, GameMatcher.Interactive)
    .NoneOf(GameMatcher.Animating);
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Systems&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;entitas中有四种Systems：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;IInitializeSystem:&lt;/span&gt; 只执行一次 (&lt;span&gt;system.Initialize()&lt;/span&gt;)&lt;/li&gt;
&lt;li&gt;&lt;span&gt;IExecuteSystem:&lt;/span&gt; 每帧执行 (&lt;span&gt;system.Execute()&lt;/span&gt;)&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ICleanupSystem:&lt;/span&gt; &lt;span&gt;在其他系统完成后每一帧执行&lt;/span&gt;(system.Cleanup())&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ReactiveSystem:&lt;/span&gt; &lt;span&gt;当观察的group改变时执行&lt;/span&gt;(&lt;span&gt;system.Execute(Entity[])&lt;/span&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;div readability=&quot;7.5&quot;&gt;用法实例如下：
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public class MoveSystem : IExecuteSystem {
    public void Execute() {
        // Do sth
    }
}

public class CreateLevelSystem : IInitializeSystem {
    public void Initialize() {
        // Do sth
    }
}

public class RenderPositionSystem: ReactiveSystem&amp;lt;GameEntity&amp;gt; {

    public RenderPositionSystem(Contexts contexts) : base(contexts.Game) {
        
    }

    protected override Collector&amp;lt;GameEntity&amp;gt; GetTrigger(IContext&amp;lt;GameEntity&amp;gt; context) {
        return context.CreateCollector(GameMatcher.Position);
    }

    protected override bool Filter(GameEntity entity) {
        // check for required components (here it is position and view)
        return entity.hasPosition &amp;amp;&amp;amp; entity.hasView;
    }

    protected override void Execute(List&amp;lt;GameEntity&amp;gt; entities) {
        foreach (var e in entities) {
            // do stuff to the matched entities
            e.view.gameObject.transform.position = e.position.position;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;最后需要注意的是，需要&lt;span&gt;创建一个管理System的System，因为一个游戏开发过程中，不可能只有一个System的，为了方便管理，便有了【Feature】System的概念。这个类要继承Feature，在构造器里Add所有System进去。Feature就像一个管理System的SystemManager。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var systems = new Systems(contexts)
    .Add(new CreateLevelSystem(contexts))
    .Add(new UpdateBoardSystem(contexts))
    .Add(new MoveSystem(contexts))
    .Add(new RenderPositionSystem(contexts));

// Call once on start
systems.Initialize();

// Call every frame
systems.Execute();
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;System详解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;总共有上述四种Systems，在实际开发中，需要&lt;span&gt;为应用程序中的每个任务或行为创建systems，并按照定义的顺序执行它们。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;InitializeSystem&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;InitializeSystem&lt;span&gt;在程序开始时运行一次。它实现接口IInitializeSystem，后者定义了Initialize()方法。这是您设置初始游戏状态的地方，类似于Unity的Start()方法。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Entitas;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyInitSystem : IInitializeSystem {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Initialize() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialization code here&lt;/span&gt;
&lt;span&gt;    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;ExecuteSystem&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ExecuteSystem&lt;span&gt;每帧执行一次。它实现接口IExecuteSystem，接口定义了Execute()方法。这是放置需要每帧执行的代码的地方，类似于Unity的Update()方法。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Entitas;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyExecSystem : IExecuteSystem {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Execute() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; per-frame code goes here&lt;/span&gt;
&lt;span&gt;    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;CleanupSystem&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在所有其他systems完成它们的工作之后，&lt;/span&gt;&lt;span&gt;CleanupSystem&lt;/span&gt;&lt;span&gt;在每个帧的末尾运行。它实现了接口ICleanupSystem，接口定义了方法Cleanup()。如果想要创建只存在于一帧的实体，那么这个工具非常有用。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyCleanupSystem : ICleanupSystem {
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Cleanup() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cleanup code here 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; runs after every execute and reactive system has completed&lt;/span&gt;
&lt;span&gt;    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;ReactiveSystem&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ReactiveSystem&lt;/span&gt;&lt;span&gt;在底层是使用了group观察者。通过它，你可以轻而易举的拥有发生改变的你感兴趣的实体。假设你在战场上有100个战斗单位，但是只有10个单位改变了他们的位置。不使用普通的IExecuteSystem，根据位置更新所有100个视图，您可以使用IReactiveSystem，它只更新10个更改单元的视图。所以效率很高。与其他system不同，ReactiveSystem继承自基类ReactiveSystem&lt;/span&gt;，而不是实现接口。entitas为游戏中的每个context生成一个实体类型。如果您的context是&lt;span&gt;Game, GameState and Input&lt;/span&gt;，那么将生成三种类型:GameEntity、GameStateEntity和InputEntity。&lt;span&gt;ReactiveSystem&lt;/span&gt;要求提供它们响应的特定context和关联实体类型。&lt;span&gt;基类定义了一些必须实现的抽象方法。首先，须创建一个构造函数，该构造函数调用基构造函数并为其提供适当的context。必须重写3个方法:GetTrigger()返回一个Collector收集器，它告诉system要响应什么事件。Filter()对collector收集器返回的实体执行最后检查，确保它们在对每个实体调用Execute()之前都附加了所需的组件。Execute()是游戏逻辑的主要位置。需要注意的是:不应该尝试将ReactiveSystem&lt;/span&gt;和ExecuteSystem&lt;span&gt;相结合，只需将ReactiveSystem看作是&lt;/span&gt;ExecuteSystem&lt;span&gt;的一种特殊情况。所有其他接口都可以混合使用。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Entitas;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyReactiveSystem : ReactiveSystem&amp;lt;MyContextEntity&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyReactiveSystem (Contexts contexts) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(contexts.MyContext) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pass the context of interest to the base constructor&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; ICollector&amp;lt;MyContextEntity&amp;gt; GetTrigger(IContext&amp;lt;MyContextEntity&amp;gt;&lt;span&gt; context) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; specify which component you are reacting to
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return context.CreateCollector(MyContextMatcher.MyComponent);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; you can also specify which type of event you need to react to
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return context.CreateCollector(MyContextMatcher.MyComponent.Added()); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the default
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return context.CreateCollector(MyContextMatcher.MyComponent.Removed());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return context.CreateCollector(MyContextMatcher.MyComponent.AddedOrRemoved());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; combine matchers with AnyOf and AllOf
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return context.CreateCollector(LevelMatcher.AnyOf(MyContextMatcher.Component1, MyContextMatcher.Component2));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use multiple matchers
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return context.CreateCollector(LevelMatcher.MyContextMatcher, MyContextMatcher.Component2.Removed());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; or any combination of all the above
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return context.CreateCollector(LevelMatcher.AnyOf(MyContextMatcher.Component1, MyContextMatcher.Component2),
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                                LevelMatcher.Component3.Removed(),
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                                LevelMatcher.AllOf(MyContextMatcher.C4, MyContextMatcher.C5).Added());&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Filter(MyContextEntity entity) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; check for required components&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Execute(List&amp;lt;MyContextEntity&amp;gt;&lt;span&gt; entities) {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; e &lt;span&gt;in&lt;/span&gt;&lt;span&gt; entities) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do stuff to the matched entities&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;要响应来自多个context的实体的更改，需要使用&lt;/span&gt;multi-reactive system（&lt;span&gt;多响应系统）。首先，需要声明一个接口，该接口将组合来自具有相同组件的多个context的实体，并且需要通过部分类为实体类实现该接口。然后创建从MultiReactiveSystem继承的系统，并传递新接口。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; PositionViewEntity : IEntity, IPosition, IView {}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EnemyEntity : PositionViewEntity {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProjectileEntity : PositionViewEntity {}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ViewSystem : MultiReactiveSystem&amp;lt;PositionViewEntity, Contexts&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ViewSystem(Contexts contexts) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(contexts) {}

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; ICollector[] GetTrigger(Contexts contexts) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ICollector[] {
            contexts.Enemy.CreateCollector(EnemyMatcher.Position),
            contexts.Projectile.CreateCollector(ProjectileMatcher.Position)
        };
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Filter(PositionViewEntityentity) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; entity.hasView &amp;amp;&amp;amp;&lt;span&gt; entity.hasPosition;
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Execute(List&amp;lt;PositionViewEntity&amp;gt;&lt;span&gt; entities) {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; e &lt;span&gt;in&lt;/span&gt;&lt;span&gt; entities) {
            e.View.transform.position &lt;/span&gt;=&lt;span&gt; e.Position.value;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Features&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;entitas为提供了Features来组织你的system。使用Features将相关system组合在一起。这有一个额外的好处，就是可以在Unity层次结构中为你的system分离可视化调试对象。现在可以在逻辑组中检查它们，而不是一次检查所有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Feature还可以帮助你在项目中执行更广泛的范例规则。功能的执行顺序由添加它们的顺序决定，把你的系统分成InputSystems: Feature, GameLogicSystems: Feature和RenderingSystems: Feature，然后按照这个顺序初始化它们，确保游戏逻辑不会被干扰。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Feature要求实现构造函数。使用Add()方法向Feature添加system。这里添加它们的顺序定义了它们在运行时的执行顺序。可以在GameController中使用Feature将systems组实例化。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Entitas;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InputSystems : Feature
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; InputSystems(Contexts contexts) : &lt;span&gt;base&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Input Systems&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; order is respected &lt;/span&gt;
        Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmitInputSystem(contexts));
        Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProcessInputSystem(contexts));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;在你的GameController中：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Systems createSystems(Contexts contexts) {

     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; order is respected&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Feature(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Systems&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Input executes first&lt;/span&gt;
         .Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputSystems(contexts))
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update &lt;/span&gt;
         .Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GameBoardSystems(contexts))
         .Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GameStateSystems(contexts))
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Render executes after game logic &lt;/span&gt;
         .Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ViewSystems(contexts))
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Destroy executes last&lt;/span&gt;
         .Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DestroySystem(contexts));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;entitas中的Attributes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Code Generator（&lt;span&gt;代码生成器）目前支持与类、接口和结构一起使用的以下特性：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;[Context]&lt;/span&gt;: &lt;span&gt;可以使用此特性使组件仅在指定的context中可用&lt;/span&gt;;例如 &lt;span&gt;[MyContextName]&lt;/span&gt;, &lt;span&gt;[Enemies]&lt;/span&gt;, &lt;span&gt;[UI]&lt;/span&gt;....&lt;span&gt;提高内存占用。它还可以创建组件。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[Unique]&lt;/span&gt;: &lt;span&gt;代码生成器将提供额外的方法，以确保最多存在一个具有该组件的实体。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[FlagPrefix]&lt;/span&gt;:&lt;span&gt;仅可用于支持标记组件的自定义前缀。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[PrimaryEntityIndex]&lt;/span&gt;: &lt;span&gt;可用于将实体限制为唯一的组件值。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[EntityIndex]&lt;/span&gt;: &lt;span&gt;可用于搜索具有组件值的实体。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[CustomComponentName]&lt;/span&gt;: &lt;span&gt;为一个类或接口生成具有不同名称的多个组件。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[DontGenerate]&lt;/span&gt;: &lt;span&gt;代码生成器不会使用此属性处理组件。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[Cleanup]&lt;/span&gt;: &lt;span&gt;代码生成器将生成删除组件或销毁实体的系统。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span&gt;Code Generator代码生成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;code generator是entitas框架的一大特色，可以让我们在开发时少写一些代码，在unity编辑器project面板中，&lt;span&gt;Generated目录下都是自动生成的文件，不要去修改它们。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官方文档中介绍说可以自定义以及扩展code generator，让codegenerator更好的为我们服务，这一点我暂时没有去尝试。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;个人看法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以下是个人愚见，如有错误欢迎指正。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;遵循这个框架的规则去写代码，代码结构清晰。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ECS这种模式，耦合度就很低，所有的游戏物体都是组件的组合而已，可扩展性强，通过合理组合component就能配置出一个新的游戏物体。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;很方便的管理所有实体状态，entitas提供了类似状态机的功能，当感兴趣的某个属性发生变化时，能在System中很方便的做出响应，不管什么状态，都能很方便的做出对应处理。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;unity本身的开发模式就类似ECS，unity2018更是推出了最新的ECS框架，entitas很符合这种开发模式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;entitas自开源以来，一直在更新维护，并受到了unity官方的认可，在unite大会上都有提到。所以，这个框架还是很靠谱的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;国内资料少，上手难度高。国内用这个框架开发的特别少，遇到问题需要自己爬坑。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不适合小项目。小项目用entitas反而麻烦&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;entitas更新太快，官方wiki文档更新没有跟上，比如，我在看官方Demo-MatchOne的时候，有个Event的Attribute， wiki上暂时还没有这个的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;代码热更方面是个问题， entitas基本对unity开发定了一套完整的规则，特别是有Code Generate，如果项目发布后想要更新加入新的代码会很麻烦，官方对此也没有说明，目前好像也没有人分享在entitas中加入lua热更的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 17 Aug 2018 07:00:00 +0000</pubDate>
<dc:creator>禹泽鹏鹏</dc:creator>
<og:description>框架介绍 entitas是一个超快、超轻量的c# Entity-Component-System (ECS)框架，专门为Unity引擎设计。提供内部缓存和高速的组件访问，经过精心设计，可以在垃圾收集环</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IAMTOM/p/9493272.html</dc:identifier>
</item>
<item>
<title>webpack4 系列教程(四): 单页面解决方案--代码分割和懒加载 - YuanXin.me</title>
<link>http://www.cnblogs.com/geyouneihan/p/9492956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geyouneihan/p/9492956.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本节课讲解&lt;code&gt;webpack4&lt;/code&gt;打包&lt;strong&gt;单页应用&lt;/strong&gt;过程中的代码分割和代码懒加载。不同于多页面应用的提取公共代码，单页面的代码分割和懒加载不是通过&lt;code&gt;webpack&lt;/code&gt;配置来实现的，而是通过&lt;code&gt;webpack&lt;/code&gt;的写法和内置函数实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前&lt;code&gt;webpack&lt;/code&gt;针对此项功能提供 2 种函数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;import()&lt;/code&gt;: 引入并且自动执行相关 js 代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require.ensure()&lt;/code&gt;: 引入但需要手动执行相关 js 代码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文将会进行逐一讲解。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dongyuanxin/webpack-demos/tree/master/demo04&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 本节课源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dongyuanxin/webpack-demos&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 所有课程源码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;1. 准备工作&lt;/h3&gt;
&lt;p&gt;此次代码的目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/webpack/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/3.png&quot; alt=&quot;代码目录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;page.js&lt;/code&gt;是入口文件,&lt;code&gt;subPageA.js&lt;/code&gt;和&lt;code&gt;subPageB.js&lt;/code&gt;共同引用&lt;code&gt;module.js&lt;/code&gt;。下面，我们按照代码引用的逻辑，从底向上展示代码：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;module.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;export default &quot;module&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;subPageA.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import &quot;./module&quot;;
console.log(&quot;I'm subPageA&quot;);
export default &quot;subPageA&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;subPageB.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import &quot;./module&quot;;
console.log(&quot;I'm subPageB&quot;);
export default &quot;subPageB&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意：subPageA.js 和 subPageB.js 两个文件中都执行了&lt;code&gt;console.log()&lt;/code&gt;语句。之后将会看到&lt;code&gt;import()&lt;/code&gt;和&lt;code&gt;require()&lt;/code&gt;不同的表现形式：是否会自动执行 js 的代码？&lt;/p&gt;
&lt;h3 id=&quot;编写配置文件&quot;&gt;2. 编写配置文件&lt;/h3&gt;
&lt;p&gt;下面编写&lt;code&gt;webpack&lt;/code&gt;配置文件（很简单）：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const webpack = require(&quot;webpack&quot;);
const path = require(&quot;path&quot;);

module.exports = {
  entry: {
    page: &quot;./src/page.js&quot; //
  },
  output: {
    publicPath: __dirname + &quot;/dist/&quot;,
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;[name].bundle.js&quot;,
    chunkFilename: &quot;[name].chunk.js&quot;
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，关于第三方库，因为要在&lt;code&gt;page.js&lt;/code&gt;中使用&lt;code&gt;lodash&lt;/code&gt;，所以，&lt;code&gt;package.json&lt;/code&gt;文件配置如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.15.1&quot;
  },
  &quot;dependencies&quot;: {
    &quot;lodash&quot;: &quot;^4.17.10&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;import编写page.js&quot;&gt;3. &lt;code&gt;import()&lt;/code&gt;编写&lt;code&gt;page.js&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;我个人是非常推荐&lt;code&gt;import()&lt;/code&gt;写法，因为和 es6 语法看起来很像。除此之外，&lt;code&gt;import()&lt;/code&gt;可以通过注释的方法来指定打包后的 chunk 的名字。&lt;/p&gt;
&lt;p&gt;除此之外，相信对&lt;code&gt;vue-router&lt;/code&gt;熟悉的朋友应该知道，其官方文档的路由懒加载的配置也是通过&lt;code&gt;import()&lt;/code&gt;来书写的。&lt;/p&gt;
&lt;p&gt;下面，我们将书写&lt;code&gt;page.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import(/* webpackChunkName: 'subPageA'*/ &quot;./subPageA&quot;).then(function(subPageA) {
  console.log(subPageA);
});

import(/* webpackChunkName: 'subPageB'*/ &quot;./subPageB&quot;).then(function(subPageB) {
  console.log(subPageB);
});

import(/* webpackChunkName: 'lodash'*/ &quot;lodash&quot;).then(function(_) {
  console.log(_.join([&quot;1&quot;, &quot;2&quot;]));
});
export default &quot;page&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令行中运行&lt;code&gt;webpack&lt;/code&gt;，打包结果如下：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/webpack/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/4.png&quot; alt=&quot;import打包结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们创建&lt;code&gt;index.html&lt;/code&gt;文件，通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签引入我们打包结果，需要注意的是：因为是单页应用，所以只要引用入口文件即可（即是上图中的&lt;code&gt;page.bundle.js&lt;/code&gt;）。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;script src=&quot;./dist/page.bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开浏览器控制台，刷新界面，结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/webpack/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/5.png&quot; alt=&quot;控制台运行结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中圈出的部分，就是说明&lt;code&gt;import()&lt;/code&gt;会自动运行&lt;code&gt;subPageA.js和subPageB.js&lt;/code&gt;的代码。&lt;/p&gt;
&lt;p&gt;在 NetWork 选项中，我们可以看到，懒加载也成功了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/webpack/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/6.png&quot; alt=&quot;懒加载&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;require编写page.js&quot;&gt;4. &lt;code&gt;require()&lt;/code&gt;编写&lt;code&gt;page.js&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;require.ensure()&lt;/code&gt;不会自动执行&lt;code&gt;js&lt;/code&gt;代码，请注意注释：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;require.ensure(
  [&quot;./subPageA.js&quot;, &quot;./subPageB.js&quot;], // js文件或者模块名称
  function() {
    var subPageA = require(&quot;./subPageA&quot;); // 引入后需要手动执行，控制台才会打印
    var subPageB = require(&quot;./subPageB&quot;);
  },
  &quot;subPage&quot; // chunkName
);

require.ensure(
  [&quot;lodash&quot;],
  function() {
    var _ = require(&quot;lodash&quot;);
    _.join([&quot;1&quot;, &quot;2&quot;]);
  },
  &quot;vendor&quot;
);

export default &quot;page&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实，根据我们编写的代码，&lt;code&gt;subPageA.js&lt;/code&gt;和&lt;code&gt;subPageB.js&lt;/code&gt;共同引用了&lt;code&gt;module.js&lt;/code&gt;文件，我们可以将&lt;code&gt;module.js&lt;/code&gt;体现抽离出来：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;require.include(&quot;./module.js&quot;); // 将subPageA和subPageB共用的module.js打包在此page中

// ...
// 再输入上面那段代码&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终打包后，检验和引入方法与&lt;code&gt;import()&lt;/code&gt;一致，这里不再冗赘。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;2.8875&quot;&gt;
&lt;p&gt;欢迎技术交流，引用请注明出处。&lt;br/&gt;个人网站：&lt;a href=&quot;http://yuanxin.me&quot;&gt;Yuan Xin&lt;/a&gt;&lt;br/&gt;原文链接：&lt;a href=&quot;http://yuanxin.me/#/passage/33&quot;&gt;webpack4 系列教程(四): 单页面解决方案--代码分割和懒加载&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 17 Aug 2018 06:02:00 +0000</pubDate>
<dc:creator>YuanXin.me</dc:creator>
<og:description>本节课讲解 打包 单页应用 过程中的代码分割和代码懒加载。不同于多页面应用的提取公共代码，单页面的代码分割和懒加载不是通过 配置来实现的，而是通过 的写法和内置函数实现的。 目前 针对此项功能提供 2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geyouneihan/p/9492956.html</dc:identifier>
</item>
<item>
<title>微信小程序实战–集阅读与电影于一体的小程序项目（二） - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/9491165.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/9491165.html</guid>
<description>&lt;h3 id=&quot;文章列表页跳转到文章详情页&quot;&gt;9.文章列表页跳转到文章详情页&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;给每篇文章添加个postId&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;posts-data.js&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;var local_database = [{
  date: &quot;2018/8/16&quot;,
  title: &quot;荷塘月色&quot;,
  imgSrc: '/images/post/sls.JPG',
  content: '这几天心里颇不宁静。今晚在院子里坐着乘凉，忽然想起日日走过的荷塘，在这满月的光里，总该另有一番样子吧。',
  reading: &quot;100&quot;,
  collection: '50',
  avatar: '/images/avatar/1.png',
  postId:0
},
{
  date: &quot;2018/7/15&quot;,
  title: &quot;背影&quot;,
  imgSrc: '/images/post/bl.png',
  content: '我与父亲不相见已二年余了，我最不能忘记的是他的背影 。那年冬天，祖母死了，父憨穿封费莩渡凤杀脯辑亲的差使也交卸了，正是祸不单行的日子',
  reading: &quot;120&quot;,
  collection: '150',
  avatar: '/images/avatar/2.png',
  postId: 1
},
{
  date: &quot;2018/6/2&quot;,
  title: &quot;济南的冬天&quot;,
  imgSrc: '/images/post/crab.png',
  content: '对于一个在北平住惯的人，像我，冬天要是不刮风，便觉得是奇迹；济南的冬天是没有风声的。',
  reading: &quot;80&quot;,
  collection: '50',
  avatar: '/images/avatar/3.png',
  postId: 2
},

{
  date: &quot;2018/5/1&quot;,
  title: &quot;江南之雨&quot;,
  imgSrc: '/images/post/vr.png',
  content: '江南之春雨如此缠绵，然煽情，如此醉，影青青之烟雨巷，雨丝风，润之使人动心如此',
  reading: &quot;80&quot;,
  collection: '50',
  avatar: '/images/avatar/3.png',
  postId: 3
},

{
  date: &quot;2018/4/6&quot;,
  title: &quot;忆江南&quot;,
  imgSrc: '/images/post/xiaolong.jpg',
  content: '昨晚和阿浩谈起诸多童年记忆，不知不觉眼前浮现一片油菜花海，黄灿灿，一眼望不到头，连空气都带着甜香。',
  reading: &quot;80&quot;,
  collection: '50',
  avatar: '/images/avatar/4.png',
  postId: 4
},
]

module.exports = {
  postlist:local_database
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;post.wxml&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html&quot; title=&quot;事件文档&quot;&gt;事件文档&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;绑定事件&lt;/li&gt;
&lt;li&gt;添加自定义属性，把文章id传到js中&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt; &amp;lt;block wx:for=&quot;{{postlist}}&quot; wx:for-item=&quot;item&quot;&amp;gt;
    &amp;lt;view catchtap=&quot;onPostTap&quot; data-postid=&quot;{{item.postId}}&quot;&amp;gt;
      &amp;lt;template is=&quot;postItem&quot; data=&quot;{{...item}}&quot; /&amp;gt;
    &amp;lt;/view&amp;gt;
  &amp;lt;/block&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;post.js&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取到文章id&lt;/li&gt;
&lt;li&gt;跳到详情页面&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var postsData = require('../../data/posts-data.js')

Page({
  data: {
    postlist: postsData.postlist
  },
  onPostTap: function (event) {
    var postId = event.currentTarget.dataset.postid;
 
    wx:wx.navigateTo({
      url: 'post-detail/post-detail'
    })
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在posts目录下新建post-detail目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://139.199.131.146/wp-content/uploads/2018/08/4132abca055d6bfe0c5a86e047abd174.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;post-detail.wxml&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view&amp;gt;这是文章详情页&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;app.json全局配置&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
  &quot;pages&quot;: [
    &quot;pages/welcome/welcome&quot;,
    &quot;pages/posts/post&quot;,
    &quot;pages/posts/post-detail/post-detail&quot;  
  ],
  &quot;window&quot;: {
    &quot;navigationBarBackgroundColor&quot;: &quot;#405f80&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在点击文章，就可以跳转到文章详情页面了。&lt;/p&gt;
&lt;h3 id=&quot;文章详情页面布局&quot;&gt;10.文章详情页面布局&lt;/h3&gt;
&lt;p&gt;post-detail.wxml&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view class=&quot;container&quot;&amp;gt;
  &amp;lt;image class=&quot;head-image&quot; src=&quot;/images/post/sls.JPG&quot;&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;view class=&quot;author-date&quot;&amp;gt;
    &amp;lt;image class=&quot;avatar&quot; src=&quot;/images/avatar/2.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
    &amp;lt;text class=&quot;author&quot;&amp;gt;朱自清&amp;lt;/text&amp;gt;
    &amp;lt;text class=&quot;const-text&quot;&amp;gt;发表于&amp;lt;/text&amp;gt;
    &amp;lt;text class=&quot;date&quot;&amp;gt;一天前&amp;lt;/text&amp;gt;
  &amp;lt;/view&amp;gt;
  &amp;lt;text class=&quot;title&quot;&amp;gt;背影&amp;lt;/text&amp;gt;
  &amp;lt;view class=&quot;tool&quot;&amp;gt;
    &amp;lt;view class=&quot;circle-img&quot;&amp;gt;
      &amp;lt;image src=&quot;/images/icon/collection.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
      &amp;lt;image class=&quot;share-img&quot; src=&quot;/images/icon/share.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
    &amp;lt;/view&amp;gt;
    &amp;lt;view class=&quot;horizon&quot;&amp;gt;&amp;lt;/view&amp;gt;
  &amp;lt;/view&amp;gt;
  &amp;lt;text class='detail'&amp;gt;我与父亲不相见已二年余了，我最不能忘记的是他的背影。那年冬天，祖母死了，父亲的差使也交卸了，正是祸不单行的日子，我从北京到徐州，打算跟着父亲奔丧回家。到徐州见着父亲，看见满院狼藉的东西，又想起祖母，不禁簌簌地流下眼泪。父亲说，“事已如此，不必难过，好在天无绝人之路！”&amp;lt;/text&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;post-detail.wxss&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.container{
  display:flex;
  flex-direction: column;
}

.head-image{
  width: 100%;
  height: 460rpx;
}

.author-date{
  flex-direction: row;
  margin-left:30rpx;
  margin-top: 20rpx;
}

.avatar{
  height: 64rpx;
  width: 64rpx;
  vertical-align: middle;
}

.author{
  font-size: 30rpx;
  font-weight: 300;
  margin-left: 20rpx;
  vertical-align: middle;
  color: #666;
}

.const-text{
  font-size: 24rpx;
  color: #999;
  margin-left: 20rpx;
}

.date{
  font-size: 24rpx;
  margin-left: 30rpx;
  vertical-align: middle;
  color: #999;
}

.title{
  margin-left: 40rpx;
  font-size: 36rpx;
  font-weight: 700;
  margin-top: 30rpx;
  letter-spacing: 2px;
  color: #4b556c;
}

.tools{
  margin-top: 20rpx;
}
.circle-img{
  float: right;
  margin-right: 40rpx;
  vertical-align: middle;
}

.circle-img image{
  width: 90rpx;
  height: 90rpx;
}

.share-img{
  margin-left: 30rpx;
}

.horizon{
  width: 660rpx;
  height: 1px;
  background-color: #e5e5e5;
  vertical-align: middle;
  position: relative;
  top: 46rpx;
  margin: 0 auto;
  z-index: -99;
}

.detail{
  color: #666;
  margin-left: 30rpx;
  margin-top: 20rpx;
  margin-right: 30rpx;
  line-height: 44rpx;
  letter-spacing: 2px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;app.wxss&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;text{
    font-family:MicroSoft yahei;
    font-size: 24rpx;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果预览&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://139.199.131.146/wp-content/uploads/2018/08/0b5fcaaa202cbe2fa4f12a0f846ae082.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;播放按钮和导航栏&quot;&gt;11.播放按钮和导航栏&lt;/h3&gt;
&lt;p&gt;post-detial.wxml添加一个播放按钮图片&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view class=&quot;container&quot;&amp;gt;
  &amp;lt;image class=&quot;head-image&quot; src=&quot;/images/post/sls.JPG&quot;&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;image class=&quot;audio&quot; src=&quot;/images/music/music-start.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;view class=&quot;author-date&quot;&amp;gt;
    &amp;lt;image class=&quot;avatar&quot; src=&quot;/images/avatar/2.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
    &amp;lt;text class=&quot;author&quot;&amp;gt;朱自清&amp;lt;/text&amp;gt;
    &amp;lt;text class=&quot;const-text&quot;&amp;gt;发表于&amp;lt;/text&amp;gt;
    &amp;lt;text class=&quot;date&quot;&amp;gt;一天前&amp;lt;/text&amp;gt;
  &amp;lt;/view&amp;gt;
  &amp;lt;text class=&quot;title&quot;&amp;gt;背影&amp;lt;/text&amp;gt;
  &amp;lt;view class=&quot;tool&quot;&amp;gt;
    &amp;lt;view class=&quot;circle-img&quot;&amp;gt;
      &amp;lt;image src=&quot;/images/icon/collection.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
      &amp;lt;image class=&quot;share-img&quot; src=&quot;/images/icon/share.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
    &amp;lt;/view&amp;gt;
    &amp;lt;view class=&quot;horizon&quot;&amp;gt;&amp;lt;/view&amp;gt;
  &amp;lt;/view&amp;gt;
  &amp;lt;text class='detail'&amp;gt;我与父亲不相见已二年余了，我最不能忘记的是他的背影。那年冬天，祖母死了，父亲的差使也交卸了，正是祸不单行的日子，我从北京到徐州，打算跟着父亲奔丧回家。到徐州见着父亲，看见满院狼藉的东西，又想起祖母，不禁簌簌地流下眼泪。父亲说，“事已如此，不必难过，好在天无绝人之路！”&amp;lt;/text&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;post-detail.wxss&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.audio{
  width: 102rpx;
  height: 110rpx;
  position: absolute;
  left: 50%;
  margin-left: -51rpx;
  top: 180rpx;
  opacity: 0.6
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;post-detail.json添加导航栏文字&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;{
  &quot;navigationBarTitleText&quot;: &quot;阅读&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://139.199.131.146/wp-content/uploads/2018/08/00ac0324de4ed60daea36097d194de0c.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用数据填充文章详情页面&quot;&gt;12.使用数据填充文章详情页面&lt;/h3&gt;
&lt;p&gt;post-data.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var local_database = [{
    date: &quot;2018/8/16&quot;,
    title: &quot;荷塘月色&quot;,
    imgSrc: '/images/post/sls.JPG',
    content: '这几天心里颇不宁静。今晚在院子里坐着乘凉，忽然想起日日走过的荷塘，在这满月的光里，总该另有一番样子吧。',
    reading: &quot;100&quot;,
    collection: '50',
    avatar: '/images/avatar/1.png',
    postId: 0,
    headImgSrc: &quot;/images/post/sls.JPG&quot;,
    author: &quot;朱自清&quot;,
    datetime: &quot;24小时前&quot;,
  detail: &quot;这几天心里颇不宁静。今晚在院子里坐着乘凉，忽然想起日日走过的荷塘，在这满月的光里，总该另有一番样子吧。月亮渐渐地升高了，墙外马路上孩子们的欢笑，已经听不见了；妻在屋里拍着闰儿，迷迷糊糊地哼着眠歌。我悄悄地披了大衫，带上门出去。沿着荷塘，是一条曲折的小煤屑路。这是一条幽僻的路；白天也少人走，夜晚更加寂寞。荷塘四面，长着许多树，蓊蓊郁郁的。路的一旁，是些杨柳，和一些不知道名字的树。没有月光的晚上，这路上阴森森的，有些怕人。今晚却很好，虽然月光也还是淡淡的。路上只我一个人，背着手踱着。这一片天地好像是我的；我也像超出了平常的自己，到了另一个世界里。我爱热闹，也爱冷静；爱群居，也爱独处。像今晚上，一个人在这苍茫的月下，什么都可以想，什么都可以不想，便觉是个自由的人。白天里一定要做的事，一定要说的话，现 在都可不理。这是独处的妙处，我且受用这无边的荷香月色好了。&quot;
  },

  {
    date: &quot;2018/7/15&quot;,
    title: &quot;背影&quot;,
    imgSrc: '/images/post/bl.png',
    content: '我与父亲不相见已二年余了，我最不能忘记的是他的背影 。那年冬天，祖母死了，父憨穿封费莩渡凤杀脯辑亲的差使也交卸了，正是祸不单行的日子',
    reading: &quot;120&quot;,
    collection: '150',
    avatar: '/images/avatar/2.png',
    postId: 1,
    headImgSrc: &quot;/images/post/bl.png&quot;,
    author: &quot;朱自清&quot;,
    datetime: &quot;三天前&quot;,
    detail: &quot;我与父亲不相见已二年余了，我最不能忘记的是他的背影。那年冬天，祖母死了，父亲的差使也交卸了，正是祸不单行的日子，我从北京到徐州，打算跟着父亲奔丧回家。到徐州见着父亲，看见满院狼藉的东西，又想起祖母，不禁簌簌地流下眼泪。父亲说，“事已如此，不必难过，好在天无绝人之路！”回家变卖典质，父亲还了亏空；又借钱办了丧事。这些日子，家中光景很是惨淡，一半为了丧事，一半为了父亲赋闲。丧事完毕，父亲要到南京谋事，我也要回北京念书，我们便同行。到南京时，有朋友约去游逛，勾留了一日；第二日上午便须渡江到浦口，下午上车北去。父亲因为事忙，本已说定不送我，叫旅馆里一个熟识的茶房陪我同去。他再三嘱咐茶房，甚是仔细。但他终于不放心，怕茶房不妥帖；颇踌躇了一会。其实我那年已二十岁，北京已来往过两三次，是没有甚么要紧的了。他踌躇了一会，终于决定还是自己送我去。我两三回劝他不必去；他只说，“不要紧，他们去不好！” &quot;
  },

  {
    date: &quot;2018/6/2&quot;,
    title: &quot;济南的冬天&quot;,
    imgSrc: '/images/post/crab.png',
    content: '对于一个在北平住惯的人，像我，冬天要是不刮风，便觉得是奇迹；济南的冬天是没有风声的。',
    reading: &quot;80&quot;,
    collection: '50',
    avatar: '/images/avatar/3.png',
    postId: 2,
    headImgSrc: &quot;/images/post/crab.png&quot;,
    author: &quot;老舍&quot;,
    datetime: &quot;一月前&quot;,
    detail: &quot;对于一个在北平住惯的人，像我，冬天要是不刮风，便觉得是奇迹；济南的冬天是没有风声的。对于一个刚由伦敦回来的人，像我，冬天要能看得见日光，便觉得是怪事；济南的冬天是响晴的。自然，在热带的地方，日光是永远那么毒，响亮的天气，反有点叫人害怕。可是，在北中国的冬天，而能有温晴的天气，济南真得算个宝地。设若单单是有阳光，那也算不了出奇。请闭上眼睛想：一个老城，有山有水，全在天底下晒着阳光，暖和安适地睡着，只等春风来把它们唤醒，这是不是个理想的境界？小山整把济南围了个圈儿，只有北边缺着点口儿。这一圈小山在冬天特别可爱，好像是把济南放在一个小摇篮里，它们安静不动地低声地说“你们放心吧，这儿准保暖和。真的，济南的人们在冬天是面上含笑的。他们一看那些小山，心中便觉得有了着落，有了依靠.&quot;
  },

  {
    date: &quot;2018/5/1&quot;,
    title: &quot;江南之雨&quot;,
    imgSrc: '/images/post/vr.png',
    content: '江南之春雨如此缠绵，然煽情，如此醉，影青青之烟雨巷，雨丝风，润之使人动心如此',
    reading: &quot;80&quot;,
    collection: '50',
    avatar: '/images/avatar/3.png',
    postId: 3,
    headImgSrc: &quot;/images/post/crab.png&quot;,
    author: &quot;老舍&quot;,
    datetime: &quot;一月前&quot;,
    detail: &quot;对于一个在北平住惯的人，像我，冬天要是不刮风，便觉得是奇迹；济南的冬天是没有风声的。对于一个刚由伦敦回来的人，像我，冬天要能看得见日光，便觉得是怪事；济南的冬天是响晴的。自然，在热带的地方，日光是永远那么毒，响亮的天气，反有点叫人害怕。可是，在北中国的冬天，而能有温晴的天气，济南真得算个宝地。设若单单是有阳光，那也算不了出奇。请闭上眼睛想：一个老城，有山有水，全在天底下晒着阳光，暖和安适地睡着，只等春风来把它们唤醒，这是不是个理想的境界？小山整把济南围了个圈儿，只有北边缺着点口儿。这一圈小山在冬天特别可爱，好像是把济南放在一个小摇篮里，它们安静不动地低声地说“你们放心吧，这儿准保暖和。真的，济南的人们在冬天是面上含笑的。他们一看那些小山，心中便觉得有了着落，有了依靠.&quot;
  },

  {
    date: &quot;2018/4/6&quot;,
    title: &quot;忆江南&quot;,
    imgSrc: '/images/post/xiaolong.jpg',
    content: '昨晚和阿浩谈起诸多童年记忆，不知不觉眼前浮现一片油菜花海，黄灿灿，一眼望不到头，连空气都带着甜香。',
    reading: &quot;80&quot;,
    collection: '50',
    avatar: '/images/avatar/4.png',
    postId: 4,
    headImgSrc: &quot;/images/post/crab.png&quot;,
    author: &quot;老舍&quot;,
    datetime: &quot;一月前&quot;,
    detail: &quot;对于一个在北平住惯的人，像我，冬天要是不刮风，便觉得是奇迹；济南的冬天是没有风声的。对于一个刚由伦敦回来的人，像我，冬天要能看得见日光，便觉得是怪事；济南的冬天是响晴的。自然，在热带的地方，日光是永远那么毒，响亮的天气，反有点叫人害怕。可是，在北中国的冬天，而能有温晴的天气，济南真得算个宝地。设若单单是有阳光，那也算不了出奇。请闭上眼睛想：一个老城，有山有水，全在天底下晒着阳光，暖和安适地睡着，只等春风来把它们唤醒，这是不是个理想的境界？小山整把济南围了个圈儿，只有北边缺着点口儿。这一圈小山在冬天特别可爱，好像是把济南放在一个小摇篮里，它们安静不动地低声地说“你们放心吧，这儿准保暖和。真的，济南的人们在冬天是面上含笑的。他们一看那些小山，心中便觉得有了着落，有了依靠.&quot;
  },
]

module.exports = {
  postlist: local_database
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;post.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var postsData = require('../../data/posts-data.js')

Page({
  data: {
    postlist: postsData.postlist
  },
  onPostTap: function (event) {
    var postId = event.currentTarget.dataset.postid;
 
    wx:wx.navigateTo({
      url: &quot;post-detail/post-detail?id=&quot; + postId
    })
  }

})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;post-detail.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;
var postsData = require('../../../data/posts-data.js')

Page({

  /**
   * 页面的初始数据
   */
  data: {
    
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    var postId = options.id;
    var postData = postsData.postlist[postId];
    this.setData({
      postData:postData
    })
  },
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;post-detail.wxml&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view class=&quot;container&quot;&amp;gt;
  &amp;lt;image class=&quot;head-image&quot; src=&quot;{{postData.headImgSrc}}&quot;&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;image class=&quot;audio&quot; src=&quot;/images/music/music-start.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;view class=&quot;author-date&quot;&amp;gt;
    &amp;lt;image class=&quot;avatar&quot; src=&quot;{{postData.avatar}}&quot;&amp;gt;&amp;lt;/image&amp;gt;
    &amp;lt;text class=&quot;author&quot;&amp;gt;{{postData.author}}&amp;lt;/text&amp;gt;
    &amp;lt;text class=&quot;const-text&quot;&amp;gt;发表于&amp;lt;/text&amp;gt;
    &amp;lt;text class=&quot;date&quot;&amp;gt;{{postData.datetime}}&amp;lt;/text&amp;gt;
  &amp;lt;/view&amp;gt;
  &amp;lt;text class=&quot;title&quot;&amp;gt;{{postData.title}}&amp;lt;/text&amp;gt;
  &amp;lt;view class=&quot;tool&quot;&amp;gt;
    &amp;lt;view class=&quot;circle-img&quot;&amp;gt;
      &amp;lt;image src=&quot;/images/icon/collection.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
      &amp;lt;image class=&quot;share-img&quot; src=&quot;/images/icon/share.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
    &amp;lt;/view&amp;gt;
    &amp;lt;view class=&quot;horizon&quot;&amp;gt;&amp;lt;/view&amp;gt;
  &amp;lt;/view&amp;gt;
  &amp;lt;text class='detail'&amp;gt;{{postData.detail}}&amp;lt;/text&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用缓存实现文章收藏&quot;&gt;13.使用缓存实现文章收藏&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/data.html#wxsetstoragesynckeydata&quot; title=&quot;缓存文档&quot;&gt;缓存文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;post-detail.wxml&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt; &amp;lt;view class=&quot;circle-img&quot;&amp;gt;
      &amp;lt;image wx:if=&quot;{{collected}}&quot; catchtap='onCollectionTap' src=&quot;/images/icon/collection.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
      &amp;lt;image wx:else catchtap='onCollectionTap' src=&quot;/images/icon/collection-anti.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
      &amp;lt;image class=&quot;share-img&quot; src=&quot;/images/icon/share.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;post-detail.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var postsData = require('../../../data/posts-data.js')

Page({

  data: {

  },

  onLoad: function(options) {
    var postId = options.id;
    var postData = postsData.postlist[postId];
    this.setData({
      postData: postData,
      'currentPostId': postId
    })
    var postsCollected = wx.getStorageSync('posts_Collected')
    if (postsCollected) {
      var postCollected = postsCollected[postId]
      this.setData({
        collected: postCollected
      })
    } else {
      var postsCollected = {};
      postsCollected[postId] = false;
      wx.setStorageSync('posts_Collected', postsCollected);
    }
  },
  onCollectionTap: function(ev) {
    var postsCollected = wx.getStorageSync('posts_Collected')
    var postCollected = postsCollected[this.data.currentPostId]
    postCollected = !postCollected;
    postsCollected[this.data.currentPostId] = postCollected;
    // 更新文章是否收藏的缓存值
    wx.setStorageSync('posts_Collected', postsCollected)
    // 更新数据绑定变量，实现切换图片
    this.setData({
      collected: postCollected
    })
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到缓存的状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://139.199.131.146/wp-content/uploads/2018/08/3dda483ffa70b24651cc58792cebbed9.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Aug 2018 05:26:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<og:description>9.文章列表页跳转到文章详情页 给每篇文章添加个postId posts data.js post.wxml</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/9491165.html</dc:identifier>
</item>
<item>
<title>缓存服务的更新策略有哪些？ - IVAN-jsjwk</title>
<link>http://www.cnblogs.com/jsjwk/p/9492777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jsjwk/p/9492777.html</guid>
<description>
&lt;p&gt;在互联网项目开发中，缓存的应用是非常普遍了，缓存可以帮助页面提高加载速度，减少服务器或数据源的负载。&lt;/p&gt;
&lt;h4&gt;1、为什么需要缓存？&lt;/h4&gt;
&lt;p&gt;一般在项目中，最消耗性能的地方就是后端服务的数据库了。而数据库的读写频率常常都是不均匀分布的，大多情况是读多写少，并且读操作（select）还会有一些复杂的判断条件，比如 like、group、join 等等，这些语法是非常消耗性能的，所有会出现很多的慢查询，因此数据库很容易在读操作的环节遇到瓶颈。&lt;/p&gt;
&lt;p&gt;那么通过在数据库前面，前置一个缓存服务，就可以有效的吸收不均匀的请求，抵挡流量波峰。&lt;/p&gt;
&lt;p&gt;另外，如果应用与数据源不在同一个服务器的情况下，中间还会有很多的网络消耗，也会对应用的响应速度有很大影响，如果当前应用对数据实时性的要求不那么强的话，在应用侧加上缓存就能很快速的提升效率。&lt;/p&gt;
&lt;h4&gt;2、那使用缓存会遇到哪些问题呢？&lt;/h4&gt;
&lt;p&gt;虽然缓存可以提高整体性能，但是它也可能会带来别的问题。例如使用缓存之后，就相当于把数据存放了2份，一份是在数据库中，另一份存放在缓存中。当有新的数据要写入或者旧数据需要更新的时候，如果我们只更新了其中一份数据源，那两边的数据就不一致了，所以这里就存在一个缓存数据与数据库数据如何进行有效且快速的同步问题，才可以保证数据的最终一致性。&lt;/p&gt;
&lt;p&gt;另外，加上缓存服务其实也引入了系统架构的复杂度，因为还需要额外的关注缓存自身带来的下列问题：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;缓存的过期时间问题：&lt;br/&gt;设计缓存的过期时间需要非常的有技巧，且必须与业务实际情况相结合。因为如果设计的过期时间太短了，那会导致缓存效果不佳，且还会造成频繁的从数据库中往缓存里写数据。如果缓存设计的过期时间太长了，又会导致内存的浪费。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;缓存的命中率问题：&lt;br/&gt;这也是设计缓存中需要存放哪些数据的很重要一点，如果设计的不好，可能会导致缓存命中率过低，失去缓存效果。一般对于热点数据而言，要保证命中率达到70%以上效果最佳。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;缓存的穿透/雪崩问题：&lt;br/&gt;是指如果缓存服务一旦宕机或全部丢失，那么有可能一瞬间所有的流量都直接打到了后端数据库上，可能会造成连锁反应，瞬间的请求高峰极有可能导致数据库无法承载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;3、缓存的更新策略具体有哪些？&lt;/h4&gt;
&lt;p&gt;典型的缓存模式，一般有如下几种：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cache Aside&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Read/Write Through&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Write Behind&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每种模式都有不同的特点，适应与不同的项目场景，下面来依次看看：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cache Aside 模式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1453917/201808/1453917-20180817130151639-141787513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是大家经常用到的一种策略模式。这种模式主要流程如下：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;应用在查询数据的时候，先从缓存Cache中读取数据，如果缓存中没有，则再从数据库中读取数据，得到数据库的数据之后，将这个数据也放到缓存Cache中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果应用要更新某个数据，也是先去更新数据库中的数据，更新完成之后，则通过指令让缓存Cache中的数据失效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里为什么不让更新操作在写完数据库之后，紧接着去把缓存Cache中的数据也修改了呢？&lt;/p&gt;
&lt;p&gt;主要是因为这样做的话，就有2个写操作的事件了，担心在并发的情况下会导致脏数据，举个例子：&lt;br/&gt;假如同时有2个请求，请求A和请求B，并发的执行。请求A是要去读数据，请求B是要去更新数据。初始状态缓存中是没有数据的，当请求A读到数据之后，准备往回写的时候，此刻，请求B正好要更新数据，更新完了数据库之后，又去把缓存更新了，那请求A再往缓存中写的就是旧数据了，属于脏数据。&lt;/p&gt;
&lt;p&gt;那么 Cache Aside 模式就没有脏数据问题了吗？不是的，在极端情况下也可能会产生脏数据，比如：&lt;/p&gt;
&lt;p&gt;假如同时有2个请求，请求A和请求B，并发的执行。请求A是要去读数据，请求B是要去写数据。假如初始状态缓存中没有这个数据，那请求A发现缓存中没有数据，就会去数据库中读数据，读到了数据准备写回缓存中，就在这个时候，请求B是要去写数据的，请求B在写完数据库的数据之后，又去设置了缓存失效。这个时候，请求A由于在数据库中读到了之前的旧数据，开始往缓存中写数据了，此时写进入的就也是旧数据。那么最终就会导致，缓存中的数据与数据库的数据不一致，造成了脏数据。&lt;/p&gt;
&lt;p&gt;不过这种概率比上面一种概率要小很多。所以整体而言  Cache Aside 模式 还是一种比较简单实用的方式。&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Read/Write Through 模式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1453917/201808/1453917-20180817130211463-1857548118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个模式其实就是将 缓存服务 作为主要的存储，应用的所有读写请求都是直接与缓存服务打交道，而不管最后端的数据库了，数据库的数据由缓存服务来维护和更新。不过缓存中数据变更的时候是同步去更新数据库的，在应用的眼中只有缓存服务。&lt;/p&gt;
&lt;p&gt;流程就相当简单了：&lt;/p&gt;
&lt;p&gt;这个模式出现脏数据的概率就比较低，但是就强依赖缓存了，对缓存服务的稳定性有较大要求，另外，增加新缓存节点时还会有初始状态空数据问题。&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Write Behind 模式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个模式就是 Read/Write Through 模式 的一个变种。区别就是 Read/Write Through 模式的缓存写数据库的时候是同步的，而 Write Behind 模式 的缓存操作数据库是异步的。&lt;/p&gt;
&lt;p&gt;流程如下：&lt;/p&gt;
&lt;p&gt;这个模式的特点就是速度很快，效率会非常高，但是数据的一致性比较差，还可能会有数据的丢失情况，实现逻辑也较为复杂。&lt;/p&gt;
&lt;p&gt;以上就是目前三种主流的缓存更新策略，另外还有Refrsh-Ahead模式等由于使用的不是很常见就不详细介绍了。&lt;/p&gt;
&lt;p&gt;缓存是互联网项目中非常普遍的一个提高效率的方案，用法比较多，也比较关键，大家可以一起交流。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流互联网认知、项目管理、大数据、Web、区块链技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1453917/201808/1453917-20180817130229764-733723906.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 17 Aug 2018 05:03:00 +0000</pubDate>
<dc:creator>IVAN-jsjwk</dc:creator>
<og:description>在互联网项目开发中，缓存的应用是非常普遍了，缓存可以帮助页面提高加载速度，减少服务器或数据源的负载。 1、为什么需要缓存？ 一般在项目中，最消耗性能的地方就是后端服务的数据库了。而数据库的读写频率常常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jsjwk/p/9492777.html</dc:identifier>
</item>
<item>
<title>Promise学习笔记 - qfstudy</title>
<link>http://www.cnblogs.com/qfstudy/p/9492708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qfstudy/p/9492708.html</guid>
<description>&lt;h2 id=&quot;promise对象&quot;&gt;Promise对象&lt;/h2&gt;
&lt;p&gt;Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 &lt;code&gt;then&lt;/code&gt; 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。&lt;/p&gt;
&lt;h2 id=&quot;promise-的状态&quot;&gt;Promise 的状态&lt;/h2&gt;
&lt;p&gt;一个 Promise 的当前状态必须为以下三种状态中的一种：&lt;strong&gt;等待态（Pending）&lt;/strong&gt;、&lt;strong&gt;执行态（Fulfilled）&lt;/strong&gt;和&lt;strong&gt;拒绝态（Rejected）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;异步操作未完成（pending）&lt;/li&gt;
&lt;li&gt;异步操作成功（fulfilled）&lt;/li&gt;
&lt;li&gt;异步操作失败（rejected）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基本用法&quot;&gt;基本用法&lt;/h2&gt;
&lt;p&gt;Promise是一个构造函数，Promise接收一个参数，这个参数是函数，同时这个参数函数要传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。&lt;/p&gt;
&lt;p&gt;Promise对象上有then、catch等方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var getAjax = function (url) {
    const promise=new Promise(function(resolve,reject){
    var xhr=new XMLHttpRequest()
    xhr.onreadystatechange=function(){
        if(xhr.readyState!==4){
            return
        }
        if(xhr.status===200){
            resolve('成功时调用resolve函数，并返回一个Promise对象')
        }else{
            reject(new Error(xhr.statusText))
        }
    }
    xhr.open('GET',url)
    xhr.send()
    })
    return promise//返回promise对象
}
getAjax('./ajax.html')
    .then((data)=&amp;gt;{
            console.log('第一个参数: '+ data)//打印resolve函数传递的参数
            return ('第一个then的第一个参数')//返回一个Promise对象并将数据传递给下一个then
        },(data)=&amp;gt;{
            console.log('第二个参数: '+ data)//打印reject函数传递的参数
            return('第一个then的第二个参数')//返回一个Promise对象并将数据传递给下一个then
            }
        )
    .then((data)=&amp;gt;{
        //如果刚开始在getAjax函数中是调用reject函数，第一个then方法才会执行第二个参数，但是后面的then方法只执行第一个参数
            console.log('第一个参数: '+ data)//打印上一个then方法传递的参数
            return ('第二个then的第一个参数')
        },(data)=&amp;gt;{
            console.log('第二个参数: '+ data)
            return ('第二个then的第二个参数')
        }
    )
    .then((data)=&amp;gt;{
            console.log('第一个参数: '+ data)
        },(data)=&amp;gt;{
            console.log('第二个参数: '+ data)
        }
    )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;异步操作成功时调用resolve:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9437556-6dd5dd09e58e0afa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;异步操作失败时调用reject:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9437556-15dd161db79f252c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结：&lt;/h2&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Promise是一个构造函数，通过new命令创建promise对象。在创建对象的时候传递一个参数，这个参数是一个函数，这个函数有两个参数，这两个参数分别是resolve和reject，它们是两个函数，由 JavaScript 引擎提供，不用自己实现。成功时调用resolve方法，失败时调用reject方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在promise对象上有then方法，这个方法可以传递两个参数，这两个参数是函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果调用resolve函数，就会调用then方法的第一个参数。如果调用的是reject函数，就会调用then方法的第二个参数。不管第一个then调用第一个参数还是第二个参数，第一个then方法后面的then方法都会执行第一个参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;resolve方法和reject方法需要带参数，这个参数会传递给then方法对应的参数 。在then方法中返回数据时，可以传递给下一个then方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 17 Aug 2018 04:31:00 +0000</pubDate>
<dc:creator>qfstudy</dc:creator>
<og:description>Promise对象 Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。 Pro</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qfstudy/p/9492708.html</dc:identifier>
</item>
<item>
<title>.NET MVC CSRF/XSRF 漏洞 - Caligula</title>
<link>http://www.cnblogs.com/caligula/p/9492675.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caligula/p/9492675.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近我跟一个漏洞还有一群阿三干起来了……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;背景：&lt;/p&gt;
&lt;p&gt;我的客户是一个世界知名的药企，最近这个客户上台了一位阿三管理者，这个货上线第一个事儿就是要把现有的软件供应商重新洗牌一遍。由于我们的客户关系维护的非常好，直接对口人提前透露给我们这个管理者就是想让一个阿三公司垄断他们的软件供应，并且表示了非常鄙视。我们表示了理解，毕竟任意一家公司只要进去一个阿三，慢慢的。。。慢慢的。。。就变成满屋都是阿三。。。&lt;/p&gt;
&lt;p&gt;然后某一家阿三公司就暗地里中标了，然后我们就面临KT。由于我们维护着12个高活跃系统，所以KT的工作量也是非常的大。&lt;/p&gt;
&lt;p&gt;BUT！ 阿三的牛逼之处就在这时候体现出来了，他会从各个维度找你的事儿，其中一个就是找漏洞（自己找了一家阿三的漏洞检测公司免费做）报给客户并威胁说解决不完不接手，用以拉长KT的周期（本来KT只有三周时间）。&lt;/p&gt;
&lt;p&gt;然后客户的阿三头头就同意了。。。&lt;/p&gt;
&lt;p&gt;这个漏洞本来就有，客户一直表示不想处理，因为大多数网站太老旧了，很多都不是我们一手开发的。&lt;/p&gt;
&lt;p&gt;但是这回看来是不干不行了，还好客户表示会付费，行吧。。。 那就整&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/621162/201808/621162-20180817103322721-1251921521.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在有请漏洞登场！&lt;/p&gt;
&lt;p&gt;大家好！我叫CSRF，全名是 Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet&lt;/p&gt;
&lt;p&gt;这是我的简历：&lt;a title=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#Viewstate_.28ASP.NET.29&quot; href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#Viewstate_.28ASP.NET.29&quot; target=&quot;_blank&quot;&gt;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#Viewstate_.28ASP.NET.29&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（Google Translate 了解一下）&lt;/p&gt;
&lt;p&gt;这个玩意说白了就是一个伪装攻击，伪装工具是Cookie。&lt;/p&gt;
&lt;p&gt;这个玩意是这样运作的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/621162/201808/621162-20180817112837695-540911234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（请不要在意这个丑逼的图。。。）&lt;/p&gt;

&lt;p&gt;简单描述就是&lt;/p&gt;
&lt;p&gt;其他网站用你的身份（Cookie）假装是你干了你不知道的事儿，这时候请想想你在网上银行转账的时候&lt;/p&gt;
&lt;p&gt;那么这里面就出现一个重大的疑点：&lt;/p&gt;
&lt;p&gt;为啥WebSiteB发过来的请求WebSiteA会收到呢？ IIS吃了脏东西不管事儿了？&lt;/p&gt;
&lt;p&gt;因为我们的网站支持&lt;span&gt;跨域请求!&lt;/span&gt;（是不是看着贼扎眼！画重点了啊）&lt;/p&gt;
&lt;p&gt;现在毛病基本OK了，剩的就是出方案。&lt;/p&gt;
&lt;p&gt;对与CSRF这个东西知名度还是很高的，网上一搜一大把&lt;/p&gt;
&lt;p&gt;.NET MVC就自带了解决方案，此方案只针对常规的MVC项目，前后端分离的绕行，以后我要是解决了我再回来写。。。&lt;/p&gt;
&lt;p&gt;解决方案也很粗暴，一句话来说就是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们的服务器只接收来自我们自己页面发过来的请求&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;放到实现上就是：每个页面都按照一定规则生成一个Token，然后再发请求的时候带过去，服务器先看Token再干别的&lt;/p&gt;
&lt;p&gt;这时候有人说了：要是别的网站伪造Token怎么办？&lt;/p&gt;
&lt;p&gt;有道是孔子曰：不怕贼偷就怕贼惦记，他要是就想搞你，你早晚是防不住的啊，兄die&lt;/p&gt;
&lt;p&gt;下面介绍关键代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
@Html.AntiForgeryToken()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是cshtml的页面的代码，aspx的差不多&lt;/p&gt;
&lt;p&gt;这东西的作用是会在页面上生成一个 Hidden，Value就是Token&lt;/p&gt;
&lt;p&gt;最后变成Html长介样儿：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;input name=&quot;__RequestVerificationToken&quot; 
type=&quot;hidden&quot; value=&quot;MbnNdB3T64quXYviXLsvoi_FlbM2SihwiiPCgSzaWAL0duMy7H6SbuF0lkUAxOD-DwF4P_4kxlyravohGXsQ_ERVPm5f3Oa3owG6LZ26WRw1&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　那一球乱糟糟的就是Token&lt;/p&gt;
&lt;p&gt;那么这玩意怎么用呢？&lt;/p&gt;
&lt;p&gt;Type 1，Form Request：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
@using (Html.BeginForm(&quot;Action&quot;, &quot;Controller&quot;, null, FormMethod.Post, new { id = &quot;formId&quot; }))
{
    @Html.AntiForgeryToken();
    Other Code......
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Type 2，Ajax Request：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
var token = $('@Html.AntiForgeryToken()').val();
var headers = {};
headers[&quot;__RequestVerificationToken&quot;] = token;

            $.ajax({
                type: &quot;post&quot;,
                headers: headers,
                url: &quot;@Url.Action(&quot;Action&quot;,&quot;Controller&quot;)&quot;,
                data: { },
                dataType: &quot;json&quot;,
                success: function (response) {
                   
                }
            });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;说到底就是页面上生成了Token之后，想尽一切办法发到后台去，不拘泥与形式&lt;/p&gt;
&lt;p&gt;form就是直接包到里面了，后台直接用name拿就ok了，Ajax是放在header里了。&lt;/p&gt;
&lt;p&gt;接下来就是后台验证，由于绝大多数Action都需要堵这个漏洞，所以直接写了一个Filter&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    using System.Net;
    using System.Web.Helpers;
    using System.Web.Mvc;

    public class ExtendedValidateAntiForgeryToken : AuthorizeAttribute
    {
        public override void OnAuthorization(AuthorizationContext filterContext)
        {
            var request = filterContext.HttpContext.Request;
            if (request.HttpMethod != WebRequestMethods.Http.Post) return;
            if (request.IsAjaxRequest())
            {
                var antiForgeryCookie = request.Cookies[AntiForgeryConfig.CookieName];
                var cookieValue = antiForgeryCookie != null ? antiForgeryCookie.Value : null;
                //从cookies 和 Headers 中 验证防伪标记  
                //这里可以加try-catch  
                //try
                //{
                AntiForgery.Validate(cookieValue, request.Headers[&quot;__RequestVerificationToken&quot;]);
                //}
                //catch (Exception e)
                //{
                //    //filterContext.Result = new RedirectResult(&quot;/Account/Login?returnUrl=&quot; +
                //    // HttpUtility.UrlEncode(filterContext.HttpContext.Request.Url.ToString()));
                //    ContentResult result = new ContentResult();
                //    result.Content = &quot;&amp;lt;div style='text-align:center;padding:1em;' &amp;gt;当前已经处于退出状态，请重新登录&amp;lt;/div&amp;gt;&quot;;
                //    filterContext.Result = result;
                //}
            }
            else
            {
                //try
                //{
                new ValidateAntiForgeryTokenAttribute().OnAuthorization(filterContext);
                //}
                //catch (Exception ex)
                //{
                //    //
                //}
            }
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　里面代码核心就是验证Token的有效性，用的是官方API方法，但是要区别一个事儿，就是前文提到了咱们Ajax和Form带Token的方式不一样，所以需要判断是不是AJAX Request，走两个分支。&lt;/p&gt;
&lt;p&gt;然后就是把Filter挂到Action上就行了。&lt;/p&gt;
&lt;p&gt;好了，漏洞堵上了，用时2天，客户贼开心，正在准备去找阿三干仗的时候出岔子了。&lt;/p&gt;
&lt;p&gt;细心的老铁可能发现了，上面的解决方案都是POST请求啊，GET呢？&lt;/p&gt;
&lt;p&gt;这个就是个事儿了，从网上调查的时候得知，这个CSRF全是针对POST的，压根就不管GET。&lt;/p&gt;
&lt;p&gt;比如这个文章：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://stackoverflow.com/questions/35473856/asp-net-mvc-csrf-on-a-get-request&quot; href=&quot;https://stackoverflow.com/questions/35473856/asp-net-mvc-csrf-on-a-get-request&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/35473856/asp-net-mvc-csrf-on-a-get-request&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿三哪个什么漏洞检测公司发回来一堆GET的URL。。。&lt;/p&gt;
&lt;p&gt;在跟客户说明原委之后，客户炸了。。。 要干阿三，然后就发了一系列言辞犀利的邮件，也CC了他们哪个阿三头头&lt;/p&gt;
&lt;p&gt;最后阿三们看有点失控，一个是我们POST改的太快了（47处），第二个是，没想到客户的IT急眼了。。。&lt;/p&gt;
&lt;p&gt;这时的阿三很尴尬，在邮件里回：我们有很丰富的修改漏洞的经验&lt;/p&gt;
&lt;p&gt;WTF？！！&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/621162/201808/621162-20180817121331561-1052127217.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还没等我们说话，客户直接回了一句：好！我现在约一个会，你们说说GET请求是怎么回事儿&lt;/p&gt;
&lt;p&gt;行了。。。 我去帮客户干仗了。。。&lt;/p&gt;
&lt;p&gt;想想跟印度人、韩国人、澳大利亚人加上我一个中国人开英语的会我就脑仁儿疼。。。。。。&lt;/p&gt;

&lt;p&gt;另外附加一个连接：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://weblogs.asp.net/dixin/anti-forgery-request-recipes-for-asp-net-mvc-and-ajax&quot; href=&quot;https://weblogs.asp.net/dixin/anti-forgery-request-recipes-for-asp-net-mvc-and-ajax&quot; target=&quot;_blank&quot;&gt;https://weblogs.asp.net/dixin/anti-forgery-request-recipes-for-asp-net-mvc-and-ajax&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 17 Aug 2018 04:18:00 +0000</pubDate>
<dc:creator>Caligula</dc:creator>
<og:description>最近我跟一个漏洞还有一群阿三干起来了…… 背景： 我的客户是一个世界知名的药企，最近这个客户上台了一位阿三管理者，这个货上线第一个事儿就是要把现有的软件供应商重新洗牌一遍。由于我们的客户关系维护的非常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caligula/p/9492675.html</dc:identifier>
</item>
<item>
<title>Haskell学习-monad - Jeff.Zhong</title>
<link>http://www.cnblogs.com/edwardloveyou/p/9485614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edwardloveyou/p/9485614.html</guid>
<description>&lt;p&gt;原文地址：&lt;a href=&quot;http://jeffzhong.space/2018/08/16/haskelld/&quot;&gt;Haskell学习-monad&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是monad&quot;&gt;什么是Monad&lt;/h2&gt;
&lt;p&gt;Haskell是一门纯函数式的语言，纯函数的优点是安全可靠。函数输出完全取决于输入，不存在任何隐式依赖，它的存在如同数学公式般完美无缺。可是纯函数因为隔绝了外部环境，连最基本的输入输出都无法完成。而 &lt;strong&gt;Monad&lt;/strong&gt; 就是 Haskell 给出的解决方案。但&lt;strong&gt;Monad&lt;/strong&gt; 并不仅仅是 IO 操作的抽象，它更是多种类似操作之间共性的抽象。所以 Monad 解决的问题并不局限在 IO 上，像 Haskell 中的 &lt;strong&gt;Maybe&lt;/strong&gt; 和 &lt;strong&gt;[]&lt;/strong&gt; 都是 &lt;strong&gt;Monad&lt;/strong&gt;。Haskell 中漂亮的错误处理方式， &lt;strong&gt;do&lt;/strong&gt; 表示法和灵活的列表推导式 (&lt;strong&gt;list comprehension&lt;/strong&gt;) 都算是 &lt;strong&gt;Monad&lt;/strong&gt; 的贡献。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Monad&lt;/strong&gt; 基本上是一种加强版的 &lt;strong&gt;Applicative Functor&lt;/strong&gt;，正如 &lt;strong&gt;Applicative Functor&lt;/strong&gt; 是 &lt;strong&gt;Functor&lt;/strong&gt; 的加强版一样。所以在充分理解 &lt;strong&gt;Applicative Functor&lt;/strong&gt; 的基础上，过渡到 &lt;strong&gt;Monad&lt;/strong&gt; 其实是非常平滑的。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;-- Monad的定义
class Monad m where
    return :: a -&amp;gt; m a
    (&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b
    (&amp;gt;&amp;gt;) :: m a -&amp;gt; m b -&amp;gt; m b
    x &amp;gt;&amp;gt; y = x &amp;gt;&amp;gt;= \_ -&amp;gt; y
    fail :: String -&amp;gt; m a
    fail msg = error msg&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; 跟其他语言中的 &lt;strong&gt;return&lt;/strong&gt; 是完全不一样的，它是一个把普通值包进一个 context 里面的函数，并不是结束函数执行的关键字。其实等价于Applicative中的 &lt;strong&gt;pure&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;gt;&amp;gt;&lt;/strong&gt; 忽略前面表达式的返回值，直接执行当前表达式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt; 接受一个 monadic value（也就是具有 context 的值，可以用装有普通值的盒子来比喻）并且把它喂给一个接受普通值的函数，并回传一个 monadic value。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;=&amp;lt;&amp;lt;&lt;/strong&gt; 和上面 &lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt; 功能一样，只是结合顺序相反。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;monad-的原理&quot;&gt;Monad 的原理&lt;/h2&gt;
&lt;p&gt;函数之间要协作，就必须以各种形式交互连接。但如何隔离纯函数与副作用函数，同时又能让两类函数相互复用呢？&lt;/p&gt;
&lt;p&gt;以 IO 操作为例子分析，为了充分隔离纯函数与 IO 函数，Haskell 中不能实现 &lt;strong&gt;IO Char -&amp;gt; Char&lt;/strong&gt; 这样一种输入是 IO 类型返回值却是普通类型的函数。否则副作用函数就能很容易变身为纯函数了。事实上一旦参数中有 IO，返回值必有 IO，这就保证了充分隔离。&lt;/p&gt;
&lt;p&gt;那如何让纯函数与 IO 函数相互复用呢？这就要靠 IO Monad 中定义的 &lt;strong&gt;return&lt;/strong&gt; 和 &lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt; 这两个函数了。&lt;strong&gt;return&lt;/strong&gt; （在 Haskell 中不是关键字，只是一个函数名）的作用是将某个类型为 &lt;strong&gt;A&lt;/strong&gt; 的值 &lt;strong&gt;a&lt;/strong&gt; 提升（装箱）为类型为 &lt;strong&gt;IO A&lt;/strong&gt; 的值 &lt;strong&gt;Char -&amp;gt; IO Char&lt;/strong&gt; 。有了这个函数后，纯函数就可以通过 &lt;strong&gt;return&lt;/strong&gt; 变成返回值为 IO 带副作用的函数了。&lt;/p&gt;
&lt;p&gt;有了提升而没有下降操作，怎么复合 &lt;strong&gt;putChar :: Char -&amp;gt; IO()&lt;/strong&gt; 与 &lt;strong&gt;getChar :: IO Char&lt;/strong&gt; 呢。 getChar 从 IO 读取一个字符， putChar 把字符写入 IO。但 &lt;strong&gt;getChar&lt;/strong&gt; 返回的是 &lt;strong&gt;IO Char&lt;/strong&gt; 类型，而 &lt;strong&gt;putChar&lt;/strong&gt; 需要的是普通的 &lt;strong&gt;Char&lt;/strong&gt; 类型，两者不匹配怎么办？ &lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt; 函数出马了！ &lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt; 的类型是&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;IO a -&amp;gt; (a -&amp;gt; IO b) -&amp;gt; IO b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样 &lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt; 就可以连接 &lt;strong&gt;getChar&lt;/strong&gt; 与 &lt;strong&gt;putChar&lt;/strong&gt; ，把输入写到输出中&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;getChar &amp;gt;&amp;gt;= putChar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 &lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt; 操作实际上是类型下降（或拆箱）操作，同时执行下降操作的函数返回值也必须是 IO 类型。这样既充分隔离纯函数与副作用函数，又能让函数相互复用。通过 &lt;strong&gt;return&lt;/strong&gt; 和 &lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt; 两个平行世界 (范畴) 就有了可控的交流通道。&lt;/p&gt;
&lt;h2 id=&quot;do-表示法&quot;&gt;do 表示法&lt;/h2&gt;
&lt;p&gt;Haskell的 do 表示法实际上是Monad的语法糖：它给我们提供了一种不使用 (&lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt;) 和匿名函数来写monadic代码的方式。去除do语法糖的过程就是把它转换为 (&lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt;) 和匿名函数。&lt;/p&gt;
&lt;p&gt;do 表示法可以使用分号 &lt;strong&gt;;&lt;/strong&gt; 和大括号 &lt;strong&gt;{ }&lt;/strong&gt; 将语句分块；但一般会使用一个表达式一行的方式，不同的作用域用不同的缩进区分。&lt;/p&gt;
&lt;p&gt;我们还是以IO 为例子，接受两次的键盘输入，然后将两次输入的字符串合并成一个字符串，最后屏幕打印输出。 &lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt; 会接受前面表达式的值；&lt;strong&gt;&amp;gt;&amp;gt;&lt;/strong&gt; 则会忽略前面表达式的值；这里使用 &lt;strong&gt;return&lt;/strong&gt; 实际它返回的仍然是IO String，因为Haskell会自动类型推导得出。monadic 的表达式代码如下：&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;(++) &amp;lt;$&amp;gt; getLine &amp;lt;*&amp;gt; getLine &amp;gt;&amp;gt;= print &amp;gt;&amp;gt; return &quot;over&quot;
111
222
&amp;gt; &quot;111222&quot;
&amp;gt; &quot;over&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 do改写，明显更加清晰，和我们熟悉的命令式语言风格差不多。&lt;br/&gt;&lt;strong&gt;&amp;lt;-&lt;/strong&gt; 表示从monadic value中取出普通值，可以看成是拆开盒子取出所需要的值。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;foo :: IO String  
foo = do  
    x &amp;lt;- getLine
    y &amp;lt;- getLine
    print (x ++ y)
    return &quot;over&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;do语法对应模式&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;do {e}             -&amp;gt; e
do {e; es}         -&amp;gt; e &amp;gt;&amp;gt; do {es}
do {let decls; es} -&amp;gt; let decls in do {es}
do {p &amp;lt;- e; es}    -&amp;gt; e &amp;gt;&amp;gt;= \p -&amp;gt; es&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;monad-类型&quot;&gt;Monad 类型&lt;/h2&gt;
&lt;p&gt;来看一下几个默认的Monad类型，它们都必须实现 &lt;strong&gt;return&lt;/strong&gt;,&lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt;,&lt;strong&gt;fail&lt;/strong&gt;这几个函数。&lt;/p&gt;
&lt;ol readability=&quot;36.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;Maybe&lt;/strong&gt;&lt;br/&gt;中间任何一步只要有&lt;strong&gt;Nothing&lt;/strong&gt;，结果就提前返回&lt;strong&gt;Nothing&lt;/strong&gt;。没有任何意外的情况才返回&lt;strong&gt;Just 值&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;-- Maybe 的 Monad instance
instance Monad Maybe where
    return x = Just x
    Nothing &amp;gt;&amp;gt;= f = Nothing
    Just x &amp;gt;&amp;gt;= f  = f x
    fail _ = Nothing

-- 实例
Just 3 &amp;gt;&amp;gt;= (\x -&amp;gt; Nothing &amp;gt;&amp;gt;= (\y -&amp;gt; Just (show x ++ y)))
&amp;gt; Nothing

Just 3 &amp;gt;&amp;gt;= (\x -&amp;gt; Just &quot;!&quot; &amp;gt;&amp;gt;= (\y -&amp;gt; Just (show x ++ y)))
&amp;gt; Just &quot;3!&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 do 表示法写成这样：&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;foo :: Maybe String
foo = do
    x &amp;lt;- Just 3
    y &amp;lt;- Just &quot;!&quot;
    Just (show x ++ y)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;59&quot;&gt;
&lt;p&gt;&lt;strong&gt;List&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt; 基本上就是接受一个有 context 的值，把他喂进一个只接受普通值的函数，并回传一个具有 context 的值。&lt;strong&gt;[ ]&lt;/strong&gt; 其实等价于 Nothing。&lt;/p&gt;
&lt;p&gt;当我们用 &lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt; 把一个 list 喂给这个函数，lambda 会映射每个元素，会计算出一串包含一堆 list 的 list，最后再把这些 list 压扁，得到一层的 list。这就是我们得到 列表 &lt;strong&gt;list&lt;/strong&gt; 处理 Mondic value 的过程。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;--list 的 Monad instance
instance Monad [] where
    return x = [x]
    xs &amp;gt;&amp;gt;= f = concat (map f xs)
    fail _ = []

-- 实例
[3,4,5] &amp;gt;&amp;gt;= \x -&amp;gt; [x,-x]
&amp;gt; [3,-3,4,-4,5,-5]

[1,2,3] &amp;gt;&amp;gt;= \x -&amp;gt; return (-x)
&amp;gt; [-1,-2,-3]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;list comprehension&lt;/strong&gt; 也不过是 &lt;strong&gt;Monad&lt;/strong&gt; 的语法糖&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;[1,2] &amp;gt;&amp;gt;= \n -&amp;gt; ['a','b'] &amp;gt;&amp;gt;= \ch -&amp;gt; return (n,ch) -- Monad
[ (n,ch) | n &amp;lt;- [1,2], ch &amp;lt;- ['a','b'] ] -- list comprehension
&amp;gt; [(1,'a'),(1,'b'),(2,'a'),(2,'b')]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;list comprehension&lt;/strong&gt; 的过滤基本上跟 guard 是一致的。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;[1..50] &amp;gt;&amp;gt;= (\x -&amp;gt; guard ('7' `elem` show x) &amp;gt;&amp;gt; return x)
&amp;gt; [7,17,27,37,47]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用 &lt;strong&gt;do&lt;/strong&gt; 改写, 如果不写最后一行 &lt;strong&gt;return x&lt;/strong&gt;，那整个 list 就会是包含一堆空 &lt;strong&gt;tuple&lt;/strong&gt; 的 list。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;sevensOnly :: [Int]
sevensOnly = do
    x &amp;lt;- [1..50]
    guard ('7' `elem` show x)
    return x

-- 对应的 list comprehension
[ x | x &amp;lt;- [1..50], '7' `elem` show x ]
&amp;gt; [7,17,27,37,47]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;Either&lt;/strong&gt;&lt;br/&gt;在 &lt;strong&gt;Control.Monad.Error&lt;/strong&gt; 里面有 &lt;strong&gt;Error&lt;/strong&gt;的 &lt;strong&gt;Monad instance&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;instance (Error e) =&amp;gt; Monad (Either e) where
    return x = Right x
    Right x &amp;gt;&amp;gt;= f = f x
    Left err &amp;gt;&amp;gt;= f = Left err
    fail msg = Left (strMsg msg)

Right 3 &amp;gt;&amp;gt;= \x -&amp;gt; return (x + 100) :: Either String Int
&amp;gt; Right 103&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;monad-规则&quot;&gt;Monad 规则&lt;/h2&gt;
&lt;ol readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;return a &amp;gt;&amp;gt;= f == f a&lt;/strong&gt;&lt;br/&gt;== 左边的表达式等价于右边的表达式。如果仅仅是把一个值包装到monad里面然后使用 (&lt;strong&gt;&amp;gt;&amp;gt;=&lt;/strong&gt;) 调用的话，我们就没有必要使用 &lt;strong&gt;return&lt;/strong&gt; ；这条规则对于我们的代码风格有着实际的指导意义：我们不应该写一些不必要的代码；这条规则保证了简短的写法和冗余的写法是等价的。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;return 3 &amp;gt;&amp;gt;= (\x -&amp;gt; Just (x+100000)) -- 和直接函数调用没有区别&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;m &amp;gt;&amp;gt;= return == m&lt;/strong&gt;&lt;br/&gt;这一条规则对风格也有好处：如果在一系列的action块里面，如果最后一句就是需要返回的正确结果，那么就不需要使用 return 了；和第一条规则一样，这条规律也能帮助我们简化代码。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt; Just &quot;move on up&quot; &amp;gt;&amp;gt;= return -- 可以不需要 return&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;(m &amp;gt;&amp;gt;= f) &amp;gt;&amp;gt;= g == m &amp;gt;&amp;gt;= (\x -&amp;gt; f x &amp;gt;&amp;gt;= g)&lt;/strong&gt;&lt;br/&gt;当我们用 &amp;gt;&amp;gt;= 把一串 monadic function 串在一起，他们的先后顺序不应该影响结果。&lt;br/&gt;而这不就是结合律吗？我们可以把那些子action提取出来组合成一个新action。&lt;br/&gt;(&lt;strong&gt;&amp;lt;=&amp;lt;&lt;/strong&gt;) 可以用来合成两个 monadic functions, 类似于普通函数结合(&lt;strong&gt;.&lt;/strong&gt;)， 而(&lt;strong&gt;&amp;gt;=&amp;gt;&lt;/strong&gt;) 表示结合顺序相反。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;(&amp;lt;=&amp;lt;) :: (Monad m) =&amp;gt; (b -&amp;gt; m c) -&amp;gt; (a -&amp;gt; m b) -&amp;gt; (a -&amp;gt; m c)
f &amp;lt;=&amp;lt; g = (\x -&amp;gt; g x &amp;gt;&amp;gt;= f)

-- 普通函数结合(.)
let f = (+1) . (*100)
f 4
&amp;gt; 401

-- 合成monadic functions (&amp;lt;=&amp;lt;)
let g = (\x -&amp;gt; return (x+1)) &amp;lt;=&amp;lt; (\x -&amp;gt; return (x*100))
Just 4 &amp;gt;&amp;gt;= g
&amp;gt; Just 401

-- 也可以将 monadic 函数用foldr,id 和(.)合成 
let f = foldr (.) id [(+1),(*100),(+1)]
f 1
&amp;gt; 201&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;monad-的---r-形态&quot;&gt;Monad 的 (-&amp;gt;) r 形态&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(-&amp;gt;) r&lt;/strong&gt; 不只是一个 &lt;strong&gt;functor&lt;/strong&gt; 和 &lt;strong&gt;applicative functor&lt;/strong&gt;，同时也是一个 &lt;strong&gt;monad&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;每一个 &lt;strong&gt;monad&lt;/strong&gt; 都是个 &lt;strong&gt;applicative functor&lt;/strong&gt;，而每一个 &lt;strong&gt;applicative functor&lt;/strong&gt;也都是一个 &lt;strong&gt;functor&lt;/strong&gt;。尽管 &lt;strong&gt;moand&lt;/strong&gt; 有 &lt;strong&gt;functor&lt;/strong&gt; 跟 &lt;strong&gt;applicative functor&lt;/strong&gt; 的性质，但他们不见得有 &lt;strong&gt;Functor&lt;/strong&gt; 跟 &lt;strong&gt;Applicative&lt;/strong&gt; 的 instance 定义。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;instance Monad ((-&amp;gt;) r) where
    return x = \_ -&amp;gt; x
    h &amp;gt;&amp;gt;= f = \w -&amp;gt; f (h w) w&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;monad-辅助函数&quot;&gt;Monad 辅助函数&lt;/h2&gt;
&lt;p&gt;带下划线函数等价于不带下划线的函数, 只是不返回值&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;= :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b
=&amp;lt;&amp;lt; :: (a -&amp;gt; m b) -&amp;gt; m a -&amp;gt; m b
form :: t a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m (t b)
form_ :: t a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m ()
mapM :: (a -&amp;gt; m b) -&amp;gt; t a -&amp;gt; m (t b)
mapM_ :: (a -&amp;gt; m b) -&amp;gt; t a -&amp;gt; m ()
filterM :: (a -&amp;gt; m Bool) -&amp;gt; [a] -&amp;gt; m [a]
foldM :: (b -&amp;gt; a -&amp;gt; m b) -&amp;gt; b -&amp;gt; t a -&amp;gt; m b
sequence :: t (m a) -&amp;gt; m (t a)
sequence_ :: t (m a) -&amp;gt; m ()
liftM :: (a1 -&amp;gt; r) -&amp;gt; m a1 -&amp;gt; m r
when :: Bool -&amp;gt; f () -&amp;gt; f ()
join :: m (m a) -&amp;gt; m a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中在 IO 中经常用到的一些函数&lt;/p&gt;
&lt;ol readability=&quot;16&quot;&gt;&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;strong&gt;sequence&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;sequence&lt;/strong&gt; 接受一串 I/O action，并回传一个会依序执行他们的 I/O action。运算的结果是包在一个 I/O action 的一连串 I/O action 的运算结果。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;main = do
    a &amp;lt;- getLine
    b &amp;lt;- getLine
    c &amp;lt;- getLine
    print [a,b,c]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实可以写成&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;main = do
    rs &amp;lt;- sequence [getLine, getLine, getLine]
    print rs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个常见的使用方式是我们将 &lt;strong&gt;print&lt;/strong&gt; 或 &lt;strong&gt;putStrLn&lt;/strong&gt; 之类的函数 map 到串列上。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;sequence (map print [1,2,3,4,5])
1
2
3
4
5
[(),(),(),(),()]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;mapM&lt;/strong&gt; 跟 &lt;strong&gt;mapM_&lt;/strong&gt;&lt;br/&gt;由于对一个串列 map 一个回传 I/O action 的函数，然后再 &lt;strong&gt;sequence&lt;/strong&gt; 这个动作太常用了。所以函式库中提供了 &lt;strong&gt;mapM&lt;/strong&gt; 跟 &lt;strong&gt;mapM_&lt;/strong&gt;。&lt;strong&gt;mapM&lt;/strong&gt; 接受一个函数跟一个串列，将对串列用函数 map 然后 sequence 结果。&lt;strong&gt;mapM_&lt;/strong&gt; 也作同样的事，只是他把运算的结果丢掉而已。在我们不关心 I/O action 结果的情况下，&lt;strong&gt;mapM_&lt;/strong&gt; 是最常被使用的。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;mapM print [1,2,3]
1
2
3
[(),(),()]

mapM_ print [1,2,3]
1
2
3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;form&lt;/strong&gt; 和 &lt;strong&gt;form_&lt;/strong&gt; 与 &lt;strong&gt;mapM&lt;/strong&gt; 和 &lt;strong&gt;mapM_&lt;/strong&gt; 类似，不过只是把列表参数提前。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;还有一些是在 &lt;strong&gt;monad&lt;/strong&gt; 中定义，且等价于 &lt;strong&gt;functor&lt;/strong&gt; 或 &lt;strong&gt;applicative functor&lt;/strong&gt; 中所具有的函数。&lt;/p&gt;
&lt;ol readability=&quot;21&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;liftM&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;liftM&lt;/strong&gt; 跟 &lt;strong&gt;fmap&lt;/strong&gt; 等价, 也有 &lt;strong&gt;liftM3&lt;/strong&gt;，&lt;strong&gt;liftM4&lt;/strong&gt; 跟 &lt;strong&gt;liftM5&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;liftM :: (Monad m) =&amp;gt; (a -&amp;gt; b) -&amp;gt; m a -&amp;gt; m b
liftM f m = m &amp;gt;&amp;gt;= (\x -&amp;gt; return (f x))

liftM (*2) [1,2]
&amp;gt; [2,4]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;ap&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;ap&lt;/strong&gt; 基本上就是 **&amp;lt;*&amp;gt;**，只是他限制在 Monad 上而不是 Applicative 上。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;ap :: (Monad m) =&amp;gt; m (a -&amp;gt; b) -&amp;gt; m a -&amp;gt; m b
ap mf m = do
    f &amp;lt;- mf
    x &amp;lt;- m
    return (f x)

ap [(*2)] [1,2,3]
&amp;gt; [2,4,6]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;join&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;m &amp;gt;&amp;gt;= f&lt;/strong&gt; 永远等价于 &lt;strong&gt;join (fmap f m)&lt;/strong&gt; 这性质非常有用&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;join :: (Monad m) =&amp;gt; m (m a) -&amp;gt; m a

join (Just (Just 9))
&amp;gt; Just 9

join [[1,2,3],[4,5,6]]  -- 对于 list 而言 join 不过就是 concat
&amp;gt; [1,2,3,4,5,6]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;filterM&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;filterM&lt;/strong&gt;，除了能做 filter 的动作，同时还能保有 monadic context。&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;filterM :: (Monad m) =&amp;gt; (a -&amp;gt; m Bool) -&amp;gt; [a] -&amp;gt; m [a]

filterM (\x -&amp;gt; return (x &amp;gt; 2)) [1,2,3,4]
&amp;gt; [3,4]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;foldM&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;foldl&lt;/strong&gt; 的 monadic 的版本叫做 &lt;strong&gt;foldM&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;haskell&quot;&gt;
&lt;code&gt;foldM :: (Monad m) =&amp;gt; (a -&amp;gt; b -&amp;gt; m a) -&amp;gt; a -&amp;gt; [b] -&amp;gt; m a

foldM (\x y -&amp;gt; return (x + y)) 0 [1,2,3]
&amp;gt; 6&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 17 Aug 2018 04:12:00 +0000</pubDate>
<dc:creator>Jeff.Zhong</dc:creator>
<og:description>原文地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edwardloveyou/p/9485614.html</dc:identifier>
</item>
<item>
<title>数据分析 第二篇：数据特征分析（统计量分析） - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/4440860.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/4440860.html</guid>
<description>&lt;p&gt;对于成功的数据分析而言，把握数据整体的性质是至关重要的，使用统计量来检查数据特征，主要是检查数据的集中程度、离散程度和分布形状，通过这些统计量可以识别数据集整体上的一些重要性质，对后续的数据分析，有很大的参考作用。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;一，基本统计量&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;用于描述数据的基本统计量主要分为三类，分别是中心趋势统计量、散布程度统计量和分布形状统计量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，中心趋势统计量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中心趋势统计量是指表示位置的统计量，直观地说，给定一个属性，它的值大部分落在何处？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）均值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;均值（mean）又称算数平均数，描述数据去指导额平均位置，数学表达式：均值 =  ∑x  /  n；&lt;/p&gt;
&lt;p&gt;有时，一组数据中的每个值可以和一个权重W&lt;sub&gt;i&lt;/sub&gt;相关联，权重反映的的是依附值的重要性或出现的频率，这种均值称作加权均值 =  ∑xw  /  n；&lt;/p&gt;
&lt;p&gt;尽管均值是描述数据集中心趋势的最有用的统计量，但是，它并非总是度量数据中心的最佳方法，这是因为，均值对极端值（离群点）很敏感。为了抵消少数极端值的影响，我们可以使用截尾均值，截尾均值是指丢弃极端值后的均值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）中位数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于倾斜（非对称）的数据，能够更好地描述数据中心的统计量是中位数（median），中位数是有序数据值的中间值，中位数可避免极端数据，代表这数据总体的中等情况。例如：从小到大排序，总数是奇数，取中间的数，总数是偶数，取中间两个数的平均数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）众数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众数（mode）是变量中出现频率最大的值，通常用于对定性数据确定众数，例如：用户状态（正常，欠费停机，申请停机，拆机、消号），该变量的众数是 “正常” 则是正常的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，表示数据离散程度的统计量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;度量数据离散程度的统计量主要是标准差和四分位极差。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）标准差（或方差）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标准差用于度量数据分布的离散程度，低标准差意味着数据观测趋向于靠近均值，高标准差表示数据散步在一个大的值域中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）四分位极差&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;极差（range），也称作值域，是一组数据中的最大值和最小值的差， range = Max - Min。&lt;/p&gt;
&lt;p&gt;百分位数（quantile）是把数据值按照从小到大的顺序排列，把数据分成100份。中位数是数据的中间位置上的数据，第一个四分位数记作Q1，是指第25个百分位上的数据，第三个四分位数记作（Q3），是指第75个百分位上的数据。&lt;/p&gt;
&lt;p&gt;四分位极差（IQR）= Q3 - Q1 ，IQR是指第一个四分位和第三个四分位之间的距离，它给出被数据的中间一半所覆盖的范围，是表示数据离散程度的一个简单度量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，表示分布形状的统计量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分布形状使用偏度系数和峰度系数来度量，&lt;/p&gt;
&lt;p&gt;偏度是用于衡量数据分布对称性的统计量：通过对偏度系数的测量，我们能够判定数据分布的不对称程度以及方向。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于正态分布(或严格对称分布)偏度等于0&lt;/li&gt;
&lt;li&gt;若偏度为负， 则x均值左侧的离散度比右侧强；&lt;/li&gt;
&lt;li&gt;若偏度为正， 则x均值左侧的离散度比右侧弱；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201808/628084-20180809182442962-1541696127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;峰度是用于衡量数据分布陡峭或平滑的统计量，通过对峰度系数的测量，我们能够判定数据分布相对于正态分布而言是更陡峭还是平缓。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正态分布的峰度为3，&lt;/li&gt;
&lt;li&gt;当时间序列的曲线峰值比正态分布的高时，峰度大于3；&lt;/li&gt;
&lt;li&gt;当比正态分布的低时，峰度小于3。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（1）偏度系数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;偏度系数反映数据分布偏移中心位置的程度，记为SK，则有 SK= (均值一中位数)/标准差。偏度系数是描述分布偏离对称性程度的一个特征数。&lt;/p&gt;
&lt;p&gt;正态分布的偏度为0，偏度&amp;lt;0称分布具有负偏离（左偏态），此时数据位于均值左边的位于右边的多，有个尾巴拖到左边，说明左边有极端值，偏度&amp;gt;0称分布具有正偏离（右偏态）。偏度接近如于0 ，可认为分布对称。例如：知道分布有可能在偏度上偏离正态分布，则可用偏度来检验分布的正态性。偏度的绝对值数值越大表示其分布形态的偏斜程度越大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）峰度系数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;峰度系数（Kurtosis）用来度量数据在中心聚集程度，记为K，描述总体中所有取值分布形态陡缓程度的统计量(与正态分布比较,，就是正态分布的峰顶)。&lt;/p&gt;
&lt;p&gt;例如：正态分布的峰度系数值是3，K&amp;gt;3的峰度系数说明观察量更集中，有比正态分布更短的尾部；K&amp;lt;3的峰度系数说明观测量不那么集中，有比正态分布更长的尾部。&lt;/p&gt;
&lt;p&gt;峰度系数公式是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201808/628084-20180805160224138-1930015522.png&quot; alt=&quot;&quot; width=&quot;202&quot; height=&quot;89&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例，本文使用vcd包中的Arthritis数据集来演示如何进行统计量分析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;head(Arthritis)
  ID Treatment  Sex Age Improved
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;   Treated Male  &lt;span&gt;27&lt;/span&gt;&lt;span&gt;     Some
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;   Treated Male  &lt;span&gt;29&lt;/span&gt;&lt;span&gt;     None
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;   Treated Male  &lt;span&gt;30&lt;/span&gt;&lt;span&gt;     None
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   Treated Male  &lt;span&gt;32&lt;/span&gt;&lt;span&gt;   Marked
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;   Treated Male  &lt;span&gt;46&lt;/span&gt;&lt;span&gt;   Marked
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;   Treated Male  &lt;span&gt;58&lt;/span&gt;   Marked
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中变量Improved和Sex是因子类型，ID和Age是数值类型。&lt;/p&gt;
&lt;h2&gt;二，集中趋势度量&lt;/h2&gt;
&lt;p&gt;集中趋势通过均值、中位数和众数来度量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，均值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;均值是所有数据的平均值，使用mean()函数来计算向量的均值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
age.mean &amp;lt;- mean(Arthritis$Age)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时，为了反映在均值中不同成分所占的权重，为数据中的每个元素&lt;strong&gt;X&lt;sub&gt;i &lt;/sub&gt;&lt;/strong&gt;赋予一个权重W&lt;sub&gt;i&lt;/sub&gt;，这样就得到了加权平均值，使用weighted.mean(x,w)来计算加权平均值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
weighted.mean(x,w)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;x为数据向量，w为权重向量，x中每一个元素都对应w中的一个权重值。&lt;/p&gt;
&lt;p&gt;根据Sex来设置权重（weight），男性的Age的权重为95%，女性的Age的权重为105%，那么得到的加权平均值是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
age.wt &amp;lt;- ifelse(Arthritis$Sex==&quot;Male&quot;,0.95,1.05&lt;span&gt;)
age.wt.mean &amp;lt;- weighted.mean(Arthritis$Age,age.wt)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果数据中存在极端值或者数据是偏态分布的，那么均值就不能很好地度量数据的集中趋势，为了消除少数极端值的影响，可以使用截断均值或者中位数来度量数据的集中趋势。截断均值是指去掉极端值之后的平均值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，中位数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中位数是把一组观察值从小到大按顺序排列，位于中间的那个数据。使用median(x)计算中位数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
age.median &amp;lt;- median(Arthritis$Age)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，众数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众数是指数据集中出现最频繁的值，众数常用于定性数据。R没有标准的内置函数来计算众数，因此，我们将创建一个用户自定义函数来计算数据集的众数。&lt;/p&gt;
&lt;p&gt;该函数以向量作为输入，以众数值作为输出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
getmode &amp;lt;-&lt;span&gt; function(v) {
   uniqv &amp;lt;-&lt;span&gt; unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三，离中趋势度量&lt;/h2&gt;
&lt;p&gt;衡量离中趋势的四个度量值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;值域（Range）的计算公式：Range = Max - Min&lt;/li&gt;
&lt;li&gt;标准差：度量数据偏离均值的程度&lt;/li&gt;
&lt;li&gt;变异系数（CV）：变异系数度量标准差相对于均值的离中趋势，计算公式是：CV=标准差/均值&lt;/li&gt;
&lt;li&gt;四分位数间距（IQR）是上四分位数Q&lt;sub&gt;U&lt;/sub&gt;和下四分位数Q&lt;sub&gt;L&lt;/sub&gt;之差，其间包含全部观察值的一般，其值越大，说明数据的变异程度越大，离中趋势越明显。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 查看Arthritis数据集的离中趋势：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
get_stat &amp;lt;-&lt;span&gt; function(v){
  v.mean &amp;lt;-&lt;span&gt; mean(v)
  v.median &amp;lt;-&lt;span&gt; median(v)
  v.range &amp;lt;- max(v)-&lt;span&gt;min(v)
  v.sd &amp;lt;-&lt;span&gt; sd(v)
  v.cv &amp;lt;- v.sd/v&lt;span&gt;.mean
  v.iqr &amp;lt;-  quantile(v,0.75) - quantile(v,0.25&lt;span&gt;)
  d.stat &amp;lt;- data.frame(mean=v.mean,median=v.median,range=v.range,sd=v.sd,cv=v.cv,iqr=v.iqr, row.names =&lt;span&gt; NULL)
}

mystat &amp;lt;- get_stat(Arthritis$Age) &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四，偏度和峰度&lt;/h2&gt;
&lt;p&gt;基础安装包中没有提供计算偏度和峰度的函数，用户可以自行添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
mystats &amp;lt;- function(x, na.omit=&lt;span&gt;FALSE){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (na.omit)
    x &lt;/span&gt;&amp;lt;- x[!&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.na(x)]
    m &lt;/span&gt;&amp;lt;-&lt;span&gt; mean(x)
    n &lt;/span&gt;&amp;lt;-&lt;span&gt; length(x)
    s &lt;/span&gt;&amp;lt;-&lt;span&gt; sd(x)
    skew &lt;/span&gt;&amp;lt;- sum((x-m)^&lt;span&gt;3&lt;/span&gt;/s^&lt;span&gt;3&lt;/span&gt;)/&lt;span&gt;n
    kurt &lt;/span&gt;&amp;lt;- sum((x-m)^&lt;span&gt;4&lt;/span&gt;/s^&lt;span&gt;4&lt;/span&gt;)/n - &lt;span&gt;3&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;(c(n=n, mean=m, stdev=s, skew=skew, kurtosis=&lt;span&gt;kurt))
}
myvars &lt;/span&gt;&amp;lt;- c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
sapply(mtcars[myvars], mystats)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为大家推荐一篇文章：&lt;a href=&quot;https://www.sohu.com/a/125526669_609133&quot; target=&quot;_blank&quot;&gt;关于偏度与峰度的一些探索&lt;/a&gt;，引用该文中的峰度影响实验的结论：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;尾部或离群点对峰度影响为正向，且影响程度最大。而高概率区对峰度影响也为正向，但是比较少；而山腰位置，中等概率区域则影响为负向。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sohu.com/a/125526669_609133&quot; target=&quot;_blank&quot;&gt;关于偏度与峰度的一些探索&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Aug 2018 03:32:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>对于成功的数据分析而言，把握数据整体的性质是至关重要的，使用统计量来检查数据特征，主要是检查数据的集中程度、离散程度和分布形状，通过这些统计量可以识别数据集整体上的一些重要性质，对后续的数据分析，有很</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/4440860.html</dc:identifier>
</item>
<item>
<title>美团在O2O场景下的广告营销 - 美团技术团队</title>
<link>http://www.cnblogs.com/meituantech/p/9492103.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/meituantech/p/9492103.html</guid>
<description>&lt;p&gt;美团作为中国最大的在线本地生活服务平台，覆盖了餐饮、酒店、旅行、休闲娱乐、外卖配送等方方面面生活场景，连接了数亿用户和数百万商户。如何帮助本地商户开展在线营销，使得他们能快速有效地触达目标用户群体提升经营效率，是美团的核心问题之一，而机器学习相关技术在本地在线营销场景下发挥着非常关键作用。&lt;/p&gt;
&lt;p&gt;本文将从5个方面来介绍。首先，介绍O2O场景下广告业务的特点，及其与B2B和B2C广告业务的差别；其次，从商户效果感知、用户体验和媒体平台收益三个维度，介绍O2O广告业务的最重要的考量指标；第三，从前两节阐述的业务特点和考量指标出发，介绍O2O场景下在线广告营销的机制设计；第四，介绍O2O特有的实时场景化下的推送广告；最后，简要介绍O2O广告系统相关的工具。&lt;/p&gt;
&lt;h2 id=&quot;o2o-&quot;&gt;O2O场景下的广告业务特点&lt;/h2&gt;
&lt;p&gt;在O2O业务模式和相关的平台崛起之前，大品牌的商家由于收入规模大、营销费用充分，为了提升品牌知名度依靠如下的途径开展宣传：传统媒体（如电视、广播、报纸）；互联网流量（如传统搜索引擎、门户网站等）；户外广告（如公交地铁车身、广告牌、灯箱等）。通过上述媒介，商户能快速接触大量的用户，宣传品牌的形象。上述营销方式也有其局限。首先广告投放的资金门槛较高，营销预算有限的商户无法承担相关费用；其次对于以直接效果为导向的商家来说，上述投放形式过于粗放且无法形成直接的购买转化效果闭环。对于大多数的中小商家来说，他们营销预算有限且更加注重直接的购买转化，获取潜在客户的主要途径是散发传单、派发礼物、沿街喇叭广告。但是，这些线下的营销手段覆盖到的潜在消费者较为有限，并且这些方式无法长期持续开展。&lt;/p&gt;
&lt;p&gt;以美团为代表的O2O本地生活服务平台快速成长壮大，逐渐成为广大本地服务商户在线营销的最重要的手段之一。美团平台上聚集了上亿的消费者，他们使用平台寻找商家、查询优惠信息、浏览评论。对于商户而言，他们是最直接的潜在消费者。通过在美团平台开展在线营销，商户能够获得更多的展示机会吸引更多客户到店消费。借助于便利的在线咨询、预定和支付手段，平台上的广告业务可以形成了效果闭环，商户能清晰准确掌握广告投放的效果并以此优化广告投放策略。&lt;/p&gt;
&lt;p&gt;对于美团而言，平台可以基于对用户大数据的挖掘和分析，在由时间、地点、用户和关系构成的特定场景下，连接用户线上和线下行为，理解并判断用户情感、态度和需求，为用户提供实时、定向、创意的信息和内容服务。&lt;br/&gt;O2O场景下的在线营销广告相较于传统的B2C和B2B商业模式下的广告有其独特属性，独特性主要体现在移动化、本地化、场景化以及多样性4个维度。&lt;/p&gt;
&lt;p&gt;随着宽带无线接入技术和移动终端技术的飞速发展，人们逐渐开始使用手机等移动设备随时随地从互联网上获取信息和服务。在这个时代，无论是新闻阅读、社交通信还是电子购物，人们都习惯于通过手机应用来直接满足自身的需求。事实上，美团在移动互联网发展的初期就主动适应了这一历史潮流，大力发展移动服务能力，目前已经有超过90%的交易行为是通过移动互联网服务达成的。O2O广告作为连接人和服务的本地化生活服务营销模式，它有鲜明的移动化和本地化的特点。&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;移动化&lt;/strong&gt;。它主要体现在精确性、即时性和互动性三个方面。通过移动设备的传感器，我们能精确了解用户所处的地理位置，推送更加精准的广告。绝大多数用户随时都把手机带在身边，所以广告信息能及时推送给用户。功能强大的各种移动应用，为广告提供了多种互动可能性，例如在美团App上，用户直接可以完成推广商户的信息查询、排队和交易。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;本地化&lt;/strong&gt;。以转化效果为导向的O2O广告营销，营销的目标用户是提供服务的本地商户附近的人群。在淘宝上，一双皮鞋可以对全国的用户开展推广和售卖，无论消费者在何地，物流和快递都会准确地把货物送达到消费者的手上。而在美团上，一家在五道口的火锅店最佳的推广对象是五道口附近的食客，这些食客才最有可能直接到火锅店来消费。实际上，通过观测实际的交易数据，我们发现超过90%的交易中用户和商户的距离小于3公里。营销活动要取得好的效果，必须针对性地选择目标群体，在O2O广告中目标群体就是本地化的用户人群。移动设备的精确定位为商户发现目标人群提供了保证。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;场景化&lt;/strong&gt;。消费者、移动设备、时间、空间构成了用户消费需求的精准场景。PC时代，用户的标识以Cookie为载体，但Cookie极易清除，同时一台电脑可能会被多人使用，这导致用户信息很难有效串联，连受众年龄、居住地等基础信息都无法准确把握。而在移动互联网时代一机一人的模式下，通过分析和挖掘用户在平台上留下的各种行为足迹，我们能对用户方方面面的属性和偏好进行解析和重构，产出十分精准的用户画像。在了解用户的地理位置、消费意图和行为轨迹等用户信息前提下，O2O广告营销能在由时间、地点、用户和需求构成的特定场景下，为用户提供实时、定向和富有创意的营销内容，连接用户线上和线下的行为。例如在一个阳光明媚的下午，对一个在CBD上班并有喝下午茶习惯的白领，平台可以适时地推送下午茶或者咖啡店商户。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;多样性&lt;/strong&gt;。O2O商业模式面对的是各式各样的本地生活服务业务，不同的业务有着不同的特点，并对O2O广告营销也提出了不同的需求。举个简单的例子，不同的服务业务对目标用户的本地性要求也大相径庭：餐饮类服务对距离比较敏感，这一类服务商家的目标用户群体是商户周边的食客；婚纱摄影类服务对距离就没那么敏感了，这一类服务商家的目标群体是全城的新婚夫妇。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;-&quot;&gt;商户、用户和平台三者利益平衡&lt;/h2&gt;
&lt;p&gt;广告系统和搜索系统、推荐系统，有着十分相似的系统架构：它们大都采用了检索加排序的流程体系。基于这一点，有很多人认为广告业务和搜索推荐业务没有区别。实际上，广告业务有其独特规律。广告首先是一项商业活动，它的出现远远早于互联网。作为一种商业活动，商户、消费者和媒体平台三者的利益都要被重视和考虑，这些利益指标是广告业务得以可持续健康发展的启明灯。本节将从商业活动的角度出发，分析美团O2O广告营销中的商户效果感知、用户体验和平台收益这三项重要指标。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;商户效果感知&lt;/h3&gt;
&lt;p&gt;商户在美团广告平台上进行广告营销的根本目的，是通过美团触达更多的潜在消费者，获得最大的增量利益。&lt;br/&gt;本地生活服务类型的商家的成本可以分为两个部分：变动成本和固定成本。变动成本是随着业务量变动而线性变动的成本，主要来自原料消耗。而固定成本是在一定时期内是不会随着业务量的改变而改变的成本，如门面装修的投入、店铺的租金、店铺服务人员的基本工资等。商户如果没有足够的业务量，不能招揽足够多的消费者，则单位业务量的成本会居高不下，导致严重亏损。因此，对于餐饮行业，商家的首要目标是提升翻桌率、减小空座率，而对于酒店行业，商家的首要目标是提升满房率、减少空房情况。固定成本的存在是本地商户开展O2O广告营销的基本前提。&lt;/p&gt;
&lt;p&gt;从商户的角度出发，O2O广告营销的效果可以从三个维度来衡量：广告的可见性、广告带来的线上增量收益和广告带来的整体增量收益。&lt;/p&gt;
&lt;p&gt;对于商户来说，可见性是最初步且最直接的营销结果，是商户得到的最快的效果反馈。广告的可见性表示商户的营销信息已经开始通过媒体平台去触达潜在的消费群体。因此，稳定可靠的广告展现预期是赢得广大商户对O2O广告营销信任的最基础要求。&lt;/p&gt;
&lt;p&gt;广告带来的线上增量收益是指通过在美团等媒体平台上的广告投放带来的线上收益。这一部分收益可以分为两类：一类是直接的在线订单带来的收入，例如团购、酒店预订等；另一类则是在线预约等非直接交易带来的收益。对这一部分收益，平台方能给出准确的统计、分析并反馈给广告商户。对于外卖、婚纱摄影和酒店旅游等对线上流量、线上交易依附度很高的行业来说，它们的线上收益占整体收益的比例非常大，这个比例直接反映了商户的经营活动的状况。&lt;/p&gt;
&lt;p&gt;除了直接使用在线交易，用户使用美团的另一种场景是通过平台查看商户菜品、评价和地理位置等信息，然后直接到店进行消费。广告给商户带来的整体增量收益即包含了这部分离线客户引流带来的收益。餐饮类的商户的线上交易只占门店整体收益的一小部分，因此，对广告效果的衡量需要综合考虑在线和离线两部分收益。离线引流部分收益相对于在线交易收益较难准确统计，但是平台可以通过用户的实时地理位置准确统计部分用户的到店情况，或者通过曝光、点击至到店的数据漏斗模型对到店数据进行估计。未来随着电子化支付方式的普及，平台将能更好地对商户的整体收益进行统计。&lt;/p&gt;
&lt;p&gt;了解了O2O广告营销效果的主要衡量指标后，要确定商户的广告投放成本是否真的较低，需要用到投入产出比（Return over Investment，ROI）这一常用的评价指标，即某次广告活动的总产出与总投入的比例。对应于两种广告收益指标，ROI也可以分为在线支付ROI和整体ROI：在线支付ROI等于在线增量交易额除以广告费消耗，整体支付ROI等于整体门店收入增量除以广告费消耗。在广告费预算有限的情况下，商户总是寻求优化广告投放，提升ROI。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;用户体验&lt;/h3&gt;
&lt;p&gt;有效地保障用户体验，是美团开展O2O广告营销的基本前提条件。平台只有保障用户体验、对用户有用，它的价值才能得到体现。美团通过让更多的用户留存并活跃在平台上，才能吸引更多的本地生活服务商户来进行广告投放，才能生成更大的流量用以广告变现。&lt;/p&gt;
&lt;p&gt;美团主要从短期和长期两个维度来进行用户体验指标的设计和度量。从信息曝光、用户点击和用户交易这个用户行为漏斗出发，短期用户体验指标主要考虑了点击和交易情况。第一个短期用户体验指标是点击率（Click through Rate，CTR），其数学表达为点击次数（Click）除以曝光次数（Impression）。点击率反映了给用户展示的商户信息的质量和相关性，与用户意向无关的、与用户所处时间地点场景不匹配的广告信息展示，不能满足用户的需求、吸引用户的点击，从而导致较低的点击率。点击率这一指标又细分为广告曝光的点击率和整体页面的点击率，前者度量了广告本身的优劣，后者反映了广告对整体信息呈现效果（自然结果加广告结果）的影响。劣质的广告除自身点击率较低之外，还会搅扰用户整体浏览行为，使得用户不能愉悦获取需要的本地生活服务信息。&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;CTR=点击次数/曝光次数&lt;/strong&gt;&lt;/center&gt;
&lt;p&gt;为了获得真实的曝光，一般会在移动端进行埋点监控每个POI在手机屏幕上实际展现的比例和时间，将超过一定展示比例和时间阈值的POI纳入曝光次数的统计。&lt;/p&gt;
&lt;p&gt;第二个短期用户体验指标是转化率（Conversion Rate，CVR），其数学表达为交易次数（Order）除以点击次数（Click）。转化率同样反映了商户信息展示的相关性和质量，和用户需求不相匹配的商户展示将不能促成交易的达成，从而导致较低的转化率。和点击率指标类似，转化率指标亦可分为广告转化率和整体页面转化率。其中广告转化率还和商户的在线交易ROI成正比，准确有效的广告投放，不仅可以提升用户体验，还能提升商户的ROI。&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;CVR = 交易次数/点击次数&lt;/strong&gt;&lt;/center&gt;
&lt;p&gt;长期用户体验指标以更长的时间跨度为出发点，评价广告对用户的长期持续影响。长期用户体验指标主要包括回访率和复购率两个指标。回访率是一个反映用户长期留存的指标，其意义为一定时期内用户是否还会重新登录和使用美团平台。回访率指标包括周回访率、月回访率等。低质量的广告投放，搅扰了用户使用平台方便获取商户信息的感受和体验，使得用户脱离平台以致流失，从而导致回访率降低。复购率则反映了用户消费体验的指标，其意义是一定时期内用户是否会重新购买某一个商家的服务。同样，低质量的商户服务会损害了用户的消费体验，使得用户不再进行同样的消费，进而导致了复购率的下降。&lt;/p&gt;
&lt;p&gt;为了准确衡量广告投放带来的用户体验影响，除了进行策略变更对比测试之外，平台会长期保留一小部分流量作为对照组，不对这部分用户开展广告投放，通过比较整体流量和对照组上相关用户体验指标的差异，来确定广告对用户体验的长期影响，进而督促和指导平台优化广告投放策略。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;平台收益&lt;/h3&gt;
&lt;p&gt;美团作为媒体平台的目标是，在保障商户ROI和用户体验的情况下，优化流量变现效率，实现商户营销诉求和用户消费诉求的最佳连接。&lt;/p&gt;
&lt;p&gt;前两节已经介绍了商户ROI和用户体验的基本概念。我们知道只有保障商户的ROI，才会有更多的商户、更多的预算进入到广告投放系统内；只有保障用户的体验，才会有更多的用户、更多的流量用于广告变现。这两者决定了广告业务这一块奶酪的大小。&lt;/p&gt;
&lt;p&gt;流量变现效率衡量单位流量所能带来广告收益。对于展示广告业务，流量变现效率主要用千次广告展示收益（Revenue per Mille，RPM）来表示。对于搜索广告，流量变现效率主要用单次搜索广告收益（Revenue per Search，RPS）来表示。&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;广告收入=曝光次数×CTR×CPC&lt;/strong&gt;&lt;/center&gt;

&lt;center&gt;&lt;strong&gt;广告收入=广告主数×ARPU&lt;/strong&gt;&lt;/center&gt;
&lt;p&gt;从流量供给端来看，广告收入（Revenue）是广告曝光次数、点击率和点击单价（CPC）的乘积；从流量需求端来看，广告收入是广告主数量和每用户平均收入（Average Revenue Per User，ARPU）的乘积。在广告商户数、预算和流量情况稳定的前提条件下，流量变现效率的提高主要通过点击率和点击单价两个关键指标驱动，而这两个指标的良性提高依赖于广告投放的机制设计和投放算法，详细内容将在下文展开陈述。&lt;/p&gt;
&lt;h2 id=&quot;o2o-&quot;&gt;O2O广告机制设计&lt;/h2&gt;
&lt;p&gt;前面介绍了美团O2O广告营销的特点，分析了商户、用户和平台三者的利益情况。本节将从上述特点和利益情况出发，阐述美团实际业务中O2O广告机制的设计原理，包括广告位设定、广告召回机制和广告排序机制。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;广告位设定&lt;/h3&gt;
&lt;p&gt;在移动端，美团的自然结果以列表的样式进行信息呈现，而广告占用列表中的固定位置（区间浮动固定位置）进行展现。从商户的效果感知角度出发，固定位广告形式能给商户以较为确定的广告展现预期，使得商户有明确的竞价标的（即固定展现位置）。&lt;/p&gt;
&lt;p&gt;广告位的设定，需要综合考虑和平衡商户、用户和平台三者的利益关系。过于密集的广告位置设计和广告展现会降低用户寻找商户信息的效率，影响用户使用体验。过于稀疏的广告位置设计导致广告展现机会过少，导致平台流量变现效率能力不足。头部广告位对用户体验影响较大，但是能获取更多的曝光，更有价值，更能激发商户的出价意愿。腰尾部广告位对用户体验影响较小，但是广告位曝光概率小，不能有效刺激商户出价。美团的实际广告位设定，一方面考虑了各个展位和业务的自身特点，另一方面通过A/B测试进行多种方案的比较和选择，最终选择能有效兼顾用户体验、商户效果和平台收入的设计方案。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;广告召回机制&lt;/h3&gt;
&lt;p&gt;广告召回在技术上与搜索和推荐十分相似。搜索场景广告会使用用户的查询词去广告商户索引中去寻找匹配的商户，推荐场景广告会根据用户的意图、位置等场景信息去匹配合适的商户。&lt;/p&gt;
&lt;p&gt;搜索广告匹配中，一项重要技术是查询改写。一方面，我们使用传统的自然语言处理方法，对查询进行有效分析（例如成分分析），完成同义和近义改写；另一方面，我们使用深度语义相似度神经网络模型（DSSM）和序列到序列模型（Sequence to Sequence）进行查询的改写，进一步提升广告匹配的覆盖率和准确性。&lt;/p&gt;
&lt;p&gt;针对O2O商业模式的特点和广告业务各方的利益，广告召回机制在传统搜索推荐召回机制基础上进行了优化改进。我们在召回中引入了逐层召回的理念，各层依次设置由紧到松的相关性水准（Match Level）控制召回广告的质量，在当前相关性水准已经召回足够数量广告候选的情况下，不再进行后续召回。&lt;br/&gt;相关性水准考虑多种相关性因素：查询匹配模式、距离和星级等。例如针对Query匹配模式，广告召回时会优先使用Query精确匹配模式召回，其次选择模糊匹配模式，最后才尝试采用语义匹配模式。针对距离因素，广告召回会优先召回距离3公里内的商户，其次选择5公里内的商户，最后尝试全城召回。&lt;/p&gt;
&lt;p&gt;相关性水准的设置应该充分考虑到不同O2O业务的特点。例如距离的设置上，对于餐饮类流量，系统会优先召回3公里内的商户，而对于距离相对不敏感的婚纱摄影类流量，系统则会放宽限制，优先召回10公里内的商户，或者直接采用全城召回策略。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;广告排序机制&lt;/h3&gt;
&lt;p&gt;和传统的搜索广告业务一样，美团的广告是按点击计费（Cost Per Click，CPC）广告，广告主依据广告的点击价值进行出价（bid），广告系统按照RankScore（RankScore为出价和广告质量度的乘积）进行广告排序。在广告系统中，广告质量度一般用广告的预估点击率来衡量。&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;RankScore=bid×CTR&lt;/strong&gt;&lt;/center&gt;
&lt;p&gt;广告按照RankScore排序后，会依据广义第二价格（Generalized Second Price）进行计费。&lt;/p&gt;
&lt;center&gt;charge&lt;span&gt;i&lt;/span&gt;=（CTR&lt;span&gt;i+1&lt;/span&gt;×bid&lt;span&gt;i+1&lt;/span&gt;）/CTR&lt;span&gt;i&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;由此可知，准确的预测广告的点击率是保障广告收入和用户体验的前提。广告点击率预估问题是一个典型的监督机器学习问题，它的目标是在给定广告商户、用户和查询上下文的前提下准确预测点击行为发生的概率。这个监督学习问题的特征我们用x表示，目标用y∈{1，-1}表示（广告曝光后获得点击为1，否则为-1）。通过收集线上的广告曝光和点击日志，我们可以获得大量的标注样本{（𝑥&lt;span&gt;i&lt;/span&gt;，𝑦&lt;span&gt;i&lt;/span&gt;）}作为监督学习的训练数据。&lt;/p&gt;
&lt;p&gt;我们使用参数模型拟合这个概率：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/g1.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;
&lt;p&gt;其中，𝑤监督学习问题即是搜索𝑤使得目标损失函数最小的一个优化问题:&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/g2.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/g3-4.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;
&lt;p&gt;其中，𝐿(𝑦, 𝑓(𝑥, 𝑤))是模型的损失函数，在点击率预估问题中一般使用负Log似然函数（Negative Log-Likelihood）作为损失函数。优化问题（公式1）是原始的点击率预估问题，优化问题（公式2）引入了正则项𝑅(𝑤)，用以控制模型的复杂度，防止模型过拟合。此外当我们选择L1范数作为正则项的时候，我们能获得稀疏解，缩减模型大小，进而减少线上服务加载模型的内存需求，提升模型的预测速度。下面我们简要介绍几种常用的点击率预估模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑回归模型&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/g5.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;
&lt;p&gt;逻辑回归模型是广泛应用的点击率预估模型，它是一种线性模型，相应的优化问题有非常好的性质。它是一个无约束的凸优化问题，有全局唯一的最优解。它支持大规模的特征，通过常用的梯队方法能较快收敛到最优解。逻辑回归模型的可解释性十分优良，通过特征对应的权重我们能很好分析各个特征的重要性以及它们对点击率的影响关系。&lt;/p&gt;
&lt;p&gt;逻辑回归也有它的劣势：首先，作为线性模型，它的表达能力相对较弱，需要通过大量的特征工程工作（例如，特征组合）来弥补和提升模型的表达能力；其次，它需要进行大量的特征预处理工作，例如特征归一化、离散化等。&lt;/p&gt;
&lt;p&gt;逻辑回归作为基础模型和其他模型相结合，扬长避短，充分发挥其作用。例如逻辑回归和梯度提升决策树结合，通过梯度提升决策树解决特征离散化和特征组合问题，并充分发挥逻辑回归对大规模特征的支持和良好的优化问题性质。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因子分解机FM模型和场感知因子分解机FFM模型&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/g6.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/g7.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;
&lt;p&gt;FM模型和FFM模型是非线性模型，它们对特征进行两两组合，提升了模型的表达能力。此外FM和FFM模型都对特征进行向量化的表达和学习（W&lt;span&gt;i&lt;/span&gt;，W&lt;span&gt;i&lt;/span&gt;,f&lt;span&gt;j&lt;/span&gt;）提升模型的泛化能力。FFM相对于FM引入了域的概念，在FM中特征i和其他特征组合用的是同一个向量表示，而在FFM中特征i和不同域的特征组合会使用不同的向量表示，进一步提升了模型的复杂度和表达力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人工神经网络（Artificial Neural Network，ANN）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;近几年神经网络模型强势复兴，以深度神经网络为代表的方法，在图像识别、语音识别以及自然语言处理等领域超越传统浅模型，取得了突破性的进展。在点击率预估这个任务上，最近也涌现出一批深度神经网络模型，取得了明显的效果，其中典型的模型是Wide &amp;amp; Deep模型。&lt;/p&gt;
&lt;p&gt;Wide &amp;amp; Deep模型包含Wide和Deep两个部分。Wide部分可以类比逻辑回归模型，能对相关特征的作用进行很好的记忆。Deep部分类似FM模型和FFM模型，它们都对相关特征进行了向量化的表示（Embedding）和学习，但是Deep部分通过复杂的网络结构可以表达更复杂的特征交互和组合关系，提供了更好的泛化能力和表达力。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/g8-9.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;
&lt;p&gt;梯度方法是模型的优化（优化问题的求解）的基础方法。公式3是使用标准梯度方法求解点击率预估优化问题公式1的迭代步骤。在点击率预估问题中，由于训练样本数量庞大（十亿、百亿），直接应用公式3计算量巨大，迭代速度受限。因此在点击率预估问题中，我们一般使用随机梯度下降法（Stochastic Gradient Descent，SGD）进行问题求解。在SGD方法（公式4）中，我们使用一小部分样本上的梯度对整体优化目标的梯度进行近似估计，加快参数迭代速度。其中b是样本集合大小，当b=1时，我们用单样本的梯度来近似整体目标函数的梯度值。&lt;/p&gt;
&lt;p&gt;在美团我们使用参数服务器框架（Parameter Server）实现模型并行和数据并行，以解决包含大规模训练数据和特征的复杂模型求解问题，如图1所示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/%E5%9B%BE%E7%89%871.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;

&lt;center&gt;图1　参数服务器框架&lt;/center&gt;
&lt;p&gt;特征工程方面，点击率预估特征主要从广告、用户和查询这三个方面来挖掘和刻画广告展现场景（见图2），特征需要包含影响点击率的方方面面，是模型成败的重要因素。特征的选取需要从业务场景出发。在O2O场景下，一个影响点击率的重要特征就是商户和用户之间的距离。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/%E5%9B%BE%E7%89%872.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;

&lt;center&gt;图2　点击率预估的特征&lt;/center&gt;
&lt;h2 id=&quot;o2o-&quot;&gt;O2O推送广告&lt;/h2&gt;
&lt;p&gt;在O2O场景下，除了搜索推荐广告，推送广告也非常重要。推送广告就是媒体在合适的时机将合适的广告以消息的形式推送给合适的人群。推送广告的主要目标是：提升用户活跃度、实现人群精准触达。美团注册用户有3.5亿，但是日活跃用户只有3000万，年活跃用户也只有1亿，还有很大一部分用户平时不登录美团App，或者登录次数很少。给这部分用户推送广告，引导用户打开App，有助于提高用户活跃度。另一方面，推送广告通过丰富的人群定向，实现精准投放。要实现精准触达，需要做到两点：有完整的用户画像，用户画像包含属性标签、偏好标签和行为标签，我们以此来判断用户对广告的兴趣；智能匹配技术，将广告精准定位到合适的用户上。&lt;/p&gt;
&lt;p&gt;推送广告的特点是：主动触达、用户意图不明确。理论上来说，推送广告可以在任意时间给任意用户推送任意广告，而搜索广告只能在用户搜索或者筛选的时候给用户展示广告。但推送广告的劣势是用户意图不明确，而搜索广告具有搜索词或者明确的筛选条件，这些都是明确的用户意图。所以相比搜索广告，推送广告更需要精准的受众定向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;受众定向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用的定向方式有下面几种：&lt;/p&gt;
&lt;ul readability=&quot;12&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;时间定向&lt;/strong&gt;。时间定向能够让品牌根据消费者行为、营业时间，甚至是季节性活动或特殊事件来进行广告投放。举个例子，美发沙龙只有白天营业，如果定向时间包括了晚上非营业时段，那么用户在晚上非营业时间看到广告后，无法通过打电话来预约，这样就没有转化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;重定向&lt;/strong&gt;。它指根据用户的历史行为，将曾在商家发生过浏览、收藏、购买等行为的用户作为商家的精准定向人群，进行广告推送，拉回用户完成转化。通常情况下，消费者不会看过就能记住，你需要重定向。根据重定向推送广告是通过视觉方式提醒消费者有关商家产品信息的好方式。消费者看到后可能会想：“啊，我忘了要买这双鞋……”而这种面包屑式的提醒方式往往能够诱使他们点击并购买。重定向方式是所有定向方式中最精准、投资回报率最高的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;地理位置类定向&lt;/strong&gt;。它指的是根据用户实时地理位置（一般是蜂窝信息或者GPS经纬度）做一些定向，有助于帮助商家触达那些正在前往商家所在区域的消费者，包括距离定向、商圈定向等。这种定向方式在移动设备上投放广告时有着非常重要的作用。比如本地的一家美发沙龙，想要招揽本地生意，那么就可以使用地理位置定向技术在特定半径内进行宣传。如果这家店在三角区内有发廊的特许经营权，那么它就可以使用该技术进行一个以上定位。当然针对各区域进行定向的时候，商家可以根据区域内业务发展状况调整出价。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;人口属性定向&lt;/strong&gt;。人口属性标签包括性别、年龄、收入水平、婚姻状况、是否有车、是否有小孩等。通过人口属性标签，可以将广告推送给相关消费者，就是可能购买的人群，具体选择什么标签主要取决于商家销售的是什么产品。例如婚纱摄影类商家会选择婚姻状况标签为“未婚”的人群进行广告投放，美甲美睫类商家会选择性别标签为“女性”的人群进行广告投放。这些标签里面，性别、年龄这种标签比较容易得到，因为用户注册的时候就提供了相关信息；而收入水平这种标签需要通过预估得到。使用人口属性定向的时候，标签既不能过于笼统，也不能太过细分。例如美甲美睫商家选择年龄标签的时候，一方面，不能选择0~60岁，这种人群太泛了，低年龄段和高年龄段人群可能没有很强烈的美甲美睫需求。另一方面，也要防止对人群太过细分，例如，尽管最终可能需要选择一个更细化的年龄标签，但却不能仅仅定位为一个具体年龄，若只选择22岁的人群，这可能导致人群覆盖不完整。时刻记住目标受众，但在定位的时候得找到一个折中的办法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;行为定向&lt;/strong&gt;。它是从用户的行为数据中挖掘用户兴趣偏好，从而推送相应的广告。行为数据包括频道、商家详情页、团单详情页的浏览和点击，用户评论和打分等。兴趣偏好一般分为长期、短期和实时偏好。当我们挖掘用户长期偏好的时候，使用的是“一段时间内的行为”，需要对不同时间的行为计算不同的权重，因为用户的兴趣是动态变化的，三个月前用户商圈偏好是A，可能现在搬家了商圈偏好变成了B。为了衡量不同时间行为权重，将行为累计控制在一段时间内，一般使用滑动窗口法和时间衰减法。兴趣偏好包括品类偏好、价格偏好、商圈偏好等。品类偏好指的是用户偏好的商品和服务的品类，例如，用户喜欢吃川湘菜还是江浙菜，喜欢火锅还是自助餐；价格偏好指的是用户的消费水平，例如，用户点外卖价格区间是偏好0~20元价位还是偏好20~40元价位。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;新客推荐&lt;/strong&gt;。即Look-alike，以广告主的老顾客作为种子信息，结合广告平台的大数据，寻找出老顾客具有的某种特征或规律，为广告主找到具有相同特征或规律的潜在顾客。这种方式可在保证精准定向效果的同时，扩大用户覆盖面。例如一个川菜馆广告主想投放广告，目标人群除了在本店消费过的顾客外，还可以选择在别的川菜馆或者湘菜馆消费过的顾客，因为他们可能口味差不多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用户在平台上的搜索、浏览、收藏、购买等行为会被记录下来，形成用户日志。通过对用户日志的分析和挖掘得到用户画像，包括用户基本属性、兴趣偏好、行为标签等。广告定向是广告和用户匹配的过程，为每个广告找到适合的受众群体。广告投放后，需要统计定向效果，包括定向精准程度和覆盖率。精准定向广告的运作流程如图3所示。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/%E5%9B%BE%E7%89%873.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;

&lt;center&gt;图3　精准定向广告流程&lt;/center&gt;
&lt;p&gt;为了实现广告和用户的匹配，首先需要为广告的受众人群进行初步假设，即确定广告感兴趣的人群，并将其与用户画像标签映射起来，这一步要靠产品调研和分析得到。然后根据这个初步假设确定广告投放的定向条件，匹配到符合条件的人群。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单个定向条件的表示。每一个定向条件都用一个&amp;lt;key, value=&quot;&quot;&amp;gt;对来表达。比如，职业分为学生和白领两种，定向条件为学生时表示为 &amp;lt;&quot;Professional&quot;, &quot;Student&quot;&amp;gt;。&lt;/li&gt;
&lt;li&gt;组合定向条件的表示。广告主设定的定向条件组合往往非常复杂，是各种不同定向条件的组合，涉及交、并、取反等操作。我们采用析取范式（Disjunctive Normal Form，DNF）的形式来存储广告的定向条件。下面以几个例子来说明DNF的表达方式。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;DNF1: （30岁 男性）∪（25岁 女性）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;DNF2: （广东人 广东男性）∪（北京人 北京品牌新客）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;DNF3: （非男性）∪（男性 实时位置在店铺周围2公里范围）∪（喜欢美食的）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这样的表达形式中，有两点需要说明：第一，每个DNF可以分解成一个或者多个合取范式（Conjunction Normal Form，CNF），DNF1 ＝ C1∪ C2，其中，C1 ＝（30岁 男性）， C2 ＝（25岁 女性）；第二，每个CNF可以分解成一个或者多个条件的交。上例中的C1 ＝ A1 ∩ A2，其中A1 ＝ 30岁，A2 ＝男性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;定向条件匹配&lt;/strong&gt;。定向匹配过程如图4所示。一个定向请求包括用户ID和广告投放ID，首先根据用户ID去取用户标签，根据广告投放ID取定向包，将定向包解析表达成DNF的形式，然后与用户标签进行匹配。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定向效果评价&lt;/strong&gt;。定向效果一般从质和量两个方面进行评估。质指的是精准程度，主要指标是点击率和转化率。量指的是覆盖程度，主要指标是用户覆盖率、广告主使用率以及定向方式对应的流量占比。&lt;/li&gt;
&lt;/ul&gt;&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/%E5%9B%BE%E7%89%874.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;

&lt;center&gt;图4　定向匹配过程&lt;/center&gt;
&lt;p&gt;在美团推送广告中，重定向方式点击率和转化率最好，但覆盖率最低；地理位置定向和人口属性标签拥有更广泛的人群，效果相对较差。实际采用哪种定向，需要看广告主的推广需求，广告主需要综合考虑精准程度和覆盖率的平衡。&lt;/p&gt;
&lt;h2 id=&quot;o2o-&quot;&gt;O2O广告系统工具&lt;/h2&gt;
&lt;p&gt;“工欲善其事必先利其器”，有效的工具是一个优秀高效的广告生态的重要组成部分。本节我们从面向开发人员、面向广告主和运营人员两个角度进行简述。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;面向开发人员的系统工具&lt;/h3&gt;
&lt;p&gt;面向开发者的工具主要包含三个方面：离线数据分析工具、实时数据分析工具以及在线广告系统调试工具。&lt;/p&gt;
&lt;p&gt;离线数据分析工具支持从各个维度（广告位、广告类型、时间、区域、算法策略等）统计广告业务的各项关键指标（召回率、点击率、转化率、RPS/RPM、CPC等），检视广告系统的短板和漏洞，帮助广告算法和工程团队发现问题和寻找潜力。&lt;/p&gt;
&lt;p&gt;实时数据分析工具从时效性角度弥补离线数据分析的缺点，帮助开发者尽早发现数据异常，更快地响应和修复问题。在背后支撑这些分析方法的是Hive、Spark、Elasticsearch和Druid等大数据处理工具。如图5所示是实时消耗数据分析工具。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/%E5%9B%BE%E7%89%875.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;

&lt;center&gt;图5　实时消耗数据分析工具&lt;/center&gt;
&lt;p&gt;在线广告系统调试工具是针对单个广告主或单个查询等具体问题的排查。通过调试工具可方便构造模拟请求并查看单个服务处理详细信息，收集各个广告流程步骤（召回、排序和创意优选等）的信息，跟踪和定位线上实时环境中各步骤的问题。除了线上问题排查之外，调试工具也是开发阶段用于验证策略效果和算法正确性不可或缺的手段。如图6所示是在线广告调试工具的基本界面。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/%E5%9B%BE%E7%89%876.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;

&lt;center&gt;图6　在线广告调试工具界面&lt;/center&gt;
&lt;h3 id=&quot;-&quot;&gt;面向广告主和运营人员的工具&lt;/h3&gt;
&lt;p&gt;面向广告主和运营人员的工具包括广告主出价预估和排名预估、商户效果漏斗分析、账户诊断等相关工具。面向广告主的工具帮助广告主更好地衡量和感知广告效果，让其了解市场竞争情况，协助其有效主动地优化广告投放效果。面向运营人员的工具能让运营人员对广告主的投放情况有更清晰的了解，进而帮助其更好地指导和服务广告主。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;效果漏斗分析工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如前文所述，O2O广告从在线展示到用户进店消费需要经过点击和转化多个流程，为了帮助广告主优化整体投放效果，我们在推广后台提供了效果漏斗分析工具。效果漏斗分析工具主要包括曝光/访问量/感兴趣/到店三层漏斗，同时给出相应的问题诊断和优化建议，如图7所示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/%E5%9B%BE%E7%89%877.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;

&lt;center&gt;图7　效果漏斗分析工具&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; &lt;strong&gt;推广实况工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感知广告展示位置以及竞价实况是投放中的广告主核心需求之一。但个性化智能排序技术体系和带有地理位置限制属性的O2O广告场景下，由于用户个性标签、地理位置等原因会导致广告主看不到自己投放中的广告在客户端曝光，广告主难以分析原因，也不知道如何优化现有的广告投放。&lt;/p&gt;
&lt;p&gt;推广实况工具提供查看排名、模拟出价和诊断优化功能。广告主可以查看选定商圈、类目、地理位置等特定条件下的实时排名，也可以查看去个性化后一般情况下的平均排名。同时工具对于广告展现位次过低或得不到展示的情况会给出具体的原因和相应提示。广告主可根据提示调整投放设置，比如对出价过低导致排名靠后情况建议调高出价，通过工具可以实时查看调整后的新排名情况，如图8所示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/%E5%9B%BE%E7%89%878.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;

&lt;center&gt;图8　推广实况工具&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; &lt;strong&gt;流失订单分析工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流失订单分析工具基于门店流失订单记录提供对比分析功能。流失订单是指最近一周内用户对商家A进行了点击，但实际去B、C商家下单的流量算作A的流失订单。分析工具根据用户的点击下单行为数据帮商家分析自身与用户最终下单商家之间的差距在哪里。比如对酒店商家，工具会提供商家平均房价、平均评分、商家首图等信息对比，广告主从中可以分析出订单流失原因，如图9所示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/%E5%9B%BE%E7%89%879.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;

&lt;center&gt;图9 流失订单分析工具&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; &lt;strong&gt;广告收益模拟器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为吸引潜在新广告客户入驻，广告收益模拟器为商家提供广告收益预估功能。该工具基于门店的历史非广告时期点击转化率、门店所在商圈流量以及竞争对手状态等信息，预估门店投放广告后能够带来的新增流量和订单量，帮助新客户快速了解广告产品，建立投资回报预期。同时通过该工具，商户可以方便地跳转到推广通平台进行注册和投放。此外，模拟器也可协助销售人员对商圈流量以及商圈可承载广告数进行预估，让销售人员更有针对性地开拓市场，提升新签成功率，如图10所示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/O2O_advertising/%E5%9B%BE%E7%89%8710.png&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;

&lt;center&gt;图10 广告收益模拟器&lt;/center&gt;
&lt;h2 id=&quot;-&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本章从O2O广告的特性出发，介绍了O2O广告利益相关方的主要关注指标。O2O广告是美团的核心问题之一。本章着重介绍了如何应用机器学习方法提升广告投放的效果和效率，以及本地场景化的推送广告。此外，还简要展示了O2O广告平台相关的工具。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;作者简介&lt;/h2&gt;
&lt;p&gt;亦平，2013年6月加入美团，目前负责美团搜索广告算法策略，曾负责美团搜索排序工作。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;招聘信息&lt;/h2&gt;
&lt;p&gt;美团广告平台全面负责美团到店餐饮、到店综合（结婚、丽人、休闲娱乐、学习培训、亲子、家装）、酒店旅游的商业变现。搜索广告基于数亿用户、数百万商家和数千万订单的真实数据做挖掘，在变现的同时确保用户体验和商家利益。欢迎有意向的同学加入搜索广告算法组。简历请投递至：zhouyayue#meituan.com&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;参考文献&lt;/h3&gt;
&lt;p&gt;[1] Huang, P.-S., He, X., Gao, J., Deng, L., Acero, A., &amp;amp; Heck, L. (2013). Learning deep structured semantic models for web search using clickthrough data. In Proceedings of the 22nd ACM international conference on Conference on information &amp;amp; knowledge management (pp. 2333-2338).&lt;br/&gt;[2] Sutskever, I., Vinyals, O., &amp;amp; Le, Q. V. (2014). Sequence to sequence learning with neural networks. In Advances in neural information processing systems (pp. 3104-3112).&lt;br/&gt;[3] Juan, Y., Zhuang, Y., Chin, W.-S., &amp;amp; Lin, C.-J. (2016). Field-aware Factorization Machines for CTR Prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50).&lt;br/&gt;[4] Cheng, H.-T., Koc, L., Harmsen, J., Shaked, T., Chandra, T., Aradhye, H., . others. (2016). Wide &amp;amp; deep learning for recommender systems. In Proceedings of the 1st Workshop on Deep Learning for Recommender Systems (pp. 7-10).&lt;br/&gt;[5] Li, M., Zhou, L., Yang, Z., Li, A., Xia, F., Andersen, D. G., &amp;amp; Smola, A. (2013). Parameter server for distributed machine learning. In Big Learning NIPS Workshop (Vol. 1).&lt;br/&gt;[6] Edelman, B., Ostrovsky, M., &amp;amp; Schwarz, M. (2005). Internet advertising and the generalized second price auction: Selling billions of dollars worth of keywords.&lt;/p&gt;
&lt;div class=&quot;hidden-mobile&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;发现文章有错误、对内容有疑问，都可以关注美团技术团队微信公众号（meituantech），在后台给我们留言。我们每周会挑选出一位热心小伙伴，送上一份精美的小礼品。快来扫码关注我们吧！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;article__footer__img&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/meituanjishutuandui.png&quot; alt=&quot;公众号二维码&quot; width=&quot;455&quot; align=&quot;center&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 17 Aug 2018 02:50:00 +0000</pubDate>
<dc:creator>美团技术团队</dc:creator>
<og:description>本文将从5个方面来介绍。首先，介绍O2O场景下广告业务的特点，及其与B2B和B2C广告业务的差别；其次，从商户效果感知、用户体验和媒体平台收益三个维度，介绍O2O广告业务的最重要的考量指标；第三，从前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/meituantech/p/9492103.html</dc:identifier>
</item>
</channel>
</rss>