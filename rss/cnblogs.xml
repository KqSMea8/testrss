<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>快速序列化组件MessagePack介绍 - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/8039933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/8039933.html</guid>
<description>&lt;p&gt;MessagePack for C＃（MessagePack-CSharp）是用于C＃的极速MessagePack序列化程序，比MsgPack-Cli快10倍，与其他所有C＃序列化程序相比，具有最好的性能。 MessagePack for C＃具有内置的LZ4压缩功能，可以实现超快速序列化和二进制占用空间小。 性能永远是重要的！ 可用于游戏，分布式计算，微服务，数据存储到Redis等。支持.NET, .NET Core, Unity, Xamarin。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171214200132920-1375437951.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图我们看出MessagePack for C＃在性能测试中是最好的，这里解释一下第三个MsgPack-Cli是MessagePack官方实现的。第一和第二都是MessagePack for C＃，第一项相比第二项具有稍快一点的序列化和反序列化速度，但是第二项采用了L4压缩功能，显著的减少了二进制的大小。在实际使用中推荐使用L4压缩功能。&lt;/p&gt;

&lt;p&gt;该组件已经发布在Nuget，使用命令加入项目。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Install-Package MessagePack&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;分析器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Install-Package MessagePackAnalyzer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;扩展&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Install-Package MessagePack.ImmutableCollection
Install-Package MessagePack.ReactiveProperty
Install-Package MessagePack.UnityShims
Install-Package MessagePack.AspNetCoreMvcFormatter&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;1.4189189189189&quot;&gt;
&lt;p&gt;Unity在此处下载 &lt;a href=&quot;https://github.com/neuecc/MessagePack-CSharp/releases&quot; class=&quot;uri&quot;&gt;https://github.com/neuecc/MessagePack-CSharp/releases&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;定义一个类添加&lt;code&gt;[MessagePackObject]&lt;/code&gt;特性，公共成员（属性或者字段）添加&lt;code&gt;[Key]&lt;/code&gt;特性，调用&lt;code&gt;MessagePackSerializer.Serialize&amp;lt;T&amp;gt;/Deserialize&amp;lt;T&amp;gt;&lt;/code&gt;进行序列化和反序列化，&lt;code&gt;ToJson&lt;/code&gt;可以帮我们转储二进制为json格式。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 标记 MessagePackObjectAttribute
[MessagePackObject]
public class MyClass
{
    // Key 是序列化索引，对于版本控制非常重要。
    [Key(0)]
    public int Age { get; set; }

    [Key(1)]
    public string FirstName { get; set; }

    [Key(2)]
    public string LastName { get; set; }

    // 公共成员中不序列化目标，标记IgnoreMemberAttribute
    [IgnoreMember]
    public string FullName { get { return FirstName + LastName; } }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        var mc = new MyClass
        {
            Age = 99,
            FirstName = &quot;hoge&quot;,
            LastName = &quot;huga&quot;,
        };

        // 序列化
        var bytes = MessagePackSerializer.Serialize(mc);
        //反序列化
        var mc2 = MessagePackSerializer.Deserialize&amp;lt;MyClass&amp;gt;(bytes);

        // 你可以将msgpack二进制转储为可读的json。
        // 在默认情况下，MeesagePack for C＃减少了属性名称信息。
        // [99,&quot;hoge&quot;,&quot;huga&quot;]
        var json = MessagePackSerializer.ToJson(bytes);
        Console.WriteLine(json);

        Console.ReadKey();

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;序列化索引将会影响该信息在序列化数据中的位置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;默认情况下特性是必须的，但是我们有方法进行改变，让它变为不是必须的，详情请看后面。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MessagePackAnalyzer&lt;/code&gt; 可以帮助我们定义对象. 如果不符合规则，那么特性, 程序集等可以被检测到，如果我们编译就会出现编译错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171214203656482-248372267.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果要允许特定类型（例如，注册自定义类型时），请将MessagePackAnalyzer.json放在项目根目录下，并将生成操作设置为&lt;code&gt;AdditionalFiles&lt;/code&gt;（其他文件）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171214203909888-962307440.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是MessagePackAnalyzer.json内容的一个示例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[ &quot;MyNamespace.FooClass&quot;, &quot;MyNameSpace.BarStruct&quot; ]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这些类型可以默认序列化。&lt;/p&gt;
&lt;p&gt;基元（int、string等等）, Enum, Nullable&amp;lt;&amp;gt;, TimeSpan, DateTime, DateTimeOffset, Nil, Guid, Uri, Version, StringBuilder, BitArray, ArraySegment&amp;lt;&amp;gt;, BigInteger, Complext, Task, Array[], Array[,], Array[,,], Array[,,,], KeyValuePair&amp;lt;,&amp;gt;, Tuple&amp;lt;,...&amp;gt;, ValueTuple&amp;lt;,...&amp;gt;, List&amp;lt;&amp;gt;, LinkedList&amp;lt;&amp;gt;, Queue&amp;lt;&amp;gt;, Stack&amp;lt;&amp;gt;, HashSet&amp;lt;&amp;gt;, ReadOnlyCollection&amp;lt;&amp;gt;, IList&amp;lt;&amp;gt;, ICollection&amp;lt;&amp;gt;, IEnumerable&amp;lt;&amp;gt;, Dictionary&amp;lt;,&amp;gt;, IDictionary&amp;lt;,&amp;gt;, SortedDictionary&amp;lt;,&amp;gt;, SortedList&amp;lt;,&amp;gt;, ILookup&amp;lt;,&amp;gt;, IGrouping&amp;lt;,&amp;gt;, ObservableCollection&amp;lt;&amp;gt;, ReadOnlyOnservableCollection&amp;lt;&amp;gt;, IReadOnlyList&amp;lt;&amp;gt;, IReadOnlyCollection&amp;lt;&amp;gt;, ISet&amp;lt;&amp;gt;, ConcurrentBag&amp;lt;&amp;gt;, ConcurrentQueue&amp;lt;&amp;gt;, ConcurrentStack&amp;lt;&amp;gt;, ReadOnlyDictionary&amp;lt;,&amp;gt;, IReadOnlyDictionary&amp;lt;,&amp;gt;, ConcurrentDictionary&amp;lt;,&amp;gt;, Lazy&amp;lt;&amp;gt;, Task&amp;lt;&amp;gt;, 自定义继承ICollection &amp;lt;&amp;gt;或IDictionary &amp;lt;,&amp;gt;具有无参构造方法, IList，IDictionary和自定义继承ICollection或IDictionary具有无参构造函数（包括ArrayList和Hashtable）。&lt;/p&gt;
&lt;p&gt;您可以添加自定义类型的支持和一些官方/第三方扩展包。 对于ImmutableCollections（ImmutableList &amp;lt;&amp;gt;等），对于ReactiveProperty和Unity（Vector3, Quaternion等等），对于F＃（Record，FsList，Discriminated Unions等）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MessagePack.Nil&lt;/code&gt;是MessagePack for C＃的内置null/void/unit表示类型。&lt;/p&gt;

&lt;p&gt;MessagePack for C＃可以序列化public Class或Struct，序列化目标必须标记[MessagePackObject]和[Key]， Key类型可以选择int或字符串。如果Key类型是int，则使用序列化格式为数组，如果Key类型是字符串，则使用序列化格式为键值对，如果您定义了[MessagePackObject(keyAsPropertyName:true)]，则不需要Key特性。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[MessagePackObject]
public class Sample1
{
    [Key(0)]
    public int Foo { get; set; }
    [Key(1)]
    public int Bar { get; set; }
}

[MessagePackObject]
public class Sample2
{
    [Key(&quot;foo&quot;)]
    public int Foo { get; set; }
    [Key(&quot;bar&quot;)]
    public int Bar { get; set; }
}

[MessagePackObject(keyAsPropertyName: true)]
public class Sample3
{
    // 不需要key特性
    public int Foo { get; set; }

    // 不需要序列化的成员使用IgnoreMember特性
    [IgnoreMember]
    public int Bar { get; set; }
}

// 结果 [10,20]
Console.WriteLine(MessagePackSerializer.ToJson(new Sample1 { Foo = 10, Bar = 20 }));

// 结果 {&quot;foo&quot;:10,&quot;bar&quot;:20}
Console.WriteLine(MessagePackSerializer.ToJson(new Sample2 { Foo = 10, Bar = 20 }));

// 结果 {&quot;Foo&quot;:10}
Console.WriteLine(MessagePackSerializer.ToJson(new Sample3 { Foo = 10, Bar = 20 }));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有模式序列化目标都是公共实例成员（字段或属性）。 如果要避免序列化目标，可以将&lt;code&gt;[IgnoreMember]&lt;/code&gt;添加到目标成员。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;目标类必须是 public, 不允许 private, internal 类.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;应该使用哪种Key类型，int或string？ 作者建议使用int key，因为比string key更快，更紧凑。 但是string key有关键的名字信息，对调试很有用。&lt;/p&gt;
&lt;p&gt;MessagePackSerializer序列化目标时，必须在目标使用特性才能保证稳健性，如果类进行了扩充，你必须意识到版本控制。如果Key不存在，MessagePackSerializer将会使用默认值。如果使用的是int key，那么必须从0开始，如果不必要的属性出现，请填写空缺的数字。重用是不好的。 此外，如果Int Key的跳转数字差距太大，则会影响二进制大小。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[MessagePackObject]
public class IntKeySample
{
    [Key(3)]
    public int A { get; set; }
    [Key(10)]
    public int B { get; set; }
}

// int key不从0开始并且数字进行了跳跃，将会出现下面的结果
//[null,null,null,0,null,null,null,null,null,null,0]
Console.WriteLine(MessagePackSerializer.ToJson(new IntKeySample()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你想像JSON.NET那样使用！不想加特性！ 如果你这样想，你可以使用无约定的解析器。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ContractlessSample
{
    public int MyProperty1 { get; set; }
    public int MyProperty2 { get; set; }
}

var data = new ContractlessSample { MyProperty1 = 99, MyProperty2 = 9999 };
var bin = MessagePackSerializer.Serialize(data, MessagePack.Resolvers.ContractlessStandardResolver.Instance);

// {&quot;MyProperty1&quot;:99,&quot;MyProperty2&quot;:9999}
Console.WriteLine(MessagePackSerializer.ToJson(bin));

// 全局设置无约束解析器为默认解析器
MessagePackSerializer.SetDefaultResolver(MessagePack.Resolvers.ContractlessStandardResolver.Instance);

// 序列化
var bin2 = MessagePackSerializer.Serialize(data);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我想序列化私人成员！ 默认情况下，不能序列化/反序列化私有成员。 但是你可以使用allow-private解析器来序列化私人成员。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[MessagePackObject]
public class PrivateSample
{
    [Key(0)]
    int x;

    public void SetX(int v)
    {
        x = v;
    }

    public int GetX()
    {
        return x;
    }
}

var data = new PrivateSample();
data.SetX(9999);

// 你可以选择 StandardResolverAllowPrivate 或者  ContractlessStandardResolverAllowPrivate 解析器
var bin = MessagePackSerializer.Serialize(data, MessagePack.Resolvers.DynamicObjectResolverAllowPrivate.Instance);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我不需要类型，我想像BinaryFormatter那样使用！ 你可以使用无类型的解析器和帮助器。 请参阅Typeless部分。&lt;/p&gt;
&lt;p&gt;解析器是MessagePack For C#的关键定制点。 详情请见扩展部分。&lt;/p&gt;

&lt;p&gt;您可以使用[DataContract]而不是[MessagePackObject]。 如果type标记为DataContract，则可以使用[DataMember]代替[Key]，[IgnoreDataMember]代替[IgnoreMember]。&lt;/p&gt;
&lt;p&gt;[DataMember(Order = int)] 和 [Key(int)]相同, [DataMember(Name = string)]和 [Key(string)]相同. 如果使用 [DataMember], 则类似于 [Key(nameof(propertyname)].&lt;/p&gt;
&lt;p&gt;使用DataContract使其成为一个共享的类库，您不必引用MessagePack for C＃。 但是，它不包含在分析器或由&lt;code&gt;mpc.exe&lt;/code&gt;生成的代码中。此外，像UnionAttribute，MessagePackFormatterAttribute，SerializationConstructorAttribute等功能不能使用。 出于这个原因，我建议您基本上使用MessagePack for C＃特性。&lt;/p&gt;

&lt;p&gt;MessagePack for C＃支持反序列化不可变对象。 例如，这个struct可以自然地序列化/反序列化。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[MessagePackObject]
public struct Point
{
    [Key(0)]
    public readonly int X;
    [Key(1)]
    public readonly int Y;

    public Point(int x, int y)
    {
        this.X = x;
        this.Y = y;
    }
}

var data = new Point(99, 9999);
var bin = MessagePackSerializer.Serialize(data);

// Okay to deserialize immutable obejct
var point = MessagePackSerializer.Deserialize&amp;lt;Point&amp;gt;(bin);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MessagePackSerializer choose constructor with the least matched argument, match index if key in integer or match name(ignore case) if key is string. If encounts MessagePackDynamicObjectResolverException: can't find matched constructor parameter you should check about this.&lt;/p&gt;
&lt;p&gt;MessagePackSerializer选择具有最少参数的构造方法，如果key是整型将匹配索引或者如果key是字符串将匹配名称（忽略大小写）。 如果遇到 &lt;code&gt;MessagePackDynamicObjectResolverException: can't find matched constructor parameter&lt;/code&gt; 你应该检查一会下。&lt;/p&gt;
&lt;p&gt;如果不能自动匹配，可以通过[SerializationConstructorAttribute]手动指定使用构造函数。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[MessagePackObject]
public struct Point
{
    [Key(0)]
    public readonly int X;
    [Key(1)]
    public readonly int Y;

    // 如果没有标记特性，将会使用这方法（最少参数）
    public Point(int x)
    {
        X = x;
    }

    [SerializationConstructor]
    public Point(int x, int y)
    {
        this.X = x;
        this.Y = y;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果对象实现了&lt;code&gt;IMessagePackSerializationCallbackReceiver&lt;/code&gt;，则接受&lt;code&gt;OnBeforeSerialize&lt;/code&gt;和&lt;code&gt;OnAfterDeserialize&lt;/code&gt;序列化处理。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[MessagePackObject]
public class SampleCallback : IMessagePackSerializationCallbackReceiver
{
    [Key(0)]
    public int Key { get; set; }

    public void OnBeforeSerialize()
    {
        Console.WriteLine(&quot;OnBefore&quot;);
    }

    public void OnAfterDeserialize()
    {
        Console.WriteLine(&quot;OnAfter&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;MessagePack for C＃支持序列化接口。这就像XmlInclude或ProtoInclude。在MessagePack for C＃里叫Union。UnionAttribute只能附加到接口或抽象类。 它需要区分的整型key和子类型&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// mark inheritance types
[MessagePack.Union(0, typeof(FooClass))]
[MessagePack.Union(1, typeof(BarClass))]
public interface IUnionSample
{
}

[MessagePackObject]
public class FooClass : IUnionSample
{
    [Key(0)]
    public int XYZ { get; set; }
}

[MessagePackObject]
public class BarClass : IUnionSample
{
    [Key(0)]
    public string OPQ { get; set; }
}

// ---

IUnionSample data = new FooClass() { XYZ = 999 };

// serialize interface.
var bin = MessagePackSerializer.Serialize(data);

// deserialize interface.
var reData = MessagePackSerializer.Deserialize&amp;lt;IUnionSample&amp;gt;(bin);

// use type-switch of C# 7.0
switch (reData)
{
    case FooClass x:
        Console.WriteLine(x.XYZ);
        break;
    case BarClass x:
        Console.WriteLine(x.OPQ);
        break;
    default:
        break;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C＃7.0 type-switch是Union的最佳选择。 Union被序列化为两个长度的数组。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;IUnionSample data = new BarClass { OPQ = &quot;FooBar&quot; };

var bin = MessagePackSerializer.Serialize(data);

// Union is serialized to two-length array, [key, object]
// [1,[&quot;FooBar&quot;]]
Console.WriteLine(MessagePackSerializer.ToJson(bin));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在抽象类中使用Union，你可以像接口那样使用。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Union(0, typeof(SubUnionType1))]
[Union(1, typeof(SubUnionType2))]
[MessagePackObject]
public abstract class ParentUnionType
{
    [Key(0)]
    public int MyProperty { get; set; }
}

[MessagePackObject]
public class SubUnionType1 : ParentUnionType
{
    [Key(1)]
    public int MyProperty1 { get; set; }
}

[MessagePackObject]
public class SubUnionType2 : ParentUnionType
{
    [Key(1)]
    public int MyProperty2 { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承类型的序列化，在数组（或键值对）中是扁平化的，对于整型键是无关紧要的，它不能复制父类和所有的子类。&lt;/p&gt;

&lt;p&gt;如果使用&lt;code&gt;MessagePackSerializer.Deserialize&amp;lt;object&amp;gt;&lt;/code&gt; 或者&lt;code&gt;MessagePackSerializer.Deserialize&amp;lt;dynamic&amp;gt;&lt;/code&gt;，messagepack将转换为 primitive values，msgpack-primitive将转换为&lt;code&gt;bool, char, sbyte, byte, short, int, long, ushort, uint, ulong, float, double, DateTime, string, byte[], object[], IDictionary&amp;lt;object, object&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// sample binary.
var model = new DynamicModel { Name = &quot;foobar&quot;, Items = new[] { 1, 10, 100, 1000 } };
var bin = MessagePackSerializer.Serialize(model, ContractlessStandardResolver.Instance);

// dynamic, untyped
var dynamicModel = MessagePackSerializer.Deserialize&amp;lt;dynamic&amp;gt;(bin, ContractlessStandardResolver.Instance);

Console.WriteLine(dynamicModel[&quot;Name&quot;]); // foobar
Console.WriteLine(dynamicModel[&quot;Items&quot;][2]); // 100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以你可以使用索引访问键值对或者数组。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;StandardResolver&lt;/code&gt;和&lt;code&gt;ContractlessStandardResolver&lt;/code&gt;可以通过&lt;code&gt;DynamicObjectTypeFallbackResolver&lt;/code&gt;将Object类型序列化为具体类型。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var objects = new object[] { 1, &quot;aaa&quot;, new ObjectFieldType { Anything = 9999 } };
var bin = MessagePackSerializer.Serialize(objects);

// [1,&quot;aaa&quot;,[9999]]
Console.WriteLine(MessagePackSerializer.ToJson(bin));

// Support Anonymous Type Serialize
var anonType = new { Foo = 100, Bar = &quot;foobar&quot; };
var bin2 = MessagePackSerializer.Serialize(anonType, MessagePack.Resolvers.ContractlessStandardResolver.Instance);

// {&quot;Foo&quot;:100,&quot;Bar&quot;:&quot;foobar&quot;}
Console.WriteLine(MessagePackSerializer.ToJson(bin2));&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Unity支持是有限的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;反序列化时，与Dynamic（Untyped）反序列化相同。&lt;/p&gt;

&lt;p&gt;Typeless API就像BinaryFormatter, 将类型信息嵌入到二进制中，所以不需要类型去反序列化.&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;object mc = new Sandbox.MyClass()
{
    Age = 10,
    FirstName = &quot;hoge&quot;,
    LastName = &quot;huga&quot;
};

// serialize to typeless
var bin = MessagePackSerializer.Typeless.Serialize(mc);

// binary data is embeded type-assembly information.
// [&quot;Sandbox.MyClass, Sandbox&quot;,10,&quot;hoge&quot;,&quot;huga&quot;]
Console.WriteLine(MessagePackSerializer.ToJson(bin));

// can deserialize to MyClass with typeless
var objModel = MessagePackSerializer.Typeless.Deserialize(bin) as MyClass;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类型信息由mspgack ext格式序列化，typecode为100。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MessagePackSerializer.Typeless&lt;/code&gt;是&lt;code&gt;Serialize / Deserialize &amp;lt;object&amp;gt;（TypelessContractlessStandardResolver.Instance）&lt;/code&gt;的快捷方式。 如果要配置默认的Typeless解析器，可以通过&lt;code&gt;MessagePackSerializer.Typeless.RegisterDefaultResolver&lt;/code&gt;进行设置。&lt;/p&gt;

&lt;p&gt;与其他序列化器在Windows 10 Pro x64 Intel Core i7-6700K 4.00GHz, 32GB RAM上进行Benchmarks比较，&lt;a href=&quot;https://github.com/neuecc/ZeroFormatter/tree/master/sandbox/PerformanceComparison&quot; title=&quot;Benchmark代码在这&quot;&gt;Benchmark代码在这&lt;/a&gt;-&lt;a href=&quot;https://github.com/neuecc/ZeroFormatter/blob/bc63cb925d/sandbox/PerformanceComparison/packages.config&quot; title=&quot;版本信息&quot;&gt;版本信息&lt;/a&gt;，ZeroFormatter和FlatBuffers具有非常快速的反序列化器，因此忽略反序列化的性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171219155629381-1253440926.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MessagePack for C＃使用许多技术来提高性能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;序列化只使用ref byte []和int offset，不使用（Memory）Stream（调用Stream api会有开销）&lt;/li&gt;
&lt;li&gt;高级API使用内部内存池，分配工作内存不要低于64k&lt;/li&gt;
&lt;li&gt;不创建中间实用程序实例（XxxWriter / Reader，XxxContext等）&lt;/li&gt;
&lt;li&gt;所有代码避免装箱，所有平台（包括Unity / IL2CPP）&lt;/li&gt;
&lt;li&gt;对静态泛型字段生成的格式化程序进行缓存，查找时从缓存查找（不使用字典缓存，因为字典查找需要一定开销）&lt;/li&gt;
&lt;li&gt;重新调整的动态代码生成&lt;/li&gt;
&lt;li&gt;当代码生成知道目标是primitive时直接调用PrimitiveAPI&lt;/li&gt;
&lt;li&gt;当代码生成知道目标（整数/字符串）范围时，减少可变长度格式的分支&lt;/li&gt;
&lt;li&gt;不在迭代集合上使用IEnumerable&amp;lt;T&amp;gt; 抽象&lt;/li&gt;
&lt;li&gt;使用预先生成的查找表来减少检查消息包类型所耗时间&lt;/li&gt;
&lt;li&gt;对非泛型方法使用优化类型key字典&lt;/li&gt;
&lt;li&gt;避免查找映射（字符串键）键的字符串键解码，并使用自动化名称查找与il内联代码生成&lt;/li&gt;
&lt;li&gt;对于字符串键编码，预先生成的成员名字节并在IL中使用固定大小的二进制副本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在创建这个库之前，作则实现了一个具有ZeroFormatter＃Performance的快速序列化器。 这是一个进一步演变的实现。 MessagePack for C#始终是快速的，为所有类型（原始，小结构，大对象，任何集合）进行了优化。&lt;/p&gt;

&lt;p&gt;性能取决于选项。 这是一个BenchmarkDotNet的微型benchamark。 目标对象有9个成员（MyProperty1〜MyProperty9），值为零。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;IntKey&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;72.67 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1.00&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0132&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;56 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;StringKey&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;217.95 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3.00&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0131&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;56 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Typeless_IntKey&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;176.71 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2.43&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0131&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;56 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Typeless_StringKey&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;378.64 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;5.21&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0129&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;56 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;MsgPackCliMap&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1,355.26 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;18.65&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.1431&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;608 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MsgPackCliArray&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;455.28 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6.26&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0415&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;176 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ProtobufNet&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;265.85 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3.66&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0319&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;136 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Hyperion&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;366.47 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;5.04&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0949&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;400 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;JsonNetString&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2,783.39 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;38.30&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.6790&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2864 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;JsonNetStreamReader&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3,297.90 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;45.38&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1.4267&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6000 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;JilString&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;553.65 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;7.62&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0362&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;152 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;JilStreamReader&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1,408.46 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;19.38&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.8450&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3552 B&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;IntKey，StringKey，Typeless_IntKey，Typeless_StringKey都是MessagePack for C＃的方法&lt;br/&gt;，在反序列化过程中实现零内存分配。JsonNetString /JilString从字符串反序列化。JsonStStreamReader / JilStreamReader是从StreamReader的UTF8 byte []中反序列化的。反序列化通常从Stream读取。 因此，它将从字节数组（或流）而不是字符串中读取。&lt;/p&gt;
&lt;p&gt;MessagePack for C＃IntKey是最快的。 StringKey比IntKey慢，因为StringKey需要从字符串进行匹配。 如果是IntKey，读取数组长度，根据数组长度进行for循环二进制解码。 如果StringKey，读取map 长度，根据map长度循环，首先需要对密钥解码，然后按照key查找，最后二进制解码，则需要额外两个步骤（解码密钥和按键查找）。&lt;/p&gt;
&lt;p&gt;字符串键通常是有用的，无约束的，简单的JSON替换，与其他语言的互操作性，以及更多的某些版本。 MessagePack for C＃也为String Key进行了优化。 首先，它不会将UTF8字节数组解码为与成员名称匹配的字符串，它会按原样查找字节数组（避免解码成本和额外分配）。&lt;/p&gt;
&lt;p&gt;它会尝试匹配每个长整型（long）（每8个字符，如果长度不够，填充0）使用automata和在生成时内联IL代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171221135005334-1754235309.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这也避免了计算字节数组的哈希码，并且可以在长单元上进行多次比较。&lt;/p&gt;
&lt;p&gt;这是ILSpy生成的反序列化器代码的示例的反编译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201712/668104-20171221135435678-1158736440.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/neuecc/MessagePack-CSharp#performance&quot; class=&quot;uri&quot;&gt;https://github.com/neuecc/MessagePack-CSharp#performance&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果节点数量很大，则使用嵌入式二进制搜索进行搜索。&lt;/p&gt;
&lt;p&gt;另外请注意，这是序列化的基准测试结果。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;IntKey&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;84.11 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1.00&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0094&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;40 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;StringKey&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;126.75 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1.51&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0341&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;144 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Typeless_IntKey&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;183.31 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2.18&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0265&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;112 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Typeless_StringKey&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;193.95 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2.31&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0513&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;216 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;MsgPackCliMap&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;967.68 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;11.51&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.1297&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;552 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MsgPackCliArray&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;284.20 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3.38&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.1006&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;424 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ProtobufNet&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;176.43 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2.10&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.0665&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;280 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Hyperion&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;280.14 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3.33&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.1674&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;704 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ZeroFormatter&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;149.95 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1.78&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.1009&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;424 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;JsonNetString&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1,432.55 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;17.03&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.4616&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1944 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;JsonNetStreamWriter&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1,775.72 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;21.11&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1.5526&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6522 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;JilString&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;547.51 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6.51&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;0.3481&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1464 B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;JilStreamWriter&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;778.78 ns&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;NA&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;9.26&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1.4448&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6066 B&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当然，IntKey是最快的，但StringKey也不错。&lt;/p&gt;

&lt;p&gt;MessagePack是一个快速和紧凑的格式，但它不是压缩格式。 LZ4是非常快速的压缩算法，使用MessagePack for C＃可以实现极快的性能和非常紧凑的二进制大小！&lt;/p&gt;
&lt;p&gt;MessagePack for C＃具有内置的LZ4支持。 您可以使用LZ4MessagePackSerializer而不是MessagePackSerializer。 内建支持是特殊的，作者已经创建了序列化压缩管道，并专门调整了管道，所以共享工作内存，不分配，不要调整，直到完成。&lt;/p&gt;
&lt;p&gt;序列化二进制不是简单地压缩lz4二进制。 序列化二进制是有效的MessagePack二进制使用ext格式和自定义typecode（99）。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var array= Enumerable.Range(1, 100).Select(x =&amp;gt; new MyClass { Age = 5, FirstName = &quot;foo&quot;, LastName = &quot;bar&quot; }).ToArray();

// call LZ4MessagePackSerializer instead of MessagePackSerializer, api is completely same
var lz4Bytes = LZ4MessagePackSerializer.Serialize(array);
var mc2 = LZ4MessagePackSerializer.Deserialize&amp;lt;MyClass[]&amp;gt;(lz4Bytes);

// you can dump lz4 message pack
// [[5,&quot;hoge&quot;,&quot;huga&quot;],[5,&quot;hoge&quot;,&quot;huga&quot;],....]
var json = LZ4MessagePackSerializer.ToJson(lz4Bytes);
Console.WriteLine(json);

// lz4Bytes is valid MessagePack, it is using ext-format( [TypeCode:99, SourceLength|CompressedBinary] )
// [99,&quot;0gAAA+vf3ABkkwWjZm9vo2JhcgoA////yVBvo2Jhcg==&quot;]
var rawJson = MessagePackSerializer.ToJson(lz4Bytes);
Console.WriteLine(rawJson);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;protbuf-net是.NET上最常用的二进制格式化库。 我（作者）喜欢protobuf-net，并尊重那伟大的工作。 但是如果使用protobuf-net作为通用序列化格式，则可能会引起烦人的问题。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[ProtoContract]
public class Parent
{
    [ProtoMember(1)]
    public int Primitive { get; set; }
    [ProtoMember(2)]
    public Child Prop { get; set; }
    [ProtoMember(3)]
    public int[] Array { get; set; }
}

[ProtoContract]
public class Child
{
    [ProtoMember(1)]
    public int Number { get; set; }
}

using (var ms = new MemoryStream())
{
    // serialize null.
    ProtoBuf.Serializer.Serialize&amp;lt;Parent&amp;gt;(ms, null);

    ms.Position = 0;
    var result = ProtoBuf.Serializer.Deserialize&amp;lt;Parent&amp;gt;(ms);

    Console.WriteLine(result != null); // True, not null. but all property are zero formatted.
    Console.WriteLine(result.Primitive); // 0
    Console.WriteLine(result.Prop); // null
    Console.WriteLine(result.Array); // null
}

using (var ms = new MemoryStream())
{
    // serialize empty array.
    ProtoBuf.Serializer.Serialize&amp;lt;Parent&amp;gt;(ms, new Parent { Array = new int[0] });

    ms.Position = 0;
    var result = ProtoBuf.Serializer.Deserialize&amp;lt;Parent&amp;gt;(ms);

    Console.WriteLine(result.Array == null); // True, null!
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;protobuf(-net)不能正确处理null和空集合。 因为protobuf没有null表示（这是protobuf-net作者的答案）。&lt;/p&gt;
&lt;p&gt;MessagePack规范可以完全序列化C＃类型。 这就是推荐MessagePack而不是protobuf的原因。&lt;/p&gt;
&lt;p&gt;Protocol Buffers具有良好的IDL和gRPC，这比MessagePack好得多。 如果你想使用IDL，我（作者）推荐Google.Protobuf。&lt;/p&gt;
&lt;p&gt;JSON是很好的通用格式。 这是完美的，简单的，足够规范的。 Utf8Json创建了我采用与MessagePack for C＃相同的体系结构，并避免编码/修饰成本，所以像二进制一样工作。 如果你想了解二进制与文本，请参阅Utf8Json /应使用哪个序列化器部分。&lt;/p&gt;
&lt;p&gt;ZeroFormatter与FlatBuffers类似，但专门用于C＃。 这是特别的。 反序列化速度非常快，但是二进制大小却很大。 而ZeroFormatter的缓存算法需要额外的内存。&lt;/p&gt;
&lt;p&gt;ZeroFormatter也是特别的。 当与ZeroFormatter对比的情况下，它显示格式化的力量。 但是对于许多常见的用途，MessagePack for C＃会更好。&lt;/p&gt;

&lt;p&gt;MessagePack for C＃具有扩展点，您可以添加外部类型的序列化支持。 下列是官方扩展支持。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package MessagePack.ImmutableCollection
Install-Package MessagePack.ReactiveProperty
Install-Package MessagePack.UnityShims
Install-Package MessagePack.AspNetCoreMvcFormatter&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MessagePack.ImmutableCollection&lt;/code&gt;添加对 &lt;code&gt;System.Collections.Immutable&lt;/code&gt;的支持. 添加了对&lt;code&gt;ImmutableArray&amp;lt;&amp;gt;, ImmutableList&amp;lt;&amp;gt;, ImmutableDictionary&amp;lt;,&amp;gt;, ImmutableHashSet&amp;lt;&amp;gt;, ImmutableSortedDictionary&amp;lt;,&amp;gt;, ImmutableSortedSet&amp;lt;&amp;gt;, ImmutableQueue&amp;lt;&amp;gt;, ImmutableStack&amp;lt;&amp;gt;, IImmutableList&amp;lt;&amp;gt;, IImmutableDictionary&amp;lt;,&amp;gt;, IImmutableQueue&amp;lt;&amp;gt;, IImmutableSet&amp;lt;&amp;gt;, IImmutableStack&amp;lt;&amp;gt;&lt;/code&gt;的序列化支持.&lt;/p&gt;
&lt;p&gt;MessagePack.ReactiveProperty包添加对ReactiveProperty库的支持。它增加了&lt;code&gt;ReactiveProperty &amp;lt;&amp;gt;，IReactiveProperty &amp;lt;&amp;gt;，IReadOnlyReactiveProperty &amp;lt;&amp;gt;，ReactiveCollection &amp;lt;&amp;gt;，unit&lt;/code&gt;序列化支持。 这对保存视图模型状态很有用。&lt;/p&gt;
&lt;p&gt;MessagePack.AspNetCoreMvcFormatter是ASP.NET Core MVC序列化的附加组件，可提升性能。 这是配置示例。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc().AddMvcOptions(option =&amp;gt;
    {
        option.OutputFormatters.Clear();
        option.OutputFormatters.Add(new MessagePackOutputFormatter(ContractlessStandardResolver.Instance));
        option.InputFormatters.Clear();
        option.InputFormatters.Add(new MessagePackInputFormatter(ContractlessStandardResolver.Instance));
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多信息请访问github: &lt;a href=&quot;https://github.com/neuecc/MessagePack-CSharp&quot; class=&quot;uri&quot;&gt;https://github.com/neuecc/MessagePack-CSharp&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Dec 2017 15:31:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stulzq/p/8039933.html</dc:identifier>
</item>
<item>
<title>node.js之路由，中间件，ge请求和post请求的参数 - 蜜迷</title>
<link>http://www.cnblogs.com/15fj/p/8111678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/15fj/p/8111678.html</guid>
<description>&lt;p&gt;一、路由&lt;/p&gt;
&lt;p&gt;　　　1、什么是路由&lt;/p&gt;
&lt;p&gt;　　　　　　服务器需要根据不同的URL或请求来执行不一样的操作，我们可以通过路由来实现这个步骤&lt;/p&gt;
&lt;p&gt;　　　2、实现路由的方法&lt;/p&gt;
&lt;p&gt;　　　　2.1、get请求访问网址时，做什么事&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1    app.get(&quot;网址&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
&lt;/span&gt;2        
3    });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　2.2、post请求访问网址时，做什么事　　　　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1    app.post(&quot;网址&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
&lt;/span&gt;2        
3    });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　2.3、任何请求访问这个网址　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1    app.all(&quot;网址&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;2        
3    });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　注意：1、’这里的网址不分大小写，例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1    app.get(&quot;/AAb&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){　　　　　　　　//我们访问　　/aab也是可以的
&lt;/span&gt;2        res.send(&quot;你好&quot;&lt;span&gt;);
&lt;/span&gt;3    });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　　　　2、你路由到/a ， 实际/a?id=2&amp;amp;sex=nan 也能被处理。&lt;/p&gt;

&lt;p&gt;　　3、路由中正则表达式的使用&lt;/p&gt;
&lt;p&gt;　　　　3.1、正则表达式中，未知部分用圆括号分组，然后可以用req.params[0]、[1]得到。req.params类数组对象。　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1    app.get(/^\/student\/([\d]{10})$/,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
&lt;/span&gt;2        res.send(&quot;学生信息，学号&quot; + req.params[0&lt;span&gt;]);
&lt;/span&gt;3    });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　 3.2、冒号写法（推荐）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express=require('express'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;冒号1&lt;/span&gt;
app.get(&quot;&lt;span&gt;/student/:id&lt;/span&gt;&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id=&lt;span&gt;req.params[&quot;id&quot;];　　　　　　　　　　　　　　　　　　　　//得到id的值
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg=/^[\d]{6}$/&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(reg.test(id)){
        res.send(id);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        res.send(&lt;/span&gt;&quot;请检查格式&quot;&lt;span&gt;);
    }

});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;冒号2&lt;/span&gt;
app.get(&quot;&lt;span&gt;/:username/:oid&lt;/span&gt;&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; username = &lt;span&gt;req.params[&quot;username&quot;];　　　　　　　　　　　　//得到username的值
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oid = &lt;span&gt;req.params[&quot;oid&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;];　　　　　　　　　　　　　　　　　　//得到//oid的值&lt;/span&gt;
    res.write(username);
    res.end(oid);
});
app.listen(&lt;/span&gt;3000);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 运行结果：&lt;/p&gt;
&lt;p&gt;冒号1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202490/201712/1202490-20171225221433962-2041713246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 冒号2：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202490/201712/1202490-20171225221519759-1144303017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;二、中间件&lt;/p&gt;
&lt;p&gt;　　1、什么是中间件&lt;/p&gt;
&lt;p&gt;　　　　应用于应用之间 充当连接服务的，例如上面的get、post请求就是中间件&lt;/p&gt;
&lt;p&gt;　　2、express中所有的路由（中间件）的顺序（很重要）&lt;/p&gt;
&lt;p&gt;　　　　　2.1、next（）方法　　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express=require(&quot;express&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
app.get(&lt;/span&gt;&quot;/&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res,next) {
    console.log(&lt;/span&gt;1&lt;span&gt;);
    next();             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有next参数，就只会conlose出来1，而不会是1，2&lt;/span&gt;
&lt;span&gt;});
app.get(&lt;/span&gt;&quot;/&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res) {
    console.log(&lt;/span&gt;2&lt;span&gt;);
});
 app.listen(&lt;/span&gt;3000);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　2.2、顺序冲突:下面这两个路由，看起来没有关系，但其实是有冲突的，因为admin可以当做用户名 login可以当做id&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express=require(&quot;express&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
app.get(&lt;/span&gt;&quot;/&lt;span&gt;:username&lt;/span&gt;/&lt;span&gt;:id&lt;/span&gt;&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
        console.log(&lt;/span&gt;&quot;1&quot;&lt;span&gt;);
     res.send(&lt;/span&gt;&quot;用户信息&quot; +&lt;span&gt; req.params.username);
});

app.get(&lt;/span&gt;&quot;/&lt;span&gt;admin&lt;/span&gt;/&lt;span&gt;login&lt;/span&gt;&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
     console.log(&lt;/span&gt;&quot;2&quot;&lt;span&gt;);
     res.send(&lt;/span&gt;&quot;管理员登录&quot;&lt;span&gt;);
});
app.listen(&lt;/span&gt;3000)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　运行结果：当我们访问172.0.0.1：3000/admin/login时只会输出  &lt;span&gt;用户信息admin &lt;span&gt;而不会&lt;/span&gt;是管理员登录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;2.3、解决顺序冲突&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　2.3.1、具体的往上写，抽象的往下写&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express=require(&quot;express&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体的&lt;/span&gt;
app.get(&quot;/admin/login&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
     console.log(&lt;/span&gt;&quot;2&quot;&lt;span&gt;);
     res.send(&lt;/span&gt;&quot;管理员登录&quot;&lt;span&gt;);
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抽象的&lt;/span&gt;
app.get(&quot;/:username/:id&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
        console.log(&lt;/span&gt;&quot;1&quot;&lt;span&gt;);
     res.send(&lt;/span&gt;&quot;用户信息&quot; +&lt;span&gt; req.params.username);
});
app.listen(&lt;/span&gt;3000)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果：当我们访问172.0.0.1：3000/admin/login时输出  &lt;span&gt;管理员登录&lt;/span&gt; 而不会是&lt;span&gt;用户信息admin &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　2.3.2、检索数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express=require(&quot;express&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
app.get(&lt;/span&gt;&quot;/:username/:id&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res,next) {
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; username=&lt;span&gt;req.params.username;
      //检索数据库，如果username 不存在，那么next()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(检索数据库){
        console.log(&lt;/span&gt;&quot;1&quot;&lt;span&gt;);
        res.send(&lt;/span&gt;&quot;用户信息&quot;&lt;span&gt;)
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        next();
    }
});
app.get(&lt;/span&gt;&quot;/admin/login&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res) {
    console.log(&lt;/span&gt;&quot;2&quot;&lt;span&gt;);
    res.send(&lt;/span&gt;&quot;管理员登录&quot;&lt;span&gt;);
});
app.listen(&lt;/span&gt;3000)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　3、app.use()中间件：与get、post不同的是，他的网址&lt;span&gt;不是精确匹配的&lt;/span&gt;。而是能够有小文件夹拓展的。&lt;/p&gt;
&lt;p&gt;　　　　3.1、get.use()的模糊匹配&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express=require(&quot;express&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;匹配所有网址&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;法一&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;当你不写路径的时候，实际上就相当于“/”,就是所有网址&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; app.use(function (req,res,next) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     console.log(new Date());&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     next();                 //执行下面的&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; });&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;法二&lt;/span&gt;
app.use(&quot;/&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res,next) {
    console.log(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
    next();                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行下面的&lt;/span&gt;
&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;匹配/admin所有地址，例如/admin/ss/aa这个都行&lt;/span&gt;
app.use(&quot;/admin&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res) {
    res.write(req.originalUrl&lt;/span&gt;+&quot;\n&quot;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  /admin/ss/aa&lt;/span&gt;
    res.write(req.path+&quot;\n&quot;);           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  /ss/aa&lt;/span&gt;
    res.write(req.baseUrl+&quot;\n&quot;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   /admin&lt;/span&gt;
    res.end(&quot;你好&quot;&lt;span&gt;);
});
app.listen(&lt;/span&gt;3000);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　3.2、get.use()读取文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express=require(&quot;express&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fs=require(&quot;fs&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当你不写路径的时候，实际上就相当于“/”,就是所有网址&lt;/span&gt;
app.use(haha);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;haha是一个函数&lt;/span&gt;
app.listen(3000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; function haha(req,res) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;     res.send(&quot;哈哈&quot;);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;span&gt;
app.use(&lt;/span&gt;'/admin',&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res) {
    res.send(&lt;/span&gt;'管理员登录'&lt;span&gt;);
})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据当前的网址，读取punlic文件夹的文件&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;如果有这个文件，就渲染这个文件&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;如果没有这个文件，那么next()&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; haha(req,res,next) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; filePath=&lt;span&gt;req.originalUrl;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据当前的网址，读取public文件夹的文件&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果有这个文件，那么渲染这个文件&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没哟偶这个文件，那么next();&lt;/span&gt;
    fs.readFile(&quot;./public/&quot;+filePath,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err,data) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(err){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件不存在&lt;/span&gt;
            next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一定要写,不然处于挂起状态&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        res.send(data.toString());
    })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　4、render和send&lt;/p&gt;
&lt;p&gt;　　　　　4.1、res.send()方法快速测试页&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express=require(&quot;express&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态服务&lt;/span&gt;
app.use('/jingtai',express.static(&quot;./public&quot;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新的路由&lt;/span&gt;
app.get('/images',&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res) {
    res.send(&lt;/span&gt;&quot;哈哈&quot;&lt;span&gt;)
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会自动识别err参数，如果有，那么就这个函数能捕获err&lt;/span&gt;
app.use(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res) {
    res.status(&lt;/span&gt;404).send(&quot;没有这个页面！&quot;&lt;span&gt;);
})
app.listen(&lt;/span&gt;3000);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　　　4.2、res.render()渲染内容，将会根据views中的模板文件进行渲染。如果不想使用views文件夹，想自己设置文件夹名字，那么app.set(&quot;views&quot;,&quot;aaaa&quot;);&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express=require(&quot;express&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; //设置ejs文件夹名字     //在day3文件夹下新建文件夹a，然后在里面放ejs文件&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; app.set(&quot;views&quot;,&quot;a&quot;)&lt;/span&gt;
app.set(&quot;view engine&quot;,&quot;ejs&quot;&lt;span&gt;);
app.get(&lt;/span&gt;&quot;/&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res) {
    res.render(&lt;/span&gt;&quot;haha&quot;&lt;span&gt;,{news:[]});

});

app.get(&lt;/span&gt;&quot;/check&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res) {
    res.send({
        &lt;/span&gt;&quot;user&quot;:&quot;ok&quot;&lt;span&gt;
    })
})
app.listen(&lt;/span&gt;3000);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　5、req.query:当输入http://127.0.0.1:3000/?id=0&amp;amp;ag=9&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express=require(&quot;express&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
app.get(&lt;/span&gt;&quot;/&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res) {
    console.log(req.query);
    res.send();
});
app.listen(&lt;/span&gt;3000);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202490/201712/1202490-20171225225750322-1827668972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;三、get请求参数post请求参数：&lt;/p&gt;
&lt;p&gt;GET请求的参数：在URL中，在Express中，不需要使用url模块了。可以直接使用req.query对象。&lt;/p&gt;
&lt;p&gt;POST请求参数：在express中不能直接获得，必须使用body-parser模块。使用后，将可以用req.body得到参数。但是如果表单中含有文件上传，那么还是需要使用formidable模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;form.ejs&lt;/span&gt;

&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form action=&quot;#&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; name=&quot;name&quot;/&amp;gt;
    &amp;lt;input type=&quot;text&quot; name=&quot;age&quot;/&amp;gt;

    &amp;lt;input type=&quot;submit&quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//.js&lt;br/&gt;var&lt;/span&gt; express=require(&quot;express&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bodyParser=require('body-parser'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
app.set(&lt;/span&gt;'view engine','ejs'&lt;span&gt;)
app.get(&lt;/span&gt;'/',&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res) {
    res.render(&lt;/span&gt;&quot;form&quot;&lt;span&gt;);
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;bodyParser API&lt;/span&gt;
app.use(bodyParser.urlencoded({extended:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;}));
app.post(&lt;/span&gt;'/',&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req,res) {
    console.log(req.body);
});
app.listen(&lt;/span&gt;3000);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202490/201712/1202490-20171225230133759-140100363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202490/201712/1202490-20171225230147712-1402299105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如何问题欢迎指教！&lt;/p&gt;

</description>
<pubDate>Mon, 25 Dec 2017 15:04:00 +0000</pubDate>
<dc:creator>蜜迷</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/15fj/p/8111678.html</dc:identifier>
</item>
<item>
<title>【Java入门提高篇】Day10 Java代理——静态代理 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/8111359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/8111359.html</guid>
<description>&lt;p&gt;　　今天要介绍的是一个Java中一个很重要的概念——代理。&lt;/p&gt;
&lt;p&gt;　　什么是代理？联系生活想想看，代理似乎并不陌生，最形象的代表便是经纪人，明星一般都有经纪人，经纪人作为中间人，负责代理明星的相关事宜，比如说，有人要请明星去唱歌表演，一般不会直接跟明星联系，而是联系他的经纪人，他的经纪人来负责安排行程，而真正唱歌表演的还是明星本人，经纪人仅仅作为一个附加物存在。&lt;/p&gt;
&lt;p&gt;　　在Java中，代理也是这样的概念，来看个栗子：&lt;/p&gt;
&lt;p&gt;　　先来创建一个明星类Stars：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Stars &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IStars{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Stars(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sing(){
        System.out.println(getName() &lt;/span&gt;+ &quot; 唱了一首歌.&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dance(){
        System.out.println(getName() &lt;/span&gt;+ &quot; 跳了一支舞.&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是相应的接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IStars {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; sing();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; dance();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在创建一个代理类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StarsProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IStars{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存接收的代理对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; IStars stars;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StarsProxy(IStars stars){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.stars =&lt;span&gt; stars;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sing() {
        System.out.println(&lt;/span&gt;&quot;我是代理，我收到了唱歌请求。&quot;&lt;span&gt;);
        stars.sing();
        System.out.println(&lt;/span&gt;&quot;唱歌完毕&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dance() {
        System.out.println(&lt;/span&gt;&quot;我是代理，我收到了跳舞请求。&quot;&lt;span&gt;);
        stars.dance();
        System.out.println(&lt;/span&gt;&quot;跳舞完毕&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　来测试一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建目标对象&lt;/span&gt;
        IStars stars = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stars(&quot;Frank&quot;);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理对象，把目标传给代理对象，建立关系&lt;/span&gt;
        IStars starsProxy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StarsProxy(stars);
        starsProxy.sing();
        starsProxy.dance();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;我是代理，我收到了唱歌请求。
Frank 唱了一首歌.
唱歌完毕
我是代理，我收到了跳舞请求。
Frank 跳了一支舞.
跳舞完毕&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以看到，实际上代理类只是保存了Stars类的一个实例，因为实现的是相同的接口，StarsProxy类必须实现需要代理的Stars类的方法，比如这里的dance和sing，而这个接口正是链接两者的关键，因为实现接口就代表必定存在接口中声明的方法。&lt;/p&gt;
&lt;p&gt;　　那么，为什么要使用代理呢？&lt;/p&gt;
&lt;p&gt;　　其实主要目的是为了扩展原有类的功能，想想看，如果那个Stars类不是你写的，而是别人写的，现在要将原有的sing或者dance方法进行改造，比如需要统计唱歌和跳舞的次数，次数大于10则不进行该操作直接返回，这时候用代理就很好实现了，来把代理类稍作修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StarsProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IStars{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存接收的代理对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; IStars stars;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存sing和dance的次数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StarsProxy(IStars stars){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.stars =&lt;span&gt; stars;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sing() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ifWork()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        System.out.println(&lt;/span&gt;&quot;我是代理，我收到了唱歌请求。&quot;&lt;span&gt;);
        stars.sing();
        System.out.println(&lt;/span&gt;&quot;唱歌完毕&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dance() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ifWork()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        System.out.println(&lt;/span&gt;&quot;我是代理，我收到了跳舞请求。&quot;&lt;span&gt;);
        stars.dance();
        System.out.println(&lt;/span&gt;&quot;跳舞完毕&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否继续工作
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 是返回true，否则返回false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; ifWork(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (num &amp;gt; 3&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;明星今天已经很累了，明天再来吧。&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            num&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改一下测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建目标对象&lt;/span&gt;
        Stars stars = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stars();
        stars.setName(&lt;/span&gt;&quot;Frank&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理对象，把目标传给代理对象，建立关系&lt;/span&gt;
        StarsProxy starsProxy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StarsProxy(stars);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0;i &amp;lt; 5; i++&lt;span&gt;){
            starsProxy.sing();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;我是代理，我收到了唱歌请求。
Frank 唱了一首歌.
唱歌完毕
我是代理，我收到了唱歌请求。
Frank 唱了一首歌.
唱歌完毕
我是代理，我收到了唱歌请求。
Frank 唱了一首歌.
唱歌完毕
我是代理，我收到了唱歌请求。
Frank 唱了一首歌.
唱歌完毕
明星今天已经很累了，明天再来吧。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看，简单粗暴。&lt;/p&gt;
&lt;p&gt;　　但其实并没有多少干货，这里仅仅是一种代理的思想，用这种思想可以比较方便的在不直接修改原有类的前提下对原有类的方法进行扩展。&lt;/p&gt;
&lt;p&gt;　　但是限制也显而易见：&lt;/p&gt;
&lt;p&gt;　　1.代理类需要跟被代理类实现相同的接口，这样才能一起向上转型后实现多态。&lt;/p&gt;
&lt;p&gt;　　2.当被代理的类需要进行的扩展增多时，管理会变得更加困难，之后对被代理类的修改，需要同时修改代理类，增加了修改成本。&lt;/p&gt;
&lt;p&gt;　　所以不要为了使用而使用，应用在合适的场景才能发挥它真正的作用。&lt;/p&gt;
&lt;p&gt;　　至此，本篇讲解完毕，欢迎大家继续关注！&lt;/p&gt;
</description>
<pubDate>Mon, 25 Dec 2017 13:39:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/8111359.html</dc:identifier>
</item>
<item>
<title>Nginx服务编译安装、日志功能、状态模块及访问认证模式实操 - 酷酷的二连长</title>
<link>http://www.cnblogs.com/lyq863987322/p/8111347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyq863987322/p/8111347.html</guid>
<description>&lt;div readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　[root@web ~]# &lt;span&gt;cat&lt;/span&gt; /etc/redhat-&lt;span&gt;release 
　　CentOS release &lt;/span&gt;&lt;span&gt;6.9&lt;/span&gt;&lt;span&gt; (Final)
　　[root@web &lt;/span&gt;~]# &lt;span&gt;uname&lt;/span&gt; -&lt;span&gt;a
　　Linux db02 &lt;/span&gt;&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;32&lt;/span&gt;-&lt;span&gt;696&lt;/span&gt;.el6.x86_64 #&lt;span&gt;1&lt;/span&gt; SMP Tue Mar &lt;span&gt;21&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;05&lt;/span&gt; UTC &lt;span&gt;2017&lt;/span&gt; x86_64 x86_64 x86_64 GNU/Linux
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;　　Nginx是一个开源的，支持高性能、高并发的WWW服务器和代理服务软件&lt;/p&gt;&lt;div readability=&quot;116.63383407306&quot;&gt;
&lt;p class=&quot;a&quot;&gt;　　nginx软件常见的使用方式或架构为：LNMP(linux nginx mysql php)&lt;/p&gt;
&lt;h2 class=&quot;a&quot;&gt;Nginx的特点或优势&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;  　　支持高并发：能支持几万并发连接（特别是静态小文件业务环境）&lt;/li&gt;
&lt;li&gt;  　　资源消耗少：在3万并发连接下，开启10个Nginx线程消耗的内存不到200MB&lt;/li&gt;
&lt;li&gt;  　　可以做HTTP反向代理及加速缓存、即负载均衡功能，内置对RS节点服务器健康检查功能，这相当于专业的Haproxy软件或LVS的功能。&lt;/li&gt;
&lt;li&gt;  　　具备Squid等专业缓存软件等的缓存功能。   &lt;/li&gt;
&lt;li&gt;  　　支持异步网络I/O事件模型epoll（Linux 2.6+）(绘图说明同步和异步)&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;11&quot;&gt;
&lt;p class=&quot;a&quot;&gt;  　　　　大并发写操作；先写内存，再将内存数据存储到硬盘中---保证访问效率&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;  　　　　大并发读操作；先写磁盘，再将磁盘数据存储到内存中---保证数据安全&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　总结：高并发--&amp;gt;资源消耗少--&amp;gt;功能多样(web服务/负载均衡/支持缓存)--&amp;gt;通讯模型先进(epoll)&lt;/p&gt;

&lt;h2&gt;一、解决nginx依赖包&lt;/h2&gt;
&lt;p&gt;需要的依赖：&lt;/p&gt;
&lt;p&gt;　　pcre：兼容perl语言正则表达式，perl compatible regular expressions rewirte模块 参数信息（perl方式定义正则表达式）&lt;/p&gt;
&lt;p&gt;　　openssl：https&lt;/p&gt;
&lt;p&gt;　　注意：所有安装依赖软件，后面都要加上-devel&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_8733e92f-49eb-49ec-bf3d-3daf79b00501&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8733e92f-49eb-49ec-bf3d-3daf79b00501&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8733e92f-49eb-49ec-bf3d-3daf79b00501&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
[root@web ~]# &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y pcre-devel openssl-&lt;span&gt;devel
下载nginx
[root@web tools]# &lt;/span&gt;&lt;span&gt;wget&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/download/nginx-1.10.2.tar.gz&lt;/span&gt;
&lt;span&gt;[root@web tools]# ll
total &lt;/span&gt;&lt;span&gt;892&lt;/span&gt;
-rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;910812&lt;/span&gt; Oct &lt;span&gt;24&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt; nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;解决依赖，下载nginx&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;二、解压nginx、创建管理用户、配置nginx&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_fe84abc5-a5ba-4cff-8978-b1b39202173d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fe84abc5-a5ba-4cff-8978-b1b39202173d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fe84abc5-a5ba-4cff-8978-b1b39202173d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
[root@web tools]# &lt;span&gt;tar&lt;/span&gt; xf nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;&lt;span&gt;.gz
[root@web tools]# ll
total &lt;/span&gt;&lt;span&gt;896&lt;/span&gt;&lt;span&gt;
drwxr&lt;/span&gt;-xr-x &lt;span&gt;8&lt;/span&gt; &lt;span&gt;1001&lt;/span&gt; &lt;span&gt;1001&lt;/span&gt;   &lt;span&gt;4096&lt;/span&gt; Oct &lt;span&gt;18&lt;/span&gt;  &lt;span&gt;2016&lt;/span&gt; nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;
-rw-r--r-- &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;910812&lt;/span&gt; Oct &lt;span&gt;24&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt; nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;&lt;span&gt;.gz
[root@web tools]# cd nginx&lt;/span&gt;-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
[root@web nginx&lt;/span&gt;-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;]# useradd -s /sbin/nologin www -&lt;span&gt;M
[root@web nginx&lt;/span&gt;-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;]# &lt;span&gt;id&lt;/span&gt;&lt;span&gt; www
uid&lt;/span&gt;=&lt;span&gt;2223&lt;/span&gt;(www) gid=&lt;span&gt;2223&lt;/span&gt;(www) &lt;span&gt;groups&lt;/span&gt;=&lt;span&gt;2223&lt;/span&gt;&lt;span&gt;(www)
[root@web01 nginx&lt;/span&gt;-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;]# ./configure --prefix=/application/nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt; --user=www --group=www --with-http_stub_status_module  --with-&lt;span&gt;http_ssl_module
&lt;/span&gt;--&lt;span&gt;prefix：表示指定软件安装到哪个目录中，指定目录不存在会自动创建
&lt;/span&gt;--user/--&lt;span&gt;group：nginx工作进程由哪个用户运行管理
&lt;/span&gt;--with-&lt;span&gt;http_stub_status_module：表示启动nginx状态模块功能（用户访问nginx的网络信息）
&lt;/span&gt;--with-http_ssl_module：启动https功能模块 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;解压nginx、创建用户、配置nginx&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;三、编译&amp;amp;&amp;amp;编译安装&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;make&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;make&lt;/span&gt; &lt;span&gt;install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;给软件创建软连接文件，方便以后管理使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_f8b549cf-c992-46f5-892d-5164893e712e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f8b549cf-c992-46f5-892d-5164893e712e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f8b549cf-c992-46f5-892d-5164893e712e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
[root@web application]# &lt;span&gt;ln&lt;/span&gt; -s /application/nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/ /application/&lt;span&gt;nginx
[root@web application]# ll
total &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
lrwxrwxrwx &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; root root   &lt;span&gt;26&lt;/span&gt; Oct &lt;span&gt;24&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt; nginx -&amp;gt; /application/nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;
drwxr&lt;/span&gt;-xr-x &lt;span&gt;6&lt;/span&gt; root root &lt;span&gt;4096&lt;/span&gt; Oct &lt;span&gt;24&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt; nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;创建软连接&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;四、启动nginx服务&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_f5125320-71e0-4afa-8b25-d17bcbabf229&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f5125320-71e0-4afa-8b25-d17bcbabf229&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f5125320-71e0-4afa-8b25-d17bcbabf229&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
[root@web application]# /application/nginx/sbin/&lt;span&gt;nginx 
[root@web application]# &lt;/span&gt;&lt;span&gt;ps&lt;/span&gt; -ef |&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; nginx
root  &lt;/span&gt;&lt;span&gt;15342&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt; ?   &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; nginx: master process /application/nginx/&lt;span&gt;sbinnginx
www   &lt;/span&gt;&lt;span&gt;15343&lt;/span&gt;  &lt;span&gt;15342&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt; ?  &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;span&gt; nginx: worker process  
        
root  &lt;/span&gt;&lt;span&gt;15345&lt;/span&gt;  &lt;span&gt;12539&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;grep&lt;/span&gt; --color=auto nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;启动nginx&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;软件安装完目录信息&lt;/h2&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p class=&quot;a&quot;&gt;　　conf             --- 软件配置文件保存目录&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　html             --- 网站站点目录*&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　logs             --- 日志文件保存目录&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　sbin             --- nginx命令保存目录&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;conf目录中内容&lt;/h3&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p class=&quot;a&quot;&gt;　　nginx.conf           　　--- nginx程序的主配置文件&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　nginx.conf.default  　 --- nginx配置备份文件&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;因为初始化的nginx配置文件内有较多注释，影响对配置文件的修改，所以进行精简化配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@web conf]# &lt;span&gt;egrep&lt;/span&gt; -v &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#|^$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; nginx.conf.default &amp;gt;nginx.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;nginx软件启动重启方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_faaf836d-3ef9-4951-9d95-6a11c4d462ee&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_faaf836d-3ef9-4951-9d95-6a11c4d462ee&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_faaf836d-3ef9-4951-9d95-6a11c4d462ee&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;启动方法（全路径） 
&lt;/span&gt;/applocation/nginx/sbin/&lt;span&gt;nginx 
停止方法（全路径&lt;/span&gt;+   -&lt;span&gt;s 参数 接指令）
&lt;/span&gt;/applocation/nginx/sbin/nginx -&lt;span&gt;s stop
平滑重启方法（全路径&lt;/span&gt;+   -&lt;span&gt;s 参数 接指令）
&lt;/span&gt;/applocation/nginx/sbin/nginx -&lt;span&gt;s reload
检查配置文件语法（全路径&lt;/span&gt;+  -&lt;span&gt;t 参数）
&lt;/span&gt;/applocation/nginx/sbin/nginx -&lt;span&gt;t
查看怎么部署的（全路径&lt;/span&gt;+   -&lt;span&gt;V 参数）
&lt;/span&gt;/applocation/nginx/sbin/nginx -V
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;nginx重启方式&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;Nginx配置文件配置详解&lt;/h2&gt;
&lt;p&gt;在server模块下指定主页文件，可以指定自己写的主页，这里需要注意的是，主页文件要放到站点目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_20566545-a5fe-4d45-92ac-708cd7021c20&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_20566545-a5fe-4d45-92ac-708cd7021c20&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_20566545-a5fe-4d45-92ac-708cd7021c20&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
[root@web nginx]# &lt;span&gt;cat&lt;/span&gt; conf/&lt;span&gt;nginx.conf
worker_processes  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;                        ##worker进程数量
events {
    worker_connections  &lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;               ##每个worker进程支持的最大连接数
}
http {
    include       mime.types;               ##Nginx支持的媒体类型库文件
    default_type  application&lt;/span&gt;/octet-&lt;span&gt;stream; ##默认的媒体类型
    sendfile        on;                     ##开启高效传输模式
    keepalive_timeout  &lt;/span&gt;&lt;span&gt;65&lt;/span&gt;&lt;span&gt;;                  ##连接超时
    server {
        listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;                    ##提供服务的端口，默认是80
        server_name  www.zxpo.top;          ##提供服务的域名主机名
        location &lt;/span&gt;/&lt;span&gt; {
            root   html&lt;/span&gt;/&lt;span&gt;www;                ##站点的根目录，相当于Nginx的安装目录
            index  index.html index.htm;   ##默认的首页文件，多个用空格分开
        }
        error_page   &lt;/span&gt;&lt;span&gt;500&lt;/span&gt; &lt;span&gt;502&lt;/span&gt; &lt;span&gt;503&lt;/span&gt; &lt;span&gt;504&lt;/span&gt;  /&lt;span&gt;50x.html;    ##出现对应的状态码，使50x.html
        location &lt;/span&gt;= /&lt;span&gt;50x.html {
            root   html;                    ##指定对应的站点目录为html
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;配置文件详解&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;多个server模块堆在一个配置文件中比较乱，难以修改，可以将配置文件分为多个，一个nginx.conf为主，例如&lt;/p&gt;
&lt;p&gt;创建一个exyra目录为存放不同站点的配置文件目录，将不同网页的server模块写成不同的配置文件，然后引用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;http {
    include       mime.types;
    default_type  application&lt;/span&gt;/octet-&lt;span&gt;stream;
    sendfile        on;
    keepalive_timeout  &lt;/span&gt;&lt;span&gt;65&lt;/span&gt;&lt;span&gt;;
    include     extra&lt;/span&gt;/&lt;span&gt;www.conf;
    include     extra&lt;/span&gt;/&lt;span&gt;blog.conf;
    include     extra&lt;/span&gt;/&lt;span&gt;bbs.conf;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;基于域名访问&lt;/h2&gt;
&lt;p&gt;　　在server模块中设置，server模块可以有多个，server_name，可以修改成不同的域名，如果是本地测试的话，记得host文件解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; server {
        listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
        server_name  www.zxpo.top;          &lt;/span&gt;&amp;lt;-&lt;span&gt; 修改虚拟主机域名名称
        location &lt;/span&gt;/&lt;span&gt; {
            root   html&lt;/span&gt;/www;                &amp;lt;-&lt;span&gt; 修改虚拟主机站点目录
            index  index.html index.htm;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;基于端口访问&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
        listen       &lt;/span&gt;&lt;span&gt;81&lt;/span&gt;;      &amp;lt;-&lt;span&gt; 将端口换成81，进行测试
        server_name  bbs.zxpo.top;
        location &lt;/span&gt;/&lt;span&gt; {
            root   html&lt;/span&gt;/&lt;span&gt;bbs;
            index  index.html index.htm;
        }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;检查&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@web nginx]# netstat -lntup|&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; nginx
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;       &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*         LISTEN      &lt;span&gt;15342&lt;/span&gt;/&lt;span&gt;nginx         
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;81&lt;/span&gt;       &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*         LISTEN      &lt;span&gt;15342&lt;/span&gt;/nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;基于IP访问&lt;/h2&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p class=&quot;a&quot;&gt;　　注意：采用基于IP配置虚拟主机，修改完配置文件后，需要重启配置文件，不能够采用平滑重启。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　　　    只要配置文件中，有关IP地址相关的改动，都需要进行重启nginx服务，不能够采用平滑重启。&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;改配置文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
        listen       &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.8&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;;   &amp;lt;-&lt;span&gt;改成某个ip还有指定的端口
        server_name  www.zxpo.top;
        location &lt;/span&gt;/&lt;span&gt; {
            root   html&lt;/span&gt;/&lt;span&gt;www;
            index  index.html index.htm;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后重启&lt;/p&gt;
&lt;h2&gt;curl访问网站流程&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@web ~]# curl -v www.zxpo.top         &amp;lt;- 利用curl命令-&lt;span&gt;v参数获取访问网站流程
a. 访问网站时首先需要根据域名解析获取到网站的ip地址，找寻网站的ip地址对应的服务器
b. 访问网站时其次需要根据请求建立连接的目标端口信息，找寻网站的相应服务端口是否存在
c. 访问网站时再次需要根据请求域名信息获悉相应的站点，找寻网站的相应站点目录下的资源信息
d. 访问网站时最后如果ip地址加端口信息都已找到，但没有找到对应的域名信息，会按照默认原则使用第一个虚拟主机作为默认访问的虚拟站点目录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Nginx共享文件web页面&lt;/h2&gt;
&lt;p&gt;　　当配置autoindex on参数以后，会显示站点目录文件列表信息：&lt;/p&gt;
&lt;p&gt;　　　1. 对于nginx服务可以识别解析资源，进行点击，会显示相应内容&lt;/p&gt;
&lt;p&gt;　　　2. 对于nginx服务不可以识别解析资源，进行点击，会直接下载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
        listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
        server_name  www.zxpo.com;
        location &lt;/span&gt;/&lt;span&gt; {
            root   html&lt;/span&gt;/www;           &amp;lt;-&lt;span&gt;或者在设置一级专门做共享的目录
          index  index.html index.htm; &lt;/span&gt;&amp;lt;-&lt;span&gt;这里要在站点目录中把主页文件删除，否则会直接显示主页
            autoindex on;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1234532/201712/1234532-20171225205111353-1602873015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　stub_status模块主要用于查看Nginx的一些状态信息&lt;/p&gt;
&lt;p&gt;       在主配置文件配置  log_format main……&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;http {
    include       mime.types;
    default_type  application&lt;/span&gt;/octet-&lt;span&gt;stream;
    sendfile        on;
    keepalive_timeout  &lt;/span&gt;&lt;span&gt;65&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;log_format  main  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$remote_addr - $remote_user [$time_local] &quot;$request&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                   &lt;span&gt;'&lt;/span&gt;&lt;span&gt;$status $body_bytes_sent &quot;$http_referer&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                   &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;&lt;br/&gt;省略……
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;访问状态信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1234532/201712/1234532-20171225205730306-1976554998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;p class=&quot;a&quot;&gt;　　Active connections   客户端连接数&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　accepts   接收数值&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　handled   处理数值（通常跟接收值是一样的，但是限制值达到上限就例外了）&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　requests  客户端请求值&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　Reading   请求报文的连接数&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　Writing   响应&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　Waiting   等待请求的数量&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　说明：一般以上页面内容信息主要会被zabbix监控服务调取，形成图像信息；根据图像信息，从而判断nginx网站服务用户访问量情况&lt;/p&gt;
&lt;/div&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;196&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;Nginx&lt;/strong&gt;&lt;strong&gt;日志变量&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;516&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;196&quot;&gt;
&lt;p&gt;$remote_addr&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;516&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;记录访问网站的客户端地址；即源 ip地址&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;196&quot;&gt;
&lt;p&gt;$http_x_forwarded_for&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;516&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;当前端有代理服务器时，设置web节点记录客户端地址的配置，此参数生效的前提是代理服务器上也进行了相关的 x_forwarded_for设置可以记录用户真实的 IP地址信息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;196&quot;&gt;
&lt;p&gt;$remote_user&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;516&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;远程客户端用户名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;196&quot;&gt;
&lt;p&gt;$time_local&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;516&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;记录访问时间与时区&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;196&quot;&gt;
&lt;p&gt;$request&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;516&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;用户的 http请求起始行信息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;196&quot;&gt;
&lt;p&gt;$status&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;516&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;http状态码，记录请求返回的状态，例如：200，404，301等&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;196&quot;&gt;
&lt;p&gt;$body_bytes_sents&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;516&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;服务器发送给客户端的响应body字节数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;196&quot;&gt;
&lt;p&gt;$http_referer&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;516&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;记录此次请求是从哪个链接访问过来的，可以根据referer进行防盗链设置即表示是哪个网站介绍过来的&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;196&quot;&gt;
&lt;p&gt;$http_user_agent&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;516&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;记录客户端访问信息，例如：浏览器、手机客户端等&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td colspan=&quot;2&quot; valign=&quot;top&quot; width=&quot;712&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;在没有特殊要求的情况下，采用默认的配置即可，更多可以设置的记录日志信息的变量见： http://nginx.org/en/docs/http/ngx_httpJog_module.html&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;错误日志信息&lt;/h2&gt;
&lt;p&gt;　　记录nginx服务运行异常情况信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;error_log的默认值为：
error_log logs&lt;/span&gt;/error.log error；
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;可以放置的标签段为（可以设置的区块）：
main，http，server，location&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参考资料：&lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#error_log&quot; target=&quot;_blank&quot;&gt;http://nginx.org/en/docs/ngx_core_module.html#error_log&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;　　说明：nginx官方文档查询信息如何使用，如何根据配置信息获取所在模块目录&lt;/p&gt;
&lt;h3&gt;配置文件中设置错误日志&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
error_log  logs/error.log  error;  
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;访问日志信息&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Nginx日志格式中默认的参数配置如下：
log_format  main  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;$status $body_bytes_sent &quot;$http_referer&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Nginx记录日志的默认参数配置如下：
access_log  logs&lt;/span&gt;/access.log  main;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;配置文件中设置访问日志&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;http {
    include       mime.types;
    default_type  application&lt;/span&gt;/octet-&lt;span&gt;stream;
    sendfile        on;
    keepalive_timeout  &lt;/span&gt;&lt;span&gt;65&lt;/span&gt;&lt;span&gt;;
 log_format  main  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$remote_addr - $remote_user [$time_local] &quot;$request&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                   &lt;span&gt;'&lt;/span&gt;&lt;span&gt;$status $body_bytes_sent &quot;$http_referer&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                   &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

access_log  logs&lt;/span&gt;/access.log  main;&lt;br/&gt;……
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;日志信息说明&lt;/h3&gt;
&lt;p&gt;这是一条日志文件中的日志信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.253&lt;/span&gt; - - [&lt;span&gt;25&lt;/span&gt;/Oct/&lt;span&gt;2017&lt;/span&gt;:&lt;span&gt;15&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;:&lt;span&gt;35&lt;/span&gt; +&lt;span&gt;0800&lt;/span&gt;] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET /favicon.ico HTTP/1.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;404&lt;/span&gt; &lt;span&gt;571&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.zxpo.top/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$remote_addr    &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.253&lt;/span&gt;&lt;span&gt;       客户端IP地址信息
$remote_user    &lt;/span&gt;-&lt;span&gt;                远程认证用户信息
[$time_local]     [&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;/Oct/&lt;span&gt;2017&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt; +&lt;span&gt;0800&lt;/span&gt;&lt;span&gt;]       显示访问事件信息
$request        GET &lt;/span&gt;/ HTTP/&lt;span&gt;1.1&lt;/span&gt;&lt;span&gt;   表示显示请求行内容
$status        &lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;               显示状态码信息（若日志中，状态码为304，表示用户端有缓存信息）
$body_bytes_sent   &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;            响应保存主体内容大小
$http_user_agent                 定义客户端以什么软件进行访问web服务器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Nginx日志切割方式&lt;/h2&gt;
&lt;h3&gt;利用脚本切割&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
&lt;/span&gt;/application/nginx/sbin/nginx -&lt;span&gt;s reload    #先重启一次生成日志

&lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; /application/nginx/logs/access_www.log /application/nginx/logs/access_www_$(&lt;span&gt;date&lt;/span&gt; +%&lt;span&gt;F).log    #然后改名

&lt;/span&gt;/application/nginx/sbin/nginx -s reload    #再次重启重新生成新的
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;具体切割日志脚本&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@www logs]# &lt;span&gt;cat&lt;/span&gt; /server/script/cut_nginx_log.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;!/bin/&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
Dateformat&lt;/span&gt;=`&lt;span&gt;date&lt;/span&gt; +%Y%m%&lt;span&gt;d`
Basedir&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/application/nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Nginxlogdir&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$Basedir/logs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Logname&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_www&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;-d $Nginxlogdir ] &amp;amp;&amp;amp; cd $Nginxlogdir || exit &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;-f ${Logname}.log ] || exit &lt;span&gt;1&lt;/span&gt;
/bin/&lt;span&gt;mv&lt;/span&gt;&lt;span&gt; ${Logname}.log ${Dateformat}_${Logname}.log
$Basedir&lt;/span&gt;/sbin/nginx -s reload
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;logrotate方式切割&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1234532/201712/1234532-20171225211456228-1700300384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; logrotate配置文件详解&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
/var/log/nginx&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.log { #/var/log/nginx/日志的存储目录，可以根据实际情况进行修改
&lt;span&gt;daily &lt;/span&gt;               ##日志文件将按天轮循
&lt;span&gt;weekly&lt;/span&gt;               ##日志文件将按周轮循
&lt;span&gt;monthly&lt;/span&gt;              ##日志文件将按月轮循
&lt;span&gt;missingok&lt;/span&gt;            ##在日志轮循期间，任何错误将被忽略，例如“文件无法找到”之类的错误
&lt;span&gt;rotate 7&lt;/span&gt;             #一次存储7个日志文件。对于第8个日志文件，时间最久的那个日志文件将被删除
&lt;span&gt;dateext&lt;/span&gt;              #定义日志文件后缀是日期格式,也就是切割后文件是:xxx.log-20160402.gz这样的格式。如果该参数被注释掉,切割出来是按数字递增,即前面说的 xxx.log-1这种格式
&lt;span&gt;# compress &lt;/span&gt;          ##在轮循任务完成后，已轮循的归档将使用gzip进行压缩
&lt;span&gt;delaycompress&lt;/span&gt;        ##总是与compress选项一起用，delaycompress选项指示logrotate不要将最近的归档压缩，压缩将在下一次轮循周期进行。这在你或任何软件仍然需要读取最新归档时很有用
&lt;span&gt;notifempty&lt;/span&gt;           ##如果是空文件的话，不进行转储
&lt;span&gt;create 640 nginx adm&lt;/span&gt; ##以指定的权限和用书属性，创建全新的日志文件，同logrotate也会重命名原始日志文件
&lt;span&gt;sharedscripts&lt;/span&gt;        ##表示postrotate脚本在压缩了日志之后只执行一次
&lt;span&gt;postrotate&lt;/span&gt;        
&lt;span&gt;[ -f /var/run/nginx.pid ] &amp;amp;&amp;amp; kill -USR1 `cat /var/run/nginx.pid`
endscript        
}&lt;/span&gt;
## postrotate/endscript：在所有其它指令完成后，postrotate和endscript里面指定的命令将被执行。在这种情况下，rsyslogd进程将立即再次读取其配置并继续运行。注意：这两个关键字必须单独成行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 进行策略控制&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_3ac75137-f946-45c8-91f1-44919d54e8a0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3ac75137-f946-45c8-91f1-44919d54e8a0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3ac75137-f946-45c8-91f1-44919d54e8a0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
location = /&lt;span&gt; {                      
        [ configuration A ]
    }
    location &lt;/span&gt;/&lt;span&gt; {                   
        [ configuration B ]
    }
    location &lt;/span&gt;/documents/&lt;span&gt; {        
        [ configuration C ]
    }
    location &lt;/span&gt;^~ /images/&lt;span&gt; {        
        [ configuration D ]
    }
    location &lt;/span&gt;~* \.（gif|jpg|&lt;span&gt;jpeg）$ {       
        [ configuration E ]
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;官方location说明&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　location表示位置的概念，类似于if，即满足什么条件，就做什么&lt;/p&gt;
&lt;p&gt;　　控制访问网段，设置访问网段白名单和黑名单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@web01 www]# &lt;span&gt;cat&lt;/span&gt; /application/nginx/conf/extra/&lt;span&gt;www.conf 
    server {
        listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
        server_name  www.etiantian.org t.org;
        location &lt;/span&gt;/&lt;span&gt; {
            root   html&lt;/span&gt;/&lt;span&gt;www;
            index  index.html index.htm;
        }
        location &lt;/span&gt;/AV/&lt;span&gt; {
            root   html&lt;/span&gt;/&lt;span&gt;www;
            index  index.html index.htm;
            allow  &lt;/span&gt;&lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;1.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;&lt;span&gt;;   ##允许内网网段访问
            deny   all;             ##其余网段拒绝
        }
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;location匹配说明&lt;/h2&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;253&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;不用&lt;/strong&gt;&lt;strong&gt;URI&lt;/strong&gt;&lt;strong&gt;及特殊字符组合匹配&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;459&quot;&gt;
&lt;p&gt;&lt;strong&gt;匹配说明&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;253&quot;&gt;
&lt;p&gt;location = / {&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;459&quot;&gt;
&lt;p&gt;精确匹配 /&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;253&quot;&gt;
&lt;p&gt;location ^~ /images {&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;459&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;匹配常规字符串，不做正则匹配检查（优先）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;253&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;location ~* \. ( gif|jpg|jpeg ) $ {&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;459&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;正常匹配，匹配后缀为gif|jpg|jpeg的&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;253&quot;&gt;
&lt;p&gt;location /documents/ {&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;459&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;匹配常规字符串，如果有正则，优先匹配正则&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;253&quot;&gt;
&lt;p&gt;location / {&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;459&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;所有location都不能匹配后的默认匹配&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td colspan=&quot;2&quot; valign=&quot;top&quot; width=&quot;712&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;~   :&lt;/strong&gt; &lt;strong&gt;匹配内容区分大小写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~* &lt;/strong&gt; &lt;strong&gt;：匹配内容不区分大小写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;！&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt; &lt;strong&gt;：表示取反匹配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;^~ &lt;/strong&gt; &lt;strong&gt;：表示当多个匹配同时存在，优先匹配&lt;/strong&gt;&lt;strong&gt;^~&lt;/strong&gt;&lt;strong&gt;内容&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;修改nginx的相关配置文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    server {
        listen      &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
        server_name  www.zxpo.top;
        location &lt;/span&gt;/&lt;span&gt; {
            root   html&lt;/span&gt;/&lt;span&gt;www;
            index  index.html index.htm;
            auth_basic       &lt;/span&gt;&lt;span&gt;&quot;erlianzhang&lt;/span&gt;&lt;span&gt; training&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            auth_basic_user_file    &lt;/span&gt;/application/nginx/conf/&lt;span&gt;htpasswd;
       }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建密码认证文件并进行授权&lt;/h2&gt;
&lt;h3&gt; 首先要下载httpd-tools软件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; httpd-tools -y
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;htpasswd的参数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_bf2efafb-eb2a-4be1-bade-0d751b9f7d1d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bf2efafb-eb2a-4be1-bade-0d751b9f7d1d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bf2efafb-eb2a-4be1-bade-0d751b9f7d1d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
[root@web application]# htpasswd -&lt;span&gt;hlep
Usage:
    htpasswd [&lt;/span&gt;-&lt;span&gt;cmdpsD] passwordfile username
    htpasswd &lt;/span&gt;-&lt;span&gt;b[cmdpsD] passwordfile username password
    htpasswd &lt;/span&gt;-&lt;span&gt;n[mdps] username
    htpasswd &lt;/span&gt;-&lt;span&gt;nb[mdps] username password
 &lt;/span&gt;-c      Create a new &lt;span&gt;file&lt;/span&gt;&lt;span&gt;.
        创建一个新的密码文件
 &lt;/span&gt;-n      Don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t update file; display results on stdout.&lt;/span&gt;
&lt;span&gt;        不更新文件，显示输出结果
 &lt;/span&gt;-&lt;span&gt;m      Force MD5 encryption of the password.
        强制采用MD5加密密码
 &lt;/span&gt;-&lt;span&gt;d      Force CRYPT encryption of the password (default).
        强制采用CRYPT加密密码（默认）
 &lt;/span&gt;-&lt;span&gt;p      Do not encrypt the password (plaintext).
        不加密密码（明文） 
 &lt;/span&gt;-&lt;span&gt;s      Force SHA encryption of the password.
        强制采用SHA加密密码
 &lt;/span&gt;-b      Use the password from the command line rather than prompting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; it.
        使用密码来自命令行，相当于免交互方式
 &lt;/span&gt;-&lt;span&gt;D      Delete the specified user.
        删除指定用户
On Windows, NetWare and TPF systems the &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; flag is used by default.
On all other systems, the &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; flag will probably not work.
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;htpasswd参数详解&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;创建认证文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_0572697a-854c-4af8-a300-ac9577c93fc5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0572697a-854c-4af8-a300-ac9577c93fc5&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0572697a-854c-4af8-a300-ac9577c93fc5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
[root@web www]# htpasswd -bc /application/nginx/conf/htpasswd lyq &lt;span&gt;123456&lt;/span&gt;&lt;span&gt;
Adding password &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; user oldboy
[root@web01 www]# &lt;/span&gt;&lt;span&gt;cat&lt;/span&gt; /application/nginx/conf/&lt;span&gt;htpasswd 
lyq:DVu6f44f2I81w    &lt;/span&gt;&amp;lt;- 加密的认证文件自动设置密文
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;认证文件生成&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;给密码文件授权，重启Nginx&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7007f125-dc5a-4ce2-9b53-d273d5ba7b3b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7007f125-dc5a-4ce2-9b53-d273d5ba7b3b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7007f125-dc5a-4ce2-9b53-d273d5ba7b3b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
[root@web www]# &lt;span&gt;chown&lt;/span&gt; -R www.www /application/nginx/conf/&lt;span&gt;htpasswd
[root@web www]# &lt;/span&gt;&lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;400&lt;/span&gt; /application/nginx/conf/&lt;span&gt;htpasswd
[root@web www]# &lt;/span&gt;/application/nginx/sbin/nginx -&lt;span&gt;t
nginx: the configuration &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; /application/nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/conf/&lt;span&gt;nginx.conf syntax is ok
nginx: configuration &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; /application/nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/conf/&lt;span&gt;nginx.conf test is successful
[root@web www]# &lt;/span&gt;/application/nginx/sbin/nginx -s reload
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;授权密码文件，重启nginx&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;登陆测试&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1234532/201712/1234532-20171225213310540-703621609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Mon, 25 Dec 2017 13:35:00 +0000</pubDate>
<dc:creator>酷酷的二连长</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyq863987322/p/8111347.html</dc:identifier>
</item>
<item>
<title>关于signal和fork的思考 - xcywt</title>
<link>http://www.cnblogs.com/xcywt/p/8111314.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcywt/p/8111314.html</guid>
<description>&lt;p&gt;&lt;span&gt;fork可以在linux中创建子进程。先看man手册里面的东西：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;SYNOPSIS&lt;br/&gt;       #include &amp;lt;unistd.h&amp;gt;&lt;/p&gt;&lt;p&gt;       pid_t fork(void);&lt;/p&gt;&lt;p&gt;DESCRIPTION&lt;br/&gt;       fork()  creates  a new process by duplicating the calling process.  The&lt;br/&gt;       new process, referred to as the child, is an  exact  duplicate  of  the&lt;br/&gt;       calling  process,  referred  to as the parent    ......&lt;br/&gt;RETURN VALUE&lt;br/&gt;       On success, the PID of the child process is returned in the parent, and&lt;br/&gt;       0  is returned in the child.  On failure, -1 is returned in the parent,&lt;br/&gt;       no child process is created, and errno is set appropriately.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数的作用的创建一个进程，这个函数会返回两次，可能有三种不同的返回值。 &lt;br/&gt;1. 出错返回-1 &lt;br/&gt;2. 返回0，表示是子进程 &lt;br/&gt;3. 返回大于0，表示是父进程&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面的一个简单的实例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;signal.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/types.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/wait.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; CHILDCOUNT 1

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{ 
    pid_t fpid[CHILDCOUNT ];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; CHILDCOUNT; i++&lt;span&gt;)
    {
        fpid[i] &lt;/span&gt;=&lt;span&gt; fork();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fpid[i] &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {   
            perror(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(fpid[i] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is child process, id:%d, my father:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, getpid(), getppid());
            getchar();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is parent process, id:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, getpid());
        }
    }

    getchar();
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main() ------\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;补充一点知识&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fork出来的子进程复制了父进程的内存空间（处理代码区都复制了），和父进程共享代码区&lt;/li&gt;
&lt;li&gt;fork之后，父子进程谁先执行不确定&lt;/li&gt;
&lt;li&gt;子进程中新定义的变量和父进程没有任何关系&lt;/li&gt;
&lt;li&gt;子进程也会复制父进程文件描述符，但是不会复制文件表。而是共用一个offset&lt;/li&gt;
&lt;li&gt;如果父进程先挂了，子进程就变成孤儿进程了，它爹就会变成1号进程&lt;/li&gt;
&lt;li&gt;子进程挂了会给父进程发信号（SIGCHLD），如果父进程收到该信号没有及时处理。子进程就变成僵尸进程了，直到父进程处理了该信号或父进程也退出了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;如何避免僵尸进程的出现？&lt;/span&gt;&lt;br/&gt;如之前所说，父进程应该及时处理子进程发出来的信号，并且去获取子进程的退出码。 &lt;br/&gt;在父进程中使用wait或waitpid参数等待子进程退出。 &lt;br/&gt;也可以在收到子进程退出的信号时用wait或waitpid等待。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;signal.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/types.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/wait.h&amp;gt;

&lt;span&gt;void&lt;/span&gt; sig_handle(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sig)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ret = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s() +++\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, __func__);
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; 0&lt;span&gt;
    wait(NULL);
&lt;/span&gt;&lt;span&gt;#else&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(ret = waitpid(-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, NULL, WNOHANG))
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waitpid failed\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waitpid success\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    signal(SIGCHLD, sig_handle); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记A&lt;/span&gt;
    pid_t fpid[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
    {
        fpid[i] &lt;/span&gt;=&lt;span&gt; fork();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fpid[i] &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {   
            perror(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(fpid[i] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is child process, id:%d, my father:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, getpid(), getppid());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is parent process, id:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, getpid());
        }
    }

    getchar();
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main() ------\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如没有signal(SIGCHLD, sig_handle);这个语句，函数运行时，5个子进程马上就结束了（父进程不能退出了）。这时候去查看可以看到有5个僵尸进程。 &lt;br/&gt;如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
xcy@xcy-&lt;span&gt;virtual&lt;/span&gt;-machine:~/test/sock4$ ps -ef |&lt;span&gt; grep test
xcy        &lt;/span&gt;&lt;span&gt;5573&lt;/span&gt;   &lt;span&gt;2863&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; pts/&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; ./&lt;span&gt;test
xcy        &lt;/span&gt;&lt;span&gt;5574&lt;/span&gt;   &lt;span&gt;5573&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; pts/&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; [test] &amp;lt;defunct&amp;gt;&lt;span&gt;
xcy        &lt;/span&gt;&lt;span&gt;5575&lt;/span&gt;   &lt;span&gt;5573&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; pts/&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; [test] &amp;lt;defunct&amp;gt;&lt;span&gt;
xcy        &lt;/span&gt;&lt;span&gt;5576&lt;/span&gt;   &lt;span&gt;5573&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; pts/&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; [test] &amp;lt;defunct&amp;gt;&lt;span&gt;
xcy        &lt;/span&gt;&lt;span&gt;5577&lt;/span&gt;   &lt;span&gt;5573&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; pts/&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; [test] &amp;lt;defunct&amp;gt;&lt;span&gt;
xcy        &lt;/span&gt;&lt;span&gt;5578&lt;/span&gt;   &lt;span&gt;5573&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; pts/&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; [test] &amp;lt;defunct&amp;gt;&lt;span&gt;
xcy        &lt;/span&gt;&lt;span&gt;5580&lt;/span&gt;   &lt;span&gt;3126&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; grep --color=&lt;span&gt;auto test
xcy@xcy&lt;/span&gt;-&lt;span&gt;virtual&lt;/span&gt;-machine:~/test/sock4$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加上那句话就没有了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
xcy@xcy-&lt;span&gt;virtual&lt;/span&gt;-machine:~/test/sock4$ ps -ef |&lt;span&gt; grep test
xcy        &lt;/span&gt;&lt;span&gt;5587&lt;/span&gt;   &lt;span&gt;2863&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt; pts/&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; ./&lt;span&gt;test
xcy        &lt;/span&gt;&lt;span&gt;5595&lt;/span&gt;   &lt;span&gt;3126&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; grep --color=&lt;span&gt;auto test
xcy@xcy&lt;/span&gt;-&lt;span&gt;virtual&lt;/span&gt;-machine:~/test/sock4$
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;再来一些有意思的东西&lt;/span&gt;&lt;br/&gt;我们知道fork会出现两个进程，两个进程都会往下执行，看下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;unistd.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    fork();
    fork();
    fork();
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就相当于最开始主进程创建两个进程A和B。 &lt;br/&gt;A又创建两个进程A1，A2。B又创建两个进程B1，B2。 &lt;br/&gt;最后，A1，A2，B1，B2都创建两个进程，所以最后会有8个进程，+会打印8次。 &lt;br/&gt;这样就想细胞的二次分裂一样，3次分裂周期之后就有了8个细胞。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;再来看个更难的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;unistd.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; fun()
{
    fork();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fork() || fork() &amp;amp;&amp;amp; fork(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个fork返回大于0，后面两个就不执行了&lt;/span&gt;
    fork() &amp;amp;&amp;amp; fork() ||&lt;span&gt; fork();
    fork();
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    fun2();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一共能创建几个进程呢，+会打印几次呢。我们先一步一步来分析，假定所有的fork都会成功： &lt;br/&gt;第一次分裂成A和B。A进程创建的进程和B创建的进程数目肯定是一样的。&lt;/p&gt;
&lt;p&gt;就先像下面这样分析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
fork() &amp;amp;&amp;amp; fork() || fork(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; line 1&lt;/span&gt;
fork(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; line 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要注意&amp;amp;&amp;amp;运算符和||运算符： &lt;br/&gt;对于&amp;amp;&amp;amp;来说：第一个表达式如果为0，后面的表达式就不用算了 &lt;br/&gt;对于||来说：第一个表达式如果为1，后面的表达式也不用算了。 &lt;br/&gt;为&lt;span&gt;了更好分析，上面的fork一次标号为fork1，fork2，fork3，fork4。 &lt;/span&gt;&lt;br/&gt;先看line1。&lt;span&gt;fork1&lt;/span&gt;会返回一个非0，和一个0.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.返回0，则直接进入line2，&lt;span&gt;fork4&lt;/span&gt;创建两个进程&lt;/li&gt;
&lt;li&gt;2.返回大于0，执行&lt;span&gt;fork2&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;2.1 fork2返回0，则需要执行&lt;span&gt;fork3&lt;/span&gt;，再接着执行&lt;span&gt;fork4&lt;/span&gt;.这里会创建4个进程&lt;/li&gt;
&lt;li&gt;2.2 fork2返回大于0，也会执行&lt;span&gt;fork3&lt;/span&gt;和&lt;span&gt;fork4&lt;/span&gt;。相当于也创建4个进程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上，第一次的A进程会产生10个进程，同理，B也会有10个进程。所以一共会有20个进程。&lt;/p&gt;

</description>
<pubDate>Mon, 25 Dec 2017 13:24:00 +0000</pubDate>
<dc:creator>xcywt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcywt/p/8111314.html</dc:identifier>
</item>
<item>
<title>FiddlerCoreAPI开发（二）截获HTTPS流量 - real王一</title>
<link>http://www.cnblogs.com/realwy/p/8111253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/realwy/p/8111253.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/realwy/p/8075705.html&quot;&gt;上一篇文章&lt;/a&gt;简单简单分析了fiddlercore自带样例的代码，本篇文章进入主题，介绍如何使用fiddlercore截获&lt;strong&gt;HTTPS&lt;/strong&gt;流量。&lt;/p&gt;
&lt;p&gt;当时学习完样例代码后，我觉得结合注释来抓HTTPS的包应该也很简单，结果按照注释的提示修改了下代码后，还是抓不到，反复尝试了很多方法都没有解决，在google上搜了搜有人说可能是证书的问题，但也没有给出具体的解决办法，所以只能自己慢慢摸索，终于找到了一种方法，在这里和大家分享一下。&lt;/p&gt;
&lt;p&gt;既然有可能是证书出了问题，那么我们就自己生成个证书，翻了翻帮助文档发现还真有这样的函数，叫做createRootCert()，而且函数说明中写道： “Create a self-signed certificate to use for &lt;strong&gt;HTTPS interception&lt;/strong&gt;” ，看到这个说明我觉得我可能找对地方了，直接生成证书：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fiddler.CertMaker.createRootCert();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用GetRootCertificate()获得上述证书：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;X509Certificate2 oRootCert = Fiddler.CertMaker.GetRootCertificate();//Returns the Root certificate that Fiddler uses to generate per-site certificates used for HTTPS interception. &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把这个证书安装到受信任的根证书颁发机构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Security.Cryptography.X509Certificates.X509Store certStore = new System.Security.Cryptography.X509Certificates.X509Store(StoreName.Root, StoreLocation.LocalMachine);
certStore.Open(OpenFlags.ReadWrite);
try
{
    certStore.Add(oRootCert);
}
finally
{
    certStore.Close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个证书还要赋值给变量oDefaultClientCertificate（The default certificate used for client authentication）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fiddler.FiddlerApplication.oDefaultClientCertificate = oRootCert;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，问题算是解决了，后面就是按部就班的做就可以了。&lt;/p&gt;
&lt;p&gt;bBufferResponse这个属性在BeforeRequest里设为true，可以修改响应内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fiddler.FiddlerApplication.BeforeRequest += delegate(Fiddler.Session oS)
{
    oS.bBufferResponse = true;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BeforeResponse里面把会话存起来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fiddler.FiddlerApplication.BeforeResponse += delegate(Fiddler.Session oSession)
{
    if (oSession.isHTTPS)
    {

            Monitor.Enter(oAllSessions);
            oAllSessions.Add(oSession);
            Monitor.Exit(oAllSessions);

    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;忽略服务器证书错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fiddler.CONFIG.IgnoreServerCertErrors = true;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再往后正常的Startup()和CreateProxyEndpoint()就可以了，响应的内容都保存在oAllSessions里面了，想怎么处理就怎么处理吧，在此不多赘述了，懂的人都懂。&lt;/p&gt;
&lt;p&gt;最后附一张上某宝截获的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1209573/201712/1209573-20171225220639072-1932514202.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;注意&quot;&gt;注意&lt;/h2&gt;
&lt;p&gt;1.如果是火狐浏览器的话，还需要把证书导入到浏览器中。&lt;/p&gt;
&lt;p&gt;2.别忘了Shutdown()，不然浏览器就上不了网了，上不了的话去浏览器设置里面把代理去掉就可以了。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Dec 2017 13:15:00 +0000</pubDate>
<dc:creator>real王一</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/realwy/p/8111253.html</dc:identifier>
</item>
<item>
<title>锁的实现原理 - 钟绍威</title>
<link>http://www.cnblogs.com/wewill/p/8111215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wewill/p/8111215.html</guid>
<description>&lt;p&gt; 锁在多线程中是必不可少的，他给多线程提供了&lt;strong&gt;同步&lt;/strong&gt;的功能，让多线程可以&lt;strong&gt;互斥&lt;/strong&gt;的执行同步块，并具有&lt;strong&gt;可见性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; 本文将从happens-before关系出发，结合ReentranLock源码，如何用内存屏障、CAS操作、LOCK指令实现锁的功能。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;happens-before规则&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;程序顺序规则：在一个线程中，前面的操作happens-before后面的操作&lt;/li&gt;
&lt;li&gt;锁规则：对同一个锁，解锁happens-before加锁。&lt;/li&gt;
&lt;li&gt;传递性规则：A happens-before B，B happens-before C，则A happens-before C&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt; 从这段代码看看happens-before关系，线程A先执行store()，线程B后执行load()&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; value = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; finish = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

&lt;span class=&quot;co&quot;&gt;//线程A&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;store&lt;/span&gt;(){
    &lt;span class=&quot;co&quot;&gt;//A：加锁前的操作&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;){ &lt;span class=&quot;co&quot;&gt;//B：加锁&lt;/span&gt;
        value = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;      &lt;span class=&quot;co&quot;&gt;//C：写value&lt;/span&gt;
        finish = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;  &lt;span class=&quot;co&quot;&gt;//D：写finish&lt;/span&gt;
    }                   &lt;span class=&quot;co&quot;&gt;//E：解锁&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//F：解锁后的操作&lt;/span&gt;
}

&lt;span class=&quot;co&quot;&gt;//线程B&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(){
    &lt;span class=&quot;co&quot;&gt;//G：加锁前的操作&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;){ &lt;span class=&quot;co&quot;&gt;//H：加锁&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(finish){     &lt;span class=&quot;co&quot;&gt;//I：读finish&lt;/span&gt;
            assert value == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;//J：读value&lt;/span&gt;
        }
    }                   &lt;span class=&quot;co&quot;&gt;//K：解锁&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//L：解锁后的操作&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里有13个happens-before关系。①～⑤是线程A的程序顺序关系，⑥~⑩是线程B的程序顺序关系，⑪是锁规则关系，⑫～⑬是传递性关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/7C9719EF8B2540A991189CF40D5B4310?method=download&amp;amp;shareKey=c7457c11dcae9bf05cebe8c1749d23be&quot; title=&quot;锁happens-before关系&quot; alt=&quot;锁happens-before关系&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;①~⑩&lt;/strong&gt;根据程序顺序规则，只要不重排序数据依赖的指令，执行结果就是正确的，就可以保证在&lt;em&gt;单线程&lt;/em&gt;内的可见性。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;⑪&lt;/strong&gt;根据锁规则，E happens-before H，也就是&lt;strong&gt;线程A解锁 happens-before 线程B加锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;⑫&lt;/strong&gt;根据传递性规则，线程A解锁前的操作都需要对线程B加锁可见，ABCDE happens-before H，也就是&lt;strong&gt;线程A解锁及其先前操作 happens-before 线程B加锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;⑬&lt;/strong&gt;再根据传递性规则，线程A解锁前的操作都需要对线程B加锁之后的操作可见，ABCDE happens-before HIJKL，最终得出&lt;strong&gt;线程A解锁及其先前操作 happens-before 线程B加锁及其后续操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; 这样来看，为了保证解锁及其之前操作的可见性，需要把解锁线程的本地内存刷新到主内存去。同时为了保证加锁线程读到最新的值，需要将本地内存的共享变量设为无效，重新从主内存中读取。&lt;/p&gt;
&lt;span id=&quot;yuanli&quot;/&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前面得出来的锁的可见性：线程A解锁及其先前操作 happens-before 线程B加锁及其后续操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 将前面得出的可见性分解为三个等级：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程A解锁 happens-before 线程B加锁&lt;/li&gt;
&lt;li&gt;线程A解锁及其先前操作 happens-before 线程B加锁&lt;/li&gt;
&lt;li&gt;线程A解锁及其先前操作 happens-before 线程B加锁及其后续操作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于这是在多线程间实现可见性，那么就要考虑本地内存和主内存的缓存不一致问题，需要用到JMM的内存屏障：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/26850C1996884379959E4075A9F6D1D5?method=download&amp;amp;shareKey=c7457c11dcae9bf05cebe8c1749d23be&quot; alt=&quot;内存屏障&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 逐级的实现可见性：&lt;/p&gt;
&lt;p&gt; 1) 对于&lt;strong&gt;第一级可见性&lt;/strong&gt;，线程A解锁 需要对 线程B加锁可见，在多线程间的，会引发缓存不一致，所以要把&lt;strong&gt;线程A的本地内存刷新到主内存去&lt;/strong&gt;。所以在解锁、加锁之间需要加&lt;strong&gt;写读内存屏障&lt;/strong&gt;，这里有两种实现方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在线程A解锁后加StoreLoad Barrier&lt;/li&gt;
&lt;li&gt;在线程B加锁前，加StoreLoad Barrier。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 在常用的开发模式中，常常是一个线程负责写，多个线程负责读，典型的像生产者-消费者模式。所以相较后者，前者的内存屏障执行次数少，性能高。采用第一种实现方式比较好。&lt;/p&gt;
&lt;p&gt; 2) 对于&lt;strong&gt;第二级可见性&lt;/strong&gt;，线程A解锁前的操作需要对加锁可见，也就是线程A解锁前的操作不能被重排序到解锁后。由于只有写操作会对改变共享变量，所以需要在解锁前加上&lt;strong&gt;StoreStore Barrier&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; 3) 对于&lt;strong&gt;第三级可见性&lt;/strong&gt;，线程B加锁之后的读写操作不能重排序到加锁前，否则线程B可能读不到线程A的操作结果，以及线程B可能在线程A之前修改了共享变量。所以需要在线程B加锁后加上&lt;strong&gt;LoadLoad Barrier 和 LoadStore Barrier&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; 综上所述：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解锁前加StoreStore Barrier&lt;/li&gt;
&lt;li&gt;解锁后加StoreLoad Barrier&lt;/li&gt;
&lt;li&gt;加锁后加LoadLoad Barrier 和LoadStore Barrier&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 加上内存屏障后的程序：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; value = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; finish = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

&lt;span class=&quot;co&quot;&gt;//线程A&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;store&lt;/span&gt;(){
    &lt;span class=&quot;co&quot;&gt;//A：加锁前的操作&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;){ &lt;span class=&quot;co&quot;&gt;//B：加锁&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;loadLoadBarrier&lt;/span&gt;();
        &lt;span class=&quot;fu&quot;&gt;loadStoreBarrier&lt;/span&gt;();
        value = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;      &lt;span class=&quot;co&quot;&gt;//C：写value&lt;/span&gt;
        finish = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;  &lt;span class=&quot;co&quot;&gt;//D：写finish&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;storeStoreBarrier&lt;/span&gt;();
                        &lt;span class=&quot;co&quot;&gt;//E：解锁&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;storeLoadBarrier&lt;/span&gt;();
    }                   
    &lt;span class=&quot;co&quot;&gt;//F：解锁后的操作&lt;/span&gt;
}

&lt;span class=&quot;co&quot;&gt;//线程B&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(){
    &lt;span class=&quot;co&quot;&gt;//G：加锁前的操作&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;){ &lt;span class=&quot;co&quot;&gt;//H：加锁&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;loadLoadBarrier&lt;/span&gt;();
        &lt;span class=&quot;fu&quot;&gt;loadStoreBarrier&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(finish){     &lt;span class=&quot;co&quot;&gt;//I：读finish&lt;/span&gt;
            assert value == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;//J：读value&lt;/span&gt;
        }
        &lt;span class=&quot;fu&quot;&gt;storeStoreBarrier&lt;/span&gt;();
                        &lt;span class=&quot;co&quot;&gt;//K：解锁&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;storeLoadBarrier&lt;/span&gt;();
    }
    &lt;span class=&quot;co&quot;&gt;//L：解锁后的操作&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; Java提供的锁可以分为两种：隐形锁和显性锁。隐形锁就是常用的synchronized语句，是由Java语法提供的，语法的源码比较难找。在这里用显性锁的源码去分析，显性锁实际上是Java中的一个工具类，允许以调用函数的形式去加锁解锁。从功能上看显性锁的功能更强大，因为其能通过继承实现不同算法的锁，以便根据实际情况选择合适的锁。这里使用ReentrantLock去分析源码。&lt;/p&gt;
&lt;p&gt; 在前面&lt;a href=&quot;http://www.cnblogs.com/wewill/p/8111215.html#yuanli&quot;&gt;实现锁的原理&lt;/a&gt;中，得出实现可见性的原理是在加锁解锁前后加上内存屏障。乍一看这不是和volatile的原理是一模一样的吗，连使用的内存屏障种类顺序都一样。所以在ReentrantLock中，他&lt;strong&gt;复用了volatile提供的可见性&lt;/strong&gt;，并没有再去写内存屏障。&lt;/p&gt;
&lt;p&gt; 在ReentrantLock中，他有一个变量state是volatile的（继承自AbstractQueuedSynchorinizer）。解锁-加锁分别是由写-读state这个volatile变量去实现的。这个&lt;strong&gt;state变量可以理解成所被重入的次数&lt;/strong&gt;（ReentrantLock是可重入锁），0表示没有线程拥有该锁，2表示被拥有者连续拥有了两次且没有释放。&lt;/p&gt;
&lt;p&gt; ReentranLoack分为公平锁和不公平锁，下面分别看看这两种锁在解锁加锁的源码。&lt;/p&gt;
&lt;h2 id=&quot;解锁的实现&quot;&gt;解锁的实现&lt;/h2&gt;
&lt;p&gt; 公平锁和不公平锁的对于解锁的实现都是一样的，都是写state变量。最后都是调用ReentranLock.Sync.tryRelease()&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//在java.util.concurrent.locks.ReentranLock.Sync.tryRelease()&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryRelease&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; releases) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;() - releases;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;() != &lt;span class=&quot;fu&quot;&gt;getExclusiveOwnerThread&lt;/span&gt;())&lt;span class=&quot;co&quot;&gt;//如果当前线程不是该锁的拥有者则抛出异常&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalMonitorStateException();
    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; free = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;//锁是否可用&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (c == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {&lt;span class=&quot;co&quot;&gt;//state=0 表示该持有线程完全释放该锁，需要设置free为可用状态以及拥有者线程置空&lt;/span&gt;
        free = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
    }
    &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(c);&lt;span class=&quot;co&quot;&gt;//在释放锁的最后，写state&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; free;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 根据&lt;a target=&quot;_blank&quot; href=&quot;http://www.cnblogs.com/wewill/p/8108629.html/#cpushixian&quot;&gt;volatile原理&lt;/a&gt;知道，写state这个volatile变量也就相当于&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;storeStoreBarrier&lt;/span&gt;();
解锁;
&lt;span class=&quot;fu&quot;&gt;storeLoadBarrier&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这样的内存屏障和前面&lt;a href=&quot;http://www.cnblogs.com/wewill/p/8111215.html#yuanli&quot;&gt;锁原理&lt;/a&gt;分析的是一样的，所以&lt;strong&gt;写volatile与解锁有一样的功能&lt;/strong&gt;，也就能&lt;strong&gt;使用写volatile的方式实现解锁&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;加锁的实现&quot;&gt;加锁的实现&lt;/h2&gt;
&lt;p&gt; 加锁中，公平锁和不公平锁实现的方式就有很大的不同了。公平锁使用的是&lt;strong&gt;读volatile&lt;/strong&gt;，不公平锁使用的是&lt;strong&gt;CompareAndSet(CAS)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;公平锁的加锁实现&quot;&gt;公平锁的加锁实现&lt;/h3&gt;
&lt;p&gt; 先看公平锁的读state加锁实现，核心代码在ReentranLock.FairSync.tryAcquire()。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//在java.util.concurrent.locks.ReentranLock.FairSync.tryAcquire()&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; acquires) {
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Thread current = Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;();
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;();&lt;span class=&quot;co&quot;&gt;//在加锁的一开始，读state&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (c == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {&lt;span class=&quot;co&quot;&gt;//锁处于可用状态&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;hasQueuedPredecessors&lt;/span&gt;() &amp;amp;&amp;amp;
            &lt;span class=&quot;fu&quot;&gt;compareAndSetState&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, acquires)) {
            &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(current);&lt;span class=&quot;co&quot;&gt;//设置锁被当前线程拥有&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        }
    }
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (current == &lt;span class=&quot;fu&quot;&gt;getExclusiveOwnerThread&lt;/span&gt;()) {&lt;span class=&quot;co&quot;&gt;//state&amp;gt;0，重入了&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; nextc = c + acquires;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (nextc &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;st&quot;&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;//超过最大重入次数2147483648（最大的int）&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(nextc);&lt;span class=&quot;co&quot;&gt;//更新state&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 根据&lt;a target=&quot;_blank&quot; href=&quot;http://www.cnblogs.com/wewill/p/8108629.html#cpushixian&quot;&gt;volatile原理&lt;/a&gt;知道，读state这个volatile变量也就相当于&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;加锁;
&lt;span class=&quot;fu&quot;&gt;loadLoadBarrier&lt;/span&gt;();
&lt;span class=&quot;fu&quot;&gt;loadStoreBarrier&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这样的内存屏障和前面&lt;a href=&quot;http://www.cnblogs.com/wewill/p/8111215.html#yuanli&quot;&gt;锁原理&lt;/a&gt;分析的是一样的，所以&lt;strong&gt;读volatile与加锁有一样的功能&lt;/strong&gt;，也就能&lt;strong&gt;使用读volatile的方式实现加锁&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;不公平锁的加锁实现&quot;&gt;不公平锁的加锁实现&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//在java.util.concurrent.locks.ReentranLock.NoFairSync.lock()&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetState&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))&lt;span class=&quot;co&quot;&gt;//如果该锁可用，则占有&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;());
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//尝试重入&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;acquire&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
}
&lt;span class=&quot;co&quot;&gt;//在java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState()&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;compareAndSetState&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expect, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; update) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; unsafe.&lt;span class=&quot;fu&quot;&gt;compareAndSwapInt&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, stateOffset, expect, update);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果该锁没占用的时候，调用的是unsafe.compareAndSwapInt()，这是一个CAS操作。如果该锁已经被占有了，尝试重入，这部分的代码是使用和公平锁一样的读state方式实现的。&lt;/p&gt;
&lt;p&gt; unsafe.compareAndSwapInt()这是一个native方法，是用JNI调用C++或者汇编的，需要到openjdk看，位置在：openjdk-7-fcs-src-b147-&lt;br/&gt;27_jun_2011\openjdk\hotspot\src\os_cpu\windows_x86\vm\atomic_windows_x86.inline.hpp&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//CAS源码：&lt;/span&gt;
inline jint Atomic::&lt;span class=&quot;fu&quot;&gt;cmpxchg&lt;/span&gt; (jint exchange_value, &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; jint* dest,
        jint compare_value) {
        &lt;span class=&quot;co&quot;&gt;// alternative for InterlockedCompareExchange&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; mp = os::&lt;span class=&quot;fu&quot;&gt;is_MP&lt;/span&gt;();&lt;span class=&quot;co&quot;&gt;//是否为多核心处理器&lt;/span&gt;
    __asm {
        mov edx, dest           &lt;span class=&quot;co&quot;&gt;//要修改的地址，也就是state变量&lt;/span&gt;
        mov ecx, exchange_value &lt;span class=&quot;co&quot;&gt;//新值值&lt;/span&gt;
        mov eax, compare_value  &lt;span class=&quot;co&quot;&gt;//期待值&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;LOCK_IF_MP&lt;/span&gt;(mp)          &lt;span class=&quot;co&quot;&gt;//如果是多处理器，在下面指令前加上LOCK前缀&lt;/span&gt;
        cmpxchg dword ptr [edx], ecx&lt;span class=&quot;co&quot;&gt;//[edx]与eax对比，相同则[edx]=ecx，否则不操作&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里看到有一个LOCK_IF_MP，作用是如果是多处理器，在指令前加上LOCK前缀，因为在单处理器中，是不会存在缓存不一致的问题的，所有线程都在一个CPU上跑，使用同一个缓存区，也就不存在本地内存与主内存不一致的问题，不会造成可见性问题。然而在多核处理器中，共享内存需要从写缓存中刷新到主内存中去，并遵循&lt;a target=&quot;_blank&quot; href=&quot;http://www.cnblogs.com/wewill/p/8098189.html#mesi&quot;&gt;缓存一致性协议&lt;/a&gt;通知其他处理器更新缓存。&lt;br/&gt;Lock在这里的作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在cmpxchg执行期间，锁住内存地址[edx]，其他处理器不能访问该内存，保证原子性。即使是在32位机器上修改64位的内存也可以保证原子性。&lt;/li&gt;
&lt;li&gt;将本处理器上写缓存全部强制写回主存中去，也就是&lt;a target=&quot;_blank&quot; href=&quot;http://www.cnblogs.com/wewill/p/8098189.html#mesi-memorybarrier&quot;&gt;写屏障&lt;/a&gt;，保证每个线程的本地内存与主存一致。&lt;/li&gt;
&lt;li&gt;禁止cmpxchg与前后任何指令重排序，防止指令重排序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 可见CAS操作具有与读写volatile变量一致的作用，都能保证可见性。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Dec 2017 13:04:00 +0000</pubDate>
<dc:creator>钟绍威</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wewill/p/8111215.html</dc:identifier>
</item>
<item>
<title>js原生的轮播，原理以及实践 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/8109993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/8109993.html</guid>
<description>
&lt;p&gt;轮播，无论是文字轮播还是图片轮播，他们的原理是一样的，都是通过定时器执行循环展示和影藏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、手动轮播&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一系列的大小相等的图片平铺，利用CSS布局只显示一张图片，其余隐藏。通过计算偏移量利用定时器实现自动播放，或通过手动点击事件切换图片。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何利用css实现布局显示一张图片？主要的属性是over-follow:hidden。首先给容器一个固定的长和宽，然后设置over-flow:hidden。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、html结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 首先父容器container存放所有内容，子容器list存在图片。子容器buttons存放按钮小圆点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;left: -600px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;img/5.png&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;img/1.png&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;img/2.png&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;img/3.png&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;img/4.png&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;img/5.png&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;img/1.png&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;buttons&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;on&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;prev&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;arrow&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;amp;lt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;next&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;arrow&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;优化，无缝滚动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你从最后一张图切换回第一张图时，有很大空白，利用两张辅助图来填补这个空白。&lt;/p&gt;
&lt;p&gt;这里补充下无缝滚动，直接看代码，复制最后一张图片放置第一张图片前，同时复制第一张图片放置最后一张图片的后面。并且，将第一张图片辅助图（实际上是实际显示的第5张图片隐藏起来，故设置style=&quot;left: -600px;&quot;）&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;2、css样式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、对盒子模型，文档流的理解，绝对定位问题。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;2、注意list的overflow:hidden;只显示窗口的一张图片，把左右两边的都隐藏起来。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;3、确保buttons中每个span所在层置顶，将其设置为最顶端。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            * &lt;/span&gt;{&lt;span&gt;
                margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
                padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
                text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
            }&lt;span&gt;
            
            body &lt;/span&gt;{&lt;span&gt;
                padding&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;
            }&lt;span&gt;
            
            #container &lt;/span&gt;{&lt;span&gt;
                position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
                width&lt;/span&gt;:&lt;span&gt; 600px&lt;/span&gt;;&lt;span&gt;
                height&lt;/span&gt;:&lt;span&gt; 400px&lt;/span&gt;;&lt;span&gt;
                border&lt;/span&gt;:&lt;span&gt; 3px solid #333&lt;/span&gt;;&lt;span&gt;
                overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
            }&lt;span&gt;
            
            #list &lt;/span&gt;{&lt;span&gt;
                position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
                z-index&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;&lt;span&gt;
                width&lt;/span&gt;:&lt;span&gt; 4200px&lt;/span&gt;;&lt;span&gt;
                height&lt;/span&gt;:&lt;span&gt; 400px&lt;/span&gt;;
            }&lt;span&gt;
            
            #list img &lt;/span&gt;{&lt;span&gt;
                float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
                width&lt;/span&gt;:&lt;span&gt; 600px&lt;/span&gt;;&lt;span&gt;
                height&lt;/span&gt;:&lt;span&gt; 400px&lt;/span&gt;;
            }&lt;span&gt;
            
            #buttons &lt;/span&gt;{&lt;span&gt;
                position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
                left&lt;/span&gt;:&lt;span&gt; 250px&lt;/span&gt;;&lt;span&gt;
                bottom&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;&lt;span&gt;
                z-index&lt;/span&gt;:&lt;span&gt; 2&lt;/span&gt;;&lt;span&gt;
                height&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;&lt;span&gt;
                width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;
            }&lt;span&gt;
            
            #buttons span &lt;/span&gt;{&lt;span&gt;
                float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
                margin-right&lt;/span&gt;:&lt;span&gt; 5px&lt;/span&gt;;&lt;span&gt;
                width&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;&lt;span&gt;
                height&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;&lt;span&gt;
                border&lt;/span&gt;:&lt;span&gt; 1px solid #fff&lt;/span&gt;;&lt;span&gt;
                border-radius&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
                background&lt;/span&gt;:&lt;span&gt; #333&lt;/span&gt;;&lt;span&gt;
                cursor&lt;/span&gt;:&lt;span&gt; pointer&lt;/span&gt;;
            }&lt;span&gt;
            
            #buttons .on &lt;/span&gt;{&lt;span&gt;
                background&lt;/span&gt;:&lt;span&gt; orangered&lt;/span&gt;;
            }&lt;span&gt;
            
            .arrow &lt;/span&gt;{&lt;span&gt;
                position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
                top&lt;/span&gt;:&lt;span&gt; 180px&lt;/span&gt;;&lt;span&gt;
                z-index&lt;/span&gt;:&lt;span&gt; 2&lt;/span&gt;;&lt;span&gt;
                display&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
                width&lt;/span&gt;:&lt;span&gt; 40px&lt;/span&gt;;&lt;span&gt;
                height&lt;/span&gt;:&lt;span&gt; 40px&lt;/span&gt;;&lt;span&gt;
                font-size&lt;/span&gt;:&lt;span&gt; 36px&lt;/span&gt;;&lt;span&gt;
                font-weight&lt;/span&gt;:&lt;span&gt; bold&lt;/span&gt;;&lt;span&gt;
                line-height&lt;/span&gt;:&lt;span&gt; 35px&lt;/span&gt;;&lt;span&gt;
                text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
                color&lt;/span&gt;:&lt;span&gt; #fff&lt;/span&gt;;&lt;span&gt;
                background-color&lt;/span&gt;:&lt;span&gt; RGBA(0, 0, 0, .3)&lt;/span&gt;;&lt;span&gt;
                cursor&lt;/span&gt;:&lt;span&gt; pointer&lt;/span&gt;;
            }&lt;span&gt;
            
            .arrow:hover &lt;/span&gt;{&lt;span&gt;
                background-color&lt;/span&gt;:&lt;span&gt; RGBA(0, 0, 0, .7)&lt;/span&gt;;
            }&lt;span&gt;
            
            #container:hover .arrow &lt;/span&gt;{&lt;span&gt;
                display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;
            }&lt;span&gt;
            
            #prev &lt;/span&gt;{&lt;span&gt;
                left&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;
            }&lt;span&gt;
            
            #next &lt;/span&gt;{&lt;span&gt;
                right&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;
            }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3、JS实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们先实现出手动点击左右两个箭头切换图片的效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list = document.getElementById('list'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prev = document.getElementById('prev'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; next = document.getElementById('next'&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; animate(offset) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取的是style.left，是相对左边获取距离，所以第一张图后style.left都为负值，&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;且style.left获取的是字符串，需要用parseInt()取整转化为数字。&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; newLeft = parseInt(list.style.left) +&lt;span&gt; offset;
            list.style.left &lt;/span&gt;= newLeft + 'px'&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(newLeft&amp;lt;-3000&lt;span&gt;){
                list.style.left &lt;/span&gt;= -600 + 'px'&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(newLeft&amp;gt;-600&lt;span&gt;){
                list.style.left &lt;/span&gt;= -3000 + 'px'&lt;span&gt;;
            }
        }

        prev.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            animate(&lt;/span&gt;600&lt;span&gt;);
        }
        next.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            animate(&lt;/span&gt;-600&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201712/900740-20171225163847431-426944047.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;运行后我们会发现，一直点击右箭头 ，会出现空白，而且，不能回到第一张图片。要点击左箭头才能回到第一张图片。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 原因是我们利用偏移量left来获取图片，当看到left值小于3600时，因为没有第8张图片就出现空白，所以这里我们需要对偏移量做一个判断。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(newLeft&amp;lt;-3000&lt;span&gt;){
                list.style.left &lt;/span&gt;= -600 + 'px'&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(newLeft&amp;gt;-600&lt;span&gt;){
                list.style.left &lt;/span&gt;= -3000 + 'px'&lt;span&gt;;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加了这个判断就是说，在实时的left值在小于-3000的时候，通过操作dom元素直接把left值给到-600，回到初始化的状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是轮播有自动轮播和手动轮播。上面基本实现的是手动点击进行轮播（手动轮播）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、自动轮播&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要实现自动，必须有定时器进行计时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于定时器，有必要说明一下setInterval()跟setTimeout的区别了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单来说，setInterval()执行多次，setTimeout()只执行一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以自动轮播需要我们每隔一段时间执行一次，选择setInterval()函数。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;自动循环播放&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; timer;
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; play(){
            timer &lt;/span&gt;= setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                prev.onclick();
            },&lt;/span&gt;1500&lt;span&gt;)
        }
        play();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201712/900740-20171225170946853-543452867.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;完美实现了自动轮播&lt;/p&gt;
&lt;p&gt;但是，当我们想仔细看某一张图片时候，要把图片停住，我们清楚定时器就可以&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、手动可以干预轮播&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我想仔细看某一张照片时候，要图片停住，需要用到&lt;a title=&quot;window.clearInterval&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/window/clearInterval&quot; target=&quot;_blank&quot;&gt;window.clearInterval&lt;/a&gt; 这个方法。&lt;/p&gt;
&lt;p&gt;这里，我们需要对其DOM操作，需要获取整个轮播图区域，鼠标进入到容器区域就清空计时器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;鼠标放上（离开）对应轮播暂停（播放）&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; container = document.getElementById('container'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; stop() {
           &lt;strong&gt; clearInterval(timer);&lt;/strong&gt;
        }
        container.onmouseover &lt;/span&gt;=&lt;span&gt; stop;
        container.onmouseout &lt;/span&gt;= play;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201712/900740-20171225172112275-855799589.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个鼠标放上轮播暂停的实现就完美实现了。&lt;/p&gt;

&lt;p&gt;现在回顾一下，的确很简单，不是很难，并不是必须要用插件实现，原生的js也可以实现，你可以优化一下封装成自己的轮播插件。&lt;/p&gt;
&lt;p&gt;（1）容器的css布局。&lt;/p&gt;
&lt;p&gt;（2）每一次轮播通过偏移量left实现，手动轮播的按钮绑定每一次偏移量增加还是减少一张照片宽度的偏移量。&lt;/p&gt;
&lt;p&gt;（3）自动轮播，通过setInterval()方法实现定时器，执行下一张的点击函数&lt;/p&gt;
&lt;p&gt;（4）鼠标控制轮播的暂停和继续。通过onmouseover为暂停，onmouseout为继续。&lt;/p&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('db0eba8a-dbe6-475e-9f55-9c292994c273')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_db0eba8a-dbe6-475e-9f55-9c292994c273&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_db0eba8a-dbe6-475e-9f55-9c292994c273&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('db0eba8a-dbe6-475e-9f55-9c292994c273',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_db0eba8a-dbe6-475e-9f55-9c292994c273&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            *&lt;span&gt; {
                margin: &lt;/span&gt;0&lt;span&gt;;
                padding: &lt;/span&gt;0&lt;span&gt;;
                text&lt;/span&gt;-&lt;span&gt;decoration: none;
            }
            
            body {
                padding: 20px;
            }
            
            #container {
                position: relative;
                width: 600px;
                height: 400px;
                border: 3px solid #&lt;/span&gt;333&lt;span&gt;;
                overflow: hidden;
            }
            
            #list {
                position: absolute;
                z&lt;/span&gt;-index: 1&lt;span&gt;;
                width: 4200px;
                height: 400px;
            }
            
            #list img {
                &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;: left;
                width: 600px;
                height: 400px;
            }
            
            #buttons {
                position: absolute;
                left: 250px;
                bottom: 20px;
                z&lt;/span&gt;-index: 2&lt;span&gt;;
                height: 10px;
                width: 100px;
            }
            
            #buttons span {
                &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;: left;
                margin&lt;/span&gt;-&lt;span&gt;right: 5px;
                width: 10px;
                height: 10px;
                border: 1px solid #fff;
                border&lt;/span&gt;-radius: 50%&lt;span&gt;;
                background: #&lt;/span&gt;333&lt;span&gt;;
                cursor: pointer;
            }
            
            #buttons .on {
                background: orangered;
            }
            
            .arrow {
                position: absolute;
                top: 180px;
                z&lt;/span&gt;-index: 2&lt;span&gt;;
                display: none;
                width: 40px;
                height: 40px;
                font&lt;/span&gt;-&lt;span&gt;size: 36px;
                font&lt;/span&gt;-&lt;span&gt;weight: bold;
                line&lt;/span&gt;-&lt;span&gt;height: 35px;
                text&lt;/span&gt;-&lt;span&gt;align: center;
                color: #fff;
                background&lt;/span&gt;-color: RGBA(0, 0, 0, .3&lt;span&gt;);
                cursor: pointer;
            }
            
            .arrow:hover {
                background&lt;/span&gt;-color: RGBA(0, 0, 0, .7&lt;span&gt;);
            }
            
            #container:hover .arrow {
                display: block;
            }
            
            #prev {
                left: 20px;
            }
            
            #next {
                right: 20px;
            }
        &lt;/span&gt;&amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;div id=&quot;container&quot;&amp;gt;
            &amp;lt;div id=&quot;list&quot; style=&quot;left: -600px;&quot;&amp;gt;
                &amp;lt;img src=&quot;img/5.png&quot; alt=&quot;1&quot; /&amp;gt;
                &amp;lt;img src=&quot;img/1.png&quot; alt=&quot;1&quot; /&amp;gt;
                &amp;lt;img src=&quot;img/2.png&quot; alt=&quot;2&quot; /&amp;gt;
                &amp;lt;img src=&quot;img/3.png&quot; alt=&quot;3&quot; /&amp;gt;
                &amp;lt;img src=&quot;img/4.png&quot; alt=&quot;4&quot; /&amp;gt;
                &amp;lt;img src=&quot;img/5.png&quot; alt=&quot;5&quot; /&amp;gt;
                &amp;lt;img src=&quot;img/1.png&quot; alt=&quot;5&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div id=&quot;buttons&quot;&amp;gt;
                &amp;lt;span index=&quot;1&quot; class=&quot;on&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span index=&quot;2&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span index=&quot;3&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span index=&quot;4&quot;&amp;gt;&amp;lt;/span&amp;gt;
                &amp;lt;span index=&quot;5&quot;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;a href=&quot;javascript:;&quot; id=&quot;prev&quot; class=&quot;arrow&quot;&amp;gt;&amp;amp;lt;&amp;lt;/a&amp;gt;
            &amp;lt;a href=&quot;javascript:;&quot; id=&quot;next&quot; class=&quot;arrow&quot;&amp;gt;&amp;amp;gt;&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;

    &amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
    window.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list = document.getElementById('list'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prev = document.getElementById('prev'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; next = document.getElementById('next'&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; animate(offset) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;获取的是style.left，是相对左边获取距离，所以第一张图后style.left都为负值，
            且style.left获取的是字符串，需要用parseInt()取整转化为数字。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; newLeft = parseInt(list.style.left) +&lt;span&gt; offset;
            list.style.left &lt;/span&gt;= newLeft + 'px'&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(newLeft &amp;lt; -3000&lt;span&gt;) {
                list.style.left &lt;/span&gt;= -600 + 'px'&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(newLeft &amp;gt; -600&lt;span&gt;) {
                list.style.left &lt;/span&gt;= -3000 + 'px'&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;上一步&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        prev.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                animate(&lt;/span&gt;600&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;下一步&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        next.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                animate(&lt;/span&gt;-600&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;自动循环播放&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; timer;

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; play() {
            timer &lt;/span&gt;= setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                prev.onclick();
            }, &lt;/span&gt;1500&lt;span&gt;)
        }
        play();
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;鼠标放上（离开）对应轮播暂停（播放）&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; container = document.getElementById('container'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; stop() {
            clearInterval(timer);
        }
        container.onmouseover &lt;/span&gt;=&lt;span&gt; stop;
        container.onmouseout &lt;/span&gt;=&lt;span&gt; play;
    }
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;四、小点也随着图片进行轮播&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先要能拿到有多少个小点的数组，然后每一次的下一步的时候判断一下当前的小圆点的标志位。&lt;/p&gt;
&lt;p&gt;（1）当标志位大于数组的长度时候，需要把标志位赋值为初始值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;上一步&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        prev.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                index &lt;/span&gt;= index -1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(index &amp;lt; 1&lt;span&gt;) {
                    index &lt;/span&gt;= 5&lt;span&gt;;
                }
                buttonShow();
                animate(&lt;/span&gt;600&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;下一步&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        next.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                index &lt;/span&gt;= index + 1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(index &amp;gt; 5&lt;span&gt;) {
                    index &lt;/span&gt;= 1&lt;span&gt;;
                }
                buttonShow();
                animate(&lt;/span&gt;-600&lt;span&gt;);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）每执行一次下一步，标志位temp+1，同时将圆点的上一个样式清除，下一个显示选中样式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; buttonShow() {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;console.log(buttons.length);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;清除之前的样式&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; buttons.length; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(buttons[i].className === 'on'&lt;span&gt;) {
                    buttons[i].className &lt;/span&gt;= ''&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;数组从0开始，temp从-1开始&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            buttons[index &lt;/span&gt;- 1].className = 'on'&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201712/900740-20171225194853556-1969942855.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、小点可以点击到对应的图片上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;突然发现图片下边还有一堆小点，需要给增加点击事件，点击哪一个点，就到哪一张图片上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;小圆点的点击事件&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i =0;i&amp;lt;buttons.length;i++&lt;span&gt;){
            buttons[i].onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (){
                console.log(i);
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;偏移量的获取：获取鼠标的小圆点的位置，用this把index绑定到对象buttons[i]上&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;由于index是自定义属性，需要用到getAttribute()这个dom的2级方法，去获取自定义的index属性&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; clickIndex = parseInt(&lt;span&gt;this&lt;/span&gt;.getAttribute('index'&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; offset = 600*(index-&lt;span&gt;clickIndex);
                animate(offset);
                index &lt;/span&gt;=&lt;span&gt; clickIndex;
                buttonShow();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201712/900740-20171225201337900-64780090.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要大功告成了，但是发现控制台会发现打印出来的永远的是i=5。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;                                       “对javascript来说&lt;/strong&gt;&lt;strong&gt;，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。”&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;就是说，js没有块级作用域这东西，（可能我C写多了，混淆了）。在第一次循环（从 i=0 到 4 这一过程）结束后，最后的 i 获取到的为 &lt;em id=&quot;__mceDel&quot;&gt;buttons.length &lt;/em&gt;的值被&lt;/p&gt;
&lt;p&gt;保存在for循环之外，最后鼠标点击任何一个小圆点时，自然访问的一直是 i=5 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用立即函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;小圆点的点击事件&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; buttons.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;使用立即函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i) {
                buttons[i].onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                    console.log(i);
                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;偏移量的获取：获取鼠标的小圆点的位置，用this把index绑定到对象buttons[i]上&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;由于index是自定义属性，需要用到getAttribute()这个dom的2级方法，去获取自定义的index属性&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; clickIndex = parseInt(&lt;span&gt;this&lt;/span&gt;.getAttribute('index'&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; offset = 600 * (index -&lt;span&gt; clickIndex);
                    animate(offset);
                    index &lt;/span&gt;=&lt;span&gt; clickIndex;
                    buttonShow();
                }
            })(i)
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里涉及到js的闭包问题。&lt;/p&gt;

&lt;p&gt;完美原生js实现轮播，原理以及实践。总结一下：&lt;/p&gt;
&lt;p&gt;原理：（1）使用的是css只显示一张图片，其余隐藏。通过计算偏移量利用定时器实现自动播放，或通过手动点击事件切换图片。&lt;/p&gt;
&lt;p&gt;实践：&lt;a href=&quot;http://www.mwcxs.top/%E8%BD%AE%E6%92%AD/index.html&quot; target=&quot;_blank&quot;&gt;http://www.mwcxs.top/%E8%BD%AE%E6%92%AD/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;欢迎访问：&lt;/p&gt;
&lt;p&gt;1、云商城isv系统&lt;a href=&quot;http://isv.suningcloud.com/mpisv-web/index&quot; target=&quot;_blank&quot;&gt;http://isv.suningcloud.com/mpisv-web/index&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 2、云商城消费者门户&lt;a href=&quot;http://www.suningcloud.com/promotion/index/experience_center.html&quot; target=&quot;_blank&quot;&gt;http://www.suningcloud.com/promotion/index/experience_center.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Dec 2017 13:01:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/8109993.html</dc:identifier>
</item>
<item>
<title>Java基础(四)-异常处理机制及其设计 - 玉树临枫</title>
<link>http://www.cnblogs.com/yuanfy008/p/8110897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanfy008/p/8110897.html</guid>
<description>&lt;p&gt;本篇主要是记录自己所理解的Java异常处理机制（基于jdk1.7）以及怎么去处理和设计异常。还记得当初学习Java异常这块的时候都没怎么注意它的用途，以为就是简单的处理下异常，我避免程序出现这样错误就行了（当初真的很懵懂很天真）。当踏入社会工作后才知道一个好的异常处理框架是有多重要，比方说当你的项目投入使用的时候，当程序出错如何快速的定位到问题的根源（出了什么错，在哪出的错，为什么出错），这就跟你的异常处理的好坏有关了（当然离不开你的日志处理）。在有效使用异常的情况下，异常类型会回答报的什么错，异常堆栈跟踪回答在哪出的错，异常信息会回答为什么出错。所以如果设计和处理的不好，将会花费大量时间去维护（出现这样的情况公司肯定是不愿意的同时也会质疑你的能力了）。&lt;/p&gt;
&lt;p&gt;本篇将从下面几个方面进行记录，如果发现有错误的地方还请各位大佬们指出以便改进，谢谢。&lt;/p&gt;
&lt;h3&gt;一、Java异常结构&lt;/h3&gt;
&lt;p&gt;　　首先你得明白异常是什么，为什么发生异常。通俗的讲，程序异常就是程序出现了错误，而这种错误可能是逻辑上的错误也可能是系统上的错误。在Java中把异常当做对象处理，所以我们要了解在java中有哪些可以类是用来描述异常的，它的层次结构图如下（&lt;em&gt;只描述写重要的类&lt;/em&gt;）：&lt;img src=&quot;https://images2018.cnblogs.com/blog/690169/201712/690169-20171225151714681-71176952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二、异常分类及其常见异常类&lt;/h3&gt;
&lt;p&gt;　　在java中，所有的异常都是通过Throwable类及其子类传播的（从上面层次结构图中可以看出）。根据层次关系我们依次来分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Throwable：在它下面有两个重要的子类：Error和Exception。它们两个都是重要的异常处理类，但两者分别承担的角色或者针对的对象却不一样，请看下面分析。&lt;/li&gt;
&lt;li&gt;Error：是指程序无法处理的错误，也称unchecked exceptions（未经检查的异常：编译器不要求强制处置的异常）。比如：Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。&lt;/li&gt;
&lt;li&gt;Exception：是程序本身可以处理的异常。其中除了&lt;span lang=&quot;zh-CN&quot;&gt;RuntimeException及其子类外的任何Exception子类都称为checked exceptions（受检查的异常：编译器要求必须处置的异常）。自然RuntimeException及其子类就归属于非受检查的异常。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
/**
 * The class {@code Exception} and its subclasses are a form of
 * {@code Throwable} that indicates conditions that a reasonable
 * application might want to catch.
 *
 * &lt;span&gt;&amp;lt;p&amp;gt;The class {@code Exception} and any subclasses that are not also
 * subclasses of {@link RuntimeException} are &amp;lt;em&amp;gt;checked
 * exceptions&amp;lt;/em&amp;gt;&lt;/span&gt;.  Checked exceptions need to be declared in a
 * method or constructor's {@code throws} clause if they can be thrown
 * by the execution of the method or constructor and propagate outside
 * the method or constructor boundary.
 *
 * @author  Frank Yellin
 * @see     java.lang.Error
 * @jls 11.2 Compile-Time Checking of Exceptions
 * @since   JDK1.0
 */
public class Exception extends Throwable {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　根据上面Excepiton类还可以分成这两大类：运行时异常和非运行时异常。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运行时异常：都是RuntimeException泪及其子类。例如常见类：NullPointerException（空指针）、IndexOutOfBoundsException（下标越界异常）、ArithmeticException（算术异常）、ClassNotFoundException（找不到类异常）、IllegalArgumentException （非法参数异常）等。这些异常也属于非受检查异常。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。&lt;/li&gt;
&lt;li&gt;非运行时异常：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。例如常见类：IOException、SQLException、ParseException、FileNotFoundException（文件找不到异常）等。&lt;/li&gt;
&lt;li&gt;综上分类，可以将Throwable划分成这样：&lt;img src=&quot;https://images2018.cnblogs.com/blog/690169/201712/690169-20171225151833853-1488743444.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;三、异常处理机制&lt;/h3&gt;
&lt;p&gt; 　　在java中异常处理机制大致为：先抛出异常再捕捉异常。抛出异常一般是交给java虚拟机，当然也可以自己手动抛出异常（下面会涉及到），重点是怎么捕捉异常。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1、捕获异常（try、catch、finally）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　捕获异常的形式可能是上面三个的组合，组合形式有：try..catch、try...finally和try..catch..finally&lt;/p&gt;
&lt;p&gt;　　主要记录下try..catch..finally的主要事项：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.1、其中catch块可以有多个，但要注意捕获异常类的顺序：子类一定要在父类前，否则会编译不通过。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    public void&lt;span&gt; test1() {
        int[] arr = {1,3,5,0&lt;span&gt;};
        try&lt;span&gt;{
            for (int i = 0; i &amp;lt; arr.length; i ++&lt;span&gt;) {
                System.out.println(10/&lt;span&gt;arr[i]);
            }
        }catch&lt;span&gt; (Exception e){
            e.printStackTrace();
       &lt;span&gt; }catch&lt;/span&gt;&lt;span&gt;&lt;span&gt; (ArithmeticException e){//编译不通过。因为异常在前面的catch块中捕获。&lt;/span&gt;
            e.printStackTrace();
        }finally&lt;span&gt;{
            System.out.println(&quot;end&quot;&lt;span&gt;);
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;1.2  当catch块中有return时要注意其执行顺序：finally语句在return返回之前执行。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; ExceptionTest {
    
    @Test
    public void&lt;span&gt; test1() {
        System.out.println(&quot;计算结果：&quot; +&lt;span&gt; sum());
    }
    
    public int&lt;span&gt; sum() {
        int count = 0&lt;span&gt;;
        int[] arr = {1,3,5,0&lt;span&gt;};
        try&lt;span&gt;{
            for (int i = 0; i &amp;lt; arr.length; i ++&lt;span&gt;) {
                count += 10/&lt;span&gt;arr[i];
            }
        }catch&lt;span&gt; (ArithmeticException e){
            System.out.println(&quot;计算失败,分母不能为0：&quot; +&lt;span&gt; e.getMessage());
            return&lt;span&gt; count;
        }finally&lt;span&gt;{
            &lt;span&gt;System.out.println(&quot;sum() end&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);//会先执行&lt;/span&gt;
        }
        return&lt;span&gt; count;
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ouput:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
计算失败,分母不能为0：/&lt;span&gt; by zero
sum() end
计算结果：15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;1.3  当catch块中有return时要注意fianlly语句对其返回值进行修改时是否影响其返回值：基本类型及其字符串类型是不会被改变的，对象类型下成员变量的值是可以改变的。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
 1 public class&lt;span&gt; ExceptionTest {
 2     
 3 &lt;span&gt;    @Test
 4     public void&lt;span&gt; test1() {
 5         System.out.println(&quot;基本类型mod1()=&quot; +&lt;span&gt; mol1());
 6         System.out.println(&quot;字符串类型mod2()=&quot; +&lt;span&gt; mol2());
 7         System.out.println(&quot;对象类型mod3()=&quot; +&lt;span&gt; mol3());
 8 &lt;span&gt;    }
 9     
10     public int&lt;span&gt; mol1() {
11         int count = 0&lt;span&gt;;
12         int[] arr = {1,3,5,0&lt;span&gt;};
13         try&lt;span&gt;{
14             for (int i = 0; i &amp;lt; arr.length; i ++&lt;span&gt;) {
15                 arr[i] = 10/&lt;span&gt;arr[i];
16 &lt;span&gt;            }
17         }catch&lt;span&gt; (ArithmeticException e){
18             return&lt;span&gt; count;
19         }finally&lt;span&gt;{
20             //基本类型修改无效，其实这相当于一个局部变量
21             count = -1&lt;span&gt;;
22 &lt;span&gt;        }
23         return&lt;span&gt; count;
24 &lt;span&gt;    }
25     
26     public&lt;span&gt; String mol2() {
27         String msg = &quot;success&quot;&lt;span&gt;;
28         int[] arr = {1,3,5,0&lt;span&gt;};
29         try&lt;span&gt;{
30             for (int i = 0; i &amp;lt; arr.length; i ++&lt;span&gt;) {
31                 arr[i] = 10/&lt;span&gt;arr[i];
32 &lt;span&gt;            }
33         }catch&lt;span&gt; (ArithmeticException e){
34             msg = &quot;fail&quot;&lt;span&gt;;
35             return&lt;span&gt; msg;
36         }finally&lt;span&gt;{
37             //字符串修改无效，其实这相当于一个局部变量
38             msg = &quot;fail, finally&quot;&lt;span&gt;;
39 &lt;span&gt;        }
40         return&lt;span&gt; msg;
41 &lt;span&gt;    }
42     public&lt;span&gt; StringBuffer mol3() {
43         StringBuffer msg = new&lt;span&gt; StringBuffer();
44         int[] arr = {1,3,5,0&lt;span&gt;};
45         try&lt;span&gt;{
46             for (int i = 0; i &amp;lt; arr.length; i ++&lt;span&gt;) {
47                 arr[i] = 10/&lt;span&gt;arr[i];
48 &lt;span&gt;            }
49         }catch&lt;span&gt; (ArithmeticException e){
50             msg.append(&quot;fail&quot;&lt;span&gt;);
51             return&lt;span&gt; msg;
52         }finally&lt;span&gt;{
53             //对象类型，其成员变量char[] value;的值是可以被改变的
54             msg.append(&quot;, finally&quot;&lt;span&gt;);
55 &lt;span&gt;        }
56         return&lt;span&gt; msg;
57 &lt;span&gt;    }
58     
59 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　output:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
基本类型mod1()=0&lt;span&gt;
字符串类型mod2()=&lt;span&gt;fail
对象类型mod3()=fail, finally&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;1.4  当finally语句中有返回值时，会覆盖catch中的返回语句，也会使catch块的throw 抛出的异常失效。（其实不建议使用的）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionTest {
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1() {
        System.out.println(&lt;/span&gt;&quot;基本类型mod1()=&quot; +&lt;span&gt; mol4());
        System.out.println(&lt;/span&gt;&quot;字符串类型mod2()=&quot; +&lt;span&gt; mol5());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mol4() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr = {1,3,5,0&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arr.length; i ++&lt;span&gt;) {
                arr[i] &lt;/span&gt;= 10/&lt;span&gt;arr[i];
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ArithmeticException e){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
            count &lt;/span&gt;= -1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; count;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接返回值，不会在进入catch块中执行&lt;/span&gt;
&lt;span&gt;        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String mol5() {
        String msg &lt;/span&gt;= &quot;success&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr = {1,3,5,0&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arr.length; i ++&lt;span&gt;) {
                arr[i] &lt;/span&gt;= 10/&lt;span&gt;arr[i];
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ArithmeticException e){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArithmeticException(&quot;分母不能为0&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串修改无效，其实这相当于一个局部变量&lt;/span&gt;
            msg = &quot;fail, finally&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; msg;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接返回值，不会在进入catch块抛出异常&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return msg;&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　output:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
基本类型mod1()=-1&lt;span&gt;
字符串类型mod2()&lt;/span&gt;=fail, &lt;span&gt;finally&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　2、抛出异常，有两种方式：使用throws指定异常，在方法上使用；可以使用throw new 的方法，在方法里使用。不要搞混淆就行。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;四、有关设计和处理异常的几个建议（参考Effective Java）&lt;/h3&gt;
&lt;p&gt;　　1、只针对异常的情况才使用异常，不要用异常去控制正常流程。（这点我想大部分人不会这么做，但是也列举出来，如果这么做了会引起莫名奇妙的问题）&lt;/p&gt;
&lt;p&gt;　　2、避免不必要的使用受检异常。&lt;/p&gt;
&lt;p&gt;　　3、优先使用标准异常，即错误信息相对应的异常，不要乱抛出异常类否则会找不到问题的根源。比方说有个地方是数组索引超限，你却抛出个参数非法异常，这样就掩盖了原始异常信息。&lt;/p&gt;
&lt;p&gt;　　4、不要忽略异常，即不要使用空catch块。（没有异常信息，就无法找出问题的所在）&lt;/p&gt;
&lt;p&gt;　　5、尽量捕获写细节信息。比方说数组索引越界，它是超过最大索引还是小于0？&lt;/p&gt;
</description>
<pubDate>Mon, 25 Dec 2017 12:16:00 +0000</pubDate>
<dc:creator>玉树临枫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanfy008/p/8110897.html</dc:identifier>
</item>
<item>
<title>代码迁移之旅（二）- 渐进式迁移方案 - 枕边书</title>
<link>http://www.cnblogs.com/zhenbianshu/p/8110912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenbianshu/p/8110912.html</guid>
<description>&lt;p&gt;这是代码迁移的第二篇文章，也是最后一篇了，由于个人原因，原来的迁移我无法继续参与了，但完整的方案我已经准备好了，在测试环境也已经可以正常进行了。 上篇文章 &lt;a href=&quot;http://www.cnblogs.com/zhenbianshu/p/7773930.html&quot;&gt;代码重构之旅（一） 项目结构&lt;/a&gt; 介绍了迁移代码的前期准备和项目结构的设计，本篇文章来介绍一下可实施的迁移方案。&lt;/p&gt;
&lt;p&gt;使代码的迁移过程更简单、更安全是我们要追求的目标，在迁移之前，代码的可用性我们一定也只能画一个问号。&lt;/p&gt;
&lt;p&gt;文章欢迎转载，但请注明来源：http://www.cnblogs.com/zhenbianshu/p/8110912.html， 谢谢。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;首先要看一下一次完整的迁移需要满足什么要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;灰度发布，谁也无法保证一次将整个系统迁移到另一个系统不会发生问题，而以接口或接口部分流量为单位进行迁移则可以大大提升可控性。&lt;/li&gt;
&lt;li&gt;客户端无感知，即迁移平滑，长时间的系统不可用是完全无法接受的。&lt;/li&gt;
&lt;li&gt;可回滚，一旦出现异常问题可以快速回滚，避免造成较大影响。&lt;/li&gt;
&lt;li&gt;易实现，尽量避免大量地操作，操作多意味着犯错的可能性更大，回滚的难度也大。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有实现了以上要求，才算是一次成功的迁移。那么先分析一下目前的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819496/201712/819496-20171225195252853-362048442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图是我们两个系统的目前状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;两个系统共享一个 Nginx 服务器，而且在 Nginx 中，由于新老系统的 &lt;code&gt;Host::Ip&lt;/code&gt; 也不需要变动，所以新老系统还共享一个同一个 Server。&lt;/li&gt;
&lt;li&gt;新旧两个模块分别对应着两个版本控制目录，旧模块将 Http 请求进行 url 重写后直接分发到各 PHP 脚本，例如：&lt;code&gt;rewrite ^/api/common/test.json?(.*)$ /api_test.php?$1;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新模块将 Http 请求直接分发到 index.php 后，由 index.php 进行内部路由转发。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两个模块初始状态相安无事，现在的问题是如何将旧模块的接口逐渐过渡到新模块中。由于旧模块的分发入口在 Nginx 中，最简单的办法自然是修改其原来的重定向规则。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;先看一个典型的 Nginx Http 服务器配置：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-nginx&quot;&gt;http {
    upstream stream_name{
    }
    
    server {
        listen port;
        server_name domain_name host_name;
        
        rewrite ori destA;

        location pathA {
            rewrite ori destB type;
        }
        
        location pathB {
            if(match){
                rewrite ori destC type;
            }
                rewrite ori destD type; 
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们要使用的就是 Nginx 强大的路由重定向功能。&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;location&lt;/h3&gt;
&lt;p&gt;location 是一个 URI 捕获语句，它被定义在 server 模块内，会对 server 内的所有请求进行 uri 匹配，一旦匹配，则进入 location 模块内部执行。&lt;/p&gt;
&lt;p&gt;location 常见的使用形式是：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-nginx&quot;&gt;location path_pattern {
    operation;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的 &lt;code&gt;path_pattern&lt;/code&gt; 有以下几种形式，优先级从高到低为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;完全相等匹配 &lt;code&gt;location = uri {}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;前缀匹配 &lt;code&gt;location prefix {}&lt;/code&gt; 或 &lt;code&gt;location ^prefix ~ {}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正则匹配 &lt;code&gt;location ~ regex {}&lt;/code&gt; 或不区分大小写正则匹配 &lt;code&gt;location *~ regex {}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通用匹配 &lt;code&gt;location / {}&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不同的 pattern 类型匹配顺序与定义顺序无关，而是由优先级从高到低进行匹配，同一类型的，优先使用 pattern 串更长的进行匹配，因为长串会更精确。&lt;/p&gt;
&lt;p&gt;它的 operation 一般是 rewrite 或 proxy_pass 语句，对捕获到的请求进行重写或转发。用于转发的 proxy_pass 语句很简单， &lt;code&gt;proxy_pass proxy_name;&lt;/code&gt; 即可，下面具体说一下路由重写功能。&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;if&lt;/h3&gt;
&lt;p&gt;if 语句可以对 uri 进行更加灵活的判断和操作，它的常见使用形式是：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-nginx&quot;&gt;if (match) {
    rewrite ori destA type;
}
    rewrite ori destB type;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;code&gt;match&lt;/code&gt; 语句中，可以使用如 &lt;code&gt;$request_uri&lt;/code&gt; 等全局变量，常见的还有 &lt;code&gt;$query_string,$uri,$remote_addr&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;但是需要注意使用 if 语句是十分低效的行为，它就像普通的代码一样，每个 Http 请求碰到 if 语句都会进行一次 &lt;code&gt;match&lt;/code&gt; 计算并判断，虽然写在 location 内部会好一些，但最好还是极力避免此语句。&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;rewrite&lt;/h3&gt;
&lt;p&gt;rewrite 是对匹配到的请求进行 uri 重写，它可以被写在 &lt;code&gt;server/location/if&lt;/code&gt; 模块中，使用方式 是 &lt;code&gt;rewrite ori dest type;&lt;/code&gt;。在 server 模块中，rewrite 和 location 的执行顺序为：&lt;code&gt;server中的rewrite -&amp;gt; location -&amp;gt; location中的rewrite&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用正则或全相等来匹配 &lt;code&gt;ori&lt;/code&gt;，并将正则结果应用于 &lt;code&gt;dest&lt;/code&gt; 上，如 &lt;code&gt;rewrite ^/api/common/test.json?(.*)$ /api_test.php?$1;&lt;/code&gt; 则将 ori 内部的 query_string 匹配出来并使用 &lt;code&gt;$1&lt;/code&gt; 赋值给 dest。&lt;/p&gt;
&lt;p&gt;rewrite 默认将 uri 重写后并不直接将请求分发到 CGI，而是将结果 uri 作为一个新的请求再次进行 server 模块内处理，如果循环重入超 10 次 nginx 会直接返回 &lt;code&gt;500 internal server error&lt;/code&gt;，而控制 rewrite 匹配后的行为 主要依靠其 type 参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;last 结束此模块(server/location) 匹配，并重入 server 模块处理，rewrite 默认使用此项;&lt;/li&gt;
&lt;li&gt;break 结束所有模块匹配，直接将请求分发到 CGI；&lt;/li&gt;
&lt;li&gt;redirect 直接分发请求，返回 Http 状态码 302 临时重定向；&lt;/li&gt;
&lt;li&gt;permanment 直接分发请求，返回 Http 状态码 301 永久重定向；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;toc_6&quot;&gt;应用&lt;/h3&gt;
&lt;p&gt;介绍完了 Nginx 的重定向功能，还需要考虑怎么使用此功能进行代码的过渡。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用 location 捕获对应接口；&lt;/li&gt;
&lt;li&gt;使用 if 进行部分流量分发（可选）；&lt;/li&gt;
&lt;li&gt;将请求 rewrite 到新模块。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如：&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-nginx&quot;&gt;location ~ /api/test.json {  # 匹配到 test 接口
    if ($remote_addr ~* 1$) {  # 分流 IP 末位为 1 的请求
        root new_dir/public; # 设置新项目的目录为根目录
        rewrite ^(.*)$ /index.php$1 break; # 将请求分发到新项目的 index.php 入口文件
    }
    rewrite ^/api/test.json?(.*)$ /api_test.php?$1; # IP 末位不为 1 的请求继续访问旧项目
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;p&gt;如上，我们发现如果针对每个接口进行一次 location 重定向，都需要写 7 行代码，即使不用 if 语句（多数情况如此），每次也需要 4 行代码。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-nginx&quot;&gt;location ~ /api/test.json {  # 匹配到 test 接口
    root new_dir/public; # 设置新项目的目录为根目录
    rewrite ^(.*)$ /index.php$1 break; # 将请求分发到新项目的 index.php 入口文件
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如此下来，项目如果有 100 个接口，那么维护这100个 location 模块也颇为废劲。其实更多时刻，我们并不需要使用 location 语句，直接在 server 模块内部使用 rewrite 即可，而阻止我们直接使用 rewrite 的，就是由于新旧模块不在同一文件夹下，我们必须使用 root 语句将根目录定义到新项目下。至于为什么不将新旧项目的父文件夹定义为 root，是因为旧项目中有一些路径可能会有深坑。&lt;/p&gt;
&lt;p&gt;这里我们可以使用 linux 的 &lt;code&gt;软链接&lt;/code&gt; 来 把新项目“放置”在旧项目下：linux 中软链接的功能就像 windows 中的&lt;code&gt;快捷方式&lt;/code&gt;一样，是一个指向文件或真实目录的符号。至于其实现，就要说到 linux 文件结构中的重要概念 &lt;code&gt;inode&lt;/code&gt; 了，不过这里不再多提。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ln -s /path/to/dir_new /path/to/dir_old/yaf&lt;/code&gt; 在旧项目目录下创建一个 &lt;code&gt;yaf&lt;/code&gt; 软链接指向新项目目录；&lt;/p&gt;
&lt;p&gt;这样，就可以以旧项目目录为根目录，找到新项目目录下的文件了，使用单行命令 &lt;code&gt;rewrite ^(/api/test.json(.*)$) /yaf/public/index.php$1 break;&lt;/code&gt; 即可。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;通过上面 Nginx 的重定向，所有的请求都会被分发到 index.php 中， 接下来就需要在 yaf 内对 index.php 接收到的 Http 请求进行内部分发。&lt;/p&gt;
&lt;p&gt;yaf 提供了 &lt;code&gt;Yaf_Route_Static、Yaf_Route_Simple、Yaf_Route_Supervar、Yaf_Route_Map、Yaf_Route_Rewrite、Yaf_Route_Regex&lt;/code&gt; 六种路由方式，各有其适合的场景，需要在 &lt;code&gt;/conf/application.ini&lt;/code&gt; 中配置 &lt;code&gt;application.dispatcher.defaultRoute.type=&quot;type&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们的内部接口名完全不规则，有改写为 &lt;code&gt;.json&lt;/code&gt; 后缀的，也有保持 &lt;code&gt;.php&lt;/code&gt; 的，有带下划线的，也有大小写敏感的，找不到什么规律，于是使用了 &lt;code&gt;map&lt;/code&gt; 类型，直接匹配 &lt;code&gt;uri&lt;/code&gt; 然后映射向 controller 类。&lt;/p&gt;
&lt;p&gt;我们将 uri 和controller的映射统一保存在一个文件内，形如：&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-php&quot;&gt;return array(
    // 接口作用
    'key' =&amp;gt;  
        array(
            'type' =&amp;gt; 'rewrite',  
            'match' =&amp;gt; '/api/test.json', 
            'route' =&amp;gt; 
                array(
                    'controller' =&amp;gt; 'Api_Test'
                ),
        ),
        ...
    );&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在 &lt;code&gt;Bootstrap.php&lt;/code&gt; 内加载此配置文件：&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-php&quot;&gt;    public function _initRouter() {
        $router = \Yaf\Dispatcher::getInstance()-&amp;gt;getRouter();
        $config = getConfig('rewrite_file_name');
        $router-&amp;gt;addConfig($config);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自此，关于迁移的配置就完成了。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;一次安全的迁移，完整的测试当然必不可少。在保证技术方案没问题的前提下，还要进行完整的业务逻辑测试。在 QA 测试之前，开发首先要通过尽可能完整的测试，将 BUG 率降到最低。&lt;/p&gt;
&lt;p&gt;我们的系统对外提供服务都是通过接口，这也方便了我们进行测试。为了保证测试的完整性，可以将线上流量引入到新代码中进行测试，而实行请求导流的最好媒介就是日志。&lt;/p&gt;
&lt;p&gt;一般来说，服务器都有完整的线上请求日志，如果有必要，在给特定接口添加特定日志以配合测试也是可以的。接入线上日志，构造跟线上一样的请求到测试服务器，再对比原始服务器的响应内容，将异常响应记录下来由开发分析并查找原因，直到最后新旧项目对所有请求的响应完全一致。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;项目的重构不是一个小事，特别是大规模的项目代码迁移，执行它必须胆大心细，但每一次重构，无论是对自己的技术能力还是项目的生命周期都是很大的提升。&lt;/p&gt;
&lt;p&gt;虽然不鼓励没事就瞎折腾代码，但一定要时刻警惕，走出代码的舒适区，一定要提前预防根治代码疾病，不要在代码已经无可救药时才想到重构。&lt;/p&gt;
&lt;p&gt;技术发展迅速，代码总有过时的一天，所以经常对代码有目的有计划的小幅优化是非常有意义的。&lt;/p&gt;
&lt;p&gt;关于本文有什么问题可以在下面留言交流，如果您觉得本文对您有帮助，可以点击下面的 &lt;strong&gt;&lt;code&gt;推荐&lt;/code&gt;&lt;/strong&gt; 支持一下我，博客一直在更新，欢迎 &lt;strong&gt;&lt;code&gt;关注&lt;/code&gt;&lt;/strong&gt; 。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Dec 2017 12:05:00 +0000</pubDate>
<dc:creator>枕边书</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenbianshu/p/8110912.html</dc:identifier>
</item>
</channel>
</rss>