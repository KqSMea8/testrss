<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>金融数据分析与挖掘具体实现方法 -1 - 汪凡</title>
<link>http://www.cnblogs.com/wf-skylark/p/9551967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wf-skylark/p/9551967.html</guid>
<description>&lt;h3&gt;有人让我写一下关于数据挖掘在金融方面的应用，再加上现在金融对数据方面的要求不断提高，准备用两篇随笔来做个入门总结。&lt;/h3&gt;
&lt;h3&gt;首先，在看这篇随笔以前稍微补充一点金融方面的知识，因为我不是金融专业的，以下补充知识来自互联网与个人整理，欢迎批评指正并补充说明。&lt;/h3&gt;
&lt;h2&gt;1 先来了解一下什么是金融市场呢？&lt;/h2&gt;
&lt;p&gt;通常狭义的金融市场特指有价证券（股票、债券）发行和流通的场所。&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;股票、债券是用来资本流通的金融产品，广义上的金融市场还包含货币市场，其中代表性的是期货市场等。&lt;/p&gt;
&lt;p&gt;其实不管是资本市场，还是货币市场，都是可以提供给投资者投资的地方，其中货币市场以期货为代表的适合短期投资，而以股票代表的证券市场适合长期投资！&lt;/p&gt;
&lt;p&gt;常见机构：银行、投资银行（证券公司）、保险公司、基金等&lt;/p&gt;
&lt;p&gt;有价证券：是虚拟资本的一种形式，它本身没价值，但有价格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-狭义的金融市场划分&quot;&gt;2 狭义的金融市场划分&lt;/h2&gt;
&lt;h3 id=&quot;21-按交易程序划分&quot;&gt;2.1 按交易程序划分&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发行市场：又称为处理新发行证券的金融市场，筹集资金的公司、政府或公共部门通过发行新的股票和债券来进行融资。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;流通市场：又称二级市场，是指已经发行的证券进行转让、交易的市场。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们通过一张图来理解一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829013222440-1252649901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于投资的几个类别，一般我们将天使、VC、PE三个部分统称为私募(Private Equity)，指的是没有在证券交易所公开上市交易的资产。&lt;/p&gt;
&lt;p&gt;1、公司规模&lt;/p&gt;
&lt;p&gt;天使投资主要投资早期创业公司；&lt;/p&gt;
&lt;p&gt;VC投资中期高速发展型创业公司；&lt;/p&gt;
&lt;p&gt;PE介入即将上市或被兼并收购的成熟企业。&lt;/p&gt;
&lt;p&gt;2、资金规模&lt;/p&gt;
&lt;p&gt;天使投资：500万以下 VC投资：千万 PE：千万级别以上&lt;/p&gt;
&lt;h3 id=&quot;22-参与主体&quot;&gt;2.2 参与主体&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;证券交易所
&lt;ul&gt;&lt;li&gt;买卖股票、公司债等有价证券的市场&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829013456739-1108012299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;证券公司：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以承销发行、自营买卖或自营兼代理买卖证券&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829013532621-1218698233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-关于金融产品的区别&quot;&gt;2.3 关于金融产品的区别&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829014227890-2052088086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：政府、公司等发行股票、债券目的为了进行融资、发展等&lt;/p&gt;
&lt;h2 id=&quot;521-什么是股票&quot;&gt;3 什么是股票?&lt;/h2&gt;
&lt;p&gt;股票，是股份公司签发的证明股东所持股份的凭证，代表了股东对股份公司净资产的所有权。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特点：每股股票都代表股东对企业拥有单位的所有权，所拥有的份额取决于持有的股票数量总占比。本身没有价格，代表一种价值&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;522-股票按照股东权利的分类&quot;&gt;3.1 股票按照股东权利的分类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;按股东权利分类，股票可分为普通股、优先股等&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;33&quot;&gt;
&lt;h3&gt;普通股&lt;/h3&gt;
&lt;p&gt;普通股是指在公司的经营管理和盈利及财产的分配上享有普通权利的股份，代表满足所有债权偿付要求及优先股东的收益权与求偿权要求后对企业盈利和剩余财产的索取权。普通股构成公司资本的基础，是股票的一种基本形式。现上海和深圳证券交易所上进行交易的股票都是普通股。&lt;/p&gt;
&lt;p&gt;普通股股东&lt;/p&gt;
&lt;p&gt;（1）公司决策参与权。普通股股东有权参与股东大会，并有建议权、表决权和选举权，也可以委托他人代表其行使其股东权利。&lt;/p&gt;
&lt;p&gt;（2）利润分配权。普通股股东有权从公司利润分配中得到股息。普通股的股息是不固定的，由公司赢利状况及其分配政策决定。普通股股东必须在优先股股东取得固定股息之后才有权享受股息分配权。&lt;/p&gt;
&lt;p&gt;（3）优先认股权。如果公司需要扩张而增发普通股股票时，现有普通股股东有权按其持股比例，以低于市价的某一特定价格优先购买一定数量的新发行股票，从而保持其对企业所有权的原有比例。&lt;/p&gt;
&lt;p&gt;（4）剩余资产分配权。当公司破产或清算时，若公司的资产在偿还欠债后还有剩余，其剩余部分按先优先股股东、后普通股股东的顺序进行分配。&lt;/p&gt;
&lt;h3 id=&quot;优先股&quot;&gt;优先股&lt;/h3&gt;
&lt;p&gt;优先股相对于普通股。优先股在利润分红及剩余财产分配的权利方面优先于普通股。&lt;/p&gt;
&lt;p&gt;（1）优先分配权。在公司分配利润时，拥有优先股票的股东比持有普通股票的股东，分配在先，但是享受固定金额的股利，即优先股的股利是相对固定的。&lt;/p&gt;
&lt;p&gt;（2）优先求偿权。若公司清算，分配剩余财产时，优先股在普通股之前分配。注：当公司决定连续几年不分配股利时，优先股股东可以进入股东大会来表达他们的意见，保护他们自己的权利。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;523-股票按照上市地区的分类&quot;&gt;3.2 股票按照上市地区的分类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;根据上市地区可以分为，我国上市公司的股票有A股(在上海和深圳上市)、B股(上海和深圳上市，其中上海B股以美元结算，深圳B股以港元结算)，H股(香港交易所上市，在大陆运作的公司)。并且还有一些N股和S股等的划分。这一区分主要依据股票的上市地点和所面对的投资者而定&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;524-股票按照股票业绩的分类&quot;&gt;3.3 股票按照股票业绩的分类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;根据业绩也分为：ST股、垃圾股、蓝筹股 等
&lt;ul&gt;&lt;li&gt;蓝筹股：股票市场上，那些在其所属行业内占有重要支配性地位、业绩优良，成交活跃、红利优厚的大公司。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在进行股票投资的时候，我们会使用价值投资方式。选择公司前景好、业绩好的一些公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;知道了股票的基本分类，接下来我们去看看股票具体的一些机制。&quot;&gt;知道了股票的基本分类，接下来我们去看看股票具体的一些机制。&lt;/h4&gt;
&lt;h3 id=&quot;525-人民币普通股票&quot;&gt;3.4 人民币普通股票&lt;/h3&gt;
&lt;h3 id=&quot;1-a股&quot;&gt;A股&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;A股即人民币普通股票。它是由我国境内的公司发行，供境内机构、组织或个人(不含港、澳、台投资者)以人民币认购和交易的普通股股票。
&lt;ul&gt;&lt;li&gt;特点： A股不是实物股票，以无纸化电子记帐，实行T+1交易制度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;T+1制度&lt;/p&gt;
&lt;p&gt;自1995年1月1日起，为了保证股票市场的稳定，防止过度投机，股市实行“T+1”交易制度，当日买进的股票，要到下一个交易日才能卖出。同时，对资金仍然实行“T+0”，即当日回笼的资金马上可以使用。&lt;/p&gt;
&lt;p&gt;T+1是一种股票交易制度，即当日买进的股票，要到下一个交易日才能卖出。&lt;/p&gt;
&lt;p&gt;“T+1&quot;中&quot;T&quot;指的是交易登记日，&quot;T+1&quot;指的是交易登记日的第二天。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;526-股票的代码、开户、价格形成&quot;&gt;3.5 股票的代码、开户、价格形成&lt;/h3&gt;
&lt;p&gt;我们可以看到这样的符号：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829014751668-257439536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-股票代码&quot;&gt;3.5.1 股票代码&lt;/h3&gt;
&lt;p&gt;股票代码用数字表示股票的不同含义。股票代码除了区分各种股票，也有其潜在的意义，比如600*是上交所上市的股票代码，6006是最早上市的股票，一个公司的股票代码跟车牌号差不多，能够显示出这个公司的实力以及知名度&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;1、沪市A股票买卖的代码是以600、601或603打头(在上海证券交易所上市的全是主板)&lt;/p&gt;
&lt;p&gt;2、深市A股票买卖的代码是以000打头，其中中小板代码以002打头，创业板股票代码以300打头&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题：那么经常说的股票价格是什么？怎么形成的？&quot;&gt;问题：那么经常说的股票价格是什么？怎么形成的？&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829014858201-210384226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-股票价格&quot;&gt;3.5.2 股票价格&lt;/h3&gt;
&lt;p&gt;股票价格（Stock Price）又叫股票行市，是指股票在证券市场上买卖的价格。股票在流通市场上的价格，才是完全意义上的股票的市场价格&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;股票初始发行价格=市盈率还原值×40%+股息还原率×20%+每股净值×20%+预计当年股息与一年期存款利率还原值×20%，影响股票价格的因素有很多，如企业因素、盈利情况、净资产、市场、行业等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;3-股票的交易时间和过程&quot;&gt;3.5.3 股票的交易时间和过程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;股票交易时间
&lt;ul&gt;&lt;li&gt;休息日：周六、周日和上证所公告的休市日不交易。（一般为五一、十一国庆节、春节、元旦、清明节、端午节、中秋节等国家法定节假日）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;股票交易过程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（一）、集合竞价阶段：9：15 — 9：25&lt;/p&gt;
&lt;p&gt;1、9：15 — 9：19可以申报和撤单；9：20 — 9：25 可以申报，不可以撤单。&lt;/p&gt;
&lt;p&gt;2、深圳交易所14：57 — 15：00实行集合竞价，可以申报，不可以撤单。&lt;/p&gt;
&lt;p&gt;（二）、连续竞价阶段&lt;/p&gt;
&lt;p&gt;1、上海交易所：9：30 — 11：30；13：00 — 15：00&lt;/p&gt;
&lt;p&gt;2、深圳交易所：9：30 — 11：30；13：00 — 14：56：59&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829015014260-620089044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（三）成交原则&lt;/p&gt;
&lt;p&gt;价格优先，时间优先&lt;/p&gt;
&lt;h3 id=&quot;4-交易费用&quot;&gt;3.5.4 交易费用&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code&gt;1、印花税：1‰(卖的时候才收取，此为国家税收，全国统一)。
2、过户费：深圳交易所无此项费用，上海交易所收费标准(按成交金额的0.02‰人民币 [2]  )。
3、交易佣金：最高收费为3‰，最低收费5元。各家劵商收费不一，开户前可咨询清楚。


例子：
假设你买入10000股，每股票价格为10元，以此为例，对其买入成本计算：
买入股票所用金额：10元/股×10000股=100000元;
过户费：0.02‰×100000=2元(沪市股票计算，深市为0);
交易佣金：100000×3‰=300元(按最高标准计算，正常情况下都小于这个值);
买入总成本：100000元+300元+2元=100302元(买入10000股，每股10元，所需总资金)
多少每股卖出才不赔钱?
可按如下公式计算：（买入总成本+卖出过户费）÷(1-印花税率-交易佣金率)÷股票数量=（100310元+10元）÷(1-0.001-0.003)÷10000=10.07228916元
=10.07元(四舍五入)。
若以10.08每股卖出价格计算：
股票金额：10.08元/股×10000股=100800元;
印花税：100800元×1‰=100.8元;
过户费：0.002%×100800元≈2元;
交易佣金：100800元×3‰=302.4元;
卖出后收入：100800元-100.8元-2元-302.4元=100394.8元;
最终实际盈利为：卖出后收入-买入总成本=100394.8-100302=92.8元;&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;527-股票的层次划分&quot;&gt;3.6 股票的层次划分&lt;/h3&gt;
&lt;p&gt;即使在国内对于A股来说，目前总共有3000多只股票。并且数字可能随着时间会不断改变，如何更好的管理这些上市公司？实现怎样的制度去区分公司的规模大小？&lt;/p&gt;
&lt;h3 id=&quot;1-中国股票市场的层次划分&quot;&gt;3.6.1 中国股票市场的层次划分&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;主板：市场占有率高、规模较大、基础较好、高收益、低风险的大型优秀企业。&lt;/li&gt;
&lt;li&gt;中小板：主要服务于即将或已进入成熟期、盈利能力强、但规模较主板小的中小企业。&lt;/li&gt;
&lt;li&gt;创业板：是以自主创新企业及其他成长型创业企业为服务对象，主要为“两高”、“六新”企业，即高科技、高成长性、新经济、新服务、新农业、新能源、新材料、新商业模式企业。&lt;/li&gt;
&lt;li&gt;新三板：主要为创新型、创业型、成长型中小微企业发展服务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在选择购买股票的时候，有时候会根据划分依据去选择特定指数、行业、板块下的股票！！！&lt;/p&gt;
&lt;h3 id=&quot;2-股票的不同性质划分&quot;&gt;3.6.2 股票的不同性质划分&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829015506834-1823200208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;code&gt;概念股概念股是与业绩股相对而言的。业绩股需要有良好的业绩支撑。概念股则是依靠某一种题材比如资产重组概念，三通概念等支撑价格。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829015637377-1349047152.png&quot; alt=&quot;&quot;/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;行业：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829015702455-142194396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;指数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829015720903-1890833482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;53-股票数据&quot;&gt;4 股票数据&lt;/h2&gt;
&lt;h3 id=&quot;531-交易数据&quot;&gt;4.1 交易数据&lt;/h3&gt;
&lt;p&gt;股票在流通市场上的价格，才是完全意义上的股票的市场价格，一般称为股票市价或股票行市。股票市价表现为开盘价、收盘价、最高价、最低价等形式。其中收盘价最重要，是分析股市行情时采用的基本数据。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829015916636-1881483454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;533-股票k线图&quot;&gt;4.2 股票K线图&lt;/h3&gt;
&lt;p&gt;K线图这种图表源处于日本德川幕府时代，被当时日本米市的商人用来记录米市的行情与价格波动，后因其细腻独到的标画方式而被引入到股市及期货市场。&lt;/p&gt;
&lt;h3 id=&quot;1-k线图基本形态&quot;&gt;4.2.1 K线图基本形态&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829020013733-1296925383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-k线图的计算周期&quot;&gt;4.2.2 K线图的计算周期&lt;/h3&gt;
&lt;h3 id=&quot;不同的时间间隔看待股票数据变化，会有不一样的发现！&quot;&gt;不同的时间间隔看待股票数据变化，会有不一样的发现！&lt;/h3&gt;
&lt;p&gt;K线的计算周期可将其分为日K线，周K线，月K线，年K线&lt;/p&gt;
&lt;p&gt;很多网站提供了日线、周K线、月K线等周期数据，但是最原始的只有日K线的数据。我们需要自己去生成计算不同频率的数据&lt;/p&gt;
&lt;h3 id=&quot;534-案例：股票k线数据重采样&quot;&gt;4.3 案例：股票K线数据重采样&lt;/h3&gt;
&lt;h3&gt;股票方面的基础知识差不多了，接下来我们做个将日k线图转换成周k线图的案例吧！&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;DataFrame.resample(rule, how=None, axis=0, fill_method=None, closed=None,kind=None,)
&lt;ul&gt;&lt;li&gt;频率转换和时间序列重采样，对象必须具有类似日期时间的索引（DatetimeIndex，PeriodIndex或TimedeltaIndex）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829020442522-1323818237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日K周K对比：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829020521284-577286054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;那么日线、周线、月线等怎么切换标准？？&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;周K线是指以周一的开盘价，周五的收盘价，全周最高价和全周最低价来画的K线图&lt;/p&gt;
&lt;p&gt;大部分周线的指标是这个日线指标在这一周最后一个交易日的值。比如周线的’close’应该等于这一周最后一天日线数据的‘close’,但是有的指标是例外，比如周线的’high’应该等于这一周所有日线‘high’中的最大值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们还是使用之前stock_day当中的某个股票的行情数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将索引转换成DatetimeIndex类型&lt;/li&gt;
&lt;li&gt;对不同指标进行重采样&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
stock_day = pd.read_csv(&quot;./data/stock_day/stock_day.csv&quot;)
stock_day = stock_day.sort_index()
# 对每日交易数据进行重采样 （频率转换）
stock_day.index


# 1、必须将时间索引类型编程Pandas默认的类型
stock_day.index = pd.to_datetime(stock_day.index)

# 2、进行频率转换日K---周K,首先让所有指标都为最后一天的价格
period_week_data = stock_day.resample('W').last()

# 分别对于开盘、收盘、最高价、最低价进行处理
period_week_data['open'] = stock_day['open'].resample('W').first()
# 处理最高价和最低价
period_week_data['high'] = stock_day['high'].resample('W').max()
# 最低价
period_week_data['low'] = stock_day['low'].resample('W').min()
# 成交量 这一周的每天成交量的和
period_week_data['volume'] = stock_day['volume'].resample('W').sum()
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;对于其中存在的缺失值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829020731349-2087195354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
period_week_data.dropna(axis=0)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以将计算出来的周K和原先的日K画图显示出来&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;画出K线图显示&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;金融数据绘制需要使用mpl_finance框架, 通过pip 安装即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from mpl_finance import candlestick_ochl
import matplotlib.pyplot as plt

# 先画日K线
fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(20, 8), dpi=80)
# 准备数据， array数组
stock_day['index'] = [i for i in range(stock_day.shape[0])]
day_k = stock_day[['index', 'open', 'close', 'high', 'low']]
candlestick_ochl(axes, day_k.values, width=0.2, colorup='r', colordown='g')
plt.show()


# 周K线图数据显示出来
period_week_data['index'] = [i for i in range(period_week_data.shape[0])]
week_k = period_week_data[['index', 'open', 'close', 'high', 'low']]
candlestick_ochl(axes, week_k.values, width=0.2, colorup='r', colordown='g')

plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;535-什么是除权数据以及复权操作（了解）&quot;&gt;4.4 什么是除权数据以及复权操作？&lt;/h3&gt;
&lt;p&gt; 上市公司会时不时的发生现金分红、送股等一系列股本变动，这会造成股价的非正常变化，导致我们不能直接通过股价来计算股票的涨跌幅。这种数据我们也称之为除权数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829021002440-1898107698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们要对这种数据做处理，也称之为复权数据。怎么进行复权呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
简单的一种方式：
原始数据：
1号：100  2号：50 3号：53 4号：51
复权后：
100 / 50 = 2 比例
1号：100  2号：100 3号：106 4号：102
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;536-基本面数据&quot;&gt;4.5 基本面数据&lt;/h3&gt;
&lt;h3 id=&quot;1-基本面数据的用处&quot;&gt;4.5.1 基本面数据的用处&lt;/h3&gt;
&lt;p&gt;主要用于基本面分析，主要侧重于从股票的基本面因素，如企业经营能力，财务状况，行业背景等对公司进行研究与分析，试图从公司角度找出股票的“内在价值”，从而与股票市场价值进行比较，挑选出最具投资价值的股票。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;code&gt;量化主要就属于这样的一个分析方式
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;54-股票时间序列数据处理&quot;&gt;5 股票时间序列数据处理&lt;/h2&gt;
&lt;h3 id=&quot;541-什么是时间序列&quot;&gt;5.1 什么是时间序列?&lt;/h3&gt;
&lt;p&gt;时间序列是一组按照时间发生先后顺序进行排列的数据点序列。通常一组时间序列的时间间隔为一恒定值（如1秒，5分钟，12小时，7天，1年），因此时间序列可以作为离散时间数据进行分析处理。&lt;/p&gt;
&lt;p&gt;例如：某监控系统的折线图表，显示了请求次数和响应时间随时间的变化趋势&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829021613182-1855679137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3 id=&quot;542-pandas的时间类型&quot;&gt;5.2 Pandas的时间类型&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;pd.to_datetime()：转换成pandas的时间类型 Timestamp('2018-03-02 00:00:00')&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# pd将时间数据转换成pandas时间类型
# 1、填入时间的字符串，格式有几种, &quot;2018-01-01&quot; ，”01/02/2018“
pd.to_datetime(&quot;01/02/2017&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;543-pandas的时间序列类型&quot;&gt;5.3 Pandas的时间序列类型&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1、转换时间序列类型&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;69&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 传入时间的列表
pd.to_datetime([&quot;2017-01-01&quot;, &quot;2017-02-01&quot;, &quot;2017-03-01&quot;])

# 或者
date = [datetime(2018, 3, 1), datetime(2018, 3, 2), datetime(2018, 3, 3), datetime(2018, 3, 4), datetime(2018, 3, 5)]
date = pd.to_datetime(date)

# 如果其中有空值
date = [datetime(2018, 3, 1), datetime(2018, 3, 2), np.nan, datetime(2018, 3, 4), datetime(2018, 3, 5)]
date = pd.to_datetime(date)
# 结果会变成NaT类型
DatetimeIndex(['2018-03-01', '2018-03-02', 'NaT', '2018-03-04', '2018-03-05'], dtype='datetime64[ns]', freq=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;2、Pandas的时间序列类型：DatetimeIndex&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# DateTimeIndex
pd.to_datetime(date)
DatetimeIndex(['2018-03-01', '2018-03-02', '2018-03-03', '2018-03-04',
               '2018-03-05'],
              dtype='datetime64[ns]', freq=None)

pd.to_datetime(date).values

array(['2018-03-01T00:00:00.000000000', '2018-03-02T00:00:00.000000000',
       '2018-03-03T00:00:00.000000000', '2018-03-04T00:00:00.000000000',
       '2018-03-05T00:00:00.000000000'], dtype='datetime64[ns]')
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们也可以通过DatetimeIndex来转换&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3、通过pd.DatetimeIndex进行转换&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
pd.DatetimeIndex(date)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;知道了时间序列类型，所以我们可以用这个当做索引，获取数据&quot;&gt;知道了时间序列类型，所以我们可以用这个当做索引，获取数据&lt;/h4&gt;
&lt;h3 id=&quot;544-pandas的基础时间序列结构&quot;&gt;5.4 Pandas的基础时间序列结构&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 最基础的pandas的时间序列结构,以时间为索引的，Series序列结构
# 以时间为索引的DataFrame结构
series_date = pd.Series(3.0, index=date)

pd.to_datetime(series_date)
pd.DatetimeIndex(series_date)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pandas时间序列series的index必须是DatetimeIndex&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DatetimeIndex的属性
&lt;ul&gt;&lt;li&gt;year,month,weekday,day,hour….&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
time.year
time.month
time.weekday
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;545-pandas生成指定频率的时间序列&quot;&gt;5.5 Pandas生成指定频率的时间序列&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;pandas.date_range(start=None, end=None, periods=None, freq='D', tz=None, normalize=False, name=None, closed=None, **kwargs)
&lt;ul&gt;&lt;li&gt;Returna fixed frequency DatetimeIndex, with day (calendar) as the default frequency&lt;/li&gt;
&lt;li&gt;start:开始时间&lt;/li&gt;
&lt;li&gt;end:结束时间&lt;/li&gt;
&lt;li&gt;periods:产生多长的序列&lt;/li&gt;
&lt;li&gt;freq:频率 D,H,Q等&lt;/li&gt;
&lt;li&gt;tz:时区&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829022016319-324932963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 生成指定的时间序列
# 1、生成2017-01-02~2017-12-30，生成频率为1天, 不跳过周六周日
pd.date_range(&quot;2017-01-02&quot;, &quot;2017-12-30&quot;, freq=&quot;D&quot;)

# 2、生成2017-01-02~2017-12-30，生成频率为1天, 跳过周六周日, 能够用在金融的数据，日线的数据
pd.date_range(&quot;2017-01-02&quot;, &quot;2017-12-30&quot;, freq=&quot;B&quot;)

# 3、只知道开始时间日期，我也知道总共天数多少，生成序列， 从&quot;2016-01-01&quot;, 共504天，跳过周末
pd.date_range(&quot;2016-01-01&quot;, periods=504, freq=&quot;B&quot;)

# 4、生成按照小时排列的时间序列数据
pd.date_range(&quot;2017-01-02&quot;, &quot;2017-12-30&quot;, freq='H')

# 5、按照3H去进行生成
pd.date_range(&quot;2017-01-02&quot;, &quot;2017-12-30&quot;, freq='3H')

# 6、按照1H30分钟去进行生成时间序列
pd.date_range(&quot;2017-01-02&quot;, &quot;2017-12-30&quot;, freq='1H30min')

# 7、按照每月最后一天
pd.date_range(&quot;2017-01-02&quot;, &quot;2017-12-30&quot;, freq='BM')

# 8、按照每个月的第几个星期几
pd.date_range(&quot;2017-01-02&quot;, &quot;2017-12-30&quot;, freq='WOM-3FRI')
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;546什么是时间序列分析&quot;&gt;5.6什么是时间序列分析&lt;/h3&gt;
&lt;p&gt;对于时间序列类型，有特有的分析方法。同样股票本身也是一种时间序列类型，我们就以股票的数据来进行时间序列的分析&lt;/p&gt;
&lt;p&gt;时间序列分析( time series analysis)方法,强调的是通过对一个区域进行一定时间段内的连续观察计算，提取相关特征，并分析其变化过程。&lt;/p&gt;
&lt;p&gt;时间序列分析主要有确定性变化分析&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确定性变化分析：移动平均法， 移动方差和标准差、移动相关系数&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;547-移动平均法&quot;&gt;5.7 移动平均法&lt;/h3&gt;
&lt;h3 id=&quot;5471-移动窗口&quot;&gt;5.7.1 移动窗口&lt;/h3&gt;
&lt;p&gt;主要用在时间序列的数组变换， 不同作用的函数将它们统称为移动窗口函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829022134387-1369925005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5472-移动平均线&quot;&gt;5.7.2 移动平均线&lt;/h3&gt;
&lt;p&gt;那么会有各种观察窗口的方法，其中最常用的就是移动平均法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;移动平均线(Moving Average)简称均线, 将某一段时间的收盘价之和除以该周期&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829022209213-164399078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5473-移动平均线的分类&quot;&gt;5.7.3 移动平均线的分类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;移动平均线依计算周期分为短期(5天)、中期(20天)和长期(60天、120天)，移动平均线没有固定的界限&lt;/li&gt;
&lt;li&gt;移动平均线依据算法分为算数、加权法和指数移动平均线&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不同的移动平均线方法不一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-简单移动平均线&quot;&gt;1 简单移动平均线&lt;/h4&gt;
&lt;p&gt;简单移动平均线(SMA)，又称“算数移动平均线”，是指特定期间的收盘价进行平均化比如说，5日的均线SMA=(C1+ C2 + C3 + C4 + C5) / 5&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829022255612-500441672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829022313816-966739046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;案例：对股票数据进行移动平均计算&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829022341531-177616437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拿到股票数据，画出K线图&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 拿到股票K线数据
stock_day = pd.read_csv(&quot;./data/stock_day/stock_day.csv&quot;)
stock_day = stock_day.sort_index()
stock_day[&quot;index&quot;] = [i for i in range(stock_day.shape[0])]
arr = stock_day[['index', 'open', 'close', 'high', 'low']]
values = arr.values[:200]
# 画出K线图
fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(20, 8), dpi=80)
candlestick_ochl(axes, values, width=0.2, colorup='r', colordown='g')
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;2-计算移动平均线&quot;&gt;2 计算移动平均线&lt;/h4&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;pandas.rolling_mean(arg, window, min_periods=None, freq=None, center=False, how=None, **kwargs) Moving mean.&lt;/p&gt;
&lt;p&gt;Parameters:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;arg : Series, DataFrame&lt;/li&gt;
&lt;li&gt;window : 计算周期&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 直接对每天的收盘价进行求平均值， 简单移动平局线(SMA)
# 分别加上短期、中期、长期局均线
pd.rolling_mean(stock_day[&quot;close&quot;][:200], window=5).plot()
pd.rolling_mean(stock_day[&quot;close&quot;][:200], window=10).plot()
pd.rolling_mean(stock_day[&quot;close&quot;][:200], window=20).plot()
pd.rolling_mean(stock_day[&quot;close&quot;][:200], window=30).plot()
pd.rolling_mean(stock_day[&quot;close&quot;][:200], window=60).plot()
pd.rolling_mean(stock_day[&quot;close&quot;][:200], window=120).plot()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;3-加权移动平均线-wma&quot;&gt;3 加权移动平均线 (WMA)&lt;/h3&gt;
&lt;p&gt;加权移动平均线 (WMA)将过去某特定时间内的价格取其平均值，它的比重以平均线的长度设定，愈近期的收市价，对市况影响愈重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829022507799-44058703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正因加权移动平均线强调将愈近期的价格比重提升，故此当市况倒退时，加权移动平均线比起其它平均线更容易预测价格波动。但是我们还是不会轻易使用加权，应为他的比重过大！！！！&lt;/p&gt;
&lt;h3 id=&quot;4-指数平滑移动平均线ewma&quot;&gt;4 指数平滑移动平均线(EWMA)&lt;/h3&gt;
&lt;p&gt;是因应移动平均线被视为落后指标的缺失而发展出来的，为解决一旦价格已脱离均线差值扩大，而平均线未能立即反应，EWMA可以减少类似缺点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829022526627-940206758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829022541766-2045407276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;pd.ewma(com=None, span=one)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指数平均线&lt;/li&gt;
&lt;li&gt;span:时间间隔&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 画出指数平滑移动平均线
pd.ewma(stock_day['close'][:200], span=10).plot()
pd.ewma(stock_day['close'][:200], span=30).plot()
pd.ewma(stock_day['close'][:200], span=60).plot()
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;548-移动方差和标准差&quot;&gt;5.8 移动方差和标准差&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;方差和标准差：反应某一时期的序列的稳定性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829022616040-68382142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 求出指定窗口大小的收盘价标准差和方差
pd.rolling_var(stock_day['close'][:200], window=10).plot()
pd.rolling_std(stock_day['close'][:200], window=10).plot()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;549-各项指标数据两两关联散点图&quot;&gt;5.9 各项指标数据两两关联散点图&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;pd.scatter_matrix(frame, figsize=None)
&lt;ul&gt;&lt;li&gt;frame:DataFrame&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
frame = data[['open','volume', 'ma20', 'p_change', 'turnover']]
pd.scatter_matrix(frame, figsize=(20, 8))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201808/1396321-20180829022653840-2048154429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从中我们可以简单看到成交量（volume）和换手率（turnover）有非常明显的线性关系，因为换手率的定义就是：成交量除以发行总股数。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;通过一些图或者相关性分析可以找到强相关的一些指标，在机器学习、量化方向中会详细介绍&lt;/p&gt;
&lt;p&gt;相关系数：后面会介绍，目前我们只需知道他是反应两个序列之间的关系即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;5410-案例：移动平均线数据本地保存&quot;&gt;5.10 案例：移动平均线数据本地保存&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
ma_list = [5, 20 ,60]
for ma in ma_list:
    data['MA' + str(ma)] = pd.rolling_mean(data.close, ma)
for ma in ma_list:
    data['EMA' + str(ma)] = pd.ewma(data.close, span=ma)

data.to_csv(&quot;EWMA.csv&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;5411-移动平均线的作用&quot;&gt;5.11 移动平均线的作用&lt;/h2&gt;
&lt;p&gt;移动平均线经常会作为技术分析的基础理论，从中衍生出各种技术指标策略。后面将会介绍简单的基于均线的策略。&lt;/p&gt;
</description>
<pubDate>Tue, 28 Aug 2018 18:39:00 +0000</pubDate>
<dc:creator>汪凡</dc:creator>
<og:description>有人让我写一下关于数据挖掘在金融方面的应用，再加上现在金融对数据方面的要求不断提高，准备用两篇随笔来做个入门总结。 首先，在看这篇随笔以前稍微补充一点金融方面的知识，因为我不是金融专业的，以下补充知识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wf-skylark/p/9551967.html</dc:identifier>
</item>
<item>
<title>Mysql系列九：使用zookeeper管理远程Mycat配置文件、Mycat监控、Mycat数据迁移（扩容） - 小不点啊</title>
<link>http://www.cnblogs.com/leeSmall/p/9551038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leeSmall/p/9551038.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;use&lt;/span&gt;&lt;span&gt; TESTDB;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; employee(
 id &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt; auto_increment,
 name &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
 sharding_id &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
 company_id &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack002&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack003&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack004&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack005&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack006&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack007&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack008&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack009&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack010&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack011&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack012&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack013&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack014&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack015&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack016&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack019&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack021&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack022&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack023&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack024&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack025&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; employee(id, name, sharding_id, company_id) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack026&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;10010&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);
&lt;/pre&gt;</description>
<pubDate>Tue, 28 Aug 2018 17:56:00 +0000</pubDate>
<dc:creator>小不点啊</dc:creator>
<og:description>一、使用zookeeper管理远程Mycat配置文件 环境准备： 虚拟机192.168.152.130： zookeeper，具体参考前面文章 搭建dubbo+zookeeper+dubbo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leeSmall/p/9551038.html</dc:identifier>
</item>
<item>
<title>那些年，我们用并行遇到的坑02 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9551866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9551866.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;Oracle 10.2.0.5&lt;br/&gt;&lt;strong&gt;现象：&lt;/strong&gt;RMAN分配多个通道，但实际无法使用到并行。&lt;br/&gt;&lt;strong&gt;构建测试用例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create tablespace dbs_d_test;
alter tablespace dbs_d_test add datafile; --这里是11
alter tablespace dbs_d_test add datafile; --这里是12
alter tablespace dbs_d_test add datafile; --这里是13

alter database datafile 11,12,13 resize 1G;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;使用RMAN备份&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;run {
allocate channel c1 device type disk;
allocate channel c2 device type disk;
allocate channel c3 device type disk;

backup as copy datafile 11 format '/tmp/incr/copy11.bak';
backup as copy datafile 12 format '/tmp/incr/copy12.bak';
backup as copy datafile 13 format '/tmp/incr/copy13.bak';

release channel c1;
release channel c2;
release channel c3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用下面SQL查询长操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select inst_id, sid, username, opname, target, sofar, totalwork, sofar * 100 / totalwork from gv$session_longops where sofar &amp;lt; totalwork;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现上面这种备份写法，虽然分配了多个通道，但实际观察并没有使用到并行。3个文件的备份是串行操作的。这点从上面的长操作中可以看到，同时从RMAN输出日志中同样也可以看到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;RMAN&amp;gt; run {
2&amp;gt; allocate channel c1 device type disk;
3&amp;gt; allocate channel c2 device type disk;
4&amp;gt; allocate channel c3 device type disk;
5&amp;gt; 
6&amp;gt; backup as copy datafile 11 format '/tmp/incr/copy11.bak';
7&amp;gt; backup as copy datafile 12 format '/tmp/incr/copy12.bak';
8&amp;gt; backup as copy datafile 13 format '/tmp/incr/copy13.bak';
9&amp;gt; 
10&amp;gt; release channel c1;
11&amp;gt; release channel c2;
12&amp;gt; release channel c3;
13&amp;gt; }

using target database control file instead of recovery catalog
allocated channel: c1
channel c1: sid=128 instance=jy1 devtype=DISK

allocated channel: c2
channel c2: sid=117 instance=jy1 devtype=DISK

allocated channel: c3
channel c3: sid=129 instance=jy1 devtype=DISK

Starting backup at 29-AUG-18
channel c1: starting datafile copy
input datafile fno=00011 name=+ZHAOJINGYU/jy/datafile/dbs_d_test.615.985387387
output filename=/tmp/incr/copy11.bak tag=TAG20180829T002101 recid=13 stamp=985393279
channel c1: datafile copy complete, elapsed time: 00:00:25
Finished backup at 29-AUG-18

Starting backup at 29-AUG-18
channel c1: starting datafile copy
input datafile fno=00012 name=+ZHAOJINGYU/jy/datafile/dbs_d_test.613.985387391
output filename=/tmp/incr/copy12.bak tag=TAG20180829T002127 recid=14 stamp=985393305
channel c1: datafile copy complete, elapsed time: 00:00:25
Finished backup at 29-AUG-18

Starting backup at 29-AUG-18
channel c1: starting datafile copy
input datafile fno=00013 name=+ZHAOJINGYU/jy/datafile/dbs_d_test.611.985387395
output filename=/tmp/incr/copy13.bak tag=TAG20180829T002153 recid=15 stamp=985393330
channel c1: datafile copy complete, elapsed time: 00:00:25
Finished backup at 29-AUG-18

released channel: c1

released channel: c2

released channel: c3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际是串行操作，都是用的通道c1，这3个数据文件的copy备份消耗3个25s=75s。&lt;/p&gt;

&lt;p&gt;改进写法，用到了并行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;run {
allocate channel c1 device type disk;
allocate channel c2 device type disk;
allocate channel c3 device type disk;

backup as copy datafile 11,12,13 format '/tmp/incr/copy_%u.bak';

release channel c1;
release channel c2;
release channel c3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从日志看到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;RMAN&amp;gt; run {
2&amp;gt; allocate channel c1 device type disk;
3&amp;gt; allocate channel c2 device type disk;
4&amp;gt; allocate channel c3 device type disk;
5&amp;gt; 
6&amp;gt; backup as copy datafile 11,12,13 format '/tmp/incr/copy_%u.bak';
7&amp;gt; 
8&amp;gt; release channel c1;
9&amp;gt; release channel c2;
10&amp;gt; release channel c3;
11&amp;gt; }

using target database control file instead of recovery catalog
allocated channel: c1
channel c1: sid=129 instance=jy1 devtype=DISK

allocated channel: c2
channel c2: sid=127 instance=jy1 devtype=DISK

allocated channel: c3
channel c3: sid=119 instance=jy1 devtype=DISK

Starting backup at 29-AUG-18
channel c1: starting datafile copy
input datafile fno=00011 name=+ZHAOJINGYU/jy/datafile/dbs_d_test.615.985387387
channel c2: starting datafile copy
input datafile fno=00012 name=+ZHAOJINGYU/jy/datafile/dbs_d_test.613.985387391
channel c3: starting datafile copy
input datafile fno=00013 name=+ZHAOJINGYU/jy/datafile/dbs_d_test.611.985387395
output filename=/tmp/incr/copy_14tbnq76.bak tag=TAG20180829T002302 recid=16 stamp=985393432
channel c1: datafile copy complete, elapsed time: 00:00:55
output filename=/tmp/incr/copy_15tbnq76.bak tag=TAG20180829T002302 recid=17 stamp=985393432
channel c2: datafile copy complete, elapsed time: 00:00:55
output filename=/tmp/incr/copy_16tbnq76.bak tag=TAG20180829T002302 recid=18 stamp=985393435
channel c3: datafile copy complete, elapsed time: 00:00:55
Finished backup at 29-AUG-18

released channel: c1

released channel: c2

released channel: c3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际是并行操作，分别用的通道c1、c2、c3，这3个数据文件的copy备份消耗1个55s=55s。&lt;br/&gt;那为什么并行没有成倍增加效率？跟上一篇提到的一样，系统的整体I/O能力达到瓶颈了。所以一味的增加并行度并不总是有意义的。&lt;/p&gt;

&lt;p&gt;如果数据文件很大，但实际使用的并不多，则可以考虑使用备份集的方式，减少备份对空间的占用，一般同时也会加快备份的速度：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;run {
allocate channel c1 device type disk;
allocate channel c2 device type disk;
allocate channel c3 device type disk;

backup as compressed backupset datafile 11,12,13 format '/tmp/incr/datafile_%u.bak';

release channel c1;
release channel c2;
release channel c3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从日志可以看到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;RMAN&amp;gt; run {
2&amp;gt; allocate channel c1 device type disk;
3&amp;gt; allocate channel c2 device type disk;
4&amp;gt; allocate channel c3 device type disk;
5&amp;gt; 
6&amp;gt; backup as compressed backupset datafile 11,12,13 format '/tmp/incr/datafile_%u.bak';
7&amp;gt; 
8&amp;gt; release channel c1;
9&amp;gt; release channel c2;
10&amp;gt; release channel c3;
11&amp;gt; }

using target database control file instead of recovery catalog
allocated channel: c1
channel c1: sid=128 instance=jy1 devtype=DISK

allocated channel: c2
channel c2: sid=134 instance=jy1 devtype=DISK

allocated channel: c3
channel c3: sid=116 instance=jy1 devtype=DISK

Starting backup at 29-AUG-18
channel c1: starting compressed full datafile backupset
channel c1: specifying datafile(s) in backupset
input datafile fno=00011 name=+ZHAOJINGYU/jy/datafile/dbs_d_test.615.985387387
channel c1: starting piece 1 at 29-AUG-18
channel c2: starting compressed full datafile backupset
channel c2: specifying datafile(s) in backupset
input datafile fno=00012 name=+ZHAOJINGYU/jy/datafile/dbs_d_test.613.985387391
channel c2: starting piece 1 at 29-AUG-18
channel c3: starting compressed full datafile backupset
channel c3: specifying datafile(s) in backupset
input datafile fno=00013 name=+ZHAOJINGYU/jy/datafile/dbs_d_test.611.985387395
channel c3: starting piece 1 at 29-AUG-18
channel c1: finished piece 1 at 29-AUG-18
piece handle=/tmp/incr/datafile_17tbnqi9.bak tag=TAG20180829T002857 comment=NONE
channel c1: backup set complete, elapsed time: 00:00:02
channel c3: finished piece 1 at 29-AUG-18
piece handle=/tmp/incr/datafile_19tbnqia.bak tag=TAG20180829T002857 comment=NONE
channel c3: backup set complete, elapsed time: 00:00:01
channel c2: finished piece 1 at 29-AUG-18
piece handle=/tmp/incr/datafile_18tbnqi9.bak tag=TAG20180829T002857 comment=NONE
channel c2: backup set complete, elapsed time: 00:00:05
Finished backup at 29-AUG-18

released channel: c1

released channel: c2

released channel: c3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我这里这几个文件根本没有业务数据，所以效率提升尤为明显，只需要5s钟就完成了备份。&lt;/p&gt;
</description>
<pubDate>Tue, 28 Aug 2018 16:51:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>环境： Oracle 10.2.0.5 现象： RMAN分配多个通道，但实际无法使用到并行。 构建测试用例：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9551866.html</dc:identifier>
</item>
<item>
<title>redis为什么这么火该怎么用 - yswenli</title>
<link>http://www.cnblogs.com/yswenli/p/9551581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yswenli/p/9551581.html</guid>
<description>&lt;p&gt;　　最近一些人在介绍方案时，经常会出现redis这个词，于是很多小伙伴百度完redis也就觉得它是一个缓存，然后项目里面把数据丢进去完事，甚至有例如将实体属性拆分塞进redis hash里面的奇怪用法等等！原因是什么呢？大家觉得redis火，使用了redis项目就是高大上的，于是不管三七二十一，项目里用上强塞一个用上！这里本人想说的是你知道redis为什么这么火么，应该怎么用么？下面带着本人拙建，简单分析一下：&lt;/p&gt;
&lt;h2&gt;一、redis性能&lt;/h2&gt;
&lt;p&gt;　　redis是一个基于内存hash结构的缓存型db，同mysql等传统数据库对比性能时，读操作在1k左右数据的时候相差基本上在10-100倍的差别，写入的性能差别就更大了，下面是一些测试数据&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/542396/201808/542396-20180828231145965-1304206029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/542396/201808/542396-20180828231207136-443364743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过对redis的set、get命令测试观察，redis的读写性能在单线程下可以达到每秒2W左右；通过对mysql的select和insert、delete语句测试，mysql的读性能可达到5000每秒左右，写性能可到达3000每秒，读性能基本是写性能的2倍。而上述测试是基于redis单实例、单连接的情况，如果根据cpu核数来增加redis实例，并且使用pie和多连接，这个数据还能轻松的再上一个数量级~&lt;/p&gt;
&lt;h2&gt;二、redis缓存&lt;/h2&gt;
&lt;p&gt;　　上面分析了redis的性能非常高，基本上同机器配置下完全吊打传统sql，甚至nosql的mongodb等。即使这样redis也只是一个分布式缓存，或者说是分布式缓存数据库，那么redis肯定不能像传统数据一样，动不动放个几T的数据，一般都是用来放热数据或者体量小的数据，其他的数据还是使用队列通过后台服务放到sql db里面；另外根据redis的特性，建议服务器cpu核心数要留个1/4，每个实例的内存最得多出1/2；假如24核的120G的服务器，建议部署18个reids实例，每个实例5G的内存，实际使用不要超过3G的数据量~reids是缓存就继承了缓存的优缺点，性能高是优点，缺点：缓存穿透、缓存雪崩。&lt;/p&gt;
&lt;p&gt;　　1.缓存穿透：缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/542396/201808/542396-20180829002215438-1776170311.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　解决办法就是将从db过来的返回值进行缓存，根据实际情况重新加热，若db返回是空则缓存几分钟就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/542396/201808/542396-20180829002244011-1319087843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　2.缓存雪崩：在我们设置缓存时采用了相同的过期时间或者缓存服务器因某些原因无法使用时，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/542396/201808/542396-20180829002839631-1810000881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解决办法过期时间上增加一个范围的随机值，使用Redis Sentinel 和 Redis Cluster 实现高可用，另增设一个寿命更短的本机缓存来解决redis分布缓存抢修时的问题。&lt;/p&gt;
&lt;p&gt;　　在发生无论是缓存穿透还是缓存雪崩，都建议使用队列来排队、拒绝大量请求涌入和分布式互斥锁来避免后端数据服务被冲击，防止已有的数据出现问题。&lt;/p&gt;
&lt;h2&gt;三、总结&lt;/h2&gt;
&lt;p&gt;　　redis很强大，无论是哨兵式集群还是自带的redis cluster方式集群，但是一定要对redis了解清楚才能更好的使用~&lt;/p&gt;

</description>
<pubDate>Tue, 28 Aug 2018 16:32:00 +0000</pubDate>
<dc:creator>yswenli</dc:creator>
<og:description>最近一些人在介绍方案时，经常会出现redis这个词，于是很多小伙伴百度完redis也就觉得它是一个缓存，然后项目里面把数据丢进去完事，甚至有例如将实体属性拆分塞进redis hash里面的奇怪用法等等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yswenli/p/9551581.html</dc:identifier>
</item>
<item>
<title>netstat实现原理 - 冷冰若水</title>
<link>http://www.cnblogs.com/lit10050528/p/9551795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lit10050528/p/9551795.html</guid>
<description>&lt;p&gt;因为最近接手的项目是基于嵌入式Linux openwrt的，一开始以为会跟之前的服务器开发没什么大的区别，但是遇到问题去分析的时候才发现，工具链还是有些差别的，openwrt的netstat是属于一个叫做busybox的工具集的，这个工具集是专门提供给嵌入式Linux，它的参数很简单，居然没有Linux下netstat的-p选项，因此当我想查看是哪些进程在监听哪些端口时，发现只能查看有哪些监听端口，无法得知是属于哪个进程的，lsof也没有-i选项。&lt;/p&gt;
&lt;p&gt;但是有时候排查问题又必须知道哪个进程监听了某个端口，因此就想搞清楚Linux下的netstat是怎么实现可以查看监听端口属于哪个进程呢。&lt;/p&gt;
&lt;p&gt;首先想法就是去下载busybox的源代码，但是感觉代码太多了，费时费力，于是灵机一动想到Linux下的另一个工具strace（追踪程序调用的系统调用），通过strace来查看netstat执行时都做了什么操作。&lt;/p&gt;
&lt;p&gt;截取了strace输出的某一段，可以看到，调用open以及readlink遍历了/proc/3055/fd/目录下的所有文件，大家都知道这个目录是进程打开文件的目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/483444/201808/483444-20180828235344137-1647456810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在strace输出的最后，可以看到调用了open打开/proc/net/udp文件，并读取里面的内容将其解析输出，这里面就记录了所有udp连接的信息，同时/proc/net/tcp对应tcp连接、/proc/net/unix对应Unix socket连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/483444/201808/483444-20180828235753970-241480742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据这个文件的标头可以知道，第二列是local address，但是由于是16进制编码，所以需要我们手动转换成10进制。&lt;/p&gt;
&lt;p&gt;这里其实可以发现，/proc/net/udp这个文件中的信息是不包含进程信息的，所以这也是为什么netstat在开始的时候会先遍历所有/proc/xx/fd目录，因为netstat可以通过inode将/proc/net/udp中的行和/proc/xx/fd中的文件关联起来，这样就可以得到某一行udp连接的进程信息（因为inode是唯一的）。&lt;/p&gt;
&lt;p&gt;所以，分析到这里，我猜测busybox中的netstat应该是没有遍历所有/proc/xx/fd这一步，仅仅是读取了/proc/net/udp文件并解析输出。&lt;/p&gt;
&lt;p&gt;明白了netstat的原理，那么即使遇到不提供netstat -p选项的嵌入式Linux，我们也能手动分析出自己想要的信息，进而解决问题。&lt;/p&gt;
</description>
<pubDate>Tue, 28 Aug 2018 16:06:00 +0000</pubDate>
<dc:creator>冷冰若水</dc:creator>
<og:description>因为最近接手的项目是基于嵌入式Linux openwrt的，一开始以为会跟之前的服务器开发没什么大的区别，但是遇到问题去分析的时候才发现，工具链还是有些差别的，openwrt的netstat是属于一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lit10050528/p/9551795.html</dc:identifier>
</item>
<item>
<title>ORM框架的前世今生 - 7tiny</title>
<link>http://www.cnblogs.com/7tiny/p/9551754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/7tiny/p/9551754.html</guid>
<description>&lt;p&gt;目录&lt;/p&gt;
&lt;p&gt;一、ORM简介&lt;br/&gt;二、ORM的工作原理&lt;br/&gt;三、ORM的优缺点&lt;br/&gt;四、常见的ORM框架&lt;/p&gt;
&lt;h2&gt;一、ORM简介&lt;/h2&gt;
&lt;p&gt;ORM（Object Relational Mapping）对象关系映射，一般指持久化数据和实体对象的映射&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/998608/201808/998608-20180828234813310-775455226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;数据存储是绝大多数软件系统都要接触到的技术，具有一定规模的软件产品，为了方便存储和管理数据，便引入了数据库这一工具，但是数据如何从程序写入数据库的呢？&lt;/p&gt;
&lt;p&gt;为方便程序员通过代码将数据写入数据库，一般的语言开发的厂商都会为各种数据库适配数据库连接的驱动程序，比如ADO.Net,JDBC等。&lt;/p&gt;
&lt;p&gt;但是数据库连接的驱动程序的职责在于管理连接数据库，设置连接参数等信息，通常会返回各自封装好的数据集类型，驱动程序封装的类型往往是以数据为核心进行描述的，现代化的软件设计为了简便描述事物的特征都而以面向对象思想为核心，两者之间的转换还有很多的路要走。&lt;/p&gt;
&lt;p&gt;除却转换部分，Sql语句的编写也是一大学问，一般的编程语言都没有为sql语句定义类型，这是因为每种数据库的sql语句风格都是不一样的，难以给出一个统一的方案。退而求其次，一般的编程语言都采用字符串形式传递sql语句到数据库驱动程序。抛弃各种各样的sql语句的学习之外，这种方式有一个很大的弊端，那就是sql语句的拼写极容易由于手误而犯错。&lt;/p&gt;
&lt;p&gt;在这种场景下，ORM框架诞生了！&lt;/p&gt;
&lt;h2&gt;二、ORM的工作原理&lt;/h2&gt;
&lt;p&gt;在讲解完ORM的前世之后，我们来聊聊ORM框架为我们做了什么。&lt;/p&gt;
&lt;p&gt;在第一节我们提过了，没有ORM的情况下，主要有两个槽点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.驱动返回类型和对象不能良好映射&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2.SQL语句的学习成本及易错率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，且看我们的ORM如何改善这两个槽点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/998608/201808/998608-20180828234819143-1555188191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;1.数据驱动返回的数据通常都是以数据为核心的数据集合，我们需要通过手动将类对象和数据库返回的列数据进行一一匹配获取，然后赋值到对象上。在这里要感谢泛型和反射两大语法，通过泛型和反射，我们可以获取到任何实体类的属性而不是具体到某一种类型，通过遍历实体类的属性去数据集合中一一获取并复制返回。这一操作便将数据集合的数据完美包装成了以面向对象为核心的和类相关的对象数据集合。&lt;/p&gt;
&lt;p&gt;2.sql语句的拼写，我们可以提供一套公共sql语句模板，然后在具体实体对象操作的时候将实体对象的属性名称和属性值当作参数拼接进去，组装成完整的sql语句(例如java体系中的Mybatis框架）或者依旧采用封装一套浅显易懂的Api，Api内部通过对应方法和实体对象的组装成sql语句（例如.Net体系中EntityFramework框架）&lt;/p&gt;
&lt;p&gt;ORM还为我们做了什么？&lt;/p&gt;
&lt;p&gt;最重要的两个问题解决完之后，我们可以在框架中做一些对我们有帮助的其他事情。ORM框架做的最多的便是“缓存”。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/998608/201808/998608-20180828234849164-89287979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;作为程序员应该掌握的基础知识，数据库操作是要和硬盘打交道的，而程序是在内存中运行的，操作内存的速度要比操作硬盘快数十倍以上，可见一个访问量较高的大型系统很容易由于数据库操作过于频繁而拖慢整体速度，从而影响系统的使用。因此，ORM框架要帮助我们减少数据库的访问，加快系统速度。&lt;/p&gt;
&lt;p&gt;ORM框架的缓存系统一般是较为复杂的，而且每种ORM框架对缓存的实现机制都是不同的。整体的思路却是一致的，对访问频率较高的数据进行缓存，并在对数据编辑的时候要对缓存进行更新，以免出现数据不一致的问题。详细的缓存实现策略这里不一一赘述，感兴趣可以针对某个ORM框架进行剖析。&lt;/p&gt;
&lt;h2&gt;三、ORM的优缺点&lt;/h2&gt;
&lt;p&gt;通过上面两节的描述，我们很容易总结出ORM框架的优缺点。我们先来说说优点。&lt;/p&gt;
&lt;p&gt;ORM框架降低了学习门槛，一个对sql语句并不熟悉的开发人员也可以很容易通过简易的ORM框架Api进行数据库的操作。&lt;/p&gt;
&lt;p&gt;提高了开发效率，ORM使我们减少很多繁琐重复的工作量，让我们的注意力集中在实现业务上。&lt;/p&gt;
&lt;p&gt;一定程度上提高了程序的响应速度。&lt;/p&gt;
&lt;p&gt;ORM框架的弊端也很明显，框架会自动生成Sql语句，所有场景的sql语句都是同一套模板，难以自动针对场景对sql语句进行良好的优化，某种场景下很容易生成执行很慢的sql语句。如果让DBA看到这样的执行sql，必定引来抓狂崩溃。&lt;/p&gt;
&lt;p&gt;ORM框架只是为了满足绝大多数的场景而生的，特殊需要优化sql的场景下，我们完全可以直接使用驱动手动执行sql或使用ORM框架内提供的sql语句api进行自定义sql语句。&lt;/p&gt;
&lt;h2&gt;四、市面常见的ORM框架&lt;/h2&gt;
&lt;h4&gt;.Net体系：&lt;/h4&gt;
&lt;p&gt;EntityFramework，功能强大，lambda api，有些庞大臃肿，很多功能用不上&lt;br/&gt;Dapper，轻量级，数据库种类支持丰富，sql写法灵活，运行速度快&lt;br/&gt;CYQ.Data，自动化，日志，分布式缓存，弱类型，api简介&lt;/p&gt;
&lt;h4&gt;Java体系：&lt;/h4&gt;
&lt;p&gt;MyBatis，映射采用Xml配置sql，多种映射关系灵活配置，sql需要手动编写到配置，轻量级，半自动&lt;br/&gt;Hibernate，Xml配置sql，支持HQL语句，移植性好，日志，重量级，功能全，全自动&lt;br/&gt;Speedment，lambda api，依赖java8&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/998608/201808/998608-20180828234902526-182806093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 28 Aug 2018 15:53:00 +0000</pubDate>
<dc:creator>7tiny</dc:creator>
<og:description>目录 一、ORM简介二、ORM的工作原理三、ORM的优缺点四、常见的ORM框架 一、ORM简介 ORM（Object Relational Mapping）对象关系映射，一般指持久化数据和实体对象的映</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/7tiny/p/9551754.html</dc:identifier>
</item>
<item>
<title>Html5游戏开发-图形与动画（一） - 吃西瓜的星星</title>
<link>http://www.cnblogs.com/zhuxiaoxiao/p/9551697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuxiaoxiao/p/9551697.html</guid>
<description>&lt;p&gt;最近研究了一下出来了很久的HTML5，总结了一下，准备来个系列，文中也许有很多问题，欢迎大家指正。&lt;/p&gt;
&lt;h2&gt;Canvas介绍&lt;/h2&gt;
&lt;p&gt;canvas用于在网页中绘制图形的一个元素，具体内容请查看 -&amp;gt; &lt;a title=&quot;canvas介绍&quot; href=&quot;http://www.w3school.com.cn/html5/html_5_canvas.asp&quot; target=&quot;_blank&quot;&gt;HTML5 Canvas&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里说些w3school中没有的。&lt;/p&gt;
&lt;h3&gt;立即模式&lt;/h3&gt;
&lt;p&gt;canvas元素是立即模式的图形系统，意味着当你提出要求时，他会立即绘制，然后立即忘记（绘制完成一个对象，就会销毁这个对象）。其它的图形系统（例如：SVG），使用了保留模式的图形系统，就是说绘制时他们会保留一系列将要绘制的对象。正因未Canvas不需要维护这一系列对象，所以Canvas的运行速度要快很多。&lt;/p&gt;
&lt;h3&gt;双缓存机制&lt;/h3&gt;
&lt;p&gt;在上面，我们提到了立即模式，但这里的“立即绘制”并不是大家所谓的立即，此处需要进一步说明。&lt;/p&gt;
&lt;p&gt;在浏览器调用我们定义的绘制方法（假设这个方法是DrawGame）绘制当前动画帧时，Canvas元素并不是立即绘制出你指定的内容。相反，它会创建另一个Canvas元素（我们叫它Canvas2），所有的绘制实际上都在Canvas2中进行。当DrawGame方法返回时，浏览器会通过一个图形操作，复制Canvas2内容到屏幕上，我们将这种技术称为双缓存技术，双缓存技术让动画的实现变得平滑。&lt;/p&gt;
&lt;h3&gt;坐标系统（translate）&lt;/h3&gt;
&lt;p&gt;translate(x,y)这是Canvas元素的一个方法，游戏的背景移动，大多通过该方法来实现。游戏中，我们不会通过频繁对大量元素进行坐标计算来实现对象的滚动，因为这样的计算不仅消耗计算机性能，还增加了代码的维护难度。&lt;/p&gt;
&lt;p&gt;注意：为了不影响后续的绘制，在使用translate(x,y)修改坐标系统后，需要再次调用translate(-x,-y)来恢复坐标系统。&lt;/p&gt;
&lt;p&gt;具体内容请查看 -&amp;gt; &lt;a href=&quot;http://www.w3school.com.cn/html5/canvas_translate.asp&quot; target=&quot;_blank&quot;&gt;HTML5 canvas translate()&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;创建Canvas镜像和恢复Canvas&lt;/h3&gt;
&lt;p&gt;在进行动画绘制时，我们会经常的对Canvas元素的绘图环境（context）进行修改，例如strokeStyle，lineWidth等。这些修改操作都是永久的，也就意味着对他们的修改将会影响接下来任何你在Canvas元素的图形操作。那么如何让这些操作只是临时有效呢？这里我们可以使用save()和restore()方法对当前Canvas元素的绘图环境状态创建镜像和恢复。任何写在这两个方法间的环境属性修改，在执行restore后，都会恢复成save时的状态。&lt;/p&gt;
&lt;p&gt;注意：save()和restore()需要成对出现，也就是有save，就要有restore。&lt;/p&gt;

&lt;h2&gt;实现平滑的HTML5动画&lt;/h2&gt;
&lt;p&gt;所谓的动画，说白了就是一张一张的图片不断的连续更换。所以，通过编程实现动画也就是不断的通过替换图片，来达到动画的效果。&lt;/p&gt;
&lt;p&gt;但是，这种不断地替换，当然不能使用死循环while(true)来实现，传统的方法是使用setTimeout()和setInterval()方法，这两个方法虽然都提供了毫秒级的精确度，但实际上，却达不到毫秒级（参考此处：&lt;a href=&quot;https://yq.aliyun.com/ziliao/64850&quot; target=&quot;_blank&quot;&gt;setTimeout精度测试&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/SunshinePengChao/article/details/44617143&quot; target=&quot;_blank&quot;&gt;setInterval精度测试&lt;/a&gt;）。所以为了保证动画的平滑度，我们不应该继续使用setTimeout和setInterval方法来实现对时间有着苛刻要求的动画，用什么来代替？我们在下一节讲到。&lt;/p&gt;
&lt;h3&gt;requestAnimationFrame()方法&lt;/h3&gt;
&lt;p&gt;在w3c中的Timing Control for Script-based Animations（参考此处 -&amp;gt; &lt;a href=&quot;https://www.w3.org/TR/animation-timing/&quot; target=&quot;_blank&quot;&gt;w3c-Script-based Animations&lt;/a&gt;）说明中，定义了一个requestAnimationFrame()窗口对象的方法。不同于setTimeout和setInterval方法，requestAnimationFrame是专门用来实现动画的，它使用浏览器的时间间隔进行绘制，不会掉帧。&lt;/p&gt;
&lt;p&gt;这里需要注意的是，requestAnimationFrame方法在窗体没激活或者页签不可见的时候，动画会暂停。&lt;/p&gt;
&lt;p&gt;下面是盗的图，支持requestAnimationFrame方法的浏览器及版本（来源：&lt;a href=&quot;https://www.aliyun.com/jiaocheng/644857.html&quot; target=&quot;_blank&quot;&gt;HTML5 requestAnimationFrame( ) 动画API&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/614311/201808/614311-20180828230516260-801202284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;javascript实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; animate(now)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    DrawGame(now);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    requestAnimationFrame(animate);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;...
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; requestAnimationFrame(animate);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;制作基于时间的运动&lt;/h2&gt;
&lt;p&gt;游戏帧速率是不稳定的，也许此时能够60帧/秒，下一刻也许就成了10帧/秒。游戏帧的速率是变化的，我们不能让游戏帧的速率影像到游戏中物体运动的速率，例如：人物的运动，背景的滚动，子弹的速度等等。所以，游戏中物体的运动必须是基于时间的，并且仅仅依赖于时间（例如：像素/秒），而不是动画帧速率。&lt;/p&gt;
&lt;p&gt;在上一节的实例中，我们可以发现animate有个参数是now，它代表当前绘制的时间，既然有了这个参数，我们就能知道两次时间间隔，从而计算出运动的距离。&lt;/p&gt;
&lt;p&gt;javascript实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; speed = 50&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; lastAnimationTime = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; offsetX = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SetBackgroundOffsetX(now)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     offsetX += speed * (now - lastAnimationTime)/1000
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果一直加下去，背景会慢慢移出屏幕，下面的代码自己写吧&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;结尾&lt;/h2&gt;
&lt;p&gt;到这里，关于图形与动画的内容就差不多结束了，内容不多，代码很少，但是我觉得已经够了，毕竟大部分的基础知识都能在网上找到哈哈。&lt;/p&gt;
&lt;p&gt;本人不是HTML5大佬，如文中有问题，请大家帮忙指正，谢谢大家~&lt;/p&gt;
</description>
<pubDate>Tue, 28 Aug 2018 15:36:00 +0000</pubDate>
<dc:creator>吃西瓜的星星</dc:creator>
<og:description>最近研究了一下出来了很久的HTML5，总结了一下，准备来个系列，文中也许有很多问题，欢迎大家指正。 Canvas介绍 canvas用于在网页中绘制图形的一个元素，具体内容请查看 -&gt; </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuxiaoxiao/p/9551697.html</dc:identifier>
</item>
<item>
<title>HashMap 源码解析(一)之使用、构造以及计算容量 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9551659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9551659.html</guid>
<description>&lt;p&gt;HashMap 是基于哈希表的 Map 接口的实现。 它的使用频率是非常的高。&lt;/p&gt;
&lt;h2 id=&quot;集合和映射&quot;&gt;集合和映射&lt;/h2&gt;
&lt;p&gt;作为集合框架中的一员，在深入之前， 让我们先来简单了解一下集合框架以及 HashMap 在集合框架中的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180828232232556?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;集合框架&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;集合框架分为两种， 即集合(Collections)和映射(Map)&lt;/li&gt;
&lt;li&gt;HashMap 是 AbstractMap 的子类。而 AbstractMap 实现了 Map， 因此它有 Map 的特性。&lt;/li&gt;
&lt;li&gt;通过Map接口， 可以生成集合(Collections)。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那集合(Collections)和映射(Map)是什么关系呢？&lt;br/&gt;从图中我们可以看出， Map 和 Collection 是一种并行的关系。可以这么理解：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;集合（Collectin)是一组&lt;strong&gt;单独&lt;/strong&gt;的元素， 通常应用了某种规则。 List 是按特定顺序来存储元素， 而 Set 存储的是不重复的元素。&lt;/li&gt;
&lt;li&gt;映射(Map)是一系列 “Key-Value” 的集合。&lt;/li&gt;
&lt;li&gt;在 Map 中可以通过一定的方法产生 Collection。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;hashmap-特点&quot;&gt;HashMap 特点&lt;/h2&gt;
&lt;p&gt;很多时候， 我们都说， HashMap 具有如下的特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据键的 HashCode 存储数据， 具有很快的访问速度；&lt;/li&gt;
&lt;li&gt;此类不保证映射的顺序，特别是它不保证该顺序恒久不变；&lt;/li&gt;
&lt;li&gt;允许键为 null, 但最多一条记录；&lt;/li&gt;
&lt;li&gt;允许多条记录的值为 null；&lt;/li&gt;
&lt;li&gt;线程不安全。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;也许你现在对这些特点的印象还不够深刻， 在后续的源码解析过程中， 可以一一的见识庐山真面目。&lt;/p&gt;

&lt;p&gt;HashMap 的使用应该算是很简单的。有以下的方法时使用频率相对来说最高的。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;V put(K key, V value)&lt;/td&gt;
&lt;td&gt;将指定的值与此映射中的指定键关联&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;V get(Object key)&lt;/td&gt;
&lt;td&gt;返回指定键所映射的值；如果对于该键来说，此映射不包含任何映射关系，则返回 null。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;int size()&lt;/td&gt;
&lt;td&gt;返回此映射中的键-值映射关系数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;V remove(Object key)&lt;/td&gt;
&lt;td&gt;从此映射中移除指定键的映射关系（如果存在）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet()&lt;/td&gt;
&lt;td&gt;返回此映射所包含的映射关系的 Set 视图。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Set&lt;/td&gt;
&lt;td&gt;返回此映射中所包含的键的 Set 视图。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以下为一个示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public void testHashMap() {
    HashMap&amp;lt;String, String&amp;gt; animals = new HashMap&amp;lt;String, String&amp;gt;();
    animals.put(&quot;Tom&quot;, &quot;Cat&quot;);
    animals.put(&quot;Tedi&quot;, &quot;Dog&quot;);
    animals.put(&quot;Jerry&quot;, &quot;Mouse&quot;);
    animals.put(&quot;Don&quot;, &quot;Duck&quot;);

    // 遍历方法1 键值视图
    System.out.println(&quot;====================KeySet======================&quot;);
    Set&amp;lt;String&amp;gt; names = animals.keySet();
    for (String name:
         names) {
        System.out.println(&quot;KeySet: &quot;+name+&quot; is a &quot; + animals.get(name));
    }

    // 通过 Entry 进行遍历
    System.out.println(&quot;==================Entry========================&quot;);
    Set&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; entrys= animals.entrySet();
    for(Map.Entry&amp;lt;String, String&amp;gt; entry:entrys){
        System.out.println(&quot;Entry: &quot;+entry.getKey()+&quot; is a &quot; + entry.getValue());
    }
    animals.remove(&quot;Don&quot;);
    // 通过 KeySet Iterator 进行遍历
    System.out.println(&quot;======= KeySet Iterator after remove()=============&quot;);
    Iterator&amp;lt;String &amp;gt; iter = animals.keySet().iterator();
    while (iter.hasNext()) {
        String name = iter.next();
        String pet = animals.get(name);
        System.out.println(&quot; KeySet Iterator : &quot;+name+&quot; is a &quot; + pet);
    }
    animals.clear();
    // 通过 Entry Iterator 进行遍历
    System.out.println(&quot;========== Entry Iterator after clear()==========&quot;);
    Iterator&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; entryIter = animals.entrySet().iterator();
    while (entryIter.hasNext()) {
        Map.Entry&amp;lt;String, String&amp;gt; animal = entryIter.next();
        System.out.println(&quot; Entry Iterator : &quot;+animal.getKey()+&quot; is a &quot; + animal.getValue());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上的例子对 HashMap 的常用的基本方法进行了使用。&lt;/p&gt;

&lt;h2 id=&quot;相关属性&quot;&gt;相关属性&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 最大容量， 当传入容量过大时将被这个值替换
 */
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
/**
 *  HashMap的扩容阈值(=负载因子*table的容量)，在HashMap中存储的Node键值对超过这个数量时，自动扩容容量为原来的二倍
 */
int threshold;
/**
 * 这就是经常提到的负载因子
 */
final float loadFactor;    &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;构造方法&quot;&gt;构造方法&lt;/h2&gt;
&lt;p&gt;HashMap 的构造方法有四个函数， 第四个暂且先不讲。 前三个基本最后基本都是为了初始化 initialCapacity 和 loadFactor 的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法是我们最常用的， 将 loadFactor 和 其余参数定义为默认的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们需要明确指出我们的容量和负载因子时， 使用该函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们需要明确指出我们的容量和负载因子时， 使用该函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public HashMap(int initialCapacity, float loadFactor) {
    // 初始化的容量不能小于0
    if (initialCapacity &amp;lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                           initialCapacity);
    // 初始化容量不大于最大容量
    if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    // 负载因子不能小于 0
    if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                           loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们观察以上的三个构造构造函数， 发现在其中并没有对存储的对象 table 的初始化， 源码中也没有代码块进行初始化或者其他的。其实是延迟到第一次使用时进行初始化， 在 resize() 中进行了初始化。&lt;/p&gt;
&lt;p&gt;在构造函数中，最值得我们深究的就是 tableSizeFor 函数。在初始化时，将这个函数的返回值赋给了 threshold ， 并不是说 threshold 就等于这个值了， 在后续会从新计算 threshold 的&lt;/p&gt;
&lt;h2 id=&quot;tablesizefor-函数&quot;&gt;tableSizeFor 函数&lt;/h2&gt;
&lt;p&gt;该函数是获取大于或等于传入容量 initialCapacity 的2的整数次幂。 试想， 如果我们自己来实现这个函数应该怎么实现呢？&lt;/p&gt;
&lt;h3 id=&quot;一般的算法效率低-不值得借鉴&quot;&gt;一般的算法(效率低， 不值得借鉴)&lt;/h3&gt;
&lt;p&gt;我们要计算比一个数距离最近的二次幂， 大多数人的想法，应该是一次取2的 0 次幂到 31 逐个与当前的数字进行比较， 第一个大于或等于的值就是我们想要的了。函数大致如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int getNearestPowerOfTwo(int cap){
    int num=0;
    for (int i = 0; i &amp;lt; 31; i++) {
        if ((num = (1 &amp;lt;&amp;lt; i)) &amp;gt;= cap){
            break;
        }
    }
    return num;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是我随手写的， 还有很大的改进空间， 在这里就不深究了。&lt;/p&gt;
&lt;h3 id=&quot;tablesizefor-函数算法&quot;&gt;tableSizeFor 函数算法&lt;/h3&gt;
&lt;p&gt;而 HashMap 中的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 2;
    n |= n &amp;gt;&amp;gt;&amp;gt; 4;
    n |= n &amp;gt;&amp;gt;&amp;gt; 8;
    n |= n &amp;gt;&amp;gt;&amp;gt; 16;
    return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先不说这个算法的原理， 来看和我之前的函数相比效率。&lt;/p&gt;
&lt;h3 id=&quot;效率比较&quot;&gt;效率比较&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public void compare(){
    long start = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; 30); i++) {
        getNearestPowerOfTwo(i);
    }

    long end = System.currentTimeMillis();
    System.out.println((end-start));

    long start2 = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; 30); i++) {
        tableSizeFor(i);
    }

    long end2 = System.currentTimeMillis();
    System.out.println((end2-start2));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;8094&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2453&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是时间上相比是 3.3 倍左右。接下来让我们看看其实现原理。&lt;/p&gt;
&lt;h3 id=&quot;tablesizefor-函数原理&quot;&gt;tableSizeFor 函数原理&lt;/h3&gt;
&lt;h4 id=&quot;核心思想&quot;&gt;核心思想&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;将该数的低位二进制位全部变为1， 并加1返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180828232840202?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;例子&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;低位二进制全部变为1&quot;&gt;低位二进制全部变为1&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;int n = cap - 1;
n |= n &amp;gt;&amp;gt;&amp;gt; 1;
n |= n &amp;gt;&amp;gt;&amp;gt; 2;
n |= n &amp;gt;&amp;gt;&amp;gt; 4;
n |= n &amp;gt;&amp;gt;&amp;gt; 8;
n |= n &amp;gt;&amp;gt;&amp;gt; 16;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其原理是：&lt;/p&gt;
&lt;p&gt;首先， 我们忽略最高位之外的所有位数， 看图解说：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180828232325502?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;原理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt;. 右移 1 位，并与之前的数做或运算。 则紧邻的后 1 位变成了 1. 而此时已经确定了 2 个 1， 因此下一次可以右移2位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 2&lt;/strong&gt;. 右移 2 位，并与之前的数做或运算， 则紧邻的后 2 也变成了 1. 而此时已经确定了 4 个 1， 因此下一次可以右移 4 位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 3&lt;/strong&gt;. 右移 4 位，并与之前的数做或运算， 则紧邻的后 4 位也变成了1. 而此时已经确定了8 个 1， 因此下一次可以右移 8 位。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;依次类推， 最后右移了 31 位。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1 + 2 + 4 + 8 + 16 = 31;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于 int 类型去掉符号位之后就只剩下 31 位了，因此， 右移了 31 位之后可以保证最高位后面的数字都为 1。&lt;/p&gt;
&lt;p&gt;第一步为什么要 n = cap - 1？&lt;/p&gt;
&lt;p&gt;如果不做该操作， 则如传入的 cap 是 2 的整数幂， 则返回值是预想的 2 倍。&lt;/p&gt;
</description>
<pubDate>Tue, 28 Aug 2018 15:32:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>主要讲解了 HashMap 的使用和构造， 并详细分析了 tableSizeFor 函数的原理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9551659.html</dc:identifier>
</item>
<item>
<title>分享自己写的基于Dapper的轻量级ORM框架~ - oldli</title>
<link>http://www.cnblogs.com/oldli/p/9551606.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oldli/p/9551606.html</guid>
<description>&lt;p&gt;本项目是一个使用.NET Standard 2.0开发的，基于 Dapper 的轻量级 ORM 框架，包含基本的CRUD以及根据表达式进行一些操作的方法，目前只针对单表，不包含多表连接操作。&lt;br/&gt;github：&lt;a href=&quot;https://github.com/iamoldli/NetSql&quot; class=&quot;uri&quot;&gt;https://github.com/iamoldli/NetSql&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;安装&quot;&gt;2.2、安装&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Install-Package NetSql&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建实体&quot;&gt;2.2、创建实体&lt;/h2&gt;
&lt;p&gt;创建&lt;code&gt;Article&lt;/code&gt;实体类，继承&lt;code&gt;EntityBase&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Article : EntityBase
{
    [Column(&quot;Title&quot;)]
    public string Title1 { get; set; }

    public string Summary { get; set; }

    public string Body { get; set; }

    public Category Category { get; set; }

    public int ReadCount { get; set; }

    public bool IsDeleted { get; set; }

    public DateTime CreatedTime { get; set; }
}

public enum Category
{
    Blog,
    Movie
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;EntityBase&lt;/code&gt;是一个定义好的实体基类，包含一个泛型主键标识，默认是 Int 类型的，也可以指定 long 或者 string 类型&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt; public class Article : EntityBase&amp;lt;string&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;定义数据库上下文dbcontext&quot;&gt;2.3、定义数据库上下文(DbContext)&lt;/h2&gt;
&lt;p&gt;数据库上下文我是模仿的 EF，&lt;code&gt;IDbContextOptions&lt;/code&gt;是数据库上下文配置项接口，默认包含了 SqlServer 的实现&lt;code&gt;DbContextOptions&lt;/code&gt;，如果使用的是 MySql 或者 SQLite，需要额外安装对应的扩展包&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Install-Package NetSql.MySql //MySql&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Install-Package NetSql.SQLite //SQLite&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我定义了一个&lt;code&gt;BlogDbContext&lt;/code&gt;上下文，其中包含一个&lt;code&gt;Articles&lt;/code&gt;数据集&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class BlogDbContext : DbContext
{
    public BlogDbContext(IDbContextOptions options) : base(options)
    {
    }

    public IDbSet&amp;lt;Article&amp;gt; Articles { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据集dbset使用说明&quot;&gt;2.4、数据集(DbSet)使用说明&lt;/h2&gt;
&lt;h3 id=&quot;创建数据库上下文实例&quot;&gt;2.4.1、创建数据库上下文实例&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private readonly BlogDbContext _dbContext;
private readonly IDbSet&amp;lt;Article&amp;gt; _dbSet;

public DbSetTests()
{
    _dbContext = new BlogDbContext(new SQLiteDbContextOptions(&quot;Filename=./Database/Test.db&quot;));
    _dbSet = _dbContext.Set&amp;lt;Article&amp;gt;();

    //预热
    _dbSet.Find().First();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;插入&quot;&gt;2.4.2、插入&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public async void InsertTest()
{
    var article = new Article
    {
        Title1 = &quot;test&quot;,
        Category = Category.Blog,
        Summary = &quot;这是一篇测试文章&quot;,
        Body = &quot;这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章&quot;,
        ReadCount = 10,
        IsDeleted = true,
        CreatedTime = DateTime.Now
    };

    await _dbSet.InsertAsync(article);

    Assert.True(article.Id &amp;gt; 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;批量插入&quot;&gt;2.4.3、批量插入&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public void BatchInsertTest()
{
    var sw = new Stopwatch();
    sw.Start();

    var tran = _dbContext.BeginTransaction();

    for (var i = 0; i &amp;lt; 10000; i++)
    {
        var article = new Article
        {
            Title1 = &quot;test&quot; + i,
            Category = i % 3 == 1 ? Category.Blog : Category.Movie,
            Summary = &quot;这是一篇测试文章&quot;,
            Body = &quot;这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章&quot;,
            ReadCount = 10,
            IsDeleted = i % 2 == 0,
            CreatedTime = DateTime.Now
        };

        _dbSet.InsertAsync(article, tran);
    }

    tran.Commit();

    sw.Stop();

    var s = sw.ElapsedMilliseconds;

    Assert.True(s &amp;gt; 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;根据主键删除&quot;&gt;2.4.4、根据主键删除&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public void DeleteTest()
{
    var b = _dbSet.DeleteAsync(3).Result;

    Assert.True(b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;根据表达式删除&quot;&gt;2.4.5、根据表达式删除&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public async void DeleteWhereTest()
{
    var b = await _dbSet.Find(m =&amp;gt; m.Id &amp;gt; 10).Delete();

    Assert.True(b);
}

[Fact]
public async void DeleteWhereTest()
{
    var b = await _dbSet.Find(m =&amp;gt; m.Id &amp;gt; 10)
        .Where(m =&amp;gt; m.CreatedTime &amp;gt; DateTime.Now).Delete();

    Assert.True(b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改&quot;&gt;2.4.6、修改&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public async void UpdateTest()
{
    var article = await _dbSet.Find().First();
    article.Title1 = &quot;修改测试&quot;;

    var b = await _dbSet.UpdateAsync(article);

    Assert.True(b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;根据表达式修改实体部分属性&quot;&gt;2.4.7、根据表达式修改实体部分属性&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public async void UpdateWhereTest()
{
    var b = await _dbSet.Find(m =&amp;gt; m.Id == 1000).Update(m =&amp;gt; new Article
    {
        Title1 = &quot;hahahaah&quot;,
        ReadCount = 1000
    });

    Assert.True(b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;根据主键查询单个实体&quot;&gt;2.4.8、根据主键查询单个实体&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public void GetTest()
{
    var article = _dbSet.GetAsync(100).Result;

    Assert.NotNull(article);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;根据表达式查询单条数据&quot;&gt;2.4.9、根据表达式查询单条数据&lt;/h3&gt;
&lt;p&gt;该方法返回结果集中的第一条数据&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public async void GetWehreTest()
{
    var article = await _dbSet.Find(m =&amp;gt; m.Id &amp;gt; 100).First();

    Assert.NotNull(article);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用表达式&quot;&gt;2.4.10、使用表达式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;IDbSet&lt;/code&gt;的&lt;code&gt;Find&lt;/code&gt;方法会返回一个&lt;code&gt;INetSqlQueryable&lt;/code&gt;对象，这个对象是模仿的 EF 里面的&lt;code&gt;IQueryable&lt;/code&gt;，虽然有些不伦不类，但是是按照适合自己的方式设计的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;INetSqlQueryable&lt;/code&gt;目前包含以下方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Where&lt;/code&gt;&lt;/strong&gt;：用于添加过滤条件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var query =  _dbSet.Find().Where(m =&amp;gt; m.Id &amp;gt; 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;WhereIf&lt;/code&gt;&lt;/strong&gt;：根据指定条件来添加过滤条件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var query = _dbSet.Find().WhereIf(id &amp;gt; 1, m =&amp;gt; m.Id &amp;gt; 200);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;OrderBy&lt;/code&gt;&lt;/strong&gt;：用于添加排序规则&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var query = _dbSet.Find(m =&amp;gt; m.Id &amp;gt; 200 &amp;amp;&amp;amp; m.Id &amp;lt; 1000).OrderBy(m =&amp;gt; m.Id, SortType.Desc);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Limit&lt;/code&gt;&lt;/strong&gt;：该方法包含两个参数&lt;code&gt;skip&lt;/code&gt;和&lt;code&gt;take&lt;/code&gt;，标识跳过 skip 条数据，取 take 条数据&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var query = _dbSet.Find(m =&amp;gt; m.Id &amp;gt; 100 &amp;amp;&amp;amp; m.Id &amp;lt; 120).Limit(5, 10);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Select&lt;/code&gt;&lt;/strong&gt;：选择要返回的列&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var query = _dbSet.Find().Select(m =&amp;gt; new { m.Id, m.Title1 }).Limit(0, 10);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法都是用于构造&lt;code&gt;INetSqlQueryable&lt;/code&gt;的，下面的方法则是执行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Max&lt;/code&gt;&lt;/strong&gt;：查询最大值&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var maxReadCount = _dbSet.Find().Max(m =&amp;gt; m.ReadCount).Result;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Min&lt;/code&gt;&lt;/strong&gt;：查询最小值&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var maxReadCount = _dbSet.Find().Min(m =&amp;gt; m.ReadCount).Result;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Count&lt;/code&gt;&lt;/strong&gt;：查询数量&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var count = _dbSet.Find(m =&amp;gt; m.Id &amp;gt; 1000).Count().Result;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Exists&lt;/code&gt;&lt;/strong&gt;：判断是否存在&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var b = _dbSet.Find(m =&amp;gt; m.Id &amp;gt; 1000).Exists().Result;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;First&lt;/code&gt;&lt;/strong&gt;：获取第一条数据&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var article = _dbSet.Find(m =&amp;gt; m.Id &amp;gt; 100 &amp;amp;&amp;amp; m.Id &amp;lt; 120).First().Result;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Delete&lt;/code&gt;&lt;/strong&gt;：删除数据&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var b = _dbSet.Find(m =&amp;gt; m.Id &amp;gt; 1000).Delete().Result;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Update&lt;/code&gt;&lt;/strong&gt;：更新数据&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var b = await _dbSet.Find(m =&amp;gt; m.Id == 1000).Update(m =&amp;gt; new Article
{
    Title1 = &quot;hahahaah&quot;,
    ReadCount = 1000
});&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ToList&lt;/code&gt;&lt;/strong&gt;：获取结果集&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var list = await _dbSet.Find(m =&amp;gt; m.Id &amp;gt; 100 &amp;amp;&amp;amp; m.Id &amp;lt; 120).ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;特性&quot;&gt;3、特性&lt;/h2&gt;
&lt;h3 id=&quot;表别名以及列名&quot;&gt;表别名以及列名&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Table(&quot;blog_article&quot;)]
public class Article : EntityBase
{
    [Column(&quot;Title&quot;)]
    public string Title1 { get; set; }

    public string Summary { get; set; }

    public string Body { get; set; }

    public Category Category { get; set; }

    public int ReadCount { get; set; }

    public bool IsDeleted { get; set; }

    public DateTime CreatedTime { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;指定主键&quot;&gt;指定主键&lt;/h3&gt;
&lt;p&gt;可以通过&lt;code&gt;KeyAttribute&lt;/code&gt;来指定某个字段为主键&lt;/p&gt;
&lt;h2 id=&quot;泛型仓储repository&quot;&gt;4、泛型仓储(Repository)&lt;/h2&gt;
&lt;p&gt;平时开发时用到伪 DDD 比较多，所以框架提供了一个泛型仓储接口&lt;code&gt;IRepository&lt;/code&gt;以及一个抽象实现&lt;code&gt;RepositoryAbstract&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 判断是否存在
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;where&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;transaction&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
Task&amp;lt;bool&amp;gt; ExistsAsync(Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; where, IDbTransaction transaction = null);

/// &amp;lt;summary&amp;gt;
/// 新增
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;entity&quot;&amp;gt;实体&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;transaction&quot;&amp;gt;事务&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
Task&amp;lt;bool&amp;gt; AddAsync(TEntity entity, IDbTransaction transaction = null);

/// &amp;lt;summary&amp;gt;
/// 批量新增
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;list&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;transaction&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
Task&amp;lt;bool&amp;gt; AddAsync(List&amp;lt;TEntity&amp;gt; list, IDbTransaction transaction = null);

/// &amp;lt;summary&amp;gt;
/// 删除
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;transaction&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
Task&amp;lt;bool&amp;gt; DeleteAsync(dynamic id, IDbTransaction transaction = null);

/// &amp;lt;summary&amp;gt;
/// 更新
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;entity&quot;&amp;gt;实体&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;transaction&quot;&amp;gt;事务&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
Task&amp;lt;bool&amp;gt; UpdateAsync(TEntity entity, IDbTransaction transaction = null);

/// &amp;lt;summary&amp;gt;
/// 根据主键查询
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;transaction&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
Task&amp;lt;TEntity&amp;gt; GetAsync(dynamic id, IDbTransaction transaction = null);

/// &amp;lt;summary&amp;gt;
/// 根据表达式查询单条记录
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;where&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;transaction&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
Task&amp;lt;TEntity&amp;gt; GetAsync(Expression&amp;lt;Func&amp;lt;TEntity,bool&amp;gt;&amp;gt; where, IDbTransaction transaction = null);

/// &amp;lt;summary&amp;gt;
/// 分页查询
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;paging&quot;&amp;gt;分页&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;where&quot;&amp;gt;过滤条件&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;transaction&quot;&amp;gt;事务&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
Task&amp;lt;List&amp;lt;TEntity&amp;gt;&amp;gt; PaginationAsync(Paging paging = null, Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; where = null, IDbTransaction transaction = null);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RepositoryAbstract&lt;/code&gt;中包含实体对应的数据集&lt;code&gt;IDbSet&lt;/code&gt;以及数据上限为&lt;code&gt;IDbContext&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected readonly IDbSet&amp;lt;TEntity&amp;gt; Db;
protected readonly IDbContext DbContext;

protected RepositoryAbstract(IDbContext dbContext)
{
    DbContext = dbContext;
    Db = dbContext.Set&amp;lt;TEntity&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于事务，建议使用工作单元&lt;code&gt;IUnitOfWork&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IUnitOfWork
{
    /// &amp;lt;summary&amp;gt;
    /// 打开一个事务
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    IDbTransaction BeginTransaction();

    /// &amp;lt;summary&amp;gt;
    /// 提交
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    void Commit();

    /// &amp;lt;summary&amp;gt;
    /// 回滚
    /// &amp;lt;/summary&amp;gt;
    void Rollback();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;项目已经包含了一个实现&lt;code&gt;UnitOfWork&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;仓储使用方法&quot;&gt;6、仓储使用方法&lt;/h2&gt;
&lt;h3 id=&quot;定义仓储&quot;&gt;6.1、定义仓储&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IArticleRepository : IRepository&amp;lt;Article&amp;gt;
{
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建仓储实例&quot;&gt;6.2、创建仓储实例&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private readonly IArticleRepository _repository;

public RepositoryTest()
{
    var dbContext = new BlogDbContext(new SQLiteDbContextOptions(&quot;Filename=./Database/Test.db&quot;));
    _repository = new ArticleRepository(dbContext);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;新增&quot;&gt;6.3、新增&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public async void AddTest()
{
    var article = new Article
    {
        Title1 = &quot;test&quot;,
        Category = Category.Blog,
        Summary = &quot;这是一篇测试文章&quot;,
        Body = &quot;这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章&quot;,
        ReadCount = 10,
        IsDeleted = true,
        CreatedTime = DateTime.Now
    };

    await _repository.AddAsync(article);

    Assert.True(article.Id &amp;gt; 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;批量增加&quot;&gt;6.4、批量增加&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public void BatchInsertTest()
{
    var list = new List&amp;lt;Article&amp;gt;();
    for (var i = 0; i &amp;lt; 10000; i++)
    {
        var article = new Article
        {
            Title1 = &quot;test&quot; + i,
            Category = i % 3 == 1 ? Category.Blog : Category.Movie,
            Summary = &quot;这是一篇测试文章&quot;,
            Body = &quot;这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章这是一篇测试文章&quot;,
            ReadCount = 10,
            IsDeleted = i % 2 == 0,
            CreatedTime = DateTime.Now
        };
        list.Add(article);
    }
    var sw = new Stopwatch();
    sw.Start();

    _repository.AddAsync(list);

    sw.Stop();
    var s = sw.ElapsedMilliseconds;

    Assert.True(s &amp;gt; 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除&quot;&gt;6.5、删除&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public async void DeleteTest()
{
    var b = await _repository.DeleteAsync(2);

    Assert.True(b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改-1&quot;&gt;6.6、修改&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public async void UpdateTest()
{
    var article = await _repository.GetAsync(2);
    article.Title1 = &quot;修改测试&quot;;

    var b = await _repository.UpdateAsync(article);

    Assert.True(b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分页查询&quot;&gt;6.7、分页查询&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public async void PaginationTest()
{
    var paging = new Paging(1, 20);
    var list = await _repository.PaginationAsync(paging, m =&amp;gt; m.Id &amp;gt; 1000);

    Assert.True(paging.TotalCount &amp;gt; 0);
}&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Tue, 28 Aug 2018 15:15:00 +0000</pubDate>
<dc:creator>oldli</dc:creator>
<og:description>本项目是一个使用.NET Standard 2.0开发的，基于 Dapper 的轻量级 ORM 框架，包含基本的CRUD以及根据表达式进行一些操作的方法，目前只针对单表，不包含多表连接操作。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/oldli/p/9551606.html</dc:identifier>
</item>
<item>
<title>玩转 lua in Redis - sunsky303</title>
<link>http://www.cnblogs.com/sunsky303/p/9551526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunsky303/p/9551526.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;        Redis学了一段时间了，基本的东西都没问题了。从今天开始讲写一些redis和lua脚本的相关的东西，lua这个脚本是一个好东西，可以运行在任何平台上，也可以嵌入到大多数语言当中，来扩展其功能。lua脚本是用C语言写的，体积很小，运行速度很快，并且每次的执行都是作为一个原子事务来执行的，我们可以在其中做很多的事情。由于篇幅很多，一次无法概述全部，这个系列可能要通过多篇文章的形式来写，好了，今天我们进入正题吧。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、Lua简介&lt;/strong&gt;&lt;br/&gt;    &lt;br/&gt;        Lua 是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组，由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo所组成并于1993年开发。 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。Lua 有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。&lt;/p&gt;&lt;p&gt;       Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，这使得Lua在应用程序中可以被广泛应用。不仅仅作为扩展脚本，也可以作为普通的配置文件，代替XML,ini等文件格式，并且更容易理解和维护。 Lua由标准C编写而成，代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。一个完整的Lua解释器不过200k，在目前所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三、使用Lua脚本的好处&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;       1、减少网络开销：可以将多个请求通过脚本的形式一次发送，减少网络时延和请求次数。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;       2、原子性的操作：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;       3、代码复用：客户端发送的脚步会永久存在redis中，这样，其他客户端可以复用这一脚本来完成相同的逻辑。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;       4、速度快：见 与其它语言的性能比较, 还有一个 JIT编译器可以显著地提高多数任务的性能; 对于那些仍然对性能不满意的人, 可以把关键部分使用C实现, 然后与其集成, 这样还可以享受其它方面的好处。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;       5、可以移植：只要是有ANSI C 编译器的平台都可以编译，你可以看到它可以在几乎所有的平台上运行:从 Windows 到Linux，同样Mac平台也没问题, 再到移动平台、游戏主机，甚至浏览器也可以完美使用 (翻译成JavaScript).&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;       6、源码小巧：20000行C代码，可以编译进182K的可执行文件，加载快，运行快。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;四、redis和lua整合详解&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     &lt;strong&gt; 1、调用Lua脚本的语法：&lt;/strong&gt;&lt;br/&gt;              $ redis-cli --eval path/to/redis.lua KEYS[1] KEYS[2] , ARGV[1] ARGV[2] ...&lt;/p&gt;&lt;p&gt;              --eval，告诉redis-cli读取并运行后面的lua脚本&lt;br/&gt;               path/to/redis.lua，是lua脚本的位置&lt;br/&gt;               KEYS[1] KEYS[2]，是要操作的键，可以指定多个，在lua脚本中通过KEYS[1], KEYS[2]获取&lt;br/&gt;               ARGV[1] ARGV[2]，参数，在lua脚本中通过ARGV[1], ARGV[2]获取。&lt;/p&gt;&lt;p&gt;      &lt;strong&gt;        注意： KEYS和ARGV中间的 ',' 两边的空格，不能省略。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;             &lt;strong&gt;redis支持大部分Lua标准库&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;库名&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;Base&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;提供一些基础函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;String&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;提供用于字符串操作的函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;Table&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;提供用于表操作的函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;Math&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;提供数学计算函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;Debug&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;提供用于调试的函数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br/&gt;       &lt;strong&gt;2、在脚本中调用redis命令&lt;/strong&gt;&lt;br/&gt;               在脚本中可以使用redis.call函数调用Redis命令&lt;/p&gt;&lt;p&gt;              redis.call('set', 'foo', 'bar')&lt;br/&gt;              local value=redis.call('get', 'foo') --value的值为bar&lt;/p&gt;&lt;p&gt;              redis.call函数的返回值就是Redis命令的执行结果&lt;/p&gt;&lt;p&gt;              Redis命令的返回值有5种类型，redis.call函数会将这5种类型的回复转换成对应的Lua的数据类型，具体的对应规则如下（空结果比较特殊，其对应Lua的false）&lt;/p&gt;
&lt;p&gt;               &lt;strong&gt;redis返回值类型和Lua数据类型转换规则&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;redis返回值类型&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Lua数据类型&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;整数回复&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;数字类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;字符串回复&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;字符串类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;多行字符串回复&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;table类型(数组形式)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;状态回复&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;table类型(只有一个ok字段存储状态信息)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;错误回复&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;table类型(只有一个err字段存储错误信息)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br/&gt;                  redis还提供了redis.pcall函数，功能与redis.call相同，唯一的区别是当命令执行出错时，redis.pcall会记录错误并继续执行，而redis.call会直接返回错误，不会继续执行。在脚本中可以使用return语句将值返回给客户端，如果没有执行return语句则默认返回nil&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                  Lua数据类型和redis返回值类型转换规则&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Lua数据类型&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;redis返回值类型&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;数字类型&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;整数回复(Lua的数字类型会被自动转换成整数)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;字符串类型&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;字符串回复&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;table类型(数组形式)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;多行字符串回复&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;table类型(只有一个ok字段存储状态信息)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;状态回复&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;table类型(只有一个err字段存储错误信息)&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;错误回复&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br/&gt;        &lt;strong&gt;3、脚本相关命令&lt;/strong&gt;&lt;br/&gt;             &lt;strong&gt;EVAL语法：&lt;/strong&gt; &lt;strong&gt;eval script numkeys key [key ...] arg [arg ...]&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;              通过key和arg这两类参数向脚本传递数据，它们的值在脚本中分别使用KEYS和ARGV两个表类型的全局变量访问。&lt;/p&gt;
&lt;p&gt;              &lt;strong&gt;script&lt;/strong&gt;： 是lua脚本&lt;/p&gt;
&lt;p&gt;              &lt;strong&gt;numkeys&lt;/strong&gt;：表示有几个key，分别是KEYS[1],KEYS[2]...，如果有值，从第numkeys+1个开始就是参数值，ARGV[1],ARGV[2]...&lt;/p&gt;&lt;p&gt;             &lt;strong&gt;注意： EVAL命令依据参数numkeys来将其后面的所有参数分别存入脚本中KEYS和ARGV两个table类型的全局变量。当脚本不需要任何参数时，也不能省略这个参数(设为0)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
       192.168.127.128:6379&amp;gt;eval &quot;return redis.call('set',KEYS[1],ARGV[1])&quot; 1 name liulei
       OK

       192.168.127.128:6379&amp;gt;get name
       &quot;liulei&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       &lt;strong&gt;4、 EVALSHA命令&lt;/strong&gt;&lt;br/&gt;              在脚本比较长的情况下，如果每次调用脚本都需要将整个脚本传给Redis会占用较多的带宽。为了解决这个问题，Redis提供了EVALSHA命令，允许开发者通过脚本内容的SHA1摘要来执行脚本，该命令的用法和EVAL一样，只不过是将脚本内容替换成脚本内容的SHA1摘要。&lt;/p&gt;&lt;p&gt;             Redis在执行EVAL命令时会计算脚本的SHA1摘要并记录在脚本缓存中，执行EVALSHA命令时Redis会根据提供的摘要从脚本缓存中查找对应的脚本内容，如果找到了则执行脚本，否则会返回错误：&quot;NOSCRIPT No matching script. Please use EVAL.&quot;&lt;/p&gt;&lt;p&gt;             &lt;strong&gt;在程序中使用EVALSHA命令的一般流程如下。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                 1）、先计算脚本的SHA1摘要，并使用EVALSHA命令执行脚本。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;                 2）、获得返回值，如果返回“NOSCRIPT”错误则使用EVAL命令重新执行脚本。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;              虽然这一流程略显麻烦，但值得庆幸的是很多编程语言的Redis客户端都会代替开发者完成这一流程。执行EVAL命令时，先尝试执行EVALSHA命令，如果失败了才会执行EVAL命令。&lt;/p&gt;&lt;p&gt;               SCRIPTLOAD &quot;lua-script&quot;  将脚本加入缓存，但不执行， 返回：脚本的SHA1摘要&lt;/p&gt;&lt;p&gt;               SCRIPT EXISTS lua-script-sha1   判断脚本是否已被缓存&lt;/p&gt;&lt;p&gt;       &lt;strong&gt;5、 SCRIPT FLUSH（该命令不区分大小写）&lt;/strong&gt;&lt;br/&gt;               清空脚本缓存，redis将脚本的SHA1摘要加入到脚本缓存后会永久保留，不会删除，但可以手动使用SCRIPT FLUSH命令清除全部脚本缓存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
       192.168.127.128:6379&amp;gt;script flush
       OK

       192.168.127.128:6379&amp;gt;SCRIPT FLUSH
       OK
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;      &lt;strong&gt; 6、SCRIPT KILL（该命令不区分大小写）&lt;/strong&gt;&lt;br/&gt;              强制终止当前脚本的执行。 但是，如果当前执行的脚步对redis的数据进行了写操作，则SCRIPT KILL命令不会终止脚本的运行，以防止脚本只执行了一部分。脚本中的所有命令，要么都执行，要么都不执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
       192.168.127.128:6379&amp;gt;script kill
      (error)NOTBUSY No scripts in execution right now

      192.168.127.128:6379&amp;gt;SCRIPT KILL
      (error)NOTBUSY No scripts in execution right now
       //这是当前没有脚本在执行，所以提示该错误
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       &lt;strong&gt;7、lua-time-limit 5000（redis.conf配置文件中）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;              为了防止某个脚本执行时间过长导致Redis无法提供服务（比如陷入死循环），Redis提供了lua-time-limit参数限制脚本的最长运行时间，默认为5秒钟。当脚本运行时间超过这一限制后，Redis将开始接受其他命令但不会执行（以确保脚本的原子性，因为此时脚本并没有被终止），而是会返回“BUSY”错误。&lt;/p&gt;
</description>
<pubDate>Tue, 28 Aug 2018 14:56:00 +0000</pubDate>
<dc:creator>sunsky303</dc:creator>
<og:description>一、引言 Redis学了一段时间了，基本的东西都没问题了。从今天开始讲写一些redis和lua脚本的相关的东西，lua这个脚本是一个好东西，可以运行在任何平台上，也可以嵌入到大多数语言当中，来扩展其功</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunsky303/p/9551526.html</dc:identifier>
</item>
</channel>
</rss>