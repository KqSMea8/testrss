<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>vue.js+socket.io+express+mongodb打造在线聊天[二] - 一曲笙箫</title>
<link>http://www.cnblogs.com/clm960227/p/Mirok.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clm960227/p/Mirok.html</guid>
<description>&lt;h2 id=&quot;articleHeader0&quot;&gt;vue.js+socket.io+express+mongodb打造在线聊天[二]&lt;/h2&gt;
&lt;h2 id=&quot;articleHeader1&quot;&gt;在线地址观看&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.chenleiming.com/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;http://www.chenleiming.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;articleHeader2&quot;&gt;github地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/clm960227/vuechat&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;https://github.com/clm960227/...&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;articleHeader3&quot;&gt;&lt;strong&gt;有喜欢的小哥哥，小姐姐请反手来个star，谢谢！有issue的欢迎提出&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br/&gt;本项目基于vue.js+socket.io+express+mongodb实现的聊天效果， 界面以及功能参考QQ，微信&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术栈&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前端： vue,vue-router,vuex,axios&lt;/li&gt;
&lt;li&gt;构建： webpack，vue-cli&lt;/li&gt;
&lt;li&gt;后端： express，multer(上传图片)，cors(跨域处理), superagent(调用机器人接口),mongoose(操作数据库)&lt;/li&gt;
&lt;li&gt;通讯： socket.io&lt;/li&gt;
&lt;li&gt;数据库： mongodb&lt;/li&gt;
&lt;li&gt;css预处理器： sass&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;功能列表&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户注册&lt;/li&gt;
&lt;li&gt;用户登录&lt;/li&gt;
&lt;li&gt;群聊&lt;/li&gt;
&lt;li&gt;群聊中@小美 和机器人聊天 （注意@小美和消息中间要有空格）&lt;/li&gt;
&lt;li&gt;机器人聊天&lt;/li&gt;
&lt;li&gt;留言板&lt;/li&gt;
&lt;li&gt;更换主题颜色&lt;/li&gt;
&lt;li&gt;进出聊天群提醒&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;功能展示&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;登录与注册&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img src=&quot;https://segmentfault.com/img/bV79cZ?w=247&amp;amp;h=432&quot; alt=&quot;&quot; data-src=&quot;/img/bV79cZ?w=247&amp;amp;h=432&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img src=&quot;https://segmentfault.com/img/bV79c8?w=247&amp;amp;h=432&quot; alt=&quot;&quot; data-src=&quot;/img/bV79c8?w=247&amp;amp;h=432&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;群聊中与机器人聊天&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img src=&quot;https://segmentfault.com/img/bV79c9?w=247&amp;amp;h=432&quot; alt=&quot;&quot; data-src=&quot;/img/bV79c9?w=247&amp;amp;h=432&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;机器人聊天&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img src=&quot;https://segmentfault.com/img/bV79dg?w=247&amp;amp;h=432&quot; alt=&quot;&quot; data-src=&quot;/img/bV79dg?w=247&amp;amp;h=432&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img src=&quot;https://segmentfault.com/img/bV79dm?w=247&amp;amp;h=432&quot; alt=&quot;&quot; data-src=&quot;/img/bV79dm?w=247&amp;amp;h=432&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;更换主题&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img src=&quot;https://segmentfault.com/img/bV79do?w=247&amp;amp;h=432&quot; alt=&quot;&quot; data-src=&quot;/img/bV79do?w=247&amp;amp;h=432&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;好啦~功能差不多就这些啦，这次添加了进出群提醒，主题颜色更换还有布局的一些调整。废话不多说啦，接下来该介绍介绍核心部分，以免被各位小哥哥，小姐姐打。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端聊天代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const infoObj = {
        status: 'userstate',
        nickname: this.getUserinfo.nickname,
        roomId: this.roomId
    }
    this.socket.emit('join-room', infoObj)
    this.socket.on('join-room', (joinInfo) =&amp;gt; {
        this.MsgList.push(joinInfo)
        this.$nextTick(() =&amp;gt; {
                this.msgDOM.scrollTop = this.msgDOM.scrollHeight
        })
    })
    // 聊天
    this.socket.on('chat-msg', (msg) =&amp;gt; {
        console.log(msg)
        this.MsgList.push(msg)
        this.$nextTick(() =&amp;gt; {
            this.msgDOM.scrollTop = this.msgDOM.scrollHeight
        })
    })
    // 离开房间
    this.socket.on('leave-room', (leaveInfo) =&amp;gt; {
        this.MsgList.push(leaveInfo)
        this.$nextTick(() =&amp;gt; {
            this.msgDOM.scrollTop = this.msgDOM.scrollHeight
        })
    })
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;后端聊天代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
io.on('connection', (socket) =&amp;gt; {
  // 进入房间
  socket.on('join-room', (info) =&amp;gt; {
    // 添加到房间
    socket.join(info.roomId)
    const joinInfo = {
      status: info.status,
      text: info.nickname + '加入了群聊'
    }
    socket.to(info.roomId).broadcast.emit('join-room', joinInfo)
  })
  // 群聊天
  socket.on('chat-msg', (msg) =&amp;gt; {
    saveChatMsg(msg, () =&amp;gt; {
      io.to(msg.roomId).emit('chat-msg', msg)
      // 分割聊天消息，判断是否与机器人聊天
      const msgArr = msg.text.split(' ')
      const robotParam = {
        userId: msg.userId,
        roomId: msg.roomId || null,
        timeStamp: msg.timeStamp + 1 || null,
        text: msgArr[1]
      }
      if (msgArr[0] === '@小美') {
        getRobotMsg(robotParam, (robotmsg) =&amp;gt; {
          saveChatMsg(robotmsg)
          io.to(msg.roomId).emit('chat-msg', robotmsg)
        })
      }
    })
  })
  // 机器人聊天
  socket.on('robot-msg', (msg) =&amp;gt; {
    const robotParam = {
      userId: msg.userId,
      timeStamp: msg.timeStamp,
      text: msg.text
    }
    getRobotMsg(robotParam, (robotmsg) =&amp;gt; {
      socket.emit('robot-msg', robotmsg)
    })
  })
  // 离开房间
  socket.on('leave-room', (info) =&amp;gt; {
    socket.leave(info.roomId)
    const leaveInfo = {
      status: info.status,
      text: info.nickname + '离开了群聊'
    }
    socket.to(info.roomId).broadcast.emit('leave-room', leaveInfo)
  })
})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;vuex&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;69&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
export default new Vuex.Store({
    state: {
        // 主题颜色
        themeColor: '',
        // 存放用户信息
        userInfo: {
            userId: '',
            nickname: '',
            headPic: ''
        },
        // 机器人信息
        robot: {
            Info: {
                userId: 'robot',
                nickname: '小美',
                headPic: '/static/img/robot-headpic.jpg'
            },
            // 机器人打招呼
            greetMsg: 'hi~ 我是机器人小美，有什么可以帮您的嘛？'
        }
    },
    getters: {
        // 获取主题颜色
        getThemeColor: state =&amp;gt; {
            return state.themeColor
        },
        // 获取登录用户信息
        getUserinfo: state =&amp;gt; {
            return state.userInfo
        },
        // 获取机器人信息
        getRobotinfo: state =&amp;gt; {
            return state.robot.Info
        },
        // 获取机器人欢迎语
        getRobotGreetMsg: state =&amp;gt; {
            return state.robot.greetMsg
        }
    },
    mutations: {
        // 设置用户信息
        setUserinfo(state, userInfo) {
            state.userInfo.userId = userInfo.userId
            state.userInfo.nickname = userInfo.nickname
            state.userInfo.headPic = userInfo.headPic
        },
        // 设置聊天记录
        setHistoryMsg(state, msgList) {
            state.msgInfo = msgList
        },
        // 设置主题颜色
        setThemeColor(state, color) {
            state.themeColor = color
        }
    },
    actions: {
        // 注册用户
        async register({commite}, data) {
            const res = await url.register(data)
            if (res.data.state === 0) {
                return {
                    status: 'fail',
                    data: res.data.data
                }
            }
            return {
                status: 'success',
                data: res.data.data
            }
        },
        // 登录用户
        async login({commite}, data) {
            const res = await url.login(data)
            if (res.data.state === 0) {
                return {
                    status: 'fail',
                    data: res.data.data
                }
            }
            return {
                status: 'success',
                data: res.data.data
            }
        },
        // 上传图片
        async upload({commite}, data) {
            await url.upload(data)
        },
        // 获取聊天记录
        async getHistoryChatMsg({commite}, data) {
            const res = await url.gethistorychatmsg(data)
            return {
                status: 'success',
                data: res.data.data.msgList
            }
        },
        // 保存留言
        async saveLeaveMsg({commite}, data) {
            const res = await    url.saveleavemsg(data)
            return {
                status: res.data.data.stateText
            }
        },
        // 获取留言数据
        async getLeaveMsg({commite}) {
            const res = await url.getleavemsg()
            return {
                status: res.data.data.stateText,
                data: res.data.data.leaveMsg
            }
        }
    }
})
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 10 Apr 2018 15:17:00 +0000</pubDate>
<dc:creator>一曲笙箫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clm960227/p/Mirok.html</dc:identifier>
</item>
<item>
<title>写给 Android 应用工程师的 Binder 原理剖析 - BaronZhang</title>
<link>http://www.cnblogs.com/baronzhang/p/8784458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baronzhang/p/8784458.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/android/binder/header.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;一. 前言&lt;/h2&gt;
&lt;p&gt;这篇文章我酝酿了很久，参考了很多资料，读了很多源码，却依旧不敢下笔。生怕自己理解上还有偏差，对大家造成误解，贻笑大方。又怕自己理解不够透彻，无法用清晰直白的文字准确的表达出 Binder 的设计精髓。直到今天提笔写作时还依旧战战兢兢。&lt;/p&gt;
&lt;p&gt;Binder 之复杂远远不是一篇文章就能说清楚的，本文想站在一个更高的维度来俯瞰 Binder 的设计，最终帮助大家形成一个完整的概念。对于应用层开发的同学来说，理解到本文这个程度也就差不多了。希望更加深入理解 Binder 实现机制的，可以阅读文末的参考资料以及相关源码。&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;二. Binder 概述&lt;/h2&gt;
&lt;p&gt;简单介绍下什么是 Binder。Binder 是一种进程间通信机制，基于开源的 OpenBinder 实现；OpenBinder 起初由 Be Inc. 开发，后由 Plam Inc. 接手。从字面上来解释 Binder 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。对于 Binder 更全面的定义，等我们介绍完 Binder 通信原理后再做详细说明。&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;1.1 为什么必须理解 Binder ？&lt;/h3&gt;
&lt;p&gt;作为 Android 工程师的你，是不是常常会有这样的疑问：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么 Activity 间传递对象需要序列化？&lt;/li&gt;
&lt;li&gt;Activity 的启动流程是什么样的？&lt;/li&gt;
&lt;li&gt;四大组件底层的通信机制是怎样的？&lt;/li&gt;
&lt;li&gt;AIDL 内部的实现原理是什么？&lt;/li&gt;
&lt;li&gt;插件化编程技术应该从何学起？等等...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些问题的背后都与 Binder 有莫大的关系，要弄懂上面这些问题理解 Bidner 通信机制是必须的。&lt;/p&gt;
&lt;p&gt;我们知道 Android 应用程序是由 Activity、Service、Broadcast Receiver 和 Content Provide 四大组件中的一个或者多个组成的。有时这些组件运行在同一进程，有时运行在不同的进程。这些进程间的通信就依赖于 Binder IPC 机制。不仅如此，Android 系统对应用层提供的各种服务如：ActivityManagerService、PackageManagerService 等都是基于 Binder IPC 机制来实现的。Binder 机制在 Android 中的位置非常重要，毫不夸张的说理解 Binder 是迈向 Android 高级工程的第一步。&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;1.2 为什么是 Binder ?&lt;/h3&gt;
&lt;p&gt;Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于&lt;strong&gt;性能&lt;/strong&gt;、&lt;strong&gt;稳定性&lt;/strong&gt;和&lt;strong&gt;安全性&lt;/strong&gt;几方面的原因。&lt;/p&gt;
&lt;h4 id=&quot;toc_5&quot;&gt;性能&lt;/h4&gt;
&lt;p&gt;首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。&lt;/p&gt;
&lt;p&gt;注：各种IPC方式数据拷贝次数，此表来源于&lt;a href=&quot;http://blog.csdn.net/universus/article/details/6211589&quot;&gt;Android Binder 设计与实现 - 设计篇&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;IPC方式&lt;/th&gt;
&lt;th&gt;数据拷贝次数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;共享内存&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Binder&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Socket/管道/消息队列&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;toc_6&quot;&gt;稳定性&lt;/h4&gt;
&lt;p&gt;再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。&lt;/p&gt;
&lt;h4 id=&quot;toc_7&quot;&gt;安全性&lt;/h4&gt;
&lt;p&gt;另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。&lt;/p&gt;
&lt;p&gt;基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后用一张表格来总结下 Binder 的优势：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;优势&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;只需要一次数据拷贝，性能上仅次于共享内存&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;稳定性&lt;/td&gt;
&lt;td&gt;基于 C/S 架构，职责明确、架构清晰，因此稳定性好&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;安全性&lt;/td&gt;
&lt;td&gt;为每个 APP 分配 UID，进程的 UID 是鉴别进程身份的重要标志&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;toc_8&quot;&gt;二. Linux 下传统的进程间通信原理&lt;/h2&gt;
&lt;p&gt;了解 Linux IPC 相关的概念和原理有助于我们理解 Binder 通信原理。因此，在介绍 Binder 跨进程通信原理之前，我们先聊聊 Linux 系统下传统的进程间通信是如何实现。&lt;/p&gt;
&lt;h3 id=&quot;toc_9&quot;&gt;2.1 基本概念介绍&lt;/h3&gt;
&lt;p&gt;这里我们先从 Linux 中进程间通信涉及的一些基本概念开始介绍，然后逐步展开，向大家说明传统的进程间通信的原理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/android/binder/linux_ipc_1.png&quot; alt=&quot;Linux 背景知识&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进程隔离&lt;/li&gt;
&lt;li&gt;进程空间划分：用户空间(User Space)/内核空间(Kernel Space)&lt;/li&gt;
&lt;li&gt;系统调用：用户态/内核态&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;toc_10&quot;&gt;进程隔离&lt;/h4&gt;
&lt;p&gt;简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。&lt;/p&gt;
&lt;h4 id=&quot;toc_11&quot;&gt;进程空间划分：用户空间(User Space)/内核空间(Kernel Space)&lt;/h4&gt;
&lt;p&gt;现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/android/binder/process_space.png&quot; alt=&quot;图片来自网络&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;toc_12&quot;&gt;系统调用：用户态与内核态&lt;/h4&gt;
&lt;p&gt;虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助&lt;strong&gt;系统调用&lt;/strong&gt;来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。&lt;/p&gt;
&lt;p&gt;Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。&lt;/p&gt;
&lt;p&gt;当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于&lt;strong&gt;内核运行态（内核态）&lt;/strong&gt;。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。&lt;/p&gt;
&lt;p&gt;当进程在执行用户自己的代码的时候，我们称其处于&lt;strong&gt;用户运行态（用户态）&lt;/strong&gt;。此时处理器在特权级最低的（3级）用户代码中运行。&lt;/p&gt;
&lt;p&gt;系统调用主要通过如下两个函数来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs stylus&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;copy_from_user&lt;span class=&quot;hljs-params&quot;&gt;() &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;toc_13&quot;&gt;2.2 Linux 下的传统 IPC 通信原理&lt;/h3&gt;
&lt;p&gt;理解了上面的几个概念，我们再来看看传统的 IPC 方式中，进程之间是如何实现通信的。&lt;/p&gt;
&lt;p&gt;通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/android/binder/linux_ipc_2.png&quot; alt=&quot;传统 IPC 通信原理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种传统的 IPC 通信方式有两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;性能低下，一次数据传递需要经历：内存缓存区 --&amp;gt; 内核缓存区 --&amp;gt; 内存缓存区，需要 2 次数据拷贝；&lt;/li&gt;
&lt;li&gt;接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;toc_14&quot;&gt;三. Binder 跨进程通信原理&lt;/h2&gt;
&lt;p&gt;理解了 Linux IPC 相关概念和通信原理，接下来我们正式介绍下 Binder IPC 的原理。&lt;/p&gt;
&lt;h3 id=&quot;toc_15&quot;&gt;3.1 动态内核可加载模块 &amp;amp;&amp;amp; 内存映射&lt;/h3&gt;
&lt;p&gt;正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的&lt;strong&gt;动态内核可加载模块&lt;/strong&gt;（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;Binder 驱动&lt;/strong&gt;（Binder Dirver）。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。&lt;/p&gt;
&lt;p&gt;这就不得不通道 Linux 下的另一个概念：&lt;strong&gt;内存映射&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。&lt;/p&gt;
&lt;p&gt;内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。&lt;/p&gt;
&lt;h3 id=&quot;toc_16&quot;&gt;3.2 Binder IPC 实现原理&lt;/h3&gt;
&lt;p&gt;Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。&lt;/p&gt;
&lt;p&gt;比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘--&amp;gt;内核空间--&amp;gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。&lt;/p&gt;
&lt;p&gt;而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。&lt;/p&gt;
&lt;p&gt;一次完整的 Binder IPC 通信过程通常是这样：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先 Binder 驱动在内核空间创建一个数据接收缓存区；&lt;/li&gt;
&lt;li&gt;接着在内核空间开辟一块内核缓存区，建立&lt;strong&gt;内核缓存区&lt;/strong&gt;和&lt;strong&gt;内核中数据接收缓存区&lt;/strong&gt;之间的映射关系，以及&lt;strong&gt;内核中数据接收缓存区&lt;/strong&gt;和&lt;strong&gt;接收进程用户空间地址&lt;/strong&gt;的映射关系；&lt;/li&gt;
&lt;li&gt;发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的&lt;strong&gt;内核缓存区&lt;/strong&gt;，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/android/binder/binder_ipc_1.png&quot; alt=&quot;Binder IPC 原理&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_17&quot;&gt;四. Binder 通信模型&lt;/h2&gt;
&lt;p&gt;介绍完 Binder IPC 的底层通信原理，接下来我们看看实现层面是如何设计的。&lt;/p&gt;
&lt;p&gt;一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。&lt;/p&gt;
&lt;h3 id=&quot;toc_18&quot;&gt;4.1 Client/Server/ServiceManager/驱动&lt;/h3&gt;
&lt;p&gt;前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/android/binder/binder_ipc_2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。&lt;/p&gt;
&lt;p&gt;通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;http://www.google.com/&quot;&gt;www.google.com&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 DNS 域名服务器，域名服务器中保存了&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;http://www.google.com/&quot;&gt;www.google.com&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 对应的 ip 地址 10.249.23.13，然后通过这个 ip 地址才能放到到&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;http://www.google.com/&quot;&gt;www.google.com&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 对应的服务器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/android/binder/binder_ipc_3.png&quot; alt=&quot;互联网通信模型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://blog.csdn.net/universus/article/details/6211589&quot;&gt;Android Binder 设计与实现&lt;/a&gt;一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;strong&gt;Binder 驱动&lt;/strong&gt;&lt;br/&gt;Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ServiceManager 与实名 Binder&lt;/strong&gt;&lt;br/&gt;ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。&lt;/p&gt;&lt;p&gt;细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER_SET_CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（&lt;strong&gt;这就是那只预先造好的那只鸡&lt;/strong&gt;）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Client 获得实名 Binder 的引用&lt;/strong&gt;&lt;br/&gt;Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;toc_19&quot;&gt;4.2 Binder 通信过程&lt;/h3&gt;
&lt;p&gt;至此，我们大致能总结出 Binder 通信过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先，一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；&lt;/li&gt;
&lt;li&gt;Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。&lt;/li&gt;
&lt;li&gt;Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/android/binder/binder_ipc_4.png&quot; alt=&quot;Binder 通信模型&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;toc_20&quot;&gt;4.3 Binder 通信中的代理模式&lt;/h3&gt;
&lt;p&gt;我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。&lt;/p&gt;
&lt;p&gt;前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。&lt;/p&gt;
&lt;p&gt;当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/android/binder/binder_ipc_5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;toc_21&quot;&gt;4.4 Binder 的完整定义&lt;/h3&gt;
&lt;p&gt;现在我们可以对 Binder 做个更加全面的定义了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从进程间通信的角度看，Binder 是一种进程间通信的机制；&lt;/li&gt;
&lt;li&gt;从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；&lt;/li&gt;
&lt;li&gt;从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理&lt;/li&gt;
&lt;li&gt;从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_22&quot;&gt;五. 手动编码实现跨进程调用&lt;/h2&gt;
&lt;p&gt;通常我们在做开发时，实现进程间通信用的最多的就是 AIDL。当我们定义好 AIDL 文件，在编译时编译器会帮我们生成代码实现 IPC 通信。借助 AIDL 编译以后的代码能帮助我们进一步理解 Binder IPC 的通信原理。&lt;/p&gt;
&lt;p&gt;但是无论是从可读性还是可理解性上来看，编译器生成的代码对开发者并不友好。比如一个 BookManager.aidl 文件对应会生成一个 BookManager.java 文件，这个 java 文件包含了一个 BookManager 接口、一个 Stub 静态的抽象类和一个 Proxy 静态类。Proxy 是 Stub 的静态内部类，Stub 又是 BookManager 的静态内部类，这就造成了可读性和可理解性的问题。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Android 之所以这样设计其实是有道理的，因为当有多个 AIDL 文件的时候把 BookManager、Stub、Proxy 放在同一个文件里能有效避免 Stub 和 Proxy 重名的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此便于大家理解，下面我们来手动编写代码来实现跨进程调用。&lt;/p&gt;
&lt;h3 id=&quot;toc_23&quot;&gt;5.1 各 Java 类职责描述&lt;/h3&gt;
&lt;p&gt;在正式编码实现跨进程调用之前，先介绍下实现过程中用到的一些类。了解了这些类的职责，有助于我们更好的理解和实现跨进程通信。&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;IBinder&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;IInterface&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; : IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;Binder&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;Stub&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;toc_24&quot;&gt;5.2 实现过程讲解&lt;/h3&gt;
&lt;p&gt;一次跨进程通信必然会涉及到两个进程，在这个例子中 RemoteService 作为服务端进程，提供服务；ClientActivity 作为客户端进程，使用 RemoteService 提供的服务。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/android/binder/ipc_1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么服务端进程具备什么样的能力？能为客户端提供什么样的服务呢？还记得我们前面介绍过的 IInterface 吗，它代表的就是服务端进程具体什么样的能力。因此我们需要定义一个 BookManager 接口，BookManager 继承自 IIterface，表明服务端具备什么样的能力。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;只定义服务端具备什么要的能力是不够的，既然是跨进程调用，那么接下来我们得实现一个跨进程调用对象 Stub。Stub 继承 Binder, 说明它是一个 Binder 本地对象；实现 IInterface 接口，表明具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要调用方自己实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;abstract &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Stub &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;Binder &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;BookManager {

    ...
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static BookManager &lt;span class=&quot;hljs-title&quot;&gt;asInterface&lt;span class=&quot;hljs-params&quot;&gt;(IBinder binder) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (binder == &lt;span class=&quot;hljs-keyword&quot;&gt;null)
            &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;null;
        IInterface iin = binder.queryLocalInterface(DESCRIPTOR);
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (iin != &lt;span class=&quot;hljs-keyword&quot;&gt;null &amp;amp;&amp;amp; iin &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof BookManager)
            &lt;span class=&quot;hljs-keyword&quot;&gt;return (BookManager) iin;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;new Proxy(binder);
    }

    ...

    &lt;span class=&quot;hljs-annotation&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;onTransact&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int code, Parcel data, Parcel reply, &lt;span class=&quot;hljs-keyword&quot;&gt;int flags) &lt;span class=&quot;hljs-keyword&quot;&gt;throws RemoteException {
        &lt;span class=&quot;hljs-keyword&quot;&gt;switch (code) {

            &lt;span class=&quot;hljs-keyword&quot;&gt;case INTERFACE_TRANSACTION:
                reply.writeString(DESCRIPTOR);
                &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;true;

            &lt;span class=&quot;hljs-keyword&quot;&gt;case TRANSAVTION_addBook:
                data.enforceInterface(DESCRIPTOR);
                Book arg0 = &lt;span class=&quot;hljs-keyword&quot;&gt;null;
                &lt;span class=&quot;hljs-keyword&quot;&gt;if (data.readInt() != &lt;span class=&quot;hljs-number&quot;&gt;0) {
                    arg0 = Book.CREATOR.createFromParcel(data);
                }
                &lt;span class=&quot;hljs-keyword&quot;&gt;this.addBook(arg0);
                reply.writeNoException();
                &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;true;

        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;super.onTransact(code, data, reply, flags);
    }

    ...
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Stub 类中我们重点介绍下&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;asInterface&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 和&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;onTransact&lt;/code&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先说说&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;asInterface&lt;/code&gt;，当 Client 端在创建和服务端的连接，调用 bindService 时需要创建一个 ServiceConnection 对象作为入参。在 ServiceConnection 的回调方法 onServiceConnected 中 会通过这个 asInterface(IBinder binder) 拿到 BookManager 对象，这个 IBinder 类型的入参 binder 是驱动传给我们的，正如你在代码中看到的一样，方法中会去调用 binder.queryLocalInterface() 去查找 Binder 本地对象，如果找到了就说明 Client 和 Server 在同一进程，那么这个 binder 本身就是 Binder 本地对象，可以直接使用。否则说明是 binder 是个远程对象，也就是 BinderProxy。因此需要我们创建一个代理对象 Proxy，通过这个代理对象来是实现远程访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来我们就要实现这个代理类 Proxy 了，既然是代理类自然需要实现 BookManager 接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Proxy &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;BookManager {
    
    ...

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;Proxy&lt;span class=&quot;hljs-params&quot;&gt;(IBinder remote) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.remote = remote;
    }

    &lt;span class=&quot;hljs-annotation&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;addBook&lt;span class=&quot;hljs-params&quot;&gt;(Book book) &lt;span class=&quot;hljs-keyword&quot;&gt;throws RemoteException {

        Parcel data = Parcel.obtain();
        Parcel replay = Parcel.obtain();
        &lt;span class=&quot;hljs-keyword&quot;&gt;try {
            data.writeInterfaceToken(DESCRIPTOR);
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (book != &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
                data.writeInt(&lt;span class=&quot;hljs-number&quot;&gt;1);
                book.writeToParcel(data, &lt;span class=&quot;hljs-number&quot;&gt;0);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
                data.writeInt(&lt;span class=&quot;hljs-number&quot;&gt;0);
            }
            remote.transact(Stub.TRANSAVTION_addBook, data, replay, &lt;span class=&quot;hljs-number&quot;&gt;0);
            replay.readException();
        } &lt;span class=&quot;hljs-keyword&quot;&gt;finally {
            replay.recycle();
            data.recycle();
        }
    }

    ...
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看看 addBook() 的实现；在 Stub 类中，addBook(Book book) 是一个抽象方法，Client 端需要继承并实现它。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果 Client 和 Server 在同一个进程，那么直接就是调用这个方法。&lt;/li&gt;
&lt;li&gt;如果是远程调用，Client 想要调用 Server 的方法就需要通过 Binder 代理来完成，也就是上面的 Proxy。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Proxy 中的 addBook() 方法中首先通过 Parcel 将数据序列化，然后调用 remote.transact()。正如前文所述 Proxy 是在 Stub 的 asInterface 中创建，能走到创建 Proxy 这一步就说明 Proxy 构造函数的入参是 BinderProxy，即这里的 remote 是个 BinderProxy 对象。最终通过一系列的函数调用，Client 进程通过系统调用陷入内核态，Client 进程中执行 addBook() 的线程挂起等待返回；驱动完成一系列的操作之后唤醒 Server 进程，调用 Server 进程本地对象的 onTransact()。最终又走到了 Stub 中的 onTransact() 中，onTransact() 根据函数编号调用相关函数（在 Stub 类中为 BookManager 接口中的每个函数中定义了一个编号，只不过上面的源码中我们简化掉了；在跨进程调用的时候，不会传递函数而是传递编号来指明要调用哪个函数）；我们这个例子里面，调用了 Binder 本地对象的 addBook() 并将结果返回给驱动，驱动唤醒 Client 进程里刚刚挂起的线程并将结果返回。&lt;/p&gt;
&lt;p&gt;这样一次跨进程调用就完成了。&lt;/p&gt;
&lt;p&gt;完整的代码我放到 GitHub 上了，有兴趣的小伙伴可以去看看。源码地址：&lt;a href=&quot;https://github.com/BaronZ88/HelloBinder&quot;&gt;https://github.com/BaronZ88/HelloBinder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后建议大家在不借助 AIDL 的情况下手写实现 Client 和 Server 进程的通信，加深对 Binder 通信过程的理解。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;受个人能力水平限制，文章中难免会有错误。如果大家发现文章不足之处，欢迎与我沟通交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文在写作过程中参考了很多文章、书籍和源码，其中有很多描述和图片都借鉴了下面的文章，在这里感谢大佬们的无私分享！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料如下：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.8924731182796&quot;&gt;
&lt;p&gt;如果你喜欢我的文章，就关注下我的公众号&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 、&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;https://zhuanlan.zhihu.com/baron&quot;&gt;&lt;strong&gt;知乎专栏&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 或者在&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;https://github.com/BaronZ88&quot;&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 上添个 Star 吧！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/common/qrcode500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 10 Apr 2018 15:11:00 +0000</pubDate>
<dc:creator>BaronZhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baronzhang/p/8784458.html</dc:identifier>
</item>
<item>
<title>spring-boot 使用Aop通知打印控制器请求报文和返回报文 - 浅浅_浅默</title>
<link>http://www.cnblogs.com/zeryts/p/8784172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zeryts/p/8784172.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　开发过程中我们往往需要写许多例如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
　　@GetMapping(&quot;/id/get&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Result getById( String id) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        log.info(&lt;/span&gt;&quot;请求参数为:&quot;+&lt;span&gt;id);
        verify(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; VerifyParam(&quot;部门id&quot;&lt;span&gt;, id));
        Result result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Result(&quot;通过id获取部门信息成功!&quot;&lt;span&gt;, service.queryById(id));
        log.info(&lt;/span&gt;&quot;返回报文为:&quot;+&lt;span&gt;result.toString());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印请求参数以及返回参数的方法,而这些操作存在于每个方法之中,使得我们代码较为冗余,为此我们可以通过动态代理将打印参数和打印返回报文作为切面,使用切入点表达式将其切入至每个方法之中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、步骤&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1、引入Aop相关的依赖:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;AOP相关的依赖&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-aop&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　引入依赖后spring-aop会加载其需要的依赖,spring默认使用aspectJ实现通知&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1358569/201804/1358569-20180410214801701-138211782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中aspectjweaver.jar中包含了解析aspectJ切入点表达式的文件,使用切入点表达式处理事务的时候也需要加入此依赖。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、配置:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1）、创建配置类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @功能描述:用于controller层操作的AOP类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将对象交由spring进行管理&lt;/span&gt;
@Aspect &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代表此类为一个切面类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerAop {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　其中@Aspect 注解代表其为一个切面管理类,可以在其下定义切入点表达式，aspectJ框架会进行解析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2）、定义切入点表达式：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    @Pointcut(&quot;execution(public * com.hzt.manage.*.web.controller..*.*(..))&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 切入点表达式&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; privilege() {
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　其中，@Pointcut代表此方法为一个切入点表达式。其value值为切入点表达式,其中value可以省略其大致格式为:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　@注解（表达标签+表达式格式）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　的格式，Spring AOP支持的AspectJ切入点指示符如下：&lt;/p&gt;
&lt;p&gt;      　　 &lt;em&gt;1、 &lt;span&gt;execution：用于匹配方法执行的连接点；&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;      　　　 2、within：用于匹配指定类型内的方法执行；&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;                   3、this：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;                   4、target：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;       　　   5、args：用于匹配当前执行的方法传入的参数为指定类型的执行方法；&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;       　　   6、@within：用于匹配所以持有指定注解类型内的方法；&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;        　　  7、@target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;        　　  8、@args：用于匹配当前执行的方法传入的参数持有指定注解的执行；&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;       　　   9、@annotation：用于匹配当前执行方法持有指定注解的方法；&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;        　　 10、bean：Spring AOP扩展的，AspectJ没有对于指示符，用于匹配特定名称的Bean对象的执行方法；&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;       　　  11、reference pointcut：表示引用其他命名切入点，只有@ApectJ风格支持，Schema风格不支持。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　args中定义了切入点表达式方法执行时候的参数:&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    @Pointcut(value=&quot;execution(public * com.hzt.manage.*.web.controller..*.*(..))&amp;amp;&amp;amp;args(param)&quot;,argNames=&quot;param&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 切入点表达式&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; privilege1(String param) {
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们重点介绍&lt;em&gt;&lt;span&gt;execution&lt;/span&gt;&lt;/em&gt;方法连接点的表达式，其大概结构为:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)&lt;span&gt;throws&lt;/span&gt;-pattern?) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;em&gt;&lt;span&gt;1、修饰符匹配（modifier-pattern?）(可省略)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　2、返回值匹配（ret-type-pattern）可以为*表示任何返回值 ,如 (String) 代表只筛选返回String类型的切入点 ,全路径的类名等(不可省略)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　3、类路径匹配（declaring-type-pattern?）如*.manage代表一级包为任意,二级包为manage的名称。*..manage代表所有manage包下的子类包。com..*.comtroller代表com包下所有的controller包等，*代表所有包都匹配。(不可省略)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　4、方法名匹配（name-pattern）可以指定方法名 或者 *代表所有, get* 代表以get开头的所有方法，也可指定前缀*get代表任意后缀为get的方法（不可省略）&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　5、参数匹配（(param-pattern)）可以指定具体的参数类型，多个参数间用“,”隔开，各个参数也可以用“*”来表示匹配任意类型的参数，如(String)表示匹配一个String参数的方法；(*,String) 表示匹配有两个参数的方法，第一个参数可以是任意类型，而第二个参数是String类型；可以用(..)表示任意参数（不可省略）&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　6、异常类型匹配（throws-pattern?）&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3、定义切面方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Around(&lt;/span&gt;&quot;privilege()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object around(ProceedingJoinPoint pjd) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取方法名&lt;/span&gt;
        String className =&lt;span&gt; pjd.getSignature().getClass().getName();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取执行的方法名称&lt;/span&gt;
        String methodName =&lt;span&gt; pjd.getSignature().getName();
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 初始化日志打印 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Logger log &lt;/span&gt;=&lt;span&gt; LoggerFactory.getLogger(className);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义返回参数&lt;/span&gt;
        Object result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录开始时间&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取方法参数&lt;/span&gt;
        Object[] args =&lt;span&gt; pjd.getArgs();
        String params &lt;/span&gt;= &quot;前端请求参数为:&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取请求参数集合并进行遍历拼接&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object object : args) {
            params &lt;/span&gt;+= object.toString() + &quot;,&quot;&lt;span&gt;;
        }
        params &lt;/span&gt;= params.substring(0, params.length() - 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印请求参数参数&lt;/span&gt;
        &lt;span&gt;log.info(className+&quot;类的&quot;+methodName + &quot;的&quot; + params);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行目标方法&lt;/span&gt;
        result =&lt;span&gt; pjd.proceed();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印返回报文&lt;/span&gt;
        log.info(&quot;方法返回报文为:&quot; + (result &lt;span&gt;instanceof&lt;/span&gt; Result ?&lt;span&gt; (Result) result : result));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取执行完的时间&lt;/span&gt;
        log.info(methodName + &quot;方法执行时长为:&quot; + (System.currentTimeMillis() -&lt;span&gt; start));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　5、@Around 环绕通知，如上代码所示便是环绕通知，其有ProceedingJoinPoint参数&lt;/p&gt;
&lt;p&gt;　　　　　　其中 &lt;span&gt;pjd.proceed();方法代表去执行目标方法，并获得一个Object类型的返回值&lt;/span&gt;,我们可以对返回值进行加工处理,如装饰加工等。&lt;/p&gt;
&lt;p&gt;　　　　　　return的值为方法执行的结果。上述代码中首先获取类名、方法名、方法请求参数等，进行打印的拼接，并且记录方法执行的开始时间，并进行打印至日志。&lt;/p&gt;
&lt;p&gt;　　　　　　然后执行方法，获取到方法返回结果，进行打印执行时间和执行结果。&lt;/p&gt;
&lt;p&gt;　　　　　　最后返回执行结果。即使用Aop打印请求报文和返回报文的aop切面编码结束。&lt;/p&gt;
&lt;p&gt;　　　　其中@Around代表其为一个环绕通知方法，其有以下几种类型：&lt;/p&gt;
&lt;p&gt;　　　　1、@Before前置通知,拥有请求参数 JoinPoint ,用来连接当前连接点的连接细节，一般包括方法名和参数值。在方法执行前进行执行方法体，不能改变方法参数，也不能改变方法执行结果。　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    @Before(value = &quot;privilege()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before(JoinPoint joinPoint) {
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　2、@After 后置通知：在目标方法执行之后，无论是否发生异常，都进行执行的通知。在后置通知中，不能访问目标方法的执行结果(因为有可能发生异常)，不能改变方法执行结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Before(value = &quot;privilege()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(JoinPoint joinPoint) {
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　3、@AfterReturning 返回通知，在目标方法执行结束时，才执行的通知,同后置方法相同。其能访问方法执行结果(因为正常执行)和方法的连接细节，但是不能改变方法执行结果。　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    @AfterReturning(value = &quot;privilege()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturing(JoinPoint joinPoint,Object result) {
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　result中存放的为方法的返回值。&lt;/p&gt;
&lt;p&gt;　　　4、@AfterThrowing 异常通知：在目标方法出现异常时才会进行执行的代码。 throwing属性代表方法体执行时候抛出的异常，其值一定与方法中Exception的值需要一致。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    @AfterThrowing(value=&quot;privilege()&quot;,throwing=&quot;ex&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; exce(JoinPoint joinPoint, Exception ex) {
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　&lt;strong&gt;&lt;span&gt;三、测试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　编写一个Controller方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
@RequestMapping(&lt;/span&gt;&quot;/api/v1/dept&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DeptController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseController{
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 日志记录类 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Logger log =&lt;span&gt; LoggerFactory.getLogger(getClass());
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 自家的service &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DeptService service;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * @功能描述:根据id查询部门内容的方法
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; Dept
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/id/get&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Result getById( String id) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        verify(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; VerifyParam(&quot;部门id&quot;&lt;span&gt;, id));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result(&quot;通过id获取部门信息成功!&quot;&lt;span&gt;, service.queryById(id));
    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　如此我们的controller层中的方法就大大的简洁了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　测试结果：&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018-04-10 22:59:27.468  INFO 1460 --- [nio-8088-exec-5] nProceedingJoinPoint$MethodSignatureImpl : getById的前端请求参数为:22
2018-04-10 22:59:27.470  INFO 1460 --- [nio-8088-exec-5] nProceedingJoinPoint$MethodSignatureImpl : 方法返回报文为:Result [result_code=suc, result_message=通过id获取部门信息成功!, data=Dept [id=22, no=22, name=22, manager=22, description=22, phone=22, createTime=Thu Apr 19 23:38:37 CST 2018, editTime=null]]
2018-04-10 22:59:27.470  INFO 1460 --- [nio-8088-exec-5] nProceedingJoinPoint$MethodSignatureImpl : getById方法执行时长为:2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如此便能很雅观简洁隐式的打印请求参数、返回结果和执行时间等!&lt;/p&gt;

</description>
<pubDate>Tue, 10 Apr 2018 15:02:00 +0000</pubDate>
<dc:creator>浅浅_浅默</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zeryts/p/8784172.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构（数组篇02） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8711731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8711731.html</guid>
<description>&lt;p&gt;　　　　上一篇文章简单的介绍了一下js的类型，以及数组的增删方法。这一篇文章，我们一起来看看数组还有哪些用法，以及在实际工作中我们可以用这些方法来做些什么。由于其中有部分内容并不常用，所以我尽量缩小篇幅。在这篇文章内介绍完大部分的数组方法，加快我们实现其它数据结构的脚步。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、concat()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　合并数组&lt;/strong&gt;，可以合并一个或多个数组。会按照参数顺序依次合并进想要合并的数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;concat的参数并不是只能传入数组，字符串，数字，布尔值，对象等都可以传入。&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; arr = [0,1,2,3,4,5,6&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = &quot;7&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = {a:1&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; d = [9,10&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newArr = arr.concat(a,b,c,&quot;d&quot;,{b:2&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[0, 1, 2, 3, 4, 5, 6, &quot;7&quot;, true, {a:1}, &quot;d&quot;, {b:2}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　需要注意的是，&lt;strong&gt;concat&lt;/strong&gt;&lt;strong&gt;方法会生成一个新的数组&lt;/strong&gt;，并不会改变原数组的值。那么这里还是要说一下，&lt;strong&gt;concat的主要作用在于合并数组&lt;/strong&gt;！而且前面也说过，&lt;strong&gt;并不建议在数组中存入不同类型的参数&lt;/strong&gt;，所以上面例子合并的参数只是为了测试&lt;strong&gt;可以这么做，但是不要这么做&lt;/strong&gt;，到时候会有意想不到的乱子！&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、join()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　把所有的数组元素依照分隔符（也就是参数）链接成一个字符串。如果不传入参数则以&quot;，&quot;逗号分隔。该方法同样会生成一个新的字符串结果。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arr = [&quot;z&quot;,&quot;a&quot;,&quot;k&quot;,&quot;i&quot;,&quot;n&quot;,&quot;g&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arrStr = arr.join(&quot;-&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;z&quot;, &quot;a&quot;, &quot;k&quot;, &quot;i&quot;, &quot;n&quot;, &quot;g&quot;]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;z-a-k-i-n-g&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;3、some()和every()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;some()方法，会遍历数组中的每个元素，&lt;strong&gt;直到返回false结束&lt;/strong&gt;！而&lt;strong&gt;every()&lt;/strong&gt;呢，与some()相反，&lt;strong&gt;直到返回true结束&lt;/strong&gt;！下面简单举两个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; isEven = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (val) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (val % 2) == 0 ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nums = [1,2,3,4,5,6,7,8,9,10&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; judgeA=&lt;span&gt; nums.&lt;span&gt;every&lt;/span&gt;(isEven)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; judgeB =&lt;span&gt; nums.&lt;span&gt;some&lt;/span&gt;(isEven)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　解释一下，其实简单来说，some用来判断本数组中&lt;strong&gt;是否存在&lt;/strong&gt;(至少有一个)符合传入函数的条件的值，而every则判断是否本数组中&lt;strong&gt;每一个值都&lt;/strong&gt;符合条件。&lt;/p&gt;
&lt;p&gt;　　　　那么在上面的例子中，some方法确定数组中存在符合条件的值，所以返回true，后面有没有符合条件的跟我没关系了。只要找到找一个符合条件的就说明我可以返回true了。如果some方法遍历了整个数组还没有找到符合条件的值，则会遗憾的返回false。&lt;/p&gt;
&lt;p&gt;　　　　而every方法，跟some方法其实刚好相反。我只要发现一个不符合条件，我就高高兴兴的返回false，只有在遍历了整个数组元素发现都符合条件，才会可怜兮兮的返回true。&lt;/p&gt;
&lt;p&gt;　　　　如果要记忆区分这两种方法，其实并不是很难，&lt;strong&gt;every(每一个)，说明只有所有都对才算是true。而some(一些)，说明你有一个就行啦，我就给你返回true。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4、forEach()，map()和filter()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;敲黑板！这是重点！重点！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;forEach()：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;forEach()方法&lt;/strong&gt;，它接受一个方法（function）作为参数，该方法中可以有三个参数（item,index,arr）分别是调用forEach数组中的每一项元素，每一项元素的下标，调用forEach方法的数组。&lt;strong&gt;该方法会遍历数组中的每一项，为每一项执行你想做的事，不更改原数组并且没有返回值。但是我们可以自己通过数组的索引来修改原来的数组。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [1,2,3,4,5,6,7,8,9,10&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newNumsB =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newNumsA = nums.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item,index,arr){
    newNumsB.push(item &lt;/span&gt;+ 100&lt;span&gt;)
    arr[index] &lt;/span&gt;= item + 10&lt;span&gt;;
})
console.log(nums)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]&lt;/span&gt;
&lt;span&gt;console.log(newNumsB)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[101, 102, 103, 104, 105, 106, 107, 108, 109, 110]&lt;/span&gt;
&lt;span&gt;console.log(newNumsA)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　forEach方法并不会改变原数组，如果你想要操作调用方法所修改后的值，需要把他重新赋值给一个空数组，或者，如果修改原数组是你想要的结果，那么可以通过匿名函数的第三个参数来获取到原数组从而更改他。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;map()：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;map()方法&lt;/strong&gt;，其实简单来说就是一个&lt;strong&gt;映射，&lt;/strong&gt;&lt;strong&gt;但是map必须要有返回值，并且map会返回一个新数组。&lt;/strong&gt;同样的，map也可以有三个参数，跟forEach是一样的。&lt;strong&gt;但是，你却无法向forEach那样来通过匿名函数的第三个参数来改变原数组，因为map需要return！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [1,2,3,4,5,6,7,8,9,10&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newMapNums = nums.map(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item,index,arr) {
    console.log(item,index,arr);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item *&lt;span&gt; item;
})
console.log(newMapNums)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;filter()：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　还有一个&lt;strong&gt;filter()&lt;/strong&gt;方法，也就是“&lt;strong&gt;过滤&lt;/strong&gt;”。filter会返回一个调用该方法数组的一个子集，什么意思呢，就是说filter的参数是一个函数，该函数是用来逻辑判断的（类似于every和some的那种判定），如果判断结果返回true或者可以作为true值返回，那么就会成为这个子集中的一个元素。简单说就是，&lt;strong&gt;你（调用filter方法的数组中每一个元素）是否能通过我（filter的function方法）的判定，如果可以就会成为我（返回的新数组）的一员。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [1,2,3,4,5,6,7,8,9,10&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newNums = nums.filter(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item,index,arr){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item &amp;gt; 5&lt;span&gt;
})
console.log(newNums)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[6, 7, 8, 9, 10]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这里要注意的是，原数组仍旧是无法更改的，跟map一样。&lt;strong&gt;因为它有返回值，是通过返回值来组织新的数组的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;5、reduce()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　英文的解释是缩减，刚好，咱们js中reduce方法差不多就是这个意思。&lt;strong&gt;该方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　reduce的参数有点多，我还是这样写吧reduce(function(total,item,index,arr){},initalVal)。其中item，index，arr我就不说了，大家都知道是啥。total是啥呢？initalVal能猜到是什么么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [1,2,3,4,5,6,7,8,9,10&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newNums = nums.reduce(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(total,item,index,arr){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; total + item*100&lt;span&gt;
},&lt;/span&gt;100&lt;span&gt;)
console.log(newNums)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5600&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　total其实就是指你之前所累加的值，而initalVal就是你最初的total是多少，也就是你在即将开始reduce方法时初始值是多少（从什么值开始累加），可以不传或者传为0。那我就有点小问题了，reduce只能做数值的计算么？能不能加字符串，布尔值设置数组呢？咱们来小试一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; strs = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newStrs = strs.reduce(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(total,item,index){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; total + item + &quot;-&quot;&lt;span&gt;
})
console.log(newStrs)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ab-c-d-e-f-&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　哎？竟然会是这样的结果，那么咱们来看看为什么。首先咱们没有传initalVal，那么就是从strs的第一项开始加，total的第一个值为字符串”a“，而后面呢我们又return了item + ”-“，也就说是从数组的第二项开始得到了我们想要的结果，最后我们给数组的最后一个元素”f“，也加上了”-“，这就是为啥会有这样的结果的原因了。所以，如果大家确&lt;strong&gt;实一定不得不&lt;/strong&gt;想要做这样的操作，&lt;strong&gt;请你用join方法&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt; 　　　　那么，我们可不可以在数组中加入其它元素呢？这里不再赘述，你们要自己去试试噢。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;6、toString(),把数组中所有元素作为字符串输出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;toString有点类似于join，但是join是数组方法，toString却适用于几乎所有的javascript对象。这里不多说，点一下就好。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;7、valueOf()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　与toString和join在数组中的使用方法是一样的，也同样是返回以逗号分隔的字符串对象。&lt;/p&gt;
&lt;p&gt;　　　　但是这里不会多说但是会强调，&lt;strong&gt;toString和valueOf都不仅仅只是数组的方法，他们几乎适用于所有的原生JS对象。而且依照对象的不同会有不同的展现形式！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;8、indexOf()和lastIndexOf()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　这两个东西不太好解释，我看看怎么简单说明一下呢~~~。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;indexOf是返回与参数匹配的第一个元素的索引，lastIndexOf返回与参数匹配的最后一个元素的索引。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nums = [0,1,2,3,4,5,6,6,7,&quot;a&quot;,9,10,{name:&quot;zaking&quot;},[&quot;b&quot;,&quot;c&quot;&lt;span&gt;]];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = nums.indexOf(7&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = nums.lastIndexOf(7&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = nums.indexOf(6&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; d = nums.lastIndexOf(6&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; e = nums.indexOf(100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; f = nums.lastIndexOf(100&lt;span&gt;);
console.log(a,b,c,d,e,f)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8 8 6 7 -1 -1&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; x = nums.indexOf(&quot;a&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = nums.lastIndexOf(&quot;a&quot;&lt;span&gt;);
console.log(x,y);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9 9&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; m = nums.indexOf({name:&quot;zaking&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n = nums.lastIndexOf({name:&quot;zaking&quot;&lt;span&gt;});
console.log(m,n)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-1,-1&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; i = nums.indexOf(&quot;b&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; j = nums.indexOf([&quot;b&quot;,&quot;c&quot;&lt;span&gt;])
console.log(i,j)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-1,-1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　其实可以说indexOf是从数组的头部开始搜索，搜索到了匹配的第一个值就停止搜索并返回该值的下标。而lastIndexOf则是从尾部开始，搜索到了第一个匹配的值就停止并返回该值的下标。&lt;/p&gt;
&lt;p&gt;　　　　这里有一个令人不容易注意但是却十分容易混乱的事情，就是，&lt;strong&gt;无论从头还是从尾来搜索数组，数组的下标计算方式是永远不会变的，&lt;/strong&gt;所以，不要认为从尾部搜索就是尾部的第一个数组元素下标为0，不是这样的！&lt;/p&gt;
&lt;p&gt;　　　　那么再说，如果搜索的参数在数组中并不存在，那么则返回-1，两个方法都是一样的。&lt;/p&gt;
&lt;p&gt;　　　　而且我们还可以从上面的简单测试代码中发现，&lt;strong&gt;这两个方法的参数只适用于基本类型，如果对数组中的引用类型元素进行索引查找是不可以也通常是不会应用的！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　那么这篇文章就到这里了，简单介绍了ES5数组的几乎所有的方法，其实ES6对数组进行了不错的扩展并且新增了很多方法，但是这里不会多说，因为那样的话又会多出几篇的篇幅，还有一个原因就是阮一峰大神的&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/array&quot; target=&quot;_blank&quot;&gt;ES6入门&lt;/a&gt;已经介绍的十分详细，大家如果有兴趣可以自行查阅。下一篇文章会介绍一下多维数组（也就二维三维...）和数组的简单排序。&lt;/p&gt;

&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 10 Apr 2018 14:47:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8711731.html</dc:identifier>
</item>
<item>
<title>Excel as a Service —— Excel 开发居然可以这么玩 - 陈希章</title>
<link>http://www.cnblogs.com/chenxizhang/p/8783774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxizhang/p/8783774.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;据不完全统计，全世界使用Excel作为电子表格和数据处理的用户数以十亿计，这不仅得益于它的使用简便，同时还因为它内置了很多强大的函数，结合你的想象力可以编写出各种公式，并可快速根据数据生成图表和透视分析等。另一方面，Excel在整个Office家族中也是拥有开发者最多的一个组件，不管是在客户端的VBA宏和VSTO插件开发，以及在早些年出现在SharePoint Server中的Excel Service（包括用来呈现Excel文件的Web Part，以及一套XML Web Service可供远程调用Excel的功能，包括自定义Excel函数等。&lt;/p&gt;
&lt;p&gt;在Office 365的时代，SharePoint Online中已经将Excel Service的功能删除掉了，取而代之的是2016年7月份左右揭开神秘面纱的Microsoft Graph Excel API，融入Microsoft Graph大家族的Excel Service快速迭代，目前它的功能也趋向稳定了。今天我将用一个实例来介绍一下它的奇妙设计和应用场景。&lt;/p&gt;

&lt;h2&gt;范例介绍&lt;/h2&gt;

&lt;p&gt;设想一下，你用Excel做了一份非常强大的“抵押贷款测算表”，这里面可以通过输入几个参数，使用Excel自带的PMT函数计算每月还款额，据此快速生成一个还款计划，如下图所示：&lt;/p&gt;
&lt;blockquote readability=&quot;3.9827586206897&quot;&gt;
&lt;p&gt;PMT 是一个财务函数，用于根据固定付款额和固定利率计算贷款的付款额。有兴趣可以参考 &lt;a href=&quot;https://support.office.com/zh-cn/article/PMT-%E5%87%BD%E6%95%B0-0214DA64-9A63-4996-BC20-214433FA6441&quot;&gt;https://support.office.com/zh-cn/article/PMT-%E5%87%BD%E6%95%B0-0214DA64-9A63-4996-BC20-214433FA6441&lt;/a&gt; 的帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-04-10-21-48-48.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-04-10-21-48-48.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;与此同时，你还可以很轻松地生成一个数据列表，和对应的图表，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-04-10-21-49-25.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-04-10-21-49-25.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过改变“购买价格”、“利率”、“贷款期”、“贷款金额”等单元格的数值，Excel会自动计算其他单元格的数值，包括自动刷新图表。这一切对广大的“表哥表姐”来说都是非常熟悉的体验。&lt;/p&gt;
&lt;p&gt;那么问题来了：如果你的一个网页中也要实现“抵押贷款测算”的功能，你是不是应该自己去实现一次PMT这种函数的功能呢？我不知道，但我觉得你读了本文后会改变一些想法—— 我们完全可以将这些计算交给Excel Service去做，前端应用直接调用即可。&lt;/p&gt;
&lt;p&gt;使用Microsoft Graph中的Excel API，你不仅可以访问工作簿，工作表和单元格、表格和图表等，修改他们的属性和数值，甚至还可以将图表用图片的形式读取过来，一切都在你的掌握之中。接下去用一个范例代码演示这些奇妙的场景。&lt;/p&gt;
&lt;blockquote readability=&quot;2.3382352941176&quot;&gt;
&lt;p&gt;Microsoft Graph Excel API的官方文档，请参考 &lt;a href=&quot;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/resources/excel&quot;&gt;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/resources/excel&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/excelgraph.md#%E4%BD%BF%E7%94%A8microsoft-graph-%E8%8E%B7%E5%8F%96%E5%B7%A5%E4%BD%9C%E7%B0%BF%E5%92%8C%E5%8D%95%E5%85%83%E6%A0%BC&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;h2&gt;使用Microsoft Graph 获取工作簿和单元格&lt;/h2&gt;

&lt;p&gt;要使用Micrsosoft Graph Excel API,你只需要将Excel文件放到OneDrive for Business或者SharePoint Online的文档库中即可。例如，我将演示用的文件放在了一个目录中：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-04-10-21-58-45.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-04-10-21-58-45.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你需要了解一些Microsoft Graph的背景知识，如果你对Microsoft Graph比较陌生，建议你参考我之前的两篇文章&lt;/p&gt;
&lt;p&gt;本文所采用的方式就是用Graph Explorer这种方式来操作Microsoft Graph Excel API。我的这个文件是在OneDrive for Business 的个人云盘的根目录下面的testgraph目录中，文件名为 demofile.xlsx，所以我可以使用&lt;code&gt;GET &lt;a href=&quot;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook&quot; class=&quot;uri&quot;&gt;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook&lt;/a&gt;&lt;/code&gt;获取到这个工作簿&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-04-10-22-03-30.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-04-10-22-03-30.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;GET &lt;a href=&quot;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/worksheets&quot; class=&quot;uri&quot;&gt;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/worksheets&lt;/a&gt;&lt;/code&gt; 可以获取工作簿中所有的工作表信息&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-04-10-22-04-12.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-04-10-22-04-12.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;GET &lt;a href=&quot;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/worksheets/%E6%8A%B5%E6%8A%BC%E8%AE%A1%E7%AE%97%E5%99%A8/range(address&quot; class=&quot;uri&quot;&gt;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/worksheets/抵押计算器/range(address&lt;/a&gt;='c4')&lt;/code&gt; 可以获取名称为“抵押计算器“的工作表中的C4单元格对象&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-04-10-22-05-14.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-04-10-22-05-14.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然，也可以通过名称访问单元格对象，语法是 &lt;code&gt;GET &lt;a href=&quot;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/names/%E6%AF%8F%E6%9C%88%E8%BF%98%E8%B4%B7%E6%95%B0%E9%A2%9D&quot; class=&quot;uri&quot;&gt;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/names/每月还贷数额&lt;/a&gt;&lt;/code&gt; 这样的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-04-10-22-07-58.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-04-10-22-07-58.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你还可以返回多个单元格的数值，例如下面这样的查询 &lt;code&gt;GET &lt;a href=&quot;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/worksheets/&quot;&gt;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/worksheets/&lt;/a&gt;抵押计算器/range(address='c4:c6')/values&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-04-10-22-10-13.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-04-10-22-10-13.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/excelgraph.md#%E6%9B%B4%E6%96%B0%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E5%AE%B9&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;h2&gt;更新单元格内容&lt;/h2&gt;

&lt;p&gt;上一节我用几种不同的语法展示了如何获取工作簿、工作表和单元格（包括直接查询它的数值），那么如果我们希望能修改某个单元格的数值，应该怎么做呢？下面的例子演示了如何将名称为“抵押计算器“的工作表中的C4的数值修改为一个新的值，例如400000.&lt;/p&gt;
&lt;p&gt;需要注意的是，查询数据我们一般用的API请求方法是GET，而修改数据则需要用到的请求方法是PATCH。为了实现上面所提到的单元格修改需求，我们要执行的查询是 &lt;code&gt;PATCH &lt;a href=&quot;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/worksheets/%E6%8A%B5%E6%8A%BC%E8%AE%A1%E7%AE%97%E5%99%A8/range(address&quot; class=&quot;uri&quot;&gt;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/worksheets/抵押计算器/range(address&lt;/a&gt;='c4')&lt;/code&gt;,与此同时，还需要提供新的数值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&lt;br/&gt;values:[[400000]]&lt;br/&gt;}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PATCH方法可以对目标对象执行局部更新。上面的代码我们只提供了Values这个属性集合，但其实还可以增加其他的属性，来达到一次修改多个属性的目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-04-10-22-18-05.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-04-10-22-18-05.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;执行成功后，你可以发现C4的数值已经变成了400000。&lt;/p&gt;
&lt;blockquote readability=&quot;6.9919571045576&quot;&gt;
&lt;p&gt;这里我埋了一个伏笔，如果你在程序中用如上的方式修改了某个单元格(A)的数值，然后去获取另外一个单元格（B）的值，假设B跟A是有公式的关系，你可能期望的是B的值也会立即刷新。但事实上，它不会。这里涉及到一些相对复杂的概念，就是Excel API有两种访问的模式，我们现在用的这种，是所谓的“非持久化会话模式”，一般用来查询数据，或者修改后不保存，所以在下一次查询的时候，其实你获取的还是旧值。 关于如何创建持久会话，并且在多个查询中共用它，请参考 &lt;a href=&quot;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/workbook_createsession&quot;&gt;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/workbook_createsession&lt;/a&gt; 的详细说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/excelgraph.md#%E8%8E%B7%E5%8F%96%E5%B7%A5%E4%BD%9C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%A1%A8&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;h2&gt;获取工作表中的图表&lt;/h2&gt;

&lt;p&gt;我们已经知道了如何访问工作簿的单元格，以及如何更新它们的数值，这已经可以让我们轻松实现很多业务场景了：你可以在Excel中做好很多复杂的公式，设计数据之间的关系，然后通过API修改某些单元格的值，然后去获取其他单元格的值，看起来你的应用具有了类似Excel那样神奇的功能，但其实所有的事情都还是Excel在默默地为你服务，你所做的只是调用一两次接口而已。&lt;/p&gt;
&lt;p&gt;接下来还要演示一个有意思的场景是将工作表中的图表用图片的形式提取出来，这个场景特别适合于我们已经经过了数据的处理，然后希望将图表展现在前端的应用中。Excel API可以将一个图表以一个Base64字符串的形式返回，客户端可以利用这个进行图片展现。&lt;/p&gt;
&lt;p&gt;听起来很玄的事情，其实也只是一个GET请求而已 &lt;code&gt;GET &lt;a href=&quot;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/worksheets/%E5%88%86%E6%9C%9F%E8%BF%98%E6%AC%BE%E8%A1%A8%E6%A0%BC/charts/%E5%9B%BE%E8%A1%A8&quot; class=&quot;uri&quot;&gt;https://graph.microsoft.com/v1.0/me/drive/root:/testgraph/demofile.xlsx:/workbook/worksheets/分期还款表格/charts/图表&lt;/a&gt; 1/image&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-04-10-22-27-06.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-04-10-22-27-06.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接口返回的结果是一串很长很长的字符串，你肯定是看不懂的。你要做的是将这个字符串复制出来，然后随便用一个文本编辑器，新建一个文件，然后填入如下的内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;img src=&quot;&lt;a href=&quot;data:image/png;base64,这里填写你查询得到的字符串&quot; class=&quot;uri&quot;&gt;data:image/png;base64,这里填写你查询得到的字符串&lt;/a&gt;&quot;&amp;gt;&amp;lt;/img&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来将这个保存为一个html文件，然后在浏览器中打开它。你是不是觉得下面这个图表似曾相识呢，恭喜你答对了，其实这个图表就是之前Excel文件中的那一个呀。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2018-04-10-22-30-05.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2018-04-10-22-30-05.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;我在很多场合都分享过Office 365 平台化的能力和开发场景，Microsoft Graph在其中起到了关键作用，而今天给大家展示的Excel API则将这一点表现的淋漓尽致，而且毫无疑问，我这里演示的只是一些皮毛，更多有意思的场景，还等待着你的发现呢。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Apr 2018 14:46:00 +0000</pubDate>
<dc:creator>陈希章</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxizhang/p/8783774.html</dc:identifier>
</item>
<item>
<title>vue组件详解（五）——组件高级用法 - 柴小智</title>
<link>http://www.cnblogs.com/chaixiaozhi/p/8783620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaixiaozhi/p/8783620.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、递归组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;组件在它的模板内可以递归地调用自己， 只要给组件设置name 的选项就可以了。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app19&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-component19 &lt;/span&gt;&lt;span&gt;:count&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-component19&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
Vue.component('my-component19'&lt;span&gt;,{
    name: &lt;/span&gt;'my-component19',  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实当你利用 Vue.component 全局注册了一个组件，全局的ID会被自动设置为组件的name。&lt;/span&gt;
&lt;span&gt;    props: {
      count: {
          type: Number,
          &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: 1&lt;span&gt;
      }
    },
    template: &lt;/span&gt;'&amp;lt;div&amp;gt;&amp;lt;my-component19 :count=&quot;count+1&quot; v-if=&quot;count&amp;lt;3&quot;&amp;gt;&amp;lt;/my-component19&amp;gt;&amp;lt;/div&amp;gt;'&lt;span&gt;
});

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app19 =  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;'#app19'&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;渲染结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app19&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!----&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 设置name 后，在组件模板内就可以递归使用了，不过需要注意的是，&lt;span&gt;必须给一个条件来限制递归数量，&lt;/span&gt;否则会抛出错误： max stack size exceeded 。&lt;/p&gt;
&lt;p&gt;组件递归使用可以用来开发一些具有未知层级关系的独立组件，比如级联选择器和树形控件等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、内联模板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;组件的模板一般都是在template 选项内定义的， Vue 提供了一个内联模板的功能，在使用组件时，&lt;span&gt;给组件标签使用inline-template 特性，&lt;/span&gt;组件就会把它的内容当作模板，而不是把它当内容分发，这让模板更灵活。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app20&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-component20 &lt;/span&gt;&lt;span&gt;inline-template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;在父组件中定义子组件的模板&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-component20&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Vue.component('my-component20'&lt;span&gt;,{
    data: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            msg: &lt;/span&gt;'在子组件声明的数据'&lt;span&gt;
        }
    }
});

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app20 =  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;'#app20'&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;三、动态组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vue.js 提供了一个特殊的元素＜component&amp;gt; 用来动态地挂载不同的组件， 使用is特性来选择要挂载的组件。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app21&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;component &lt;/span&gt;&lt;span&gt;:is&lt;/span&gt;&lt;span&gt;=&quot;currentView&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;changeView('A')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;切换到A&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;changeView('B')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;切换到B&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;changeView('C')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;切换到C&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app21 =  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;'#app21'&lt;span&gt;,
    data: {
      currentView: &lt;/span&gt;'comA'&lt;span&gt;
    },
    methods: {
        changeView: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentView = 'com'+&lt;span&gt; data　　&lt;span&gt;//动态地改变currentView的值就可以动态挂载组件了。&lt;/span&gt;
        }
    },
    components: {
        comA: {
            template: &lt;/span&gt;'&amp;lt;div&amp;gt;组件A&amp;lt;/div&amp;gt;'&lt;span&gt;
        },
        comB: {
            template: &lt;/span&gt;'&amp;lt;div&amp;gt;组件B&amp;lt;/div&amp;gt;'&lt;span&gt;
        },
        comC: {
            template: &lt;/span&gt;'&amp;lt;div&amp;gt;组件C&amp;lt;/div&amp;gt;'&lt;span&gt;
        }
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;strong&gt;四、异步组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你的工程足够大， 使用的组件足够多时， 是时候考虑下性能问题了， 因为一开始把所有的组件都加载是没必要的一笔开销。&lt;/p&gt;
&lt;p&gt;好在Vue.js 允许将组件定义为一个工厂函数，&lt;span&gt;动态地解析组件&lt;/span&gt;。Vue. 只在组件需要渲染时触发工厂函数， 并且把结果缓存起来，用于后面的再次渲染。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app22&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-component22&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-component22&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Vue.component('my-component22',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject){
    window.setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        resolve({
            template: &lt;/span&gt;'&amp;lt;div&amp;gt;我是异步渲染的&amp;lt;/div&amp;gt;'&lt;span&gt;
        })
    },&lt;/span&gt;2000&lt;span&gt;)
});

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app22 =  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;'#app22'&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;工厂函数接收一个resolve 回调，在收到从服务器下载的组件定义时调用。&lt;/span&gt;也可以调用reject( reason ）指示加载失败。&lt;br/&gt;这里setTimeout 只是为了演示异步，具体的下载逻辑可以自己决定，比如把组件配置写成一个对象配置，通过Ajax 来请求，然后调用resolve 传入配置选项。&lt;/p&gt;

</description>
<pubDate>Tue, 10 Apr 2018 14:28:00 +0000</pubDate>
<dc:creator>柴小智</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaixiaozhi/p/8783620.html</dc:identifier>
</item>
<item>
<title>Django 中间件 - 低调的人儿</title>
<link>http://www.cnblogs.com/DI-DIAO/p/8782373.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DI-DIAO/p/8782373.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　之前我们给视图函数加装饰器来判断是用户是否登录，把没有登录的用户请求跳转到登录页面。我们通过给几个特定视图函数加装饰器实现了这个需求。但是以后添加的视图函数可能也需要加上装饰器，这样是不是稍微有点繁琐。&lt;/p&gt;
&lt;p&gt;　　中间件可以实现给所有请求做相同的操作，免去给每一个视图函数加装饰器的工作。&lt;/p&gt;
&lt;h2&gt;中间件介绍&lt;/h2&gt;
&lt;h3&gt;什么是中间件&lt;/h3&gt;
&lt;p&gt;　　官方说法：中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。每个中间件组件都负责做一些特定的功能。&lt;/p&gt;
&lt;p&gt;　　说的真实点，其实中间件就是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，它本质上就是一个自定义类，类中定义了几个办法，Django框架会在请求的特定的时间去执行这些方法。&lt;/p&gt;
&lt;p&gt;　　在Django中，其实我们一直都在使用中间件，在Django项目的settings.py文件中，有一项就是中间件的配置：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MIDDLEWARE&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
MIDDLEWARE =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.security.SecurityMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions.middleware.SessionMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.common.CommonMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.csrf.CsrfViewMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.auth.middleware.AuthenticationMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.messages.middleware.MessageMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.clickjacking.XFrameOptionsMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span data-mce-=&quot;&quot;&gt;MIDDLEWARE&lt;/span&gt;配置项是一个列表，列表中是一个个字符串，这些字符串其实一个个类，也就是一个个中间件。&lt;/p&gt;
&lt;h2&gt;自定义中间件&lt;/h2&gt;
&lt;p&gt;　　中间件可以定义五个方法，分别是：（主要的是process_request和process_response）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;process_request(self,request)&lt;/li&gt;
&lt;li&gt;process_view(self,request,view_func,view_args,view_kwargs)&lt;/li&gt;
&lt;li&gt;process_template_response(self,request,response)&lt;/li&gt;
&lt;li&gt;process_exception(self,request,exception)&lt;/li&gt;
&lt;li&gt;process_response(self,request,response)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照Django定义的规则向后继续执行，如果是HttpResponse对象，则直接将对象返回给用户。&lt;/p&gt;
&lt;h3&gt;自定义中间件示例&lt;/h3&gt;
&lt;p&gt;在项目下单独新建一个  my_middlewares.py  文件，专门放置自定义中间件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.utils.deprecation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MiddlewareMixin


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD1(MiddlewareMixin):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; response
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;process_request&lt;/h3&gt;
&lt;p&gt;　　process_request 有一个参数，就是 request ，这个 request 和视图函数中的 request 是一样的。&lt;/p&gt;
&lt;p&gt;　　它的返回值可以是None，也可以是HttpResponse对象。返回值是None的话，按正常流程继续走，交给下一个中间件处理，如果是HttpResponse对象，Django将不执行视图函数，而将相应对象返回给浏览器。&lt;/p&gt;
&lt;p&gt;　　我们来看看多个中间件时，Django是如何执行其中的 process_request方法的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.utils.deprecation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MiddlewareMixin


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD1(MiddlewareMixin):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD2(MiddlewareMixin):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在settings.py的MIDDLEWARE配置项中注册上述两个自定义中间件：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
MIDDLEWARE =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.security.SecurityMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions.middleware.SessionMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.common.CommonMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.csrf.CsrfViewMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.auth.middleware.AuthenticationMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.messages.middleware.MessageMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.clickjacking.XFrameOptionsMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;middlewares.MD1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自定义中间件MD1&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;middlewares.MD2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自定义中间件MD2&lt;/span&gt;
]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;此时，我们访问一个视图，会发现终端中打印如下内容：&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MD1里面的 process_request
MD2里面的 process_request
app01 中的 index视图&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;把MD1和MD2的位置调换一下，再访问一个视图，会发现终端中打印的内容如下：&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MD2里面的 process_request
MD1里面的 process_request
app01 中的 index视图&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看结果我们知道：视图函数还是最后执行的，MD2比MD1先执行自己的process_request方法。&lt;/p&gt;
&lt;p&gt;在打印一下两个自定义中间件中process_request方法中的request参数，会发现它们是同一个对象。&lt;/p&gt;
&lt;p&gt;由此总结一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;中间件的process_request方法是在执行视图函数之前执行的。&lt;/li&gt;
&lt;li&gt;当配置多个中间件时，会按照MIDDLEWARE中的注册顺序，也就是列表的索引值，从前到后依次执行的。&lt;/li&gt;
&lt;li&gt;不同中间件之间传递的request都是同一个对象&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;process_response&lt;/h3&gt;
&lt;p&gt;　　它有两个参数，一个是request，一个是response，request就是上述例子中一样的对象，response是视图函数返回的HttpResponse对象。该方法的返回值也必须是HttpResponse对象。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;给上述的M1和M2加上process_response方法：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.utils.deprecation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MiddlewareMixin


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD1(MiddlewareMixin):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD2(MiddlewareMixin):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2里面的 process_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; response
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;访问一个视图，看一下终端的输出：&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MD2里面的 process_request
MD1里面的 process_request
app01 中的 index视图
MD1里面的 process_response
MD2里面的 process_response&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看结果可知：&lt;/p&gt;
&lt;p&gt;　　process_response方法是在视图函数之后执行的，并且顺序是MD1比MD2先执行。(此时settings.py中 MD2比MD1先注册)&lt;/p&gt;
&lt;p&gt;　　多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序&lt;strong&gt;倒序&lt;/strong&gt;执行的，也就是说第一个中间件的process_request方法首先执行，而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;process_view&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;process_view(self, request, view_func, view_args, view_kwargs)&lt;/p&gt;

&lt;p&gt;该方法有四个参数&lt;/p&gt;

&lt;p&gt;request是HttpRequest对象。&lt;/p&gt;

&lt;p&gt;view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。）&lt;/p&gt;

&lt;p&gt;view_args是将传递给视图的位置参数的列表.&lt;/p&gt;

&lt;p&gt;view_kwargs是将传递给视图的关键字参数的字典。 view_args和view_kwargs都不包含第一个视图参数（request）。&lt;/p&gt;

&lt;p&gt;Django会在调用视图函数之前调用process_view方法。&lt;/p&gt;

&lt;p&gt;它应该返回None或一个HttpResponse对象。 如果返回None，Django将继续处理这个请求，执行任何其他中间件的process_view方法，然后在执行相应的视图。 如果它返回一个HttpResponse对象，Django不会调用适当的视图函数。 它将执行中间件的process_response方法并将应用到该HttpResponse并返回结果。&lt;/p&gt;
&lt;p&gt; 给MD1和MD2添加process_view方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.utils.deprecation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MiddlewareMixin


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD1(MiddlewareMixin):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_view(self, request, view_func, view_args, view_kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; * 80&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1 中的process_view&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(view_func, view_func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD2(MiddlewareMixin):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2里面的 process_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_view(self, request, view_func, view_args, view_kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; * 80&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2 中的process_view&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(view_func, view_func.&lt;span&gt;__name__&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;访问index视图函数，看一下输出结果：&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MD2里面的 process_request
MD1里面的 process_request
&lt;/span&gt;--------------------------------------------------------------------------------&lt;span&gt;
MD2 中的process_view
&lt;/span&gt;&amp;lt;function index at 0x000001DE68317488&amp;gt;&lt;span&gt; index
&lt;/span&gt;--------------------------------------------------------------------------------&lt;span&gt;
MD1 中的process_view
&lt;/span&gt;&amp;lt;function index at 0x000001DE68317488&amp;gt;&lt;span&gt; index
app01 中的 index视图
MD1里面的 process_response
MD2里面的 process_response&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;process_view方法是在process_request之后，视图函数之前执行的，执行顺序按照MIDDLEWARE中的注册顺序&lt;strong&gt;从前到后顺序&lt;/strong&gt;&lt;span&gt;执行的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;process_exception&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;process_exception(self, request, exception)&lt;/p&gt;
&lt;p&gt;该方法两个参数:&lt;/p&gt;
&lt;p&gt;一个HttpRequest对象&lt;/p&gt;
&lt;p&gt;一个exception是视图函数异常产生的Exception对象。&lt;/p&gt;
&lt;p&gt;　　这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象。如果是HttpResponse对象，Django将调用模板和中间件中的process_response方法，并返回给浏览器，否则将默认处理异常。如果返回一个None，则交给下一个中间件的process_exception方法来处理异常。它的执行顺序也是按照中间件注册顺序的倒序执行。&lt;/p&gt;

&lt;p&gt; 给MD1和MD2添加上这个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.utils.deprecation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MiddlewareMixin


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD1(MiddlewareMixin):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_view(self, request, view_func, view_args, view_kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; * 80&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1 中的process_view&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(view_func, view_func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_exception(self, request, exception):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(exception)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1 中的process_exception&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD2(MiddlewareMixin):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2里面的 process_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_view(self, request, view_func, view_args, view_kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; * 80&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2 中的process_view&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(view_func, view_func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_exception(self, request, exception):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(exception)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2 中的process_exception&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果视图函数中无异常，process_exception方法不执行。&lt;/p&gt;
&lt;p&gt;想办法，在视图函数中抛出一个异常：&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index(request):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app01 中的 index视图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;呵呵&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;O98K&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在MD1的process_exception中返回一个响应对象：&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD1(MiddlewareMixin):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_view(self, request, view_func, view_args, view_kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; * 80&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1 中的process_view&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(view_func, view_func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_exception(self, request, exception):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(exception)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1 中的process_exception&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(str(exception))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回一个响应对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;看输出结果：&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MD2里面的 process_request
MD1里面的 process_request
&lt;/span&gt;--------------------------------------------------------------------------------&lt;span&gt;
MD2 中的process_view
&lt;/span&gt;&amp;lt;function index at 0x0000022C09727488&amp;gt;&lt;span&gt; index
&lt;/span&gt;--------------------------------------------------------------------------------&lt;span&gt;
MD1 中的process_view
&lt;/span&gt;&amp;lt;function index at 0x0000022C09727488&amp;gt;&lt;span&gt; index
app01 中的 index视图
呵呵
MD1 中的process_exception
MD1里面的 process_response
MD2里面的 process_response&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;注意，这里并没有执行MD2的process_exception方法，因为MD1中的process_exception方法直接返回了一个响应对象。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;process_template_response&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;process_template_response(self, request, response)&lt;/p&gt;

&lt;p&gt;它的参数，一个HttpRequest对象，response是TemplateResponse对象（由视图函数或者中间件产生）。&lt;/p&gt;

&lt;p&gt;process_template_response是在视图函数执行完成后立即执行，但是它有一个前提条件，那就是视图函数返回的对象有一个render()方法（或者表明该对象是一个TemplateResponse对象或等价方法）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD1(MiddlewareMixin):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1里面的 process_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_view(self, request, view_func, view_args, view_kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; * 80&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1 中的process_view&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(view_func, view_func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_exception(self, request, exception):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(exception)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1 中的process_exception&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; HttpResponse(str(exception))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_template_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD1 中的process_template_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MD2(MiddlewareMixin):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2里面的 process_request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2里面的 process_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_view(self, request, view_func, view_args, view_kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; * 80&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2 中的process_view&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(view_func, view_func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_exception(self, request, exception):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(exception)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2 中的process_exception&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_template_response(self, request, response):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MD2 中的process_template_response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; response
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;views.py中：&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index(request):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app01 中的 index视图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; render():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in index/render&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;O98K&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    rep &lt;/span&gt;= HttpResponse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    rep.render &lt;/span&gt;=&lt;span&gt; render
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; rep
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;访问index视图，终端输出的结果：&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MD2里面的 process_request
MD1里面的 process_request
&lt;/span&gt;--------------------------------------------------------------------------------&lt;span&gt;
MD2 中的process_view
&lt;/span&gt;&amp;lt;function index at 0x000001C111B97488&amp;gt;&lt;span&gt; index
&lt;/span&gt;--------------------------------------------------------------------------------&lt;span&gt;
MD1 中的process_view
&lt;/span&gt;&amp;lt;function index at 0x000001C111B97488&amp;gt;&lt;span&gt; index
app01 中的 index视图
MD1 中的process_template_response
MD2 中的process_template_response
&lt;/span&gt;&lt;span&gt;in&lt;/span&gt; index/&lt;span&gt;render
MD1里面的 process_response
MD2里面的 process_response&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从结果看出：&lt;/p&gt;
&lt;p&gt;视图函数执行完之后，立即执行了中间件的process_template_response方法，顺序是倒序，先执行MD1的，在执行MD2的，接着执行了视图函数返回的HttpResponse对象的render方法，返回了一个新的HttpResponse对象，接着执行中间件的process_response方法。&lt;/p&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;p&gt;   1. process_request(self, request)&lt;br/&gt;    - 视图函数执行之前（在urls.py找对应关系之前）&lt;br/&gt;    - 注册顺序&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   2. process_response(self, request, response)&lt;br/&gt;    - 视图函数执行之后&lt;br/&gt;    - 注册顺序的倒序  &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   3. process_view(self, view_func, view_args, view_kwargs)&lt;br/&gt;    - 视图函数执行之前（在urls.py中找到对应关系之后）&lt;br/&gt;     此时view_func就是将要执行的视图函数对象！！！&lt;br/&gt;    - 注册顺序&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;   4. process_exception(self, request, exception)&lt;br/&gt;    - 视图函数执行之后，只有在有异常的时候才执行&lt;br/&gt;    - 注册顺序的倒序&lt;br/&gt;  &lt;br/&gt;   5. process_template_response(self, request, response)&lt;br/&gt;    - 视图函数执行之后，只有在响应对象有render方法的时候才执行&lt;br/&gt;    - 注册顺序的倒序&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;中间件的执行流程&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;中间件的执行流程：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;请求到达中间件之后，先按照正序执行每个注册中间件的 process_request 方法，process_request 方法返回的值是None，就依次执行，如果返回的值是&lt;span&gt;HttpResponse&lt;/span&gt;对象，不再执行后面的 process_request 方法，而是执行当前对应中间件的 process_request 方法，将&lt;span data-mce-=&quot;&quot;&gt;HttpResponse&lt;/span&gt;对象返回给浏览器。也就说：&lt;span&gt;如果MIDDLEWARE中注册了6个中间件，执行过程中，第3个中间件返回了一个HttpResponse对象，那么第4,5,6中间件的process_request和process_response方法都不执行，顺序执行3,2,1中间件的process_response方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201804/867021-20180409214209079-1725524152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;process_request方法都执行完后，匹配路由，找到要执行的视图函数，先不执行视图函数，先执行中间件中的process_view方法，process_view方法返回None，继续按顺序执行，所有process_view方法执行完后执行视图函数。加入中间件3 的process_view方法返回了HttpResponse对象，则4,5,6的process_view以及视图函数都不执行，直接从最后一个中间件，也就是中间件6的process_response方法开始倒序执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201804/867021-20180409214307195-1684061444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;process_template_response和process_exception两个方法的触发是有条件的，执行顺序也是倒序。总结所有的执行流程如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201804/867021-20180409214356226-286908304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201804/867021-20180409214433968-2137571775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;中间件版登陆验证&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;中间件版的登录验证需要依靠session，所以数据库中要有django_session表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;urls.py&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.conf.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; url
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; app01 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    url(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^index/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.index),
    url(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^login/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, views.login, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
]

&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;views.py&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render, HttpResponse, redirect


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index(request):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; home(request):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; login(request):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        user &lt;/span&gt;= request.POST.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        pwd &lt;/span&gt;= request.POST.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Q1mi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; pwd == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置session&lt;/span&gt;
            request.session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; user
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取跳到登陆页面之前的URL&lt;/span&gt;
            next_url = request.GET.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果有，就跳转回登陆之前的URL&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; next_url:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redirect(next_url)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 否则默认跳转到index页面&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/index/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;login.html&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;meta http-equiv=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-ua-compatible&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IE=edge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;登录页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{% url 'login' %}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;用户名：&amp;lt;/label&amp;gt;
        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;密 码：&amp;lt;/label&amp;gt;
        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;my_middlewares.py&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthMD(MiddlewareMixin):
    white_list &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/login/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, ]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 白名单&lt;/span&gt;
    balck_list = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/black/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, ]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 黑名单&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request):
        &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; redirect, HttpResponse

        next_url &lt;/span&gt;=&lt;span&gt; request.path_info
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.path_info, request.get_full_path())

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; next_url &lt;span&gt;in&lt;/span&gt; self.white_list &lt;span&gt;or&lt;/span&gt; request.session.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; next_url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.balck_list:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;This is an illegal URL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/login/?next={}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(next_url))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在settings.py中注册&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
MIDDLEWARE =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.security.SecurityMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions.middleware.SessionMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.common.CommonMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.csrf.CsrfViewMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.auth.middleware.AuthenticationMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.messages.middleware.MessageMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;middlewares.AuthMD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;AuthMD中间件注册后，所有的请求都要走AuthMD的process_request方法。&lt;/p&gt;
&lt;p&gt;访问的URL在白名单内或者session中有user用户名，则不做阻拦走正常流程；&lt;/p&gt;
&lt;p&gt;如果URL在黑名单中，则返回This is an illegal URL的字符串；&lt;/p&gt;
&lt;p&gt;正常的URL但是需要登录后访问，让浏览器跳转到登录页面。&lt;/p&gt;
&lt;p&gt;注：AuthMD中间件中需要session，所以AuthMD注册的位置要在session中间的下方。&lt;/p&gt;

&lt;p&gt;附：Django请求流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201804/867021-20180409234112982-196913305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 10 Apr 2018 13:30:00 +0000</pubDate>
<dc:creator>低调的人儿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DI-DIAO/p/8782373.html</dc:identifier>
</item>
<item>
<title>ORA-01578和ORA-26040--NOLOGGING操作引起的坏块-错误解释和解决方案(文档ID 1623284.1) - ^_^小麦苗^_^</title>
<link>http://www.cnblogs.com/lhrbest/p/8783087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lhrbest/p/8783087.html</guid>
<description>&lt;hr/&gt;&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（一）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;操作引起的坏块（&lt;/span&gt;&lt;span&gt;ORA-01578&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ORA-26040&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果只是错误&lt;/span&gt;&lt;span&gt;ORA-01578&lt;/span&gt;&lt;span&gt;，而没有伴随&lt;/span&gt;&lt;span&gt;ORA-26040&lt;/span&gt;&lt;span&gt;，那么这个坏块是由其它的原因引起的坏块，可以尝试使用&lt;/span&gt;&lt;span&gt;RMAN&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;BMR&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Block Media Recovery&lt;/span&gt;&lt;span&gt;）修复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果数据段（表段、索引段）被定义为&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;属性，那么当&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;加&lt;/span&gt;&lt;span&gt;APPEND&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;UNRECOVERABLE&lt;/span&gt;&lt;span&gt;操作修改该数据段或者使用数据泵（&lt;/span&gt;&lt;span&gt;DATAPUMP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;impdp&lt;/span&gt;&lt;span&gt;参数&lt;/span&gt;&lt;span&gt;DISABLE_ARCHIVE_LOGGING:Y&lt;/span&gt;&lt;span&gt;时，联机重做日志只会记录很少的日志信息。如果这些联机重做日志或归档日志被用来恢复数据文件，那么&lt;/span&gt;&lt;span&gt;Oracle&lt;/span&gt;&lt;span&gt;会将对应的数据块标志为无效（&lt;/span&gt;&lt;span&gt;Soft Corrupt&lt;/span&gt;&lt;span&gt;），而且下一次访问这些数据块时，会报&lt;/span&gt;&lt;span&gt;ORA-01578&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ORA-26040&lt;/span&gt;&lt;span&gt;错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;SQL&amp;gt; select * from test_nologging;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORA-01578: ORACLE data block corrupted (file # 11, block # 84)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORA-01110: data file 4: '/oradata/users.dbf'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ORA-26040: Data block was loaded using the NOLOGGING option&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;数据字典视图&lt;/span&gt;&lt;span&gt;DBA_TABLES&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;DBA_INDEXES&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;DBA_LOBS&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;DBA_TAB_PARTITIONS&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;DBA_LOB_PARTITIONS&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;DBA_TAB_SUBPARTITIONS&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;LOGGING&lt;/span&gt;&lt;span&gt;列记录了&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;属性。若&lt;/span&gt;&lt;span&gt;LOGGING='NO'&lt;/span&gt;&lt;span&gt;则表示&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据泵&lt;/span&gt;&lt;span&gt;DATAPUMP&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;impdp&lt;/span&gt;&lt;span&gt;参数&lt;/span&gt;&lt;span&gt;DISABLE_ARCHIVE_LOGGING:Y&lt;/span&gt;&lt;span&gt;在执行导入时会禁止&lt;/span&gt;&lt;span&gt;LOGGING&lt;/span&gt;&lt;span&gt;定义，而产生&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;操作。如果相应的&lt;/span&gt;&lt;span&gt;datafile&lt;/span&gt;&lt;span&gt;被&lt;/span&gt;&lt;span&gt;restored&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;recovered&lt;/span&gt;&lt;span&gt;，那么接下来的涉及到目标表的查询会报错&lt;/span&gt;&lt;span&gt;ORA-1578&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ORA-26040&lt;/span&gt;&lt;span&gt;。如果数据库是&lt;/span&gt;&lt;span&gt;FORCE LOGGING&lt;/span&gt;&lt;span&gt;模式，那么&lt;/span&gt;&lt;span&gt;DISABLE_ARCHIVE_LOGGING&lt;/span&gt;&lt;span&gt;选项不会关闭&lt;/span&gt;&lt;span&gt;LOGGING&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;impdp&lt;/span&gt;&lt;span&gt;使用参数“&lt;/span&gt;&lt;span&gt;DISABLE_ARCHIVE_LOGGING:Y&lt;/span&gt;&lt;span&gt;”的一个例子&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;impdp scott/tiger directory=DATA_PUMP_DIR dumpfile=dp transform=disable_archive_logging:y&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;导致的坏块不会导致&lt;/span&gt;&lt;span&gt;RMAN&lt;/span&gt;&lt;span&gt;备份失败。一般来说&lt;/span&gt;&lt;span&gt;soft corrupt block&lt;/span&gt;&lt;span&gt;不会导致&lt;/span&gt;&lt;span&gt;RMAN&lt;/span&gt;&lt;span&gt;备份失败，不需要设置&lt;/span&gt;&lt;span&gt;MAXCORRUPT&lt;/span&gt;&lt;span&gt;。数据库备份中就会含有&lt;/span&gt;&lt;span&gt;soft corrupt block&lt;/span&gt;&lt;span&gt;，如果使用这些备份恢复数据，那么恢复的数据也含有&lt;/span&gt;&lt;span&gt;soft corrupt block&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除&lt;/span&gt;&lt;span&gt;ORA-26040&lt;/span&gt;&lt;span&gt;错误之外，当还有一些其他通用信息出现时，&lt;/span&gt;&lt;span&gt;block dump&lt;/span&gt;&lt;span&gt;可能会被产生。如果数据块的&lt;/span&gt;&lt;span&gt;block dump&lt;/span&gt;&lt;span&gt;内有&lt;/span&gt;&lt;span&gt;byte 0xff&lt;/span&gt;&lt;span&gt;信息或者属于某个段，&lt;/span&gt;&lt;span&gt;ORA-1578&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ORA-26040&lt;/span&gt;&lt;span&gt;会因为介质恢复了&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;的部分导致了&lt;/span&gt;&lt;span&gt;corruption&lt;/span&gt;&lt;span&gt;而出现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（二）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;利用&lt;/span&gt;&lt;span&gt;RMAN&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;DBV&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;检测&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;导致的坏块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DBV&lt;/span&gt;&lt;span&gt;在检测坏块时，如果&lt;/span&gt;&lt;span&gt;RDBMS&lt;/span&gt;&lt;span&gt;版本小于&lt;/span&gt;&lt;span&gt;10.2.0.4&lt;/span&gt;&lt;span&gt;，那么&lt;/span&gt;&lt;span&gt;DBV&lt;/span&gt;&lt;span&gt;打印错误&lt;/span&gt;&lt;span&gt;DBV-200&lt;/span&gt;&lt;span&gt;，如果&lt;/span&gt;&lt;span&gt;RDBMS&lt;/span&gt;&lt;span&gt;版本大于或等于&lt;/span&gt;&lt;span&gt;10.2.0.4&lt;/span&gt;&lt;span&gt;，那么&lt;/span&gt;&lt;span&gt;DBV&lt;/span&gt;&lt;span&gt;打印错误&lt;/span&gt;&lt;span&gt;DBV-201&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;DBV-00200: Block, dba 46137428, already marked corrupted&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DBV-00201: Block, DBA 46137428, marked corrupt for invalid redo application&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;RMAN&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;VALIDATE&lt;/span&gt;&lt;span&gt;命令可以用来检测&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;数据块，检查结果记录在视图&lt;/span&gt;&lt;span&gt;V$DATABASE_BLOCK_CORRUPTION&lt;/span&gt;&lt;span&gt;（小于&lt;/span&gt;&lt;span&gt;12c&lt;/span&gt;&lt;span&gt;的版本）和&lt;/span&gt;&lt;span&gt;V$NONLOGGED_BLOCK&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;12c&lt;/span&gt;&lt;span&gt;及其以上）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面的例子中检查出&lt;/span&gt;&lt;span&gt;DATAFILE 4&lt;/span&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt;933&lt;/span&gt;&lt;span&gt;坏块，查询&lt;/span&gt;&lt;span&gt;V$DATABASE_BLOCK_CORRUPTION&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;V$NONLOGGED_BLOCK&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; VALIDATE DATABASE;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;File Status Marked Corrupt Empty Blocks Blocks Examined High SCN&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---- ------ -------------- ------------ --------------- ----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4    OK     933            1            6401            2275124  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  File Name: /oracle/dbs/users.dbf&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;RMAN&lt;/span&gt;&lt;span&gt;在检测坏块时，如果&lt;/span&gt;&lt;span&gt;RDBMS&lt;/span&gt;&lt;span&gt;版本小于&lt;/span&gt;&lt;span&gt;10.2.0.5&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;11.1.0.7&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;RMAN&lt;/span&gt;&lt;span&gt;打印如下错误：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;10.2.0.4 and lower, 11.1.0.6, 11.1.0.7:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN validate reports it in v$database_block_corruption with CORRUPTION_TYPE=LOGICAL&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;RDBMS&lt;/span&gt;&lt;span&gt;版本大于或等于&lt;/span&gt;&lt;span&gt;10.2.0.5&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;11.2.0.1&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;RMAN&lt;/span&gt;&lt;span&gt;报告，查看视图&lt;/span&gt;&lt;span&gt;v$database_block_corruption&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;CORRUPTION_TYPE=NOLOGGING&lt;/span&gt;&lt;span&gt;的记录。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;10.2.0.5 and 11.2.0.1+:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN validate reports it in v$database_block_corruption with CORRUPTION_TYPE=NOLOGGING&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;12c&lt;/span&gt;&lt;span&gt;及以后版本中，&lt;/span&gt;&lt;span&gt;RMAN validate&lt;/span&gt;&lt;span&gt;的结果不在视图&lt;/span&gt;&lt;span&gt;v$database_block_corruption&lt;/span&gt;&lt;span&gt;中，而是在视图&lt;/span&gt;&lt;span&gt;v$nonlogged_block&lt;/span&gt;&lt;span&gt;。从&lt;/span&gt;&lt;span&gt;12.2&lt;/span&gt; &lt;span&gt;版本开始，可以使用新的命令：“&lt;/span&gt;&lt;span&gt;validate .. nonlogged block&lt;/span&gt;&lt;span&gt;”去验证&lt;/span&gt;&lt;span&gt;nologging&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在以下的例子中，数据文件&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt;nologged&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;36&quot;&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; validate database nonlogged block;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Starting validate at ...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;using target database control file instead of recovery catalog&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;allocated channel: ORA_DISK_1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: SID=133 device type=DISK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: starting validation of datafile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: validation complete, elapsed time: 00:00:35&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;List of Datafiles&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;=================&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;File Status Nonlogged Blocks Blocks Examined Blocks Skipped&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---- ------ ---------------- --------------- --------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1        OK 0                         106363 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2        OK 0                          78919 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3        OK 0                          96639 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4        OK 0                           4991 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5        OK 400                         2559 0&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6        OK 569                         2559 0&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Details of nonlogged blocks can be queried from v$nonlogged_block view&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在告警日志中会更新以下信息：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;Started Nonlogged Block Replacement recovery(validate) on file 5 (ospid 26351 rcvid 10616970560844821494)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finished Nonlogged Block Replacement recovery(validate) on file 5. 400 blocks found&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Started Nonlogged Block Replacement recovery(validate) on file 6 (ospid 26351 rcvid 10616970560844821494)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finished Nonlogged Block Replacement recovery(validate) on file 6. 569 blocks found&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（三）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;监控&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若执行了&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;操作，并且之后在没有备份的情况下，&lt;/span&gt;&lt;span&gt;RMAN&lt;/span&gt;&lt;span&gt;命令“&lt;/span&gt;&lt;span&gt;REPORT UNRECOVERABLE&lt;/span&gt;&lt;span&gt;”可以查询出被影响的&lt;/span&gt;&lt;span&gt;datafile&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; report unrecoverable;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;using target database control file instead of recovery catalog&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Report of files that need backup due to unrecoverable operations&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;File Type of Backup Required Name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---- ----------------------- -----------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4    full or incremental     /oracle/dbs/users.dbf&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当初始化参数&lt;/span&gt;&lt;span&gt;db_unrecoverable_scn_tracking&lt;/span&gt;&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;（默认值，该参数在&lt;/span&gt;&lt;span&gt;10g&lt;/span&gt;&lt;span&gt;中是不可用的），那么&lt;/span&gt;&lt;span&gt;V$DATAFILE&lt;/span&gt;&lt;span&gt;中以下列会被更新；&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;SYS@lhr121&amp;gt; select UNRECOVERABLE_CHANGE# ,   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2  UNRECOVERABLE_TIME    ,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  3  FIRST_NONLOGGED_SCN ,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  4  FIRST_NONLOGGED_TIME from v$datafile where file#=6;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UNRECOVERABLE_CHANGE# UNRECOVERABLE_TIME  FIRST_NONLOGGED_SCN FIRST_NONLOGGED_TIM&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--------------------- ------------------- ------------------- -------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;              2878238 2018-04-10 10:53:47             2878238 2018-04-10 10:53:47&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;11.2.0.4&lt;/span&gt; &lt;span&gt;或&lt;/span&gt;&lt;span&gt;12.1.0.2+&lt;/span&gt;&lt;span&gt;版本中，设置&lt;/span&gt;&lt;span&gt;event 16490&lt;/span&gt;&lt;span&gt;的情况下，物理备库的&lt;/span&gt;&lt;span&gt;MRP&lt;/span&gt;&lt;span&gt;进程会检查出&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;变化，并记录在&lt;/span&gt;&lt;span&gt;alert log&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;ORA-16490 &quot;logging invalidated blocks on standby due to invalidation redo&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;INVD_BLKS: Invalidating (file &amp;lt;file number&amp;gt;, bno &amp;lt;block number&amp;gt;)&quot;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;fname: 'Datafile name'. rdba: ...&quot;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（四）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;识别数据块什么时候被标志为&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;识别数据块什么时候被标志为&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;，可以将&lt;/span&gt;&lt;span&gt;trace&lt;/span&gt;&lt;span&gt;文件中数据块&lt;/span&gt;&lt;span&gt;SCN&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;v$database_block_coruption&lt;/span&gt;&lt;span&gt;视图中&lt;/span&gt;&lt;span&gt;CORRUPTION_CHANGE#&lt;/span&gt;&lt;span&gt;值转换为时间：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①　&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;trace&lt;/span&gt;&lt;span&gt;文件中数据块&lt;/span&gt;&lt;span&gt;SCN&lt;/span&gt;&lt;span&gt;，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;  Start dump data blocks tsn: 60 file#: 4 minblk 84 maxblk 84&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  buffer tsn: 3 rdba: 0x02c00054 (11/84)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  scn: 0x0771.4fa24eb5 seq: 0xff flg: 0x04 tail: 0x4eb500ff&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;提取&lt;/span&gt;&lt;span&gt;SCN&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;span&gt;0x0771.4fa24eb5,&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;&lt;span&gt;'.'&lt;/span&gt;&lt;span&gt;，然后转换&lt;/span&gt;&lt;span&gt;0x07714fa24eb&lt;/span&gt;&lt;span&gt;到十进制&lt;/span&gt;&lt;span&gt;511453045995&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②　&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;v$database_block_coruption&lt;/span&gt;&lt;span&gt;视图中&lt;/span&gt;&lt;span&gt;CORRUPTION_CHANGE#&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果运行&lt;/span&gt;&lt;span&gt;RMAN validate&lt;/span&gt;&lt;span&gt;命令后，&lt;/span&gt;&lt;span&gt;v$database_block_coruption&lt;/span&gt;&lt;span&gt;视图中&lt;/span&gt;&lt;span&gt;corruption_type='NOLOGGING' (10.2.0.5&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;11.2.0.1+)&lt;/span&gt;&lt;span&gt;，那么&lt;/span&gt;&lt;span&gt;CORRUPTION_CHANGE#&lt;/span&gt;&lt;span&gt;列的值就是十进制的&lt;/span&gt;&lt;span&gt;SCN&lt;/span&gt;&lt;span&gt;值。可以使用下面的方法获得&lt;/span&gt;&lt;span&gt;SCN Timestamp&lt;/span&gt;&lt;span&gt;时间：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;select scn_to_timestamp(&amp;amp;&amp;amp;decimal_scn) from dual;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果运行&lt;/span&gt;&lt;span&gt;RMAN validate:&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;select file#, block#, scn_to_timestamp(CORRUPTION_CHANGE#)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from v$database_block_corruption&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;where CORRUPTION_TYPE='NOLOGGING';&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;12c&lt;/span&gt;&lt;span&gt;中：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;select file#, block#, scn_to_timestamp(NONLOGGED_START_CHANGE#) from v$nonlogged_block;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果查询&lt;/span&gt;&lt;span&gt;gv$archived_log&lt;/span&gt; &lt;span&gt;或&lt;/span&gt; &lt;span&gt;gv$log_history&lt;/span&gt;&lt;span&gt;遇到错误&lt;/span&gt;&lt;span&gt;ORA-08181:&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;62&quot;&gt;
&lt;p&gt;&lt;span&gt;alter session set nls_date_format = 'DD-MON-YY HH24:MI:SS';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select first_time, next_time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from gv$archived_log&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;where &amp;amp;decimal_scn between first_change# and next_change#;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select first_time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from gv$log_history&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;where &amp;amp;decimal_scn between first_change# and next_change#;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果运行&lt;/span&gt;&lt;span&gt;RMAN validate:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;alter session set nls_date_format = 'DD-MON-YY HH24:MI:SS';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select file#, block#, first_time, next_time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from v$archived_log, v$database_block_corruption&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;where CORRUPTION_CHANGE# between first_change# and next_change#&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;and CORRUPTION_TYPE='NOLOGGING';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select file#,block#,first_time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from   v$log_history, v$database_block_corruption&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;where  CORRUPTION_CHANGE# between first_change# and next_change#&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  and CORRUPTION_TYPE='NOLOGGING';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;12c:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;alter session set nls_date_format = 'DD-MON-YY HH24:MI:SS';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select file#, block#, first_time, next_time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from v$nonlogged_block, v$archived_log&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;where NONLOGGED_START_CHANGE# between first_change# and next_change#;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select file#, block#, first_time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from v$nonlogged_block, v$log_history&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;where NONLOGGED_START_CHANGE# between first_change# and next_change#;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（五）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;SYSAUX&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;表空间、&lt;/span&gt;&lt;span&gt;AWR&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;EM&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;等出现&lt;/span&gt;&lt;span&gt;NOARCHIVELOG&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果数据库版本是&lt;/span&gt;&lt;span&gt;11.1.0.6&lt;/span&gt; &lt;span&gt;或&lt;/span&gt; &lt;span&gt;11.1.0.7&lt;/span&gt; &lt;span&gt;或&lt;/span&gt; &lt;span&gt;11.2.0.1&lt;/span&gt;&lt;span&gt;，对&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;对象执行过&lt;/span&gt;&lt;span&gt;DIRECT PATH&lt;/span&gt;&lt;span&gt;操作，并且后续执行了&lt;/span&gt;&lt;span&gt;RECOVER DATABASE&lt;/span&gt;&lt;span&gt;命令，即使数据库&lt;/span&gt;&lt;span&gt;FORCE LOGGING&lt;/span&gt;&lt;span&gt;是打开的情况下，会出现&lt;/span&gt;&lt;span&gt;ORA-1578&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ORA-26040&lt;/span&gt;&lt;span&gt;错误。这种问题经常发生在&lt;/span&gt;&lt;span&gt;SYSAUX&lt;/span&gt;&lt;span&gt;表空间中的&lt;/span&gt;&lt;span&gt;AWR&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;EM&lt;/span&gt;&lt;span&gt;对象。请参考&lt;/span&gt;&lt;span&gt;Note 1071869.1&lt;/span&gt;&lt;span&gt;。注意数据库当前版本可能已经大于&lt;/span&gt;&lt;span&gt;11.1&lt;/span&gt; &lt;span&gt;或者&lt;/span&gt; &lt;span&gt;11.2.0.1&lt;/span&gt;&lt;span&gt;但是问题可能是在升级之前产生的。这个约束在&lt;/span&gt;&lt;span&gt;11.2.0.2&lt;/span&gt;&lt;span&gt;以上版本中取消，这个问题在&lt;/span&gt;&lt;span&gt;10g&lt;/span&gt;&lt;span&gt;不会发生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RDBMS&lt;/span&gt;&lt;span&gt;版本变化：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;226&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;RDBMS&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;版本&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;501&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;变化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td width=&quot;226&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;10.2.0.4+&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;501&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;DBverify&lt;/span&gt;&lt;span&gt;报告&lt;/span&gt;&lt;span&gt;NOLOGGING block&lt;/span&gt;&lt;span&gt;错误信息&lt;/span&gt; &lt;span&gt;&quot;DBV-00201: Block, DBA &amp;lt;rdba&amp;gt;, marked corrupt for invalid redo application&quot;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;226&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;10.2.0.5, 10.2.0.1+&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;501&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;RMAN validate&lt;/span&gt;&lt;span&gt;命令检查&lt;/span&gt;&lt;span&gt;NOLOGGING block&lt;/span&gt;&lt;span&gt;，在&lt;/span&gt;&lt;span&gt;v$database_block_coruption&lt;/span&gt;&lt;span&gt;视图中记录&lt;/span&gt;&lt;span&gt;corruption_type='NOLOGGING'&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;226&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;11g+&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;501&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;引入&lt;/span&gt;&lt;span&gt;db_unrecoverable_scn_tracking&lt;/span&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td width=&quot;226&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;11.1.0.6 or 11.1.0.7 or 11.2.0.1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;501&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;NOARCHIVELOG&lt;/span&gt;&lt;span&gt;模式数据库，对&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;对象执行了&lt;/span&gt;&lt;span&gt;DIRECT PATH&lt;/span&gt;&lt;span&gt;操作，并且以后手动恢复数据库，即使打开了&lt;/span&gt;&lt;span&gt;FORCE LOGGING&lt;/span&gt;&lt;span&gt;，也会报&lt;/span&gt;&lt;span&gt;ORA-1578&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;ORA-26040&lt;/span&gt;&lt;span&gt;。这个约束在&lt;/span&gt;&lt;span&gt;11.2.0.2&lt;/span&gt;&lt;span&gt;以上版本取消，这个问题在&lt;/span&gt;&lt;span&gt;10g&lt;/span&gt;&lt;span&gt;不会发生。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;226&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;12c&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;501&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;RMAN validate&lt;/span&gt;&lt;span&gt;的结果不在视图&lt;/span&gt;&lt;span&gt;v$database_block_corruption&lt;/span&gt;&lt;span&gt;中，而是在视图&lt;/span&gt;&lt;span&gt;v$nonlogged_block&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;226&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;12.2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;501&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;以下&lt;/span&gt;&lt;span&gt;RMAN&lt;/span&gt;&lt;span&gt;命令被引入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; validate [database / datafile] nonlogged block;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; recover [database / datafile] nonlogged block; -&amp;gt;&lt;/span&gt; &lt;span&gt;对于&lt;/span&gt; &lt;span&gt;Standby&lt;/span&gt; &lt;span&gt;数据库&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（六）&lt;/span&gt;&lt;strong&gt;&lt;span&gt;解决方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;操作引起的坏块是不能修复的，比如“&lt;/span&gt;&lt;span&gt;Media Recovery&lt;/span&gt;&lt;span&gt;”或“&lt;/span&gt;&lt;span&gt;RMAN blockrecover&lt;/span&gt;&lt;span&gt;”都无法修复这种坏块。可行的方法是在&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;操作之后立刻备份对应的数据文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果错误是执行&lt;/span&gt;&lt;span&gt;RMAN DUPLICATE&lt;/span&gt; &lt;span&gt;或&lt;/span&gt; &lt;span&gt;RESTORE&lt;/span&gt;&lt;span&gt;之后产生的，那么在源库打开&lt;/span&gt;&lt;span&gt;FORCE LOGGING&lt;/span&gt;&lt;span&gt;，然后再重新运行&lt;/span&gt;&lt;span&gt;RMAN DUPLICATE&lt;/span&gt; &lt;span&gt;或&lt;/span&gt; &lt;span&gt;RESTORE&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;alter database force logging;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果错误出现在物理&lt;/span&gt;&lt;span&gt;STANDBY&lt;/span&gt;&lt;span&gt;数据库，那么可以从主库恢复被影响的数据文件（只有当主库没有这个问题的情况下）。参考文档&lt;/span&gt;&lt;span&gt;Doc ID 958181.1&lt;/span&gt;&lt;span&gt;。在&lt;/span&gt;&lt;span&gt;Oracle 12c&lt;/span&gt;&lt;span&gt;中可以使用&lt;/span&gt;&lt;span&gt;RMAN&lt;/span&gt;&lt;span&gt;选项&lt;/span&gt;&lt;span&gt;RECOVER NONLOGGED BLOCK with DATAFILE&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;TABLESPACE&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;DATABASE&lt;/span&gt;&lt;span&gt;。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; RECOVER DATABASE NONLOGGED BLOCK;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;为了避免这个问题发生，在主库强制生产日志：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;alter database force logging;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果同一个&lt;/span&gt;&lt;span&gt;datafile&lt;/span&gt;&lt;span&gt;的数据块在主库出现&lt;/span&gt;&lt;span&gt;nologging&lt;/span&gt;&lt;span&gt;坏块，但是备库没有，可以通过手动跳过&lt;/span&gt;&lt;span&gt;(dbms_repair)&lt;/span&gt;&lt;span&gt;坏块或者设置&lt;/span&gt;&lt;span&gt;event 10231&lt;/span&gt;&lt;span&gt;。主库出现&lt;/span&gt;&lt;span&gt;nologging&lt;/span&gt;&lt;span&gt;坏块可能是由于主库执行过备份恢复或者之前是备库，执行了&lt;/span&gt;&lt;span&gt;switchover&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;NOLOGGING&lt;/span&gt;&lt;span&gt;数据块位于空闲数据块（&lt;/span&gt;&lt;span&gt;dba_free_space&lt;/span&gt;&lt;span&gt;视图可以查询到），那么&lt;/span&gt;&lt;span&gt;DBVerify&lt;/span&gt;&lt;span&gt;检查会发现这个问题，报错&lt;/span&gt;&lt;span&gt;DBV-00201&lt;/span&gt;&lt;span&gt;或者在&lt;/span&gt;&lt;span&gt;v$database_block_corruption&lt;/span&gt;&lt;span&gt;视图中显示。对于这种情况，可以等待到这个数据块被重用时会自动格式化或者手动强制格式化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是索引，那么可以重新创建（&lt;/span&gt;&lt;span&gt;drop/create&lt;/span&gt;&lt;span&gt;）索引。如果是表，那么可以使用存储过程&lt;/span&gt;&lt;span&gt;DBMS_REPAIR.SKIP_CORRUPT_BLOCKS&lt;/span&gt;&lt;span&gt;跳过坏块，然后考虑是否重建表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在删除有坏块的段之后，这个坏块就处于空闲状态，后续可以被分配给其他对象或段，当这个坏块被分配给其它对象或段时，这个数据块被重新格式化。如果&lt;/span&gt;&lt;span&gt;v$database_block_corruption&lt;/span&gt;&lt;span&gt;视图中还是显示为坏块，那么可以手动运行&lt;/span&gt;&lt;span&gt;rman validate&lt;/span&gt;&lt;span&gt;来清除视图中的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是&lt;/span&gt;&lt;span&gt;LOB&lt;/span&gt;&lt;span&gt;，那么请参考&lt;/span&gt;&lt;span&gt;Note 293515.1&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;实验一：&lt;/span&gt;&lt;span&gt;DISABLE_ARCHIVE_LOGGING:Y&lt;/span&gt;&lt;/h2&gt;
&lt;div readability=&quot;207&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; list backupset of datafile 6;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;List of Backup Sets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;===================&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BS Key  Type LV Size       Device Type Elapsed Time Completion Time   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------- ---- -- ---------- ----------- ------------ -------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;12      Full    352.78M    DISK        00:03:21     2018-04-09 14:50:59&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        BP Key: 12   Status: AVAILABLE  Compressed: YES  Tag: TAG20180409T144738&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Piece Name: /u04/flash_recovery_area/LHR121/backupset/2018_04_09/o1_mf_nnndf_TAG20180409T144738_fdp34bfm_.bkp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  List of Datafiles in backup set 12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  File LV Type Ckp SCN    Ckp Time            Name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  ---- -- ---- ---------- ------------------- ----&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  6       Full 2865977    2018-04-09 14:47:38 /u04/oradata/lhr121/users01.dbf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr env_oracle]$ impdp scott/tiger dumpfile=log.dmp tables=T_LOG TRANSFORM=DISABLE_ARCHIVE_LOGGING:Y remap_schema=LHR:SCOTT&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Import: Release 12.1.0.2.0 - Production on Tue Apr 10 10:53:17 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2014, Oracle and/or its affiliates.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Connected to: Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Advanced Analytics and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORA-39002: invalid operation&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORA-39166: Object SCOTT.T_LOG was not found or could not be exported or imported.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr env_oracle]$ impdp lhr/lhr dumpfile=log.dmp tables=T_LOG TRANSFORM=DISABLE_ARCHIVE_LOGGING:Y remap_schema=LHR:SCOTT&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Import: Release 12.1.0.2.0 - Production on Tue Apr 10 10:53:40 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2014, Oracle and/or its affiliates.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Connected to: Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Advanced Analytics and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Master table &quot;LHR&quot;.&quot;SYS_IMPORT_TABLE_02&quot; successfully loaded/unloaded&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Starting &quot;LHR&quot;.&quot;SYS_IMPORT_TABLE_02&quot;:  lhr/******** dumpfile=log.dmp tables=T_LOG TRANSFORM=DISABLE_ARCHIVE_LOGGING:Y remap_schema=LHR:SCOTT&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Processing object type TABLE_EXPORT/TABLE/TABLE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Processing object type TABLE_EXPORT/TABLE/TABLE_DATA&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;. . imported &quot;SCOTT&quot;.&quot;T_LOG&quot;                             34.24 KB       9 rows&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Processing object type TABLE_EXPORT/TABLE/INDEX/INDEX&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Processing object type TABLE_EXPORT/TABLE/INDEX/STATISTICS/INDEX_STATISTICS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Processing object type TABLE_EXPORT/TABLE/STATISTICS/TABLE_STATISTICS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Processing object type TABLE_EXPORT/TABLE/STATISTICS/MARKER&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Job &quot;LHR&quot;.&quot;SYS_IMPORT_TABLE_02&quot; successfully completed at Tue Apr 10 10:54:14 2018 elapsed 0 00:00:32&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr env_oracle]$ rm -rf /u04/oradata/lhr121/users01.dbf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr env_oracle]$ rman target /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Recovery Manager: Release 12.1.0.2.0 - Production on Tue Apr 10 10:55:09 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2014, Oracle and/or its affiliates.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;connected to target database: LHR121 (DBID=3221842516)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; restore datafile 6;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Starting restore at 2018-04-10 10:55:17&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;using target database control file instead of recovery catalog&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;allocated channel: ORA_DISK_1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: SID=29 device type=DISK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: starting datafile backup set restore&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: specifying datafile(s) to restore from backup set&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: restoring datafile 00006 to /u04/oradata/lhr121/users01.dbf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: reading from backup piece /u04/flash_recovery_area/LHR121/backupset/2018_04_09/o1_mf_nnndf_TAG20180409T144738_fdp34bfm_.bkp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN-00571: ===========================================================&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN-00569: =============== ERROR MESSAGE STACK FOLLOWS ===============&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN-00571: ===========================================================&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN-03002: failure of restore command at 04/10/2018 10:55:20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORA-19870: error while restoring backup piece /u04/flash_recovery_area/LHR121/backupset/2018_04_09/o1_mf_nnndf_TAG20180409T144738_fdp34bfm_.bkp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORA-19573: cannot obtain exclusive enqueue for datafile 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; startup force mount&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Oracle instance started&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;database mounted&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Total System Global Area     658505728 bytes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Fixed Size                     2927864 bytes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Variable Size                285213448 bytes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Database Buffers             364904448 bytes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Redo Buffers                   5459968 bytes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; restore datafile 6;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Starting restore at 2018-04-10 10:57:02&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;allocated channel: ORA_DISK_1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: SID=12 device type=DISK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: starting datafile backup set restore&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: specifying datafile(s) to restore from backup set&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: restoring datafile 00006 to /u04/oradata/lhr121/users01.dbf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: reading from backup piece /u04/flash_recovery_area/LHR121/backupset/2018_04_09/o1_mf_nnndf_TAG20180409T144738_fdp34bfm_.bkp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: piece handle=/u04/flash_recovery_area/LHR121/backupset/2018_04_09/o1_mf_nnndf_TAG20180409T144738_fdp34bfm_.bkp tag=TAG20180409T144738&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: restored backup piece 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: restore complete, elapsed time: 00:00:03&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finished restore at 2018-04-10 10:57:06&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; recover datafile 6;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Starting recover at 2018-04-10 10:57:13&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;using channel ORA_DISK_1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;starting media recovery&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log for thread 1 with sequence 39 is already on disk as file /u04/flash_recovery_area/LHR121/archivelog/2018_04_09/o1_mf_1_39_fdp3bvmm_.arc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log for thread 1 with sequence 40 is already on disk as file /u04/flash_recovery_area/LHR121/archivelog/2018_04_09/o1_mf_1_40_fdp3bvoz_.arc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log for thread 1 with sequence 41 is already on disk as file /u04/flash_recovery_area/LHR121/archivelog/2018_04_09/o1_mf_1_41_fdp7bhhl_.arc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log for thread 1 with sequence 42 is already on disk as file /u04/flash_recovery_area/LHR121/archivelog/2018_04_09/o1_mf_1_42_fdp7ccfv_.arc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log for thread 1 with sequence 43 is already on disk as file /u04/flash_recovery_area/LHR121/archivelog/2018_04_10/o1_mf_1_43_fdr7xxg4_.arc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log for thread 1 with sequence 44 is already on disk as file /u04/flash_recovery_area/LHR121/archivelog/2018_04_10/o1_mf_1_44_fdr7yc13_.arc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log file name=/u04/flash_recovery_area/LHR121/archivelog/2018_04_09/o1_mf_1_39_fdp3bvmm_.arc thread=1 sequence=39&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log file name=/u04/flash_recovery_area/LHR121/archivelog/2018_04_09/o1_mf_1_40_fdp3bvoz_.arc thread=1 sequence=40&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log file name=/u04/flash_recovery_area/LHR121/archivelog/2018_04_09/o1_mf_1_41_fdp7bhhl_.arc thread=1 sequence=41&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log file name=/u04/flash_recovery_area/LHR121/archivelog/2018_04_09/o1_mf_1_42_fdp7ccfv_.arc thread=1 sequence=42&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;media recovery complete, elapsed time: 00:00:01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finished recover at 2018-04-10 10:57:15&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; alter database open;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Statement processed&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;118&quot;&gt;
&lt;p&gt;&lt;span&gt;SYS@lhr121&amp;gt; select * from v$nonlogged_block;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     FILE#     BLOCK#     BLOCKS NONLOGGED_START_CHANGE# NONLOGGED_START_TIM NONLOGGED_END_CHANGE# NONLOGGED_END_TIME  RESETLOGS_CHANGE# RESETLOGS_TIME      OBJECT#                                 REASON      CON_ID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------- ---------- ---------- ----------------------- ------------------- --------------------- ------------------- ----------------- ------------------- ---------------------------------------- ------- ----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         6       1939          1                 2878238                                   2878238                                                          UNKNOWN           0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@lhr121&amp;gt; select file#, block#, scn_to_timestamp(NONLOGGED_START_CHANGE#)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2  from v$nonlogged_block;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     FILE#     BLOCK# SCN_TO_TIMESTAMP(NONLOGGED_START_CHANGE#)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------- ---------- ---------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         6       1939 10-APR-18 10.52.44.000000000 AM&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@lhr121&amp;gt; SELECT TABLESPACE_NAME,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2         SEGMENT_TYPE,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  3         OWNER,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  4         SEGMENT_NAME,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  5         PARTITION_NAME&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  6  FROM   DBA_EXTENTS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  7  WHERE  FILE_ID = 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  8  AND    1939 BETWEEN BLOCK_ID AND BLOCK_ID + BLOCKS - 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  9  ;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TABLESPACE_NAME     SEGMENT_TYPE       OWNER               SEGMENT_NAME       PARTITION_NAME&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------------------- ------------------ ------------------ -----------------  -----------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;USERS               TABLE              SCOTT               T_LOG&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@lhr121&amp;gt; SELECT DBMS_ROWID.ROWID_OBJECT(ROWID) OBJECT_ID,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2         DBMS_ROWID.ROWID_RELATIVE_FNO(ROWID) FILE_ID,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  3         DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID) BLOCK_ID,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  4         COUNT(1) COUNTS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  5    FROM scott.t_log&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  6   GROUP BY DBMS_ROWID.ROWID_OBJECT(ROWID),&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  7            DBMS_ROWID.ROWID_RELATIVE_FNO(ROWID),&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  8            DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  9   ORDER BY DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; OBJECT_ID    FILE_ID   BLOCK_ID     COUNTS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------- ---------- ---------- ----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     94411          6       1939          9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@lhr121&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@lhr121&amp;gt; select * from  scott.t_log;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select * from  scott.t_log&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       *&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ERROR at line 1:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORA-01578: ORACLE data block corrupted (file # 6, block # 1939)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORA-01110: data file 6: '/u04/oradata/lhr121/users01.dbf'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORA-26040: Data block was loaded using the NOLOGGING option&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@lhr121&amp;gt; select UNRECOVERABLE_CHANGE# ,   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2  UNRECOVERABLE_TIME    ,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  3  FIRST_NONLOGGED_SCN ,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  4  FIRST_NONLOGGED_TIME from v$datafile where file#=6;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UNRECOVERABLE_CHANGE# UNRECOVERABLE_TIME  FIRST_NONLOGGED_SCN FIRST_NONLOGGED_TIM&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--------------------- ------------------- ------------------- -------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;              2878238 2018-04-10 10:53:47             2878238 2018-04-10 10:53:47&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;实验二：&lt;/span&gt;&lt;span&gt;NOLOGGING+APPEND&lt;/span&gt;&lt;/h2&gt;
&lt;div readability=&quot;426&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@ora11g &amp;gt; create table test_nologging as select * from user_tables;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table created.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@ora11g &amp;gt; alter table test_nologging nologging;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table altered.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@ora11g &amp;gt; select tablespace_name from user_tables where table_name='TEST_NOLOGGING';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TABLESPACE_NAME&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;USERS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; alter database  no force logging;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Database altered.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; select force_logging from v$database;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FOR&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; alter database drop  supplemental log data;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Database altered.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; alter database  drop  supplemental log data(all,primary key,unique,foreign key) columns;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Database altered.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; SELECT supplemental_log_data_min min,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2         supplemental_log_data_pk pk,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  3         supplemental_log_data_ui ui,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  4         supplemental_log_data_fk fk,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  5         supplemental_log_data_all allc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  6    FROM v$database;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MIN      PK  UI  FK  ALL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-------- --- --- --- ---&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NO       NO  NO  NO  NO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@ora11g &amp;gt; exit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Disconnected from Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Data Mining and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr env_oracle]$ rman target /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Recovery Manager: Release 11.2.0.3.0 - Production on Tue Apr 10 13:27:25 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2011, Oracle and/or its affiliates.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;connected to target database: ORA11G (DBID=4270446895)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; backup datafile 4;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Starting backup at 2018-04-10 13:27:37&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;using target database control file instead of recovery catalog&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;allocated channel: ORA_DISK_1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: SID=155 device type=DISK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: starting full datafile backup set&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: specifying datafile(s) in backup set&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;input datafile file number=00004 name=/u01/app/oracle/oradata/ora11g/users01.dbf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: starting piece 1 at 2018-04-10 13:27:39&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: finished piece 1 at 2018-04-10 13:29:36&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;piece handle=/u05/app/oracle/flash_recovery_area/ORA11G/backupset/2018_04_10/o1_mf_nnndf_TAG20180410T132739_fdrltcot_.bkp tag=TAG20180410T132739 comment=NONE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: backup set complete, elapsed time: 00:01:58&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finished backup at 2018-04-10 13:29:37&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; exit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Recovery Manager complete.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$ sas&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL*Plus: Release 11.2.0.3.0 Production on Tue Apr 10 14:14:15 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2011, Oracle.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Connected to:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Data Mining and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; conn lhr/lhr&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Connected.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@ora11g &amp;gt; insert /*+append */ into TEST_NOLOGGING select * from test_nologging;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3264 rows created.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@ora11g &amp;gt; commit;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Commit complete.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@ora11g &amp;gt; exit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Disconnected from Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Data Mining and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$&lt;/span&gt; &lt;strong&gt;&lt;span&gt;mv /u01/app/oracle/oradata/ora11g/users01.dbf /u01/app/oracle/oradata/ora11g/users01.dbf_bk&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$ sas&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL*Plus: Release 11.2.0.3.0 Production on Tue Apr 10 14:11:34 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2011, Oracle.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Connected to:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Data Mining and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; startup force mount&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;exit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORACLE instance started.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Total System Global Area  409194496 bytes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Fixed Size                  2228864 bytes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Variable Size             322964864 bytes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Database Buffers           75497472 bytes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Redo Buffers                8503296 bytes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Database mounted.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; Disconnected from Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Data Mining and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$ rman target /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Recovery Manager: Release 11.2.0.3.0 - Production on Tue Apr 10 14:11:57 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2011, Oracle and/or its affiliates.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;connected to target database: ORA11G (DBID=4270446895, not open)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; restore datafile 4;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Starting restore at 2018-04-10 14:12:07&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;using target database control file instead of recovery catalog&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;allocated channel: ORA_DISK_1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: SID=133 device type=DISK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: starting datafile backup set restore&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: specifying datafile(s) to restore from backup set&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: restoring datafile 00004 to /u01/app/oracle/oradata/ora11g/users01.dbf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: reading from backup piece /u05/app/oracle/flash_recovery_area/ORA11G/backupset/2018_04_10/o1_mf_nnndf_TAG20180410T132739_fdrltcot_.bkp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: piece handle=/u05/app/oracle/flash_recovery_area/ORA11G/backupset/2018_04_10/o1_mf_nnndf_TAG20180410T132739_fdrltcot_.bkp tag=TAG20180410T132739&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: restored backup piece 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: restore complete, elapsed time: 00:01:16&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finished restore at 2018-04-10 14:13:24&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; recover datafile 4;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Starting recover at 2018-04-10 14:13:34&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;using channel ORA_DISK_1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;starting media recovery&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log for thread 1 with sequence 330 is already on disk as file /u05/app/oracle/flash_recovery_area/ORA11G/archivelog/2018_04_10/o1_mf_1_330_fdrm7pm4_.arc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log for thread 1 with sequence 331 is already on disk as file /u05/app/oracle/flash_recovery_area/ORA11G/archivelog/2018_04_10/o1_mf_1_331_fdrmly0v_.arc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log for thread 1 with sequence 332 is already on disk as file /u05/app/oracle/flash_recovery_area/ORA11G/archivelog/2018_04_10/o1_mf_1_332_fdrn29bv_.arc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log for thread 1 with sequence 333 is already on disk as file /u05/app/oracle/flash_recovery_area/ORA11G/archivelog/2018_04_10/o1_mf_1_333_fdrnohdf_.arc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log for thread 1 with sequence 334 is already on disk as file /u05/app/oracle/flash_recovery_area/ORA11G/archivelog/2018_04_10/o1_mf_1_334_fdrnwqqw_.arc&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log file name=/u05/app/oracle/flash_recovery_area/ORA11G/archivelog/2018_04_10/o1_mf_1_330_fdrm7pm4_.arc thread=1 sequence=330&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log file name=/u05/app/oracle/flash_recovery_area/ORA11G/archivelog/2018_04_10/o1_mf_1_331_fdrmly0v_.arc thread=1 sequence=331&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;archived log file name=/u05/app/oracle/flash_recovery_area/ORA11G/archivelog/2018_04_10/o1_mf_1_332_fdrn29bv_.arc thread=1 sequence=332&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;media recovery complete, elapsed time: 00:00:01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finished recover at 2018-04-10 14:13:37&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; alter database open;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;database opened&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; exit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Recovery Manager complete.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$ sas&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL*Plus: Release 11.2.0.3.0 Production on Tue Apr 10 14:14:15 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2011, Oracle.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Connected to:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Data Mining and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; select count(1) from lhr.test_nologging;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select count(1) from lhr.test_nologging&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                         *&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ERROR at line 1:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORA-01578: ORACLE data block corrupted (file # 4, block # 180937)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ORA-01110: data file 4: '/u01/app/oracle/oradata/ora11g/users01.dbf'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ORA-26040: Data block was loaded using the NOLOGGING option&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; select UNRECOVERABLE_CHANGE# ,   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2         UNRECOVERABLE_TIME    ,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  3         FIRST_NONLOGGED_SCN ,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  4         FIRST_NONLOGGED_TIME&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  5  from v$datafile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  6  where file#=4;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UNRECOVERABLE_CHANGE# UNRECOVERABLE_TIME  FIRST_NONLOGGED_SCN FIRST_NONLOGGED_TIM&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--------------------- ------------------- ------------------- -------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             60522292 2018-04-10 14:11:22            60522291 2018-04-10 14:11:22&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; select * from v$database_block_corruption;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;no rows selected&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; exit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Disconnected from Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Data Mining and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$ rman target /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Recovery Manager: Release 11.2.0.3.0 - Production on Tue Apr 10 14:15:42 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2011, Oracle and/or its affiliates.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;connected to target database: ORA11G (DBID=4270446895)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; validate datafile 4;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Starting validate at 2018-04-10 14:15:50&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;using target database control file instead of recovery catalog&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;allocated channel: ORA_DISK_1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: SID=21 device type=DISK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: starting validation of datafile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: specifying datafile(s) for validation&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;input datafile file number=00004 name=/u01/app/oracle/oradata/ora11g/users01.dbf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: validation complete, elapsed time: 00:00:35&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;List of Datafiles&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;=================&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;File Status Marked Corrupt Empty Blocks Blocks Examined High SCN&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---- ------ -------------- ------------ --------------- ----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4    OK     103            64922        196829          60543025 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  File Name: /u01/app/oracle/oradata/ora11g/users01.dbf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  Block Type Blocks Failing Blocks Processed&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  ---------- -------------- ----------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  Data       0              19747          &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  Index      0              5352           &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  Other      0              106779         &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finished validate at 2018-04-10 14:16:26&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; exit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Recovery Manager complete.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$ sas&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL*Plus: Release 11.2.0.3.0 Production on Tue Apr 10 14:16:44 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2011, Oracle.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Connected to:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Data Mining and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; select * from v$database_block_corruption;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     FILE#     BLOCK#     BLOCKS CORRUPTION_CHANGE# CORRUPTIO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------- ---------- ---------- ------------------ ---------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         4     180937         15           60522291 NOLOGGING&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         4     180994         88           60522292 NOLOGGING&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; exit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Disconnected from Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Data Mining and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$ rmant target /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-bash: rmant: command not found&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$ rman target /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Recovery Manager: Release 11.2.0.3.0 - Production on Tue Apr 10 14:21:04 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2011, Oracle and/or its affiliates.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;connected to target database: ORA11G (DBID=4270446895)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; BLOCKRECOVER CORRUPTION LIST;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Starting recover at 2018-04-10 14:21:08&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;using target database control file instead of recovery catalog&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;allocated channel: ORA_DISK_1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;channel ORA_DISK_1: SID=133 device type=DISK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;starting media recovery&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;media recovery complete, elapsed time: 00:00:00&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finished recover at 2018-04-10 14:21:10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RMAN&amp;gt; exit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Recovery Manager complete.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[oracle@rhel6lhr oradata]$ sas&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL*Plus: Release 11.2.0.3.0 Production on Tue Apr 10 14:21:17 2018&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Copyright (c) 1982, 2011, Oracle.  All rights reserved.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Connected to:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;With the Partitioning, OLAP, Data Mining and Real Application Testing options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYS@ora11g &amp;gt; select * from v$database_block_corruption;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     FILE#     BLOCK#     BLOCKS CORRUPTION_CHANGE# CORRUPTIO&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------- ---------- ---------- ------------------ ---------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         4     180937         15           60522291 NOLOGGING&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         4     180994         88           60522292 NOLOGGING&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;hr/&gt;


</description>
<pubDate>Tue, 10 Apr 2018 13:21:00 +0000</pubDate>
<dc:creator>^_^小麦苗^_^</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lhrbest/p/8783087.html</dc:identifier>
</item>
<item>
<title>Spring 环境与profile(三)——利用maven的resources、filter和profile实现不同环境使用不同配置文件 - jihite</title>
<link>http://www.cnblogs.com/kaituorensheng/p/8783014.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaituorensheng/p/8783014.html</guid>
<description>&lt;h3&gt;基本概念 &lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;profiles定义了各个环境的变量id &lt;/li&gt;
&lt;li&gt;filters中定义了变量配置文件的地址，其中地址中的环境变量就是上面profile中定义的值 &lt;/li&gt;
&lt;li&gt;resources中是定义哪些目录下的文件会被配置文件中定义的变量替换&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;利用filter实现对资源文件(resouces)过滤&lt;/p&gt;
&lt;p&gt;maven filter可利用指定的xxx.properties中对应的key=value对资源文件中的${key}进行替换，最终把你的资源文件中的username=${key}替换成username=value &lt;/p&gt;
&lt;p&gt;利用profile来切换环境&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;示例&lt;/h3&gt;
&lt;p&gt;代码结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/408927/201804/408927-20180410210503379-1383993762.png&quot; alt=&quot;&quot; width=&quot;605&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;
&lt;p&gt;db.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
jdbc.username=&lt;span&gt;${jdbc.username}
jdbc.password&lt;/span&gt;=&lt;span&gt;${jdbc.password}
jdbc.url&lt;/span&gt;=&lt;span&gt;${jdbc.url}
name&lt;/span&gt;=${myName}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dev.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
jdbc.url=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:3306/devdb?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;zeroDateTimeBehavior=convertToNull&lt;/span&gt;
jdbc.username=&lt;span&gt;devuser
jdbc.password&lt;/span&gt;=dev123456
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;product.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
jdbc.url=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:3306/productdb?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;zeroDateTimeBehavior=convertToNull&lt;/span&gt;
jdbc.username=&lt;span&gt;productuser
jdbc.password&lt;/span&gt;=product123456
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;test.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
jdbc.url=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:3306/testdb?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;zeroDateTimeBehavior=convertToNull&lt;/span&gt;
jdbc.username=&lt;span&gt;testuser
jdbc.password&lt;/span&gt;=test123456
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;pom.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
  xsi:schemaLocation&lt;/span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;mavenImparityProfile&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;mavenImparityProfile&amp;lt;/artifactId&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;name&amp;gt;mavenImparityProfile Maven Webapp&amp;lt;/name&amp;gt;
  &amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.apache.org&amp;lt;/url&amp;gt;&lt;/span&gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;

  &amp;lt;profiles&amp;gt;
      &amp;lt;profile&amp;gt;
          &amp;lt;id&amp;gt;test&amp;lt;/id&amp;gt;
          &amp;lt;properties&amp;gt;
              &amp;lt;env&amp;gt;test&amp;lt;/env&amp;gt;&amp;lt;!--相当于定义一个变量 供下面使用--&amp;gt;
              &amp;lt;myName&amp;gt;张三&amp;lt;/myName&amp;gt;&amp;lt;!--使用一个properties文件中未定义，但是其他地方会取值的变量--&amp;gt;
          &amp;lt;/properties&amp;gt;
          &amp;lt;activation&amp;gt;&amp;lt;!--默认激活--&amp;gt;
              &amp;lt;activeByDefault&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/activeByDefault&amp;gt;
          &amp;lt;/activation&amp;gt;
      &amp;lt;/profile&amp;gt;
      &amp;lt;profile&amp;gt;
          &amp;lt;id&amp;gt;dev&amp;lt;/id&amp;gt;
          &amp;lt;properties&amp;gt;
              &amp;lt;env&amp;gt;dev&amp;lt;/env&amp;gt;
              &amp;lt;myName&amp;gt;李四&amp;lt;/myName&amp;gt;
          &amp;lt;/properties&amp;gt;
          &amp;lt;activation&amp;gt;&amp;lt;!--默认激活--&amp;gt;
              &amp;lt;activeByDefault&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/activeByDefault&amp;gt;
          &amp;lt;/activation&amp;gt;
      &amp;lt;/profile&amp;gt;
      &amp;lt;profile&amp;gt;
          &amp;lt;id&amp;gt;product&amp;lt;/id&amp;gt;
          &amp;lt;properties&amp;gt;
              &amp;lt;env&amp;gt;product&amp;lt;/env&amp;gt;
          &amp;lt;/properties&amp;gt;
      &amp;lt;/profile&amp;gt;
  &amp;lt;/profiles&amp;gt;

  &amp;lt;build&amp;gt;
    &amp;lt;finalName&amp;gt;mavenImparityProfile&amp;lt;/finalName&amp;gt;
      &amp;lt;filters&amp;gt; &amp;lt;!--filters中定义了变量配置文件的地址，其中地址中的环境变量env就是上面profile中定义的值--&amp;gt;
          &amp;lt;filter&amp;gt;src/main/resources/properties/${env}.properties&amp;lt;/filter&amp;gt;
      &amp;lt;/filters&amp;gt;

      &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt; &amp;lt;!--resources中是定义哪些目录下的文件会被配置文件中定义的变量替换，一般我们会把项目的配置文件放在src/main/resources下--&amp;gt;
            &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
             &amp;lt;filtering&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/filtering&amp;gt; &amp;lt;!--是否使用过滤器--&amp;gt;
         &amp;lt;/resource&amp;gt;
     &amp;lt;/resources&amp;gt;
  &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jihite/SpringLearn/tree/master/mavenImparityProfile&quot; target=&quot;_blank&quot;&gt;地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Apr 2018 13:13:00 +0000</pubDate>
<dc:creator>jihite</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaituorensheng/p/8783014.html</dc:identifier>
</item>
<item>
<title>Spring事务管理 - Lovebugs.cn</title>
<link>http://www.cnblogs.com/Lovebugs/p/8782922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lovebugs/p/8782922.html</guid>
<description>&lt;h3&gt;事务的概念&lt;/h3&gt;
&lt;p&gt;首先来回顾一下什么是事务？&lt;br/&gt;事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。&lt;br/&gt;举个例子，假设张三和李四两人之间要进行转账操作----张三要给李四转账1000元。那么这个转账操作就有下面两个步骤：&lt;br/&gt;①修改张三账户，扣除1000元②修改李四账户，增加1000元。&lt;br/&gt;显然在这个过程中，不允许出现步骤①完成后整个操作就终止的情况。要想让这两个步骤能一起完成或一起失败的话，就要对其加上事务管理。&lt;/p&gt;
&lt;h3&gt;事务的特性&lt;/h3&gt;
&lt;p&gt;事务有如下4个特性：原子性、一致性、隔离性、永久性。&lt;br/&gt;①原子性指事务是一个不可分割的基本单位，一组操作要么都发生，要么都不发生。&lt;br/&gt;②一致性指事务完成前后的数据要保持一致，比如转账操作中事务完成前后的总钱数不能发生改变。&lt;br/&gt;③隔离性指多个用户并发访问时，每一个事务都是相互独立的，不能被其他事务所干扰。&lt;br/&gt;④永久性指事务一旦被提交，就真正的被修改了，无法改变撤回。&lt;/p&gt;
&lt;h3&gt;Spring事务接口&lt;/h3&gt;
&lt;p&gt;Sring事务管理主要提供了三个接口：&lt;br/&gt;①事务管理器 PlatformTransactionManager&lt;br/&gt;②事务定义信息 TransactionDefinition&lt;br/&gt;③事务运行状态 TransactionStatus&lt;/p&gt;
&lt;p&gt;简单的写一下这三种接口的功能：&lt;br/&gt;1）PlatformTransactionManager&lt;br/&gt;Spring在该接口中为不同的持久化框架提供了不同的PlatformTransactionManager接口实现类，事务的提交、回滚等操作全部交给它来实现。&lt;/p&gt;
&lt;p&gt;2）TransactionDefication&lt;br/&gt;该接口中定义了一些事务的隔离级别、超时信息、传播行为等常量和方法。&lt;br/&gt;之所以要定义隔离级别是因为如果不考虑事务的隔离性，就可能会引发一系列安全问题，比如脏读，不可重复读，幻读等。&lt;br/&gt;（脏读指一个事务读取了另一个事务改写了但还未提交的数据时，此时如果这些数据被回滚了，则读到的数据就会是无效的。&lt;br/&gt;不可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。幻读指的是一个事务读取了几行记录之后，另一个事务插入了一些记录，此时幻读就发生了）&lt;/p&gt;
&lt;p&gt;隔离级别就是用来解决上面几种问题的。&lt;/p&gt;

&lt;p&gt;Spring为事务提供了四种隔离级别：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1715&quot; data-height=&quot;516&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7347393-8de5d9823c08684b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7347393-8de5d9823c08684b.png&quot; data-original-width=&quot;1715&quot; data-original-height=&quot;516&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;579473&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;此外该接口中还定义了Spring事务的传播行为。传播行为是用来解决业务层中多个方法之间的相互调用的问题，用来决定事务是如何进行传递的。&lt;/p&gt;

&lt;p&gt;有七种传播行为：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;888&quot; data-height=&quot;427&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7347393-a8e88f47730042bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7347393-a8e88f47730042bf.png&quot; data-original-width=&quot;888&quot; data-original-height=&quot;427&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;231507&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3）TransactionStatus&lt;br/&gt;事务状态的接口，该接口中提供了一组方法，可以获得事物的状态信息，比如事务是否开启，事务是否已完成，是否为一个新事物等等。&lt;/p&gt;
&lt;h3&gt;事务管理方式&lt;/h3&gt;
&lt;p&gt;Spring支持两种方式管理事务&lt;br/&gt;①编程式的事务管理&lt;br/&gt;该方式是要手动来写代码进行事务管理，较少使用。&lt;br/&gt;②使用xml配置的声明式事务&lt;br/&gt;Spring的声明式事务是通过AOP来实现的，开发中推荐使用此种方式，代码的侵入性较小。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;br/&gt;微信公众号【IT资源社】&lt;br/&gt;本公众号致力于免费分享全网最优秀的视频资源，学习资料，面试经验等，前端，PHP，JAVA，算法，Python，大数据等等，你想要的这都有，还会分享优质博文，提高你的认知与思维&lt;/p&gt;

&lt;p&gt;IT资源社－QQ交流群：601357554&lt;br/&gt;要进微信交流群的话加微信：super1319164238&lt;br/&gt;微信搜索公众号：ITziyuanshe 或者扫描下方二维码直接关注，&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;497&quot; data-height=&quot;479&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7347393-3fe6e3a550ad4bec?imageMogr2/auto-orient/strip%7CimageView2/2/w/497&quot; alt=&quot;&quot; width=&quot;222&quot; height=&quot;214&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7347393-3fe6e3a550ad4bec&quot; data-original-width=&quot;497&quot; data-original-height=&quot;479&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;46260&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 10 Apr 2018 13:05:00 +0000</pubDate>
<dc:creator>Lovebugs.cn</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Lovebugs/p/8782922.html</dc:identifier>
</item>
</channel>
</rss>