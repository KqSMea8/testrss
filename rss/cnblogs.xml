<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>机器学习100天——数据预处理(第一天) - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/9638093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/9638093.html</guid>
<description>&lt;p&gt;有个叫Avik Jain的老外在github上发起了一个100天学习机器学习的项目，每天花一个小时学习机器学习，学习内容由浅入深。今天是第一天，内容是如何进行数据预处理。该教程的编程语言是Python。&lt;/p&gt;

&lt;p&gt;数据预处理分为6步：&lt;/p&gt;

&lt;p&gt;第一步：导入NumPy和Pandas库。NumPy和Pandas是每次都要导入的库，其中Numpy包含了数学计算函数，Pnadas是一个用于导入和管理数据集(Data Sets)的类库。&lt;/p&gt;

&lt;p&gt;第二步：导入数据集。数据集一般都是.csv格式，csv文件以文本形式存储数据。每一行数据是一条记录。我们使用pandas类库的read_csv方法读取本地的csv文件作为一个dataframe。然后从datafram中分别创建自变量和因变量的矩阵和向量。&lt;/p&gt;

&lt;p&gt;第三步：处理缺失的数据。我们得到的数据很少是完整的。数据可能因为各种原因丢失，为了不降低机器学习模型的性能，需要处理数据。我们可以用整列的平均值或者中间值替换丢失的数据。我们用sklearn.preprocessing库中的Inputer类完成这项任务。&lt;/p&gt;

&lt;p&gt;第四步：对分类数据进行编码。分类数据指的是含有标签值而不是数字值得变量。取值范围通常是固定的。例如“YES”和“NO”不能用于模型的数学计算，所以需要编码成数字。为数显这一功能，我们从sklearn.preprocessing库中导入LabelEncoder类。&lt;/p&gt;

&lt;p&gt;第五步：拆分数据集为测试集合和训练集合。把数据集拆分成两个，一个是用来训练模型的训练集合，另一个是用来验证模型的测试集合。两种比例一般是80:20。我们导入sklearn.crossvalidation库中的train_test_split()方法。&lt;/p&gt;

&lt;p&gt;第六步：特征缩放。大部分模型算法使用两点间的欧式近距离表示，但此特征在幅度、单位和范围姿态问题上变化很大。在距离计算中，高幅度的特征比低幅度特征权重大。可用特征标准化或Z值归一化解决。导入sklearn.preprocessing库的StandardScalar类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/110616/201809/110616-20180912231928545-1206032466.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 1&lt;span&gt;: 导入类库
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 2&lt;span&gt;: 导入数据集
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; dataset = pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Data.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; X = dataset.iloc[ : , :-1&lt;span&gt;].values
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; Y = dataset.iloc[ : , 3&lt;span&gt;].values
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 3&lt;span&gt;: 处理缺失的数据
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Imputer
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; imputer = Imputer(missing_values = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NaN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, strategy = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mean&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, axis =&lt;span&gt; 0)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; imputer = imputer.fit(X[ : , 1:3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; X[ : , 1:3] = imputer.transform(X[ : , 1:3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; Step 4&lt;span&gt;:编码分类数据
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LabelEncoder, OneHotEncoder
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; labelencoder_X =&lt;span&gt; LabelEncoder()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; X[ : , 0] =&lt;span&gt; labelencoder_X.fit_transform(X[ : , 0])
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;Creating a dummy variable
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; onehotencoder = OneHotEncoder(categorical_features =&lt;span&gt; [0])
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; X =&lt;span&gt; onehotencoder.fit_transform(X).toarray()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; labelencoder_Y =&lt;span&gt; LabelEncoder()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; Y =&lt;span&gt;  labelencoder_Y.fit_transform(Y)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; Step 5&lt;span&gt;: 切分数据集成训练数据和测试数据
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.cross_validation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; X_train, X_test, Y_train, Y_test = train_test_split( X , Y , test_size = 0.2, random_state =&lt;span&gt; 0)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; Step 6&lt;span&gt;: 特征缩放
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; StandardScaler
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; sc_X =&lt;span&gt; StandardScaler()
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; X_train =&lt;span&gt; sc_X.fit_transform(X_train)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; X_test = sc_X.fit_transform(X_test)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本教程的测试数据请关注本人的公众号获取：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/110616/201809/110616-20180912232212869-1354932756.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 15:23:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>有个叫Avik Jain的老外在github上发起了一个100天学习机器学习的项目，每天花一个小时学习机器学习，学习内容由浅入深。今天是第一天，内容是如何进行数据预处理。该教程的编程语言是Python</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/9638093.html</dc:identifier>
</item>
<item>
<title>struts2.5+框架使用通配符与动态方法 - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9638045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9638045.html</guid>
<description>&lt;ol&gt;&lt;li&gt;
&lt;h2&gt;通配符：&lt;/h2&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在学习struts框架时经常会使用到通配符调用方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;usercrud&quot;&lt;/span&gt;&lt;span&gt; namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;test-*&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.gitee.dgwcode.action.UserCrudAction&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;{1}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;query&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/view/success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;allowed-methods&amp;gt;query,delete,update,insert&amp;lt;/allowed-methods&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的action name=&quot;user_*&quot;中*这个符号代表的值会传入method=“{1}”中，并对应action类的一个方法名，这样就能很大程度地减少配置文档中action的数目。&lt;/p&gt;

&lt;p&gt;但是在使用这种通配符方法的时候，经常会看到这样的映射错误提示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Struts Problem Report
Struts has detected an unhandled exception:

Messages:    
There is no Action mapped for namespace [/] and action name [test-update] associated with context path [/Struts2_01].&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果看到提示的是映射问题，你可以按照映射路线排除一遍，&lt;/p&gt;
&lt;p&gt;第一步：先排查访问的链接有没有问题（细节问题）&lt;/p&gt;
&lt;p&gt;第二步：&lt;span&gt;查看struts.xml的配置（仔细排查，出现问题几率很大）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第三步：查看相关的action类及方法（比如return的值是不是跟配置文件中的result对应得上等）&lt;/p&gt;
&lt;p&gt;第四步：查看结果响应页面是否存在问题（出现问题的几率比较小）&lt;/p&gt;

&lt;h2&gt;2.动态方法&lt;/h2&gt;
&lt;p&gt;当使用动态调用方法时（action名 + 感叹号 + 方法名进行方法调用），需要将其属性改为true，&lt;/p&gt;
&lt;p&gt;如：query为类中的方法名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;${pageContext.request.contextPath }/test!query&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;DynamicMethodInvocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当使用通配符调用语法时，建议将其属性改为false（struts2.5.2中默认是false）&lt;/p&gt;
&lt;p&gt;当我们需要将其属性改成false时，&lt;/p&gt;
&lt;p&gt;只在struts.xml配置文件中加入此句即可修改属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 动态方法调用 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;
            class&lt;/span&gt;&lt;span&gt;=&quot;com.gitee.dgwcode.action.UserCrudAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;query&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/view/success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;allowed-methods&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;query,delete,update,insert&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;allowed-methods&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：&amp;lt;allowed-methods&amp;gt;方法名1，方法名2…&amp;lt;/allowed-methods&amp;gt;代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Sep 2018 15:13:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>概述：struts2.5以后加强了安全性，下面就是安全配置引发的问题 通配符： 在学习struts框架时经常会使用到通配符调用方法，如下： 其中的action name=&quot;user_*&amp;qu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9638045.html</dc:identifier>
</item>
<item>
<title>“万恶之源”的动态代理 - 黑米面包派</title>
<link>http://www.cnblogs.com/wujiwen/p/9638008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wujiwen/p/9638008.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最近准备整理一下框架学习的只是，发现不管是RPC框架，还是Spring的框架，Mybatis的框架都有很多地方地方用到了动态代理的方式，例如我们强大的Spring AOP、Mybatis中的接口方法查询都是用到了JDK动态代理，为了后期巩固知识的方便，我希望自己能从基础入手，真正理解框架。也要求自己以这样的方式来记录学习/复习过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一代理模式&quot;&gt;一、代理模式&lt;/h3&gt;
&lt;h4 id=&quot;什么是代理模式&quot;&gt;1.1什么是代理模式？&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;em&gt;代理模式的定义&lt;/em&gt;：代理模式是指给某一个对象提供一个代理对象，并由代理对象来控制对原对象（被代理）的引用。引战的说法就是，婚介所来介绍对象🙂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;代理模式分类&quot;&gt;1.3代理模式分类&lt;/h4&gt;
&lt;p&gt;如果按照代理创建的时期来分类的话，可以分成&lt;strong&gt;静态代理&lt;/strong&gt;和&lt;strong&gt;动态代理&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态代理：由程序员创建或者特定的工具自动生成的源码，程序运行之前，代理类的字节码文件已经创建好了。&lt;/li&gt;
&lt;li&gt;动态代理：通过反射机制动态创建，在程序运行时才创建。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;二静态代理&quot;&gt;二、静态代理&lt;/h3&gt;
&lt;p&gt;实现静态代理有四个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义业务接口&lt;/li&gt;
&lt;li&gt;被代理的类来实现业务接口&lt;/li&gt;
&lt;li&gt;定义代理类并实现业务接口&lt;/li&gt;
&lt;li&gt;客户端调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们将按照这个步骤来实现一个静态代理，仿照AOP，我们来实现一个记录数据库插入数据的前后日志需求。&lt;/p&gt;
&lt;h4 id=&quot;定义业务接口&quot;&gt;2.1定义业务接口&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;IService.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.proxy.stat;
/**
 * created with IntelliJ IDEA.
 * packageName  : com.proxy.stat
 * author       : wujw
 * date         : 2018/9/12 21:47
 * version      : 1.0.0
 * description  : 业务接口
 */
public interface IService {
    /**
     * 将数据库插入一条数据
     * @param data data
     */
    void insert(String data);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;被代理类实现业务接口&quot;&gt;2.2被代理类实现业务接口&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;ServiceImpl.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.proxy.stat;

/**
 * created with IntelliJ IDEA.
 * packageName  : com.proxy.stat
 * author       : wujw
 * date         : 2018/9/12 21:50
 * version      : 1.0.0
 * description  : 被代理类实现业务接口
 */
public class ServiceImpl implements IService{
    public void insert(String data) {
        System.out.println(&quot;insert into database ： &quot;+ data);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;定义代理类并实现业务接口&quot;&gt;2.3定义代理类并实现业务接口&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;ServiceProxy.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.proxy.stat;

/**
 * created with IntelliJ IDEA.
 * packageName  : com.proxy.stat
 * author       : wujw
 * date         : 2018/9/12 21:52
 * version      : 1.0.0
 * description  : 代理类并实现业务接口
 */
public class ServiceProxy implements IService{
    //被代理对象
    private IService iService;
    //构造方式注入
    public ServiceProxy(final IService iService) {
        this.iService = iService;
    }

    public void insert(String data) {
        System.out.println(&quot;ready to insert into database&quot;);
        iService.insert(data);
        System.out.println(&quot;insert into database success&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;客户端调用测试&quot;&gt;2.4客户端调用测试&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.proxy.stat;

/**
 * created with IntelliJ IDEA.
 * packageName  : com.proxy.stat
 * author       : wujw
 * date         : 2018/9/12 21:59
 * version      : 1.0.0
 * description  : 客户端调用
 */
public class StaticProxyGo {
    public static void main(String[] args) {
        
        IService iService = new ServiceImpl();
        //将被代理对象注入到代理类中
        ServiceProxy proxy = new ServiceProxy(iService);

        proxy.insert(&quot;Apple凌晨会发布什么产品呢？&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;结果：：：：：：：：：：：：：：：：：：：：：：：：
ready to insert into database
insert into database ： Apple凌晨会发布什么产品呢？
insert into database success

Process finished with exit code 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就实现了一个静态代理。但是静态代理中每出现一个服务都需要为其去创建一个代理类，工作量太大了。&lt;/p&gt;
&lt;h3 id=&quot;三动态代理jdk&quot;&gt;三、动态代理（JDK）&lt;/h3&gt;
&lt;p&gt;使用JDK动态代理步骤&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建被代理的接口和类&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;InvocationHandler&lt;/code&gt;接口的实现类。在&lt;code&gt;invoke&lt;/code&gt;方法中实现代理逻辑&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Proxy&lt;/code&gt;的静态方法&lt;code&gt;newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h)&lt;/code&gt;创建一个代理对象。&lt;/li&gt;
&lt;li&gt;客户端调用&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;创建被代理的接口和类&quot;&gt;3.1创建被代理的接口和类&lt;/h4&gt;
&lt;p&gt;我们依旧使用上面提到的静态代理中的接口和类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Iservice.java&lt;/code&gt; 和&lt;code&gt;ServiceImpl&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;创建invcationhandler接口的实现类&quot;&gt;3.2创建InvcationHandler接口的实现类&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.proxy.dynamic;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

/**
 * created with IntelliJ IDEA.
 * packageName  : com.proxy.dynamic
 * author       : wujw
 * date         : 2018/9/12 22:19
 * version      : 1.0.0
 * description  : TODO
 */
public class MyInvocationHandler implements InvocationHandler {
    //被代理的对象，Object类型
    private Object object;

    public MyInvocationHandler(Object object){
        this.object = object;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;ready to insert into database&quot;);
        
        Object returnValue = method.invoke(object,args);
        
        System.out.println(&quot;insert into database success&quot;);
        
        return returnValue;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;客户端调用&quot;&gt;3.4客户端调用&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.proxy.dynamic;

import com.proxy.IService;
import com.proxy.ServiceImpl;

import java.lang.reflect.Proxy;

/**
 * created with IntelliJ IDEA.
 * packageName  : com.proxy.dynamic
 * author       : wujw
 * date         : 2018/9/12 22:23
 * version      : 1.0.0
 * description  : TODO
 */
public class DynamicProxyGo {
    public static void main(String[] args) {
        IService iService = new ServiceImpl();
        MyInvocationHandler handler = new MyInvocationHandler(iService);
        //第一个参数是指定代理类的类加载器（我们传入当前测试类的类加载器）
        //第二个参数是代理类需要实现的接口（我们传入被代理类实现的接口，这样生成的代理类和被代理类就实现了相同的接口） 
        //第三个参数是invocation handler，用来处理方法的调用。这里传入我们自己实现的handler 
        IService proxyObject = (IService) Proxy.newProxyInstance(DynamicProxyGo.class.getClassLoader(),iService.getClass().getInterfaces(),handler);
        proxyObject.insert(&quot;Apple 凌晨会发布什么产品呢？&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;结果：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
ready to insert into database
insert into database ： Apple 凌晨会发布什么产品呢？
insert into database success

Process finished with exit code 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到结果和静态代理一致，说明我们的实现是成功的。&lt;/p&gt;
&lt;p&gt;JDK来实现动态代理需要实现类通过接口业务定义方法（可看需要的参数），那对于没有接口的类，那我们如果实现动态代理呢？这时候就需要&lt;code&gt;CGLIB&lt;/code&gt;了。&lt;code&gt;CGLIB&lt;/code&gt;采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与&lt;code&gt;CGLIB&lt;/code&gt;动态代理均是实现&lt;code&gt;Spring AOP&lt;/code&gt;的基础。&lt;/p&gt;
&lt;h3 id=&quot;四动态代理cglib&quot;&gt;四、动态代理（CGLIB）&lt;/h3&gt;
&lt;h4 id=&quot;创建cglib代理类&quot;&gt;4.1创建CGLIB代理类&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.proxy.dynamic;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * created with IntelliJ IDEA.
 * packageName  : com.proxy.dynamic
 * author       : wujw
 * date         : 2018/9/12 22:35
 * version      : 1.0.0
 * description  : TODO
 */
public class CGBILProxy implements MethodInterceptor {
    //被代理对象
    private Object object;
    public Object getInstance(final Object object){
        this.object = object;
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(this.object.getClass());
        enhancer.setCallback(this);
        return enhancer.create();
    }
    
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println(&quot;ready to insert into database&quot;);

        Object returnValue = methodProxy.invoke(object,objects);

        System.out.println(&quot;insert into database success&quot;);

        return returnValue;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;客户端调用-1&quot;&gt;4.2客户端调用&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.proxy.dynamic;

import com.proxy.ServiceImpl;

/**
 * created with IntelliJ IDEA.
 * packageName  : com.proxy.dynamic
 * author       : wujw
 * date         : 2018/9/12 22:46
 * version      : 1.0.0
 * description  : TODO
 */
public class CGlibProxyGo {
    public static void main(String[] args) {
        //这次我们不使用接口
        ServiceImpl iService = new ServiceImpl();

        CGBILProxy cgbilProxy = new CGBILProxy();
        ServiceImpl service = (ServiceImpl) cgbilProxy.getInstance(iService);

        service.insert(&quot;Apple 凌晨会发布什么产品呢？&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;结果：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：：
ready to insert into database
insert into database ： Apple 凌晨会发布什么产品呢？
insert into database success&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自此，我们已经实现了三类代理方式，接下来我们将继续深究代理模式的内部代码及其常用的框架中是实现案例。&lt;/p&gt;
&lt;p&gt;我们将在下一篇幅中记录讨论，这里感谢前辈们的案例，给了我很多的参考案例&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 15:04:00 +0000</pubDate>
<dc:creator>黑米面包派</dc:creator>
<og:description>前言 最近准备整理一下框架学习的只是，发现不管是RPC框架，还是Spring的框架，Mybatis的框架都有很多地方地方用到了动态代理的方式，例如我们强大的Spring AOP、Mybatis中的接口</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wujiwen/p/9638008.html</dc:identifier>
</item>
<item>
<title>C#基于websocket-sharp实现简易httpserver(封装) - OMango</title>
<link>http://www.cnblogs.com/OMango/p/9637970.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OMango/p/9637970.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　其实就是很简单的，公司会桌面开发的人员紧缺啊，项目又赶，而我们公司的前端人员人多还厉害（ps:吐槽下，后端的人真的少啊，会桌面开发的更少啊），所以萌生出了使用html+js来构建本地应用程序，但是我们的客户基本都是制造行业，需要对很多硬件进行交互（IO卡、PLC、串口等等各种），那就势必还是需要传统的应用程序（毕竟方案多），emmm，那这两者之间需要怎么样结合呢？so就有了本文，让winform变成一个httpserver，这样就可以接入各种硬件以及处理耗时动作，将界面跟业务处理分开，当时这个还是前端人员提出能不能用前端技术构建界面，后面我们一合计，应该是可以试试（&lt;strong&gt;ps:大佬们如果有问题请轻拍啊&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、技术点说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　websocket-sharp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://github.com/sta/websocket-sharp&quot; target=&quot;_blank&quot;&gt;websocket-sharp&lt;/a&gt;是开源的websocket的C#封装，可以帮助我们快速构建websocket的相关应用，但是同时它也提供了httpserver的功能，这次选型这个的缘故也是因为有websocket的存在，后续扩展做实时的数据交互应该是非常方便的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　其他：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　autofac（IOC使用）、json.net（json序列化使用）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、关注点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201809/465472-20180912214005240-95781410.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如图所示，对于一个自动更新程序，关注点应该都是以上几个点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持Get以及Post请求，这个应该是基本的（对于其他请求没有进行封装）&lt;/li&gt;
&lt;li&gt;依赖注入，还是很好用的，最直观的就是不用写new对象了&lt;/li&gt;
&lt;li&gt;异常filter，可以实现全局异常捕获以及处理（服务端开发应该用的比较多）&lt;/li&gt;
&lt;li&gt;文件获取，最直观的就是要显示图片咋办&lt;/li&gt;
&lt;li&gt;自定义filter，就是平常我们针对于每个action的拦截器（目前还未实现）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　大致应该就以上几点，如果实现以上几点，应该可以算是一个像模像样的简陋版httpserver（只支持api访问的那种）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、设计流程图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201809/465472-20180912215558071-96822732.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;






























&lt;p&gt;&lt;strong&gt;　　一些说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、为了减少依赖，我将websocket-sharp的源码全部放入到MHttpServer项目中，感谢websocket-sharp的作者，可以让我方便的实现httpserver的功能&lt;/p&gt;
&lt;p&gt;　　2、整体流程就如上所示，应该还是比较顺畅，我目前是把自己做服务器端开发时候的一些惯性思路带到这个项目中，有可能会不符合其他人的开发习惯&lt;/p&gt;
&lt;p&gt;　　3、其他具体看github的代码，如果有人想做研究的话&lt;/p&gt;
&lt;p&gt;　　4、程序考虑支持XP，所以将.net framework的版本定在4.0，所以autofac的版本是比较低的，这个如果需要最新版本可以自己去升级&lt;/p&gt;
&lt;p&gt;　　5、整体的开发参照目前WebApi的方式进行，路由规则定为controller/action（例如：User/Add），所以是没有参照restful的标准（实际原因是理解不了Restful怎么应付复杂的http请求场景，例如参数个数类型一样的情况下？？）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;五、如何使用&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;新建winform项目后，在需要开启的地方里加入以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
     MHttpServer.Listen listen = &lt;span&gt;new&lt;/span&gt; MHttpServer.Listen(&lt;span&gt;8088&lt;/span&gt;&lt;span&gt;);
     ContainerBuilder builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContainerBuilder();
     builder.RegisterType&lt;/span&gt;&amp;lt;TestService&amp;gt;&lt;span&gt;().PropertiesAutowired();
     listen.InitController(builder);
     listen.start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上代码是实例化一个httpserver对象，并且将service注入到buid中，将build传入到InitController，通过这种方式实现全局的依赖注入&lt;/p&gt;
&lt;p&gt;　　效果如下：&lt;/p&gt;
&lt;p&gt;　　正常执行，并且触发更新winform的界面，TestDo方法是一个事件，事件中将收到的数据显示在form的richtextbox中&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201809/465472-20180912221924244-1536188590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　故意触发异常执行：&lt;/p&gt;
&lt;p&gt;　　触发异常执行的时候，如下图所示，进入了ExceptionFilter中，并且将处理过的异常返回到前端&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201809/465472-20180912221947443-2085911796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;六、总结&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这次的实践只是一个新的尝试，如果效果比较好的话，后续对于交互要求比较高的程序，应该都会采用这种方案进行，通过NanUI或者electron构建界面，本地开启httpserver进行硬件的交互以及业务上的数据查询，充分发挥团队中每个人的作用&lt;/p&gt;
&lt;p&gt;　　这个项目中的大部分东西都是第三方开源产品，我只是做了一个封装，所以最后感谢开源这些产品的作者们&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;由于个人原因，在测试上可能会有所不够，如果有什么bug的话，还请告知，感谢（ps:文字表达弱鸡，多多包涵）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　项目地址：&lt;a href=&quot;https://github.com/Hello-Mango/MHttpServer&quot; target=&quot;_blank&quot;&gt;https://github.com/Hello-Mango/MHttpServer&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者： Mango&lt;/p&gt;
&lt;p&gt;出处： &lt;a href=&quot;http://www.cnblogs.com/OMango/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/OMango/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于自己：专注.Net桌面开发以及Web后台开发，开始接触微服务、docker等互联网相关（最近被互联网架构搞的死去活来- -）&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，如有问题， 可站内信告知.&lt;/p&gt;


</description>
<pubDate>Wed, 12 Sep 2018 14:56:00 +0000</pubDate>
<dc:creator>OMango</dc:creator>
<og:description>一、背景 其实就是很简单的，公司会桌面开发的人员紧缺啊，项目又赶，而我们公司的前端人员人多还厉害（ps:吐槽下，后端的人真的少啊，会桌面开发的更少啊），所以萌生出了使用html+js来构建本地应用程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OMango/p/9637970.html</dc:identifier>
</item>
<item>
<title>Java并发编程-ReentrantReadWriteLock - lingjiango</title>
<link>http://www.cnblogs.com/iou123lg/p/9637637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iou123lg/p/9637637.html</guid>
<description>&lt;p&gt;　　基于&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9464385.html&quot; target=&quot;_blank&quot;&gt;AQS的前世今生&lt;/a&gt;，来学习并发工具类ReentrantReadWriteLock。本文将从ReentrantReadWriteLock的产生背景、源码原理解析和应用来学习这个并发工具类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt; &lt;strong&gt;产生背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　前面我们学习的&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9535710.html&quot; target=&quot;_blank&quot;&gt;重入锁ReentrantLock&lt;/a&gt;本质上还是互斥锁，每次最多只能有一个线程持有ReentrantLock。对于维护数据完整性来说，互斥通常是一种过于强硬的规则，因此也就不必要的限制了并发性。互斥是一种保守的加锁策略，虽然可以避免“写/写”冲突和“写/读”冲突，但也同样避免了“读/读”冲突。和互联网的“二八法则”一样，大部分数据都是读数据，可以存放在缓存中，数据结构的操作其实很多也是读操作，可以考虑适当的放宽加锁需求，允许多个读操作线程同时访问数据结构以提升程序的性能。在这样的需求背景下，就产生了读写锁ReadWriteLock，一个资源可以同时被多个读操作访问，或者被一个写操作访问，但是不能读写操作同时访问。ReadWriteLock定义了接口规范，实际实现读写锁控制的类是ReentrantReadWriteLock，该类为读写锁提供了可重入的加锁语义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;/strong&gt; &lt;strong&gt;源码原理解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 读写锁原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　既然是读写锁，那就是有两把锁，可以用AQS的同步状态表示其中的一把锁，再引入一个新的属性表示另外一把锁，但是这么做就变成了二元并发安全问题，使问题变得更加复杂。ReentrantReadWriteLock选择了用一个属性，即AQS的同步状态来表示读写锁，怎样用一个属性来表示读写锁呢？那就是位运算，对位运算不熟悉的可以先看下&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9576468.html&quot; target=&quot;_blank&quot;&gt;此文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　ReentantReadWriteLock采用“按位切割”的方式，就是将这个32位的int型state变量分为高16位和低16位来使用，&lt;strong&gt;高16位代表读状态，低16位代表写状态&lt;/strong&gt;。&lt;strong&gt;读锁是可以共享的，而写锁是互斥的，对于写锁而言，用低16位表示线程的重入次数，但是读锁因为可以同时有多个线程，所以重入次数需要通过其他的方式来记录，那就是ThreadLocal变量。从这也可以总结出来和ReentrantLock相比，写锁的重入次数会减少，最多不能超过65535次。读锁的线程数也有限制，最对不能超过65535个。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　假设状态变量是c，则读状态就是c&amp;gt;&amp;gt;&amp;gt;16（无符号右移16位），其实就是通过无符号右移运算抹掉低的16位，剩下的就是c的高16位。写状态是c&amp;amp;((1 &amp;lt;&amp;lt; 16) - 1)，其实就是c&amp;amp;00000000000000001111111111111111，与运算之后，高的16位被抹掉，剩下的就是c的低16位。如果读线程申请读锁，当前写锁重入次数不为 0 时，则等待，否则可以马上分配；如果是写线程申请写锁，当前状态为 0 则可以马上分配，否则等待。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 读锁的获取和释放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　读锁的获取方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; unused) {
            Thread current &lt;/span&gt;= Thread.currentThread();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;持有写锁的线程可以获取读锁&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (exclusiveCount(c) != 0 &amp;amp;&amp;amp;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经分配了写锁&lt;/span&gt;
                getExclusiveOwnerThread() != current) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程不是持有写锁的线程&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r = sharedCount(c); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读锁获取次数&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!readerShouldBlock() &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;由子类根据公平策略实现决定是否可获取读锁&lt;/span&gt;
                r &amp;lt; MAX_COUNT &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读锁获取次数小于最大值&lt;/span&gt;
                compareAndSetState(c, c + SHARED_UNIT)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新读锁状态&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (r == 0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读锁的第一个线程 此时可以不用记录到ThreadLocal&lt;/span&gt;
                    firstReader =&lt;span&gt; current; 
                    firstReaderHoldCount &lt;/span&gt;= 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;避免查找ThreadLocal 提升效率&lt;/span&gt;
                } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (firstReader == current) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读锁的第一个线程重入&lt;/span&gt;
                    firstReaderHoldCount++&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非读锁的第一个线程&lt;/span&gt;
                    HoldCounter rh = cachedHoldCounter; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面为重入次数更新&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (rh == &lt;span&gt;null&lt;/span&gt; || rh.tid !=&lt;span&gt; getThreadId(current))
                        cachedHoldCounter &lt;/span&gt;= rh =&lt;span&gt; readHolds.get();
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (rh.count == 0&lt;span&gt;)
                        readHolds.set(rh);
                    rh.count&lt;/span&gt;++&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fullTryAcquireShared(current); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取读锁失败 循环重试&lt;/span&gt;
&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fullTryAcquireShared(Thread current) {
            HoldCounter rh &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (exclusiveCount(c) != 0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到写锁&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (getExclusiveOwnerThread() !=&lt;span&gt; current) 
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非写锁线程获取失败
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else we hold the exclusive lock; blocking here
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; would cause deadlock.&lt;/span&gt;
                } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (readerShouldBlock()) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make sure we're not acquiring read lock reentrantly&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (firstReader ==&lt;span&gt; current) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert firstReaderHoldCount &amp;gt; 0;&lt;/span&gt;
                    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rh == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            rh &lt;/span&gt;=&lt;span&gt; cachedHoldCounter;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rh == &lt;span&gt;null&lt;/span&gt; || rh.tid !=&lt;span&gt; getThreadId(current)) {
                                rh &lt;/span&gt;=&lt;span&gt; readHolds.get();
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rh.count == 0&lt;span&gt;)
                                    readHolds.remove();
                            }
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rh.count == 0&lt;span&gt;)
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sharedCount(c) == MAX_COUNT) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读锁数量达到最大&lt;/span&gt;
                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;Maximum lock count exceeded&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareAndSetState(c, c + SHARED_UNIT)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读锁获取成功 处理方式和之前类似&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (sharedCount(c) == 0&lt;span&gt;) {
                        firstReader &lt;/span&gt;=&lt;span&gt; current;
                        firstReaderHoldCount &lt;/span&gt;= 1&lt;span&gt;;
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (firstReader ==&lt;span&gt; current) {
                        firstReaderHoldCount&lt;/span&gt;++&lt;span&gt;;
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rh == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            rh &lt;/span&gt;=&lt;span&gt; cachedHoldCounter;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rh == &lt;span&gt;null&lt;/span&gt; || rh.tid !=&lt;span&gt; getThreadId(current))
                            rh &lt;/span&gt;=&lt;span&gt; readHolds.get();
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (rh.count == 0&lt;span&gt;)
                            readHolds.set(rh);
                        rh.count&lt;/span&gt;++&lt;span&gt;;
                        cachedHoldCounter &lt;/span&gt;= rh; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cache for release&lt;/span&gt;
&lt;span&gt;                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　读锁的释放方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryReleaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; unused) {
            Thread current &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (firstReader == current) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程是读锁的第一个线程
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert firstReaderHoldCount &amp;gt; 0;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (firstReaderHoldCount == 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次占有读锁 直接清除该线程&lt;/span&gt;
                    firstReader = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    firstReaderHoldCount&lt;/span&gt;--;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读锁的第一个线程重入次数减少&lt;/span&gt;
            } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                HoldCounter rh &lt;/span&gt;=&lt;span&gt; cachedHoldCounter;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rh == &lt;span&gt;null&lt;/span&gt; || rh.tid !=&lt;span&gt; getThreadId(current))
                    rh &lt;/span&gt;=&lt;span&gt; readHolds.get();
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; rh.count;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;lt;= 1&lt;span&gt;) {
                    readHolds.remove();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读锁释放&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (count &amp;lt;= 0&lt;span&gt;)
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; unmatchedUnlockException();
                }
                &lt;/span&gt;--rh.count; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重入次数减少&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nextc = c -&lt;span&gt; SHARED_UNIT;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减少读锁的线程数量&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetState(c, nextc))
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Releasing the read lock has no effect on readers,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; but it may allow waiting writers to proceed if
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; both read and write locks are now free.&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; nextc == 0&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.3 写锁的获取和释放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　写锁的获取方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
            Thread current &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; w = exclusiveCount(c);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写锁状态&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (c != 0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示锁已经被分配出去了 if c != 0 and w == 0表示获取读锁
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (Note: if c != 0 and w == 0 then shared count != 0)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他线程获取到了写锁&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (w == 0 || current !=&lt;span&gt; getExclusiveOwnerThread())
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写锁重入次数超过最大值&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (w + exclusiveCount(acquires) &amp;gt;&lt;span&gt; MAX_COUNT)
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;Maximum lock count exceeded&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reentrant acquire  更新写锁重入次数&lt;/span&gt;
                setState(c +&lt;span&gt; acquires);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (writerShouldBlock() ||&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类实现写锁是否公平获取&lt;/span&gt;
                !compareAndSetState(c, c +&lt;span&gt; acquires))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cas获取写锁失败&lt;/span&gt;
            setExclusiveOwnerThread(current);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取写锁成功 独占&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　写锁的释放方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isHeldExclusively())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程不持有写锁&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalMonitorStateException();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nextc = getState() - releases; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重入次数减少&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; free = exclusiveCount(nextc) == 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;减少到0写锁释放&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (free)
                setExclusiveOwnerThread(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写锁释放&lt;/span&gt;
&lt;span&gt;            setState(nextc);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; free;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.4 锁降级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　锁降级指的是写锁降级为读锁，首先持有当前写锁，然后获取到读锁，在tryAcquireShared方法中已经体现了该过程，随后再释放该写锁的过程。锁降级主要是为了保持数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此时有另外的线程获取到了写锁并修改了数据，那么当前线程是无法知晓数据已经更新了。如果当前线程遵循锁降级的过程，则其他线程会被阻塞，直到当前线程操作完成其他线程才可以获取写锁进行数据更新。RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;/strong&gt; &lt;strong&gt;应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　概况性的总结RentrantReadWriteLock的应用，就是ReentrantLock能使用的地方，RentrantReadWriteLock都能使用，而且能提供更好的吞吐率。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;参考资料:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;https://github.com/lingjiango/ConcurrentProgramPractice&quot;&gt;https://github.com/lingjiango/ConcurrentProgramPractice&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 14:52:00 +0000</pubDate>
<dc:creator>lingjiango</dc:creator>
<og:description>基于AQS的前世今生，来学习并发工具类ReentrantReadWriteLock。本文将从ReentrantReadWriteLock的产生背景、源码原理解析和应用来学习这个并发工具类。 1、 产生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iou123lg/p/9637637.html</dc:identifier>
</item>
<item>
<title>【智能算法】粒子群算法（Particle Swarm Optimization）超详细解析+入门代码实例讲解 - 短短的路走走停停</title>
<link>http://www.cnblogs.com/infroad/p/9637751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/infroad/p/9637751.html</guid>
<description>&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;喜欢的话可以扫码关注我们的公众号哦，更多精彩尽在微信公众号【程序猿声】&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-6-29/64155226.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h01&quot;&gt;&lt;span&gt;01 算法起源&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;粒子群优化算法(PSO)是一种进化计算技术(evolutionary computation)，1995 年由Eberhart 博士和kennedy 博士提出，源于对鸟群捕食的行为研究 。该算法最初是受到飞鸟集群活动的规律性启发，进而利用群体智能建立的一个简化模型。粒子群算法在对动物集群活动行为观察基础上，利用群体中的个体对信息的共享使整个群体的运动在问题求解空间中产生从无序到有序的演化过程，从而获得最优解。&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;&lt;span&gt;02 什么是粒子群算法？&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h21&quot;&gt;&lt;span&gt;2.1 官方定义（参照百科）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;粒子群算法，也称粒子群优化算法或鸟群觅食算法（Particle Swarm Optimization），缩写为 PSO， 是近年来由J. Kennedy和R. C. Eberhart等开发的一种新的进化算法(Evolutionary Algorithm - EA)。PSO 算法属于进化算法的一种，和模拟退火算法相似，它也是从随机解出发，通过迭代寻找最优解，它也是通过适应度来评价解的品质，但它比遗传算法规则更为简单，它没有遗传算法的“交叉”(Crossover) 和“变异”(Mutation) 操作，它通过追随当前搜索到的最优值来寻找全局最优。这种算法以其实现容易、精度高、收敛快等优点引起了学术界的重视，并且在解决实际问题中展示了其优越性。粒子群算法是一种并行算法。&lt;/p&gt;
&lt;h4 id=&quot;h22&quot;&gt;&lt;span&gt;2.2 通俗点描述&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;如同前面的描述，PSO模拟的是鸟群的捕食行为。设想这样一个场景：一群鸟在随机搜索食物。在这个区域里只有一块食物。所有的鸟都不知道食物在那里。但是他们知道当前的位置离食物还有多远。那么找到食物的最优策略是什么呢。最简单有效的就是搜寻目前离食物最近的鸟的周围区域。&lt;/p&gt;
&lt;p&gt;鸟群在整个搜寻的过程中，通过相互传递各自的信息，让其他的鸟知道自己的位置，通过这样的协作，来判断自己找到的是不是最优解，同时也将最优解的信息传递给整个鸟群，最终，整个鸟群都能聚集在食物源周围，即找到了最优解。&lt;/p&gt;
&lt;p&gt;PSO中，每个优化问题的解都是搜索空间中的一只鸟。我们称之为“粒子”。所有的粒子都有一个由被优化的函数决定的适应值(fitness value)，每个粒子还有一个速度决定他们飞翔的方向和距离。然后粒子们就追随当前的最优粒子在解空间中搜索。&lt;/p&gt;
&lt;p&gt;PSO 初始化为一群随机粒子(随机解)。然后通过迭代找到最优解。在每一次迭代中，粒子通过跟踪两个&quot;极值&quot;来更新自己。第一个就是粒子本身所找到的最优解，这个解叫做个体极值pBest。另一个极值是整个种群目前找到的最优解，这个极值是全局极值gBest。另外也可以不用整个种群而只是用其中一部分作为粒子的邻居，那么在所有邻居中的极值就是局部极值。&lt;/p&gt;
&lt;h4 id=&quot;h23&quot;&gt;&lt;span&gt;2.3 再再再通俗点的描述&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;粒子群算法的基本思想是通过群体中个体之间的协作和信息共享来寻找最优解。如上的情景。试着想一下一群鸟在寻找食物，在这个区域中只有一只虫子，所有的鸟都不知道食物在哪。但是它们知道自己的当前位置距离食物有多远，同时它们知道离食物最近的鸟的位置。想一下这时候会发生什么？&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-9-6/9593811.jpg&quot; alt=&quot;&quot;/&gt;&lt;p&gt;同时各只鸟在位置不停变化时候离食物的距离也不断变化，所以每个鸟一定有过离食物最近的位置，这也是它们的一个参考。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-9-6/447585.jpg&quot; alt=&quot;&quot;/&gt;&lt;p&gt;所以，粒子群算法就是把鸟看成一个个粒子，并且他们拥有位置和速度这两个属性，然后根据自身已经找到的离食物最近的解和参考整个共享于整个集群中找到的最近的解去改变自己的飞行方向，最后我们会发现，整个集群大致向同一个地方聚集。而这个地方是离食物最近的区域，条件好的话就会找到食物。&lt;/p&gt;
&lt;h3 id=&quot;h03&quot;&gt;&lt;span&gt;03 粒子抽象&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h31&quot;&gt;&lt;span&gt;3.1 关于速度和位置&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;粒子群算法通过设计一种无质量的粒子来模拟鸟群中的鸟，粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。&lt;/p&gt;
&lt;p&gt;鸟被抽象为没有质量和体积的微粒(点)，并延伸到N维空间，粒子i在N维空间的位置表示为矢量Xi＝(α1，α2，…，αN)，飞行速度表示为矢量Vi＝(β1，β2，…，βN)。每个粒子都有一个由目标函数决定的适应值(fitness value)，并且知道自己到目前为止发现的最好位置(pbest)和现在的位置Xi。这个可以看作是粒子自己的飞行经验。除此之外，每个粒子还知道到目前为止整个群体中所有粒子发现的最好位置(gbest)(gbest是pbest中的最好值)，这个可以看作是粒子同伴的经验。粒子就是通过自己的经验和同伴中最好的经验来决定下一步的运动。&lt;/p&gt;
&lt;h4 id=&quot;h32&quot;&gt;&lt;span&gt;3.2 速度和位置的更新&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;PSO初始化为一群随机粒子(随机解)。然后通过迭代找到最优解。在每一次的迭代中，粒子通过跟踪两个“极值”(pbest，gbest)来更新自己。在找到这两个最优值后，粒子通过下面的公式来更新自己的速度和位置。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-9-6/55013546.jpg&quot; alt=&quot;&quot;/&gt;&lt;p&gt;对于公式(1)：&lt;/p&gt;
&lt;p&gt;公式(1)的第①部分称为【记忆项】，表示上次速度大小和方向的影响；&lt;/p&gt;
&lt;p&gt;公式(1)的第②部分称为【自身认知项】，是从当前点指向粒子自身最好点的一个矢量，表示粒子的动作来源于自己经验的部分；&lt;/p&gt;
&lt;p&gt;公式(1)的第③部分称为【群体认知项】，是一个从当前点指向种群最好点的矢量，反映了粒子间的协同合作和知识共享。粒子就是通过自己的经验和同伴中最好的经验来决定下一步的运动。&lt;/p&gt;
&lt;p&gt;以上面两个公式为基础，再来看一个公式：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-9-6/73018595.jpg&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;公式(2)和 公式(3)被视为标准PSO算法。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;h04pso&quot;&gt;&lt;span&gt;04 标准PSO算法流程&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h41pso&quot;&gt;&lt;span&gt;4.1 标准PSO算法的流程&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1）初始化一群微粒(群体规模为N)，包括随机位置和速度；&lt;/p&gt;
&lt;p&gt;2）评价每个微粒的适应度；&lt;/p&gt;
&lt;p&gt;3）对每个微粒，将其适应值与其经过的最好位置pbest作比较，如果较好，则将其作为当前的最好位置pbest；&lt;/p&gt;
&lt;p&gt;4）对每个微粒，将其适应值与其经过的最好位置gbest作比较，如果较好，则将其作为当前的最好位置gbest；&lt;/p&gt;
&lt;p&gt;5）根据公式(2)、(3)调整微粒速度和位置；&lt;/p&gt;
&lt;p&gt;6）未达到结束条件则转第2）步。&lt;/p&gt;
&lt;p&gt;迭代终止条件根据具体问题一般选为最大迭代次数Gk或(和)微粒群迄今为止搜索到的最优位置满足预定最小适应阈值。&lt;/p&gt;
&lt;h4 id=&quot;h42pso&quot;&gt;&lt;span&gt;4.2 PSO流程图解&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-9-6/46960353.jpg&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h43c1c2&quot;&gt;&lt;span&gt;4.3 学习因子c1、c2分析&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;公式(2)和(3)中pbest和gbest分别表示微粒群的局部和全局最优位置。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当C1＝0时，则粒子没有了认知能力，变为只有社会的模型(social-only)：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-9-6/73761363.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;称为全局PSO算法。粒子有扩展搜索空间的能力，具有较快的收敛速度，但由于缺少局部搜索，对于复杂问题&lt;br/&gt;比标准PSO 更易陷入局部最优。

&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当C2＝0时，则粒子之间没有社会信息，模型变为只有认知(cognition-only)模型：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-9-6/73761363.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;称为局部PSO算法。由于个体之间没有信息的交流，整个群体相当于多个粒子进行盲目的随机搜索，收敛速度慢，因而得到最优解的可能性小。

&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h05&quot;&gt;&lt;span&gt;05 代码实例讲解&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h51&quot;&gt;&lt;span&gt;5.1 先来看个简单的实例&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在这个例子中，我们选取了一个求解函数y=-x*(x-1) 在[0,2]上最大值的粒子群算法。然后通过步步跟踪算法输出结果，来给大家讲解粒子运动的过程。&lt;/p&gt;
&lt;p&gt;下面先看代码和代码注释。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;AlgorithmPSO&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;[] y;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;[] x;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;[] v;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; c1=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; c2=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; pbest[];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; gbest;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; vmax=&lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;fitnessFunction&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;n;i++){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;            y[i]=-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;*x[i]*(x[i]-&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;        }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{ &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;        x=&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;[n];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;        v=&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;[n];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;        y=&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;[n];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;        pbest=&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;[n];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;        x[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;        x[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;2.0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;        v[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;        v[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;0.02&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;        fitnessFunction();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;n;i++){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;            pbest[i]=y[i];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(y[i]&amp;gt;gbest) gbest=y[i];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;34&lt;/span&gt;        }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;35&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;算法开始，起始最优解:&quot;&lt;/span&gt;+gbest);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;36&lt;/span&gt;        System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;37&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;38&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getMAX&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; a,&lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;39&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a&amp;gt;b?a:b;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;40&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;41&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;42&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PSO&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; max)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;43&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;max;i++){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;44&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; w=&lt;span class=&quot;hljs-number&quot;&gt;0.4&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;45&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;j&amp;lt;n;j++){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;46&lt;/span&gt;                &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;47&lt;/span&gt;                v[j]=w*v[j]+c1*Math.random()*(pbest[j]-x[j])+c2*Math.random()*(gbest-x[j]);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;48&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(v[j]&amp;gt;vmax) v[j]=vmax;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;49&lt;/span&gt;                x[j]+=v[j];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;50&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;51&lt;/span&gt;                &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;52&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(x[j]&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) x[j]=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;53&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(x[j]&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) x[j]=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;54&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;55&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;56&lt;/span&gt;            fitnessFunction();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;57&lt;/span&gt;            &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;58&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;j&amp;lt;n;j++){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;59&lt;/span&gt;                pbest[j]=getMAX(y[j],pbest[j]);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;60&lt;/span&gt;                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(pbest[j]&amp;gt;gbest) gbest=pbest[j];&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;61&lt;/span&gt;                System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;粒子n&quot;&lt;/span&gt;+j+&lt;span class=&quot;hljs-string&quot;&gt;&quot;: x = &quot;&lt;/span&gt;+x[j]+&lt;span class=&quot;hljs-string&quot;&gt;&quot;  &quot;&lt;/span&gt;+&lt;span class=&quot;hljs-string&quot;&gt;&quot;v = &quot;&lt;/span&gt;+v[j]);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;62&lt;/span&gt;            }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;63&lt;/span&gt;            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;第&quot;&lt;/span&gt;+(i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)+&lt;span class=&quot;hljs-string&quot;&gt;&quot;次迭代，全局最优解 gbest = &quot;&lt;/span&gt;+gbest);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;64&lt;/span&gt;            System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;65&lt;/span&gt;        }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;66&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;67&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;68&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;69&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;70&lt;/span&gt;        AlgorithmPSO ts=&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; AlgorithmPSO();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;71&lt;/span&gt;        ts.init();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;72&lt;/span&gt;        ts.PSO(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;73&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;74&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;75&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;算法开始，起始最优解:&lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;粒子n0: x = &lt;span class=&quot;hljs-number&quot;&gt;0.004&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.004&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;粒子n1: x = &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;  v = -&lt;span class=&quot;hljs-number&quot;&gt;4.065770842472382&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;第&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;次迭代，全局最优解 gbest = &lt;span class=&quot;hljs-number&quot;&gt;0.007984&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;粒子n0: x = &lt;span class=&quot;hljs-number&quot;&gt;0.01778510589090629&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.013785105890906289&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;粒子n1: x = &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;  v = -&lt;span class=&quot;hljs-number&quot;&gt;1.625639647649872&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;第&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;次迭代，全局最优解 gbest = &lt;span class=&quot;hljs-number&quot;&gt;0.03525390179026183&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;粒子n0: x = &lt;span class=&quot;hljs-number&quot;&gt;0.0610276658084214&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.04324255991751511&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;粒子n1: x = &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;  v = -&lt;span class=&quot;hljs-number&quot;&gt;0.6035255880722042&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;第&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;次迭代，全局最优解 gbest = &lt;span class=&quot;hljs-number&quot;&gt;0.11833095562281844&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;粒子n0: x = &lt;span class=&quot;hljs-number&quot;&gt;0.1610276658084214&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;粒子n1: x = &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;  v = -&lt;span class=&quot;hljs-number&quot;&gt;0.012719944703824898&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;第&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;次迭代，全局最优解 gbest = &lt;span class=&quot;hljs-number&quot;&gt;0.29612542246113416&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;粒子n0: x = &lt;span class=&quot;hljs-number&quot;&gt;0.2610276658084214&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;粒子n1: x = &lt;span class=&quot;hljs-number&quot;&gt;0.06231495466940402&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.06231495466940402&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;第&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;次迭代，全局最优解 gbest = &lt;span class=&quot;hljs-number&quot;&gt;0.4539198892994499&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;粒子n0: x = &lt;span class=&quot;hljs-number&quot;&gt;0.3610276658084214&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;粒子n1: x = &lt;span class=&quot;hljs-number&quot;&gt;0.16231495466940402&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;第&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;次迭代，全局最优解 gbest = &lt;span class=&quot;hljs-number&quot;&gt;0.5917143561377656&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;粒子n0: x = &lt;span class=&quot;hljs-number&quot;&gt;0.46102766580842136&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;粒子n1: x = &lt;span class=&quot;hljs-number&quot;&gt;0.262314954669404&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;第&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;次迭代，全局最优解 gbest = &lt;span class=&quot;hljs-number&quot;&gt;0.7095088229760813&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;粒子n0: x = &lt;span class=&quot;hljs-number&quot;&gt;0.5610276658084213&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;粒子n1: x = &lt;span class=&quot;hljs-number&quot;&gt;0.362314954669404&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;第&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;次迭代，全局最优解 gbest = &lt;span class=&quot;hljs-number&quot;&gt;0.8073032898143969&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;35&lt;/span&gt;粒子n0: x = &lt;span class=&quot;hljs-number&quot;&gt;0.6610276658084213&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;36&lt;/span&gt;粒子n1: x = &lt;span class=&quot;hljs-number&quot;&gt;0.462314954669404&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;37&lt;/span&gt;第&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;次迭代，全局最优解 gbest = &lt;span class=&quot;hljs-number&quot;&gt;0.8850977566527127&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;39&lt;/span&gt;粒子n0: x = &lt;span class=&quot;hljs-number&quot;&gt;0.7610276658084213&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;40&lt;/span&gt;粒子n1: x = &lt;span class=&quot;hljs-number&quot;&gt;0.562314954669404&lt;/span&gt;  v = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;41&lt;/span&gt;第&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;次迭代，全局最优解 gbest = &lt;span class=&quot;hljs-number&quot;&gt;0.9428922234910285&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们来观察两个粒子的位移x在每一次迭代中的变化（离食物的距离）。&lt;/p&gt;
&lt;p&gt;1) 初始状态&lt;/p&gt;
&lt;p&gt;粒子n0: x = 0.0 v = 0.01&lt;br/&gt;粒子n1: x = 2.0 v = 0.02&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-9-9/72026107.jpg&quot; alt=&quot;&quot;/&gt;&lt;p&gt;两个粒子位于区间两端。&lt;/p&gt;
&lt;p&gt;2) 第一次迭代&lt;/p&gt;
&lt;p&gt;粒子n0: x = 0.004 v = 0.004&lt;br/&gt;粒子n1: x = 0.0 v = -4.065770842472382&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-9-9/27426553.jpg&quot; alt=&quot;&quot;/&gt;&lt;p&gt;两个粒子都跑到原点了。&lt;/p&gt;
&lt;p&gt;3) 第二、三……十次迭代&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-9-9/29956217.jpg&quot; alt=&quot;&quot;/&gt;&lt;p&gt;可以看到，两个粒子在不断靠近最优点。上面多个圈是他们聚集的过程，可以看出来，聚集过程是个越来越密集的过程。这才是10次迭代而已。如果我们加大迭代次数，很容易就找出最优解了。最后放上一个迭代100次的结果：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://oyxhmjutw.bkt.clouddn.com/18-9-9/30303264.jpg&quot; alt=&quot;&quot;/&gt;&lt;p&gt;相信通过这个简单的例子。大家已经对粒子群算法有了非常清晰的认识了。&lt;/p&gt;
&lt;h3 id=&quot;h06psoga&quot;&gt;&lt;span&gt;06 PSO和GA比较&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h61&quot;&gt;&lt;span&gt;6.1 共性&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;(1)都属于仿生算法。&lt;br/&gt;(2) 都属于全局优化方法。&lt;br/&gt;(3) 都属于随机搜索算法。&lt;br/&gt;(4) 都隐含并行性。&lt;br/&gt;(5) 根据个体的适配信息进行搜索，因此不受函数 约束条件的限制，如连续性、可导性等。&lt;br/&gt;(6) 对高维复杂问题，往往会遇到早熟收敛和收敛 性能差的缺点，都无法保证收敛到最优点。&lt;/p&gt;
&lt;h4 id=&quot;h62&quot;&gt;&lt;span&gt;6.2 差异&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;(1) PSO有记忆，好的解的知识所有粒子都保 存，而GA，以前的知识随着种群的改变被改变。&lt;br/&gt;(2) PSO中的粒子仅仅通过当前搜索到最优点进行共享信息，所以很大程度上这是一种单共享项信息机制。而GA中，染色体之间相互共享信息，使得整个种群都向最优区域移动。&lt;br/&gt;(3) GA的编码技术和遗传操作比较简单，而PSO 相对于GA，没有交叉和变异操作，粒子只是通过内部速度进行更新，因此原理更简单、参数更少、实现更容易。&lt;/p&gt;
&lt;h3 id=&quot;h07&quot;&gt;&lt;span&gt;07 代码下载&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;欲获取代码，请关注我们的微信公众号【程序猿声】，在后台回复：&lt;strong&gt;PSO&lt;/strong&gt; 。即可下载。&lt;/p&gt;
&lt;img title=&quot;微信公众号&quot; src=&quot;http://upload-images.jianshu.io/upload_images/10386940-546ac15b9d7add56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;微信公众号&quot;/&gt;&lt;p&gt;推荐文章：&lt;a href=&quot;https://www.cnblogs.com/infroad/p/9260954.html&quot;&gt;10分钟教你用Python做个打飞机小游戏超详细教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐文章：&lt;a href=&quot;https://www.cnblogs.com/infroad/p/9269158.html&quot;&gt;10分钟教你用python下载和拼接微信好友头像图片&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐文章：&lt;a href=&quot;https://www.cnblogs.com/infroad/p/9275903.html&quot;&gt;10分钟教你用python一行代码搞点大新闻&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐文章：&lt;a href=&quot;https://www.cnblogs.com/infroad/p/9241267.html&quot;&gt;10分钟教你用python打造贪吃蛇超详细教程&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 14:16:00 +0000</pubDate>
<dc:creator>短短的路走走停停</dc:creator>
<og:description>喜欢的话可以扫码关注我们的公众号哦，更多精彩尽在微信公众号【程序猿声】 01 算法起源 粒子群优化算法(PSO)是一种进化计算技术(evolutionary computation)，1995 年由E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/infroad/p/9637751.html</dc:identifier>
</item>
<item>
<title>cocos2d-x学习之路（二）——分析AppDelegate和HelloWorldScene文件 - VisualGMQ</title>
<link>http://www.cnblogs.com/learn-program/p/9636795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learn-program/p/9636795.html</guid>
<description>&lt;p&gt;这里我们来看一下cocos自动给我们生成的工程里有些什么东西，并且分析一下这些代码的用途，来为我们以后编写cocos程序铺下基础。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我建议看我这份随笔的看官先看看cocos官网的快速入门手册，不然可能会比较迷糊（因为待会要分析一些代码，如果以前没见过的话会比较昏）。&lt;/span&gt;&lt;a href=&quot;http://www.cocos2d-x.org/docs/cocos2d-x/zh/index.html&quot; target=&quot;_blank&quot;&gt;传送门在这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中一些基本不需要程序员干涉的代码我可能会不予分析。你也可以查看官方API手册。&lt;span&gt;&lt;a href=&quot;http://cocos2d-x.org/docs/api-ref/cplusplus/v3x/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;传送门在这里&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下面的代码分析，如果是非常有用的东西我会在分析中用蓝色标出。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 首先我们进入相关的系统（你的如果是mac就打开proj.ios_mac文件夹下的工程，是windows就打开proj.win32文件夹下的工程，以此类推）的工程。我这里是mac，运行一下cocos给我们生成的代码，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180912193510199-447782095.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然是自己的demo嘛，当然要给自己打个广告啦（那个居中的图标显然是cocos的logo）&lt;/p&gt;
&lt;p&gt;这个界面里面有一些我们可以直接看出来的东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180912194339245-1514779719.png&quot; alt=&quot;&quot; width=&quot;632&quot; height=&quot;454&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里所有的元素都是我根据以往用过的引擎猜测的，实际上我们还是要看一下代码&lt;/span&gt;。不过我们目前知道大概有这么些东西了，待会可以针对着看一下。&lt;/p&gt;
&lt;p&gt;然后我们可以看看这些资源在哪里，我通过XCODE可以直接看到： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180912195028002-1536361232.png&quot; alt=&quot;&quot; width=&quot;322&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里logo是HelloWorld.png，右下角的开关机图标是CloseNormal.png，而那个CloseSelected.png是按下按钮的图片。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;分析AppDelegate&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;好的，到我们的分析阶段了。AppDelegate分为头文件和实现文件。我们当然是先看头文件啦。这个文件在Classes文件夹下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef  _APP_DELEGATE_H_
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;  _APP_DELEGATE_H_
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cocos2d.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;@brief    The cocos2d Application.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;Private inheritance here hides part of interface from Director.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;  AppDelegate : &lt;span&gt;private&lt;/span&gt;&lt;span&gt; cocos2d::Application
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    AppDelegate();　　//构造函数
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;AppDelegate();　　//析构函数
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initGLContextAttrs();　　//这个暂时不知道是干什么的
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @brief    Implement Director and Scene init code here.
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @return true    Initialize success, app continue.
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @return false   Initialize failed, app terminate.
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; applicationDidFinishLaunching();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    @brief  Called when the application moves to the background
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    @param  the pointer of the application
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; applicationDidEnterBackground();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    @brief  Called when the application reenters the foreground
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    @param  the pointer of the application
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; applicationWillEnterForeground();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; _APP_DELEGATE_H_&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第4行包含了cocos2d的头文件。&lt;/p&gt;
&lt;p&gt;第11行定义了AppDelegate类，继承自cocos2d的Application类。&lt;/p&gt;
&lt;p&gt;这里堆AppDelegate类的几个虚函数在注释上都有一定的说明了：&lt;/p&gt;
&lt;p&gt;第24行的applicationDidFinishLaunching()是在程序初始化的时候自动调用的函数。在这里面我们可以初始化导演（Director）和场景（Scence）。如果程序初始化成果会返回True，否则返回False。&lt;/p&gt;
&lt;p&gt;第30行的applicationDidEnterBackground()是在程序失去焦点的时候调用。这里面一般是加入用来停止程序的代码。&lt;/p&gt;
&lt;p&gt;第36行的applicationWillEnterForeground()是在程序获得焦点的时候调用，可以在里面加入继续游戏的代码。&lt;/p&gt;

&lt;p&gt;接下来看看实现文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppDelegate.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorldScene.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; #define USE_AUDIO_ENGINE 1
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; #define USE_SIMPLE_AUDIO_ENGINE 1&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; USE_AUDIO_ENGINE &amp;amp;&amp;amp; USE_SIMPLE_AUDIO_ENGINE
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;#error&lt;/span&gt; &quot;Don't use AudioEngine and SimpleAudioEngine at the same time. Please just select one in your game!&quot;
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; USE_AUDIO_ENGINE
&lt;span&gt; 12&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;audio/include/AudioEngine.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; cocos2d::experimental;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;#elif&lt;/span&gt; USE_SIMPLE_AUDIO_ENGINE
&lt;span&gt; 15&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;audio/include/SimpleAudioEngine.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CocosDenshion;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;USING_NS_CC;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; cocos2d::Size designResolutionSize = cocos2d::Size(&lt;span&gt;480&lt;/span&gt;, &lt;span&gt;320&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; cocos2d::Size smallResolutionSize = cocos2d::Size(&lt;span&gt;480&lt;/span&gt;, &lt;span&gt;320&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; cocos2d::Size mediumResolutionSize = cocos2d::Size(&lt;span&gt;1024&lt;/span&gt;, &lt;span&gt;768&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; cocos2d::Size largeResolutionSize = cocos2d::Size(&lt;span&gt;2048&lt;/span&gt;, &lt;span&gt;1536&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;AppDelegate::AppDelegate()
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt; AppDelegate::~&lt;span&gt;AppDelegate() 
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; USE_AUDIO_ENGINE
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;    AudioEngine::end();
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;#elif&lt;/span&gt; USE_SIMPLE_AUDIO_ENGINE
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;    SimpleAudioEngine::end();
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if you want a different context, modify the value of glContextAttrs
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; it will affect all platforms&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AppDelegate::initGLContextAttrs()　　　　&lt;span&gt;//这个真心没看懂是个啥
&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set OpenGL context attributes: red,green,blue,alpha,depth,stencil,multisamplesCount&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;     GLContextAttrs glContextAttrs = {&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;    GLView::setGLContextAttrs(glContextAttrs);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if you want to use the package manager to install more packages,  
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; don't modify or remove this function&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; register_all_packages()
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;flag for packages manager&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; AppDelegate::applicationDidFinishLaunching() {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initialize director&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;     auto director =&lt;span&gt; Director::getInstance();
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     auto glview = director-&amp;gt;&lt;span&gt;getOpenGLView();
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;glview) {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) || (CC_TARGET_PLATFORM == CC_PLATFORM_MAC) || (CC_TARGET_PLATFORM == CC_PLATFORM_LINUX)
&lt;span&gt; 62&lt;/span&gt;         glview = GLViewImpl::createWithRect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestGame&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, cocos2d::Rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, designResolutionSize.width, designResolutionSize.height));
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         glview = GLViewImpl::create(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestGame&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;         director-&amp;gt;&lt;span&gt;setOpenGLView(glview);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; turn on display FPS&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;     director-&amp;gt;setDisplayStats(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set FPS. the default value is 1.0/60 if you don't call this&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;     director-&amp;gt;setAnimationInterval(&lt;span&gt;1.0f&lt;/span&gt; / &lt;span&gt;60&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set the design resolution&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;     glview-&amp;gt;&lt;span&gt;setDesignResolutionSize(designResolutionSize.width, designResolutionSize.height, ResolutionPolicy::NO_BORDER);　　&lt;span&gt;//不知道是干啥的
&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     auto frameSize = glview-&amp;gt;&lt;span&gt;getFrameSize();
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if the frame's height is larger than the height of medium size.&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (frameSize.height &amp;gt;&lt;span&gt; mediumResolutionSize.height)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;    {        
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         director-&amp;gt;setContentScaleFactor(MIN(largeResolutionSize.height/designResolutionSize.height, largeResolutionSize.width/&lt;span&gt;designResolutionSize.width));
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if the frame's height is larger than the height of small size.&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (frameSize.height &amp;gt;&lt;span&gt; smallResolutionSize.height)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;    {        
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         director-&amp;gt;setContentScaleFactor(MIN(mediumResolutionSize.height/designResolutionSize.height, mediumResolutionSize.width/&lt;span&gt;designResolutionSize.width));
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if the frame's height is smaller than the height of medium size.&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    {        
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         director-&amp;gt;setContentScaleFactor(MIN(smallResolutionSize.height/designResolutionSize.height, smallResolutionSize.width/&lt;span&gt;designResolutionSize.width));
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    register_all_packages();
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create a scene. it's an autorelease object&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;     auto scene =&lt;span&gt; HelloWorld::createScene();
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; run&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;     director-&amp;gt;&lt;span&gt;runWithScene(scene);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This function will be called when the app is inactive. Note, when receiving a phone call it is invoked.&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AppDelegate::applicationDidEnterBackground() {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;     Director::getInstance()-&amp;gt;&lt;span&gt;stopAnimation();
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; USE_AUDIO_ENGINE
&lt;span&gt;110&lt;/span&gt; &lt;span&gt;    AudioEngine::pauseAll();
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;#elif&lt;/span&gt; USE_SIMPLE_AUDIO_ENGINE
&lt;span&gt;112&lt;/span&gt;     SimpleAudioEngine::getInstance()-&amp;gt;&lt;span&gt;pauseBackgroundMusic();
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;     SimpleAudioEngine::getInstance()-&amp;gt;&lt;span&gt;pauseAllEffects();
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this function will be called when the app is active again&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AppDelegate::applicationWillEnterForeground() {
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;     Director::getInstance()-&amp;gt;&lt;span&gt;startAnimation();
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; USE_AUDIO_ENGINE
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;    AudioEngine::resumeAll();
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;#elif&lt;/span&gt; USE_SIMPLE_AUDIO_ENGINE
&lt;span&gt;124&lt;/span&gt;     SimpleAudioEngine::getInstance()-&amp;gt;&lt;span&gt;resumeBackgroundMusic();
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;     SimpleAudioEngine::getInstance()-&amp;gt;&lt;span&gt;resumeAllEffects();
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 第18行以上的乱七八糟的东西我们就先不看了，无非就是包含头文件啊，使用命名空间什么的。这些暂时不管。&lt;/p&gt;
&lt;p&gt;第19行是一个宏，可以进入到里面看看（这个宏后面用到的还比较多）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; USING_NS_CC                     using namespace cocos2d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到就是使用cocos2d的命名空间。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第21～24行定义了四种大小（从cocos2d::Size可以看出是大小的定义），按照变量名字分别是设计时大小，最小化大小，通常化大小和最大化大小。这里我还是要重复说一下：现在这些只是我们的猜测，具体的还是要看到相关代码才行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么我们可以想，我是不是更改一下这些玩意就可以改变窗口大小了呢？嗯……可以尝试一下，就先从designResolutionSize下手吧。&lt;/p&gt;
&lt;p&gt;我这里将designResolutionSize参数改成1024，480，果然窗口的大小改变了： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180912200944889-345940829.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过改变了其他三个尺寸之后窗口没什么变化。暂时先不管吧，反正现在知道&lt;span&gt;designResolutionSize变量存储的是当前窗口的大小&lt;/span&gt;就行了&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;30～37行是析构函数的实现。可以看出是释放了AudioEngine和SimpleAudioEngine两个模块。&lt;/li&gt;
&lt;li&gt;51行的函数用于管理包。当你想要使用包管理器（Package Manager）来安装多个包的时候，就不要修改或者删除这里的代码。（你问我包是啥？对不起我也不晓得。你说那你怎么知道这个是包管理器函数？看注释啊🙂）&lt;/li&gt;
&lt;li&gt;56~103是个大函数，为程序初始化的时候调用的函数。让我们来慢慢分析：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;58行初始化了导演。按照官方快速入门手册的说法，导演（Direct）是一个单例对象（关于单例请见单例模式），主要用于切换场景啊，维护层啊什么的，就和我们生活中的导演差不多。&lt;/li&gt;
&lt;li&gt;59~67行初始化了视图。并且对视图创建失败做了一定的检测。最后将这个视图指定为Direct的视图。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;70行打开了FPS显示。这里你可以把参数改为false，运行程序你会发下左下角的调试信息消失了。这个比较重要，因为我们的游戏最后发布的时候是不需要显示FPS信息的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;73行设置了这个程序的帧率，即FPS。从参数可以看出是60帧每秒（FPS=60）。这个到时候在制作自己的游戏的时候可以根据实际情况改一改。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;79~92行分别对窗口大小大于smallResolutionSize ，mediumResolutionSize ，largeResolutionSize时做出行动。这里的setContentScaleFactor函数是“改变Surface里像素的大小”。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;96行创建了一个场景（Scene）&lt;/span&gt;。根据官方手册知道场景是用来容纳物体（比如Sprite啊什么的&lt;/span&gt;）的。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;100行说明在程序开始的时候运行这个场景&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;接下来的106~115行是用来指定窗口获得焦点时的相关行动&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;118~127则是窗口失去焦点的相关行动&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里关于APPDelegate文件就分析完了。我们看出来好像这个文件里面没有什么和我们一开始看到的界面元素有关系。好像都是一些对游戏初始化的工作。所以以后我们不会大幅度更改这里面的代码。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;分析HelloWorldScene文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 那么首先还是来看看其头文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef __HELLOWORLD_SCENE_H__
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; __HELLOWORLD_SCENE_H__
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cocos2d.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HelloWorld : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; cocos2d::Scene
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; cocos2d::Scene*&lt;span&gt; createScene();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; init();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a selector callback&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; menuCloseCallback(cocos2d::Ref*&lt;span&gt; pSender);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; implement the &quot;static create()&quot; method manually&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    CREATE_FUNC(HelloWorld);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; __HELLOWORLD_SCENE_H__&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个头文件挺简单的，定义了一个HelloWorld类继承自cocos2d::Scene。&lt;/p&gt;

&lt;p&gt;接下来看看实现文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorldScene.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SimpleAudioEngine.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;USING_NS_CC;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; Scene*&lt;span&gt; HelloWorld::createScene()
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; HelloWorld::create();
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Print useful error message instead of segfaulting when files are not there.&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; problemLoading(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; filename)
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error while loading: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, filename);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Depending on how you compiled you might have to add 'Resources/' in front of filenames in HelloWorldScene.cpp\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; on &quot;init&quot; you need to initialize your instance&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; HelloWorld::init()
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;//////////////////////////////
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. super init first&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;Scene::init() )
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt;     auto visibleSize = Director::getInstance()-&amp;gt;&lt;span&gt;getVisibleSize();
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     Vec2 origin = Director::getInstance()-&amp;gt;&lt;span&gt;getVisibleOrigin();
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;///////////////////////////&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. add a menu item with &quot;X&quot; image, which is clicked to quit the program
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    you may modify it.
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add a &quot;close&quot; icon to exit the progress. it's an autorelease object&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     auto closeItem =&lt;span&gt; MenuItemImage::create(
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;                                            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CloseNormal.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                                            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CloseSelected.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                                            CC_CALLBACK_1(HelloWorld::menuCloseCallback, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (closeItem == nullptr ||
&lt;span&gt; 42&lt;/span&gt;         closeItem-&amp;gt;getContentSize().width &amp;lt;= &lt;span&gt;0&lt;/span&gt; ||
&lt;span&gt; 43&lt;/span&gt;         closeItem-&amp;gt;getContentSize().height &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         problemLoading(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'CloseNormal.png' and 'CloseSelected.png'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;float&lt;/span&gt; x = origin.x + visibleSize.width - closeItem-&amp;gt;getContentSize().width/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;float&lt;/span&gt; y = origin.y + closeItem-&amp;gt;getContentSize().height/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         closeItem-&amp;gt;&lt;span&gt;setPosition(Vec2(x,y));
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create menu, it's an autorelease object&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;     auto menu =&lt;span&gt; Menu::create(closeItem, NULL);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     menu-&amp;gt;&lt;span&gt;setPosition(Vec2::ZERO);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;addChild(menu, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;///////////////////////////&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. add your codes below...
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add a label shows &quot;Hello World&quot;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create and initialize a label&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;     auto label = Label::createWithTTF(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fonts/Marker Felt.ttf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (label ==&lt;span&gt; nullptr)
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         problemLoading(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'fonts/Marker Felt.ttf'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; position the label on the center of the screen&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;         label-&amp;gt;setPosition(Vec2(origin.x + visibleSize.width/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                                 origin.y + visibleSize.height - label-&amp;gt;&lt;span&gt;getContentSize().height));
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add the label as a child to this layer&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;addChild(label, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add &quot;HelloWorld&quot; splash screen&quot;&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;     auto sprite = Sprite::create(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWorld.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (sprite ==&lt;span&gt; nullptr)
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;         problemLoading(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'land.png'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; position the sprite on the center of the screen&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;         sprite-&amp;gt;setPosition(Vec2(visibleSize.width/&lt;span&gt;2&lt;/span&gt; + origin.x, visibleSize.height/&lt;span&gt;2&lt;/span&gt; +&lt;span&gt; origin.y));
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add the sprite as a child to this layer&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;addChild(sprite, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HelloWorld::menuCloseCallback(Ref*&lt;span&gt; pSender)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Close the cocos2d-x game scene and quit the application&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;     Director::getInstance()-&amp;gt;&lt;span&gt;end();
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;#if&lt;/span&gt; (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)
&lt;span&gt;104&lt;/span&gt;     exit(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;第六行的createScene()函数调用了HelloWorld类的create方法创建了一个层。你说诶不对啊，上面那个HelloWorld类的定义里面没有create方法呀。这个时候你可以回过头再去看看CREATE_FUNC宏的代码。其实CREATE_FUNC函数就是create函数啦。这个函数被APPDelegate类调用过（见APPDelegate的实现文件97行）&lt;/li&gt;
&lt;li&gt;12~16行定义的函数用于输出错误信息&lt;/li&gt;
&lt;li&gt;19~95行定义了HelloWorld类的init函数。这个函数是在CREATE_FUNC里面被调用的。我们来看看这个函数里面到底有些啥&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;23~26行为第一步——创建Scene&lt;/li&gt;
&lt;li&gt;36~57创建菜单（原来菜单在这里，赶紧看看那这个菜单是什么）&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;首先36行通过MenuItemImage的create方法创建一个菜单组件。&lt;/span&gt;注意到这里面的参数！这个参数正是我们前面在界面上看到的开关机图像！原来那个东西不是按钮，是一个菜单。&lt;/li&gt;
&lt;li&gt;41~52行判断是否创建菜单项成功，并且调整菜单项位置为右下角&lt;/li&gt;
&lt;li&gt;&lt;span&gt;55行通过菜单组件创建一个菜单&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;56行设置菜单位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;57行将菜单放到层的树里面（就是放到层中）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;65~95行，注释上写着“加入你自己的代码”。我们来看看cocos给我们加了什么代码
&lt;ul&gt;&lt;li&gt;65行创建了一个label，而且是使用TTF字体创建的。用于显示HelloWorld（果然HelloWorld是个label）&lt;/li&gt;
&lt;li&gt;66~78行判断label是否创建成功，并且设置了label的位置，加入了层。&lt;/li&gt;
&lt;li&gt;81行创建了一个Sprite，也就是精灵。用于绘制那个logo。&lt;/li&gt;
&lt;li&gt;82~93行同样是判断精灵是否创建成功，然后修改位置，加入层。 &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最后98~107定义了菜单的回调函数。这里如果点击了就会推出程序。然后这里有一个比较重要的东西：CC_TARGET_PLATFORM常量。这个常量存储着这个程序运行的操作系统。这里判断是否为IOS操作系统。我们可以使用这个常量来获得当前操作系统。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么知道了这些之后，你可以更改一下代码来产生自己的界面。我这里改变了label的显示，并且改变了logo（把你要替换logo的图片放在Resource/res下，而且最好是png。我一开始使用bmp不能读取）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180912214828978-1368008820.png&quot; alt=&quot;&quot; width=&quot;1212&quot; height=&quot;948&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，我们的demo就分析完成了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;函数调用的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可能看完上面的分析有些人会有些头昏：“这说的都是啥和啥啊我现在脑子里一片混乱”。没关系，下面我们使用函数之间的调用图来说明一下这四个文件到底干了什么： &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180912215416223-574146046.png&quot; alt=&quot;&quot; width=&quot;1091&quot; height=&quot;843&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这下清楚许多了吧。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在我们来总结一些常用的代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;designResolutionSize变量用于设定窗口大小&lt;/li&gt;
&lt;li&gt;&lt;span&gt;director-&amp;gt;setDisplayStats(true);用于设置是否显示FPS&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;director-&amp;gt;setAnimationInterval(1.0f / 60);用于设置FPS&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其他的代码，有的涉及到菜单和label的，我们放到以后的专题去说。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Sep 2018 13:50:00 +0000</pubDate>
<dc:creator>VisualGMQ</dc:creator>
<og:description>cocos2d-x编程，分析一下工程中本来就有的四个文件，来弄清整个cocos的框架</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learn-program/p/9636795.html</dc:identifier>
</item>
<item>
<title>一统江湖的大前端（3） DOClever——你的postman有点low - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9609307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9609307.html</guid>
<description>&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;《一统江湖的大前端》系列是自己的前端学习笔记，旨在介绍javascript在非网页开发领域的应用案例和发现各类好玩的js库，不定期更新。如果你对前端的理解还是写写页面绑绑事件，那你真的是有点OUT了，前端能做的事情已经太多了, &lt;code&gt;手机app开发&lt;/code&gt; , &lt;code&gt;桌面应用开发&lt;/code&gt; , &lt;code&gt;用于神经网络人工智能的库&lt;/code&gt; , &lt;code&gt;页面游戏&lt;/code&gt; , &lt;code&gt;数据可视化&lt;/code&gt; , 甚至 &lt;code&gt;嵌入式开发&lt;/code&gt; ，什么火就搞什么,活脱脱一个&lt;strong&gt;蹭热点小能手&lt;/strong&gt;。如果你也觉得前端的日常开发有些枯燥，不妨一起来看看前端的另一番模样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/07/3cb747240a6e89821b931ee097e784fa.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mock服务器-excel怎么了&quot;&gt;Mock服务器 + Excel怎么了&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果你的开发进度还在被后端开发人员牵着鼻子走，请参考《一统江湖的大前端（2）—— Mock.js+Node.js如何与后端潇洒分手》，优化自己的开发工作流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了Mock服务器和Excel的文档说明后，相信大家的沟通效率会比以前提升很多，但仍然被沟通占据着绝大部分开发时间，常常遇到的情况会有：&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;没有注释信息，字段不宜对齐&lt;/strong&gt;&lt;br/&gt;Mock服务器返回的只有数据，没有注释信息，即便后端开发人员有心把查到的信息重组为你需要的字段，但仍有可能因为无法对号入座而作罢。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;接口数量增加后难以管理&lt;/strong&gt;&lt;br/&gt;简易的Mock服务器无法提供相应的接口文档，随着接口数量的增加，分分钟乱成一锅粥，总不能每次查个接口都是跑去翻Mock服务器的源代码然后看注释吧&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;无测试支持&lt;/strong&gt;&lt;br/&gt;MockJs只生成模拟数据，并无任何对自动化测试的支持&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;满怀热情写了API文档，But没人看&lt;/strong&gt;&lt;br/&gt;程序员大多没有Excel习惯，而且大家都很忙，忙到即便你提供了Mock接口以及相关的API说明，他们还是会再问你一遍关于接口的信息&lt;em&gt;程序员习惯以自己熟悉的方式进行工作，而且一般默认这种效率最高&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Excel版本的API文档方便交流，但不易更新&lt;/strong&gt;&lt;br/&gt;一对一联调时候还好，但如果项目组内协作人员较多时，麻烦就来了，每当你更新或是增加接口信息时，就要重新给所有相关人员发送一次新的Excel文件，很不方便。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;doclever前端开发的接口管理工具&quot;&gt;DOClever——前端开发的接口管理工具&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/07/53e0080feb9f289a896948a9a14a7016.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java开发人员有&lt;code&gt;Swagger&lt;/code&gt;，无严格保密性要求的可以尝试阿里的&lt;code&gt;RAP&lt;/code&gt;，都是专业且强大的接口管理工具。当我们仅希望在内网中使用，或仅仅处于优化个人工作流的目的时，强烈推荐这块&lt;strong&gt;开源接口管理软件&lt;/strong&gt;——&lt;code&gt;DOClever&lt;/code&gt;，&lt;code&gt;DOClever&lt;/code&gt;非常适合前端人员使用，&lt;code&gt;VUE+express+mongodb&lt;/code&gt;编写，纯前端技术栈，能够实现&lt;code&gt;团队管理&lt;/code&gt;，&lt;code&gt;接口管理&lt;/code&gt;，&lt;code&gt;文档管理&lt;/code&gt;，&lt;code&gt;自动化测试&lt;/code&gt;等功能，甚至可以根据接口返回数据自动生成接口文档的结构，方便智能。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;无论你当前在做的项目是否有管理好相关的接口文档，作为开发人员，你都应该有自己的方式来管理好所有出自你手的接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;mockjs尚未失宠&quot;&gt;MockJs尚未失宠&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;特殊场景&lt;br/&gt;&lt;code&gt;DOClever&lt;/code&gt;自带的Mock工具可以按参数类型生成虚拟数据，对于开发人员交流已经够用了，但如果前台需要多条&lt;code&gt;模式相同&lt;/code&gt;的数据时，就需要用到上一篇博客中提到的MockJs来生成，（&lt;code&gt;DOClever&lt;/code&gt;自带的Mock语法貌似尚未支持循环生成雷同数据，除了自己修改源代码外，如果还有其他更方便的实现方法也请不吝赐教~），&lt;code&gt;DOClever&lt;/code&gt;中可以设置多台Mock服务器的url地址，常见的协作需求中，两套数据基本够用了，一套方便快捷，配合核对接口，另一套需要自定义开发，配合实现各种前端展示需求。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;doclever的安装&quot;&gt;DOClever的安装&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;安装需要的东西真的比较多，尤其是对于非前端人员而言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;1.安装nodejs&lt;br/&gt;上一篇博客的附件中有&lt;code&gt;nodejs V8.9&lt;/code&gt;的安装包&lt;/li&gt;
&lt;li&gt;2.安装mongodb&lt;br/&gt;mongodb的安装可以参考&lt;a href=&quot;http://www.cnblogs.com/lecaf/p/mongodb.html&quot;&gt;Windows环境下如何安装mongodb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;3.安装mongodb可视化管理工具(个人推荐robot3T)[可选]&lt;/li&gt;
&lt;li&gt;4.安装DOClever&lt;br/&gt;由于是开源项目，直接在github上下载&lt;a href=&quot;https://github.com/sx1989827/DOClever&quot;&gt;DOClever&lt;/a&gt;,使用方法主页有很详细的说明，按步骤来部署就可以了。&lt;br/&gt;自己部署的图：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/07/ad2ecef0acb1d76df17bf2ec14939fba.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始doclever&quot;&gt;开始DOCLever&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可视化的管理API&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;界面左侧树形图式管理所有相关API，方便查找&lt;/li&gt;
&lt;li&gt;可视化界面直接填写API相关信息&lt;/li&gt;
&lt;li&gt;参数化填写request请求体&lt;/li&gt;
&lt;li&gt;参数化编写响应数据，支持无限层次嵌套&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/07/f5a8f3f05fcaede7dcd0d97c75cf6a12.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方便的Mock数据获取&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;直接选择DOClever自带的mock服务器，可以方便地与协作人员沟通接口字段和结构&lt;/li&gt;
&lt;li&gt;选择自己搭建的Mock服务器，可以方便地获得更多&lt;strong&gt;模式相同&lt;/strong&gt;的响应数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/07/270638aebc5799e6534be8ebd2c777bd.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;自动化接口测试&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;简易的自动化测试语法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/07/0621adb37594f07e0c86b571a1c8a5e8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;自动化测试集计划任务&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;定时跑任务自动化测试用例集&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/07/85df6842868f60ceb06f84a28cbed50b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;别人开发的代码你可以不管，但出自你手的代码， 愿它们都是精品，易于查询，易于管理。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 13:38:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>《一统江湖的大前端》系列是自己的前端学习笔记，旨在介绍javascript在非网页开发领域的应用案例和发现各类好玩的js库，不定期更新。如果你对前端的理解还是写写页面绑绑事件，那你真的是有点OUT了，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9609307.html</dc:identifier>
</item>
<item>
<title>Spring Cloud 微服务架构学习笔记与示例 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/java_spring_cloud_foundation_sample_list.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/java_spring_cloud_foundation_sample_list.html</guid>
<description>&lt;p&gt;本文示例基于Spring Boot 1.5.x实现，如对Spring Boot不熟悉，可以先学习我的这一篇：《&lt;a title=&quot;spring boot&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/java_spring_boot_foundation_demos.html&quot; target=&quot;_blank&quot;&gt;Spring Boot 1.5.x 基础学习示例&lt;/a&gt;》。关于微服务基本概念不了解的童鞋，可以先阅读下始祖Martin Fowler的《&lt;a title=&quot;Microservice - 翻译版&quot; href=&quot;https://mp.weixin.qq.com/s/fzk-kENu0I22P3F2Vu7KBA&quot; target=&quot;_blank&quot;&gt;Microservice&lt;/a&gt;》，本文不做介绍和描述。&lt;/p&gt;

&lt;h2&gt;1.1 第一代服务框架&lt;/h2&gt;
&lt;p&gt;　　代表：Dubbo(Java)、Orleans(.Net)等&lt;/p&gt;
&lt;p&gt;　　特点：和语言绑定紧密&lt;/p&gt;
&lt;h2&gt;1.2 第二代服务框架&lt;/h2&gt;
&lt;p&gt;　　代表：Spring Cloud等&lt;/p&gt;
&lt;p&gt;　　现状：适合混合式开发（例如借助Steeltoe OSS可以让ASP.Net Core与Spring Cloud集成），正值当年&lt;/p&gt;
&lt;h2&gt;1.3 第三代服务框架&lt;/h2&gt;
&lt;p&gt;　　代表：Service Mesh（服务网格） =&amp;gt; 例如Service Fabric、lstio、Linkerd、Conduit等&lt;/p&gt;
&lt;p&gt;　　现状：在快速发展中，更新迭代比较快&lt;/p&gt;
&lt;h2&gt;1.4 未来（目测不久）主流的服务架构和技术栈&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180823103510130-441053512.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　基础的云平台为微服务提供了资源能力（计算、存储和网络等），容器作为最小工作单元被Kubernetes调度和编排，Service Mesh（服务网格）管理微服务的服务通信，最后通过API Gateway向外暴露微服务的业务接口。&lt;/p&gt;
&lt;p&gt;　　目前，我所在的项目组已经在采用这种技术架构了，服务网格采用的是Linkerd，容器编排采用的是K8S，Spring Cloud已经没用了。But，不代表Spring Cloud没有学习的意义，对于中小型项目团队，&lt;strong&gt;&lt;em&gt;Spring Cloud仍然是快速首选&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;2.1 Spring Cloud极简介绍&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180822202553841-1217264857.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　首先，尽管Spring Cloud带有“Cloud”这个单词，但它并不是云计算解决方案，而是在Spring Boot基础之上构建的，用于快速构建分布式系统的通用模式的工具集。&lt;/p&gt;
&lt;p&gt;　　 其次，使用Spring Cloud开发的应用程序非常适合在Docker和PaaS（比如Pivotal Cloud Foundry）上部署，所以又叫做云原生应用（Cloud Native Application）。云原生可以简单地理解为面向云环境的软件架构。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;总结 &lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;：&lt;/strong&gt;Spring Cloud是一个基于Spring Boot实现的云原生应用开发工具，它为基于JVM的云原生应用开发中涉及的配置管理、服务发现、熔断器、智能路由、微代理、控制总线、分布式会话和集群状态管理等操作提供了一种简单的开发方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Spring Cloud具有如下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;约定大于配置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;适用于各种环境&lt;/li&gt;
&lt;li&gt;隐藏了组件的复杂性，并提供声明式、无XML式的配置方式&lt;/li&gt;
&lt;li&gt;开箱即用，快速启动&lt;/li&gt;
&lt;li&gt;&lt;span&gt;组件丰富，功能齐全&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　Spring Cloud作为第二代微服务的代表性框架，已经在国内众多大中小型的公司有实际应用案例。许多公司的业务线全部拥抱Spring Cloud，部分公司选择部分拥抱Spring Cloud。例如，拍拍贷资深架构师杨波老师就根据自己的实际经验以及对Spring Cloud的深入调研，并结合国内一线互联网大厂的开源项目应用实践结果，认为Spring Cloud技术栈中的有些组件离生产级开发尚有一定距离，最后提出了一个可供中小团队参考的微服务架构技术栈，又被称为“中国特色的微服务架构技术栈1.0”：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180823122622168-180774166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图中涉及到的组件，这里不做具体介绍，有兴趣的童鞋可以浏览波波老师的这篇文章：《&lt;a href=&quot;http://www.infoq.com/cn/articles/china-microservice-technique?utm_source=tuicool&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;一个可供中小团队参考的微服务架构技术栈&lt;/a&gt;》。&lt;/p&gt;
&lt;h2&gt;2.2 Spring Cloud核心子项目&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Spring Cloud Netflix：核心组件，可以对多个Netflix OSS开源套件进行整合，包括以下几个组件：
&lt;ul&gt;&lt;li&gt;Eureka：服务治理组件，包含服务注册与发现&lt;/li&gt;
&lt;li&gt;Hystrix：容错管理组件，实现了熔断器&lt;/li&gt;
&lt;li&gt;Ribbon：客户端负载均衡的服务调用组件&lt;/li&gt;
&lt;li&gt;Feign：基于Ribbon和Hystrix的声明式服务调用组件&lt;/li&gt;
&lt;li&gt;Zuul：网关组件，提供智能路由、访问过滤等功能&lt;/li&gt;
&lt;li&gt;Archaius：外部化配置组件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Spring Cloud Config：配置管理工具，实现应用配置的外部化存储，支持客户端配置信息刷新、加密/解密配置内容等。&lt;/li&gt;
&lt;li&gt;Spring Cloud Bus：事件、消息总线，用于传播集群中的状态变化或事件，以及触发后续的处理&lt;/li&gt;
&lt;li&gt;Spring Cloud Security：基于spring security的安全工具包，为我们的应用程序添加安全控制&lt;/li&gt;
&lt;li&gt;Spring Cloud Consul : 封装了Consul操作，Consul是一个服务发现与配置工具（与Eureka作用类似），与Docker容器可以无缝集成&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/em&gt;下面资料都是我们项目组新同事以及老同事（.Net技术背景）所采用的学习资料，&lt;span&gt;&lt;strong&gt;&lt;span&gt;并不保证适合于所有人&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。本示例主要也主要是基于下面的资料而写的sample code。&lt;/p&gt;
&lt;p&gt;　　（1）周立：《&lt;a href=&quot;https://book.douban.com/subject/30278673/&quot; target=&quot;_blank&quot;&gt;Spring Cloud与Docker 微服务架构实战&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180822203658690-695659411.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）程序猿DD：《&lt;a href=&quot;https://book.douban.com/subject/27025912/&quot; target=&quot;_blank&quot;&gt;Spring Cloud 微服务实战&lt;/a&gt;》、《&lt;a href=&quot;http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/&quot; target=&quot;_blank&quot;&gt;Spring Cloud基础教程（Dalston版本）&lt;/a&gt;（&lt;em&gt;强力推荐&lt;/em&gt;）》&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180822203530287-752031402.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）纯洁的微笑，《&lt;a href=&quot;http://www.ityouknow.com/spring-cloud&quot; target=&quot;_blank&quot;&gt;Spring Cloud系列文章&lt;/a&gt;》&lt;/p&gt;

&lt;h2&gt;4.1 示例环境版本&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Java&lt;/strong&gt; : JDK &amp;amp; JRE 1.8 8u151&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Boot&lt;/strong&gt; : 1.5.15.RELEASE&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Cloud&lt;/strong&gt; : Edgware.SR3 （&lt;span&gt;&lt;strong&gt;&lt;em&gt;小贴士&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;：Spring Cloud的版本命名是以伦敦地铁站的名字来命名的）&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;4.2 示例地址与结构说明&lt;/h2&gt;
&lt;p&gt;　　示例地址：&lt;a title=&quot;Sample Address&quot; href=&quot;https://github.com/EdisonChou/EDC.SpringCloud.Samples&quot; target=&quot;_blank&quot;&gt;https://github.com/EdisonChou/EDC.SpringCloud.Samples&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4.2.1 服务注册与发现 - 基于Eureka&lt;/h3&gt;
&lt;p&gt;　　此部分示例位于：&lt;a title=&quot;part 1&quot; href=&quot;https://github.com/EdisonChou/EDC.SpringCloud.Samples/tree/master/src/part1_service-register-discovery&quot; target=&quot;_blank&quot;&gt;part1_service-register-discovery&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　此部分示例主要演示了如何基于Eureka实现服务的注册与发现，其中包括两个版本：&lt;/p&gt;
&lt;p&gt;　　① 单节点版本 （开发环境调试用） =&amp;gt; 位于eureka-service-sn (sn代表single node)项目内&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180827150050804-810811632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里需要注意的地方是：在开发环境需要关闭Eureka的自我保护机制，不然你无法轻易看到服务移除的效果，需要在application.yml中如下设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;eureka:
  server:
    enableSelfPreservation: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt; # 本地调试环境下关闭自我保护机制
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是因为Eureka考虑到生产环境中可能存在的网络分区故障，会导致微服务与Eureka Server之间无法正常通信。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留），也不盲目注销任何健康的微服务。&lt;/p&gt;
&lt;p&gt;　　关于自我保护机制，更多内容可以参考：《&lt;a href=&quot;https://blog.csdn.net/zhxdick/article/details/79153106&quot; target=&quot;_blank&quot;&gt;Spring Cloud Eureka全解之自我保护机制&lt;/a&gt;》　&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180827151103729-1280844661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　② HA多节点版本 （部署/生产环境用） =&amp;gt; 位于eureka-service-ha-1 &amp;amp; eureka-service-ha-2这两个项目内&lt;/p&gt;
&lt;p&gt;　　此版本需要注意的是两个节点的application.yml保持一致，但由于其中使用了peer1和peer2的hostname，在本地开发环境需要给Windows（我假设你使用的是Windows系统）设置hosts文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
  127.0.0.1    peer1 peer2
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6.8264058679707&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;扩展：&lt;/strong&gt;&lt;/em&gt;除了Eureka之外，还可以选择通用型较强的Consul，关于Consul的基本概念与服务端的安装配置可以看看我的这一篇《&lt;a title=&quot;Consul Foundation&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/9124985.html&quot; target=&quot;_blank&quot;&gt;.Net Core微服务之基于Consul实现服务注册于发现&lt;/a&gt;》了解一下。最后，不得不说，Spring Boot 和 Spring Cloud中核心组件封装的注解真的是太强大了，很多操作一个注解直接搞定，无须过多的coding。　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;4.2.2 客户端负载均衡 - 基于Ribbon&lt;/h3&gt;
&lt;p&gt;　　此部分示例位于：&lt;a title=&quot;part 2&quot; href=&quot;https://github.com/EdisonChou/EDC.SpringCloud.Samples/tree/master/src/part2_client-load-balance&quot; target=&quot;_blank&quot;&gt;part2_client-load-balance&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　此部分示例主要演示了如何基于Ribbon实现客户端的负载均衡，建议启动方式：先启动Eureka，再启动UserService和MovieService。通过访问MovieService的API接口 /log-instance 进行日志查看，测试结果如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180828100514390-46002450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上图可以看出，通过客户端的负载均衡算法，依次访问了不同的服务节点。&lt;/p&gt;
&lt;h3&gt;4.2.3 声明式REST调用 - 基于Feign&lt;/h3&gt;
&lt;p&gt;　　此部分示例位于：&lt;a title=&quot;part 3&quot; href=&quot;https://github.com/EdisonChou/EDC.SpringCloud.Samples/tree/master/src/part3_feign&quot; target=&quot;_blank&quot;&gt;part3_feign&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180828143813878-505173877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此部分示例主要演示了基于Feign如何实现声明式调用，包括以下内容：&lt;/p&gt;
&lt;p&gt;　　（1）基本整合Feign进行单参数与多参数的请求：位于movie-service这个项目内&lt;/p&gt;
&lt;p&gt;　　需要注意的就是别忘了在启动类加上@EnableFeignClients注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableDiscoveryClient
&lt;span&gt;&lt;strong&gt;@EnableFeignClients &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要使用Feign，需要加上此注解&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MovieServiceApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(MovieServiceApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）自定义Feign配置的使用：位于movie-service-feign-customizing这个项目内&lt;/p&gt;
&lt;p&gt;　　下面的Feign接口就使用了自定义的配置类FeignConfiguration。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@FeignClient(name = &quot;user-service&quot;, &lt;span&gt;&lt;strong&gt;configuration&lt;/strong&gt;&lt;/span&gt; = FeignConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserFeignClient {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用feign自带的注解@RequestLine
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt; &lt;span&gt;https://github.com/OpenFeign/feign&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id 用户id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 用户信息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestLine(&lt;/span&gt;&quot;GET /{id}&quot;&lt;span&gt;)
    User findById(@Param(&lt;/span&gt;&quot;id&quot;&lt;span&gt;) Long id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）Feign的日志的使用：位于movie-service-feign-logging这个项目内&lt;/p&gt;
&lt;p&gt;　　需要注意的是：Feign虽然提供了logger，但是其日志打印只会对DEBUG级别做出响应。日志级别一共有4种类型，如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Logger.Level 可选值：&lt;br/&gt;* NONE: 不记录任何日志（默认值）&lt;br/&gt;* BASIC: 仅记录请求方法、URL、响应状态码以及执行时间&lt;br/&gt;* HEADERS: 记录BASIC级别的基础之上，记录请求和响应的header&lt;br/&gt;* FULL: 记录请求和响应的header，body和元数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　要输出日志打印，application.yml内要设置DEBUG级别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;logging:
  level:
    # 将Feign接口的日志级别设置为DEBUG，因为Feign的Logger.Level只针对DEBUG做出响应
    com.mbps.cd.movieservice.feign.UserFeignClient: DEBUG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后，针对FULL级别的日志打印效果如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180828145412951-1521816745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.2.4 容错处理 - 基于Hystrix&lt;/h3&gt;
&lt;p&gt;　　此部分示例位于：&lt;a title=&quot;part 4&quot; href=&quot;https://github.com/EdisonChou/EDC.SpringCloud.Samples/tree/master/src/part4_hystrix&quot; target=&quot;_blank&quot;&gt;part4_hystrix&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　此部分示例主要演示如何基于Hystrix实现容错处理，主要包括以下内容：&lt;/p&gt;
&lt;p&gt;　　（1）通用方式整合Hystrix：此示例位于movie-service项目中&lt;/p&gt;
&lt;p&gt;　　针对普通的方法，只需加上HystrixCommand注解及定义回退方法即可，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @HystrixCommand(fallbackMethod = &quot;findByIdFallback&quot;&lt;span&gt;)
    @GetMapping(value &lt;/span&gt;= &quot;/user/{id}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User findById(@PathVariable Long id) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; restTemplate.getForObject(&quot;http://user-service/&quot; + id, User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User findByIdFallback(Long id){
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setId(&lt;/span&gt;-1L&lt;span&gt;);
        user.setUsername(&lt;/span&gt;&quot;Default User&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）Feign使用Hystrix：此示例位于movie-service-feign-hystrix项目中&lt;/p&gt;
&lt;p&gt;　　针对Feign，它是以接口形式工作的，好在Spring Cloud已默认为Feign整合了Hystrix，不过默认是关闭的，需要手动在配置文件中开启：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;feign:
  hystrix:
    enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在之前的版本（Dalston之前的版本）中是默认开启的，至于为何要改为默认禁用，可以看看这里：&lt;a title=&quot;reference&quot; href=&quot;https://github.com/spring-cloud/spring-cloud-netflix/issues/1277&quot; target=&quot;_blank&quot;&gt;https://github.com/spring-cloud/spring-cloud-netflix/issues/1277&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　然后直接在FeignClient注解中加入fallback属性即可，例如下面所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@FeignClient(name = &quot;user-service&quot;, fallback = FeignClientFallback.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserFeignClient {
    @GetMapping(value &lt;/span&gt;= &quot;/{id}&quot;&lt;span&gt;)
    User findById(@PathVariable(&lt;/span&gt;&quot;id&quot;&lt;span&gt;) Long id);
}

@Component
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; FeignClientFallback &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserFeignClient{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User findById(Long id) {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setId(&lt;/span&gt;-1L&lt;span&gt;);
        user.setUsername(&lt;/span&gt;&quot;Default User&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果想要在Feign发生回退时能够留下日志供查看回退原因，那么可以使用FallbackFactory，示例项目：movie-service-feign-fallback-factory.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5437f300-2255-4ce0-895e-9cf0f3ae3c53')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_5437f300-2255-4ce0-895e-9cf0f3ae3c53&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5437f300-2255-4ce0-895e-9cf0f3ae3c53&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5437f300-2255-4ce0-895e-9cf0f3ae3c53',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5437f300-2255-4ce0-895e-9cf0f3ae3c53&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
@FeignClient(name = &quot;user-service&quot;, fallbackFactory = FeignClientFallbackFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserFeignClient {
    @GetMapping(value &lt;/span&gt;= &quot;/{id}&quot;&lt;span&gt;)
    User findById(@PathVariable(&lt;/span&gt;&quot;id&quot;&lt;span&gt;) Long id);
}

@Component
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; FeignClientFallbackFactory &lt;span&gt;implements&lt;/span&gt; FallbackFactory&amp;lt;UserFeignClient&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER =&lt;span&gt;
            LoggerFactory.getLogger(FeignClientFallbackFactory.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserFeignClient create(Throwable cause) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserFeignClient() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User findById(Long id) {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 * 日志最好放在各个fallback中，而不要直接放在create方法中
                 * 否则在引用启动时，就会打印该日志
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                FeignClientFallbackFactory.LOGGER.info(&lt;/span&gt;&quot;sorry, fallback. reason was: &quot;&lt;span&gt;, cause);
                User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
                user.setId(&lt;/span&gt;-1L&lt;span&gt;);
                user.setUsername(&lt;/span&gt;&quot;Default Username&quot;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
            }
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　当发生回退时，日志输出信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180829105743871-715284667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　除此之外，关于Hystrix部分，还有监控的主题，这里由于我所在的项目组的技术架构中不会涉及到，也就没有弄，有兴趣的童鞋可以关注一下Hystrix自带的监控以及基于Turbine的聚合监控。参考文章：《&lt;a href=&quot;http://blog.didispace.com/spring-cloud-starter-dalston-5-1/&quot; target=&quot;_blank&quot;&gt;Hystrix监控面板（Dalston版）&lt;/a&gt;》与《&lt;a href=&quot;http://blog.didispace.com/spring-cloud-starter-dalston-5-2/&quot; target=&quot;_blank&quot;&gt;Hystrix监控数据聚合&lt;/a&gt;》。&lt;/p&gt;
&lt;h3&gt;4.2.5 API网关 - 基于Zuul&lt;/h3&gt;
&lt;p&gt;　　此部分示例位于：&lt;a title=&quot;part 5&quot; href=&quot;https://github.com/EdisonChou/EDC.SpringCloud.Samples/tree/master/src/part5_zuul&quot; target=&quot;_blank&quot;&gt;part5_zuul&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　此部分示例主要演示如何基于Zuul实现API网关，主要包括以下内容：&lt;/p&gt;
&lt;p&gt;　　（1）整合Zuul编写API网关：位于zuul-service项目中&lt;/p&gt;
&lt;p&gt;　　可以测试验证的内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;路由规则：依次启动eureka，user-service，movie-service，zuul-service，然后通过zuul访问user-service接口&lt;/li&gt;
&lt;li&gt;负载均衡：依次启动eureka，多个user-service，zuul-service，然后多次访问user-service，最后查看日志信息（两个user-service都会打印hibernate日志信息），验证是否达到负载均衡的效果。&lt;strong&gt;&lt;em&gt;PS&lt;/em&gt;&lt;/strong&gt;：Zuul内置了Ribbon来实现负载均衡。　　&lt;/li&gt;
&lt;li&gt;路由端点：依次启动eureka，user-service，movie-service，zuul-service，然后浏览器访问zuul-service（http://localhost:5000/routes）可以得到路由端点信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　对于路由端点，需要改一下以下配置，才能正常显示路由端点信息，否则会报401的错误：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;management:
  security:
    enabled: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt; # 默认为true，改为false以便可以看到routes
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;路由配置：示例主要演示了路由前缀、全局敏感设置以及路由规则设置&lt;/li&gt;
&lt;li&gt;大文件上传设置：针对超大文件上传（比如500M），需要在Zuul中提升超时设置&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('dd411ad6-4332-43c6-8c47-b5d7e2a5facb')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_dd411ad6-4332-43c6-8c47-b5d7e2a5facb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dd411ad6-4332-43c6-8c47-b5d7e2a5facb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('dd411ad6-4332-43c6-8c47-b5d7e2a5facb',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dd411ad6-4332-43c6-8c47-b5d7e2a5facb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 下面的设置针对超大文件上传（比如500M），提升了超时设置
hystrix:
  command:
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      execution:
        isolation:
          thread:
            timeoutInMillseconds: &lt;/span&gt;60000&lt;span&gt;

ribbon:
  ConnectionTimeout: &lt;/span&gt;3000&lt;span&gt;
  ReadTimeout: &lt;/span&gt;60000
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　（2）Zuul的过滤器：主要位于zuul-service-filter这个项目中&lt;/p&gt;
&lt;p&gt;　　对于Zuul的请求声明周期来说，一共有4种标准过滤器类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PRE：在请求被路由之前调用，可利用这种过滤器实现身份验证、记录调试信息等操作；&lt;/li&gt;
&lt;li&gt;ROUTING：将请求路由到微服务，可利用这种过滤器用于构建发送给微服务的请求；&lt;/li&gt;
&lt;li&gt;POST：在路由到微服务以后执行，可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等；&lt;/li&gt;
&lt;li&gt;ERROR：在其他阶段发生错误时执行该过滤器；　　&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180829194447438-1935637453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此示例中演示了PRE类型的过滤器，部分场景下，想要禁用部分过滤器，只需要在配置文件中设置即可，例如这里禁用PreRequestLogFilter过滤器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7f7056b0-e9b2-4309-9b42-b0fd60c003a1')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_7f7056b0-e9b2-4309-9b42-b0fd60c003a1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7f7056b0-e9b2-4309-9b42-b0fd60c003a1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7f7056b0-e9b2-4309-9b42-b0fd60c003a1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7f7056b0-e9b2-4309-9b42-b0fd60c003a1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;zuul:
  # 禁用指定过滤器设置
  PreRequestLogFilter:
    pre:
      disable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; # 禁用我们创建的PreRequestLogFilter过滤器
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　（3）Zuul的容错与回退：主要位于zuul-service-fallback这个项目中&lt;/p&gt;
&lt;p&gt;　　Zuul自身就带有Hystrix，但是&lt;strong&gt;&lt;em&gt;它监控的粒度是微服务级别，而不是某个API&lt;/em&gt;&lt;/strong&gt;，当某个API不可用时，会统一抛500错误码的异常页。我们可以为Zuul添加回退，以实现更友好的返回信息。实现也很简单，只需要实现FallbackProvider接口即可。这里要注意的是，对于Edgware之前的版本（即Dalston及更低版本）需要实现的是ZuulFallbackProvider接口，而Edgware及之后的版本要实现的是FallbackProvider接口。因为FallbackProvider是ZuulFallbackProvider的子接口，而它的好处就是多了一个接口可以获取可能造成回退的原因，具体可以参考这一篇文章：《&lt;a href=&quot;https://www.jianshu.com/p/632f26892c44&quot; target=&quot;_blank&quot;&gt;Spring Cloud Edgware新特性之八：Zuul回退的改进&lt;/a&gt;》。下面是本示例中访问user-service接口（user-service被我手动关闭）后的返回结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180829203408560-1338574330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）Zuul的高可用架构&lt;/p&gt;
&lt;p&gt;　　生产环境中一般都需要部署高可用的Zuul以避免单点故障，实际开发中有两种情况：&lt;/p&gt;
&lt;p&gt;　　① Zuul的客户端也注册到了Eureka Server上（比如：MVC App, SPA 等）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://www.itmuch.com/images/spring-cloud/8-7.png&quot; alt=&quot;&quot; width=&quot;1033&quot; height=&quot;686&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此时Zuul的高可用和其他微服务没区别，都是借助Eureka和Ribbon来实现负载均衡。&lt;/p&gt;
&lt;p&gt;　　② Zuul的客户端未注册到Eureka Server上（比如手机App端等）&lt;/p&gt;
&lt;p&gt;　　现实中这种场景或许更常见，此时需要借助一个额外的负载均衡器来实现Zuul的高可用，比如：Nginx、HAProxy以及F5等。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://www.itmuch.com/images/spring-cloud/8-8.png&quot; alt=&quot;&quot; width=&quot;1094&quot; height=&quot;782&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更多Zuul高可用的内容，可以浏览周立老师的这一篇：《&lt;a href=&quot;http://www.itmuch.com/spring-cloud/zuul/zuul-ha/&quot; target=&quot;_blank&quot;&gt;Zuul的高可用&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;　　（5）使用Zuul聚合微服务：此示例位于zuul-service-aggregation项目中&lt;/p&gt;
&lt;p&gt;　　许多场景下可能一个外部请求要查询Zuul后端的多个服务，这时可以使用Zuul来聚合服务请求，即只需请求一次，由Zuul来请求各个服务，然后组织好数据发送给客户端（比如App客户端）。示例中主要基于RxJava与Zuul来结合实现的微服务请求的聚合。&lt;/p&gt;
&lt;h3&gt;4.2.6 统一配置管理 - 基于Spring Cloud Config&lt;/h3&gt;
&lt;p&gt;　　Spring Cloud Config为分布式系统外部化配置提供了服务端和客户端的支持，包括Config Server和Config Client两部分，其架构图如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180911102332162-368646690.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中，各个微服务在启动时会请求Config Server以获取所需要的配置属性，然后缓存这些属性以提高性能，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180911102459754-1863677573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此部分示例位于：&lt;a title=&quot;part 6&quot; href=&quot;https://github.com/EdisonChou/EDC.SpringCloud.Samples/tree/master/src/part6_config&quot; target=&quot;_blank&quot;&gt;part6_config&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　此部分示例主要演示如何基于Spring Cloud Config实现统一配置中心，主要包括以下内容：&lt;/p&gt;
&lt;p&gt;　　（1）基本的Config Server与Config Client编写：此示例位于config-service与config-client中&lt;/p&gt;
&lt;p&gt;　　此示例需要用到一些已放到git的配置文件，这里我已将其放到了github方便大家可以直接拿来测试用，仓库地址为：&lt;a title=&quot;github&quot; href=&quot;https://github.com/EdisonChou/EDC.SpringCloud.Samples.Config&quot; target=&quot;_blank&quot;&gt;https://github.com/EdisonChou/EDC.SpringCloud.Samples.Config&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;22&quot;&gt;
&lt;p&gt;端点与配置文件的&lt;strong&gt;&lt;em&gt;映射规则&lt;/em&gt;&lt;/strong&gt;如下：&lt;/p&gt;
&lt;p&gt;/{application}/{profile}[/{label}]&lt;/p&gt;
&lt;p&gt;/{application}-{profile}.yml&lt;/p&gt;
&lt;p&gt;/{label}/{application}-{profile}.yml&lt;/p&gt;
&lt;p&gt;/{application}-{profile}.properties&lt;/p&gt;
&lt;p&gt;/{label}/{application}-{profile}.properties&lt;/p&gt;
&lt;p&gt;其中，application: 表示微服务的虚拟主机名，即配置的spring.application.name&lt;/p&gt;
&lt;p&gt;profile: 表示当前的环境，dev, test or production?&lt;/p&gt;
&lt;p&gt;label: 表示git仓库分支，master or relase or others repository name? 默认是master&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　项目中，config-service的配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1e66354b-ec66-4927-a85b-d597f3497639')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_1e66354b-ec66-4927-a85b-d597f3497639&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1e66354b-ec66-4927-a85b-d597f3497639&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1e66354b-ec66-4927-a85b-d597f3497639',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1e66354b-ec66-4927-a85b-d597f3497639&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;8080&lt;span&gt;

spring:
  application:
    name: sampleservice&lt;/span&gt;-config-&lt;span&gt;server
  cloud:
    config:
      server:
        git:
          # 配置Git仓库地址
          uri: https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/EdisonChou/EDC.SpringCloud.Samples.Config&lt;/span&gt;
&lt;span&gt;          # Git仓库账号（如果需要认证）
          username:
          # Git仓库密码（如果需要认证）
          password:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　启动顺序：先启动config-server，再启动config-client，因为config-client在启动时就回去config-server获取配置，如果这时config-server未启动则会报错。&lt;/p&gt;
&lt;p&gt;　　这里需要注意的就是在config-client中，对于spring cloud config的配置应该放在bootstrap.yml中而不是application.yml中，否则会不起作用。这里涉及到一个spring cloud的“引导上下文”的概念，可以参考这篇《&lt;a href=&quot;https://www.cnblogs.com/niechen/p/8968204.html&quot; target=&quot;_blank&quot;&gt;深入理解Spring Cloud引导上下文&lt;/a&gt;》来了解一下。&lt;/p&gt;
&lt;p&gt;　　（2）使用/refresh端点手动刷新配置：仍然位于config-client项目中&lt;/p&gt;
&lt;p&gt;　　要想在运行期间刷新配置，需要两点改造：加上@RefreshScope注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
@RefreshScope &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @RefreshScope注解不能少，否则即使调用/refresh，配置也不会刷新&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigClientController {
    @Value(&lt;/span&gt;&quot;${profile}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String profile;

    @GetMapping(&lt;/span&gt;&quot;/profile&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.profile;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此外，针对Spring Boot 1.5.x，还需要给config-client端关闭安全认证，否则无法正常refresh：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;management:
  security:
    enabled: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　之后，就可以通过对config-client发起POST请求刷新配置了：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180911110239157-395567823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不过，如果所有微服务都需要手动刷新配置，工作量会很大。所以，在实际环境中，一般会实现配置的自动刷新。&lt;/p&gt;
&lt;p&gt;　　（3）使用Spring Cloud Bus自动刷新配置：此示例位于config-server-cloud-bus与config-client-cloud-bus项目中&lt;/p&gt;
&lt;p&gt;　　此示例使用到的架构如下图所示，它将Config Server加入消息总线之中，并使用Config Server的/bus/refersh端点来实现配置的刷新。这样，各个微服务只需要关注自身的业务逻辑，而无需再自己手动刷新配置。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180911164253270-1574652079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Tip：&lt;/strong&gt;&lt;/em&gt;Spring Cloud Bus基于轻量级地消息代理（例如RabbitMQ、Kafka等）连接分布式系统的节点，就可以通过广播的方式来传播状态的更改（例如配置的更新）或者其他的管理指令。我们可以将Spring Cloud Bus想象成一个分布式的Spring Boot Actuator。　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　运行顺序：先启动config-service-cloud-bus，再启动两个config-client-cloud-bus（第一个默认端口8081，第二个端口改为8082），修改github中sampleservice-foo-dev.properties中的profile值后commit &amp;amp; push，然后POST请求config-service-cloud-bus的/bus/refersh端点，最后再次访问两个client的/profile端点进行验证。&lt;/p&gt;
&lt;p&gt;　　如果部分场景想要知道Spring Cloud Bus事件传播的细节，可以通过以下设置来跟踪事件总线：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  cloud:
    bus:
      trace:
        enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; # 开启cloud bus跟踪
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（4）与Eureka的配合使用：此示例位于config-service-eureka与config-client-eureka两个项目中&lt;/p&gt;
&lt;p&gt;　　（5）Config Server的高可用：涉及到Git仓库的高可用、RabbitMQ的高可用以及Config Server自身的高可用。&lt;/p&gt;
&lt;p&gt;　　对于Git仓库的高可用，第三方Git仓库类似于GitHub等本身已经实现了高可用，而针对自建Git仓库如GitLab，可以参考GitLab官方文档搭建高可用：&lt;a title=&quot;GitLab的高可用&quot; href=&quot;https://about.gitlab.com/high-availability/&quot; target=&quot;_blank&quot;&gt;https://about.gitlab.com/high-availability/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　对于Config Server自身的高可用，也可以分为未注册到Eureka和注册到Eureka两种情形，具体可以参考Zuul的高可用的架构图。&lt;/p&gt;
&lt;p&gt;　　此外，对于配置内容的加密，此示例没有涉及，它依赖于&lt;em&gt;JCE&lt;/em&gt;（&lt;em&gt;Java Cryptography Extension&lt;/em&gt;），可以参考这一篇《&lt;a href=&quot;https://blog.csdn.net/u014792352/article/details/73163714&quot; target=&quot;_blank&quot;&gt;Spring Cloud配置文件加密&lt;/a&gt;》了解一下。&lt;/p&gt;
&lt;blockquote readability=&quot;5.1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;扩展：&lt;/em&gt;&lt;/strong&gt;关于统一配置中心，还可以选择更好用的Apollo（携程的开源项目），可以看看我的这一篇《&lt;a title=&quot;Apollo Introduction&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/netcore_microservice_apollo_foundation.html&quot; target=&quot;_blank&quot;&gt;.Net Core微服务之基于Apollo实现统一配置中心&lt;/a&gt;》了解一下。　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;4.2.7 微服务跟踪 - 基于Spring Cloud Sleuth&lt;/h3&gt;
&lt;p&gt;　　首先，值得一提的是Spring Cloud Sleuth大量借用了Google Dapper，Twitter Zipkin和Apache HTrace的设计，我们得了解一些术语，例如：span、trace、annotation等，详细可以参考这篇《&lt;a href=&quot;https://blog.csdn.net/hry2015/article/details/78905489&quot; target=&quot;_blank&quot;&gt;Spring Cloud系列之分布式链路监控Spring Cloud Sleuth&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;　　此示例位于：&lt;a href=&quot;https://github.com/EdisonChou/EDC.SpringCloud.Samples/tree/master/src/part7_sleuth&quot; target=&quot;_blank&quot;&gt;part7_sleuth&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　此部分示例主要演示如何基于Spring Cloud Sleuth实现分布式链路监控，主要包括以下内容：&lt;/p&gt;
&lt;p&gt;　　（1）基础整合Spring Cloud Sleuth：位于user-service-trace与movie-service-trace项目中，主要查看控制台输出日志&lt;/p&gt;
&lt;p&gt;　　（2）Spring Cloud Sleuth与Zipkin的配合使用：位于zipkin-service-server、user-service-trace-zipkin与movie-service-trace-zipkin三个项目中&lt;/p&gt;
&lt;p&gt;　　Zipkin是Twitter开源的分布式跟踪系统，基于Dapper论文设计而来，主要功能是收集系统的时序数据，从而追踪微服务架构的系统延时问题，此外还提供了一个非常友好的界面来帮助追踪分析数据。&lt;/p&gt;
&lt;p&gt;　　下图是一个接入Zipkin之后的服务调用简易流程图：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180912100436938-1105881734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　运行顺序：首先运行zipkin-service-server，其次运行user-service-zipkin与movie-service-zipkin，然后访问http://localhost:8010/user/1得到数据结果，最后访问zipkin server首页，填入起始时间、结束时间等筛选条件后，点击Find a trace按钮，可以看到trace列表，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180912124929461-1130110818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击“依赖分析”，可以得到下图，有助于我们分析依赖关系：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201809/381412-20180912124826365-256580926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　需要注意的是，在开发调试时，因为默认的采样百分比是10%，Sleuth会忽略大量span，因此我们可以在开发环境将其设置为100%：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  sleuth:
    sampler:
      # 指定需采样的请求的百分比，默认是0.&lt;/span&gt;1（即10%），这里方便查看设为100%&lt;span&gt;（实际环境不要这样设置）
      percentage: &lt;/span&gt;1.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）使用RabbitMQ收集数据：此示例位于zipkin-service-server-stream与user-service-trace-zipkin-stream两个项目中&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/668104/201709/668104-20170919144417181-47072786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此外，Spring Cloud Sleuth还可以与ELK配合使用，不过此示例没有涉及，感兴趣的朋友可以参考这一篇《&lt;a href=&quot;https://blog.csdn.net/yejingtao703/article/details/78318234&quot; target=&quot;_blank&quot;&gt;Spring Cloud Sleuth与ELK集成&lt;/a&gt;》。当然，示例中的跟踪数据都是存放到内存中，但是跟踪数据还是建议存放到ElasticSearch中，生产环境切莫只存储到内存中。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180808003740095-518556064.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　IDE =&amp;gt; &lt;a href=&quot;https://www.jetbrains.com/idea/&quot; target=&quot;_blank&quot;&gt;Intellij Idea Community 2018&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　(&lt;em&gt;&lt;strong&gt;PS:&lt;/strong&gt;&lt;/em&gt; 如果是.Net程序猿背景，强烈建议更改快捷键与Visual Studio保持一致，这样能加快开发效率，如不了解如何修改，可以参考邹琼俊《&lt;a href=&quot;https://www.cnblogs.com/jiekzou/p/9202247.html&quot; target=&quot;_blank&quot;&gt;从.Net到Java - Idea and Start Spring Boot&lt;/a&gt;》)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180823162644740-346644119.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Plugin =&amp;gt; 阿里巴巴代码规约&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 12 Sep 2018 13:33:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>本文示例基于Spring Boot 1.5.x实现，如对Spring Boot不熟悉，可以先学习我的这一篇：《Spring Boot 1.5.x 基础学习示例》。关于微服务基本概念不了解的童鞋，可以先</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/java_spring_cloud_foundation_sample_list.html</dc:identifier>
</item>
<item>
<title>NetCore实践篇：分布式监控客户端ZipkinTracer从入门到放弃之路 - 从此启程</title>
<link>http://www.cnblogs.com/fancunwei/p/9637247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9637247.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;/&gt;&lt;title&gt;NetCore实践篇：分布式监控客户端ZipkinTracer从入门到放弃之路 - 从此启程 - 博客园&lt;/title&gt;&lt;meta property=&quot;og:description&quot; content=&quot;前言 本文紧接上篇.Net架构篇:思考如何设计一款实用的分布式监控系统？,上篇仅仅是个思考篇，跟本文没有太大的关系。但有思考，结合现有的开源组件，实践起来更易理解起来，所以看本文之前，应该先看下上篇博&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=giTNza-Of-PEt5UsELhFQAR7G6-bfaSa4oolcq7i9-o1&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/CodingLife/bundle-CodingLife.css?v=g4Oce5UBaUn_FUwadcT09ICEg5NkULQGtUpNhTtrI8U1&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/blog/customcss/156695.css?v=r%2bEfLPLHmVY1QN6D5bgXkjUt32Y%3d&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/CodingLife/bundle-CodingLife-mobile.css?v=Xay8b9tTSw814nBzbOgvS6rrbcxrobMhvHJHdZAO9vI1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;https://www.cnblogs.com/fancunwei/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;https://www.cnblogs.com/fancunwei/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;https://www.cnblogs.com/fancunwei/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot; readability=&quot;168.30987762238&quot;&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/fancunwei&quot; target=&quot;_blank&quot;&gt;　　&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/fancunwei/1299318/o_o_github.png&quot; alt=&quot;Go to my github&quot;/&gt;&lt;/a&gt;  &lt;/p&gt;
&lt;div id=&quot;home&quot; readability=&quot;16.153543307087&quot;&gt;

&lt;div id=&quot;main&quot; readability=&quot;46.478458592628&quot;&gt;
&lt;div id=&quot;mainContent&quot; readability=&quot;31.898251192369&quot;&gt;
&lt;div class=&quot;forFlow&quot; readability=&quot;6.0309079201545&quot;&gt;
&lt;div id=&quot;post_detail&quot; readability=&quot;30.543831168831&quot;&gt;
&lt;div id=&quot;topics&quot; readability=&quot;4.8993174061433&quot;&gt;
&lt;div class=&quot;post&quot; readability=&quot;25.776556776557&quot;&gt;


&lt;div class=&quot;postBody&quot; readability=&quot;30.7265625&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;60.461081081081&quot;&gt;

&lt;h3 data-source-line=&quot;4&quot; id=&quot;zipkin简介&quot;&gt;Zipkin简介&lt;/h3&gt;

&lt;p data-source-line=&quot;5&quot;&gt;&lt;img data-src=&quot;https%3A%2F%2Fzipkin.io%2Fpublic%2Fimg%2Fzipkin-logo-200x119.jpg&quot; alt=&quot;zipkin&quot; src=&quot;https://zipkin.io/public/img/zipkin-logo-200x119.jpg?ynotemdtimestamp=1536756224976&quot; data-processed=&quot;https%3A%2F%2Fzipkin.io%2Fpublic%2Fimg%2Fzipkin-logo-200x119.jpg&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;8&quot;&gt;Zipkin是一种分布式跟踪系统。它有助于收集解决微服务架构中的延迟问题所需的时序数据。它管理这些数据的收集和查找。Zipkin的设计基于&lt;a href=&quot;http://research.google.com/pubs/pub36356.html&quot; target=&quot;_blank&quot;&gt;Google Dapper&lt;/a&gt; 论文。&lt;/p&gt;
&lt;p data-source-line=&quot;10&quot;&gt;应用程序用于向Zipkin报告时序数据。Zipkin UI还提供了一个依赖关系图，显示了每个应用程序通过的跟踪请求数。如果要解决延迟问题或错误，可以根据应用程序，跟踪长度，注释或时间戳对所有跟踪进行筛选或排序。选择跟踪后，您可以看到每个跨度所需的总跟踪时间百分比，从而可以识别有问题的应用程序。&lt;/p&gt;
&lt;p data-source-line=&quot;12&quot;&gt;&lt;img data-src=&quot;https%3A%2F%2Fzipkin.io%2Fpublic%2Fimg%2Fweb-screenshot.png&quot; alt=&quot;zipkin演示&quot; src=&quot;https://zipkin.io/public/img/web-screenshot.png?ynotemdtimestamp=1536756224976&quot; data-processed=&quot;https%3A%2F%2Fzipkin.io%2Fpublic%2Fimg%2Fweb-screenshot.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3 data-source-line=&quot;14&quot; id=&quot;快速开始&quot;&gt;快速开始&lt;/h3&gt;

&lt;p data-source-line=&quot;16&quot;&gt;&lt;a href=&quot;https://zipkin.io/pages/quickstart&quot; target=&quot;_blank&quot;&gt;启动的三种方式&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4 data-source-line=&quot;18&quot; id=&quot;docker&quot;&gt;Docker&lt;/h4&gt;

&lt;blockquote data-source-line=&quot;19&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;docker run -d -p 9411:9411 openzipkin/zipkin&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h4 data-source-line=&quot;20&quot; id=&quot;java&quot;&gt;Java&lt;/h4&gt;

&lt;blockquote data-source-line=&quot;21&quot; readability=&quot;2.0754716981132&quot;&gt;
&lt;p&gt;curl -sSL &lt;a href=&quot;https://zipkin.io/quickstart.sh&quot; target=&quot;_blank&quot;&gt;https://zipkin.io/quickstart.sh&lt;/a&gt; | bash -s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;23&quot;&gt;
&lt;p&gt;java -jar zipkin.jar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h4 data-source-line=&quot;25&quot; id=&quot;源码启动&quot;&gt;源码启动&lt;/h4&gt;

&lt;pre data-source-line=&quot;26&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;# get the latest source
git clone https://github.com/openzipkin/zipkin
cd zipkin
# Build the server and also make its dependencies
./mvnw -DskipTests --also-make -pl zipkin-server clean install
# Run the server
java -jar ./zipkin-server/target/zipkin-server-*exec.jar
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote data-source-line=&quot;36&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;无论您以何种方式启动zikpin,请访问 http://your_host:9411以查询跟踪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h4 data-source-line=&quot;38&quot; id=&quot;启动效果&quot;&gt;启动效果&lt;/h4&gt;

&lt;p data-source-line=&quot;40&quot;&gt;&lt;img data-src=&quot;https%3A%2F%2Fnote.youdao.com%2Fyws%2Fpublic%2Fresource%2F1d2b37a48cba11c0ef16eccccfbdaaa2%2Fxmlnote%2F858DA8221E3446FCAF6506454C326CCF%2F23888&quot; alt=&quot;启动后效果&quot; src=&quot;https://note.youdao.com/yws/public/resource/1d2b37a48cba11c0ef16eccccfbdaaa2/xmlnote/858DA8221E3446FCAF6506454C326CCF/23888?ynotemdtimestamp=1536756224976&quot; data-processed=&quot;https%3A%2F%2Fnote.youdao.com%2Fyws%2Fpublic%2Fresource%2F1d2b37a48cba11c0ef16eccccfbdaaa2%2Fxmlnote%2F858DA8221E3446FCAF6506454C326CCF%2F23888&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3 data-source-line=&quot;42&quot; id=&quot;架构&quot;&gt;架构&lt;/h3&gt;
&lt;h4 data-source-line=&quot;44&quot; id=&quot;架构简述&quot;&gt;架构简述&lt;/h4&gt;

&lt;p data-source-line=&quot;45&quot;&gt;应用程序中的监控器记录有关发生的操作的时间和元数据，并且对用户是透明的。如一个web监听服务记录了请求什么时候进来，什么时候离开。这个监控的数据叫做Span。&lt;/p&gt;
&lt;p data-source-line=&quot;47&quot;&gt;将数据发送到Zipkin的检测应用程序中的组件称为Reporter。&lt;/p&gt;
&lt;p data-source-line=&quot;49&quot;&gt;如图所示 &lt;img data-src=&quot;https%3A%2F%2Fzipkin.io%2Fpublic%2Fimg%2Farchitecture-1.png&quot; alt=&quot;&quot; src=&quot;https://zipkin.io/public/img/architecture-1.png?ynotemdtimestamp=1536756224976&quot; data-processed=&quot;https%3A%2F%2Fzipkin.io%2Fpublic%2Fimg%2Farchitecture-1.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4 data-source-line=&quot;52&quot; id=&quot;示例流程&quot;&gt;示例流程&lt;/h4&gt;

&lt;p data-source-line=&quot;53&quot;&gt;这是一个示例序列的http跟踪，其中用户代码调用资源/ foo。这个结果是单个Span，在用户代码收到http响应后异步发送到Zipkin。&lt;/p&gt;
&lt;pre data-source-line=&quot;55&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;zh-hans&quot;&gt;┌─────────────┐&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;┌───────────────────────┐&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;┌─────────────┐&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;┌──────────────────┐&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; User Code &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; Trace Instrumentation &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; Http Client &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; Zipkin Collector &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;└─────────────┘&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;└───────────────────────┘&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;└─────────────┘&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;└──────────────────┘&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;┌─────────┐&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;──┤&lt;/span&gt;GET /foo &lt;span class=&quot;zh-hans&quot;&gt;├─▶&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;────┐&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;└─────────┘&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; record tags
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;◀───┘&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;────┐&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt; trace headers &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;◀───┘&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;────┐&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; record timestamp
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;◀───┘&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;┌─────────────────┐&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;──┤&lt;/span&gt;GET /foo &lt;span class=&quot;zh-hans&quot;&gt;├─▶&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;X-B3-TraceId: aa &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;────┐&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;X-B3-SpanId: &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;b &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;└─────────────────┘&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; invoke
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; request &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;┌────────┐&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;◀───┘&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;◀─────┤&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt; OK &lt;span class=&quot;zh-hans&quot;&gt;├───────&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;────┐&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;└────────┘&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; record duration &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;┌────────┐&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;◀───┘&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;◀──┤&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt; OK &lt;span class=&quot;zh-hans&quot;&gt;├──&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;└────────┘&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;┌────────────────────────────────┐&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;──┤&lt;/span&gt; asynchronously report span &lt;span class=&quot;zh-hans&quot;&gt;├────▶&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;{ &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;traceId&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;aa&quot;&lt;/span&gt;, &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;6b&quot;&lt;/span&gt;, &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;get&quot;&lt;/span&gt;, &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;timestamp&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1483945573944000&lt;/span&gt;,&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;duration&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;386000&lt;/span&gt;, &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;annotations&quot;&lt;/span&gt;: [ &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;--snip-- &lt;span class=&quot;zh-hans&quot;&gt;│&lt;/span&gt;
&lt;span class=&quot;zh-hans&quot;&gt;└────────────────────────────────┘&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;97&quot;&gt;跟踪检测报告以异步方式跨越，以防止与跟踪系统相关的延迟或故障延迟或中断用户代码。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 data-source-line=&quot;98&quot; id=&quot;transport&quot;&gt;Transport。&lt;/h3&gt;

&lt;p data-source-line=&quot;99&quot;&gt;由仪器库发送的span必须从跟踪到Zipkin收集器的服务传输。 主要支持三种传输: HTTP, Kafka 和 Scribe.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 data-source-line=&quot;102&quot; id=&quot;组件&quot;&gt;组件&lt;/h3&gt;

&lt;p data-source-line=&quot;103&quot;&gt;Zipkin有4个组件：&lt;/p&gt;
&lt;ul data-source-line=&quot;105&quot;&gt;&lt;li&gt;收集器（collector）&lt;/li&gt;
&lt;li&gt;存储(storage）&lt;/li&gt;
&lt;li&gt;搜索（search）&lt;/li&gt;
&lt;li&gt;web UI&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-source-line=&quot;109&quot; id=&quot;web-ui&quot;&gt;Web UI&lt;/h3&gt;

&lt;p data-source-line=&quot;110&quot;&gt;我们创建了一个GUI，它为查看跟踪提供了一个很好的界面。Web UI提供了一种基于服务，时间和注释查看跟踪的方法。注意：UI中没有内置身份验证！&lt;/p&gt;
&lt;h3 data-source-line=&quot;113&quot; id=&quot;netcore使用zipkin&quot;&gt;.NetCore使用zipkin&lt;/h3&gt;
&lt;h3 data-source-line=&quot;115&quot; id=&quot;第一款zipkintracer&quot;&gt;第一款ZipkinTracer&lt;/h3&gt;

&lt;p data-source-line=&quot;117&quot;&gt;按照官方文档说明。&lt;/p&gt;
&lt;pre data-source-line=&quot;119&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
using ZipkinTracer.DependencyInjection;
using ZipkinTracer.Owin;
public class Startup
{
public void Configuration(IApplicationBuilder app)
{
app.UseZipkinTracer();
}
public void ConfigureServices(IServiceCollection services)
{
var config = new ZipkinConfig(new Uri(&quot;http://XXX:9411&quot;), request =&amp;gt; new Uri(&quot;https://yourservice.com&quot;))
{
Bypass = request =&amp;gt; request.GetUri().AbsolutePath.StartsWith(&quot;/allowed&quot;),
SpanProcessorBatchSize = 10,
SampleRate = 0.5
}
services.AddZipkinTracer(config);
}
}
//GetUri()&lt;span class=&quot;zh-hans&quot;&gt;方法报错。&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;145&quot;&gt;改成如下方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;146&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt; public void Configuration(IApplicationBuilder app)
{
app.UseZipkinTracer();
}
public void ConfigureServices(IServiceCollection services)
{
var config = new ZipkinConfig(new Uri(&quot;http://weixinhe.cn:9411&quot;));
services.AddZipkinTracer(config);
services.AddZipkinTracer(config);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;158&quot;&gt;客户端调用&lt;/p&gt;
&lt;pre data-source-line=&quot;159&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;using ZipkinTracer.Http;
public class HomeController : Controller
{
private readonly IZipkinTracer _tracer;
public HomeController(IZipkinTracer tracer)
{
_tracer = tracer;
}
public async Task&amp;lt;ActionResult&amp;gt; Index()
{
using (var httpClient = new HttpClient(new ZipkinMessageHandler(_tracer))))
{
var response = await httpClient.GetAsync(&quot;http://www.google.com&quot;);
if (response.IsSuccessStatusCode)
{
var content = await response.Content.ReadAsStringAsync();
}
}
return View();
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;185&quot;&gt;运行程序,报错！ &lt;img data-src=&quot;https%3A%2F%2Fnote.youdao.com%2Fyws%2Fpublic%2Fresource%2F1d2b37a48cba11c0ef16eccccfbdaaa2%2Fxmlnote%2F5B4728A51F5842DEA8BBD3FF7727D050%2F23977&quot; alt=&quot;&quot; src=&quot;https://note.youdao.com/yws/public/resource/1d2b37a48cba11c0ef16eccccfbdaaa2/xmlnote/5B4728A51F5842DEA8BBD3FF7727D050/23977?ynotemdtimestamp=1536756224976&quot; data-processed=&quot;https%3A%2F%2Fnote.youdao.com%2Fyws%2Fpublic%2Fresource%2F1d2b37a48cba11c0ef16eccccfbdaaa2%2Fxmlnote%2F5B4728A51F5842DEA8BBD3FF7727D050%2F23977&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;188&quot;&gt;让我们去官网看看问题,&lt;a href=&quot;https://github.com/sbebrys/ZipkinTracer/issues/10&quot; target=&quot;_blank&quot;&gt;issue&lt;/a&gt; 里面有人提出了这个问题，&lt;/p&gt;
&lt;blockquote data-source-line=&quot;190&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Registering zipkin tracer throws an error #10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;192&quot;&gt;下面有人回复:意思是需要重写中间件。&lt;/p&gt;
&lt;blockquote data-source-line=&quot;194&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;I have the same issue. According to the documentation, the dependencies in the middlewares should be moved into the Invoke method. In this case, the ZipkinMiddleware has to be changed in my opinion.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;196&quot;&gt;年久失修，作者未回复。但是源码都放在那里了，难道任由其报错而无能为力么？这我不能忍受。所以，下载源码，引用源码项目。开启调试之路。&lt;/p&gt;
&lt;h3 data-source-line=&quot;197&quot; id=&quot;解决问题&quot;&gt;解决问题&lt;/h3&gt;

&lt;p data-source-line=&quot;199&quot;&gt;右键查看属性，竟然看不到目标框架。应该是版本太低了。 &lt;img data-src=&quot;https%3A%2F%2Fnote.youdao.com%2Fyws%2Fpublic%2Fresource%2F1d2b37a48cba11c0ef16eccccfbdaaa2%2Fxmlnote%2F752747C5CAC94EE5AB15BF6E532B1A24%2F24002&quot; alt=&quot;&quot; src=&quot;https://note.youdao.com/yws/public/resource/1d2b37a48cba11c0ef16eccccfbdaaa2/xmlnote/752747C5CAC94EE5AB15BF6E532B1A24/24002?ynotemdtimestamp=1536756224976&quot; data-processed=&quot;https%3A%2F%2Fnote.youdao.com%2Fyws%2Fpublic%2Fresource%2F1d2b37a48cba11c0ef16eccccfbdaaa2%2Fxmlnote%2F752747C5CAC94EE5AB15BF6E532B1A24%2F24002&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;202&quot;&gt;查看依赖版本是framework4.6和.netstandard 1.3&lt;/p&gt;
&lt;p data-source-line=&quot;204&quot;&gt;&lt;img data-src=&quot;https%3A%2F%2Fnote.youdao.com%2Fyws%2Fpublic%2Fresource%2F1d2b37a48cba11c0ef16eccccfbdaaa2%2Fxmlnote%2F9AC2DB4005D44CBFAD4EB12CB613C0A6%2F24008&quot; alt=&quot;依赖版本&quot; src=&quot;https://note.youdao.com/yws/public/resource/1d2b37a48cba11c0ef16eccccfbdaaa2/xmlnote/9AC2DB4005D44CBFAD4EB12CB613C0A6/24008?ynotemdtimestamp=1536756224976&quot; data-processed=&quot;https%3A%2F%2Fnote.youdao.com%2Fyws%2Fpublic%2Fresource%2F1d2b37a48cba11c0ef16eccccfbdaaa2%2Fxmlnote%2F9AC2DB4005D44CBFAD4EB12CB613C0A6%2F24008&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;206&quot;&gt;那好办，我们新建一个.netcore2.1版本的项目，然后将tracer的代码都复制过去。 一些复制好并引用后，还是刚才那个错。调试也没有看到哪里报错，只是最终页面报错了。所以我们继续搜索。&lt;/p&gt;
&lt;blockquote data-source-line=&quot;209&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Cannot consume scoped service 'XXXX' from singleton 'XXX'.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 data-source-line=&quot;211&quot; id=&quot;依赖注入的知识普及&quot;&gt;依赖注入的知识普及&lt;/h3&gt;

&lt;p data-source-line=&quot;213&quot;&gt;&lt;a href=&quot;https://dotnetcoretutorials.com/2017/03/25/net-core-dependency-injection-lifetimes-explained/&quot; target=&quot;_blank&quot;&gt;.net核心依赖注入生命周期解释&lt;/a&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;215&quot;&gt;&lt;a href=&quot;https://dotnetcoretutorials.com/2018/03/20/cannot-consume-scoped-service-from-singleton-a-lesson-in-asp-net-core-di-scopes/&quot; target=&quot;_blank&quot;&gt;无法从Singleton消耗Scoped服务 - ASP.net核心DI范围的一课&lt;/a&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;217&quot;&gt;&lt;a href=&quot;https://dotnetcoretutorials.com/2017/03/30/third-party-dependency-injection-asp-net-core/&quot; target=&quot;_blank&quot;&gt;ASP.net核心中的第三方依赖注入&lt;/a&gt;&lt;/p&gt;
&lt;blockquote data-source-line=&quot;219&quot; readability=&quot;3.0714285714286&quot;&gt;
&lt;p&gt;此网站已收集在&lt;a href=&quot;https://www.cnblogs.com/fancunwei/p/9605627.html&quot; target=&quot;_blank&quot;&gt;.NetCore外国一些高质量博客分享&lt;/a&gt;,长期保持更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;221&quot;&gt;上面三篇文章普及了一些依赖注入的知识。sorry，这块我研究的很浅。。。这次顺带了解了不少，以后要抽空专门研究一下。&lt;/p&gt;
&lt;blockquote data-source-line=&quot;223&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;Single:单例是一个将持续应用程序整个生命周期的实例。在Web术语中，这意味着在服务的初始请求之后，每个后续请求将使用相同的实例。这也意味着它跨越Web请求（因此，如果两个不同的用户访问您的网站，代码仍然使用相同的实例）。考虑单例的最简单方法是，如果类中有静态变量，则它是跨多个实例的单个值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;225&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;Scoped：范围内的生命周期对象通常会简化为“每个Web请求一个实例”，但实际上它比实际上更加微妙。无可否认，在大多数情况下，您可以将每个Web请求视为范围对象。您可能会看到的常见问题是每个Web请求创建一次DBContext，或者创建一次NHibernate上下文，以便您可以将整个请求包含在事务中。作用域生存期对象的另一个非常常见的用途是当您要创建每个请求缓存时。 Scoped生命周期实际上意味着在创建的“范围”对象中将是同一个实例。它恰好发生在.net核心中，它在“范围”内包装请求，但您实际上可以手动创建范围&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;229&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Transient:每次请求服务时，都会创建一个新实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;232&quot;&gt;关于上述的类似错误&lt;a href=&quot;https://github.com/AutoMapper/AutoMapper/issues/2569&quot; target=&quot;_blank&quot;&gt;无法从单件服务 ＃2569中使用作用域服务'AutoMapper.IMapper'&lt;/a&gt;,有用户评论：&lt;/p&gt;
&lt;blockquote data-source-line=&quot;234&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;这是一个基本的设计约束。你不能让单身人士(Single)依赖于瞬态(Scoped)或范围内(Transient)的物品。这不是容器的错，这些生命周期是不相容的。如果您需要兼容的生命周期，请选择不同的生命周期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;236&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Singleton &amp;lt; - Singleton 良好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;238&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Singleton &amp;lt; - Scoped 糟糕&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;240&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Singleton &amp;lt; - Transient 糟糕&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;242&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Scoped &amp;lt; - Singleton 良好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;244&quot;&gt;
&lt;p&gt;Scoped &amp;lt; - Scoped 良好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;246&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Scoped &amp;lt; - Transient 良好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;248&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;TRANSIENT &amp;lt; - Singleton 良好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;250&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Transient &amp;lt; - Scoped 良好在范围内，糟糕在范围外 TRANSIENT&amp;lt; - TRANSIENT 良好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;253&quot; readability=&quot;7.8422535211268&quot;&gt;
&lt;p&gt;所以真的只有两种情况“总是糟糕”，一种情况“有时候很糟糕”。 &lt;a href=&quot;http://asp.net/&quot; target=&quot;_blank&quot;&gt;ASP.NET&lt;/a&gt; Core DI使这个非常明确，甚至将工厂方法传递给上下文对象，例如过滤器。过滤器是Singleton，因此您不能拥有构造函数依赖项。相反，您使用传递给过滤器方法的各种XyzContext对象来解析依赖项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;256&quot;&gt;上述是十分有价值的评价，先收藏，以后细细品味。&lt;/p&gt;
&lt;p data-source-line=&quot;258&quot;&gt;有了这些基础知识和良好建议，我们再来回顾下代码。看到前面都是AddSingleton，后面是AddScoped，在上面的建议中是属于糟糕的。虽然不清楚作者的意图，但我们可以先把程序跑起来，以后用熟悉了再来仔细修复。&lt;/p&gt;
&lt;pre data-source-line=&quot;259&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt; public static class ServiceCollectionExtensions
{
public static void AddZipkinTracer(this IServiceCollection services, ZipkinConfig config)
{
if (config == null) throw new ArgumentNullException(nameof(config));
var maxSize = config.MaxQueueSize &amp;lt;= 0 ? 100 : config.MaxQueueSize;
services.AddSingleton(config);
services.AddSingleton(new BlockingCollection&amp;lt;Span&amp;gt;(maxSize));
services.AddSingleton&amp;lt;IServiceEndpoint, ServiceEndpoint&amp;gt;();
services.AddSingleton&amp;lt;ISpanProcessorTask, SpanProcessorTask&amp;gt;();
services.AddSingleton&amp;lt;ISpanProcessor, SpanProcessor&amp;gt;();
services.AddSingleton&amp;lt;ITraceInfoAccessor, TraceInfoAccessor&amp;gt;();
services.AddScoped&amp;lt;ISpanCollector, SpanCollector&amp;gt;();
services.AddScoped&amp;lt;IZipkinTracer, ZipkinClient&amp;gt;();
services.AddScoped&amp;lt;ISpanTracer, SpanTracer&amp;gt;();
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;282&quot;&gt;好吧，临时将三个AddScoped 改为 AddSingleton(); 运行项目。又开始报错了。。。。说IZipkinTracer需要一个无参的构造函数。&lt;/p&gt;
&lt;pre data-source-line=&quot;285&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;InvalidOperationException: Could not create an instance of type 'ZipkinTracer.IZipkinTracer'. Model bound complex types must not be abstract or value types and must have a parameterless constructor. Alternatively, give the 'tracer' parameter a non-null default value.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;290&quot;&gt;继续搜索新的这个错误。&lt;/p&gt;
&lt;h3 data-source-line=&quot;291&quot; id=&quot;模型绑定的知识普及&quot;&gt;模型绑定的知识普及&lt;/h3&gt;

&lt;blockquote data-source-line=&quot;292&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;Model bound complex types must not be abstract or value types and must have a parameterless constructor&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;294&quot;&gt;&lt;a href=&quot;http://asp.net/&quot; target=&quot;_blank&quot;&gt;asp.net&lt;/a&gt; mvc github的问题里面讨论的很激烈。我只能根据翻译大概猜测意思了。&lt;/p&gt;
&lt;p data-source-line=&quot;296&quot;&gt;&lt;a href=&quot;https://github.com/aspnet/Mvc/issues/6014&quot; target=&quot;_blank&quot;&gt;模型通过DI ＃6014 绑定到接口&lt;/a&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;298&quot;&gt;&lt;a href=&quot;https://github.com/aspnet/Mvc/issues/5883&quot; target=&quot;_blank&quot;&gt;用于简单模型 - 视图模型 - 模型属性映射的基本对象映射器&lt;/a&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;300&quot;&gt;&lt;a href=&quot;https://github.com/aspnet/Mvc/issues/6549&quot; target=&quot;_blank&quot;&gt;未来投资：模型绑定&lt;/a&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;302&quot;&gt;&lt;a href=&quot;http://www.dotnet-programming.com/post/2017/04/06/Model-binding-interfaces-fixing-server-side-validation.aspx&quot; target=&quot;_blank&quot;&gt;Asp.net Core中的自定义模型绑定，3：模型绑定接口&lt;/a&gt;&lt;/p&gt;
&lt;blockquote data-source-line=&quot;303&quot; readability=&quot;2.3333333333333&quot;&gt;
&lt;p&gt;又get到一个网址：&lt;a href=&quot;http://www.dotnet-programming.com/&quot; target=&quot;_blank&quot;&gt;http://www.dotnet-programming.com&lt;/a&gt;,已更新到&lt;a href=&quot;https://www.cnblogs.com/fancunwei/p/9605627.html&quot; target=&quot;_blank&quot;&gt;.NetCore外国一些高质量博客分享&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;305&quot;&gt;&lt;a href=&quot;https://stackoverflow.com/questions/43632346/why-it-requires-the-default-constructor-instead-of-using-my-factory-method-direc&quot; target=&quot;_blank&quot;&gt;为什么它需要默认构造函数而不是直接使用我的工厂方法？&lt;/a&gt;&lt;/p&gt;
&lt;h4 data-source-line=&quot;306&quot; id=&quot;精彩评论&quot;&gt;精彩评论：&lt;/h4&gt;

&lt;p data-source-line=&quot;308&quot;&gt;您正在混淆&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;依赖注入&lt;/a&gt;和&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding#how-model-binding-works&quot; target=&quot;_blank&quot;&gt;模型绑定&lt;/a&gt;。有一个很大的不同。请考虑执行以下操作。 注册IModelFactory为服务：&lt;/p&gt;
&lt;pre data-source-line=&quot;310&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;public void ConfigureServices(IServiceCollection services)
{
services.AddSingleton&amp;lt;IModelFactory&amp;gt;(ModelFactory.Current);
// Add framework services.
services.AddMvc();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;319&quot;&gt;现在在您的控制器中，用于FromServices获取实例，并使用以下内容获取创建模型所需的值FromForm：&lt;/p&gt;
&lt;pre data-source-line=&quot;320&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;[HttpPost]
public IActionResult CreateTemplate([FromForm] string name,
[FromServices] IModelFactory factory)
{
var item = factory.CreateTechnicalTaskTemplate(name);
repo.Templates.Add(item);
return View(nameof(TemplatesList));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;330&quot;&gt;您的工厂应该被视为一项服务。模型绑定需要POCO，而不是接口。&lt;/p&gt;
&lt;h3 data-source-line=&quot;332&quot; id=&quot;从入门到放弃&quot;&gt;从入门到放弃&lt;/h3&gt;

&lt;p data-source-line=&quot;334&quot;&gt;对不起，模型绑定这个错，我没看太懂，只能先放弃了。如果对着源码都找不到解决办法，我只能理解自己的知识太浅。。。时间也很晚了，程序员也是需要有业余生活的。关于zipkintracer的试用到此为止。下期使用官方推荐客户端&lt;a href=&quot;https://github.com/openzipkin/zipkin4net&quot; target=&quot;_blank&quot;&gt;zipkin4net&lt;/a&gt;&lt;br/&gt;。&lt;/p&gt;
&lt;p data-source-line=&quot;336&quot;&gt;看官们，你们也真的深入了解依赖注入和模型绑定么？&lt;/p&gt;
&lt;h3 data-source-line=&quot;338&quot; id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;h3/&gt;
&lt;p data-source-line=&quot;340&quot;&gt;本篇旅程虽然失败，但也了解了zipkin的相关介绍，原理，也在解决问题的过程中加深了依赖注入的理解。模型绑定的概念还不是太清楚，抽空我再看看。真可谓：无心栽花花不成，无心插柳柳成荫。来一句鸡汤：努力向前走，总会有意想不到的收获。&lt;/p&gt;
&lt;h3 data-source-line=&quot;342&quot; id=&quot;可参考资料&quot;&gt;可参考资料&lt;/h3&gt;
&lt;h3/&gt;

&lt;p data-source-line=&quot;343&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/konglongaa/article/details/58016398&quot; target=&quot;_blank&quot;&gt;部署Zipkin分布式性能追踪日志系统的操作记录&lt;/a&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;345&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/guolianyu/p/9545430.html&quot; target=&quot;_blank&quot;&gt;微服务监控zipkin+asp.net core&lt;/a&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;347&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/cd2696879877&quot; target=&quot;_blank&quot;&gt;各大厂分布式链路跟踪系统架构对比&lt;/a&gt; &lt;a href=&quot;https://www.jianshu.com/p/967f73586b87&quot; target=&quot;_blank&quot;&gt;Net和Java基于zipkin的全链路追踪&lt;/a&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;350&quot;&gt;本篇到此结束，感谢观看。&lt;/p&gt;



&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2018-09-12 20:46&lt;/span&gt; &lt;a href=&quot;https://www.cnblogs.com/fancunwei/&quot;&gt;从此启程&lt;/a&gt; 阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;) 评论() &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=9637247&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/fancunwei/p/9637247.html#&quot; onclick=&quot;AddToWz(9637247);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;







&lt;/body&gt;</description>
<pubDate>Wed, 12 Sep 2018 12:46:00 +0000</pubDate>
<dc:creator>从此启程</dc:creator>
<og:description>前言 本文紧接上篇.Net架构篇:思考如何设计一款实用的分布式监控系统？,上篇仅仅是个思考篇，跟本文没有太大的关系。但有思考，结合现有的开源组件，实践起来更易理解起来，所以看本文之前，应该先看下上篇博</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9637247.html</dc:identifier>
</item>
</channel>
</rss>