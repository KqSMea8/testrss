<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[Cpp] 面向对象程序设计 C++ - farwish</title>
<link>http://www.cnblogs.com/farwish/p/8099721.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/farwish/p/8099721.html</guid>
<description>
&lt;p&gt;初始化列表（包括成员对象初始化）&lt;/p&gt;
&lt;p&gt;  初始化列表 ( 推荐 ) :&lt;br/&gt;  可以初始化任何类型的数据, 不管是不是普通类型还是对象，都建议用.&lt;br/&gt;  不再需要在构造器中赋值了, 而且初始化列表比构造函数要早执行.&lt;br/&gt;  成员初始化次序取决于成员在类中的声明次序.&lt;/p&gt;&lt;p&gt;  当类成员有其它对象时，构造器内给对象赋值会触发成员对象的默认构造函数(无参数的)，如果成员对象没有默认构造函数编译报错.&lt;br/&gt;  所以有成员变量为对象这种场景下，要用 initializer list.&lt;/p&gt;
&lt;p&gt;Source：&lt;a href=&quot;https://github.com/farwish/unix-lab/blob/master/cpp/Initializer_list.cc&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/unix-lab/blob/master/cpp/Initializer_list.cc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;继承&lt;/p&gt;
&lt;p&gt;  复用的一种方式，还有上面介绍过的 &quot;对象组合&quot;（成员变量为其他对象）&lt;/p&gt;
&lt;p&gt;  私有属性只能由父类自己访问；受保护的属性可以由子类访问，别人都无法访问.&lt;/p&gt;
&lt;p&gt;  当实例化子类时，会先调用父类的构造函数，当父类没有默认构造函数时又没有初始化自己的构造函数时，编译报类似 &quot;no matching function AA::AA( )&quot;，所以在子类中只能用 initializer list 对父类成员初始化.&lt;/p&gt;
&lt;p&gt;  析构的调用次序则反过来，先子类后父类.&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/farwish/unix-lab/blob/master/cpp/Extends.cc&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/unix-lab/blob/master/cpp/Extends.cc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;函数重载（Function overload）和默认参数（Default argument）&lt;/p&gt;
&lt;p&gt;  同名函数通过拥有不同的参数表实现重载. void print( );   void print ( int i )&lt;/p&gt;
&lt;p&gt;  默认参数是在头文件中给原型的默认参数值，唯一的好处是某些情况下少打字；但是在调用时容易造成阅读困难，另外也不安全，如果我们不 include 头文件而是自己写一个函数声明，把默认参数值设为其它的，那么就和设计者的意图不一样。所以建议不使用 Default argument 如 void f (int i , int j = 10); &lt;/p&gt;

&lt;p&gt;内联函数（Inline functions）&lt;/p&gt;
&lt;p&gt;  当函数前面有 inline 时，它就是一个 declaration，而不再是 defination，因此不需要担心重复定义的问题。&lt;/p&gt;
&lt;p&gt;  内联函数的 body 放在头文件里就可以了，不需要 .cpp 文件，和传统的一个 .h 对应一个 .cpp 不同。&lt;/p&gt;
&lt;p&gt;  因为内联函数有类型检查，因此比做同样事情的宏要好。 &lt;/p&gt;
&lt;p&gt;  ( 使用场合：函数只有2~3行的，需要重复调用的；不适合的：函数比较大，递归 )&lt;/p&gt;
&lt;p&gt;  成员函数在 class 声明时如果给出了 body，那么这些都是 inline 函数，只要有一个头文件就够了。&lt;/p&gt;
&lt;p&gt;  另一种写法是保持 class 声明干净，而为单独实现的成员函数前面加 inline.&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/farwish/unix-lab/blob/master/cpp/Inline.h&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/unix-lab/blob/master/cpp/Inline.h&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/farwish/unix-lab/blob/master/cpp/Inline_main.cc&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/unix-lab/blob/master/cpp/Inline_main.cc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;const; 不可修改的对象（对象成员）&lt;/p&gt;
&lt;p&gt;成员函数 const 的用法：&lt;/p&gt;
&lt;p&gt;  在声明和定义的地方要一起用. &lt;/p&gt;
&lt;p&gt;  　　int getData( ) const;&lt;/p&gt;
&lt;p&gt;  　　int getData( ) const { return data }&lt;/p&gt;
&lt;p&gt;  不修改数据的成员函数应该被定义为 const.&lt;/p&gt;
&lt;p&gt;  如果类有 const 成员变量 或者 实例一个 const 对象，那么一定要在 initialize list 里面初始化变量，否则编译无法通过，因为后面无法修改它 (成员变量)。&lt;/p&gt;
&lt;p&gt;  func( ) { } 和 func( ) const { } 是不一样的，它们构成重载( overload )，因为它们相当于是 func( A* this ) 与 func( const A* this )，参数表不一样。&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/farwish/unix-lab/blob/master/cpp/Const_class.cc&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/unix-lab/blob/master/cpp/Const_class.cc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;引用（C++数据类型）&lt;/p&gt;
&lt;p&gt;  char c; char* p = &amp;amp;c; char&amp;amp; r = c;&lt;/p&gt;
&lt;p&gt;  本地变量或全局变量，必须有初始值，type&amp;amp; name = 'name'　　&lt;/p&gt;
&lt;p&gt;  　　int x = 3;&lt;/p&gt;
&lt;p&gt;　　  int&amp;amp; y = x;            # 赋初值&lt;/p&gt;
&lt;p&gt; 　　 const int&amp;amp; z = x;  # z 不能做左值，但是可以通过修改 x 来修改 z&lt;/p&gt;
&lt;p&gt;  作为参数和成员变量时，可以没有初始值，因为它们会在构造对象时被调用者初始化，type&amp;amp; name;&lt;/p&gt;
&lt;p&gt;　　  void f ( int&amp;amp; x )&lt;/p&gt;
&lt;p&gt;  　　f ( y );      # 在函数调用时初始化&lt;/p&gt;
&lt;p&gt;  指针和引用的区别：&lt;/p&gt;
&lt;p&gt;  　　引用不能为 null.　　　　　　　　　　　　　 指针可以为 null.&lt;/p&gt;
&lt;p&gt;  　　引用依赖另一个变量，是一个变量的别名.　　指针独立于已存在的对象.&lt;/p&gt;
&lt;p&gt;　　  引用不能指向一个新的地址.　　　　　　　　指针可以更改指向不同的地址.&lt;/p&gt;
&lt;p&gt;  　　cpp内存模型的复杂性体现在：三个地方放对象（堆，栈，全局数据区），访问对象的方式（变量放对象，指针访问，引用访问）。&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/farwish/unix-lab/blob/master/cpp/Reference.cc&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/unix-lab/blob/master/cpp/Reference.cc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;引用再研究&lt;/p&gt;
&lt;p&gt;  引用作为类的成员时，声明时没有办法给初始值，因为它需要和另外一个变量捆绑在一起，作为别名；所以必须在构造函数的 initializer list 里初始化。&lt;/p&gt;
&lt;p&gt;  函数可以返回一个引用，但不能引用本地变量。&lt;/p&gt;
&lt;p&gt;  参数前的 const 的引用，const 保证不被修改，引用使传参高效，好处是函数中不用使用 * 号。 &lt;/p&gt;
&lt;p&gt;  参数传引用，这说明参数是一个可以做左值的东西，传参不能使用变量非const的表达式。&lt;/p&gt;
&lt;p&gt;  　　void func(int &amp;amp;); func(i * 3); // error:invalid initialization of non-const reference of type 'int&amp;amp;' from a temporary of type 'int'   error: in passing argument 1 of 'void f (int &amp;amp;)'&lt;/p&gt;
&lt;p&gt;  　　void func(const int&amp;amp;); int i = 3; func(i * 3); // 区别仅在于参数是const的，正确输出9&lt;/p&gt;
&lt;p&gt;  不能对函数返回的对象做左值，编译会报错，error: using temporary as lvalue [-fpermissive]。&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/farwish/unix-lab/blob/master/cpp/Reference_2.cc&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/unix-lab/blob/master/cpp/Reference_2.cc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;向上造型（Upcasting）&lt;/p&gt;
&lt;p&gt;  子类的对象当做父类的对象来看，叫做向上造型，因为一般习惯把父类画在上面；Upcasting 一定是安全的，最多子类拥有的被无视。&lt;/p&gt;
&lt;p&gt;  父类的对象当做子类的对象看，叫做向下造型，Downcasting 有风险，因为父类不一定拥有子类的东西。&lt;/p&gt;
&lt;p&gt;  类型转换和造型的区别，类型转换原来的值转换完就变了，而造型数据没变，子类的对象还是子类的对象，只是看待的眼光不一样。&lt;/p&gt;
&lt;p&gt;  Persion John('JOHN');&lt;/p&gt;
&lt;p&gt;  Animal* p = &amp;amp;John;  // Upcast,  因为Person是Animal的一种, 但反过来就是 Downcast&lt;/p&gt;
&lt;p&gt;  Animal&amp;amp; q = John;   // Upcast&lt;/p&gt;

&lt;p&gt;多态性（polymorphism）：Upcast 和 Dynamic binding 两个条件构成多态性&lt;/p&gt;
&lt;p&gt;  Upcast: 把派生类当做基类使用。&lt;/p&gt;
&lt;p&gt;  Dynamic binding: 调用对象的函数。&lt;/p&gt;
&lt;p&gt;  　　（Static binding: 调用代码写明的函数）&lt;/p&gt;
&lt;pre&gt;
/**
 * 通用函数，对任何 Shape 和其子类都通用.
 *
 * 动态绑定，调用的 render 在运行时决定:
 *  p 有一个静态类型和动态类型，如果 p 的 render 函数是 virtual 的，那么是动态绑定，不是 virtual 则是静态绑定。
 *  所以动态绑定还是静态绑定取决于 render 函数，而不是对象 p；如果我们调用的是 move 函数，那么就是静态绑定。
 */
void render(Shape*&lt;span&gt; p)
{
    p-&amp;gt;&lt;span&gt;render();
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/farwish/unix-lab/blob/master/cpp/Polymorphism.cc&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/unix-lab/blob/master/cpp/Polymorphism.cc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;虚 析构函数&lt;/p&gt;
&lt;p&gt;  Shape的析构不是 virtual 时，默认是静态绑定，delete p 时，只有 Shape 的析构会被调用，Ellipse 的不会调用。&lt;/p&gt;
&lt;p&gt;  Shape的析构是 virtual 时，表示动态绑定，delete p 时，会先调子类的析构，在调父类的析构。&lt;/p&gt;
&lt;p&gt;  　　Shape* p = new Ellipse(100.0, 110.0);&lt;br/&gt;  　　delete p;&lt;/p&gt;
&lt;p&gt;  其它 OOP 语言默认就是 virtual 的，也就是动态绑定的，而C++默认是静态绑定的，动态绑定需要手动加 virtual。&lt;/p&gt;
&lt;p&gt;  如果一个类里有一个 virtual 函数，它的析构函数就必须是 virtual 的。&lt;/p&gt;
&lt;p&gt;  如果父类和子类有名字相同、参数表相同的 virtual 函数，那么子类成员函数就对父类构成了重写/覆盖。&lt;/p&gt;
&lt;p&gt;  子类成员函数中调用父类的同名函数用 Base::func( ) 的方式。&lt;/p&gt;
&lt;p&gt;  父类里有两个 virtual 的重载(overload)函数，那么子类里也要实现两个 overloaded 的函数，否则另一个函数会发生 name hidden，只有 C++ 会发生函数的隐藏。&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/farwish/unix-lab/blob/master/cpp/Polymorphism.cc&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/unix-lab/blob/master/cpp/Polymorphism.cc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;拷贝构造&lt;/p&gt;
&lt;p&gt;  拷贝构造的唯一形式：T::T(const T&amp;amp;)&lt;/p&gt;
&lt;p&gt;  拷贝构造什么时候被调用？&lt;br/&gt;  　　1.用对象进行初始化时，Person p = p1 或 Person p(p1)，这两种写法相同，注意它不是 assignment 而是 initialization (因为变量前有类型)。&lt;br/&gt;  　　2.调用一个函数，函数的参数是一个对象时，void func(Person p);&lt;br/&gt;  　　3.用返回对象的函数返回值进行初始化。&lt;/p&gt;
&lt;p&gt;  Construction vs Assignment&lt;br/&gt;  每个对象只能构造一次，每个对象应该被析构一次，&lt;br/&gt;  对象一旦被构造，它可以是被赋值的目标，前头有类型就是 initialization，没有类型就是 assignment.&lt;/p&gt;&lt;p&gt;  Copy constructor guidelines&lt;br/&gt;  写一个类就先写三个函数 default constructor, virtual distructor, copy constructor。&lt;br/&gt;  如果确实不需要拷贝构造，那么就声明为私有，不建议这么做，限制了很多事不能做。&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/farwish/unix-lab/blob/master/cpp/Copy_constructor.cc&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/unix-lab/blob/master/cpp/Copy_constructor.cc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;静态对象&lt;/p&gt;
&lt;p&gt;  static两个基本的含义：&lt;/p&gt;
&lt;p&gt;  　　静态存储，本地变量是static，这个本地变量具有持久存储（事实上static的本地变量就是全局变量）。&lt;/p&gt;
&lt;p&gt;  　　名字可见性，全局变量、函数的static，那么这个全局变量、函数只在当前文件中可用。&lt;/p&gt;
&lt;p&gt;  static 在 C++ 中的使用：&lt;/p&gt;
&lt;p&gt;  　　静态本地变量 - 持久存储。&lt;/p&gt;
&lt;p&gt;　　  静态成员变量 - 所有对象间共享。&lt;/p&gt;
&lt;p&gt;  　　静态成员函数 - 所有对象间共享，它只能访问静态成员变量。&lt;/p&gt;
&lt;p&gt;　　  对象是静态的 - 除了遵守两个基本法则（存储、可见性），保证只构造析构一次。&lt;/p&gt;
&lt;p&gt;  静态初始化的依赖&lt;/p&gt;
&lt;p&gt;  　　多个 cpp 文件都有自己的全局变量的情况，没人保证初始化顺序先后；&lt;/p&gt;
&lt;p&gt;　　  如果一个变量的初始化依赖另一个变量的值作为参数，那么需要先初始化那另一个变量，但是跨文件的初始化是不存在的。所以解决方案是，1. 别这么干。 2. 逻辑上许可的话，把所有有依赖的全局变量放到一个地方。&lt;/p&gt;
&lt;p&gt;Source：&lt;a href=&quot;https://github.com/farwish/unix-lab/blob/master/cpp/Static_members.cc&quot; target=&quot;_blank&quot;&gt;https://github.com/farwish/unix-lab/blob/master/cpp/Static_members.cc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Link：&lt;a href=&quot;http://www.cnblogs.com/farwish/p/8099721.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/farwish/p/8099721.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 10 Feb 2018 15:42:00 +0000</pubDate>
<dc:creator>farwish</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/farwish/p/8099721.html</dc:identifier>
</item>
<item>
<title>好用的开源库（二）——uCrop 图片裁剪 - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/8440072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/8440072.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近想要实现图片裁剪的功能，在Github上找到了这个uCrop,star的人挺多的，便是决定入坑，结果长达一个小时的看资料+摸索，终于是在项目中实现了图片裁剪的功能，今天便是来介绍一下uCrop的使用方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Yalantis/uCrop&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;uCrop&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;目录：&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;
&lt;h3&gt;&lt;span&gt;配置&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;&lt;span&gt;流程介绍&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;&lt;span&gt;使用&lt;/span&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;配置&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.添加依赖&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;maven { url &quot;https://jitpack.io&quot; }&lt;br/&gt;&lt;code&gt;compile 'com.github.yalantis:ucrop:2.2.1'&lt;/code&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201802/1210268-20180210220457560-1315138150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201802/1210268-20180210220528357-1029440363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.配置Androidmanifest文件&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activity
            &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;com.yalantis.ucrop.UCropActivity&quot;&lt;/span&gt;&lt;span&gt;
            android:screenOrientation&lt;/span&gt;&lt;span&gt;=&quot;portrait&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;screenOrientation是屏幕方向，由于是在手机上使用的，这里便设置为竖直方向&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 3.还有读写权限的声明&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201802/1210268-20180210221709763-1701526944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS：这里Write权限其实是包括了读和写的权限，所以我们只需要声明一个就行了，多声明写的权限也是没有问题的&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;简单流程介绍：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用之前我们来了解一下剪切图片的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，Ucrop构造函数有两个参数，分别是需要裁剪的图片的Uri和裁剪之后的Uri，裁剪之后的Uri需要我们创建，之后对Ucrop进行一些设置，如裁剪框的宽高大小，设置裁剪框的竖线数量或者输出的图片格式等等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完成设置后就可以进入到裁剪的那个Activity进行裁剪的操作，结束裁剪之后会有返回码，我们在onActivityResult方法中对其进行截取就可以获得裁剪之后的Uri，之后我们就可以利用这个Uri获得裁剪之后的图片&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;使用：&lt;/h2&gt;
&lt;h3&gt;1.新建一个输出的Uri，mDestinationUri&lt;/h3&gt;
&lt;h3&gt;2.新建一个Ucrop类，相关设置如图片中代码&lt;/h3&gt;
&lt;p&gt;参数传入的是需要裁剪的图片的Uri&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201802/1210268-20180210231956326-13769087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.在onActivityResult中截取裁剪图片输出的Uri&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201802/1210268-20180210232829060-1374203129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.处理图片&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201802/1210268-20180210232919779-123566490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里直接使用Uri的toString方法将Uri转换为String&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt; 5.显示图片&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这里使用IO流，具体可以看看代码理解理解（其实直接用刚才获得的那个Uri也行，不用转换成String类型）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201802/1210268-20180210233013654-277781535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;可能出现的问题：&lt;/h2&gt;
&lt;h3&gt;出现应用已停止：&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;原因：在使用裁剪的当前的Activity使用了actionbar，在Androidmanifest文件中将该activity的theme改为Noactionbar即可&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 10 Feb 2018 15:41:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/8440072.html</dc:identifier>
</item>
<item>
<title>自兴人工智能------Python语言的变量认识及操作 - Causal因</title>
<link>http://www.cnblogs.com/zhongsiyi/p/8440060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhongsiyi/p/8440060.html</guid>
<description>&lt;p&gt;今天我给大家介绍的是python中的Number变量,与c++,java有些不同,下面让来为大家介绍:&lt;/p&gt;
&lt;p&gt;在python中是不用声明变量类型的,不过在使用变量前需要对其赋值,没有值得变量是没有意义的,编译器也不会通过&lt;/p&gt;
&lt;p&gt;一 : 整型-----int:&lt;/p&gt;
&lt;p&gt;int 在python中的用法与c++大致是一样的:&lt;/p&gt;
&lt;p&gt;a=12&lt;/p&gt;
&lt;p&gt;print a&lt;/p&gt;
&lt;p&gt;打印的结果就是:12&lt;/p&gt;
&lt;p&gt;在这里我要首先向大家介绍几个函数&lt;/p&gt;
&lt;p&gt;type():返回括号中的数据类型 &lt;/p&gt;
&lt;p&gt;        a='hello'&lt;/p&gt;
&lt;p&gt;        print type(a)&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;lt;type 'string'&amp;gt;&lt;/p&gt;

&lt;p&gt;len():返回括号中的变量的长度&lt;/p&gt;
&lt;p&gt;注:使用len()方法是不能用int类型&lt;/p&gt;
&lt;p&gt;       a='hello world'&lt;/p&gt;
&lt;p&gt;       print len(a)&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt; &amp;gt;11&lt;/p&gt;
&lt;p&gt;二 : 浮点型------float&lt;/p&gt;
&lt;p&gt;浮点型由整数部分与小数部分组成,也可以用科学计数法表示&lt;/p&gt;
&lt;p&gt;   a=1.23&lt;/p&gt;
&lt;p&gt;  print type(a)&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt; &amp;lt;type 'float'&amp;gt;&lt;/p&gt;

&lt;p&gt;三　：复数&lt;/p&gt;
&lt;p&gt;复数是由实数部分和虚数部分构成,可以用a+bj或comple(a,b),复数的实部a和虚部b都是浮点型&lt;/p&gt;

&lt;p&gt;四: 数据类型转换&lt;/p&gt;
&lt;p&gt;int(x) : 将x转换为一个整数&lt;/p&gt;
&lt;p&gt;float(x) : 将x转换为一个浮点数&lt;/p&gt;
&lt;p&gt;complex(x) ：将ｘ转换为一个复数，实数部分为ｘ，虚数部分为０&lt;/p&gt;
&lt;p&gt;         a=1.23&lt;/p&gt;
&lt;p&gt;         print complex(a)&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;(1.23+0j)&lt;/p&gt;
&lt;p&gt;complex(x,y) :　将ｘ和ｙ转换为一个复数，实数部分为ｘ，ｘ和ｙ是数字表达式&lt;/p&gt;

&lt;p&gt;五:　常量&lt;/p&gt;
&lt;p&gt;ｐython中有两个比较常见的常量,即PI和E&lt;/p&gt;
&lt;p&gt;PI:数学常量pi(圆周率)&lt;/p&gt;
&lt;p&gt;E:数学常量e.即自然数&lt;/p&gt;

&lt;p&gt;好了,今天的介绍到此结束,希望能帮到你们&lt;/p&gt;










&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 10 Feb 2018 15:34:00 +0000</pubDate>
<dc:creator>Causal因</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhongsiyi/p/8440060.html</dc:identifier>
</item>
<item>
<title>当我们刚开始我们的码农生涯时，我们该做些什么 - 赵孤鸿</title>
<link>http://www.cnblogs.com/zhaoguhong/p/8439547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaoguhong/p/8439547.html</guid>
<description>&lt;p&gt;最近公司新来了一个妹子，老大让我带。妹子大大的眼睛，一眨一眨的，灰常可爱。从她身上我仿佛看到了两年前的自己，从面对业务的各种懵逼，到完不成任务时主动加班，蓦然有一种恍如隔日的感觉。所以想和大家聊聊当我们刚开始我们的码农生涯时，我们该做些什么？&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;写在前面&lt;/h3&gt;
&lt;p&gt;先聊一下带妹子这两周的趣事，感觉很有意思。记得当老大说让我带妹子的时候，我的心情是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1161430/201802/1161430-20180210190110170-907437034.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后事情并非总朝着预料中的方向发展，妹子对我说的最多的一句话居然是&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;大哥，我eclipse炸了&lt;br/&gt;大哥，我eclipse又炸了&lt;br/&gt;大哥，我eclipse又又炸了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还好妹子没叫我大叔，我想对妹子说的是，虽然我长的有点着急，但头发少代表着睿智，真不代表年龄&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1161430/201802/1161430-20180210190218560-547592566.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;妹子奉行着初入江湖无所畏惧的精神，刚来一周就光荣的提交了一个bug上线了，加班填坑的事就不说了，吓得我对妹子提交的代码必须要review，然后就有了下面的对话&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我：分号为什么不换行？&lt;br/&gt;妹子：别人都没换，，，&lt;br/&gt;我：你怎么知道这个地方能取到值？&lt;br/&gt;妹子：我猜的，，，&lt;br/&gt;我：记笔记咱能不能记到电脑上？&lt;br/&gt;妹子：，，，&lt;br/&gt;我：同样的代码你为啥要写四遍，不能抽象出来吗？&lt;br/&gt;妹子：，，，&lt;br/&gt;我：你这1，2，3是什么意思，这是魔术数字知不知道？&lt;br/&gt;妹子：，，，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，我想对妹子说，不是哥哥针对你，是因为你桌子上放的糖，总是不让我吃。额不，是因为你要打好基础，我都是为了你好，嗯，是这样的。&lt;/p&gt;
&lt;h3 id=&quot;主动出击&quot;&gt;主动出击&lt;/h3&gt;
&lt;p&gt;我说的可不是主动出击追妹子，而是当你以菜鸟的身份初入职场时。要主动出击了解公司的各种规章制度和项目流程。对于整个项目的开发流程，各种开发环境，版本控制管理，都要有所了解。&lt;/p&gt;
&lt;p&gt;不能糊里糊涂什么都等着别人安排，不然等到代码提交错分支或者连错数据库等问题时徒增尴尬。殊不知，或许这些信息项目的文档里都有，只是你没去看而已。&lt;/p&gt;
&lt;h3 id=&quot;取人之长补己之短&quot;&gt;取人之长,补己之短&lt;/h3&gt;
&lt;p&gt;无知不可怕，可怕的是不自知。初入职场，遇到问题，虚心的像别人请教是快速成长的不二法门。或者你纠结了几天的问题，老司机一句话就点醒了你。&lt;/p&gt;
&lt;p&gt;但问问题要讲究方法，最起码是自己尝试过解决之后再去问。例如，项目启动不了，你要告诉给你解决问题的人：最近有没有改过什么东西；自己尝试过哪些解决办法；以及自己判断是什么原因造成的等。而不是简单一句：我项目启动不了了，帮我看看呗。&lt;/p&gt;
&lt;p&gt;善于学习而不迷信。多看看老司机写的代码，想一想如果自己的话该如何写，取其精华，去其糟粕。不加分辨一味地去模仿是不可取的。要养成自己独立思考的习惯。&lt;/p&gt;
&lt;h3 id=&quot;承担责任&quot;&gt;承担责任&lt;/h3&gt;
&lt;p&gt;不要因为自己是菜鸟而怕担责任，也不要因为给你分了简单的任务而暗自窃喜。回想自己的两年多码农生涯，让我成长最多的不是分分钟就写完的简单业务代码，也不是上来就可以复制粘贴的增删改查，而是折磨了我无数次的变态需求，还有那些加班加点的奋战。&lt;/p&gt;
&lt;p&gt;如果分任务的时候，每次你拿到的都是最轻松的，最简单的，恰恰也说明了你是团队中最无能的。如果你能主动承担相对麻烦的，有难度的任务，也许你会为此付出更多时间，会踩更多的坑，但这也恰恰是你成才的机会。&lt;/p&gt;
&lt;h3 id=&quot;持续学习&quot;&gt;持续学习&lt;/h3&gt;
&lt;p&gt;曾经，我认为“码农”二字只是对程序员的一句调侃而已，现如今却发现是不能再真的事实。如今的程序员犹如过江之鲫，何止百万。如若不能脱颖而出，必然要成为所谓三十五岁被辞退的一员。而持续学习则是不被淘汰的必经之路。&lt;/p&gt;
&lt;p&gt;如果你每天晚上有两个小时的空闲时间，以前全部都在打王者农药。现在你可以尝试分出来一个小时去学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你把一个小时交给了自由和享受，也不要忘了把另外一个小时交给梦想和责任。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;听说你们公司新来了一个妹子让你带啊&lt;br/&gt;是啊&lt;br/&gt;妹子哪的人呢&lt;br/&gt;额，，，&lt;br/&gt;有男朋友吗？&lt;br/&gt;额，，，&lt;br/&gt;有啥爱好？&lt;br/&gt;额，，，&lt;/p&gt;
&lt;p&gt;这些你不知道，你说你知道啥&lt;br/&gt;我知道妹子昨天提交的代码第168行多了一个分号&lt;/p&gt;
&lt;p&gt;这么说你是有对象喽&lt;br/&gt;那个，new的算吗&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 10 Feb 2018 11:14:00 +0000</pubDate>
<dc:creator>赵孤鸿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaoguhong/p/8439547.html</dc:identifier>
</item>
<item>
<title>监听器应用【统计网站人数、自定义session扫描器、踢人小案例】 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8439390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8439390.html</guid>
<description>&lt;p&gt;从第一篇已经讲解过了监听器的基本概念，以及Servlet各种的监听器。这篇博文主要讲解的是监听器的应用。&lt;/p&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;我们在网站中一般使用Session来标识某用户是否登陆了，如果登陆了，就在Session域中保存相对应的属性。如果没有登陆，那么Session的属性就应该为空。&lt;/p&gt;
&lt;p&gt;现在，我们想要统计的是网站的在线人数。我们应该这样做：&lt;strong&gt;我们监听是否有新的Session创建了，如果新创建了Sesssion，那么在线人数就应该+1。这个在线人数是整个站点的，所以应该有Context对象保存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大致思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;监听Session是否被创建了&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果Session被创建了，那么在Context的域对象的值就应该+1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果Session从内存中移除了，那么在Context的域对象的值就应该-1.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;监听器代码：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CountOnline &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; HttpSessionListener {
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sessionCreated&lt;/span&gt;(HttpSessionEvent se) {
    
            &lt;span class=&quot;co&quot;&gt;//获取得到Context对象，使用Context域对象保存用户在线的个数&lt;/span&gt;
            ServletContext context = se.&lt;span class=&quot;fu&quot;&gt;getSession&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getServletContext&lt;/span&gt;();
            
            &lt;span class=&quot;co&quot;&gt;//直接判断Context对象是否存在这个域，如果存在就人数+1,如果不存在，那么就将属性设置到Context域中&lt;/span&gt;
            Integer num = (Integer) context.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;num&quot;&lt;/span&gt;);
            
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (num == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                context.&lt;span class=&quot;fu&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;num&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                num++;
                context.&lt;span class=&quot;fu&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;num&quot;&lt;/span&gt;, num);
            }
        }
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sessionDestroyed&lt;/span&gt;(HttpSessionEvent se) {
    
            ServletContext context = se.&lt;span class=&quot;fu&quot;&gt;getSession&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getServletContext&lt;/span&gt;();
            Integer num = (Integer) se.&lt;span class=&quot;fu&quot;&gt;getSession&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;num&quot;&lt;/span&gt;);
    
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (num == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                context.&lt;span class=&quot;fu&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;num&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                num--;
                context.&lt;span class=&quot;fu&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;num&quot;&lt;/span&gt;, num);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;显示页面代码：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
在线人数：${num}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;我们每使用一个浏览器访问服务器，都会新创建一个Session。那么网站的在线人数就会+1。&lt;/p&gt;
&lt;p&gt;使用同一个页面刷新，还是使用的是那个Sesssion，所以网站的在线人数是不会变的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170324153536587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;我们都知道Session是保存在内存中的，如果Session过多，服务器的压力就会非常大。&lt;/p&gt;
&lt;p&gt;但是呢，&lt;strong&gt;Session的默认失效时间是30分钟(30分钟没人用才会失效)，这造成Seesion可能会过多（没人用也存在内存中，这不是明显浪费吗？）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然啦，我们可以&lt;strong&gt;在web.xml文件中配置Session的生命周期&lt;/strong&gt;。但是呢，&lt;strong&gt;这是由服务器来做的，我嫌它的时间不够准确。&lt;/strong&gt;（有时候我配置了3分钟，它用4分钟才帮我移除掉Session）&lt;/p&gt;
&lt;p&gt;所以，我决定自己&lt;strong&gt;用程序手工移除那些长时间没人用的Session。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析-1&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;要想移除长时间没人用的Session，肯定要先拿到全部的Session啦。所以我们&lt;strong&gt;使用一个容器来装载站点所有的Session&lt;/strong&gt;。。&lt;/p&gt;
&lt;p&gt;只要&lt;strong&gt;Sesssion一创建了，就把Session添加到容器里边&lt;/strong&gt;。毫无疑问的，我们需要监听Session了。&lt;/p&gt;
&lt;p&gt;接着，我们要做的就是&lt;strong&gt;隔一段时间就去扫描一下全部Session，如果有Session长时间没使用了，我们就把它从内存中移除。隔一段时间去做某事，这肯定是定时器的任务呀。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定时器应该在服务器一启动的时候，就应该被创建了。因此还需要监听Context&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，我们还要考虑到并发的问题，如果有人同时访问站点，那么&lt;strong&gt;监听Session创建的方法就会被并发访问了&lt;/strong&gt;。&lt;strong&gt;定时器扫描容器的时候，可能是获取不到所有的Session的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这需要我们做同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;于是乎，我们已经有大致的思路了&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;监听Session和Context的创建&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用一个容器来装载Session&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定时去扫描Session，如果它长时间没有使用到了，就把该Session从内存中移除。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发访问的问题&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;代码-1&quot;&gt;代码&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;监听器代码：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Listener1 &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; ServletContextListener,
            HttpSessionListener {
    
    
    
        &lt;span class=&quot;co&quot;&gt;//服务器一启动，就应该创建容器。我们使用的是LinkList(涉及到增删)。容器也应该是线程安全的。&lt;/span&gt;
        List&amp;lt;HttpSession&amp;gt; list = Collections.&lt;span class=&quot;fu&quot;&gt;synchronizedList&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;HttpSession&amp;gt;());
    
        &lt;span class=&quot;co&quot;&gt;//定义一把锁（Session添加到容器和扫描容器这两个操作应该同步起来）&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Object lock = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;contextInitialized&lt;/span&gt;(ServletContextEvent sce) {
    
    
            Timer timer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Timer();
            &lt;span class=&quot;co&quot;&gt;//执行我想要的任务，0秒延时，每10秒执行一次&lt;/span&gt;
            timer.&lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyTask&lt;/span&gt;(list, lock), &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;);
    
        }
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sessionCreated&lt;/span&gt;(HttpSessionEvent se) {
    
            &lt;span class=&quot;co&quot;&gt;//只要Session一创建了，就应该添加到容器中&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (lock) {
                list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(se.&lt;span class=&quot;fu&quot;&gt;getSession&lt;/span&gt;());
            }
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Session被创建啦&quot;&lt;/span&gt;);
    
        }
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sessionDestroyed&lt;/span&gt;(HttpSessionEvent se) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Session被销毁啦。&quot;&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;contextDestroyed&lt;/span&gt;(ServletContextEvent sce) {
    
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;任务代码：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;


    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    * 在任务中应该扫描容器，容器在监听器上，只能传递进来了。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    * 要想得到在监听器上的锁，也只能是传递进来&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    * */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyTask &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; TimerTask {
    
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; List&amp;lt;HttpSession&amp;gt; sessions;
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Object lock;
    
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyTask&lt;/span&gt;(List&amp;lt;HttpSession&amp;gt; sessions, Object lock) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;sessions&lt;/span&gt; = sessions;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt; = lock;
        }
    
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
    
            &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (lock) {
                &lt;span class=&quot;co&quot;&gt;//遍历容器&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (HttpSession session : sessions) {
    
                    &lt;span class=&quot;co&quot;&gt;//只要15秒没人使用，我就移除它啦&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - session.&lt;span class=&quot;fu&quot;&gt;getLastAccessedTime&lt;/span&gt;() &amp;gt; (&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;)) {
                        session.&lt;span class=&quot;fu&quot;&gt;invalidate&lt;/span&gt;();
                        sessions.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(session);
                    }
    
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;15秒如果Session没有活跃，那么就被删除！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170324163909737?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用集合来装载我们所有的Session&lt;/li&gt;
&lt;li&gt;使用定时器来扫描session的声明周期【由于定时器没有session，我们传进去就好了】&lt;/li&gt;
&lt;li&gt;关于并发访问的问题，我们在扫描和检测session添加的时候，同步起来就好了【当然，定时器的锁也是要外面传递进来的】&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;列出所有的在线用户，后台管理者拥有踢人的权利，点击踢人的超链接，该用户就被注销了。&lt;/p&gt;
&lt;h2 id=&quot;分析-2&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;首先，怎么能列出所有的在线用户呢？？一般我们在线用户都是用Session来标记的&lt;strong&gt;，所有的在线用户就应该用一个容器来装载所有的Session。。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们监听Session的是否有属性添加(&lt;strong&gt;监听Session的属性有添加、修改、删除三个方法。如果监听到Session添加了，那么这个肯定是个在线用户！&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;装载Session的容器应该是在Context里边的【属于全站点】，并且容器应该使用Map集合【待会还要通过用户的名字来把用户踢了】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;写监听器，监听是否有属性添加在Session里边了&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写简单的登陆页面。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列出所有的在线用户&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现踢人功能(也就是摧毁Session)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;代码-2&quot;&gt;代码&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; KickPerson &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; HttpSessionAttributeListener {

    &lt;span class=&quot;co&quot;&gt;// Public constructor is required by servlet spec&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;KickPerson&lt;/span&gt;() {
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;attributeAdded&lt;/span&gt;(HttpSessionBindingEvent sbe) {

        &lt;span class=&quot;co&quot;&gt;//得到context对象，看看context对象是否有容器装载Session&lt;/span&gt;
        ServletContext context = sbe.&lt;span class=&quot;fu&quot;&gt;getSession&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getServletContext&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;//如果没有，就创建一个呗&lt;/span&gt;
        Map map = (Map) context.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;map&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (map == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            map = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap();
            context.&lt;span class=&quot;fu&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;map&quot;&lt;/span&gt;, map);
        }

        &lt;span class=&quot;co&quot;&gt;//---------------------------------------------------------------------------------------&lt;/span&gt;
        
        &lt;span class=&quot;co&quot;&gt;//得到Session属性的值&lt;/span&gt;
        Object o = sbe.&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;//判断属性的内容是否是User对象&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (o &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; User) {
            User user = (User) o;
            map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(user.&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;(), sbe.&lt;span class=&quot;fu&quot;&gt;getSession&lt;/span&gt;());
        }
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;attributeRemoved&lt;/span&gt;(HttpSessionBindingEvent sbe) {
      &lt;span class=&quot;co&quot;&gt;/* This method is called when an attribute&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         is removed from a session.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      */&lt;/span&gt;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;attributeReplaced&lt;/span&gt;(HttpSessionBindingEvent sbe) {
      &lt;span class=&quot;co&quot;&gt;/* This method is invoked when an attibute&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         is replaced in a session.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      */&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;登陆页面&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;form&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; action=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${pageContext.request.contextPath }/LoginServlet&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;post&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    用户名：&lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;submit&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;登陆&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;处理登陆Servlet&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;//得到传递过来的数据&lt;/span&gt;
        String username = request.&lt;span class=&quot;fu&quot;&gt;getParameter&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;);

        User user = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;User&lt;/span&gt;();
        user.&lt;span class=&quot;fu&quot;&gt;setUsername&lt;/span&gt;(username);

        &lt;span class=&quot;co&quot;&gt;//标记该用户登陆了！&lt;/span&gt;
        request.&lt;span class=&quot;fu&quot;&gt;getSession&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;user&quot;&lt;/span&gt;, user);

        &lt;span class=&quot;co&quot;&gt;//提供界面，告诉用户登陆是否成功&lt;/span&gt;
        request.&lt;span class=&quot;fu&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;message&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;恭喜你，登陆成功了！&quot;&lt;/span&gt;);
        request.&lt;span class=&quot;fu&quot;&gt;getRequestDispatcher&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/message.jsp&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;forward&lt;/span&gt;(request, response);
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;列出在线用户&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode jsp&quot;&gt;
&lt;code class=&quot;sourceCode jsp&quot;&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;c:forEach&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; items&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${map}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; var&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;me&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

    ${me.key} &amp;lt;a&lt;span class=&quot;ot&quot;&gt; href&lt;/span&gt;=&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;${pageContext.request.contextPath}&lt;span class=&quot;dt&quot;&gt;/KickPersonServlet?username=&lt;/span&gt;${me.key}&lt;span class=&quot;dt&quot;&gt;&quot;&lt;/span&gt;&amp;gt;踢了他吧&amp;lt;/a&amp;gt;

    &amp;lt;br&amp;gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/c:forEach&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;处理踢人的Servlet&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

        String username = request.&lt;span class=&quot;fu&quot;&gt;getParameter&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;);

        &lt;span class=&quot;co&quot;&gt;//得到装载所有的Session的容器&lt;/span&gt;
        Map map = (Map) &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getServletContext&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;map&quot;&lt;/span&gt;);

        &lt;span class=&quot;co&quot;&gt;//通过名字得到Session&lt;/span&gt;
        HttpSession httpSession = (HttpSession) map.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(username);
        httpSession.&lt;span class=&quot;fu&quot;&gt;invalidate&lt;/span&gt;();
        map.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(username);

        &lt;span class=&quot;co&quot;&gt;//摧毁完Session后，返回列出在线用户页面&lt;/span&gt;
        request.&lt;span class=&quot;fu&quot;&gt;getRequestDispatcher&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/listUser.jsp&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;forward&lt;/span&gt;(request, response);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;测试-1&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;使用多个浏览器登陆来模拟在线用户（同一个浏览器使用的都是同一个Session）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170326161527748?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;监听Seesion的创建和监听Session属性的变化有啥区别？？？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Session的创建只代表着&lt;strong&gt;浏览器给服务器发送了请求。会话建立&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Session属性的变化就不一样了，&lt;strong&gt;登记的是具体用户是否做了某事(登陆、购买了某商品)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章的同学，可以关注微信公众号:Java3y&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 10 Feb 2018 10:45:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8439390.html</dc:identifier>
</item>
<item>
<title>zalenium  应用 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/8439359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/8439359.html</guid>
<description>&lt;p&gt;zalenium是一个Selenium Grid扩展，用Docker容器动态扩展你的本地网格。它使用docker-selenium在本地运行Firefox和Chrome中的测试，如果需要不同的浏览器，你的测试可以重定向到云测试提供商（Sauce Labs，BrowserStack，TestingBot）。 Zalenium也可以在Kubernetes中使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;繁杂的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有一个稳定的网格来运行Selenium的UI测试&lt;/li&gt;
&lt;li&gt;随着时间的推移保持它（跟上新的浏览器，Selenium和驱动程序版本）&lt;/li&gt;
&lt;li&gt;提供涵盖所有浏览器和平台的功能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就是为什么开发zalenium的原因，在需求中创建了docker-selenium节点。在Firefox和Chrome中进行的UI测试将运行得更快，因为它们在本地网格上运行，在从头开始创建并在测试完成后处理的节点上运行。&lt;/p&gt;
&lt;p&gt;如果需要docker-selenium无法实现的功能，测试会重定向到云测试提供程序（Sauce Labs，BrowserStack，TestingBot）。&lt;/p&gt;
&lt;p&gt;Zalenium的主要目标是：允许任何人拥有一次性和灵活的Selenium Grid基础设施。&lt;/p&gt;

&lt;h3 id=&quot;zalenium的由来&quot;&gt;zalenium的由来&lt;/h3&gt;
&lt;p&gt;由Zalando和Selenium两个单词组成。如前所述，这个项目的目的是提供一个简单的方法来创建一个Grid，并服务于Selenium社区。不过，这不是一个正式的Selenium项目。&lt;/p&gt;
&lt;p&gt;注：Zalando只是一个电商平台。Zalenium由该平台的研发团队开发与维护。&lt;/p&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;如果你从未安装和使用过Docker ，请参考 &lt;a href=&quot;http://www.testclass.net/docker/&quot;&gt;Docker教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、安装Docker Engin，版本 &amp;gt; = 1.11.1（可能适用于早期版本，尚未测试）。&lt;/p&gt;
&lt;p&gt;2、docker daemon 正在运行（例如，docker info可以正常工作）。&lt;/p&gt;
&lt;p&gt;3、拉取 docker-selenium镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo docker pull elgalu/selenium&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：这里拉取的是非官方的docker-selenium镜像。&lt;/p&gt;
&lt;p&gt;4、拉取zalenium镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo docker pull dosel/zalenium&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;速度太慢，可以使用国内镜像：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.docker-cn.com/registry-mirror&quot; class=&quot;uri&quot;&gt;https://www.docker-cn.com/registry-mirror&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看镜像：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo docker images
REPOSITORY        TAG       IMAGE ID       CREATED       SIZE   
elgalu/selenium   latest    9d39de56e57b   3 days ago    1.4GB
dosel/zalenium    latest    e5a39a962b2c   8 days ago    746MB&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;运行&quot;&gt;运行&lt;/h3&gt;
&lt;p&gt;Zalenium使用docker来按需扩展，因此我们需要为docker.sock提供完全的访问权限，这就是所谓的“Docker alongside docker”。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run --rm -ti --name zalenium -p 4444:4444 \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v /tmp/videos:/home/seluser/videos \
    --privileged dosel/zalenium start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;--privileged 为可选项，建议运行zalenium的privileged参数，通过Haveged增加熵（entropy）水平节点注册过程的速度。因为它可以提高性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备测试脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;grid_demo.py&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; selenium &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; webdriver
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; time &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; sleep

driver &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; webdriver.Remote(
command_executor&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'http://127.0.0.1:4444/wd/hub'&lt;/span&gt;,
desired_capabilities&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{&lt;span class=&quot;st&quot;&gt;'browserName'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'chrome'&lt;/span&gt;})

driver.get(&lt;span class=&quot;st&quot;&gt;'https://www.baidu.com'&lt;/span&gt;)
driver.find_element_by_id(&lt;span class=&quot;st&quot;&gt;&quot;kw&quot;&lt;/span&gt;).send_keys(&lt;span class=&quot;st&quot;&gt;&quot;docker selenium&quot;&lt;/span&gt;)
driver.find_element_by_id(&lt;span class=&quot;st&quot;&gt;&quot;su&quot;&lt;/span&gt;).click()
sleep(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
driver.quit()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以运行测试了，通过 &lt;a href=&quot;http://localhost:4444/wd/hub&quot; class=&quot;uri&quot;&gt;http://localhost:4444/wd/hub&lt;/a&gt; 主节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python3 grid_demo.py&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;附加属性&quot;&gt;附加属性&lt;/h3&gt;
&lt;p&gt;相比于官方的docker-selenium，zalenium最直观的感受的就在此处。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/311516/201802/311516-20180210184234263-1462113667.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过浏览器后台执行Selenium总有一种不安全的感觉，zalenium可以将脚本的执行录制成视频，供你回放观看。不过，我这里提示：“没有找到支持的视频格式和MIME类型”也许是因为我的Ubuntu没有安装视频播放器。好在还有Logs可以查看。&lt;br/&gt;视频录制，默认在/tmp/videos文件夹可以找到保存的视频。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/311516/201802/311516-20180210184248841-1268716099.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当运行测试脚本的过程中，可以通过该页面观看脚本的执行过程，这功能还是666的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多用法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zalando.github.io/zalenium/#usage&quot; class=&quot;uri&quot;&gt;https://zalando.github.io/zalenium/#usage&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 10 Feb 2018 10:31:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/8439359.html</dc:identifier>
</item>
<item>
<title>【ASP.NET Core】给路由规则命名有何用处 - 东邪独孤</title>
<link>http://www.cnblogs.com/tcjiaan/p/8439178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tcjiaan/p/8439178.html</guid>
<description>&lt;p&gt;上一篇中老周给伙伴们介绍了自定义视图搜索路径的方法，本篇咱们扯一下有关 URL 路径规则的名称问题。在扯今天的话题之前，先补充点东东。在上一篇中设置视图搜索路径时用到三个有序参数：{2}{1}{0}，分别是 Area、Controller、Action。其中说到几个特殊的视图，如_Layout.cshtml、_ViewStart.cshtml等。_Layout.cshtml 页默认放在 /Views/Shared 目录下，但，_ViewStart.cshtml 和 _ViewImports.cshtml 这两个不应该放在 Shared 目录下，一般应放到 /Views 下，这样它们可以作用于所有的视图。如果放到了 Shared 目录下，它们只对 Shared 目录中的视图起作用，而对于 Views 下的其他视图不起作用。&lt;/p&gt;
&lt;p&gt;比如，放到 /Views 下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Views（目录）
    │  _ViewImports.cshtml
    │  _ViewStart.cshtml
    │  
    └─Home（目录，Controller的名字）
            Index.cshtml（视图，Action）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，Home 是子目录，对应着控制器 Home，Home 中的 Index.cshtml 视图对应着 Action 名 Index。此时，_ViewStart 和 _ViewImports 中的内容会应用到 /Views 下的所有视图中（如 Index.cshtml）。&lt;/p&gt;
&lt;p&gt;要是改为这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Views
    ├─Home
    │      About.cshtml
    │      Index.cshtml
    │      _ViewImports.cshtml
    │      _ViewStart.cshtml
    │      
    └─Users
            AddNew.cshtml&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，Views 有两个子目录，Home 是一个控制器，Users 是另一个控制器，这时候，_ViewStart 和 _ViewImports 只对 Home 下面的视图起作用，对 Users 目录下的视图是不起作用的。&lt;/p&gt;
&lt;p&gt;_ViewStart 主要用途是在所有视图文件执行之前执行，一般我们用它来设置 Layout 属性，以指定使用的布局页（相当于页面母板），这样一来，我们不需要在每个视图上都加 Layout = &quot;xxxx&quot; 了。_ViewImports 主要是用来引入要用到的命名空间（就是 C# 中的 using），这样你不需要在每个视图中写一堆 @using Razor 标记了。&lt;/p&gt;
&lt;p&gt;这两个文件都是约定式的，所以你不应该随便改它的名字，_ViewImports 可以通过 RazorTemplateEngineOptions 类的 ImportsFileName 属性来修改，不过，_ViewStart 好像不能改，老周看到 asp.net core 源码中是写死了的，估计是不能改文件名的。&lt;/p&gt;
&lt;p&gt;其实，这两个文件不应该改名，而且你改了名字也没啥用，反正功能是不变的，还是遵守约定好一些，这样人家看你的项目时也看得懂。_Layout.cshtml 文件如非必要，也不应该改名字，如果你的应用要用多个布局视图，可能建个子目录，然后每个子目录下放_Layout，这样结构清晰一些，毕竟，看到 _Layout.cshtml 就明白它是母板页了。&lt;/p&gt;

&lt;h2&gt;规则模板&lt;/h2&gt;
&lt;p&gt;我们都知道，在 Startup.Configure 方法中，会以此方式来指定 URL 路径规则。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            app.UseMvc(route =&amp;gt;&lt;span&gt;
            {
                route.MapRoute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Students}/{action=List}/{sid?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                route.MapRoute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;edit_post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller}-{action}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以添加 K 条规则，比如上面的例子，我添加了两条规则。&lt;/p&gt;
&lt;p&gt;{controller} 和 {action} 是约定的名称，用来识别 Controller 和 Action ，所以你不要自作聪明乱来，必要有些写死了的参数才能进行 URL 分析，不然，你给个 URL http://dog.org/shopping/pay/500，那应用程序根本不知道哪一段是表示 Controller，哪一段是表示 action。&lt;/p&gt;
&lt;p&gt;如果确定了 controller 和 action 这两个值，那么其他的参数就好分析了。&lt;/p&gt;
&lt;p&gt;其他参数如果是可选的，可以在后面加个问号，比如 {controller}/{action}/{id?}，这表示 id 的值是可选的。&lt;/p&gt;
&lt;p&gt;上面老周添加的两个规则中，edit_post 那个其实不太规范，URL 中各段最好用 “/” 来分隔，因为 “-” 有时候是不允许用的，比如，id 参数前面就不能用，你不能写成 {controller}-{action}-{id?}，要是 id 中包含了字符“-”，咋办呢？而“/”则不同，URL Encode 后不会冒出这个字符来。&lt;/p&gt;
&lt;p&gt;所以用 / 最好，这里用 - 只是老周故意用来演示而已，URL 嘛，没必要玩花样，没意义。&lt;/p&gt;

&lt;h2&gt;基于 Attribute 指定的 URL 路由&lt;/h2&gt;
&lt;p&gt;在 Startup.Configure 方法中指定的 URL 路由是作用于整个应用程序的，如果想为个别控制器或个别 Action 指定路由规则，那么可以考虑使用 Attribute 的形式。&lt;/p&gt;
&lt;p&gt;attribute 形式的路由规则和应用程序级别的规则相似，只是，在应用级别时，用大括号来包裹参数名（如 {controller}），而在 Attribute 方案中，是用中括号的，它只能用两个值：[controller]、[action]。其他参数也是用大括号。比如，[controlloer]/[action]/[id?] 会报错，你得改为 [controller]/[action]/{id?}。&lt;/p&gt;
&lt;p&gt;RouteAttribute 既可以用于 Controller 类型，也可能用于单个 Action 方法上。我举个例子，像这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello/[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SomethingController : Controller
    {
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{name?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult SayHi(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            ……
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在类上应用用的 Attribute 中，可以使用这样的 URL ：http://localhost:999/hello/something/sayhi 。而在 SayHi 方法上，又用了 Route Attribute，指定了一个附加参数 name，并且是可选的。于是它可以与类上的 Route attribute 合并，变成：http://localhost:999/hello/something/sayhi/Peter。这时，字符串 Peter 会传给 SayHi 方法的 name 参数，因为，参数的名字与 Route 中的参数名是相同的，都叫 name。如果 SayHi 中的参数名不叫 name，那你得运用一下 FromRouteAttribute 了。就像这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{name?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult SayHi(&lt;em&gt;&lt;strong&gt;[FromRoute(Name =&lt;/strong&gt; &lt;/em&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]&lt;span&gt;string&lt;/span&gt;&lt;span&gt; who)
        {
            ……
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你希望 URL 中给 name 传入 int 类型的值，你还可以限制它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{name:int}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实这些约束条件对应的是 Microsoft.AspNetCore.Routing.Constraints 命名空间下面的类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/367389/201802/367389-20180210174145607-1707439419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Route Data&lt;/h2&gt;
&lt;p&gt;Route data 其实就是一个字典，存放的就是 URL 路径规则中参数与值的 key-value 对。这个很简单，我举个例子，你就明白了。&lt;/p&gt;
&lt;p&gt;咱们就直接用上面那个例子吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello/[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SomethingController : Controller
    {
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{name?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult SayHi([FromRoute(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]&lt;span&gt;string&lt;/span&gt;&lt;span&gt; who)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Json(RouteData.Values);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 SayHi 方法中，咱们把 route data 返回。&lt;/p&gt;
&lt;p&gt;运行应用后，输入地址：http://localhost/hello/something/sayhi/Tom，得到的输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/367389/201802/367389-20180210175148357-681766865.png&quot; alt=&quot;&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不用我解释了吧。&lt;/p&gt;

&lt;h2&gt;给路由命名&lt;/h2&gt;
&lt;p&gt;上面的都是 F 话，本小节才是本文的主题。我们回头看看上面老周举过例的那个 route。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            app.UseMvc(route =&amp;gt;&lt;span&gt;
            {
                route.MapRoute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Students}/{action=List}/{sid?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                route.MapRoute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;edit_post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller}-{action}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每条路由规则都会有自己的 name，为啥要命名？最直接的理由是为了唯一标识每条规则。除了此因素外，我们可以在开发过程中选择使用哪条规则，有了 name，想找出某条规则就好办了，就好比你上学的时候，老师点名，要么点姓名，要么点学号。&lt;/p&gt;
&lt;p&gt;基于 Attribute 的路由规则也可以命名的，例如。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello/[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就把它命名为 prv 了，你还可以这样写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello/[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;em&gt;&lt;strong&gt;Name =&lt;/strong&gt; &lt;/em&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[controller]_[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样也可以用 Controller 和 Action 的名字生成一个唯一的名字，比如 Something_SayHi。但是这种方法太动态了，好像不那么好操控，还是用一个固定的名字好一点。&lt;/p&gt;
&lt;p&gt;要在开发的时候选择使用指定的 URL 路由，需要在 Razor 页中添加 Tag Helper，标记帮助类可以扩展 HTML 标记的某些功能。在需要使用 tag helper 的页面，或者统一在 _ViewImports.cshtml 页中加入这些指令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;@addTagHelper&lt;/strong&gt; *, Microsoft.AspNetCore.Mvc.TagHelpers
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;格式是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;类型全路径&amp;gt;, &amp;lt;程序集&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类型写在前面（包括 namespace 名），程序集名写在后面，用逗号分隔。这里用星号（*）是最爽的，它是通配符，表示引入所有 tag helper 类型。这样快捷，一行代码了事。&lt;/p&gt;
&lt;p&gt;然后在 HTML 中你这样写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;
          asp-route&lt;/span&gt;&lt;span&gt;=&quot;edit_post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/strong&gt;&lt;/em&gt;        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;asp-for&lt;/span&gt;&lt;span&gt;=&quot;Name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;asp-for&lt;/span&gt;&lt;span&gt;=&quot;Name&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;asp-validation-for&lt;/span&gt;&lt;span&gt;=&quot;Name&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;text-danger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;asp-for&lt;/span&gt;&lt;span&gt;=&quot;Age&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;asp-for&lt;/span&gt;&lt;span&gt;=&quot;Age&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;asp-validation-for&lt;/span&gt;&lt;span&gt;=&quot;Age&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;text-danger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;asp-for&lt;/span&gt;&lt;span&gt;=&quot;ID&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-dark&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他代码你不用看了，只看这一句就够了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 asp-route=&quot;edit_post&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的意思就是使用我刚刚定义的那条规则。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 route.MapRoute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;edit_post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller}-{action}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，在运行后就会生成这样的 HTML。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt; action&lt;/span&gt;&lt;span&gt;=&quot;/Students-Editdata&quot;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            此处省略 1650 个字
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我定义的规则是 {controller}-{action}的形式，所以，Controller 是 Students，Action 是 Editdata，连起来就是 Students-Editdata。&lt;/p&gt;
&lt;p&gt;那么，这里它为什么能识别出 controller 和 action 的值呢，你看看我的代码就知道了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentsController : Controller
    {
        &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; StudentDBContext m_context;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收依赖注入&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; StudentsController(StudentDBContext c)
        {
            m_context &lt;/span&gt;=&lt;span&gt; c;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult List()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; q = &lt;span&gt;from&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt;&lt;span&gt; m_context.Students
                    &lt;/span&gt;&lt;span&gt;orderby&lt;/span&gt;&lt;span&gt; s.ID
                    &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; s;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(q.ToList());
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下方法用于编辑页&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Editdata([FromRoute(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)] &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; q = &lt;span&gt;from&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt;&lt;span&gt; m_context.Students
                    &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; id ==&lt;span&gt; s.ID
                    &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; s;
            Student stu &lt;/span&gt;=&lt;span&gt; q.FirstOrDefault();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(stu == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Content(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在地球上找不到此学员。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(stu);
        }

        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Editdata(Student s)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ModelState.IsValid == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(s);
            }
            m_context.Students.Update(s);
            m_context.SaveChanges();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; RedirectToAction(nameof(List));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我定义了 Editdata 方法的重载，一个用于 get 请求，一个用于 post 请求，form 是以 post 方式提交，因此它能自动识别出 controller 和 action 的名字。&lt;/p&gt;
&lt;p&gt;那万一，如果不是同名的呢，好办。你用 asp-route-&amp;lt;value&amp;gt; 来指定各个参数的值。比如这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;
          asp-route&lt;/span&gt;&lt;span&gt;=&quot;edit_post&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
          asp-route-controller&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;=&quot;Demo&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
          asp-route-action&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;=&quot;Runwork&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
          asp-route-sid&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 asp-route- 后面直接跟上路由规则参数的名称就可以了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;有一点要注意，asp-route 与 asp-controller、asp-action是会冲突的，如果你用了这两个标记，就不能用 asp-route 标记了，当然 asp-route-xxx 是可以用的。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;好了，今天的内容就扯到这儿了，顺便把示例的代码也传上来，以供伙伴们娱乐。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/tcjiaan/NamedRouteSample.zip&quot; target=&quot;_blank&quot;&gt;示例源代码下载地址&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 10 Feb 2018 10:28:00 +0000</pubDate>
<dc:creator>东邪独孤</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tcjiaan/p/8439178.html</dc:identifier>
</item>
<item>
<title>JMeter生成HTML性能报告 - 测试小小小白</title>
<link>http://www.cnblogs.com/spl-/p/8439349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/spl-/p/8439349.html</guid>
<description>&lt;p&gt;有时候我们写性能报告的时候需要一些性能分布图，JMeter是可以生成HTML性能报告的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、准备工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1：&lt;strong&gt;jmeter3.0&lt;/strong&gt;&lt;strong&gt;版本&lt;/strong&gt;之后开始支持动态生成测试报表&lt;/p&gt;
&lt;p&gt;2：&lt;strong&gt;jdk&lt;/strong&gt;版本&lt;strong&gt;1.7&lt;/strong&gt;以上&lt;/p&gt;
&lt;p&gt;3：需要jmx脚本文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、基本操作步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先执行cmd命令：进入jmeter的安装目录bin目录里面&lt;/p&gt;

&lt;p&gt;输入命令：jmeter&lt;strong&gt; -n -t 目录&lt;/strong&gt; test.jmx &lt;strong&gt;-l&lt;/strong&gt; result.jtl&lt;strong&gt; &lt;em&gt;-e -o&lt;/em&gt;&lt;/strong&gt; 目录/tmp/ResultReport&lt;/p&gt;
&lt;p&gt;举个栗子：jmeter -n -t &lt;strong&gt;D:\apache-jmeter-3.2\bin\yqjr.jmx&lt;/strong&gt; -l &lt;strong&gt;result.jtl&lt;/strong&gt; -e -o &lt;strong&gt;D:\apache-jmeter-3.2\bin\HttpReport&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;● -n: 非GUI模式执行JMeter&lt;br/&gt;● -t: 执行测试文件所在的位置&lt;br/&gt;● -l: 指定生成测试结果的保存文件，jtl文件格式&lt;br/&gt;● -e: 测试结束后，生成测试报告&lt;br/&gt;● -o: 指定测试报告的存放位置&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这段命令中，第一处标粗的是我的接口脚本跟路径，第二处标粗的是自动生成的&lt;span lang=&quot;EN-US&quot;&gt;jtl文件，第三处标粗的是报告文件夹路径，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;这一段命令在&lt;span lang=&quot;EN-US&quot;&gt;cmd下执行命令即可（注意，必须在脚本文件路径下执行&lt;span lang=&quot;EN-US&quot;&gt;cmd，否则需要&lt;span lang=&quot;EN-US&quot;&gt;cmd下执行切换路径）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;结尾的 &lt;strong&gt;ResultReport&lt;/strong&gt; 是自己手动创建的报告文件夹。每次启动命令之前，文件夹内容必须和 &lt;strong&gt;jtl&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;文件一起清空&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、执行结果成功图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331615/201802/1331615-20180210181315888-859990002.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、查看报告&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在生成的目录里面查找以.HTNL   打开&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331615/201802/1331615-20180210181441232-953873501.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;生生的报告如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331615/201802/1331615-20180210181618295-227852918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;五、彩蛋哦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前考虑过每次执行命令都要先去目录下清空报告文件夹和&lt;span lang=&quot;EN-US&quot;&gt;jtl，还要敲命令，很烦，后来想了一个方法，那就是写一个&lt;span lang=&quot;EN-US&quot;&gt;bat，每次执行&lt;span lang=&quot;EN-US&quot;&gt;bat都自动去清空之前的报告，然后执行命令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 命令如下：&lt;/p&gt;
&lt;p&gt;del  /s /Q D:\apache-jmeter-3.2\bin\result.jtl          &lt;strong&gt;删除result.jtl文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rd /s /Q D:\apache-jmeter-3.2\bin\HttpReport          &lt;strong&gt;删除HttpReport文件夹&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;md D:\apache-jmeter-3.2\bin\HttpReport              &lt;strong&gt;重建HttpReport文件夹&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;栗子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1331615/201802/1331615-20180210181833841-762016217.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;今天的文章到此结束，是不是又学会一招呢   关注我 随时更新...&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 10 Feb 2018 10:21:00 +0000</pubDate>
<dc:creator>测试小小小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/spl-/p/8439349.html</dc:identifier>
</item>
<item>
<title>在高并发、高负载的情况下，如何给表添加字段并设置DEFAULT值？ - ^_^小麦苗^_^</title>
<link>http://www.cnblogs.com/lhrbest/p/8439345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lhrbest/p/8439345.html</guid>
<description>&lt;hr/&gt;&lt;hr/&gt;

&lt;p&gt;在&lt;span&gt;Oracle 12c&lt;/span&gt;之前，当&lt;span&gt;Oracle&lt;/span&gt;表数据量上亿时，对表执行“&lt;span&gt;ALTER TABLE XXX ADD COLUMN_XX VARCHAR2(2) DEFAULT 'XXX';&lt;/span&gt;”操作时，效率及安全性是必须要考虑的因素。若直接执行，则会在该过程中给表加上&lt;span&gt;6&lt;/span&gt;级表锁，也就是连查询都需要等待，这在生产库上是相当危险的操作。因为&lt;span&gt;Oracle&lt;/span&gt;在执行上述操作过程中，不仅要更新数据字典，还会刷新全部的记录，并且会使得&lt;span&gt;Undo&lt;/span&gt;表空间暴涨，所以，正确的做法是将更新数据字典和更新字段值分开。&lt;/p&gt;
&lt;p&gt;例如，表&lt;span&gt;LKILL.T_KILL&lt;/span&gt;约有&lt;span&gt;4500W&lt;/span&gt;的数据，直接添加一个字段&lt;span&gt;C_LHR&lt;/span&gt;需要花费&lt;span&gt;21&lt;/span&gt;分钟，如下所示：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;12:20:17 SYS@RACLHR2&amp;gt; ALTER TABLE LKILL.T_KILL ADD C_LHR VARCHAR2(100) DEFAULT 'LHR';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table altered.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Elapsed: 00:21:58.53&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;若修改为如下的方式，则可以显著提高这个操作的性能，但表中原有的记录对于新添加的列为空，新增记录默认值会设置为&lt;span&gt;LHR&lt;/span&gt;，那么原有记录的默认值就需要在系统空闲的时候进行批量更新、批量提交或采用系统包&lt;span&gt;DBMS_PARALLEL_EXECUTE&lt;/span&gt;来更新，这样不至于大批量锁表，请参考本书中分批更新的部分【 &lt;span&gt;REF _Ref24783 \n \h&lt;/span&gt; &lt;span&gt;3.1.10.5&lt;/span&gt; &lt;span&gt;REF _Ref24783 \h&lt;/span&gt; 分批插入、分批更新、分批删除、分批提交】。如下所示：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;12:42:17 SYS@RACLHR2&amp;gt; ALTER TABLE LKILL.T_KILL ADD A_LHR VARCHAR2(100);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table altered.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Elapsed: 00:00:00.35&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;13:53:54 SYS@RACLHR2&amp;gt; ALTER TABLE LKILL.T_KILL MODIFY A_LHR VARCHAR2(100) DEFAULT 'LHR';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table altered.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Elapsed: 00:00:00.06&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;需要注意的是，从&lt;span&gt;Oracle 11g&lt;/span&gt;开始，当添加一个带有默认值的非空列时（注意&lt;span&gt;2&lt;/span&gt;个条件，&lt;span&gt;NOT NULL&lt;/span&gt;和默认值），&lt;span&gt;Oracle&lt;/span&gt;不会使用这个默认值来物理更新现有存在的行，&lt;span&gt;Oracle&lt;/span&gt;只会存储这个新列元数据（&lt;span&gt;NOT NULL&lt;/span&gt;约束和&lt;span&gt;DEFAULT&lt;/span&gt;默认值），从而使得对该表的添加带有默认值的非空列操作可以在瞬间完成。当然，从表中检索该列时，会有部分的&lt;span&gt;NVL&lt;/span&gt;函数代价。具体的细微差别可以通过&lt;span&gt;10046&lt;/span&gt;事件来分析，这里不再详细解析。&lt;/p&gt;
&lt;p&gt;从&lt;span&gt;Oracle 12c&lt;/span&gt;开始，支持具有默认值的空列的添加列的&lt;span&gt;DDL&lt;/span&gt;语句优化，即如下&lt;span&gt;2&lt;/span&gt;条&lt;span&gt;SQL&lt;/span&gt;语句的效率是一样的，也不存在锁表的现象了：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;ALTER TABLE LKILL.T_KILL ADD A_LHR VARCHAR2(100);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ALTER TABLE LKILL.T_KILL ADD A_LHR VARCHAR2(100) NOT NULL;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;示例如下所示：&lt;/p&gt;
&lt;div readability=&quot;42&quot;&gt;
&lt;p&gt;&lt;span&gt;LHR@OCPLHR1&amp;gt; select * from v$version where rownum&amp;lt;=1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BANNER&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@OCPLHR1&amp;gt; set time on&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;16:59:00 LHR@OCPLHR1&amp;gt; set timing on&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;16:59:08 LHR@OCPLHR1&amp;gt; CREATE TABLE t1 AS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;16:59:21   2  SELECT ROWNUM N1,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;16:59:21   3         TRUNC((ROWNUM - 1) / 3) N2,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;16:59:21   4         TRUNC(DBMS_RANDOM.VALUE(ROWNUM, ROWNUM * 10)) N3,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;16:59:21   5         DBMS_RANDOM.STRING('U', 10) cl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;16:59:21   6    FROM DUAL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;16:59:21   7  CONNECT BY LEVEL &amp;lt;= 200000;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table created.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:05.72&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;16:59:45 LHR@OCPLHR1&amp;gt; SELECT d.bytes FROM user_segments d WHERE d.segment_name='T1';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     BYTES&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   7340032&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.09&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;17:01:00 LHR@OCPLHR1&amp;gt; ALTER TABLE t1 ADD c_ddl NUMBER DEFAULT 666 ;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table altered.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Elapsed: 00:00:25.29&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;17:02:07 LHR@OCPLHR1&amp;gt; SELECT d.bytes FROM user_segments d WHERE d.segment_name='T1';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     BYTES&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   8388608&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;17:02:13 LHR@OCPLHR1&amp;gt; ALTER TABLE t1 ADD c_ddl2 NUMBER DEFAULT 888 not null;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table altered.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Elapsed: 00:00:00.08&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;17:02:37 LHR@OCPLHR1&amp;gt; SELECT d.bytes FROM user_segments d WHERE d.segment_name='T1';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     BYTES&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   8388608&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.01&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;可以看出，在&lt;span&gt;Oracle 11g&lt;/span&gt;中，加了&lt;span&gt;NOT NULL&lt;/span&gt;约束的&lt;span&gt;SQL&lt;/span&gt;语句，可以在瞬间完成添加列的操作，而只设置了默认值的&lt;span&gt;SQL&lt;/span&gt;语句使用了&lt;span&gt;25&lt;/span&gt;秒的时间。另外，加了&lt;span&gt;NOT NUL&lt;/span&gt;约束的&lt;span&gt;SQL&lt;/span&gt;语句执行完毕后，表的大小没有变化，这也说明了&lt;span&gt;Oracle&lt;/span&gt;并没有做物理更新。&lt;/p&gt;
&lt;p&gt;下面查看其执行计划，注意在这里不要使用“&lt;span&gt;SET AUTOT ON&lt;/span&gt;”的方式，否则不能看到其真实的执行计划：&lt;/p&gt;
&lt;div readability=&quot;55&quot;&gt;
&lt;p&gt;&lt;span&gt;17:05:30 LHR@OCPLHR1&amp;gt; SELECT COUNT(*) FROM t1 WHERE c_ddl2=888;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  COUNT(*)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    200000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.02&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;17:05:39 LHR@OCPLHR1&amp;gt; select  * from table(dbms_xplan.display_cursor);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PLAN_TABLE_OUTPUT&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL_ID  bq50v8z914juk, child number 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SELECT COUNT(*) FROM t1 WHERE c_ddl2=888&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Plan hash value: 3724264953&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;---------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |&lt;/p&gt;
&lt;p&gt;---------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;|   0 | SELECT STATEMENT   |      |       |       |   282 (100)|          |&lt;/p&gt;
&lt;p&gt;|   1 |  SORT AGGREGATE    |      |     1 |    13 |            |          |&lt;/p&gt;
&lt;p&gt;|*  2 |   TABLE ACCESS FULL| T1   |   199K|  2530K|   282   (2)| 00:00:04 |&lt;/p&gt;
&lt;p&gt;---------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Predicate Information (identified by operation id):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2 - filter(NVL(&quot;C_DDL2&quot;,888)=888)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Note&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-----&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   - dynamic sampling used for this statement (level=2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;23 rows selected.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;17:08:55 LHR@OCPLHR1&amp;gt; SELECT * FROM t1 WHERE rownum&amp;lt;=1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        N1         N2         N3 CL              C_DDL     C_DDL2&lt;/p&gt;
&lt;p&gt;---------- ---------- ---------- ---------- ---------- ----------&lt;/p&gt;
&lt;p&gt;         1          0          8 XYGGZXRRYR        666        888&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;可以看到，在谓词部分出现了&lt;span&gt;NVL&lt;/span&gt;函数。所以，&lt;span&gt;Oracle&lt;/span&gt;认为&lt;span&gt;C_DDL2&lt;/span&gt;列是空列。&lt;/p&gt;
&lt;p&gt;下面测试是否可以使用索引：&lt;/p&gt;
&lt;div readability=&quot;58&quot;&gt;
&lt;p&gt;&lt;span&gt;17:29:24 LHR@OCPLHR1&amp;gt; CREATE INDEX idx_c_ddl2 ON t1(c_ddl2);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Index created.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.71&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;17:31:08 LHR@OCPLHR1&amp;gt; update t1 set c_ddl2='8881' where rownum&amp;lt;=1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 row updated.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.05&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;17:31:13 LHR@OCPLHR1&amp;gt; commit;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Commit complete.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.00&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;17:31:16 LHR@OCPLHR1&amp;gt; SELECT * FROM t1 WHERE c_ddl2=8881;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        N1         N2         N3 CL              C_DDL     C_DDL2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------- ---------- ---------- ---------- ---------- ----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         1          0          8 XYGGZXRRYR        666       8881&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;17:31:24 LHR@OCPLHR1&amp;gt; select  * from table(dbms_xplan.display_cursor);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PLAN_TABLE_OUTPUT&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL_ID  0sm5s7zkvycrq, child number 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SELECT * FROM t1 WHERE c_ddl2=8881&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Plan hash value: 1464185165&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;| Id  | Operation                   | Name       | Rows  | Bytes | Cost (%CPU)| Time     |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;|   0 | SELECT STATEMENT            |            |       |       |     2 (100)|          |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;|   1 |  TABLE ACCESS BY INDEX ROWID| T1         |     1 |    34 |     2   (0)| 00:00:01 |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;|*  2 |   INDEX RANGE SCAN          | IDX_C_DDL2 |     1 |       |     1   (0)| 00:00:01 |&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Predicate Information (identified by operation id):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2 - access(&quot;C_DDL2&quot;=8881)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;19 rows selected.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.11&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;令人惊喜的是，使用了索引。&lt;/p&gt;
&lt;p&gt;下面看看在&lt;span&gt;Oracle 12c&lt;/span&gt;中的执行情况：&lt;/p&gt;
&lt;div readability=&quot;152&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt; set line 120&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt; select * from v$version where rownum&amp;lt;=1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BANNER                                                                               CON_ID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-------------------------------------------------------------------------------- ----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production              0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.00&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt; CREATE TABLE t1 AS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2  SELECT ROWNUM N1,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  3         TRUNC((ROWNUM - 1) / 3) N2,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  4         TRUNC(DBMS_RANDOM.VALUE(ROWNUM, ROWNUM * 10)) N3,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       DBMS_RANDOM.STRING('U', 10) cl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  6    FROM DUAL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  7  CONNECT BY LEVEL &amp;lt;= 100000;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table created.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:09.41&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt; SELECT d.bytes FROM user_segments d WHERE d.segment_name='T1';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     BYTES&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   4194304&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.33&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt;  ALTER TABLE t1 ADD c_ddl NUMBER DEFAULT 666 ;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table altered.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.65&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt; SELECT d.bytes FROM user_segments d WHERE d.segment_name='T1';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     BYTES&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   4194304&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.14&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt; ALTER TABLE t1 ADD c_ddl2 NUMBER DEFAULT 888 not null;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Table altered.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.15&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt; SELECT d.bytes FROM user_segments d WHERE d.segment_name='T1';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     BYTES&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   4194304&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.09&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt; SELECT COUNT(*) FROM t1 WHERE c_ddl2=888;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  COUNT(*)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    100000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.02&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt;  select  * from table(dbms_xplan.display_cursor);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PLAN_TABLE_OUTPUT&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-----------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL_ID  bq50v8z914juk, child number 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SELECT COUNT(*) FROM t1 WHERE c_ddl2=888&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Plan hash value: 3724264953&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;|   0 | SELECT STATEMENT   |      |       |       |   122 (100)|          |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;|   1 |  SORT AGGREGATE    |      |     1 |    13 |            |          |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;|*  2 |   TABLE ACCESS FULL| T1   |   100K|  1269K|   122   (1)| 00:00:01 |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Predicate Information (identified by operation id):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2 - filter(NVL(&quot;C_DDL2&quot;,888)=888)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Note&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-----&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   - statistics feedback used for this statement&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;23 rows selected.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.05&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt; SELECT COUNT(*) FROM t1 WHERE c_ddl=666;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  COUNT(*)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    100000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.04&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt;  select  * from table(dbms_xplan.display_cursor);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PLAN_TABLE_OUTPUT&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;------------------------------------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL_ID  dph2gfp6f0jja, child number 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SELECT COUNT(*) FROM t1 WHERE c_ddl=666&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Plan hash value: 3724264953&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;|   0 | SELECT STATEMENT   |      |       |       |   122 (100)|          |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;|   1 |  SORT AGGREGATE    |      |     1 |    13 |            |          |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;|*  2 |   TABLE ACCESS FULL| T1   |  1000 | 13000 |   122   (1)| 00:00:01 |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Predicate Information (identified by operation id):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;---------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   2 - filter(DECODE(TO_CHAR(SYS_OP_VECBIT(&quot;SYS_NC00005$&quot;,0)),NULL,NVL(&quot;&lt;/p&gt;
&lt;p&gt;              C_DDL&quot;,666),'0',NVL(&quot;C_DDL&quot;,666),'1',&quot;C_DDL&quot;)=666)&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;20 rows selected.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt; SELECT d.column_name, d.column_id,d.hidden_column,d.virtual_column FROM Dba_Tab_Cols d  WHERE d.table_name='T1' order by column_id;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;COLUMN_NAME      COLUMN_ID HID VIR&lt;/p&gt;
&lt;p&gt;--------------- ---------- --- ---&lt;/p&gt;
&lt;p&gt;N1                       1 NO  NO&lt;/p&gt;
&lt;p&gt;N2                       2 NO  NO&lt;/p&gt;
&lt;p&gt;N3                       3 NO  NO&lt;/p&gt;
&lt;p&gt;CL                       4 NO  NO&lt;/p&gt;
&lt;p&gt;C_DDL                    5 NO  NO&lt;/p&gt;
&lt;p&gt;C_DDL2                   6 NO  NO&lt;/p&gt;
&lt;p&gt;SYS_NC00005$               YES NO&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7 rows selected.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elapsed: 00:00:00.32&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LHR@lhr121&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;从示例可以清楚地看到，在&lt;span&gt;Oracle 12c&lt;/span&gt;中，添加具有默认值的&lt;span&gt;DDL&lt;/span&gt;优化已扩展到包括默认值的空列。&lt;span&gt;Oracle&lt;/span&gt;使用了一个未公开的函数&lt;span&gt;SYS_OP_VECBIT&lt;/span&gt;和新的隐藏列&lt;span&gt;SYS_NC00005$&lt;/span&gt;，因为该列没有被物理更新。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有关批量更新和&lt;span&gt;DBMS_PARALLEL_EXECUTE&lt;/span&gt;的使用更详细的内容可以参考我的&lt;span&gt;BLOG&lt;/span&gt;：&lt;span&gt;① http://blog.itpub.net/26736162/viewspace-2140626/ ②http://blog.itpub.net/26736162/viewspace-1684396&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;hr/&gt;&lt;hr/&gt;


</description>
<pubDate>Sat, 10 Feb 2018 10:18:00 +0000</pubDate>
<dc:creator>^_^小麦苗^_^</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lhrbest/p/8439345.html</dc:identifier>
</item>
<item>
<title>数据分区------《Designing Data-Intensive Applications》读书笔记9 - HappenLee</title>
<link>http://www.cnblogs.com/happenlee/p/8439325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/happenlee/p/8439325.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;进入到第六章了，我们要开始聊聊分布式系统之中的核心问题：&lt;strong&gt;数据分区&lt;/strong&gt;。分布式系统通常是通过大规模的数据节点来处理单机没有办法处理的海量数据集，因此，可以将一个大型数据集可以分布在多个磁盘上，查询负载可以分布在多个处理器上。在这一章中，我们首先讨论划分大型数据集的不同方法，并观察数据索引如何与分区交互，然后将探索数据分区重新平衡的策略。最后，来看看路由技术怎么将查询索引到正确的分区。内容看起来还不少，我们开始吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;分区与副本&quot;&gt;1. 分区与副本&lt;/h3&gt;
&lt;p&gt;分区与副本是很容易混淆的概念，我们这里离清一下两者。&lt;br/&gt;数据分区的每个副本可以存储在多个节点上。这意味着，即使每个记录恰好属于一个分区，它仍然可以存储在几个不同的节点上进行容错。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-4c36370f0b774f7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;数据分区与副本的关系：&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看出，分区和副本是需要解决不同问题的，并不能混为一谈，两者同样作为分布式系统之中的核心技术，共同为分布式系统提供好的解决方案。&lt;/p&gt;
&lt;h3 id=&quot;分区策略&quot;&gt;2. 分区策略&lt;/h3&gt;
&lt;p&gt;数据分区的目的是：&lt;strong&gt;将数据和查询负载均匀地分布在节点上。&lt;/strong&gt;（&lt;strong&gt;其实副本也有同样的效果，取决于副本同步机制&lt;/strong&gt;）而如果数据分区不公平，则会出现某些分区的数据或查询比其他分区要多，我们称之为&lt;strong&gt;偏斜&lt;/strong&gt;。数据偏斜就使得分区效果变差，导致负载不均衡形成分区热点。 所以分区策略通常以分区均匀为考量，接下来我们介绍几种常见的分区策略：&lt;/p&gt;
&lt;h4 id=&quot;范围分区&quot;&gt;范围分区&lt;/h4&gt;
&lt;p&gt;范围分区是分配一个连续的范围键，如同几册百科全书一般。如果知道范围之间的边界，就可以很容易地确定哪个分区包含给定的键。如果您还知道哪个分区被分配到哪个节点，那么您可以直接将请求发送到适当的节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-229e6d58f107edb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;多册百科全书按照范围分册&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是很多时候键的范围不一定是&lt;strong&gt;均匀分布&lt;/strong&gt;的，为了均匀地分布数据，分区边界需要和数据的特点相适应。对于每一个分区，我们可以把按键顺序排列，如&lt;strong&gt;SSTable&lt;/strong&gt;，显然这样可以大幅提升范围扫描的效率。&lt;/p&gt;
&lt;p&gt;而范围分区的缺点是某些访问模式会导致&lt;strong&gt;热点&lt;/strong&gt;。如果某个范围的键频繁被访问，将导致某个分区的读写量遥遥领先，而其他分区被闲置。（&lt;strong&gt;这种情况考虑细分分区粒度或者级联索引，用一个较均匀的特征先做一次分区&lt;/strong&gt;）&lt;/p&gt;
&lt;h4 id=&quot;哈希分区&quot;&gt;哈希分区&lt;/h4&gt;
&lt;p&gt;由于范围分区容易产生热点问题，许多分布式数据存储使用一个哈希函数来确定一个键值的分区。一个好的哈希函数可以将倾斜的数据均匀分布，即使数据范围很接近，但是它们的哈希值是均匀分布的值。如下图所示，时间接近的键值被哈希函数均匀的分区在多个分区，每个键的哈希值落在一个分区的范围将被存储在该分区：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-2eb099967364c172.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;哈希分区&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用哈希分区，我们失去了键范围分区的一个很好的特性，曾经相邻的键现在分散在所有分区上，因此它们的排序顺序丢失。我们可以通过&lt;strong&gt;级联索引&lt;/strong&gt;的方式解决这个问题。级联索引方法支持一对多关系的优雅的数据模型，通过两分区方式来综合不同分区方式的优点，通过键哈希来确定分区的第一部分，但其他列作为SSTables的数据排序串联。因此，查询不能在复合键的第一列内搜索范围内的值，但是如果它为第一列指定一个固定值，它就可以在键的其他列上执行有效的范围扫描。例如，在社交媒体站点上，一个用户可以发布许多更新。如果更新主键（user_id，update_timestamp），那么你可以有效地检索在一定时间间隔内特定用户的所有更新。不同的用户可以存储在不同的分区上，但是在每个用户中，更新是在单个分区上以时间戳顺序存储的。&lt;/p&gt;
&lt;h5 id=&quot;tip缓解热点&quot;&gt;Tip：缓解热点&lt;/h5&gt;
&lt;p&gt;通过哈希函数分区的确有助于减少热点。然而，它不能完全避免它们：在极端情况下，所有读写操作都是相同的键，最终仍然会将所有请求到同一分区。例如，在社交媒体网站上，一个拥有数百万追随者的名人用户在做某事时可能会引发一场读写风暴。此事件可能导致短时间内大量写入同一个键（其中的Key可能是名人的用户ID，或者是人们评论的行为ID）。这时哈希函数也无能为力，因为两个相同ID的哈希值仍然相同。&lt;/p&gt;
&lt;p&gt;大多数数据系统不能自动补偿这种高度倾斜的工作负载，因此应用程序有责任减少偏斜。例如，如果已知一个键非常热，一个简单的方法就是在键的开头或结尾加上一个随机数。只有一个两位数的十进制随机数将把写入分成100个不同的键，允许这些键被分配到不同的分区。但是将不同的键分开写入后，现在任何读取都必须做额外的工作，因为它们必须从所有100个键读取数据并将其组合起来。而且这种方式还需要额外的记录：因为只为少量的热键添加随机数是有意义的；对于绝大多数具有低写入吞吐量的键，这将是不必要的开销。因此，还需要一些方法来跟踪哪些键正在被分割。&lt;/p&gt;
&lt;h3 id=&quot;分区与二级索引&quot;&gt;2. 分区与二级索引&lt;/h3&gt;
&lt;p&gt;上文讨论的分区方案依赖于一个关键值数据模型。通过主键访问记录，可以由该键确定分区，并使用它将读取和写入请求路由到负责该键的分区。&lt;/p&gt;
&lt;p&gt;而一旦涉及到&lt;strong&gt;二级索引&lt;/strong&gt;，情况会变得更加复杂。二级索引通常不确定记录的唯一性而应该是寻找一个特定的值出现的方式如：&lt;em&gt;找到所有颜色是红色的车&lt;/em&gt; 这样的查询。二级索引的问题是它不能映射到分区。有两种主要方法将数据库分为二级索引：基于分区的索引和基于全局的索引。&lt;/p&gt;
&lt;h4 id=&quot;基于分区的索引&quot;&gt;基于分区的索引&lt;/h4&gt;
&lt;p&gt;假如有一个卖二手车的网站，每个列表都有一个唯一的ID，称之为文档。通过文档id（例如，分区0中的IDS 0到499、分区1中的IDS 500到999）对数据库进行分区。&lt;br/&gt;您希望让用户搜索汽车，允许它们按颜色和按颜色进行过滤，因此需要对颜色进行二级索引索引，每当一辆红色的车是添加到数据库中，数据库分区自动添加到索引的文档的ID到红色索引处。如下图所示：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-e4d95a38f88666ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;基于分区的索引&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这种索引方法中，每个分区都是完全独立的，每个分区都保留自己的索引，只覆盖分区中的文档id。它不关心存储在其他分区中的数据。每当您需要向数据库写入添加、删除或更新文档时，只需要处理包含您正在编写的文档ID的分区。&lt;/p&gt;
&lt;p&gt;但是，从索引读取时需要注意，如果您想搜索红色的汽车，您需要将查询发送到所有分区，并&lt;strong&gt;将所有返回的结果组合&lt;/strong&gt;起来。这样导致了二级索引上的读取查询非常耗时。即使并行的写入和查询分区，分散/聚集操作会导致延迟放大。&lt;/p&gt;
&lt;h4 id=&quot;基于全局的索引&quot;&gt;基于全局的索引&lt;/h4&gt;
&lt;p&gt;上节提到分区索引的缺点，所以我们可以建立一个全局的索引，涵盖所有的分区数据。但是，不能只存储索引在一个节点，因为它可能会成为一个瓶颈和故障点。所以全局索引也必须被分区，但它可以划分不同的主键索引。如下图所示：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-920f50209c155aea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;全局索引的索引分区&quot;/&gt;&lt;br/&gt;全局索引使读操作更加高效：而不用分散/聚集所有分区的数据。但全球索引的缺点是，写入速度较慢，更复杂，因为写一个文件现在可以影响指数的多个分区。（&lt;strong&gt;文件中的每一项可能会在不同的分区，在不同的节点上，在实践之中，二级全局索引通常通过异步的方式进行更新&lt;/strong&gt;）。&lt;/p&gt;
&lt;h3 id=&quot;分区平衡&quot;&gt;3 分区平衡&lt;/h3&gt;
&lt;p&gt;随着时间的推移，数据库中的东西发生了变化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1) 查询吞吐量增加，因此您需要添加更多CPU来处理负载。&lt;/li&gt;
&lt;li&gt;(2) 数据集大小增加，所以您需要添加更多的磁盘和RAM来存储它。&lt;/li&gt;
&lt;li&gt;(3) 机器故障，其他机器需要接管故障机器的责任。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所有这些变化都要求将数据和请求从一个节点移动到另一个节点。而负载从集群中的一个节点转移到另一个节点的过程称为&lt;strong&gt;分区平衡&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;无论采用哪种分区方案，通常都希望分区平衡以满足下面的要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1) 重新平衡后，集群中的节点之间应该公平地共享负载（&lt;strong&gt;数据存储、读写请求&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;(2) 当分区平衡工作时，数据库应该继续接受读写操作。&lt;/li&gt;
&lt;li&gt;(3) 在节点之间移动尽量减少数据的移动，以便使平衡快速完整，并减少网络和磁盘I/O负载。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;海量分区&quot;&gt;海量分区&lt;/h4&gt;
&lt;p&gt;节点创建远超节点数目的分区数，并为每个节点分配几个分区。例如，在10个节点的群集上运行的数据库可以从一开始分裂成1000个分区，以便分配给每个节点大约100个分区。当将一个节点添加到集群中，新节点可以从每个现有节点窃取一些分区，直到再次公平分配分区为止。如下图所示：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-88ae22accd73b67e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;海量分区的再平衡&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分区的数量不会改变，分区的键分配也不会改变。唯一改变的是分区与节点之间的映射。这种分区平衡的变化不是即时的，在网络上传输大量数据需要一定的时间，&lt;strong&gt;所以旧的分区节点在分区平衡时需要承担这个过程之中的读写操作。&lt;/strong&gt;通过海量分区同样也可以通过给性能更强悍的节点分配更多的分区，可以强制这些节点承担更大的负载份额。&lt;/p&gt;
&lt;p&gt;一开始配置的分区数量就是所能拥有的最大节点数，因此您需要选择足够高的分区数目以适应未来的增长。然而，每个分区也有管理开销，所以选择过高的值会适得其反。&lt;/p&gt;
&lt;h5 id=&quot;动态分区&quot;&gt;动态分区&lt;/h5&gt;
&lt;p&gt;对于使用键范围分区的数据库，固定范围值的固定分区数量将非常不方便：如果您的边界错误，您可能会将所有数据放在一个分区中，而所有其他分区都是空的。手动重新分区分区将非常繁琐。所以可以采取&lt;strong&gt;动态分区&lt;/strong&gt;的机制：&lt;/p&gt;
&lt;p&gt;当一个分区的增长超过配置的大小，它被分为两个分区，大约一半的数据分配在两个新的分区。相反，如果大量数据被删除，一个分区缩小到某个阈值以下，它可以与相邻分区合并。动态分区的优点是分区的数量与总数据量相适应。如果只有少量的数据，少量的分区就足够了，因此开销很小；如果有大量的数据，每个单独的分区的大小限制为一个可配置的最大值。&lt;/p&gt;
&lt;h3 id=&quot;请求路由&quot;&gt;4. 请求路由&lt;/h3&gt;
&lt;p&gt;在多台机器上运行的多个节点上对数据集进行分区，所以会面临一个核心问题：&lt;strong&gt;当客户端想要提出请求时，它如何知道要连接哪个节点？当分区被重新平衡，分区节点变化的时候客户端如何感知变化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在高层次上，对这个问题有几种不同的解决方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.允许客户端与任何节点联系。如果该节点恰好拥有请求所应用的分区，则它可以直接处理请求；否则，它将请求转发到适当的节点，接收应答，并将应答传递给客户端。&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;将客户端的所有请求首先发送到路由层，这将决定应处理每个请求并相应转发它的节点。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;要求客户端知道分区和分配给节点的分区。在这种情况下，客户机可以直接连接到适当的节点，而不需要任何中介。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-e77433af7bef27b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;三种路由解决方案&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在三种情况之中关键的问题是：&lt;strong&gt;组成路由决策的组件（可能是其中一个节点，或者路由层，或客户端）如何了解分区分配给节点的变化？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;许多分布式数据系统依赖于一个单独的协调服务如ZooKeeper跟踪这个集群的元数据，每个节点在ZooKeeper之中注册自己。ZooKeeper维护分区节点映射的权威，而路由层或客户端，可以订阅这个ZooKeeper。当一个分区发生变化时，或添加一个节点或删除，ZooKeeper通知路由层，这样可以保持它的路由信息更新。如下图所示：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-bf094d39b7f43141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;基于ZooKeeper的请求路由&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Cassandra和Riak采取了不同的方法：通过使用Gossip协议节点之间传播集群状态的任何变化。请求可以发送到任何节点，该节点将它们转发到所请求分区的适当节点。该模型提出了更复杂的数据库节点，但避免了外部协调服务的依赖。&lt;/p&gt;
&lt;p&gt;当使用路由层或向随机节点发送请求时，客户端仍然需要找到连接到的IP地址。这些并不像分区对节点的分配那样快速变化，因此经常使用DNS来达到此目的。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;我们在本篇之中总结了数据分区技术运用到的多种策略与技术，希望大家能够更好的认识数据分区技术在分布式存储之中的重要意义。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 10 Feb 2018 10:04:00 +0000</pubDate>
<dc:creator>HappenLee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/happenlee/p/8439325.html</dc:identifier>
</item>
</channel>
</rss>