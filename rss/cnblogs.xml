<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET运行时中的监测和可观测性 - Alin-</title>
<link>http://www.cnblogs.com/WithLin/p/9798485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WithLin/p/9798485.html</guid>
<description>&lt;blockquote readability=&quot;6.4235294117647&quot;&gt;
&lt;p&gt;今年5月份的时候研究分布式追踪的问题知道了的拦截方式比较零散， 刚好8月份的时候看到这篇文章，这个文章总结的比较完整。存档了很久，趁今天有空翻译给大家。&lt;a href=&quot;http://mattwarren.org/2018/08/21/Monitoring-and-Observability-in-the-.NET-Runtime/&quot;&gt;原文地址&lt;/a&gt;，校验：&lt;a href=&quot;https://home.cnblogs.com/u/chenug&quot;&gt;张蘅水&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;.NET是一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Managed_code&quot;&gt;&lt;em&gt;托管运行时&lt;/em&gt;&lt;/a&gt;，这意味着它提供了“管理”您的程序的高级功能，从&lt;a href=&quot;https://github.com/mattwarren/coreclr/blob/master/Documentation/botr/intro-to-clr.md#fundamental-features-of-the-clr&quot;&gt;简介到公共语言运行时（CLR）&lt;/a&gt;（2007年编写）：&lt;/p&gt;
&lt;p&gt;运行时具有许多功能，因此按如下方式对它们进行分类很有用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;基本功能&lt;/strong&gt; 对其他功能设计有广泛影响的功能。这些包括：&lt;br/&gt;1.垃圾收集&lt;br/&gt;2.记忆安全和类型安全&lt;br/&gt;3.对编程语言的高级支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;辅助功能&lt;/strong&gt; - 许多有用的程序可能不需要基本特性所支持的功能：&lt;br/&gt;1.使用AppDomains进行程序隔离&lt;br/&gt;2.程序安全和沙盒&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他功能&lt;/strong&gt; - 所有运行时环境都需要但不利用CLR基本功能的功能。相反，它们是创建完整编程环境的结果。其中包括：&lt;br/&gt;1.版本&lt;br/&gt;2.&lt;strong&gt;Debugging/Profiling&lt;/strong&gt;&lt;br/&gt;3.互操作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;您可以看到，“&lt;strong&gt;Debugging/Profiling&lt;/strong&gt;”虽然不是基本或辅助功能，但由于“ 需要创建完整的编程环境 ” ，它仍然会进入列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这篇文章的其余部分将看&lt;em&gt;什么&lt;/em&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_performance_management&quot;&gt;监测&lt;/a&gt;，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%A7%80%E6%B8%AC%E6%80%A7&quot;&gt;可观测性&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%86%85%E7%9C%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&quot;&gt;内省&lt;/a&gt;功能核心CLR提供，&lt;em&gt;为什么&lt;/em&gt;他们是有用的，&lt;em&gt;如何&lt;/em&gt;提供他们。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了便于浏览，帖子分为3个主要部分（最后有一些“额外阅读材料”）：&lt;/p&gt;
&lt;h2 id=&quot;诊断diagnostics&quot;&gt;诊断(Diagnostics)&lt;/h2&gt;
&lt;p&gt;首先，我们将查看CLR提供的&lt;strong&gt;诊断&lt;/strong&gt;信息，传统上这些信息是通过&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/etw/about-event-tracing&quot;&gt;“Windows事件跟踪”&lt;/a&gt;（ETW）提供的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/performance/clr-etw-keywords-and-levels&quot;&gt;CLR提供的&lt;/a&gt;各种事件涉及：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;垃圾收集（GC）&lt;/li&gt;
&lt;li&gt;即时（JIT）编译&lt;/li&gt;
&lt;li&gt;模块和AppDomains&lt;/li&gt;
&lt;li&gt;线程和锁争用&lt;/li&gt;
&lt;li&gt;以及更多&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，这是&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/corhost.cpp#L649&quot;&gt;触发AppDomain Load事件的&lt;/a&gt;地方，这是&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/exceptionhandling.cpp#L203&quot;&gt;Exception Thrown事件&lt;/a&gt;，这里是&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/gctoclreventsink.cpp#L139-L144&quot;&gt;GC Allocation Tick事件&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;perf-view&quot;&gt;Perf View&lt;/h3&gt;
&lt;p&gt;如果你想看到来自你的.NET程序的ETW事件，我建议使用优秀的&lt;a href=&quot;https://github.com/Microsoft/perfview&quot;&gt;PerfView工具&lt;/a&gt;，从这些&lt;a href=&quot;https://channel9.msdn.com/Series/PerfView-Tutorial&quot;&gt;PerfView教程&lt;/a&gt;开始，或者这个优秀的演讲&lt;a href=&quot;https://www.slideshare.net/InfoQ/perfview-the-ultimate-net-performance-tool&quot;&gt;PerfView：终极.NET性能工具&lt;/a&gt;。PerfView被广泛认可，因为它提供了宝贵的信息，例如Microsoft工程师经常将其用于&lt;a href=&quot;https://github.com/dotnet/corefx/issues/28834&quot;&gt;性能调查&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5590759-af39d031358bb86b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;共同基础设施&quot;&gt;共同基础设施&lt;/h3&gt;
&lt;p&gt;但是，如果从名称中不清楚，ETW事件仅在Windows上可用，这并不适合新的.NET“跨平台”世界。您可以&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/project-docs/linux-performance-tracing.md&quot;&gt;在Linux上&lt;/a&gt;使用&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/project-docs/linux-performance-tracing.md&quot;&gt;PerfView进行性能跟踪&lt;/a&gt;（通过&lt;a href=&quot;https://lttng.org/&quot;&gt;LTTng&lt;/a&gt;），但这只是cmd-line集合工具，称为“PerfCollect”，分析和丰富的UI（包括&lt;a href=&quot;https://github.com/Microsoft/perfview/pull/502&quot;&gt;flamegraphs&lt;/a&gt;）目前仅适用于Windows。&lt;/p&gt;
&lt;p&gt;但是如果你想分析.NET Performance Linux，还有其他一些方法：&lt;/p&gt;
&lt;p&gt;上面的第二个链接讨论了在.NET Core中正在使用的新&lt;strong&gt;“EventPipe”基础架构&lt;/strong&gt;（以及EventSources和EventListeners，你能发现一个主题！），你可以看到它在&lt;a href=&quot;https://github.com/dotnet/designs/blob/master/accepted/cross-platform-performance-monitoring.md&quot;&gt;跨平台性能监控设计中的目标&lt;/a&gt;。在高层次上，它将为CLR提供一个单独的位置来推动与诊断和性能相关的“事件”。然后，这些“事件”将被路由到一个或多个记录器，例如，可能包括ETW，LTTng和BPF，精确记录器由CLR运行的OS /平台确定。&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/coding-guidelines/cross-platform-performance-and-eventing.md&quot;&gt;.NET Cross-Plat性能和事件设计&lt;/a&gt;中还有更多背景信息可以解释不同日志记录技术的优缺点。&lt;/p&gt;
&lt;p&gt;“事件管道”中正在进行的所有工作都在&lt;a href=&quot;https://github.com/dotnet/coreclr/projects/5&quot;&gt;“性能监控”项目&lt;/a&gt;和相关的&lt;a href=&quot;https://github.com/dotnet/coreclr/search?q=EventPipe&amp;amp;type=Issues&quot;&gt;“EventPipe”问题中&lt;/a&gt;进行跟踪。&lt;/p&gt;
&lt;h3 id=&quot;未来的计划&quot;&gt;未来的计划&lt;/h3&gt;
&lt;p&gt;最后，还有一个&lt;a href=&quot;https://github.com/dotnet/designs/blob/master/accepted/performance-profiling-controller.md&quot;&gt;性能分析控制器的(Performance Profiling Controller )&lt;/a&gt;未来计划，其目标如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;控制器负责以简单和跨平台的方式控制性能分析基础结构和.NET性能诊断组件生成的性能数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们的想法是&lt;a href=&quot;http://mattwarren.org/2018/08/21/Monitoring-and-Observability-in-the-.NET-Runtime/(https://github.com/dotnet/designs/blob/master/accepted/performance-profiling-controller.md#functionality-exposed-through-controller)&quot;&gt;通过&lt;/a&gt;从“事件管道”中提取所有相关数据，通过&lt;a href=&quot;http://mattwarren.org/2018/08/21/Monitoring-and-Observability-in-the-.NET-Runtime/(https://github.com/dotnet/designs/blob/master/accepted/performance-profiling-controller.md#functionality-exposed-through-controller)&quot;&gt;HTTP服务器&lt;/a&gt;公开&lt;a href=&quot;http://mattwarren.org/2018/08/21/Monitoring-and-Observability-in-the-.NET-Runtime/(https://github.com/dotnet/designs/blob/master/accepted/performance-profiling-controller.md#functionality-exposed-through-controller)&quot;&gt;以下功能&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;REST API&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Pri 1：简单分析：为运行时间配置X个时间并返回跟踪。&lt;/li&gt;
&lt;li&gt;Pri 1：高级分析：开始跟踪（以及配置）&lt;/li&gt;
&lt;li&gt;Pri 1：高级分析：停止跟踪（对此调用的响应将是跟踪本身）&lt;/li&gt;
&lt;li&gt;Pri 2：获取与所有EventCounters或指定EventCounter相关的统计信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;可浏览的HTML页面&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Pri 1：流程中所有托管代码堆栈的文本表示。&lt;/li&gt;
&lt;li&gt;提供当前正在运行的用作简单诊断报告的快照概述。&lt;/li&gt;
&lt;li&gt;Pri 2：显示EventCounters的当前状态（可能具有历史记录）。&lt;br/&gt;* 提供现有计数器及其值的概述。&lt;br/&gt;* 开放性问题：我不相信存在必要的公共API来枚举EventCounters。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;我很高兴看到“&lt;strong&gt;性能分析控制器(Performance Profiling Controller)&lt;/strong&gt;”（PPC？）的位置，我认为将这种内置到CLR中确实非常有价值，这是&lt;a href=&quot;https://github.com/golang/go/wiki/Performance&quot;&gt;其他运行时的内容&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;剖析profiling&quot;&gt;剖析(Profiling)&lt;/h2&gt;
&lt;p&gt;CLR提供的另一个强大功能是&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms404386(v%3dvs.100)&quot;&gt;Profiling API&lt;/a&gt;，它（大部分）被第三方工具用于在非常低级别挂钩到运行时。您可以在&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/bb384493(v%3dvs.100)&quot;&gt;此概述中&lt;/a&gt;找到有关API的更多信息，但在较高级别，它允许您连接在以下情况下触发的回调：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5590759-e1e6f4dade78fa92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;来自BOTR页面的图像&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/profiling.md#profiling-api--overview&quot;&gt;分析API - 概述&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此外还有其他&lt;strong&gt;非常强大的功能&lt;/strong&gt;。首先，您可以&lt;strong&gt;设置每次执行.NET方法时调用的挂钩，&lt;/strong&gt;无论是在运行时还是用户代码中。这些回调被称为“进入/离开”钩子，并且有一个&lt;a href=&quot;https://github.com/Microsoft/clr-samples/tree/master/ProfilingAPI/ReJITEnterLeaveHooks&quot;&gt;很好的示例&lt;/a&gt;显示如何使用它们，但为了使它们工作，您需要了解&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/19023&quot;&gt;不同操作系统和CPU架构的“调用约定”&lt;/a&gt;，这&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/18977&quot;&gt;并不总是容易的&lt;/a&gt;。另外，作为警告，Profiling API是一个只能通过C / C ++代码访问的COM组件，你不能在C＃/ F＃/ VB.NET中使用它！&lt;/p&gt;
&lt;p&gt;其次，Profiler能够通过&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/icorprofilerfunctioncontrol-setilfunctionbody-method&quot;&gt;SetILFunctionBody（）API&lt;/a&gt;在&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/icorprofilerfunctioncontrol-setilfunctionbody-method&quot;&gt;JIT &lt;/a&gt;&lt;strong&gt;之前重写任何.NET方法的IL代码&lt;/strong&gt;。这个API功能非常强大，构成了许多.NET &lt;a href=&quot;https://stackify.com/application-performance-management-tools/&quot;&gt;APM工具&lt;/a&gt;的基础，您可以在我之前的文章中了解更多关于如何使用它的方法。&lt;a href=&quot;http://mattwarren.org/2014/08/14/how-to-mock-sealed-classes-and-static-methods/&quot;&gt;如何模拟密封类和静态方法&lt;/a&gt;以及&lt;a href=&quot;https://github.com/mattwarren/DDD2011_ProfilerDemo/commit/9f804cec8ef11b802e020e648180b436a429833f?w=1&quot;&gt;随附的代码&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;icorprofiler-api&quot;&gt;ICorProfiler API&lt;/h3&gt;
&lt;p&gt;事实证明，运行时必须执行各种疯狂的技巧才能使Profiling API正常工作，只需查看进入此PR的内容&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/19054&quot;&gt;允许重新连接&lt;/a&gt;（有关'ReJIT'的详细信息，请参阅&lt;a href=&quot;https://blogs.msdn.microsoft.com/davbr/2011/10/12/rejit-a-how-to-guide/&quot;&gt;ReJIT：A How-To指南&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;所有Profiling API接口和回调的总体定义可在&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/src/inc/corprof.idl&quot;&gt;\vm\inc\corprof.idl中找到&lt;/a&gt;（请参阅&lt;a href=&quot;https://en.wikipedia.org/wiki/Interface_description_language&quot;&gt;接口说明语言&lt;/a&gt;）。但它分为2个逻辑部分，一个是&lt;strong&gt;Profiler - &amp;gt;'Execution Engine'（EE）&lt;/strong&gt;接口，称为&lt;code&gt;ICorProfilerInfo&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Declaration of class that implements the ICorProfilerInfo* interfaces, which allow the
// Profiler to communicate with the EE.  This allows the Profiler DLL to get
// access to private EE data structures and other things that should never be exported
// outside of the EE.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这在以下文件中实现：&lt;/p&gt;
&lt;p&gt;另一个主要部分是&lt;strong&gt;EE - &amp;gt; Profiler&lt;/strong&gt;回调，它们在&lt;code&gt;ICorProfilerCallback&lt;/code&gt;界面下组合在一起：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// This module implements wrappers around calling the profiler's 
// ICorProfilerCallaback* interfaces. When code in the EE needs to call the
// profiler, it goes through EEToProfInterfaceImpl to do so.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些回调在以下文件中实现：&lt;/p&gt;
&lt;p&gt;最后，值得指出的是，Profiler API可能无法在.NET Core运行的所有操作系统和CPU-arch上运行，例如&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/18977&quot;&gt;Linux上的ELT调用存根问题&lt;/a&gt;，有关详细信息，请参阅&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/project-docs/profiling-api-status.md&quot;&gt;CoreCLR Profiler API的状态&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;分析和调试profiling-v.-debugging&quot;&gt;分析和调试(Profiling v. Debugging)&lt;/h3&gt;
&lt;p&gt;除此之外，“分析”和“调试”确实有一些重叠，因此从&lt;a href=&quot;https://blogs.msdn.microsoft.com/jmstall/2004/10/22/clr-debugging-vs-clr-profiling/&quot;&gt;CLR调试与CLR分析&lt;/a&gt;&lt;em&gt;中了解.NET运行时上下文中&lt;/em&gt;不同的API提供&lt;em&gt;了&lt;/em&gt;什么是有帮助的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5590759-5eb562e65f76707e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;调试debugging&quot;&gt;调试(Debugging)&lt;/h2&gt;
&lt;p&gt;调试意味着不同的事情不同的人，比如我问在Twitter上“ &lt;em&gt;什么是你调试的.NET程序的途径&lt;/em&gt; ”，并得到了&lt;a href=&quot;https://mobile.twitter.com/matthewwarren/status/1030444463385178113&quot;&gt;广泛&lt;/a&gt;的&lt;a href=&quot;https://mobile.twitter.com/matthewwarren/status/1030580487969038344&quot;&gt;不同反应&lt;/a&gt;，虽然反应两组含有一个很好的工具清单和技术，所以他们值得一试，谢谢#LazyWeb！&lt;/p&gt;
&lt;p&gt;但也许这句话最好总结一下&lt;strong&gt;Debugging究竟是&lt;/strong&gt;什么😊&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5590759-abbcc4717f35ce03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CLR提供了与调试相关的非常广泛的功能，但为什么需要提供这些服务，优秀的帖子&lt;a href=&quot;https://blogs.msdn.microsoft.com/jmstall/2004/10/10/why-is-managed-debugging-different-than-native-debugging/&quot;&gt;为什么托管调试与本机调试不同？&lt;/a&gt;提供了3个理由：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以在硬件级别抽象本机调试，但&lt;strong&gt;需要在IL级别抽象管理调试&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;托管调试需要大量的信息，&lt;strong&gt;直到运行时才可用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;托管调试器需要&lt;strong&gt;与垃圾收集器（GC）协调&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以给一个体面的经验，CLR &lt;em&gt;具有&lt;/em&gt;提供&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/debugging/&quot;&gt;更高级别的调试API&lt;/a&gt;称&lt;code&gt;ICorDebug&lt;/code&gt;，这将在下面从“常用的调试方案”的图像中显示&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/dac-notes.md#marshaling-specifics&quot;&gt;的BOTR&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5590759-a322f6aae4d89b10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外，还有很好的描述了不同部分&lt;a href=&quot;https://blogs.msdn.microsoft.com/jmstall/2004/12/28/how-do-managed-breakpoints-work/&quot;&gt;如何在管理断点如何工作中&lt;/a&gt;相互作用&lt;a href=&quot;https://blogs.msdn.microsoft.com/jmstall/2004/12/28/how-do-managed-breakpoints-work/&quot;&gt;？&lt;/a&gt;，虽然描述&lt;em&gt;左&lt;/em&gt;和&lt;em&gt;右&lt;/em&gt;是上图中的相反！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Here’s an overview of the pipeline of components:
1) End-user
2) Debugger (such as Visual Studio or MDbg).
3) CLR Debugging Services (which we call &quot;The Right Side&quot;). This is the implementation of ICorDebug (in mscordbi.dll).
---- process boundary between Debugger and Debuggee ----
4) CLR. This is mscorwks.dll. This contains the in-process portion of the debugging services (which we call &quot;The Left Side&quot;) which communicates directly with the RS in stage #3.
5) Debuggee's code (such as end users C# program)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;icordebug-api&quot;&gt;ICorDebug API&lt;/h3&gt;
&lt;p&gt;但是如何实现所有这些以及从&lt;a href=&quot;https://github.com/Microsoft/clrmd/blob/master/Documentation/GettingStarted.md#clr-debugging-a-brief-introduction&quot;&gt;CLR Debugging简要介绍&lt;/a&gt;的不同组件是什么：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;所有.Net调试支持都在我们称之为“The Dac”的dll之上实现。此文件（通常命名&lt;code&gt;mscordacwks.dll&lt;/code&gt;）是我们的公共调试API（&lt;code&gt;ICorDebug&lt;/code&gt;）以及两个私有调试API 的构建块：SOS-Dac API和IXCLR。&lt;/p&gt;
&lt;p&gt;在一个完美的世界中，每个人都会使用&lt;code&gt;ICorDebug&lt;/code&gt;我们的公共调试API。但是，像您这样的工具开发人员所需的绝大多数功能都缺乏&lt;code&gt;ICorDebug&lt;/code&gt;。这是我们正在修复的问题，但这些改进将进入CLR v.next，而不是旧版本的CLR。实际上，&lt;code&gt;ICorDebug&lt;/code&gt;API仅在CLR v4中添加了对故障转储调试的支持。任何调试CLR v2崩溃转储的人根本无法使用&lt;code&gt;ICorDebug&lt;/code&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（有关其他文章，请参阅&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/src/ToolBox/SOS/SOSAndICorDebug.md&quot;&gt;SOS和ICorDebug&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;ICorDebug&lt;/code&gt;API实际上是分成多个接口，也有在他们的70！我不会在这里列出所有内容，但是我将展示它们所属的类别，有关更多信息，请参阅&lt;a href=&quot;https://blogs.msdn.microsoft.com/jmstall/2006/01/04/partition-of-icordebug/&quot;&gt;ICorDebug的分区，&lt;/a&gt;其中包含此列表，因为它更详细。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;顶级(Debugging)：&lt;/strong&gt; ICorDebug + ICorDebug2是顶级接口，有效地充当ICorDebugProcess对象的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回调(Callbacks)：&lt;/strong&gt;通过调试器实现的回调对象上的方法调度托管调试事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程(Process)：&lt;/strong&gt;这组接口表示正在运行的代码，并包含与事件相关的API。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码/类型检查(Code / Type Inspection)：&lt;/strong&gt; 主要可以在静态PE映像上运行，但实时数据有一些便​​捷方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行控制(Execution Control)：&lt;/strong&gt;执行是“检查”线程执行的能力。实际上，这意味着放置断点（F9）和踩踏（F11步入，F10步进，S + F11步出）等。ICorDebug的执行控制仅在托管代码中运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程+调用堆栈(Threads + Callstacks)：&lt;/strong&gt;调用堆栈是调试器检查功能的支柱。以下接口与获取callstack有关。ICorDebug仅公开调试托管代码，因此堆栈跟踪仅受管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象检查(Object Inspection)：&lt;/strong&gt;对象检查是API的一部分，它允许您在整个调试对象中查看变量的值。对于每个接口，我列出了“MVP”方法，我认为必须简洁地传达该接口的用途。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外需要注意的是，与Profiling APIs一样，调试API的支持级别因操作系统和CPU架构而异。例如，截至2018年8月，&lt;a href=&quot;https://github.com/dotnet/diagnostics/issues/58#issuecomment-414182115&quot;&gt;“没有针对Linux ARM进行托管调试和诊断的解决方案”&lt;/a&gt;。有关“Linux”支持的更多信息，请参阅这篇很棒的文章，&lt;a href=&quot;https://www.raydbg.com/2018/Debugging-Net-Core-on-Linux-with-LLDB/&quot;&gt;在Linux上使用LLDB调试.NET Core，&lt;/a&gt;并从Microsoft 检出&lt;a href=&quot;https://github.com/dotnet/diagnostics&quot;&gt;诊断存储库&lt;/a&gt;，其目标是更容易在Linux上调试.NET程序。&lt;/p&gt;
&lt;p&gt;最后，如果你想看看&lt;code&gt;ICorDebug&lt;/code&gt;API在C＃中的样子，看一下&lt;a href=&quot;https://github.com/Microsoft/clrmd/blob/master/src/Microsoft.Diagnostics.Runtime/ICorDebug/ICorDebugWrappers.cs&quot;&gt;CLRMD库中包含&lt;/a&gt;的&lt;a href=&quot;https://github.com/Microsoft/clrmd/blob/master/src/Microsoft.Diagnostics.Runtime/ICorDebug/ICorDebugWrappers.cs&quot;&gt;包装器&lt;/a&gt;，包括所有&lt;a href=&quot;https://github.com/Microsoft/clrmd/blob/c81a592f3041a9ae86f4c09351d8183801e39eed/src/Microsoft.Diagnostics.Runtime/ICorDebug/ICorDebugHelpers.cs&quot;&gt;可用的回调&lt;/a&gt;（CLRMD将在后面的文章中进行更深入的介绍）。&lt;/p&gt;
&lt;h3 id=&quot;sos和dac&quot;&gt;SOS和DAC&lt;/h3&gt;
&lt;p&gt;“数据访问组件(Data Access Component)”（DAC）在&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/dac-notes.md&quot;&gt;BOTR页面&lt;/a&gt;中有详细讨论，但实际上它提供了对CLR数据结构的“进程外”访问，因此可以从&lt;em&gt;另一个进程&lt;/em&gt;读取其内部详细信息。这允许调试器（via &lt;code&gt;ICorDebug&lt;/code&gt;）或&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/tools/sos-dll-sos-debugging-extension&quot;&gt;'Son of Strike'（SOS）扩展&lt;/a&gt;进入CLR的运行实例或内存转储，并找到如下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有正在运行的线程&lt;/li&gt;
&lt;li&gt;托管堆上有哪些对象&lt;/li&gt;
&lt;li&gt;有关方法的完整信息，包括机器代码&lt;/li&gt;
&lt;li&gt;当前的'堆栈跟踪'&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;除此之外&lt;/strong&gt;，如果您想要解释所有奇怪的名称和一点'.NET历史课'，请参阅&lt;a href=&quot;https://stackoverflow.com/questions/21361602/what-the-ee-means-in-sos/21363245#21363245&quot;&gt;此Stack Overflow答案&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md#sos-commands&quot;&gt;SOS命令&lt;/a&gt;的完整列表非常令人印象深刻，并且在WinDBG旁边使用它可以让您非常低级地了解程序和CLR中发生的情况。要了解它是如何实现的，让我们看一下这个&lt;code&gt;!HeapStat&lt;/code&gt;命令，该命令可以为您提供.NET GC正在使用的不同堆大小的摘要：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5590759-9a6b9693acb576d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（来自&lt;a href=&quot;https://blogs.msdn.microsoft.com/tom/2008/06/30/sos-upcoming-release-has-a-few-new-commands-heapstat/&quot;&gt;SOS的&lt;/a&gt;图片&lt;a href=&quot;https://blogs.msdn.microsoft.com/tom/2008/06/30/sos-upcoming-release-has-a-few-new-commands-heapstat/&quot;&gt;：即将发布的版本有一些新命令 - HeapStat&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;这是代码流，显示了SOS和DAC如何协同工作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;SOS&lt;/strong&gt;完整&lt;code&gt;!HeapStat&lt;/code&gt;命令（&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/src/ToolBox/SOS/Strike/strike.cpp#L4605-L4782&quot;&gt;链接&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOS&lt;/strong&gt;&lt;code&gt;!HeapStat&lt;/code&gt;处理'Workstation GC' 的命令中的代码（&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/src/ToolBox/SOS/Strike/strike.cpp#L4631-L4667&quot;&gt;链接&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOS&lt;/strong&gt; &lt;code&gt;GCHeapUsageStats(..)&lt;/code&gt;功能，重负荷（&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/src/ToolBox/SOS/Strike/eeheap.cpp#L768-L850&quot;&gt;链接&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享&lt;/strong&gt;&lt;code&gt;DacpGcHeapDetails&lt;/code&gt;包含指向GC堆中主数据的指针的数据结构，例如段，卡表和各代（&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/src/inc/dacprivate.h#L690-L722&quot;&gt;链接&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GetGCHeapStaticData&lt;/code&gt;填充&lt;code&gt;DacpGcHeapDetails&lt;/code&gt;结构的&lt;strong&gt;DAC&lt;/strong&gt;函数（&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/src/inc/dacprivate.h#L690-L722&quot;&gt;链接&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享&lt;/strong&gt;&lt;code&gt;DacpHeapSegmentData&lt;/code&gt;包含GC堆的单个“段”的详细信息的数据结构（&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/src/inc/dacprivate.h#L738-L771&quot;&gt;链接&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GetHeapSegmentData(..)&lt;/code&gt;填充&lt;code&gt;DacpHeapSegmentData&lt;/code&gt;结构的&lt;strong&gt;DAC&lt;/strong&gt;（&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/release/2.1/src/debug/daccess/request.cpp#L2829-L2868&quot;&gt;链接&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;第三方调试器3rd-party-debuggers&quot;&gt;第三方'调试器'(3rd Party ‘Debuggers’)&lt;/h3&gt;
&lt;p&gt;由于Microsoft发布了调试API，它允许第三方使用&lt;code&gt;ICorDebug&lt;/code&gt;接口，这里列出了我遇到的一些内容：&lt;/p&gt;
&lt;h3 id=&quot;记忆转储memory-dumps&quot;&gt;记忆转储(Memory Dumps)&lt;/h3&gt;
&lt;p&gt;我们要看的最后一个区域是“内存转储”，可以从&lt;em&gt;实时&lt;/em&gt;系统中捕获并离线分析。.NET运行时一直很好地支持&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn342825.aspx?f=255&amp;amp;MSPPError=-2147217396#BKMK_Collect_memory_snapshots&quot;&gt;在Windows上创建“内存转储”&lt;/a&gt;，现在.NET Core是“跨平台”，也可以&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/xplat-minidump-generation.md&quot;&gt;在其他操作系统上使用相同的&lt;/a&gt;工具。&lt;/p&gt;
&lt;p&gt;“内存转储”的一个问题是，获取SOS和DAC文件的正确匹配版本可能会非常棘手。幸运的是，Microsoft刚刚发布了以下&lt;a href=&quot;https://github.com/dotnet/symstore/tree/master/src/dotnet-symbol&quot;&gt;&lt;code&gt;dotnet symbol&lt;/code&gt;CLI工具&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;可以下载任何给定核心转储，minidump或任何支持平台的文件格式（如ELF，MachO，Windows DLL，PDB和便携式PDB）的调试所需的所有文件（给出coreclr模块的符号，模块，SOS和DAC）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，如果你花费任何时间&lt;strong&gt;分析'内存转储'，&lt;/strong&gt;你真的应该看看微软几年前发布的优秀的&lt;a href=&quot;https://github.com/Microsoft/clrmd&quot;&gt;CLR MD库&lt;/a&gt;。我之前&lt;a href=&quot;http://mattwarren.org/2016/09/06/Analysing-.NET-Memory-Dumps-with-CLR-MD/&quot;&gt;已经写过&lt;/a&gt;你可以用它做什么，但简而言之，它允许你通过一个直观的C＃API与内存转储交互，其中的类可以访问&lt;a href=&quot;https://github.com/Microsoft/clrmd/blob/master/src/Microsoft.Diagnostics.Runtime/ClrHeap.cs#L16&quot;&gt;ClrHeap&lt;/a&gt;，&lt;a href=&quot;https://github.com/Microsoft/clrmd/blob/6735e1012d11c244874fa3ba3af6e73edc0da552/src/Microsoft.Diagnostics.Runtime/GCRoot.cs#L105&quot;&gt;GC Roots&lt;/a&gt;，&lt;a href=&quot;https://github.com/Microsoft/clrmd/blob/master/src/Microsoft.Diagnostics.Runtime/ClrThread.cs#L103&quot;&gt;CLR Threads&lt;/a&gt;，&lt;a href=&quot;https://github.com/Microsoft/clrmd/blob/master/src/Microsoft.Diagnostics.Runtime/ClrThread.cs#L37&quot;&gt;Stack Frames&lt;/a&gt;和&lt;a href=&quot;https://github.com/Microsoft/clrmd/tree/master/src/Samples&quot;&gt;更多&lt;/a&gt;。实际上，除了实现工作所需的时间之外，CLR MD还可以&lt;a href=&quot;https://github.com/Microsoft/clrmd/issues/33&quot;&gt;实现&lt;em&gt;大多数&lt;/em&gt;（如果不是全部）SOS命令&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但是从&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2013/05/01/net-crash-dump-and-live-process-inspection/&quot;&gt;宣布帖子&lt;/a&gt;来看它是如何运作&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2013/05/01/net-crash-dump-and-live-process-inspection/&quot;&gt;的&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;ClrMD托管库是CLR仅内部调试API的包装器。虽然这些仅内部API对于诊断非常有用，但我们不支持它们作为公开的，有文档的版本，因为它们非常难以使用并且与CLR的其他实现细节紧密耦合。ClrMD通过围绕这些低级调试API提供易于使用的托管包装来解决此问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过在官方支持的库中提供这些API，Microsoft使开发人员能够在CLRMD之上构建&lt;a href=&quot;http://mattwarren.org/2018/06/15/Tools-for-Exploring-.NET-Internals/#tools-based-on-clr-memory-diagnostics-clrmd&quot;&gt;各种工具&lt;/a&gt;，这是一个很好的结果！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;总而言之，.NET Runtime提供了广泛的诊断，调试和分析功能，可以深入了解CLR内部的情况。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Oct 2018 07:52:00 +0000</pubDate>
<dc:creator>Alin-</dc:creator>
<og:description>今年5月份的时候研究分布式追踪的问题知道了的拦截方式比较零散， 刚好8月份的时候看到这篇文章，这个文章总结的比较完整。存档了很久，趁今天有空翻译给大家。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WithLin/p/9798485.html</dc:identifier>
</item>
<item>
<title>NLP是什么 - 仗剑走天涯|</title>
<link>http://www.cnblogs.com/chenliangcl/p/9798397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenliangcl/p/9798397.html</guid>
<description>&lt;p&gt;而在计算机领域， NLP（Natural Language Processing），也就是人们常说的「自然语言处理」，就是研究如何让计算机读懂人类语言。&lt;/p&gt;
&lt;p&gt;这包括，既要能让计算机理解自然语言文本的意义，也能以自然语言文本来表达给定的深层的意图、思想等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/388326/201810/388326-20181016153716614-2077550262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以，这项技术往往体现了人工智能的最高任务与境界，也就是说，只有当计算机具备了理解自然语言的能力时，机器才算实现了真正的智能。&lt;/p&gt;
&lt;p&gt;然而，这一切远非人们想象的那么简单。 根本原因就在于自然语言文本和对话的各个层次上广泛存在各种各样的歧义性或多义性。&lt;/p&gt;
&lt;p&gt;并且，由于中文词语是由汉字千变万化组成的，所以中文领域的「自然语言处理」显得尤为复杂。&lt;/p&gt;
&lt;p&gt;专注于「自然语言处理」领域多年, 深耕「语义分析」技术， NLP 的技术和服务一直伴随着 ImageQ 的发展而不断进步。&lt;/p&gt;
&lt;p&gt;从「中文分词」、「词云画像」、「词性分析」到「自动摘要」、「关系挖掘」、「情感分析」、「知识图谱」等，NLP 技术已不再单纯的停留在概念层面， 而是逐步渗透并成功应用在 ImageQ 服务的各个垂直领域中。&lt;/p&gt;
&lt;p&gt;为什么需要NLP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/388326/201810/388326-20181016153758883-1712150415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;日常生活中，我们总会碰到一些不知道怎么读的生僻字， 这时往往就会去搜索引擎搜索，比如“ 4 个又念什么”。&lt;/p&gt;
&lt;p&gt;我们发现，搜索结果一定是向你展示“ 4 个又组成的字”是怎样的，并一旁附上拼音及注释等，而不是“ 4 个又念什么”这几个孤零零的词或者其表面的匹配结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/388326/201810/388326-20181016153830914-1045363378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;▲搜索引擎相关结果展示&lt;/p&gt;
&lt;p&gt;这其实就是NLP技术的一个体现了。通过这项技术，人们不必花费大量心力去学习和了解难懂的计算机语言，而是用自己最习惯的语言来使用计算机，并进一步了解这背后的意义。&lt;/p&gt;
&lt;p&gt;NLP 究竟能用来干什么&lt;/p&gt;
&lt;p&gt;那 NLP 究竟能干些什么呢？ 我们类比小孩子的学习之路，并结合 ImageQ 平台开放的几项典型 NLP 技术来进行一下说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;幼儿园时期&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个时期的我们，接收到的还只是单个的词、或短或长的句子，我们不了解这其中的动词、名词有哪些，搞不懂当中的主体又是谁，也尚不清楚标点符号、分隔符是什么意思，只是单纯的你说一句，我学一句了，小脑袋里充斥着各样的东西，但更多是杂乱的，少有章法可言的。&lt;/p&gt;
&lt;p&gt;好比我们身处的信息的海洋，每天，各类信息和数据不断涌现，尚未处理消化，新一轮的信息轰炸又随即展开，而后不断堆积，再涌现，再堆积......&lt;/p&gt;
&lt;p&gt;到最后采集来的也都是杂乱的，断层的，一些有价值的内容也往往在这个过程中渐渐流失了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;小学时期&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到了小学，我们能学习到的内容慢慢多了起来， 我们知道了“摘”是动词，“花”是名词, “和”是连词等等，清楚标点符号有“，”“。”“？”等，也学会了如何分词、断句等等。&lt;/p&gt;
&lt;p&gt;对应在NLP领域，则是「中文分词」、「词性分析」等层面的展现了。&lt;/p&gt;
&lt;p&gt;■中文分词&lt;/p&gt;
&lt;p&gt;「中文自动分词」处于中文自然语言处理的底层，是公认的中文信息处理的第一道工序，扮演着重要的角色， 而单词切分又是理解语言的最初的一道工序。&lt;/p&gt;
&lt;p&gt;良好的分词效果能为机器理解提供基础，也为人们做出更好、更正确的决策提供一定依据。&lt;/p&gt;
&lt;p&gt;■词性分析&lt;/p&gt;
&lt;p&gt;在分词的基础之上，我们为每个分词结果中的单词单独标注一个正确的词性，确定每个词是动词、名词、形容词或其他。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/388326/201810/388326-20181016153916841-16245553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;▲词性分析&lt;/p&gt;
&lt;p&gt;同一个词性在不同场景下所代表的具体属性也会不一样。比如“刀”用于日常生活中会是烹饪工具，而放在公安事件中，则又可能是一种作案工具了。&lt;/p&gt;
&lt;p&gt;通过领先的具有自主知识产权的专利算法——基于BI-LSTM和CRF的文本序列标注系统及方法，运用语言学逻辑解构文字规律，并结合「深度学习」算法优化判断字词之间的语义规则，相较于传统自然语言处理系统，ImageQ 支持更精准的语义识别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/388326/201810/388326-20181016153946392-299126557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;▲相关技术实现流程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;中学时期&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个时候，我们的学习有了更广泛的涉猎，也开始要学着提炼文章的中心思想， 观点倾向，分析个中人物、事件关系等等。&lt;/p&gt;
&lt;p&gt;这又涉及到自然语言处理中的「依存句法」、「自动摘要」、「情感评分」层级的内容。我们主要讲一下「情感评分」。&lt;/p&gt;
&lt;p&gt;「情感评分」即文本倾向性分析，依托「深度学习」、「机器学习」等语义理解技术，能快速判别大众对某一事件或产品持积极、中性还是消极态度。&lt;/p&gt;
&lt;p&gt;比如我们给定「十九大」报告，其呈现出来情感评分远远大于 1，是积极的正面情绪为主。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/388326/201810/388326-20181016154009206-1667185712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;▲「十九大」报告的情绪评分&lt;/p&gt;
&lt;p&gt;具有自主知识产权的 ImageQ 语义分析引擎提供行业领先的 ImageQNLP 和 ImageQMind 语义分析技术， 基于大数据词库辅助和大量的行业语料库，通过「句法分析」和「机器学习」等方法实现智能语义分析。&lt;/p&gt;
&lt;p&gt;在特定场景下的正负面情感分析准确度达到 85% ~ 90% 。经过行业数据标注学习后准确率可达 90% ~ 95%。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;大学时期&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过积累，我们已逐步形成自有的思维方式和知识体系， 在探索新技术的同时，也开始试着将所学应用到实际，解决某些现实问题。&lt;/p&gt;
&lt;p&gt;在「媒体」，「政府」、「公安」等领域多年的积极探索，ImageQ 沉淀了不少技术，积累了大量的行业语料，词库和知识库，同时也汇聚了众多国内外优秀的专家团队协同合作，共同助力为行业客户解决其最重要最实际的问题，大量应用场景和案例也都获得客户的高度认可。&lt;/p&gt;
&lt;p&gt;虽然现阶段针对一定应用， 具有相当「自然语言处理」能力的平台已经出现，并商品化，甚至开始产业化。但对「自然语言处理」的探索， 这还仍未称得上是终点。&lt;/p&gt;
&lt;p&gt;不过可以预见的是，不论是探究自然本质还是付诸实际应用, NLP 技术在将来必定会有令人期待的惊喜和异常快速的发展。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Oct 2018 07:44:00 +0000</pubDate>
<dc:creator>仗剑走天涯|</dc:creator>
<og:description>NLP是什么 NLP是什么 而在计算机领域， NLP（Natural Language Processing），也就是人们常说的「自然语言处理」，就是研究如何让计算机读懂人类语言。 这包括，既要能让计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenliangcl/p/9798397.html</dc:identifier>
</item>
<item>
<title>基于libcurl实现REST风格http/https的get和post - 蜗牛201</title>
<link>http://www.cnblogs.com/woniu201/p/9798278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woniu201/p/9798278.html</guid>
<description>&lt;p&gt;c/c++开发中经常要用到http/https协议，直接使用socket工作量很大，要是使用socket实现https，那更不可思议，开源的c/c++的http客户端框架，libcurl是首选，而且也相当成熟稳定，最近C++项目中用到https请求，就做下研究。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;libcurl简介(来源官网)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;libcurl是一个跨平台的网络协议库，支持http, https, ftp, gopher, telnet, dict, file, 和ldap 协议。libcurl同样支持HTTPS证书授权，HTTP POST, HTTP PUT, FTP 上传, HTTP基本表单上传，代理，cookies,和用户认证。官网地址：https://curl.haxx.se/libcurl/&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;实现HTTP/GET：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*******************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Copyright (C),  2016-2018,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;FileName:        Get
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;Author:            woniu201
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;Email:             wangpengfei.201@163.com
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;Created:           2018/10/15
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;Description:    实现HTTP/HTTPS GET请求
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;*******************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; size_t WriteGetResp(&lt;span&gt;void&lt;/span&gt; *buffer, size_t size, size_t nmemb, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;userp)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     ((&lt;span&gt;string&lt;/span&gt;*)userp)-&amp;gt;append((&lt;span&gt;char&lt;/span&gt;*)buffer, &lt;span&gt;0&lt;/span&gt;, size*&lt;span&gt;nmemb);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; size*&lt;span&gt;nmemb;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;@ Brief:        GET请求
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;@ Author:        woniu201 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;@ Created:        2018/10/15
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;@ Return:            
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;***********************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HttpGet(&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; url)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;&lt;span&gt; respData;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     CURL*&lt;span&gt; curl;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    CURLcode res;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     curl =&lt;span&gt; curl_easy_init();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (curl ==&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    curl_easy_setopt(curl, CURLOPT_URL, url);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteGetResp);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;amp;&lt;span&gt;respData);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;      curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 5000); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;libcurl存在毫秒超时bug,如果设备小于1000ms立即返回失败
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;      curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 5000); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置超时时间&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; bCA =&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;bCA)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, FALSE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定为不验证证书和HOST &lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, FALSE); 
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE); 
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         curl_easy_setopt(curl, CURLOPT_CAINFO, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     res =&lt;span&gt; curl_easy_perform(curl);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (res !=&lt;span&gt; CURLE_OK)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         cout &amp;lt;&amp;lt; curl_easy_strerror(res) &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    curl_easy_cleanup(curl);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;     cout &amp;lt;&amp;lt; Utf8ToAscii(respData) &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;实现HTTP/POST：&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*******************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Copyright (C),  2016-2018,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;FileName:        Post
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;Author:            woniu201
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;Email:             wangpengfei.201@163.com
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;Created:           2018/10/15
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;Description:    实现HTTP/HTTPS POST请求
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;*******************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; size_t WritePostBodyResp(&lt;span&gt;void&lt;/span&gt; *buffer, size_t size, size_t nmemb, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;userp)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     ((&lt;span&gt;string&lt;/span&gt;*)userp)-&amp;gt;append((&lt;span&gt;char&lt;/span&gt;*)buffer, &lt;span&gt;0&lt;/span&gt;, size*&lt;span&gt;nmemb);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; size*&lt;span&gt;nmemb;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; size_t WritePostHeaderResp(&lt;span&gt;void&lt;/span&gt; *buffer, size_t size, size_t nmemb, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;userp)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     ((&lt;span&gt;string&lt;/span&gt;*)userp)-&amp;gt;append((&lt;span&gt;char&lt;/span&gt;*)buffer, &lt;span&gt;0&lt;/span&gt;, size*&lt;span&gt;nmemb);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; size*&lt;span&gt;nmemb;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;@ Brief:        POST请求
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;@ Author:        woniu201 
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;@ Created:        2018/10/15
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;@ Return:            
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;***********************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HttpPost(&lt;span&gt;char&lt;/span&gt;* url, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; body)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;&lt;span&gt; respBodyData;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;&lt;span&gt; respHeadData;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     CURL*&lt;span&gt; curl;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    CURLcode res;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置头&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; curl_slist *headers =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     headers = curl_slist_append(headers, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type:application/json;charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     
&lt;span&gt;40&lt;/span&gt;     curl =&lt;span&gt; curl_easy_init();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (curl ==&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    curl_easy_setopt(curl, CURLOPT_URL, url);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, WritePostHeaderResp);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WritePostBodyResp);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     curl_easy_setopt(curl, CURLOPT_WRITEHEADER, &amp;amp;&lt;span&gt;respHeadData);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;amp;&lt;span&gt;respBodyData);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;      curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 5000); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;libcurl存在毫秒超时bug,如果设备小于1000ms立即返回失败
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;      curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 5000); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置超时时间&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; bCA =&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;bCA)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, FALSE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定为不验证证书和HOST &lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, FALSE); 
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE); 
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         curl_easy_setopt(curl, CURLOPT_CAINFO, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; 
&lt;span&gt;70&lt;/span&gt;     res =&lt;span&gt; curl_easy_perform(curl);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (res !=&lt;span&gt; CURLE_OK)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         cout &amp;lt;&amp;lt; curl_easy_strerror(res) &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;    curl_slist_free_all(headers);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;    curl_easy_cleanup(curl);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; 
&lt;span&gt;78&lt;/span&gt;     cout &amp;lt;&amp;lt; Utf8ToAscii(respHeadData) &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;     cout &amp;lt;&amp;lt; Utf8ToAscii(respBodyData) &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;其他代码：&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;85&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*******************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Copyright (C),  2016-2018,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;FileName:        utils
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;Author:            woniu201
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;Email:             wangpengfei.201@163.com
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;Created:           2018/10/15
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;Description:    ASSIC--UTF8互转
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;*******************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt;11&lt;/span&gt; #include &amp;lt;Windows.h&amp;gt;
&lt;span&gt;12&lt;/span&gt; #include &amp;lt;wchar.h&amp;gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; wstring    AsciiToUnicode(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&amp;amp;&lt;span&gt; str) {  
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 预算-缓冲区中宽字节的长度    &lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; unicodeLen = MultiByteToWideChar(CP_ACP, &lt;span&gt;0&lt;/span&gt;, str.c_str(), -&lt;span&gt;1&lt;/span&gt;, nullptr, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给指向缓冲区的指针变量分配内存    &lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     wchar_t *pUnicode = (wchar_t*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(wchar_t)*&lt;span&gt;unicodeLen);  
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始向缓冲区转换字节    &lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     MultiByteToWideChar(CP_ACP, &lt;span&gt;0&lt;/span&gt;, str.c_str(), -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, pUnicode, unicodeLen);  
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     wstring ret_str =&lt;span&gt; pUnicode;  
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pUnicode);  
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret_str;  
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}  
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UnicodeToAscii(&lt;span&gt;const&lt;/span&gt; wstring&amp;amp;&lt;span&gt; wstr) {  
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 预算-缓冲区中多字节的长度    &lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ansiiLen = WideCharToMultiByte(CP_ACP, &lt;span&gt;0&lt;/span&gt;, wstr.c_str(), -&lt;span&gt;1&lt;/span&gt;, nullptr, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, nullptr, nullptr);  
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给指向缓冲区的指针变量分配内存    &lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *pAssii = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;)*&lt;span&gt;ansiiLen);  
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始向缓冲区转换字节    &lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     WideCharToMultiByte(CP_ACP, &lt;span&gt;0&lt;/span&gt;, wstr.c_str(), -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, pAssii, ansiiLen, nullptr, nullptr);  
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt; ret_str =&lt;span&gt; pAssii;  
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pAssii);  
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret_str;  
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; wstring Utf8ToUnicode(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&amp;amp;&lt;span&gt; str) {  
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 预算-缓冲区中宽字节的长度    &lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; unicodeLen = MultiByteToWideChar(CP_UTF8, &lt;span&gt;0&lt;/span&gt;, str.c_str(), -&lt;span&gt;1&lt;/span&gt;, nullptr, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给指向缓冲区的指针变量分配内存    &lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     wchar_t *pUnicode = (wchar_t*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(wchar_t)*&lt;span&gt;unicodeLen);  
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始向缓冲区转换字节    &lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     MultiByteToWideChar(CP_UTF8, &lt;span&gt;0&lt;/span&gt;, str.c_str(), -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, pUnicode, unicodeLen);  
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     wstring ret_str =&lt;span&gt; pUnicode;  
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pUnicode);  
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret_str;  
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;}  
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UnicodeToUtf8(&lt;span&gt;const&lt;/span&gt; wstring&amp;amp;&lt;span&gt; wstr) {  
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 预算-缓冲区中多字节的长度    &lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ansiiLen = WideCharToMultiByte(CP_UTF8, &lt;span&gt;0&lt;/span&gt;, wstr.c_str(), -&lt;span&gt;1&lt;/span&gt;, nullptr, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, nullptr, nullptr);  
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给指向缓冲区的指针变量分配内存    &lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *pAssii = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;)*&lt;span&gt;ansiiLen);  
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始向缓冲区转换字节    &lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     WideCharToMultiByte(CP_UTF8, &lt;span&gt;0&lt;/span&gt;, wstr.c_str(), -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, pAssii, ansiiLen, nullptr, nullptr);  
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt; ret_str =&lt;span&gt; pAssii;  
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pAssii);  
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret_str;  
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;}  
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;@ Brief:        ASSIC转UTF8
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;@ Author:        woniu201 
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;@ Created:        2018/10/16
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;@ Return:            
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;***********************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AsciiToUtf8(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&amp;amp;&lt;span&gt; str) {  
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; UnicodeToUtf8(AsciiToUnicode(str));  
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;}  
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;@ Brief:        UTF8转ASSIC
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;@ Author:        woniu201 
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;@ Created:        2018/10/16
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;@ Return:            
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;***********************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Utf8ToAscii(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&amp;amp;&lt;span&gt; str) {  
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; UnicodeToAscii(Utf8ToUnicode(str));  
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; }  
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef _MAIN_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; _MAIN_H
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;include/curl.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;ssleay32.lib&quot;)
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;libcurl.lib&quot;)
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AsciiToUtf8(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&amp;amp;&lt;span&gt; str);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Utf8ToAscii(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&amp;amp;&lt;span&gt; str);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HttpGet(&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; url);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HttpPost(&lt;span&gt;char&lt;/span&gt;* url, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; body);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HttpDownload(&lt;span&gt;char&lt;/span&gt;* url,  &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; filePath);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应libcurl库和头文件下载地址(支持HTTPS)：&lt;a href=&quot;https://download.csdn.net/download/woniu211111/10724021&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Oct 2018 07:31:00 +0000</pubDate>
<dc:creator>蜗牛201</dc:creator>
<og:description>c/c++开发中经常要用到http/https协议，直接使用socket工作量很大，要是使用socket实现https，那更不可思议，开源的c/c++的http客户端框架，libcurl是首选，而且也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woniu201/p/9798278.html</dc:identifier>
</item>
<item>
<title>KClient——kafka消息中间件源码解读 - NinWoo</title>
<link>http://www.cnblogs.com/NinWoo/p/9798270.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NinWoo/p/9798270.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;最近在拜读李艳鹏的《可伸缩服务架构——框架与中间件》，该篇随笔，针对第二章的KClient（kafka消息中间件）源码解读项目，进行学习。&lt;/p&gt;

&lt;p&gt;从使用角度上开始入手学习&lt;/p&gt;
&lt;h2 id=&quot;kclient-processor&quot;&gt;kclient-processor&lt;/h2&gt;
&lt;p&gt;该项目使用springboot调用kclient库，程序目录如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;domain
&lt;ul&gt;&lt;li&gt;Cat ： 定义了一个cat对象&lt;/li&gt;
&lt;li&gt;Dog ： 定义了一个Dog对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;handler ： 消息处理器
&lt;ul&gt;&lt;li&gt;AnimalsHandler ： 定义了Cat和Dog的具体行为&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;KClientApplication.java ： Spring boot的主函数——程序执行入口&lt;/li&gt;
&lt;li&gt;KClientController.java : Controller 文件&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;top.ninwoo.kclient.app.kclientapplication&quot;&gt;top.ninwoo.kclient.app.KClientApplication&lt;/h3&gt;
&lt;p&gt;1.启动Spring Boot&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ApplicationContext ctxBackend = SpringApplication.run(
                KClientApplication.class, args);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.启动程序后将自动加载KClientController(@RestController)&lt;/p&gt;
&lt;h3 id=&quot;top.ninwoo.kclient.app.kclientcontroller&quot;&gt;top.ninwoo.kclient.app.KClientController&lt;/h3&gt;
&lt;p&gt;1.通过@RestController，使@SpringBootApplication,可以自动加载该Controller&lt;/p&gt;
&lt;p&gt;2.通过&lt;code&gt;kafka-application.xml&lt;/code&gt;加载Beans&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private ApplicationContext ctxKafkaProcessor =
            new ClassPathXmlApplicationContext(&quot;kafka-application.xml&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;kafka-application.xml&lt;/code&gt;声明了一个kclient bean，并设置其初始化执行&lt;code&gt;init&lt;/code&gt;方法，具体实现见下章具体实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean name=&quot;kClientBoot&quot; class=&quot;top.ninwoo.kafka.kclient.boot.KClientBoot&quot; init-method=&quot;init&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外声明了一个扫描消息处理器的bean&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;context:component-scan base-package=&quot;top.ninwoo.kclient.app.handler&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体内容在下一节介绍&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;@RequestMapping&lt;/code&gt;定义&lt;code&gt;/&lt;/code&gt;,&lt;code&gt;/status&lt;/code&gt;,&lt;code&gt;/stop&lt;/code&gt;,&lt;code&gt;/restart&lt;/code&gt;定义了不同的接口&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些接口实现比较简单，需要注意的是他们调用的&lt;code&gt;getKClientBoot()&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;上文，我们已经通过xml中，添加了两个Bean，调用Bean的具体实现方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private KClientBoot getKClientBoot() {
        return (KClientBoot) ctxKafkaProcessor.getBean(&quot;kClientBoot&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过Bean获取到KClient获取到了KClientBoot对象，便可以调用其具体方法。&lt;/p&gt;
&lt;h3 id=&quot;top.ninwoo.kclient.app.handler.animalshandler&quot;&gt;top.ninwoo.kclient.app.handler.AnimalsHandler&lt;/h3&gt;
&lt;p&gt;消息处理函数&lt;/p&gt;
&lt;p&gt;1.使用&lt;code&gt;@KafkaHandlers&lt;/code&gt;进行声明bean，关于其具体实现及介绍在具体实现中进行介绍&lt;/p&gt;
&lt;p&gt;2.定义了三个处理函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dogHandler&lt;/li&gt;
&lt;li&gt;catHandler&lt;/li&gt;
&lt;li&gt;ioExceptionHandler&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;dogHandler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体处理很简单，主要分析@InputConsumer和@Consumer的作用，具体实现将在后续进行介绍。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @InputConsumer(propertiesFile = &quot;kafka-consumer.properties&quot;, topic = &quot;test&quot;, streamNum = 1)
    @OutputProducer(propertiesFile = &quot;kafka-producer.properties&quot;, defaultTopic = &quot;test1&quot;)
    public Cat dogHandler(Dog dog) {
        System.out.println(&quot;Annotated dogHandler handles: &quot; + dog);

        return new Cat(dog);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@InputConsumer&lt;/code&gt;根据输入参数定义了一个Consumer，通过该Consumer传递具体值给dog，作为该处理函数的&lt;br/&gt;输入。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@OutputProducer&lt;/code&gt;根据输入参数定义一个Producer，而该处理函数最后返回的Cat对象，将通过该Producer最终传递到Kafka中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下的功能与上述相同，唯一需要注意的是 &lt;code&gt;@InputConsumer&lt;/code&gt;和&lt;code&gt;@OutputProducer&lt;/code&gt;可以单独存在。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@InputConsumer(propertiesFile = &quot;kafka-consumer.properties&quot;, topic = &quot;test1&quot;, streamNum = 1)
    public void catHandler(Cat cat) throws IOException {
        System.out.println(&quot;Annotated catHandler handles: &quot; + cat);

        throw new IOException(&quot;Man made exception.&quot;);
    }

    @ErrorHandler(exception = IOException.class, topic = &quot;test1&quot;)
    public void ioExceptionHandler(IOException e, String message) {
        System.out.println(&quot;Annotated excepHandler handles: &quot; + e);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;top.ninwoo.kclient.app.domain&quot;&gt;top.ninwoo.kclient.app.domain&lt;/h3&gt;
&lt;p&gt;只是定义了Cat和Dog对象，不做赘述。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;到这里，总结下我们都实现了哪些功能？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;程序启动&lt;/li&gt;
&lt;li&gt;调用KClientBoot.init()方法&lt;/li&gt;
&lt;li&gt;AnimalsHandler定义了消费者和生产者的具体方法。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;kclient-core&quot;&gt;kclient-core&lt;/h2&gt;
&lt;p&gt;kclient消息中间件的主体部分，该部分将会涉及&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;kafka基本操作&lt;/li&gt;
&lt;li&gt;反射&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;项目结构如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;boot
&lt;ul&gt;&lt;li&gt;ErrorHandler&lt;/li&gt;
&lt;li&gt;InputConsumer&lt;/li&gt;
&lt;li&gt;OutputProducer&lt;/li&gt;
&lt;li&gt;KafkaHandlers&lt;/li&gt;
&lt;li&gt;KClientBoot&lt;/li&gt;
&lt;li&gt;KafkaHandler&lt;/li&gt;
&lt;li&gt;KafkaHandlerMeta&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;core
&lt;ul&gt;&lt;li&gt;KafkaConsumer&lt;/li&gt;
&lt;li&gt;KafkaProducer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;excephandler
&lt;ul&gt;&lt;li&gt;DefaultExceptionHandler&lt;/li&gt;
&lt;li&gt;ExceptionHandler&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;handlers
&lt;ul&gt;&lt;li&gt;BeanMessageHandler&lt;/li&gt;
&lt;li&gt;BeansMessageHandler&lt;/li&gt;
&lt;li&gt;DocumentMessageHandler&lt;/li&gt;
&lt;li&gt;ObjectMessageHandler&lt;/li&gt;
&lt;li&gt;ObjectsMessageHandler&lt;/li&gt;
&lt;li&gt;MessageHandler&lt;/li&gt;
&lt;li&gt;SafelyMessageHandler&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;reflection.util
&lt;ul&gt;&lt;li&gt;AnnotationHandler&lt;/li&gt;
&lt;li&gt;AnnotationTranversor&lt;/li&gt;
&lt;li&gt;TranversorContext&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在接下来的源码阅读中，我将按照程序执行的顺序进行解读。如果其中涉及到没有讨论过的模块，读者可以向下翻阅。这么&lt;br/&gt;做的唯一原因，为了保证思维的连续性，尽可能不被繁杂的程序打乱。&lt;/p&gt;
&lt;h3 id=&quot;top.ninwoo.kafka.kclient.boot.kclientboot&quot;&gt;top.ninwoo.kafka.kclient.boot.KClientBoot&lt;/h3&gt;
&lt;p&gt;如果读者刚刚阅读上一章节，那么可能记得，我们注册了一个kClientBoot的bean，并设置了初始化函数init(),所以，在kclient源码的阅读中&lt;br/&gt;，我们将从该文件入手，开始解读。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void init() {
        meta = getKafkaHandlerMeta();

        if (meta.size() == 0)
            throw new IllegalArgumentException(
                    &quot;No handler method is declared in this spring context.&quot;);

        for (final KafkaHandlerMeta kafkaHandlerMeta : meta) {
            createKafkaHandler(kafkaHandlerMeta);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.该函数，首先获取了一个HandlerMeta，我们可以简单理解，在这个数据元中，存储了全部的Handler信息，这个Handler信息指的是上一章节中通过&lt;code&gt;@KafkaHandlers&lt;/code&gt;定义的处理函数，&lt;br/&gt;具体实现见&lt;code&gt;top.ninwoo.kafka.kclient.boot.KafkaHandlerMeta&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;2.获取数据元之后，通过循环，创建对应的处理函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    for (final KafkaHandlerMeta kafkaHandlerMeta : meta) {
            createKafkaHandler(kafkaHandlerMeta);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.getKafkaHandlerMeta函数的具体实现&lt;/p&gt;
&lt;p&gt;a.通过applicationContext获取包含kafkaHandlers注解的Bean名称。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String[] kafkaHandlerBeanNames = applicationContext
    .getBeanNamesForAnnotation(KafkaHandlers.class);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;b.通过BeanName获取到Bean对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Object kafkaHandlerBean = applicationContext
        .getBean(kafkaHandlerBeanName);
    Class&amp;lt;? extends Object&amp;gt; kafkaHandlerBeanClazz = kafkaHandlerBean
        .getClass();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;c.构建mapData数据结构,具体构建见&lt;code&gt;top.ninwoo.kafka.kclient.reflection.util.AnnotationTranversor&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Map&amp;lt;Class&amp;lt;? extends Annotation&amp;gt;, Map&amp;lt;Method, Annotation&amp;gt;&amp;gt; mapData = extractAnnotationMaps(kafkaHandlerBeanClazz);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;d.map转数据元并添加到数据元meta list中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    meta.addAll(convertAnnotationMaps2Meta(mapData, kafkaHandlerBean));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.循环遍历创建kafkaHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    for (final KafkaHandlerMeta kafkaHandlerMeta : meta) {
            createKafkaHandler(kafkaHandlerMeta);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;createkafkahandler函数的具体实现&quot;&gt;createKafkaHandler()函数的具体实现：&lt;/h4&gt;
&lt;p&gt;a.通过meta获取clazz中的参数类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class&amp;lt;? extends Object&amp;gt; paramClazz = kafkaHandlerMeta
    .getParameterType()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;b.创建kafkaProducer&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;KafkaProducer kafkaProducer = createProducer(kafkaHandlerMeta);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;c.创建ExceptionHandler&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;ExceptionHandler&amp;gt; excepHandlers = createExceptionHandlers(kafkaHandlerMeta);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;d.根据clazz的参数类型，选择消息转换函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    MessageHandler beanMessageHandler = null;
        if (paramClazz.isAssignableFrom(JSONObject.class)) {
            beanMessageHandler = createObjectHandler(kafkaHandlerMeta,
                    kafkaProducer, excepHandlers);
        } else if (paramClazz.isAssignableFrom(JSONArray.class)) {
            beanMessageHandler = createObjectsHandler(kafkaHandlerMeta,
                    kafkaProducer, excepHandlers);
        } else if (List.class.isAssignableFrom(Document.class)) {
            beanMessageHandler = createDocumentHandler(kafkaHandlerMeta,
                    kafkaProducer, excepHandlers);
        } else if (List.class.isAssignableFrom(paramClazz)) {
            beanMessageHandler = createBeansHandler(kafkaHandlerMeta,
                    kafkaProducer, excepHandlers);
        } else {
            beanMessageHandler = createBeanHandler(kafkaHandlerMeta,
                    kafkaProducer, excepHandlers);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;e.创建kafkaConsumer,并启动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        KafkaConsumer kafkaConsumer = createConsumer(kafkaHandlerMeta,
                beanMessageHandler);
        kafkaConsumer.startup();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;f.创建KafkaHanlder,并添加到列表中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        KafkaHandler kafkaHandler = new KafkaHandler(kafkaConsumer,
                kafkaProducer, excepHandlers, kafkaHandlerMeta);

        kafkaHandlers.add(kafkaHandler);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;createexceptionhandlers的具体实现&quot;&gt;createExceptionHandlers的具体实现&lt;/h4&gt;
&lt;p&gt;1.创建一个异常处理列表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;ExceptionHandler&amp;gt; excepHandlers = new ArrayList&amp;lt;ExceptionHandler&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.从kafkaHandlerMeta获取异常处理的注解&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (final Map.Entry&amp;lt;ErrorHandler, Method&amp;gt; errorHandler : kafkaHandlerMeta
    .getErrorHandlers().entrySet()) {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.创建一个异常处理对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ExceptionHandler exceptionHandler = new ExceptionHandler() {
    public boolean support(Throwable t) {}
    public void handle(Throwable t, String message) {}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;support方法判断异常类型是否和输入相同&quot;&gt;support方法判断异常类型是否和输入相同&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;    public boolean support(Throwable t) {
        // We handle the exception when the classes are exactly same
        return errorHandler.getKey().exception() == t.getClass();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h5 id=&quot;handler方法进一步对异常进行处理&quot;&gt;handler方法，进一步对异常进行处理&lt;/h5&gt;
&lt;p&gt;1.获取异常处理方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Method excepHandlerMethod = errorHandler.getValue();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.使用Method.invoke执行异常处理方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;excepHandlerMethod.invoke(kafkaHandlerMeta.getBean(),
                   t, message);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里用到了一些反射原理，以下对invoke做简单介绍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Object invoke(Object obj,
                     Object... args)
              throws IllegalAccessException,
                     IllegalArgumentException,
                     InvocationTargetException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;obj 从底层方法被调用的对象&lt;/li&gt;
&lt;li&gt;args 用于方法的参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在该项目中的实际情况如下：&lt;/p&gt;
&lt;p&gt;Method实际对应&lt;code&gt;top.ninwoo.kclient.app.handler.AnimalsHandler&lt;/code&gt;中的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @ErrorHandler(exception = IOException.class, topic = &quot;test1&quot;)
    public void ioExceptionHandler(IOException e, String message) {
        System.out.println(&quot;Annotated excepHandler handles: &quot; + e);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;kafkaHandlerMeta.getBean() ： AninmalsHandler&lt;/li&gt;
&lt;li&gt;t&lt;/li&gt;
&lt;li&gt;message&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;invoke完成之后，将会执行ioExceptionHandler函数&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;4.添加异常处理到列表中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;excepHandlers.add(exceptionHandler);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;createobjecthandler&quot;&gt;createObjectHandler&lt;/h3&gt;
&lt;h3 id=&quot;createobjectshandler&quot;&gt;createObjectsHandler&lt;/h3&gt;
&lt;h3 id=&quot;createdocumenthandler&quot;&gt;createDocumentHandler&lt;/h3&gt;
&lt;h3 id=&quot;createbeanhandler&quot;&gt;createBeanHandler&lt;/h3&gt;
&lt;h3 id=&quot;createbeanshandler&quot;&gt;createBeansHandler&lt;/h3&gt;
&lt;p&gt;以上均实现了类似的功能，只是创建了不同类型的对象，然后重写了不同的执行函数。&lt;/p&gt;
&lt;p&gt;实现原理和异常处理相同，底层都是调用了invoke函数，通过反射机制启动了对应的函数。&lt;/p&gt;
&lt;p&gt;下一节对此做了详细介绍&lt;/p&gt;
&lt;h3 id=&quot;invokehandler&quot;&gt;invokeHandler&lt;/h3&gt;
&lt;p&gt;1.获取对应Method方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Method kafkaHandlerMethod = kafkaHandlerMeta.getMethod();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.执行接收返回结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object result = kafkaHandlerMethod.invoke(
    kafkaHandlerMeta.getBean(), parameter);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.如果生产者非空，意味着需要通过生产者程序将结果发送到Kafka中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (kafkaProducer != null) {
    if (result instanceof JSONObject)
        kafkaProducer.send(((JSONObject) result).toJSONString());
    else if (result instanceof JSONArray)
        kafkaProducer.send(((JSONArray) result).toJSONString());
    else if (result instanceof Document)
        kafkaProducer.send(((Document) result).getTextContent());
    else
        kafkaProducer.send(JSON.toJSONString(result));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生产者和消费者创建方法&quot;&gt;生产者和消费者创建方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;
    protected KafkaConsumer createConsumer(
            final KafkaHandlerMeta kafkaHandlerMeta,
            MessageHandler beanMessageHandler) {
        KafkaConsumer kafkaConsumer = null;

        if (kafkaHandlerMeta.getInputConsumer().fixedThreadNum() &amp;gt; 0) {
            kafkaConsumer = new KafkaConsumer(kafkaHandlerMeta
                    .getInputConsumer().propertiesFile(), kafkaHandlerMeta
                    .getInputConsumer().topic(), kafkaHandlerMeta
                    .getInputConsumer().streamNum(), kafkaHandlerMeta
                    .getInputConsumer().fixedThreadNum(), beanMessageHandler);

        } else if (kafkaHandlerMeta.getInputConsumer().maxThreadNum() &amp;gt; 0
                &amp;amp;&amp;amp; kafkaHandlerMeta.getInputConsumer().minThreadNum() &amp;lt; kafkaHandlerMeta
                .getInputConsumer().maxThreadNum()) {
            kafkaConsumer = new KafkaConsumer(kafkaHandlerMeta
                    .getInputConsumer().propertiesFile(), kafkaHandlerMeta
                    .getInputConsumer().topic(), kafkaHandlerMeta
                    .getInputConsumer().streamNum(), kafkaHandlerMeta
                    .getInputConsumer().minThreadNum(), kafkaHandlerMeta
                    .getInputConsumer().maxThreadNum(), beanMessageHandler);

        } else {
            kafkaConsumer = new KafkaConsumer(kafkaHandlerMeta
                    .getInputConsumer().propertiesFile(), kafkaHandlerMeta
                    .getInputConsumer().topic(), kafkaHandlerMeta
                    .getInputConsumer().streamNum(), beanMessageHandler);
        }

        return kafkaConsumer;
    }


    protected KafkaProducer createProducer(
            final KafkaHandlerMeta kafkaHandlerMeta) {
        KafkaProducer kafkaProducer = null;

        if (kafkaHandlerMeta.getOutputProducer() != null) {
            kafkaProducer = new KafkaProducer(kafkaHandlerMeta
                    .getOutputProducer().propertiesFile(), kafkaHandlerMeta
                    .getOutputProducer().defaultTopic());
        }

        // It may return null
        return kafkaProducer;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两部分比较简单，不做赘述。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;KClientBoot.java实现了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取使用KafkaHandlers中定义注释的方法及其它信息&lt;/li&gt;
&lt;li&gt;基于反射机制，生成处理函数。&lt;/li&gt;
&lt;li&gt;执行处理函数&lt;/li&gt;
&lt;li&gt;创建对应Producer和Consumer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还剩余几个比较简单的部分，比如shutdownAll()等方法，将在具体实现处进行补充介绍。&lt;/p&gt;
&lt;p&gt;到此，整个项目的主体功能都已经实现。接下来，将分析上文中出现频率最高的&lt;code&gt;kafkaHandlerMeta&lt;/code&gt;与生产者消费者的具体实现。&lt;/p&gt;

&lt;p&gt;KafkaHandlerMeta存储了全部的可用信息，该类实现比较简单，主要分析其成员对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Object bean : 存储底层的bean对象&lt;/li&gt;
&lt;li&gt;Method method ： 存储方法对象&lt;/li&gt;
&lt;li&gt;Class&amp;lt;? extends Object&amp;gt; parameterType ： 存储参数的类型&lt;/li&gt;
&lt;li&gt;InputConsumer inputConsumer ： 输入消费者注解对象，其中存储着创建Consumer需要的配置&lt;/li&gt;
&lt;li&gt;OutputProducer outputProducer ： 输出生产者注解对象，其中存储着创建Producer需要的配置&lt;/li&gt;
&lt;li&gt;Map&amp;lt;ErrorHandler, Method&amp;gt; errorHandlers = new HashMap&amp;lt;ErrorHandler, Method&amp;gt;() 异常处理函数与其方法组成的Map&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;top.ninwoo.kafka.kclient.core.kafkaproducer&quot;&gt;top.ninwoo.kafka.kclient.core.KafkaProducer&lt;/h2&gt;
&lt;p&gt;该类主要通过多态封装了kafka Producer的接口，提供了更加灵活丰富的api接口，比较简单不做赘述。&lt;/p&gt;
&lt;h2 id=&quot;top.ninwoo.kafka.kclient.core.kafkaconsumer&quot;&gt;top.ninwoo.kafka.kclient.core.KafkaConsumer&lt;/h2&gt;
&lt;p&gt;该类的核心功能是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;加载配置文件&lt;/li&gt;
&lt;li&gt;初始化线程池&lt;/li&gt;
&lt;li&gt;初始化GracefullyShutdown函数&lt;/li&gt;
&lt;li&gt;初始化kafka连接&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在这里跳过构造函数，但在进入核心问题前，先明确几个成员变量的作用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;streamNum : 创建消息流的数量&lt;/li&gt;
&lt;li&gt;fixedThreadNum ： 异步线程池中的线程数量&lt;/li&gt;
&lt;li&gt;minThreadNum ： 异步线程池的最小线程数&lt;/li&gt;
&lt;li&gt;maxThreadNum ： 异步线程池的最大线程数&lt;/li&gt;
&lt;li&gt;stream : kafka消息流&lt;/li&gt;
&lt;li&gt;streamThreadPool : kafka消息处理线程池&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在每个构造函数后都调用了init()方法，所以我们从init()入手。另外一个核心方法startup()将在介绍完init()函数进行介绍。&lt;/p&gt;
&lt;h3 id=&quot;init&quot;&gt;init()&lt;/h3&gt;
&lt;p&gt;在执行核心代码前，进行了一系列的验证，这里跳过该部分。&lt;/p&gt;
&lt;p&gt;1.加载配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;properties = loadPropertiesfile();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.如果共享异步线程池，则初始化异步线程池&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sharedAsyncThreadPool = initAsyncThreadPool();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.初始化优雅关闭&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;initGracefullyShutdown();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.初始化kafka连接&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;initKafka();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;initasyncthreadpool&quot;&gt;initAsyncThreadPool()&lt;/h3&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private ExecutorService initAsyncThreadPool() {
        ExecutorService syncThreadPool = null;
        if (fixedThreadNum &amp;gt; 0)
            syncThreadPool = Executors.newFixedThreadPool(fixedThreadNum);
        else
            syncThreadPool = new ThreadPoolExecutor(minThreadNum, maxThreadNum,
                    60L, TimeUnit.SECONDS, new SynchronousQueue&amp;lt;Runnable&amp;gt;());

        return syncThreadPool;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，如果异步线程数大于0，则使用该参数进行创建线程池。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;syncThreadPool = Executors.newFixedThreadPool(fixedThreadNum);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果线程数不大于0，使用minThreadNum,maxThreadNum进行构造线程池。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;syncThreadPool = new ThreadPoolExecutor(minThreadNum, maxThreadNum,
                    60L, TimeUnit.SECONDS, new SynchronousQueue&amp;lt;Runnable&amp;gt;());&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;executors简介&quot;&gt;Executors简介&lt;/h4&gt;
&lt;p&gt;这里介绍Executors提供的四种线程池&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。&lt;/li&gt;
&lt;li&gt;newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。&lt;/li&gt;
&lt;li&gt;newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。&lt;/li&gt;
&lt;li&gt;newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;threadpoolexecutor简介&quot;&gt;ThreadPoolExecutor简介&lt;/h4&gt;
&lt;p&gt;ThreadPooExecutor与Executor的关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171225112037173?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU4MDY4NjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构造方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue)；

ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, RejectedExecutionHandler handler)

ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory)

ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;corePoolSize&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;核心线程数，默认情况下核心线程会一直存活，即使处于闲置状态也不会受存keepAliveTime限制。除非将allowCoreThreadTimeOut设置为true。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;maximumPoolSize&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;线程池所能容纳的最大线程数。超过这个数的线程将被阻塞。当任务队列为没有设置大小的LinkedBlockingDeque时，这个值无效。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;keepAliveTime&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;非核心线程的闲置超时时间，超过这个时间就会被回收。&lt;/p&gt;
&lt;p&gt;指定keepAliveTime的单位，如TimeUnit.SECONDS。当将allowCoreThreadTimeOut设置为true时对corePoolSize生效。&lt;/p&gt;
&lt;p&gt;线程池中的任务队列.&lt;/p&gt;
&lt;p&gt;常用的有三种队列，SynchronousQueue,LinkedBlockingDeque,ArrayBlockingQueue。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SynchronousQueue&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;线程工厂，提供创建新线程的功能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RejectedExecutionHandler&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用RejectedExecutionHandler的rejectedExecution方法。&lt;/p&gt;
&lt;h2 id=&quot;initkafka&quot;&gt;initKafka&lt;/h2&gt;
&lt;p&gt;由于kafka API已经改动很多，所以这里关于Kafka的操作仅做参考，不会详细介绍。&lt;/p&gt;
&lt;p&gt;1.加载Consumer配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ConsumerConfig config = new ConsumerConfig(properties);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.创建consumerConnector连接&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;consumerConnector = Consumer.createJavaConsumerConnector(config);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.存储kafka topic与对应设置的消息流数量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Map&amp;lt;String, Integer&amp;gt; topics = new HashMap&amp;lt;String, Integer&amp;gt;();
topics.put(topic, streamNum);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.从kafka获取消息流&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Map&amp;lt;String, List&amp;lt;KafkaStream&amp;lt;String, String&amp;gt;&amp;gt;&amp;gt; streamsMap = consumerConnector
         .createMessageStreams(topics, keyDecoder, valueDecoder);
streams = streamsMap.get(topic);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.创建消息处理线程池&lt;/p&gt;
&lt;h2 id=&quot;startup&quot;&gt;startup()&lt;/h2&gt;
&lt;p&gt;上述init()主要介绍了kafka消费者的初始化，而startup()则是kafkaConsumer作为消费者进行消费动作的核心功能代码。&lt;/p&gt;
&lt;p&gt;1.依次处理消息线程streams中的消息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (KafkaStream&amp;lt;String, String&amp;gt; stream : streams) {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.创建消息任务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AbstractMessageTask abstractMessageTask = (fixedThreadNum == 0 ? new SequentialMessageTask(
    stream, handler) : new ConcurrentMessageTask(stream, handler, fixedThreadNum));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.添加到tasks中，以方便关闭进程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tasks.add(abstractMessageTask);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.执行任务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;streamThreadPool.execute(abstractMessageTask);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;abstractmessagetask&quot;&gt;AbstractMessageTask&lt;/h2&gt;
&lt;p&gt;任务执行的抽象类，核心功能如下从消息线程池中不断获取消息，进行消费。&lt;br/&gt;下面是完整代码，不再详细介绍：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    abstract class AbstractMessageTask implements Runnable {
        protected KafkaStream&amp;lt;String, String&amp;gt; stream;

        protected MessageHandler messageHandler;

        AbstractMessageTask(KafkaStream&amp;lt;String, String&amp;gt; stream,
                            MessageHandler messageHandler) {
            this.stream = stream;
            this.messageHandler = messageHandler;
        }

        public void run() {
            ConsumerIterator&amp;lt;String, String&amp;gt; it = stream.iterator();
            while (status == Status.RUNNING) {
                boolean hasNext = false;
                try {
                    // When it is interrupted if process is killed, it causes some duplicate message processing, because it commits the message in a chunk every 30 seconds
                    hasNext = it.hasNext();
                } catch (Exception e) {
                    // hasNext() method is implemented by scala, so no checked
                    // exception is declared, in addtion, hasNext() may throw
                    // Interrupted exception when interrupted, so we have to
                    // catch Exception here and then decide if it is interrupted
                    // exception
                    if (e instanceof InterruptedException) {
                        log.info(
                                &quot;The worker [Thread ID: {}] has been interrupted when retrieving messages from kafka broker. Maybe the consumer is shutting down.&quot;,
                                Thread.currentThread().getId());
                        log.error(&quot;Retrieve Interrupted: &quot;, e);

                        if (status != Status.RUNNING) {
                            it.clearCurrentChunk();
                            shutdown();
                            break;
                        }
                    } else {
                        log.error(
                                &quot;The worker [Thread ID: {}] encounters an unknown exception when retrieving messages from kafka broker. Now try again.&quot;,
                                Thread.currentThread().getId());
                        log.error(&quot;Retrieve Error: &quot;, e);
                        continue;
                    }
                }

                if (hasNext) {
                    MessageAndMetadata&amp;lt;String, String&amp;gt; item = it.next();
                    log.debug(&quot;partition[&quot; + item.partition() + &quot;] offset[&quot;
                            + item.offset() + &quot;] message[&quot; + item.message()
                            + &quot;]&quot;);

                    handleMessage(item.message());

                    // if not auto commit, commit it manually
                    if (!isAutoCommitOffset) {
                        consumerConnector.commitOffsets();
                    }
                }
            }

            protected void shutdown() {

                // Actually it doesn't work in auto commit mode, because kafka v0.8 commits once per 30 seconds, so it is bound to consume duplicate messages.
                stream.clear();

            }

            protected abstract void handleMessage(String message);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sequentialmessagetask-sequentialmessagetask&quot;&gt;SequentialMessageTask &amp;amp;&amp;amp; SequentialMessageTask&lt;/h3&gt;
&lt;p&gt;或许您还比较迷惑如何在这个抽象类中实现我们具体的消费方法，实际上是通过子类实现handleMessage方法进行绑定我们具体的消费方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    class SequentialMessageTask extends AbstractMessageTask {
        SequentialMessageTask(KafkaStream&amp;lt;String, String&amp;gt; stream,
                              MessageHandler messageHandler) {
            super(stream, messageHandler);
        }

        @Override
        protected void handleMessage(String message) {
            messageHandler.execute(message);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该子类中，handleMessage直接执行了&lt;code&gt;messageHandler.execute(message)&lt;/code&gt;,而没有调用线程池，所以是顺序消费消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    class ConcurrentMessageTask extends AbstractMessageTask {
        private ExecutorService asyncThreadPool;

        ConcurrentMessageTask(KafkaStream&amp;lt;String, String&amp;gt; stream,
                              MessageHandler messageHandler, int threadNum) {
            super(stream, messageHandler);

            if (isSharedAsyncThreadPool)
                asyncThreadPool = sharedAsyncThreadPool;
            else {
                asyncThreadPool = initAsyncThreadPool();
            }
        }

        @Override
        protected void handleMessage(final String message) {
            asyncThreadPool.submit(new Runnable() {
                public void run() {
                    // if it blows, how to recover
                    messageHandler.execute(message);
                }
            });
        }

        protected void shutdown() {
            if (!isSharedAsyncThreadPool)
                shutdownThreadPool(asyncThreadPool, &quot;async-pool-&quot;
                        + Thread.currentThread().getId());
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ConcurrentMessageTask中， handleMessage调用asyncThreadPool.submit()提交了任务到异步线程池中，是一个并发消费。&lt;/p&gt;
&lt;p&gt;而messageHandler是通过&lt;code&gt;KClientBoot&lt;/code&gt;的createKafkaHandler创建并发送过来的，所以实现了最终的消费。&lt;/p&gt;
&lt;h2 id=&quot;总结-1&quot;&gt;总结：&lt;/h2&gt;
&lt;p&gt;到此全部的项目解读完毕，如果仍有疑惑，可以参看李艳鹏老师的《可伸缩服务架构框架与中间件》一书，同时也可以与我联系交流问题。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Oct 2018 07:30:00 +0000</pubDate>
<dc:creator>NinWoo</dc:creator>
<og:description>[TOC] 最近在拜读李艳鹏的《可伸缩服务架构——框架与中间件》，该篇随笔，针对第二章的KClient（kafka消息中间件）源码解读项目，进行学习。 kclient消息中间件 从使用角度上开始入手学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NinWoo/p/9798270.html</dc:identifier>
</item>
<item>
<title>深入理解synchronized方法同步的是方法还是对象？ - 真正的小明被占用了</title>
<link>http://www.cnblogs.com/SAM-CJM/p/9798263.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SAM-CJM/p/9798263.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一.运用synchronized关键字&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们来看看一个多线程中线程不安全的列子&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;共享数据类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NotSynchronizated &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; num =10&lt;span&gt;;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;当前线程为:&quot;+&lt;span&gt;currentThread().getName());
            num&lt;/span&gt;--&lt;span&gt;;
            System.out.println(&lt;/span&gt;&quot;num的值为:&quot;+&lt;span&gt;num);
            Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;线程测试类:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将共享数据放入3个线程里进行处理&lt;/span&gt;
        NotSynchronizated notSynchronizated = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotSynchronizated();
        Thread t1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Thread(notSynchronizated,&quot;A&quot;&lt;span&gt;);
        Thread t2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Thread(notSynchronizated,&quot;B&quot;&lt;span&gt;);
        Thread t3&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Thread(notSynchronizated,&quot;C&quot;&lt;span&gt;);
        Thread t4&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Thread(notSynchronizated,&quot;D&quot;&lt;span&gt;);
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个列子中run方法没有使用关键字synchronized，那么就会造成线程不安全，结果如下：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181016125600092-1890941269.png&quot; alt=&quot;&quot; width=&quot;106&quot; height=&quot;113&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么当我们使用关键字synchronized后结果就会同步了，结果如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181016125746242-1089384934.png&quot; alt=&quot;&quot; width=&quot;140&quot; height=&quot;117&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，在这里是对这个run方法进行了同步呢？还是对这个对象进行了同步呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二.synchronized同步的是对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 为了证明synchronized同步的是对象，我们举出下面的代码：&lt;/p&gt;
&lt;p&gt;共享资源类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SynchronizatedObject &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; num=20&lt;span&gt;;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){

        System.out.println(&lt;/span&gt;&quot;当前的线程为&quot;+&lt;span&gt;currentThread().getName());
        num&lt;/span&gt;--&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;当前num为&quot;+&lt;span&gt;num);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Text {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {&lt;/span&gt;
        SynchronizatedObject synchronizatedObject1=&lt;span&gt;new&lt;/span&gt; SynchronizatedObject();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第一个资源共享类&lt;/span&gt;
        SynchronizatedObject synchronizatedObject2=&lt;span&gt;new&lt;/span&gt; SynchronizatedObject();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第二个资源共享类&lt;/span&gt;
        Thread t1=&lt;span&gt;new&lt;/span&gt; Thread(synchronizatedObject1,&quot;A&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入&lt;/span&gt;
        Thread t2=&lt;span&gt;new&lt;/span&gt; Thread(synchronizatedObject2,&quot;B&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入&lt;/span&gt;
&lt;span&gt;        t1.start();
        t2.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181016131112218-1115420545.png&quot; alt=&quot;&quot; width=&quot;147&quot; height=&quot;122&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这里明显看出这个synchronized关键字同步的是对象而不是方法，&lt;/p&gt;
&lt;p&gt;如果同步的是方法那么他将不会出现这种线程不安全的情况，而是两对象一个一个按顺序的进入这个同步的方法里，&lt;/p&gt;
&lt;p&gt;出现这中情况，只能说明他是对象同步的。&lt;/p&gt;
&lt;p&gt;所以说这段代码意思是我创建了两个对象，同时我也创建了两把对象锁来同步话各自的run方法，只不过每一条线程的调用顺序不同才会出现这样的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：synchronized关键字同步的是对象不是方法&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 16 Oct 2018 07:29:00 +0000</pubDate>
<dc:creator>真正的小明被占用了</dc:creator>
<og:description>一.运用synchronized关键字 首先我们来看看一个多线程中线程不安全的列子 代码如下： 共享数据类： 线程测试类: 在这个列子中run方法没有使用关键字synchronized，那么就会造成线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SAM-CJM/p/9798263.html</dc:identifier>
</item>
<item>
<title>装饰者模式 - mingmingcome</title>
<link>http://www.cnblogs.com/mingmingcome/p/9798248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mingmingcome/p/9798248.html</guid>
<description>&lt;p&gt;&lt;code&gt;begin 2018年9月29日14:19:22&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;装饰者模式decorator-pattern&quot;&gt;装饰者模式（Decorator Pattern）&lt;/h2&gt;
&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;金玉其外，败絮其中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;动态地给一个对象添加一些额外的职责，就增加功能来说，装饰者模式比生成子类更为灵活。——《设计模式：可复用面向对象软件的基础》&lt;/p&gt;
&lt;p&gt;装饰者模式是一种对象结构型模式。&lt;/p&gt;
&lt;h4 id=&quot;使用场景&quot;&gt;使用场景&lt;/h4&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;角色&quot;&gt;角色&lt;/h4&gt;
&lt;p&gt;抽象构件角色（Component）：定义一个对象接口或抽象类，可以给这些对象动态地添加职责。&lt;/p&gt;
&lt;p&gt;具体构件角色（ConcreteComponent）：实际被动态地添加职责的对象。&lt;/p&gt;
&lt;p&gt;抽象装饰者角色（Decorator）：实现了Component接口，用来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。&lt;/p&gt;
&lt;p&gt;具体装饰者角色（ConcreteDecorator）：动态地添加职责的对象。&lt;/p&gt;
&lt;h4 id=&quot;图示&quot;&gt;图示&lt;/h4&gt;
&lt;p&gt;装饰者模式（Decorator）结构图&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/decorator-class-diagram.jpg&quot; alt=&quot;装饰者模式（Decorator）结构图&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码示例&quot;&gt;代码示例&lt;/h4&gt;
&lt;p&gt;装饰者模式（Decorator）代码示例类图&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/decorator-instance-class-diagram.jpg&quot; alt=&quot;装饰者模式（Decorator）代码示例类图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个关于相亲的故事。某家有女初长成，七大姑八大姨欲帮忙觅得佳婿，后在各种群、圈、网站，收集了各种男人的资料。这里需要一个应用生成收集过来的男人的描述，如：是否有车、是否有房、是否有存款、是否有好品质。然后这个应用了装饰者模式的应用就诞生了，动态添加男人的描述，最后得到男人的综述。&lt;/p&gt;
&lt;p&gt;抽象构件角色（Man.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 男人
public interface Man {
    public void getManDesc();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体构件角色（NormalMan.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 普通男人
public class NormalMan implements Man{
    private String name = null;
    
    public NormalMan(String name) {
        this.name = name;
    }
    
    @Override
    public void getManDesc() {
        System.out.print(name + &quot;: &quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抽象装饰者角色（AttachedPropertiesDecorator.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 附加属性装饰者
public abstract class AttachedPropertiesDecorator implements Man{
    private Man man;
    
    public AttachedPropertiesDecorator(Man man) {
        this.man = man;
    }
    
    public void getManDesc() {
        man.getManDesc();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体装饰者角色（CarDecoratorImpl.java、HouseDecoratorImpl.java、DepositDecoratorImpl.java、QualityDecoratorImpl.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 小车装饰者
public class CarDecoratorImpl extends AttachedPropertiesDecorator{
    private String car = &quot;有车&quot;;
    
    public CarDecoratorImpl(Man man) {
        super(man);
    }
    
    public void addCar() {
        System.out.print(car + &quot; &quot;);
    }
    
    @Override
    public void getManDesc() {
        super.getManDesc();
        addCar();
    }
}

// 房子装饰者
public class HouseDecoratorImpl extends AttachedPropertiesDecorator{
    private String house = &quot;有房&quot;;
    
    public HouseDecoratorImpl(Man man) {
        super(man);
    }
    
    public void addHouse() {
        System.out.print(house + &quot; &quot;);
    }
    
    @Override
    public void getManDesc() {
        super.getManDesc();
        addHouse();
    }
}

// 存款装饰者
public class DepositDecoratorImpl extends AttachedPropertiesDecorator{
    private String deposit = &quot;有存款&quot;;
    
    public DepositDecoratorImpl(Man man) {
        super(man);
    }
    
    public void addDeposit() {
        System.out.print(deposit + &quot; &quot;);
    }
    
    @Override
    public void getManDesc() {
        super.getManDesc();
        addDeposit();
    }
}

// 品质装饰者
public class QualityDecoratorImpl extends AttachedPropertiesDecorator{
    private String quality = &quot;有好品质&quot;;
    
    public QualityDecoratorImpl(Man man) {
        super(man);
    }
    
    public void addQuality() {
        System.out.print(quality + &quot; &quot;);
    }
    
    @Override
    public void getManDesc() {
        super.getManDesc();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有车、有房、有存款、有品质具体修饰者。&lt;/p&gt;
&lt;p&gt;装饰者模式测试类（DecoratorTest.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DecoratorTest {

    public static void main(String[] args) {
        Man man = new NormalMan(&quot;张三&quot;);
        Man man1 = new CarDecoratorImpl(man);
        Man man2 = new HouseDecoratorImpl(man1);
        Man man3 = new DepositDecoratorImpl(man2);
        System.out.println(&quot;层层装饰:&quot;);
        man3.getManDesc();
        System.out.println();
        
        System.out.println(&quot;重复装饰（有两个'有存款'）:&quot;);
        Man man4 = new DepositDecoratorImpl(man3);
        man4.getManDesc();
        System.out.println();
        
        System.out.println(&quot;任意修饰:&quot;);
        Man man5 = new QualityDecoratorImpl(man1);
        man5.getManDesc();
        System.out.println();
        
        System.out.println(&quot;直接得到修饰结果:&quot;);
        Man man6 = new HouseDecoratorImpl(new DepositDecoratorImpl(new NormalMan(&quot;李四&quot;)));
        man6.getManDesc();
        System.out.println();

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/decorator-instance-test-result.png&quot; alt=&quot;运行结果&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;
&lt;p&gt;1、装饰者模式和继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活型。&lt;/p&gt;
&lt;p&gt;2、通过使用不同的具体装饰者类及它们不同的组合顺序，可以得到不同装饰后具有不同行为或者状态的对象。例如上面的CarDecoratorImpl可以多次修饰一个男人，证明他有很多车。&lt;/p&gt;
&lt;p&gt;3、符合开闭原则。&lt;/p&gt;
&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;
&lt;p&gt;1、增加了抽象装饰者类和具体装饰者类，一定程度增加了系统的复杂度，加大了系统的学习和理解成本。&lt;/p&gt;
&lt;p&gt;2、灵活性也意味着更容易出错，对于多次被多次修饰的对象，调试时寻找错误可能需要找到多个地方。&lt;/p&gt;
&lt;h3 id=&quot;装饰者模式进阶&quot;&gt;装饰者模式进阶&lt;/h3&gt;
&lt;h4 id=&quot;透明与半透明的装饰者模式&quot;&gt;透明与半透明的装饰者模式&lt;/h4&gt;
&lt;p&gt;透明的装饰者模式：要求客户端完全针对抽象编程（依赖倒置原则），装饰者模式的透明型要求客户端程序不应该声明具体构件类型和具体装饰者类型，而应该全部声明为抽象构件类型。当然调用的也是抽象构件类声明的接口方法了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Man man = new NormalMan(&quot;张三&quot;);
Man man1 = new CarDecoratorImpl(man);
Man man2 = new HouseDecoratorImpl(man1);
Man man3 = new DepositDecoratorImpl(man2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;半透明的装饰者模式：允许用户在客户端声明具体装饰者类型的对象，允许在具体装饰者中新增方法且客户端可以调用这些新增的方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Man man = new NormalMan(&quot;张三&quot;);
CarDecoratorImpl man1 = new CarDecoratorImpl(man);
HouseDecoratorImpl man2 = new HouseDecoratorImpl(man);
DepositDecoratorImpl man3 = new DepositDecoratorImpl(man);

man1.addCar();
man2.addHouse();
man3.addDeposit();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;java.io中装饰者模式的应用&quot;&gt;java.io中装饰者模式的应用&lt;/h4&gt;
&lt;p&gt;java I/O类继承结构图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/decorator-Java%20IO.jpg&quot; alt=&quot;java I/O类继承结构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然java I/O中类比较多，但是装饰者模式的应用方式是差不多的。下面举一个例子：InputStream及其子类&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/decorator-inputstream-hierarchy.jpg&quot; alt=&quot;InputStream及其子类&quot;/&gt;&lt;/p&gt;
&lt;p&gt;装饰者模式对照上图可得：&lt;/p&gt;
&lt;p&gt;抽象构件角色：InputStream，这是一个抽象类。&lt;/p&gt;
&lt;p&gt;具体构件角色：ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream（已弃用）、AudioInputStream等，实现了InputStream抽象类。&lt;/p&gt;
&lt;p&gt;抽象装饰者角色：FilterInputStream，实现了抽象构件角色，且成为具体装饰者的父类。&lt;/p&gt;
&lt;p&gt;具体装饰者模式：FilterInputStream的子类如常用的BufferedInputStream、DataInputStream，还有其他不常用的CheckedInputStream、CipherInputStream、LineNumberInputStream、PushBackInputStream。这里其实具体的装饰者还有直接继承InputStream的ObjectInputStream、SequenceInputStream，这里涉及到下面介绍的&lt;strong&gt;装饰者模式的简化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里的装饰者模式大多都是半透明的，具体装饰者提供了比抽象构件多的方法，客户端可以使用这些方法。&lt;/p&gt;
&lt;h4 id=&quot;装饰者模式的简化&quot;&gt;装饰者模式的简化&lt;/h4&gt;
&lt;p&gt;装饰者有3种简化模式：&lt;/p&gt;
&lt;p&gt;第一种情况，只有一个具体装饰者，这样就不需要抽象装饰者，具体装饰者直接继承抽象构件就可以了。&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/decorator-class-diagram-simplify1.jpg&quot; alt=&quot;装饰者模式简化的第一种情况&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二种情况，只有一个具体构件，这样就不需要抽象构件，抽象装饰者可以直接继承具体构件就可以了。&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/decorator-class-diagram-simplify2.jpg&quot; alt=&quot;装饰者模式简化的第二种情况&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三种情况，就是上面组合起来：只有一个具体构件和一个具体装饰者，这样抽象角色都不需要了，具体装饰者直接继承集体构件就可以了。&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/decorator-class-diagram-simplify3.jpg&quot; alt=&quot;装饰者模式简化的第三种情况&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;需要动态给某个对象添加职责，使用装饰者模式。&lt;/p&gt;
&lt;h4 id=&quot;完&quot;&gt;完&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;end 2018年10月16日15:24:03&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Oct 2018 07:27:00 +0000</pubDate>
<dc:creator>mingmingcome</dc:creator>
<og:description>`begin 2018年9月29日14:19:22` 装饰者模式（Decorator Pattern） 定义 金玉其外，败絮其中。 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰者模式比生成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mingmingcome/p/9798248.html</dc:identifier>
</item>
<item>
<title>SpringBoot快速入门 - Miya。</title>
<link>http://www.cnblogs.com/SimpleWu/p/9798146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/9798146.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Editor：SimpleWu&lt;/p&gt;
&lt;p&gt;GIT（有本文章所有测试代码实例）：https://gitlab.com/450255266/code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;springboot简介&quot;&gt;SpringBoot简介&lt;/h3&gt;
&lt;p&gt;Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。&lt;/p&gt;
&lt;p&gt;Spring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring引用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。&lt;/p&gt;
&lt;p&gt;Spring Boot的主要优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为所有Spring开发者更快的入门&lt;/li&gt;
&lt;li&gt;开箱即用，提供各种默认配置来简化项目配置&lt;/li&gt;
&lt;li&gt;内嵌式容器简化Web项目&lt;/li&gt;
&lt;li&gt;没有冗余代码生成和XML配置的要求&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;在下面的代码中只要有一定基础会发现这写代码实例非常简单对于开发者来说几乎是“零配置”。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;springboot运行&quot;&gt;SpringBoot运行&lt;/h3&gt;
&lt;p&gt;开发工具：jdk8，IDEA,STS，eclipse（需要安装STS插件）这些都支持快速启动SpringBoot工程。我这里就不快速启动了，使用maven工程。学习任何一项技术首先就要精通HelloWord，那我们来跑个初体验。&lt;/p&gt;
&lt;p&gt;首先只用maven我们创建的maven工程直接以jar包的形式创建就行了，首先我们来引入SpringBoot的依赖&lt;/p&gt;
&lt;p&gt;首先我们需要依赖SpringBoot父工程，这是每个项目中必须要有的。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--引入SpringBoot父依赖--&amp;gt;
&amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.0.5.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; 
&amp;lt;/parent&amp;gt;
&amp;lt;!--编码与JAVA版本--&amp;gt;
&amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
&amp;lt;/properties&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们启动WEB模块当然必须要引入WEB模块的依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
        &amp;lt;!--引入SpringBoot-WEB模块--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要编写一个SpringBoot启动类，SpringbootFirstExperienceApplication.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class SpringbootFirstExperienceApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootFirstExperienceApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到了这里我们直接把他当成SpringMVC来使用就行了，不过这里默认是不支持JSP官方推荐使用模板引擎，后面会写到整合JSP。这里我就不写Controller了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@SpringBootApplication&lt;/strong&gt;：之前用户使用的是3个注解注解他们的main类。分别是@Configuration,@EnableAutoConfiguration,@ComponentScan。由于这些注解一般都是一起使用，spring boot提供了一个统一的注解@SpringBootApplication。&lt;/p&gt;
&lt;p&gt;注意事项：我们使用这个注解在不指定扫描路径的情况下，SpringBoot只能扫描到和SpringbootFirstExperienceApplication同包或子包的Bean；&lt;/p&gt;
&lt;h3 id=&quot;springboot目录结构&quot;&gt;SpringBoot目录结构&lt;/h3&gt;
&lt;p&gt;在src/main/resources中我们可以有几个文件夹：&lt;/p&gt;
&lt;p&gt;templates：用来存储模板引擎的，Thymeleaf，FreeMarker，Velocity等都是不错的选择。&lt;/p&gt;
&lt;p&gt;static：存储一些静态资源，css,js等&lt;/p&gt;
&lt;p&gt;public：在默认SpringBoot工程中是不生成这个文件夹的，但是在自动配置中我们可以有这个文件夹用来存放公共的资源（html等）&lt;/p&gt;
&lt;p&gt;application.properties:这个文件名字是固定的，SpringBoot启动会默认加载这些配置在这里面可以配置端口号，访问路径，数据库连接信息等等。这个文件非常重要，当然官方中推出了一个yml格式这是非常强大的数据格式。&lt;/p&gt;
&lt;h3 id=&quot;整合jdbctemplate&quot;&gt;整合JdbcTemplate&lt;/h3&gt;
&lt;p&gt;引入依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.5.2.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--引入WEB模块--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
         &amp;lt;!--引入JDBC模块--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
         &amp;lt;!--引入数据库驱动--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置application.properties，虽然说是“零配置”但是这些必要的肯定要指定，否则它怎么知道连那个数据库？&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.datasource.url=jdbc:mysql://localhost:3306/mybatis
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class EmployeeService {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public boolean saveEmp(String name,String email,String gender){
        String sql = &quot;insert into tal_employee values(null,?,?,?)&quot;;
        int result = jdbcTemplate.update(sql, name,email,gender);
        System.out.println(&quot;result : &quot; + result);
        return result &amp;gt; 0 ? true:false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class EmployeeController {
    
    @Autowired
    private EmployeeService employeeService;
    
    @RequestMapping(&quot;/save&quot;)
    public String insert(String name,String email,String gender){
        boolean result = employeeService.saveEmp(name, email, gender);
        if(result){
            return &quot;success&quot;;
        }
        return &quot;error&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们直接返回一个文本格式。&lt;/p&gt;
&lt;h3 id=&quot;restcontroller&quot;&gt;@RestController&lt;/h3&gt;
&lt;p&gt;在上面的代码中我们使用到这个注解修改我们的Controller类而是不使用@Controller这个注解，其实中包含了@Controller，同时包含@ResponseBody既然修饰在类上面那么就是表示这个类中所有的方法都是@ResponseBody所以在这里我们返回字符串在前台我们会以文本格式展示，如果是对象那么它会自动转换成json格式返回。&lt;/p&gt;
&lt;h3 id=&quot;整合jsp&quot;&gt;整合JSP&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在创建整合JSP的时候指定要选WAR，一定要选WAR。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引入依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.2.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;!-- SpringBoot WEB组件 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 整合JSP依赖 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们只需要配置试图解析器路径就可以了。&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;#配置试图解析器前缀
spring.mvc.view.prefix=/WEB-INF/views/
#配置试图解析器后缀
spring.mvc.view.suffix=.jsp&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;整合jpa&quot;&gt;整合JPA&lt;/h3&gt;
&lt;p&gt;同样的整合JPA我们只需要启动我们SpringBoot已经集成好的模块即可。&lt;/p&gt;
&lt;p&gt;添加依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.5.2.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--启动JPA组件--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动JPA组件后直接配置数据库连接信息就可以使用JPA功能。&lt;/p&gt;
&lt;p&gt;Application.properties&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.datasource.url=jdbc:mysql://localhost:3306/mybatis
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实体类：Employee.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Table(name=&quot;tal_employee&quot;)
@Entity
public class Employee implements Serializable{
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;
    @Column(name=&quot;last_Name&quot;)
    private String lastName;
    private String email;
    private String gender;
    //get set 省略
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;EmployeeDao接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface EmployeeDao extends JpaRepository&amp;lt;Employee, Integer&amp;gt;{
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;EmployeeController.java:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
public class EmployeeController {
    @Autowired
    private EmployeeDao employeeDao;

    @ResponseBody
    @RequestMapping(&quot;/emps&quot;)
    public List&amp;lt;Employee&amp;gt; getEmployees(){
        List&amp;lt;Employee&amp;gt; employees = employeeDao.findAll();
        System.out.println(employees);
        return employees;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;整合mybatis&quot;&gt;整合MyBatis&lt;/h3&gt;
&lt;p&gt;引入依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.5.2.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--引入对JDBC的支持--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
         &amp;lt;!--引入对logging的支持--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-logging&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- SpringBoot MyBatis启动器 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置application.properties&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.datasource.url=jdbc:mysql://localhost:3306/mybatis
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
##############datasource classpath 数据连接池地址##############
#spring.datasource.type=com.alibaba.druid.pool.DruidDataSource

#指定我们的mapper.xml位置
mybatis.mapper-locations=classpath:com/simple/springboot/mybatis/dao/mapper/*.xml
#entity.class 指定我们实体类所在包位置
mybatis.type-aliases-package=com.simple.springboot.mybatis.entity&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然这里还有很多属性如果想要使用可以参考官方文档。到了这里其他就不写了，把他当作SSM使用就ok。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：在我们的Dao层接口中一定要在类上加上注解@Mapper否则无法扫描到。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;aop功能使用&quot;&gt;AOP功能使用&lt;/h3&gt;
&lt;p&gt;在我们SpringBoot中使用AOP非常简单。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.simple.springboot.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class SpringBootAspect {
    
    /**
     * 定义一个切入点
     * @author:SimpleWu
     * @Date:2018年10月12日
     */
    @Pointcut(value=&quot;execution(* com.simple.springboot.util.*.*(..))&quot;)
    public void aop(){}
    
    /**
     * 定义一个前置通知
     * @author:SimpleWu
     * @Date:2018年10月12日
     */
    @Before(&quot;aop()&quot;)
    public void aopBefore(){
        System.out.println(&quot;前置通知 SpringBootAspect....aopBefore&quot;);
    }
    
    /**
     * 定义一个后置通知
     * @author:SimpleWu
     * @Date:2018年10月12日
     */
    @After(&quot;aop()&quot;)
    public void aopAfter(){
        System.out.println(&quot;后置通知  SpringBootAspect....aopAfter&quot;);
    }
    
    /**
     * 处理未处理的JAVA异常
     * @author:SimpleWu
     * @Date:2018年10月12日
     */
    @AfterThrowing(pointcut=&quot;aop()&quot;,throwing=&quot;e&quot;)
    public void exception(Exception e){
        System.out.println(&quot;异常通知 SpringBootAspect...exception ..&quot; + e);
    }
    
    /**
     * 环绕通知
     * @author:SimpleWu
     * @throws Throwable 
     * @Date:2018年10月12日
     */
    @Around(&quot;aop()&quot;)
    public void around(ProceedingJoinPoint invocation) throws Throwable{
        System.out.println(&quot;SpringBootAspect..环绕通知 Before&quot;);
        invocation.proceed();
        System.out.println(&quot;SpringBootAspect..环绕通知 After&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;任务调度&quot;&gt;任务调度&lt;/h3&gt;
&lt;p&gt;SpringBoot已经集成好一个调度功能。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class ScheduledTasks {
    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss&quot;);
   
    /**
     * 任务调度，每隔5秒执行一次
     * @author:SimpleWu
     * @Date:2018年10月12日
     */
    
    @Scheduled(fixedRate = 1000)
    public void reportCurrentTime() {
        System.out.println(&quot;现在时间：&quot; + dateFormat.format(new Date()));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后启动的时候我们必须要在主函数类上加上注解：@EnableScheduling（翻译过来就是开启调度）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * SpringBoot使用任务调度
 * @EnableScheduling标注程序开启任务调度
 * @author :SimpleWu
 * @Date:2018年10月12日
 */

@SpringBootApplication
@EnableScheduling
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 16 Oct 2018 07:13:00 +0000</pubDate>
<dc:creator>Miya。</dc:creator>
<og:description>[TOC] SprinBoot快速入门 Editor：SimpleWu GIT（有本文章所有测试代码实例）：https://gitlab.com/450255266/code SpringBoot简介</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/9798146.html</dc:identifier>
</item>
<item>
<title>使用 WRK 压力测试工具对 ASP.NET Core 的接口进行压力测试 - myzony</title>
<link>http://www.cnblogs.com/myzony/p/9798116.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myzony/p/9798116.html</guid>
<description>&lt;h2 id=&quot;简要介绍&quot;&gt;0. 简要介绍&lt;/h2&gt;
&lt;p&gt;WRK 是一款轻量且易用的 HTTP 压力测试工具，通过该工具我们可以方便地对我们所开发的 WebAPI 项目进行压力测试，并且针对测试的情况返回结果。&lt;/p&gt;
&lt;blockquote readability=&quot;5.9823788546256&quot;&gt;
&lt;p&gt;PS：Wrk 并不能针对测试的结果生成动态的图表，如果有这种需要，可以尝试使用另一款工具 Vegeta。该项目使用的 Golang 进行编写，其 GitHub 地址为：&lt;a href=&quot;https://github.com/tsenart/vegeta&quot; class=&quot;uri&quot;&gt;https://github.com/tsenart/vegeta&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的内容就是一个标准的测试结果信息：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 针对 127.0.0.1:8080 进行压力测试
wrk -t12 -c400 -d30s http://127.0.0.1:8080/index.html&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 这里是测试结果
Running 30s test @ http://127.0.0.1:8080/index.html
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   635.91us    0.89ms  12.92ms   93.69%
    Req/Sec    56.20k     8.07k   62.00k    86.54%
  22464657 requests in 30.00s, 17.76GB read
Requests/sec: 748868.53
Transfer/sec:    606.33MB&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装&quot;&gt;1. 安装&lt;/h2&gt;
&lt;p&gt;关于 OS X 与 Windows 的安装可以参考 Wrk 官方 WIKI 进行操作，本文主要讲解一下 CentOS 7.x 下如果进行编译。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo yum groupinstall 'Development Tools'
sudo yum install -y openssl-devel git 
git clone https://github.com/wg/wrk.git wrk
cd wrk
make&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译之后，你会得到如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201810/1203160-20181016150706537-1674995565.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到生成了一个 wrk 的可执行文件，你可以将其添加到环境变量的 PATH 当中，这里就不再赘述，我们等会儿使用的时候直接 ./wrk 使用。&lt;/p&gt;
&lt;h2 id=&quot;命令说明&quot;&gt;2. 命令说明&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./wrk -H &quot;Authorization: Bearer TokenValue&quot; -t 2 -c 50 -d 10s --latency --timeout 1s &quot;http://&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的命令就是一个典型的压力测试命令，关于参数的含义请看下表。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;与 HTTP 保持连接的连接数，最终每个线程能够处理的为 连接数/线程数。&lt;/td&gt;
&lt;td&gt;-c 50&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;指定压力测试的时间有多长。&lt;/td&gt;
&lt;td&gt;-d 10s，其他单位有 2s,2m,2h&lt;br/&gt;如果不带单位的话，默认为秒。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;压力测试时所使用的线程数目，最好为你 CPU 核心的数量。&lt;/td&gt;
&lt;td&gt;-t 4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;指定要执行的 Lua 脚本&lt;/td&gt;
&lt;td&gt;-s ./post.lua&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-H&lt;/td&gt;
&lt;td&gt;执行请求的时候所附带的 Header 组。&lt;/td&gt;
&lt;td&gt;-H &quot;User-Agent: wrk&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;--latency&lt;/td&gt;
&lt;td&gt;打印详细的统计信息。&lt;/td&gt;
&lt;td&gt;--latency&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;--timeout&lt;/td&gt;
&lt;td&gt;每次请求所返回响应体的时间，如果超过了配置的时间，则视为请求超时。&lt;/td&gt;
&lt;td&gt;--timeout 1s&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;开始压力测试&quot;&gt;3. 开始压力测试&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201810/1203160-20181016150718942-1812945510.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行了上述代码之后我们可以看到很直观的信息，第一个就是 20s 的时间内完成了 2887 次请求，一共接受到了 2.46MB 的数据。在 Socket errors 里面我们可以看到有 35 个请求产生了超时的情况，每秒执行的请求大概为 144.20 个，每秒的数据传输大概为 125.75 KB。&lt;/p&gt;
&lt;p&gt;除此之外，还说明了平均每次请求所消耗的时间为 338.44 ms，最极端的情况为 994.27ms。&lt;/p&gt;
&lt;h2 id=&quot;lua-脚本&quot;&gt;4. LUA 脚本&lt;/h2&gt;
&lt;p&gt;在第三节我们可以看到一些标准的 GET 请求我们可以直接通过指定命令来进行测试，即便该接口有授权验证，我们可以通过 &lt;code&gt;-H&lt;/code&gt; 参数来指定 &lt;code&gt;Authorization&lt;/code&gt; 头来实现权限验证。&lt;br/&gt;但是针对一些复杂的情况，我们就需要编写 LUA 脚本来实现压力测试了。&lt;/p&gt;
&lt;p&gt;官方编写了很多的 LUA 脚本 DEMO ，存放在 GitHub 上面，其地址为：&lt;a href=&quot;https://github.com/wg/wrk/tree/master/scripts&quot; class=&quot;uri&quot;&gt;https://github.com/wg/wrk/tree/master/scripts&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里我们以实现 POST 请求为例：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;wrk.method = &quot;POST&quot;
wrk.body   = '{&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123qwe&quot;,&quot;rememberClient&quot;:true}'
wrk.headers[&quot;Content-Type&quot;] = &quot;application/json&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们的接口地址更改了一下，改变成了 Login 接口，该接口需要传入用户名与密码，并且其 Method 为 POST。&lt;/p&gt;
&lt;p&gt;将上述 LUA 脚本保存为 post.lua 文件，然后通过 &lt;code&gt;-s&lt;/code&gt; 参数指定 LUA 脚本的路径并执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201810/1203160-20181016150730379-1026568237.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;lua-脚本相关详解&quot;&gt;5. LUA 脚本相关详解&lt;/h2&gt;
&lt;p&gt;WRK 中执行 HTTP 请求的时候，调用 Lua 分为 3 个阶段，&lt;code&gt;setup&lt;/code&gt;、&lt;code&gt;running&lt;/code&gt;、&lt;code&gt;done&lt;/code&gt;，每个 WRK 线程中都有独立的脚本环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201810/1203160-20181016150757512-240103441.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;wrk-的全局属性&quot;&gt;5.1 WRK 的全局属性&lt;/h3&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;wrk = {
  scheme  = &quot;http&quot;,
  host    = &quot;localhost&quot;,
  port    = nil,
  method  = &quot;GET&quot;,
  path    = &quot;/&quot;,
  headers = {},
  body    = nil,
  thread  = &amp;lt;userdata&amp;gt;,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;wrk-的全局方法&quot;&gt;5.2 WRK 的全局方法&lt;/h3&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;-- 生成整个request的string，例如：返回
-- GET / HTTP/1.1
-- Host: tool.lu
function wrk.format(method, path, headers, body)

-- 获取域名的IP和端口，返回table，例如：返回 `{127.0.0.1:80}`
function wrk.lookup(host, service)

-- 判断addr是否能连接，例如：`127.0.0.1:80`，返回 true 或 false
function wrk.connect(addr)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;setup-阶段&quot;&gt;5.3 Setup 阶段&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;setup()&lt;/code&gt; 方法是在线程创建之后，启动之前。&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;function setup(thread)

-- thread提供了1个属性，3个方法
-- thread.addr 设置请求需要打到的ip
-- thread:get(name) 获取线程全局变量
-- thread:set(name, value) 设置线程全局变量
-- thread:stop() 终止线程&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;running-阶段&quot;&gt;5.4 Running 阶段&lt;/h3&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;function init(args)
-- 每个线程仅调用1次，args 用于获取命令行中传入的参数, 例如 --env=pre

function delay()
-- 每个线程调用多次，发送下一个请求之前的延迟, 单位为ms

function request()
-- 每个线程调用多次，返回http请求

function response(status, headers, body)
-- 每个线程调用多次，返回http响应&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;done-阶段&quot;&gt;5.5 Done 阶段&lt;/h3&gt;
&lt;p&gt;可以用于自定义结果报表，整个过程中只执行一次。&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;function done(summary, latency, requests)


latency.min              -- minimum value seen
latency.max              -- maximum value seen
latency.mean             -- average value seen
latency.stdev            -- standard deviation
latency:percentile(99.0) -- 99th percentile value
latency(i)               -- raw value and count

summary = {
  duration = N,  -- run duration in microseconds
  requests = N,  -- total completed requests
  bytes    = N,  -- total bytes received
  errors   = {
    connect = N, -- total socket connection errors
    read    = N, -- total socket read errors
    write   = N, -- total socket write errors
    status  = N, -- total HTTP status codes &amp;gt; 399
    timeout = N  -- total request timeouts
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而官方的 &lt;a href=&quot;https://github.com/wg/wrk/blob/master/scripts/setup.lua&quot;&gt;setup.lua&lt;/a&gt; 脚本则是重载这些方法并使用的一个 DEMO：&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;-- example script that demonstrates use of setup() to pass
-- data to and from the threads

local counter = 1
local threads = {}

function setup(thread)
   thread:set(&quot;id&quot;, counter)
   table.insert(threads, thread)
   counter = counter + 1
end

function init(args)
   requests  = 0
   responses = 0

   local msg = &quot;thread %d created&quot;
   print(msg:format(id))
end

function request()
   requests = requests + 1
   return wrk.request()
end

function response(status, headers, body)
   responses = responses + 1
end

function done(summary, latency, requests)
   for index, thread in ipairs(threads) do
      local id        = thread:get(&quot;id&quot;)
      local requests  = thread:get(&quot;requests&quot;)
      local responses = thread:get(&quot;responses&quot;)
      local msg = &quot;thread %d made %d requests and got %d responses&quot;
      print(msg:format(id, requests, responses))
   end
end&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;6. 参考资料&lt;/h2&gt;
&lt;p&gt;wrk中的lua脚本：&lt;a href=&quot;https://type.so/linux/lua-script-in-wrk.html&quot; class=&quot;uri&quot;&gt;https://type.so/linux/lua-script-in-wrk.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;http 性能测试 wrk使用教程：&lt;a href=&quot;https://juejin.im/post/5a59e74f5188257353008fea&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5a59e74f5188257353008fea&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Oct 2018 07:10:00 +0000</pubDate>
<dc:creator>myzony</dc:creator>
<og:description>0. 简要介绍 WRK 是一款轻量且易用的 HTTP 压力测试工具，通过该工具我们可以方便地对我们所开发的 WebAPI 项目进行压力测试，并且针对测试的情况返回结果。 PS：Wrk 并不能针对测试的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myzony/p/9798116.html</dc:identifier>
</item>
<item>
<title>阿里试用，女朋友逼着我给她排序 - zweizhao</title>
<link>http://www.cnblogs.com/ZweiZhao/p/9798008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZweiZhao/p/9798008.html</guid>
<description>&lt;h2 id=&quot;前景提要&quot;&gt;前景提要&lt;/h2&gt;
&lt;p&gt;说来简直丢尽了钢铁直男的脸，没错，昨晚我在愉快的做着外包的活（中国移动的小程序，自由职业，喂），11点多了，女友突然脑子一抽：“你能不能帮我把这个玩意排序一下给我用啊，我好薅点羊毛，技术能实现嘛？”&lt;br/&gt;我比较无奈的看了看，阿里试用咩？什么鬼，哦哦哦，就这玩意啊，爬虫爬一下就是了。我是前端……&lt;br/&gt;回道：“没问题啊，爬虫呗。”&lt;br/&gt;她：“哇，多久能做出来啊？”&lt;br/&gt;我：“我现在在忙诶，1-2小时吧。”&lt;br/&gt;她：“行了，你别忙了，赶紧帮我弄一下出来！”&lt;br/&gt;我看了看她的脸，羞耻的最小化《微信开发者工具》。。。&lt;/p&gt;
&lt;h2 id=&quot;页面展示&quot;&gt;页面展示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794080/201810/794080-20181016140944737-145296225.png&quot; alt=&quot;阿里试用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你要是觉得这也是广告，那真是太抬举我了。&lt;/p&gt;
&lt;h2 id=&quot;爬虫搞起来&quot;&gt;爬虫搞起来&lt;/h2&gt;
&lt;p&gt;NodeJS 爬虫，百度一下，到处都是现成的代码，我也就不一一分析了，拿出简书的一段代码，来自 埃米莉Emily：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const express = require('express');
// 调用 express 实例，它是一个函数，不带参数调用时，会返回一个 express 实例，将这个变量赋予 app 变量。
const superagent = require('superagent');
const cheerio = require('cheerio');
const app = express();

app.get('/', (req, res, next) =&amp;gt; {
  console.log(req)
  superagent.get('https://www.v2ex.com/')
    .end((err, sres) =&amp;gt; {
      // 常规的错误处理
      if (err) {
        return next(err);
      }
      // sres.text 里面存储着网页的 html 内容，将它传给 cheerio.load 之后
      // 就可以得到一个实现了 jquery 接口的变量，我们习惯性地将它命名为 `$`
      // 剩下就都是 jquery 的内容了
      let $ = cheerio.load(sres.text);
      let items = [];
      $('.item_title a').each((idx, element) =&amp;gt; {
        let $element = $(element);
        items.push({
          title: $element.text(),
          href: $element.attr('href')
        });
      });

      res.send(items);
    });
});

app.listen(3000, function () {
  console.log('app is listening at port 3000');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嘛，express 用 NodeJS 的不可能不知道，superagent 理解成可以在 Node 里面做对外请求即可，cheerio 嗯，Node 专用 JQ。&lt;/p&gt;
&lt;h2 id=&quot;首爬&quot;&gt;首爬&lt;/h2&gt;
&lt;p&gt;把上面的请求地址换成：&lt;code&gt;https://try.taobao.com/&lt;/code&gt;，查看页面标签结构，找到想要的选择器结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794080/201810/794080-20181016141514060-1365446772.png&quot; alt=&quot;标签结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.tb-try-wd-item-info &amp;gt; .detail&lt;/code&gt;，把这个替换上面选择器 &lt;code&gt;.item_title a&lt;/code&gt;，走起：&lt;/p&gt;
&lt;p&gt;……我不想展示结果，因为只有六个，页面实际展示是 10 个，找了半天，发现两个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794080/201810/794080-20181016141653548-1291693698.png&quot; alt=&quot;推荐&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794080/201810/794080-20181016141701958-2121909945.png&quot; alt=&quot;POST 请求来的数据&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，第一个是爬到的 6 个是推荐，喵的，不是下面列表；&lt;br/&gt;第二个，下面列表是后面通过 POST 单独请求来的数据，怎么看都是某框架的 SSR 干的好事。&lt;/p&gt;
&lt;p&gt;于是爬虫不成，得换战略。&lt;/p&gt;
&lt;h2 id=&quot;模拟-post&quot;&gt;模拟 POST&lt;/h2&gt;
&lt;p&gt;OK，既然是 POST，就好弄了，直接把连接跟参数刨出来，然后 superagent 模拟：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;superagent
  .post(
    `https://try.taobao.com/api3/call?what=show&amp;amp;page=${paylaod.page}&amp;amp;pageSize&amp;amp;api=x%2Fsearch`
  )
  .set('content-type', 'application/x-www-form-urlencoded; charset=UTF-8')
  .end((err, sres) =&amp;gt; {
    // 常规的错误处理
    if (err) {
      return next(err)
    }
    const result = JSON.parse(sres.text).result // 返回结构树
    resolve(result)
  })   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;content-type 源自：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794080/201810/794080-20181016142140872-388668027.png&quot; alt=&quot;contetnType&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哼哼哼，你没猜错，失败了，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794080/201810/794080-20181016142926715-1013698862.png&quot; alt=&quot;失败页面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想想是必然的，怎么可能给你随便请求呢，然后该怎么做？研究？nonono，老夫上来就是一梭子，不就是 Content-Type 么！&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;superagent
  .post(
    `https://try.taobao.com/api3/call?what=show&amp;amp;page=${paylaod.page}&amp;amp;pageSize&amp;amp;api=x%2Fsearch`
  )
  .set(
    'user-agent',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36'
  )
  .set('accept', 'pplication/json, text/javascript, */*; q=0.01')
  .set('accept-encoding', 'gzip, deflate, br')
  .set(
    'accept-language',
    'zh-CN,zh;q=0.9,en;q=0.8,la;q=0.7,zh-TW;q=0.6,da;q=0.5'
  )
  // .set('content-length', '8')
  .set('content-type', 'application/x-www-form-urlencoded; charset=UTF-8')
  .set(
    'cookie',
    'your cookie'
  )
  .set('origin', 'https://try.taobao.com')
  .set('referer', 'https://try.taobao.com')
  .set('x-csrf-token', 'f0b8e7443eb7e')
  .set('x-requested-with', 'XMLHttpRequest')
  .end((err, sres) =&amp;gt; {
    // 常规的错误处理
    if (err) {
      return next(err)
    }
    const result = JSON.parse(sres.text).result
    resolve(result)
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据就是下面这个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794080/201810/794080-20181016143200714-729772976.png&quot; alt=&quot;content-type2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不就是头么，不就是源么，不就是用户代理么，用个 HTTPS 还没有你办法了？&lt;/p&gt;
&lt;p&gt;注意上面 &lt;code&gt;.set('content-length', '8')&lt;/code&gt;，不知道那边怎么玩，加上这个就超时……&lt;/p&gt;
&lt;p&gt;于是，交代了吧：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;pages&quot;: {
        &quot;paging&quot;: {
            &quot;n&quot;: 2182,
            &quot;page&quot;: 1,
            &quot;pages&quot;: 219
        },
        &quot;items&quot;: [
            {
                &quot;shopUserId&quot;: &quot;2450112357&quot;,
                &quot;title&quot;: &quot;凯度高端款嵌入式蒸烤箱&quot;,
                &quot;status&quot;: 1,
                &quot;totalNum&quot;: 1,
                &quot;requestNum&quot;: 15530,
                &quot;acceptNum&quot;: 0,
                &quot;reportNum&quot;: 0,
                &quot;isApplied&quot;: false,
                &quot;shopName&quot;: &quot;casdon凯度旗舰店&quot;,
                &quot;showId&quot;: &quot;2561626&quot;,
                &quot;startTime&quot;: 1539619200000,
                &quot;endTime&quot;: 1540220400000,
                &quot;id&quot;: &quot;34530215&quot;,
                &quot;type&quot;: 1,
                &quot;pic&quot;: &quot;//img.alicdn.com/bao/uploaded/TB1ycS2eMDqK1RjSZSyXXaxEVXa.jpg&quot;,
                &quot;shopItemId&quot;: &quot;559771706359&quot;,
                &quot;price&quot;: 13850
            },
            {
                &quot;shopUserId&quot;: &quot;3189770892&quot;,
                &quot;title&quot;: &quot;皇家美素佳儿老包装2段400g&quot;,
                &quot;status&quot;: 1,
                &quot;totalNum&quot;: 50,
                &quot;requestNum&quot;: 2079,
                &quot;acceptNum&quot;: 0,
                &quot;reportNum&quot;: 0,
                &quot;isApplied&quot;: false,
                &quot;shopName&quot;: &quot;皇家美素佳儿旗舰店&quot;,
                &quot;showId&quot;: &quot;2551240&quot;,
                &quot;startTime&quot;: 1539619200000,
                &quot;endTime&quot;: 1540220400000,
                &quot;id&quot;: &quot;34396042&quot;,
                &quot;type&quot;: 1,
                &quot;pic&quot;: &quot;//img.alicdn.com/bao/uploaded/TB1YrSZaVYqK1RjSZLeXXbXppXa.jpg&quot;,
                &quot;shopItemId&quot;: &quot;547114874458&quot;,
                &quot;price&quot;: 189
            },
            {
                &quot;shopUserId&quot;: &quot;1077716829&quot;,
                &quot;title&quot;: &quot;关注店铺优先审水密码幻彩隔离&quot;,
                &quot;status&quot;: 1,
                &quot;totalNum&quot;: 10,
                &quot;requestNum&quot;: 6907,
                &quot;acceptNum&quot;: 0,
                &quot;reportNum&quot;: 0,
                &quot;isApplied&quot;: false,
                &quot;shopName&quot;: &quot;水密码旗舰店&quot;,
                &quot;showId&quot;: &quot;2568391&quot;,
                &quot;startTime&quot;: 1539619200000,
                &quot;endTime&quot;: 1540220400000,
                &quot;id&quot;: &quot;34784086&quot;,
                &quot;type&quot;: 1,
                &quot;pic&quot;: &quot;//img.alicdn.com/bao/uploaded/TB16_4ChmzqK1RjSZPxXXc4tVXa.jpg&quot;,
                &quot;shopItemId&quot;: &quot;559005882880&quot;,
                &quot;price&quot;: 599
            },
            {
                &quot;shopUserId&quot;: &quot;725786863&quot;,
                &quot;title&quot;: &quot;精品皮草派克大衣&quot;,
                &quot;status&quot;: 1,
                &quot;totalNum&quot;: 1,
                &quot;requestNum&quot;: 11793,
                &quot;acceptNum&quot;: 0,
                &quot;reportNum&quot;: 0,
                &quot;isApplied&quot;: false,
                &quot;shopName&quot;: &quot;美瑞蓓特&quot;,
                &quot;showId&quot;: &quot;2557886&quot;,
                &quot;startTime&quot;: 1539619200000,
                &quot;endTime&quot;: 1540220400000,
                &quot;id&quot;: &quot;34574078&quot;,
                &quot;type&quot;: 1,
                &quot;pic&quot;: &quot;//img.alicdn.com/bao/uploaded/TB1zVLMdCrqK1RjSZK9XXXyypXa.jpg&quot;,
                &quot;shopItemId&quot;: &quot;577418950477&quot;,
                &quot;price&quot;: 5980
            },
            {
                &quot;shopUserId&quot;: &quot;3000840351&quot;,
                &quot;title&quot;: &quot;保友智能新品Pofit电脑椅&quot;,
                &quot;status&quot;: 1,
                &quot;totalNum&quot;: 1,
                &quot;requestNum&quot;: 12895,
                &quot;acceptNum&quot;: 0,
                &quot;reportNum&quot;: 0,
                &quot;isApplied&quot;: false,
                &quot;shopName&quot;: &quot;保友办公家具旗舰店&quot;,
                &quot;showId&quot;: &quot;2557100&quot;,
                &quot;startTime&quot;: 1539619200000,
                &quot;endTime&quot;: 1540220400000,
                &quot;id&quot;: &quot;34528042&quot;,
                &quot;type&quot;: 1,
                &quot;pic&quot;: &quot;//img.alicdn.com/bao/uploaded/TB1bYZEg6TpK1RjSZKPXXa3UpXa.png&quot;,
                &quot;shopItemId&quot;: &quot;577598687971&quot;,
                &quot;price&quot;: 5408
            },
            {
                &quot;shopUserId&quot;: &quot;791732485&quot;,
                &quot;title&quot;: &quot;TEK手持吸尘器A8&quot;,
                &quot;status&quot;: 1,
                &quot;totalNum&quot;: 1,
                &quot;requestNum&quot;: 17195,
                &quot;acceptNum&quot;: 0,
                &quot;reportNum&quot;: 0,
                &quot;isApplied&quot;: false,
                &quot;shopName&quot;: &quot;泰怡凯旗舰店&quot;,
                &quot;showId&quot;: &quot;2552265&quot;,
                &quot;startTime&quot;: 1539619200000,
                &quot;endTime&quot;: 1540220400000,
                &quot;id&quot;: &quot;34444014&quot;,
                &quot;type&quot;: 1,
                &quot;pic&quot;: &quot;//img.alicdn.com/bao/uploaded/TB1D6bWbhTpK1RjSZFGXXcHqFXa.jpg&quot;,
                &quot;shopItemId&quot;: &quot;547653053965&quot;,
                &quot;price&quot;: 5199
            },
            {
                &quot;shopUserId&quot;: &quot;3229583972&quot;,
                &quot;title&quot;: &quot;椰富海南冷炸椰子油食用油1L&quot;,
                &quot;status&quot;: 1,
                &quot;totalNum&quot;: 20,
                &quot;requestNum&quot;: 4451,
                &quot;acceptNum&quot;: 0,
                &quot;reportNum&quot;: 0,
                &quot;isApplied&quot;: false,
                &quot;shopName&quot;: &quot;椰富食品专营店&quot;,
                &quot;showId&quot;: &quot;2561698&quot;,
                &quot;startTime&quot;: 1539619200000,
                &quot;endTime&quot;: 1540220400000,
                &quot;id&quot;: &quot;34532250&quot;,
                &quot;type&quot;: 1,
                &quot;pic&quot;: &quot;//img.alicdn.com/bao/uploaded/TB1VjLSePDpK1RjSZFrXXa78VXa.jpg&quot;,
                &quot;shopItemId&quot;: &quot;578653506446&quot;,
                &quot;price&quot;: 256
            },
            {
                &quot;shopUserId&quot;: &quot;855223948&quot;,
                &quot;title&quot;: &quot;卡西欧立式家用电钢琴PX770&quot;,
                &quot;status&quot;: 1,
                &quot;totalNum&quot;: 1,
                &quot;requestNum&quot;: 16762,
                &quot;acceptNum&quot;: 0,
                &quot;reportNum&quot;: 0,
                &quot;isApplied&quot;: false,
                &quot;shopName&quot;: &quot;世纪音缘乐器专营店&quot;,
                &quot;showId&quot;: &quot;2551326&quot;,
                &quot;startTime&quot;: 1539619200000,
                &quot;endTime&quot;: 1540220400000,
                &quot;id&quot;: &quot;34420041&quot;,
                &quot;type&quot;: 1,
                &quot;pic&quot;: &quot;//img.alicdn.com/bao/uploaded/TB1CC6aa9zqK1RjSZFpXXakSXXa.jpg&quot;,
                &quot;shopItemId&quot;: &quot;562405126383&quot;,
                &quot;price&quot;: 4838
            },
            {
                &quot;shopUserId&quot;: &quot;4065939832&quot;,
                &quot;title&quot;: &quot;关注宝贝送轻奢沙发床&quot;,
                &quot;status&quot;: 1,
                &quot;totalNum&quot;: 1,
                &quot;requestNum&quot;: 17436,
                &quot;acceptNum&quot;: 0,
                &quot;reportNum&quot;: 0,
                &quot;isApplied&quot;: false,
                &quot;shopName&quot;: &quot;贝兮旗舰店&quot;,
                &quot;showId&quot;: &quot;2559904&quot;,
                &quot;startTime&quot;: 1539619200000,
                &quot;endTime&quot;: 1540220400000,
                &quot;id&quot;: &quot;34532170&quot;,
                &quot;type&quot;: 1,
                &quot;pic&quot;: &quot;//img.alicdn.com/bao/uploaded/TB1AzxYegHqK1RjSZFPXXcwapXa.jpg&quot;,
                &quot;shopItemId&quot;: &quot;577798067313&quot;,
                &quot;price&quot;: 4399
            },
            {
                &quot;shopUserId&quot;: &quot;807974445&quot;,
                &quot;title&quot;: &quot;森海塞尔CX6蓝牙耳机&quot;,
                &quot;status&quot;: 1,
                &quot;totalNum&quot;: 4,
                &quot;requestNum&quot;: 22557,
                &quot;acceptNum&quot;: 0,
                &quot;reportNum&quot;: 0,
                &quot;isApplied&quot;: false,
                &quot;shopName&quot;: &quot;sennheiser旗舰店&quot;,
                &quot;showId&quot;: &quot;2559701&quot;,
                &quot;startTime&quot;: 1539619200000,
                &quot;endTime&quot;: 1540220400000,
                &quot;id&quot;: &quot;34532161&quot;,
                &quot;type&quot;: 1,
                &quot;pic&quot;: &quot;//img.alicdn.com/bao/uploaded/TB1HET6d7voK1RjSZFwXXciCFXa.jpg&quot;,
                &quot;shopItemId&quot;: &quot;564408956766&quot;,
                &quot;price&quot;: 999
            }
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;细心的小伙伴应该看到，我没有发送 form 给他，一样可以请求到需要的数据，page 挂在了 query 上……这里，允许我严重怀疑一下他们的技术能力。&lt;/p&gt;
&lt;h2 id=&quot;展示部分&quot;&gt;展示部分&lt;/h2&gt;
&lt;p&gt;数据拿到，就简单了，其实就是这一个接口实现剩下的功能了，没错，记住我是前端。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;tb try&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    .warning {
      color: red;
    }

    button {
      width: 100px;
      height: 44px;
      margin-right: 44px;
    }

    table {
      border: 1px solid #d8d8d8;
      border-collapse: collapse;
    }

    tr {
      border-bottom: 1px solid #d8d8d8;
      cursor: pointer;
    }

    tr:last-child {
      border: 0;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;button onclick=&quot;postPage()&quot;&amp;gt;下一页&amp;lt;/button&amp;gt;
  &amp;lt;span id=&quot;currentPage&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;table&amp;gt;
    &amp;lt;tbody&amp;gt;
      &amp;lt;tr&amp;gt;
        &amp;lt;th&amp;gt;序号（倒序）&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;概率&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;名字&amp;lt;/th&amp;gt;
      &amp;lt;/tr&amp;gt;
    &amp;lt;/tbody&amp;gt;
    &amp;lt;tbody id=&quot;results&quot;&amp;gt;&amp;lt;/tbody&amp;gt;
  &amp;lt;/table&amp;gt;

  &amp;lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;
    let currentPage = 0 // 当前页面
    let allItems = [] // 全部数据
    let currentTime = 0 // 锁频率使用，标记上次时间
    const loopInterval = 2 // 锁频率步长，单位秒
    const results = document.querySelector('#results')
    const currentPageText = document.querySelector('#currentPage')
    const reFullTBody = arr =&amp;gt; {
      let innerHtml = ''
      arr.forEach((item, i) =&amp;gt; {
        item.rate = item.totalNum / item.requestNum * 100
        let tr = `
          &amp;lt;tr onclick=&quot;window.open('https://try.taobao.com/item.htm?id=${item.id}')&quot;&amp;gt;
            &amp;lt;td&amp;gt;${i + 1}&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;${item.rate.toFixed(3) + '%'}&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;${item.title}&amp;lt;/td&amp;gt;
          &amp;lt;/tr&amp;gt;
          `
        if (item.rate &amp;gt; 5) tr = tr.replace('&amp;lt;tr', '&amp;lt;tr class=&quot;warning&quot;')
        innerHtml += tr
      })
      currentPageText.innerText = `当前页：${currentPage}`
      results.innerHTML = innerHtml // 原谅我 mvvm 的臭毛病
    }

    const postPage = () =&amp;gt; {
      // 锁频率步长内取消请求
      const newTime = new Date().getTime()
      const shoudBack = newTime - currentTime &amp;lt; loopInterval * 1000
      if(shoudBack) {
        alert(loopInterval + '秒内不要多次点击哦。')
        return
      }
      currentTime = newTime
      $.post('/table', { page: currentPage }, res =&amp;gt; {
        if(res.length &amp;lt; 1) {
          alert('今天结束的已经筛选完了')
          return
        }
        allItems = [...allItems, ...res]
        allItems.sort((a, b) =&amp;gt; b.rate - a.rate)
        reFullTBody(allItems)
        currentPage--
      })
    }

    $.get('/total', res =&amp;gt; {
      currentPage = res.pages
      postPage()
    })
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;长这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794080/201810/794080-20181016144313181-1159665620.png&quot; alt=&quot;展示&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我多人性化，可以点击跳转、概率超过 5% 红色展示、还告诉你当前所在页码、点太快还给你提示………………………………&lt;/p&gt;
&lt;p&gt;就是这么好用，喜欢的赶紧体验吧！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;线上：&lt;a href=&quot;http://only-u.site:8000/&quot;&gt;点我体验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/ZweiZhao/Spider&quot;&gt;Spider&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;觉得有用，不要吝惜 star 哦。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Oct 2018 07:01:00 +0000</pubDate>
<dc:creator>zweizhao</dc:creator>
<og:description>阿里试用排序 前景提要 说来简直丢尽了钢铁直男的脸，没错，昨晚我在愉快的做着外包的活（中国移动的小程序，自由职业，喂），11点多了，女友突然脑子一抽：“你能不能帮我把这个玩意排序一下给我用啊，我好薅点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZweiZhao/p/9798008.html</dc:identifier>
</item>
<item>
<title>The Road to learn React书籍学习笔记(第三章) - 赖同学</title>
<link>http://www.cnblogs.com/lbh2018/p/theroadtolearnreactpart_3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lbh2018/p/theroadtolearnreactpart_3.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/react-pratice/tree/master/my-first-react-app&quot;&gt;代码详情&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明周期方法&quot;&gt;声明周期方法&lt;/h2&gt;
&lt;p&gt;通过之前的学习，可以了解到ES6 类组件中的生命周期方法 &lt;code&gt;constructor()&lt;/code&gt; 和 &lt;code&gt;render()&lt;/code&gt;&lt;br/&gt;&lt;code&gt;constructor()&lt;/code&gt; 构造函数只有在组件实例化并插入到 &lt;code&gt;DOM&lt;/code&gt; 中的时候才会被调用。组件实例化的过程称为组件的挂载 &lt;code&gt;mount&lt;/code&gt;&lt;br/&gt;&lt;code&gt;render()&lt;/code&gt;方法也会在组件挂载过程中被调用，同时组件更新的时候也会被调用。每当组件的状态 &lt;code&gt;state&lt;/code&gt; 和属性 &lt;code&gt;props&lt;/code&gt; 改变的时候，组件的 &lt;code&gt;render()&lt;/code&gt; 方法都会被调用&lt;/p&gt;
&lt;h3 id=&quot;挂载过程中有四个生命周期方法调用顺序是这样的&quot;&gt;挂载过程中有四个生命周期方法，调用顺序是这样的&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;constructor()&lt;/code&gt;&lt;br/&gt;&lt;code&gt;componentWillMount()&lt;/code&gt;&lt;br/&gt;&lt;code&gt;render()&lt;/code&gt;&lt;br/&gt;&lt;code&gt;componentDidMount()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;当组件的状态或者属性改变的时候用来更新的生命周期如下五个步骤&quot;&gt;当组件的状态或者属性改变的时候用来更新的生命周期如下五个步骤&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;componentWillReceiveProps()&lt;/code&gt;&lt;br/&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;br/&gt;&lt;code&gt;componentWillUpdate()&lt;/code&gt;&lt;br/&gt;&lt;code&gt;render()&lt;/code&gt;&lt;br/&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;组件卸载的生命周期只有一个&quot;&gt;组件卸载的生命周期只有一个&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;componentWillUnmount()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;生命周期详解&quot;&gt;生命周期详解&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;constructor(props)&lt;/code&gt;&lt;br/&gt;在组件初始化的时被调用，在这个方法中，可以设置初始化状态以及绑定类方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;componentWillMount()&lt;/code&gt;&lt;br/&gt;在 &lt;code&gt;render()&lt;/code&gt; 方法之前被调用，这就是为什么它可以用作去设置组件内部的状态，因为它不会触发组件的再次渲染，一般还是推荐在 &lt;code&gt;constructor()&lt;/code&gt; 中去初始化状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;componentDidMount()&lt;/code&gt;&lt;br/&gt;仅在组件挂载后执行一次，是发起异步请求去API 获取数据的最好时期，获取到的数据将被保存在内部组件的状态中然后在 &lt;code&gt;render()&lt;/code&gt; 生命周期方法中展示出来&lt;/p&gt;
&lt;p&gt;&lt;code&gt;componentWillReceviceProps(nextProps)&lt;/code&gt;&lt;br/&gt;这个方法在一个更新声明周（&lt;code&gt;update lifecycle&lt;/code&gt;）中使用， 新的属性会作为它的输入，因此可以利用 &lt;code&gt;this.props&lt;/code&gt; 来对比之后的属性和之前的属性，基于对比的结果去实现不同的行为，此外还可以基于新的属性来设置组件的状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shouldComponentUpdate(nextProps,nextState)&lt;/code&gt;&lt;br/&gt;每次组件因为状态或者是属性更改而更新时，它都会被调用。在成熟的React应用中使用它来进行性能优化。在一个更新声明周期中，组件以及其组件将根据该方法返回的布尔值来决定是否重新渲染，这样就可以阻止组件的渲染声明周期方法，避免不必要的渲染&lt;/p&gt;
&lt;p&gt;&lt;code&gt;componentWillUpdate(nextProps,nextState)&lt;/code&gt;&lt;br/&gt;这个方法是 &lt;code&gt;render()&lt;/code&gt; 方法执行之前的最后一个方法，此时拥有了下一个属性和状态，可以利用这个方法在渲染之前做最后的准备。注意这个声明周期不能再触发 &lt;code&gt;setState()&lt;/code&gt; 如果想基于新的属性计算状态 ,必须使用 &lt;code&gt;componentWillReceiveProps()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;componentDidUpdate(prevProps,prevState)&lt;/code&gt;&lt;br/&gt;这个方法在 &lt;code&gt;render()&lt;/code&gt; 之后调用，可以用它当成操作DOM 或者是 执行更多异步请求的机会&lt;/p&gt;
&lt;p&gt;&lt;code&gt;componentWillUnmount()&lt;/code&gt;&lt;br/&gt;它会在组件销毁之前被调用，可以利用这个声明周期方法去执行任何清理任务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;render()&lt;/code&gt; 是必须有的，否则不会返回一个组件实例&lt;/p&gt;
&lt;h3 id=&quot;还有一个生命周期方法&quot;&gt;还有一个生命周期方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;componentDidCatch(error,info)&lt;/code&gt;&lt;br/&gt;在 &lt;code&gt;React 16&lt;/code&gt; 中引入，用来捕获组件的错误。&lt;br/&gt;举例来说，在你的应用中展示样本数据本来是没问题的。但是可能会有列表的本地状态被意外设置成 &lt;code&gt;null&lt;/code&gt; 的情况发生（例如从外部 &lt;code&gt;API&lt;/code&gt; 获取列表失败时，你把本地状态设置为空了）。然后它就不能像之前一样去过滤（&lt;code&gt;filter&lt;/code&gt;）和映射（&lt;code&gt;map&lt;/code&gt;）这个列表，因为它不是一个空列表（[]）而是 &lt;code&gt;null&lt;/code&gt;。这时组件就会崩溃，然后整个应用就会挂掉。现在你可以用&lt;code&gt;componentDidCatch()&lt;/code&gt; 来捕获错误，将它存在本地的状态中，然后像用户展示一条信息，说明应用发生了错误&lt;/p&gt;
&lt;h2 id=&quot;获取数据&quot;&gt;获取数据&lt;/h2&gt;
&lt;p&gt;从 &lt;code&gt;Hacker News API&lt;/code&gt; 获取数据。可以在 &lt;code&gt;componentDidMount()&lt;/code&gt; 生命周期方法来获取数据,用JavaScript原生的 &lt;code&gt;fetch API&lt;/code&gt; 来发起请求&lt;br/&gt;在那之前，先设置好 &lt;code&gt;URL&lt;/code&gt;常量和默认参数，将 &lt;code&gt;API&lt;/code&gt; 请求分解成几步&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;import React,{ Component } from 'react';
import './App.css'

const DEFAULT_QUERY = 'redux';
const PATH_BASE = 'https://hn.algolia.com/api/v1';
const PATH_SEARCH = '/search';
const PARAM_SEARCH = 'query=';

在ES6 中 可以用模板字符串（`template strings`） 来连接字符串

//ES6 
const url = `${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${DEFAULT_QUERY}`;
//ES5 
var url = PATH_BASE + PATH_SEARCH +'?' + PARAM_SEARCH + DEFAULT_QUERY;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;...

class App extends Component {

constructor(props) {
  super(props);

  this.state = {
    result: null,
    searchTerm: DEFAULT_QUERY,
  };

  this.setSearchTopStories = this.setSearchTopStories.bind(this);
  this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
  this.onSearchChange = this.onSearchChange.bind(this);
  this.onDismiss = this.onDismiss.bind(this);
}

setSearchTopStories(result) {
  this.setState({ result });
}

fetchSearchTopStories(searchTerm) {
  fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}`)
    .then(response =&amp;gt; response.json())
    .then(result =&amp;gt; this.setSearchTopStories(result))
    .catch(e =&amp;gt; e);
}

componentDidMount() {
  const { searchTerm } = this.state;
  this.fetchSearchTopStories(searchTerm);
}

...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 &lt;code&gt;Hacker News API&lt;/code&gt; 得到一个真实的列表。组件将一个空的列表结果以及一个默认的搜索词作为初始状态。这个默认搜索词也同样用在 &lt;code&gt;Search&lt;/code&gt; 组件的输入字段和第一个 API 请求中。&lt;/p&gt;
&lt;p&gt;其次，在组件挂载之后，它用了 &lt;code&gt;componentDidMount()&lt;/code&gt;生命周期方法去获取数据。在第一次获取数据时，使用的是本地状态中的默认搜索词。它将获取与 “&lt;code&gt;redux&lt;/code&gt;” 相关的资讯，因为它是默认的参数。&lt;/p&gt;
&lt;p&gt;再次，这里使用的是原生的 &lt;code&gt;fetch API&lt;/code&gt;。&lt;code&gt;JavaScript ES6&lt;/code&gt; 模板字符串允许组件利用 &lt;code&gt;searchTerm&lt;/code&gt; 来组成 URL。该 URL 是原生 &lt;code&gt;fetch API&lt;/code&gt; 函数的参数。返回的响应需要被转化成 JSON 格式的数据结构。这是在处理 &lt;code&gt;JSON&lt;/code&gt; 数据结构时，原生的 fetch API 中的强制步骤。最后将处理后的响应赋值给组件内部状态中的结果。此外，我们用一段 &lt;code&gt;catch&lt;/code&gt; 代码来处理出错的情况。如果在发起请求时出现错误，这个函数会进入到 &lt;code&gt;catch&lt;/code&gt; 中而不是 &lt;code&gt;then&lt;/code&gt; 中。在本书之后的章节中，将涵盖错误处理的内容。&lt;/p&gt;
&lt;p&gt;最后但同样重要的是，不要忘记在构造函数中绑定你的组件方法。&lt;/p&gt;
&lt;h2 id=&quot;拓展操作符&quot;&gt;拓展操作符&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Dismiss&lt;/code&gt; 按钮之所以不工作，是因为 &lt;code&gt;onDismiss()&lt;/code&gt; 方法不能处理复杂的 &lt;code&gt;result&lt;/code&gt; 对象。它现在还只能处理一个本地状态中的简单列表。但是现在这个列表已经不再是简单的平铺列表了。现在，让我们去操作这个 &lt;code&gt;result&lt;/code&gt; 对象而不是去操作列表。&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;onDismiss(id) {
const isNotId = item =&amp;gt; item.objectID !== id;
const updatedHits = this.state.result.hits.filter(isNotId);
this.setState({
  ...
});
}

/ don`t do this
this.state.result.hits = updatedHits&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;React 拥护不可变的数据结构，不应该改变一个对象或者是直接改变状态。更好的做法是基于现在拥有的资源来创建一个新的对象。&lt;br/&gt;&lt;code&gt;javaSrcipt ES6&lt;/code&gt; 的 &lt;code&gt;Object.assign()&lt;/code&gt; 函数可以达到这样的目的。它把接受的第一个参数作为目标对象，后面的所有参数作为源对象，然后把所有的源对象合并到目标对象中。只要将目标对象设置为空，就可以得到一个新的对象。&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;const updatedHits  = {hits:updatedHits };
const updateList = Object.assign({},this.state.result,updateHits);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;es6中数组的扩展运算符&quot;&gt;ES6中数组的扩展运算符&lt;/h3&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;数组+字符串
const userList = ['Robin', 'Andrew', 'Dan'];
const additionalUser = 'Jordan';
const allUsers = [ ...userList, additionalUser ];

console.log(allUsers);
// output: ['Robin', 'Andrew', 'Dan', 'Jordan']

合并数组
onst oldUsers = ['Robin', 'Andrew'];
const newUsers = ['Dan', 'Jordan'];
const allUsers = [ ...oldUsers, ...newUsers ];

console.log(allUsers);
// output: ['Robin', 'Andrew', 'Dan', 'Jordan']
对象
const userNames = { firstname: 'Robin', lastname: 'Wieruch' };
const userAge = { age: 28 };
const user = { ...userNames, ...userAge };

console.log(user);
// output: { firstname: 'Robin', lastname: 'Wieruch', age: 28 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新改写&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;onDismiss(id) {
    const isNotId = item =&amp;gt; item.objectID !== id;
    const updatedHits = this.state.result.hits.filter(isNotId);
    this.setState({
      result: { ...this.state.result, hits: updatedHits }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;条件渲染&quot;&gt;条件渲染&lt;/h2&gt;
&lt;p&gt;条件渲染用于需要决定渲染哪个元素的时候，就可以用 &lt;code&gt;JSX&lt;/code&gt; 中 &lt;code&gt;if-else&lt;/code&gt; 来实现&lt;br/&gt;组件内部状态中的 &lt;code&gt;result&lt;/code&gt; 对象初始值为空，当 &lt;code&gt;API&lt;/code&gt; 结果还没有返回的时候，此时的主组件中没有任何的元素，这就是一个条件渲染，因为在某个特定的条件下， &lt;code&gt;render()&lt;/code&gt; 方法提前返回了，根据条件， 主组件渲染它的元素或者什么都不渲染&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Table&lt;/code&gt; 组件的渲染依赖于 &lt;code&gt;result&lt;/code&gt;，所以将它包在一个独立的条件渲染中才比较合理。即使 &lt;code&gt;result&lt;/code&gt; 为空，其它的所有组件还是应该被渲染。你只需要在 &lt;code&gt;JSX&lt;/code&gt; 中加上一个三元运算符就可以达到这样的目的。&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;return (
    &amp;lt;div className=&quot;page&quot;&amp;gt;
      &amp;lt;div className = &quot;interactions&quot;&amp;gt;
        &amp;lt;Search
          value={searchText}
          onChange={this.onSearchChange} /&amp;gt;
          {
            result?
            &amp;lt;Table
            list={result.hits}
            pattern={searchText}
            onDismiss={this.onDismiss}/&amp;gt;:null
          }
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是实现条件渲染的第二种方式。&lt;br/&gt;第三种则是运用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 逻辑运算符。在JavaScript中， true &amp;amp;&amp;amp; 'Hello World' 的值永远是 “Hello World”。而 false &amp;amp;&amp;amp; 'Hello World' 的值则永远是 false&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;  const result = true &amp;amp;&amp;amp; 'Hello World';
  console.log(result);
  // output: Hello World

  const result = false &amp;amp;&amp;amp; 'Hello World';
  console.log(result);
  // output: false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以也可以这样改写&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;{ result &amp;amp;&amp;amp;
  &amp;lt;Table
    list={result.hits}
    pattern={searchTerm}
    onDismiss={this.onDismiss}
  /&amp;gt;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;客户端或者服务端搜索&quot;&gt;客户端或者服务端搜索&lt;/h2&gt;
&lt;p&gt;在使用 &lt;code&gt;Search&lt;/code&gt; 组件的输入栏时，会在客户端过滤这个列表，所以要做的是使用 API 在服务端进行搜索。否则，就只能处理第一次从 &lt;code&gt;componentDidMount()&lt;/code&gt; 拿到的默认搜索词的 API 响应&lt;br/&gt;可以在主组件中顶一个 &lt;code&gt;onSeachSubmit()&lt;/code&gt; 方法，当 &lt;code&gt;Search&lt;/code&gt; 组件进行搜索的时候，可以用这个方法来 API 获取结果，顺便在 &lt;code&gt;Search&lt;/code&gt; 中增加一个新按钮，这个按钮可以触发搜索请求&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;  class FormP extends Component {

  constructor(props) {
    super(props);
    this.state = {
      result: null,
      searchText: DEFAULT_QUERY,
    };
    this.setSearchTopStories = this.setSearchTopStories.bind(this);
    this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
    this.onSearchChange = this.onSearchChange.bind(this);
    this.onSearchSubmit = this.onSearchSubmit.bind(this);
    this.onDismiss = this.onDismiss.bind(this);
  }

  ....

  onSearchSubmit(e) {
    const { searchText } = this.state;
    // console.log( searchText);
    this.fetchSearchTopStories(searchText);
    e.preventDefault();
  }
}

const Search = ({ value, onChange, onSubmit, children }) =&amp;gt;
  &amp;lt;form onSubmit={onSubmit} &amp;gt;
    &amp;lt;input
      type=&quot;text&quot;
      value={value}
      onChange={onChange}
    /&amp;gt;
    &amp;lt;button type=&quot;submit&quot;&amp;gt;
      {children}
    &amp;lt;/button&amp;gt;
  &amp;lt;/form&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分页抓取&quot;&gt;分页抓取&lt;/h2&gt;
&lt;p&gt;改造一下可组合 API 常量，以便于处理分页数据&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;const DEFAULT_QUERY = 'redux';
const PATH_BASE = 'https://hn.algolia.com/api/v1';
const PATH_SEARCH = '/search';
const PARAM_SEARCH = 'query=';
const PARAM_PAGE = 'page=';
const url = `${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&amp;amp;${PARAM_PAGE}`;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fetchSearchTopStories()&lt;/code&gt; 函数接收分页作为第二个参数。如果不提供第二个参数，它将使用 &lt;code&gt;0&lt;/code&gt; 作为初始参数并发起请求。因此 &lt;code&gt;componentDidMount()&lt;/code&gt; 和 &lt;code&gt;onSearchSubmit()&lt;/code&gt; 方法在第一个请求中默认获取第一页。之后的请求将根据提供的第二个参数抓取下一个页面的数据。&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;  class App extends Component {

  ...

  fetchSearchTopStories(searchTerm, page = 0) {
    fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&amp;amp;${PARAM_PAGE}\
${page}`)
      .then(response =&amp;gt; response.json())
      .then(result =&amp;gt; this.setSearchTopStories(result))
      .catch(e =&amp;gt; e);
  }

  ...

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;客户端缓存&quot;&gt;客户端缓存&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/react-pratice/tree/master/my-first-react-app&quot;&gt;The Road to learn React 代码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;错误处理&quot;&gt;错误处理&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/react-pratice/tree/master/my-first-react-app&quot;&gt;The Road to learn React 代码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码组织和测试&quot;&gt;代码组织和测试&lt;/h2&gt;
&lt;p&gt;本章将专注在几个重要话题来保证在一个规模增长的应用中代码的可维护性。你将了解如何去组织代码，以便在构建你的工程目录和文件时时遵循最佳实践。本章你将学会的另外一个话题是测试，这对你的代码健壮性非常重要。本章也会结合之前的练习项目来为你介绍这几个话题。&lt;/p&gt;
&lt;h2 id=&quot;es6模块-import-和-export&quot;&gt;ES6模块： &lt;code&gt;Import&lt;/code&gt; 和 &lt;code&gt;Export&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;JavaScript ES6&lt;/code&gt; 中可以从模块中导入和导出某些功能，这些功能可以是函数、类、组件、常量等等。基本上可以将所有东西都赋值到一个变量上。模块可以是单个文件，或者一个带有入口文件的文件夹&lt;/p&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 与 &lt;code&gt;export&lt;/code&gt; 语句可以让我们在不同的文件共享代码，这些语言有利于代码的分割。代码风格就是将代码分配到多个文件夹中去，以保持代码的重用性和可维护性。前者得以成立时因为可以在不同的文件中导入相同的代码片段，而后者得以成立是因为维护的代码时唯一的代码源&lt;/p&gt;
&lt;p&gt;最后一点是，它能帮助我们思考代码封装。不是所有的功能都需要从一个文件导出。其中一些功能应该只在定义它的文件夹中使用。一个文件导出的功能是这个文件公共 API ，只有导出的功能才能被其他地方重用。遵循了封装的最佳实践&lt;/p&gt;
&lt;p&gt;可以导出一个或者多个变量，称为一个命名的导出&lt;/p&gt;
&lt;p&gt;file1.js&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;const firstname = 'lai',&lt;br/&gt;const lastname = 'bh',&lt;br/&gt;&lt;code&gt;export&lt;/code&gt; { firstname , lastname };&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并在另外一个文件中引用&lt;br/&gt;file2.js&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; { firstname, lastname } from './file1.js';&lt;br/&gt;console.log(firstname); // lai&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也可以用对象的方式导入另外文件的全部变量&lt;br/&gt;file2.js&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; * as person from './file1.js';&lt;br/&gt;console.log(person.firstname); // lai&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;导入可以有一个别名，可能发生在输出多个文件中有相同命名的导出的时候。&lt;br/&gt;file2.js&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; { firstname as foo } from './file1.js'&lt;br/&gt;console.log(foo); // lai&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有一种情况 &lt;code&gt;default&lt;/code&gt; 语句，可以被用在以下情况&lt;br/&gt;为了导出和导入单一功能&lt;br/&gt;为了强调一个模块输出 API 中的主要功能&lt;br/&gt;这样可以向后兼容 ES5 只有一个导出物的功能&lt;/p&gt;
&lt;p&gt;file1.js&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;const lbh = { firstname:'lai', lastname:'bh'};&lt;br/&gt;&lt;code&gt;export default&lt;/code&gt; lbh;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以在导入 &lt;code&gt;default&lt;/code&gt; 输出时省略花括号&lt;br/&gt;file2.js&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; developer from './file1.js'&lt;br/&gt;console.log(developer); // { firstname:'lai',lastname:'bh'}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，输入名称可以与导入的 &lt;code&gt;default&lt;/code&gt; 名称不一样，也可以将其与命名的导出与导入语句使用同一个名称&lt;br/&gt;file1.js&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;const firstname = 'lai',&lt;br/&gt;const lastname = 'bh',&lt;br/&gt;const lbh = { firstname, lastname};&lt;br/&gt;&lt;code&gt;export&lt;/code&gt;{ firstname, lastname};&lt;br/&gt;&lt;code&gt;export default&lt;/code&gt; lbh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;file2.js&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; lbh, { firstname, lastname } from './file1.js';&lt;br/&gt;console.log(lbh); // { firstname:'lai',lastname:'bh'}&lt;br/&gt;console.log(firstname, lastname); // (lai,bh)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在命名的导出中，可以省略多余行直接导出变量&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;export default&lt;/code&gt; firstname = 'lai';&lt;br/&gt;&lt;code&gt;export default&lt;/code&gt; lastname = 'bh';&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;代码组织与es6模块&quot;&gt;代码组织与ES6模块&lt;/h2&gt;
&lt;p&gt;可能会用到的模块结构&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;src/
  index.js
  index.css
  App.js
  App.test.js
  App.css
  Button.js
  Button.test.js
  Button.css
  Table.js
  Table.test.js
  Table.css
  Search.js
  Search.test.js
  Search.css&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里将组件封装到各自文件中，但是这看起来不是很好。你可以看到非常多的命名冗余，并且只有文件的扩展文字不同。另外一种模块的结构大概类似：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;src/
  index.js
  index.css
  App/
    index.js
    test.js
    index.css
  Button/
    index.js
    test.js
    index.css
  Table/
    index.js
    test.js
    index.css
  Search/
    index.js
    test.js
    index.css&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这看起来比之前清晰多了。文件名中的 index 名称表示他是这个文件夹的入口文件。这仅仅是一个命名共识，你也可以使用你习惯的命名。在这个模块结构中，一个组件被 JavaScript 文件中组件声明，样式文件，测试共同定义。&lt;/p&gt;
&lt;p&gt;另外一个步骤可能要将 App 组件中的变量抽出。这些变量用来组合出 Hacker News 的 API URL。&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;src/
  index.js
  index.css
  constants/
    index.js
  components/
    App/
      index.js
      test.js
      index..css
    Button/
      index.js
      test.js
      index..css
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自然这些模块会分割到 src/constants/ 和 src/components/ 中去。现在 src/constants/index.js 文件可能看起来类似下面这样：&lt;/p&gt;
&lt;p&gt;Code Playground: src/constants/index.js&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;export const DEFAULT_QUERY = 'redux';
export const DEFAULT_HPP = '100';
export const PATH_BASE = 'https://hn.algolia.com/api/v1';
export const PATH_SEARCH = '/search';
export const PARAM_SEARCH = 'query=';
export const PARAM_PAGE = 'page=';
export const PARAM_HPP = 'hitsPerPage=';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;App/index.js 文件可以导入这些变量，以便使用。&lt;/p&gt;
&lt;p&gt;Code Playground: src/components/App/index.js&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;import {
DEFAULT_QUERY,
DEFAULT_HPP,
PATH_BASE,
PATH_SEARCH,
PARAM_SEARCH,
PARAM_PAGE,
PARAM_HPP,
} from '../constants/index.js';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你使用 index.js 这个命名共识的时候，你可以在相对路径中省略文件名。&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;Code Playground: src/components/App/index.js
import {
  DEFAULT_QUERY,
  DEFAULT_HPP,
  PATH_BASE,
  PATH_SEARCH,
  PARAM_SEARCH,
  PARAM_PAGE,
  PARAM_HPP,
} from '../constants';

...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是 index.js 文件名称后面发生了什么？这个约定是在 node.js 世界里面被引入的。index 文件是一个模块的入口。它描述了一个模块的公共 API。外部模块只允许通过 index.js 文件导入模块中的共享代码。考虑用下面虚构的模块结构进行演示：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;src/
  index.js
  App/
    index.js
  Buttons/
    index.js
    SubmitButton.js
    SaveButton.js
    CancelButton.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 Buttons/ 文件夹有多个按钮组件定义在了不同的文件中。每个文件都 export default 特定的组件，使组件能够被 Buttons/index.js 导入。Buttons/index.js 文件导入所有不同的表现的按钮，并将他们导出作为模块的公共 API。&lt;/p&gt;
&lt;p&gt;Code Playground: src/Buttons/index.js&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;import SubmitButton from './SubmitButton';
import SaveButton from './SaveButton';
import CancelButton from './CancelButton';

export {
  SubmitButton,
  SaveButton,
  CancelButton,
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在 src/App/index.js 可以通过定位在 index.js 文件模块的公共 API 导入这些按钮。&lt;br/&gt;Code Playground: src/App/index.js&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;import {
  SubmitButton,
  SaveButton,
  CancelButton
} from '../Buttons';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://leanpub.com/the-road-to-learn-react-chinese&quot; class=&quot;uri&quot;&gt;https://leanpub.com/the-road-to-learn-react-chinese&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Oct 2018 06:16:00 +0000</pubDate>
<dc:creator>赖同学</dc:creator>
<og:description>The Road to learn React书籍学习笔记(第三章) ===========</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lbh2018/p/theroadtolearnreactpart_3.html</dc:identifier>
</item>
</channel>
</rss>