<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Entity Framework Core 2.0 使用入门 - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/7717873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/7717873.html</guid>
<description>&lt;p&gt;Entity Framework（后面简称EF）作为微软家的ORM，自然而然从.NET Framework延续到了.NET Core。以前我也嫌弃EF太重而不去使用它，但是EF Core（Entity Framework Core）已经做了很多性能优化，还有一些增加新特性，吸引了我去使用它。关于EF Core 2.0 的新特性请看：&lt;a href=&quot;http://www.cnblogs.com/stulzq/p/7366044.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/stulzq/p/7366044.html&lt;/a&gt;&lt;/p&gt;

&lt;h6 id=&quot;新建一个.net-core控制台程序&quot;&gt;1.新建一个.NET Core控制台程序&lt;/h6&gt;
&lt;h6 id=&quot;通过nuget安装-ef-core&quot;&gt;2.通过Nuget安装 EF Core&lt;/h6&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;MySql/MariaDB 推荐使用Pomelo EF Core组件，因为官方的目前可能存在bug，Pomelo EF Core同样是微软官方所推荐的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其他数据库请查看：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/ef/core/providers/&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/zh-cn/ef/core/providers/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装好EF Core之后，打开项目*.csproj文件 添加如下代码。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;&amp;lt;ItemGroup&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;DotNetCliToolReference&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; Include=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Microsoft.EntityFrameworkCore.Tools.DotNet&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; Version=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;2.0.0&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ItemGroup&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本文所用数据库为MariaDB&lt;/p&gt;
&lt;h6 id=&quot;添加实体&quot;&gt;3.添加实体&lt;/h6&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }

    public List&amp;lt;Post&amp;gt; Posts { get; set; }
}

public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public int BlogId { get; set; }
    public Blog Blog { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;添加数据库上下文&quot;&gt;4.添加数据库上下文&lt;/h6&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class BloggingContext : DbContext
{
    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }
    public DbSet&amp;lt;Post&amp;gt; Posts { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        //配置mariadb连接字符串
        optionsBuilder.UseMySql(&quot;Server=localhost;Port=3306;Database=BloggingDB; User=root;Password=;&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;使用&quot;&gt;5.使用&lt;/h6&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    using (var db = new BloggingContext())
    {
        db.Blogs.Add(new Blog { Url = &quot;http://blogs.msdn.com/adonet&quot; });
        var count = db.SaveChanges();
        Console.WriteLine(&quot;{0} records saved to database&quot;, count);

        Console.WriteLine();
        Console.WriteLine(&quot;All blogs in database:&quot;);
        foreach (var blog in db.Blogs)
        {
            Console.WriteLine(&quot; - {0}&quot;, blog.Url);
        }
    }
    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;现在F5运行，肯定会出异常的，因为我们需要使用的数据库并不存在，EF Core默认的创建数据库策略已经和EF不用，请看后面的迁移操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&quot;创建一个asp.net-core-2.0-mvc项目&quot;&gt;1.创建一个asp.net core 2.0 mvc项目&lt;/h6&gt;
&lt;h6 id=&quot;通过nuget安装-ef-core同上&quot;&gt;2.通过Nuget安装 EF Core（同上）&lt;/h6&gt;
&lt;h6 id=&quot;添加实体同上&quot;&gt;3.添加实体（同上）&lt;/h6&gt;
&lt;h6 id=&quot;添加数据库上下文-1&quot;&gt;4.添加数据库上下文&lt;/h6&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class BloggingContext : DbContext
{
    public BloggingContext(DbContextOptions&amp;lt;BloggingContext&amp;gt; options)
        : base(options)
    { }

    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }
    public DbSet&amp;lt;Post&amp;gt; Posts { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;配置ef-core&quot;&gt;5.配置EF Core&lt;/h6&gt;
&lt;p&gt;在Startup添加如下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContextPool&amp;lt;BloggingContext&amp;gt;(options =&amp;gt; options.UseMySql(&quot;Server=localhost;Port=3306;Database=WebBloggingDB; User=root;Password=;&quot;)); //配置mariadb连接字符串
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;在controller中获取数据库上下文&quot;&gt;6.在Controller中获取数据库上下文。&lt;/h6&gt;
&lt;p&gt;这里我们利用ASP.NET Core的依赖注入来获取数据库上下文。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private readonly BloggingContext _context;

public BlogsController(BloggingContext context)
{
    _context = context;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;前面说过，EF Core默认的创建数据库策略已经和EF不用，需要我们通过迁移来创建数据库&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里不论是控制台还是ASP.NET Core操作都是一样的，这里以ASP.NET Core作为示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;将asp.net-core项目设为启动项目&quot;&gt;1.将ASP.NET Core项目&lt;strong&gt;设为启动项目&lt;/strong&gt;&lt;/h6&gt;
&lt;h6 id=&quot;打开程序包管理器控制台并选择对应的项目&quot;&gt;2.打开&lt;code&gt;程序包管理器控制台&lt;/code&gt;，并选择对应的项目&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/668104/201710/668104-20171023163849394-1749370744.png&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;执行添加迁移命令-add-migration-init&quot;&gt;3.执行添加迁移命令 &lt;code&gt;Add-Migration init&lt;/code&gt;&lt;/h6&gt;
&lt;h6 id=&quot;迁移成功可以看见在项目根目录下添加了一个migrations文件夹&quot;&gt;4.迁移成功可以看见在项目根目录下添加了一个Migrations文件夹&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/668104/201710/668104-20171023164609723-1825005413.png&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;更新迁移到数据库执行命令-update-database&quot;&gt;5.更新迁移到数据库，执行命令 &lt;code&gt;Update-Database&lt;/code&gt;&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/668104/201710/668104-20171023164726504-1148106977.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时我们的数据库已经被创建！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/668104/201710/668104-20171023164848519-1314979904.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在就可以正常运行控制台或者ASP.NET Core程序了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/668104/201710/668104-20171023165647769-1368603558.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;EF Core将迁移更新到生产环境可以使用&lt;code&gt;Script-Migration&lt;/code&gt;命令生成sql脚本，然后到生产数据库执行&lt;/p&gt;
&lt;p&gt;语法 &lt;code&gt;Script-Migration [-From] &amp;lt;String&amp;gt; [-To] &amp;lt;String&amp;gt; [-Idempotent] [-Output &amp;lt;String&amp;gt;] [-Context &amp;lt;String&amp;gt;] [-Project &amp;lt;String&amp;gt;] [-StartupProject &amp;lt;String&amp;gt;] [&amp;lt;CommonParameters&amp;gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;code&gt;Script-Migration -From 20171023035934_v113 -To 20171024035934_V114&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上面的命令会生成113版本迁移到114版本的SQL语句&lt;/p&gt;
&lt;p&gt;生成SQL语句如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/668104/201710/668104-20171023170125035-333266862.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;还有一种方法就是通过代码进行自动迁移，这里暂时不做叙述，后面的文章会详细介绍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面所介绍的都是Code First，这里介绍一下DB First，大型项目推荐使用DB First。&lt;/p&gt;
&lt;h6 id=&quot;创建数据库sql-server&quot;&gt;1.创建数据库（Sql Server）&lt;/h6&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;DATABASE&lt;/span&gt; [Blogging];
GO

&lt;span class=&quot;kw&quot;&gt;USE&lt;/span&gt; [Blogging];
GO

&lt;span class=&quot;kw&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;TABLE&lt;/span&gt; [Blog] (
    [BlogId] &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; IDENTITY,
    [Url] &lt;span class=&quot;dt&quot;&gt;nvarchar&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;,
    &lt;span class=&quot;kw&quot;&gt;CONSTRAINT&lt;/span&gt; [PK_Blog] &lt;span class=&quot;kw&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;KEY&lt;/span&gt; ([BlogId])
);
GO

&lt;span class=&quot;kw&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;TABLE&lt;/span&gt; [Post] (
    [PostId] &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; IDENTITY,
    [BlogId] &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;,
    [Content] &lt;span class=&quot;dt&quot;&gt;nvarchar&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;),
    [Title] &lt;span class=&quot;dt&quot;&gt;nvarchar&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;),
    &lt;span class=&quot;kw&quot;&gt;CONSTRAINT&lt;/span&gt; [PK_Post] &lt;span class=&quot;kw&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;KEY&lt;/span&gt; ([PostId]),
    &lt;span class=&quot;kw&quot;&gt;CONSTRAINT&lt;/span&gt; [FK_Post_Blog_BlogId] &lt;span class=&quot;kw&quot;&gt;FOREIGN&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;KEY&lt;/span&gt; ([BlogId]) &lt;span class=&quot;kw&quot;&gt;REFERENCES&lt;/span&gt; [Blog] ([BlogId]) &lt;span class=&quot;kw&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;CASCADE&lt;/span&gt;
);
GO

&lt;span class=&quot;kw&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;INTO&lt;/span&gt; [Blog] (Url) &lt;span class=&quot;kw&quot;&gt;VALUES&lt;/span&gt;
(&lt;span class=&quot;st&quot;&gt;'http://blogs.msdn.com/dotnet'&lt;/span&gt;),
(&lt;span class=&quot;st&quot;&gt;'http://blogs.msdn.com/webdev'&lt;/span&gt;),
(&lt;span class=&quot;st&quot;&gt;'http://blogs.msdn.com/visualstudio'&lt;/span&gt;)
GO&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6 id=&quot;新建一个.net-core控制台程序-1&quot;&gt;2.新建一个.NET Core控制台程序&lt;/h6&gt;
&lt;h6 id=&quot;通过nuget添加ef&quot;&gt;3.通过Nuget添加EF&lt;/h6&gt;
&lt;h6 id=&quot;执行下面的命令创建实体&quot;&gt;4.执行下面的命令创建实体&lt;/h6&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Scaffold-DbContext &quot;Data Source=.;Initial Catalog=Blogging;Integrated Security=True&quot; Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令格式为：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Scaffold-DbContext &quot;数据库连接字符串&quot; EF组件名(Microsoft.EntityFrameworkCore.SqlServer/Pomelo.EntityFrameworkCore.MySql/等等) -OutputDir 输出文件夹名称&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后查看项目目录，可以看到一件多了一个Models文件夹，下面有创建的实体和数据库上下文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/668104/201710/668104-20171023202433691-1581665885.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ASP.NET Core项目操作是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;本文demo-httpsgithub.comstulzqentityframeworkcore2demo&quot;&gt;本文Demo: &lt;a href=&quot;https://github.com/stulzq/EntityFrameworkCore2Demo&quot; class=&quot;uri&quot;&gt;https://github.com/stulzq/EntityFrameworkCore2Demo&lt;/a&gt;&lt;/h4&gt;
</description>
<pubDate>Mon, 23 Oct 2017 23:27:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stulzq/p/7717873.html</dc:identifier>
</item>
<item>
<title>逆向知识第一讲,IDA的熟悉使用 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7721042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7721042.html</guid>
<description>&lt;h2&gt;一丶熟悉IDA,以及手工制作sig文件.&lt;/h2&gt;
&lt;p&gt;IDA,静态分析工具,网上随便找一个即可下载.&lt;/p&gt;
&lt;p&gt;首先,我们写一个可执行EXE,最简单的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024012455707-1690958878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用IDA打开.&lt;/p&gt;
&lt;p&gt;1.提示使用什么格式打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024012547941-253248763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为是PE格式,所以我们选择PE即可.点击OK&lt;/p&gt;
&lt;p&gt;2.重新打开一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024012630238-2076351795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果以前已经打开过这个PE,那么重新打开,则会显示这三个按钮,&lt;/p&gt;
&lt;p&gt;1.overwrite 重新写入,代表覆盖以前的.(联系中常用这个,工作中不常用)&lt;/p&gt;
&lt;p&gt;2.load existing 加载已经存在,这个很常用,因为有的时候汇编的注释很多,或者样本分析不会是一天完成,那么加载这个已经存在的即可.&lt;/p&gt;
&lt;p&gt;3.取消.&lt;/p&gt;
&lt;p&gt;3.打开后显示的视图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024012942551-566521386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个视图是罗列出函数的逻辑.&lt;/p&gt;
&lt;p&gt;我们不看这个,主要是看汇编代码.&lt;/p&gt;
&lt;p&gt;1.切换到汇编代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024013048019-1231428339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右键,点击Text View&lt;/p&gt;
&lt;p&gt;2.查看汇编代码.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024013136082-2119571124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有代码提醒功能,那么我们要学会怎么做,IDA是读取.sig文件,然后显示出来的.&lt;/p&gt;
&lt;p&gt;那么我们要学会怎么做.&lt;/p&gt;
&lt;h2&gt;二丶制作.sig文件.让IDA显示.&lt;/h2&gt;
&lt;p&gt;制作.sig文件,我们依赖于一个VC自带的工具,还有特征提取工具.&lt;/p&gt;
&lt;p&gt;1.VC 自带的lib.exe&lt;/p&gt;
&lt;p&gt;2.特征提取工具pcf.exe&lt;/p&gt;
&lt;p&gt;都会打包.&lt;/p&gt;
&lt;p&gt;第一个,我们首先手动制作一个.sig文件.&lt;/p&gt;
&lt;h3&gt;1.熟悉什么是特征,以及特征是什么.&lt;/h3&gt;
&lt;p&gt;先熟悉一下特征是什么&lt;/p&gt;
&lt;p&gt;首先上图看到,我们已经显示出来了system这个库函数了,那么是怎么显示的? IDA读取sig文件,但是读取sig文件也要有特征匹配才会显示.&lt;/p&gt;
&lt;p&gt;首先我们双击system,进去查看它的汇编,以及二进制代码.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024013619176-460248823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认是没有机器码的,所以我们要显示出来机器码.&lt;/p&gt;
&lt;p&gt;Options(选项) - &amp;gt; General(一般)&lt;/p&gt;
&lt;p&gt;然后出来下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024013722973-896067963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只需要在画红色方框的地方,写入大小,则会显示机器代码多少&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024013821176-508920014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;特征就是固定的二进制代码, 注意,是固定的二进制代码,打死都不会变的.&lt;/p&gt;
&lt;p&gt;比如上面的push ebp的机器代码,是55&lt;/p&gt;
&lt;p&gt;但是注意,偏移不是,比如最后的一个红框后面的偏移,因为这个受很多因素干扰.&lt;/p&gt;
&lt;h3&gt;2.使用lib.exe提取obj文件出来.&lt;/h3&gt;
&lt;p&gt;注意,因为printf是属于libc.lib中,所以直接把libc.lib的obj提取出来&lt;/p&gt;
&lt;p&gt;这里我的环境变量已经配置好了,可以直接使用CMD命令行了,注意,如果你没有配置,请网上搜索配置的方法.&lt;/p&gt;
&lt;p&gt;vc的lib.exe目录所在文件.&lt;/p&gt;
&lt;p&gt;vc98 -&amp;gt; bin -&amp;gt;lib.exe, 这里给的是一部分,因为我不知道你的vc在哪里装着,所以这个是不会变的.&lt;/p&gt;
&lt;p&gt;而libc.lib所在的文件路径,也是在vc98下面,只不过不是bin了,变成了lib了&lt;/p&gt;
&lt;p&gt;首先lib工具的使用命令&lt;/p&gt;
&lt;h3&gt;1.遍历lib中所有obj的文件&lt;/h3&gt;
&lt;p&gt;lib /list xxx.lib&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024015410066-1832610582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.lib.exe提取obj文件出来.&lt;/h3&gt;
&lt;p&gt;命令:&lt;/p&gt;
&lt;p&gt;lib /extract: xxxxx.obj  lib文件名&lt;/p&gt;
&lt;p&gt;比如上面随便提取一个&lt;/p&gt;
&lt;p&gt;lib /extract: build\inter\st_obj\xxxxx.obj  libc.lib&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024015828488-1979378874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 3.使用pcf.exe(特征提取工具)&lt;/h3&gt;
&lt;p&gt;这个工具要自己去下载.&lt;/p&gt;
&lt;p&gt;官方网址: &lt;a href=&quot;http://www.hex-rays.com/products/ida/support/ida/flair61.zip&quot; target=&quot;_blank&quot;&gt;http://www.hex-rays.com/products/ida/support/ida/flair61.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要用户名和密码&lt;/p&gt;
&lt;p&gt;当然也会打包,只不过版本比较低.&lt;/p&gt;
&lt;p&gt;首先,使用pcf文件,生成一个.obj文件的特征码.结尾是.pat&lt;/p&gt;
&lt;p&gt;命令:&lt;/p&gt;
&lt;p&gt;pcf xxxx.obj&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024021310394-1160075168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看特征码格式.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024021620723-2116627138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前边都是机器码,后面的2E 2E 2E 2E...代表的是偏移什么的,反正就是做补充的.&lt;/p&gt;
&lt;p&gt;比如机器码&lt;/p&gt;
&lt;p&gt;55&lt;/p&gt;
&lt;p&gt;68 &lt;/p&gt;
&lt;p&gt;FF 25 00 00 40 00&lt;/p&gt;
&lt;p&gt;那么写到文件中就是55 68 FF 2E 2E 2E 2E 2E 2E 2E 2E &lt;/p&gt;
&lt;p&gt;其中两个2E代表一个.&lt;/p&gt;
&lt;h3&gt;四丶生成.sig文件.&lt;/h3&gt;
&lt;p&gt;这个会用到sigmake的工具&lt;/p&gt;
&lt;p&gt;命令  sigmake  xxxx.pat  xxxx.sig&lt;/p&gt;
&lt;p&gt;举例子:&lt;/p&gt;
&lt;p&gt;sigmake printf.pat  printf.sig&lt;/p&gt;
&lt;p&gt;那么生成的文件就是printf.sig&lt;/p&gt;
&lt;p&gt;只需要把这个文件拷贝到IDA目录下的sig目录下即可.然后使用IDA的时候我们需要简单设置一下.&lt;/p&gt;
&lt;p&gt;命令就是上面那个命令&lt;/p&gt;
&lt;p&gt;制作完成之后拷贝到IDA的sig目录下.&lt;/p&gt;
&lt;p&gt;然后打开IDA, 快捷键Shift + F5  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024022211629-534035712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出来下面的界面&lt;/p&gt;
&lt;p&gt;那么现在我们右键,添加我们的sig文件进去即可.这个时候我们的printf就可以显示了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024022247910-1035582607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加进去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024022313238-2047095285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击OK即可.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171024022402113-776604524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们的printf就已经显示出来了.&lt;/p&gt;
&lt;p&gt;上面只是一个简单的.生成一个,当然可以写脚本生成很多个.&lt;/p&gt;

&lt;p&gt;当然也有脚本,脚本使用方法.(.bat)&lt;/p&gt;
&lt;p&gt;脚本名称  libc&lt;/p&gt;
&lt;p&gt;注意不是libc.lib&lt;/p&gt;
&lt;p&gt;可以一键升成libc库中的所有.sig&lt;/p&gt;
&lt;p&gt; 课堂资料:  链接：&lt;a href=&quot;http://pan.baidu.com/s/1boN2Zvx&quot; target=&quot;_blank&quot;&gt;http://pan.baidu.com/s/1boN2Zvx&lt;/a&gt; 密码：rfag&lt;/p&gt;

</description>
<pubDate>Mon, 23 Oct 2017 18:31:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7721042.html</dc:identifier>
</item>
<item>
<title>javascript 之数据类型--01 - 风吹De麦浪</title>
<link>http://www.cnblogs.com/CandyManPing/p/7720278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CandyManPing/p/7720278.html</guid>
<description>&lt;p&gt;国庆整理资料时，发现刚开始入门前端时学习JS 的资料，打算以一个基础入门博客记录下来，有不写不对的多多指教；&lt;/p&gt;
&lt;p&gt;先推荐些书籍给需要的童鞋&lt;/p&gt;
&lt;p&gt;《JavaScript 高级程序设计.pdf》第三版&lt;/p&gt;
&lt;p&gt; 《JavaScript权威指南(第六版).pdf》&lt;/p&gt;
&lt;p&gt;《高性能javascript.pdf》&lt;/p&gt;
&lt;p&gt;《JavaScript语言精粹---高清版.pdf》&lt;/p&gt;
&lt;p&gt;《你不知道的JavaScript（上卷）.pdf》&lt;/p&gt;
&lt;p&gt;《你不知道的JavaScript（中卷）.pdf》&lt;/p&gt;

&lt;p&gt;ECMAScript 中数据类型分为基本数据类型，复杂数据类型也称为引用数据类型，即常说的对象；&lt;/p&gt;
&lt;p&gt;基本数据类型是简单的数据段，包括 String、Number、Boolean、Null、Undefined。&lt;/p&gt;
&lt;p&gt;引用数据类型是由一组无序的名值对组成 如 Object；&lt;/p&gt;
&lt;h2&gt;基本数据类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、Undefined 类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; Undefined 类型只有一个值，即 undefined。以下情况的值会是 undefined&lt;br/&gt;（1）变量被声明了，但没有赋值，默认值为undefined。&lt;br/&gt;（2）调用函数时，应该提供的参数没有提供，该参数等于undefined。&lt;br/&gt;（3）对象没有赋值的属性，该属性的值为undefined。&lt;br/&gt;（4）函数没有返回值时，默认返回undefined。&lt;br/&gt;（5）未定义的变量使用typeof 返回undefined（严格模式下报错）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script&amp;gt;
    var a;
    console.log(a);//undefined
    function f(a, b, c) {
        console.log(c)//undefined
    }
    f(1, 2); //未传递的实参

    function fo(){}
    console.log(fo());//没有明确返回值，默认返回undefined
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、Null 类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Null 只有一个值 null，null是javascript语言的关键字，它表示一个特殊值，常用来描述&quot;空值&quot;，从逻辑角度来看，null 是一个空对象指针；通常要把一个变量来保存对象，那么最好将变量初始化为null；&lt;/p&gt;
&lt;p&gt;[注意]null是空对象指针，而[]是空数组，{}是空对象，三者不相同；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;null与undefined 都是表示无、不存在，那么为什么会同时存在呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、一开始null像在Java、.net里一样，被当成一个对象。但是javascript的值分成原始类型和对象类型两大类，作者认为基本类型表示”无”的值最好不是对象。&lt;br/&gt;2、javascript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。作者认为如果null自动转为0，很不容易发现错误；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;null 与undefined 区别又是什么呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前来说，null和undefined基本是同义的，都是表示无，只是应用场景不太一样 如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;null表示&quot;没有对象&quot;，即该处不应该有值&lt;/strong&gt;。典型用法是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作为函数的参数，表示该函数的参数不是对象。&lt;/li&gt;
&lt;li&gt;作为对象原型链的终点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;undefined表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义/初始化&lt;/strong&gt;。典型用法是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量被声明了，但没有赋值，默认值为undefined。&lt;/li&gt;
&lt;li&gt;调用函数时，应该提供的参数没有提供，该参数等于undefined。&lt;/li&gt;
&lt;li&gt;对象没有赋值的属性，该属性的值为undefined。&lt;/li&gt;
&lt;li&gt;函数没有返回值时，默认返回undefined。&lt;/li&gt;
&lt;li&gt;未定义的变量使用typeof 返回undefined（严格模式下报错）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;(typeof null) //返回object 误区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是0。由于 null 被设计成空指针(大多数平台下值为0x00)，因此，null的类型标签也成为了0，typeof null就错误的返回了&quot;object&quot;.(referenc) &lt;strong&gt;但是如果修复了 会造成大量旧的js不兼容；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该现象有待于在ECMAScript 6中被修复 (该提议已被否决). 正确的返回值将成为 typeof null === 'null'.&lt;/p&gt;
&lt;p&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、Boolean 类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Boolean 布尔类型有 true、false。在js中是区分大小写的，即 True、False 并不是Boolean的值，虽然Boolean 只有这两个值，但是在js中任何数据类型的值调用Boolean()函数，都能返回一个Boolean值；只要记住如下规则即可：（0，-0，NaN，''，null，undefined）这六个永远为false，其它都为true&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script&amp;gt;
    var message = 'ds';
    if (message) {
        console.log('成功'+message)// 成功ds
    }
    var obj={};
    if(obj){
        console.log('成功'+obj)// 成功[object Object]
    }
    var a=0;
    if(a){
        console.log('成功'+a);
    }else{
        console.log('失败'+a)// 失败0
    }

&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4、Number 类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在js中使用Number 类型来表示整数与浮点数（数值必须包含一个小数点）；&lt;/p&gt;
&lt;p&gt;var intNum=66; //整数&lt;br/&gt;var floatNum=1.1 //浮点数&lt;/p&gt;
&lt;p&gt;如果某次计算的结果超出了Javascript 数值范围（Number.MAX_VALUE 最大值 Number.MIX_VALUE）那么这个结果就会自动转为Infinity，如果这个数值是负数会转为-Infinity（负无穷），如果是正数会转为Infinity（正无穷）&lt;/p&gt;
&lt;p&gt;NaN：非数值（Not a Number）是一个特殊的值，表示这里本应该是一个数值，但是并不是数值； 如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
 var a=10,b='str';
    console.log(a*b);//NaN
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NaN 具有如下特点：&lt;br/&gt;1、任何与NaN的操作都是返回NaN;&lt;br/&gt;2、NaN与任何值都不相等；　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script&amp;gt;
    var a = 10, b = 'str';
    console.log(a * b);//NaN

    console.log(NaN == NaN)//false
    console.log(NaN === NaN)//false
    console.log(NaN == 'str')//false
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对NaN的两个特点，ECMAScript定义了 isNaN()函数来确定某个变量/表达式结果是不是NaN，这个函数会尝试把变量转换为数值，如果不能转换则返回true，反正返回false;　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script&amp;gt;

    console.log(isNaN('red'));//true 不能转换number
    console.log(isNaN('10'));//false 能转换number
    console.log(isNaN(10));//false 能转换number
    console.log(isNaN(false));//false 能转换number
    console.log(isNaN(true));//false 能转换number

    console.log(isNaN(''));//false 能转换number  0
    console.log(isNaN(undefined));//true 不能转换number
    console.log(isNaN('undefined'));//true 不能转换number
    console.log(isNaN(null));//false 能转换number 0
    console.log(isNaN('null'));//true 不能转换number
    
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;typeof 基本数据类型检查&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script&amp;gt;
    var s = 'name';
    console.log(typeof s)//string
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;typeof                            返回以下字符串&lt;/p&gt;
&lt;p&gt;undefined                      这个变量未定义、未初始化&lt;br/&gt;object                            这个变量是对象或者是null&lt;br/&gt;boolean                         这个变量是布尔值&lt;br/&gt;number                          这个变量是数值&lt;br/&gt;string                             这个变量是字符串&lt;br/&gt;function                         这个变量是函数&lt;/p&gt;

&lt;p&gt;引用类型是一种用于将数据和功能组织在一起的数据结构（也常被成为类），引用类型的值（对象）是引用类型的一个实例。但是js中没有类的概念，因此引用类型也可以被称为对象，因为他们描述的是属性和方法的集合；&lt;br/&gt;ECMAScript提供了很多原生引用类型（如：Object）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Object类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们看到的大部分引用类型都是Object类型的实例，Object的实例本身不具备很多功能，但对于在应用程序中存储和传输数据而言，是非常理想的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Array类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了Object之外，Array算是js最常用最常用的类型。js中的数组与其他语言的数组都是数据的有序列表，因为js是弱类型，所以js中数组的每一项可以保存任何类型的数据；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Date类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;js中用于构建日期对象的引用类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RegExp类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;js通过RegExp类型来支持正则表达式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;js中的function实际上是对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针；&lt;/p&gt;
&lt;p&gt;引用类型提供的属性以及方法这里不在叙述，不知道的可以参考如下连接&lt;/p&gt;
&lt;p&gt;http://www.w3school.com.cn/jsref/jsref_obj_array.asp&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;instanceof  检测某个实例的具体类型 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
object instanceof constructor
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;&lt;br/&gt;instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。&lt;br/&gt;可以理解为 instanceof 用于判断某个实例（对象）是否是某个类型的实例；　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
var a=new Array();
alert(a instanceof Array);//true，
alert(a instanceof Object)也会返回true;这是因为Array是object的子类。

再如：
function test(){};
var a=new test();
alert(a instanceof test)会返回true。
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 23 Oct 2017 17:18:00 +0000</pubDate>
<dc:creator>风吹De麦浪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CandyManPing/p/7720278.html</dc:identifier>
</item>
<item>
<title>node+vue进阶【课程学习系统项目实战详细讲解】打通前后端全栈开发(1)：创建项目，完成登录功能 - 苏天天</title>
<link>http://www.cnblogs.com/chengduxiaoc/p/7718768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengduxiaoc/p/7718768.html</guid>
<description>&lt;p&gt;第一章 建议学习时间8小时·分两次学习      总项目预计10章&lt;/p&gt;

&lt;p&gt;学习方式：详细阅读，并手动实现相关代码（如果没有node和vue基础，请学习前面的vue和node基础博客【共10章】）&lt;/p&gt;
&lt;p&gt;视频教程地址：www.lalalaweb.com，随博客进度会上传教学视频，大家可前往视频学习（暂时还没有视频）&lt;/p&gt;
&lt;p&gt;演示地址：后台：&lt;a href=&quot;http://demoback.lalalaweb.com/&quot; target=&quot;_blank&quot;&gt;demoback.lalalaweb.com&lt;/a&gt;  前台：&lt;a href=&quot;http://demo.lalalaweb.com/&quot; target=&quot;_blank&quot;&gt;demo.lalalaweb.com&lt;/a&gt;&lt;a href=&quot;http://www.lalalaweb.com/&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后台权限是开放的，大家一定不要删除admin用户或修改密码，不然别人就无法登录了，演示过程中可能会发现bug，希望即时留言反馈，谢谢&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;源码下载：https://github.com/sutianbinde/classweb               //不是全部的代码，每次更新博客才更新代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习目标&lt;/strong&gt;：此教程将教会大家 如何一步一步实现一个完整的课程学习系统（包括课程管理后台/Node服务器/学习门户三个模块）。&lt;/p&gt;
&lt;p&gt;上次node基础课程博客大家反响很好，时隔3个月，才更新项目部分，预计2~3天更新一章，我尽量20天更新完毕，学完这个项目Nodejs和vue就基本熟悉了，如发现教程有误的地方，请及时留言反馈&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;express项目构建  vue-cli项目构建&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 我们首先给项目取一个名字  “在线课堂” 好啦，英文名 classweb&lt;/p&gt;
&lt;p&gt;先在自己喜欢的位置 创建项目目录文件夹  classweb&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023192040285-1072887756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建node项目（这个项目我们采取前后端分离的模式，所以需要分别创建node和vue项目，但都放在classweb中）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入目录，运行  express server 生成服务器端项目(server是我们服务端项目的名字)   （这里注意，得提前安装node express-generator，学习过前面node基础的同学这些应该的安装了的，没安装的先学前面的课程）&lt;/p&gt;
&lt;p&gt;打开命令行的简单方法：在文件夹中按住 shift 鼠标右键 点击“在此处打开命令行” / &quot;在此处打开powershell窗口&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023192514457-736489017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先安装 cnpm 镜像(它是npm的国内代理，可以使下载速度加快，如果以及安装了的就不用安装了)，使用如下代码，安装完成后测试一下 cnpm -v&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install -g cnpm --registry=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;registry.npm.taobao.org&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023193755004-589452432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进入项目，安装依赖，运行测试一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023192810473-19248230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023192833285-1083535287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样就运行起来了，在浏览器输入http://localhost:3000/  访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023192913332-1610595750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面 Node项目就建好了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建 vue项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先全局安装vue-cli&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --global vue-cli
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里注意，我们最好是另外开一个命令行 来执行，因为开发时前面的Node项目和vue项目要同时运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023194807332-1826230854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后在创建vue项目，使用 npm install --global vue-cli&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：ESLint选项要选择no（不然代码一点不规范就报错） ，如果选错了，把vueclient文件夹删了重新创建一遍即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023195514113-1466939518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 进入项目，安装依赖，运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023195812473-109234738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这时候浏览器中就自动代开网页了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023195850223-2048122847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;两个项目的安装和测试就完成了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装mongodb操作软件 Robomongo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;百度云链接&lt;/p&gt;
&lt;p&gt;链接：http://pan.baidu.com/s/1jHLSG78 密码：6dhb&lt;/p&gt;
&lt;p&gt;安装方法参考：https://jingyan.baidu.com/article/9113f81b011ee72b3214c78d.html&lt;/p&gt;

&lt;p&gt; 链接好以后，在nwe connection右键  create database   输入创建 classweb数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023200950223-321070522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023201044519-2111615735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;创建好以后，展开classweb,然后在cloolections右键，  create collection 创建一个user表（在弹出框中输入user），用来放后台登录的用户&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023201134082-1029215018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建好以后就有user表了，双击就能打开user表，现在里面没有数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023201358051-361388733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 往里面添加一条数据，便于以后登录使用&lt;/p&gt;
&lt;p&gt;user右键 insert document，然后输入后面的数据 ，save， （数据用户名 admin  密码是 123456 加密后的字段 还有手机号）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023201958551-703176926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;name&quot; : &quot;admin&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;phone&quot; : &quot;13388868886&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;password&quot; : &quot;4QrcOUm6Wau+VuBX8g+IPg==&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023201936410-224574481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后表中就多了这么一条数据了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023202135816-321206029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现登录功能&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 首先我们把项目导入 编辑器，我这里使用的Hbuilder，建议大家也使用这个，因为项目中nodemodules的文件太多，webstrom或sublimetex都会很卡&lt;/p&gt;
&lt;p&gt;然后找到App.vue，去掉多余示例样式，只留图中的部分，这是项目的入口页面&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：每个项目都有很多文件，大家暂时也不用明白他们都表示什么意思，等用到的时候我会在用到的地方给大家讲解的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;预警：第一次进入项目开发，肯定会有很多报错，大家一定仔细阅读步骤，仔细实现代码，如果报错，有是英文的看不懂，大家可以试着查一查百度/google，也可以在下边留言，我看到尽量简答，不要因为出错了难以解决就放弃了，我开始学习的时候也遇到很多不知所措的错误，心中会有一万只草泥马奔腾的感觉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023204023051-894974835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后在componets文件夹中新建 login.vue 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023205322598-119007564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在login.vue文件中写入下面登录页面的代码(实现了基本的登录布局，在js中定义就基本的变量和登录的方法名)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;backlogin&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;login_box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;后台登录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;myinput&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;手机号/用户名&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;@keyup.13&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;myinput&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;口令&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;login_other&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;找回密码&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;remenberme&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;remenberme&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;记住我&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;:disabled&lt;/span&gt;&lt;span&gt;=&quot;disablebtn&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{loginText}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    
    export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
      name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;backlogin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      data () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                username:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;TODO:先预存测试值，以免手动输入&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                password:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                disablebtn:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                loginText:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
      },
      methods:{
            login(){
                
            }
        }
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Add &quot;scoped&quot; attribute to limit CSS to this component only &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;scoped&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    .header&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 60px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        box-shadow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 1px 5px rgba(13,62,73,0.2) &lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .header img&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 170px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin-top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 12px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin-left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 15px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .header span&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #566a80&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 21px 0 0 20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .login_box&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 320px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .login_box .myinput&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1px solid #cad3de&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 40px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 40px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 5px 0 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        border-radius&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 3px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        outline&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; none&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        box-sizing&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; border-box&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .login_box .myinput:focus&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1px solid #4289dc&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .login_other&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        overflow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; hidden&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    
    .login_other a&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; right&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #727f8f&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .login_other a:hover&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #273444&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .login_other input, .login_other label&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #727f8f&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .login_other input&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 4px 5px 0 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .login&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        box-sizing&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; border-box&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; none 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 44px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        line-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 44px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#4187db&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 16px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        border-radius&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 3px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin-right&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 40px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        transition&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; all 0.5s ease&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        cursor&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; pointer&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        outline&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; none&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #fff&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin-top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 15px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .login:hover&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #2668b5&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .login[disabled]&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        opacity&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0.8&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .login[disabled]:hover&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#4187db&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .title&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #273444&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1.5em&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 0 20px 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    
    @media only screen and (max-width: 768px) &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        .login_box{
            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 280px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 然后修改router文件夹下的index.js文件来配置首页访问的组件是login.vue   （这里获取组件的时候  @表示src文件夹路径  所有vue文件的引入都不需要vue后缀，import后的赋值最好统一给大写）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023205740301-1448799262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这样我们会发现刚打开的vue项目自动刷新了，展示效果如下图（如果没有刷新请查看命令行窗口有无报错，有报错就需要修改代码，修改正确再重启 npm run dev）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023210032863-2066565209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ajax请求&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;vue中请求数据，这里我们使用第三方库axios，这也是vue作者推荐的，比自带的http好用很多。&lt;/p&gt;
&lt;p&gt;先安装axios&lt;/p&gt;
&lt;p&gt;把原来的服务ctrl+c两次停掉，然后 运行 cnpm install axios --save 安装，安装完成再重新启动服务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：这里为什么要用 --save呢，因为使用save的话，这个包就会集成到package.json中的，我们上线的时候就能通过npm install去直接安装了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023210824394-820328830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完成后大家打开package.json，就可以看到里面多了 axios:版本号&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023210944082-919708630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后我们在main.js中添加如下代码 引入axios，并配置基础路径（因为是跨域请求node端，所以所有请求前面都需要添加node端的基础地址，以后打包上线的时候需要合并的时候再把这个地址删掉），文件位置和修改后的代码如下图&lt;/p&gt;
&lt;p&gt;由于是跨域请求，我们需要配置withCredentials为true，这样避免每次都被识别为新的请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import axios from 'axios';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入axios组件&lt;/span&gt;
axios.defaults.withCredentials=&lt;span&gt;true&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跨域保存session有用&lt;/span&gt;
axios.defaults.baseURL = &quot;http://localhost:3000&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打包的时候直接删掉，默认基础路径在这里配置&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;将 axios 赋值给 Vue，方便在子组件里面使用&lt;/span&gt;
Vue.prototype.$reqs = axios;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023211751113-556737072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后在Login.vue中写登录的具体方法  将如下登录请求代码写在 login方法中，登录的地址为 “/users/login” ，这个接口我们一会儿在node中去写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.disablebtn = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loginText = &quot;登录中...&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this.$reqs就访问到了main.js中绑定的axios&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.$reqs.post(&quot;/users/login&quot;&lt;span&gt;,{
                        username:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.username,
                        password:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.password
                }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(result){ 
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;
&lt;span&gt;                    console.log(result)
                    _this.disablebtn &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    _this.loginText &lt;/span&gt;= &quot;登录&quot;&lt;span&gt;;
                    
                }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (error) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;失败&lt;/span&gt;
                    _this.disablebtn = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    _this.loginText &lt;/span&gt;= &quot;登录&quot;&lt;span&gt;
                });
                &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;然后我们转到node端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先在routes中创建dbhandler.js文件，写入下面我们封装好的mongodb操作方法。增删改查的具体操作我们在前面的node基础教程中已经详细讲解了，这是这些方法的封装，代码和以前讲的封装有些许差异，大家直接用下面的代码，不要用以前的。&lt;/p&gt;
&lt;p&gt;这些方法我也写了好久，这里直接贡献给大家，大家就可以不用自己写了，直接复制就Ok，空了可以好好研究研究&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023214047160-340477126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; mongo=require(&quot;mongodb&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; MongoClient =&lt;span&gt; mongo.MongoClient;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; assert = require('assert'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = require('url'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host=&quot;localhost&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port=&quot;27017&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Urls = 'mongodb://localhost:27017/classweb'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; classweb  ===&amp;gt; 自动创建一个&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;add一条数据 &lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; add = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(db,collections,selector,fn){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; collection =&lt;span&gt; db.collection(collections);
  collection.insertMany([selector],&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,result){
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
        assert.equal(err,&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
      console.log(e);
      result &lt;/span&gt;=&lt;span&gt; [];
    };
    
    fn(result);
    db.close();
  });
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; deletes = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(db,collections,selector,fn){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; collection =&lt;span&gt; db.collection(collections);
  collection.deleteOne(selector,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,result){
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
        assert.equal(err,&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        assert.notStrictEqual(&lt;/span&gt;0&lt;span&gt;,result.result.n);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
      console.log(e);
      result.result &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
    };
    
    fn( result.result &lt;/span&gt;? [result.result] : []); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没报错且返回数据不是0，那么表示操作成功。&lt;/span&gt;
&lt;span&gt;    db.close;
  });
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;find&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; find = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(db,collections,selector,fn){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;collections=&quot;hashtable&quot;;&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; collection =&lt;span&gt; db.collection(collections);
  
    collection.find(selector).toArray(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,result){
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(docs);&lt;/span&gt;
      &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
        assert.equal(err,&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
      }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
        console.log(e);
        result &lt;/span&gt;=&lt;span&gt; [];
      }
      
      fn(result);
      db.close();
    });

}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; updates = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(db,collections,selector,fn){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; collection =&lt;span&gt; db.collection(collections);
  
  collection.updateOne(selector[&lt;/span&gt;0],selector[1],&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,result){
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
        assert.equal(err,&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        assert.notStrictEqual(&lt;/span&gt;0&lt;span&gt;,result.result.n);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
      console.log(e);
      result.result &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
    };
    
    fn( result.result &lt;/span&gt;? [result.result] : []); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没报错且返回数据不是0，那么表示操作成功。&lt;/span&gt;
&lt;span&gt;    db.close();
  });

}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; methodType =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 项目所需&lt;/span&gt;
&lt;span&gt;  login:find,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   type ---&amp;gt; 不放在服务器上面&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  放入到服务器&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  请求---&amp;gt; 根据传入进来的请求 数据库操作&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  req.query    req.body&lt;/span&gt;
  show:find, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;后台部分&lt;/span&gt;
&lt;span&gt;  add:add,
  update:updates,
  &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;:deletes,
  updatePwd:updates,
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;portal部分&lt;/span&gt;
&lt;span&gt;  showCourse:find,
  register:add
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主逻辑    服务器  ， 请求    --》 &lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; req.route.path ==》 防止前端的请求 直接操作你的数据库&lt;/span&gt;
module.exports = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res,collections,selector,fn){
  MongoClient.connect(Urls, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err, db) {
    assert.equal(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, err);
    console.log(&lt;/span&gt;&quot;Connected correctly to server&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据 请求的地址来确定是什么操作  （为了安全，避免前端直接通过请求url操作数据库）&lt;/span&gt;
    methodType[req.route.path.substr(1&lt;span&gt;)](db,collections,selector,fn);
    
    db.close();
  });

};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 然后修改自动生成的 users.js  为如下代码&lt;/p&gt;
&lt;p&gt;代码解释：&lt;/p&gt;
&lt;p&gt;引入了express框架，路由router，并且引入了上面封装的 dbhandler。&lt;/p&gt;
&lt;p&gt;crypto是加密包，对传输过来的密码进行加密&lt;/p&gt;
&lt;p&gt;post请求使用  post方法接收&lt;/p&gt;
&lt;p&gt;handler()调用的是dbhander中的方法，传入的参数依次 （ req:请求详细， res:响应信息，  “user”操作的表的名称， 传入的查询数据， 回掉函数）&lt;/p&gt;
&lt;p&gt;在dbhander.js中配置了login对应的操作是查询，返回数据放到数组中。如果数组空，就表示没查到数据，如果非空，比较密码是否一致，如果都正确，就返回登录成功。&lt;/p&gt;
&lt;p&gt;最后的module.exports = router是ES6的模块暴露，前面基础博客中已经讲了，这里就不赘述了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express = require('express'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; router =&lt;span&gt; express.Router();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handler = require('./dbhandler.js'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; crypto = require('crypto'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; POST users listing. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;
router.post('/login', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req, res, next) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; md5 = crypto.createHash('md5'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; password = md5.update(req.body.password).digest('base64'&lt;span&gt;);

    handler(req, res, &lt;/span&gt;&quot;user&quot;, {name: req.body.username},&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data.length===0&lt;span&gt;){
            res.end(&lt;/span&gt;'{&quot;err&quot;:&quot;抱歉，系统中并无该用户，如有需要，请向管理员申请&quot;}'&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(data[0].password !==&lt;span&gt; password){
            res.end(&lt;/span&gt;'{&quot;err&quot;:&quot;密码不正确&quot;}'&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(data.length!==0&amp;amp;&amp;amp;data[0].password===&lt;span&gt;password){
            
            req.session.username &lt;/span&gt;= req.body.username; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存session&lt;/span&gt;
            req.session.password =&lt;span&gt; password;
            
            res.end(&lt;/span&gt;'{&quot;success&quot;:&quot;true&quot;}'&lt;span&gt;);
        }
        
    });
    
});

module.exports &lt;/span&gt;= router;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样请求的代码就写完了，但是跨域请求 需要在node中也作配置才可以请求到&lt;/p&gt;
&lt;p&gt;修改app.js，在11行左右找到 var app= express()，在其后面添加如下代码&lt;/p&gt;
&lt;p&gt;第二段代码是服务器端存session的，直接使用express-session模块（后面会带着大家安装），然后添加配置项即可（配置项的说明在备注中）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跨域  后期删&lt;/span&gt;
app.all('*', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req, res, next) {
        res.header(&lt;/span&gt;&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8080&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了跨域保持session，所以指定地址，不能用*&lt;/span&gt;
    res.header('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS'&lt;span&gt;);
    res.header(&lt;/span&gt;&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;&lt;span&gt;);
    res.header(&lt;/span&gt;'Access-Control-Allow-Headers', 'Content-Type'&lt;span&gt;);
    res.header(&lt;/span&gt;'Access-Control-Allow-Credentials', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;); 
    next();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;session&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; session=require('express-session'&lt;span&gt;);
app.use(session({
    secret:&lt;/span&gt;'classweb531234',               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 session 签名&lt;/span&gt;
    name:'classweb'&lt;span&gt;,
    cookie:{maxAge:&lt;/span&gt;60*1000*60*24}, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 储存的时间 24小时&lt;/span&gt;
    resave:&lt;span&gt;false&lt;/span&gt;,             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次请求都重新设置session&lt;/span&gt;
    saveUninitialized:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023222704160-900561364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 停止Node端服务，安装mongodb&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnpm install mongodb --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023214714223-617382537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;安装 express-session&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnpm install express-session --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023223744082-622125574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 重启服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023223834535-171807667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;刷新vue的登录页面，点击登录&lt;/p&gt;
&lt;p&gt;你会发现，控制台打印出了返回的登录成功信息，这样我们的登录功能就编写完成了 （常见出错原因在后面附录）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023223937535-716473130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 附录：常见报错&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt; 1. 数据库连接失败 ：&lt;/p&gt;
&lt;p&gt;　　①可能mongo未自动启动，请按基础教程中的介绍正确启动mongo (Net start MongoDB) &lt;/p&gt;
&lt;p&gt;　　 ②数据库名没写对  检查dbhandler.js中的下图名字是否和数据库名称一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023224453160-1843162721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023224532551-1370137498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　③表名称没给对 ，检查user.js 中的表名是否和数据库中的一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023224618035-1106314512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.根本链接不到地址，在网页控制台打印红色的链接失败&lt;/p&gt;
&lt;p&gt;　　①请求地址没写对,核对login.vue中的地址和 node端routes/index.js中的地址是否对上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171023224842394-1659398555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　②跨域配置不对，请按上面的步骤把 vue部分和node部分都好好再核对着写一遍&lt;/p&gt;




&lt;p&gt;好啦，今天就讲到这里。下一篇将讲解 首页路由配置，导航，首页统计信息，用户添加/修改/删除，表格组件封装。&lt;/p&gt;

&lt;p&gt;关注公众号，博客更新即可收到推送&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799986/201710/799986-20171011124427824-1210633966.jpg&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Oct 2017 16:24:00 +0000</pubDate>
<dc:creator>苏天天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengduxiaoc/p/7718768.html</dc:identifier>
</item>
<item>
<title>读阮一峰老师 es6 入门笔记 —— 第一章 - Stitch晨</title>
<link>http://www.cnblogs.com/stitchgogo/p/7533273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stitchgogo/p/7533273.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　鉴于最近用 vuejs 框架开发项目，其中有很多涉及到 es6 语法不太理解所以便认真地读了一下这本书。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　地址：&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot;&gt;http://es6.ruanyifeng.com/#README&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一章：let ,const 命令以及块级作用域&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;es6 新增了 let 和 const 这两个变量的声明关键字，这样大大的强化了 js 变量的合理程度以及修补了很多es6 版本前出现的bug。他们有着以下的特性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 &lt;span&gt; &lt;strong&gt;&lt;span&gt;一：let 的声明&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 &lt;strong&gt;&lt;span&gt;1.1 用let 声明的变量会将变量绑定到声明时所属的语句块中，并且语句块外部不可访问&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 例如下面这个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;}

console.log(i);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ReferenceError: i is not defined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在es6 版本以前，循环条件内的变量如果用var 声明则循环结束后还可以在外部环境中访问，而是用let 声明不会。在每一次循环中let 都会被重新声明一次并且在本轮循环中有效&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在for 循环中还有一个特别的地方，条件块和执行块都是一个独立的块作用域因此下面的例子也能正常运行&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
  let i &lt;/span&gt;= 'abc'&lt;span&gt;;
  console.log(i);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; abc&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; abc&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; abc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;即使是声明了同名变量但因为是在不同的块作用域中声明，所以不会报错，但我觉得为了阅读代码有更好的体验还是尽量别用同名变量&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.2 用let 声明的变量不存在变量提升&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;变量提升一直是js 的一个通病，好听一点是叫做“特征”，这不仅颠覆了编程语言执行顺序还会带来一些不可思议的问题，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; var 的情况&lt;/span&gt;
console.log(foo); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出undefined&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; foo = 2&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; let 的情况&lt;/span&gt;
console.log(bar); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错ReferenceError&lt;/span&gt;
let bar = 2;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一种用var 声明的变量在代码执行前就已经存在变量的提升可以拆解为如下步骤：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; var 的情况&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; foo;
console.log(foo); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出undefined&lt;/span&gt;
foo = 2;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以才会输出 undefined&lt;/p&gt;
&lt;p&gt;而let 的出现改变了这个“特征”，使js 不存在变量声明，假若在声明变量语句前调用变量则会报错&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.3 暂时性死区&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个语句块中用let 声明一个变量，这个变量便会绑定在这个语句块中不受外部变量影响，例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; tmp = 123&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
  tmp &lt;/span&gt;= 'abc'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ReferenceError&lt;/span&gt;
&lt;span&gt;  let tmp;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面例子中因为tmp 是在if 语句块中声明所以tmp 便绑定在了if 语句块中，语句块中又会重新判断一次块内语句声明的合理性，而tmp 的调用时在声明前所以报错&lt;/p&gt;
&lt;p&gt;总之，在代码块内，使用&lt;code&gt;let&lt;/code&gt;命令声明变量之前，该变量都是不可用的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.4 不允许重复声明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用let 声明的变量不能同名，否则报错，另外在函数内部用let 声明的变量也不可以与参数同名&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二：块级作用域&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 没有作用域的日子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;es5 没有块级作用域的概念，这样导致了内层变量覆盖外层变量 以及 用来计数的循环变量泄露为全局变量　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内层变量覆盖外层变量的例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; tmp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f() {
  console.log(tmp);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp = 'hello world'&lt;span&gt;;
  }
}

f(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面说过var 声明的变量会被提升，所以上面的例子可以拆解成这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; tmp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f() {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; tmp;
  console.log(tmp);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
    tmp &lt;/span&gt;= 'hello world'&lt;span&gt;;
  }
}

f(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为变量提升 tmp 未被赋值就被调用（函数的后期也没有为tmp 赋值），所以导致函数输出为undefined&lt;/p&gt;

&lt;p&gt;用来计数的循环变量泄露为全局变量例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; s = 'hello'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; s.length; i++&lt;span&gt;) {
  console.log(s[i]);
}

console.log(i); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面也说过，用let 在循环条件内部声明变量的好处就是不会将变量泄露到全局作用域，而用var 则会。es5的解决办法是用闭包模拟块作用域迫使循环条件内部的变量不泄露&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2 es6 作用域的来袭&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看个例子：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f1() {
  let n &lt;/span&gt;= 5&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
    let n &lt;/span&gt;= 10&lt;span&gt;;
  }
  console.log(n); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;函数体内部定义了一个块作用域，其上级作用域就是函数体，当在if 语句作用域外调用 变量n 的时候是不会调用到if 语句内部的变量的只会调用会输出语句所属语句块中的对应变量。&lt;/p&gt;
&lt;p&gt;假如用var 声明便会这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f1() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n = 5&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n = 10&lt;span&gt;;
     }
    console.log(n);
}

f1();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为变量的提升影响了输出结果，分解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f1() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; n;
    n &lt;/span&gt;= 5&lt;span&gt;;
   
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
          n &lt;/span&gt;= 10&lt;span&gt;;
     } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断条件成立 变量n 被重新赋值为10&lt;/span&gt;
&lt;span&gt;    console.log(n);
}

f1();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 故输出10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.3 块作用域可嵌套，在不同的块作用域声明同名变量不会报错&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{{{{
  let insane &lt;/span&gt;= 'Hello World'&lt;span&gt;;
  {let insane &lt;/span&gt;= 'Hello World'&lt;span&gt;}
}}}}; &lt;span&gt;// 没问题&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;块作用域的出现使原来的 iife（自执行函数）可以停止使用了&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.4 块级内部声明函数可能会因为浏览器的差异导致不可思议的效果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;es5 规则中函数只能在全局作用域中声明，不能再局部作用域声明，但是浏览器并没有遵循这个原则为了兼容以前的旧代码这种声明是正常的&lt;/p&gt;
&lt;p&gt;而es6 有了块作用域的概念，明确指明可以在块级作用域中声明函数，例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; f() { console.log('I am outside!'&lt;span&gt;); }

(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重复声明一次函数f&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt; f() { console.log('I am inside!'&lt;span&gt;); }
  }

  f();
}());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在es5 中运行会输出  I am inside! 因为函数声明的提升，而在es6 中调用理论会输出  I am outside!，而实际上浏览器执行会直接报错那是因为为了减轻老代码不兼容的问题浏览器可以不按规则办事，具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;允许在块级作用域内声明函数。&lt;/li&gt;
&lt;li&gt;函数声明类似于&lt;code&gt;var&lt;/code&gt;，即会提升到全局作用域或函数作用域的头部。&lt;/li&gt;
&lt;li&gt;同时，函数声明还会提升到所在的块级作用域的头部。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 所以在支持es6 的浏览器执行上面例子语句其实会执行如下语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 浏览器的 ES6 环境&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; f() { console.log('I am outside!'&lt;span&gt;); }
(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; f;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
    f &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;() { console.log('I am inside!'&lt;span&gt;); }
  }

  f();
}());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncaught TypeError: f is not a function&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;考虑到浏览器的差异，所以尽量少在块作用域中使用函数声明而改成用函数表达式。&lt;/p&gt;
&lt;p&gt;另外ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不报错&lt;/span&gt;
'use strict'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f() {}
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错&lt;/span&gt;
'use strict'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; f() {}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.5 do 表达式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;块作用域没有返回值，如果在块作用域前面加上一个 do 关键字可以使块作用域有返回值，在chrome 上没有实验出来只能贴下阮一峰老师的实例代码了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let x = &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
  let t &lt;/span&gt;=&lt;span&gt; f();
  t &lt;/span&gt;* t + 1&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;x 会得到块作用域的返回值（尽管不知道哪里才是返回的值）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三：const（&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;constant &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;） 声明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3.1 const 声明的变量是一个常量，声明之后常量的值不可改变而且一旦声明就必须要初始化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;声明常量后再次赋值的错误：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const PI = 3.1415&lt;span&gt;;
console.log(PI); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.1415&lt;/span&gt;
&lt;span&gt;
PI &lt;/span&gt;= 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错 TypeError: Assignment to constant variable.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;声明常量但不赋初始值的错误：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const foo;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SyntaxError: Missing initializer in const declaration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2 const 声明的常量和 let 声明的变量一样：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1、都会绑定在声明的语句块中，在语句块外调用会报错&lt;/p&gt;
&lt;p&gt;　　2、不存在变量提升，存在暂时性死区，只能在声明的位置后面使用&lt;/p&gt;
&lt;p&gt;　　3、不能重复声明&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.3 const 声明的常量是一个基础类型，那么它保证这个基础类型的值不变；如果const 声明的常量是一个引用类型，那么它保证这个引用的指针不变&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，&lt;code&gt;const&lt;/code&gt;只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。例如我们改变对象中某个键的对应值，在常量声明下是可以继续运行的不会报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想完全冻结对象可以用使用 Object.freeze() &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Oct 2017 16:21:00 +0000</pubDate>
<dc:creator>Stitch晨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stitchgogo/p/7533273.html</dc:identifier>
</item>
<item>
<title>linux组网笔记 - ooj88s</title>
<link>http://www.cnblogs.com/ooj88s/p/7719926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ooj88s/p/7719926.html</guid>
<description>&lt;p&gt;一直以为自己linux还说的过去，事实上已经跟不上日新月异的应用需要了。&lt;/p&gt;
&lt;p&gt;现成文档都没法看，错太多。然而毕竟是多年积累，整理一个准确的文档还是能做到的。&lt;/p&gt;
&lt;p&gt;本机ip设置：&lt;/p&gt;
&lt;p&gt;# static interface&lt;br/&gt;auto eth0&lt;br/&gt;iface eth0 inet static&lt;br/&gt;address 192.168.127.11&lt;br/&gt;netmask 255.255.255.0&lt;br/&gt;network 192.168.127.0&lt;br/&gt;broadcast 192.168.127.255&lt;br/&gt;gateway 192.168.127.2&lt;br/&gt;dns-nameservers 192.168.127.2&lt;/p&gt;
&lt;p&gt;说明一下，这个是/etc/network/interfaces配置的某网卡设置，很多文档不是少了网关就是少了dns，难道没有配置过windows的ip？&lt;/p&gt;
&lt;p&gt;# dhcp interface&lt;br/&gt;auto eth1&lt;br/&gt;iface eth1 inet dhcp&lt;/p&gt;
&lt;p&gt;自动分配ip，没啥说的。&lt;/p&gt;
&lt;p&gt;有些系统的dns设置在另一个地方，/etc/resolv.conf。&lt;/p&gt;
&lt;p&gt;我的系统中这个文件会被重置。很多解决方法说关掉NetworkManager？这不是扯么。哪有这么解决问题的，拆东墙补西墙。&lt;/p&gt;
&lt;p&gt;有的会好一点，改/etc/sysconfig/network-scripts/，&lt;/p&gt;
&lt;p&gt;似乎是在centos上好用。&lt;/p&gt;
&lt;p&gt;还有一个文件修改了也可以，是在/etc/NetworkManager/NetworkManager.conf中注释掉dns=dnsmasq这个行。&lt;/p&gt;
&lt;p&gt;可以看到，这些办法都是比较排斥新组件的，与自由开放的互联网精神背道而驰。&lt;/p&gt;
&lt;p&gt;其实随便看看返回的信息就知道，ubuntu系统是使用了resolvconf这个新工具来配置dns的，而这个工具并不建议直接调用，&lt;/p&gt;
&lt;p&gt;推荐了一种更规范的操作，就是使用一个新字段dns-nameservers在interfaces文件中，这会隐式的自动调用这个新工具配置dns。&lt;/p&gt;
&lt;p&gt;当然也不是啥新工具了，14.04版就有了。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 16:02:00 +0000</pubDate>
<dc:creator>ooj88s</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ooj88s/p/7719926.html</dc:identifier>
</item>
<item>
<title>Cocos2d-x Lua游戏开发Mac环境搭建以及一点点感悟 - Zxiao..旭</title>
<link>http://www.cnblogs.com/taoxu/p/7639940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taoxu/p/7639940.html</guid>
<description>
&lt;p&gt;接触Cocos2d-x&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;       最近由于公司项目的需要，自己开始接触Cocos，开始做一些简单的轻量级的游戏，以前没有接触过这一块的东西，也是借助这个机会学习一下游戏的开发，由于以前自己接触的全都是iOS和Android移动端App的开发，所以这整个Cocos的学习总结的文章会在真个过程中贯穿对比自己相对熟悉的iOS和Android对比学习，要是也有和我自己情况类似的朋友，接下来总结的这整个Cocos系列的文章也许可以帮助到你，有不足的地方也希望指正，我们一同进步。&lt;/p&gt;
&lt;p&gt;       刚开始的时候，由于以前的游戏是用C++开发，自己就去慢慢的开始学习用Cocos2d-x C++简单的了解项目。自己看了最基本的一些Cocos的东西之后，说以后的游戏用JS做，然后又开始学习JS，最后决定用Lua开发，可能这就是人生.....其实上面说的意思就是想总结一些开发游戏的时候我们可以有的选择，开发语言就有 C++，JavaScript , Lua 三个选择，它们和你真正利用它们做游戏就像你懂OC、Swift。懂Java之后去做iOS或者Android之间的距离，这个可以仔细的想一想，懂这些语言和开发实际项目之间距离是什么，然后也就明白懂这些语言和实际的游戏项目开发之间欠缺的就是Cocos2d-x的东西，要认清了这些也就了解了“游戏怎么做”这个基本的问题吧！ &lt;/p&gt;

&lt;p&gt;说说Cocos  &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      Cocos是一个大概念，等我们具体的开发中使用到的是Cocos2d-x模块的东西，看看这个Cocos 产品的一个架构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/739006/201710/739006-20171009141309762-880478599.png&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1: Cocos Creator 这是一个为我们开发游戏做的IDE，具体的可以看这个 &lt;a href=&quot;http://www.cocos.com/docs/creator/&quot; target=&quot;_blank&quot;&gt;Cocos Creator v1.5.x 用户手册&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2: Framework 这个就是开发的核心Cocos2d-x，其实按照我自己的理解，和iOS中我们常说的框架是类似的，比如你处理一些基本数据你就需要Foundation框架，处理UI的东西需要UIKit框架一样，这个Cocos2d-x就是我们开发游戏是需要的“框架”。&lt;/p&gt;
&lt;p&gt;3: SDK 这一部分的AnySDK是为CP商提供一套第三方SDK接入解决方案，包括我们常用的像支付、分享、统计分析等等。具体的也可以看看 &lt;a href=&quot;http://docs.anysdk.com/&quot; target=&quot;_blank&quot;&gt;SDK文档&lt;/a&gt;，可能有些人还知道棱镜SDK、anysdk、易接（1SDk），关于这几个有什么区别，甚至在什么时候用哪个等等的额问题，下面这篇文章可能能说明问题：&lt;/p&gt;
&lt;p&gt;     &lt;a href=&quot;https://www.zhihu.com/question/24680586&quot; target=&quot;_blank&quot;&gt;如何评价棱镜SDK、anysdk、易接（1SDk），他们都有什么差别&lt;/a&gt;？&lt;/p&gt;
&lt;p&gt;4、&lt;/p&gt;

&lt;p&gt;通过上面的分析和阐述能明白 Cocos 是什么 这个问题就可以了。&lt;/p&gt;

&lt;p&gt;说说Cocos开发语言&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      前面Framework提到过游戏开发的语言，就是C++ 、JavaScript 、Lua这三种，按照我自己的一点点小小的理解，要说什么语言比较好一点这种问题也不够资格回答，在知乎上看到过这样的问题，有兴趣的可以去看看，也许里面一些回答能让你有自己的理解：&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;https://www.zhihu.com/question/23363748&quot; target=&quot;_blank&quot;&gt;最适合游戏开发的语言是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      相信每一个程序猿对C/C++是有一定的掌握的，按照自己学习JS和Lua的过程，它们的学习难度都不大，完全可以通过对C掌握来相对容易的拿下它们。所以千万不要为你要学习一门新的开发语言而担心或者害怕，哪有程序猿不需要学习新东西更新自己的知识库的！当然这点难度的是也难不倒伟大的程序猿。&lt;/p&gt;
&lt;p&gt;      接下来说说Lua，Lua是一个脚本语言，具体的Lua语法什么的我们就不提了，在后面具体说到Lua的时候再说，知道了Cocos2d-Lua你还需要知道这个： Quick-Coco2d-x&lt;/p&gt;
&lt;p&gt;      下面这段话是在泰然网（也就是Quick-Coco2d-x官网）的教程里面说的，具体的告诉我们，什么是 Quick-Coco2d-x  &lt;/p&gt;
&lt;p&gt;      首先，想了解 Quick-Coco2d-x 就必须先知道 Cocos2d-x 是什么，不过我想关于 Cocos2d-x 的介绍这里就不用我来废话了吧，毕竟这么牛的游戏引擎还是应该很点名气的吧！&lt;/p&gt;
&lt;p&gt;      其次，由于 Cocos2d-x 中使用的是 C++ 语言，而 C++ 又对开发人员要求较高，所以逐渐地，开发者们开始将 Cocos2d-x 的 C++ 接口转成了 Lua 接口，从而衍生出了 Cocos2d-lua 的版本。而 Quick（Quick-Coco2d-x）是 Cocos2d-Lua 的一个豪华增强和扩展版本，它重写了支持代码、解决了内存泄露和只能使用全局函数做回调等等问题。Quick 能让开发者使用 Lua 这种简单易懂的脚本语言来编写游戏，并大大提高了开发效率。现在Quick 团队也已接手了 Cocos2d-lua 的开发和维护工作，所以未来 Quick 和 Cocos2d-lua 将有望完全合并起来。&lt;/p&gt;
&lt;p&gt;      我想通过上面两段话也就理解了Quick-Coco2d-x 和 Cocos2d-lua的关系！而下面的开发环境的搭建我们也就这两个方面说说，用Quick-Coco2d-lua 和Cocos2d-lua进行一个对比，也就能知道怎样的开发环境对于开发人员是最友好的。&lt;/p&gt;

&lt;p&gt;在Mac上开发游戏环境选择搭建&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      首先通过环境的搭建和各种对比之后在这抛出一个见解： 目前自己觉得比较友好的方式是 Quick-Coco2d-x + Sublime Text 3(2/3都可以)&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;http://www.sublimetext.com/&quot; target=&quot;_blank&quot;&gt;Sublime Text 3&lt;/a&gt; 你可以直接去官网下载    具体的 Quick-Coco2d-x 你可以看看这个：&lt;a href=&quot;http://www.cocoachina.com/bbs/read.php?tid-331250.html%20%20&quot; target=&quot;_blank&quot;&gt;Quick社区版第一个稳定版，Quick-Cocos2dx-Community 3.6 release发布&lt;/a&gt;！&lt;/p&gt;
&lt;p&gt;      它详细的介绍了Mac版本的客户端Paly3安装方式，下面就是一个Paly3运行起来的样子：&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;http://images2017.cnblogs.com/blog/739006/201710/739006-20171023233431207-2059861720.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;552&quot;/&gt;&lt;/p&gt;

&lt;p&gt;         接下来这个Paly3 我们就不再说了，新建项目/导入项目  或者打开已有的项目等等的相信都能理解。要是安装中出现一些问题，希望都可以自己动手上网解决了，当然也可以加我QQ多多交流。&lt;/p&gt;
&lt;p&gt;        Mac 搭建游戏开发环境还有一些方式，比如：还有利用 Cocos Studio 2 的，这个具体的可以看它的官网：  &lt;a href=&quot;http://www.cocos.com/&quot; target=&quot;_blank&quot;&gt;Cocos 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        看看官网的下载，相信创建一个基本的Demo这种事也难不住你。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;http://images2017.cnblogs.com/blog/739006/201710/739006-20171023234706910-202682848.png&quot; alt=&quot;&quot; width=&quot;804&quot; height=&quot;386&quot;/&gt;&lt;/p&gt;

&lt;p&gt;          直接运行你创建在项目，也就可以看到Demo啦。&lt;/p&gt;
&lt;p&gt;          再给大家分享个链接： &lt;a href=&quot;http://www.tairan.com/AboutQuick&quot;&gt;Quick-Cocos2d-x教程汇总&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;后面文章做的事&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;      其实这篇文章起笔真的也是许久之前的事情了，自己接触Cocos也就两个多月，感觉也度过了最艰难的入门时期，最近也真的是太忙，没有时间留给自己总结这两个多月的东西了，没错，国庆加班到现在，真的是累！&lt;/p&gt;
&lt;p&gt;      不传播负能量啦，说说后面的，其实很想仔细的把iOS内存管理，Block以及多线程的东西也好好的总结一下的，最近给游戏里面负责添加了苹果原生支付，所以Lua和iOS的交互以及苹果内购方面的东西也值得好好总结一下啦。&lt;/p&gt;
&lt;p&gt;      接下来应该会先总结Lua和iOS交互以及支付的事，毕竟也要给客户写文档，到时顺便把这些一起做了。&lt;/p&gt;
&lt;p&gt;      猿猿们，1024快乐！！！&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 15:57:00 +0000</pubDate>
<dc:creator>Zxiao..旭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taoxu/p/7639940.html</dc:identifier>
</item>
<item>
<title>hash在URL上的用法及作用 - 畅园</title>
<link>http://www.cnblogs.com/dsfads/p/7719906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dsfads/p/7719906.html</guid>
<description>&lt;div id=&quot;navCategory&quot;&gt;
&lt;p&gt;&lt;strong&gt;阅读目录&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h3&gt;1. #&lt;/h3&gt;
&lt;p&gt;    10年9月，twitter改版。一个显著变化，就是URL加入了&quot;#!&quot;符号。比如，改版前的用户主页网址为&lt;a href=&quot;http://twitter.com/username&quot;&gt;http://twitter.com/username&lt;/a&gt;改版后，就变成了&lt;a href=&quot;http://twitter.com/#!/username&quot;&gt;http://twitter.com/#!/username&lt;/a&gt;&lt;br/&gt;　　这是主流网站第一次将&quot;#&quot;大规模用于重要URL中。这表明井号（Hash）的作用正在被重新认识。本文根据HttpWatch的文章，整理与井号有关的所有重要知识点。&lt;br/&gt;&lt;strong&gt;一、#的涵义&lt;/strong&gt;&lt;br/&gt;　　#代表网页中的一个位置。其右面的字符，就是该位置的标识符。比如，http://www.example.com/index.html#print就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。&lt;br/&gt;　　为网页位置指定标识符，有两个方法。一是使用锚点，比如&amp;lt;a name=&quot;print&quot;&amp;gt;&amp;lt;/a&amp;gt;，二是使用id属性，比如&amp;lt;div id=&quot;print&quot;&amp;gt;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;二、HTTP请求不包括#&lt;/strong&gt;&lt;br/&gt;　　#是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括#。&lt;br/&gt;比如，访问下面的网址，&lt;a href=&quot;http://www.example.com/index.html#print&quot;&gt;http://www.example.com/index.html#print&lt;/a&gt;，浏览器实际发出的请求是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /index.html HTTP/1.1
Host: www.example.com
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;三、#后的字符&lt;/strong&gt;&lt;br/&gt;　　在第一个#后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。&lt;br/&gt;比如，下面URL的原意是指定一个颜色值：&lt;a href=&quot;http://www.example.com/?color=#fff&quot;&gt;http://www.example.com/?color=#fff&lt;/a&gt;，但是，浏览器实际发出的请求是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /?color= HTTP/1.1
Host: www.example.com
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;四、改变#不触发网页重载&lt;/strong&gt;&lt;br/&gt;　　单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页。&lt;br/&gt;比如，从http://www.example.com/index.html#location1改成http://www.example.com/index.html#location2，浏览器不会重新向服务器请求index.html。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、改变#会改变浏览器的访问历史&lt;/strong&gt;&lt;br/&gt;　　每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用&quot;后退&quot;按钮，就可以回到上一个位置。这对于&lt;strong&gt;ajax&lt;/strong&gt;应用程序特别有用，可以用不同的#值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、window.location.hash读取#值&lt;/strong&gt;&lt;br/&gt;　　window.location.hash这个属性可读可写。读取时，可以用来判断网页状态是否改变；写入时，则会在不重载网页的前提下，创造一条访问历史记录。&lt;br/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七、onhashchange事件&lt;/strong&gt;&lt;br/&gt;　　这是一个HTML 5新增的事件，当#值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。&lt;br/&gt;　　它的使用方法有三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;window.onhashchange = func;&lt;/li&gt;
&lt;li&gt;&amp;lt;body onhashchange=&quot;func();&quot;&amp;gt;&lt;/li&gt;
&lt;li&gt;window.addEventListener(&quot;hashchange&quot;， func, false);&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;八、Google抓取#的机制&lt;/strong&gt;&lt;br/&gt;　　默认情况下，Google的网络蜘蛛&lt;strong&gt;忽视&lt;/strong&gt;URL的#部分。&lt;br/&gt;　　但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用&quot;#!&quot;，Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。&lt;br/&gt;　　比如，Google发现新版twitter的URL：&lt;a href=&quot;http://twitter.com/#!/username&quot;&gt;http://twitter.com/#!/username&lt;/a&gt;&lt;br/&gt;　　就会自动抓取另一个URL：&lt;a href=&quot;http://twitter.com/?_escaped_fragment_=/username&quot;&gt;http://twitter.com/?_escaped_fragment_=/username&lt;/a&gt;&lt;br/&gt;　　通过这种机制，Google就可以索引动态的Ajax内容。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/subview/1641/5762264.htm?fr=aladdin&quot;&gt;AJAX&lt;/a&gt; = 异步 &lt;a href=&quot;http://baike.baidu.com/view/16168.htm&quot; target=&quot;_blank&quot;&gt;JavaScript&lt;/a&gt;和&lt;a href=&quot;http://baike.baidu.com/view/63.htm&quot; target=&quot;_blank&quot;&gt;XML&lt;/a&gt;（&lt;a href=&quot;http://baike.baidu.com/view/5286041.htm&quot; target=&quot;_blank&quot;&gt;标准通用标记语言&lt;/a&gt;的子集）。AJAX 是一种用于创建快速动态网页的技术。&lt;/p&gt;
&lt;h3&gt;2. ？&lt;/h3&gt;
&lt;p&gt;1）连接作用：比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http://www.xxx.com/Show.asp?id=77&amp;amp;nameid=2905210001&amp;amp;page=1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）清除缓存：比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http://www.xxxxx.com/index.html 
http://www.xxxxx.com/index.html?test123123
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个url打开的页面一样，但是后面这个有问号，说明不调用缓存的内容，而认为是一个新地址，重新读取。&lt;/p&gt;

&lt;h3&gt;3. &amp;amp;&lt;/h3&gt;
&lt;p&gt;不同参数的间隔符&lt;/p&gt;

</description>
<pubDate>Mon, 23 Oct 2017 15:53:00 +0000</pubDate>
<dc:creator>畅园</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dsfads/p/7719906.html</dc:identifier>
</item>
<item>
<title>如何升级laravel5.4到laravel5.5并使用新特性？ - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/7719893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/7719893.html</guid>
<description>&lt;p&gt;修改composer.json:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;laravel/framework&quot;: &quot;5.5.*&quot;,

&quot;phpunit/phpunit&quot;: &quot;~6.0&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;scripts增加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        &quot;post-autoload-dump&quot;: [
            &quot;Illuminate\\Foundation\\ComposerScripts::postAutoloadDump&quot;,
            &quot;@php artisan package:discover&quot;
        ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行composer update -vvv&lt;/p&gt;

&lt;p&gt;为扩展包增加了一个自动发现功能。&lt;/p&gt;
&lt;p&gt;以barryvdh/laravel-debugbar为例，先删除这个包。composer remove barryvdh/laravel-debugbar&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/136188/201710/136188-20171023234627519-1875875714.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先把APP里面的Barryvdh\Debugbar\ServiceProvider::class,去掉。&lt;/p&gt;
&lt;p&gt;就删除成功了。&lt;/p&gt;
&lt;p&gt;再重新安装：&lt;/p&gt;
&lt;p&gt;我们看github上这个包最新版的&lt;br/&gt;Installing barryvdh/laravel-debugbar (v3.1.0): Downloading (100%)&lt;/p&gt;
&lt;p&gt;里面的包的composer.json有这么一个说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;extra&quot;: {
        &quot;branch-alias&quot;: {
            &quot;dev-master&quot;: &quot;3.0-dev&quot;
        },
        &quot;laravel&quot;: {
            &quot;providers&quot;: [
                &quot;Barryvdh\\Debugbar\\ServiceProvider&quot;
            ],
            &quot;aliases&quot;: {
                &quot;Debugbar&quot;: &quot;Barryvdh\\Debugbar\\Facade&quot;
            }
        }
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到，在bootstrap/cache/packages.php里面已经写上了debugbar，并且我们在页面上也可以看到有debugbar的存在。但是我们并不需要在app.php里面增加debugbar的serviceProvider了。非常方便!!!&lt;/p&gt;
&lt;p&gt;就是说，我们引入的包里面，只要有这个extra.laravel的说明，后面的providers和alias会自动增加到框架中去。&lt;/p&gt;

&lt;p&gt;这个特性的功能就是把资源直接作为api返回给前端，并且进行需要的包装。&lt;/p&gt;
&lt;p&gt;这里的resource就是返回资源，我们可以创建这么一个返回资源，这个资源会被包装在data字段中，json，api返回。&lt;/p&gt;
&lt;p&gt;比如创建一个PostCollection资源。代表文章集合。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;php artisan make:resource PostCollection&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我希望返回的api里面有两个字段：data和meta，data代表的就是文章集合，meta代表的是一些附属的元数据信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php

namespace App\Http\Resources;

use Illuminate\Http\Resources\Json\ResourceCollection;

class PostCollection extends ResourceCollection
{
    /**
     * Transform the resource collection into an array.
     *
     * @param  \Illuminate\Http\Request
     * @return array
     */
    public function toArray($request)
    {
        return parent::toArray($request);
    }


    public function with($request)
    {
        return [
            'meta' =&amp;gt; [
                'site' =&amp;gt; 'laravel55',
            ],
        ];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在路由中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Route::get('/api/posts', function () {
    return new \App\Http\Resources\PostCollection(\App\Post::all());
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且在\App\Post中重新定义toArray()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public function toArray()
    {
        return [
            &quot;id&quot; =&amp;gt; $this-&amp;gt;id,
            &quot;title&quot; =&amp;gt; $this-&amp;gt;title,
        ];
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这个时候就返回了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/136188/201710/136188-20171023234732613-1101718611.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有人说，其实laravel中在控制器中直接返回对象也就是调用它们的toArray方法，那么如果你把上式的路由修改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Route::get('/api/posts', function () {
    return new \App\Http\Resources\PostCollection(\App\Post::paginate(3));
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你就感觉到增加这个&quot;api resource&quot;的方便性了：统一API返回结构，并且让你少写了很多代码。&lt;/p&gt;

&lt;p&gt;我们之前自定义的Command需要在Console\Commands\Kernel.php中写上每个Command:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Kernel extends ConsoleKernel
{
    /**
     * The Artisan commands provided by your application.
     *
     * @var array
     */
    protected $commands = [
        \App\Console\Commands\ESInit::class
    ];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，不用了，只修改commands函数:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected function commands()
    {
        $this-&amp;gt;load(__DIR__ . '/Commands');

        require base_path('routes/console.php');
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这个规则是为了我们的自定义验证规则。比如，我们的登录，需要邮箱后缀为gmail.com才能登录。那么这个时候我们就需要定义一个验证规则类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;php artisan make:rule ValidLoginEmail&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在App\Rules文件夹下面看到ValidLoginEmail类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class ValidLoginEmail implements Rule
{
    /**
     * Create a new rule instance.
     *
     * @return void
     */
    public function __construct()
    {
        //
    }

    /**
     * Determine if the validation rule passes.
     *
     * @param  string  $attribute
     * @param  mixed  $value
     * @return bool
     */
    public function passes($attribute, $value)
    {
        $strs = explode(&quot;@&quot;, $value);
        if (count($strs) == 2 &amp;amp;&amp;amp; $strs[1] == &quot;gmail.com&quot;) {
            return true;
        }
        return false;
    }

    /**
     * Get the validation error message.
     *
     * @return string
     */
    public function message()
    {
        return '邮箱必须是gmail结尾';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再修改loginController的login()的验证部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$this-&amp;gt;validate(request(),[
            'email' =&amp;gt; ['required', new ValidLoginEmail(), 'email'],
            'password' =&amp;gt; 'required|min:5|max:10',
            'is_remember' =&amp;gt; 'integer'
        ]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/136188/201710/136188-20171023234831473-608339696.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;还是login方法，我们也可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public function login(Request $request)
    {
        // 验证
        $request-&amp;gt;validate([
            'email' =&amp;gt; ['required', new ValidLoginEmail(), 'email'],
            'password' =&amp;gt; 'required|min:5|max:10',
            'is_remember' =&amp;gt; 'integer'
        ]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不再需要使用&lt;br/&gt;&lt;code&gt;$this-&amp;gt;validate(request(),[&lt;/code&gt;&lt;br/&gt;这样做的好处是更语义化了：验证请求符合下列规则...&lt;/p&gt;

&lt;p&gt;在以前，我们自定义一个Exception类，要想这个异常单独处理，就需要在Handler.php里面的render方法这么写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public function render($request, Exception $exception)
    {
        if ($exception instanceof \App\Exceptions\ForbiddenException) {
            return response()-&amp;gt;view(&quot;exceptions/forbidden&quot;);
        }
        return parent::render($request, $exception);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样自定义异常定义多了，这个函数就非常冗余。&lt;/p&gt;
&lt;p&gt;现在的方法就是，在自定义异常里面定义一下render方法就行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
namespace App\Exceptions;

class ForbiddenException extends \Exception
{
    /**
     * Report the exception.
     *
     * @return void
     */
    public function report()
    {
        //
    }

    /**
     * Report the exception.
     *
     * @param  \Illuminate\Http\Request
     * @return void
     */
    public function render($request)
    {
        return response()-&amp;gt;view(&quot;exceptions/forbidden&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果你这个路由什么逻辑都没有，只是渲染一个模版，那么就很适合使用这个方法。比如创建文章页面：&lt;/p&gt;
&lt;p&gt;原先：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Route::get('/posts/create', '\App\Http\Controllers\PostController@create');


    // 创建页面
    public function create()
    {
        return view(&quot;post/create&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 创建文章
    Route::view('/posts/create', 'post/create');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个功能大赞，能让人少写很多代码。&lt;/p&gt;
&lt;p&gt;更多5.5新特性请看：&lt;br/&gt;&lt;a href=&quot;https://laravel.com/docs/5.5/releases&quot; class=&quot;uri&quot;&gt;https://laravel.com/docs/5.5/releases&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Oct 2017 15:50:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjf512/p/7719893.html</dc:identifier>
</item>
<item>
<title>80806汇编(5)——[BX]和Loop指令 - exRunner</title>
<link>http://www.cnblogs.com/exRunner/p/7719894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/exRunner/p/7719894.html</guid>
<description>&lt;p&gt;已经好久没写点东西了，国庆节就一直想弄个个人网站，这段时间一直在弄那个，虽然有现成的框架（Hexo），但是总想弄出自己的效果来，但是最后还是有些差强人意，只好打翻了有重来（强迫症表示难受），也懒得弄那么多了。好在最近差不多事情也理顺了，今天强迫自己静下来写了点东西。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;简述&quot;&gt;简述&lt;/h2&gt;
&lt;p&gt;今天看了下汇编中的[BX]和Loop指令，Loop指令容易知道，一看就是用来做循环的指令，那么[BX]又是什么呢？&lt;/p&gt;
&lt;p&gt;首先我们知道，要完整的描述一个内存单元，需要两种信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存单元的地址&lt;/li&gt;
&lt;li&gt;内存单元的长度（类型：字节或字等）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于第一个——【内存单元的地址】，我们知道，用[addr]可以表示一个内存单元，其中addr表示这个内存单元的偏移地址，段地址默认在DS寄存器中。而单元的长度（类型）则可以由指令中的其他操作对象指出（如寄存器），就像下面这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么，在这里[BX]也表示一个内存单元，其偏移地址存于BX寄存器中，段地址默认在DS寄存器中。也把BX寄存器叫做&lt;strong&gt;基址寄存器&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;两个约定&quot;&gt;两个约定&lt;/h2&gt;
&lt;p&gt;为了方便后面的叙述，这里作两个约定，当然也是跟着书上的来啦，哈哈，不过我发现很多书上也都默认有这个叙述方法。&lt;/p&gt;
&lt;h3 id=&quot;描述性符号&quot;&gt;1. 描述性符号&quot;( )&quot;&lt;/h3&gt;
&lt;p&gt;用描述性符号“( )”表示一个寄存器或一个内存单元中的内容，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(ax) 表示寄存器AX中的内容，(al) 表示寄存器AL中的内容。
(addr) 表示物理地址为addr的内存单元中的内容。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此&quot;( )&quot;中的元素类型有3种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;寄存器名；&lt;/li&gt;
&lt;li&gt;段寄存器名；&lt;/li&gt;
&lt;li&gt;内存单元的物理地址。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其所表示的数据类型有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字节；&lt;/li&gt;
&lt;li&gt;字。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体是那种类型则由寄存器名或具体的运算符决定。&lt;/p&gt;
&lt;h3 id=&quot;常量符号idata&quot;&gt;2. 常量符号&quot;idata&quot;&lt;/h3&gt;
&lt;p&gt;用idata表示一个常量。&lt;br/&gt;如用&lt;code&gt;mov ax, [idata]&lt;/code&gt;代表&lt;code&gt;mov ax, [1]&lt;/code&gt;、&lt;code&gt;mov ax, [2]&lt;/code&gt;等。&lt;br/&gt;如用&lt;code&gt;mov bx, idata&lt;/code&gt;代表&lt;code&gt;mov bx, 1&lt;/code&gt;、&lt;code&gt;mov bx, 2&lt;/code&gt;等。&lt;/p&gt;
&lt;h2 id=&quot;bx&quot;&gt;[BX]&lt;/h2&gt;
&lt;p&gt;我们对[BX]的使用有如下用法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, [&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]  &lt;span class=&quot;co&quot;&gt;; bx中存放的数据作为偏移地址，段地址默认在ds中，(ax) = ((ds) * 16 + (bx))&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; [&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;], &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;; bx中存放的数据作为偏移地址，段地址默认在ds中，((ds) * 16 + (bx)) = (ax)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;loop指令&quot;&gt;Loop指令&lt;/h2&gt;
&lt;p&gt;Loop指令用于实现循环功能，循环次数存于CX寄存器中 。&lt;br/&gt;【格式】loop 标号&lt;br/&gt;示例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;cx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;; 设置循环次数&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;s:&lt;/span&gt;                  &lt;span class=&quot;co&quot;&gt;; 标号&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;; 循环执行的程序段&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;loop&lt;/span&gt; s           &lt;span class=&quot;co&quot;&gt;; Loop指令&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Loop指令通常用于执行某些需要重复运行的指令，比如操作某一块连续的内存地址块。通常把循环次数存于CX寄存器中，CPU通过判断CX里面的值是否为零来决定是否执行循环。CPU执行Loop指令的描述如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. (CX) = (CX) -1
2. (CX)不为零，转去标号处执行，反之不执行循环，向下执行指令&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的标号&quot;s&quot;并不是固定的，你也可以指定其他的标号。在这里标号实际上是标识了一个地址，在该地址处存在着我们的程序指令（如上面的add ax, ax），在执行循环的时候，若CX的值不为零，则&quot;Loop 标号&quot;指令将IP的值设置为标号所标识的地址，CPU就将执行IP所指向的指令。&lt;/p&gt;
&lt;p&gt;我们可以得到这样一个Loop指令的简单框架：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;cx&lt;/span&gt;, 循环次数
&lt;span class=&quot;ot&quot;&gt;label&lt;/span&gt;:
需要循环执行的程序段
&lt;span class=&quot;kw&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;label&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【注意】书上的一个实例程序中提到在汇编程序中的数据表示问题，我们知道，在汇编中，数据多以16进制表示，而16进制中有 'A~F' 6个字母，但是在汇编源程序中，数据的书写不能以字母开头，如“9876H”可以直接书写为“9876H”，但是“A000H”不能书写成“A000H”，而需写为“0A000H”（以0开头）。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;bx和loop指令&quot;&gt;[BX]和Loop指令&lt;/h2&gt;
&lt;p&gt;在实际编程中可能会遇到要处理某一段地址连续的内存单元中的数据，通常可用循环来解决这类问题。在这样的循环过程中，需要一个变量来保存内存单元的偏移地址，这时候“基址寄存器——BX”就起作用了。&lt;/p&gt;
&lt;p&gt;【注：以下内容来自王爽的《汇编语言》(第三版)】&lt;br/&gt;考虑这么一个问题，我们要计算 ffff:0~ffff:b 单元中的数据的和，要求将结果存储在dx寄存器中。&lt;br/&gt;我们首先分析一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;运算后的结果是否会超出dx能存储的范围？&lt;br/&gt;&lt;code&gt;ffff:0~ffff:b 内存单元中的数据是字节型的数据，范围在0~255之间，12个这样的数据相加的结果不会大于65535，是可以存储在dx寄存器中的。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我们能否将 ffff:0~ffff:b 中的数据直接累加到dx中？&lt;br/&gt;&lt;code&gt;这是比不可能的，为什么？因为数据类型不匹配，dx是16位寄存器，而 ffff:0~ffff:b 中的数据是8位的。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;那么是否可以将其累加到dl中，并设置(dh)=0，从而实现累加到dx中？&lt;br/&gt;&lt;code&gt;看第一条分析，12个8字节的数据相加是有可能超过255的，而我们的dl是8位寄存器，那么答案很明显了。不能！&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;那到底应该如何做呢？&lt;br/&gt;&lt;code&gt;这里有两个问题，类型的匹配和结果的不超界，我们可以考虑用一个16位的寄存器来做中介。将内存单元中的8位数据赋值到一个16位寄存器ax中，再将ax中的数据加到dx上，从而使两个运算对象类型匹配并且结果不会超界。&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;考虑完以上问题，很明显，如果是在高级语言中，这是一个很容易做的问题，一个循环就可以实现，那么在汇编中，我们也可以用循环来实现这个操作。我们可以把BX用作存储内存单元偏移地址的变量，在每次循环的时候改变BX中的值，从而实现把 ffff:0~ffff:b 12个内存单元中的数据相加。&lt;br/&gt;实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;assume &lt;span class=&quot;kw&quot;&gt;cs&lt;/span&gt;:code
code &lt;span class=&quot;kw&quot;&gt;segment&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;    start:&lt;/span&gt;             &lt;span class=&quot;co&quot;&gt;;程序入口&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;, 0ffffh&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ds&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;;初始化ds:bx指向ffff:0&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;dx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;;初始化累加寄存器dx，(dx)=0&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;cx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;    s:&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;al&lt;/span&gt;, [&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt; ah, &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;dx&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;inc&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;;使ds:bx指向下一个内存单元&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;loop&lt;/span&gt; s

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;, 4c00h&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt; 21h&lt;/span&gt;
code ends
&lt;span class=&quot;ot&quot;&gt;end&lt;/span&gt; start        &lt;span class=&quot;co&quot;&gt;;程序结束&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;段前缀&quot;&gt;段前缀&lt;/h2&gt;
&lt;p&gt;在指令“mov ax, [bx]”中，内存单元的偏移地址由bx指出，而段地址则默认存储在ds中。但是我们可以在访问内存单元的指令中显示给出内存单元的段地址所在的段寄存器，如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ds&lt;/span&gt;:[&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;cs&lt;/span&gt;:[&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ss&lt;/span&gt;:[&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;es&lt;/span&gt;:[&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ss&lt;/span&gt;:[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;cs&lt;/span&gt;:[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些出现在访问内存单元的指令中，用于显示地指明内存单元的段地址的“ds:” “cs:” “es:” “ss:”，在汇编语言中称为&lt;strong&gt;段前缀&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;段前缀的使用&quot;&gt;段前缀的使用&lt;/h3&gt;
&lt;p&gt;考虑一个问题，将内存单元 ffff:0~ffff:b 单元中的数据复制到 0:200~0:20b 单元中。&lt;br/&gt;分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;0:200 ~0:20b 单元等同于 0020:0~0020:b 单元，它们描述的是同一段内存空间。&lt;/li&gt;
&lt;li&gt;复制过程用循环实现，我们可以使用一个变量[BX]同时操作两段内存单元（使用段前缀来标识不同的段）。&lt;/li&gt;
&lt;li&gt;将 0:200~0:20b 用 0020:0~0020:b 描述，是为了使目标单元的偏移地址和源始单元的偏移地址从同一数值0开始。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode asm&quot;&gt;
&lt;code class=&quot;sourceCode fasm&quot;&gt;assume &lt;span class=&quot;kw&quot;&gt;cs&lt;/span&gt;:code
code &lt;span class=&quot;kw&quot;&gt;segment&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;, 0ffffh&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ds&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;;(ds)=0ffffh&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;, 0020h&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;es&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;;(es)=0020h&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;;此时ds:bx指向ffff:0，es:dx指向0020:0&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;cx&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;    s:&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;dl&lt;/span&gt;, [&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;]      &lt;span class=&quot;co&quot;&gt;;段地址默认在ds中&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;es&lt;/span&gt;:[&lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;], &lt;span class=&quot;kw&quot;&gt;dl&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;;段前缀指明内存段&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;inc&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;bx&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;loop&lt;/span&gt; s

    &lt;span class=&quot;kw&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt;, 4c00h&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;bn&quot;&gt; 21h&lt;/span&gt;
code ends
&lt;span class=&quot;ot&quot;&gt;end&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 23 Oct 2017 15:50:00 +0000</pubDate>
<dc:creator>exRunner</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/exRunner/p/7719894.html</dc:identifier>
</item>
</channel>
</rss>