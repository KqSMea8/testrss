<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>单点登录系统实现 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/8094722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/8094722.html</guid>
<description>&lt;p&gt;今天的干货有点湿，里面夹杂着我的泪水。可能也只有代码才能让我暂时的平静。通过本章内容你将学到单点登录系统和传统登录系统的区别，单点登录系统设计思路，Spring4 Java配置方式整合HttpClient，整合SolrJ ，HttpClient简易教程。还在等什么？撸起袖子开始干吧！&lt;br/&gt;效果图：8081端口是sso系统，其他两个8082和8083端口模拟两个系统。登录成功后检查Redis数据库中是否有值。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/806956/201712/806956-20171223175305193-1149592447.gif&quot; alt=&quot;效果图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;技术：SpringBoot，SpringMVC，Spring，SpringData，Redis，HttpClient&lt;br/&gt;说明：本章的用户登录注册的代码部分已经在SpringBoot基础入门中介绍过了，这里不会重复贴代码。&lt;br/&gt;源码：见文章底部&lt;br/&gt;SpringBoot基础入门：&lt;a href=&quot;http://www.cnblogs.com/itdragon/p/8047132.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/itdragon/p/8047132.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;单点登录系统简介&quot;&gt;单点登录系统简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/806956/201712/806956-20171223225633553-1173436321.png&quot; alt=&quot;单点登录系统&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在传统的系统，或者是只有一个服务器的系统中。Session在一个服务器中，各个模块都可以直接获取，只需登录一次就进入各个模块。若在服务器集群或者是分布式系统架构中，每个服务器之间的Session并不是共享的，这会出现每个模块都要登录的情况。这时候需要通过单点登录系统（Single Sign On）将用户信息存在Redis数据库中实现Session共享的效果。从而实现一次登录就可以访问所有相互信任的应用系统。&lt;/p&gt;
&lt;h2 id=&quot;单点登录系统实现&quot;&gt;单点登录系统实现&lt;/h2&gt;
&lt;p&gt;Maven项目核心配置文件 pom.xml 需要在原来的基础上添加 httpclient和jedis jar包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;    &amp;lt;!-- http client version is 4.5.3 --&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;    &amp;lt;!-- redis java client version is 2.9.0  --&amp;gt;
        &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring4-java配置方式&quot;&gt;Spring4 Java配置方式&lt;/h2&gt;
&lt;p&gt;这里，我们需要整合httpclient用于各服务之间的通讯(也可以用okhttp)。同时还需要整合redis用于存储用户信息(Session共享)。&lt;br/&gt;在Spring3.x之前，一般在&lt;strong&gt;应用的基本配置&lt;/strong&gt;用xml，比如数据源、资源文件等。&lt;strong&gt;业务开发&lt;/strong&gt;用注解，比如Component，Service，Controller等。其实在Spring3.x的时候就已经提供了Java配置方式。现在的Spring4.x和SpringBoot都开始推荐使用Java配置方式配置bean。它可以使bean的结构更加的清晰。&lt;/p&gt;
&lt;h3 id=&quot;整合-httpclient&quot;&gt;整合 HttpClient&lt;/h3&gt;
&lt;p&gt;HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。&lt;br/&gt;HttpClient4.5系列教程 : &lt;a href=&quot;http://blog.csdn.net/column/details/httpclient.html&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/column/details/httpclient.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先在src/main/resources 目录下创建 httpclient.properties 配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#设置整个连接池默认最大连接数
http.defaultMaxPerRoute=100
#设置整个连接池最大连接数
http.maxTotal=300
#设置请求超时
http.connectTimeout=1000
#设置从连接池中获取到连接的最长时间
http.connectionRequestTimeout=500
#设置数据传输的最长时间
http.socketTimeout=10000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 src/main/java/com/itdragon/config 目录下创建 HttpclientSpringConfig.java 文件&lt;br/&gt;这里用到了四个很重要的注解&lt;br/&gt;@Configuration : 作用于类上，指明该类就相当于一个xml配置文件&lt;br/&gt;@Bean : 作用于方法上，指明该方法相当于xml配置中的，注意方法名的命名规范&lt;br/&gt;@PropertySource : 指定读取的配置文件，引入多个value={&quot;xxx:xxx&quot;,&quot;xxx:xxx&quot;},ignoreResourceNotFound=true 文件不存在是忽略&lt;br/&gt;@Value : 获取配置文件的值，该注解还有很多语法知识，这里暂时不扩展开&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.config;

import java.util.concurrent.TimeUnit;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.client.IdleConnectionEvictor;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.context.annotation.Scope;

/**
 * @Configuration   作用于类上，相当于一个xml配置文件
 * @Bean            作用于方法上，相当于xml配置中的&amp;lt;bean&amp;gt;
 * @PropertySource  指定读取的配置文件
 * @Value           获取配置文件的值
 */
@Configuration
@PropertySource(value = &quot;classpath:httpclient.properties&quot;)
public class HttpclientSpringConfig {

    @Value(&quot;${http.maxTotal}&quot;)
    private Integer httpMaxTotal;

    @Value(&quot;${http.defaultMaxPerRoute}&quot;)
    private Integer httpDefaultMaxPerRoute;

    @Value(&quot;${http.connectTimeout}&quot;)
    private Integer httpConnectTimeout;

    @Value(&quot;${http.connectionRequestTimeout}&quot;)
    private Integer httpConnectionRequestTimeout;

    @Value(&quot;${http.socketTimeout}&quot;)
    private Integer httpSocketTimeout;

    @Autowired
    private PoolingHttpClientConnectionManager manager;

    @Bean
    public PoolingHttpClientConnectionManager poolingHttpClientConnectionManager() {
        PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager();
        // 最大连接数
        poolingHttpClientConnectionManager.setMaxTotal(httpMaxTotal);
        // 每个主机的最大并发数
        poolingHttpClientConnectionManager.setDefaultMaxPerRoute(httpDefaultMaxPerRoute);
        return poolingHttpClientConnectionManager;
    }

    @Bean   // 定期清理无效连接
    public IdleConnectionEvictor idleConnectionEvictor() {
        return new IdleConnectionEvictor(manager, 1L, TimeUnit.HOURS);
    }

    @Bean   // 定义HttpClient对象 注意该对象需要设置scope=&quot;prototype&quot;:多例对象
    @Scope(&quot;prototype&quot;)
    public CloseableHttpClient closeableHttpClient() {
        return HttpClients.custom().setConnectionManager(this.manager).build();
    }

    @Bean   // 请求配置
    public RequestConfig requestConfig() {
        return RequestConfig.custom().setConnectTimeout(httpConnectTimeout) // 创建连接的最长时间
                .setConnectionRequestTimeout(httpConnectionRequestTimeout) // 从连接池中获取到连接的最长时间
                .setSocketTimeout(httpSocketTimeout) // 数据传输的最长时间
                .build();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;整合-redis&quot;&gt;整合 Redis&lt;/h3&gt;
&lt;p&gt;SpringBoot官方其实提供了spring-boot-starter-redis pom 帮助我们快速开发，但我们也可以自定义配置，这样可以更方便地掌控。&lt;br/&gt;Redis 系列教程 : &lt;a href=&quot;http://www.cnblogs.com/itdragon/category/1122427.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/itdragon/category/1122427.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先在src/main/resources 目录下创建 redis.properties 配置文件&lt;br/&gt;设置Redis主机的ip地址和端口号，和存入Redis数据库中的key以及存活时间。这里为了方便测试，存活时间设置的比较小。这里的配置是单例Redis。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;redis.node.host=192.168.225.131
redis.node.port=6379

REDIS_USER_SESSION_KEY=REDIS_USER_SESSION
SSO_SESSION_EXPIRE=30&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在src/main/java/com/itdragon/config 目录下创建 RedisSpringConfig.java 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.config;

import java.util.ArrayList;
import java.util.List;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;
import redis.clients.jedis.JedisShardInfo;
import redis.clients.jedis.ShardedJedisPool;

@Configuration
@PropertySource(value = &quot;classpath:redis.properties&quot;)
public class RedisSpringConfig {

    @Value(&quot;${redis.maxTotal}&quot;)
    private Integer redisMaxTotal;

    @Value(&quot;${redis.node.host}&quot;)
    private String redisNodeHost;

    @Value(&quot;${redis.node.port}&quot;)
    private Integer redisNodePort;

    private JedisPoolConfig jedisPoolConfig() {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(redisMaxTotal);
        return jedisPoolConfig;
    }
    
    @Bean 
    public JedisPool getJedisPool(){    // 省略第一个参数则是采用 Protocol.DEFAULT_DATABASE
        JedisPool jedisPool = new JedisPool(jedisPoolConfig(), redisNodeHost, redisNodePort);
        return jedisPool;
    }

    @Bean
    public ShardedJedisPool shardedJedisPool() {
        List&amp;lt;JedisShardInfo&amp;gt; jedisShardInfos = new ArrayList&amp;lt;JedisShardInfo&amp;gt;();
        jedisShardInfos.add(new JedisShardInfo(redisNodeHost, redisNodePort));
        return new ShardedJedisPool(jedisPoolConfig(), jedisShardInfos);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;service-层&quot;&gt;Service 层&lt;/h3&gt;
&lt;p&gt;在src/main/java/com/itdragon/service 目录下创建 UserService.java 文件，它负责三件事情&lt;br/&gt;第一件事件：验证用户信息是否正确，并将登录成功的用户信息保存到Redis数据库中。&lt;br/&gt;第二件事件：负责判断用户令牌是否过期，若没有则刷新令牌存活时间。&lt;br/&gt;第三件事件：负责从Redis数据库中删除用户信息。&lt;br/&gt;这里用到了一些工具类，不影响学习，可以从源码中直接获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.service;

import java.util.UUID;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import com.itdragon.pojo.ItdragonResult;
import com.itdragon.pojo.User;
import com.itdragon.repository.JedisClient;
import com.itdragon.repository.UserRepository;
import com.itdragon.utils.CookieUtils;
import com.itdragon.utils.ItdragonUtils;
import com.itdragon.utils.JsonUtils;

@Service
@Transactional
@PropertySource(value = &quot;classpath:redis.properties&quot;)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private JedisClient jedisClient;
    
    @Value(&quot;${REDIS_USER_SESSION_KEY}&quot;)
    private String REDIS_USER_SESSION_KEY;
    
    @Value(&quot;${SSO_SESSION_EXPIRE}&quot;)
    private Integer SSO_SESSION_EXPIRE;
    
    public ItdragonResult userLogin(String account, String password,
            HttpServletRequest request, HttpServletResponse response) {
        // 判断账号密码是否正确
        User user = userRepository.findByAccount(account);
        if (!ItdragonUtils.decryptPassword(user, password)) {
            return ItdragonResult.build(400, &quot;账号名或密码错误&quot;);
        }
        // 生成token
        String token = UUID.randomUUID().toString();
        // 清空密码和盐避免泄漏
        String userPassword = user.getPassword();
        String userSalt = user.getSalt();
        user.setPassword(null);
        user.setSalt(null);
        // 把用户信息写入 redis
        jedisClient.set(REDIS_USER_SESSION_KEY + &quot;:&quot; + token, JsonUtils.objectToJson(user));
        // user 已经是持久化对象，被保存在session缓存当中，若user又重新修改属性值，那么在提交事务时，此时 hibernate对象就会拿当前这个user对象和保存在session缓存中的user对象进行比较，如果两个对象相同，则不会发送update语句，否则会发出update语句。
        user.setPassword(userPassword);
        user.setSalt(userSalt);
        // 设置 session 的过期时间
        jedisClient.expire(REDIS_USER_SESSION_KEY + &quot;:&quot; + token, SSO_SESSION_EXPIRE);
        // 添加写 cookie 的逻辑，cookie 的有效期是关闭浏览器就失效。
        CookieUtils.setCookie(request, response, &quot;USER_TOKEN&quot;, token);
        // 返回token
        return ItdragonResult.ok(token);
    }
    
    public void logout(String token) {
        jedisClient.del(REDIS_USER_SESSION_KEY + &quot;:&quot; + token);
    }

    public ItdragonResult queryUserByToken(String token) {
        // 根据token从redis中查询用户信息
        String json = jedisClient.get(REDIS_USER_SESSION_KEY + &quot;:&quot; + token);
        // 判断是否为空
        if (StringUtils.isEmpty(json)) {
            return ItdragonResult.build(400, &quot;此session已经过期，请重新登录&quot;);
        }
        // 更新过期时间
        jedisClient.expire(REDIS_USER_SESSION_KEY + &quot;:&quot; + token, SSO_SESSION_EXPIRE);
        // 返回用户信息
        return ItdragonResult.ok(JsonUtils.jsonToPojo(json, User.class));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;controller-层&quot;&gt;Controller 层&lt;/h2&gt;
&lt;p&gt;负责跳转登录页面跳转&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class PageController {

    @RequestMapping(&quot;/login&quot;)
    public String showLogin(String redirect, Model model) {
        model.addAttribute(&quot;redirect&quot;, redirect);
        return &quot;login&quot;;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;负责用户的登录，退出，获取令牌的操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import com.itdragon.pojo.ItdragonResult;
import com.itdragon.service.UserService;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @RequestMapping(value=&quot;/login&quot;, method=RequestMethod.POST)
    @ResponseBody
    public ItdragonResult userLogin(String username, String password,
            HttpServletRequest request, HttpServletResponse response) {
        try {
            ItdragonResult result = userService.userLogin(username, password, request, response);
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return ItdragonResult.build(500, &quot;&quot;);
        }
    }
    
    @RequestMapping(value=&quot;/logout/{token}&quot;)
    public String logout(@PathVariable String token) {
        userService.logout(token); // 思路是从Redis中删除key，实际情况请和业务逻辑结合
        return &quot;index&quot;;
    }
    
    @RequestMapping(&quot;/token/{token}&quot;)
    @ResponseBody
    public Object getUserByToken(@PathVariable String token) {
        ItdragonResult result = null;
        try {
            result = userService.queryUserByToken(token);
        } catch (Exception e) {
            e.printStackTrace();
            result = ItdragonResult.build(500, &quot;&quot;);
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;视图层&quot;&gt;视图层&lt;/h2&gt;
&lt;p&gt;一个简单的登录页面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&amp;gt;
&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, width=device-width, user-scalable=no&quot; /&amp;gt;
        &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&amp;gt;
        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,Chrome=1&quot; /&amp;gt;
        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot; /&amp;gt;
        &amp;lt;title&amp;gt;欢迎登录&amp;lt;/title&amp;gt;
        &amp;lt;link type=&quot;image/x-icon&quot; href=&quot;images/favicon.ico&quot; rel=&quot;shortcut icon&quot;&amp;gt;
        &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;static/css/main.css&quot; /&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;wrapper&quot;&amp;gt;
            &amp;lt;div class=&quot;container&quot;&amp;gt;
                &amp;lt;h1&amp;gt;Welcome&amp;lt;/h1&amp;gt;
                &amp;lt;form method=&quot;post&quot; onsubmit=&quot;return false;&quot; class=&quot;form&quot;&amp;gt;
                    &amp;lt;input type=&quot;text&quot; value=&quot;itdragon&quot; name=&quot;username&quot; placeholder=&quot;Account&quot;/&amp;gt;
                    &amp;lt;input type=&quot;password&quot; value=&quot;123456789&quot; name=&quot;password&quot; placeholder=&quot;Password&quot;/&amp;gt;
                    &amp;lt;button type=&quot;button&quot; id=&quot;login-button&quot;&amp;gt;Login&amp;lt;/button&amp;gt;
                &amp;lt;/form&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;ul class=&quot;bg-bubbles&quot;&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot; src=&quot;static/js/jquery-1.10.1.min.js&quot; &amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            var redirectUrl = &quot;${redirect}&quot;; // 浏览器中返回的URL
            function doLogin() {
                $.post(&quot;/user/login&quot;, $(&quot;.form&quot;).serialize(),function(data){
                    if (data.status == 200) {
                        if (redirectUrl == &quot;&quot;) {
                            location.href = &quot;http://localhost:8082&quot;;
                        } else {
                            location.href = redirectUrl;
                        }
                    } else {
                        alert(&quot;登录失败，原因是：&quot; + data.msg);
                    }
                });
            }
            $(function(){
                $(&quot;#login-button&quot;).click(function(){
                    doLogin();
                });
            });
        &amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;httpclient-基础语法&quot;&gt;HttpClient 基础语法&lt;/h2&gt;
&lt;p&gt;这里封装了get，post请求的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.utils;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.apache.http.NameValuePair;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

public class HttpClientUtil {
    
    public static String doGet(String url) {                            // 无参数get请求
        return doGet(url, null);
    }

    public static String doGet(String url, Map&amp;lt;String, String&amp;gt; param) { // 带参数get请求
        CloseableHttpClient httpClient = HttpClients.createDefault();   // 创建一个默认可关闭的Httpclient 对象
        String resultMsg = &quot;&quot;;                                          // 设置返回值
        CloseableHttpResponse response = null;                          // 定义HttpResponse 对象
        try {
            URIBuilder builder = new URIBuilder(url);                   // 创建URI,可以设置host，设置参数等
            if (param != null) {
                for (String key : param.keySet()) {
                    builder.addParameter(key, param.get(key));
                }
            }
            URI uri = builder.build();
            HttpGet httpGet = new HttpGet(uri);                         // 创建http GET请求
            response = httpClient.execute(httpGet);                     // 执行请求
            if (response.getStatusLine().getStatusCode() == 200) {      // 判断返回状态为200则给返回值赋值
                resultMsg = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {                                                     // 不要忘记关闭
            try {
                if (response != null) {
                    response.close();
                }
                httpClient.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return resultMsg;
    }
    
    public static String doPost(String url) {                           // 无参数post请求
        return doPost(url, null);
    }

    public static String doPost(String url, Map&amp;lt;String, String&amp;gt; param) {// 带参数post请求
        CloseableHttpClient httpClient = HttpClients.createDefault();   // 创建一个默认可关闭的Httpclient 对象
        CloseableHttpResponse response = null;
        String resultMsg = &quot;&quot;;
        try {
            HttpPost httpPost = new HttpPost(url);                      // 创建Http Post请求
            if (param != null) {                                        // 创建参数列表
                List&amp;lt;NameValuePair&amp;gt; paramList = new ArrayList&amp;lt;NameValuePair&amp;gt;();
                for (String key : param.keySet()) {
                    paramList.add(new BasicNameValuePair(key, param.get(key)));
                }
                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList);// 模拟表单
                httpPost.setEntity(entity);
            }
            response = httpClient.execute(httpPost);                    // 执行http请求
            if (response.getStatusLine().getStatusCode() == 200) {
                resultMsg = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (response != null) {
                    response.close();
                }
                httpClient.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return resultMsg;
    }

    public static String doPostJson(String url, String json) {
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;
        try {
            HttpPost httpPost = new HttpPost(url);
            StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON);
            httpPost.setEntity(entity);
            response = httpClient.execute(httpPost);
            if (response.getStatusLine().getStatusCode() == 200) {
                resultString = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (response != null) {
                    response.close();
                }
                httpClient.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return resultString;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-自定义拦截器&quot;&gt;Spring 自定义拦截器&lt;/h2&gt;
&lt;p&gt;这里是另外一个项目 itdragon-service-test-sso 中的代码，&lt;br/&gt;首先在src/main/resources/spring/springmvc.xml 中配置拦截器，设置那些请求需要拦截&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;!-- 拦截器配置 --&amp;gt;
    &amp;lt;mvc:interceptors&amp;gt;
        &amp;lt;mvc:interceptor&amp;gt;
            &amp;lt;mvc:mapping path=&quot;/github/**&quot;/&amp;gt;
            &amp;lt;bean class=&quot;com.itdragon.interceptors.UserLoginHandlerInterceptor&quot;/&amp;gt;
        &amp;lt;/mvc:interceptor&amp;gt;
    &amp;lt;/mvc:interceptors&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 src/main/java/com/itdragon/interceptors 目录下创建 UserLoginHandlerInterceptor.java 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.itdragon.interceptors;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.StringUtils;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
import com.itdragon.pojo.User;
import com.itdragon.service.UserService;
import com.itdragon.utils.CookieUtils;

public class UserLoginHandlerInterceptor implements HandlerInterceptor {

    public static final String COOKIE_NAME = &quot;USER_TOKEN&quot;;

    @Autowired
    private UserService userService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        String token = CookieUtils.getCookieValue(request, COOKIE_NAME);
        User user = this.userService.getUserByToken(token);
        if (StringUtils.isEmpty(token) || null == user) {
            // 跳转到登录页面，把用户请求的url作为参数传递给登录页面。
            response.sendRedirect(&quot;http://localhost:8081/login?redirect=&quot; + request.getRequestURL());
            // 返回false
            return false;
        }
        // 把用户信息放入Request
        request.setAttribute(&quot;user&quot;, user);
        // 返回值决定handler是否执行。true：执行，false：不执行。
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
            ModelAndView modelAndView) throws Exception {
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
            Exception ex) throws Exception {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;可能存在的问题&quot;&gt;可能存在的问题&lt;/h2&gt;
&lt;h4 id=&quot;springdata-自动更新问题&quot;&gt;SpringData 自动更新问题&lt;/h4&gt;
&lt;p&gt;SpringData 是基于Hibernate的。当User 已经是持久化对象，被保存在session缓存当中。若User又重新修改属性值，在提交事务时，此时hibernate对象就会拿当前这个User对象和保存在session缓存中的User对象进行比较，如果两个对象相同，则不会发送update语句，否则，会发出update语句。&lt;br/&gt;笔者采用比较傻的方法，就是在提交事务之前把数据还原。各位如果有更好的办法请告知，谢谢！&lt;br/&gt;参考博客：&lt;a href=&quot;http://www.cnblogs.com/xiaoluo501395377/p/3380270.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xiaoluo501395377/p/3380270.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;检查用户信息是否保存&quot;&gt;检查用户信息是否保存&lt;/h4&gt;
&lt;p&gt;登录成功后，进入Redis客户端查看用户信息是否保存成功。同时为了方便测试，也可以删除这个key。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost bin]# ./redis-cli -h 192.168.225.131 -p 6379
192.168.225.131:6379&amp;gt; 
192.168.225.131:6379&amp;gt; keys *
1) &quot;REDIS_USER_SESSION:1d869ac0-3d22-4e22-bca0-37c8dfade9ad&quot;
192.168.225.131:6379&amp;gt; get REDIS_USER_SESSION:1d869ac0-3d22-4e22-bca0-37c8dfade9ad
&quot;{\&quot;id\&quot;:3,\&quot;account\&quot;:\&quot;itdragon\&quot;,\&quot;userName\&quot;:\&quot;ITDragonGit\&quot;,\&quot;plainPassword\&quot;:null,\&quot;password\&quot;:null,\&quot;salt\&quot;:null,\&quot;iphone\&quot;:\&quot;12349857999\&quot;,\&quot;email\&quot;:\&quot;itdragon@git.com\&quot;,\&quot;platform\&quot;:\&quot;github\&quot;,\&quot;createdDate\&quot;:\&quot;2017-12-22 21:11:19\&quot;,\&quot;updatedDate\&quot;:\&quot;2017-12-22 21:11:19\&quot;}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;1 单点登录系统通过将用户信息放在Redis数据库中实现共享Session效果。&lt;br/&gt;2 Java 配置方式使用四个注解 @Configuration @Bean @PropertySource @Value 。&lt;br/&gt;3 Spring 拦截器的设置。&lt;br/&gt;4 HttpClient 的使用&lt;br/&gt;5 祝大家圣诞节快乐&lt;/p&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/tree/master/SpringBoot/SSO&quot; class=&quot;uri&quot;&gt;https://github.com/ITDragonBlog/daydayup/tree/master/SpringBoot/SSO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里，基于SpringBoot的单点登录系统就结束了，有什么不对的地方请指出。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 14:51:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/8094722.html</dc:identifier>
</item>
<item>
<title>Spring之AOP一 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/8093965.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/8093965.html</guid>
<description>&lt;p&gt;面向切片式编程不仅在Java中存在，在其他语言也是存在，例如asp.net的管道模型中，可以利用aop来进行自定义一些操作，比如权限认证、日志等。今天主要是引入AOP，具体它涉及到的专有名词先不做解释。&lt;/p&gt;
&lt;p&gt;一、横切纵切&lt;/p&gt;
&lt;p&gt;首先要知道什么是横切什么是纵切(吐槽大会的观众们这也是知识点)，下面的两张图是从网上找的，是讨论刨妇产是横切好还是纵切好的问题，知道什么是横切什么是纵切之后，我们也可以用莲藕来做比喻，横切切出来是圆的，纵切就不是了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201712/733213-20171223164732725-1684546396.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;242&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201712/733213-20171223164754256-809294908.png&quot; alt=&quot;&quot; width=&quot;471&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、AOP&lt;/p&gt;
&lt;p&gt;对于一些系统特别时生产环境的问题有些是在UAT或者ST环境是发现不了的，但又不可能用真时的正式环境来进行测试，我们做项目一般都会增加日志输出，这样未来可以通过日志来定位发现问题，那就需要在每个方法中增加日志信息，并需要进行捕获异常，如果按照一般的做法那就需要在每个方法中增加日志信息，并在方法中增加try catch来进行捕获日常，这样就会很麻烦，哪天我又不想增加日志信息、捕获异常了那还需要修改代码，而且影响的范围也是特别的大，这样就体现不了低耦合的特点。那该如何是好呢？于是乎AOP来了。&lt;span&gt;AOP技术利用一种称为“横切”的技术，解剖封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，这样就能减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。&lt;/span&gt;红字部分基本把AOP的作用解释清楚了，它会将多个类的公共行为封装到一个可重用模块，然后将这个模糊注入里面，这里有个切的过程，不是内部操作，内部操作那还是复用了，是外部来进行操作。&lt;/p&gt;
&lt;p&gt;三、代码中实现AOP&lt;/p&gt;
&lt;p&gt; 还是在上面博客代码的基础上，新建了一个ServiceImplA类，它实现了IService接口，我想实现这样一个功能，就是想在调用service方法前后增加日志打印或为service方法增加try catch,那该怎么做呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_d1d1c2ca-89d3-4f36-9972-9c14603f2660&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d1d1c2ca-89d3-4f36-9972-9c14603f2660&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d1d1c2ca-89d3-4f36-9972-9c14603f2660&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.IService;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IService {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; service(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_e96ecf38-e72b-42cc-b664-3a9625de4e81&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e96ecf38-e72b-42cc-b664-3a9625de4e81&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e96ecf38-e72b-42cc-b664-3a9625de4e81&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.IService.IService;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServiceImplA &lt;span&gt;implements&lt;/span&gt;&lt;span&gt;  IService{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; service(String name) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;ServiceImplA name&quot;+&lt;span&gt;name);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;1.在每处调用的地方增加日志和try catch&lt;/p&gt;
&lt;p&gt;这种也是一种方法，但缺点是很明显的，就是每处都要更改，量也会很大，显然不可取。这里是每个点都要加，一个方法可能被调用多处，那就要写多次。&lt;/p&gt;
&lt;p&gt;2.代理模式&lt;/p&gt;
&lt;p&gt;代理模式又分为动态代理模式和静态代理模式。&lt;/p&gt;
&lt;p&gt;(1)静态代理&lt;/p&gt;
&lt;p&gt;&lt;span&gt;静态代理关键是在代理对象和目标对象实现共同的接口，并且代理对象持有目标对象的引用。&lt;/span&gt;这里我创建了类ProxyServiceA，它实现IService接口，同时将实现IService接口的对象作为一个属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_56d7a4eb-38ed-4b65-bdc9-e769fff0ca98&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_56d7a4eb-38ed-4b65-bdc9-e769fff0ca98&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_56d7a4eb-38ed-4b65-bdc9-e769fff0ca98&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.IService.IService;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxyServiceA &lt;span&gt;implements&lt;/span&gt;&lt;span&gt;  IService{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ProxyServiceA(IService service) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.service =&lt;span&gt; service;
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IService service;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; service(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;log start&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            service.service(name);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e)
        {
             &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        }
        System.out.println(&lt;/span&gt;&quot;log end&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面的代码确实能为实现IService接口的对象增加调用前后的方法，并且增加了try catch。但是问题又来了。项目中接口可不止一个，可能会有很多，而且每个接口中的方法也会有好多，如果这样一个一个的增加不也是个问题。to be or not to be,that is a question.虽然比第一种方式，这种只需在每个方法中设置一次。&lt;/p&gt;
&lt;p&gt;(2)动态代理&lt;/p&gt;
&lt;p&gt;静态代理虽然也能解决上面增加日志和try catch来捕获异常，但是还是很麻烦，每个方法都要设置，于是动态代理来解决这个问题了。&lt;span&gt;动态代理实现主要是实现InvocationHandler，并且将目标对象注入到代理对象中，利用反射机制来执行目标对象的方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_9c8b0ae2-2934-4b6d-9e03-db68d8a032db&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9c8b0ae2-2934-4b6d-9e03-db68d8a032db&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9c8b0ae2-2934-4b6d-9e03-db68d8a032db&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DynaProxyServiceA &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Object target;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标对象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object bind(Object object){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; object;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(&lt;span&gt;this&lt;/span&gt;.target.getClass().getClassLoader(), &lt;span&gt;this&lt;/span&gt;.target.getClass().getInterfaces(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        Object result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        System.out.println(&lt;/span&gt;&quot;log start&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
             result &lt;/span&gt;= method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.target, args);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e)
        {
             &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        }
        System.out.println(&lt;/span&gt;&quot;log end&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_291e61da-4bcf-4228-9d49-11616777be0f&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_291e61da-4bcf-4228-9d49-11616777be0f&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_291e61da-4bcf-4228-9d49-11616777be0f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
           IService service = (IService) &lt;span&gt;new&lt;/span&gt; DynaProxyServiceA().bind(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceImplA());
           service.service(&lt;/span&gt;&quot;cuiyw&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201712/733213-20171223204308256-1637185633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; (3)2的升华&lt;/p&gt;
&lt;p&gt;上面通过动态代理可以实现在方法前后打印日志以及捕获异常，但是打印日志也可能有几种日志啊，现在是之间输出到操作台，那可能会是输入到文件或数据库，那肿么办呢？这里打印日志的操作我们也可以进一步的抽象，还是先创建一个接口ILog,然后创建一个类ConsoleLog实现ILog这个接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_05a01001-9d41-40bb-81e7-537006a37119&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_05a01001-9d41-40bb-81e7-537006a37119&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_05a01001-9d41-40bb-81e7-537006a37119&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ILog {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start(Method method) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; end(Method method) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_29943b89-63ba-4c82-b1e2-b5f89c7f36c8&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_29943b89-63ba-4c82-b1e2-b5f89c7f36c8&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_29943b89-63ba-4c82-b1e2-b5f89c7f36c8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConsoleLog &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ILog{


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start(Method method) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&lt;span&gt;new&lt;/span&gt; Date()+&quot; method name:&quot;+method.getName() + &quot; start...&quot;&lt;span&gt;);

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; end(Method method) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&lt;span&gt;new&lt;/span&gt; Date()+&quot; method name:&quot;+ method.getName() + &quot; end...&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;然后将打印对象也在动态代理中抽象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_1638332e-09dd-49c6-aec1-503f839e9c51&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1638332e-09dd-49c6-aec1-503f839e9c51&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1638332e-09dd-49c6-aec1-503f839e9c51&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DynaProxyServiceA &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object proxy;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object bind(Object object,Object proxy){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; object;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.proxy=&lt;span&gt;proxy;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(&lt;span&gt;this&lt;/span&gt;.target.getClass().getClassLoader(), &lt;span&gt;this&lt;/span&gt;.target.getClass().getInterfaces(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        Object result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射得到操作者的实例&lt;/span&gt;
        Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Object&amp;gt; clazz = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.proxy.getClass();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射得到操作者的Start方法&lt;/span&gt;
        Method start =clazz.getDeclaredMethod(&quot;start&quot;,&lt;span&gt;new&lt;/span&gt; Class[]{Method.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射执行start方法&lt;/span&gt;
        start.invoke(&lt;span&gt;this&lt;/span&gt;.proxy, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{method});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行要处理对象的原本方法&lt;/span&gt;
        result=method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.target, args);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射得到操作者的end方法&lt;/span&gt;
        Method end = clazz.getDeclaredMethod(&quot;end&quot;, &lt;span&gt;new&lt;/span&gt; Class[]{Method.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射执行end方法&lt;/span&gt;
        end.invoke(&lt;span&gt;this&lt;/span&gt;.proxy, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{method});
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_61f07e72-7106-4824-b9d3-e25bd2c0d85f&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_61f07e72-7106-4824-b9d3-e25bd2c0d85f&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_61f07e72-7106-4824-b9d3-e25bd2c0d85f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
           IService service = (IService) &lt;span&gt;new&lt;/span&gt; DynaProxyServiceA().bind(&lt;span&gt;new&lt;/span&gt; ServiceImplA(),&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConsoleLog());
           service.service(&lt;/span&gt;&quot;cuiyw&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201712/733213-20171223213041725-1531272419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是把start、end都在动态代理中执行了，其实我们可以判断哪个方法有被实现，然后再进行执行。&lt;/p&gt;
&lt;p&gt;四、总结感悟&lt;/p&gt;
&lt;p&gt;上面标题是代码中实现AOP,虽并未提到AOP但是，如果把上面的能理解明白了，那AOP就很好理解了，也不用理解什么切点、连接点等这些名字就能用。&lt;/p&gt;
&lt;p&gt;最后聊几句大家可能都会遇到的问题，上周项目组开会说项目组有重组的可能，哎，感觉公司还真是够冷漠无情的，有利用价值就利用，没利用价值就被干掉，不管年龄大小，自身本来就没安全感，遇到这事还真是觉得对未来更加恐惧，害怕以后也会遇到这样的情况，这也让我更加下定决心要尽快把java学好。留给中国队的时间不多了。&lt;/p&gt;

</description>
<pubDate>Sat, 23 Dec 2017 13:46:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/8093965.html</dc:identifier>
</item>
<item>
<title>开发一个博客园系统 - JeffD</title>
<link>http://www.cnblogs.com/Jeffding/p/8035312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jeffding/p/8035312.html</guid>
<description>&lt;p&gt;　　最近在学django框架，准备用django写一个博客园的系统，并且在写的过程中也遇到一些问题，实践出真知，对django开发web应用方面也有了进一步的了解。很多操作实现都是以我所认知的技术完成的，可能存在不合理的地方（毕竟实现的方法多种多样），基本完成后会将源码上传到git，也欢迎各位大神指正。&lt;/p&gt;
&lt;p&gt;　　首先，要写未登录主站（index）。这里需要注意文章的分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1165242/201712/1165242-20171213200537816-1713022453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　文章的分类切换，网站本身有定义的文章类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
   type_choices =&lt;span&gt; [
        (&lt;/span&gt;1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;3, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OpenStack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;4, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GoLang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
    ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要实现主页的分类（分类标签样式要突出）需要使用一个前端与后端都有的id来显示分类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_a4471314-fe4b-473f-b7b6-dcf7b5b22c80&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a4471314-fe4b-473f-b7b6-dcf7b5b22c80&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a4471314-fe4b-473f-b7b6-dcf7b5b22c80&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;if&lt;/span&gt; request.method==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        type_id &lt;/span&gt;= int(kwargs.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;if&lt;/span&gt; kwargs.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;else&lt;/span&gt;&lt;span&gt; None
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;后台都是get传参&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; type_id:
            article_list &lt;/span&gt;= models.Article.objects.filter(article_type_id=type_id).extra(select={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strftime('%%Y-%%m',create_time)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            article_list &lt;/span&gt;= models.Article.objects.all().extra(select={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strftime('%%Y-%%m',create_time)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})
        type_choice_list &lt;/span&gt;= models.Article.type_choices&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分类的&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(type_choice_list)#[(1, 'Python'), (2, 'Linux'), (3, 'OpenStack'), (4, 'GoLang')]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;后台代码&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7a2c0f24-3871-4084-88a2-b1ad47ed4a04&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7a2c0f24-3871-4084-88a2-b1ad47ed4a04&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7a2c0f24-3871-4084-88a2-b1ad47ed4a04&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
{% &lt;span&gt;if&lt;/span&gt; type_id %&lt;span&gt;}
                        &lt;/span&gt;&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;全部&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
                    {&lt;/span&gt;% &lt;span&gt;else&lt;/span&gt; %&lt;span&gt;}
                        &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;active&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;全部&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
                    {&lt;/span&gt;% endif %&lt;span&gt;}

                    {&lt;/span&gt;% &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; type_choice_list %&lt;span&gt;}
                        {&lt;/span&gt;% &lt;span&gt;if&lt;/span&gt; item.0 == type_id %&lt;span&gt;}
                            &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;active&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/all/{{ item.0 }}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{ item.1 }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
                        {&lt;/span&gt;% &lt;span&gt;else&lt;/span&gt; %&lt;span&gt;}
                            &lt;/span&gt;&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/all/{{ item.0 }}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{ item.1 }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;
                        {&lt;/span&gt;% endif %&lt;span&gt;}
                    {&lt;/span&gt;% endfor %}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;前端代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　登陆与注册页面&lt;/p&gt;
&lt;p&gt;　　登陆与注册的验证使用form表单功能完成，除此之外我们还需要有一个图片验证码用于认证。&lt;/p&gt;
&lt;p&gt; 　　在前端设置一个图片，图片src属性指向后端（获取图片时向后端发生get请求方式，后端返回的），验证码图片由后端生成图片在上面显示，点击更换我们使用每次点击在src属性后面加一个？，这样url改变了前端向后台发送一个get请求，那么就会获得一个新的验证码图片了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_51bf197a-7f0a-4c85-a461-578e714ae78e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_51bf197a-7f0a-4c85-a461-578e714ae78e&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_51bf197a-7f0a-4c85-a461-578e714ae78e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
 &amp;lt;img style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 120px;height: 30px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/check_code/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;点击更换&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;change_img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;

        $(function(){
            change_img();
        });
        function change_img() {&lt;/span&gt;//&lt;span&gt;get方式在url上加？刷新图片
            $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#change_img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click(function () {
                $(this)[0].src&lt;/span&gt;=$(this)[0].src+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            })
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;前端代码&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57.5&quot;&gt;&lt;img id=&quot;code_img_closed_78749dc5-6a01-44db-b600-28ed567b36d5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_78749dc5-6a01-44db-b600-28ed567b36d5&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_78749dc5-6a01-44db-b600-28ed567b36d5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;110&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image,ImageDraw,ImageFont,ImageFilter
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; rd_check_code(width=120, height=30, char_length=4, font_file=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kumo.ttf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, font_size=28&lt;span&gt;):
    code &lt;/span&gt;=&lt;span&gt; []
    img &lt;/span&gt;= Image.new(mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RGB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, size=(width, height), color=(255, 255, 255&lt;span&gt;))
    draw &lt;/span&gt;= ImageDraw.Draw(img, mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RGB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; rndChar():
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        生成随机字母   
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; chr(random.randint(65, 90&lt;span&gt;))
 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; rndColor():
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        生成随机颜色
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (random.randint(0, 255), random.randint(10, 255), random.randint(64, 255&lt;span&gt;))
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写文字&lt;/span&gt;
    font =&lt;span&gt; ImageFont.truetype(font_file, font_size)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(char_length):
        char &lt;/span&gt;=&lt;span&gt; rndChar()
        code.append(char)
        h &lt;/span&gt;= random.randint(0, 4&lt;span&gt;)
        draw.text([i &lt;/span&gt;* width / char_length, h], char, font=font, fill=&lt;span&gt;rndColor())
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写干扰点&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(40&lt;span&gt;):
        draw.point([random.randint(0, width), random.randint(0, height)], fill&lt;/span&gt;=&lt;span&gt;rndColor())
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写干扰圆圈&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(40&lt;span&gt;):
        draw.point([random.randint(0, width), random.randint(0, height)], fill&lt;/span&gt;=&lt;span&gt;rndColor())
        x &lt;/span&gt;=&lt;span&gt; random.randint(0, width)
        y &lt;/span&gt;=&lt;span&gt; random.randint(0, height)
        draw.arc((x, y, x &lt;/span&gt;+ 4, y + 4), 0, 90, fill=&lt;span&gt;rndColor())
 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 画干扰线&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
        x1 &lt;/span&gt;=&lt;span&gt; random.randint(0, width)
        y1 &lt;/span&gt;=&lt;span&gt; random.randint(0, height)
        x2 &lt;/span&gt;=&lt;span&gt; random.randint(0, width)
        y2 &lt;/span&gt;=&lt;span&gt; random.randint(0, height)
 
        draw.line((x1, y1, x2, y2), fill&lt;/span&gt;=&lt;span&gt;rndColor())
 
    img &lt;/span&gt;=&lt;span&gt; img.filter(ImageFilter.EDGE_ENHANCE_MORE)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; img,&lt;span&gt;''&lt;/span&gt;.join(code)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;PIL生成随机码模块&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_bd369e67-11bd-4c5c-8e3b-d31a6c131d38&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bd369e67-11bd-4c5c-8e3b-d31a6c131d38&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bd369e67-11bd-4c5c-8e3b-d31a6c131d38&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; check_code(request):
    &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; io &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BytesIO
    &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; utils.random_check_code &lt;span&gt;import&lt;/span&gt;&lt;span&gt; rd_check_code
    img,code &lt;/span&gt;=&lt;span&gt; rd_check_code()
    stream &lt;/span&gt;= BytesIO()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;开辟一个内存空间，类似于文件句柄&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(stream)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;io空间，&amp;lt;_io.BytesIO object at 0x06D6EAE0&amp;gt;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(img)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;pillow生成的图片对象&lt;/span&gt;
    img.save(stream,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(stream)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(stream.getvalue())&lt;span&gt;#&lt;/span&gt;&lt;span&gt;bytes类型的图片信息，返回前端生成图片&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(img)
    request.session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = code&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将生成的随机字符串存到session用于验证&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; HttpResponse(stream.getvalue())
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;后端返回随机码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　登录后将session信息写入浏览器cookie，可以完成两周免登陆效果。注销我使用的时Ajax，后台需要清理session。这个过程中要注意，Ajax需要向后台发送自己的csrf码，否则后端默认是伪造的跨站请求，不给予服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_a9b207b4-f87b-442c-8cd1-f034abcdfe25&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a9b207b4-f87b-442c-8cd1-f034abcdfe25&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a9b207b4-f87b-442c-8cd1-f034abcdfe25&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; $(function () {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.take_off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(function () {
            {&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;                        $(&quot;.take_off&quot;).click(function () {#}&lt;/span&gt;
            {&lt;span&gt;#&lt;/span&gt;&lt;span&gt;            $.ajaxSetup({#}&lt;/span&gt;
            {&lt;span&gt;#&lt;/span&gt;&lt;span&gt;                data:{csrfmiddlewaretoken:'{{ csrf_token }}'}#}&lt;/span&gt;
            {&lt;span&gt;#&lt;/span&gt;&lt;span&gt;            });#}&lt;/span&gt;
&lt;span&gt;                $.ajax({
                url:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                type:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                {&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;data:{ 'csrftoken':{{ csrf_token}} },#}&lt;/span&gt;
                data:{csrfmiddlewaretoken:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{{ csrf_token }}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
                dataType:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JSON&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                success:function(arg){
                    console.log(arg);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arg.status){
                        location.href&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    }}
            })
            });
       });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Ajax注销&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　注册也有一个地方需要注意，就是图片上传的问题，我使用的是硬解码的方式存放图片：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_91ded08c-a072-4b3f-8544-175ce11a4344&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_91ded08c-a072-4b3f-8544-175ce11a4344&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_91ded08c-a072-4b3f-8544-175ce11a4344&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
            with open(os.path.join(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/static/imgs/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, obj.cleaned_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avatar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).name), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as file:
                all &lt;/span&gt;= obj.cleaned_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avatar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).chunks()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拿到整个文件&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; trunk &lt;span&gt;in&lt;/span&gt;&lt;span&gt; all:
                    file.write(trunk)
                file.close()
            obj.cleaned_data[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avatar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = os.path.join(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/static/imgs/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, obj.cleaned_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;avatar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).name)
            models.UserInfo.objects.create(&lt;/span&gt;**obj.cleaned_data)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;直接在后端进行存储&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　这种方法还是比较笨重的解决方法，在创建数据库的时候有一个upload_to字段可以直接指定文件存放路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_697181f5-39ab-4544-8a89-bfe13207f94a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_697181f5-39ab-4544-8a89-bfe13207f94a&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_697181f5-39ab-4544-8a89-bfe13207f94a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
avatar = models.ImageField(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;头像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,upload_to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;static/imgs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;创建数据表直接指定&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　不过这两种方法都不够灵活，不能防止图片名重复的问题，这里有一篇博客对存储路径进行优化的方式。这已经解决了很多一部分命名问题了。http://blog.csdn.net/alxandral_brother/article/details/53415551。&lt;/p&gt;
&lt;p&gt;　　用Ajax完成图片预览功能&lt;/p&gt;
&lt;p&gt;　　首先文件上传的丑陋的接口我们是没有办法修改的（点击上传那个），所以我们使用默认图片遮住这个文件框。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-sm-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;position: relative;height:80px;width: 80px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
     &amp;lt;img id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;position: absolute;height:80px;width: 80px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/imgs/default.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    {{ obj.avatar }}&lt;/span&gt;&amp;lt;span&amp;gt;{{ obj.errors.avatar.0 }}&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来是关于上传预览的部分，最早我们使用Ajax把前端获取的图片发给后端，后端接收后保存再发送回前端显示预览，但是这样做会导致用户上传了图片但是没有注册成功，那么后端保存的图片信息就是垃圾数据，那么我们必须要进行定期的数据清理工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_62da7676-a07b-4051-a122-0e0ecc291dc2&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_62da7676-a07b-4051-a122-0e0ecc291dc2&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_62da7676-a07b-4051-a122-0e0ecc291dc2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/bootstrap-3.3.5-dist/css/bootstrap.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;
        .login{
            width: 600px;
            margin: 0 auto;
            padding: 20px;
            margin&lt;/span&gt;-&lt;span&gt;top: 80px;
        }
        .f1{
            position: absolute;height:80px;width: 80px;top:0;left: 0;opacity: 0;
        }

    &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;position: relative;height:80px;width: 80px; left:260px;top: -10px &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;img id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height:80px;width: 80px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/image/default.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;input id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height: 80px;width: 80px; position: absolute; top:0;left: 0; opacity: 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
            {{ obj.avatar }}
        &lt;/span&gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/jquery-3.2.1.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;&lt;span&gt;
        $(function () {
            bindAvartar1();
        });

        function bindAvartar1() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                &lt;/span&gt;//$(this)[0]           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;jquery变成DOM对象&lt;/span&gt;
                //$(this)[0].files     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取上传当前文件的上传对象&lt;/span&gt;
                //$(this)[0].files[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取上传当前文件的上传对象的某个对象&lt;/span&gt;
                var obj =&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                &lt;/span&gt;//&lt;span&gt;ajax 发送后台获取头像路径
                &lt;/span&gt;//&lt;span&gt;img src 重新定义新的路径

                var formdata &lt;/span&gt;= new FormData();  //&lt;span&gt;创建一个对象
                formdata.append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,obj);
                var xhr &lt;/span&gt;=&lt;span&gt; new XMLHttpRequest();
                xhr.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/register/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                xhr.send(formdata);

                xhr.onreadystatechange &lt;/span&gt;=&lt;span&gt; function () {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xhr.readyState ==4&lt;span&gt;){
                        var file_path &lt;/span&gt;=&lt;span&gt; xhr.responseText;
                        console.log(file_path);
                        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; file_path)
                    }
                };

            })
        }
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Ajax上传预览&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_58daa93a-2070-43cc-81c0-fc3595ae21ae&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_58daa93a-2070-43cc-81c0-fc3595ae21ae&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_58daa93a-2070-43cc-81c0-fc3595ae21ae&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; register(request):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;register.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.POST)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request.FILES)
        file_obj &lt;/span&gt;= request.FILES.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(file_obj)
        file_path &lt;/span&gt;= os.path.join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, file_obj.name)
        with open(file_path, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; chunk &lt;span&gt;in&lt;/span&gt;&lt;span&gt; file_obj.chunks():
                f.write(chunk)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(file_path)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;后端保存图片&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　当然，我们还可以使用本地预览的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_eade0231-49cd-4c55-aa82-a8ebf697706a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eade0231-49cd-4c55-aa82-a8ebf697706a&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eade0231-49cd-4c55-aa82-a8ebf697706a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/bootstrap-3.3.5-dist/css/bootstrap.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;
        .login{
            width: 600px;
            margin: 0 auto;
            padding: 20px;
            margin&lt;/span&gt;-&lt;span&gt;top: 80px;
        }
        .f1{
            position: absolute;height:80px;width: 80px;top:0;left: 0;opacity: 0;
        }

    &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;position: relative;height:80px;width: 80px; left:260px;top: -10px &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;img id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height:80px;width: 80px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/image/default.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;input id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height: 80px;width: 80px; position: absolute; top:0;left: 0; opacity: 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
            {{ obj.avatar }}
        &lt;/span&gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/jquery-3.2.1.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;&lt;span&gt;
        $(function () {
            bindAvartar2();
        });

      

        function bindAvartar2() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                var obj &lt;/span&gt;=&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                &lt;/span&gt;//&lt;span&gt;将文件对象上传到浏览器
                &lt;/span&gt;//&lt;span&gt;IE10 以下不支持
                var v &lt;/span&gt;=&lt;span&gt; window.URL.createObjectURL(obj);
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,v);

                &lt;/span&gt;//&lt;span&gt;不会自动释放内存
                &lt;/span&gt;//&lt;span&gt;当加载完图片后,释放内存
                document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).onload=&lt;span&gt; function () {
                    window.URL.revokeObjectURL(v);
                };
            })
        }





        function bindAvartar3() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                var obj &lt;/span&gt;=&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                var reader &lt;/span&gt;=&lt;span&gt; new FileReader();
                reader.onload &lt;/span&gt;=&lt;span&gt; function (e) {
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,this.result);
                };
                reader.readAsDataURL(obj)
            })
        }

    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;本地上传预览的两种方式&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　因为用户的浏览器版本限制，我们可以采用多重手段给不同的用户使用预览功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_ab46aadb-4fe6-4e62-939d-4d9a2239badb&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ab46aadb-4fe6-4e62-939d-4d9a2239badb&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ab46aadb-4fe6-4e62-939d-4d9a2239badb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/bootstrap-3.3.5-dist/css/bootstrap.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;
        .login{
            width: 600px;
            margin: 0 auto;
            padding: 20px;
            margin&lt;/span&gt;-&lt;span&gt;top: 80px;
        }
        .f1{
            position: absolute;height:80px;width: 80px;top:0;left: 0;opacity: 0;
        }

    &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;position: relative;height:80px;width: 80px; left:260px;top: -10px &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;img id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height:80px;width: 80px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/image/default.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;input id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height: 80px;width: 80px; position: absolute; top:0;left: 0; opacity: 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/static/jquery-3.2.1.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;&lt;span&gt;
        $(function(){
           bindAvatar();
        });

        function bindAvatar(){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(window.URL.createObjectURL){
                bindAvatar2();
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(window.FileReader){
                bindAvatar3()
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                bindAvatar1();
            }
        }



        function bindAvatar1() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                &lt;/span&gt;//$(this)[0]           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;jquery变成DOM对象&lt;/span&gt;
                //$(this)[0].files     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取上传当前文件的上传对象&lt;/span&gt;
                //$(this)[0].files[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取上传当前文件的上传对象的某个对象&lt;/span&gt;
                var obj =&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                &lt;/span&gt;//&lt;span&gt;ajax 发送后台获取头像路径
                &lt;/span&gt;//&lt;span&gt;img src 重新定义新的路径

                var formdata &lt;/span&gt;= new FormData();  //&lt;span&gt;创建一个对象
                formdata.append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,obj);
                var xhr &lt;/span&gt;=&lt;span&gt; new XMLHttpRequest();
                xhr.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/register/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                xhr.send(formdata);

                xhr.onreadystatechange &lt;/span&gt;=&lt;span&gt; function () {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xhr.readyState ==4&lt;span&gt;){
                        var file_path &lt;/span&gt;=&lt;span&gt; xhr.responseText;
{&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;                        console.log(file_path);#}&lt;/span&gt;
                        $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; file_path)
                    }
                };
            })
        }


        function bindAvatar2() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                var obj &lt;/span&gt;=&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                &lt;/span&gt;//&lt;span&gt;将文件对象上传到浏览器
                &lt;/span&gt;//&lt;span&gt;IE10 以下不支持


                &lt;/span&gt;//&lt;span&gt;不会自动释放内存
                &lt;/span&gt;//&lt;span&gt;当加载完图片后,释放内存

                document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).onload=&lt;span&gt; function () {
                    window.URL.revokeObjectURL(v);
                };

                var v &lt;/span&gt;=&lt;span&gt; window.URL.createObjectURL(obj);
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,v);
            })
        }





        function bindAvatar3() {
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#imgSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).change(function () {
                var obj &lt;/span&gt;=&lt;span&gt; $(this)[0].files[0];
                console.log(obj);

                var reader &lt;/span&gt;=&lt;span&gt; new FileReader();
                reader.onload &lt;/span&gt;=&lt;span&gt; function (e) {
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#previewImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).attr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,this.result);
                };
                reader.readAsDataURL(obj)
            })
        }



    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;一步到位，大家都能用&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　主页部分，主页部分的主要操作就是各项分类，你可以将标签，随笔和时间分开写，其实我一开始也是这么做的，但实际上重复代码有很多，这些按分类展现的页面，唯一的不同就是根据不同类型分类的文章也不同。根据这一点，我们可以将分类写到一个视图函数里面，这样代码更为精简。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
url(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^(?P&amp;lt;site&amp;gt;\w+)/(?P&amp;lt;key&amp;gt;((tag)|(date)|(category)))/(?P&amp;lt;val&amp;gt;\w+-*\w*)/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, views.filter)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而分类的过程中主要涉及的就是ORM的操作，并且也没有十分难的数据表操作。&lt;/p&gt;
&lt;p&gt;　　文章页&lt;/p&gt;
&lt;p&gt;　　文章页的部分主要是点赞与评论部分，先说一下评论部分，评论可以做成缩进的多级评论，但是需要将数据库获得的数据进行数据结构改造，快速索引。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45.5&quot;&gt;&lt;img id=&quot;code_img_closed_431b2e2b-cd1c-47e4-a089-b1960239e2e5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_431b2e2b-cd1c-47e4-a089-b1960239e2e5&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_431b2e2b-cd1c-47e4-a089-b1960239e2e5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
    msg_list =&lt;span&gt; [
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;写的太好了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;你说得对&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:3,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;顶楼上&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:4,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;你眼瞎吗&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:5,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我看是&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:4&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:6,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;鸡毛&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:2&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:7,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;你是没呀&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:5&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:8,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;惺惺惜惺惺想寻&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:3&lt;span&gt;},
    ]
    msg_list_dict &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; msg_list:
        item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = []&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每一行加一个空列表child，存放子数据&lt;/span&gt;
        msg_list_dict[item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]] = item&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每个行加一个索引的序列改造成[1;{},2:{}]&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; #### msg_list_dict用于查找,msg_list&lt;/span&gt;
    result =&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; msg_list:
        pid &lt;/span&gt;= item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果有父id&lt;/span&gt;
            msg_list_dict[pid][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].append(item)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加到刚才的child列表中&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            result.append(item)&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;列表里都是第一级的评论&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ########################### 打印 ###################&lt;/span&gt;
    &lt;span&gt;from&lt;/span&gt; utils.comment &lt;span&gt;import&lt;/span&gt;&lt;span&gt; comment_tree
    comment_str &lt;/span&gt;= comment_tree(result)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;自定义把所有的评论一级一级递归的拨开，解析成HTML格式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;多级评论&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_5fcefdb8-d0c4-4bc5-b8c9-e6430192745e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5fcefdb8-d0c4-4bc5-b8c9-e6430192745e&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5fcefdb8-d0c4-4bc5-b8c9-e6430192745e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; comment_tree(comment_list):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

    :param result: [ {id,:child:[xxx]},{}]
    :return:
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    comment_str &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div class='comment'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; comment_list:
        tpl &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div class='content'&amp;gt;%s&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(row[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        comment_str &lt;/span&gt;+=&lt;span&gt; tpl
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; row[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
            &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;            child_str = comment_tree(row[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
            comment_str &lt;/span&gt;+=&lt;span&gt; child_str
    comment_str &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt; comment_str
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;util.comment&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　个人觉得也可以写成博客园的@的方式，@的回复可跨表取到。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_a5051041-4e52-4c5f-822f-bfd18b47dd0d&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a5051041-4e52-4c5f-822f-bfd18b47dd0d&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a5051041-4e52-4c5f-822f-bfd18b47dd0d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
{% &lt;span&gt;for&lt;/span&gt; re &lt;span&gt;in&lt;/span&gt; reply %&lt;span&gt;}
    &lt;/span&gt;&amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color: #e0e0e0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{ re.comment__create_time }}&amp;amp;nbsp [发言人]{{ re.comment__user__username }}&amp;lt;/div&amp;gt;&lt;span&gt;
    {&lt;/span&gt;% &lt;span&gt;if&lt;/span&gt; re.comment__reply__user__username %&lt;span&gt;}
    &lt;/span&gt;&amp;lt;p&amp;gt;@{{ re.comment__reply__user__username }}&amp;lt;/p&amp;gt;&lt;span&gt;
        {&lt;/span&gt;% &lt;span&gt;else&lt;/span&gt; %&lt;span&gt;}
        &lt;/span&gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&lt;span&gt;
    {&lt;/span&gt;% endif %&lt;span&gt;}
&lt;/span&gt;&amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 100%;border-bottom: #00b3ee 1px solid ;margin-top: 5px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;  {{ re.comment__content }} &amp;lt;/div&amp;gt;&lt;span&gt;

{&lt;/span&gt;% endfor %}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;数据可以后端跨表取&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　点赞要给赞绑定点击事件，定义1为赞，0为踩，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;updown(this,{{ content.nid }},1);//传给绑定事件触发的函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_d82efbd8-0035-4670-8564-239af8fd71ea&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d82efbd8-0035-4670-8564-239af8fd71ea&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d82efbd8-0035-4670-8564-239af8fd71ea&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        function updown(ths,nid,val){
            $.ajax({
                url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/updown.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                data:{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:val,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:nid,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;csrfmiddlewaretoken&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{{ csrf_token }}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
                type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                dataType:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;JSON&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                success:function(arg){
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arg.status){
                        &lt;/span&gt;//&lt;span&gt; 点赞成功刷新页面
                        location.reload();
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        alert(arg.msg)
                    }
                }
            })
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;绑定事件&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　后台管理可以使用xadmin来做，当然也可以写一个后台管理，我这个后台管理暂时使用管理员管理界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1165242/201712/1165242-20171223220008475-681048939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://www.cnblogs.com/Jeffding/p/8093483.html&quot;&gt;xadmin使用方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　这两天把后台搭起来再把源码上传。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 13:46:00 +0000</pubDate>
<dc:creator>JeffD</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jeffding/p/8035312.html</dc:identifier>
</item>
<item>
<title>来腾讯云开发者实验室 学习.NET Core 2.0 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/8094409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/8094409.html</guid>
<description>&lt;p&gt;腾讯云开发者实验室为开发者提供了一个零门槛的在线实验平台,开发者实验室提供的能力：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;零门槛扫码即可免费领取实验机器，支持使用自有机器参与，实验完成后支持保留实验成果；&lt;/li&gt;
&lt;li&gt;在线 WEB IDE 支持 shell 命令操作，支持机器文件操作，支持文件实时编辑，结合交互式教学体验提供了良好的在线实验体验；&lt;/li&gt;
&lt;li&gt;基于云的真实标准的实验环境，确保实验的普适性；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体内容可以看视频：&lt;/p&gt;

&lt;p&gt;.NET Core 的最重要的一个特性就是跨平台，Windows 很多同学都会，学习 Linux 已经成为一个.NET 程序员的必备技能，因此我和腾讯云同事合作在腾讯云上提供了 1 个 CentOS 7.2 环境下的.net core 2.0实验教程,结合腾讯云上其他 Linux 的教程，这就是一个非常好的实现在线学习环境。&lt;/p&gt;
&lt;p&gt;腾讯云在线实验室目前有 30 个教程，具体参看 &lt;a href=&quot;https://www.qcloud.com/developer/labs/list&quot;&gt;实验列表&lt;/a&gt; 。其中有 3个实验是.NET Core 和 Mono 相关的, 具体访问 &lt;a title=&quot;https://cloud.tencent.com/developer/labs/gallery?tagId=11&quot; href=&quot;https://cloud.tencent.com/developer/labs/gallery?tagId=11&quot;&gt;https://cloud.tencent.com/developer/labs/gallery?tagId=11&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从 linux 基础开始到.net core 的入门的系列实验，动手实验的效果要比纯粹的看文章的效果要好很多&lt;/strong&gt;，这里给大家整理一下在腾讯云学习的系列实验推荐。&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.qcloud.com/developer/labs/lab/10000&quot;&gt;Linux 基础入门&lt;/a&gt;：实验介绍基本的 Linux 操作和命令，如目录切换、文件操作、进程查看、端口查看、资源占用情况等等，实现从零开始操作 Linux 机器。具体可以参考我整理的一个文档 &lt;a href=&quot;https://github.com/geffzhang/opendotnet&quot;&gt;《.NET 跨平台(CentOS ) 相关文档整理》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2、 &lt;a href=&quot;https://www.qcloud.com/developer/labs/lab/10100&quot;&gt;搭建 .NET Core 开发环境&lt;/a&gt;：本实验将带您学习搭建 .NET Core 和 Jexus 组成的 .NET Core Web 开发环境。参考文章： &lt;a href=&quot;https://www.qcloud.com/community/article/563486&quot;&gt;在 CentOS 上使用 Jexus 托管运行 ZKEACMS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、 &lt;a href=&quot;https://www.qcloud.com/developer/labs/lab/10101&quot;&gt;搭建 Mono 开发环境&lt;/a&gt; ：本实验带您搭建 Mono 开发环境， 体验在 Linux 上写传统.NET 应用的环境，具体参考： &lt;a href=&quot;https://www.qcloud.com/community/article/829845&quot;&gt;Mono 新突破：CentOS 7.2 下安装 Mono 5.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、 &lt;a href=&quot;https://cloud.tencent.com/developer/labs/lab/10347&quot; target=&quot;_blank&quot;&gt;搭建.NET Core 2.0环境&lt;/a&gt;: 学习如何在CentOS 7.2 下搭建 .NET Core 2和 Jexus 组成的 .NET Core Web 开发环境&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 12:59:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/8094409.html</dc:identifier>
</item>
<item>
<title>数据库设计 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8093887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8093887.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　本文将详细介绍数据库设计的相关知识&lt;/p&gt;

&lt;h3&gt;设计范式&lt;/h3&gt;
&lt;p&gt;　　数据库设计共有三大范式：&lt;/p&gt;
&lt;p&gt;　　第一范式：无重复的列&lt;/p&gt;
&lt;p&gt;　　第二范式：属性完全依赖于主键&lt;/p&gt;
&lt;p&gt;　　第三范式：属性不能依赖于主属性&lt;/p&gt;
&lt;p&gt;　　下面将分别对这三个范式进行详细介绍&lt;/p&gt;

&lt;h3&gt;第一范式&lt;/h3&gt;
&lt;p&gt;　　数据库表中的每一列都是不可分割的基本数据项，同一列中不能有多个值。具体而言，有以下两条要求&lt;/p&gt;
&lt;p&gt;　　1、每一列属性都是不可再分的，确保每一列的原子性&lt;/p&gt;
&lt;p&gt;　　2、两列的属性相近或相似或一样，尽量合并属性一样的列， 确保不产生冗余数据&lt;/p&gt;
&lt;p&gt;　　以考勤表设计为例，考勤表用来记录每天学生的考勤情况&lt;/p&gt;
&lt;p&gt;　　最简单的情况是，每一天都建立一张表。字段是每个学生的姓名，列值表示是否签到。这样，可以很方便的存储当天的考勤情况。但是，这也导致了每天都需要在数据库里新建一张考勤表。而且，这种做法违反了第一范式，这张考勤表的字段的属性含义都是一样的，都是记录学员的考勤情况。因此，这些字段是需要合并的&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223165205631-1871162147.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　更优化的设计是，第一字段是学生姓名，第二字段是0101表示`1月1日，第三字段是0102表示1月2日，以此类推。这种做法，不再需要设计那么多表，将学生的姓名列合并成了一个姓名列。但是，同样它没有遵循第一范式，1年365天， 代码除了学生姓名列外，还需要设置365个字段。而且，这些列的含义都是一样的，记录当天的考勤。因此，这些字段也是需要合并的&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223170531100-1437466428.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　下面是优化的情况，把所有的日期合并成一个日期字段，新增一个考勤状态字段，如下所示，完全遵循了第一范式，没有重复的列，且每一列都是可拆分的。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223170726521-924793622.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　总而言之，用第一范式设计数据库时，就是分解数据，并将属性相似的列合并&lt;/p&gt;

&lt;h3&gt;第二范式&lt;/h3&gt;
&lt;p&gt;　　第二范式需要遵循以下要求：&lt;/p&gt;
&lt;p&gt;　　1、一个表表必须有一个主键&lt;/p&gt;
&lt;p&gt;　　2、没有包含在主键中的列必须完全依赖于主键，而不能只 依赖于主键的一部分&lt;/p&gt;
&lt;p&gt;　　以下面购物车表为例，用户ID和商品ID构成了商品的主键，数量列依赖于用户购买商品的数量，单价和商品名称只依赖于商品ID。因此，这张表不满足第二范式&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223185750600-8272923.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　优化后，修改如下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223185905068-1839455476.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;第三范式&lt;/h3&gt;
&lt;p&gt;　　非主键列必须直接依赖于主键，不能存在传递依赖。第三范式，相较于第二范式而言，强调的是直接依赖，而不能是传递依赖&lt;/p&gt;
&lt;p&gt;　　关于传递依赖，以下面的中奖信息表为例，中奖金额依赖于中奖等级，而中将等级及依赖于用户ID，这就是传递依赖&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223190402115-1302523537.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　要遵循第三范式，就要消除传递依赖&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223190441053-2024254094.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;新闻系统&lt;/h3&gt;
&lt;p&gt;　　下面尝试利用三个范式，来设计新闻系统数据库。包括以下要点：&lt;/p&gt;
&lt;p&gt;　　1、用户名、密码、是否是管理员&lt;/p&gt;
&lt;p&gt;　　2、新闻标题、新闻内容、作者、新闻时间、是否上线&lt;/p&gt;
&lt;p&gt;　　3、评论人、评论内容、评论时间、评论源&lt;/p&gt;
&lt;p&gt;　　分别对应用户表、新闻表和评论表&lt;/p&gt;
&lt;p&gt;　　一般来说，用户名长度不超过20个字符，密码长度不超过20个字符，新闻标题长度不超过30个字符，新闻内容长度不超过5000个字符，评论内容长度不超过300个字符&lt;/p&gt;
&lt;p&gt;　　用户表详细如下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223192903975-779039949.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　新闻表详细如下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223193143631-540026917.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　评论表详细如下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201712/740839-20171223193224443-1927512479.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;　　在设计数据库时，只需满足以上三个范式，就可以设计既合理又满足需求的数据库&lt;/p&gt;

</description>
<pubDate>Sat, 23 Dec 2017 11:36:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8093887.html</dc:identifier>
</item>
<item>
<title>支付宝当面付扫码支付功能详解 - 孤独是1态度</title>
<link>http://www.cnblogs.com/gudu1/p/8094197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gudu1/p/8094197.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言： 上篇呢主要是针对微信验证登录做了讲解，当然微信也是提供了很多的接口来供开发者进行调用，同样，微信也有支付，相信小伙伴们学习了上篇的登录之后，已经能够融汇贯通，做出微信的支付功能。那么本篇呢就讲解一下支付宝的支付功能，同样的，通过这一个例子，你就能使用支付宝其它的功能，还是那句老话，就当做是一个敲门砖吧，好了，下面就开始吧。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;本篇为原创，转载请标出处&lt;/span&gt;：&lt;a href=&quot;http://www.cnblogs.com/gudu1/p/8094197.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/gudu1/p/8094197.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　微信有测试公众号测试，那么支付宝呢？他也有，不过名字是叫做支付宝沙箱环境，地址：&lt;a href=&quot;https://sandbox.alipaydev.com/sms/receive.htm&quot; target=&quot;_blank&quot;&gt;https://sandbox.alipaydev.com/sms/receive.htm&lt;/a&gt; ，扫码登陆之后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1037461/201712/1037461-20171223171239615-326288555.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; APPID，支付宝网关，以及应用网关 这些呢是固定不变的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　&amp;gt;&amp;gt;&lt;/span&gt; 我们已经知道微信使用的是 SHA-1 加密，那么支付宝使用的就是RSA 和 RSA2 加密，当然了，支付宝推荐使用RSA2加密，两个的区别就是RSA2 是2048 位，RSA 是1024位，所以RSA2加密更好，我们就使用它就好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 授权回调地址就是用户扫码进行支付之后，支付宝服务器回调我们程序接口的地址，规则呢跟微信的是一样的，这里不多讲了，不明白的请看一下上篇微信验证登录的讲解 &lt;a href=&quot;http://www.cnblogs.com/gudu1/p/8087130.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/gudu1/p/8087130.html&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 接下来的就配置一下我们的密匙，使用哪个加密方式就配置哪个就好了，支付宝很周到，给我们提供了生成密匙的工具，下载位置：&lt;a href=&quot;https://docs.open.alipay.com/291/105971&quot; target=&quot;_blank&quot;&gt;https://docs.open.alipay.com/291/105971&lt;/a&gt; ，这个也是支付宝的官方文档，具体怎么使用，里面都很详细，这里就不占篇幅了，然后生成之后，就直接 copy 进去配置就好了，很简单的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　下面还是老样子，先贴出代码，然后讲解代码中的一些点，支付宝也提供了Java 、PHP、.NET  版本的支付代码，这点是非常到位的，所以我们只是站在巨人的肩膀上，前人栽树，后人乘凉，下载地址：&lt;a href=&quot;https://docs.open.alipay.com/194/105201/&quot; target=&quot;_blank&quot;&gt;https://docs.open.alipay.com/194/105201/&lt;/a&gt; ，下载我们都会，下载之后把代码copy 出来，需要使用哪个功能就copy 哪个，因为我这里使用的支付宝生成二维码预下单的功能，然后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Controller &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;@Controller
@RequestMapping(&lt;/span&gt;&quot;/order/&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController {
 @RequestMapping(&lt;/span&gt;&quot;pay.do&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ServerResponse&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt; pay(HttpSession session, Long orderNo, HttpServletRequest request) {
        Integer userId &lt;/span&gt;=&lt;span&gt; ((User) session.getAttribute(Const.CURRENT_USER)).getId();
        String path &lt;/span&gt;= request.getSession().getServletContext().getRealPath(PropertiesUtil.getProperty(&quot;upload_image_path&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (orderNo == &lt;span&gt;null&lt;/span&gt; || orderNo == 0L&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createByErrorMessage(&quot;支付订单不能为空&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderService.pay(userId, orderNo, path);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　&lt;span&gt;Service 的pay 方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service(&quot;iOrderService&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OrderServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IOrderService {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(OrderServiceImpl.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 支付宝当面付2.0服务&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; AlipayTradeService tradeService;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数
         *  Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Configs.init(&lt;/span&gt;&quot;zfbinfo.properties&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 使用Configs提供的默认参数
         *  AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        tradeService &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AlipayTradeServiceImpl.ClientBuilder().build();
    }
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 支付宝预创建支付订单，生成支付的二维码用户用户扫码支付
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; userId  用户ID
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; orderNo 订单号
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; path    本地上传图片地址
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Transactional
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServerResponse pay(Integer userId, Long orderNo, String path) {
        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; mapResult =&lt;span&gt; Maps.newHashMap();
        Order order &lt;/span&gt;=&lt;span&gt; orderMapper.selectOrderByOrderNo(orderNo);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (order == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createBySuccessMessage(&quot;该订单不存在&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线，
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需保证商户系统端不能重复，建议通过数据库sequence生成，&lt;/span&gt;
        String outTradeNo =&lt;span&gt; order.getOrderNo().toString();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店当面付扫码消费”&lt;/span&gt;
        String subject = &quot;Happy_mmall 扫码付款&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (必填) 订单总金额，单位为元，不能超过1亿元
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】&lt;/span&gt;
        String totalAmount =&lt;span&gt; order.getPayment().toString();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】&lt;/span&gt;
        String undiscountableAmount = &quot;0&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID&lt;/span&gt;
        String sellerId = &quot;&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订单描述，可以对交易或商品进行一个详细地描述，比如填写&quot;购买商品2件共15.00元&quot;&lt;/span&gt;
        String body = &lt;span&gt;new&lt;/span&gt; StringBuffer().append(&quot;订单:&quot;).append(order.getOrderNo()).append(&quot;,共花费&quot;).append(order.getPayment()).append(&quot;元&quot;&lt;span&gt;).toString();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 商户操作员编号，添加此参数可以为商户操作员做销售统计&lt;/span&gt;
        String operatorId = &quot;test_operator_id&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持&lt;/span&gt;
        String storeId = &quot;test_store_id&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持&lt;/span&gt;
        ExtendParams extendParams = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExtendParams();
        extendParams.setSysServiceProviderId(&lt;/span&gt;&quot;2088100200300400500&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 支付超时，定义为120分钟&lt;/span&gt;
        String timeoutExpress = &quot;120m&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 商品明细列表，需填写购买商品详细信息，&lt;/span&gt;
        List&amp;lt;GoodsDetail&amp;gt; goodsDetailList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;GoodsDetail&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加 用户 预支付的订单中的商品&lt;/span&gt;
        List&amp;lt;OrderItem&amp;gt; orderItemList =&lt;span&gt; orderItemMapper.selectListByUserIdAndOrderNo(orderNo, userId);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (OrderItem orderItem : orderItemList) {
            GoodsDetail goods1 &lt;/span&gt;=&lt;span&gt; GoodsDetail.newInstance(orderItem.getProductId().toString(), orderItem.getProductName(),
                    BigDecimalUtil.mul(orderItem.getCurrentUnitPrice().doubleValue(), &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Double(100&lt;span&gt;)).longValue(),
                    orderItem.getQuantity());
            goodsDetailList.add(goods1);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建扫码支付请求builder，设置请求参数&lt;/span&gt;
        AlipayTradePrecreateRequestBuilder builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AlipayTradePrecreateRequestBuilder()
                .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo)
                .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body)
                .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams)
                .setTimeoutExpress(timeoutExpress)
                .setNotifyUrl(PropertiesUtil.getProperty(&lt;/span&gt;&quot;alipay.callback.url&quot;))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置&lt;/span&gt;
&lt;span&gt;                .setGoodsDetailList(goodsDetailList);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建预支付订单对象&lt;/span&gt;
        AlipayF2FPrecreateResult result =&lt;span&gt; tradeService.tradePrecreate(builder);
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (result.getTradeStatus()) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SUCCESS:
                logger.info(&lt;/span&gt;&quot;支付宝预下单成功: )&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取响应 Response&lt;/span&gt;
                AlipayTradePrecreateResponse response =&lt;span&gt; result.getResponse();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  简单打印一下日志&lt;/span&gt;
&lt;span&gt;                dumpResponse(response);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建本地上传图片的文件夹，不存在则创建&lt;/span&gt;
                File folder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(path);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;folder.exists()) {
                    folder.setWritable(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    folder.mkdirs();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要修改为运行机器上的路径,&lt;/span&gt;
                String filePath = String.format(path + &quot;/qr-%s.png&quot;&lt;span&gt;,
                        response.getOutTradeNo());
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; %s 是一种占位符，即后面的response.getOutTradeNo() ，只是生成额随机字符串，防止重名&lt;/span&gt;
                String fileName = String.format(&quot;/qr-%s.png&quot;&lt;span&gt;, response.getOutTradeNo());

                logger.info(&lt;/span&gt;&quot;filePath:&quot; +&lt;span&gt; filePath);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上传到本地服务器&lt;/span&gt;
                ZxingUtils.getQRCodeImge(response.getQrCode(), 256&lt;span&gt;, filePath);
                File targetFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(path, fileName);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上传图片到FTP服务器，上传FTP完毕之后，删除本地存储的图片&lt;/span&gt;
&lt;span&gt;                    FTPUtil.upload(Lists.newArrayList(targetFile));
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    logger.error(&lt;/span&gt;&quot;上传二维码失败&quot;&lt;span&gt;, e);
                    e.printStackTrace();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刚刚上传到FTP的图片地址URL&lt;/span&gt;
                String qrPathUrl =&lt;span&gt; PathUtil.getFTPImgPath(targetFile.getName());
                mapResult.put(&lt;/span&gt;&quot;qrPath&quot;&lt;span&gt;, qrPathUrl);
                mapResult.put(&lt;/span&gt;&quot;orderNo&quot;&lt;span&gt;, orderNo.toString());
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ServerResponse.createBySuccess(mapResult);
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FAILED:
                logger.error(&lt;/span&gt;&quot;支付宝预下单失败!!!&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createByErrorMessage(&quot;支付宝预下单失败!!!&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; UNKNOWN:
                logger.error(&lt;/span&gt;&quot;系统异常，预下单状态未知!!!&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createByErrorMessage(&quot;系统异常，预下单状态未知!!!&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                logger.error(&lt;/span&gt;&quot;不支持的交易状态，交易返回异常!!!&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createByErrorMessage(&quot;不支持的交易状态，交易返回异常!!!&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 在此之前呢不要忘记添加支付宝的集成依赖jar包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 为了方便理解，代码中的每一步都添加了注释，代码比较多，但是大多数的代码都是直接copy支付宝 提供的Demo，然后根据我们自己的业务需求修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 由于篇幅问题，请注意静态代码块中的代码，会加载一个配置文件，这个配置文件支付宝同样有提供，我们只要修改一下其中的参数值，APPID、PID（商户UID）、以及加密的公钥和私钥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 我们程序支付整体的思路是这样：用户确认下单后，点击支付，然后会调用我们pay.do 这个接口，然后我们的程序在向支付宝服务器发送请求之前会添加一些参数，就是商品的订单号、收款平台信息、以及购买商品需要支付的总价格，需要修改的一处是 创建AlipayTradePrecreateRequestBuilder对象的时候，把call_back的URL修改成我们自己程序的接口，然后程序就向支付宝发送消息，因为这里支付宝集成做的特别好，只需要创建一个预支付对象，把需要的参数传进去，就可以发起预支付请求，返回二维码字节流，我们把二维码进行保存，然后展示给用户，进行扫码支付，用户扫码之后，不管是支付成功或者支付失败都会回调我们的call_back中配置的URL，进行处理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 接下来就是我们的 call_back ：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;@Controller
@RequestMapping(&lt;/span&gt;&quot;/order/&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController {
    @RequestMapping(&lt;/span&gt;&quot;alipay_callback.do&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ServerResponse callBack(HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; AlipayApiException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出支付宝回调携带的所有参数并进行转换，数组转换为字符串&lt;/span&gt;
        Map&amp;lt;String, String[]&amp;gt; tempParams =&lt;span&gt; request.getParameterMap();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  参数存放 Map&lt;/span&gt;
        Map&amp;lt;String, String&amp;gt; requestParams =&lt;span&gt; Maps.newHashMap();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Iterator&amp;lt;String&amp;gt; iterator =&lt;span&gt; tempParams.keySet().iterator(); iterator.hasNext(); ) {
            String key &lt;/span&gt;=&lt;span&gt; iterator.next();
            String[] strs &lt;/span&gt;=&lt;span&gt; tempParams.get(key);
            String str &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里如果数组的长度是1，说明只有一个，直接赋值就好，如果超过一个，后面加一个逗号来隔离&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; strs.length; i++&lt;span&gt;) {
                str &lt;/span&gt;= strs.length - 1 == i ? str + strs[i] : str + strs[i] + &quot;,&quot;&lt;span&gt;;
            }
            requestParams.put(key, str);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 去除sign_type&lt;/span&gt;
        requestParams.remove(&quot;sign_type&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 验证签名&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; result = AlipaySignature.rsaCheckV2(requestParams, Configs.getPublicKey(), &quot;utf-8&quot;&lt;span&gt;, Configs.getSignType());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;result) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ServerResponse.createByErrorMessage(&quot;非法请求,再恶意请求我就报警找网警了&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AlipayApiException e) {
            logger.error(&lt;/span&gt;&quot;支付宝回调验证异常&quot;&lt;span&gt;, e);
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Service 方法进行处理&lt;/span&gt;
        ServerResponse serverResponse =&lt;span&gt; orderService.alipayCallBack(requestParams);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;serverResponse.isSuccess()) {
            logger.error(&lt;/span&gt;&quot;OrderController.callBack()&quot;,&quot;数据操作失败&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ServerResponse.createBySuccess(Const.AlipayCallback.RESPONSE_FAILED);
        }
        logger.info(&lt;/span&gt;&quot;支付宝支付回调完成，没有异常&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ServerResponse.createBySuccess(Const.AlipayCallback.RESPONSE_SUCCESS);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt; &lt;/span&gt;这个支付宝回调URL是这样：http://smyang.s1.natapp.cc/order/alipay_callback.do，对应我们的Controller 的RequestMapping中的路由，代码中都有添加注释，还是很清晰的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt; &lt;/span&gt;支付宝的验证签名的规则是怎样的呢？在通知返回的参数中除了sign_type和sign，其余的都是待验签的参数，详细请看 &lt;a href=&quot;https://docs.open.alipay.com/194/103296/&quot; target=&quot;_blank&quot;&gt;https://docs.open.alipay.com/194/103296/&lt;/a&gt; ，但是这里只remove 掉了sign_type，通过查看源码发现，在支付宝集成代码中需要获取一下sign，然后它才remove 掉了sign，所以这里我们只需要remove掉sign_type就好，而且是必须的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt; &lt;/span&gt;在 rsaCheckV2() 方法中我们加入的参数sign_type，指定了使用哪种加密方式来验签，如果通过就确定这个支付过程是安全的，同时 Configs 这个类也是支付宝给我们提供的，很到位的吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; 最后调用了Service方法进行我们的代码逻辑，比如：更新数据库中用户的支付状态，这个就是我们自己的业务需求了，在我们的业务代码中主要是通过支付宝回调参数中的 tradeStatus 这个字段来判断用户是否支付成功，具体的tradeStatus的状态，可以自行查看支付宝官方文档。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然，支付宝不止这一种支付方式，另外还有好多，可以自行去查看，官方文档才是我们最好的老师。好了，到这里就先结束了，后续如果有不足的地方再另行修改。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 23 Dec 2017 11:30:00 +0000</pubDate>
<dc:creator>孤独是1态度</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gudu1/p/8094197.html</dc:identifier>
</item>
<item>
<title>【Win 10 应用开发】MIDI 音乐合成——音符消息篇 - 东邪独孤</title>
<link>http://www.cnblogs.com/tcjiaan/p/8085408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tcjiaan/p/8085408.html</guid>
<description>&lt;p&gt;在上一篇中，老周介绍了一些乐理知识，有了那些常识后，进行 MIDI 编程就简单得多了。尽管微软已经把 API 封装好，用起来也很简单，但是，如果你没有相应的音乐知识基础，你是无法进行 MIDI 编程的。&lt;/p&gt;
&lt;p&gt;这一篇老周将给你讲述一下如何让你的声卡播放一个音符，这会包含两条消息，而且这两条消息是很常用的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、Note On：让 MIDI 设备（如果没有专业设备，那就是你的声卡）发出某个音符的声音，比如，发出中音 3 的声音。注意啊，Note on 一旦发送，设备会一直播放这个声音，要想停止播放一个音符，你就要用到下面这条消息，它们是天生的一对。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Note Off：关闭某个音符，即停止播放某个音符。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;咱们先来了解三个很重要的类，跟 MIDI 设备通信相关的 API 都在 Windows.Devices.Midi 命名空间下，封装好的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、MidiInPort：用来从 MIDI 输入设备接收消息，所以它公开了一个 MessageReceived 事件，只要 MIDI 输入设备发送了消息，就会引发这个事件，这时候你可以处理这个事件，把收到的消息再传到声卡上进行播放。MIDI 输入设备一般是 MIDI 键盘，估计大部分人用不上这个类，因为一般人不会购买 MIDI 键盘。真想买个好用的，起码是 88 键的，价格还是不低的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、MidiOutPort：连接 MIDI 输出设备，可以播放 MIDI 音乐。如果没有专业的 MIDI 音响，就可以连到你的声卡上，内置外置都可以，市面上有外置的 MIDI 声卡卖，当然了，想省钱的话，你是买不到好音色的，要是你不在乎音色的话，那无所谓。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、MidiSynthesizer：这个类非常好使，它其实类似于 MidiOutPort 类，但它可以自动选择默认的设备（当然也可选择设备）。这个类是专门针对 MIDI 合成而设计的，尽管它与 MidiOutPort 相似，但侧重点不同。MidiOutPort 侧重于与 MIDI 设备的通信，而 MidiSynthesizer 类是侧重于合成。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们在进行电子音乐合成的时候，只需要使用 MidiSynthesizer 类即可，它没有构造函数，可以调用 CreateAsync 静态方法来获取实例。对于普通设备而言，我们调用无参数的重载版本就行了，应用程序会默认选择声卡作为输出设备。然后，我们尽管发送 MIDI 消息就OK。当不再使用 MidiSynthesizer 实例时，应该把它 Dispose 掉，以释放资源占用。&lt;/p&gt;
&lt;p&gt;是不是很简单呢，一切都是封装好的，所以说，你只要有一定的乐理基础就可以轻松玩耍这些 API。据说，这个 MidiSynthesizer 类还包含了罗兰公司（Roland）的通用音色库。&lt;/p&gt;
&lt;p&gt;当然了，这只能是通用的 128 种乐器的声音，不包含各种演奏技巧（如揉弦、波音、颤音等）。其目的是尽可能地兼容各类声卡，包括很烂的声卡，虽然比较普通，不过嘛，音色听着还是可以的，只是少了点感觉。不过也是，电声毕竟是虚假的乐音，而不是自然音，就算是专业级别的音源，其实听着也不会太有乐感的。所以嘛，真想感受音乐之美，还是买个真实的乐器自己去演奏。老周小时候喜欢口琴和笛子，上初中的时候，学了一点电子琴、口风琴和扬琴，不过只是学了一点点而已。上高中的三年基本没碰过乐器。大学的时候，在学生会里面鬼混，所以经常可以拿乐队的吉他拨两下。&lt;/p&gt;
&lt;p&gt;后来，像洞箫、巴乌、葫芦丝、陶埙、陶笛等都学过。想学学古琴，但是买一把好琴比较贵，就没有去学了。吹奏类乐器一般比较便宜，至少像老周这种穷人还能买得起，因此老周家里放的乐器，多数是吹奏类的。击打类的有一对小铜鼓，在路边捡的。&lt;/p&gt;

&lt;p&gt;好，不扯了，咱们说正题。本篇的重点是学会两条 MIDI 消息，对，就是上面说的 Note on 和 Note off。不管是 on 还是 off，这两条音符消息的格式是一样的，都是包含三个字节。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个字节是 【状态码 + 通道编号】，这个可能你不太理解，没事，老周待会儿再解释。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个字节是音符，对，就是上一篇中，简谱上面的 1234567，唱出来就是 dol re mi fa sol la xi，用一个字节表示，从 0 - 127，共128 个音符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三个字节是音速，值也是从 0 到 127。这个音速其实你感觉不到什么，发送到声卡上的效果就是音量。值越小声音越小，如果是 0 就等于静音了，127 时声音最大。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;好，下面逐个解释两下。&lt;/p&gt;
&lt;p&gt;首先，状态码，在前一篇中，老周简单地说了一下 MIDI 文件的结构，一个 MIDI 事件是由 delta-time 和事件主体组成。而一个事件的开头都有一个标志字节。在MIDI文件中， Note on 和 Note off 都是一个事件；而在实时通信中，可认为是一条 MIDI 消息，其实结构是一样的。&lt;/p&gt;
&lt;p&gt;不管是Note on 和 Note off ，还是其他通道消息，其第一个字节是由两部分信息组成的。我们知道，一个字节有 8 位，从右边起，1 - 4位表示通道编号，所以，MIDI 音乐有 16 个通道。为什么是 16 个通道呢，不是刚说了吗，只有 4 位二进制位表示通道编号，二进制 1111 就是 15，所以，通道的有效编号是 0 - 15，共16个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：轨道与通道不同。轨道地用于 MIDI 文件的，可以是单轨，可以是多轨，轨道只是方便存储，也方便人类查看，但 MIDI 设置并不认轨道，只认识标准的 16 个通道。故 MIDI 消息只有通道的概念。另外，还要注意，第 10 个通道（编号 9 ）是打击乐专用通道，在 GM 2 标准中，增加了一个，即第 10、11 通道可用于打击乐（编号 9、10）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第 5 到 8 位表示状态码，或者说事件标志，总之，用来标识某个指令。Note Off 的标志是 1000，换算为十六进制就是 0x8 ；Note On 的标志是 1001，换算为十六进制就是 0x9。&lt;/p&gt;
&lt;p&gt;假设，要向第四个通道发送一条 Note on 消息。第四个通道的编号是 3，换算为二进制就是 0011，Note on 的标志为 1001，所以，组合起来，第一个字节就是 1001 0011，换算为十六进制就是 0x93。再比如，要向第一个通道发送一条消息，第一通道的编号是0，即 0000，Note on 的标志是 1001，组合起来的字节就是 1001 0000，换算为十六进制就是 0x90。&lt;/p&gt;
&lt;p&gt;如果要向第二个通道发送一条 Note off 消息。第二个通道的编号是 1，即 0001，Note off 的标志为 1000，组合起来的字节就是 0x81。&lt;/p&gt;

&lt;p&gt;音符消息的第二个字节是音符，值从 0 - 127，共128个。虽然有 128 个音符，但实际上你只要记住一个值就行了—— 60，它表示的是中音 1 。128 / 12，余数为 8 ，凑不成一个 12，所以，中音 1 就位于 120 / 2 = 60 处。为什么音符是 12 个一组呢？上一篇中老周为啥要介绍“十二平均律”，就是有用的，MIDI 的音符排序是遵守十二平均律的，所以每 12 个音符构成一个“八度”。&lt;/p&gt;
&lt;p&gt;于是这一来，这里头就有十来个八度了，其实我们大多数歌曲根本用不上，很多情况下，只用到三个八度：低音区、中音区、高音区。所以，你只需要记住中音 1 的编号是 60 就好办了。你看啊，中音 1 是 60，那么，低音 1 就是 60 - 12 = 48，高音 1 就是 60 + 12 = 72，倍高音 1 就是 60 + 12*2 = 84，倍低音 1 就是 60 - 12*2 = 36。&lt;/p&gt;
&lt;p&gt;下面老周给你一张表，用以参考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201712/367389-20171223171610287-1070361616.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;

&lt;p&gt;音符消息的第三个字节是音速，值从 0 - 127，这个所谓的音速，发送到设备后实际表现出来的效果是音量，127时音量最大，如果是0就无声了。如果我们向 MIDI 设备发送一条音速 = 0 的 Note on 消息，它的结果等同于 Note off 消息。说白了就是，音速为 0 的 note on 消息等同于 note off 消息，结果都是停止播放音符。&lt;/p&gt;

&lt;p&gt;举几个例子，如果要让通道0发出中音 1 的声音，首先，note on 的标志是 0x9，通道为0，合起来第一个字节是 0x90；第二个字节表示音符，中音1是60，即 0x3C； 第三个字节是音速，我们用最大值127，即 0x7F。所以这条 note on 消息就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0x90&lt;/span&gt;  &lt;span&gt;0x3C&lt;/span&gt;  &lt;span&gt;0x7F&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要是想停止上面的音符，就发送：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0x80&lt;/span&gt;  &lt;span&gt;0x3C&lt;/span&gt;  &lt;span&gt;0x7F&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 Note Off 消息是停止音符的，所以音速值可以随便，这里我还是用 127 吧。&lt;/p&gt;
&lt;p&gt;再比如，向通道14发送一条播放中音 5 的消息。Note On 的标志是 0x9，通道 14 是 1110，即 0xE；中音 5 是 67，即 0x43；音速用最大值，所以，整条消息为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0x9E&lt;/span&gt;  &lt;span&gt;0x43&lt;/span&gt;  &lt;span&gt;0x7F&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;======================================================================&lt;/p&gt;
&lt;p&gt;下面咱们开始编程，先说说连接设备。不管是输入还是输出设备，我们都可以用这种方法连接。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        IMidiOutPort midiOuter = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;async&lt;/span&gt; Task&amp;lt;IMidiOutPort&amp;gt;&lt;span&gt; GetOuterPortAsync()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取设备查询字符串&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; q =&lt;span&gt; MidiOutPort.GetDeviceSelector();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找相关 MIDI 输出设备&lt;/span&gt;
            DeviceInformationCollection devs = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; DeviceInformation.FindAllAsync(q);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果连接多个 MIDI 设备，就要选一个来耍，
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有连外设，那只能有一个，就是声卡兼容的合成器&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; MidiOutPort.FromIdAsync(q);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后初始化一下 out port。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  midiOuter = &lt;span&gt;await&lt;/span&gt; GetOuterPortAsync();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不需要的时候，记得要清理一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
  midiOuter?.Dispose();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里有一个很 TNND 重要的事情，一定要注意，声明变量时，一定要声明为 IMidiOutPort 接口类型，不要声明为 MidiOutPort 类型，这样做到时候很可能你无法与设备通信，发了消息过去没声音。不要问为什么了，记住就行，这是封装 COM 组件的，COM通常都是用接口中来操作的。&lt;/p&gt;

&lt;p&gt;好的，下面正式实现我们今天的示例，为了演示，老周特意写了一首歌，意境优美，相当动听，值得收藏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201712/367389-20171223182755225-1740682976.png&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于这首歌热情扬溢，老周故意把节拍设置为 60，即每分钟 60 拍，正好一秒一拍。&lt;/p&gt;
&lt;p&gt;用来进行音乐合成，最好直接使用 MidiSynthesizer 类。&lt;/p&gt;
&lt;p&gt;第一步。初始化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        MidiSynthesizer mSynthesizer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnNavigatedTo(NavigationEventArgs e)
        {
            mSynthesizer &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; MidiSynthesizer.CreateAsync();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在离开当前页面时，不再需要，释放掉，洗地。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnNavigatingFrom(NavigatingCancelEventArgs e)
        {
            mSynthesizer&lt;/span&gt;?&lt;span&gt;.Dispose();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步，定义几个变量，后面要用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TEMPO = &lt;span&gt;1000&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每秒一拍&lt;/span&gt;
        &lt;span&gt;const&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; CHANNEL = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通道0，本例只用一个通道&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; isPlaying = &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TEMPO 是节拍，咱们的曲子是 J = 60，故一秒一拍，这里表示为 1000 毫秒。CHANNEL表示我们要用到的通道，为了简单演示，我们这个示例只用第一个 MIDI 通道，编号为 0。&lt;/p&gt;
&lt;p&gt;isPlaying 防止重复播放，当正在播放时，它为 true，播放完后变为 false。&lt;/p&gt;

&lt;p&gt;第三步，组合音符，并发送到 MIDI 设备上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isPlaying)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            isPlaying &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 播放音符&lt;/span&gt;
            MidiNoteOnMessage noteOn = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 停止音符&lt;/span&gt;
            MidiNoteOffMessage noteOff = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组合音符列表&lt;/span&gt;
            List&amp;lt;Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt; notes = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音5 = 55，两拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;55&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音6 = 57，两拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;57&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 3 = 64，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 2 = 62，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;62&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 3 = 64，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 6 = 57，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;57&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 3 = 64，半拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;, TEMPO / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 6 = 57，半拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;57&lt;/span&gt;, TEMPO / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 6 = 57，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;57&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 1 = 60，两拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;60&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 5 = 67，两拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;67&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 3 = 64，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 1 = 60，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;60&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 7 = 59，半拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;59&lt;/span&gt;, TEMPO / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 2 = 62，半拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;62&lt;/span&gt;, TEMPO / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 5 = 55，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;55&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 7 = 59，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;59&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 2 = 62，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;62&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 7 = 59，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;59&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 低音 6 = 57，一拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;57&lt;/span&gt;&lt;span&gt;, TEMPO));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中音 1 = 60，两拍&lt;/span&gt;
            notes.Add(&lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;60&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; TEMPO));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始操作&lt;/span&gt;
            &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; tp &lt;span&gt;in&lt;/span&gt;&lt;span&gt; notes)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启音符&lt;/span&gt;
                noteOn = &lt;span&gt;new&lt;/span&gt; MidiNoteOnMessage(CHANNEL, tp.Item1, &lt;span&gt;127&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送&lt;/span&gt;
&lt;span&gt;                mSynthesizer.SendMessage(noteOn);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 延时&lt;/span&gt;
                &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.Delay(tp.Item2);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 停止&lt;/span&gt;
                noteOff = &lt;span&gt;new&lt;/span&gt; MidiNoteOffMessage(CHANNEL, tp.Item1, &lt;span&gt;127&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送&lt;/span&gt;
&lt;span&gt;                mSynthesizer.SendMessage(noteOff);
            }

            isPlaying &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Tuple 是元组，以前老周在其他博文中说过，就是简单地把两个值组合起来，我们这里用了两种值，byte类型的表示音符编号，int类型的表示音符要持续的时间，即时值。&lt;/p&gt;
&lt;p&gt;我先用一个 List 把所有的音符与时值组合起来，然后再通过一个循环来发送到声卡。&lt;/p&gt;
&lt;p&gt;注意，在发送完 Note On后，不能立即发 Note Off，因为那样音符会停止，你就听不到了，所以要用 Delay 方法延时一下，而延时的时间就是音符的时值。如果是一拍，就是 1000 毫秒，如果是两拍就是 2000 毫秒，如果是半拍，就是 500 毫秒……&lt;/p&gt;

&lt;p&gt;第四步，现在虽然代码已经写完了，但你是无法合成 MIDI 音乐的，因为 MIDI API 是微软为我们封装过的，咱们还需要添加一个引用。如下图，请勾选【Microsoft General MIDI DLS for Universal Windows Apps】，注意是勾上前面的对勾，不要只选中，最后点确定即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201712/367389-20171223184414303-865607344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在，运行应用，然后点击【演奏这首歌】按钮，就能听到了。&lt;/p&gt;
&lt;p&gt;你听到的是大钢琴的声音，因为这是默认音色。通用音色库可以使用 128 种乐器音色，这个老周将在下一篇中介绍。&lt;/p&gt;
&lt;p&gt;本篇示例源代码，请&lt;a href=&quot;https://files.cnblogs.com/files/tcjiaan/midiNotesSample.zip&quot; target=&quot;_blank&quot;&gt;猛点击这里下载&lt;/a&gt;。&lt;/p&gt;

</description>
<pubDate>Sat, 23 Dec 2017 10:45:00 +0000</pubDate>
<dc:creator>东邪独孤</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tcjiaan/p/8085408.html</dc:identifier>
</item>
<item>
<title>如何对博客进行备份和还原？（适用于博客园） - 20162330_刘伟康</title>
<link>http://www.cnblogs.com/super925/p/8093453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/super925/p/8093453.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;

&lt;h3 id=&quot;0&quot;&gt;为什么要备份博客？&lt;/h3&gt;
&lt;p&gt;　　首先希望你是一个认真对待博客的人，其次，如果你又是一个爱惜自己物品的人，或者你有强迫症（完美主义倾向），你一定不希望哪天登录博客园翻看自己的某篇博客时突然发现这种情况——自己之前写的博客怎么缺失了一半！！！另外一半呢？？？ @_@&lt;br/&gt;于是找到&lt;a href=&quot;http://www.cnblogs.com/cmt/&quot;&gt;博客园团队&lt;/a&gt;，发了一封求救信，可结果却是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223163638834-830175376.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后呢？小编想说然后就没有然后了（没有备份自己只能默默重写了 Orz）。虽然发生这种情况的几率很小，但也要防患于未然，于是我们就可以选择一种保险的做法——备份（博客）。因此，从专业一点的角度上讲，&lt;strong&gt;备份工具&lt;/strong&gt; 可以保护数据免受意外的损失，而 &lt;strong&gt;备份博客&lt;/strong&gt; 就是为了应付博客中数据丢失等可能出现的意外情况。至于为什么会发生数据丢失，小编觉得仅就博客园丢失博客的数据而言，可能是当时的网络环境比较差，并且你在博客园加载某篇博客的 TextView 时（还未加载完毕）就点了保存，服务器正在缓存，还没有将你之前博客的数据加载完全，这就导致了一部分数据的丢失。&lt;br/&gt;　　在你下次翻看自己之前的博客时，就会不经意地发现：&lt;strong&gt;自己有一篇博客的 XXX内容 竟然奇迹般地消失了！？&lt;/strong&gt;点了一下刷新，没用，再点刷新，还是没用，慌乱的你想进去看个究竟于是直接点击了编辑，结果这部分内容真的就这样消失了！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（丢失博客的截图.pnp）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　小编已有1年多的园龄了，在这段时光里，小编不幸地遇到了两次博客数据丢失的“灾难”，第一次遇到的时候不知所措，完全傻了眼，现在多了些经验教训，遂借此篇博客进行总结和分享，并提醒更多博主定期做好“保养”博客的工作。如果有备份，就能“以防万一”了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223165032178-1456968867.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/super925/p/8093453.html#jump&quot;&gt;&lt;span&gt;【返回目录】&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;1&quot;&gt;如何在博客园备份博客？&lt;/h3&gt;
&lt;p&gt;　　我们一般使用一些大容量存储设备定期备份系统、使用U盘等中小容量存储设备来备份一些重要数据和文件，备份博客也是如此，我们可以使用博客园自带的备份功能将自己的所有博客（包括草稿）保存为一个xml文件下载下来，然后把它保存好即可（占用空间很小）。具体步骤如下：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;首先，进入个人界面，点击你最常用的“写博”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223171705006-1945499642.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其次，在写博界面中有两种备份方式，你可以点击左侧操作栏中的“博客备份”，也可以点击右上角的“备份”：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223172535115-193099359.png&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223172535115-193099359.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;进入备份界面之后，根据所选择的时间进行备份，如果不进行修改，那么开始日期就默认为你发表（或保存）第一篇博客的时间，结束日期也默认为你最近发表（或保存）的一篇博客的时间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223173038615-1031853352.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后点击下载即可进行博客备份。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;【注意】&lt;strong&gt;备份是有时间规定的，一般在工作日的8:00之前或者18:00之后，或者周六周日才不会被限制下载，建议学生党一周定期备份一次，其他博主亦可根据自己的写博频率调整。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/super925/p/8093453.html#jump&quot;&gt;&lt;span&gt;【返回目录】&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2&quot;&gt;如何还原备份的博客？&lt;/h3&gt;
&lt;p&gt;　　在备份了自己珍贵的博客之后，要怎么在博客内容丢失后迅速还原呢？办法很简单，之前我们保存的是一个xml文件，首先我们不用去下载一些xml文件的查看工具，除非有其他需要，我们只需要使用记事本打开即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223174306615-1223599813.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223174317287-361516144.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由于是xml文件，所以打开后会有一些类似html的标记语言，不用管它们，直接去寻找我们需要的。之后我们便可以看到，第一篇博客（最近发表的博客或保存的草稿）的标题和正文，正文中的markdown格式内容完好无损：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223175519834-370338677.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　找到第一篇博客的末尾之后，紧接着就是下一篇博客的标题，以此类推：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1062725/201712/1062725-20171223183242115-2043104607.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们将需要的markdown格式正文复制下来，粘贴到对应的缺失数据的博客中去重新保存即可，这样一来，我们就放心了，是不是也同时满足了强迫症的需求呢？博主们现在就可以去备份博客了（今天周六）！这次就写到这里吧，小编学识浅薄，见闻不广，如果博主们在阅读时发现了一些错误、遗漏点或者对此篇博客有其他建议，欢迎在评论区指出。(　＾∀＾)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/super925/p/8093453.html#jump&quot;&gt;&lt;span&gt;【返回目录】&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;3&quot;&gt;参考资料&lt;/h3&gt;

&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;【附】原创作品，如需转载，请注明出处，谢谢。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
</description>
<pubDate>Sat, 23 Dec 2017 10:19:00 +0000</pubDate>
<dc:creator>20162330_刘伟康</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/super925/p/8093453.html</dc:identifier>
</item>
<item>
<title>ActiveMQ基本详解与总结 - 回首笑人间</title>
<link>http://www.cnblogs.com/Survivalist/p/8094069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Survivalist/p/8094069.html</guid>
<description>&lt;p&gt;&lt;strong&gt;MQ简介&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过写和检索出入列队的针对应用程序的数据（消息）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。其中较为成熟的MQ产品有IBMWEBSPHERE MQ。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MQ特点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　MQ的消费-生产者模型的一个典型的代表，一端往消息队列中不断的写入消息，而另一端则可以读取或者订阅队列中的消息。MQ和JMS类似，但不同的是JMS是SUN JAVA消息中间件服务的一个标准和API定义，而MQ则是遵循了AMQP协议的具体实现和产品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JMS简介&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　JMS即Java消息服务（Java Message Service）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　JMS（Java Messaging Service）是Java平台上有关面向消息中间件(MOM)的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发，翻译为Java消息服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　JMS是一种与厂商无关的 API，用来访问消息收发系统消息。它类似于JDBC(Java DatabaseConnectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商目前都支持JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ，这只是几个例子。 JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个JMS客户机发送消息。消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。根据有效负载的类型来划分，可以将消息分为几种类型，它们分别携带：简单文本(TextMessage)、可序列化的对象 (ObjectMessage)、属性集合 (MapMessage)、字节流 (BytesMessage)、原始值流 (StreamMessage)，还有无有效负载的消息 (Message)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JMS和MQ的关系&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　JMS是一个用于提供消息服务的技术规范，它制定了在整个消息服务提供过程中的所有数据结构和交互流程。而MQ则是消息队列服务，是面向消息中间件（MOM）的最终实现，是真正的服务提供者；MQ的实现可以基于JMS，也可以基于其他规范或标准。&lt;/p&gt;
&lt;p&gt;支持JMS的开源MQ：&lt;/p&gt;
&lt;p&gt;目前选择的最多的是ActiveMQ。&lt;/p&gt;
&lt;p&gt;ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现,尽管JMS规范出台已经是很久的事情了,但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要特点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1. 多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python, PHP。应用协议: OpenWire,Stomp REST,WSNotification,XMPP,AMQP&lt;/p&gt;
&lt;p&gt;2. 完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务)&lt;/p&gt;
&lt;p&gt;3. 对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性&lt;/p&gt;
&lt;p&gt;4. 通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 resource adaptors的配置,可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上&lt;/p&gt;
&lt;p&gt;5. 支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA&lt;/p&gt;
&lt;p&gt;6. 支持通过JDBC和journal提供高速的消息持久化&lt;/p&gt;
&lt;p&gt;7. 从设计上保证了高性能的集群,客户端-服务器,点对点&lt;/p&gt;
&lt;p&gt;8. 支持Ajax&lt;/p&gt;
&lt;p&gt;9. 支持与Axis的整合&lt;/p&gt;
&lt;p&gt;10. 可以很容易得调用内嵌JMS provider,进行测试&lt;/p&gt;
&lt;p&gt;11. ActiveMQ速度非常快；一般要比jbossMQ快10倍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　是一个快速的开源消息组件(框架)，支持集群，同等网络，自动检测，TCP，SSL，广播，持久化，XA，和J2EE1.4容器无缝结合，并且支持轻量级容器和大多数跨语言客户端上的Java虚拟机。消息异步接受，减少软件多系统集成的耦合度。消息可靠接收，确保消息在中间件可靠保存，多个消息也可以组成原子事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　ActiveMQ默认的配置性能偏低，需要优化配置，但是配置文件复杂，ActiveMQ本身不提供管理工具；示例代码少；主页上的文档看上去比较全面，但是缺乏一种有效的组织方式，文档只有片段，用户很难由浅入深进行了解，二、文档整体的专业性太强。在研究阶段可以通过查maillist、看Javadoc、分析源代码来了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ActiveMQ应用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、 不同语言应用集成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ActiveMQ 中间件用Java语言编写，因此自然提供Java客户端 API。但是ActiveMQ 也为C/C++、.NET、Perl、PHP、Python、Ruby 和一些其它语言提供客户端。在你考虑如何集成不同平台不同语言编写应用的时候，ActiveMQ 拥有巨大优势。在这样的例子中，多种客户端API通过ActiveMQ 发送和接受消息成为可能，无论使用的是什么语言。此外，ActiveMQ 还提供交叉语言功能，该功能整合这种功能，无需使用远程过程调用（RPC）确实是个优势，因为消息协助应用解耦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、 作为RPC的替代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用RPC同步调用的应用十分普遍。假设大多数客户端服务器应用使用RPC，包括ATM、大多数WEB应用、信用卡系统、销售点系统等等。尽管很多系统很成功，但是转换使用异步消息可以带来很多好处，而且也不会放弃响应保证。使用同步请求的系统在规模上有较大的限制，因为请求会被阻塞，从而导致整个系统变慢。如果使用异步消息替代，可以很容易增加额外的消息接收者，使得消息能被并发消耗，从而加快请求处理。当然，你的系统应用间应该是解耦的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、 应用之间解耦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正如之前讨论的，紧耦合架构可以导致很多问题，尤其是如果他们是分布的。松耦合架构，在另一方面，证实了更少的依赖性，能够更好地处理不可预见的改变。不仅可以在系统中改变组件而不影响整个系统，而且组件交互也相当的简单。相比使用同步的系统（调用者必须等待被调用者返回信息），异步系统（调用方发送消息后就不管，即fire-and-forget）能够给我们带来事件驱动架构（event-driven architecture EDA）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、 作为事件驱动架构的主干&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解耦，异步架构的系统允许通过代理器自己配置更多的客户端，内存等（即vertical scalability）来扩大系统，而不是增加更多的代理器（即horizontal scalability）。考虑如亚马逊这样繁忙的电子商务系统。当用户购买物品，事实上系统需要很多步骤去处理，包括下单，创建发票，付款，执行订单，运输等。但是用户下单后，会立即返回“谢谢你下单”的界面。不只是没有延迟，而且用户还会受到一封邮件表明订单已经收到。在亚马逊下单的例子就是一个多步处理的例子。每一步都由单独的服务去处理。当用户下单是，有一个同步的体积表单动作，但整个处理流程并不通过浏览器同步处理。相反地，订单马上被接受和反馈。而剩下的步骤就通过异步处理。如果在处理过程中出错，用户会通过邮件收到通知。这样的异步处理能提供高负载和高可用性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、 提高系统扩展性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多使用事件驱动设计的系统是为了获得高可扩展性，例如电子商务，政府，制造业，线上游戏等。通过异步消息分开商业处理步骤给各个应用，能够带来很多可能性。考虑设计一个应用来完成一项特殊的任务。这就是面向服务的架构（service-oriented architecture SOA）。每一个服务完成一个功能并且只有一个功能。应用就通过服务组合起来，服务间使用异步消息和最终一致性。这样的设计便可以引入一个复杂事件处理概念（complex event processing CEP）。使用CEP，部件间的交互可以被记录追踪。在异步消息系统中，可以很容易在部件间增加一层处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;个人理解总结&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;activeMQ是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　是Apache公司旗下的一个消息总线&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;activeMQ能干什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用来在服务与服务之间进行异步通信的&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;activeMQ优势&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.流量肖锋&lt;/p&gt;
&lt;p&gt;2.任务异步处理&lt;/p&gt;
&lt;p&gt;特点：可以解耦合&lt;/p&gt;
&lt;p&gt;　　(学习新技术的三要素：是什么？能干什么？有什么优势？)&lt;/p&gt;

&lt;p&gt;　图1：&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1290673/201712/1290673-20171223181126443-1440145013.png&quot; alt=&quot;&quot; width=&quot;1128&quot; height=&quot;748&quot;/&gt;&lt;div&gt;&lt;img src=&quot;file:///C:/Users/hp/AppData/Local/YNote/data/lv753951lv@163.com/171e17c175a245ad8f96f2ad5a6523fc/day08_mq原理理解.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;CC8A358A7E4B4090A4DA57D43C240913&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;file:///C:/Users/hp/AppData/Local/YNote/data/lv753951lv@163.com/171e17c175a245ad8f96f2ad5a6523fc/day08_mq原理理解.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;CC8A358A7E4B4090A4DA57D43C240913&quot;/&gt;&lt;/div&gt;
&lt;div&gt; 
&lt;div&gt;&lt;img src=&quot;file:///C:/Users/hp/AppData/Local/YNote/data/lv753951lv@163.com/171e17c175a245ad8f96f2ad5a6523fc/day08_mq原理理解.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;CC8A358A7E4B4090A4DA57D43C240913&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通信模式：&lt;/p&gt;
&lt;p&gt;1.点对点(queue)&lt;/p&gt;
&lt;p&gt;》一个消息只能被一个服务接收&lt;/p&gt;
&lt;p&gt;》消息一旦被消费，就会消失&lt;/p&gt;
&lt;p&gt;》如果没有被消费，就会一直等待，直到被消费&lt;/p&gt;
&lt;p&gt;》多个服务监听同一个消费空间，先到先得&lt;/p&gt;
&lt;p&gt;详解：这个特点的原理是这样的，在activeMQ&lt;/p&gt;
&lt;p&gt;2.发布/订阅模式(topic)&lt;/p&gt;
&lt;p&gt; 　　》一个消息可以被多个服务接收&lt;/p&gt;
&lt;p&gt;　　》订阅一个主题的消费者，只能消费自它订阅之后发布的消息。&lt;/p&gt;
&lt;p&gt;　　》消费端如果在生产端发送消息之后启动，是接收不到消息的，除非生产端对消息进行了持久化(例如广播，只有当时听到的人能听到信息)&lt;/p&gt;

&lt;p&gt;　　图2：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1290673/201712/1290673-20171223181458412-189645569.png&quot; alt=&quot;&quot; width=&quot;926&quot; height=&quot;441&quot;/&gt;　　&lt;/div&gt;

&lt;p&gt;注：消息是被推送和拉取的(消息生产端和消费端)，不是mq服务器去主动发送的&lt;/p&gt;
&lt;p&gt;总：一些简单常用的应用场景&lt;/p&gt;
&lt;p&gt;1.发送邮件&lt;/p&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;p&gt;　　最经典的就是当用户注册时，我们就需要用activeMQ来做为中间件，当用户注册后，我门把用户的邮箱号和验证码等信息通过activeMQ的生产端发送到activeMQ的消息队列中，而一旦消息队列中出现了数据，我们的邮件模块通过实时的监控activeMQ的消息队列就能通过消费端获取到这个数据，染回邮件模块就会自行的去对数据进行解析，给用户发送邮件&lt;/p&gt;
&lt;p&gt;2.发送短信&lt;/p&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;p&gt;　　原理同发送邮件相同&lt;/p&gt;
&lt;p&gt;3.同步索引库&lt;/p&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;p&gt;　　为了缓解数据库的压力，我们把经常被调用的数据放入索引库中，当有请求查询时，我们会先去查询索引库，如果索引库内有数据，那么我们就不用就数据库进行查询，这样就能大大的减轻服务器的压力，可是随之而来的一个问题是，假如我们服务器内的数据已经发生了改变，而浏览用户查询数据时，因为索引库中已经有数据了，那么这样一来数据库与索引库的数据就不一致了，那么怎么解决这个问题呢？我们想到了通过用activeMQ来监听数据库的操作来实现数据库与索引库的数据同步，当后台管理员或房产经纪人对数据库的数据进行了增删改的操作时，我们通过activeMQ监听到了数据的改变，获取到被修改的数据的id，然后在另一个服务模块中通过这个数据的id去数据库先查询一把，然后根据查询结果进行判断，再去做索引库的数据同步。打个比方，如果查询结果返回的是空，就说明商品已经被删除，那么我们就可以根据数据的id去把索引库中的数据也一并删除了。&lt;/p&gt;
&lt;p&gt;4.同步静态页面&lt;/p&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;p&gt;　　此原理同上一个同步索引库是一个原理，目的都是为了减缓服务器的压力，我们经过数据分析发现，其实我们的一些商品详情页面的数据其实都是大同小异的，完全可以通过freemarker页面静态化的模块加上后台查询出的数据拼装成一个静态页面，而这些数据从哪来呢？我们经过讨论和研究，最后一致认为还是放在缓冲中比较好，这样一来就能大大的减轻了数据 库的压力，而另一个好处是，由于页面是纯静态页面，所以页面上的数据都是死数据，这样一来就不用像JSP动态页面那样需要和后台数据库有大量的数据交互，可以最大化的降低服务器的压力，其实这个技术已经有很多大型公司在使用了，比如淘宝，京东，网易等，我们要是细心一些就会发现，他们的页面其实就都是HTML格式的静态页面。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　声明：本文为原创文章，其他人转载需要对文章进行特殊备注和声明原文地址。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;file:///C:/Users/hp/AppData/Local/YNote/data/lv753951lv@163.com/456878ce048f414e9f21d4f62a308ce3/02_发布订阅模式.png&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;7E6322178959413488A6A2BCFCE93236&quot;/&gt;&lt;/div&gt;


</description>
<pubDate>Sat, 23 Dec 2017 10:18:00 +0000</pubDate>
<dc:creator>回首笑人间</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Survivalist/p/8094069.html</dc:identifier>
</item>
<item>
<title>vue项目的骨架及常用组件介绍 - baby格鲁特</title>
<link>http://www.cnblogs.com/ChengWuyi/p/8093486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ChengWuyi/p/8093486.html</guid>
<description>&lt;h2&gt;vue项目基础结构&lt;/h2&gt;
&lt;p&gt;一个vue的项目，我觉得最小的子集其实就是{vue,vue-router,component}，vue作为基础库，为我们提供双向绑定等功能。vue-router连接不同的&quot;页面&quot;，component作为样式或者行为输出，你可以通过这三个东西来实现最基本的静态SPA网站。当然我在这里不谈vue全家桶这样宽泛的概念，我会如数家珍的把主要的技术点一一列举。&lt;/p&gt;
&lt;p&gt;1.vue-cli：搭建基本的vue项目骨架，脚手架工具&lt;/p&gt;
&lt;p&gt;2.sass-loader&amp;amp;node-sass:我是使用的sass作为样式的预编译工具，两者缺一不可，大家也可以自行选择，less,stylus都可以&lt;/p&gt;
&lt;p&gt;3.postcss:实现响应式布局的关键，px=&amp;gt;rem。大漠已经提出了基于vw,vh的布局方案，不过我暂时持观望态度。&lt;/p&gt;
&lt;p&gt;4.vuex:管理复杂的数据流向，状态机工具，特化的Flux&lt;/p&gt;
&lt;p&gt;5.vuex-persistedstate:将vuex中state持久化的工具&lt;/p&gt;
&lt;p&gt;6.vue-router:实现SPA间“页面”之间的跳转&lt;/p&gt;
&lt;p&gt;7.vue-lazyload:实现图片的懒加载，优化http传输性能&lt;/p&gt;
&lt;p&gt;8.vue-awesome-swiper:轮播功能的实现及一些特殊切换效果的完成&lt;/p&gt;
&lt;p&gt;9.better-scroll:实现列表滚动及父子组件间的滚动问题&lt;/p&gt;
&lt;p&gt;10.axios:http工具，实现向API请求数据，以及拦截器的实现&lt;/p&gt;
&lt;p&gt;11.fastclick:解决300ms延迟的库&lt;/p&gt;
&lt;p&gt;以上这些，都是我觉得一个中大型的vue项目需要用到的，还有一些比如我在实现图片上传中用到了jsx的语法，需要babel-jsx这样的东西，不具有普适性，就不例举了。&lt;/p&gt;

&lt;p&gt; 下面简述一下上面说到的这些东西，有的东西会单独的来出来细说：&lt;/p&gt;
&lt;h2&gt;1.vue-cli：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs/vue-cli&quot; target=&quot;_blank&quot;&gt;https://github.com/vuejs/vue-cli&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;脚手架工具，当我们选择vue作为我们的开发技术栈以后，就要开始为我们的项目搭建目录及开发的环境。安装好node以后，通过以后命令进行安装&lt;/p&gt;
&lt;p&gt;npm install -g vue-cli 将vue-cli安装到全局环境&lt;/p&gt;
&lt;p&gt;vue init webpack my-vue-demo 创建基于webpack模板的名为my-vue-demo文件名的vue项目&lt;/p&gt;
&lt;p&gt;这里的模板有6中，不过我们比较常用的就是webpack了。&lt;/p&gt;
&lt;p&gt;期间你会看到有一些例如e2e这样的单元测试的工具和ESLint检测代码质量的工具，我觉得都是可以不必安装的。&lt;/p&gt;
&lt;p&gt;那么，其实我们最关心的就是在src文件夹下面的内容了。可以看下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/642545/201712/642545-20171223151348943-2006320399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图就是一个在刨除vue-cli的基本结构，在项目上比较成熟的vue骨架了。&lt;/p&gt;
&lt;h2&gt;2&amp;amp;3 :sass,postcss&lt;/h2&gt;
&lt;p&gt;直接写css得洪荒时代已经过去了，预编译的样式处理器帮助我们解放了生产力，提高了效率。sass,less,stylus各有优缺，也各有信徒。&lt;/p&gt;
&lt;p&gt;要使用sass的话，你需要安装一下sass-loader和node-sass，不过node-sass不是很好装，被墙的厉害，建议还是用taobao的镜像。如果安装完成后还是报错无法解析的话，你可能就需要去webpack.base.conf.js里去看看是否设置好了对应的loader。&lt;/p&gt;
&lt;p&gt;postcss的常用功能&lt;/p&gt;
&lt;p&gt;px2rem =&amp;gt; 可以帮助我们实现px到rem单位的转换，只需要你定义好相应的转换标准就可以了。&lt;/p&gt;
&lt;p&gt;autoprefixer =&amp;gt; 兼容性的处理postcss也可以帮我们处理好。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_5f90c8fa-9e40-4299-9003-5552bafc0a69&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5f90c8fa-9e40-4299-9003-5552bafc0a69&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5f90c8fa-9e40-4299-9003-5552bafc0a69&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;vue-loader.conf.js&lt;/span&gt;
module.exports =&lt;span&gt; {
  loaders: utils.cssLoaders({
    sourceMap: isProduction
      &lt;/span&gt;?&lt;span&gt; config.build.productionSourceMap
      : config.dev.cssSourceMap,
    extract: isProduction
  }),
  postcss: [
    require(&lt;/span&gt;'autoprefixer'&lt;span&gt;)({
      browsers: [&lt;/span&gt;'iOS &amp;gt;= 7', 'Android &amp;gt;= 4.1'&lt;span&gt;]
    }),
    require(&lt;/span&gt;'postcss-px2rem'&lt;span&gt;)
    ({ remUnit: &lt;/span&gt;64&lt;span&gt; })
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;4,5:vuex,vuex-persistedstate&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/robinvdvleuten/vuex-persistedstate&quot; target=&quot;_blank&quot;&gt;https://github.com/robinvdvleuten/vuex-persistedstate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个中大型的vue项目，肯定有复杂的状态需要去管理。简单的event bus已经不再适用了。&lt;/p&gt;
&lt;p&gt;特化的Flux架构，vuex就迎头顶上。简而言之：他就是我们处理无论是用户操作，API返回，URL变更等多重操作的状态管理工具。以后我会具体的说下vuex。&lt;/p&gt;
&lt;p&gt;用过vuex的人，会发现一个很痛苦的地方，就是vuex里面的state，只要我们去刷新，它就被释放掉了。有的状态还好，没有了大不了我们可以让用户去重新操作一遍。但是像登录这样的操作，你不可能让用户刷一下就去登一下吧。当然，你会说，我们可以存到local啊，cookie里面啊。是可以！但是这样的话,state就和local里的数据形成了一种松散的关联，state显得十分的脆弱，因为你无法预知你什么时候会少写一个setStore这样的方法。vuex-persistedstate帮我们解决了这样的问题，它帮我们直接把state映射到了本地的缓存环境，我们可以在computed里面用vuex提供的mapState辅助函数，来动态的更新local里面的数据。而不需要持久化的state，我们依旧可以刷新来释放掉。&lt;/p&gt;
&lt;h2&gt;6.vue-router&lt;/h2&gt;
&lt;p&gt;当我们使用vue来构建SPA的应用时，就等于说我们完全的分离了前后端。或者通俗点的说：这就是一个纯前端的项目。后端仅仅提供数据，任何的逻辑都在前端实现。既然&quot;脱离&quot;了后端，那么肯定就没有request Mapping这样的同步映射url了。那么，前端就需要router来实现我们前端&quot;页面&quot;的跳转。vue-router就帮我们做了这样的事情，他提供给了路由守卫给我们，我们可以设置全局的，组件内的路由守卫，来实现特定的业务逻辑。 提供过渡动画，来更加生动的展示SPA应用应有的风采等等，这个以后也要具体的来说。&lt;/p&gt;
&lt;h2&gt;7.vue-lazyload&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hilongjw/vue-lazyload&quot; target=&quot;_blank&quot;&gt;https://github.com/hilongjw/vue-lazyload&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实现图片的懒加载。这是前端性能优化的一个必须面对的问题：图片。懒加载可以减少请求的数量，而且在很直观的视觉上，也有一个良好的过渡。当然，图片我们也是需要去做一些处理的，使用webp格式来减小图片的质量，或者通过oss来对图片作处理。&lt;/p&gt;
&lt;h2&gt;8.vue-awesome-swiper&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/surmon-china/vue-awesome-swiper&quot; target=&quot;_blank&quot;&gt;https://github.com/surmon-china/vue-awesome-swiper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过它可以实现基本轮播，横轴的切换，横轴的列表滚动等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/642545/201712/642545-20171223165139818-1148541998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如我要去实现四个tab切换这样的功能，但是简单的display这样的效果我又觉得不是很满意。那么我们就可以通过swiper来实现，每次tab里面的content都会对应swiper的一个swiper-item。切换的tab，其实就是swiper里面的next page或者before page.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;data(){
　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
　　　　swiperOption: {
            slidesPerView :&lt;/span&gt;'auto'&lt;span&gt;,
            direction: &lt;/span&gt;'horizontal'&lt;span&gt;,
            freeMode : &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            loop: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
            spaceBetween: &lt;/span&gt;20&lt;span&gt;,
 　　　},
    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;swiper :options=&quot;swiperOption&quot; ref=&quot;swiper&quot; v-&lt;span&gt;if&lt;/span&gt;=&quot;list&amp;amp;&amp;amp; list.length !== 0&quot;&amp;gt;
            &amp;lt;swiper-slide v-&lt;span&gt;for&lt;/span&gt;=&quot;(item,index) in list&quot; :key=&quot;index&quot; class=&quot;hot-item&quot;&amp;gt;
              &amp;lt;router-link :to=&quot;{name:'quickCar',params:{carID:item.CarID}}&quot; class=&quot;description_car&quot;&amp;gt;
                &amp;lt;img v-lazy=&quot;item.Attachments.length !==0 &amp;amp;&amp;amp; item.Attachments[0].FilePath&quot;/&amp;gt;
                  &amp;lt;span&amp;gt;&amp;amp;yen;{{item.price}}/日&amp;lt;/span&amp;gt;
              &amp;lt;/router-link&amp;gt;
            &amp;lt;/swiper-slide&amp;gt;
  &amp;lt;/swiper&amp;gt;
 &amp;lt;p class=&quot;noData&quot; v-&lt;span&gt;else&lt;/span&gt;&amp;gt;&amp;lt;/p&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;9.better-scroll&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ustbhuangyi/better-scroll&quot; target=&quot;_blank&quot;&gt;https://github.com/ustbhuangyi/better-scroll&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实现纵轴列表的滚动，以及当有嵌套的路由的时候，通过better-scroll来实现的禁止父路由随着子路由的滚动的问题。&lt;/p&gt;
&lt;p&gt;better-scroll其实也可以去实现横轴的滚动，但是为什么不使用better-scroll来处理呢？这是因为在better-scroll实现横轴滚动的时候，我们无法在better-scorll的content的内容区域里去下向拉动我们的页面。所以导致的一个Bug就是，在better-scroll横轴滚动的区域里，页面动不了了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/642545/201712/642545-20171223165835834-909470123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图：横轴滚动下面还有内容，但是在图片所示的区域里面，无法向下拉动。所以横轴的滚动其实也是通过vue-awesome-swiper来实现的。&lt;/p&gt;
&lt;h2&gt;10.axios&lt;/h2&gt;
&lt;p&gt;基本功能就是通过axios来请求后台接口的数据。并且axios可以配合router更好的实现类似后台的拦截器的功能，例如处理token过期这样问题。因为当token过期的时候，仅仅通过vue-router的router.beforeEach来处理就有点无能为力了。这时候就需要配合后台响应返回的code来进行url的处理。&lt;/p&gt;
&lt;h2&gt;11.fastclick&lt;/h2&gt;
&lt;p&gt; 解决点透和点击延时的问题&lt;/p&gt;
&lt;p&gt;具体可以看钗神的源码分析 &lt;a href=&quot;https://www.cnblogs.com/yexiaochai/p/3442220.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/yexiaochai/p/3442220.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 23 Dec 2017 09:31:00 +0000</pubDate>
<dc:creator>baby格鲁特</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ChengWuyi/p/8093486.html</dc:identifier>
</item>
</channel>
</rss>